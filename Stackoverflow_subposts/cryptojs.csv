post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"14958103","How to decrypt message with CryptoJS AES. I have a working Ruby example","<p>I'm able to decrypt AES encrypted message with Ruby like this:</p>

<pre><code>require 'openssl'
require 'base64'

data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg=""
key = ""2e35f242a46d67eeb74aabc37d5e5d05""

aes = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
aes.decrypt
aes.key = key.scan(/../).collect{ |x| x.hex }.pack('c*')
aes.iv = Base64.decode64(data)[0...16]
puts aes.update(Base64.decode64(data)[16..-1]) + aes.final
# =&gt; JSON data...
</code></pre>

<p>Being new to CryptoJS I fail to put together working alternative. Here's what i've done so far:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

CryptoJS.AES.decrypt(atob(data).substring(16), key, {
    iv: atob(cipher).substring(0, 16),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Does CryptoJS expect data, key and initialization vector in some different way? As far as i understand, the IV are the first 16 bytes in data.</p>
","<p>This seems to work for me (writes decoded string to the console):</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

// Decode the base64 data so we can separate iv and crypt text.
var rawData = atob(data);
var iv = btoa(rawData.substring(0,16));
var crypttext = btoa(rawData.substring(16));

// Decrypt...
var plaintextArray = CryptoJS.AES.decrypt(
  {
    ciphertext: CryptoJS.enc.Base64.parse(crypttext),
    salt: """"
  },
  CryptoJS.enc.Hex.parse(key),
  { iv: CryptoJS.enc.Base64.parse(iv) }
);

// Convert hex string to ASCII.
// See https://stackoverflow.com/questions/11889329/word-array-to-string
function hex2a(hex) {
    var str = '';
    for (var i = 0; i &lt; hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

console.log(hex2a(plaintextArray.toString()));
</code></pre>

<p>The important bits are to specify no salt in your input and pass the key as a WordArray as jlvaquero says.  There are probably some efficiency improvements to be made, e.g. I'm guessing there's an easier way to convert a string to a WordArray than going to base64 and back, but at least it successfully decodes.  I lifted the hex2a function from StackOverflow question <a href=""https://stackoverflow.com/questions/11889329/word-array-to-string"">Word Array to  String</a>.</p>

<p>Edit: I figured out how to convert strings to WordArrays and vice-versa with CryptoJS so the   extra base64 encode/decode and hex-to-ASCII function are not needed.  Also it turns out the salt property need not be specified.  This is more compact and efficient:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

// Decode the base64 data so we can separate iv and crypt text.
var rawData = atob(data);
var iv = rawData.substring(0,16);
var crypttext = rawData.substring(16);

// Decrypt...
var plaintextArray = CryptoJS.AES.decrypt(
  { ciphertext: CryptoJS.enc.Latin1.parse(crypttext) },
  CryptoJS.enc.Hex.parse(key),
  { iv: CryptoJS.enc.Latin1.parse(iv) }
);

console.log(CryptoJS.enc.Latin1.stringify(plaintextArray));
</code></pre>
","65485","<javascript><ruby><aes><cryptojs>","20","27","5","2019-07-03 04:08:37","15125030","2","14","112731","","2013-02-25 01:15:44","2013-02-19 12:58:03",""
"14958103","How to decrypt message with CryptoJS AES. I have a working Ruby example","<p>I'm able to decrypt AES encrypted message with Ruby like this:</p>

<pre><code>require 'openssl'
require 'base64'

data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg=""
key = ""2e35f242a46d67eeb74aabc37d5e5d05""

aes = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
aes.decrypt
aes.key = key.scan(/../).collect{ |x| x.hex }.pack('c*')
aes.iv = Base64.decode64(data)[0...16]
puts aes.update(Base64.decode64(data)[16..-1]) + aes.final
# =&gt; JSON data...
</code></pre>

<p>Being new to CryptoJS I fail to put together working alternative. Here's what i've done so far:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

CryptoJS.AES.decrypt(atob(data).substring(16), key, {
    iv: atob(cipher).substring(0, 16),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Does CryptoJS expect data, key and initialization vector in some different way? As far as i understand, the IV are the first 16 bytes in data.</p>
","<p>This works for decryption using javascript.</p>

<pre><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/aes.js""&gt;&lt;/script&gt;
var key = ""2e35f242a46d67eeb74aabc37d5e5d05"";
var data = CryptoJS.AES.encrypt(""Message"", key); // Encryption Part
var decrypted = CryptoJS.AES.decrypt(data, key).toString(CryptoJS.enc.Utf8); // Message
</code></pre>

<p>Guess I am a little late to the party.</p>
","65485","<javascript><ruby><aes><cryptojs>","20","46","5","2019-07-03 04:08:37","15125030","2","14","112731","","2013-02-25 01:15:44","2013-02-19 12:58:03",""
"14958103","How to decrypt message with CryptoJS AES. I have a working Ruby example","<p>I'm able to decrypt AES encrypted message with Ruby like this:</p>

<pre><code>require 'openssl'
require 'base64'

data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg=""
key = ""2e35f242a46d67eeb74aabc37d5e5d05""

aes = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
aes.decrypt
aes.key = key.scan(/../).collect{ |x| x.hex }.pack('c*')
aes.iv = Base64.decode64(data)[0...16]
puts aes.update(Base64.decode64(data)[16..-1]) + aes.final
# =&gt; JSON data...
</code></pre>

<p>Being new to CryptoJS I fail to put together working alternative. Here's what i've done so far:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

CryptoJS.AES.decrypt(atob(data).substring(16), key, {
    iv: atob(cipher).substring(0, 16),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Does CryptoJS expect data, key and initialization vector in some different way? As far as i understand, the IV are the first 16 bytes in data.</p>
","<p>for the hex2a provided by another user, it may not working if ascii code is over 128 (i.e text contains chinese , etc)</p>

<p>you can use the follow to return proper unicode </p>

<pre><code>function hex2a(hex) {
    var str = '';
    for (var i = 0; i &lt; hex.length; i += 2){

        var dec = parseInt(hex.substr(i, 2), 16);
        character = String.fromCharCode(dec);


        if (dec &gt; 127)
            character = ""%""+hex.substr(i,2);

        str += character;

    }

    return decodeURI(str);
}
</code></pre>
","65485","<javascript><ruby><aes><cryptojs>","20","-1","5","2019-07-03 04:08:37","15125030","2","14","112731","","2013-02-25 01:15:44","2013-02-19 12:58:03",""
"14958103","How to decrypt message with CryptoJS AES. I have a working Ruby example","<p>I'm able to decrypt AES encrypted message with Ruby like this:</p>

<pre><code>require 'openssl'
require 'base64'

data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg=""
key = ""2e35f242a46d67eeb74aabc37d5e5d05""

aes = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
aes.decrypt
aes.key = key.scan(/../).collect{ |x| x.hex }.pack('c*')
aes.iv = Base64.decode64(data)[0...16]
puts aes.update(Base64.decode64(data)[16..-1]) + aes.final
# =&gt; JSON data...
</code></pre>

<p>Being new to CryptoJS I fail to put together working alternative. Here's what i've done so far:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

CryptoJS.AES.decrypt(atob(data).substring(16), key, {
    iv: atob(cipher).substring(0, 16),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Does CryptoJS expect data, key and initialization vector in some different way? As far as i understand, the IV are the first 16 bytes in data.</p>
","<pre><code>    var key = CryptoJS.enc.Utf8.parse('8080808080808080');
    var iv = CryptoJS.enc.Utf8.parse('8080808080808080');
    var _enid = CryptoJS.AES.decrypt(data, key,
  {
      keySize: 128 / 8,
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
  }).toString(CryptoJS.enc.Utf8);
    return _enid;
</code></pre>
","65485","<javascript><ruby><aes><cryptojs>","20","0","5","2019-07-03 04:08:37","15125030","2","14","112731","","2013-02-25 01:15:44","2013-02-19 12:58:03",""
"14958103","How to decrypt message with CryptoJS AES. I have a working Ruby example","<p>I'm able to decrypt AES encrypted message with Ruby like this:</p>

<pre><code>require 'openssl'
require 'base64'

data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg=""
key = ""2e35f242a46d67eeb74aabc37d5e5d05""

aes = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
aes.decrypt
aes.key = key.scan(/../).collect{ |x| x.hex }.pack('c*')
aes.iv = Base64.decode64(data)[0...16]
puts aes.update(Base64.decode64(data)[16..-1]) + aes.final
# =&gt; JSON data...
</code></pre>

<p>Being new to CryptoJS I fail to put together working alternative. Here's what i've done so far:</p>

<pre><code>data = ""IYkyGxYaNgHpnZWgwILMalVFmLWFgTCHCZL9263NOcfSo5lBjAzOZAtF5bF++R0Bi+9c9E+p3VEr/xvj4oABtRWVJ2wlWzLbYC2rKFk5iapFhb7uZCUpO4w4Su3a5QFa2vInjYueziRoqySZd/DpstMJ8rsJ94VGizFFFZ1l0sw1ax+wfBAv5+wHs/hlnHi/ea66KBO3rgXKahvV28h+4bh5etc8RCrmiiNbfg6Oj0jQJDjdYIdW8T9YPOI9E1hih8lbfRnMWcOFJgYekfLpoy5LI525UGnlM46J1k6ekLqsn9FqvbiOOoLgqa4YqBm1i9P0ePyjkME+t+RiL8xXX+ItgOYr9G7kM64wlTJPCW8B/crmUdmGzQNC/hD/u/8wfHBS2f8u6OtQMG/+Kpk1oju8lcUZGI/4S8A6/OuktvQr2zgnbs2aADMrM37Oait/pJ3G73S7NwVT8EaK+X43c0C/fUvW2/bD/rqCNpAh9WQlz4Cj6JHwjbmwuind6aCimF1tHjXuR9FXu+g17sPT4ZkKZ6aeBG+m170XdCGn2hVM0wH1rh3VeCG2u/JFqfuGKGSoqeHeNY/icu9pEhtZDzHd7aPoaMXcWvXC9PjooBf7GM1EPacSdnon1kBobjtKSt1l15DjO5TMrJoX7VO7GotQwo+uI/u5Kop01hBXxyxyggl1/8N0ESohPJoqLDrIwvbGK5kW4B49FVPnx9CMvjZDdSsoxPAh+hx6SPe8Hj0Nx4bRs06cbtOkte/V8QSYIqjiJDleEqPrdiKlvgToZz9L29ZR/3Ln65qU1sq7q9c0SEYxIopV7TdTjFS7y76zDPFZkhzc3DjfLtJo/M1hdtt648APcZdmAIgWH6fh3eJZ0qbiPh8RStYH7I2COmnlMw4+t/B5mlhYVSgwPK2Ir736Mh+P9Bw0fF8r9Ghhs4AJzpU0RiK9d1tCsrLfK/hSRwTXhtsSB6eDWEGkO7oeEIz43mgn0sv3SrA9JNHzYkg="";
key = ""2e35f242a46d67eeb74aabc37d5e5d05"";

CryptoJS.AES.decrypt(atob(data).substring(16), key, {
    iv: atob(cipher).substring(0, 16),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Does CryptoJS expect data, key and initialization vector in some different way? As far as i understand, the IV are the first 16 bytes in data.</p>
","<pre><code>encryptWithCryptoJS(plainText: string): string {
    const key = CryptoJS.enc.Utf8.parse(""hf8685nfhfhjs9h8"");
    const iv1 = CryptoJS.enc.Utf8.parse(""hf8685nfhfhjs9h8"");
    const encrypted = CryptoJS.AES.encrypt(plainText, key, {
        keySize: 16,
        iv: iv1,
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    return encrypted + """";
}

decryptionWithCryptoJS(cipher: string): string {
    const key = CryptoJS.enc.Utf8.parse(""hf8685nfhfhjs9h8"");
    const iv1 = CryptoJS.enc.Utf8.parse(""hf8685nfhfhjs9h8"");
    const plainText = CryptoJS.AES.decrypt(cipher, key, {
        keySize: 16,
        iv: iv1,
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    return plainText.toString(CryptoJS.enc.Utf8);
}
</code></pre>
","65485","<javascript><ruby><aes><cryptojs>","20","-1","5","2019-07-03 04:08:37","15125030","2","14","112731","","2013-02-25 01:15:44","2013-02-19 12:58:03",""
"24337317","Encrypt with PHP, Decrypt with Javascript (cryptojs)","<p>I'm having trouble with basic encryption/decryption. I've looked all around for a working example but haven't quite found a working example.</p>

<p>-I will be encrypting in php, decrypting with cryptojs for a small layer of security</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;?
$text = ""this is the text here"";
$key = ""encryptionkey"";

$msgEncrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
$msgBase64 = trim(base64_encode($msgEncrypted));

echo ""&lt;h2&gt;PHP&lt;/h2&gt;"";
echo ""&lt;p&gt;Encrypted:&lt;/p&gt;"";
echo $msgEncrypted;
echo ""&lt;p&gt;Base64:&lt;/p&gt;"";
echo $msgBase64;
 ?&gt;

&lt;p&gt;AES Decrypt&lt;/p&gt;
&lt;script&gt; 
    var key = 'encryptionkey';
    var encrypted = ""&lt;?php echo $msgBase64 ?&gt;"";
    //tried  var base64decode = CryptoJS.enc.Base64.parse(encrypted); 
    var decrypted = CryptoJS.AES.decrypt(encrypted, key);
    console.log( decrypted.toString(CryptoJS.enc.Utf8) );
&lt;/script&gt;
</code></pre>

<p>Which step am I missing?</p>
","<p>You are using two libraries that try to accommodate input that is - strictly speaking - not valid. Rijndael requires keys that 16, 24 or 32 bytes long random byte strings. You provide a 13 character string. Mcrypt, the PHP library, uses the string (presumable utf8 encoded) directly as binary input and <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">zero pads it to the required 32 bytes</a> for <code>MCRYPT_RIJNDAEL_256</code>. CryptoJS on the other hand <a href=""https://code.google.com/p/crypto-js/#The_Cipher_Input"" rel=""nofollow"">decides that you have entered something like a passphrase and instead uses a key derivation function to generate a 32 byte key</a>.</p>

<p>Furthermore the encryption algorithms used don't even match. Mcrypt uses a seldom implemented variant of the original Rijndael for the 256 bit version, while CryptoJS implements the widely known variant AES256 of the Rijndael proposal. The 128 bit version of both (<code>MCRYPT_RIJNDAEL_128</code> and AES128) are identical though.</p>

<p>The third problem you are about to face later is that Mcrypt also uses a crazy padding scheme for the data being encrypted. As Rijndael is a block cipher, it can only encrypt blocks of 16, 24 or 32 bytes (depending on the variant - AES always uses 16 byte blocks). As such data has to be padded. Mcrypt does this in a non-injective way by just appending zeros. If you are only encoding strings this will not be so much of a problem for you as utf8 encoded strings never contain zero bytes, so you can just strip them off (<a href=""https://code.google.com/p/crypto-js/#Block_Modes_and_Padding"" rel=""nofollow"">CryptoJS even supports that natively</a>).</p>

<p>The easiest fix to all these problems is to avoid having to implement any cryptography yourself (it is strongly discouraged anyway without a wide knowledge of the subject). Can you instead transmit your sensitive information over https which will use TLS (formerly called SSL) to encrypt and authenticate the channel?</p>
","39036","<javascript><php><encryption><cryptojs>","29","3","4","2019-06-28 22:19:16","","0","30","2306173","","2015-01-03 18:36:28","2014-06-21 01:03:04",""
"24337317","Encrypt with PHP, Decrypt with Javascript (cryptojs)","<p>I'm having trouble with basic encryption/decryption. I've looked all around for a working example but haven't quite found a working example.</p>

<p>-I will be encrypting in php, decrypting with cryptojs for a small layer of security</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;?
$text = ""this is the text here"";
$key = ""encryptionkey"";

$msgEncrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
$msgBase64 = trim(base64_encode($msgEncrypted));

echo ""&lt;h2&gt;PHP&lt;/h2&gt;"";
echo ""&lt;p&gt;Encrypted:&lt;/p&gt;"";
echo $msgEncrypted;
echo ""&lt;p&gt;Base64:&lt;/p&gt;"";
echo $msgBase64;
 ?&gt;

&lt;p&gt;AES Decrypt&lt;/p&gt;
&lt;script&gt; 
    var key = 'encryptionkey';
    var encrypted = ""&lt;?php echo $msgBase64 ?&gt;"";
    //tried  var base64decode = CryptoJS.enc.Base64.parse(encrypted); 
    var decrypted = CryptoJS.AES.decrypt(encrypted, key);
    console.log( decrypted.toString(CryptoJS.enc.Utf8) );
&lt;/script&gt;
</code></pre>

<p>Which step am I missing?</p>
","<blockquote>
  <p><strong>Security notice</strong>: The code on this answer is vulnerable to chosen-ciphertext attacks. See <a href=""https://stackoverflow.com/a/30159120/2224584"">this answer instead for <strong>secure encryption</strong></a>.</p>
</blockquote>

<p>Here is a working example of encrypting your string with PHP and decrypting it with CryptoJS.</p>

<p>On the PHP side:</p>

<p>Use <strong>MCRYPT_RIJNDAEL_128</strong> (not 256) to pair with AES. <em>The 128 here is the blocksize, not the keysize.</em></p>

<p>Send the <strong>IV</strong>, too. You need the IV to decrypt.</p>

<pre><code>$text = ""this is the text here"";
$key = ""encryptionkey"";

// Note: MCRYPT_RIJNDAEL_128 is compatible with AES (all key sizes)
$iv = random_bytes(16);

$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $text, MCRYPT_MODE_CBC, $iv);

echo ""iv:"".base64_encode($iv).""\n"";
echo ""ciphertext:"".base64_encode($ciphertext).""\n"";
</code></pre>

<p>Here is sample output from a test run:</p>

<pre><code>iv:BMcOODpuQurUYGICmOqqbQ==
ciphertext:ZJAab8YtkRq5TL7uyIR7frM2b3krftJzn1pTqRTAda4=
</code></pre>

<blockquote>
  <p><strong>IMPORTANT</strong>: Because we are not authenticating our ciphertext, <a href=""https://robertheaton.com/2013/07/29/padding-oracle-attack/"" rel=""nofollow noreferrer"">decryption becomes vulnerable to padding oracle attacks</a>. See also: <a href=""https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly"" rel=""nofollow noreferrer"">authenticated encryption in PHP</a>.</p>
</blockquote>

<p>On the CryptoJS side:</p>

<p>Your key is only 13 ASCII printable characters which is very weak. Mcrypt <strong>padded</strong> the key to a valid keysize using <strong>ZERO</strong> bytes.</p>

<p>Convert the <strong>key</strong> and <strong>IV</strong> to <strong>word arrays</strong>.</p>

<p>I did not have much luck decrypting with <strong>ciphertext</strong> as a word array, so I've left it in <strong>Base64</strong> format.</p>

<pre><code>CryptoJS = require(""crypto-js"")

// Mcrypt pads a short key with zero bytes
key = CryptoJS.enc.Utf8.parse('encryptionkey\u0000\u0000\u0000')

iv = CryptoJS.enc.Base64.parse('BMcOODpuQurUYGICmOqqbQ==')

// Keep the ciphertext in Base64 form
ciphertext = 'ZJAab8YtkRq5TL7uyIR7frM2b3krftJzn1pTqRTAda4='

/**
 * DANGER DANGER WILL ROBINSON! &lt;== Stop editing my answer or I will delete it.
 *
 * This example code doesn't demonstrate AUTHENTICATED ENCRYPTION
 * and is therefore vulnerable to chosen-ciphertext attacks.
 *
 * NEVER USE THIS CODE TO PROTECT SENSITIVE DATA!
 */

// Mcrypt uses ZERO padding
plaintext = CryptoJS.AES.decrypt(ciphertext, key, { iv: iv, padding: CryptoJS.pad.ZeroPadding })

// I ran this in nodejs
process.stdout.write(CryptoJS.enc.Utf8.stringify(plaintext))
</code></pre>
","39036","<javascript><php><encryption><cryptojs>","29","14","4","2019-06-28 22:19:16","","0","30","2306173","","2015-01-03 18:36:28","2014-06-21 01:03:04",""
"24337317","Encrypt with PHP, Decrypt with Javascript (cryptojs)","<p>I'm having trouble with basic encryption/decryption. I've looked all around for a working example but haven't quite found a working example.</p>

<p>-I will be encrypting in php, decrypting with cryptojs for a small layer of security</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;?
$text = ""this is the text here"";
$key = ""encryptionkey"";

$msgEncrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
$msgBase64 = trim(base64_encode($msgEncrypted));

echo ""&lt;h2&gt;PHP&lt;/h2&gt;"";
echo ""&lt;p&gt;Encrypted:&lt;/p&gt;"";
echo $msgEncrypted;
echo ""&lt;p&gt;Base64:&lt;/p&gt;"";
echo $msgBase64;
 ?&gt;

&lt;p&gt;AES Decrypt&lt;/p&gt;
&lt;script&gt; 
    var key = 'encryptionkey';
    var encrypted = ""&lt;?php echo $msgBase64 ?&gt;"";
    //tried  var base64decode = CryptoJS.enc.Base64.parse(encrypted); 
    var decrypted = CryptoJS.AES.decrypt(encrypted, key);
    console.log( decrypted.toString(CryptoJS.enc.Utf8) );
&lt;/script&gt;
</code></pre>

<p>Which step am I missing?</p>
","<p>I've required the same thing and i wrote a short library that works for CryptoJS 3.x and PHP with openssl support. Hope this helps, source plus example files here <a href=""https://github.com/brainfoolong/cryptojs-aes-php"" rel=""noreferrer"">https://github.com/brainfoolong/cryptojs-aes-php</a></p>

<h2>PHP Lib</h2>

<pre><code>/**
* Decrypt data from a CryptoJS json encoding string
*
* @param mixed $passphrase
* @param mixed $jsonString
* @return mixed
*/
function cryptoJsAesDecrypt($passphrase, $jsonString){
    $jsondata = json_decode($jsonString, true);
    $salt = hex2bin($jsondata[""s""]);
    $ct = base64_decode($jsondata[""ct""]);
    $iv  = hex2bin($jsondata[""iv""]);
    $concatedPassphrase = $passphrase.$salt;
    $md5 = array();
    $md5[0] = md5($concatedPassphrase, true);
    $result = $md5[0];
    for ($i = 1; $i &lt; 3; $i++) {
        $md5[$i] = md5($md5[$i - 1].$concatedPassphrase, true);
        $result .= $md5[$i];
    }
    $key = substr($result, 0, 32);
    $data = openssl_decrypt($ct, 'aes-256-cbc', $key, true, $iv);
    return json_decode($data, true);
}

/**
* Encrypt value to a cryptojs compatiable json encoding string
*
* @param mixed $passphrase
* @param mixed $value
* @return string
*/
function cryptoJsAesEncrypt($passphrase, $value){
    $salt = openssl_random_pseudo_bytes(8);
    $salted = '';
    $dx = '';
    while (strlen($salted) &lt; 48) {
        $dx = md5($dx.$passphrase.$salt, true);
        $salted .= $dx;
    }
    $key = substr($salted, 0, 32);
    $iv  = substr($salted, 32,16);
    $encrypted_data = openssl_encrypt(json_encode($value), 'aes-256-cbc', $key, true, $iv);
    $data = array(""ct"" =&gt; base64_encode($encrypted_data), ""iv"" =&gt; bin2hex($iv), ""s"" =&gt; bin2hex($salt));
    return json_encode($data);
}
</code></pre>

<h2>Javascript Lib</h2>

<pre><code>var CryptoJSAesJson = {
    stringify: function (cipherParams) {
        var j = {ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)};
        if (cipherParams.iv) j.iv = cipherParams.iv.toString();
        if (cipherParams.salt) j.s = cipherParams.salt.toString();
        return JSON.stringify(j);
    },
    parse: function (jsonStr) {
        var j = JSON.parse(jsonStr);
        var cipherParams = CryptoJS.lib.CipherParams.create({ciphertext: CryptoJS.enc.Base64.parse(j.ct)});
        if (j.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(j.iv)
        if (j.s) cipherParams.salt = CryptoJS.enc.Hex.parse(j.s)
        return cipherParams;
    }
}
</code></pre>

<h2>Example Javascript</h2>

<pre><code>var encrypted = CryptoJS.AES.encrypt(JSON.stringify(""value to encrypt""), ""my passphrase"", {format: CryptoJSAesJson}).toString();
var decrypted = JSON.parse(CryptoJS.AES.decrypt(encrypted, ""my passphrase"", {format: CryptoJSAesJson}).toString(CryptoJS.enc.Utf8));
</code></pre>

<h2>Example PHP</h2>

<pre><code>$encrypted = cryptoJsAesEncrypt(""my passphrase"", ""value to encrypt"");
$decrypted = cryptoJsAesDecrypt(""my passphrase"", $encrypted);
</code></pre>
","39036","<javascript><php><encryption><cryptojs>","29","56","4","2019-06-28 22:19:16","","0","30","2306173","","2015-01-03 18:36:28","2014-06-21 01:03:04",""
"24337317","Encrypt with PHP, Decrypt with Javascript (cryptojs)","<p>I'm having trouble with basic encryption/decryption. I've looked all around for a working example but haven't quite found a working example.</p>

<p>-I will be encrypting in php, decrypting with cryptojs for a small layer of security</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;?
$text = ""this is the text here"";
$key = ""encryptionkey"";

$msgEncrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC, mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND));
$msgBase64 = trim(base64_encode($msgEncrypted));

echo ""&lt;h2&gt;PHP&lt;/h2&gt;"";
echo ""&lt;p&gt;Encrypted:&lt;/p&gt;"";
echo $msgEncrypted;
echo ""&lt;p&gt;Base64:&lt;/p&gt;"";
echo $msgBase64;
 ?&gt;

&lt;p&gt;AES Decrypt&lt;/p&gt;
&lt;script&gt; 
    var key = 'encryptionkey';
    var encrypted = ""&lt;?php echo $msgBase64 ?&gt;"";
    //tried  var base64decode = CryptoJS.enc.Base64.parse(encrypted); 
    var decrypted = CryptoJS.AES.decrypt(encrypted, key);
    console.log( decrypted.toString(CryptoJS.enc.Utf8) );
&lt;/script&gt;
</code></pre>

<p>Which step am I missing?</p>
","<p>Don't go too dept with coding, just use base64 decoder</p>

<p>on php code:</p>

<pre><code>$encrypt_val=base64_encode(""value"");
</code></pre>

<p>and on js just:</p>

<pre><code>var my_orignal_val = window.atob(passed_val);
</code></pre>

<p>This will enough for your requirement.</p>
","39036","<javascript><php><encryption><cryptojs>","29","0","4","2019-06-28 22:19:16","","0","30","2306173","","2015-01-03 18:36:28","2014-06-21 01:03:04",""
"16600509","AES Encrypt in CryptoJS and decrypt in Coldfusion","<p>We've got a Silent Login service written in Coldfusion9 that accepts encrypted strings from external systems and then decrypts based on an agreed Algorithm/Encoding setup. This has worked without issue for years now from systems running ASP/JAVA/PHP, but we now have a client who has no choice but to use CryptoJS to perform the encryption and for the life of me I cannot work out why this won't decrypt in Coldfusion.</p>

<p>My knowledge of encryption isn't brilliant but the thing I am noticing is the CryptoJS encrypted ciphertext for the exact same string/key differs every time i perform the encryption whereas in Coldfusion/Java i can always expect the exact same encrypted string. I'm not sure if this is encoding related or not but i've never run into this issue accepting encrypted strings from any other system before, so I am hoping it's the way I am encrypting in CryptoJS that is incorrect.</p>

<pre><code>&lt;cfoutput&gt;

&lt;!--- Set String and Key ---&gt;
&lt;cfset theKey = toBase64(""1234567812345678"")&gt;
&lt;cfset string = ""max.brenner@google.com.au""&gt;

&lt;!--- CryptoJS AES Libraries ---&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;

&lt;script&gt;

// Encrypt String using CryptoJS AES
var encrypted = CryptoJS.AES.encrypt(""#string#"", ""#theKey#"");
console.log(encrypted.toString());

// Decrypt String using CryptoJS AES 
var decrypted = CryptoJS.AES.decrypt(encrypted, ""#theKey#"");
console.log(decrypted.toString(CryptoJS.enc.Utf8));

&lt;/script&gt;

&lt;!--- Coldfusion Decrypt String / FAILS ---&gt;
Decrypted: #decrypt(encryptedEmail, ""#theKey#"", ""AES"", ""BASE64"")#

&lt;/cfoutput&gt;
</code></pre>
","<p>There seem to be two issues:</p>

<ol>
<li><p>CryptoJS is not using your variable as the <code>key</code>. As @Miguel-F mentioned, when you pass in a string, <a href=""https://code.google.com/p/crypto-js/#The_Cipher_Input"" rel=""nofollow"">""it's treated as a passphrase and used to derive [the] actual key and IV""</a>. Both are randomly generated, which is why your encrypted result keeps changing. But more importantly, this means that CryptoJS is using a completely different <code>key</code> than the one in your CF code and that is why decrypt() fails. (At least it is part of the reason ...)</p></li>
<li><p>The second problem is that in addition to the algorithm ""AES"", there are two other encryption settings which must match: <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""nofollow"">mode</a> and <a href=""http://en.wikipedia.org/wiki/Padding_%28cryptography%29"" rel=""nofollow"">padding scheme</a>. While CryptoJS and ColdFusion use the same defaults for padding scheme, the ""modes"" are different:</p>

<ul>
<li><a href=""http://helpx.adobe.com/coldfusion/kb/strong-encryption-coldfusion-mx-7.html"" rel=""nofollow"">ColdFusion uses ""ECB""</a>. ""AES"" is actually short for <code>""AES/ECB/PKCS5Padding""</code></li>
<li>CryptoJS uses ""CBC"", which requires an additional <code>iv</code> (<a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Initialization_vector_.28IV.29"" rel=""nofollow"">initialization vector</a>) value.<br><br></li>
</ul></li>
</ol>

<p>You need to ensure all three settings are the same on both sides. Try using CBC mode in CF, since it is more secure than ECB anyway. <em>Note: It requires adding an IV value.</em></p>

<p><strong>CF Code:</strong></p>

<pre><code>&lt;!--- this is the base64 encrypted value from CryptoJS ---&gt; 
&lt;cfset encrypted = ""J2f66oiDpZkFlQu26BDKL6ZwgNwN7T3ixst4JtMyNIY=""&gt;
&lt;cfset rawString = ""max.brenner@google.com.au""&gt;
&lt;cfset base64Key = ""MTIzNDU2NzgxMjM0NTY3OA==""&gt;
&lt;cfset base64IV = ""EBESExQVFhcYGRobHB0eHw==""&gt;

&lt;cfset ivBytes = binaryDecode(base64IV, ""base64"")&gt;
&lt;cfoutput&gt;
    #decrypt(encrypted, base64Key, ""AES/CBC/PKCS5Padding"", ""base64"", ivBytes)#
&lt;/cfoutput&gt;
</code></pre>

<p><strong>CryptoJS: (Adjusted Original Example)</strong></p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var text = ""#rawString#"";
    var key = CryptoJS.enc.Base64.parse(""#base64Key#"");
    var iv  = CryptoJS.enc.Base64.parse(""#base64IV#"");

    var encrypted = CryptoJS.AES.encrypt(text, key, {iv: iv});
    console.log(encrypted.toString());

    var decrypted = CryptoJS.AES.decrypt(encrypted, key, {iv: iv});
    console.log(decrypted.toString(CryptoJS.enc.Utf8));
&lt;/script&gt;
</code></pre>

<p><br></p>

<p><strong>Edit:</strong></p>

<p>All that said, what do you mean by the client <em>""has no choice but to use CryptoJS to perform the encryption""</em>? Why cannot they use server side encryption? I am not an encryption expert, but doing encryption in javascript, and <strong><em>exposing the key on the client</em></strong>, does not sound wildly secure to begin with ... </p>
","33530","<javascript><encryption><coldfusion><aes><cryptojs>","6","11","1","2016-06-19 17:17:07","16615194","5","3","","","","2013-05-17 02:29:11",""
"25492179","Decode a Base64 String using CryptoJS","<p>I am trying to create a simple webpage with the goal to send and encrypted message to the server (which will create a file with that content), then a link is created and the user who receive the link provided will be able to see the encrypted value (since it provides the name of the file and the key).</p>

<p>The message is encrypted using CryptoJS AES, and the result is Base64 encoded to be decoded after that, only the Base64 of the encrypted message and the encrypted message is sent to the server nothing else, and this is done using Javascript.</p>

<p>My question here is. I have a message, let say ""Hello World"" which I encode using Base64, and it gives me this :</p>

<pre><code>1ffffffff5a8ae57
</code></pre>

<p>If I send this value to a variable, and then just use that variable, it show a result :</p>

<pre><code>// Works !
var test = CryptoJS.enc.Base64.parse(""Hello World"");
alert(CryptoJS.enc.Base64.stringify(test));
</code></pre>

<p>Which is normal. But If I try to write directly the text (or just do a toString(), it doesn't work... which is also normal because the 'test' variable isn't a simple String variable) :</p>

<pre><code>// Doesn't work !
var test = CryptoJS.enc.Base64.parse(""Hello World"").toString();
alert(CryptoJS.enc.Base64.stringify(test));
</code></pre>

<p>But I need to use a String since it is based on a PHP $_GET Value which is then decoded using Javascript again. So my question is, how can I do this in order to encode a String and then decoded the result as a String ?</p>

<p>This is my engine.js file :</p>

<pre><code>// Encrypt the message using a generated key
function encrypt(message, key) {
    return CryptoJS.AES.encrypt(message, key);
}

// Encode String to Base64
function encodeBase64(value) {
    return CryptoJS.enc.Base64.parse(value.toString());
}

// Decode String from Base64 Enconding
function decodeBase64(encodedValue) {
    return CryptoJS.enc.Base64.stringify(encodedValue);
}

// Decrypt the message using the generated key
function decrypt(encrypted, key) {
    return CryptoJS.AES.decrypt(encrypted, key).toString(CryptoJS.enc.Utf8);
}

// Generate the random key
function generateKey() {
    return CryptoJS.lib.WordArray.random(16).toString();
}

// Generate the random fileName
function generateFileName() {
    return CryptoJS.lib.WordArray.random(16).toString();
}

// Convert the text on the form with the encrypted version to be sent into the server
function SendMessage(message, FinalURL) {
    if ((message.value).trim()) {
        var xmlhttp = new XMLHttpRequest;
        xmlhttp.open(""POST"", ""index.php"", true);
        xmlhttp.setRequestHeader(""Content-type"", ""application/x-www-form-urlencoded"");

        // Generate the Key and Encrypt the Message
        var key             = generateKey();
        var encryptedData   = encrypt(message.value, key);
        var fileName        = generateFileName();      

        xmlhttp.send(""fileName="" + fileName + ""&amp;encryptedMsg="" + encodeBase64(encryptedData));

        var finalURL = document.URL + ""?MessageID="" + fileName + ""&amp;Key="" + key;

        FinalURL.innerHTML = ""&lt;p&gt;Final URL: &lt;a href="" + finalURL + ""&gt;"" + finalURL + ""&lt;/a&gt;&lt;/p&gt;"";
    } else {
        alert(""There is no text to be encrypted !"");
    }
}
</code></pre>
","<p>I ran into a similar confusion, and for reference, here is the solution. </p>

<p>To turn a <strong>text string (UTF-8 encoded)</strong> into a <strong>base-64 string</strong>, you need:</p>

<pre><code>var textString = 'Hello world'; // Utf8-encoded string
var words = CryptoJS.enc.Utf8.parse(textString); // WordArray object
var base64 = CryptoJS.enc.Base64.stringify(words); // string: 'SGVsbG8gd29ybGQ='
</code></pre>

<p>To turn a <strong>base-64 encoded string</strong> back into <strong>text (UTF-8 encoded)</strong>, it's:</p>

<pre><code>var base64 = 'SGVsbG8gd29ybGQ=';
var words = CryptoJS.enc.Base64.parse(base64);
var textString = CryptoJS.enc.Utf8.stringify(words); // 'Hello world'
</code></pre>

<h2>Some explanation</h2>

<p>As you can see from the examples given in the <a href=""https://code.google.com/p/crypto-js/#Encoders"">CryptoJS documentation</a>, <em>parse</em> is meant to parse a string in the format that the encoder is expecting (into a WordArray), and <em>stringify</em> turns a WordArray into a string. </p>

<p>From the documentation:</p>

<pre><code>var words  = CryptoJS.enc.Base64.parse('SGVsbG8sIFdvcmxkIQ==');
var base64 = CryptoJS.enc.Base64.stringify(words); // 'Hello, World!'
</code></pre>

<p>The WordArray is CryptoJS's format-independent representation of data. Formatters (like Base64 and Utf8) are interfaces between this WordArray format, and strings, which may contain data encoded in any format. So to change between formats, you need a formatter at either end, one parsing and one stringifying (i.e. encoding). In this case, you need to remember that when we write 'Hello World', that's text encoded in a particular format (I'm assuming UTF-8).</p>

<p>I found <a href=""https://gist.github.com/joecliff/10948117"">this Gist</a> helpful.</p>
","32720","<javascript><php><base64><aes><cryptojs>","9","41","1","2019-09-11 12:25:36","","0","9","","","","2014-08-25 18:29:04",""
"12574160","My CryptoJS encryption/decryption is not working","<p>I have an array of JSON arrays whose values I am trying to encrypt with CryptoJS and then print for use in another file, where these values should be decrypted using a user-given passphrase.</p>

<p>But I am doing something wrong and I am getting ""Uncaught Error: Malformed UTF-8 data"" when decrypting the URL's.</p>

<p>encrypt.js:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(item[key], pass);
json[j] += encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>

<p>decrypt.js:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(item[key], pass);
html += '&lt;a href=""' + decrypted.toString(CryptoJS.enc.Utf8) + '"" target=""_blank"" class=""socialico ' + key + '""&gt;' + icons[key] + '&lt;/a&gt;';
</code></pre>

<p>I followed <a href=""http://cryptojs.altervista.org/secretkey/doc/doc_aes_cryptojs-v3.html"" rel=""noreferrer"">this</a> example... Help, pretty please?</p>
","<p>That error message usually means the data wasn't decrypted correctly, and the resulting plaintext bytes don't form valid UTF-8 characters. </p>

<p>A couple things to check: </p>

<ul>
<li>First, make sure you're using the same password for both encryption and decryption. You may want to keep a hash of the correct password so that you can verify if the user gave the correct password before you use it for decryption. </li>
<li>Second, make sure that the value <code>item[key]</code> is a string before encrypting. CryptoJS can't encrypt JSON objects. You'll have to serialize it first.</li>
</ul>
","30162","<javascript><encryption><cryptojs>","11","13","1","2016-04-14 10:12:32","12591535","0","4","","","","2012-09-24 23:07:28",""
"38479667","Import crypto-js in an angular 2 project (created with angular-cli)","<p>I'm trying to import crypto-js in my angular2 project.</p>

<p>I followed several SO questions and also <a href=""https://github.com/angular/angular-cli/wiki/3rd-party-libs"" rel=""noreferrer"">angular-cli guide</a>, but at the end I still have the error <strong>Cannot find module 'crypto-js'</strong></p>

<p>What I tried :</p>

<p><code>npm install crypto-js --save</code></p>

<p>and</p>

<p><code>typings install dt~crypto-js --global --save</code></p>

<p>then I modified the file <strong>angular-cli-build.js</strong></p>

<pre><code>var Angular2App = require('angular-cli/lib/broccoli/angular2-app');

module.exports = function(defaults) {
  return new Angular2App(defaults, {
    vendorNpmFiles: [
      'systemjs/dist/system-polyfills.js',
      'systemjs/dist/system.src.js',
      'zone.js/dist/**/*.+(js|js.map)',
      'es6-shim/es6-shim.js',
      'reflect-metadata/**/*.+(ts|js|js.map)',
      'rxjs/**/*.+(js|js.map)',
      '@angular/**/*.+(js|js.map)',
      'crypto-js/**/*.+(js|js.map)'
    ]
  });
};
</code></pre>

<p>and the file <strong>src/system-config.ts</strong></p>

<pre><code>const map: any = {
    'crypto-js': 'vendor/crypto-js'
};

/** User packages configuration. */
const packages: any = {
    'crypto-js': {
        format: 'cjs'
    }
};
</code></pre>

<p>After using</p>

<p><code>import * as CryptoJS from 'crypto-js';</code></p>

<p>I still have my error. Did I miss something ?</p>

<p>Thanks</p>
","<p>Angular-cli still have some issues to integrate third-party plugins. So, Dont forget to add it in the <code>index.html</code> . Add like this way</p>

<pre><code>&lt;script src=""vendor/crypto-js/crypto-js.js""&gt;&lt;/script&gt; 
</code></pre>

<p>I think it will solve your problem :) </p>

<p>Update</p>

<pre><code>const map: any = {
    'crypto-js': 'vendor/crypto-js'
};



/** User packages configuration. */
const packages: any = {
    'crypto-js': {
        format: 'cjs',
        defaultExtension: 'js',
        main: 'crypto-js.js'
    }
};
</code></pre>
","26957","<angular><cryptojs>","8","0","4","2018-10-19 12:11:10","38481836","1","1","5407910","","2016-07-20 11:58:20","2016-07-20 11:12:12",""
"38479667","Import crypto-js in an angular 2 project (created with angular-cli)","<p>I'm trying to import crypto-js in my angular2 project.</p>

<p>I followed several SO questions and also <a href=""https://github.com/angular/angular-cli/wiki/3rd-party-libs"" rel=""noreferrer"">angular-cli guide</a>, but at the end I still have the error <strong>Cannot find module 'crypto-js'</strong></p>

<p>What I tried :</p>

<p><code>npm install crypto-js --save</code></p>

<p>and</p>

<p><code>typings install dt~crypto-js --global --save</code></p>

<p>then I modified the file <strong>angular-cli-build.js</strong></p>

<pre><code>var Angular2App = require('angular-cli/lib/broccoli/angular2-app');

module.exports = function(defaults) {
  return new Angular2App(defaults, {
    vendorNpmFiles: [
      'systemjs/dist/system-polyfills.js',
      'systemjs/dist/system.src.js',
      'zone.js/dist/**/*.+(js|js.map)',
      'es6-shim/es6-shim.js',
      'reflect-metadata/**/*.+(ts|js|js.map)',
      'rxjs/**/*.+(js|js.map)',
      '@angular/**/*.+(js|js.map)',
      'crypto-js/**/*.+(js|js.map)'
    ]
  });
};
</code></pre>

<p>and the file <strong>src/system-config.ts</strong></p>

<pre><code>const map: any = {
    'crypto-js': 'vendor/crypto-js'
};

/** User packages configuration. */
const packages: any = {
    'crypto-js': {
        format: 'cjs'
    }
};
</code></pre>

<p>After using</p>

<p><code>import * as CryptoJS from 'crypto-js';</code></p>

<p>I still have my error. Did I miss something ?</p>

<p>Thanks</p>
","<p>Ok I got it. I just download the <a href=""https://github.com/DefinitelyTyped/DefinitelyTyped/tree/4869992bc079b88280b9ff91213528904109e8ae/crypto-js"" rel=""nofollow noreferrer"">DefinitelyTyped</a> file in typings/crypto-js/ and then I add the line <code>/// &lt;reference path=""../../typings/crypto-js/crypto-js.d.ts"" /&gt;</code> before importing CryptoJS.</p>
","26957","<angular><cryptojs>","8","0","4","2018-10-19 12:11:10","38481836","1","1","5407910","","2016-07-20 11:58:20","2016-07-20 11:12:12",""
"38479667","Import crypto-js in an angular 2 project (created with angular-cli)","<p>I'm trying to import crypto-js in my angular2 project.</p>

<p>I followed several SO questions and also <a href=""https://github.com/angular/angular-cli/wiki/3rd-party-libs"" rel=""noreferrer"">angular-cli guide</a>, but at the end I still have the error <strong>Cannot find module 'crypto-js'</strong></p>

<p>What I tried :</p>

<p><code>npm install crypto-js --save</code></p>

<p>and</p>

<p><code>typings install dt~crypto-js --global --save</code></p>

<p>then I modified the file <strong>angular-cli-build.js</strong></p>

<pre><code>var Angular2App = require('angular-cli/lib/broccoli/angular2-app');

module.exports = function(defaults) {
  return new Angular2App(defaults, {
    vendorNpmFiles: [
      'systemjs/dist/system-polyfills.js',
      'systemjs/dist/system.src.js',
      'zone.js/dist/**/*.+(js|js.map)',
      'es6-shim/es6-shim.js',
      'reflect-metadata/**/*.+(ts|js|js.map)',
      'rxjs/**/*.+(js|js.map)',
      '@angular/**/*.+(js|js.map)',
      'crypto-js/**/*.+(js|js.map)'
    ]
  });
};
</code></pre>

<p>and the file <strong>src/system-config.ts</strong></p>

<pre><code>const map: any = {
    'crypto-js': 'vendor/crypto-js'
};

/** User packages configuration. */
const packages: any = {
    'crypto-js': {
        format: 'cjs'
    }
};
</code></pre>

<p>After using</p>

<p><code>import * as CryptoJS from 'crypto-js';</code></p>

<p>I still have my error. Did I miss something ?</p>

<p>Thanks</p>
","<p>This may help you: <br>
<a href=""https://github.com/Uisli21/SecureAngularLogin"" rel=""noreferrer"">https://github.com/Uisli21/SecureAngularLogin</a></p>

<hr>

<pre><code>$ npm install crypto-js --save
$ npm install @types/crypto-js --save-dev
</code></pre>

<p>then:</p>

<pre><code>import * as CryptoJS from 'crypto-js';
</code></pre>

<p>or</p>

<pre><code>import CryptoJS = require('crypto-js');
</code></pre>
","26957","<angular><cryptojs>","8","24","4","2018-10-19 12:11:10","38481836","1","1","5407910","","2016-07-20 11:58:20","2016-07-20 11:12:12",""
"38479667","Import crypto-js in an angular 2 project (created with angular-cli)","<p>I'm trying to import crypto-js in my angular2 project.</p>

<p>I followed several SO questions and also <a href=""https://github.com/angular/angular-cli/wiki/3rd-party-libs"" rel=""noreferrer"">angular-cli guide</a>, but at the end I still have the error <strong>Cannot find module 'crypto-js'</strong></p>

<p>What I tried :</p>

<p><code>npm install crypto-js --save</code></p>

<p>and</p>

<p><code>typings install dt~crypto-js --global --save</code></p>

<p>then I modified the file <strong>angular-cli-build.js</strong></p>

<pre><code>var Angular2App = require('angular-cli/lib/broccoli/angular2-app');

module.exports = function(defaults) {
  return new Angular2App(defaults, {
    vendorNpmFiles: [
      'systemjs/dist/system-polyfills.js',
      'systemjs/dist/system.src.js',
      'zone.js/dist/**/*.+(js|js.map)',
      'es6-shim/es6-shim.js',
      'reflect-metadata/**/*.+(ts|js|js.map)',
      'rxjs/**/*.+(js|js.map)',
      '@angular/**/*.+(js|js.map)',
      'crypto-js/**/*.+(js|js.map)'
    ]
  });
};
</code></pre>

<p>and the file <strong>src/system-config.ts</strong></p>

<pre><code>const map: any = {
    'crypto-js': 'vendor/crypto-js'
};

/** User packages configuration. */
const packages: any = {
    'crypto-js': {
        format: 'cjs'
    }
};
</code></pre>

<p>After using</p>

<p><code>import * as CryptoJS from 'crypto-js';</code></p>

<p>I still have my error. Did I miss something ?</p>

<p>Thanks</p>
","<p>You can try following as a solution:</p>

<pre><code>1. npm install --save @types/crypto-js


2. import { AES } from ""crypto-js"";


3. AES.encrypt('my message', 'secret key');
</code></pre>
","26957","<angular><cryptojs>","8","2","4","2018-10-19 12:11:10","38481836","1","1","5407910","","2016-07-20 11:58:20","2016-07-20 11:12:12",""
"37200587","Crypto-JS is now missing on google codes","<p>I was using the online version of <code>Crypto-Js</code> hosted on <code>google codes</code> see below:</p>

<pre><code>&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>Then yesterday my website suddenly crashed, and I find out that the host doesn't exist anymore. Am I the only one using this link? Did they move it to a different link?</p>

<p><a href=""https://i.stack.imgur.com/ipU6G.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/ipU6G.png"" alt=""crypto-js""></a> </p>
","<p>There are few ways to get the <code>CryptoJs</code> codes.</p>

<ol>
<li>Get from the google code archive : <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""noreferrer"">Crypto-Js</a></li>
<li>CDN : <a href=""https://cdnjs.com/libraries/crypto-js"" rel=""noreferrer"">CryptoJs CDN</a></li>
</ol>

<p><strong>Note</strong></p>

<p>This answer might get outdated through time and I cant really track it and this solution might not work in the future, if so, just comment here so I can update it :)</p>
","23132","<javascript><google-code><cryptojs>","17","16","2","2019-07-17 01:54:34","37224223","2","","3885376","","2017-10-02 19:46:23","2016-05-13 03:06:12",""
"37200587","Crypto-JS is now missing on google codes","<p>I was using the online version of <code>Crypto-Js</code> hosted on <code>google codes</code> see below:</p>

<pre><code>&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>Then yesterday my website suddenly crashed, and I find out that the host doesn't exist anymore. Am I the only one using this link? Did they move it to a different link?</p>

<p><a href=""https://i.stack.imgur.com/ipU6G.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/ipU6G.png"" alt=""crypto-js""></a> </p>
","<p>You can use <strong>cloudfare CDN</strong>, they still have the files. Below are the links</p>

<p><code>https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core-min.js</code></p>

<p><code>https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/hmac-sha512.js</code></p>
","23132","<javascript><google-code><cryptojs>","17","7","2","2019-07-17 01:54:34","37224223","2","","3885376","","2017-10-02 19:46:23","2016-05-13 03:06:12",""
"22607791","AES encryption using Java and decryption using Javascript","<p>I am making an application which needs Java based AES Encryption and JavaScript based decryption.
I am using the following code for encryption as a basic form.</p>

<pre><code>public class AESencrp {

  private static final String ALGO = ""AES"";
  private static final byte[] keyValue = 
      new byte[] { 'A', 'b', 'c', 'd', 'e', 'f', 'g',
      'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p'};

  public static String encrypt(String Data) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGO);
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encVal = c.doFinal(Data.getBytes());
    String encryptedValue = new BASE64Encoder().encode(encVal);
    return encryptedValue;
  }


  private static Key generateKey() throws Exception {
    Key key = new SecretKeySpec(keyValue, ALGO);
    return key;
  }
}
</code></pre>

<p>The JavaScript that I am trying to use to decrypt is </p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;   &lt;/script&gt;

var decrypted = CryptoJS.AES.decrypt(encrypted,""Abcdefghijklmnop"").toString(CryptoJS.enc.Utf8);
</code></pre>

<p>But the JavaScript decryption is not working. I am new to this, could someone tell me a way to solve without changing the Java code block ?</p>

<p>I tried Base-64 decoding my text like this:</p>

<pre><code>var words  = CryptoJS.enc.Base64.parse(encrKey);
var base64 = CryptoJS.enc.Base64.stringify(words);
var decrypted = CryptoJS.AES.decrypt(base64, ""Abcdefghijklmnop"");
alert(""dec :"" +decrypted);
</code></pre>

<p>but still no good.</p>

<p>I tried the solution suggested below to resolve possible padding issue but its not giving any solution.</p>

<pre><code>var key = CryptoJS.enc.Base64.parse(""QWJjZGVmZ2hpamtsbW5vcA=="");
var decrypt = CryptoJS.AES.decrypt( encrKey, key, { mode: CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7 } );

alert(""dec :"" +decrypt);
</code></pre>
","<ol>
<li><p>Your Java code uses the 128-bit AES key while your JavaScript code uses the 256-bit AES key.</p></li>
<li><p>Your Java code uses the ""Abcdefghijklmnop"".getBytes() as the actual key value, while your JavaScript code uses the ""Abcdefghijklmnop"" as the passphrase from which the actual key is derived.</p></li>
<li><p>The default transformation for Java AES is AES/ECB/PKCS5Padding, while default transformation for CryptoJS is AES/CBC/PKCS7Padding.</p></li>
</ol>

<p>One way to fix your example is to fix the JavaScript side:</p>

<pre><code>// this is Base64 representation of the Java counterpart
// byte[] keyValue = new byte[] { 'A', 'b', 'c', 'd', 'e', 'f', 'g',
//                'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p'};
// String keyForJS = new BASE64Encoder().encode(keyValue);
var base64Key = ""QWJjZGVmZ2hpamtsbW5vcA=="";
console.log( ""base64Key = "" + base64Key );

// this is the actual key as a sequence of bytes
var key = CryptoJS.enc.Base64.parse(base64Key);
console.log( ""key = "" + key );

// this is the plain text
var plaintText = ""Hello, World!"";
console.log( ""plaintText = "" + plaintText );

// this is Base64-encoded encrypted data
var encryptedData = CryptoJS.AES.encrypt(plaintText, key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
console.log( ""encryptedData = "" + encryptedData );

// this is the decrypted data as a sequence of bytes
var decryptedData = CryptoJS.AES.decrypt( encryptedData, key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
} );
console.log( ""decryptedData = "" + decryptedData );

// this is the decrypted data as a string
var decryptedText = decryptedData.toString( CryptoJS.enc.Utf8 );
console.log( ""decryptedText = "" + decryptedText );
</code></pre>
","23082","<java><javascript><encryption><aes><cryptojs>","9","14","2","2016-12-26 14:24:00","22610341","8","10","3218413","","2014-03-25 04:59:03","2014-03-24 11:13:15",""
"22607791","AES encryption using Java and decryption using Javascript","<p>I am making an application which needs Java based AES Encryption and JavaScript based decryption.
I am using the following code for encryption as a basic form.</p>

<pre><code>public class AESencrp {

  private static final String ALGO = ""AES"";
  private static final byte[] keyValue = 
      new byte[] { 'A', 'b', 'c', 'd', 'e', 'f', 'g',
      'h', 'i', 'j', 'k','l', 'm', 'n', 'o', 'p'};

  public static String encrypt(String Data) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGO);
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encVal = c.doFinal(Data.getBytes());
    String encryptedValue = new BASE64Encoder().encode(encVal);
    return encryptedValue;
  }


  private static Key generateKey() throws Exception {
    Key key = new SecretKeySpec(keyValue, ALGO);
    return key;
  }
}
</code></pre>

<p>The JavaScript that I am trying to use to decrypt is </p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;   &lt;/script&gt;

var decrypted = CryptoJS.AES.decrypt(encrypted,""Abcdefghijklmnop"").toString(CryptoJS.enc.Utf8);
</code></pre>

<p>But the JavaScript decryption is not working. I am new to this, could someone tell me a way to solve without changing the Java code block ?</p>

<p>I tried Base-64 decoding my text like this:</p>

<pre><code>var words  = CryptoJS.enc.Base64.parse(encrKey);
var base64 = CryptoJS.enc.Base64.stringify(words);
var decrypted = CryptoJS.AES.decrypt(base64, ""Abcdefghijklmnop"");
alert(""dec :"" +decrypted);
</code></pre>

<p>but still no good.</p>

<p>I tried the solution suggested below to resolve possible padding issue but its not giving any solution.</p>

<pre><code>var key = CryptoJS.enc.Base64.parse(""QWJjZGVmZ2hpamtsbW5vcA=="");
var decrypt = CryptoJS.AES.decrypt( encrKey, key, { mode: CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7 } );

alert(""dec :"" +decrypt);
</code></pre>
","<p>For Java and JavaScript to able to inter operate, it is essential that no defaults are used while creating Key or the Cipher. The iteration count, key length, padding, salt and IV should all be the same. </p>

<p>Reference: <a href=""https://github.com/mpetersen/aes-example"" rel=""nofollow noreferrer"">https://github.com/mpetersen/aes-example</a></p>

<p>Sample code below:</p>

<p>Encrypting String in Java:</p>

<pre><code>    String keyValue = ""Abcdefghijklmnop"";     
    SecretKeyFactory factory =   SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(keyValue.toCharArray(), hex(""dc0da04af8fee58593442bf834b30739""),
        1000, 128);

    Key key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ""AES"");
    Cipher c = Cipher.getInstance(AES/CBC/PKCS5Padding);
    c.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(hex(""dc0da04af8fee58593442bf834b30739"")));

    byte[] encVal = c.doFinal(""The Quick Brown Fox Jumped over the moon"".getBytes());
    String base64EncodedEncryptedData = new String(Base64.encodeBase64(encVal));
    System.out.println(base64EncodedEncryptedData);
</code></pre>

<p>}</p>

<p>Decrypting the same string in JavaScript:</p>

<pre><code>var iterationCount = 1000;
var keySize = 128;
var encryptionKey  =""Abcdefghijklmnop"";
var dataToDecrypt = ""2DZqzpXzmCsKj4lfQY4d/exg9GAyyj0hVK97kPw5ZxMFs3jQiEQ6LLvUsBLdkA80"" //The base64 encoded string output from Java;
var iv = ""dc0da04af8fee58593442bf834b30739""
var salt = ""dc0da04af8fee58593442bf834b30739""

var aesUtil = new AesUtil(keySize, iterationCount);
var plaintext =  aesUtil.decrypt(salt, iv, encryptionKey, dataToDecrypt);
console.log(plaintext);

**//AESUtil - Utility class for CryptoJS**
var AesUtil = function(keySize, iterationCount) {
 this.keySize = keySize / 32;
 this.iterationCount = iterationCount;
};

AesUtil.prototype.generateKey = function(salt, passPhrase) {
  var key = CryptoJS.PBKDF2(passPhrase, CryptoJS.enc.Hex.parse(salt),
  { keySize: this.keySize, iterations: this.iterationCount });
  return key;
}

AesUtil.prototype.decrypt = function(salt, iv, passPhrase, cipherText) {
  var key = this.generateKey(salt, passPhrase);
  var cipherParams = CryptoJS.lib.CipherParams.create({
    ciphertext: CryptoJS.enc.Base64.parse(cipherText)
  });
  var decrypted = CryptoJS.AES.decrypt(cipherParams,key,
  { iv: CryptoJS.enc.Hex.parse(iv) });
  return decrypted.toString(CryptoJS.enc.Utf8);
 }
}
</code></pre>
","23082","<java><javascript><encryption><aes><cryptojs>","9","4","2","2016-12-26 14:24:00","22610341","8","10","3218413","","2014-03-25 04:59:03","2014-03-24 11:13:15",""
"29512858","CryptoJS and key/IV length","<p>I have question about AES key and IV length.</p>

<p>First of all, if, for example, I'm using <s>drugs</s> <code>OpenSSL</code> extension and <code>openssl_encrypt()</code> method, I can clearly see that key for <strong>256-bit AES</strong> should be <strong>32</strong> bytes, and IV throws warning if it's different than <strong>16</strong> bytes. I can understand that, and everything is fine.</p>

<p>However, in <code>CryptoJS</code> library the key and IV length is frustrating. This is some example:</p>

<pre><code>var text = ""test"",
    key  = ""us5N0PxHAWuIgb0/Qc2sh5OdWBbXGady"",
    iv   = ""zAvR2NI87bBx746n"";

key = CryptoJS.enc.Base64.parse(key);
iv  = CryptoJS.enc.Base64.parse(iv);

crypted = CryptoJS.AES.encrypt(text, key, { iv: iv });
</code></pre>

<p>where key is <strong>32</strong> bytes, IV is <strong>16</strong>. CryptoJS requires to parse it, and after <code>CryptoJS.enc.Base64.parse()</code> I get 48 and 24 bytes accordingly. I expect that those values will get truncated to required <strong>256-bit AES</strong> length, and further expansion to n bytes will be irrelevant, and so resulting ciphertext will be the same.</p>

<p>But that's not actually happening. When I pass to CryptoJS.AES.encrypt() larger size key and <em>even</em> IV, it's producing different output. So my question is, why? What is the difference between <strong>CryptoJS</strong>  library and <strong>OpenSSL</strong> in this case?</p>
","<p>Looks like I've got it.</p>

<p>If you tend to pass custom <code>key</code> and <code>IV</code> in using <strong>CryptoJS</strong>, make sure that (assuming that <code>CryptoJS.enc.Base64.parse()</code> gives <strong>HEX</strong> string, which is used in <code>CryptoJS.AES.encrypt()</code>).</p>

<p>Taking this example, with <strong>Base64</strong> key and iv (length=22), which <strong>CryptoJS</strong> encrypts as <strong>AES-256</strong>:</p>

<pre><code>var message = ""some_secret_message"";

var key = ""6Le0DgMTAAAAANokdEEial""; //length=22
var iv  = ""mHGFxENnZLbienLyANoi.e""; //length=22

key = CryptoJS.enc.Base64.parse(key);
//key is now e8b7b40e031300000000da247441226a, length=32
iv = CryptoJS.enc.Base64.parse(iv);
//iv is now 987185c4436764b6e27a72f2fffffffd, length=32

var cipherData = CryptoJS.AES.encrypt(message, key, { iv: iv });

var data = CryptoJS.AES.decrypt(cipherData, key, { iv: iv });
//data contains ""some_secret_message""
</code></pre>

<p>Length of the <code>key</code> is 32 bytes for <strong>AES-256</strong>. (16 bytes if you want to get <strong>AES-128</strong>. If more, CryptoJS will switch to higher key length). In other case on decrypt you will get an empty message. Example:</p>

<pre><code>var message = ""some_secret_message"";

var key = ""6Le0DgMTAAAAANokdEEial1""; //length=23
var iv  = ""mHGFxENnZLbienLyANoi.e""; //length=22

key = CryptoJS.enc.Base64.parse(key); // length = 17 bytes
//key is now e8b7b40e031300000000da247441226a5d, length=34 (hex encoded)
iv = CryptoJS.enc.Base64.parse(iv); // length = 16 bytes
//iv is now 987185c4436764b6e27a72f2fffffffd, length=32 (hex encoded)

var cipherData = CryptoJS.AES.encrypt(message, key, { iv: iv });

var data = CryptoJS.AES.decrypt(cipherData, key, { iv: iv });
//data contains """" - an empty string
</code></pre>

<p>Also, from what I can see, only <code>x % 8 == 0</code> bytes of such use case gives valid result.</p>

<p>Length of <code>IV</code> should be 22 bytes (when Base64 encoded), and while transforming with <code>CryptoJS.enc.Base64.parse()</code> you will get 16 bytes (32 hex encoded), which is max for <strong>AES-256</strong> block size. Everything more than that will get truncated.</p>

<pre><code>var message = ""some_secret_message"";

var key = ""6Le0DgMTAAAAANokdEEial""; //length=22
var iv  = ""mHGFxENnZLbienLyANoi.e""; //length=22

key = CryptoJS.enc.Base64.parse(key); // length=16 bytes
//key is now e8b7b40e031300000000da247441226a5d, length=32 (hex encoded)
iv = CryptoJS.enc.Base64.parse(iv); // length=16 bytes
//iv is now 987185c4436764b6e27a72f2fffffffd, length=32 (hex encoded)

var cipherData = CryptoJS.AES.encrypt(message, key, { iv: iv });

var key = ""6Le0DgMTAAAAANokdEEial""; //length=22
var iv  = ""mHGFxENnZLbienLyANoi.e123""; //length=25

key = CryptoJS.enc.Base64.parse(key); // length = 16 bytes
//key is now e8b7b40e031300000000da247441226a5d, length=32 (hex encoded)
iv = CryptoJS.enc.Base64.parse(iv); // length = 18 bytes
//iv is now 987185c4436764b6e27a72f2fffffffded76, length=36 (hex encoded)

var data = CryptoJS.AES.decrypt(cipherData, key, { iv: iv }); //data contains ""some_secret_message"", so additional ""123"" in IV is irrelevant.
</code></pre>
","22590","<javascript><cryptojs>","6","13","1","2017-08-08 14:20:07","29561008","0","5","3042856","","2017-08-08 14:20:07","2015-04-08 11:05:01",""
"26951949","How to use CryptoJS with Angular","<p>All is in the title. I want to use the CrytoJS lib in an AngularJS application and I can't get rid of this.</p>

<p>I install crytoJS with bower:</p>

<pre><code>bower install cryptojslib
</code></pre>

<p>Then I load the lib I need :</p>

<pre><code>&lt;script type=""text/javascript"" src=""/public/system/lib/cryptojslib/rollups/md5.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""/public/system/lib/cryptojslib/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>And I try to use the CryptoJS like that :</p>

<pre><code>var pwd = CryptoJS.MD5(params.email+'|'+params.password).toString(CryptoJS.enc.Base64);
</code></pre>

<p>When I run this code, I've got the following error :</p>

<pre><code>'CryptoJS is not defined'
</code></pre>

<p>I've read that it should be possible to wrap the CryptoJS into a module but I don't know how to do.</p>

<p>Any help would be greatly appreciated.</p>

<p>JM.</p>
","<p>Shouldn't be any problems with AngularJS and CryptoJS. I setup a quick Plunker that has a hash created in a controller. No errors...</p>

<p><a href=""http://plnkr.co/edit/kzrr3EdHNXELVof6DVSp?p=preview"" rel=""noreferrer"">http://plnkr.co/edit/kzrr3EdHNXELVof6DVSp?p=preview</a></p>

<p>In the controller:</p>

<pre><code>$scope.hash = CryptoJS.MD5(""Message"");
</code></pre>

<p>In the HTML:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js""&gt;&lt;/script&gt;
</code></pre>

<p>Is this different than what you are trying?</p>
","20779","<angularjs><cryptojs>","3","5","2","2017-08-11 06:18:16","","2","3","","","","2014-11-15 23:23:12",""
"26951949","How to use CryptoJS with Angular","<p>All is in the title. I want to use the CrytoJS lib in an AngularJS application and I can't get rid of this.</p>

<p>I install crytoJS with bower:</p>

<pre><code>bower install cryptojslib
</code></pre>

<p>Then I load the lib I need :</p>

<pre><code>&lt;script type=""text/javascript"" src=""/public/system/lib/cryptojslib/rollups/md5.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""/public/system/lib/cryptojslib/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>And I try to use the CryptoJS like that :</p>

<pre><code>var pwd = CryptoJS.MD5(params.email+'|'+params.password).toString(CryptoJS.enc.Base64);
</code></pre>

<p>When I run this code, I've got the following error :</p>

<pre><code>'CryptoJS is not defined'
</code></pre>

<p>I've read that it should be possible to wrap the CryptoJS into a module but I don't know how to do.</p>

<p>Any help would be greatly appreciated.</p>

<p>JM.</p>
","<p>include the jsfile from rollups folder. </p>

<p>Even I was also getting the same error 'CryptoJS is not defined'. After this change, CryptoJS object was available</p>



<pre><code>var hashObj = CryptoJS.SHA512(myString); 
var hashString = hash.toString(CryptoJS.enc.HEX);
</code></pre>
","20779","<angularjs><cryptojs>","3","0","2","2017-08-11 06:18:16","","2","3","","","","2014-11-15 23:23:12",""
"22875419","cryptojs: How to generate AES passphrase","<p>I want to generate a 256bit password for my AES encryption. When I check the password after the encryption  it is different from my initial password. What am I doing wrong? Or is there some security mechanism I am not aware of?</p>

<p>My code:</p>

<pre><code>password=Generate_key();

var encrypted = CryptoJS.AES.encrypt(""Message"", password);

//Those two should be the same
document.write(password+""&lt;br&gt;"");
document.write(encrypted.key);


function Generate_key() {
    var key = """";
    var hex = ""0123456789abcdef"";

    for (i = 0; i &lt; 64; i++) {
        key += hex.charAt(Math.floor(Math.random() * 16));
        //Initially this was charAt(chance.integer({min: 0, max: 15}));
    }
    return key;
}
</code></pre>

<p>The output is i.e.</p>

<blockquote>
  <p>0b05308c9a00f07044416bad7a51bacd282fc5c0c999551a4ff15c302b268b20
  4df875993770411044fb35953166ee7833c32ca0741e9fec091dfa10138039e8</p>
</blockquote>

<p>Is this normal or am I doing something wrong here?
Thanks for help!</p>
","<p>Encryption is done with a key, which is a set of binary bits, not a password, which implies a human-readable string.</p>

<p>To go from a password to a key, one can use a Password Based Key Derivation Function, such as PBKDF2.  Crypto-JS already has a <a href=""https://code.google.com/p/crypto-js/#PBKDF2"" rel=""noreferrer"">PBKDF2 function built-in</a>, i.e.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var salt = CryptoJS.lib.WordArray.random(128/8);

    var key128Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32 });
    var key256Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 256/32 });
    var key512Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 512/32 });

    var key512Bits1000Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 512/32, iterations: 1000 });
&lt;/script&gt;
</code></pre>

<p>In general, use as high an iteration count as you can get away with. </p>

<p>Salt should be a random value, as in the example above; you'll need, of course, to store that value along with the iteration count in order to get the same key given the same passphrase.</p>
","19599","<encryption><passwords><aes><cryptojs>","8","14","2","2015-12-27 21:41:43","22876250","1","2","","","","2014-04-05 01:11:11",""
"22875419","cryptojs: How to generate AES passphrase","<p>I want to generate a 256bit password for my AES encryption. When I check the password after the encryption  it is different from my initial password. What am I doing wrong? Or is there some security mechanism I am not aware of?</p>

<p>My code:</p>

<pre><code>password=Generate_key();

var encrypted = CryptoJS.AES.encrypt(""Message"", password);

//Those two should be the same
document.write(password+""&lt;br&gt;"");
document.write(encrypted.key);


function Generate_key() {
    var key = """";
    var hex = ""0123456789abcdef"";

    for (i = 0; i &lt; 64; i++) {
        key += hex.charAt(Math.floor(Math.random() * 16));
        //Initially this was charAt(chance.integer({min: 0, max: 15}));
    }
    return key;
}
</code></pre>

<p>The output is i.e.</p>

<blockquote>
  <p>0b05308c9a00f07044416bad7a51bacd282fc5c0c999551a4ff15c302b268b20
  4df875993770411044fb35953166ee7833c32ca0741e9fec091dfa10138039e8</p>
</blockquote>

<p>Is this normal or am I doing something wrong here?
Thanks for help!</p>
","<p>I found the solution. You can define your own key using
<strong>var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });</strong></p>

<p>So my source code is:</p>

<pre><code>key=CryptoJS.enc.Hex.parse(Generate_key());
iv=CryptoJS.enc.Hex.parse(Generate_key());
var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>
","19599","<encryption><passwords><aes><cryptojs>","8","1","2","2015-12-27 21:41:43","22876250","1","2","","","","2014-04-05 01:11:11",""
"20519166","Can't decrypt string with CryptoJS","<p>I'm trying to encode/decode data using CryptoJS, as a preliminar test for the code I want to develop. This is the code I'm using for encrypting:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var message = ""Secret Message"";
var key = CryptoJS.enc.Hex.parse('36ebe205bcdfc499a25e6923f4450fa8');
var iv  = CryptoJS.enc.Hex.parse('be410fea41df7162a679875ec131cf2c');

// Encription. Works ok
var encrypted = CryptoJS.AES.encrypt(
        message,key,
        {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        }
    );
console.log('encrypted:'+encrypted.ciphertext.toString());
&lt;script&gt;
</code></pre>

<p>This is the first test I use for decrypting. It works OK, returning <code>3f0e590d2617dc7007b89350bd590409</code></p>

<pre><code>// Decription. Works ok with ""encrypted"" parameter
var decrypted = CryptoJS.AES.decrypt(
        encrypted,key,
        {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        }
    );
console.log('decrypted:'+decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Let's notice that <code>encrypted</code> parameter is the results from the previous call to <code>CryptoJS.AES.encrypt</code>. It's an object.</p>

<p>The problem I have is when I try to decrypt directly the string:</p>

<pre><code>// Decription. It fails with manual data
var manual_data = CryptoJS.enc.Hex.parse('3f0e590d2617dc7007b89350bd590409');
var decrypted = CryptoJS.AES.decrypt(
        manual_data,key,
        {
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        }
    );
console.log('decrypted, by hand:'+decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>It returns an ""empty"" object (an empty string in the above example). It seems like there is some data that CryptoJS.AES.decrypt needs which is stored into the encrypted object of the first example but missing from the wordarray of the second example.</p>

<p>Does anybody knows why is this happening?</p>
","<p>I have been messing with this a while and I think I have found your problem. The main problem is this line <code>encrypted.ciphertext.toString()</code>. What you want is just <code>encrypted.toString()</code>. </p>

<p>The <code>toString</code> function is defined for this object by CryptoJS and it returns the encrypted message that can be sent around safely. So if we change that we will have something like this:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(
  message,
  key,
  {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  }
);
console.log('            encrypted: '+encrypted.toString());
</code></pre>

<p>This will output <code>Pw5ZDSYX3HAHuJNQvVkECQ==</code> instead of <code>3f0e590d2617dc7007b89350bd590409</code>. The reason your second function is working is because it doesn't use <code>encrypted.ciphertext.toString()</code> it just uses the actual object so no changes on that one. For the last one we will have the change the wrong text you were using to the new text that is returned without the <code>ciphertext</code> part but we also have to remove the <code>CryptoJS.enc.Hex.parse</code>. I don't really know what you were doing here but I can investigate if you meant something by that. </p>

<pre><code>var manual_data = 'Pw5ZDSYX3HAHuJNQvVkECQ==';
var decrypted = CryptoJS.AES.decrypt(
  manual_data,
  key,
  {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  }
);
console.log('   decrypted, by hand: '+decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>This should log the right stuff. </p>

<p>I have even created a <a href=""http://jsbin.com/oHEKIZEB/1/"" rel=""noreferrer"">JSBin</a> for this. It is my first time using JSBin so I hope I did it right. </p>
","19529","<javascript><encryption><cryptojs>","11","20","1","2017-03-21 13:47:24","21298522","0","3","","","","2013-12-11 12:28:45",""
"51005488","how to use CryptoJS in javascript","<p>I used <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> instead of <code>nodejs</code> crypto module because I just use the native JavaScriptbut some codes can't work:</p>

<pre><code>function aesEncrypt(text, secKey) {
  const _text = text
  const lv = new Buffer('0102030405060708', 'binary')
  const _secKey = new Buffer(secKey, 'binary')
  const cipher = crypto.createCipheriv('AES-128-CBC', _secKey, lv)
  let encrypted = cipher.update(_text, 'utf8', 'base64')
  encrypted += cipher.final('base64')
  return encrypted
}
</code></pre>

<p>So how should I modify these codes?</p>
","<p>Here's a sample on how to use CryptoJs in webclient:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// INIT
var myString   = ""blablabla Card game bla"";
var myPassword = ""myPassword"";

// PROCESS
var encrypted = CryptoJS.AES.encrypt(myString, myPassword);
var decrypted = CryptoJS.AES.decrypt(encrypted, myPassword);
document.getElementById(""demo0"").innerHTML = myString;
document.getElementById(""demo1"").innerHTML = encrypted;
document.getElementById(""demo2"").innerHTML = decrypted;
document.getElementById(""demo3"").innerHTML = decrypted.toString(CryptoJS.enc.Utf8);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
&lt;/head&gt;


  
  &lt;strong&gt;&lt;label&gt;Original String:&lt;/label&gt;&lt;/strong&gt;
  &lt;span id=""demo0""&gt;&lt;/span&gt;

  &lt;br&gt;
  &lt;br&gt;
  
  &lt;strong&gt;&lt;label&gt;Encrypted:&lt;/label&gt;&lt;/strong&gt;
  &lt;span id=""demo1""&gt;&lt;/span&gt;

  &lt;br&gt;
  &lt;br&gt;
  
  &lt;strong&gt;&lt;label&gt;Decrypted:&lt;/label&gt;&lt;/strong&gt;
  &lt;span id=""demo2""&gt;&lt;/span&gt;

  &lt;br&gt; 
  &lt;br&gt;

  &lt;strong&gt;&lt;label&gt;String after Decryption:&lt;/label&gt;&lt;/strong&gt;
  &lt;span id=""demo3""&gt;&lt;/span&gt;

  
  &lt;br /&gt;
  &lt;br /&gt;
 </code></pre>
</div>
</div>
</p>

<h3>NB:</h3>

<p>You might want to use CDN if you don't want to use node modules. </p>
","19227","<javascript><node.js><cryptojs>","-4","8","3","2019-05-13 11:22:35","","6","1","8011544","","2018-06-23 22:54:18","2018-06-23 22:16:51",""
"51005488","how to use CryptoJS in javascript","<p>I used <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> instead of <code>nodejs</code> crypto module because I just use the native JavaScriptbut some codes can't work:</p>

<pre><code>function aesEncrypt(text, secKey) {
  const _text = text
  const lv = new Buffer('0102030405060708', 'binary')
  const _secKey = new Buffer(secKey, 'binary')
  const cipher = crypto.createCipheriv('AES-128-CBC', _secKey, lv)
  let encrypted = cipher.update(_text, 'utf8', 'base64')
  encrypted += cipher.final('base64')
  return encrypted
}
</code></pre>

<p>So how should I modify these codes?</p>
","<p>I have been very pleased with forge (node-forge). When working with crypto, sometimes simply better error messages make all the difference.</p>

<p><a href=""https://github.com/digitalbazaar/forge"" rel=""nofollow noreferrer"">https://github.com/digitalbazaar/forge</a></p>

<p>Not sure whether this goes against the ""just use native javascript"" condition, but it is available as a simple package, is well documented/easy to use, and throws helpful errors on failure.</p>

<p>Caveat: I could not get forge to work with Buffer objects, but had immediate success using forge's built-in base64/utf8 utilities and buffers.</p>
","19227","<javascript><node.js><cryptojs>","-4","0","3","2019-05-13 11:22:35","","6","1","8011544","","2018-06-23 22:54:18","2018-06-23 22:16:51",""
"51005488","how to use CryptoJS in javascript","<p>I used <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> instead of <code>nodejs</code> crypto module because I just use the native JavaScriptbut some codes can't work:</p>

<pre><code>function aesEncrypt(text, secKey) {
  const _text = text
  const lv = new Buffer('0102030405060708', 'binary')
  const _secKey = new Buffer(secKey, 'binary')
  const cipher = crypto.createCipheriv('AES-128-CBC', _secKey, lv)
  let encrypted = cipher.update(_text, 'utf8', 'base64')
  encrypted += cipher.final('base64')
  return encrypted
}
</code></pre>

<p>So how should I modify these codes?</p>
","<p>How about CryptoJS?</p>

<p>It's a solid crypto library, with a lot of functionality. It implements hashers, HMAC, PBKDF2 and ciphers. In this case ciphers is what you need. Check out the quick-start quide on the project's homepage.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code> var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");
//U2FsdGVkX18ZUVvShFSES21qHsQEqZXMxQ9zgHy+bu0=

var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
//4d657373616765


document.getElementById(""demo1"").innerHTML = encrypted;
document.getElementById(""demo2"").innerHTML = decrypted;
document.getElementById(""demo3"").innerHTML = decrypted.toString(CryptoJS.enc.Utf8);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>Full working sample actually is:

    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;

&lt;br&gt;&lt;br&gt;
&lt;label&gt;encrypted&lt;/label&gt;
&lt;div id=""demo1""&gt;&lt;/div&gt;
&lt;br&gt;

&lt;label&gt;decrypted&lt;/label&gt;
&lt;div id=""demo2""&gt;&lt;/div&gt;

&lt;br&gt;
&lt;label&gt;Actual Message&lt;/label&gt;
&lt;div id=""demo3""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","19227","<javascript><node.js><cryptojs>","-4","1","3","2019-05-13 11:22:35","","6","1","8011544","","2018-06-23 22:54:18","2018-06-23 22:16:51",""
"45068925","How to use CryptoJS with Angular 4","<p>When I was not using Angular 4, I would just put the <code>script</code> tags for the library. Even when I put the <code>script</code> tags in the <code>index.html</code> file it is not recognizing <code>CryptoJS</code>. Is there a way to use the library or a Angular equivalent? </p>
","<p>Install using NPM and import below statement in you component file.  </p>

<pre><code>npm install crypto-js

import * as crypto from 'crypto-js';
</code></pre>

<p>now you can use crypto in your component file.</p>
","18600","<angular><cryptojs>","16","29","3","2019-10-07 19:10:47","45069146","1","5","","","","2017-07-12 23:11:10",""
"45068925","How to use CryptoJS with Angular 4","<p>When I was not using Angular 4, I would just put the <code>script</code> tags for the library. Even when I put the <code>script</code> tags in the <code>index.html</code> file it is not recognizing <code>CryptoJS</code>. Is there a way to use the library or a Angular equivalent? </p>
","<p>Use following command to install cryptoJS</p>

<pre><code>npm install crypto-js --save
</code></pre>

<p>You can then build a <strong>AESEncryptDecryptService</strong> service.</p>

<pre><code>import { Injectable } from '@angular/core';
import * as CryptoJS from 'crypto-js';

@Injectable({
  providedIn: 'root'
})
export class AESEncryptDecryptService {

  secretKey = ""YourSecretKeyForEncryption&amp;Descryption"";
  constructor() { }

  encrypt(value : string) : string{
    return CryptoJS.AES.encrypt(value, this.secretKey.trim()).toString();
  }

  decrypt(textToDecrypt : string){
    return CryptoJS.AES.decrypt(textToDecrypt, this.secretKey.trim()).toString(CryptoJS.enc.Utf8);
  }
}
</code></pre>

<p>In your component, Import &amp; Inject this service</p>

<pre><code>import { AESEncryptDecryptService } from '../services/aesencrypt-decrypt.service'; 


constructor(private _AESEncryptDecryptService: AESEncryptDecryptService) { }
</code></pre>

<p>Use encrypt / decrypt functions</p>

<pre><code>let encryptedText = _self._AESEncryptDecryptService.encrypt(""Hello World"");
let decryptedText = _self._AESEncryptDecryptService.decrypt(encryptedText);
</code></pre>
","18600","<angular><cryptojs>","16","1","3","2019-10-07 19:10:47","45069146","1","5","","","","2017-07-12 23:11:10",""
"45068925","How to use CryptoJS with Angular 4","<p>When I was not using Angular 4, I would just put the <code>script</code> tags for the library. Even when I put the <code>script</code> tags in the <code>index.html</code> file it is not recognizing <code>CryptoJS</code>. Is there a way to use the library or a Angular equivalent? </p>
","<p>Documentation is at <a href=""https://cryptojs.gitbook.io/docs/"" rel=""nofollow noreferrer"">https://cryptojs.gitbook.io/docs/</a> The import for Angular 6 should be the following:</p>

<pre><code>import * as cryptoJS from 'crypto-js';
</code></pre>
","18600","<angular><cryptojs>","16","0","3","2019-10-07 19:10:47","45069146","1","5","","","","2017-07-12 23:11:10",""
"29509934","Encrypt with CryptoJS and decrypt with PHP","<p>On the client side (mobile device) I encrypt a users password with CryptoJS:</p>

<pre><code>var lib_crypt = require('aes');

$.loginButton.addEventListener('click', function(e){

var key = lib_crypt.CryptoJS.enc.Hex.parse('bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3');
var iv  = lib_crypt.CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = lib_crypt.CryptoJS.AES.encrypt($.passwordInput.value, key, { iv: iv });

var password_base64 = encrypted.ciphertext.toString(lib_crypt.CryptoJS.enc.Base64); 
return password_base64; 
});
</code></pre>

<p>On the server side i want to decrypt it with mcrypt_decrypt:</p>

<pre><code>function decryptPassword($password)
{
    $key = pack('H*', ""bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3"");
    $ciphertext_dec = base64_decode($password);
    $iv_dec = ""101112131415161718191a1b1c1d1e1f"";

    $ciphertext_dec = substr($ciphertext_dec, 16);
    $decryptedPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);

    return trim($decryptedPassword);
}
</code></pre>

<p>I use the same key and IV, what do I do wrong?</p>
","<p>You're not doing the same thing on both sides.</p>

<h1>IV</h1>

<p>You did parse the IV in CryptoJS, but forgot to do it in PHP:</p>

<pre><code>$iv_dec = pack('H*', ""101112131415161718191a1b1c1d1e1f"");
</code></pre>

<p>To fix that your IV is wrong, you probably noticed that the first 16 bytes are gibberish. That happens when the IV is wrong. Note that CryptoJS uses CBC mode by default, so the IV has only influence on the first block during decryption. <strong>Remove</strong> this:</p>

<pre><code>$ciphertext_dec = substr($ciphertext_dec, 16);
</code></pre>

<h1>Padding</h1>

<p>You probably noticed that most plaintexts don't come out right. They end with some strange repeated characters at the end. This is the PKCS#7 padding that is applied by default in CryptoJS. You have to remove the padding yourself in PHP. Good thing is that Maarten Bodewes has provided a proper copy paste solution for this <a href=""https://stackoverflow.com/a/27590539/1816580"">here</a>.</p>

<p><code>trim()</code> might be appropriate for ZeroPadding, but not when a proper padding scheme like the one defined in PKCS#7 is used. You may remove the <code>trim()</code> call altogether, because it is not useful and may result in unexpected plaintext, becauses zero bytes and whitespace is trimmed from the beginning and end.</p>
","16173","<javascript><php><encryption><mcrypt><cryptojs>","7","0","3","2018-11-01 10:37:13","29511152","3","8","1816580","","2015-04-08 09:44:57","2015-04-08 08:45:26",""
"29509934","Encrypt with CryptoJS and decrypt with PHP","<p>On the client side (mobile device) I encrypt a users password with CryptoJS:</p>

<pre><code>var lib_crypt = require('aes');

$.loginButton.addEventListener('click', function(e){

var key = lib_crypt.CryptoJS.enc.Hex.parse('bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3');
var iv  = lib_crypt.CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = lib_crypt.CryptoJS.AES.encrypt($.passwordInput.value, key, { iv: iv });

var password_base64 = encrypted.ciphertext.toString(lib_crypt.CryptoJS.enc.Base64); 
return password_base64; 
});
</code></pre>

<p>On the server side i want to decrypt it with mcrypt_decrypt:</p>

<pre><code>function decryptPassword($password)
{
    $key = pack('H*', ""bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3"");
    $ciphertext_dec = base64_decode($password);
    $iv_dec = ""101112131415161718191a1b1c1d1e1f"";

    $ciphertext_dec = substr($ciphertext_dec, 16);
    $decryptedPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);

    return trim($decryptedPassword);
}
</code></pre>

<p>I use the same key and IV, what do I do wrong?</p>
","<p>Hello,</p>

<p>in order to achieve this it should be considered to use the key and iv with 32 hex digits each, i had to solve exactly this doing my stuff and here is the way it goes</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
//The key and iv should be 32 hex digits each, any hex digits you want, but it needs to be 32 on length each
var key = CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef"");
var iv =  CryptoJS.enc.Hex.parse(""abcdef9876543210abcdef9876543210"");
/*
if you wish to have a more friendly key, you can convert letters to Hex this way:
var a = ""D"";
var hex_D = a.charCodeAt(0).toString(16);
just to mention,
if it were to binary, it would be:
var binary_D = a.charCodeAt(0).toString(2);
*/

var secret = ""Hi, this will be seen uncrypted later on"";

//crypted
var encrypted = CryptoJS.AES.encrypt(secret, key, {iv:iv});
//and the ciphertext put to base64
encrypted = encrypted.ciphertext.toString(CryptoJS.enc.Base64);    
//Assuming you have control on the server side, and know the key and iv hexes(we do),
//the encrypted var is all you need to pass through ajax,
//Let's follow with welcomed pure JS style, to reinforce one and other concept if needed
var xh = new XMLHttpRequest();
xh.open(""POST"", ""decrypt_in_php.php"", true);
xh.setRequestHeader(""Content-type"", ""application/x-www-form-urlencoded"");
xh.send(""encrypted=""+encodeURIComponent(encrypted));
&lt;/script&gt;
</code></pre>

<p>And now receiving and decrypting in PHP</p>

<pre><code>&lt;?php
//Here we have the key and iv which we know, because we have just chosen them on the JS,
//the pack acts just like the parse Hex from JS

$key = pack(""H*"", ""0123456789abcdef0123456789abcdef"");
$iv =  pack(""H*"", ""abcdef9876543210abcdef9876543210"");

//Now we receive the encrypted from the post, we should decode it from base64,
$encrypted = base64_decode($_POST[""encrypted""]);
$shown = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $encrypted, MCRYPT_MODE_CBC, $iv);

echo $shown;
//Although the decrypted is shown, there may be needed to trim and str_replace some \r \n \x06 \x05, if there is not a better ""trim"" way to do it though
?&gt;
</code></pre>

<p>With this we will have back the ""Hi, this will be seen uncrypted later on""
:)</p>
","16173","<javascript><php><encryption><mcrypt><cryptojs>","7","17","3","2018-11-01 10:37:13","29511152","3","8","1816580","","2015-04-08 09:44:57","2015-04-08 08:45:26",""
"29509934","Encrypt with CryptoJS and decrypt with PHP","<p>On the client side (mobile device) I encrypt a users password with CryptoJS:</p>

<pre><code>var lib_crypt = require('aes');

$.loginButton.addEventListener('click', function(e){

var key = lib_crypt.CryptoJS.enc.Hex.parse('bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3');
var iv  = lib_crypt.CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = lib_crypt.CryptoJS.AES.encrypt($.passwordInput.value, key, { iv: iv });

var password_base64 = encrypted.ciphertext.toString(lib_crypt.CryptoJS.enc.Base64); 
return password_base64; 
});
</code></pre>

<p>On the server side i want to decrypt it with mcrypt_decrypt:</p>

<pre><code>function decryptPassword($password)
{
    $key = pack('H*', ""bcb04b7e103a0cd8b54763051cef08bc55abe029fdebae5e1d417e2ffb2a00a3"");
    $ciphertext_dec = base64_decode($password);
    $iv_dec = ""101112131415161718191a1b1c1d1e1f"";

    $ciphertext_dec = substr($ciphertext_dec, 16);
    $decryptedPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);

    return trim($decryptedPassword);
}
</code></pre>

<p>I use the same key and IV, what do I do wrong?</p>
","<p>Here is a solution based on <a href=""https://github.com/brix/crypto-js/issues/154#issuecomment-412251295"" rel=""nofollow noreferrer"">this comment</a>, using <code>openssl_decrypt</code> from PHP.</p>

<p>The <strong>JavaScript</strong> part (development with NodeJS for browsers)  first, install <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> with <code>npm install crypto-js</code>, then your JS code:</p>

<pre><code>import aes from 'crypto-js/aes'
import encHex from 'crypto-js/enc-hex'
import padZeroPadding from 'crypto-js/pad-zeropadding'

// message to encrypt
let msg = ""Hello world"";

// the key and iv should be 32 hex digits each, any hex digits you want, but it needs to be 32 on length each
let key = encHex.parse(""0123456789abcdef0123456789abcdef"");
let iv =  encHex.parse(""abcdef9876543210abcdef9876543210"");

// encrypt the message
let encrypted = aes.encrypt(msg, key, {iv:iv, padding:padZeroPadding}).toString();

// and finally, send this ""encrypted"" string to your server
</code></pre>

<p>On the <strong>PHP</strong> side, your code will look like that:</p>

<pre><code>// we use the same key and IV
$key = hex2bin(""0123456789abcdef0123456789abcdef"");
$iv =  hex2bin(""abcdef9876543210abcdef9876543210"");

// we receive the encrypted string from the post
$encrypted = $_POST['decrypt'];
$decrypted = openssl_decrypt($encrypted, 'AES-128-CBC', $key, OPENSSL_ZERO_PADDING, $iv);
// finally we trim to get our original string
$decrypted = trim($decrypted);
</code></pre>
","16173","<javascript><php><encryption><mcrypt><cryptojs>","7","2","3","2018-11-01 10:37:13","29511152","3","8","1816580","","2015-04-08 09:44:57","2015-04-08 08:45:26",""
"27677236","Encryption in JavaScript and decryption with PHP","<p>I'm encrypting my user password in JavaScript like this:</p>

<pre><code> var encryptedPassword = CryptoJS.AES.encrypt(password, ""Secret Passphrase"");
</code></pre>

<p>It works fine but now I'm trying to decrypt in PHP on the server side like this: </p>

<pre><code> $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
 $decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ""Secret Passphrase"", base64_decode($password), MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>it doesn't works at all, the decrypted password string looks very strange:</p>

<pre><code> string(64) ""&gt;OX2MSv&lt;$i_P\=_6(m,4WT7a""
</code></pre>

<p>Here is the current state of my code in JavaScript after the helpful comments:</p>

<pre><code>    var encryptedPassword = CryptoJS.AES.encrypt(password, ""Secret Passphrase"");
    var ivHex = encryptedPassword.iv.toString();
    var ivSize = encryptedPassword.algorithm.ivSize; // same as blockSize
    var keySize = encryptedPassword.algorithm.keySize;
    var keyHex = encryptedPassword.key.toString();
    var saltHex = encryptedPassword.salt.toString(); // must be sent
    var openSslFormattedCipherTextString = encryptedPassword.toString(); // not used
    var cipherTextHex = encryptedPassword.ciphertext.toString(); // must be sent
</code></pre>

<p>I am sending saltHex and CipherTextHex to the PHP server and I'm using mcrypt_decrypt() like this:</p>

<pre><code> $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), $saltHex);
 $decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ""Secret Passphrase"", base64_decode($cipherTextHex), MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>It still does't work with this updated code.</p>

<p>Can someone help me to decrypt properly with mcrypt_decrypt() PHP function for a simple AES encryption method ? I'm sure I am doing something wrong with the cipher, mcrypt mode and the IV parameters inside my mcrypt_decrypt() method. Thanks if you know.</p>
","<p>You can't decrypt with a random initialisation vector  - you need to use the same IV the data was encrypted with. Also, IIRC, AES defaults to an 8 bit representation of the encrypted data which will need to be handled carefully in transfer over HTTP.</p>
","15875","<javascript><php><encryption><mcrypt><cryptojs>","4","0","2","2017-02-27 20:15:52","27678978","13","3","1106312","","2014-12-28 15:11:27","2014-12-28 14:17:15",""
"27677236","Encryption in JavaScript and decryption with PHP","<p>I'm encrypting my user password in JavaScript like this:</p>

<pre><code> var encryptedPassword = CryptoJS.AES.encrypt(password, ""Secret Passphrase"");
</code></pre>

<p>It works fine but now I'm trying to decrypt in PHP on the server side like this: </p>

<pre><code> $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND);
 $decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ""Secret Passphrase"", base64_decode($password), MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>it doesn't works at all, the decrypted password string looks very strange:</p>

<pre><code> string(64) ""&gt;OX2MSv&lt;$i_P\=_6(m,4WT7a""
</code></pre>

<p>Here is the current state of my code in JavaScript after the helpful comments:</p>

<pre><code>    var encryptedPassword = CryptoJS.AES.encrypt(password, ""Secret Passphrase"");
    var ivHex = encryptedPassword.iv.toString();
    var ivSize = encryptedPassword.algorithm.ivSize; // same as blockSize
    var keySize = encryptedPassword.algorithm.keySize;
    var keyHex = encryptedPassword.key.toString();
    var saltHex = encryptedPassword.salt.toString(); // must be sent
    var openSslFormattedCipherTextString = encryptedPassword.toString(); // not used
    var cipherTextHex = encryptedPassword.ciphertext.toString(); // must be sent
</code></pre>

<p>I am sending saltHex and CipherTextHex to the PHP server and I'm using mcrypt_decrypt() like this:</p>

<pre><code> $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), $saltHex);
 $decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, ""Secret Passphrase"", base64_decode($cipherTextHex), MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>It still does't work with this updated code.</p>

<p>Can someone help me to decrypt properly with mcrypt_decrypt() PHP function for a simple AES encryption method ? I'm sure I am doing something wrong with the cipher, mcrypt mode and the IV parameters inside my mcrypt_decrypt() method. Thanks if you know.</p>
","<p>The problem is that in the CryptoJS code a password is used to derive the key and the IV to be used for AES encryption, but mcrypt only uses the key to encrypt/decrypt. This information needs to be passed to php. Since you don't want to transmit the password, you have to derive the key and IV in the same way in php.</p>

<p>The following code derives the key and IV from a password and salt. It is modeled after the code in my answer <a href=""https://stackoverflow.com/a/27250883/1816580"">here</a> (for more information).</p>

<pre><code>function evpKDF($password, $salt, $keySize = 8, $ivSize = 4, $iterations = 1, $hashAlgorithm = ""md5"") {
    $targetKeySize = $keySize + $ivSize;
    $derivedBytes = """";
    $numberOfDerivedWords = 0;
    $block = NULL;
    $hasher = hash_init($hashAlgorithm);
    while ($numberOfDerivedWords &lt; $targetKeySize) {
        if ($block != NULL) {
            hash_update($hasher, $block);
        }
        hash_update($hasher, $password);
        hash_update($hasher, $salt);
        $block = hash_final($hasher, TRUE);
        $hasher = hash_init($hashAlgorithm);

        // Iterations
        for ($i = 1; $i &lt; $iterations; $i++) {
            hash_update($hasher, $block);
            $block = hash_final($hasher, TRUE);
            $hasher = hash_init($hashAlgorithm);
        }

        $derivedBytes .= substr($block, 0, min(strlen($block), ($targetKeySize - $numberOfDerivedWords) * 4));

        $numberOfDerivedWords += strlen($block)/4;
    }

    return array(
        ""key"" =&gt; substr($derivedBytes, 0, $keySize * 4),
        ""iv""  =&gt; substr($derivedBytes, $keySize * 4, $ivSize * 4)
    );
}
</code></pre>

<p>The salt is generated during encryption in CryptoJS and needs to be sent to php with the ciphertext. Before invoking <code>evpKDF</code> the salt has to be converted to a binary string from hex.</p>

<pre><code>$keyAndIV = evpKDF(""Secret Passphrase"", hex2bin($saltHex));
$decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, 
        $keyAndIV[""key""], 
        hex2bin($cipherTextHex), 
        MCRYPT_MODE_CBC, 
        $keyAndIV[""iv""]);
</code></pre>

<hr>

<p>If only <code>encryptedPassword.toString()</code> was sent to the server, then it is necessary to split the salt and actual ciphertext before use. The format is a proprietary OpenSSL-compatible format with the first 8 bytes being ""Salted__"", the next 8 bytes being the random salt and the rest is the actual ciphertext. Everything together is Base64-encoded.</p>

<pre><code>function decrypt($ciphertext, $password) {
    $ciphertext = base64_decode($ciphertext);
    if (substr($ciphertext, 0, 8) != ""Salted__"") {
        return false;
    }
    $salt = substr($ciphertext, 8, 8);
    $keyAndIV = evpKDF($password, $salt);
    $decryptPassword = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, 
            $keyAndIV[""key""], 
            substr($ciphertext, 16), 
            MCRYPT_MODE_CBC, 
            $keyAndIV[""iv""]);

    // unpad (PKCS#7)
    return substr($decryptPassword, 0, strlen($decryptPassword) - ord($decryptPassword[strlen($decryptPassword)-1]));
}
</code></pre>

<p>The same can be achieved with the OpenSSL extension instead of Mcrypt:</p>

<pre><code>function decrypt($ciphertext, $password) {
    $ciphertext = base64_decode($ciphertext);
    if (substr($ciphertext, 0, 8) != ""Salted__"") {
        return false;
    }
    $salt = substr($ciphertext, 8, 8);
    $keyAndIV = evpKDF($password, $salt);
    $decryptPassword = openssl_decrypt(
            substr($ciphertext, 16), 
            ""aes-256-cbc"",
            $keyAndIV[""key""], 
            OPENSSL_RAW_DATA, // base64 was already decoded
            $keyAndIV[""iv""]);

    return $decryptPassword;
}
</code></pre>
","15875","<javascript><php><encryption><mcrypt><cryptojs>","4","10","2","2017-02-27 20:15:52","27678978","13","3","1106312","","2014-12-28 15:11:27","2014-12-28 14:17:15",""
"26482494","Include CryptoJS in AngularJS application - Can't find variable: CryptoJS","<p>I want to use CryptoJS in my AngularJS application, but I get this error: <code>Can't find variable: CryptoJS</code>.</p>

<p>I included this in my <code>index.html</code>:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/rc4.js""&gt;&lt;/script&gt;
</code></pre>

<p>And tried to encrypt something:</p>

<pre><code>var encrypted = CryptoJS.RC4Drop.encrypt(""Message"", ""Secret Passphrase"");
</code></pre>

<p>Any help would be greatly appreciated.</p>
","<h2>Preface:</h2>

<p>This one took me a bit to sort out. I'm using the SHA1 library, but the implementation should be the same. I'm also using bower to manage my dependencies, but that shouldn't change anything on your end.</p>

<h2>Solution:</h2>

<p>In it's simplest implementation, you want to include the Crypto dependency after all your NG dependencies are wired (this is typically at the end of your <code>index.html</code>). For me I include </p>

<pre><code>&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha1.js""&gt;&lt;/script&gt; 
</code></pre>

<p>after my last NG dependency which is </p>

<pre><code>&lt;script src=""bower_components/angular-route/angular-route.js""&gt;&lt;/script&gt;
</code></pre>

<p>Then I add all my angular scripts (controllers, services, etc).</p>

<p>If you're using Bower, you can install the crypto library via </p>

<pre><code>bower install https://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha1.js --save
</code></pre>

<p>from there you can call <code>CryptoJS.SHA1('some string');</code></p>

<p><strong>note that the value you pass in has to be a string</strong></p>

<p>You can call <code>CryptoJS.SHA1('some string').toString();</code> to get the hashed value.</p>

<h2>Pro tip:</h2>

<p>You can also create a factory that you can inject into all your controls to better manage your dependencies. In my case, I went from MD5 to SHA-1 in about 20min, and this saved a ton of time.</p>

<pre><code>angular.module('someApp')
.factory('crypt', function () {
    return {
        hash: function (value) {
            var str = JSON.stringify(value);
            return CryptoJS.SHA1(str).toString();
        }
    };
});
</code></pre>

<h2>For testing:</h2>

<p>If you're using karma and jasmine to test your app, don't forget to include the path of the crypto library to your <code>karma.conf</code> file in the <code>files</code> section. Otherwise you'll get a persistent <code>Can't find variable: CryptoJS</code> error. </p>
","14461","<javascript><angularjs><encryption><cryptojs>","4","14","1","2014-12-17 00:44:54","27516593","2","2","3475602","","2014-10-21 10:35:48","2014-10-21 08:46:57",""
"44714599","Cipher a string using crypto-js with hex encoding to make it url friendly","<p>I am using <code>crypto-js</code> by <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">brix</a>. I have this function below that handles the encryption of a plain text.</p>

<pre><code>import CryptoJS from 'crypto-js'
import AES from 'crypto-js/aes'

const SECRET = 'I am batman'
const plainText = 'This is Sparta!'

export function enc(plainText){
    // returns something like this U2FsdGVkX184He5Rp991JYAiCSdTwfZs8T3kJUk3zAc=  
    // but with random `/` and I dont want that
    // I want it to be Hex but .toString(CryptoJs.enc.Hex) 
    // is not working, it just returns an '' empty string
    // it's a string, I checked using typeof
    return AES.encrypt(plainText, SECRET).toString();
}
</code></pre>

<p>How do I make the enc(string) to return a <code>Hex</code> value which is url friendly?</p>
","<p>You would likely want to do:</p>

<pre><code>export function dec(cipherText){
   var bytes = CryptoJS.AES.decrypt(cipherText, SECRET);
   var hex = bytes.toString(CryptoJS.enc.Hex);
   var plain = bytes.toString(CryptoJS.enc.Utf8);
   return [hex, plain];
}
</code></pre>

<p>This takes the encrypted <code>base64</code> string and will return the decrypted plaintext and <code>hexadecimal</code>.</p>

<p>EDIT: In regards to your comment and edited question:</p>

<pre><code>const SECRET = 'I am batman'

function enc(plainText){
    var b64 = CryptoJS.AES.encrypt(plainText, SECRET).toString();
    var e64 = CryptoJS.enc.Base64.parse(b64);
    var eHex = e64.toString(CryptoJS.enc.Hex);
    return eHex;
}

function dec(cipherText){
   var reb64 = CryptoJS.enc.Hex.parse(cipherText);
   var bytes = reb64.toString(CryptoJS.enc.Base64);
   var decrypt = CryptoJS.AES.decrypt(bytes, SECRET);
   var plain = decrypt.toString(CryptoJS.enc.Utf8);
   return plain;
}
</code></pre>

<p>The end result takes the <code>base64</code> string, makes it <code>hexadecimal</code> and returns the decrypted string.</p>
","12651","<javascript><encryption><cryptojs>","3","6","1","2019-06-20 05:15:30","44715282","5","4","2889614","","2017-06-23 07:37:40","2017-06-23 06:36:35",""
"33223926","Using CryptoJS to encrypt in Javascript and decrypt in Java","<p>I am trying to encrypt something in JavaScript using the google's <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">https://code.google.com/p/crypto-js/#AES</a> exactly as it is if the example. The problem is that where I am trying to decrypt it in Java the result is way different. The only difference that I can see is the padding (CryptoJs uses Pkcs7 whereas java uses Pkcs5) after reading a bit I realized that Pkcs7 and Pkcs5 are basically the same.</p>

<p>Here is a sample of the code that i do the encryption in Javascript:</p>

<pre class=""lang-js prettyprint-override""><code>var crypto = require('./aes.js');
var login = 'ABCD';
var key = crypto.CryptoJS.enc.Hex.parse('0123456789012345');
var ive  = crypto.CryptoJS.enc.Hex.parse('0123456789012345');

var encrypted = crypto.CryptoJS.AES.encrypt(login, key, {iv: ive});
console.log('encrypted msg = ' + encrypted)
</code></pre>

<p>This is the code that I am using in Java to decrypt it:</p>

<pre class=""lang-java prettyprint-override""><code>public String decrypt(byte[] cipherText) throws Exception {

    String psk = ""0123456789012345"";
    String iv = ""0123456789012345"";
    try {
        String encryptionKey = psk;
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
        final SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(UTF8), ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes(UTF8)));
        return new String(cipher.doFinal(cipherText), UTF8);
    } catch (BadPaddingException | IllegalBlockSizeException | UnsupportedEncodingException | InvalidAlgorithmParameterException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | NoSuchProviderException ex) {
        LOG.log(Level.SEVERE, ex.getMessage(), ex);
        throw new Exception(ex.getMessage());
    }
}
</code></pre>

<p>Do you have any idea why it fails that bad? Is it a different algorithm or do I fail somewhere else? </p>
","<p>You're not using the same key and IV in CryptoJS and Java. The key and IV in the CryptoJS are too short to be valid, because you're parsing a 16 character string as Hex which results in only 8 bytes, but AES supports only key sizes of 128, 192 and 256 bit.</p>

<p>Use </p>

<pre class=""lang-js prettyprint-override""><code>var key = crypto.CryptoJS.enc.Utf8.parse('0123456789012345');
var ive  = crypto.CryptoJS.enc.Utf8.parse('0123456789012345');
</code></pre>

<hr>

<h3>Other considerations:</h3>

<ul>
<li><p>Always use a random IV. Since it doesn't have to be secret, you can prepend it to the ciphertext or send it along in another way.</p></li>
<li><p>Authenticate the ciphertexts with HMAC or use and authenticated mode like GCM to prevent some attacks such as padding oracle attack.</p></li>
</ul>
","11094","<javascript><java><encryption><aes><cryptojs>","4","6","2","2017-07-08 13:13:55","","0","2","1816580","","2015-10-19 21:16:50","2015-10-19 21:06:44",""
"33223926","Using CryptoJS to encrypt in Javascript and decrypt in Java","<p>I am trying to encrypt something in JavaScript using the google's <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">https://code.google.com/p/crypto-js/#AES</a> exactly as it is if the example. The problem is that where I am trying to decrypt it in Java the result is way different. The only difference that I can see is the padding (CryptoJs uses Pkcs7 whereas java uses Pkcs5) after reading a bit I realized that Pkcs7 and Pkcs5 are basically the same.</p>

<p>Here is a sample of the code that i do the encryption in Javascript:</p>

<pre class=""lang-js prettyprint-override""><code>var crypto = require('./aes.js');
var login = 'ABCD';
var key = crypto.CryptoJS.enc.Hex.parse('0123456789012345');
var ive  = crypto.CryptoJS.enc.Hex.parse('0123456789012345');

var encrypted = crypto.CryptoJS.AES.encrypt(login, key, {iv: ive});
console.log('encrypted msg = ' + encrypted)
</code></pre>

<p>This is the code that I am using in Java to decrypt it:</p>

<pre class=""lang-java prettyprint-override""><code>public String decrypt(byte[] cipherText) throws Exception {

    String psk = ""0123456789012345"";
    String iv = ""0123456789012345"";
    try {
        String encryptionKey = psk;
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"", ""SunJCE"");
        final SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(UTF8), ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes(UTF8)));
        return new String(cipher.doFinal(cipherText), UTF8);
    } catch (BadPaddingException | IllegalBlockSizeException | UnsupportedEncodingException | InvalidAlgorithmParameterException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | NoSuchProviderException ex) {
        LOG.log(Level.SEVERE, ex.getMessage(), ex);
        throw new Exception(ex.getMessage());
    }
}
</code></pre>

<p>Do you have any idea why it fails that bad? Is it a different algorithm or do I fail somewhere else? </p>
","<p>Ok, I found the problem. Instead of passing as a parameter the <code>encrypted</code> I should pass <code>encrypted.ciphertext</code>. I now works perfect.</p>
","11094","<javascript><java><encryption><aes><cryptojs>","4","1","2","2017-07-08 13:13:55","","0","2","1816580","","2015-10-19 21:16:50","2015-10-19 21:06:44",""
"11797238","AES encryption in php and then decryption with Javascript (cryptojs)","<p>I'm searching for a way to make a 2 way encryption of a simple text (5 to 6 numbers and/or characters). The catch is that i want to make the encryption in php and then decrypt it via Javascript. For php i've tested using mcrypt_encode and have gotten it to work, hence when i try to decrypt it with javascript (i'm using the Crypto-js library - <a href=""http://code.google.com/p/crypto-js/"">http://code.google.com/p/crypto-js/</a> ) i get no results. Here is the php code i'm using:</p>

<pre><code>$key = ""oijhd981727783hy18274"";
$text = ""1233"";
$td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC,$iv);
echo base64_encode($crypttext);
</code></pre>

<p>and then here is the Javascript code i'm using:</p>

<pre><code>var encrypted = CryptoJS.enc.Base64.parse(""LiJU5oYHXRSNsrjMtCr5o2ev7yDFGZId85gh9MEXPeg="");
var key = 'oijhd981727783hy18274';
var decrypted = CryptoJS.AES.decrypt(encrypted, key);
document.write( decrypted.toString(CryptoJS.enc.Utf8) );
</code></pre>

<p>As i'm just testing, i copy/paste the output from the php straight into the JS and see if it would return any results, however that doesnt happen. As i'm new to the encryption/decryption part i might be missing something. Any suggestions will be greatly appreciated.</p>

<p>On a side note, as i read a lot of suggestions here about using other types of communication to transfer the data, that would not be possible in this case, as i need to pass this string to a third party software, which will bring it over on a secure area, where i have access to edit only the javascript, this is why i'm trying to encrypt the text in php and place it inside the website's source, from where the third party software will read it as it is encrypted and will transfer it to the secure section, where i will need to decrypt it back via Javascript (i dont have access to php there).</p>
","<p>Some time ago I had the same problem. I finally got to use SlowAES from <a href=""http://code.google.com/p/slowaes/"" rel=""nofollow"">http://code.google.com/p/slowaes/</a> with some fixes and ported it to PHP.</p>

<p>Note: The official sources are broken, just as the official PHP port.</p>

<p>Let me know if you're interested. Then I'd open a new repository at GitHub where you can grab everything you need...</p>
","10835","<php><javascript><encryption><mcrypt><cryptojs>","5","0","3","2012-10-24 14:00:39","","3","1","","","","2012-08-03 14:00:21",""
"11797238","AES encryption in php and then decryption with Javascript (cryptojs)","<p>I'm searching for a way to make a 2 way encryption of a simple text (5 to 6 numbers and/or characters). The catch is that i want to make the encryption in php and then decrypt it via Javascript. For php i've tested using mcrypt_encode and have gotten it to work, hence when i try to decrypt it with javascript (i'm using the Crypto-js library - <a href=""http://code.google.com/p/crypto-js/"">http://code.google.com/p/crypto-js/</a> ) i get no results. Here is the php code i'm using:</p>

<pre><code>$key = ""oijhd981727783hy18274"";
$text = ""1233"";
$td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC,$iv);
echo base64_encode($crypttext);
</code></pre>

<p>and then here is the Javascript code i'm using:</p>

<pre><code>var encrypted = CryptoJS.enc.Base64.parse(""LiJU5oYHXRSNsrjMtCr5o2ev7yDFGZId85gh9MEXPeg="");
var key = 'oijhd981727783hy18274';
var decrypted = CryptoJS.AES.decrypt(encrypted, key);
document.write( decrypted.toString(CryptoJS.enc.Utf8) );
</code></pre>

<p>As i'm just testing, i copy/paste the output from the php straight into the JS and see if it would return any results, however that doesnt happen. As i'm new to the encryption/decryption part i might be missing something. Any suggestions will be greatly appreciated.</p>

<p>On a side note, as i read a lot of suggestions here about using other types of communication to transfer the data, that would not be possible in this case, as i need to pass this string to a third party software, which will bring it over on a secure area, where i have access to edit only the javascript, this is why i'm trying to encrypt the text in php and place it inside the website's source, from where the third party software will read it as it is encrypted and will transfer it to the secure section, where i will need to decrypt it back via Javascript (i dont have access to php there).</p>
","<p>So, after some more digging i came to the following online <a href=""http://www.nakov.com/blog/2011/12/26/online-aes-encryptor-decryptor-javascript/"" rel=""noreferrer"">encryptor/decryptor</a> which led me to the <a href=""https://github.com/mdp/gibberish-aes"" rel=""noreferrer"">gibberish-aes at GitHub</a> repository.</p>

<p>Inside one of the comments on the first link i found that this JS library has a php equivalent, which seems to be working reasonably well and is fairly easy to deploy:
<a href=""https://github.com/ivantcholakov/gibberish-aes-php"" rel=""noreferrer"">https://github.com/ivantcholakov/gibberish-aes-php</a></p>

<p>So thanks to Lars for the answer he provided, i would encourage him to open the repository, i'm sure he'll make someone's life a little bit easier :)</p>
","10835","<php><javascript><encryption><mcrypt><cryptojs>","5","5","3","2012-10-24 14:00:39","","3","1","","","","2012-08-03 14:00:21",""
"11797238","AES encryption in php and then decryption with Javascript (cryptojs)","<p>I'm searching for a way to make a 2 way encryption of a simple text (5 to 6 numbers and/or characters). The catch is that i want to make the encryption in php and then decrypt it via Javascript. For php i've tested using mcrypt_encode and have gotten it to work, hence when i try to decrypt it with javascript (i'm using the Crypto-js library - <a href=""http://code.google.com/p/crypto-js/"">http://code.google.com/p/crypto-js/</a> ) i get no results. Here is the php code i'm using:</p>

<pre><code>$key = ""oijhd981727783hy18274"";
$text = ""1233"";
$td = mcrypt_module_open(MCRYPT_RIJNDAEL_256, '', MCRYPT_MODE_CBC, '');
$iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
$crypttext = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $text, MCRYPT_MODE_CBC,$iv);
echo base64_encode($crypttext);
</code></pre>

<p>and then here is the Javascript code i'm using:</p>

<pre><code>var encrypted = CryptoJS.enc.Base64.parse(""LiJU5oYHXRSNsrjMtCr5o2ev7yDFGZId85gh9MEXPeg="");
var key = 'oijhd981727783hy18274';
var decrypted = CryptoJS.AES.decrypt(encrypted, key);
document.write( decrypted.toString(CryptoJS.enc.Utf8) );
</code></pre>

<p>As i'm just testing, i copy/paste the output from the php straight into the JS and see if it would return any results, however that doesnt happen. As i'm new to the encryption/decryption part i might be missing something. Any suggestions will be greatly appreciated.</p>

<p>On a side note, as i read a lot of suggestions here about using other types of communication to transfer the data, that would not be possible in this case, as i need to pass this string to a third party software, which will bring it over on a secure area, where i have access to edit only the javascript, this is why i'm trying to encrypt the text in php and place it inside the website's source, from where the third party software will read it as it is encrypted and will transfer it to the secure section, where i will need to decrypt it back via Javascript (i dont have access to php there).</p>
","<p>From the CryptoJS documentation:</p>

<blockquote>
  <p>For the key, when you pass a string, it's treated as a passphrase and used to derive an actual key and IV. Or you can pass a WordArray that represents the actual key. If you pass the actual key, you must also pass the actual IV.</p>
</blockquote>

<p>So in your line</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, key);
</code></pre>

<p>""oijhd981727783hy18274"" is treated as a passphrase to create a key and not as the actual key.</p>

<p>Passing an IV works like this:</p>

<pre><code>var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>
","10835","<php><javascript><encryption><mcrypt><cryptojs>","5","3","3","2012-10-24 14:00:39","","3","1","","","","2012-08-03 14:00:21",""
"38703443","Keep getting error:0906D06C:PEM routines:PEM_read_bio:no start line","<p>Going crazy trying to solve error on Node.js while trying to contact Xero API.</p>

<p>I've used a bunch of combinations of '.cer' and '.crt' and '.pem'.</p>

<p>I've followed the advice of a number of StackOverflow posters.</p>

<p><a href=""https://stackoverflow.com/questions/38215083/node-js-https-pem-error-error0906d06cpem-routinespem-read-biono-start-line"">Node.js https pem error: error:0906D06C:PEM routines:PEM_read_bio:no start line</a></p>

<pre><code>Error: error:0906D06C:PEM routines:PEM_read_bio:no start line
    at Error (native)
    at Sign.sign (crypto.js:327:26)
    at Xero.oa._createSignature (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/xero/index.js:19:68)
    at exports.OAuth._getSignature (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/xero/node_modules/oauth/lib/oauth.js:90:15)
    at exports.OAuth._prepareParameters (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/xero/node_modules/oauth/lib/oauth.js:300:16)
    at exports.OAuth._performSecureRequest (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/xero/node_modules/oauth/lib/oauth.js:309:31)
    at Xero.call (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/xero/index.js:51:20)
    at /Users/BeardedMac/projects/clause/clause-mean-stack/routes/external.js:47:10
    at Layer.handle [as handle_request] (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/layer.js:95:5)
    at next (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/route.js:131:13)
    at Route.dispatch (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/route.js:112:3)
    at Layer.handle [as handle_request] (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/layer.js:95:5)
    at /Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/index.js:277:22
    at Function.process_params (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/index.js:330:12)
    at next (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/router/index.js:271:10)
    at expressInit (/Users/BeardedMac/projects/clause/clause-mean-stack/node_modules/express/lib/middleware/init.js:33:5)
</code></pre>

<p>Anyone out there have some insight?</p>

<p>The Xero API says it wants an X509 certificate...I'm not even making the call though.</p>
","<p>You need a PEM-encoded key as the <code>xero</code> module merely calls out to node's built-in <code>crypto</code> module to sign some data. Those types of keys start with</p>

<pre>
-----BEGIN RSA PRIVATE KEY-----
</pre>

<p>and end with</p>

<pre>
-----END RSA PRIVATE KEY-----
</pre>

<p>with base64-encoded data in between.</p>

<p>You can generate such a key using the <code>openssl</code> command-line utility:</p>

<pre>
openssl genrsa -out privateKey.pem 2048
</pre>

<p>Then read <code>privateKey.pem</code> in node like:</p>

<pre><code>var fs = require('fs');
var privateKey = fs.readFileSync('/path/to/privateKey.pem');

// pass `privateKey` as the RSA private key to the `xero` module ...
</code></pre>
","10821","<node.js><express><openssl><cryptojs><xero-api>","4","4","1","2016-08-01 17:23:56","38703536","0","2","-1","","2017-05-23 12:02:49","2016-08-01 16:09:54",""
"21180721","AES-256-CBC Mcrypt-PHP decrypt and Crypto-JS Encrypt","<p>I am trying to encrypt in Javascript with CryptoJS and decrypt in PHP. The JS code is:</p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(128/8); 
var key256Bits500Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 256/32, iterations: 500 });
var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f'); // just chosen for an example, usually random as well

encrypted = CryptoJS.AES.encrypt(""Message"", key512Bits1000Iterations, { iv: iv });  
var data_base64 = crypted.ciphertext.toString(CryptoJS.enc.Base64);
var iv_base64   = crypted.iv.toString(CryptoJS.enc.Base64);
var key_base64  = crypted.key.toString(CryptoJS.enc.Base64);
</code></pre>

<p>And the PHP is as follows:</p>

<pre><code>$encrypted = base64_decode($data_base64);
$iv = base64_decode($iv_base64);
$key = base64_decode($key_base64); 

    $plaintext = mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $key, $encrypted, MCRYPT_MODE_CBC, $iv);
echo ($plaintext);  
</code></pre>

<p>This does not return the correct answer.</p>

<p>I am unsure where things are going poorly! I need to do my own IV, but if I do just say:</p>

<pre><code>CryptoJS.AES.Encrypt(""Message"", ""Secret Passphrase"");
var data_base64 = crypted.ciphertext.toString(CryptoJS.enc.Base64);
var iv_base64   = crypted.iv.toString(CryptoJS.enc.Base64);
var key_base64  = crypted.key.toString(CryptoJS.enc.Base64);
</code></pre>

<p>It DOES successfully work in the PHP code -- only the key_base64 isn't something that can be changed, it has to be what the user remembers... And then it gives me a salt to get a key from the passphrase entered and IDK how it managed to get that using CryptoJS</p>
","<p>Your code WILL work if you just fix a few typos there</p>

<p><strong>JS</strong></p>

<pre><code>    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/pbkdf2.js""&gt;&lt;/script&gt;
    &lt;script&gt;
        var salt = CryptoJS.lib.WordArray.random(128/8); 
        var key256Bits500Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 256/32, iterations: 500 });
        var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f'); // just chosen for an example, usually random as well

        var encrypted = CryptoJS.AES.encrypt(""Message"", key256Bits500Iterations, { iv: iv });  
        var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64); 
        var iv_base64   = encrypted.iv.toString(CryptoJS.enc.Base64);       
        var key_base64  = encrypted.key.toString(CryptoJS.enc.Base64);
    &lt;/script&gt;
</code></pre>

<p><strong>PHP</strong></p>

<pre><code>    &lt;?php
        $encrypted = base64_decode(""data_base64""); // data_base64 from JS
        $iv        = base64_decode(""iv_base64"");   // iv_base64 from JS
        $key       = base64_decode(""key_base64"");  // key_base64 from JS

        $plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $key, $encrypted, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );
</code></pre>
","10710","<javascript><php><encryption><aes><cryptojs>","7","15","1","2014-10-28 01:27:41","21227155","0","4","","","","2014-01-17 08:01:37",""
"27248644","How to decrypt a cryptojs AES encrypted message at the java server side?","<p>I have the following cryptojs based javascript encryption/decryption functions which works perfectly fine. </p>

<p>I use a random salt, random iv value and a specific password while encrypting the message using cryptpjs. I reuse the same salt, iv and the password to generate the key while decrypting  the encrypted message.</p>

<p>This part works well..</p>

<pre><code>function  encrypt(){
  var salt = CryptoJS.lib.WordArray.random(128/8);
  var iv = CryptoJS.lib.WordArray.random(128/8);
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key128Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32 }); 
  console.log( 'key128Bits '+ key128Bits);
  var key128Bits100Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key128Bits100Iterations '+ key128Bits100Iterations);
  var encrypted = CryptoJS.AES.encrypt(""Message"", key128Bits100Iterations, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7  });
  console.log('encrypted   '+ encrypted  );
}

function  decrypt(){
  var salt = CryptoJS.enc.Hex.parse(""4acfedc7dc72a9003a0dd721d7642bde"");
  var iv = CryptoJS.enc.Hex.parse(""69135769514102d0eded589ff874cacd"");
  var encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key '+ key);
  var decrypt = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
  var ddd = decrypt.toString(CryptoJS.enc.Utf8); 
  console.log('ddd '+ddd);
} 
</code></pre>

<p>But the issue starts when I try to decrypt the same encrypted text at the java server side.
I want the encrypted message to be decrypted by my java  server code.
Here is the Java code that I wrote:</p>

<pre><code>public static void main(String args[]) throws Exception{
  String password = ""Secret Passphrase"";
  String salt = ""4acfedc7dc72a9003a0dd721d7642bde"";
  String iv = ""69135769514102d0eded589ff874cacd"";
  String encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  byte[] saltBytes = salt.getBytes(); //hexStringToByteArray(salt);
  byte[] ivBytes = iv.getBytes();//hexStringToByteArray(iv);
  IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);        
  SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(password, saltBytes);
  System.out.println( decrypt( encrypted , sKey ,ivParameterSpec));
}

public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {

  KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128/32);
  SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
  SecretKey secretKey = keyFactory.generateSecret(keySpec);
  return new SecretKeySpec(secretKey.getEncoded(), ""AES"");
}

public static String decrypt(String encryptedData, SecretKeySpec sKey, IvParameterSpec ivParameterSpec) throws Exception {

  Cipher c = Cipher.getInstance(""AES"");
  c.init(Cipher.DECRYPT_MODE, sKey, ivParameterSpec);
  byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
  byte[] decValue = c.doFinal(decordedValue);
  String decryptedValue = new String(decValue);
  return decryptedValue;
}
</code></pre>

<p>But I get the following exception:</p>

<pre><code>Exception breakpoint: SecretKeySpec.java:96, java.lang.IllegalArgumentException, Empty key
Exception in thread ""main"" java.lang.IllegalArgumentException: Empty key
at javax.crypto.spec.SecretKeySpec.&lt;init&gt;(SecretKeySpec.java:96)
</code></pre>

<p>I have no idea what I should do</p>
","<p>This part of your code is wrong:</p>

<pre><code>KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128/32);
//-&gt;---------------------------------------------------------------------^^^^^^^
</code></pre>

<p>The <code>128/32</code> value is erroneous. You need either <code>128</code>, <code>192</code> or <code>256</code>. Currently you have the equivalent of <code>4</code>, which seems to result in no output at all from the PBKDF2 function.</p>

<p>Also, in Java you should use <a href=""https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/DatatypeConverter.html#parseHexBinary-java.lang.String-"" rel=""noreferrer""><code>DatatypeConverter.parseHexBinary()</code></a>, or similar, to convert hex into bytes. Currently you are just calling <code>getBytes()</code> which isn't right. </p>

<p>Finally, you need to specify CBC mode and PKCS#5 padding in order to match your Javascript code. So change the line to:</p>

<pre><code>Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
</code></pre>
","10458","<java><encryption><aes><cryptojs>","10","9","2","2014-12-02 23:23:44","27250179","0","4","474189","","2014-12-02 12:57:28","2014-12-02 11:46:35",""
"27248644","How to decrypt a cryptojs AES encrypted message at the java server side?","<p>I have the following cryptojs based javascript encryption/decryption functions which works perfectly fine. </p>

<p>I use a random salt, random iv value and a specific password while encrypting the message using cryptpjs. I reuse the same salt, iv and the password to generate the key while decrypting  the encrypted message.</p>

<p>This part works well..</p>

<pre><code>function  encrypt(){
  var salt = CryptoJS.lib.WordArray.random(128/8);
  var iv = CryptoJS.lib.WordArray.random(128/8);
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key128Bits = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32 }); 
  console.log( 'key128Bits '+ key128Bits);
  var key128Bits100Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key128Bits100Iterations '+ key128Bits100Iterations);
  var encrypted = CryptoJS.AES.encrypt(""Message"", key128Bits100Iterations, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7  });
  console.log('encrypted   '+ encrypted  );
}

function  decrypt(){
  var salt = CryptoJS.enc.Hex.parse(""4acfedc7dc72a9003a0dd721d7642bde"");
  var iv = CryptoJS.enc.Hex.parse(""69135769514102d0eded589ff874cacd"");
  var encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  console.log('salt  '+ salt );
  console.log('iv  '+ iv );
  var key = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 128/32, iterations: 100 });
  console.log( 'key '+ key);
  var decrypt = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
  var ddd = decrypt.toString(CryptoJS.enc.Utf8); 
  console.log('ddd '+ddd);
} 
</code></pre>

<p>But the issue starts when I try to decrypt the same encrypted text at the java server side.
I want the encrypted message to be decrypted by my java  server code.
Here is the Java code that I wrote:</p>

<pre><code>public static void main(String args[]) throws Exception{
  String password = ""Secret Passphrase"";
  String salt = ""4acfedc7dc72a9003a0dd721d7642bde"";
  String iv = ""69135769514102d0eded589ff874cacd"";
  String encrypted = ""PU7jfTmkyvD71ZtISKFcUQ=="";
  byte[] saltBytes = salt.getBytes(); //hexStringToByteArray(salt);
  byte[] ivBytes = iv.getBytes();//hexStringToByteArray(iv);
  IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);        
  SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(password, saltBytes);
  System.out.println( decrypt( encrypted , sKey ,ivParameterSpec));
}

public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {

  KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128/32);
  SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
  SecretKey secretKey = keyFactory.generateSecret(keySpec);
  return new SecretKeySpec(secretKey.getEncoded(), ""AES"");
}

public static String decrypt(String encryptedData, SecretKeySpec sKey, IvParameterSpec ivParameterSpec) throws Exception {

  Cipher c = Cipher.getInstance(""AES"");
  c.init(Cipher.DECRYPT_MODE, sKey, ivParameterSpec);
  byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
  byte[] decValue = c.doFinal(decordedValue);
  String decryptedValue = new String(decValue);
  return decryptedValue;
}
</code></pre>

<p>But I get the following exception:</p>

<pre><code>Exception breakpoint: SecretKeySpec.java:96, java.lang.IllegalArgumentException, Empty key
Exception in thread ""main"" java.lang.IllegalArgumentException: Empty key
at javax.crypto.spec.SecretKeySpec.&lt;init&gt;(SecretKeySpec.java:96)
</code></pre>

<p>I have no idea what I should do</p>
","<p>Thanks to Duncan for the prompt response and advice. I am giving the complete solution that worked for me below for the benefit of others.</p>

<p><strong>Java code to  do the decryption of the cryptojs encrypted message</strong> </p>

<pre><code>public static void main(String args[]) throws Exception{

 String password = ""Secret Passphrase"";
 String salt = ""222f51f42e744981cf7ce4240eeffc3a"";
 String iv = ""2b69947b95f3a4bb422d1475b7dc90ea"";
 String encrypted = ""CQVXTPM2ecOuZk+9Oy7OyGJ1M6d9rW2D/00Bzn9lkkehNra65nRZUkiCgA3qlpzL"";

 byte[] saltBytes = hexStringToByteArray(salt);
 byte[] ivBytes = hexStringToByteArray(iv);
 IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);        
 SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(password, saltBytes);
 System.out.println( decrypt( encrypted , sKey ,ivParameterSpec));

}

public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {

 KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128);
 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
 SecretKey secretKey = keyFactory.generateSecret(keySpec);

 return new SecretKeySpec(secretKey.getEncoded(), ""AES"");
}

public static byte[] hexStringToByteArray(String s) {

 int len = s.length();
 byte[] data = new byte[len / 2];

 for (int i = 0; i &lt; len; i += 2) {
    data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
    + Character.digit(s.charAt(i+1), 16));
 }

  return data;

}

public static String decrypt(String encryptedData, SecretKeySpec sKey, IvParameterSpec ivParameterSpec) throws Exception { 

 Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
 c.init(Cipher.DECRYPT_MODE, sKey, ivParameterSpec);
 byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
 byte[] decValue = c.doFinal(decordedValue);
 String decryptedValue = new String(decValue);

 return decryptedValue;
}
</code></pre>
","10458","<java><encryption><aes><cryptojs>","10","9","2","2014-12-02 23:23:44","27250179","0","4","474189","","2014-12-02 12:57:28","2014-12-02 11:46:35",""
"17780734","CryptoJS AES encryption and JAVA AES decryption value mismatch","<p>I am encrypting a text using CryptoJS AES algorithm on the client side and I am decrypting It on Server side in java, I am getting the exception.</p>

<p><strong>JS code :</strong></p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");
console.info(""encrypted "" + encrypted);
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
var plainText = decrypted.toString(CryptoJS.enc.Utf8)
console.info(""decrypted "" + plainText);
</code></pre>

<p><strong>js output :</strong></p>

<pre><code>encrypted U2FsdGVkX1/uYgVsNZmpbgKQJ8KD+8R8yyYn5+irhoI=
decrypted Message
</code></pre>

<p><strong>Java Code :</strong></p>

<pre><code>import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESJavaScript {
    private SecretKeySpec key;
    private Cipher cipher;
    private int size = 128;
    private static final Charset CHARSET = Charset.forName(""UTF-8""); 

    public AESJavaScript() throws NoSuchAlgorithmException,
            NoSuchPaddingException, NoSuchProviderException {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(size); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        key = new SecretKeySpec(raw, ""AES/CTR/NoPadding"");
        cipher = Cipher.getInstance(""AES/CTR/NoPadding"");
    }

    public void setKey(String keyText) {
        byte[] bText = new byte[size];
        bText = keyText.getBytes(CHARSET);
        key = new SecretKeySpec(bText, ""AES/CTR/NoPadding"");
    }

    public String encrypt(String message) throws InvalidKeyException,
            IllegalBlockSizeException, BadPaddingException {
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encrypted = cipher.doFinal(message.getBytes());
        return byteArrayToHexString(encrypted);
    }

    public String decrypt(String hexCiphertext)
            throws IllegalBlockSizeException, BadPaddingException,
            InvalidKeyException {
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decrypted = cipher.doFinal(hexStringToByteArray(hexCiphertext));
        return byteArrayToHexString(decrypted);
    }

    private static String byteArrayToHexString(byte[] raw) {
        String hex = ""0x"";
        String s = new String(raw);
        for (int x = 0; x &lt; s.length(); x++) {
            char[] t = s.substring(x, x + 1).toCharArray();
            hex += Integer.toHexString((int) t[0]).toUpperCase();
        }
        return hex;
    }

    private static byte[] hexStringToByteArray(String hex) {
        Pattern replace = Pattern.compile(""^0x"");
        String s = replace.matcher(hex).replaceAll("""");

        byte[] b = new byte[s.length() / 2];
        for (int i = 0; i &lt; b.length; i++) {
            int index = i * 2;
            int v = Integer.parseInt(s.substring(index, index + 2), 16);
            b[i] = (byte) v;
        }
        return b;
    }

    public static void main(String[] args) {
        try {
            AESJavaScript ajs = new AESJavaScript();
            ajs.setKey(""Secret Passphrase"");
            String hexCiphertext = ""U2FsdGVkX1/uYgVsNZmpbgKQJ8KD+8R8yyYn5+irhoI="";
            String decrypted = ajs.decrypt(hexCiphertext);
            System.out.println(""decrypted &gt; "" + decrypted);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
</code></pre>

<p><strong>Exception is :</strong></p>

<pre><code>java.security.InvalidKeyException: Invalid AES key length: 17 bytes
    at com.sun.crypto.provider.AESCipher.engineGetKeySize(AESCipher.java:372)
    at javax.crypto.Cipher.passCryptoPermCheck(Cipher.java:1052)
    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1010)
    at javax.crypto.Cipher.implInit(Cipher.java:786)
    at javax.crypto.Cipher.chooseProvider(Cipher.java:849)
    at javax.crypto.Cipher.init(Cipher.java:1213)
    at javax.crypto.Cipher.init(Cipher.java:1153)
    at com.test.jenkins.jenkinsRestart.AESJavaScript.decrypt(AESJavaScript.java:49)
    at com.test.jenkins.jenkinsRestart.AESJavaScript.main(AESJavaScript.java:82)
</code></pre>

<p>Is there anything that I am doing wrong here or Is there anyother simple way to do these kind of encryption and decryption ?</p>
","<p>Your Java code is riddled with errors. Here are a few of them:</p>

<ul>
<li><p>Your initial exception is caused because your <code>""Secret Passphrase""</code> string contains 17 bytes. You need to truncate this to 16 bytes (or pad it to match 24 or 32 bytes). You need to match the behaviour of the CryptoJS library.</p></li>
<li><p>You are trying to hex-decode data that appears to be base64 encoded. Try using <code>DatatypeConverter.parseBase64Binary(hex);</code>.</p></li>
<li><p>You are creating a secret key with the algorithm <code>""AES/CTR/NoPadding""</code>. This in invalid, just use <code>""AES""</code>.</p></li>
<li><p>You must pass an IV/nonce value into  your decryption:</p>

<pre><code>cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(...));
</code></pre>

<p>The value you use will depend upon what CryptoJS is doing. Perhaps it uses all zeroes? Perhaps it generates a random one and you need to store it with the ciphertext?</p></li>
</ul>

<p>This should be enough to get you started.</p>
","9371","<java><javascript><encryption><aes><cryptojs>","3","4","1","2013-07-22 07:02:58","","1","4","","","","2013-07-22 05:50:00",""
"27220297","What are the AES parameters used and steps performed internally by crypto-js while encrypting a message with a password?","<p><strong>Background:</strong> 
The application that I am working on is supposed to work offline. I should encrypt some text data using a password as a key at the java server side. The encrypted data is passed to the HTML5 page and at the client side using crypto-js library the server encrypted data should be decrypted. </p>

<p><strong>My issue:</strong>
In order to encrypt my message in such a way that the client can decrypt it with crypt-js (using a user entered password), I need to know the exact steps that  crypto-js expects while encrypting a message.</p>

<p><strong>What I need to know:</strong>
I have the following encryption code which does the encryption of a message at the client side using crypto-js.</p>

<pre><code>var message = ""my message text"";
var password = ""user password"";
var encrypted = CryptoJS.AES.encrypt( message ,password );
console.log(encrypted.toString());
</code></pre>

<p>I need to know the AES parameters used by CryptoJS while encrypting a message(<em>Not sure what they are, but it sounds like: key size (256), padding (pkcs5), mode (CBC), PBE algorithm (PBKDF2), salt (random), iteration count (100)</em>)  . It would be a great help if some one could confirm it...I been trying to solve this mystery for the last few days?.</p>

<p>I need to know the different steps performed by CryptoJS while AES encrypting a message</p>
","<p>I'm looking <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">at the documentation</a> here:</p>

<ul>
<li>key size: ""If you use a passphrase, then it will generate a 256-bit key.""</li>
<li>padding: Pkcs7 (the default) </li>
<li>mode: CBC (the default) </li>
<li>iv: generated and stored in the cipher text object: use with ""encrypted.iv""</li>
</ul>

<p>Stuff for generating the key:</p>

<ul>
<li>salt: generated and stored in the cipher text object: use with ""encrypted.salt"" (although it doesn't really say that, so I'm guessing here)</li>
<li>pbe algorithm: Unclear. It's not documented.</li>
<li>iteration count: I can't find this documented anywhere. The examples in the code seem to use 1000.</li>
</ul>

<p>You can set the parameters by hand, which is maybe safer than relying on the defaults, e.g. some pseudo-code based on the examples in the documentation:</p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(128/8);
var iv = CryptoJS.lib.WordArray.random(128);
var key256Bits10000Iterations = CryptoJS.PBKDF2(""Secret Passphrase"", salt, { keySize: 256/32, iterations: 10000 }); //I don't know this is dividing by 32
var encrypted = CryptoJS.AES.encrypt(""Message"", key, { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv:iv });
</code></pre>

<p>You will probably have to experiment. I'd take it one step at a time. Get the password-based keys to match by fiddling those parameters, then get the ciphertext to match, then figure out decryption. Avoid the urge to simplify things like skipping the IV or using ECB.</p>
","9171","<javascript><security><encryption><cryptojs>","2","1","3","2018-10-01 20:39:45","27250883","1","6","1816580","","2014-12-02 13:42:11","2014-12-01 00:55:40",""
"27220297","What are the AES parameters used and steps performed internally by crypto-js while encrypting a message with a password?","<p><strong>Background:</strong> 
The application that I am working on is supposed to work offline. I should encrypt some text data using a password as a key at the java server side. The encrypted data is passed to the HTML5 page and at the client side using crypto-js library the server encrypted data should be decrypted. </p>

<p><strong>My issue:</strong>
In order to encrypt my message in such a way that the client can decrypt it with crypt-js (using a user entered password), I need to know the exact steps that  crypto-js expects while encrypting a message.</p>

<p><strong>What I need to know:</strong>
I have the following encryption code which does the encryption of a message at the client side using crypto-js.</p>

<pre><code>var message = ""my message text"";
var password = ""user password"";
var encrypted = CryptoJS.AES.encrypt( message ,password );
console.log(encrypted.toString());
</code></pre>

<p>I need to know the AES parameters used by CryptoJS while encrypting a message(<em>Not sure what they are, but it sounds like: key size (256), padding (pkcs5), mode (CBC), PBE algorithm (PBKDF2), salt (random), iteration count (100)</em>)  . It would be a great help if some one could confirm it...I been trying to solve this mystery for the last few days?.</p>

<p>I need to know the different steps performed by CryptoJS while AES encrypting a message</p>
","<p>CryptoJS <a href=""https://github.com/CryptoStore/crypto-js/tree/3.1.2/src/cipher-core.js"" rel=""nofollow noreferrer"">uses</a> the non-standardized OpenSSL KDF for key derivation (<a href=""https://github.com/CryptoStore/crypto-js/tree/3.1.2/src/evpkdf.js"" rel=""nofollow noreferrer"">EvpKDF</a>) with <strong>MD5</strong> as the hashing algorithm and <strong>1</strong> iteration. The IV is also derived from the password which means that only the actual ciphertext, the password and the salt are needed to decrypt this on Java side.</p>

<p>In other words, PBKDF2 is not used for key derivation in password mode of CryptoJS. By default AES-256 is used in CBC mode with PKCS5 padding (which is the <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">same as PKCS7 padding</a>). Keep in mind that you might need the <a href=""http://www.oracle.com/technetwork/java/javase/downloads/index.html"" rel=""nofollow noreferrer"">JCE Unlimited Strength Jurisdiction Policy Files</a>. See also <a href=""https://crypto.stackexchange.com/questions/20524/why-there-are-limitations-on-using-encryption-with-keys-beyond-certain-length"">Why there are limitations on using encryption with keys beyond certain length?</a></p>

<p>The following code recreates the KDF in Java (<code>keySize</code> and <code>ivSize</code> are 8 respectively 4 for AES-256 and come from ).</p>

<pre><code>public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords &lt; targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i &lt; iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv
}
</code></pre>

<p>Here is the complete class for reference:</p>

<pre><code>public class RecreateEVPkdfFromCryptoJS {
    public static void main(String[] args) throws UnsupportedEncodingException, GeneralSecurityException {
        String msg = ""hello"";
        String password = ""mypassword"";
        String ivHex = ""aab7d6aca0cc6ffc18f9f5909753aa5f"";
        int keySize = 8; // 8 words = 256-bit
        int ivSize = 4; // 4 words = 128-bit
        String keyHex = ""844a86d27d96acf3147aa460f535e20e989d1f8b5d79c0403b4a0f34cebb093b"";
        String saltHex = ""ca35168ed6b82778"";
        String openSslFormattedCipherTextString = ""U2FsdGVkX1/KNRaO1rgneK9S3zuYaYZcdXmVKJGqVqk="";
        String cipherTextHex = ""af52df3b9869865c7579952891aa56a9"";
        String padding = ""PKCS5Padding"";

        byte[] key = hexStringToByteArray(keyHex);
        byte[] iv = hexStringToByteArray(ivHex);
        byte[] salt = hexStringToByteArray(saltHex);
        byte[] cipherText = hexStringToByteArray(cipherTextHex);

        byte[] javaKey = new byte[keySize * 4];
        byte[] javaIv = new byte[ivSize * 4];
        evpKDF(password.getBytes(""UTF-8""), keySize, ivSize, salt, javaKey, javaIv);
        System.out.println(Arrays.equals(key, javaKey) + "" "" + Arrays.equals(iv, javaIv));

        Cipher aesCipherForEncryption = Cipher.getInstance(""AES/CBC/PKCS5Padding""); // Must specify the mode explicitly as most JCE providers default to ECB mode!!

        IvParameterSpec ivSpec = new IvParameterSpec(javaIv);
        aesCipherForEncryption.init(Cipher.DECRYPT_MODE, new SecretKeySpec(javaKey, ""AES""), ivSpec);

        byte[] byteMsg = aesCipherForEncryption.doFinal(cipherText);
        System.out.println(Arrays.equals(byteMsg, msg.getBytes(""UTF-8"")));
    }

    public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
        return evpKDF(password, keySize, ivSize, salt, 1, ""MD5"", resultKey, resultIv);
    }

    public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
        int targetKeySize = keySize + ivSize;
        byte[] derivedBytes = new byte[targetKeySize * 4];
        int numberOfDerivedWords = 0;
        byte[] block = null;
        MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
        while (numberOfDerivedWords &lt; targetKeySize) {
            if (block != null) {
                hasher.update(block);
            }
            hasher.update(password);
            block = hasher.digest(salt);
            hasher.reset();

            // Iterations
            for (int i = 1; i &lt; iterations; i++) {
                block = hasher.digest(block);
                hasher.reset();
            }

            System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                    Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

            numberOfDerivedWords += block.length/4;
        }

        System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
        System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

        return derivedBytes; // key + iv
    }

    /**
     * Copied from http://stackoverflow.com/a/140861
     * */
    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                    + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }
}
</code></pre>

<p>and the JavaScript code which was used for the generation of the values in the Java code:</p>

<pre><code>var msg = ""hello"";
var password = ""mypassword""; // must be present on the server
var encrypted = CryptoJS.AES.encrypt( msg, password );
var ivHex = encrypted.iv.toString();
var ivSize = encrypted.algorithm.ivSize; // same as the blockSize
var keySize = encrypted.algorithm.keySize;
var keyHex = encrypted.key.toString();
var saltHex = encrypted.salt.toString(); // must be sent as well
var openSslFormattedCipherTextString = encrypted.toString(); // not used
var cipherTextHex = encrypted.ciphertext.toString(); // must be sent
</code></pre>
","9171","<javascript><security><encryption><cryptojs>","2","10","3","2018-10-01 20:39:45","27250883","1","6","1816580","","2014-12-02 13:42:11","2014-12-01 00:55:40",""
"27220297","What are the AES parameters used and steps performed internally by crypto-js while encrypting a message with a password?","<p><strong>Background:</strong> 
The application that I am working on is supposed to work offline. I should encrypt some text data using a password as a key at the java server side. The encrypted data is passed to the HTML5 page and at the client side using crypto-js library the server encrypted data should be decrypted. </p>

<p><strong>My issue:</strong>
In order to encrypt my message in such a way that the client can decrypt it with crypt-js (using a user entered password), I need to know the exact steps that  crypto-js expects while encrypting a message.</p>

<p><strong>What I need to know:</strong>
I have the following encryption code which does the encryption of a message at the client side using crypto-js.</p>

<pre><code>var message = ""my message text"";
var password = ""user password"";
var encrypted = CryptoJS.AES.encrypt( message ,password );
console.log(encrypted.toString());
</code></pre>

<p>I need to know the AES parameters used by CryptoJS while encrypting a message(<em>Not sure what they are, but it sounds like: key size (256), padding (pkcs5), mode (CBC), PBE algorithm (PBKDF2), salt (random), iteration count (100)</em>)  . It would be a great help if some one could confirm it...I been trying to solve this mystery for the last few days?.</p>

<p>I need to know the different steps performed by CryptoJS while AES encrypting a message</p>
","<p>Following @Artjom B's great answer both on this question and <a href=""https://stackoverflow.com/questions/36762098/how-to-decrypt-password-from-javascript-cryptojs-aes-encryptpassword-passphras/36780727#36780727"">here for python users</a>, I am joining the full java code that helped me decrypt a string that was encrypted this way</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(message, password).toString();
</code></pre>

<p>This piece of Java code is useful when you only know the password (i.e. salt was not sent with the encrypted string):</p>

<pre><code>public String decrypt(String encrypted, String password) throws Exception {
    int keySize = 8;
    int ivSize = 4;
    // Start by decoding the encrypted string (Base64)
    // Here I used the Android implementation (other Java implementations might exist)
    byte[] cipherText = Base64.decode(encrypted, Base64.DEFAULT);
    // prefix (first 8 bytes) is not actually useful for decryption, but you should probably check that it is equal to the string ""Salted__""
    byte[] prefix = new byte[8];
    System.arraycopy(cipherText, 0, prefix, 0, 8);
    // Check here that prefix is equal to ""Salted__""
    // Extract salt (next 8 bytes)
    byte[] salt = new byte[8];
    System.arraycopy(cipherText, 8, salt, 0, 8);
    // Extract the actual cipher text (the rest of the bytes)
    byte[] trueCipherText = new byte[cipherText.length - 16];
    System.arraycopy(cipherText, 16, trueCipherText, 0, cipherText.length - 16);
    byte[] javaKey = new byte[keySize * 4];
    byte[] javaIv = new byte[ivSize * 4];
    evpKDF(password.getBytes(""UTF-8""), keySize, ivSize, salt, javaKey, javaIv);
    Cipher aesCipherForEncryption = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    IvParameterSpec ivSpec = new IvParameterSpec(javaIv);
    aesCipherForEncryption.init(Cipher.DECRYPT_MODE, new SecretKeySpec(javaKey, ""AES""), ivSpec);

    byte[] byteMsg = aesCipherForEncryption.doFinal(trueCipherText);
    return new String(byteMsg, ""UTF-8"");
}

public  byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    return evpKDF(password, keySize, ivSize, salt, 1, ""MD5"", resultKey, resultIv);
}

public  byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords &lt; targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i &lt; iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv
}
</code></pre>
","9171","<javascript><security><encryption><cryptojs>","2","2","3","2018-10-01 20:39:45","27250883","1","6","1816580","","2014-12-02 13:42:11","2014-12-01 00:55:40",""
"13855120","nodejs crypto module vs crypto-js","<p>I'm quite new to NodeJs and trying to figure out how to use the ""crypto"" module. While playing around with it I notice the difference between the ""crypto"" module in NodeJs and crypto-js: </p>

<p>With crypto-js, I have: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    var sha256 = CryptoJS.algo.SHA256.create();
    for(var i = 0; i &lt; iteration; i++) {
            alert(""saltedpassword = "" + saltedpassword);
            sha256.update(saltedpassword);
            var saltedpassword = sha256.finalize();
            sha256.reset();
    }       
    return saltedpassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>Then call : </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3)
</code></pre>

<p>And receive : </p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 6020c992a9b7cd3ca9e95b9a3e21b64911edb7983b3dd77bdcecda19f2756987
</code></pre>

<p>With ""crypto"" module, I wrote: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    for(var i = 0; i &lt; iteration-1; i++) { 
            console.log(""saltedpassword = ""+saltedpassword)
            var sha256 = crypto.createHash('sha256');
            sha256.update(saltedpassword);
            var saltedpassword = sha256.digest('hex');
    }       
    console.log(""saltedpassword = ""+saltedpassword)
    var sha256 = crypto.createHash('sha256');
    sha256.update(saltedpassword);
    return sha256.digest('base64');
}
</code></pre>

<p>Then call:  </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3);
</code></pre>

<p>And receive:</p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 4795d40ae8ae797f0ce51dfe4b496bca68f6d1f4a264f4ca52348ddd65a2988d
</code></pre>

<p>The first two items are the same but the third item is different. Did I miss out something ?</p>

<p><strong>Edited</strong>: As I compare to the Jasypt, CryptoJs generates similar keys. My question is how to tune ""crypto"" module to make it generate the same keys as CryptoJS and Jasypt do. </p>
","<p>I've done some tests and apparently this <code>reset</code> function ( in crypto-js ) messes up. I'm not sure what it does and I don't have enough patience to look for an issue. :) However, here's the working solution:</p>

<pre><code>function SHA256Encrypt(password, salt, iteration) {
    var saltedpassword = salt + password;
    for(var i = 0; i &lt; iteration-1; i++) {
        alert(""saltedpassword = "" + saltedpassword);
        saltedpassword = CryptoJS.SHA256( saltedpassword ).toString( CryptoJS.enc.Hex );
    }
    saltedpassword = CryptoJS.SHA256( saltedpassword );
    return saltedpassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>which makes both codes even more similar, which is good.</p>
","9115","<javascript><node.js><cryptojs><node-crypto>","6","0","4","2017-06-08 08:57:00","","1","1","1629030","","2017-06-08 08:57:00","2012-12-13 07:35:50",""
"13855120","nodejs crypto module vs crypto-js","<p>I'm quite new to NodeJs and trying to figure out how to use the ""crypto"" module. While playing around with it I notice the difference between the ""crypto"" module in NodeJs and crypto-js: </p>

<p>With crypto-js, I have: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    var sha256 = CryptoJS.algo.SHA256.create();
    for(var i = 0; i &lt; iteration; i++) {
            alert(""saltedpassword = "" + saltedpassword);
            sha256.update(saltedpassword);
            var saltedpassword = sha256.finalize();
            sha256.reset();
    }       
    return saltedpassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>Then call : </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3)
</code></pre>

<p>And receive : </p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 6020c992a9b7cd3ca9e95b9a3e21b64911edb7983b3dd77bdcecda19f2756987
</code></pre>

<p>With ""crypto"" module, I wrote: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    for(var i = 0; i &lt; iteration-1; i++) { 
            console.log(""saltedpassword = ""+saltedpassword)
            var sha256 = crypto.createHash('sha256');
            sha256.update(saltedpassword);
            var saltedpassword = sha256.digest('hex');
    }       
    console.log(""saltedpassword = ""+saltedpassword)
    var sha256 = crypto.createHash('sha256');
    sha256.update(saltedpassword);
    return sha256.digest('base64');
}
</code></pre>

<p>Then call:  </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3);
</code></pre>

<p>And receive:</p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 4795d40ae8ae797f0ce51dfe4b496bca68f6d1f4a264f4ca52348ddd65a2988d
</code></pre>

<p>The first two items are the same but the third item is different. Did I miss out something ?</p>

<p><strong>Edited</strong>: As I compare to the Jasypt, CryptoJs generates similar keys. My question is how to tune ""crypto"" module to make it generate the same keys as CryptoJS and Jasypt do. </p>
","<p>In the cryptojs example, finalize() returns raw binary data. In the crypto module example, digest() is returning a hex string. That difference in output means a difference in input when you iteratively re-hash.</p>
","9115","<javascript><node.js><cryptojs><node-crypto>","6","1","4","2017-06-08 08:57:00","","1","1","1629030","","2017-06-08 08:57:00","2012-12-13 07:35:50",""
"13855120","nodejs crypto module vs crypto-js","<p>I'm quite new to NodeJs and trying to figure out how to use the ""crypto"" module. While playing around with it I notice the difference between the ""crypto"" module in NodeJs and crypto-js: </p>

<p>With crypto-js, I have: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    var sha256 = CryptoJS.algo.SHA256.create();
    for(var i = 0; i &lt; iteration; i++) {
            alert(""saltedpassword = "" + saltedpassword);
            sha256.update(saltedpassword);
            var saltedpassword = sha256.finalize();
            sha256.reset();
    }       
    return saltedpassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>Then call : </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3)
</code></pre>

<p>And receive : </p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 6020c992a9b7cd3ca9e95b9a3e21b64911edb7983b3dd77bdcecda19f2756987
</code></pre>

<p>With ""crypto"" module, I wrote: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    for(var i = 0; i &lt; iteration-1; i++) { 
            console.log(""saltedpassword = ""+saltedpassword)
            var sha256 = crypto.createHash('sha256');
            sha256.update(saltedpassword);
            var saltedpassword = sha256.digest('hex');
    }       
    console.log(""saltedpassword = ""+saltedpassword)
    var sha256 = crypto.createHash('sha256');
    sha256.update(saltedpassword);
    return sha256.digest('base64');
}
</code></pre>

<p>Then call:  </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3);
</code></pre>

<p>And receive:</p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 4795d40ae8ae797f0ce51dfe4b496bca68f6d1f4a264f4ca52348ddd65a2988d
</code></pre>

<p>The first two items are the same but the third item is different. Did I miss out something ?</p>

<p><strong>Edited</strong>: As I compare to the Jasypt, CryptoJs generates similar keys. My question is how to tune ""crypto"" module to make it generate the same keys as CryptoJS and Jasypt do. </p>
","<p>Apparently I can't add comments to freakish's answer, so I'll write it here instead:</p>

<p>reset() works fine. The significant difference is you're converting the hash output to a hex string within the iteration loop.</p>
","9115","<javascript><node.js><cryptojs><node-crypto>","6","2","4","2017-06-08 08:57:00","","1","1","1629030","","2017-06-08 08:57:00","2012-12-13 07:35:50",""
"13855120","nodejs crypto module vs crypto-js","<p>I'm quite new to NodeJs and trying to figure out how to use the ""crypto"" module. While playing around with it I notice the difference between the ""crypto"" module in NodeJs and crypto-js: </p>

<p>With crypto-js, I have: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    var sha256 = CryptoJS.algo.SHA256.create();
    for(var i = 0; i &lt; iteration; i++) {
            alert(""saltedpassword = "" + saltedpassword);
            sha256.update(saltedpassword);
            var saltedpassword = sha256.finalize();
            sha256.reset();
    }       
    return saltedpassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>Then call : </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3)
</code></pre>

<p>And receive : </p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 6020c992a9b7cd3ca9e95b9a3e21b64911edb7983b3dd77bdcecda19f2756987
</code></pre>

<p>With ""crypto"" module, I wrote: </p>

<pre><code>function SHA256Hash(password, salt, iteration) {
    var saltedpassword = salt + password;
    for(var i = 0; i &lt; iteration-1; i++) { 
            console.log(""saltedpassword = ""+saltedpassword)
            var sha256 = crypto.createHash('sha256');
            sha256.update(saltedpassword);
            var saltedpassword = sha256.digest('hex');
    }       
    console.log(""saltedpassword = ""+saltedpassword)
    var sha256 = crypto.createHash('sha256');
    sha256.update(saltedpassword);
    return sha256.digest('base64');
}
</code></pre>

<p>Then call:  </p>

<pre><code>var hashedPassword = SHA256Hash(""123456789"", ""ASIN"", 3);
</code></pre>

<p>And receive:</p>

<pre><code>saltedpassword = ASIN123456789
saltedpassword = 3362d80b757d14bfe18c01f6a003ed38a3a4a3dcab0417efb457b71740e21411
saltedpassword = 4795d40ae8ae797f0ce51dfe4b496bca68f6d1f4a264f4ca52348ddd65a2988d
</code></pre>

<p>The first two items are the same but the third item is different. Did I miss out something ?</p>

<p><strong>Edited</strong>: As I compare to the Jasypt, CryptoJs generates similar keys. My question is how to tune ""crypto"" module to make it generate the same keys as CryptoJS and Jasypt do. </p>
","<h2>Use PKDF2 instead!</h2>

<p>Why are you not using the built-in <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">PBKDF2</a> from <a href=""http://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen"" rel=""nofollow"">node-crypto</a>:</p>

<pre><code>var hashedpw = crypto.pbkdf2Sync(password, salt, iterations, keysize);
</code></pre>

<p>and <a href=""https://code.google.com/p/crypto-js/#PBKDF2"" rel=""nofollow"">crypto-js</a>:</p>

<pre><code>var hashedpw = CryptoJS.PBKDF2(
    password, 
    salt, 
    { keySize: keysize/32, iterations: iterations }
);
</code></pre>

<p>Not only is it more secure than what you're trying to do by being much more expensive to compute than repeated hashing, it's also a lot easier to implement.</p>
","9115","<javascript><node.js><cryptojs><node-crypto>","6","1","4","2017-06-08 08:57:00","","1","1","1629030","","2017-06-08 08:57:00","2012-12-13 07:35:50",""
"41038425","How to use CryptoJS with Angular 2 and TypeScript in WebPack build environment?","<p>There are a whole bunch of questions around using the CryptoJS library with Angular 2 but most assume use of SystemJS and all seem out of date with the current version of TypeScript.  Can anybody give clear, simple instructions on how to use the CryptoJS library with Angular 2 and TypeScript.</p>

<p>I've installed CryptoJS using <code>npm install crypto-js</code>.</p>

<p>I've tried the recommended typings i<code>nstall crypto.js --ambient --save</code> but this simply gives a warning about --ambient being deprecated and to use --global instead.</p>

<p>I've used --global instead but that then gives an error saying no typings were available!</p>

<p>Any advice to someone new to WebPack, NodeJS AND TypeScript would be appreciated. I have the CryptoJS library installed under node_modules folder but any ""sensible"" attempts to ""import"" CryptoJS fail with ""Module not found"".
<a href=""https://i.stack.imgur.com/z3506.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/z3506.jpg"" alt=""enter image description here""></a></p>
","<pre><code>typings install dt~crypto-js --global --save
</code></pre>

<p>Explanation:</p>

<ul>
<li><code>--global</code> CryptoJS is global module</li>
<li><code>dt~</code> The typings are inside DT repository: <a href=""https://github.com/DefinitelyTyped/DefinitelyTyped"" rel=""nofollow noreferrer"">https://github.com/DefinitelyTyped/DefinitelyTyped</a></li>
<li><code>--save</code> Because you want it to be stored inside <code>typings.json</code>, don't you?</li>
</ul>
","8966","<angular><typescript><webpack><cryptojs>","1","1","2","2018-05-21 07:12:37","41038472","0","","","","","2016-12-08 11:30:39",""
"41038425","How to use CryptoJS with Angular 2 and TypeScript in WebPack build environment?","<p>There are a whole bunch of questions around using the CryptoJS library with Angular 2 but most assume use of SystemJS and all seem out of date with the current version of TypeScript.  Can anybody give clear, simple instructions on how to use the CryptoJS library with Angular 2 and TypeScript.</p>

<p>I've installed CryptoJS using <code>npm install crypto-js</code>.</p>

<p>I've tried the recommended typings i<code>nstall crypto.js --ambient --save</code> but this simply gives a warning about --ambient being deprecated and to use --global instead.</p>

<p>I've used --global instead but that then gives an error saying no typings were available!</p>

<p>Any advice to someone new to WebPack, NodeJS AND TypeScript would be appreciated. I have the CryptoJS library installed under node_modules folder but any ""sensible"" attempts to ""import"" CryptoJS fail with ""Module not found"".
<a href=""https://i.stack.imgur.com/z3506.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/z3506.jpg"" alt=""enter image description here""></a></p>
","<p>Here is the simplest step-by-step install and using example (working in nativescript/typescript/angular project):</p>

<pre><code>npm install crypto-js
</code></pre>

<p>then:</p>

<pre><code>npm install --save @types/crypto-js
</code></pre>

<p>Import in some component:</p>

<pre><code>import * as crypto from ""crypto-js"";
</code></pre>

<p>And use it:</p>

<pre><code>crypto.DES.decrypt(""Your secret"", ""YOUR_CRYPTO_KEY"");
</code></pre>
","8966","<angular><typescript><webpack><cryptojs>","1","6","2","2018-05-21 07:12:37","41038472","0","","","","","2016-12-08 11:30:39",""
"27371389","Exception thrown by cryptojs while decrypting an encrypted message","<p>I get an exception while trying to decrypt a cryptojs encrypted message. My decryption javascript code is given below. I am kind of stuck with no clue of what is happening. I did some debugging and could see that Base64 within the cipher-core library was undefined...</p>

<pre><code>function  decrypt(){
    var salt = CryptoJS.enc.Hex.parse(""3A79D3242F9D0DCE0C811DCCE7F830C5"");
    var iv = CryptoJS.enc.Hex.parse(""9BCBD77036744C7F26DF591AE6A772C6"");
    var encryptedBase64 =   ""eKCnyuKiH3lvknsNZq9hARCr6xtDLU/De7sPc3RPSRFAh7WCurBKmDZx/Ol0mbROBtAJBCT0+U927iygd4GspQ=="";
    var key = CryptoJS.PBKDF2(""passwordA"", salt, { keySize: 128/32, iterations: 100 });   
    console.log('key '+key); 
    var encryptedStr = encryptedBase64; //CryptoJS.enc.Base64.parse(encryptedBase64);
    console.log('encryptedStr  : '+ encryptedStr );    
    var decrypted = CryptoJS.AES.decrypt(encryptedStr, key, { iv: iv, mode:        CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });  
    console.log('decrypted : '+ decrypted);    
    var decryptedText = decrypted.toString(CryptoJS.enc.Utf8); 
    console.log('decrypted text : '+ decryptedText);    
}
</code></pre>

<p><strong>I get the following exception</strong></p>

<pre><code>TypeError: Cannot read property 'parse'
of undefined at Object.m.OpenSSL.parse(http: //domain.com/PEMSWeb/offlinePageDemo/offlineInspectionApp/CryptoJSv3.1.2/components/cipher-core-min.js:12:101)
at Object.f.SerializableCipher.k.extend._parse(http: //domain.com/PEMSWeb/offlinePageDemo/offlineInspectionApp/CryptoJSv3.1.2/components/cipher-core-min.js:13:220)
at Object.f.SerializableCipher.k.extend.decrypt(http: //domain.com/PEMSWeb/offlinePageDemo/offlineInspectionApp/CryptoJSv3.1.2/components/cipher-core-min.js:13:99)
at Object.decrypt(http: //domain.com/PEMSWeb/offlinePageDemo/offlineInspectionApp/CryptoJSv3.1.2/components/cipher-core-min.js:8:308)
</code></pre>

<p>I have no idea what is going wrong ...something is going incorrect within cryptojs</p>

<p><strong>Updated</strong></p>

<pre><code>I have the following libraries in my page in the same sequence
1) CryptoJSv3.1.2/components/core-min.js 
2) CryptoJSv3.1.2/components/cipher-core-min.js 
3) CryptoJSv3.1.2/components/enc-base64-min.js 
4) CryptoJSv3.1.2/components/enc-utf16-min.js 
5) CryptoJSv3.1.2/rollups/aes.js 
6) CryptoJSv3.1.2/rollups/pbkdf2.js
</code></pre>
","<p>I'm not sure why you need the components scripts, but you should change the order around. This is a working ordering found by trial and error:</p>

<pre><code>&lt;script src=""components/core-min.js ""&gt;&lt;/script&gt;
&lt;script src=""rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""components/cipher-core-min.js""&gt;&lt;/script&gt;
&lt;script src=""components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""rollups/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script src=""components/enc-utf16-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>and minimal cover set that is needed for the shown code is</p>

<pre><code>&lt;script src=""rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""rollups/pbkdf2.js""&gt;&lt;/script&gt;
</code></pre>

<p><code>core</code> is contained in the rollups, <code>base64</code> is contained in <code>aes</code>. utf16 is not needed in the code. I'm not sure what <code>cipher-core</code> does, but I guess it is also contained in <code>aes</code>.</p>

<p>The files are available for self-hosting from the <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""noreferrer"">Google Code Archive</a>.</p>
","8952","<javascript><encryption><cryptojs>","2","10","1","2016-05-13 18:40:01","27390015","3","2","1455719","","2014-12-09 22:07:38","2014-12-09 04:21:42",""
"41222162","Encrypt in PHP openssl and decrypt in javascript CryptoJS","<p>I'm encrypting some parameters in PHP using</p>

<pre><code> openssl(""parameter"", ""AES-256-ECB"", ""client"")
</code></pre>

<p>and I wish to decrypt in <strong>CryptoJS</strong>:</p>

<pre><code>CryptoJS.AES.decrypt(parameter, ""client"", {mode: CryptoJS.mode.ECB}).toString(CryptoJS.enc.Utf8);
</code></pre>

<p>but it's throwing an empty string.</p>

<p>Any suggestions?</p>
","<p><strong>CryptoJS: PHP openssl encrypt -> javascript decrypt</strong></p>

<p>PHP:</p>

<pre><code>function CryptoJSAesEncrypt($passphrase, $plain_text){

    $salt = openssl_random_pseudo_bytes(256);
    $iv = openssl_random_pseudo_bytes(16);
    //on PHP7 can use random_bytes() istead openssl_random_pseudo_bytes()
    //or PHP5x see : https://github.com/paragonie/random_compat

    $iterations = 999;  
    $key = hash_pbkdf2(""sha512"", $passphrase, $salt, $iterations, 64);

    $encrypted_data = openssl_encrypt($plain_text, 'aes-256-cbc', hex2bin($key), OPENSSL_RAW_DATA, $iv);

    $data = array(""ciphertext"" =&gt; base64_encode($encrypted_data), ""iv"" =&gt; bin2hex($iv), ""salt"" =&gt; bin2hex($salt));
    return json_encode($data);
}

$string_json_fromPHP = CryptoJSAesEncrypt(""your passphrase"", ""your plain text"");
</code></pre>

<p>JS:</p>

<pre><code>function CryptoJSAesDecrypt(passphrase,encrypted_json_string){

    var obj_json = JSON.parse(encrypted_json_string);

    var encrypted = obj_json.ciphertext;
    var salt = CryptoJS.enc.Hex.parse(obj_json.salt);
    var iv = CryptoJS.enc.Hex.parse(obj_json.iv);   

    var key = CryptoJS.PBKDF2(passphrase, salt, { hasher: CryptoJS.algo.SHA512, keySize: 64/8, iterations: 999});


    var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv});

    return decrypted.toString(CryptoJS.enc.Utf8);
}

console.log(CryptoJSAesDecrypt('your passphrase','&lt;?php echo $string_json_fromPHP?&gt;'));
</code></pre>

<p><strong>CryptoJS: javascript encrypt -> PHP openssl decrypt</strong></p>

<p>JS:</p>

<pre><code>function CryptoJSAesEncrypt(passphrase, plain_text){

    var salt = CryptoJS.lib.WordArray.random(256);
    var iv = CryptoJS.lib.WordArray.random(16);
    //for more random entropy can use : https://github.com/wwwtyro/cryptico/blob/master/random.js instead CryptoJS random() or another js PRNG

    var key = CryptoJS.PBKDF2(passphrase, salt, { hasher: CryptoJS.algo.SHA512, keySize: 64/8, iterations: 999 });

    var encrypted = CryptoJS.AES.encrypt(plain_text, key, {iv: iv});

    var data = {
        ciphertext : CryptoJS.enc.Base64.stringify(encrypted.ciphertext),
        salt : CryptoJS.enc.Hex.stringify(salt),
        iv : CryptoJS.enc.Hex.stringify(iv)    
    }

    return JSON.stringify(data);
}
</code></pre>

<p>PHP:</p>

<pre><code>function CryptoJSAesDecrypt($passphrase, $jsonString){

    $jsondata = json_decode($jsonString, true);
    try {
        $salt = hex2bin($jsondata[""salt""]);
        $iv  = hex2bin($jsondata[""iv""]);          
    } catch(Exception $e) { return null; }

    $ciphertext = base64_decode($jsondata[""ciphertext""]);
    $iterations = 999; //same as js encrypting 

    $key = hash_pbkdf2(""sha512"", $passphrase, $salt, $iterations, 64);

    $decrypted= openssl_decrypt($ciphertext , 'aes-256-cbc', hex2bin($key), OPENSSL_RAW_DATA, $iv);

    return $decrypted;

}
</code></pre>
","8724","<javascript><php><openssl><padding><cryptojs>","12","24","1","2018-09-17 21:10:19","","0","11","5604714","","2016-12-19 12:17:32","2016-12-19 12:01:46",""
"30382014","Java to JS and JS to Java encryption using cryptojs","<p>I got on this post a couple of weeks ago and worked perfectly:
<a href=""https://stackoverflow.com/questions/23321049/compatible-aes-algorithm-for-java-and-javascript"">Compatible AES algorithm for Java and Javascript</a></p>

<p>Now, I need to do the reverse operation, but once in java, I am getting this exception:</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:966)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
at javax.crypto.Cipher.doFinal(Cipher.java:2165)
</code></pre>

<p>This is my ""reverse"" operation I did in JavaScript:</p>

<pre><code>var rkEncryptionKey = CryptoJS.enc.Base64.parse('u/Gu5posvwDsXUnV5Zaq4g==');
var rkEncryptionIv = CryptoJS.enc.Base64.parse('5D9r9ZVzEYYgha93/aUK2w==');

function encryptString(stringToEncrypt) {
    var utf8Stringified = CryptoJS.enc.Utf8.parse(stringToEncrypt);
    var encrypted = CryptoJS.AES.encrypt(utf8Stringified.toString(), rkEncryptionKey, {mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: rkEncryptionIv});
    return CryptoJS.enc.Base64.parse(encrypted.toString()).toString();
}
</code></pre>

<p>I though this would be all?</p>

<p><strong>[EDIT]</strong></p>

<p>Encrypted string is the following: <code>{""company_name"":""asdfasdfasd"",""customer_name"":""asdfasdfasdfasdf"",""phone_number"":""asdfasdfasdfasdf"",""email"":""asdfasdfasdfasdfads""}</code></p>

<p>When doing the encrypt / decrypt from java to java it works, when doing so from java to javascript, also works, but from javascript to java, not working.</p>

<p><strong>Java Code</strong></p>

<pre><code>public String toJson(final String encrypted) {
    try {
        SecretKey key = new SecretKeySpec(Base64.decodeBase64(""u/Gu5posvwDsXUnV5Zaq4g==""), ""AES"");
        AlgorithmParameterSpec iv = new IvParameterSpec(Base64.decodeBase64(""5D9r9ZVzEYYgha93/aUK2w==""));
        byte[] decodeBase64 = Base64.decodeBase64(encrypted);

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, iv);

        return new String(cipher.doFinal(decodeBase64), ""UTF-8"");
    } catch (Exception e) {
        throw new RuntimeException(""This should not happen in production."", e);
    }
}
</code></pre>
","<p>Change </p>

<pre><code>return CryptoJS.enc.Base64.parse(encrypted.toString()).toString();
</code></pre>

<p>to</p>

<pre><code>return encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>

<p>The <code>encrypted</code> object usually stringifies into an OpenSSL format which might also contain the salt. If you're only interested in the actual ciphertext, then you need to stringify the <code>ciphertext</code> property.</p>

<p>Note that <code>toString()</code> takes an optional encoding function. Use the one that you need.</p>
","8649","<java><encryption><encoding><aes><cryptojs>","7","5","1","2015-05-21 19:18:33","30382153","1","4","-1","","2017-05-23 11:54:18","2015-05-21 18:50:04",""
"15440161","Using CryptoJS to encrypt in JavaScript and decrypt in C#","<p>I am trying to use CryptoJS to encrypt in JavaScript and decrypt in C#. Spent quite a bit of time trying to get both technologies to return the same output. Still, the output is different -- the encrypted string produced by CryptoJS is different from encrypted string produced by C#. What am I doing wrong? Thank you for your help.</p>

<pre><code>   &lt;%@ Page Language=""C#"" AutoEventWireup=""true"" CodeBehind=""Test.aspx.cs"" Inherits="".com.Test"" %&gt;
&lt;%@ Import Namespace=""System.Security.Cryptography"" %&gt;
&lt;p id=""output""&gt;&lt;/p&gt;
&lt;script src=""/Scripts/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(
        CryptoJS.enc.Utf8.parse(""test""),
        CryptoJS.enc.Utf8.parse(""607490BE-18CA-43D7-B11A-57E2621B0137""),
        {
            mode: CryptoJS.mode.CBC, 
            padding: CryptoJS.pad.Pkcs7,
            iv: CryptoJS.enc.Utf8.parse(""2D59831C-78AC-4227-B3F3-CE656636C23E"")
        });
    document.getElementById('output').innerText = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
&lt;/script&gt;

&lt;%
    var encryptor = new AesCryptoServiceProvider
        {
            Key = Encoding.UTF8.GetBytes(""607490BE-18CA-43D7-B11A-57E2621B0137"").Take(32).ToArray(),
            IV = Encoding.UTF8.GetBytes(""2D59831C-78AC-4227-B3F3-CE656636C23E"").Take(16).ToArray(),
            Mode = CipherMode.CBC,
            Padding = PaddingMode.PKCS7
        }.CreateEncryptor();
    var dataToEncrypt = Encoding.UTF8.GetBytes(""test"");
    Response.Write(Convert.ToBase64String(encryptor.TransformFinalBlock(dataToEncrypt, 0, dataToEncrypt.Length)));
%&gt;
</code></pre>
","<p>I had to do something similar recently, here is a working version of what you were shooting for - this encrypts a string on on the server in C# with the AES provider from System.Security.Cryptography, then sends the encrypted text to the client where it decrypts it in JavaScript with the CryptoJS library:</p>

<pre><code>&lt;%@ Page Language=""C#"" %&gt;
&lt;%@ Import Namespace=""System.Security.Cryptography"" %&gt;
&lt;%@ Import Namespace=""System.IO"" %&gt;

&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    window.onload = function (e) {
        var key = CryptoJS.enc.Base64.parse(document.getElementById('key').innerText);
        var iv = CryptoJS.enc.Base64.parse(document.getElementById('iv').innerText);
        var ciphertext = document.getElementById('ciphertext').innerText;
        var decrypted = CryptoJS.AES.decrypt(ciphertext, key, { iv: iv });

        document.getElementById('output').innerText = decrypted.toString(CryptoJS.enc.Utf8);
    }
&lt;/script&gt;

&lt;%
    string plaintext = ""the quick brown fox jumped over the lazy dog"";
    string ciphertext;
    string decryptedtext;

    UTF8Encoding utf8 = new UTF8Encoding();

    AesCryptoServiceProvider aes = new AesCryptoServiceProvider();

    using (ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV)) { 
        MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write);
        byte[] bytes = utf8.GetBytes(plaintext);
        cs.Write(bytes, 0, bytes.Length);
        cs.FlushFinalBlock();
        ms.Position = 0;
        bytes = new byte[ms.Length];
        ms.Read(bytes, 0, bytes.Length);
        ciphertext = Convert.ToBase64String(bytes);
    }

    using (ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
    {
        MemoryStream ms = new MemoryStream();
        CryptoStream cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Write);
        byte[] bytes = Convert.FromBase64String(ciphertext);
        cs.Write(bytes, 0, bytes.Length);
        cs.FlushFinalBlock();
        ms.Position = 0;
        bytes = new byte[ms.Length];
        ms.Read(bytes, 0, bytes.Length);
        decryptedtext = utf8.GetString(bytes);
    }    
%&gt;

&lt;h1&gt;Server-side in C# using System.Security.Cryptography&lt;/h1&gt;
Key:&lt;div id=""key""&gt;&lt;% Response.Write(Convert.ToBase64String(aes.Key)); %&gt;&lt;/div&gt;
IV:&lt;div id=""iv""&gt;&lt;% Response.Write(Convert.ToBase64String(aes.IV)); %&gt;&lt;/div&gt;
Plain text:&lt;div id=""plaintext""&gt;&lt;% Response.Write(plaintext); %&gt;&lt;/div&gt;
Cipher text:&lt;div id=""ciphertext""&gt;&lt;% Response.Write(ciphertext); %&gt;&lt;/div&gt;
Decrypted text:&lt;div id=""decryptedtext""&gt;&lt;% Response.Write(decryptedtext); %&gt;&lt;/div&gt;

&lt;h1&gt;Client-side in JS using CryptoJS)&lt;/h1&gt;
&lt;div id=""output""&gt;&lt;/div&gt;
</code></pre>
","8612","<javascript><asp.net><encryption><aes><cryptojs>","2","2","1","2016-10-27 07:15:44","","2","1","1044169","","2013-03-15 19:24:25","2013-03-15 18:56:51",""
"35529804","Using crypto-js to encrypt password and send form via ajax (and decrypt in java), I get : TypeError: Cannot read property 'words' of undefined","<p>I am trying to secure the password that i am sending from an HTML form to a Java Servlet (via ajax). I use <code>crypto-js</code> in my js to encrypt the password.
When the code reaches the ajax call, I get the error:</p>

<blockquote>
  <p>Uncaught TypeError: Cannot read property 'words' of undefined
  (aes.js:8)</p>
</blockquote>

<p>(I already made sure that the key Im sending is not null)</p>

<p>this is my code:</p>

<hr>

<p><strong>login.jsp:</strong></p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html &gt;
&lt;head&gt;
&lt;meta charset=""UTF-8""&gt;
&lt;title&gt;Login&lt;/title&gt;
&lt;link rel=""stylesheet"" href=""css/style.css""&gt;
&lt;script src=""jquery-1.11.2.min.js""&gt;&lt;/script&gt;
&lt;script type='text/javascript'&gt;
localStorage.setItem('loggedin', false);
&lt;/script&gt;
&lt;script src=""login.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-    js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
function convertAndSubmit()
{
    var salt = CryptoJS.lib.WordArray.random(128/8);
    var iv = CryptoJS.lib.WordArray.random(128/8);           
    console.log('salt  '+ salt );
    console.log('iv  '+ iv );
    var key128Bits100Iterations = CryptoJS.PBKDF2('1234567890987654', salt,         { keySize: 256/32, iterations: 100 });
    console.log( 'key128Bits100Iterations '+ key128Bits100Iterations);
    var encrypted = CryptoJS.AES.encrypt($(""#pwd"").val(), key128Bits100Iterations, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7  }).toString();
    checkLogin(encrypted, randkey, salt, iv);
}
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;

&lt;div class=""container""&gt;
  &lt;div id=""login-form""&gt;
    &lt;h3&gt;Login&lt;/h3&gt;

    &lt;fieldset&gt;
      &lt;form action=""javascript:void(0);"" method=""get"" name=""login""&gt;
        &lt;input type=""email"" id=""email"" name=""email"" required value=""Email""      onBlur=""if(this.value=='')this.value='Email'"" onFocus=""if(this.value=='Email')this.value='' ""&gt;
        &lt;input type=""password"" id=""pwd"" name=""pwd"" required value=""Password"" onBlur=""if(this.value=='')this.value='Password'"" onFocus=""if(this.value=='Password')this.value='' ""&gt; 
        &lt;input type=""submit"" value=""Login"" id=""login"" onclick=""javascript:convertAndSubmit()""&gt;
      &lt;/form&gt;
    &lt;/fieldset&gt;

  &lt;/div&gt; &lt;!-- end login-form --&gt;
&lt;/div&gt;
&lt;div id=""output""&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<hr>

<p><strong>login.js:</strong></p>

<pre><code>function ajaxLogin(credentials) {
    var retData = null;
    $.ajax({ //this is where the code generates the error
        async: false,
        type: 'GET',
        data: credentials,
        url: ""http://localhost:8080/AtlasServices/Login"",
        success: function(data) {
            retData = data;
        }
    });
    return retData;
}

function checkLogin(encrypted, key, s, i) {
    var credentials = {
        email: $(""#email"").val(),
        pass: encrypted,
        key: key,
        salt: s,
        iv: i
    };

    var res = window.ajaxLogin(credentials);
    if (res[""userlogged""] !== ""true"") {
        alert(""Failed to log in"");
        $(""#email"").val("""");
        $(""#pwd"").val("""");
        localStorage.setItem('loggedin', false);
    } else {
        localStorage.setItem('loggedin', true);
        window.location = ""http://localhost:8080/AtlasServices/main.html"";
    }
}
</code></pre>

<hr>

<p>I was searching for a long time for a solution...will really love some help, thanks:)</p>
","<p><code>CryptoJS.lib.WordArray.random(..)</code> creates <code>WordArray</code> object.</p>

<p><strong>From your code :</strong> </p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(128/8);
var iv = CryptoJS.lib.WordArray.random(128/8);    
</code></pre>

<p>This means <code>salt</code> and <code>iv</code> is an object not a string.</p>

<p>You are able to log <code>salt</code> and <code>iv</code> as encoded because <code>console.log</code> calls  <code>toString</code> internally from <code>salt</code> and <code>iv</code> which <code>encodes</code> the <code>WordArray</code>  </p>

<p><strong>All you need to do is encode these explicitly:</strong></p>

<pre><code>checkLogin(encrypted, randkey, salt.toString(), iv.toString());
</code></pre>

<p><strong>Note:</strong> The error you've got is related with the <code>JQuery</code>; while building url parameters <code>JQuery</code> reads all <code>objects</code>, <code>sub-objects</code>, <code>arrays</code> and <strong>functions</strong> etc... , When you send <code>WordArray</code> as an object jQuery tries to call it's functions to fetch return value into the url parameter. </p>

<p>In your case it is calling the <code>concat</code> function with an undefined parameters, which leads to the error you get. You can simply reproduce this error by calling <code>$.param(salt)</code> (or for <code>iv</code>).</p>
","8528","<javascript><jquery><ajax><encryption><cryptojs>","4","2","1","2019-05-29 08:24:32","35530228","1","","1601571","","2019-05-29 08:24:32","2016-02-20 22:22:25",""
"20053819","Google Spreadsheet: Encrypt cell content with Google Apps Script","<p>I have a Google Spreadsheet and would like to encrypt the content of a few cells (I do not care which encryption method is being used as long as there is an equivalent decryption method for iOS).</p>

<p>Unfortunately there are no built-in encryption functions in Google Apps Script.</p>

<p>For this reason I would like to use a open source Javascript library like <a href=""http://code.google.com/p/crypto-js/"" rel=""noreferrer"">Crypto-JS</a> and <a href=""https://github.com/bitwiseshiftleft/sjcl"" rel=""noreferrer"">sjcl</a>.</p>

<p>How can I use one of these libraries with Google Apps Script? </p>

<p>In the Google Apps Script documentation, I have not found any clue on how to use external JavaScript libraries with my Google Apps Script.</p>
","<p>Well I'll say this, because this is the method that I used with <a href=""http://www.datejs.com/"" rel=""noreferrer"">Date JS</a>. You can do the following:</p>

<ol>
<li>Download the source .js file(s).</li>
<li>Open the .js file(s) in a text editor</li>
<li>Copy/paste all code into a new <em>Script Project</em>
<ul>
<li>here you can ""recreate"" the original .js files (copy/paste source individually) with the same names</li>
</ul></li>
<li>Include the <em>project key</em> of that Script Project as a <em>library</em> of the project in which you want to use those functions.</li>
</ol>

<p>Even if the projects are open-source you will want to make sure you comply with the licenses of those projects if you are going to use them.</p>

<p>This is basically a small ""hack"" around not being able to upload .js files into GAS Projects. Assuming that the JS is standard, this method will work with Google's system.</p>

<hr>

<p>The other option is to simple find a light-weight one- or two-function crypto package, or a single crypto algorithm like AES-128 (taht you are given permission to use, of course). It really depends on how much encryption you want, if you need to reverse the cipher text to get the plain values, etc.</p>

<p>If this is a for some kind of password system, I would recommend using a simple hash. For example:</p>

<pre><code>function stringHash (someString) {
    var hash = 0;
    if (this.length == 0) return hash;
    for (i = 0; i &lt; this.length; i++) {
        char = this.charCodeAt(i);
        hash = ((hash &lt;&lt; 5) - hash) + char;
        hash = hash &amp; hash;
    }
    return Math.abs(hash); // Personally I don't like negative values, so I abs'd it
}
</code></pre>

<p>in which you would ask for a user's password, and if the password hash matched the hash stored in the spreadsheet or wherever, then you would validate. You can use this to simulate logging into a UiApp GUI, for example: store usernames/password hashes in a database and validate a user before loading the ""real"" app.</p>

<hr>

<p>However, as Serge mentioned, Spreadsheets will contain revision history of the original value before it was hashed, as well as the value after it was hashed. If you want to avoid this, use ScriptDB.</p>

<hr>

<p><strong>PS</strong> - in addition to this work-around, I'll say that it's not currently possible to ""import"" a non-GAS code library into your Script Project, unless you manually copy the source file-by-file into your Script Project. There may be a feature request on the Issue Tracker already, if not you can create one and I'll star it.</p>

<hr>

<p><strong>EDIT</strong>: As per request, I've included <a href=""http://www.movable-type.co.uk/scripts/aes.html"" rel=""noreferrer"">an open source AES</a> encryption ""package"" (contains base64 as well, which is nice) in the answer, to act as a reference for others who want to encrypt in GAS. Make sure you follow the author's request, which is to retain his original copyright and link back to the source.</p>

<p>Other than the AES I linked and the simple hash (equivalent to Java's String.hashCode()), whose resource can be found <a href=""http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/"" rel=""noreferrer"">here</a>, there is Crypto-JS as you mentioned in your question and, if you took the time to fully copy/paste all the code (assuming that agrees with the terms of the license - I haven't read it), you could use that by the steps I described in the top half of my answer.</p>

<p><a href=""http://www.myersdaily.org/joseph/javascript/md5-text.html"" rel=""noreferrer"">MD5 in Javascript</a> is also an algorithm that you could use. If you use the code in <strong>md5.js</strong> which is located at the top of the page, you'll have what you need. Again, make sure you're following licensing rules if you use it.</p>

<p>Personally I would probably just use the <em>hash</em> and the <em>base-64</em> patterns, as most of what you would use this encryption for is probably not incredibly important. AES might take a bit longer to compute - you can probably benchmark it yourself to see if it will cause major problems with triggers running for an extended period of time, but I doubt it would be a problem anyway.</p>

<p><strong>Note</strong>: base-64 is 2-way, so is AES. MD5 is a type of hash, and the simple hash function I provided is also (of course) a hash. Hash functions are one-way. So if you need two-way functionality (encrypt/decrypt), then use base-64 or AES. Base-64 is essentially the kid version of AES. And the simple hash function is the kid version of MD5. Keep this in mind :)</p>

<p><strong>Edit again</strong>: I'm not familiar with iOS development or its internals, but it <em>seems</em> to me that <a href=""https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html#//apple_ref/doc/uid/TP40011172-CH9-SW1"" rel=""noreferrer"">iOS can at least do some cryptographic operations</a>. You may want to read more into those methods though, because I'm not really sure how you're putting GAS and iOS together; I can't give you any more help in that area unfortunately.</p>
","8103","<javascript><google-apps-script><google-sheets><cryptojs><sjcl>","6","8","2","2019-09-27 01:21:21","20060778","7","","","","","2013-11-18 17:21:21",""
"20053819","Google Spreadsheet: Encrypt cell content with Google Apps Script","<p>I have a Google Spreadsheet and would like to encrypt the content of a few cells (I do not care which encryption method is being used as long as there is an equivalent decryption method for iOS).</p>

<p>Unfortunately there are no built-in encryption functions in Google Apps Script.</p>

<p>For this reason I would like to use a open source Javascript library like <a href=""http://code.google.com/p/crypto-js/"" rel=""noreferrer"">Crypto-JS</a> and <a href=""https://github.com/bitwiseshiftleft/sjcl"" rel=""noreferrer"">sjcl</a>.</p>

<p>How can I use one of these libraries with Google Apps Script? </p>

<p>In the Google Apps Script documentation, I have not found any clue on how to use external JavaScript libraries with my Google Apps Script.</p>
","<p>The functions above don't work for me. Here is something what you can copy and paste into google sheets (spreadsheet) script editor</p>

<pre><code>function enc(str) {
    var encoded = """";
    for (i=0; i&lt;str.length;i++) {
        var a = str.charCodeAt(i);
        var b = a ^ 123;    // bitwise XOR with any number, e.g. 123
        encoded = encoded+String.fromCharCode(b);
    }
    return encoded;
}
</code></pre>

<p>This is what you get when you use it =ENC in your spreadsheet </p>

<p><a href=""https://i.stack.imgur.com/cA7fy.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/cA7fy.jpg"" alt=""enter image description here""></a></p>

<p>Based on this post <a href=""https://stackoverflow.com/questions/3609005/simple-javascript-encrypt-php-decrypt-with-shared-secret-key"">here</a></p>
","8103","<javascript><google-apps-script><google-sheets><cryptojs><sjcl>","6","0","2","2019-09-27 01:21:21","20060778","7","","","","","2013-11-18 17:21:21",""
"44881445","CryptoJS.SHA256 help needed","<p>I am new to crypto, please help me. Thanks in advance. </p>

<p>var seed = ""adb6f118edd6ca21cd88c2709b5b395266c0b3d71bd3c55bac875a31017c29fa""
var seed_hash = CryptoJS.SHA256(seed).toString(CryptoJS.enc.Hex);</p>

<p>console.log(seed_hash);</p>

<p>The result of seed_hash is ""ead4c97002cdd8e9d60199fb23a2173fbe4065c55855608a2d1dee38891513a6""</p>

<p>My question is, how to convert it back to ""adb6f118edd6ca21cd88c2709b5b395266c0b3d71bd3c55bac875a31017c29fa""</p>

<p>and print it in console as text.</p>
","<p>You cannot, SHA256 is an hash algorithm and it is known to be irreversible.</p>

<p>So, if you have to check up for example the password stored in DB and the password inserted in a form, you have to:  </p>

<ul>
<li>store the SHA256 in your DB  </li>
<li>compare the stored password with the SHA256 of the actual inserted password</li>
</ul>

<p>For same content the result will be the same.</p>
","8009","<cryptojs>","-1","3","1","2018-01-15 18:39:43","","5","","451475","","2017-07-03 13:34:53","2017-07-03 08:56:38",""
"19094547","AES Encryption in C# and decryption in CryptoJS","<p>I would like to do AES Encryption in C# and decryption in CryptoJS.</p>
","<p>It is working now after getting some reference from Google CryptoJS group (<a href=""https://groups.google.com/forum/#!msg/crypto-js/ysgzr2Wxt_k/_Wh8l_1rhQAJ"" rel=""nofollow noreferrer"">https://groups.google.com/forum/#!msg/crypto-js/ysgzr2Wxt_k/_Wh8l_1rhQAJ</a>).</p>

<p>Here is encryption code in C#.NET.</p>

<pre><code>public class ClsCrypto
{
    private RijndaelManaged myRijndael = new RijndaelManaged();
    private int iterations;
    private byte [] salt;

    public ClsCrypto(string strPassword)
    {
        myRijndael.BlockSize = 128;
        myRijndael.KeySize = 128;
        myRijndael.IV = HexStringToByteArray(""e84ad660c4721ae0e84ad660c4721ae0"");

        myRijndael.Padding = PaddingMode.PKCS7;
        myRijndael.Mode = CipherMode.CBC;
        iterations = 1000;
        salt = System.Text.Encoding.UTF8.GetBytes(""insight123resultxyz"");
        myRijndael.Key = GenerateKey(strPassword);
    }

    public string Encrypt(string strPlainText)
    {
        byte [] strText = new System.Text.UTF8Encoding().GetBytes(strPlainText);
        ICryptoTransform transform = myRijndael.CreateEncryptor();
        byte [] cipherText = transform.TransformFinalBlock(strText, 0, strText.Length);

        return Convert.ToBase64String(cipherText);
    }

    public string Decrypt(string encryptedText)
    {
       byte[] encryptedBytes = Convert.FromBase64String(encryptedText);
       var decryptor = myRijndael.CreateDecryptor(myRijndael.Key, myRijndael.IV);
       byte[] originalBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);

       return Encoding.UTF8.GetString(originalBytes);
    }

    public static byte [] HexStringToByteArray(string strHex)
    {
        dynamic r = new byte[strHex.Length / 2];
        for (int i = 0; i &lt;= strHex.Length - 1; i += 2)
        {
            r[i/2] = Convert.ToByte(Convert.ToInt32(strHex.Substring(i, 2), 16));
        }
        return r;
    }

    private byte[] GenerateKey(string strPassword)
    {
        Rfc2898DeriveBytes rfc2898 = new          Rfc2898DeriveBytes(System.Text.Encoding.UTF8.GetBytes(strPassword), salt, iterations);

        return rfc2898.GetBytes(128 / 8);
    }
}
</code></pre>

<p>Following is decryption code in Java script.</p>

<pre><code>&lt;head runat=""server""&gt;
        &lt;script src=""rollups/aes.js"" type=""text/javascript""&gt;&lt;/script&gt;
        &lt;script src=""rollups/sha256.js"" type=""text/javascript""&gt;&lt;/script&gt;
        &lt;script src=""rollups/pbkdf2.js"" type=""text/javascript""&gt;&lt;/script&gt;
        &lt;script type=""text/javascript""&gt;
          function DecryptData() {
            var encryptData = document.getElementById('TextEncrypted').value;
            var decryptElement = document.getElementById('TextDecrypt');

            try {
                //Creating the Vector Key
                var iv = CryptoJS.enc.Hex.parse('e84ad660c4721ae0e84ad660c4721ae0');
                //Encoding the Password in from UTF8 to byte array
                var Pass = CryptoJS.enc.Utf8.parse('insightresult');
                //Encoding the Salt in from UTF8 to byte array
                var Salt = CryptoJS.enc.Utf8.parse(""insight123resultxyz"");
                //Creating the key in PBKDF2 format to be used during the decryption
                var key128Bits1000Iterations = CryptoJS.PBKDF2(Pass.toString(CryptoJS.enc.Utf8), Salt, { keySize: 128 / 32, iterations: 1000 });
                //Enclosing the test to be decrypted in a CipherParams object as supported by the CryptoJS libarary
                var cipherParams = CryptoJS.lib.CipherParams.create({
                    ciphertext: CryptoJS.enc.Base64.parse(encryptData)
                });

                //Decrypting the string contained in cipherParams using the PBKDF2 key
                var decrypted = CryptoJS.AES.decrypt(cipherParams, `enter code here`key128Bits1000Iterations, { mode: CryptoJS.mode.CBC, iv: iv, padding: CryptoJS.pad.Pkcs7 });
                decryptElement.value = decrypted.toString(CryptoJS.enc.Utf8);
            }
            //Malformed UTF Data due to incorrect password
            catch (err) {
                return """";
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
</code></pre>
","7816","<encryption><aes><cryptojs>","3","6","1","2018-03-23 10:44:53","22831964","1","4","2776571","","2014-04-03 08:30:50","2013-09-30 12:40:42",""
"25006460","Can't verify signature witn Node.js Crypto, using key pairs","<p>I've a very small code in nodejs where I sign a string and then try to verify it, using node crypto and key pairs generated with openssl. No matter what I try, the result is always ""false"", the signature can't be verified. </p>

<p>Generation of public/private key pairs:</p>

<pre><code>openssl genrsa -out rsa_1024_priv.pem 1024

openssl rsa -in rsa_1024_priv.pem -out rsa_1024_pub.pem -outform PEM -pubout
</code></pre>

<p>The resultant keys are (I don't care made them public BTW):</p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDCtTEic76GBqUetJ1XXrrWZcxd8vJr2raWRqBjbGpSzLqa3YLv
VxVeK49iSlI+5uLX/2WFJdhKAWoqO+03oH4TDSupolzZrwMFSylxGwR5jPmoNHDM
S3nnzUkBtdr3NCfq1C34fQV0iUGdlPtJaiiTBQPMt4KUcQ1TaazB8TzhqwIDAQAB
AoGAM8WeBP0lwdluelWoKJ0lrPBwgOKilw8W0aqB5y3ir5WEYL1ZnW5YXivS+l2s
tNELrEdapSbE9hieNBCvKMViABQXj4DRw5Dgpfz6Hc8XIzoEl68DtxL313EyouZD
jOiOGWW5UTBatLh05Fa5rh0FbZn8GsHrA6nhz4Fg2zGzpyECQQDi8rN6qhjEk5If
+fOBT+kjHZ/SLrH6OIeAJ+RYstjOfS0bWiM9Wvrhtr7DZkIUA5JNsmeANUGlCrQ2
cBJU2cJJAkEA26HyehCmnCkCjit7s8g3MdT0ys5WvrAFO6z3+kCbCAsGS+34EgnF
yz8dDdfUYP410R5+9Cs/RkYesqindsvEUwJBALCmQVXFeKnqQ99n60ZIMSwILxKn
Dhm6Tp5Obssryt5PSQD1VGC5pHZ0jGAEBIMXlJWtvCprScFxZ3zIFzy8kyECQQDB
lUhHVo3DblIWRTVPDNW5Ul5AswW6JSM3qgkXxgHfYPg3zJOuMnbn4cUWAnnq06VT
oHF9fPDUW9GK3yRbjNaJAkAB2Al6yY0KUhYLtWoEpQ40HlATbhNel2cn5WNs6Y5F
2hedvWdhS/zLzbtbSlOegp00d2/7IBghAfjAc3DE9DZw
-----END RSA PRIVATE KEY-----

-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCtTEic76GBqUetJ1XXrrWZcxd
8vJr2raWRqBjbGpSzLqa3YLvVxVeK49iSlI+5uLX/2WFJdhKAWoqO+03oH4TDSup
olzZrwMFSylxGwR5jPmoNHDMS3nnzUkBtdr3NCfq1C34fQV0iUGdlPtJaiiTBQPM
t4KUcQ1TaazB8TzhqwIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>Then, this is my code for node:</p>

<pre><code>var crypto = require('crypto');

var privateKey = '-----BEGIN RSA PRIVATE KEY-----\n'+
'MIICXQIBAAKBgQDCtTEic76GBqUetJ1XXrrWZcxd8vJr2raWRqBjbGpSzLqa3YLv\n'+
'VxVeK49iSlI+5uLX/2WFJdhKAWoqO+03oH4TDSupolzZrwMFSylxGwR5jPmoNHDM\n'+
'S3nnzUkBtdr3NCfq1C34fQV0iUGdlPtJaiiTBQPMt4KUcQ1TaazB8TzhqwIDAQAB\n'+
'AoGAM8WeBP0lwdluelWoKJ0lrPBwgOKilw8W0aqB5y3ir5WEYL1ZnW5YXivS+l2s\n'+
'tNELrEdapSbE9hieNBCvKMViABQXj4DRw5Dgpfz6Hc8XIzoEl68DtxL313EyouZD\n'+
'jOiOGWW5UTBatLh05Fa5rh0FbZn8GsHrA6nhz4Fg2zGzpyECQQDi8rN6qhjEk5If\n'+
'+fOBT+kjHZ/SLrH6OIeAJ+RYstjOfS0bWiM9Wvrhtr7DZkIUA5JNsmeANUGlCrQ2\n'+
'cBJU2cJJAkEA26HyehCmnCkCjit7s8g3MdT0ys5WvrAFO6z3+kCbCAsGS+34EgnF\n'+
'yz8dDdfUYP410R5+9Cs/RkYesqindsvEUwJBALCmQVXFeKnqQ99n60ZIMSwILxKn\n'+
'Dhm6Tp5Obssryt5PSQD1VGC5pHZ0jGAEBIMXlJWtvCprScFxZ3zIFzy8kyECQQDB\n'+
'lUhHVo3DblIWRTVPDNW5Ul5AswW6JSM3qgkXxgHfYPg3zJOuMnbn4cUWAnnq06VT\n'+
'oHF9fPDUW9GK3yRbjNaJAkAB2Al6yY0KUhYLtWoEpQ40HlATbhNel2cn5WNs6Y5F\n'+
'2hedvWdhS/zLzbtbSlOegp00d2/7IBghAfjAc3DE9DZw\n'+
'-----END RSA PRIVATE KEY-----';

var publicKey = '-----BEGIN PUBLIC KEY-----\n'+
'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCtTEic76GBqUetJ1XXrrWZcxd\n'+
'8vJr2raWRqBjbGpSzLqa3YLvVxVeK49iSlI+5uLX/2WFJdhKAWoqO+03oH4TDSup\n'+
'olzZrwMFSylxGwR5jPmoNHDMS3nnzUkBtdr3NCfq1C34fQV0iUGdlPtJaiiTBQPM\n'+
't4KUcQ1TaazB8TzhqwIDAQAB\n'+
'-----END PUBLIC KEY-----';

var signer = crypto.createSign('sha256');
signer.update('hola');
var sign = signer.sign(privateKey,'base64');

var verifier = crypto.createVerify('sha256');
verifier.update(sign);
var ver = verifier.verify(publicKey, sign,'base64');
console.log(ver);//&lt;--- always false!
</code></pre>

<p>I've tried to use different algorithms and encoding. I've read the PEM files with ""fs"", no luck also. What am I missing? BTW, those keys works perfectly using npm URSA module, so I know the keys are ok (can't use ursa in my project). Thanks!</p>
","<p>You need to verify the same data you signed: <code>verifier.update(sign);</code> should be <code>verifier.update('hola');</code></p>
","7574","<javascript><node.js><openssl><cryptojs>","17","17","1","2014-07-29 04:54:39","25008461","0","1","2141181","","2014-07-29 00:32:50","2014-07-29 00:27:44",""
"32188149","Difference between CryptoJS.enc.Base64.stringify() and normal Base64 encryption","<p>I'm trying to encrypt the following hash to base64:</p>

<pre><code>6bb984727b8c8c8017207e54b63976dc42ea9d24ad33bd5feeaa66869b650096
</code></pre>

<p>It's needed to access the API of a website. The website shows an example script in JavaScript using the <code>CryptoJS.enc.Base64.stringify()</code> method to encrypt the hash.
The result with this method is </p>

<pre><code>a7mEcnuMjIAXIH5Utjl23ELqnSStM71f7qpmhptlAJY=
</code></pre>

<p>However, every online base64 encryption tool I tried gives me the following result:</p>

<pre><code>NmJiOTg0NzI3YjhjOGM4MDE3MjA3ZTU0YjYzOTc2ZGM0MmVhOWQyNGFkMzNiZDVmZWVhYTY2ODY5YjY1MDA5Ng==
</code></pre>

<p>I need to create the encoded string in C++. I've also already tried 4 different base64encode implementations (OpenSSL and custom codes), but also there I get the above result and the API always answers my string is not correctly encoded. </p>

<p>So where is the difference, and does somebody know a C++ implementation for <code>CryptoJS.enc.Base64.stringify()</code>? </p>
","<p>Let's call</p>

<pre><code>a = ""6bb984727b8c8c8017207e54b63976dc42ea9d24ad33bd5feeaa66869b650096"";
b = ""a7mEcnuMjIAXIH5Utjl23ELqnSStM71f7qpmhptlAJY="";
c = ""NmJiOTg0NzI3YjhjOGM4MDE3MjA3ZTU0YjYzOTc2ZGM0MmVhOWQyNGFkMzNiZDVmZWVhYTY2ODY5YjY1MDA5Ng=="";
</code></pre>

<p>Both conversions are correct, but depend on what you actually want.</p>

<p>For example the following two equations hold</p>

<pre><code>toBase64FromBytes(toBytesFromUtf8(a)) == c
toBase64FromBytes(toBytesFromHex(a)) == b
</code></pre>

<p>It's a bad idea to trust some kind of online calculator, because they usually don't disclose how they encode stuff, so you will get arbitrary results. If you program it yourself, you get the expected results if you follow the documentation.</p>

<p>I suspect you got <code>a</code> by printing a hash or encryption result to the console like this:</p>

<pre><code>console.log(result.toString()); // a
</code></pre>

<p>Most <code>result</code> objects in CryptoJS are <code>WordArray</code> types. When you call the <code>toString()</code> function on such an object, you get a Hex-encoded string of that binary object.</p>

<p>If you print <code>result.toString(CryptoJS.enc.Base64)</code> then you get the Base64-encoded string of the binary result.</p>

<p>If you take <code>a</code> and directly encode it to Base64, then it is probably assumed that <code>a</code> is already a string (e.g. UTF-8 encoded). An online calculator doesn't know that it is Hex-encoded.</p>
","7430","<javascript><encoding><base64><cryptojs>","2","8","1","2015-08-24 17:42:05","32188410","1","","1816580","","2015-08-24 17:28:57","2015-08-24 17:27:37",""
"34061663","Triple DES encryption in JavaScript and decryption in PHP","<p>I am using JavaScript to encrypt and php to decrypt the string and vice versa but the problem is that on both the platforms the output being generated is different say If I encrypt a string ""abc"" on both the platforms they will produce different results although I am sure my encryption is correct because the string I am encrypting is decrypted in same language.</p>

<p>I understands that in this case there has to be something different in key or iv but do not know what it </p>

<p>Javascript code to encrypt string</p>

<pre><code>var encrypted = CryptoJS.TripleDES.encrypt(""Message"", ""SecretPassphrase"");
console.log(encrypted);console.log(String(encrypted));

var text = ""&lt;some plain text goes here&gt;"";
var key = ""00f74597de203655b1ebf5f410f10eb8"";
var useHashing = true;

if (useHashing) {
    key = CryptoJS.MD5(key).toString();
    key +=  key.substring(1, 16);
    console.log(key);
}
var textWordArray = CryptoJS.enc.Utf16.parse(text);
var keyHex = CryptoJS.enc.Hex.parse(key);
var iv = String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0);
var ivHex = CryptoJS.enc.Hex.parse(iv);
console.log('hexadecimal key: ' + keyHex + '\n');
console.log('iv: ' + iv + '\n');
console.log('hexadecimal iv: ' + ivHex + '\n');
var options = {
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
    iv: ivHex
};
var encrypted = CryptoJS.TripleDES.encrypt(textWordArray, keyHex, options);
var base64String = encrypted.toString();
console.log('base64: ' + base64String + '\n');
var decrypted = CryptoJS.TripleDES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(base64String)
}, keyHex, options);
console.log('decrypted: ' + decrypted.toString(CryptoJS.enc.Utf16));
</code></pre>

<p>PHP code to encrypt string</p>

<pre><code>//Generate a key from a hash
$key = md5(utf8_encode(""00f74597de203655b1ebf5f410f10eb8""), true);

//Take first 8 bytes of $key and append them to the end of $key.
$key .= substr($key, 0, 8);
//Padding for 3DES        
$blockSize = mcrypt_get_block_size('tripledes', 'ecb');
$len = strlen($value);
$pad = $blockSize - ($len % $blockSize);
$value .= str_repeat(chr($pad), $pad);

//Generating iv for 3DES
$iv = chr(0) . chr(0) . chr(0) . chr(0) . chr(0) . chr(0) . chr(0) . chr(0);

//Encrypt data
$encData = mcrypt_encrypt(MCRYPT_3DES, $key, $value, MCRYPT_MODE_CBC, $iv);

$value = base64_encode($encData);
</code></pre>

<p><strong>Example</strong> 
If I encrypt the string ""admin"" from javascript it gives me ""U2FsdGVkX1+y/zo1FJEZZ0aqPMQuwilOydbJjzIKpYw=""</p>

<p>Where as php give me ""AzZFzbnwp2Y="" </p>

<p><em>Note</em> I am using CryptoJSv3 plugin for triple DES*</p>
","<p>MD5 produces output of 128 bit, but a Triple DES key should be 192 bit long. That is why your PHP code copies the first 64 bits of the produced hash to the back. PHP and CryptoJS both use the EDE and this key copy leads to the key layout of <code>K1 || K2 || K1</code>.</p>

<p>You can do the same thing in CryptoJS. Since CryptoJS uses a <code>WordArray</code> to manage binary data internally as words of 32 bit, you can directly copy the first two words to the back of the internal array.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var pt = ""admin"";
document.querySelector(""#pt"").innerHTML = pt;

var key = ""00f74597de203655b1ebf5f410f10eb8"";
key = CryptoJS.MD5(key);

// copy 3DES subkey 1 to the last 64 bit to make a full 192-bit key
key.words[4] = key.words[0];
key.words[5] = key.words[1];

// create a 64-bit zero filled
var iv = CryptoJS.lib.WordArray.create(64/8);
var encrypted = CryptoJS.TripleDES.encrypt(pt, key, {iv: iv});
var encryptedBase64 = encrypted.toString();

document.querySelector(""#enc"").innerHTML = encryptedBase64;

var ct = {
    ciphertext: CryptoJS.enc.Base64.parse(encryptedBase64)
};
var decrypted = CryptoJS.TripleDES.decrypt(ct, key, {iv: iv});

document.querySelector(""#dec"").innerHTML = decrypted.toString(CryptoJS.enc.Utf8);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/tripledes.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/md5.js""&gt;&lt;/script&gt;
&lt;p&gt;Expected: ""AzZFzbnwp2Y=""&lt;br/&gt;Got: ""&lt;span id=""enc""&gt;&lt;/span&gt;""&lt;/p&gt;
&lt;p&gt;Expected: ""&lt;span id=""pt""&gt;&lt;/span&gt;""&lt;br/&gt;Got: ""&lt;span id=""dec""&gt;&lt;/span&gt;""&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<hr>

<p>This code is not very secure for those reasons:</p>

<ul>
<li>It uses Triple DES which only provides 112 bit of security, at best. You should use AES.</li>
<li>It uses a static IV. This is not semantically secure, because an attacker might see whether you sent the same message only by observing the ciphertexts. You need to use a random IV for each encryption and send it along with the ciphertext.</li>
<li>It doesn't use authentication. This system might be vulnerable to the padding oracle attack. It is an online attack which enables the attacker to decrypt <em>any</em> ciphertext with multiple tries. You either need to use an authenticated mode like GCM/EAX (not advisable for Triple DES) or run an HMAC-SHA256 over the ciphertext to produce the authentication tag and send it along with the ciphertext to verify it on the receiving end.</li>
</ul>
","7126","<javascript><php><encryption><cryptojs><tripledes>","0","1","1","2017-07-30 12:26:53","34067566","8","1","1816580","","2015-12-03 13:43:24","2015-12-03 09:01:31",""
"21291279","How to convert to string and back again with CryptoJs","<pre><code>var encrypted = CryptoJS.AES.encrypt(jsonStr, 'youngunicornsrunfree', { format: JsonFormatter });

//convert encrypted to a string for transfer
//convert string back to Crypto object so it can be decrypted.

var decrypted = CryptoJS.AES.decrypt(encrypted, ""youngunicornsrunfree"", { format: JsonFormatter });
</code></pre>

<p>The above two steps, work fine. But in between I need to convert encrypted to a string for transmitting over a network and then convert it back. How can I do this?</p>
","<p>Let's simplify this to be able to get to the problem. Firs we start with something like this:</p>

<pre><code>jsonStr = '{""something"":""else""}';
var encrypted = CryptoJS.AES.encrypt(jsonStr, 'youngunicornsrunfree');
var decrypted = CryptoJS.AES.decrypt(encrypted, ""youngunicornsrunfree"");
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>This gives us our answer jsonStr after we encrypt it then decrypt it. But say we want to send it to the server. We can do this easily by pulling out the encrypted string with <code>toString()</code>. Sounds to simple right? Say we need to send the encrypted jsonStr to the server. Try this</p>

<pre><code>jsonStr = '{""something"":""else""}';
var encrypted = CryptoJS.AES.encrypt(jsonStr, 'youngunicornsrunfree');
console.log(""We send this: ""+encrypted.toString());
</code></pre>

<p>Now say we sent something earlier and we are getting it back. We can do something like this:</p>

<pre><code>var messageFromServer = ""U2FsdGVkX19kyHo1s8+EwNuo/LQdL3RnSoDHU2ovA88RtyOs+PvpQ1UZssMNfflTemaMAwHDbnWagA8lQki5kQ=="";
var decrypted = CryptoJS.AES.decrypt(messageFromServer, ""youngunicornsrunfree"");
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","6683","<javascript><cryptojs>","3","10","1","2017-06-25 08:21:54","21291804","0","","1351167","","2017-06-25 08:21:54","2014-01-22 18:43:35",""
"16087621","using cryptojs to decrypt base64-encoded ciphertext with key / iv","<p>My ciphertext is encrypted in AES-128-CBC mode with PKCS1 padding. It's base64 encoded as are my keys and IVs. I'm trying to decrypt this ciphertext with CryptoJS but am having some difficulty. Here's my (non-working) code:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var plaintext = CryptoJS.AES.decrypt(
    CryptoJS.enc.Base64.parse(""...""),
    CryptoJS.enc.Base64.parse(""...""),
    { iv: CryptoJS.enc.Base64.parse(""..."") }
);
alert(plaintext.toString(CryptoJS.enc.Latin).length);
&lt;/script&gt;
</code></pre>

<p>All the .'s are base64-encoded strings. From the documentation I'm gathering that CryptoJS uses CBC mode and PKCS7 padding by default.</p>

<p>Any ideas why it's not working?</p>

<p>edit: my jsfiddle: <a href=""http://jsfiddle.net/NSmxY/1/"" rel=""nofollow"">http://jsfiddle.net/NSmxY/1/</a></p>
","","6624","<javascript><aes><cryptojs>","1","","0","2016-10-17 13:46:08","","2","","569976","","2016-10-17 13:46:08","2013-04-18 15:53:22",""
"36474899","Encrypt in javascript and decrypt in C# with AES algorithm","<p>I tried to encrypt in angular using AES librery from <a href=""http://www.c-sharpcorner.com/UploadFile/4d9083/encrypt-in-javascript-and-decrypt-in-C-Sharp-with-aes-algorithm-i/"" rel=""nofollow"">AES</a>.</p>

<p>I encrypt string using the <code>CryptoJS.AES.encrypt()</code> method from AES.</p>

<p>here my code:</p>

<pre><code>  var txtloginKod = 'Some String...';   
  var key = CryptoJS.enc.Utf8.parse('8080808080808080');
  var iv = CryptoJS.enc.Utf8.parse('8080808080808080');
  var  encryptedlogin = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(txtloginKod), key,
  {
      keySize: 128 / 8,
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
  });
</code></pre>

<p>The method <code>CryptoJS.AES.encrypt()</code> return a Object to my <code>encryptedlogin</code> variable.</p>

<p>I dont know how send this object to my WCF Web server in C#</p>

<p>When I try to send the hole object (and define the Web service method to expect get C# Object) - I got this error:</p>

<p><strong>""Converting circular structure to JSON""</strong>  </p>
","<p>You would need to serialize the ciphertext yourself. There are many ways to do it.</p>

<p>If the key is not a string, but a <code>WordArray</code> (as in your case), then a simple <code>encryptedlogin.toString()</code> would produce a Base64 encoded string only containing the ciphertext. Remember that you need to include the enc-base64.js source file.</p>

<p>If the ""key"" (actually password) is a string, then an OpenSSL-compatible key derivation is applied. In that case <code>encryptedlogin.toString()</code> would be a Base64 encoded string which contains the ""Salted__"" string, 8 byte random salt and the ciphertext.</p>

<p>If you only want to get the ciphertext then <code>encryptedlogin.ciphertext.toString()</code> will give you a Hex-encoded string which contains only the ciphertext and <code>encryptedlogin.iv.toString()</code> will give you a Hex-encoded IV. You can produce a Base64-encoded string in this way <code>encryptedlogin.ciphertext.toString(CryptoJS.enc.Base64)</code>.</p>

<p>Remember that the IV must be randomly chosen for every encryption in order to provide semantic security. It doesn't have to be secret, so you can send it along with the ciphertext.</p>

<p>On the server side, you would decode the values (Base64 or Hex depending on what you used during encryption) and use them with the AesCryptoServiceProvider class (or similar) to decrypt the ciphertext.</p>

<hr>

<p>Remember that you additionally need to authenticate your ciphertext in order to detect (malicious) manipulation. This can be done with an encrypt-then-MAC scheme with a strong MAC like HMAC-SHA256.</p>

<p>Also, if the key is transmitted along with the ciphertext or over an insecure channel, then this is basically just data obfuscation and doesn't provide real security. See more: <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow"">Javascript Cryptography Considered Harmful</a></p>
","6586","<javascript><encryption><aes><cryptojs>","2","1","3","2019-09-26 06:35:40","","2","2","1816580","","2016-04-07 13:29:04","2016-04-07 11:30:57",""
"36474899","Encrypt in javascript and decrypt in C# with AES algorithm","<p>I tried to encrypt in angular using AES librery from <a href=""http://www.c-sharpcorner.com/UploadFile/4d9083/encrypt-in-javascript-and-decrypt-in-C-Sharp-with-aes-algorithm-i/"" rel=""nofollow"">AES</a>.</p>

<p>I encrypt string using the <code>CryptoJS.AES.encrypt()</code> method from AES.</p>

<p>here my code:</p>

<pre><code>  var txtloginKod = 'Some String...';   
  var key = CryptoJS.enc.Utf8.parse('8080808080808080');
  var iv = CryptoJS.enc.Utf8.parse('8080808080808080');
  var  encryptedlogin = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(txtloginKod), key,
  {
      keySize: 128 / 8,
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
  });
</code></pre>

<p>The method <code>CryptoJS.AES.encrypt()</code> return a Object to my <code>encryptedlogin</code> variable.</p>

<p>I dont know how send this object to my WCF Web server in C#</p>

<p>When I try to send the hole object (and define the Web service method to expect get C# Object) - I got this error:</p>

<p><strong>""Converting circular structure to JSON""</strong>  </p>
","<p>Check pls <a href=""https://social.msdn.microsoft.com/Forums/vstudio/en-US/47800a60-4461-4f8e-a8d1-751fa62c7884/aes-encrypt-in-javascript-and-decrypt-in-c?forum=csharpgeneral"" rel=""nofollow noreferrer"">https://social.msdn.microsoft.com/Forums/vstudio/en-US/47800a60-4461-4f8e-a8d1-751fa62c7884/aes-encrypt-in-javascript-and-decrypt-in-c?forum=csharpgeneral</a></p>

<p>Also, you should use CryptoJS v3.1.2 AES realization to use it. You can download it here : <a href=""https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/crypto-js/CryptoJS%20v3.1.2.zip"" rel=""nofollow noreferrer"">https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/crypto-js/CryptoJS%20v3.1.2.zip</a></p>

<p>Js side code you can find here : jsfiddle.net/aEKw5/22/</p>

<p>So using info above you can encode at C# side, and decode it on js. or vice versa.</p>
","6586","<javascript><encryption><aes><cryptojs>","2","-1","3","2019-09-26 06:35:40","","2","2","1816580","","2016-04-07 13:29:04","2016-04-07 11:30:57",""
"36474899","Encrypt in javascript and decrypt in C# with AES algorithm","<p>I tried to encrypt in angular using AES librery from <a href=""http://www.c-sharpcorner.com/UploadFile/4d9083/encrypt-in-javascript-and-decrypt-in-C-Sharp-with-aes-algorithm-i/"" rel=""nofollow"">AES</a>.</p>

<p>I encrypt string using the <code>CryptoJS.AES.encrypt()</code> method from AES.</p>

<p>here my code:</p>

<pre><code>  var txtloginKod = 'Some String...';   
  var key = CryptoJS.enc.Utf8.parse('8080808080808080');
  var iv = CryptoJS.enc.Utf8.parse('8080808080808080');
  var  encryptedlogin = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(txtloginKod), key,
  {
      keySize: 128 / 8,
      iv: iv,
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.Pkcs7
  });
</code></pre>

<p>The method <code>CryptoJS.AES.encrypt()</code> return a Object to my <code>encryptedlogin</code> variable.</p>

<p>I dont know how send this object to my WCF Web server in C#</p>

<p>When I try to send the hole object (and define the Web service method to expect get C# Object) - I got this error:</p>

<p><strong>""Converting circular structure to JSON""</strong>  </p>
","<p>I too had the requirement to send encrypted JSON object to .Net CORE API 2.0 and searched on internet to find if there is any help. I know by now you would have solved this issue but to help anyone interested I am providing my solution to help them.</p>

<p>With the sample codes I found here on stackoverflow, I managed to implement the solution. The tricky bit is the key and IV has to be 16 in length for the code to work.</p>

<pre><code>public static encrypt(model: any) {
        const key = CryptoJS.enc.Utf8.parse('TestMyOwnKeyForI');
        const iv = CryptoJS.enc.Utf8.parse('TestMyOwnIV1ForI');
        // padding and truncating
        const encryptedMessage = CryptoJS.AES.encrypt(JSON.stringify(model), key, {            
            keySize: 128 / 8,
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        }).toString();

        return encryptedMessage;
}
</code></pre>

<p>In CORE I've implemented my customer model binding provider as follows:</p>

<pre><code>public class DecryptModelBinderProvider : IModelBinderProvider
    {
        public IModelBinder GetBinder(ModelBinderProviderContext context)
        {
            if (context.Metadata.ModelType == typeof(MyModel))
                return new DecryptModelBinder();

            return null;
        }
    }
</code></pre>

<p>Then my own decryptmodelbinder as follows:</p>

<pre><code>public class DecryptModelBinder : IModelBinder
    {
        public Task BindModelAsync(ModelBindingContext bindingContext)
        {
            if (bindingContext == null)
                throw new ArgumentNullException(nameof(bindingContext));
            using (var sr = new StreamReader(bindingContext.HttpContext.Request.Body))
            {
                string valueFromBody = sr.ReadToEnd();

                if (valueFromBody != null &amp;&amp; valueFromBody.Length &gt; 0)
                {
                    var decrypted = Encryption.DecryptString(valueFromBody, ""TestMyOwnKeyForI"");

                    var model = JsonConvert.DeserializeObject(decrypted, bindingContext.ModelType);

                    bindingContext.Result = ModelBindingResult.Success(model);
                    bindingContext.Model = model;        
                }

            }

            return Task.CompletedTask;
        }
    }
</code></pre>
","6586","<javascript><encryption><aes><cryptojs>","2","1","3","2019-09-26 06:35:40","","2","2","1816580","","2016-04-07 13:29:04","2016-04-07 11:30:57",""
"24414258","cryptojs aes 256 encryption and java decryption","<p>I encrypted message with cryptojs aes 256 on the client side. But couldn't decrypt it on the java side. First, I pass the key directly to the server side as hex, then convert it from hex to java bytearray. It didn't work. Then I pass the phrase, salt, iv to the server as hex. Then generate the key. It still didn't work. It always to complain the key length is not right.</p>

<p>Client side:</p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(16);
var salt_hex = CryptoJS.enc.Hex.stringify(salt);

var iv = CryptoJS.lib.WordArray.random(256/32);
var iv_hex = CryptoJS.enc.Hex.stringify(iv);


var key = CryptoJS.PBKDF2(secret, salt, { keySize: 256/32, iterations: 10 });
var key_hex=CryptoJS.enc.Hex.stringify(key);

var encrypted = CryptoJS.AES.encrypt(plaintext, key, { iv: iv });    

var encryptedtxt = secret+"":""+salt_hex+"":""+iv_hex+"":""+encrypted.ciphertext.toString(CryptoJS.enc.Base64)+"":""+key_hex;
</code></pre>

<p>Server side:</p>

<pre><code>    if (encrypted != null)
    {
        //Get the passphras, salt, IV and msg
        String data[] = encrypted.split("":"");
        String passphrase = data[0];
        String salt_hex = data[1];
        String iv_hex = data[2];
        String msg64 = data[3];
        String jskey_hex = data[4];
        byte[] jskey = hexStringToByteArray(jskey_hex);
        byte[] iv = hexStringToByteArray(iv_hex);
        byte[] salt = hexStringToByteArray(salt_hex);
        BASE64Decoder decoder = new BASE64Decoder();
        byte[] msg = decoder.decodeBuffer(msg64);

        try {
             //theClear = AES.decrypt(encrypted);
            /* Decrypt the message, given derived key and initialization vector. */
            SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
            KeySpec spec = new PBEKeySpec(passphrase.toCharArray(), salt, 10, 256/32);
            SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
            String plaintext = new String(cipher.doFinal(msg), ""UTF-8"");
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
</code></pre>
","<p>Finally figured it out. By default JRE 7 doesn't support 256-bit key. I had to download the new jars from <a href=""http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html"" rel=""nofollow"">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a> and overwrite them in the jre/lib/security folder. You will have to do the similar thing for the Websphere 6 or 7. If you don't do it, it prompts ""illegal key size"". I've also seen ""illegal key size x"", where x is a number. That means the key size is not right. Below are the code.</p>

<p>Server side:</p>

<pre><code>//@Override
public String getClearText() throws IOException {
    // Get the body
    String encrypted = super.getParameter(""aes""); //base64

    if (encrypted != null)
    {
        //Get the passphras, salt, IV and msg
        String data[] = encrypted.split("":"");
        String passphrase = data[0];
        String salt_hex = data[1];
        String iv_hex = data[2];
        String msg64 = data[3];
        String jskey_hex = data[4];
        byte[] jskey = hexStringToByteArray(jskey_hex);
        byte[] iv = hexStringToByteArray(iv_hex);
        byte[] salt = hexStringToByteArray(salt_hex);
        BASE64Decoder decoder = new BASE64Decoder();
        byte[] msg = decoder.decodeBuffer(msg64);
        String plaintext = """";
        try {
            SecretKey key = new SecretKeySpec(jskey, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
            plaintext = new String(cipher.doFinal(msg), ""UTF-8"");
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        System.out.println(""in filter, decrypted: "" +plaintext);
    }
    return plaintext;
}
</code></pre>

<p>Client:</p>

<pre><code>$(function() {

$('#test').on('submit', function() {

var plaintext = $('#text').val();
var secret = '0123456789abcdef';

var salt = CryptoJS.lib.WordArray.random(16);
var salt_hex = CryptoJS.enc.Hex.stringify(salt);

var iv = CryptoJS.lib.WordArray.random(16);
var iv_hex = CryptoJS.enc.Hex.stringify(iv);


var key = CryptoJS.PBKDF2(secret, salt, { keySize: 256/32, iterations: 1 });
//var key_hex=CryptoJS.enc.Hex.stringify(key);
var key_hex= key;

var encrypted = CryptoJS.AES.encrypt(plaintext, key, { iv: iv });    


//decrypt
var decrypted = CryptoJS.AES.decrypt(
      encrypted,
      CryptoJS.enc.Hex.parse(key_hex),
      { iv: CryptoJS.enc.Hex.parse(iv_hex) });

var text = decrypted.toString( CryptoJS.enc.Utf8 );
//console.log(encrypted);

// ----- base64 encoding ----------
var encryptedtxt =     secret+"":""+salt_hex+"":""+iv_hex+"":""+encrypted.ciphertext.toString(CryptoJS.enc.Base64)+"":""+key_hex;
console.log('html - ciphere txt : ' +encryptedtxt);

// ---- testing ----
//var decrypted = CryptoJS.AES.decrypt(encrypted, key,{iv: CryptoJS.enc.Utf8.parse(iv)});
//console.log(decrypted.toString(CryptoJS.enc.Utf8));

post ('/E2Efilter/TheServlet', encryptedtxt);
return false;
});
</code></pre>
","6437","<java><aes><cryptojs>","1","1","1","2018-04-09 12:35:00","","5","4","1033581","","2018-04-09 12:35:00","2014-06-25 16:41:16",""
"21880444","CryptoJS MD5 not converting word array, SHA256 works fine","<p>I'm using the CryptoJS library for Javascript MD5 and SHA256 hashing: <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a></p>

<p>The SHA256 stuff is working fine, but I can't convert the MD5 hash result from a word array back into a string. Below is the code I'm using to just degug the problem - I've subbed out the actual hash results, and added the <code>console.log()</code> output as comments</p>

<pre><code>email_hash = $rootScope.session.email.toLowerCase();

console.log('email', email_hash);
// email email@example.com

sha_hash = CryptoJS.SHA256(email_hash).toString(CryptoJS.enc.Hex);

console.log('sha', sha_hash);
// sha SHA256-VALUE-OUTPUTS-FINE

email_hash = CryptoJS.MD5( email_hash );

console.log( JSON.stringify( email_hash ) );
//{""words"":[0000000000,-0000000000,-00000000000,0000000000],""sigBytes"":16}

a = email_hash.toString( CryptoJS.enc.Latin1 );
b = email_hash.toString( CryptoJS.enc.Hex );

console.log( a, b );
// [object Object] [object Object] 
</code></pre>

<p>What am I doing wrong with the MD5 result?</p>
","<p>Oh ok - the answer is not in the code I posted.</p>

<p>I was using version 3.0.2 of the SHA256 code, and version 3.1.2 for MD5.</p>

<ul>
<li><a href=""https://github.com/sytelus/CryptoJS/blob/master/rollups/sha256.js"" rel=""nofollow"">https://github.com/sytelus/CryptoJS/blob/master/rollups/sha256.js</a></li>
<li><a href=""https://github.com/sytelus/CryptoJS/blob/master/rollups/md5.js"" rel=""nofollow"">https://github.com/sytelus/CryptoJS/blob/master/rollups/md5.js</a></li>
</ul>

<p>Updating SHA256 to 3.1.2, so they are both on the same version, has fixed it. I'm including the SHA256 before the MD5, so it must have been overwriting something in the MD5 file.</p>

<ul>
<li><a href=""https://github.com/sytelus/CryptoJS/blob/master/rollups/sha256.js"" rel=""nofollow"">https://github.com/sytelus/CryptoJS/blob/master/rollups/sha256.js</a></li>
</ul>
","6317","<javascript><hash><md5><cryptojs>","0","2","1","2016-10-28 23:54:08","21880761","0","","","","","2014-02-19 12:26:03",""
"13981832","How do I use Sha256 on a file(binary file such as images) in javascript?","<p>I am trying to do a Sha256 on a file in Javascript. I used <a href=""http://www.html5rocks.com/en/tutorials/file/dndfiles/"" rel=""nofollow"">FileReader(HTML5)</a> to read in a file. I use the readAsBinaryString function in the FileReader to pass in the images file. Then on the FileReader.onload function I pass in the evt.target.result to the SHA256 method in the <a href=""http://code.google.com/p/crypto-js/#PBKDF2"" rel=""nofollow"">CryptoJs API</a>. I am able to successfully get a hash value but it is not correct. When I pass in a text file, it works fine but not image file. </p>

<p>Code(Should be able to copy the code below to a HTML file and run it on firefox - press the ""entire file"" button):</p>

<pre><code>&lt;style&gt;
  #byte_content {
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    overflow-x: hidden;
  }
  #byte_range { margin-top: 5px; }
&lt;/style&gt;

&lt;input type=""file"" id=""files"" name=""file"" /&gt; Read bytes: 
&lt;span class=""readBytesButtons""&gt;
  &lt;button data-startbyte=""0"" data-endbyte=""4""&gt;1-5&lt;/button&gt;
  &lt;button data-startbyte=""5"" data-endbyte=""14""&gt;6-15&lt;/button&gt;
  &lt;button data-startbyte=""6"" data-endbyte=""7""&gt;7-8&lt;/button&gt;
  &lt;button&gt;entire file&lt;/button&gt;
&lt;/span&gt;
&lt;div id=""byte_range""&gt;&lt;/div&gt;&lt;BR&gt;
&lt;div id=""byte_content""&gt;&lt;/div&gt;&lt;BR&gt;
&lt;div id=""crypto_sha256""&gt;&lt;/div&gt;

&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script&gt;

  var sha256;

  function readBlob(opt_startByte, opt_stopByte) {

    var files = document.getElementById('files').files;
    if (!files.length) {
      alert('Please select a file!');
      return;
    }

    var file = files[0];
    var start = parseInt(opt_startByte) || 0;
    var stop = parseInt(opt_stopByte) || file.size - 1;

    var reader = new FileReader();

    // If we use onloadend, we need to check the readyState.
    reader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
        document.getElementById('byte_content').textContent = evt.target.result;
        document.getElementById('byte_range').textContent = 
            ['Read bytes: ', start + 1, ' - ', stop + 1,
             ' of ', file.size, ' byte file'].join('');

        //**UPDATED SOLUTION: Since its binary data, the message needs to be converted from string to bytes using Latin1**
            sha256.update(CryptoJS.enc.Latin1.parse(evt.target.result));

        var hash = sha256.finalize();

        document.getElementById('crypto_sha256').textContent = ['SHA-256: ', hash].join('');
      }
    };

    var blob = file.slice(start, stop + 1);
    reader.readAsBinaryString(blob);
  }

  document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
    if (evt.target.tagName.toLowerCase() == 'button') {
      var startByte = evt.target.getAttribute('data-startbyte');
      var endByte = evt.target.getAttribute('data-endbyte');

      sha256 = CryptoJS.algo.SHA256.create();

      readBlob(startByte, endByte);
    }
  }, false);
&lt;/script&gt;
</code></pre>

<p>Sample outputs:</p>

<ol>
<li><p>Testing a ""text"" file:</p>

<ul>
<li>SHA256 generated by Javascript:<br>
<strong>78cb5e86455dc8e3bc20fe17e0213a938281216d57b31f8307f5bca67c37bb09</strong></li>
<li>SHA256 generated by cygwin on the same file:<BR>
$ sha256sum Phillips.txt
<strong>78cb5e86455dc8e3bc20fe17e0213a938281216d57b31f8307f5bca67c37bb09</strong> *SomeTestFile.txt</li>
</ul></li>
<li><p>Testing a ""binary"" file(pdf):</p>

<ul>
<li>SHA256 generated by Javascript:<BR>
<strong>57f93c1d20a8ad8ade984a1d9756c1a40600bd8a7527601945c4e0b5e042c605</strong></li>
<li>SHA256 generated by cygwin on the same file:<BR>
$ sha256sum Smoke\ Detector\ Brochure.pdf
<strong>57f93c1d20a8ad8ade984a1d9756c1a40600bd8a7527601945c4e0b5e042c605</strong> *Smoke Detector Brochure.pdf</li>
</ul></li>
</ol>
","<p>I know this question is quite old but I figured I'd share what I know anyways.</p>

<p>You can do this more easily by doing what I discuss in this answer <a href=""https://stackoverflow.com/a/17848266/2226207"">https://stackoverflow.com/a/17848266/2226207</a></p>

<p>Basically you can include components/lib-typedarrays-min.js and then do the following in code.</p>

<pre><code>var reader = new FileReader();

// If we use onloadend, we need to check the readyState.
reader.onloadend = function(evt) {
  if (evt.target.readyState == FileReader.DONE) { // DONE == 2

    var wordArray = CryptoJS.lib.WordArray.create(e.target.result);
    var hash = CryptoJS.SHA256(wordArray);
  }
};

var blob = file.slice(start, stop + 1);
reader.readAsArrayBuffer(blob);
</code></pre>

<p>I haven't tested the above solution but it should work fine.</p>
","6258","<javascript><binary><filereader><sha256><cryptojs>","3","2","2","2015-04-22 13:18:40","","7","2","422930","","2012-12-24 15:25:14","2012-12-20 22:53:19",""
"13981832","How do I use Sha256 on a file(binary file such as images) in javascript?","<p>I am trying to do a Sha256 on a file in Javascript. I used <a href=""http://www.html5rocks.com/en/tutorials/file/dndfiles/"" rel=""nofollow"">FileReader(HTML5)</a> to read in a file. I use the readAsBinaryString function in the FileReader to pass in the images file. Then on the FileReader.onload function I pass in the evt.target.result to the SHA256 method in the <a href=""http://code.google.com/p/crypto-js/#PBKDF2"" rel=""nofollow"">CryptoJs API</a>. I am able to successfully get a hash value but it is not correct. When I pass in a text file, it works fine but not image file. </p>

<p>Code(Should be able to copy the code below to a HTML file and run it on firefox - press the ""entire file"" button):</p>

<pre><code>&lt;style&gt;
  #byte_content {
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    overflow-x: hidden;
  }
  #byte_range { margin-top: 5px; }
&lt;/style&gt;

&lt;input type=""file"" id=""files"" name=""file"" /&gt; Read bytes: 
&lt;span class=""readBytesButtons""&gt;
  &lt;button data-startbyte=""0"" data-endbyte=""4""&gt;1-5&lt;/button&gt;
  &lt;button data-startbyte=""5"" data-endbyte=""14""&gt;6-15&lt;/button&gt;
  &lt;button data-startbyte=""6"" data-endbyte=""7""&gt;7-8&lt;/button&gt;
  &lt;button&gt;entire file&lt;/button&gt;
&lt;/span&gt;
&lt;div id=""byte_range""&gt;&lt;/div&gt;&lt;BR&gt;
&lt;div id=""byte_content""&gt;&lt;/div&gt;&lt;BR&gt;
&lt;div id=""crypto_sha256""&gt;&lt;/div&gt;

&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script&gt;

  var sha256;

  function readBlob(opt_startByte, opt_stopByte) {

    var files = document.getElementById('files').files;
    if (!files.length) {
      alert('Please select a file!');
      return;
    }

    var file = files[0];
    var start = parseInt(opt_startByte) || 0;
    var stop = parseInt(opt_stopByte) || file.size - 1;

    var reader = new FileReader();

    // If we use onloadend, we need to check the readyState.
    reader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
        document.getElementById('byte_content').textContent = evt.target.result;
        document.getElementById('byte_range').textContent = 
            ['Read bytes: ', start + 1, ' - ', stop + 1,
             ' of ', file.size, ' byte file'].join('');

        //**UPDATED SOLUTION: Since its binary data, the message needs to be converted from string to bytes using Latin1**
            sha256.update(CryptoJS.enc.Latin1.parse(evt.target.result));

        var hash = sha256.finalize();

        document.getElementById('crypto_sha256').textContent = ['SHA-256: ', hash].join('');
      }
    };

    var blob = file.slice(start, stop + 1);
    reader.readAsBinaryString(blob);
  }

  document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
    if (evt.target.tagName.toLowerCase() == 'button') {
      var startByte = evt.target.getAttribute('data-startbyte');
      var endByte = evt.target.getAttribute('data-endbyte');

      sha256 = CryptoJS.algo.SHA256.create();

      readBlob(startByte, endByte);
    }
  }, false);
&lt;/script&gt;
</code></pre>

<p>Sample outputs:</p>

<ol>
<li><p>Testing a ""text"" file:</p>

<ul>
<li>SHA256 generated by Javascript:<br>
<strong>78cb5e86455dc8e3bc20fe17e0213a938281216d57b31f8307f5bca67c37bb09</strong></li>
<li>SHA256 generated by cygwin on the same file:<BR>
$ sha256sum Phillips.txt
<strong>78cb5e86455dc8e3bc20fe17e0213a938281216d57b31f8307f5bca67c37bb09</strong> *SomeTestFile.txt</li>
</ul></li>
<li><p>Testing a ""binary"" file(pdf):</p>

<ul>
<li>SHA256 generated by Javascript:<BR>
<strong>57f93c1d20a8ad8ade984a1d9756c1a40600bd8a7527601945c4e0b5e042c605</strong></li>
<li>SHA256 generated by cygwin on the same file:<BR>
$ sha256sum Smoke\ Detector\ Brochure.pdf
<strong>57f93c1d20a8ad8ade984a1d9756c1a40600bd8a7527601945c4e0b5e042c605</strong> *Smoke Detector Brochure.pdf</li>
</ul></li>
</ol>
","<p>Here is a simple solution found : <a href=""https://code.google.com/p/crypto-js/issues/detail?id=62"" rel=""nofollow"">https://code.google.com/p/crypto-js/issues/detail?id=62</a></p>

<blockquote>
  <p>When you pass a string to a hasher, it's converted to bytes using UTF-8. That's to ensure foreign characters are not clipped. Since you're working with binary data, you'll want to convert the string to bytes using Latin1.</p>
</blockquote>

<pre><code>sha256.update(CryptoJS.enc.Latin1.parse(evt.target.result));
</code></pre>
","6258","<javascript><binary><filereader><sha256><cryptojs>","3","2","2","2015-04-22 13:18:40","","7","2","422930","","2012-12-24 15:25:14","2012-12-20 22:53:19",""
"25567468","How to decrypt an ArrayBuffer?","<p>I've been trying to decrypt an ArrayBuffer object using CryptoJS, but so far it always returns a blank WordArray. The files (images) are encrypted in an iOS and Android app, sent to a server, and downloaded in this web app to be decrypted and displayed. The iOS and Android apps are able to decrypt the files without problems, so there's nothing wrong with the encryption process. </p>

<p>The files are downloaded with an <code>XMLHttpRequest</code> with <code>responseType</code> set to <code>arraybuffer</code>. Here's my code so far:</p>

<pre><code>// Decrypt a Base64 encrypted string (this works perfectly)
String.prototype.aesDecrypt = function(key) {

    var nkey = CryptoJS.enc.Hex.parse(key.sha256());
    return CryptoJS.AES.decrypt(this.toString(), nkey, {
        iv: CryptoJS.enc.Hex.parse('00000000000000000000000000000000'),
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }).toString(CryptoJS.enc.Utf8);

}

// Decrypt a plain encrypted ArrayBuffer (this is the problem, it always outputs an empty WordArray)
ArrayBuffer.prototype.aesDecrypt = function(key) {

    // Get key
    if (!key) return null;
    var nkey = CryptoJS.enc.Hex.parse(key.sha256());

    // Get input (if I pass the ArrayBuffer directly to the create function, it returns
    // a WordList with sigBytes set to NaN)
    //var input = CryptoJS.lib.WordArray.create(this);
    var input = CryptoJS.lib.WordArray.create(new Uint8Array(this));

    // Decrypt
    var output = CryptoJS.AES.decrypt(input, nkey, {
        iv: CryptoJS.enc.Hex.parse('00000000000000000000000000000000'),
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });

    // Output is an empty WordList
    console.log(""Output: "", output);

}
</code></pre>

<p>Another question I have is how do you convert a <code>WordArray</code> to an <code>ArrayBuffer</code>?</p>
","<p>The conversion of <code>ArrayBuffer -&gt; WordArray</code> has been discussed in <em>CryptoJS's</em> <a href=""http://code.google.com/p/crypto-js/issues/detail?id=46"" rel=""noreferrer"">issue 46</a>. For that reason a <code>TypedWordArray</code>where you can also pass an <code>ArrayBuffer</code> has been added.</p>

<hr>

<p>To use that additionally include the following script:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1/build/components/lib-typedarrays.js""&gt;&lt;/script&gt;
</code></pre>

<p>Then you can simply do:</p>

<pre><code>var wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);

/* perform decryption of `wordArray` */
</code></pre>

<hr>

<p>To reconvert the resulting <code>decryptedWordArray</code> to an <code>ArrayBuffer</code>, the simplest approach would probably be, to first convert it to a <code>Base64-String</code> (as discussed <a href=""https://stackoverflow.com/questions/11889329/word-array-to-string"">here</a>) and then decode that String to the desired <code>ArrayBuffer</code> (see <a href=""https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#Appendix.3A_Decode_a_Base64_string_to_Uint8Array_or_ArrayBuffer"" rel=""noreferrer"">here</a>). The whole procedure would look something like this:</p>

<pre><code>dcWordArray = ... // your decrypted WordArray
dcBase64String = dcWordArray.toString(CryptoJS.enc.Base64); // to Base64-String
dcArrayBuffer = base64DecToArr(dcBase64String).buffer; // to ArrayBuffer
</code></pre>

<p><strong>Edit:</strong></p>

<p>For a more efficient conversion (no intermediate <code>Base64String</code> necessary) check out <em>Aletheios</em> answer to <a href=""https://stackoverflow.com/questions/11889329/word-array-to-string"">that</a> question (the function <code>wordToByteArray(wordArray)</code> and then do <code>.buffer</code>).</p>
","6234","<javascript><encryption><cryptojs><arraybuffer>","8","9","2","2019-09-17 08:28:57","25611179","0","8","","","","2014-08-29 11:34:31",""
"25567468","How to decrypt an ArrayBuffer?","<p>I've been trying to decrypt an ArrayBuffer object using CryptoJS, but so far it always returns a blank WordArray. The files (images) are encrypted in an iOS and Android app, sent to a server, and downloaded in this web app to be decrypted and displayed. The iOS and Android apps are able to decrypt the files without problems, so there's nothing wrong with the encryption process. </p>

<p>The files are downloaded with an <code>XMLHttpRequest</code> with <code>responseType</code> set to <code>arraybuffer</code>. Here's my code so far:</p>

<pre><code>// Decrypt a Base64 encrypted string (this works perfectly)
String.prototype.aesDecrypt = function(key) {

    var nkey = CryptoJS.enc.Hex.parse(key.sha256());
    return CryptoJS.AES.decrypt(this.toString(), nkey, {
        iv: CryptoJS.enc.Hex.parse('00000000000000000000000000000000'),
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }).toString(CryptoJS.enc.Utf8);

}

// Decrypt a plain encrypted ArrayBuffer (this is the problem, it always outputs an empty WordArray)
ArrayBuffer.prototype.aesDecrypt = function(key) {

    // Get key
    if (!key) return null;
    var nkey = CryptoJS.enc.Hex.parse(key.sha256());

    // Get input (if I pass the ArrayBuffer directly to the create function, it returns
    // a WordList with sigBytes set to NaN)
    //var input = CryptoJS.lib.WordArray.create(this);
    var input = CryptoJS.lib.WordArray.create(new Uint8Array(this));

    // Decrypt
    var output = CryptoJS.AES.decrypt(input, nkey, {
        iv: CryptoJS.enc.Hex.parse('00000000000000000000000000000000'),
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });

    // Output is an empty WordList
    console.log(""Output: "", output);

}
</code></pre>

<p>Another question I have is how do you convert a <code>WordArray</code> to an <code>ArrayBuffer</code>?</p>
","<p>you can use the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt"" rel=""nofollow noreferrer""><code>web crypto</code> API</a> to directly decrypt arrayBuffer.
No need to convert binary data to a string, which is so inefficient, and it could cause memory and CPU rises.</p>
","6234","<javascript><encryption><cryptojs><arraybuffer>","8","-2","2","2019-09-17 08:28:57","25611179","0","8","","","","2014-08-29 11:34:31",""
"20738772","node crypto-js AES encrypt -> decrypt usage?","<p>I am trying to generate a simple test of <a href=""https://github.com/evanvosberg/crypto-js"" rel=""nofollow"">crypto-js on node</a> as follows:</p>

<pre><code>'use strict';

var AES = require('crypto-js/aes');
var key = 'passPhrase';
var ecr = function(str)
{
    return AES.encrypt(str, key);
};
var dcr = function(str)
{
    return AES.decrypt(str, key);
};

console.log(dcr(ecr('hello world')));
// expected result is:  hello world
</code></pre>

<p>The actual result is:</p>

<pre><code>{ words: [ 1751477356, 1864398703, 1919706117, 84215045 ],
  sigBytes: 11 }
</code></pre>

<p>What is the right usage?</p>
","<p>Oh well..
Working Code:</p>

<pre><code>'use strict';

var CryptoJS = require('crypto-js');
var key = 'pass phrase';
var ecr = function(str)
{
    return CryptoJS.AES.encrypt(str, key);
};
var dcr = function(str)
{
    return CryptoJS.AES.decrypt(str, key)
        .toString(CryptoJS.enc.Utf8);
};

console.log(dcr(ecr('hello world')));
</code></pre>

<p>Result:</p>

<pre><code>hello world
</code></pre>
","6203","<javascript><node.js><cryptojs>","2","0","2","2018-02-05 18:59:58","20748281","0","","972240","","2016-06-27 09:38:22","2013-12-23 07:20:00",""
"20738772","node crypto-js AES encrypt -> decrypt usage?","<p>I am trying to generate a simple test of <a href=""https://github.com/evanvosberg/crypto-js"" rel=""nofollow"">crypto-js on node</a> as follows:</p>

<pre><code>'use strict';

var AES = require('crypto-js/aes');
var key = 'passPhrase';
var ecr = function(str)
{
    return AES.encrypt(str, key);
};
var dcr = function(str)
{
    return AES.decrypt(str, key);
};

console.log(dcr(ecr('hello world')));
// expected result is:  hello world
</code></pre>

<p>The actual result is:</p>

<pre><code>{ words: [ 1751477356, 1864398703, 1919706117, 84215045 ],
  sigBytes: 11 }
</code></pre>

<p>What is the right usage?</p>
","<p>I modified the code to deal any object:</p>

<pre><code>'use strict';

var CryptoJS = require('crypto-js');
var key = 'pass phrase';
var ecr = function(obj)
{
    return CryptoJS.AES.encrypt(JSON.stringify(obj), key);
};
var dcr = function(obj)
{
    return JSON.parse(CryptoJS.AES.decrypt(obj, key)
        .toString(CryptoJS.enc.Utf8));
};

var s = 'hello world';
console.log(dcr(ecr(s)));

var obj = {
    id: 'ken',
    key: 'password'
};
console.log(dcr(ecr(obj)));
</code></pre>
","6203","<javascript><node.js><cryptojs>","2","3","2","2018-02-05 18:59:58","20748281","0","","972240","","2016-06-27 09:38:22","2013-12-23 07:20:00",""
"17819820","How to get correct SHA1 hash of BLOB using CryptoJS?","<p>CryptoJS v3.1.2, sha1.js rollup</p>

<p>In JS I want to calculate the SHA1 of a blob before sending it to the server. On the server I want to calculate the SHA1 of the resulting file and compare it to the SHA1 received from JS. The problem is that the hash generated by CryptoJS.SHA1() is incorrect (always 9844f81e1408f6ecb932137d33bed7cfdcf518a3)</p>

<p>JS Code:</p>

<pre><code>function uploadFileslice (slice) { // slice is a blob
    var fileReader = new FileReader()
    fileReader.onload = function(event){
        var arrayBuffer = event.target.result
        var wordArray = CryptoJS.lib.WordArray.create(arrayBuffer)
        var sha1crc = CryptoJS.SHA1(wordArray).toString(CryptoJS.enc.Hex)
        //etc
        requestParams.append('fileslice', slice)
        requestParams.append('sha1crc', sha1crc)
        //etc
    }
    fileReader.readAsArrayBuffer(slice)
}
</code></pre>

<p>PHP code:</p>

<pre><code>$file_crc = sha1_file($_FILES['fileslice']['tmp_name']);
if ($_REQUEST['sha1crc'] !== $file_crc) {
    echo ""Invalid CRC: {$_REQUEST['sha1crc']} (expected $file_crc)"";
    return;
}
</code></pre>

<p>Output:</p>

<p>Invalid CRC: 9844f81e1408f6ecb932137d33bed7cfdcf518a3 (expected 3ebe2cd2d8fd8d8f977b6d715f0b1adf5b08b407</p>

<p>I was hoping for something like myHash = CryptoJS.SHA1(blob)...</p>
","<p>From the info that you've provided I'm not sure exactly how you have things setup but in order for ArrayBuffers to be supported you have to include components/lib-typedarrays-min.js.</p>

<p>There's a discussion about this at <a href=""https://code.google.com/p/crypto-js/issues/detail?id=67"" rel=""noreferrer"">https://code.google.com/p/crypto-js/issues/detail?id=67</a>.</p>

<p>Hope this helps!</p>
","6122","<blob><sha1><cryptojs>","6","11","1","2013-07-25 02:59:13","17848266","0","","2407309","","2013-07-23 20:06:02","2013-07-23 19:55:16",""
"47766755","Using crypto-js in React","<p>I generated an app using <code>create-react-app</code> and I want to use
<a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a>
I am getting the following error</p>

<blockquote>
  <p><code>crypto.sha256() is not a function</code></p>
</blockquote>
","<p>You gotta install crypto-js using</p>

<pre><code>npm install crypto-js
</code></pre>

<p>In your js files, you have to import module you wanna use</p>

<pre><code>import sha256 from 'crypto-js/sha256';
</code></pre>

<p>Now you can use those functions</p>

<pre><code>sha256(nonce + message);
</code></pre>

<p>You have do define <code>message</code> and <code>nonce</code> before this</p>
","6046","<reactjs><create-react-app><cryptojs>","1","4","1","2017-12-16 03:24:43","47826838","0","3","3951782","","2017-12-16 03:24:43","2017-12-12 06:47:42",""
"25627399","How to encrypt a binary file with HTML5 File API and upload to server","<p>I need to encrypt and upload file to Apache/PHP server with <a href=""http://www.html5rocks.com/en/tutorials/file/dndfiles/"" rel=""nofollow"">HTML5 FileReader API</a> and <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS</a></p>

<p>I've done the following succesfully</p>

<ul>
<li>Read file with FileReader API</li>
<li>Convert file to base64 with <code>readAsDataURL()</code> function</li>
<li><p>Encrypt it with the following</p>

<p>CryptoJS.AES.encrypt(e.target.result, password);</p></li>
</ul>

<p>But I couldn't manage to send it to server as a <code>File</code> object because I already converted it to text object and I can't convert back it to a file. The following is my javascript file and server-side snippet.
<hr/>
app.js</p>

<pre><code> var reader = new FileReader();

 // Read file callback!
 reader.onload = function (e) {

     // Use the CryptoJS library and the AES cypher to encrypt the 
     // contents of the file, held in e.target.result, with the password

     var encrypted = CryptoJS.AES.encrypt(e.target.result, password);


     //SEND FORM DATA
     var data = new FormData($(""#fileinfo"")[0]);

    /*The following line doesn't work because I'm not adding a File object, 
    * I'm adding file already converted to Base64 format
    */
     data.append('file-0','data:application/octet-stream,' + encrypted);

     $.ajax({
         url: 'upload.php',
         data: data,
         cache: false,
         contentType: false,
         processData: false,
         type: 'POST',
         success: function (data) {
             //alert(data);
         }
     });

 };
</code></pre>

<p><hr/>
upload.php</p>

<pre><code>&lt;?php
var_dump($_FILES); //prints empty array
var_dump($_POST); //prints file as string 
?&gt;
</code></pre>
","<p>I found the answer the new Draft on w3
Here is a working code if anyone need</p>

<pre><code>var reader = new FileReader();

// Read file callback!
reader.onload = function (e) {

var encrypted = CryptoJS.AES.encrypt(e.target.result, password);

var data = new FormData($(""#fileinfo"")[0]);

var encryptedFile = new File([encrypted], file.name + '.encrypted', {type: ""text/plain"", lastModified: new Date()});

data.append('file[0]', encryptedFile);

$.ajax({
     url: 'upload.php',
     data: data,
     cache: false,
     contentType: false,
     processData: false,
     type: 'POST',
     success: function (data) {
         //alert(data);
     }
 });

};

reader.readAsDataURL(file);
</code></pre>
","5967","<javascript><html5><encryption><filereader><cryptojs>","4","4","1","2014-09-02 16:02:31","","2","2","","","","2014-09-02 15:47:05",""
"22245612","How can I encrypt HTML5 web storage?","<p>Is mcrypt or cryptojs better?</p>

<p>Can anyone give me an example how I can encrypt web storage with HML5?</p>

<p><strong>HTML:</strong></p>

<pre><code>&lt;div id=""Data Personal""&gt;
    &lt;h1&gt;Silakan Masukkan Data&lt;/h1&gt;
    &lt;div&gt;Nama = &lt;span id=""nama"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;telepon =  &lt;span id=""Telepon"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;Email =  &lt;span id=""email"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;Kartu kredit =  &lt;span id=""cc"" contenteditable=""true""onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p><strong>JavaScript:</strong></p>

<pre><code>function storeMyContact(id) {
    var nama = document.getElementById('nama').innerHTML;
    var Telepon = document.getElementById('Telepon').innerHTML;
    var email = document.getElementById('email').innerHTML;
    var cc = document.getElementById('cc').innerHTML;
    localStorage.setItem('datnama', nama);
    localStorage.setItem('dattlp', Telepon);
    localStorage.setItem('datemail', email);
    localStorage.setItem('datcc', cc);
}
</code></pre>
","<p>In addition to my comment up there.. it wouldn't have any difference storing regular or encrypted data.. since local storage only accepts text then if you're storing JSON for example it needs to be stringified first.. so before storing you stringify -> then encrypt -> then store.. and on retrieve you retrieve -> then decrypt -> then parse.</p>

<p>I've used CryptoJS once and that was for Hash calculation where I used to send the hashing salt via SMS.. and it was really working good. </p>

<p>An example for encryption/decryption using for example AES is:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
&lt;/script&gt;
</code></pre>

<p><a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow noreferrer"">The howto here is straightforward and easy to follow</a></p>

<p><a href=""https://plnkr.co/edit/IF3afz"" rel=""nofollow noreferrer"">Demo Link : Look for the Console</a></p>
","5925","<javascript><html5><web><mcrypt><cryptojs>","4","4","2","2016-11-08 06:04:58","","4","2","1419007","","2014-03-07 09:31:20","2014-03-07 09:00:09",""
"22245612","How can I encrypt HTML5 web storage?","<p>Is mcrypt or cryptojs better?</p>

<p>Can anyone give me an example how I can encrypt web storage with HML5?</p>

<p><strong>HTML:</strong></p>

<pre><code>&lt;div id=""Data Personal""&gt;
    &lt;h1&gt;Silakan Masukkan Data&lt;/h1&gt;
    &lt;div&gt;Nama = &lt;span id=""nama"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;telepon =  &lt;span id=""Telepon"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;Email =  &lt;span id=""email"" contenteditable=""true"" onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;div&gt;Kartu kredit =  &lt;span id=""cc"" contenteditable=""true""onkeyup=""storeMyContact(this.id)""&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p><strong>JavaScript:</strong></p>

<pre><code>function storeMyContact(id) {
    var nama = document.getElementById('nama').innerHTML;
    var Telepon = document.getElementById('Telepon').innerHTML;
    var email = document.getElementById('email').innerHTML;
    var cc = document.getElementById('cc').innerHTML;
    localStorage.setItem('datnama', nama);
    localStorage.setItem('dattlp', Telepon);
    localStorage.setItem('datemail', email);
    localStorage.setItem('datcc', cc);
}
</code></pre>
","<p>You must use server side encryption like Mcrypt if using PHP and then encode it with Base64.</p>

<pre class=""lang-js prettyprint-override""><code>var nama = '&lt;?php echo $base64EncryptedValue; ?&gt;';
localStorage.setItem('datnama', nama);
</code></pre>
","5925","<javascript><html5><web><mcrypt><cryptojs>","4","-3","2","2016-11-08 06:04:58","","4","2","1419007","","2014-03-07 09:31:20","2014-03-07 09:00:09",""
"40738576","Use Pkcs5 padding With AES encryption in Cryptojs","<p>I just need to use cryptojs AES encryption but with padding Pkcs5 which i can not find in Cryptjs document, i want to do this because it is desired from the backend.
it worked fine with Pkcs7 and cypher mode ECB, how to convert this function to work with Pkcs5</p>

<pre><code>encryptByAES: function (secretPwd) {
    var keyHex = CryptoJS.enc.Utf8.parse(this.encryption_key);
    var encrypted = CryptoJS.AES.encrypt(secretPwd, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    console.log('encryptByAES key: ',encrypted.toString());
    return encrypted.toString();
}
</code></pre>
","<p>When used with AES there is no difference betwheen <strong>PKCS#5</strong> &amp; <strong>PKCS#7</strong>. </p>

<p>The difference between the PKCS#5 and PKCS#7 padding is the block size it supports. PKCS#5 only works with 8-byte blocks whereas PKCS#7 works with block sizes betwheen 1 and 255 bytes. AES uses block size of 8 bytes.</p>
","5713","<javascript><encryption><cryptojs>","0","7","1","2016-11-22 11:15:44","40740412","0","","","","","2016-11-22 09:50:14",""
"25865222","SHA512 not the same in CryptoJS and Closure","<p>I have some troubles with a simple crypto-challenge.</p>

<p>I want to do following:</p>

<ul>
<li>getting a url-encoded and base64-encoded value</li>
<li>do url-decoding</li>
<li>do base64-decoding</li>
<li>hash with Sha512</li>
</ul>

<p>When working with CryptoJS, i use following code:</p>

<pre><code>var parameter = ""Akuwnm2318kwioasdjlnmn"";
var urlDecoded = decodeURIComponent(parameter);
var base64Decoded = CryptoJS.enc.Base64.parse(urlDecoded);
var hashed = CryptoJS.SHA512(base64Decoded).toString(CryptoJS.enc.Base64);
//hashed = ""UxupkI5+dkhUorQ+K3+Tqct1WNUkj3I6N76g82CbNQ0EAH/nWjqi9CW5Qec1vq/qakNIYeXeqiAPOVAVkzf9mA==""/eWTS2lUgCEe6NJDXhNfYvXMRQDvH6k2PHVmy6LJS7RloVvcQcpVjRNVU5lJpAg==""
</code></pre>

<p>When working with Closure, i use following code:</p>

<pre><code>var parameter = ""Akuwnm2318kwioasdjlnmn"";
var urlDecoded = decodeURIComponent(parameter);
var byteArray = goog.crypt.base64.decodeStringToByteArray(urlDecoded);
var base64Decoded = goog.crypt.byteArrayToHex(byteArray);
var sha512 = new goog.crypt.Sha512();
sha512.update(base64Decoded);
var hashed = sha512.digest();
hashed = goog.crypt.byteArrayToHex(hashed);
//hashed = ""bc2a878edfffb0937fbc6c0f9dbc9566edc59b74080d68d4c8bdfeb4027f17c4316a02285baaf446872d2df37b1144ac3ce18d62ab9c786b1f1fb18a53acea1d""
</code></pre>

<p>So, why are the hashes different?</p>

<p>I would be very happy if someone could tell me how to adapt the Closure-Code, to get the same hash as the CryptoJS code provides.</p>

<p>Thanks a lot!</p>

<p>PS:</p>

<p>I also tried:</p>

<pre><code>var parameter = ""Akuwnm2318kwioasdjlnmn"";
var urlDecoded = decodeURIComponent(parameter);
var base64DecodedByteArray = goog.crypt.base64.decodeStringToByteArray(urlDecoded);
var sha512 = new goog.crypt.Sha512();
sha512.update(base64DecodedByteArray);
var hashed = sha512.digest();
hashed = goog.crypt.byteArrayToHex(hashed);
//hashed = ""531ba9908e7e764854a2b43e2b7f93a9cb7558d5248f723a37bea0f3609b350d04007fe75a3aa2f425b941e735beafea6a434861e5deaa200f3950159337fd98""
</code></pre>

<p>but then, as you see, i get another hash. why??</p>
","<p>The first hash value is identical to the third, except it is base64-encoded rather than hex-encoded. You can change to hex encoding and get the same value:</p>

<pre><code>var hashed = CryptoJS.SHA512(base64Decoded).toString(CryptoJS.enc.Hex);
//hashed = ""531ba9908e7e764854a2b43e2b7f93a9cb7558d5248f723a37bea0f3609b350d04007fe75a3aa2f425b941e735beafea6a434861e5deaa200f3950159337fd98""
</code></pre>

<p>The second approach you show has a different value because you are not hashing the same data; you are instead converting the byteArray to a hex string and then hashing that string representation, not the underlying values.</p>
","5456","<javascript><google-closure-library><sha512><cryptojs>","3","7","1","2014-09-16 09:57:46","25865757","1","1","4045644","","2014-09-16 09:51:01","2014-09-16 09:29:48",""
"40680431","How can I encrypt/decrypt arbitrary binary files using Javascript in the browser?","<p>I need to let users load files from their system, encrypt them on-the-fly and upload to the server and do the opposite thing (download files from the server, decrypt on the fly and let the user save them locally). The exact crypto method is not very important although AES is preferred.</p>

<p>Links like <a href=""https://stackoverflow.com/questions/11666165/encryption-decryption-of-binary-data-in-the-browser"">Encryption / decryption of binary data in the browser</a> just tell you ""use CryptoJS"" but I was unable to find any actually working samples. All samples I found focus on dealing with strings while in binary data you can easily find invalid Unicode sequences.</p>

<p>Is there any working sample I can test which can process files of any kind?</p>
","<p><strong>Note:</strong> I won't explain how to decrypt the data, but that should be rather easy to figure out using the code for encryption and the documentation-links provided.</p>

<p>First of all, the user has to be able to select a file via an <code>input</code> element.</p>

<pre><code>&lt;input type=""file"" id=""file-upload"" onchange=""processFile(event)""&gt;
</code></pre>

<p>You can then load the content of the file using the HTML5 <a href=""https://developer.mozilla.org/de/docs/Web/API/FileReader"" rel=""nofollow noreferrer"">FileReader API</a></p>

<pre><code>function processFile(evt) {
    var file = evt.target.files[0],
        reader = new FileReader();

    reader.onload = function(e) {
        var data = e.target.result;

        // to be continued...
    }

    reader.readAsArrayBuffer(file);   
}
</code></pre>

<p>Encrypt the acquired data using the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API"" rel=""nofollow noreferrer"">WebCrypto API</a>.<br>
If you don't want to randomly generate the key use <a href=""https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey"" rel=""nofollow noreferrer""><code>crypto.subtle.deriveKey</code></a> to create a key, for example, from a password that the user entered.</p>

<pre><code>// [...]
var iv = crypto.getRandomValues(new Uint8Array(16)); // Generate a 16 byte long initialization vector

crypto.subtle.generateKey({ 'name': 'AES-CBC', 'length': 256 ]}, false, [ 'encrypt', 'decrypt' ])
    .then(key =&gt; crypto.subtle.encrypt({ 'name': 'AES-CBC', iv }, key, data))
    .then(encrypted =&gt; { /* ... */ });
</code></pre>

<p>Now you can send your encrypted data to the server (e.g. with AJAX).
Obviously you will also have to somehow store the Initialization Vector to later successfully decrypt everything.</p>

<hr>

<p>Here is a little example which alerts the length of the encrypted data.</p>

<p><strong>Note:</strong> If it says <code>Only secure origins are allowed</code>, reload the page with https and try the sample again (This is a restriction of the WebCrypto API):
<a href=""https://stackoverflow.com/questions/40680431/how-can-i-encrypt-decrypt-arbitrary-binary-files-using-javascript-in-the-browser/40681439#40681439"">HTTPS-Link</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function processFile(evt) {
    var file = evt.target.files[0],
        reader = new FileReader();

    reader.onload = function(e) {
        var data = e.target.result,
            iv = crypto.getRandomValues(new Uint8Array(16));
      
        crypto.subtle.generateKey({ 'name': 'AES-CBC', 'length': 256 }, false, ['encrypt', 'decrypt'])
            .then(key =&gt; crypto.subtle.encrypt({ 'name': 'AES-CBC', iv }, key, data) )
            .then(encrypted =&gt; {
                console.log(encrypted);
                alert('The encrypted data is ' + encrypted.byteLength + ' bytes long'); // encrypted is an ArrayBuffer
            })
            .catch(console.error);
    }

    reader.readAsArrayBuffer(file);   
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;input type=""file"" id=""file-upload"" onchange=""processFile(event)""&gt;</code></pre>
</div>
</div>
</p>
","5405","<javascript><encryption><cryptojs>","2","5","1","2019-04-24 12:54:37","40681439","0","3","-1","","2017-05-23 12:34:27","2016-11-18 15:13:07",""
"16996030","PHP function crypt() in JavaScript","<p>On the server side I create a password hash:</p>

<pre><code>public static function salt()
{
    return '$1$' . StringUtil::random(6, array('encode' =&gt; StringUtil::ENCODE_BASE_64));
}

public static function hash($password, $salt = null)
{
    return crypt($password, $salt ?: static::salt());
}
</code></pre>

<p>And on client side I want to do the same using CryptoJS.
Is there any analogues in javascript for PHP crypt(), not necessary with CryptoJS?</p>

<p><strong>UPD:</strong>
I want to do this on client side because I don't want to send password to server, but something like clientId crypted with hash, decrypt it on the server and get the hash for the next manipulations.</p>
","<p>What's the point of encrypting at the client and then decrypting at the server? This is not security, if all the information for encryption is client side, all someone needs to do is look at the JS source to see what your salt is, there is no security there.</p>

<p>The whole point is to send some data (over a secured channel, like https) to the server, then have the server hash it, and compare <strong>that hash</strong> to something you already have stored.</p>

<p>The security comes from what happens at the server, not from what you do to the data before you send it. A secure connection will prevent man-in-the-middle listening, but anything you have at the client is out in the open, and in no way contributes to security, unless you're using not-in-the-browser information (like having someone paste in their PGP public key along with whatever you send, with the server already knowing this person's PGP private key for authentication verification) in which case the actual data becomes irrelevant because the public key is now the important part...</p>

<p>So yeah, don't do this. It makes you believe you're being extra secure, when in fact you only made things worse.</p>
","5393","<php><javascript><hash><cryptojs>","2","1","2","2014-02-20 12:43:07","17002577","6","","589206","","2014-02-20 12:43:07","2013-06-08 04:26:32",""
"16996030","PHP function crypt() in JavaScript","<p>On the server side I create a password hash:</p>

<pre><code>public static function salt()
{
    return '$1$' . StringUtil::random(6, array('encode' =&gt; StringUtil::ENCODE_BASE_64));
}

public static function hash($password, $salt = null)
{
    return crypt($password, $salt ?: static::salt());
}
</code></pre>

<p>And on client side I want to do the same using CryptoJS.
Is there any analogues in javascript for PHP crypt(), not necessary with CryptoJS?</p>

<p><strong>UPD:</strong>
I want to do this on client side because I don't want to send password to server, but something like clientId crypted with hash, decrypt it on the server and get the hash for the next manipulations.</p>
","<p>Well, here it is: <a href=""http://pastebin.com/V4R5r9pi"" rel=""nofollow"">a CryptoJS implementation of PHP's crypt for MD5-hashes</a> (I guess it's too large to paste). So it's not a complete crypt-like thing but in your code example you are setting up a MD5-based hash (with the <code>$1$</code> salt prefix).</p>

<p>How to use it: </p>

<ol>
<li>Store in a file named <code>php-crypt-md5.js</code></li>
<li><p>Use it like that (""rollups"" is in your CryptoJS directory, just use the correct path):</p>

<pre><code>&lt;script src=""rollups/md5.js""&gt;&lt;/script&gt;
&lt;script src=""php-crypt-md5.js""&gt;&lt;/script&gt;

&lt;script&gt;
    function createSalt(len) {
        var saltAlpha = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"" +
            ""abcdefghijklmnopqrstuvwxyz./-+_""

        var salt = '$1$';
        for(var i = 0; i &lt; len; ++i) {
            salt += saltAlpha.charAt(
                Math.floor(Math.random() * saltAlpha.length));
        }

        return salt;
    }

    // in your JavaScript code:

    var salt = createSalt(8);
    var pw = ""your password"";

    var hash = CryptoJS.PHP_CRYPT_MD5(pw, salt);
</code></pre></li>
</ol>
","5393","<php><javascript><hash><cryptojs>","2","2","2","2014-02-20 12:43:07","17002577","6","","589206","","2014-02-20 12:43:07","2013-06-08 04:26:32",""
"33660331","Crypto.js decrypt with key and iv (vector) in byte arrays","<p>I have to decrypt some strings which are AES encrypted.</p>

<blockquote>
  <p>Example encrypted string: 129212143036071008133136215105140171136216244116</p>
</blockquote>

<p>I have a key, and a vector (iv) supplied to me in a byte-array format:</p>

<blockquote>
  <p>Key: [ 123, 217, 20, 11, 24, 26, 85, 45, 114, 184, 27, 162, 37, 115, 222, 209, 241, 24, 175, 144, 175, 53, 196, 29, 24, 23, 17, 218, 131, 226, 53, 209 ]</p>
  
  <p>Vector (iv): [ 146, 66, 191, 151, 23, 3, 113, 119, 231, 131, 133, 112, 79, 32, 114, 136 ]</p>
</blockquote>

<p>I should be able to decrypt the string and get:</p>

<blockquote>
  <p>Correct output: testtest</p>
</blockquote>

<p>I'm trying to use Crypto.js but I can't find a way to use the supplied key and vector. I can't find a way to convert the byte-arrays to hex. </p>

<pre><code>var encrypted = '129212143036071008133136215105140171136216244116';
var key = CryptoJS.enc.Hex.parse([ 123, 217, 20, 11, 24, 26, 85, 45, 114, 184, 27, 162, 37, 115, 222, 209, 241, 24, 175, 144, 175, 53, 196, 29, 24, 23, 17, 218, 131, 226, 53, 209 ]);
var iv  = CryptoJS.enc.Hex.parse([ 146, 66, 191, 151, 23, 3, 113, 119, 231, 131, 133, 112, 79, 32, 114, 136 ]);

var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv });

console.log('Output: '+decrypted.toString(CryptoJS.enc.Utf8)); //Should be ""testtest""
</code></pre>

<p>I would be so grateful if anyone could show me how to decrypt the example string using the key and vector with Crypto.js OR any other js method.</p>

<p>Thanks so much for any help,
Kind regards</p>
","<p>I can't manage to decrypt your original string, but I can successful use it to encrypt and decrypt a new string. In your initial implementation, an error occurs in <code>aes.js</code> because it expects <code>key</code> and <code>iv</code> to be strings rather than arrays. I have corrected this  code example below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//var encrypted = '129212143036071008133136215105140171136216244116';

var key = CryptoJS.enc.Hex.parse(CryptoJS.lib.ByteArray([123, 217, 20, 11, 24, 26, 85, 45, 114, 184, 27, 162, 37, 115, 222, 209, 241, 24, 175, 144, 175, 53, 196, 29, 24, 23, 17, 218, 131, 226, 53, 209]));
var iv = CryptoJS.enc.Hex.parse(CryptoJS.lib.ByteArray([146, 66, 191, 151, 23, 3, 113, 119, 231, 131, 133, 112, 79, 32, 114, 136]));

var  message = 'testest'
var encrypted =  CryptoJS.AES.encrypt(message, key, {
  'iv': iv
});


var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
  'iv': iv
});
document.write('Output: ' + decrypted.toString(CryptoJS.enc.Utf8)); //Should be ""testtest""</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/pad-nopadding-min.js""&gt;&lt;/script&gt;
&lt;script src=""https://greasyfork.org/scripts/6696-cryptojs-lib-bytearray/code/CryptoJSlibByteArray.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","5276","<javascript><encryption><hex><bytearray><cryptojs>","4","1","2","2017-02-16 14:45:02","33661041","2","2","","","","2015-11-11 21:39:04",""
"33660331","Crypto.js decrypt with key and iv (vector) in byte arrays","<p>I have to decrypt some strings which are AES encrypted.</p>

<blockquote>
  <p>Example encrypted string: 129212143036071008133136215105140171136216244116</p>
</blockquote>

<p>I have a key, and a vector (iv) supplied to me in a byte-array format:</p>

<blockquote>
  <p>Key: [ 123, 217, 20, 11, 24, 26, 85, 45, 114, 184, 27, 162, 37, 115, 222, 209, 241, 24, 175, 144, 175, 53, 196, 29, 24, 23, 17, 218, 131, 226, 53, 209 ]</p>
  
  <p>Vector (iv): [ 146, 66, 191, 151, 23, 3, 113, 119, 231, 131, 133, 112, 79, 32, 114, 136 ]</p>
</blockquote>

<p>I should be able to decrypt the string and get:</p>

<blockquote>
  <p>Correct output: testtest</p>
</blockquote>

<p>I'm trying to use Crypto.js but I can't find a way to use the supplied key and vector. I can't find a way to convert the byte-arrays to hex. </p>

<pre><code>var encrypted = '129212143036071008133136215105140171136216244116';
var key = CryptoJS.enc.Hex.parse([ 123, 217, 20, 11, 24, 26, 85, 45, 114, 184, 27, 162, 37, 115, 222, 209, 241, 24, 175, 144, 175, 53, 196, 29, 24, 23, 17, 218, 131, 226, 53, 209 ]);
var iv  = CryptoJS.enc.Hex.parse([ 146, 66, 191, 151, 23, 3, 113, 119, 231, 131, 133, 112, 79, 32, 114, 136 ]);

var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv });

console.log('Output: '+decrypted.toString(CryptoJS.enc.Utf8)); //Should be ""testtest""
</code></pre>

<p>I would be so grateful if anyone could show me how to decrypt the example string using the key and vector with Crypto.js OR any other js method.</p>

<p>Thanks so much for any help,
Kind regards</p>
","<p>I ended up using a .net ashx generic handler, to which i post the data over ssl, and the server-side decryption takes place using the simpleAES class.
This class uses block-size as a parameter which seems to make the difference and using this approach I was able to decrypt all the strings i needed to.</p>

<p>More info about simpleAES here: <a href=""https://github.com/huanlin/YetAnotherLibrary/blob/master/Source/Yalib/Cryptography/SimpleAes.cs"" rel=""nofollow"">https://github.com/huanlin/YetAnotherLibrary/blob/master/Source/Yalib/Cryptography/SimpleAes.cs</a></p>

<p>Thanks again for the help!</p>
","5276","<javascript><encryption><hex><bytearray><cryptojs>","4","1","2","2017-02-16 14:45:02","33661041","2","2","","","","2015-11-11 21:39:04",""
"36762098","How to decrypt password from JavaScript CryptoJS.AES.encrypt(password, passphrase) in Python","<p>I have a password which is encrypt from JavaScript via</p>

<pre class=""lang-js prettyprint-override""><code>  var password = 'sample'
  var passphrase ='sample_passphrase'
  CryptoJS.AES.encrypt(password, passphrase)
</code></pre>

<p>Then I tried to decrypt the password comes from JavaScript in Python:</p>

<pre class=""lang-py prettyprint-override""><code>  from Crypto.Cipher import AES
  import base64

  PADDING = '\0'

  pad_it = lambda s: s+(16 - len(s)%16)*PADDING
  key = 'sample_passphrase'
  iv='11.0.0.101'        #------&gt; here is my question, how can I get this iv to restore password, what should I put here?
  key=pad_it(key)        #------&gt; should I add padding to keys and iv?
  iv=pad_it(iv)          ##
  source = 'sample'
  generator = AES.new(key, AES.MODE_CFB,iv)
  crypt = generator.encrypt(pad_it(source))
  cryptedStr = base64.b64encode(crypt)
  print cryptedStr
  generator = AES.new(key, AES.MODE_CBC,iv)
  recovery = generator.decrypt(crypt)
  print recovery.rstrip(PADDING)
</code></pre>

<p>I checked JS from browser console, it shows IV in <code>CryptoJS.AES.encrypt(password, passphrase)</code> is a object with some attributes( like <code>sigBytes:16, words: [-44073646, -1300128421, 1939444916, 881316061]</code>). It seems generated randomly. </p>

<p>From one web page, it tells me that JS has two way to encrypt password 
(<a href=""http://www.cnblogs.com/Lifehacker/p/nodejs_aes_encrypt_problem.html"" rel=""noreferrer"">reference link</a> ):</p>

<blockquote>
  <ul>
  <li>a. <code>crypto.createCipher(algorithm, password)</code></li>
  <li>b. <code>crypto.createCipheriv(algorithm, key, iv)</code></li>
  </ul>
</blockquote>

<p>What I saw in JavaScript should be option a. However, only option b is equivalent to AES.new() in python.</p>

<p><strong>The questions are</strong>:</p>

<ol>
<li><p>How can I restore this password in Python without changing JavaScript code? </p></li>
<li><p>If I need IV in Python, how can I get it from the password that is used in JavaScript? </p></li>
</ol>
","<p>You will have to implement OpenSSL's <a href=""https://www.openssl.org/docs/crypto/EVP_BytesToKey.html"" rel=""noreferrer""><code>EVP_BytesToKey</code></a>, because that is what CryptoJS uses to derive the key and IV from the provided password, but pyCrypto only supports the key+IV type encryption. CryptoJS also generates a random salt which also must be send to the server. If the ciphertext object is converted to a string, then it uses automatically an OpenSSL-compatible format which includes the random salt.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var data = ""Some semi-long text for testing"";
var password = ""some password"";
var ctObj = CryptoJS.AES.encrypt(data, password);
var ctStr = ctObj.toString();

out.innerHTML = ctStr;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;div id=""out""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>Possible output:</p>

<blockquote>
  <p>U2FsdGVkX1+ATH716DgsfPGjzmvhr+7+pzYfUzR+25u0D7Z5Lw04IJ+LmvPXJMpz</p>
</blockquote>

<p>CryptoJS defaults to 256 bit key size for AES, PKCS#7 padding and CBC mode. AES has a 128 bit block size which is also the IV size. This means that we have to request 32+16 = 48 byte from EVP_BytesToKey. I've found a semi-functional implementation <a href=""https://gist.github.com/gsakkis/4546068"" rel=""noreferrer"">here</a> and extended it further.</p>

<p>Here is the full Python (tested with 2.7 and 3.4) code, which is compatible with CryptoJS:</p>

<pre><code>from Crypto import Random
from Crypto.Cipher import AES
import base64
from hashlib import md5

BLOCK_SIZE = 16

def pad(data):
    length = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
    return data + (chr(length)*length).encode()

def unpad(data):
    return data[:-(data[-1] if type(data[-1]) == int else ord(data[-1]))]

def bytes_to_key(data, salt, output=48):
    # extended from https://gist.github.com/gsakkis/4546068
    assert len(salt) == 8, len(salt)
    data += salt
    key = md5(data).digest()
    final_key = key
    while len(final_key) &lt; output:
        key = md5(key + data).digest()
        final_key += key
    return final_key[:output]

def encrypt(message, passphrase):
    salt = Random.new().read(8)
    key_iv = bytes_to_key(passphrase, salt, 32+16)
    key = key_iv[:32]
    iv = key_iv[32:]
    aes = AES.new(key, AES.MODE_CBC, iv)
    return base64.b64encode(b""Salted__"" + salt + aes.encrypt(pad(message)))

def decrypt(encrypted, passphrase):
    encrypted = base64.b64decode(encrypted)
    assert encrypted[0:8] == b""Salted__""
    salt = encrypted[8:16]
    key_iv = bytes_to_key(passphrase, salt, 32+16)
    key = key_iv[:32]
    iv = key_iv[32:]
    aes = AES.new(key, AES.MODE_CBC, iv)
    return unpad(aes.decrypt(encrypted[16:]))


password = ""some password"".encode()
ct_b64 = ""U2FsdGVkX1+ATH716DgsfPGjzmvhr+7+pzYfUzR+25u0D7Z5Lw04IJ+LmvPXJMpz""

pt = decrypt(ct_b64, password)
print(""pt"", pt)

print(""pt"", decrypt(encrypt(pt, password), password))
</code></pre>

<hr>

<p>Similar code can be found in my answers for <a href=""https://stackoverflow.com/a/27250883/1816580"">Java</a> and <a href=""https://stackoverflow.com/a/27678978/1816580"">PHP</a>.</p>

<p>JavaScript AES encryption in the browser without HTTPS is simple obfuscation and does not provide any real security, because the key must be transmitted alongside the ciphertext.</p>
","5200","<javascript><python><aes><pycrypto><cryptojs>","9","21","1","2017-07-30 09:25:07","36780727","4","3","1816580","","2016-04-22 07:36:18","2016-04-21 07:05:47",""
"45643078","Javascript : CryptoJS object missing SHA1 method","<p>This should be easy to solve....</p>

<p>My CryptoJS object exists, but it doesn't have a SHA1 method.</p>

<p>What do I have to do to make this work? There are many many samples out there. Mine, of course, doesn't work...</p>

<p>The .enc.Hex.stringify method DOES exist...</p>

<p>Any help appreciated.</p>

<pre><code>&lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8"" /&gt;
        &lt;title&gt;&lt;/title&gt;
        link href=""blaw blaw blaw"" rel=""stylesheet"" &gt;
    &lt;/head&gt;
    &lt;body&gt;
        content blaw blaw blaw

       &lt;script type=""text/javascript"" src=""https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js""&gt;&lt;/script&gt;
       &lt;script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""&gt;&lt;/script&gt;
       &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.js""&gt;&lt;/script&gt;
       &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/enc-hex.js""&gt;&lt;/script&gt;
       &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/hmac-sha1.js""&gt;&lt;/script&gt;

       &lt;script type=""text/javascript""&gt;

           var StringToSign = ""blaw blaw blaw"";
           var hash = CryptoJS.SHA1(StringToSign); // &lt;--- No SHA1 method!

           var result = CryptoJS.enc.Hex.stringify(hash);
           $("".content .z-value"").html(result);
        &lt;/script&gt;
</code></pre>

<p>
</p>

<p>Thanks</p>
","<p>You have to include sha1.js before loading hmac-sha1.js, because it doesn't load it automatically (at least not in the browser). The same is true for hmac.js. Also, enc-hex.js is already included in core.js.</p>

<p>Example code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=""utf-8"" /&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;div class=""content""&gt;&lt;/div&gt;

   &lt;script type=""text/javascript"" src=""https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js""&gt;&lt;/script&gt;
   &lt;script src=""https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"" integrity=""sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"" crossorigin=""anonymous""&gt;&lt;/script&gt;
   &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.js""&gt;&lt;/script&gt;
   &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/hmac.js""&gt;&lt;/script&gt;
   &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/sha1.js""&gt;&lt;/script&gt;

   &lt;script type=""text/javascript""&gt;

       var StringToSign = ""blaw blaw blaw"";
       var hash = CryptoJS.SHA1(StringToSign);

       var result = CryptoJS.enc.Hex.stringify(hash);
       $("".content"").html(result);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","5177","<javascript><sha1><cryptojs>","0","4","1","2017-08-12 11:32:51","45643440","2","","","","","2017-08-11 20:11:46",""
"20247953","TripleDES implementation in Javascript different comparing with C#","<p>I need to replicate the following C# method to encrypt some text from Javascript. Currently I am using <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">Crypto JS</a>, but the output from JS is not equals to the C# output.</p>

<pre><code>const string EncryptKey = ""hello"";

private static String getHexStringFromArray(byte[] arr) {
    StringBuilder sBuilder = new StringBuilder();

    for (int i = 0; i &lt; arr.Length; i++) {
        sBuilder.Append(arr[i].ToString(""x2""));
    }

    return sBuilder.ToString();
}    

public void Encrypt(string toEncrypt, bool useHashing) {
    byte[] keyArray;
    byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

    string key = EncryptKey;

    if (useHashing) {
        MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
        keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));

        hashmd5.Clear();
    } else
        keyArray = UTF8Encoding.UTF8.GetBytes(key);

    Console.WriteLine(""hexadecimal key: "" + getHexStringFromArray(keyArray));

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    tdes.Key = keyArray;
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.PKCS7;

    ICryptoTransform cTransform = tdes.CreateEncryptor();
    byte[] resultArray =
        cTransform.TransformFinalBlock(toEncryptArray, 0,
            toEncryptArray.Length);

    tdes.Clear();

    Console.WriteLine(""hexadecimal encrypted: "" + getHexStringFromArray(resultArray));

    //Return the encrypted data into unreadable string format
    string test = Convert.ToBase64String(resultArray, 0, resultArray.Length);

    Console.WriteLine(""Output: "" + test);
}
</code></pre>

<p>The output for <code>Encrypt(""password"", true)</code> is:</p>

<pre><code>hexadecimal key: 5d41402abc4b2a76b9719d911017c592
hexadecimal encrypted: 069c44845e907b346b9d82d1d553f391
Output: BpxEhF6QezRrnYLR1VPzkQ==
</code></pre>

<p>Now, the Javascript implementation (please, ignore the global variables):</p>

<pre><code>window.text = ""password"";
window.key = ""hello"";
var useHashing = true;

if (useHashing){
    key = CryptoJS.MD5(key).toString();
}

window.options = {
    mode: CryptoJS.mode.ECB, 
    padding: CryptoJS.pad.Pkcs7
};

window.textWordArray = CryptoJS.enc.Utf8.parse(text);
window.keyHex = CryptoJS.enc.Hex.parse(key);

console.log('hexadecimal key: ' + keyHex);

window.encrypted = CryptoJS.TripleDES.encrypt(textWordArray, keyHex, options);

var base64String = encrypted.toString();

console.log('base64: ' + base64String);

window.decrypted = CryptoJS.TripleDES.decrypt( {
    ciphertext: CryptoJS.enc.Base64.parse(base64String)
}, keyHex, options);

console.log('decrypted: ' + decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Produces this result:</p>

<pre><code>hexadecimal key: 5d41402abc4b2a76b9719d911017c592
base64: BK5f0AhEuUl9pYEy2Mliyw== 
</code></pre>

<p>Which is different from the C# implementation.</p>

<p><a href=""http://jsfiddle.net/dkWFr/"" rel=""nofollow"">Here</a> you can find the Javascript code.</p>

<p>Any help?</p>
","<p>TripleDES requires 24-byte key (k1 + k2 + k3). Your key is only 16-byte. And .NET auto completes with k3 = k1. But Javascript does not, k3 = 0. Please modify the key:</p>

<pre><code>if (useHashing){
   key = CryptoJS.MD5(key).toString();
   var k1 = key.substring(0, 16);
   key = key + k1;
}
</code></pre>
","5118","<c#><javascript><cryptojs><tripledes>","2","8","2","2017-07-21 10:55:46","21105246","2","2","","","","2013-11-27 16:32:50",""
"20247953","TripleDES implementation in Javascript different comparing with C#","<p>I need to replicate the following C# method to encrypt some text from Javascript. Currently I am using <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">Crypto JS</a>, but the output from JS is not equals to the C# output.</p>

<pre><code>const string EncryptKey = ""hello"";

private static String getHexStringFromArray(byte[] arr) {
    StringBuilder sBuilder = new StringBuilder();

    for (int i = 0; i &lt; arr.Length; i++) {
        sBuilder.Append(arr[i].ToString(""x2""));
    }

    return sBuilder.ToString();
}    

public void Encrypt(string toEncrypt, bool useHashing) {
    byte[] keyArray;
    byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

    string key = EncryptKey;

    if (useHashing) {
        MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
        keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));

        hashmd5.Clear();
    } else
        keyArray = UTF8Encoding.UTF8.GetBytes(key);

    Console.WriteLine(""hexadecimal key: "" + getHexStringFromArray(keyArray));

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    tdes.Key = keyArray;
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.PKCS7;

    ICryptoTransform cTransform = tdes.CreateEncryptor();
    byte[] resultArray =
        cTransform.TransformFinalBlock(toEncryptArray, 0,
            toEncryptArray.Length);

    tdes.Clear();

    Console.WriteLine(""hexadecimal encrypted: "" + getHexStringFromArray(resultArray));

    //Return the encrypted data into unreadable string format
    string test = Convert.ToBase64String(resultArray, 0, resultArray.Length);

    Console.WriteLine(""Output: "" + test);
}
</code></pre>

<p>The output for <code>Encrypt(""password"", true)</code> is:</p>

<pre><code>hexadecimal key: 5d41402abc4b2a76b9719d911017c592
hexadecimal encrypted: 069c44845e907b346b9d82d1d553f391
Output: BpxEhF6QezRrnYLR1VPzkQ==
</code></pre>

<p>Now, the Javascript implementation (please, ignore the global variables):</p>

<pre><code>window.text = ""password"";
window.key = ""hello"";
var useHashing = true;

if (useHashing){
    key = CryptoJS.MD5(key).toString();
}

window.options = {
    mode: CryptoJS.mode.ECB, 
    padding: CryptoJS.pad.Pkcs7
};

window.textWordArray = CryptoJS.enc.Utf8.parse(text);
window.keyHex = CryptoJS.enc.Hex.parse(key);

console.log('hexadecimal key: ' + keyHex);

window.encrypted = CryptoJS.TripleDES.encrypt(textWordArray, keyHex, options);

var base64String = encrypted.toString();

console.log('base64: ' + base64String);

window.decrypted = CryptoJS.TripleDES.decrypt( {
    ciphertext: CryptoJS.enc.Base64.parse(base64String)
}, keyHex, options);

console.log('decrypted: ' + decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Produces this result:</p>

<pre><code>hexadecimal key: 5d41402abc4b2a76b9719d911017c592
base64: BK5f0AhEuUl9pYEy2Mliyw== 
</code></pre>

<p>Which is different from the C# implementation.</p>

<p><a href=""http://jsfiddle.net/dkWFr/"" rel=""nofollow"">Here</a> you can find the Javascript code.</p>

<p>Any help?</p>
","<p>Here is Decrypter using 3DES-ECB of Forge js.
Since I couldn't find forge js solution adding one so others can use it.</p>

<pre><code>var md = forge.md.md5.create();
md.update(window.key);

var key = md.digest().getBytes();
//3DES-ECB requires 24byte of data and key returned from md5 is 16byte
var k1 = key.substring(0, 8);
var key1 = key + key1;

var input = forge.util.createBuffer(forge.util.decode64(window.text));
var decTer = forge.cipher.createDecipher('3DES-ECB', key1);
decTer.start();
decTer.update(input);

return decTer.output.getBytes();
</code></pre>
","5118","<c#><javascript><cryptojs><tripledes>","2","0","2","2017-07-21 10:55:46","21105246","2","2","","","","2013-11-27 16:32:50",""
"48524452","base64 Encoder via crypto-js","<p><strong>I want to Encode number to character.</strong> </p>

<ul>
<li>How Can I encode to base64 in output?</li>
</ul>

<p><strong>Code:</strong></p>

<pre><code>const CryptoJS = require('crypto-js');

function msg() {
  return '7543275'; // I want to encrypt this number to character
}

const msgLocal = msg();

// Encrypt
const ciphertext = CryptoJS.AES.encrypt(msgLocal, 'password');

// Decrypt
const bytes = CryptoJS.AES.decrypt(ciphertext.toString(), 'password');
const plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>
","<p>Solved.</p>

<pre><code>const CryptoJS = require('crypto-js');

// OUTPUT
console.log(encrypt()); // 'NzUzMjI1NDE='
console.log(decrypt()); // '75322541'

function encrypt() {
  // INIT
  const myString = '75322541'; // Utf8-encoded string

  // PROCESS
  const encryptedWord = CryptoJS.enc.Utf8.parse(myString); // encryptedWord Array object
  const encrypted = CryptoJS.enc.Base64.stringify(encryptedWord); // string: 'NzUzMjI1NDE='
  return encrypted;
}

function decrypt() {
  // INIT
  const encrypted = 'NzUzMjI1NDE='; // Base64 encrypted string

  // PROCESS
  const encryptedWord = CryptoJS.enc.Base64.parse(encrypted); // encryptedWord via Base64.parse()
  const decrypted = CryptoJS.enc.Utf8.stringify(encryptedWord); // decrypted encryptedWord via Utf8.stringify() '75322541'
  return decrypted;
}
</code></pre>
","4833","<javascript><encryption><base64><cryptojs>","1","5","1","2018-01-31 00:39:22","48530778","0","1","7428622","","2018-01-31 00:39:22","2018-01-30 15:00:57",""
"26066604","Generating unique tokens in a NodeJS, Crypto Token authentication environment","<p>Using nodejs and crypto, right now, when a user logs in, I generate a random auth token:</p>

<pre><code>var token = crypto.randomBytes(16).toString('hex');
</code></pre>

<p>I know it's unlikely, but there is a tiny chance for two tokens to be of the same value.</p>

<p>This means a user could, in theory, authenticate on another account.</p>

<p>Now, I see two obvious methods to get pass this:</p>

<ul>
<li>When I generate the token, query the user's database and see if a
Token with the same value already exists. If it does, just generate another one. As you can see, this is not perfect since I am adding queries to the database.</li>
<li>Since every user has a unique username in my database, I could<br>
generate a random token using the username as a secret generator key.
This way, there is no way of two tokens having the same value. Can crypto do that? Is it secure?</li>
</ul>

<p>How would you do it?</p>
","<p>It's too unlikely to worry about it happening by chance. I would not sacrifice performance to lock and check the database for it.</p>

<p>Consider this excerpt from <a href=""http://git-scm.com/book/ch6-1.html#A-SHORT-NOTE-ABOUT-SHA-1"" rel=""nofollow noreferrer"">Pro Git</a> about the chance of random collisions between 20-byte SHA-1 sums:</p>

<blockquote>
  <p>Heres an example to give you an idea of what it would take to get a
  SHA-1 collision [by chance]. If all 6.5 billion humans on Earth were programming,
  and every second, each one was producing code that was the equivalent
  of the entire Linux kernel history (1 million Git objects) and pushing
  it into one enormous Git repository, it would take 5 years until that
  repository contained enough objects to have a 50% probability of a
  single SHA-1 object collision. A higher probability exists [for average projects] that every
  member of your programming team will be attacked and killed by wolves
  in unrelated incidents on the same night.</p>
</blockquote>

<p>(SHA-1 collisions <a href=""https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html"" rel=""nofollow noreferrer"">can be directly constructed now</a>, so the quote is now less applicable to SHA-1, but it's still valid when considering collisions of random values.)</p>

<p>If you are still worried about that probability, then you can easily use more random bytes instead of 16.</p>

<p>But regarding your second idea: if you hashed the random ID with the username, then that hash could collide, just like the random ID could. You haven't solved anything.</p>
","4787","<node.js><cryptojs>","8","16","2","2018-09-24 08:17:44","26066901","0","4","6619626","","2018-09-24 08:17:44","2014-09-26 19:03:55",""
"26066604","Generating unique tokens in a NodeJS, Crypto Token authentication environment","<p>Using nodejs and crypto, right now, when a user logs in, I generate a random auth token:</p>

<pre><code>var token = crypto.randomBytes(16).toString('hex');
</code></pre>

<p>I know it's unlikely, but there is a tiny chance for two tokens to be of the same value.</p>

<p>This means a user could, in theory, authenticate on another account.</p>

<p>Now, I see two obvious methods to get pass this:</p>

<ul>
<li>When I generate the token, query the user's database and see if a
Token with the same value already exists. If it does, just generate another one. As you can see, this is not perfect since I am adding queries to the database.</li>
<li>Since every user has a unique username in my database, I could<br>
generate a random token using the username as a secret generator key.
This way, there is no way of two tokens having the same value. Can crypto do that? Is it secure?</li>
</ul>

<p>How would you do it?</p>
","<p>You should always add a <code>UNIQUE</code> constraint to your database column. This will create an implicit index to improve searches for this column and it will make sure that none of two records will ever has the same value. So, in the worst-case scenario you will get a database exception and not a security violation.</p>

<p>Also, depending on how frequently unique tokens are needed to be created, I think it's perfectly fine in most cases to use database lookups during generation. If your column, again, is properly indexed, it will be a pretty fast query. Most databases a very well horizontally scalable, so if your are building a next Facebook it is again an option. Furthermore, you will probably need to do a query to check for E-Mail uniqueness anyway.</p>

<p>Finally, if you are really concerned about performance you could always pre-generate a one-million of unique tokens and store them in the separate database table for quick use. Just setup a routine to periodically check it's usage and insert more records to it as needed. However, as @MacroMan stated in the comments, this could have a security implications if someone will get access to the list of pre-generated tokens, so this practice should be avoided.</p>

<ul>
<li><p><a href=""https://www.postgresql.org/docs/current/static/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS"" rel=""nofollow noreferrer"">PostgreSQL UNIQUE CONSTRAINT</a></p></li>
<li><p><a href=""https://www.techonthenet.com/mysql/unique.php"" rel=""nofollow noreferrer"">MySQL: Unique Constraints</a></p></li>
</ul>
","4787","<node.js><cryptojs>","8","1","2","2018-09-24 08:17:44","26066901","0","4","6619626","","2018-09-24 08:17:44","2014-09-26 19:03:55",""
"28706485","JavaScript: How to generate Rfc2898DeriveBytes like C#?","<p><strong>EDIT:</strong> Per discussion in the comments, let me clarify that this will be happening server side, behind SSL. I do not intend to expose the hashed password or the hashing scheme to the client. </p>

<p>Assume we have an existing asp.net identity database with the default tables (aspnet_Users, aspnet_Roles, etc.). Based on my understanding, the password hashing algorithm uses sha256 and stores the salt + (hashed password) as a base64 encoded string. <strong><em>EDIT: This assumption is incorrect, see answer below.</em></strong></p>

<p>I would like to replicate the function of the Microsoft.AspNet.Identity.Crypto class' <a href=""https://gist.github.com/trailmax/553ea84d4d0e2e20fcd7"" rel=""nofollow noreferrer"">VerifyHashedPassword</a> function with a JavaScript version. </p>

<p>Let's say that a password is <strong>welcome1</strong> and its asp.net hashed password is        <strong>ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A==</strong></p>

<p>So far I have been able to reproduce the parts of the method that get the salt and the stored sub key.</p>

<p>Where the C# implementation does more or less this:</p>

<pre><code>var salt = new byte[SaltSize];
Buffer.BlockCopy(hashedPasswordBytes, 1, salt, 0, SaltSize);
var storedSubkey = new byte[PBKDF2SubkeyLength];
Buffer.BlockCopy(hashedPasswordBytes, 1 + SaltSize, storedSubkey, 0, PBKDF2SubkeyLength);
</code></pre>

<p>I have the following in JavaScript (not elegant by any stretch):</p>

<pre><code>var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');
var saltbytes = [];
var storedSubKeyBytes = [];

for(var i=1;i&lt;hashedPasswordBytes.length;i++)
{
  if(i &gt; 0 &amp;&amp; i &lt;= 16)
  {
    saltbytes.push(hashedPasswordBytes[i]);
  }
  if(i &gt; 0 &amp;&amp; i &gt;16) {
    storedSubKeyBytes.push(hashedPasswordBytes[i]);
  }
}
</code></pre>

<p>Again, it ain't pretty, but after running this snippet the saltbytes and storedSubKeyBytes match byte for byte what I see in the C# debugger for salt and storedSubkey. </p>

<p>Finally, in C#, an instance of Rfc2898DeriveBytes is used to generate a new subkey based on the salt and the password provided, like so:</p>

<pre><code>byte[] generatedSubkey;
using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, PBKDF2IterCount))
{
   generatedSubkey = deriveBytes.GetBytes(PBKDF2SubkeyLength);
}
</code></pre>

<p>This is where I'm stuck. I have tried others' solutions such as <a href=""https://stackoverflow.com/questions/25745974/how-to-check-asp-net-password-hash-in-node-js"">this one</a>, I have used Google's and Node's CryptoJS and crypto libraries respectively, and my output never generates anything resembling the C# version. </p>

<p>(Example: </p>

<pre><code>var output = crypto.pbkdf2Sync(new Buffer('welcome1', 'utf16le'), 
    new Buffer(parsedSaltString), 1000, 32, 'sha256');
console.log(output.toString('base64'))
</code></pre>

<p>generates ""LSJvaDM9u7pXRfIS7QDFnmBPvsaN2z7FMXURGHIuqdY="")</p>

<p>Many of the pointers I've found online indicate problems involving encoding mismatches (NodeJS / UTF-8 vs. .NET / UTF-16LE), so I've tried encoding using the default .NET encoding format but to no avail.</p>

<p>Or I could be completely wrong about what I assume these libraries are doing. But any pointers in the right direction would be much appreciated.</p>
","<p>Ok, I think this problem ended up being quite a bit simpler than I was making it (aren't they always). After performing a RTFM operation on the <a href=""http://www.ietf.org/rfc/rfc6070.txt"" rel=""noreferrer"">pbkdf2 spec</a>, I ran some side-by-side tests with Node crypto and .NET crypto, and have made pretty good progress on a solution. </p>

<p>The following JavaScript code correctly parses the stored salt and subkey, then verifies the given password by hashing it with the stored salt. There are doubtless better / cleaner / more secure tweaks, so comments welcome.</p>

<pre><code>// NodeJS implementation of crypto, I'm sure google's 
// cryptoJS would work equally well.
var crypto = require('crypto');

// The value stored in [dbo].[AspNetUsers].[PasswordHash]
var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');

var hexChar = [""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""A"", ""B"", ""C"", ""D"", ""E"", ""F""];

var saltString = """";
var storedSubKeyString = """";

// build strings of octets for the salt and the stored key
for (var i = 1; i &lt; hashedPasswordBytes.length; i++) {
    if (i &gt; 0 &amp;&amp; i &lt;= 16) {
        saltString += hexChar[(hashedPasswordBytes[i] &gt;&gt; 4) &amp; 0x0f] + hexChar[hashedPasswordBytes[i] &amp; 0x0f]
    }
    if (i &gt; 0 &amp;&amp; i &gt; 16) {
        storedSubKeyString += hexChar[(hashedPasswordBytes[i] &gt;&gt; 4) &amp; 0x0f] + hexChar[hashedPasswordBytes[i] &amp; 0x0f];
    }
}

// password provided by the user
var password = 'welcome1';

// TODO remove debug - logging passwords in prod is considered 
// tasteless for some odd reason
console.log('cleartext: ' + password);
console.log('saltString: ' + saltString);
console.log('storedSubKeyString: ' + storedSubKeyString);

// This is where the magic happens. 
// If you are doing your own hashing, you can (and maybe should)
// perform more iterations of applying the salt and perhaps
// use a stronger hash than sha1, but if you want it to work
// with the [as of 2015] Microsoft Identity framework, keep
// these settings.
var nodeCrypto = crypto.pbkdf2Sync(new Buffer(password), new Buffer(saltString, 'hex'), 1000, 256, 'sha1');

// get a hex string of the derived bytes
var derivedKeyOctets = nodeCrypto.toString('hex').toUpperCase();

console.log(""hex of derived key octets: "" + derivedKeyOctets);

// The first 64 bytes of the derived key should
// match the stored sub key
if (derivedKeyOctets.indexOf(storedSubKeyString) === 0) {
    console.info(""passwords match!"");
} else {
    console.warn(""passwords DO NOT match!"");
}
</code></pre>
","4782","<javascript><c#><asp.net-identity><cryptojs><rfc2898>","8","13","4","2018-12-19 14:50:02","28728361","6","3","-1","","2017-05-23 12:03:04","2015-02-24 21:18:13",""
"28706485","JavaScript: How to generate Rfc2898DeriveBytes like C#?","<p><strong>EDIT:</strong> Per discussion in the comments, let me clarify that this will be happening server side, behind SSL. I do not intend to expose the hashed password or the hashing scheme to the client. </p>

<p>Assume we have an existing asp.net identity database with the default tables (aspnet_Users, aspnet_Roles, etc.). Based on my understanding, the password hashing algorithm uses sha256 and stores the salt + (hashed password) as a base64 encoded string. <strong><em>EDIT: This assumption is incorrect, see answer below.</em></strong></p>

<p>I would like to replicate the function of the Microsoft.AspNet.Identity.Crypto class' <a href=""https://gist.github.com/trailmax/553ea84d4d0e2e20fcd7"" rel=""nofollow noreferrer"">VerifyHashedPassword</a> function with a JavaScript version. </p>

<p>Let's say that a password is <strong>welcome1</strong> and its asp.net hashed password is        <strong>ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A==</strong></p>

<p>So far I have been able to reproduce the parts of the method that get the salt and the stored sub key.</p>

<p>Where the C# implementation does more or less this:</p>

<pre><code>var salt = new byte[SaltSize];
Buffer.BlockCopy(hashedPasswordBytes, 1, salt, 0, SaltSize);
var storedSubkey = new byte[PBKDF2SubkeyLength];
Buffer.BlockCopy(hashedPasswordBytes, 1 + SaltSize, storedSubkey, 0, PBKDF2SubkeyLength);
</code></pre>

<p>I have the following in JavaScript (not elegant by any stretch):</p>

<pre><code>var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');
var saltbytes = [];
var storedSubKeyBytes = [];

for(var i=1;i&lt;hashedPasswordBytes.length;i++)
{
  if(i &gt; 0 &amp;&amp; i &lt;= 16)
  {
    saltbytes.push(hashedPasswordBytes[i]);
  }
  if(i &gt; 0 &amp;&amp; i &gt;16) {
    storedSubKeyBytes.push(hashedPasswordBytes[i]);
  }
}
</code></pre>

<p>Again, it ain't pretty, but after running this snippet the saltbytes and storedSubKeyBytes match byte for byte what I see in the C# debugger for salt and storedSubkey. </p>

<p>Finally, in C#, an instance of Rfc2898DeriveBytes is used to generate a new subkey based on the salt and the password provided, like so:</p>

<pre><code>byte[] generatedSubkey;
using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, PBKDF2IterCount))
{
   generatedSubkey = deriveBytes.GetBytes(PBKDF2SubkeyLength);
}
</code></pre>

<p>This is where I'm stuck. I have tried others' solutions such as <a href=""https://stackoverflow.com/questions/25745974/how-to-check-asp-net-password-hash-in-node-js"">this one</a>, I have used Google's and Node's CryptoJS and crypto libraries respectively, and my output never generates anything resembling the C# version. </p>

<p>(Example: </p>

<pre><code>var output = crypto.pbkdf2Sync(new Buffer('welcome1', 'utf16le'), 
    new Buffer(parsedSaltString), 1000, 32, 'sha256');
console.log(output.toString('base64'))
</code></pre>

<p>generates ""LSJvaDM9u7pXRfIS7QDFnmBPvsaN2z7FMXURGHIuqdY="")</p>

<p>Many of the pointers I've found online indicate problems involving encoding mismatches (NodeJS / UTF-8 vs. .NET / UTF-16LE), so I've tried encoding using the default .NET encoding format but to no avail.</p>

<p>Or I could be completely wrong about what I assume these libraries are doing. But any pointers in the right direction would be much appreciated.</p>
","<p>The previous solution will not work in all cases.
Let's say that you want to compare a password <code>source</code> against a hash in the database <code>hash</code>, which can be technically possible if the database is compromised, then the function will return <code>true</code> because the subkey is an empty string.</p>

<p>Modify the function to catch that up and return false instead.</p>

<pre><code>// NodeJS implementation of crypto, I'm sure google's 
// cryptoJS would work equally well.
var crypto = require('crypto');

// The value stored in [dbo].[AspNetUsers].[PasswordHash]
var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');

var hexChar = [""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""A"", ""B"", ""C"", ""D"", ""E"", ""F""];

var saltString = """";
var storedSubKeyString = """";

// build strings of octets for the salt and the stored key
for (var i = 1; i &lt; hashedPasswordBytes.length; i++) {
    if (i &gt; 0 &amp;&amp; i &lt;= 16) {
        saltString += hexChar[(hashedPasswordBytes[i] &gt;&gt; 4) &amp; 0x0f] + hexChar[hashedPasswordBytes[i] &amp; 0x0f]
    }
    if (i &gt; 0 &amp;&amp; i &gt; 16) {
        storedSubKeyString += hexChar[(hashedPasswordBytes[i] &gt;&gt; 4) &amp; 0x0f] + hexChar[hashedPasswordBytes[i] &amp; 0x0f];
    }
}

if (storedSubKeyString === '') { return false }

// password provided by the user
var password = 'welcome1';

// TODO remove debug - logging passwords in prod is considered 
// tasteless for some odd reason
console.log('cleartext: ' + password);
console.log('saltString: ' + saltString);
console.log('storedSubKeyString: ' + storedSubKeyString);

// This is where the magic happens. 
// If you are doing your own hashing, you can (and maybe should)
// perform more iterations of applying the salt and perhaps
// use a stronger hash than sha1, but if you want it to work
// with the [as of 2015] Microsoft Identity framework, keep
// these settings.
var nodeCrypto = crypto.pbkdf2Sync(new Buffer(password), new Buffer(saltString, 'hex'), 1000, 256, 'sha1');

// get a hex string of the derived bytes
var derivedKeyOctets = nodeCrypto.toString('hex').toUpperCase();

console.log(""hex of derived key octets: "" + derivedKeyOctets);

// The first 64 bytes of the derived key should
// match the stored sub key
if (derivedKeyOctets.indexOf(storedSubKeyString) === 0) {
    console.info(""passwords match!"");
} else {
    console.warn(""passwords DO NOT match!"");
}
</code></pre>
","4782","<javascript><c#><asp.net-identity><cryptojs><rfc2898>","8","1","4","2018-12-19 14:50:02","28728361","6","3","-1","","2017-05-23 12:03:04","2015-02-24 21:18:13",""
"28706485","JavaScript: How to generate Rfc2898DeriveBytes like C#?","<p><strong>EDIT:</strong> Per discussion in the comments, let me clarify that this will be happening server side, behind SSL. I do not intend to expose the hashed password or the hashing scheme to the client. </p>

<p>Assume we have an existing asp.net identity database with the default tables (aspnet_Users, aspnet_Roles, etc.). Based on my understanding, the password hashing algorithm uses sha256 and stores the salt + (hashed password) as a base64 encoded string. <strong><em>EDIT: This assumption is incorrect, see answer below.</em></strong></p>

<p>I would like to replicate the function of the Microsoft.AspNet.Identity.Crypto class' <a href=""https://gist.github.com/trailmax/553ea84d4d0e2e20fcd7"" rel=""nofollow noreferrer"">VerifyHashedPassword</a> function with a JavaScript version. </p>

<p>Let's say that a password is <strong>welcome1</strong> and its asp.net hashed password is        <strong>ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A==</strong></p>

<p>So far I have been able to reproduce the parts of the method that get the salt and the stored sub key.</p>

<p>Where the C# implementation does more or less this:</p>

<pre><code>var salt = new byte[SaltSize];
Buffer.BlockCopy(hashedPasswordBytes, 1, salt, 0, SaltSize);
var storedSubkey = new byte[PBKDF2SubkeyLength];
Buffer.BlockCopy(hashedPasswordBytes, 1 + SaltSize, storedSubkey, 0, PBKDF2SubkeyLength);
</code></pre>

<p>I have the following in JavaScript (not elegant by any stretch):</p>

<pre><code>var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');
var saltbytes = [];
var storedSubKeyBytes = [];

for(var i=1;i&lt;hashedPasswordBytes.length;i++)
{
  if(i &gt; 0 &amp;&amp; i &lt;= 16)
  {
    saltbytes.push(hashedPasswordBytes[i]);
  }
  if(i &gt; 0 &amp;&amp; i &gt;16) {
    storedSubKeyBytes.push(hashedPasswordBytes[i]);
  }
}
</code></pre>

<p>Again, it ain't pretty, but after running this snippet the saltbytes and storedSubKeyBytes match byte for byte what I see in the C# debugger for salt and storedSubkey. </p>

<p>Finally, in C#, an instance of Rfc2898DeriveBytes is used to generate a new subkey based on the salt and the password provided, like so:</p>

<pre><code>byte[] generatedSubkey;
using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, PBKDF2IterCount))
{
   generatedSubkey = deriveBytes.GetBytes(PBKDF2SubkeyLength);
}
</code></pre>

<p>This is where I'm stuck. I have tried others' solutions such as <a href=""https://stackoverflow.com/questions/25745974/how-to-check-asp-net-password-hash-in-node-js"">this one</a>, I have used Google's and Node's CryptoJS and crypto libraries respectively, and my output never generates anything resembling the C# version. </p>

<p>(Example: </p>

<pre><code>var output = crypto.pbkdf2Sync(new Buffer('welcome1', 'utf16le'), 
    new Buffer(parsedSaltString), 1000, 32, 'sha256');
console.log(output.toString('base64'))
</code></pre>

<p>generates ""LSJvaDM9u7pXRfIS7QDFnmBPvsaN2z7FMXURGHIuqdY="")</p>

<p>Many of the pointers I've found online indicate problems involving encoding mismatches (NodeJS / UTF-8 vs. .NET / UTF-16LE), so I've tried encoding using the default .NET encoding format but to no avail.</p>

<p>Or I could be completely wrong about what I assume these libraries are doing. But any pointers in the right direction would be much appreciated.</p>
","<p>Here's another option which actually compares the bytes as opposed to converting to a string representation.</p>

<pre><code>const crypto = require('crypto');

const password = 'Password123';
const storedHashString = 'J9IBFSw0U1EFsH/ysL+wak6wb8s=';
const storedSaltString = '2nX0MZPZlwiW8bYLlVrfjBYLBKM=';

const storedHashBytes = new Buffer.from(storedHashString, 'base64');
const storedSaltBytes = new Buffer.from(storedSaltString, 'base64');

crypto.pbkdf2(password, storedSaltBytes, 1000, 20, 'sha1',
  (err, calculatedHashBytes) =&gt; {
    const correct = calculatedHashBytes.equals(storedHashBytes);
    console.log('Password is ' + (correct ? 'correct ' : 'incorrect '));
  }
);
</code></pre>

<p>1000 is the default number of iterations in <strong>System.Security.Cryptography.Rfc2898DeriveBytes</strong> and 20 is the number of bytes we are using to store the salt (again the default).</p>
","4782","<javascript><c#><asp.net-identity><cryptojs><rfc2898>","8","1","4","2018-12-19 14:50:02","28728361","6","3","-1","","2017-05-23 12:03:04","2015-02-24 21:18:13",""
"28706485","JavaScript: How to generate Rfc2898DeriveBytes like C#?","<p><strong>EDIT:</strong> Per discussion in the comments, let me clarify that this will be happening server side, behind SSL. I do not intend to expose the hashed password or the hashing scheme to the client. </p>

<p>Assume we have an existing asp.net identity database with the default tables (aspnet_Users, aspnet_Roles, etc.). Based on my understanding, the password hashing algorithm uses sha256 and stores the salt + (hashed password) as a base64 encoded string. <strong><em>EDIT: This assumption is incorrect, see answer below.</em></strong></p>

<p>I would like to replicate the function of the Microsoft.AspNet.Identity.Crypto class' <a href=""https://gist.github.com/trailmax/553ea84d4d0e2e20fcd7"" rel=""nofollow noreferrer"">VerifyHashedPassword</a> function with a JavaScript version. </p>

<p>Let's say that a password is <strong>welcome1</strong> and its asp.net hashed password is        <strong>ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A==</strong></p>

<p>So far I have been able to reproduce the parts of the method that get the salt and the stored sub key.</p>

<p>Where the C# implementation does more or less this:</p>

<pre><code>var salt = new byte[SaltSize];
Buffer.BlockCopy(hashedPasswordBytes, 1, salt, 0, SaltSize);
var storedSubkey = new byte[PBKDF2SubkeyLength];
Buffer.BlockCopy(hashedPasswordBytes, 1 + SaltSize, storedSubkey, 0, PBKDF2SubkeyLength);
</code></pre>

<p>I have the following in JavaScript (not elegant by any stretch):</p>

<pre><code>var hashedPwd = ""ADOEtXqGCnWCuuc5UOAVIvMVJWjANOA/LoVy0E4XCyUHIfJ7dfSY0Id+uJ20DTtG+A=="";
var hashedPasswordBytes = new Buffer(hashedPwd, 'base64');
var saltbytes = [];
var storedSubKeyBytes = [];

for(var i=1;i&lt;hashedPasswordBytes.length;i++)
{
  if(i &gt; 0 &amp;&amp; i &lt;= 16)
  {
    saltbytes.push(hashedPasswordBytes[i]);
  }
  if(i &gt; 0 &amp;&amp; i &gt;16) {
    storedSubKeyBytes.push(hashedPasswordBytes[i]);
  }
}
</code></pre>

<p>Again, it ain't pretty, but after running this snippet the saltbytes and storedSubKeyBytes match byte for byte what I see in the C# debugger for salt and storedSubkey. </p>

<p>Finally, in C#, an instance of Rfc2898DeriveBytes is used to generate a new subkey based on the salt and the password provided, like so:</p>

<pre><code>byte[] generatedSubkey;
using (var deriveBytes = new Rfc2898DeriveBytes(password, salt, PBKDF2IterCount))
{
   generatedSubkey = deriveBytes.GetBytes(PBKDF2SubkeyLength);
}
</code></pre>

<p>This is where I'm stuck. I have tried others' solutions such as <a href=""https://stackoverflow.com/questions/25745974/how-to-check-asp-net-password-hash-in-node-js"">this one</a>, I have used Google's and Node's CryptoJS and crypto libraries respectively, and my output never generates anything resembling the C# version. </p>

<p>(Example: </p>

<pre><code>var output = crypto.pbkdf2Sync(new Buffer('welcome1', 'utf16le'), 
    new Buffer(parsedSaltString), 1000, 32, 'sha256');
console.log(output.toString('base64'))
</code></pre>

<p>generates ""LSJvaDM9u7pXRfIS7QDFnmBPvsaN2z7FMXURGHIuqdY="")</p>

<p>Many of the pointers I've found online indicate problems involving encoding mismatches (NodeJS / UTF-8 vs. .NET / UTF-16LE), so I've tried encoding using the default .NET encoding format but to no avail.</p>

<p>Or I could be completely wrong about what I assume these libraries are doing. But any pointers in the right direction would be much appreciated.</p>
","<p>I know this is rather late, but I ran into an issue with reproducing C#'s Rfc2898DeriveBytes.GetBytes in Node, and kept coming back to this SO answer. I ended up creating a minimal class for my own usage, and I figured I'd share in case someone else was having the same issues. It's not perfect, but it works.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const crypto = require('crypto');
const $key = Symbol('key');
const $saltSize = Symbol('saltSize');
const $salt = Symbol('salt');
const $iterationCount = Symbol('iterationCount');
const $position = Symbol('position');

class Rfc2898DeriveBytes {
    constructor(key, saltSize = 32, iterationCount = 1000) {
        this[$key] = key;
        this[$saltSize] = saltSize;
        this[$iterationCount] = iterationCount;
        this[$position] = 0;
        this[$salt] = crypto.randomBytes(this[$saltSize]);
    }

    get salt() {
        return this[$salt];
    }
    set salt(buffer) {
        this[$salt] = buffer;
    }

    get iterationCount() {
        return this[$iterationCount];
    }
    set iterationCount(count) {
        this[$iterationCount] = count;
    }

    getBytes(byteCount) {
        let position = this[$position];
        let bytes = crypto.pbkdf2Sync(Buffer.from(this[$key]), this.salt, this.iterationCount, position + byteCount, 'sha1');
        this[$position] += byteCount;
        let result = Buffer.alloc(byteCount);
        for (let i = 0; i &lt; byteCount; i++) { result[i] = bytes[position + i]; }
        return result;
    }
}

module.exports = Rfc2898DeriveBytes;</code></pre>
</div>
</div>
</p>
","4782","<javascript><c#><asp.net-identity><cryptojs><rfc2898>","8","1","4","2018-12-19 14:50:02","28728361","6","3","-1","","2017-05-23 12:03:04","2015-02-24 21:18:13",""
"14754488","CryptoJS with Bower, how to manage this dependency?","<p>I need to manage <a href=""http://code.google.com/p/crypto-js/"">CryptoJS</a> with Bower. This project is hosted on code.google.com. Can be downloaded as <a href=""http://code.google.com/p/crypto-js/downloads/list"">zip file</a> or through the <a href=""http://crypto-js.googlecode.com/svn/tags"">SVN</a>.</p>

<p>Can Bower download an uncompress the zip file or download all components from the SVN and put them in the <code>crypto</code> folder?</p>

<p><code>.bowerrc</code> file, defining the download folder:</p>

<pre><code>{
  ""directory"": ""app/vendor""
}
</code></pre>

<p>I've tried this <code>component.json</code> file (fails, downloads the page itself):</p>

<pre><code>{
  ""name"": ""Backbone Client"",
  ""version"": ""1.0.0"",
  ""dependencies"": {
     ""crypto"": ""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/""
  }
}
</code></pre>

<p>Another try (<code>hmac.js</code> overriders <code>core.js</code> and it's saved as <code>index.js</code>):</p>

<pre><code>{
  ""name"": ""Backbone Client"",
  ""version"": ""1.0.0"",
  ""dependencies"": {
    ""crypto"":
       ""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/core.js"",
    ""crypto"":
       ""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/hmac.js""
    }
}
</code></pre>
","<p>Found the way reading <a href=""http://twitter.github.com/bower/"" rel=""noreferrer"">Bower official page</a>:</p>

<blockquote>
  <p>As you can see, packages can be installed by name, Git endpoint,
  GitHub shorthand, URL or local path. If you install from a URL that
  points to a zip or tar file, bower will automatically extract its
  contents.</p>
</blockquote>

<p><code>component.json</code>:</p>

<pre><code>{
  ""name"": ""Backbone Client"",
  ""version"": ""1.0.0"",
  ""dependencies"": {
    ""crypto-js"": ""http://crypto-js.googlecode.com/files/CryptoJS%20v3.1.2.zip""
  }
}
</code></pre>
","4740","<javascript><dependencies><bower><cryptojs>","12","21","1","2013-02-07 15:39:42","14755029","0","3","","","","2013-02-07 15:14:20",""
"27375908","crypto-js - read and decrypt file","<p>I have some Java functions for doing AES encryption, one for a string, and one for a file</p>

<pre><code>private static final String AES_CIPHER_METHOD = ""AES"";

public static SecretKeySpec createAesKeySpec(byte[] aesKey) {
    return new SecretKeySpec(aesKey, AES_CIPHER_METHOD);
}

public static String aesEncrypt(String data, SecretKeySpec aesKeySpec) throws EncryptionException {
    try {
        Cipher aesCipher = Cipher.getInstance(AES_CIPHER_METHOD);
        aesCipher.init(Cipher.ENCRYPT_MODE, aesKeySpec);
        byte[] encVal = aesCipher.doFinal(data.getBytes(""UTF8""));
        return new BASE64Encoder().encode(encVal);
    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IOException | BadPaddingException| IllegalBlockSizeException e) {
        throw new EncryptionException(e.getMessage(), e);
    }
}

public static void aesEncryptFile(File in, File out, SecretKeySpec aesKeySpec) throws EncryptionException {
    try {
        Cipher aesCipher = Cipher.getInstance(AES_CIPHER_METHOD);
        aesCipher.init(Cipher.ENCRYPT_MODE, aesKeySpec);

        try (InputStream inputStream = new FileInputStream(in)) {
            try (OutputStream outputStream = new CipherOutputStream(new FileOutputStream(out), aesCipher)){
                IOUtils.copy(inputStream, outputStream);
            }
        }
    } catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | IOException e){
        throw new EncryptionException(e.getMessage(), e);
    }
}
</code></pre>

<p>I also have some tests to output some test data</p>

<pre><code>private static final String KEY_STRING = ""DpiA4l0gvb7biWZtiN6Vjg=="";

private SecretKeySpec createKeySpec() {
    byte[] keyBytes = new Base64().decode(KEY_STRING.getBytes());
    return EncryptionUtils.createAesKeySpec(keyBytes);
}

public void testAesEncryptString() throws EncryptionException {
    String encryptedData = EncryptionUtils.aesEncrypt(""A normal string"", createKeySpec());
    System.out.println(encryptedData); //outputs 3XLwlSHWLm98teIoIS6QTA==
}

public void testAesEncryptStringFile() throws EncryptionException, IOException {
    File newFile = new File(FilenameUtils.concat(System.getProperty(""java.io.tmpdir""), ""myFile.txt""));
    FileUtils.writeStringToFile(newFile, ""A string in a file"");

    File encryptedFile = new File(FilenameUtils.concat(System.getProperty(""java.io.tmpdir""), ""myFile_encrypted.txt""));

    EncryptionUtils.aesEncryptFile(newFile, encryptedFile, createKeySpec());
}
</code></pre>

<p>I now need to implement decryption in javascript.</p>

<p>I have managed to successfully decrypt the plain string using crypto-js, however, I just cant get the file part working, and I cant quite see what is wrong</p>

<pre><code>var base64Key = ""DpiA4l0gvb7biWZtiN6Vjg=="";
var key = CryptoJS.enc.Base64.parse(base64Key);

var aesOptions = {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
};

var decryptedData = CryptoJS.AES.decrypt( ""3XLwlSHWLm98teIoIS6QTA=="", key, aesOptions);
var decryptedText = decryptedData.toString( CryptoJS.enc.Utf8 );
console.log( ""decryptedText = "" + decryptedText ); //CORRECT outputs ""A normal string""

var encryptedFilename = ""https://dl.dropboxusercontent.com/u/30823828/myFile_encrypted.txt"";
$.get(encryptedFilename, function(data){
    console.log(""encrypted file content"", data);
    var encryptedData = CryptoJS.enc.Base64.parse(data);
    var decryptedData = CryptoJS.AES.decrypt( encryptedData, key, aesOptions);
    var decryptedText = decryptedData.toString( CryptoJS.enc.Utf8 );
    console.log( ""decrypted file content = "" + decryptedText ); //INCORRECT outputs """" SHOULD output ""A string in a file""
});
</code></pre>

<p>link to jsfiddle - <a href=""http://jsfiddle.net/pKNzV/46/"" rel=""nofollow"">http://jsfiddle.net/pKNzV/46/</a></p>
","<p>after a lot of trial and error, I was able to get this working.</p>

<p>the function <code>base64ArrayBuffer</code> comes from the following - <a href=""https://gist.github.com/jonleighton/958841"" rel=""nofollow"">https://gist.github.com/jonleighton/958841</a></p>

<pre><code>var base64Key = ""DpiA4l0gvb7biWZtiN6Vjg=="";
var key = CryptoJS.enc.Base64.parse(base64Key);

var aesOptions = {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
};

var encryptedFilename = ""https://dl.dropboxusercontent.com/u/30823828/myFile_encrypted.txt"";

var oReq = new XMLHttpRequest();
oReq.open(""GET"", encryptedFilename, true);
oReq.responseType = ""arraybuffer"";

oReq.onload = function (oEvent) {
   var data = oReq.response;
   if (data) {
      encodedData = base64ArrayBuffer(data);
      var decryptedData = CryptoJS.AES.decrypt( encodedData, key, aesOptions);
      var decryptedText = decryptedData.toString( CryptoJS.enc.Utf8 );
      console.log( ""decryptedText = "" + decryptedText );
      console.log(""file decrypt successful: "", ""A string in a file"" === decryptedText);
   }
};

oReq.send(null);
</code></pre>
","4724","<javascript><encryption><cryptojs>","2","1","1","2014-12-16 00:47:26","27495783","1","1","","","","2014-12-09 09:51:57",""
"28242700","Decrypt PDF file on client side and view with pdf.js","<p>I'm working on a project that all pdf files are encrypted on Web Server.</p>

<p>With XMLHttpRequest I get content of the encrypted pdf file. Then with JavaScript tools I decrypt the file. After all assign the content of file to a javascript variable as decrypted_file. All this is done at client side.</p>

<p>Here is what i want to do;</p>

<p>pdf.js renders and views pdf file that is located on web server or the same directory base.</p>

<p>How could I handle pdf.js to get content from javascript variable not url as ""http//yourdomain.com/first-test.pdf or file as ""first-test.pdf""?</p>

<p>Any answers are welcome, thank you.</p>
","

<p>Assuming that you are using the viewer.html of PDF.js, opening a PDF file from data is as easy as calling <a href=""https://github.com/mozilla/pdf.js/blob/8614c17c1df9a9eb250690162d69bf32ee84f4b9/web/viewer.js#L455"" rel=""noreferrer""><code>PDFViewerApplication.open</code></a> with the right parameters.</p>

<h2>Example: Typed arrays (Uint8Array / ArrayBuffer / ..)</h2>

<pre class=""lang-js prettyprint-override""><code>// in viewer.html
var data = new Uint8Array( /* ... data ... */ );
PDFViewerApplication.open(data);
</code></pre>

<h2>Example: Blob / File objects</h2>

<pre class=""lang-js prettyprint-override""><code>// in viewer.html
var data = new Blob([ '%PDF....'] , {type: 'application/pdf'});
var url = URL.createObjectURL(data);
PDFViewerApplication.open(url);
</code></pre>

<h2>Example: data URL (if supported by browser)</h2>

<pre class=""lang-js prettyprint-override""><code>var url = 'data:application/pdf;base64,....';
PDFViewerApplication.open(url);
</code></pre>

<h2>Example: data URL (any browser)</h2>

<p>This consists of two steps: Decoding the base64 data-URL, and then converting the binary string to an <code>Uint8Array</code>.</p>

<pre class=""lang-js prettyprint-override""><code>var url = 'data:application/pdf;base64,....';
var data = url.split(';base64,')[1];
// Decode base64
var binaryString = atob(data);
// Convert binary string to Uint8Array
data = new Uint8Array(binaryString.length);
for (var i = 0, ii = binaryString.length; i &lt; ii; ++i) {
    data[i] = binaryString.charCodeAt(i);
}
PDFViewerApplication.open(data);
</code></pre>

<h2>Example: Using PDF.js in a frame</h2>

<pre class=""lang-html prettyprint-override""><code>&lt;iframe src=""viewer.html"" id=""pdfjsframe""&gt;&lt;/iframe&gt;
&lt;script&gt;
var pdfjsframe = document.getElementById('pdfjsframe');
// At the very least, wait until the frame is ready, e.g via onload.
pdfjsframe.onload = function() {
    var data = ... data here or elsewhere ... ;
    pdfjsframe.contentWindow.PDFViewerApplication.open(data);
};
&lt;/script&gt;
</code></pre>
","4676","<encryption><pdf.js><cryptojs>","4","7","1","2016-10-14 09:25:14","28525093","0","1","","","","2015-01-30 18:49:53",""
"40474177","File encryption using CryptoJS - Client side","<p>I am trying to encrypt all files within a folder located on client side. I have the below code, but getting an error. I am not entirely sure about the error.</p>

<p><strong>ERROR:</strong> <em>Uncaught TypeError: Cannot read property 'length' of undefined()</em> at line 16 in html.</p>

<p>index.html</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta content=""text/html; charset=utf-8"" http-equiv=""Content-Type"" /&gt;
    &lt;title&gt;Get Directory&lt;/title&gt;
    &lt;script src=""http://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js""&gt;&lt;/script&gt;
    &lt;script src=""assets/js/aes.js""&gt;&lt;/script&gt;
    &lt;script type=""text/javascript""&gt; 
    $(document).ready(function(){
        $(""#file-input"").on(""change"", function(e){
            var thefiles = e.target.files;
            var reader = new FileReader();
            $.each(thefiles, function(i, item){
                var thefile = item;
                reader.onload = function(){
                    var encrypted = CryptoJS.AES.encrypt(thefile, '12334');
                };
                reader.readAsDataURL(thefile);
                $(""#thelist"").append(""FILES: "" + thefile.name + ""&lt;br /&gt;"");;
            });
        });
    });
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=""file"" id=""file-input"" webkitdirectory="""" directory=""""&gt;
    &lt;div id=""thelist""&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","<p>Read all comments</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta content=""text/html; charset=utf-8"" http-equiv=""Content-Type"" /&gt;
    &lt;title&gt;Get Directory&lt;/title&gt;
    &lt;!-- Update your jQuery version??? --&gt;
    &lt;script src=""http://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js""&gt;&lt;/script&gt;
    &lt;script src=""assets/js/aes.js""&gt;&lt;/script&gt;
    &lt;script&gt; // type=""text/javascript"" is unnecessary in html5

    // Short version of doing `$(document).ready(function(){`
    // and safer naming conflicts with $
    jQuery(function($) { 

        $('#file-input').on('change', function() {

            // You can't use the same reader for all the files
            // var reader = new FileReader

            $.each(this.files, function(i, file) {

                // Uses different reader for all files
                var reader = new FileReader

                reader.onload = function() {
                    // reader.result refer to dataUrl
                    // theFile is the blob... CryptoJS wants a string...
                    var encrypted = CryptoJS.AES.encrypt(reader.result, '12334')
                }

                reader.readAsDataURL(file)
                $('#thelist').append('FILES: ' + file.name + '&lt;br&gt;')
            })
        })
    })
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=""file"" id=""file-input"" webkitdirectory="""" directory=""""&gt;
    &lt;div id=""thelist""&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>btw, browsers has a modern standard Crypto lib built in... Maybe try using that instead? and if necessary use a polyfill?</p>
","4662","<javascript><jquery><encryption><filereader><cryptojs>","0","1","1","2016-11-07 21:45:15","40475038","2","1","1008999","","2016-11-07 21:45:15","2016-11-07 20:38:40",""
"32025279","Laravel 5 - Decrypt Crypt::encrypt in Javascript","<p>I'm using <code>Crypt::encrypt</code> to encrypt my data and feed to Javascript code. How can I decrypt the data in Javascript?</p>
","<p>Using laravel 5.1 and CryptoJS which can be found at (<a href=""https://code.google.com/p/crypto-js/"" rel=""noreferrer"">https://code.google.com/p/crypto-js/</a>). </p>

<p>in .env set:</p>

<ol>
<li>APP_KEY=uberkeythatrocks</li>
</ol>

<p>in config/app.php set:</p>

<ol start=""2"">
<li>'cipher' => 'AES-256-CBC'</li>
</ol>

<p>in MyController.php:</p>

<ol start=""3"">
<li><p>$mySecret = ""Something I wanna hide from them"";</p></li>
<li><p>$encrypted = Crypt::encrypt($mySecret);</p></li>
</ol>

<p>in index.js:</p>

<ol start=""5"">
<li><p>var key = ""uberkeythatrocks"";</p></li>
<li><p>var decrypted = CryptoJS.AES.decrypt(encrypted, key);</p></li>
<li><p>var readable = decrypted.toString(CryptoJS.enc.Utf8);</p></li>
</ol>

<p>IMPORTANT:
The 'key' in PHP must be the same with 'key' in JS and the 'cipher' in PHP must be the same in JS however, CryptoJS will automatically select either AES-128-CBC or AES-256-CBC depending on the length of your 'key'. Although laravel 5.1 default 'cipher' is AES-256-CBC so I would suggest you get your 'key' from .env file to use in JS.</p>

<p>To change or generate a new 'key' from Laravel</p>

<ol>
<li>C:/mylaravel> php artisan key:generate [enter]</li>
</ol>

<p>To use AES-128-CBC</p>

<ol>
<li>Edit config/app.php and set 'cipher' => 'AES-128-CBC'</li>
</ol>

<p>then</p>

<ol start=""2"">
<li>C:/mylaravel> php artisan key:generate [enter]</li>
</ol>

<p>NOTE that the change of 'key' will mean that an existing user account login password will not work unless you delete the user and then create new.</p>

<p>HOPE THIS HELPS! :)</p>
","4625","<javascript><php><laravel><cryptojs>","3","6","2","2019-07-18 18:51:12","","7","1","712603","","2015-08-15 13:39:28","2015-08-15 13:38:39",""
"32025279","Laravel 5 - Decrypt Crypt::encrypt in Javascript","<p>I'm using <code>Crypt::encrypt</code> to encrypt my data and feed to Javascript code. How can I decrypt the data in Javascript?</p>
","<p><strong>I SOLVE THIS:</strong></p>

<p>I'm using Laravel Framework 5.7.28 and i want to decrypt some users passwords in my node.js application </p>

<p>For Decrypt in my Js file i include <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> and <a href=""https://www.npmjs.com/package/js-base64"" rel=""nofollow noreferrer"">Base64 JS</a>
<br>
<br>
Here is the code:
<br></p>

<blockquote>
  <p><strong>$key</strong> is the APP_KEY that you have in your .env file <br>
  <strong>$encrypted</strong> is what you encrypt with the <strong>Crypt::encrypt</strong> in laravel</p>
</blockquote>

<pre><code>var CryptoJS = require(""crypto-js"");
var Base64 = require('js-base64').Base64;


var encrypted = '{{ $encrypted }}';
var key = ""{{ $key }}"";

var encrypted_json = JSON.parse(Base64.decode(encrypted));


// Now I try to decrypt it.
var decrypted = CryptoJS.AES.decrypt(encrypted_json.value, CryptoJS.enc.Base64.parse(key), {
       iv : CryptoJS.enc.Base64.parse(encrypted_json.iv)
});

console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","4625","<javascript><php><laravel><cryptojs>","3","1","2","2019-07-18 18:51:12","","7","1","712603","","2015-08-15 13:39:28","2015-08-15 13:38:39",""
"31680986","How to achieve CryptoJS decryption using aes-128-cbc algorithm?","<p>I am getting an encrypted key which is generated using Java. I need to decrypt it in AngularJS app using CryptoJS. I had done similar thing using node but now in Angular I am stuck. This fiddle <a href=""http://jsfiddle.net/s5g82rqh/"" rel=""nofollow"">http://jsfiddle.net/s5g82rqh/</a> is what I have tried so far but it returns empty.</p>

<p>Below is what I have tried till now</p>

<pre><code> function decrypt_core_AES_CBC(password, ciphertext) {
   var iv  = CryptoJS.lib.WordArray.random(128/8);
   var message = CryptoJS.AES.decrypt(ciphertext, password, { mode:    CryptoJS.mode.CBC, iv: password });

  console.log(""The current iv is: "" + iv.toString() );
  return CryptoJS.enc.Utf8.stringify(message);
 }


var data = '6615702f2dd672f643fd57623d6362a510a98faf4b1c068fd468b525a5fa5471809852a0f9cb7936ce3d3892c233b8c48ce2608f16ce6fa66005b2d97689fbb4';
var key = '3426D38AB846B62B9C236D288778D997';
var dec = decrypt_core_AES_CBC(key, data);

console.log(dec);
</code></pre>

<p>Below is the node.js code which works for me. I have no success in achieving similar in CryptoJS. As per my understanding crypto comes as built-in library which node has its own wrapper on top of it. </p>

<pre><code>var crypto = require('crypto');
var defaultAlgorithm= 'aes-128-cbc';
var defaultFormat= 'hex';
var ivLength= 16;
function decode (data, key, algorithm, format) {

    // Make sure the data is a buffer object
    if (data instanceof Buffer) {
        data = data.toString();
    }

    // Get defaults if needed
    algorithm = algorithm || defaultAlgorithm;
    format = format || defaultFormat;

    ivLength = ivLength * 2;

    // Get the initialization vector
    var iv = new Buffer(data.substring(0, ivLength), 'hex');

    // Remove the iv from the data
    data = data.substring(ivLength);
    var decipher = crypto.createDecipheriv(algorithm, new Buffer(key, 'hex'), iv);
    var decrypted = decipher.update(data, format, 'utf8') + decipher.final('utf8');

    return decrypted;
}

var data ='6615702f2dd672f643fd57623d6362a510a98faf4b1c068fd468b525a5fa5471809852a0f9cb7936ce3d3892c233b8c48ce2608f16ce6fa66005b2d97689fbb4';
var key = '3426D38AB846B62B9C236D288778D997';
var dec = decode(data, key, defaultAlgorithm, defaultFormat);

console.log(dec);
</code></pre>
","<p>You have three issues:</p>

<ul>
<li><p>CryptoJS supports two types of encryption/decryption: key derived from a password and directly passed key. You want to do this from a key, so you need to parse the hex-encoded key string into CryptoJS' native format before passing it to the <code>decrypt()</code> function:</p>

<pre><code>key = CryptoJS.enc.Hex.parse(key);
</code></pre>

<p>Also, don't confuse a key with a password.</p></li>
<li><p>You forgot to slice off the IV from the ciphertext before decrypting.</p>

<pre><code>var iv = CryptoJS.enc.Hex.parse(ciphertext.slice(0, 32));
ciphertext = CryptoJS.enc.Hex.parse(ciphertext.slice(32));
</code></pre></li>
<li><p>CryptoJS' expects either a <code>CipherParams</code> object or an OpenSSL-formatted string to decrypt from. Since you only have a hex string, you have to parse it before use and use it like this:</p>

<pre><code>var message = CryptoJS.AES.decrypt({
    ciphertext: ciphertext
}, key, {
    iv: iv
});
</code></pre></li>
</ul>
","4587","<javascript><node.js><encryption><aes><cryptojs>","2","6","1","2015-07-29 07:19:15","31683009","0","1","1816580","","2015-07-28 17:18:06","2015-07-28 15:35:35",""
"26623768","Decrypting AES with Javascript CryptoJS after encrypting with PHP mcrypt","<p><strong>Encrypting in PHP with mcrypt</strong></p>

<pre><code>&lt;?php
$string = 'Secret Message';
$key = 'd4b494e4502a62edd695a903a94c2701';
$iv = '02f30dffbb0d084755f438f7d8be4a7d';

$encrypted = base64_encode(
    mcrypt_encrypt(
        MCRYPT_RIJNDAEL_256,
        $key,
        $string,
        MCRYPT_MODE_CBC,
        $iv
    )
);
//$encrypted results in 'nYoFAiyDARVSI09lH/IPdim5TvE51izVjk6sc2AK9Rg='
?&gt;
</code></pre>

<p><strong>Decrypting in Javascript with CryptoJS</strong></p>

<pre><code>&lt;script&gt;
var encrypted = 'nYoFAiyDARVSI09lH/IPdim5TvE51izVjk6sc2AK9Rg=';
var key = CryptoJS.enc.Hex.parse('d4b494e4502a62edd695a903a94c2701');
var iv = CryptoJS.enc.Hex.parse('02f30dffbb0d084755f438f7d8be4a7d');

var decrypted = CryptoJS.AES.decrypt(encrypted,key,{iv:iv,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7});

console.log(decrypted.toString(CryptoJS.enc.Utf8)); //prints an empty string
&lt;/script&gt;
</code></pre>

<p><strong>I can't figure out how to get the Javascript side to spit out the original text.</strong></p>
","<p><strong>SOLVED</strong></p>

<p><em>Note: I found out that ""MCRYPT_RIJNDAEL_256"" in PHP's mcrypt is NOT included in AES. It uses the Rijndael method, BUT with a 256-bit block size (not included in AES). So, CryptoJS does not handle 256-bit block sizes for Rijndael. Thanks, GregS</em></p>

<p><strong>Nonetheless</strong>, I found an implementation that successfully decrypted the ciphertext I get from running my PHP mcrypt function above, using MCRYPT_RIJNDAEL_256 (Rijndael, 256-bit block size, with 256-bit key/32-byte key).</p>

<p><strong>Here it is:
<a href=""https://code.google.com/p/js-mcrypt/"" rel=""noreferrer"">https://code.google.com/p/js-mcrypt/</a></strong></p>

<pre><code>&lt;script&gt;
var encrypted = 'nYoFAiyDARVSI09lH/IPdim5TvE51izVjk6sc2AK9Rg=';
var key = 'd4b494e4502a62edd695a903a94c2701';
var iv = '02f30dffbb0d084755f438f7d8be4a7d';
var decrypted = mcrypt.Decrypt(atob(encrypted), iv, key, 'rijndael-256', 'cbc');
&lt;/script&gt;
</code></pre>

<p>I hope this helps someone as I spent a week of my spare time trying to figure this out and almost giving up.</p>
","4554","<javascript><encryption><aes><mcrypt><cryptojs>","2","6","1","2015-04-01 23:04:55","26672492","6","2","2598101","","2014-10-29 23:42:29","2014-10-29 06:10:08",""
"29831300","Convert DESede/ECB/NoPadding algorithm written in java into Nodejs using crypto module","<p>I am working on migration of code form java to Nodejs. I have one requirement to encrypt the text with private key using ""DESede/ECB/NoPadding"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs. Since encrypted key is sent to other application therefore I can't change the algorithm or key here. Following is approach used in java</p>

<pre><code>1. Stored the private key in hex string. I.e. 48 chars hex string as below which is equivalent to 24 bytes reuquired for 3des
73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2
2. Following is code written in java 
https://github.com/dilipkumar2k6/3des/blob/master/TripleDes.java
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class TripleDes {
    // Crypto library related keys
    private static final String ALGO_NAME = ""DESede/ECB/NoPadding"";
    private static final int PADDING_BLOCK = 8;

    // Test Data
    private static final String PLAIN_TEXT = ""Hello World"";
    private static final String SHARED_KEY = ""73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2"";

    public static void main(String[] arg) {

        try {
            // Get Algorithm name
            String desAlgoName = getDESAlgorithmName(ALGO_NAME);
            // Create Cipher object
            Cipher cipher = Cipher.getInstance(ALGO_NAME);
            //Actual DES algo needs 56 bits key, which is equivalent to 1byte (0 at 0th position)  Get 8*3 byets key
            byte [] key = hexFromString(SHARED_KEY);
            System.out.println(""DES Algorithm  shared key size in bytes &gt;&gt; ""+key.length);
            // Create SecretKeySpec
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, desAlgoName);
            //Encrypt bytes
            byte [] encryptedBytes = encryptIntoBytes(cipher, secretKeySpec, PLAIN_TEXT.getBytes(), 0, PLAIN_TEXT.getBytes().length);
            String encryptedString=  hexToString(encryptedBytes);
            System.out.println(encryptedString);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static byte[] encryptIntoBytes(Cipher cipher, SecretKeySpec secretKeySpec, byte[] dct, int offset, int len) throws GeneralSecurityException {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] ect = cipher.doFinal(addPadding(dct, offset, len));
        return ect;
    }

    public static String getDESAlgorithmName(String algoName) {
        System.out.println(""getDESAlgorithmName algoName &gt;&gt; ""+algoName);
        String desAlgoName = null;
        int i = algoName.indexOf(""/"");
        if (i != -1)
            desAlgoName = algoName.substring(0, i);
        else
            desAlgoName = algoName;
        return desAlgoName;
    }

    /**
     * Adds padding characters to the data to be encrypted. Also adds random
     * Initial Value to the beginning of the encrypted data when using Triple
     * DES in CBC mode (DES-EDE3/CBC).
     * 
     * @param inData
     *            Array of bytes to be padded
     * @param offset
     *            Offset to starting point within array
     * @param len
     *            Number of bytes to be encrypted
     * @return Padded array of bytes
     */
    public static byte[] addPadding(byte[] inData, int offset, int len) {
        System.out.println(""addPadding offset &gt;&gt; ""+offset+"", len &gt;&gt; ""+len);
        byte[] bp = null;
        int padChars = PADDING_BLOCK; // start with max padding value
        int partial = (len + 1) % padChars; // calculate how many extra bytes
                                            // exist
        if (partial == 0) {
            padChars = 1; // if none, set to only pad with length byte
        } else {
            padChars = padChars - partial + 1; // calculate padding size to
                                                // include length
        }
        System.out.println(""addPadding &gt;&gt; Add padding of ""+padChars);
        /*
         * Create a byte array large enough to hold data plus padding bytes The
         * count of padding bytes is placed in the first byte of the data to be
         * encrypted. That byte is included in the count.
         */
        bp = new byte[len + padChars];
        bp[0] = Byte.parseByte(Integer.toString(padChars));
        System.arraycopy(inData, offset, bp, 1, len);
        return bp;
    }

    public static byte[] hexFromString(String hex) {
        int len = hex.length();
        byte[] buf = new byte[((len + 1) / 2)];

        int i = 0, j = 0;
        if ((len % 2) == 1)
            buf[j++] = (byte) fromDigit(hex.charAt(i++));

        while (i &lt; len) {
            buf[j++] = (byte) ((fromDigit(hex.charAt(i++)) &lt;&lt; 4) | fromDigit(hex
                    .charAt(i++)));
        }
        return buf;
    }

    public static int fromDigit(char ch) {
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
            return ch - '0';
        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
            return ch - 'A' + 10;
        if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
            return ch - 'a' + 10;

        throw new IllegalArgumentException(""invalid hex digit '"" + ch + ""'"");
    }

    public static String hexToString(byte[] ba) {
        return hexToString(ba, 0, ba.length);
    }

    public static final char[] hexDigits = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    public static String hexToString(byte[] ba, int offset, int length) {
        char[] buf = new char[length * 2];
        int j = 0;
        int k;

        for (int i = offset; i &lt; offset + length; i++) {
            k = ba[i];
            buf[j++] = hexDigits[(k &gt;&gt;&gt; 4) &amp; 0x0F];
            buf[j++] = hexDigits[k &amp; 0x0F];
        }
        return new String(buf);
    }

}
</code></pre>

<p>I need to migrate this code to Nodejs and facing multiple issues. I refeered <a href=""http://mygo.iteye.com/blog/2018882"" rel=""nofollow"">http://mygo.iteye.com/blog/2018882</a> to get the basic idea on nodejs way to do the encryption in des3. However I see following difference in JAVA way and Nodejs way.</p>

<pre><code>1. JAVA is using Hex string of 48 lenght as key, since one char in hex is 4 bits therfore final size is equivalent to 24 bytes length which meets DES3 requirement. 
2. In Java code, final key is being used as bytes (as needed by DES) which made indpendent of the way we store the key
3. In node js, key is stored as character i.e. to use des3 I have to use 24 bytes which is equivalent to 24 chars key as  73AD9CEC99816AA6A4D82FB2. Here this is string of 24 chars and since one char is one byte thereofore total length is 24 bytes which meets DES3 requirement.
4. Following is nodejs code for reference
https://github.com/dilipkumar2k6/3des/blob/master/Crypto.js
'use strict';
/*
 *  Offers related services.
 */
var crypto = require(""crypto"");

module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: true,
            key: '73AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = param.plaintext;
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;

}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return txt;
}
</code></pre>

<p>Following is my problem.</p>

<pre><code>1. How can i convert my existing hex code into string? I used ""hexToString"" method (please check the java code)to convert hex into string. However getting weired character (this is also expected but problem is how i can use this transformed key in nodejs.
2. Can I pass byte array as key to Nodejs? It will make problem easy as I can easily convert my hex key into bytes array and I store my bytes array key in nodejs code.
3. In my javacode, I have custom padding logic, how can i write same logic in nodejs?
4. Most importantly, can I achieve same encryption logic in nodejs (similar to java)?
</code></pre>

<p>Artjom B. helped me to get the insight of nodejs and des3 algorithm. I have edited my post to clarify my exact requirement.</p>

<p>I think my main problem is, how can i feed byte[] as key to nodejs crypto for DES3?</p>

<p>I am kind of stuck. Please help.</p>
","<p>Running <code>crypto.getCiphers()</code> shows you the available ciphers. Triple DES (EDE) in ECB mode with two keys (16 byte key) can be used as <code>des-ede</code>. If you have three part key (24 byte key) you should use <code>des-ede3</code>. <code>ecb</code> probably does not appear in the cipher description, because it's the most basic form.</p>

<p>Triple DES-EDE has different ways to use a key. EDE means encrypt-decrypt-encrypt with three different keys. If you only have for example one 8 byte key, this suggests that you use the same key for every phase of EDE. It's clear from your Java code that you have a 24 byte key (48 hex encoded chars). You have to <strong>use the same key</strong>.</p>

<p>The crypto module uses PKCS7 padding by default, so you will need to set the <a href=""https://nodejs.org/api/crypto.html#crypto_cipher_setautopadding_auto_padding_true"" rel=""nofollow"">auto padding to false</a> and do the padding yourself. I leave that task up to you.</p>

<pre><code>module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: false,
            key: '73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function mypad(buf){
    // TODO: do the padding
    // replicate padding as in Java
    return buf;
}

function myunpad(buf){
    // TODO: do the unpadding
    // read the first *byte* and remove as many trailing *bytes*
    return buf;
}

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = mypad(new Buffer(param.plaintext));
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;
}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return myunpad(new Buffer(txt, 'hex'));
}
</code></pre>

<hr>

<p>Word of caution:</p>

<p>Don't use (3)DES especially with only one 8 byte key! Don't use ECB mode! Don't use NoPadding for block modes! Use AES-256 with GCM mode (no padding since it's a streaming mode).-</p>
","4474","<node.js><des><cryptojs>","0","3","2","2016-08-17 10:03:12","29832471","1","2","1122154","","2015-04-25 00:37:55","2015-04-23 18:13:38",""
"29831300","Convert DESede/ECB/NoPadding algorithm written in java into Nodejs using crypto module","<p>I am working on migration of code form java to Nodejs. I have one requirement to encrypt the text with private key using ""DESede/ECB/NoPadding"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs. Since encrypted key is sent to other application therefore I can't change the algorithm or key here. Following is approach used in java</p>

<pre><code>1. Stored the private key in hex string. I.e. 48 chars hex string as below which is equivalent to 24 bytes reuquired for 3des
73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2
2. Following is code written in java 
https://github.com/dilipkumar2k6/3des/blob/master/TripleDes.java
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;


public class TripleDes {
    // Crypto library related keys
    private static final String ALGO_NAME = ""DESede/ECB/NoPadding"";
    private static final int PADDING_BLOCK = 8;

    // Test Data
    private static final String PLAIN_TEXT = ""Hello World"";
    private static final String SHARED_KEY = ""73AD9CEC99816AA6A4D82FB273AD9CEC99816AA6A4D82FB2"";

    public static void main(String[] arg) {

        try {
            // Get Algorithm name
            String desAlgoName = getDESAlgorithmName(ALGO_NAME);
            // Create Cipher object
            Cipher cipher = Cipher.getInstance(ALGO_NAME);
            //Actual DES algo needs 56 bits key, which is equivalent to 1byte (0 at 0th position)  Get 8*3 byets key
            byte [] key = hexFromString(SHARED_KEY);
            System.out.println(""DES Algorithm  shared key size in bytes &gt;&gt; ""+key.length);
            // Create SecretKeySpec
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, desAlgoName);
            //Encrypt bytes
            byte [] encryptedBytes = encryptIntoBytes(cipher, secretKeySpec, PLAIN_TEXT.getBytes(), 0, PLAIN_TEXT.getBytes().length);
            String encryptedString=  hexToString(encryptedBytes);
            System.out.println(encryptedString);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public static byte[] encryptIntoBytes(Cipher cipher, SecretKeySpec secretKeySpec, byte[] dct, int offset, int len) throws GeneralSecurityException {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] ect = cipher.doFinal(addPadding(dct, offset, len));
        return ect;
    }

    public static String getDESAlgorithmName(String algoName) {
        System.out.println(""getDESAlgorithmName algoName &gt;&gt; ""+algoName);
        String desAlgoName = null;
        int i = algoName.indexOf(""/"");
        if (i != -1)
            desAlgoName = algoName.substring(0, i);
        else
            desAlgoName = algoName;
        return desAlgoName;
    }

    /**
     * Adds padding characters to the data to be encrypted. Also adds random
     * Initial Value to the beginning of the encrypted data when using Triple
     * DES in CBC mode (DES-EDE3/CBC).
     * 
     * @param inData
     *            Array of bytes to be padded
     * @param offset
     *            Offset to starting point within array
     * @param len
     *            Number of bytes to be encrypted
     * @return Padded array of bytes
     */
    public static byte[] addPadding(byte[] inData, int offset, int len) {
        System.out.println(""addPadding offset &gt;&gt; ""+offset+"", len &gt;&gt; ""+len);
        byte[] bp = null;
        int padChars = PADDING_BLOCK; // start with max padding value
        int partial = (len + 1) % padChars; // calculate how many extra bytes
                                            // exist
        if (partial == 0) {
            padChars = 1; // if none, set to only pad with length byte
        } else {
            padChars = padChars - partial + 1; // calculate padding size to
                                                // include length
        }
        System.out.println(""addPadding &gt;&gt; Add padding of ""+padChars);
        /*
         * Create a byte array large enough to hold data plus padding bytes The
         * count of padding bytes is placed in the first byte of the data to be
         * encrypted. That byte is included in the count.
         */
        bp = new byte[len + padChars];
        bp[0] = Byte.parseByte(Integer.toString(padChars));
        System.arraycopy(inData, offset, bp, 1, len);
        return bp;
    }

    public static byte[] hexFromString(String hex) {
        int len = hex.length();
        byte[] buf = new byte[((len + 1) / 2)];

        int i = 0, j = 0;
        if ((len % 2) == 1)
            buf[j++] = (byte) fromDigit(hex.charAt(i++));

        while (i &lt; len) {
            buf[j++] = (byte) ((fromDigit(hex.charAt(i++)) &lt;&lt; 4) | fromDigit(hex
                    .charAt(i++)));
        }
        return buf;
    }

    public static int fromDigit(char ch) {
        if (ch &gt;= '0' &amp;&amp; ch &lt;= '9')
            return ch - '0';
        if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')
            return ch - 'A' + 10;
        if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f')
            return ch - 'a' + 10;

        throw new IllegalArgumentException(""invalid hex digit '"" + ch + ""'"");
    }

    public static String hexToString(byte[] ba) {
        return hexToString(ba, 0, ba.length);
    }

    public static final char[] hexDigits = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    public static String hexToString(byte[] ba, int offset, int length) {
        char[] buf = new char[length * 2];
        int j = 0;
        int k;

        for (int i = offset; i &lt; offset + length; i++) {
            k = ba[i];
            buf[j++] = hexDigits[(k &gt;&gt;&gt; 4) &amp; 0x0F];
            buf[j++] = hexDigits[k &amp; 0x0F];
        }
        return new String(buf);
    }

}
</code></pre>

<p>I need to migrate this code to Nodejs and facing multiple issues. I refeered <a href=""http://mygo.iteye.com/blog/2018882"" rel=""nofollow"">http://mygo.iteye.com/blog/2018882</a> to get the basic idea on nodejs way to do the encryption in des3. However I see following difference in JAVA way and Nodejs way.</p>

<pre><code>1. JAVA is using Hex string of 48 lenght as key, since one char in hex is 4 bits therfore final size is equivalent to 24 bytes length which meets DES3 requirement. 
2. In Java code, final key is being used as bytes (as needed by DES) which made indpendent of the way we store the key
3. In node js, key is stored as character i.e. to use des3 I have to use 24 bytes which is equivalent to 24 chars key as  73AD9CEC99816AA6A4D82FB2. Here this is string of 24 chars and since one char is one byte thereofore total length is 24 bytes which meets DES3 requirement.
4. Following is nodejs code for reference
https://github.com/dilipkumar2k6/3des/blob/master/Crypto.js
'use strict';
/*
 *  Offers related services.
 */
var crypto = require(""crypto"");

module.exports = {
    encrypt: function (plainText) {
        return encrypt({
            alg: 'des-ede3', //3des-ecb  
            autoPad: true,
            key: '73AD9CEC99816AA6A4D82FB2',
            plaintext: 'Hello World',
            iv: null
        });
    }
};

function encrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0);
    var plaintext = param.plaintext;
    var alg = param.alg;
    var autoPad = param.autoPad;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);  //default true  
    var ciph = cipher.update(plaintext, 'utf8', 'hex');
    ciph += cipher.final('hex');
    console.log(alg, ciph);
    return ciph;

}

function decrypt(param) {
    var key = new Buffer(param.key);
    var iv = new Buffer(param.iv ? param.iv : 0)
    var alg = param.alg;
    var autoPad = param.autoPad;

    //decrypt  
    var decipher = crypto.createDecipheriv(alg, key, iv);
    cipher.setAutoPadding(autoPad);
    var txt = decipher.update(ciph, 'hex', 'utf8');
    txt += decipher.final('utf8');
    console.log(alg, txt);
    return txt;
}
</code></pre>

<p>Following is my problem.</p>

<pre><code>1. How can i convert my existing hex code into string? I used ""hexToString"" method (please check the java code)to convert hex into string. However getting weired character (this is also expected but problem is how i can use this transformed key in nodejs.
2. Can I pass byte array as key to Nodejs? It will make problem easy as I can easily convert my hex key into bytes array and I store my bytes array key in nodejs code.
3. In my javacode, I have custom padding logic, how can i write same logic in nodejs?
4. Most importantly, can I achieve same encryption logic in nodejs (similar to java)?
</code></pre>

<p>Artjom B. helped me to get the insight of nodejs and des3 algorithm. I have edited my post to clarify my exact requirement.</p>

<p>I think my main problem is, how can i feed byte[] as key to nodejs crypto for DES3?</p>

<p>I am kind of stuck. Please help.</p>
","<p>This is my decrypt function based on Artjom's answer. use 'des-ede3' if you have a 24byte key.</p>

<pre><code>internals.decrypt = function (message, key) {
    var message = Buffer.from(message, 'base64');
    var decipher = crypto.createDecipher('des-ede', key);

    var decryptedMessage = decipher.update(message, 'hex', 'utf8');
    decryptedMessage += decipher.final('utf8');
    return decryptedMessage.toString();
}
</code></pre>
","4474","<node.js><des><cryptojs>","0","1","2","2016-08-17 10:03:12","29832471","1","2","1122154","","2015-04-25 00:37:55","2015-04-23 18:13:38",""
"34755723","AES encryption with jquery","<p>I am trying to encrypt and decrypt AES locally using the <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">CryptoJS</a> library.<br>
I have the code from the <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">example</a>:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(mess, pass);
var decrypted = CryptoJS.AES.decrypt(encrypted, pass);
</code></pre>

<p>but the <code>decrypted</code> variable is not returing the <code>mess</code> variable? Why is that?</p>

<p>Please see <a href=""http://jsfiddle.net/h9jrt2ez/"" rel=""nofollow"">JSFiddle</a>?</p>
","<p>From the <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>The hash you get back isn't a string yet. It's a WordArray object. When you use a WordArray object in a string context, it's automatically converted to a hex string.</p>
  
  <p>[...]</p>
  
  <p>You can convert a WordArray object to other formats by explicitly calling the toString method and passing an encoder.</p>
</blockquote>

<p>Replace <code>decrypted</code> with <code>decrypted.toString(CryptoJS.enc.Utf8))</code>, see the <a href=""http://jsfiddle.net/h9jrt2ez/1/"" rel=""nofollow"">updated fiddle</a>.</p>
","4451","<javascript><encryption><aes><cryptojs>","0","1","1","2016-01-12 23:52:26","34755924","2","","1816580","","2016-01-12 23:52:26","2016-01-12 23:27:00","2016-01-12 23:53:54"
"30990129","Encrypt in python - decrypt in Javascript","<p>I have need to simply encrypt some text in python and being able to decrypt in JavaScrypt.</p>

<p>So far I have in python:</p>

<pre><code>from Crypto import Random
from Crypto.Cipher import AES
import base64

BLOCK_SIZE = 16
key = ""1234567890123456"" # want to be 16 chars
textToEncrypt = ""This is text to encrypt""

def encrypt(message, passphrase):
    # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return base64.b64encode(aes.encrypt(message))

def decrypt(encrypted, passphrase):
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return aes.decrypt(base64.b64decode(encrypted))

print encrypt( textToEncrypt, key )
</code></pre>

<p>this is producing text: <code>ZF9as5JII5TlqcB5tAd4sxPuBXd5TrgE</code></p>

<p>in JavaScript:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var decrypted = CryptoJS.AES.decrypt( ""ZF9as5JII5TlqcB5tAd4sxPuBXd5TrgE"", ""1234567890123456"");
    console.log ( decrypted.toString( CryptoJS.enc.Utf8 ) );
&lt;/script&gt;
</code></pre>

<p>however it does not produce original string (empty string instead).
What I am doing wrong ?</p>

<p>Is it focusing on AES is a best idea - I will be happy if I have some kind of encryption that will blur data. </p>
","<p>There are many problems with your Python code <em>and</em> CryptoJS code:</p>

<ul>
<li><p>You use a random IV to encrypt some plaintext in Python. If you want to retrieve that plaintext, you need to use <strong>the same IV</strong> during decryption. The plaintext cannot be recovered without the IV. Usually the IV is simply prepended to the ciphertext, because it doesn't have to be secret. So you need to read the IV during decryption and not generate a new one.</p></li>
<li><p>You use CBC mode in CryptoJS (default) instead of CFB mode. The mode has to be the same. The other tricky part is that CFB mode is parametrized with a segment size. PyCrypto uses by default 8-bit segments (CFB8), but CryptoJS is only implemented for fixed segments of 128-bit (CFB128). Since the PyCrypto version is variable, you need to change that.</p></li>
<li><p>The CryptoJS <code>decrypt()</code> function expects as ciphertext either an OpenSSL formatted string or a CipherParams object. Since you don't have an OpenSSL formatted string, you have to convert the ciphertext into an object.</p></li>
<li><p>The <code>key</code> for CryptoJS is expected to be a WordArray and not a string.</p></li>
<li><p>Use the same padding. PyCrypto doesn't pad the plaintext if CFB8 is used, but padding is needed when CFB128 is used. CryptoJS uses PKCS#7 padding by default, so you only need to implement that padding in python.</p></li>
</ul>

<p>Python code (for version 2):</p>

<pre><code>def pad(data):
    length = 16 - (len(data) % 16)
    return data + chr(length)*length

def unpad(data):
    return data[:-ord(data[-1])]

def encrypt(message, passphrase):
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV, segment_size=128)
    return base64.b64encode(IV + aes.encrypt(pad(message)))

def decrypt(encrypted, passphrase):
    encrypted = base64.b64decode(encrypted)
    IV = encrypted[:BLOCK_SIZE]
    aes = AES.new(passphrase, AES.MODE_CFB, IV, segment_size=128)
    return unpad(aes.decrypt(encrypted[BLOCK_SIZE:]))
</code></pre>

<p>JavaScript code:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/components/mode-cfb-min.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var base64ciphertextFromPython = ""..."";
    var ciphertext = CryptoJS.enc.Base64.parse(base64ciphertextFromPython);

    // split iv and ciphertext
    var iv = ciphertext.clone();
    iv.sigBytes = 16;
    iv.clamp();
    ciphertext.words.splice(0, 4); // delete 4 words = 16 bytes
    ciphertext.sigBytes -= 16;

    var key = CryptoJS.enc.Utf8.parse(""1234567890123456"");

    // decryption
    var decrypted = CryptoJS.AES.decrypt({ciphertext: ciphertext}, key, {
      iv: iv,
      mode: CryptoJS.mode.CFB
    });
    console.log ( decrypted.toString(CryptoJS.enc.Utf8));
&lt;/script&gt;
</code></pre>

<hr>

<p><strong>Other considerations:</strong></p>

<p>It seems that you want to use a passphrase as a key. Passphrases are usually human readable, but keys are not. You can derive a key from a passphrase with functions such as PBKDF2, bcrypt or scrypt.</p>

<p>The code above is not fully secure, because it lacks authentication. Unauthenticated ciphertexts may lead to viable attacks and unnoticed data manipulation. Usually the an encrypt-then-MAC scheme is employed with a good MAC function such as HMAC-SHA256.</p>
","4429","<javascript><python><encryption><pycrypto><cryptojs>","3","12","2","2017-07-31 19:19:27","","6","1","367878","","2015-06-29 20:04:57","2015-06-22 21:28:55",""
"30990129","Encrypt in python - decrypt in Javascript","<p>I have need to simply encrypt some text in python and being able to decrypt in JavaScrypt.</p>

<p>So far I have in python:</p>

<pre><code>from Crypto import Random
from Crypto.Cipher import AES
import base64

BLOCK_SIZE = 16
key = ""1234567890123456"" # want to be 16 chars
textToEncrypt = ""This is text to encrypt""

def encrypt(message, passphrase):
    # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return base64.b64encode(aes.encrypt(message))

def decrypt(encrypted, passphrase):
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CFB, IV)
    return aes.decrypt(base64.b64decode(encrypted))

print encrypt( textToEncrypt, key )
</code></pre>

<p>this is producing text: <code>ZF9as5JII5TlqcB5tAd4sxPuBXd5TrgE</code></p>

<p>in JavaScript:</p>

<pre class=""lang-html prettyprint-override""><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var decrypted = CryptoJS.AES.decrypt( ""ZF9as5JII5TlqcB5tAd4sxPuBXd5TrgE"", ""1234567890123456"");
    console.log ( decrypted.toString( CryptoJS.enc.Utf8 ) );
&lt;/script&gt;
</code></pre>

<p>however it does not produce original string (empty string instead).
What I am doing wrong ?</p>

<p>Is it focusing on AES is a best idea - I will be happy if I have some kind of encryption that will blur data. </p>
","<p>(1 Year later but I hope this works for someone)</p>

<p>First of all, thanks Artjom B. your post helps me a lot. And Like OP, I have the same same problem Python server endonding and Javascript client decoding. This was my solution:</p>

<hr/>

<p><strong>Python 3.x</strong> (Server)</p>

<p>I used an excplicit <strong>PKCS7</strong> encode for padding, why? because I want to be sure Im using the same padding enconding and decoding, this is the link where I found it <a href=""http://programmerin.blogspot.com.co/2011/08/python-padding-with-pkcs7.html"" rel=""noreferrer"">http://programmerin.blogspot.com.co/2011/08/python-padding-with-pkcs7.html</a> .</p>

<p>Then, like Artjom B. said, be sure about your segment size, IV size and AES mode (CBC for me),</p>

<p>This is the code:</p>

<pre><code>def encrypt_val(clear_text):
    master_key = '1234567890123456' 
    encoder = PKCS7Encoder()
    raw = encoder.encode(clear_text)
    iv = Random.new().read( 16 )
    cipher = AES.new( master_key, AES.MODE_CBC, iv, segment_size=128 )
    return base64.b64encode( iv + cipher.encrypt( raw ) ) 
</code></pre>

<p>Note than your are enconding on base64 the concatenation of IV and encryption data.</p>

<hr/>

<p><strong>Javascript</strong> (client)</p>

<pre><code>function decryptMsg (data) {
    master_key = '1234567890123456';

    // Decode the base64 data so we can separate iv and crypt text.
    var rawData = atob(data);
    // Split by 16 because my IV size
    var iv = rawData.substring(0, 16);
    var crypttext = rawData.substring(16);

    //Parsers
    crypttext = CryptoJS.enc.Latin1.parse(crypttext);
    iv = CryptoJS.enc.Latin1.parse(iv); 
    key = CryptoJS.enc.Utf8.parse(master_key);

    // Decrypt
    var plaintextArray = CryptoJS.AES.decrypt(
      { ciphertext:  crypttext},
      key,
      {iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7}
    );

    // Can be Utf8 too
    output_plaintext = CryptoJS.enc.Latin1.stringify(plaintextArray);
    console.log(""plain text : "" + output_plaintext);
}
</code></pre>

<p>One of my main problem was keep in mind all kind of encoding and decoding data, for example, I didn't know that the master_key on client side was to be parse with Utf8.</p>
","4429","<javascript><python><encryption><pycrypto><cryptojs>","3","6","2","2017-07-31 19:19:27","","6","1","367878","","2015-06-29 20:04:57","2015-06-22 21:28:55",""
"39505636","Encryption in C# Decryption in JS (CryptoJS)","<p>I do not get the same result on CryptoJS. May you please check what is wrong?</p>

<p>Here is my expected input/outputs:</p>

<pre><code>Encrypted String: 723024D59CF7801A295F81B9D5BB616E
Decrypted String: stackoverflow
</code></pre>

<p>Here are my Decryption/Encryption methods in C# . Encryption is TripleDES mode CBC, I am using the same key and iv on the CryptoJS code.</p>

<pre><code>public static string Encrypt(string data, string key, string iv)
{
    byte[] bdata = Encoding.ASCII.GetBytes(data);
    byte[] bkey = HexToBytes(key);
    byte[] biv = HexToBytes(iv);

    var stream = new MemoryStream();
    var encStream = new CryptoStream(stream,
        des3.CreateEncryptor(bkey, biv), CryptoStreamMode.Write);

    encStream.Write(bdata, 0, bdata.Length);
    encStream.FlushFinalBlock();
    encStream.Close();

    return BytesToHex(stream.ToArray());
}

public static string Decrypt(string data, string key, string iv)
{
    byte[] bdata = HexToBytes(data);
    byte[] bkey = HexToBytes(key);
    byte[] biv = HexToBytes(iv);

    var stream = new MemoryStream();
    var encStream = new CryptoStream(stream,
        des3.CreateDecryptor(bkey, biv), CryptoStreamMode.Write);

    encStream.Write(bdata, 0, bdata.Length);
    encStream.FlushFinalBlock();
    encStream.Close();

    return Encoding.ASCII.GetString(stream.ToArray());
}
</code></pre>

<p>Here is how I do the decryption using CryptoJS</p>

<pre><code>var key = ""90033E3984CEF5A659C44BBB47299B4208374FB5DC495C96"";
var iv = ""E6B9AFA7A282A0CA"";

key = CryptoJS.enc.Hex.parse(key);
iv = CryptoJS.enc.Hex.parse(iv);


// Input is a Hex String
var decrypted = CryptoJS.TripleDES.decrypt('723024D59CF7801A295F81B9D5BB616E', key, { iv : iv, mode:CryptoJS.mode.CBC});
console.log(decrypted.toString());
</code></pre>
","<p>CryptoJS expects the ciphertext to be a <code>CipherParams</code> object or an OpenSSL-encoded string. You've passed in the ciphertext as Hex. Do this instead:</p>

<pre><code>var decrypted = CryptoJS.TripleDES.decrypt({
    ciphertext: CryptoJS.enc.Hex.parse('723024D59CF7801A295F81B9D5BB616E')
}, key, { 
    iv : iv, 
    mode:CryptoJS.mode.CBC
});
</code></pre>

<p><code>decrypted</code> is now a <code>WordArray</code> object. Stringifying it leads to a string with the default encoding which is Hex. If you know that you should get text out, you can use the appropriate encoding like:</p>

<pre><code>console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","4330","<javascript><c#><encryption><cryptojs><tripledes>","0","1","2","2019-09-27 07:45:12","39516635","1","","1816580","","2016-09-15 16:57:22","2016-09-15 07:47:31",""
"39505636","Encryption in C# Decryption in JS (CryptoJS)","<p>I do not get the same result on CryptoJS. May you please check what is wrong?</p>

<p>Here is my expected input/outputs:</p>

<pre><code>Encrypted String: 723024D59CF7801A295F81B9D5BB616E
Decrypted String: stackoverflow
</code></pre>

<p>Here are my Decryption/Encryption methods in C# . Encryption is TripleDES mode CBC, I am using the same key and iv on the CryptoJS code.</p>

<pre><code>public static string Encrypt(string data, string key, string iv)
{
    byte[] bdata = Encoding.ASCII.GetBytes(data);
    byte[] bkey = HexToBytes(key);
    byte[] biv = HexToBytes(iv);

    var stream = new MemoryStream();
    var encStream = new CryptoStream(stream,
        des3.CreateEncryptor(bkey, biv), CryptoStreamMode.Write);

    encStream.Write(bdata, 0, bdata.Length);
    encStream.FlushFinalBlock();
    encStream.Close();

    return BytesToHex(stream.ToArray());
}

public static string Decrypt(string data, string key, string iv)
{
    byte[] bdata = HexToBytes(data);
    byte[] bkey = HexToBytes(key);
    byte[] biv = HexToBytes(iv);

    var stream = new MemoryStream();
    var encStream = new CryptoStream(stream,
        des3.CreateDecryptor(bkey, biv), CryptoStreamMode.Write);

    encStream.Write(bdata, 0, bdata.Length);
    encStream.FlushFinalBlock();
    encStream.Close();

    return Encoding.ASCII.GetString(stream.ToArray());
}
</code></pre>

<p>Here is how I do the decryption using CryptoJS</p>

<pre><code>var key = ""90033E3984CEF5A659C44BBB47299B4208374FB5DC495C96"";
var iv = ""E6B9AFA7A282A0CA"";

key = CryptoJS.enc.Hex.parse(key);
iv = CryptoJS.enc.Hex.parse(iv);


// Input is a Hex String
var decrypted = CryptoJS.TripleDES.decrypt('723024D59CF7801A295F81B9D5BB616E', key, { iv : iv, mode:CryptoJS.mode.CBC});
console.log(decrypted.toString());
</code></pre>
","<p>The answer by Artjom B works, but is problematic if used with a static IV. The IV (and SALT) should change from message to message. And trying to create and send non-static IV / SALTS between different languages/libraries can be difficult.</p>

<p>So, as I was struggling also with exchanging encrypted texts between C# and JS I took the time to solve that once and for all and wrote a small library and published it under the <strong>MIT license</strong> for everyone to use. </p>

<p>The ciphertext is in base64 and combined by "":"" with the base64-SALT and the base64-IV</p>

<p>These are the steps to use it:</p>

<p>Use the library from <a href=""https://github.com/smartinmedia/Net-Core-JS-Encryption-Decryption"" rel=""nofollow noreferrer"">https://github.com/smartinmedia/Net-Core-JS-Encryption-Decryption</a></p>

<p><strong>For C#:</strong> </p>

<pre class=""lang-cs prettyprint-override""><code>    //Encrypt plain text in C# with a random password
    string plainText = ""This is my secret text!"";
    //You can also use the built in password generator!!
    //string passPhrase = PasswordGenerator.GenerateRandomPassword(20);
    //Or use your own password:        
    string passPhrase = ""This_is_my_password!"";

    var enc = EncryptionHandler.Encrypt(plainText, passPhrase);
    Console.WriteLine(""Plaintext: 'This is my secret text' with password 'This_is_my_password!' results in ciphertext: "" + enc);

    var dec3 = EncryptionHandler.Decrypt(enc, passPhrase);
    Console.WriteLine(""And decrypting again: "" + dec3);
    Console.WriteLine(""Please start the index.html to see the same in Javascript. Encryption / Decryption run in both ways and can be interchanged between C# and JS!"");
</code></pre>

<p><strong>For JS:</strong></p>

<pre><code>// This is the ciphertext, which was encrypted by C# to check the interchangeability:
    var encryptedBase64FromCSharp = ""uTkXNB+PSTjzwUCJbfAHVHd95YOlcJr38wbF08ZxqNw=:PNGRjWb5tOINneaVVf8+cw==:Aic+gosvLjTrCebzY8l/usTh+kWuE0v1xSWw7apYunI="";
    var passPhrase = ""This_is_my_password!"";

    var eH = new encryptionHandler();

    var decryptedFromCSharp = eH.decrypt(encryptedBase64FromCSharp, passPhrase);

    //Now encrypt again with JS
    var encryptTextWithJs = eH.encrypt(decryptedFromCSharp, ""This_is_my_password!"");
    //And decrypt again with JS
    var decryptedTextWithJs = eH.decrypt(encryptTextWithJs, ""This_is_my_password!"");
</code></pre>

<p>So, as you can see here, the ciphertexts can be exchanged between C# and JS with randomly generated SALTs and IVs (which are generated in the methods encrypt/decrypt).</p>
","4330","<javascript><c#><encryption><cryptojs><tripledes>","0","0","2","2019-09-27 07:45:12","39516635","1","","1816580","","2016-09-15 16:57:22","2016-09-15 07:47:31",""
"28648326","Encryption in Meteor","<p>I have user sign in form. It has about 10 inputs. I want to save that user, random generate password and hash and salt it and save it. How to achieve that? I couldn't find any good tutorial for using Crypto.js in meteor. I always stumble upon account-password package.</p>
","<p><code>accounts-password</code> actually takes care of this for you. I wish the documentation of the implementation details was better, but you can see an overview <a href=""https://www.meteor.com/accounts"">here</a>.</p>

<p>Passwords are verified by examining hashes, so only a hashed version of the passed from the client to the server which is then run through bcrypt.</p>

<p>client: password --> network: sha256(password) --> server: bcrypt(sha256(password))</p>

<p>What's nice about this implementation is: (a) the server never sees or stores password-equivalent data, (b) it's all done for you just by installing the package.</p>

<p>Also see <a href=""https://meteor.hackpad.com/SRP-bcrypt-J5mdBojeVfe"">this hackpad</a> for more details.</p>
","4317","<javascript><encryption><meteor><cryptojs>","4","14","1","2015-02-21 17:25:26","28648775","1","5","","","","2015-02-21 16:49:02",""
"20263741","Getting md5sum of a file through Crypto.js","<p>I am trying to get the md5sum of a tar file to produce the same value when using the md5sum linux command and CryptoJS's MD5 method.</p>

<p>In JavaScript I do (after a file has been put in an HTML form):</p>

<pre><code>var reader = new FileReader();

reader.onloadend = function () {
     text = (reader.result);
}

reader.readAsBinaryString(document.getElementById(""firmware_firmware"").files[0]);

var hash = CryptoJS.MD5(text);

hash.toString();
</code></pre>

<p>In Linux I do:</p>

<pre><code>md5sum name_of_file.tar
</code></pre>

<p>Currently these two produce different results. How am I able to get JavaScript to get the contents of the tar file to be MD5ed in the same way that md5sum does on Linux?</p>

<p>For a simple String, md5sum and CryptoJS produce the same value.</p>

<p>Edit: With a file called Fred.txt, with content the content: ""Fred"", both md5sum and CryptoJS produce the same value: c624decb46fa3d60e824389311b252f6.</p>

<p>On the update.tar file, the md5sum on linux gives me: 1f046eedb7d8279953d233e590830e4f, on CryptoJS it gives me: f0c3730e5a9863cffa0ba3fadd531788</p>

<p>Edit2: Further testing shows that this is actually a problem due to large file size such as 7 MegaBytes</p>
","<p>I think this is because the file does not finish loading and the hash gets created before the file upload is 100%. Try moving the hashing into the onloadend event:</p>

<pre><code>var reader = new FileReader();

reader.onloadend = function () {
     var hash = CryptoJS.MD5(reader.result);
     hash.toString();
}

reader.readAsBinaryString(document.getElementById(""firmware_firmware"").files[0]);
</code></pre>
","4291","<javascript><linux><md5><fileapi><cryptojs>","5","0","3","2018-06-05 13:33:14","20363583","3","2","967795","","2013-11-28 11:38:35","2013-11-28 10:37:08",""
"20263741","Getting md5sum of a file through Crypto.js","<p>I am trying to get the md5sum of a tar file to produce the same value when using the md5sum linux command and CryptoJS's MD5 method.</p>

<p>In JavaScript I do (after a file has been put in an HTML form):</p>

<pre><code>var reader = new FileReader();

reader.onloadend = function () {
     text = (reader.result);
}

reader.readAsBinaryString(document.getElementById(""firmware_firmware"").files[0]);

var hash = CryptoJS.MD5(text);

hash.toString();
</code></pre>

<p>In Linux I do:</p>

<pre><code>md5sum name_of_file.tar
</code></pre>

<p>Currently these two produce different results. How am I able to get JavaScript to get the contents of the tar file to be MD5ed in the same way that md5sum does on Linux?</p>

<p>For a simple String, md5sum and CryptoJS produce the same value.</p>

<p>Edit: With a file called Fred.txt, with content the content: ""Fred"", both md5sum and CryptoJS produce the same value: c624decb46fa3d60e824389311b252f6.</p>

<p>On the update.tar file, the md5sum on linux gives me: 1f046eedb7d8279953d233e590830e4f, on CryptoJS it gives me: f0c3730e5a9863cffa0ba3fadd531788</p>

<p>Edit2: Further testing shows that this is actually a problem due to large file size such as 7 MegaBytes</p>
","<p>All strings in JavaScript - even ""binary strings"" - are actually UTF-16 characters. A ""binary string"" is one that chooses to use only the first 256 code points. Since the Latin-1 encoding also uses exactly the first 256 code points, you can convert the string to bytes using Latin-1.</p>

<pre><code>var hash = CryptoJS.MD5(CryptoJS.enc.Latin1.parse(text));
</code></pre>
","4291","<javascript><linux><md5><fileapi><cryptojs>","5","6","3","2018-06-05 13:33:14","20363583","3","2","967795","","2013-11-28 11:38:35","2013-11-28 10:37:08",""
"20263741","Getting md5sum of a file through Crypto.js","<p>I am trying to get the md5sum of a tar file to produce the same value when using the md5sum linux command and CryptoJS's MD5 method.</p>

<p>In JavaScript I do (after a file has been put in an HTML form):</p>

<pre><code>var reader = new FileReader();

reader.onloadend = function () {
     text = (reader.result);
}

reader.readAsBinaryString(document.getElementById(""firmware_firmware"").files[0]);

var hash = CryptoJS.MD5(text);

hash.toString();
</code></pre>

<p>In Linux I do:</p>

<pre><code>md5sum name_of_file.tar
</code></pre>

<p>Currently these two produce different results. How am I able to get JavaScript to get the contents of the tar file to be MD5ed in the same way that md5sum does on Linux?</p>

<p>For a simple String, md5sum and CryptoJS produce the same value.</p>

<p>Edit: With a file called Fred.txt, with content the content: ""Fred"", both md5sum and CryptoJS produce the same value: c624decb46fa3d60e824389311b252f6.</p>

<p>On the update.tar file, the md5sum on linux gives me: 1f046eedb7d8279953d233e590830e4f, on CryptoJS it gives me: f0c3730e5a9863cffa0ba3fadd531788</p>

<p>Edit2: Further testing shows that this is actually a problem due to large file size such as 7 MegaBytes</p>
","<p>When you're running your bash, make sure you're not sending a newline to hashing function. If you use <code>echo</code>, add <code>-n</code> parameter:</p>

<pre><code>$ echo -n abc | md5sum
900150983cd24fb0d6963f7d28e17f72  -
</code></pre>

<p>vs:</p>

<pre><code>$ echo abc | md5sum
0bee89b07a248e27c83fc3d5951213c1  -
</code></pre>
","4291","<javascript><linux><md5><fileapi><cryptojs>","5","0","3","2018-06-05 13:33:14","20363583","3","2","967795","","2013-11-28 11:38:35","2013-11-28 10:37:08",""
"19649058","How to decrypt Triple Des CryptoJS values in Java class","<p>I was asked to encrypt some text from client side ( web ) before sending it to server side ( java )</p>

<p>So i try to use CryptoJS library for client side.
I encrypt it like this :</p>

<pre><code>    var key = ""aaaaaaaaaaaaaaaaaaaaaaaa"";
    var value = ""KF169841"";
    var encryptedString = CryptoJS.TripleDES.encrypt(value, key);
    console.log(encryptedString.toString());
</code></pre>

<p>And i get something like this : U2FsdGVkX19eYFFHgYGCr3v9/skTOKVp0pLWRNK9JTg=
I use this encryptedString and key in other <a href=""http://myeasywww.appspot.com/easyweb?command=UTILITY&amp;ID=2"" rel=""nofollow"">Decrypt tool online</a> ( Which also use CryptoJS ) and got back exact value KF169841.</p>

<p>After sending this value and key to server ( well key isn't sending directly to server though but for test, it is ), i need to decrypt it using Java.
But i quite don't know how to decrypt it. I'm tried some code from google search but it end up wrong padding if use DESese or get wrong value if i use ECB/NoPadding. 
I did try to something like setting sfg for CryptoJS side like:</p>

<pre><code>    mode: CryptoJS.mode.EBC,
    padding: CryptoJS.pad.NoPadding
</code></pre>

<p>But they got javascript exception ( a is not define )</p>

<p>So any have any experience with CryptoJS can help me decrypt this one using java ?</p>

<p>=============================================================</p>

<p>UPDATE : Sorry here my server side code i'm using</p>

<pre><code>/**
     * Method To Decrypt An Ecrypted String
     */
    public String decrypt(String encryptedString, String myEncryptionKey) {
        String decryptedText = null;
        try {
            byte[] keyAsBytes = myEncryptionKey.getBytes(""UTF8"");
            KeySpec myKeySpec = new DESedeKeySpec(keyAsBytes);
            SecretKeyFactory mySecretKeyFactory = 
                    SecretKeyFactory.getInstance(""DESede"");
            Cipher cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
            SecretKey key = mySecretKeyFactory.generateSecret(myKeySpec);

            cipher.init(Cipher.DECRYPT_MODE, key);
//            BASE64Decoder base64decoder = new BASE64Decoder();
//            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);

            byte[] encryptedText =  org.apache.commons.codec.binary.Base64.decodeBase64(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
</code></pre>
","<p>According to <a href=""http://code.google.com/p/crypto-js/#The_Cipher_Output"" rel=""nofollow"">the documentation</a>, your <code>encryptedString</code> variable contains structured data that must be split apart to be sent to Java code. You will need to send <code>encryptedString.iv</code> and <code>encryptedString.ciphertext</code> to your Java code. If you continue to use passwords (see below), you will need to send <code>encryptedString.salt</code> as well.</p>

<p>If you pass your key as a string it will be interpreted as a <em>password</em> and a key will be derived from it. If you actually want to pass an explicit key, follow the <a href=""http://code.google.com/p/crypto-js/#Custom_Key_and_IV"" rel=""nofollow"">documentation</a> and specify the IV and key as suggested by the code snippet below. If you stick with supplying a password, then you must figure out the derivation scheme and use the same process in your Java code.</p>

<pre class=""lang-js prettyprint-override""><code>// Code snippet from http://code.google.com/p/crypto-js/#Custom_Key_and_IV
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
    var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

    var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
&lt;/script&gt;
</code></pre>

<p>Regarding your Java code, it looks mostly OK (although there is plenty of room for error with string conversions). However, you probably want to convert your key from hex to binary rather than grabbing the bytes:</p>

<pre class=""lang-java prettyprint-override""><code>byte[] keyAsBytes = DatatypeConverter.parseHexBinary(myEncryptionKey);
</code></pre>

<p>This assumes you alter your JavaScript code to pass the literal key value.</p>

<p>You will also need to switch to <code>DESede/CBC/PKCS5Padding</code> and pass an <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/IvParameterSpec.html"" rel=""nofollow""><code>IVParameterSpec</code></a> object to your <code>Cipher.init</code> call, specifying the IV value sent from your Java Script code.</p>
","4146","<java><encryption><tripledes><cryptojs>","0","0","1","2013-10-29 10:13:24","","9","2","1897406","","2013-10-29 03:28:31","2013-10-29 03:21:14",""
"47128829","Unable to decrypt AES-256 (CBC) - Malformed Utf-8 data","<p>I've gone through several CrytoJS examples but haven't been able to make decryption work for me. I need to decode something for which a key (13 characters in length, just in case it's important) and iv (16 length after Base64 decode) I've been provided. I found this PHP example that works perfectly (these won't work if you run them - the key has been changed, of course :) ):</p>

<pre><code>$encrypted = urldecode('6x5Mex1DqqFK0Z9F%2F6W1FNB55UM%2Baoyjw6NgTwDDmHpVytJXNyQsA3J8jh3R4qt5MbKITzIORGLtgmfknUNLaBhBaBO%2F8GiFPT8A6wVgtQ6YOXkJHG8S9VKYgrN9MCeT0e8mbWMNfkkJ0ips4K87ZNzC6Lb5dbT1%2BRMw%2BpmCP7M8%2FwiBMdJZ%2FdINblg%2FapHtaqv6TUBRukB%2FEJWgGFB86h5fJ8VNZKssWtx35gLo6IHai6GTQpyS%2FNeq5ZbX%2BJwcnCKOzudHsdAyxk%2BQYltupFNBXBzxxW%2Fiixtew7uNtRJQfy2epcx0SOqRGKQfJrRReFWvldJWSKz%2Bv0aRMdZWCVRHovcwPLdXNWSK%2Brs7G0LCnjji4RyqzU9DTy%2BijA1Xx3xVmOxXysCkvqXNg2P0LJ0O0qLJF9lfQb%2FrrPH3h3lB0a7737CTzQh5kuqK%2FNabfV8qLNyV6cJ5oQWMfXw4LRxDIeK9Me8Fnb2K44uC39Q%3D');

$iv = urldecode('MkQ4NUFGNkVBNjIwMEY5OQ%3D%3D');

$secretKey = ""ABCDEFGHIJKL"";

// decrypt the body... 
$decrypted = trim(
    mcrypt_decrypt(MCRYPT_RIJNDAEL_128,
        substr(sha1($secretKey), 0, 32),
        base64_decode($encrypted),
        MCRYPT_MODE_CBC, 
        base64_decode($iv)
    ), ""\0..\32"");

print(""Decrypted: $decrypted"");
</code></pre>

<p>And now I'm trying to do something similar in CryptoJS, but keep getting the error <code>Malformed Utf-8 data</code>:</p>

<pre><code>var encrypted = decodeURIComponent('6x5Mex1DqqFK0Z9F%2F6W1FNB55UM%2Baoyjw6NgTwDDmHpVytJXNyQsA3J8jh3R4qt5MbKITzIORGLtgmfknUNLaBhBaBO%2F8GiFPT8A6wVgtQ6YOXkJHG8S9VKYgrN9MCeT0e8mbWMNfkkJ0ips4K87ZNzC6Lb5dbT1%2BRMw%2BpmCP7M8%2FwiBMdJZ%2FdINblg%2FapHtaqv6TUBRukB%2FEJWgGFB86h5fJ8VNZKssWtx35gLo6IHai6GTQpyS%2FNeq5ZbX%2BJwcnCKOzudHsdAyxk%2BQYltupFNBXBzxxW%2Fiixtew7uNtRJQfy2epcx0SOqRGKQfJrRReFWvldJWSKz%2Bv0aRMdZWCVRHovcwPLdXNWSK%2Brs7G0LCnjji4RyqzU9DTy%2BijA1Xx3xVmOxXysCkvqXNg2P0LJ0O0qLJF9lfQb%2FrrPH3h3lB0a7737CTzQh5kuqK%2FNabfV8qLNyV6cJ5oQWMfXw4LRxDIeK9Me8Fnb2K44uC39Q%3D');
var iv = decodeURIComponent('MkQ4NUFGNkVBNjIwMEY5OQ%3D%3D');


var encrypted = CryptoJS.enc.Base64.parse(encrypted);
var ive = CryptoJS.enc.Base64.parse(iv);

var secretOne = ""CLICKBANKINFS"";
var secretTwo = CryptoJS.SHA1(secretOne);
var secretThree = secretTwo.toString().substring(0,32);

var decrypted = CryptoJS.AES.decrypt(encrypted, secretThree, 
    { 
        iv: ive,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }
);

console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>The encrypted text and iv are both Base64 encoded. I'm not sure how this is to be handled exactly. I've seen several implementations of CryptoJS decryption and have tried several combinations but nothing worked for me.</p>

<p>Some help, please? :)</p>
","<p>Change this:</p>

<pre><code>var secretThree = secretTwo.toString().substring(0, 32));

var decrypted = CryptoJS.AES.decrypt(encrypted, secretThree, 
</code></pre>

<p>To:</p>

<pre><code>var secretThree = CryptoJS.enc.Utf8.parse(secretTwo.toString().substring(0, 32)));

var decrypted = CryptoJS.AES.decrypt({ciphertext: encrypted}, secretThree, 
</code></pre>

<ol>
<li><p>The first parameter has to be an object <em>or</em> a base64-encoded JavaScript string. Passing just <code>encrypted</code> makes the <code>decrypt</code> call silently fail. You can either do what I have above or remove the following line from your to leave the ciphertext as a base64-encoded JavaScript string:</p>

<pre><code>var encrypted = CryptoJS.enc.Base64.parse(encrypted);
</code></pre></li>
<li><p>JavaScript in general has very strange support for byte arrays, so the CryptoJS wrappers are required for everything to work properly. Even <code>secretThree</code>, which is entirely ASCII <code>[0-9a-f]</code>.</p></li>
</ol>
","4109","<cryptojs>","0","1","1","2017-11-06 05:51:01","47129520","8","","1170686","","2017-11-06 02:52:04","2017-11-06 02:18:58",""
"26486152","CryptoJS encrypts AES with passphrase but PHP decrypt needs a key","<p>I am using <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">CryptoJS</a> to encrypt a string:</p>

<pre><code>  function doHash(msg){
    msg = String(msg);
    var passphrase = 'aggourakia';
    var hash = CryptoJS.AES.encrypt(msg, passphrase);
    var ciphertext=  hash.ciphertext.toString(); //return ciphertext instead of object
    return ciphertext;      
}
</code></pre>

<p>As I understand it, <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">CryptoJS</a> <em>uses the passphrase to generate a key</em>, which is then used to encrypt the data.</p>

<blockquote>
  <p>However I'd like to decrypt the cipher using a PHP function, or maybe
  an online tool such as this: <a href=""http://aesencryption.net/"" rel=""nofollow"">http://aesencryption.net/</a></p>
</blockquote>

<p>The issue is that these expect a <strong>key</strong>, <strong>not a passphrase.</strong></p>

<p>How can I supply directly a <strong>key</strong> to the CryptoJS AES, which I can use on the server-side or any online tool to decrypt?</p>

<p>The thing is, I already have a really hard time finding PHP functions to decrypt AES ciphers already, and this passphrase/key thing is adding to the complexity</p>
","<p>If you want to supply the <strong>key</strong> directly you should supply <strong>IV</strong> too. The IV (initialization vector) is needed so it can be XOR'ed with the 1st block of the message. Then the ciphertext of the first block is XOR'ed  with the 2nd block of the message and so on. This is called <a href=""http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">cipher-block chaining (CBC)</a>.</p>

<pre><code>var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>

<p>This is from CryptoJS docs <a href=""https://code.google.com/p/crypto-js/#Custom_Key_and_IV"" rel=""nofollow"">https://code.google.com/p/crypto-js/#Custom_Key_and_IV</a></p>

<p>You can generate keys and IVs with <strong>PBKDF2</strong> like @Narf wrote. <a href=""https://code.google.com/p/crypto-js/#PBKDF2"" rel=""nofollow"">https://code.google.com/p/crypto-js/#PBKDF2</a></p>

<p>About PHP: <a href=""http://php.net/manual/en/book.mcrypt.php"" rel=""nofollow"">mcrypt</a> has MCRYPT_RIJNDAEL_128 cipher which is AES 128. MCRYPT_RIJNDAEL_192 and MCRYPT_RIJNDAEL_256 are not compatible with AES 192 and AES 256 because AES uses 128 bit block with all key sizes. Rijndael's has a configurable block size. CryptoJS will use 128bit AES if you supply a 128 bit key it will use 256 bit if you use the function that accepts a passphrase.</p>
","4030","<javascript><php><encryption><cryptojs>","5","4","1","2014-10-21 23:16:23","26488127","4","1","1814486","","2014-10-21 12:08:17","2014-10-21 11:58:39",""
"24353280","CryptoJS extra parameter in AES Encrypt. How to replicate with PHP?","<p>I am trying to replicate the following CryptoJS 3.1.2 code with PHP 5.4.4 : </p>

<pre><code>var plaintext = 'test';
var key = CryptoJS.enc.Utf8.parse('9rIY8vV8DdOKx3m6JocjEaObhhYc2NfY');
var iv = CryptoJS.enc.Utf8.parse('r0dkbnVQhklNeUGA');
var encrypted = CryptoJS.AES.encrypt(plaintext, 'euhe68vjdr1aX4F091c7aCggSMBf0A7M', key,{iv: iv,mode: CryptoJS.mode.CBC,padding: CryptoJS.pad.Pkcs7});
</code></pre>

<p>I have found several questions dealing with that problem, but none of them had that extra parameter in <code>encrypt()</code> between <code>plaintext</code> and <code>key</code>.</p>

<p>The CryptoJS wiki does not mention this parameter at all.
And yet, it works. I can decrypt with this : </p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, 'euhe68vjdr1aX4F091c7aCggSMBf0A7M', key, {iv: iv});
</code></pre>

<p>If I omit <code>'euhe68vjdr1aX4F091c7aCggSMBf0A7M'</code> in the <code>decrypt()</code> call, it won't work.
So that parameter really does something. But what? Is is a hash, a salt? </p>

<p>Does anybody know how I can replicate this specific encryption process with PHP?</p>

<p>I can not modify this JS code in any way.
The code is on a login page and is used to encrypt credentials before they are sent to the server.</p>

<p>I am trying to use PHP-cURL to submit credentials to that server from the command line, which is why I need to reproduce this encryption process.</p>

<p><strong>Update: thanks to Jim's answer, I now have the proper JavaScript, now I need help with replicating the code in PHP</strong></p>

<p>Here is the JS : </p>

<pre><code>var plaintext = 'test';
var key = 'euhe68vjdr1aX4F091c7aCggSMBf0A7M';
var iv = CryptoJS.enc.Utf8.parse('r0dkbnVQhklNeUGA');
var encrypted = CryptoJS.AES.encrypt(plaintext, key, key,{iv: iv,mode: CryptoJS.mode.CBC,padding: CryptoJS.pad.Pkcs7})
</code></pre>

<p><code>encrypted</code> equals <code>U2FsdGVkX1+ZujoXKqDHcO+4N1QO+Nv1KHUMFjZos1s=</code></p>

<p>Here is the decryption:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, key);
</code></pre>

<p><code>decrypted</code> equals <code>test</code></p>

<p>I have tried many different ways to replicate the encryption with PHP, but none of them gives a a string I can decode with the above JS.</p>

<p>For instance, using <a href=""http://www.coderelic.com/2011/10/aes-256-encryption-with-php/"" rel=""nofollow"">this AES_Encryption class</a>, I tried the following code : </p>

<pre><code>$key = 'euhe68vjdr1aX4F091c7aCggSMBf0A7M';
$iv =  'r0dkbnVQhklNeUGA';
$message = 'test';
$AES              = new AES_Encryption($key, $iv, PKCS7);
$encrypted        = $AES-&gt;encrypt($message);
$decrypted        = $AES-&gt;decrypt($encrypted);
$base64_encrypted = base64_encode('Salted__'.$encrypted);
</code></pre>

<p>I end up with <code>U2FsdGVkX18eEv+TnigBEKGJL8t/V1Hm</code> instead of <code>U2FsdGVkX1+ZujoXKqDHcO+4N1QO+Nv1KHUMFjZos1s=</code>
Note that both strings start the same way, thanks to the 'Salted__' prefix I added (since CryptoJS seems to do the same thing).</p>

<p>I tried similar code with phpseclib, openssl_encrypt and mcrypt. No luck.</p>

<p>Any hint would be appreciated.</p>

<p>**Update: FIXED **</p>

<p>This PHP code is a perfect match for the CryptoJS code above.</p>

<pre><code>function ssl_encrypt($pass, $data)
{
    // Set a random salt
    $salt = substr(md5(mt_rand(), true), 8);

    $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $pad = $block - (strlen($data) % $block);

    $data = $data . str_repeat(chr($pad), $pad);

    // Setup encryption parameters
    $td = mcrypt_module_open(MCRYPT_RIJNDAEL_128, """", MCRYPT_MODE_CBC, """");

    $key_len =  mcrypt_enc_get_key_size($td);
    $iv_len =  mcrypt_enc_get_iv_size($td);

    $total_len = $key_len + $iv_len;
    $salted = '';
    $dx = '';
    // Salt the key and iv
    while (strlen($salted) &lt; $total_len) {
        $dx = md5($dx.$pass.$salt, true);
        $salted .= $dx;
    }
    $key = substr($salted,0,$key_len);
    $iv = substr($salted,$key_len,$iv_len);

    mcrypt_generic_init($td, $key, $iv);
    $encrypted_data = mcrypt_generic($td, $data);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);

    //return chunk_split(base64_encode('Salted__' . $salt . $encrypted_data),32,""\r\n"");
    return base64_encode('Salted__' . $salt . $encrypted_data);
}

function ssl_decrypt($password, $edata)
{
    $data = base64_decode($edata);
    print ""Data: "" . $data . ""\n"";

    $salt = substr($data, 8, 8);
    print ""Salt (Base64): "" . base64_encode($salt) . ""\n"";

    $ct = substr($data, 16);
    print ""Content (Base64): "" . base64_encode($ct) . ""\n"";

    $rounds = 3;
    $data00 = $password.$salt;

    print ""Data00 (Base64): "" . base64_encode($data00) . ""\n"";

    $md5_hash = array();
    $md5_hash[0] = md5($data00, true);

    $result = $md5_hash[0];
    print ""MD5-Hash[0] (Base64): "" . base64_encode($result) . ""\n"";
    for ($i = 1; $i &lt; $rounds; $i++) {
        $md5_hash[$i] = md5($md5_hash[$i - 1].$data00, true);
        $result .= $md5_hash[$i];
        print ""Result (Base64): "" . base64_encode($result) . ""\n"";
    }

    $key = substr($result, 0, 32);
    print ""Key (Base64): "" . base64_encode($key) . ""\n"";
    $iv = substr($result, 32, 16);
    print ""IV (Base64): "" . base64_encode($iv) . ""\n"";

    print ""Decrypted: "" . openssl_decrypt($ct, 'aes-256-cbc', $key, true, $iv) . ""\n"";
}

$encryptedString = ssl_encrypt('euhe68vjdr1aX4F091c7aCggSMBf0A7M', 'test');
$decryptedString = ssl_decrypt('euhe68vjdr1aX4F091c7aCggSMBf0A7M', $encryptedString);
</code></pre>

<p>I can't remember where I found it. Sorry.</p>
","<p>This is a JavaScript thing, not a CryptoJS thing. Try this:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, 'euhe68vjdr1aX4F091c7aCggSMBf0A7M', {iv: iv});
</code></pre>

<p>or this:</p>

<pre><code>key = 'euhe68vjdr1aX4F091c7aCggSMBf0A7M';
var decrypted = CryptoJS.AES.decrypt(encrypted, key, {iv: iv});
</code></pre>

<p>You'll see that what you think is the key, isn't the key at all. It's being grouped with the optional parameters at the end, and lost.</p>

<p>'euhe68vjdr1aX4F091c7aCggSMBf0A7M' is your key, or is what your key is derived from.</p>
","3956","<javascript><php><encryption><aes><cryptojs>","2","4","1","2014-06-24 15:46:43","","3","2","1226424","","2014-06-24 15:46:43","2014-06-22 16:28:38","2014-06-23 05:09:49"
"27756579","CryptoJS AES CBC 256 decrypt adds additional byte in the middle of plaintext","<p>I am writing a Chrome extension which is using CryptoJS for some Apache Thrift work. I am currently trying to get CryptoJS working. I'm facing a problem with CryptoJS decryption of data encrypted by CryptoJS. I'm attaching a test case below, after the problem description.</p>

<p>What is happening is the following, I have an array of ""bytes"":</p>

<pre><code>var bArr = [11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65,65,65,65,69,109,78,111,99,109,57,116,90,83,49,48,90,88,78,48,76,87,78,115,97,87,86,117,100,65,103,65,65,103,65,65,49,68,69,75,65,65,77,65,65,65,65,65,86,75,102,66,85,103,115,65,66,65,65,65,65,67,81,49,90,68,99,119,77,71,73,120,78,67,48,121,78,84,90,107,76,84,81,119,77,109,81,116,79,84,65,48,90,105,48,52,79,84,86,105,78,68,73,50,89,109,78,108,78,84,99,76,65,65,85,65,65,65,65,85,89,50,104,121,98,50,49,108,76,87,78,115,97,87,86,117,100,67,49,122,90,87,78,121,90,88,81,65,11,0,3,0,0,0,36,52,51,52,55,54,56,98,53,45,50,48,102,102,45,52,99,100,102,45,56,53,97,50,45,57,49,49,56,50,98,55,98,51,102,57,53,0];
var stringToEncode = String.fromCharCode.apply(null, bArr);
</code></pre>

<p>I encrypt it with CryptoJS and then decrypt. First 25 bytes before encryption:</p>

<pre><code>11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65
</code></pre>

<p>After the decryption:</p>

<pre><code>11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,194,152,67,119,65,66
</code></pre>

<p>The only difference is an additional 194 at position 20. All other bytes are exactly the same, except of padding, obviously. I'm trying to understand where is this coming from.</p>

<p>More info regarding hat are these bytes. This is a Thrift structure with 3 fields, field 2 contains a Base64 representation of another, embedded Thrift struct. First 20 bytes of input exmplained:</p>

<ul>
<li>11,0,1: Thrift field of type string, fid 1</li>
<li>0,0,0,6: int32 length of the value of fid 1</li>
<li>100,67,119,65,66,65: string ""digest""</li>
<li>11,0,2: Thrift field of type string, fid 2</li>
<li>0,0,0,152: int32 length of the value of fid 2</li>
<li>67 ... until next byte 11: Base64 representation of the embedded struct</li>
</ul>

<p>Because of the decryption issue Thrift parser incorrectly recognises the length of fid 2 value.</p>

<p>I believe I am using AES256 CBC with a 32 byte key (SHA256) and 16 byte IV in OpenSSL mode with PKCS7 padding.</p>

<p>This is my qunit test.</p>

<pre><code>test(""Decryption"", function() {
  var bArr = [11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65,65,65,65,69,109,78,111,99,109,57,116,90,83,49,48,90,88,78,48,76,87,78,115,97,87,86,117,100,65,103,65,65,103,65,65,49,68,69,75,65,65,77,65,65,65,65,65,86,75,102,66,85,103,115,65,66,65,65,65,65,67,81,49,90,68,99,119,77,71,73,120,78,67,48,121,78,84,90,107,76,84,81,119,77,109,81,116,79,84,65,48,90,105,48,52,79,84,86,105,78,68,73,50,89,109,78,108,78,84,99,76,65,65,85,65,65,65,65,85,89,50,104,121,98,50,49,108,76,87,78,115,97,87,86,117,100,67,49,122,90,87,78,121,90,88,81,65,11,0,3,0,0,0,36,52,51,52,55,54,56,98,53,45,50,48,102,102,45,52,99,100,102,45,56,53,97,50,45,57,49,49,56,50,98,55,98,51,102,57,53,0];
  var stringToEncode = String.fromCharCode.apply(null, bArr);
  var symmetricKey = ""v3JElaRswYgxOt4b"";

  var key = CryptoJS.enc.Latin1.parse( CryptoJS.enc.Latin1.stringify( CryptoJS.SHA256( symmetricKey ) ) );
  var iv  = CryptoJS.lib.WordArray.random( 16 );

  var encrypted = CryptoJS.AES.encrypt( stringToEncode,
                                        key,
                                        { iv: iv, format: CryptoJS.format.OpenSSL }
                                      ).ciphertext.toString(CryptoJS.enc.Latin1);

  var decrypted = CryptoJS.AES.decrypt( { ciphertext: CryptoJS.enc.Latin1.parse(encrypted) },
                                          key,
                                          { iv: iv, padding: CryptoJS.pad.NoPadding }
                                      ).toString(CryptoJS.enc.Latin1);

  var buf = [];
  for (var i=0; i&lt;decrypted.length; i++) {
    buf.push( decrypted.charCodeAt(i) );
  }

  var bstr1 = """";
  for (var i=0; i&lt;bArr.length; i++) {
    bstr1 += (i&gt;0) ? "",""+bArr[i] : bArr[i]+"""";
  }
  var bstr2 = """";
  for (var i=0; i&lt;buf.length; i++) {
    bstr2 += (i&gt;0) ? "",""+buf[i] : buf[i]+"""";
  }

  console.log(""------------------------------------------"");
  console.log(bstr1);
  console.log(bstr2);
  console.log(""------------------------------------------"");

  equal( stringToEncode.slice(0,200), decrypted.slice(0,200) );
});
</code></pre>

<p>My test HTML wrapper loads these:</p>

<pre><code>&lt;script src=""../bower_components/jquery/dist/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/js-base64/base64.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/thrift/lib/js/src/thrift.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/underscore/underscore-min.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/qunit/qunit/qunit.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/core.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/cipher-core.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/format-hex.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/aes.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/pad-nopadding.js""&gt;&lt;/script&gt;
&lt;!-- the Test Suite--&gt;
&lt;script type=""text/javascript"" src=""test-client.js"" charset=""utf-8""&gt;&lt;/script&gt;
&lt;!-- CSS--&gt;
&lt;link rel=""stylesheet"" href=""../bower_components/qunit/qunit/qunit.css"" type=""text/css"" media=""screen"" /&gt;
</code></pre>

<p>And my bower.json is:</p>

<pre><code>{
  ""name"": ""gossiperl-client-chrome"",
  ""version"": ""0.1.0"",
  ""main"": ""manifest.json"",
  ""dependencies"": {
    ""jquery"": ""~1.11.0"",
    ""underscore"": ""~1.7.0"",
    ""thrift"": ""radekg/thrift#js-binary-protocol"",
    ""js-base64"": ""~2.1.5"",
    ""qunit"": ""~1.14.0"",
    ""browserify-cryptojs"": ""~0.3.1""
  },
  ""authors"": [
    ""radekg &lt;...@....com&gt;""
  ],
  ""description"": ""Gossiperl Chrome client with a sample application"",
  ""keywords"": [
    ""gossiperl"",
    ""client""
  ],
  ""license"": ""MIT"",
  ""homepage"": ""http://....com"",
  ""private"": true
}
</code></pre>
","<p>The issue is that CryptoJS treats the input as UTF-8 input string unless it is already a <code>WordArray</code>. This is of course a problem if your input isn't UTF-8. What you are seeing is that the value above 0x80 (128) is converted into two bytes to fix the UTF-8 encoding.</p>

<p>You could use a direct conversion to hex and then to <code>WordArray</code> as long as <code>WordArray</code> does not support direct conversion from arrays to <code>WordArray</code>. It's a bit strange that this feature is missing.</p>

<p>The following converts an array with unsigned byte values to hexadecimals (with a bit of a guard with regard to invalid byte values):</p>

<pre><code>function tohex(unsignedByteArray) {
    var hex = """";
    for (var i = 0; i &lt; unsignedByteArray.length; i++) {
        var c = unsignedByteArray[i];
        if (c &lt; 0 || c &gt; 255) {
            throw ""Value not an unsigned byte in array"";
        }
        var h = c.toString(16);
        if (h.length == 1) {
            hex += ""0"" + h;
        } else {
            hex += h;
        }
    }
    return hex;
}

function fromhex(hex) {
    if (hex.length % 2 !== 0) {
        throw ""Hex string should contain even number of hex digits, one per byte"";
    }
    var unsignedByteArray = [];
    for (var i = 0; i &lt; hex.length; i = i + 2) {
        var h = hex.substring(i, i + 2);
        if (!/^[0-9a-f]{2}$/i.test(h)) {
            throw ""Invalid hexdigit at offset "" + i;
        }
        var c = parseInt(h, 16);
        unsignedByteArray[unsignedByteArray.length] = c;
    }
    return unsignedByteArray;
}
</code></pre>

<p>So you would be able to use these functions like this:</p>

<pre><code>var bArr = [11, 0, 1, 0, 0, 0, 6, 100, 105, 103, 101, 115, 116, 11, 0, 2, 0, 0, 0, 152, 67, 119, 65, 66, 65, 65, 65, 65, 69, 109, 78, 111, 99, 109, 57, 116, 90, 83, 49, 48, 90, 88, 78, 48, 76, 87, 78, 115, 97, 87, 86, 117, 100, 65, 103, 65, 65, 103, 65, 65, 49, 68, 69, 75, 65, 65, 77, 65, 65, 65, 65, 65, 86, 75, 102, 66, 85, 103, 115, 65, 66, 65, 65, 65, 65, 67, 81, 49, 90, 68, 99, 119, 77, 71, 73, 120, 78, 67, 48, 121, 78, 84, 90, 107, 76, 84, 81, 119, 77, 109, 81, 116, 79, 84, 65, 48, 90, 105, 48, 52, 79, 84, 86, 105, 78, 68, 73, 50, 89, 109, 78, 108, 78, 84, 99, 76, 65, 65, 85, 65, 65, 65, 65, 85, 89, 50, 104, 121, 98, 50, 49, 108, 76, 87, 78, 115, 97, 87, 86, 117, 100, 67, 49, 122, 90, 87, 78, 121, 90, 88, 81, 65, 11, 0, 3, 0, 0, 0, 36, 52, 51, 52, 55, 54, 56, 98, 53, 45, 50, 48, 102, 102, 45, 52, 99, 100, 102, 45, 56, 53, 97, 50, 45, 57, 49, 49, 56, 50, 98, 55, 98, 51, 102, 57, 53, 0];
var bArrHex = tohex(bArr);

var stringToEncode = CryptoJS.enc.Hex.parse(bArrHex);

var symmetricKey = ""v3JElaRswYgxOt4b"";

var key = CryptoJS.enc.Latin1.parse(CryptoJS.enc.Latin1.stringify(CryptoJS.SHA256(symmetricKey)));

var iv = CryptoJS.lib.WordArray.random(16);

var encrypted = CryptoJS.AES.encrypt(stringToEncode, key, { iv: iv, format: CryptoJS.format.OpenSSL });

var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, format: CryptoJS.format.OpenSSL });

var result = fromhex(decrypted.toString(CryptoJS.enc.Hex));

console.log(result);

if (bArr.toString() == result.toString()) {
    console.log(""success"");
}
</code></pre>

<p>Note that the <code>encrypted</code> automatically encodes to base64 when used as a string. You cannot use Latin1 encoding for ciphertext. Note that your key should also contain random bytes, not only printable characters as it does now.</p>

<p>Finally note that sending AES encrypted text without MAC is inherently unsafe, for instance because of padding oracle attacks and the fact that anybody can change the data in transit.</p>
","3938","<javascript><encryption><aes><cryptojs>","2","0","2","2015-01-04 16:29:24","27757570","5","0","","","","2015-01-03 15:48:31",""
"27756579","CryptoJS AES CBC 256 decrypt adds additional byte in the middle of plaintext","<p>I am writing a Chrome extension which is using CryptoJS for some Apache Thrift work. I am currently trying to get CryptoJS working. I'm facing a problem with CryptoJS decryption of data encrypted by CryptoJS. I'm attaching a test case below, after the problem description.</p>

<p>What is happening is the following, I have an array of ""bytes"":</p>

<pre><code>var bArr = [11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65,65,65,65,69,109,78,111,99,109,57,116,90,83,49,48,90,88,78,48,76,87,78,115,97,87,86,117,100,65,103,65,65,103,65,65,49,68,69,75,65,65,77,65,65,65,65,65,86,75,102,66,85,103,115,65,66,65,65,65,65,67,81,49,90,68,99,119,77,71,73,120,78,67,48,121,78,84,90,107,76,84,81,119,77,109,81,116,79,84,65,48,90,105,48,52,79,84,86,105,78,68,73,50,89,109,78,108,78,84,99,76,65,65,85,65,65,65,65,85,89,50,104,121,98,50,49,108,76,87,78,115,97,87,86,117,100,67,49,122,90,87,78,121,90,88,81,65,11,0,3,0,0,0,36,52,51,52,55,54,56,98,53,45,50,48,102,102,45,52,99,100,102,45,56,53,97,50,45,57,49,49,56,50,98,55,98,51,102,57,53,0];
var stringToEncode = String.fromCharCode.apply(null, bArr);
</code></pre>

<p>I encrypt it with CryptoJS and then decrypt. First 25 bytes before encryption:</p>

<pre><code>11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65
</code></pre>

<p>After the decryption:</p>

<pre><code>11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,194,152,67,119,65,66
</code></pre>

<p>The only difference is an additional 194 at position 20. All other bytes are exactly the same, except of padding, obviously. I'm trying to understand where is this coming from.</p>

<p>More info regarding hat are these bytes. This is a Thrift structure with 3 fields, field 2 contains a Base64 representation of another, embedded Thrift struct. First 20 bytes of input exmplained:</p>

<ul>
<li>11,0,1: Thrift field of type string, fid 1</li>
<li>0,0,0,6: int32 length of the value of fid 1</li>
<li>100,67,119,65,66,65: string ""digest""</li>
<li>11,0,2: Thrift field of type string, fid 2</li>
<li>0,0,0,152: int32 length of the value of fid 2</li>
<li>67 ... until next byte 11: Base64 representation of the embedded struct</li>
</ul>

<p>Because of the decryption issue Thrift parser incorrectly recognises the length of fid 2 value.</p>

<p>I believe I am using AES256 CBC with a 32 byte key (SHA256) and 16 byte IV in OpenSSL mode with PKCS7 padding.</p>

<p>This is my qunit test.</p>

<pre><code>test(""Decryption"", function() {
  var bArr = [11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65,65,65,65,69,109,78,111,99,109,57,116,90,83,49,48,90,88,78,48,76,87,78,115,97,87,86,117,100,65,103,65,65,103,65,65,49,68,69,75,65,65,77,65,65,65,65,65,86,75,102,66,85,103,115,65,66,65,65,65,65,67,81,49,90,68,99,119,77,71,73,120,78,67,48,121,78,84,90,107,76,84,81,119,77,109,81,116,79,84,65,48,90,105,48,52,79,84,86,105,78,68,73,50,89,109,78,108,78,84,99,76,65,65,85,65,65,65,65,85,89,50,104,121,98,50,49,108,76,87,78,115,97,87,86,117,100,67,49,122,90,87,78,121,90,88,81,65,11,0,3,0,0,0,36,52,51,52,55,54,56,98,53,45,50,48,102,102,45,52,99,100,102,45,56,53,97,50,45,57,49,49,56,50,98,55,98,51,102,57,53,0];
  var stringToEncode = String.fromCharCode.apply(null, bArr);
  var symmetricKey = ""v3JElaRswYgxOt4b"";

  var key = CryptoJS.enc.Latin1.parse( CryptoJS.enc.Latin1.stringify( CryptoJS.SHA256( symmetricKey ) ) );
  var iv  = CryptoJS.lib.WordArray.random( 16 );

  var encrypted = CryptoJS.AES.encrypt( stringToEncode,
                                        key,
                                        { iv: iv, format: CryptoJS.format.OpenSSL }
                                      ).ciphertext.toString(CryptoJS.enc.Latin1);

  var decrypted = CryptoJS.AES.decrypt( { ciphertext: CryptoJS.enc.Latin1.parse(encrypted) },
                                          key,
                                          { iv: iv, padding: CryptoJS.pad.NoPadding }
                                      ).toString(CryptoJS.enc.Latin1);

  var buf = [];
  for (var i=0; i&lt;decrypted.length; i++) {
    buf.push( decrypted.charCodeAt(i) );
  }

  var bstr1 = """";
  for (var i=0; i&lt;bArr.length; i++) {
    bstr1 += (i&gt;0) ? "",""+bArr[i] : bArr[i]+"""";
  }
  var bstr2 = """";
  for (var i=0; i&lt;buf.length; i++) {
    bstr2 += (i&gt;0) ? "",""+buf[i] : buf[i]+"""";
  }

  console.log(""------------------------------------------"");
  console.log(bstr1);
  console.log(bstr2);
  console.log(""------------------------------------------"");

  equal( stringToEncode.slice(0,200), decrypted.slice(0,200) );
});
</code></pre>

<p>My test HTML wrapper loads these:</p>

<pre><code>&lt;script src=""../bower_components/jquery/dist/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/js-base64/base64.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/thrift/lib/js/src/thrift.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/underscore/underscore-min.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/qunit/qunit/qunit.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/core.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/cipher-core.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/format-hex.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/aes.js""&gt;&lt;/script&gt;
&lt;script src=""../bower_components/browserify-cryptojs/components/pad-nopadding.js""&gt;&lt;/script&gt;
&lt;!-- the Test Suite--&gt;
&lt;script type=""text/javascript"" src=""test-client.js"" charset=""utf-8""&gt;&lt;/script&gt;
&lt;!-- CSS--&gt;
&lt;link rel=""stylesheet"" href=""../bower_components/qunit/qunit/qunit.css"" type=""text/css"" media=""screen"" /&gt;
</code></pre>

<p>And my bower.json is:</p>

<pre><code>{
  ""name"": ""gossiperl-client-chrome"",
  ""version"": ""0.1.0"",
  ""main"": ""manifest.json"",
  ""dependencies"": {
    ""jquery"": ""~1.11.0"",
    ""underscore"": ""~1.7.0"",
    ""thrift"": ""radekg/thrift#js-binary-protocol"",
    ""js-base64"": ""~2.1.5"",
    ""qunit"": ""~1.14.0"",
    ""browserify-cryptojs"": ""~0.3.1""
  },
  ""authors"": [
    ""radekg &lt;...@....com&gt;""
  ],
  ""description"": ""Gossiperl Chrome client with a sample application"",
  ""keywords"": [
    ""gossiperl"",
    ""client""
  ],
  ""license"": ""MIT"",
  ""homepage"": ""http://....com"",
  ""private"": true
}
</code></pre>
","<p>Just as an additional reference. The accepted answer contains a key to the problem.</p>

<p>The issue is that CryptoJS treats the input as UTF-8 input string unless it is already a <code>WordArray</code>.</p>

<p>Indeed, I have changed my test to the following:</p>

<pre><code>test(""Decryption"", function() {
  var bArr = [11,0,1,0,0,0,6,100,105,103,101,115,116,11,0,2,0,0,0,152,67,119,65,66,65,65,65,65,69,109,78,111,99,109,57,116,90,83,49,48,90,88,78,48,76,87,78,115,97,87,86,117,100,65,103,65,65,103,65,65,49,68,69,75,65,65,77,65,65,65,65,65,86,75,102,66,85,103,115,65,66,65,65,65,65,67,81,49,90,68,99,119,77,71,73,120,78,67,48,121,78,84,90,107,76,84,81,119,77,109,81,116,79,84,65,48,90,105,48,52,79,84,86,105,78,68,73,50,89,109,78,108,78,84,99,76,65,65,85,65,65,65,65,85,89,50,104,121,98,50,49,108,76,87,78,115,97,87,86,117,100,67,49,122,90,87,78,121,90,88,81,65,11,0,3,0,0,0,36,52,51,52,55,54,56,98,53,45,50,48,102,102,45,52,99,100,102,45,56,53,97,50,45,57,49,49,56,50,98,55,98,51,102,57,53,0];
  var dataToEncrypt = toCryptoJSWordArray( bArr );

  var symmetricKey = ""v3JElaRswYgxOt4b"";

  var key = CryptoJS.enc.Latin1.parse( CryptoJS.enc.Latin1.stringify( CryptoJS.SHA256( symmetricKey ) ) );
  var iv  = CryptoJS.lib.WordArray.random( 16 );

  var encrypted = CryptoJS.AES.encrypt( dataToEncrypt,
                                        key,
                                        { iv: iv, format: CryptoJS.format.OpenSSL }
                                      ).ciphertext.toString(CryptoJS.enc.Latin1);

  var decrypted = toByteArray( CryptoJS.AES.decrypt( { ciphertext: CryptoJS.enc.Latin1.parse(encrypted) },
                                          key,
                                          { iv: iv, padding: CryptoJS.pad.NoPadding }
                                      ).toString(CryptoJS.enc.Latin1) );

  var bstr1 = """";
  for (var i=0; i&lt;bArr.length; i++) {
    bstr1 += (i&gt;0) ? "",""+bArr[i] : bArr[i]+"""";
  }
  var bstr2 = """";
  for (var i=0; i&lt;decrypted.length; i++) {
    bstr2 += (i&gt;0) ? "",""+decrypted[i] : decrypted[i]+"""";
  }

  console.log(""------------------------------------------"");
  console.log(bstr1);
  console.log(bstr2);
  console.log(""------------------------------------------"");

  deepEqual( bArr.slice(0,200), decrypted.slice(0,200) );
});

function toCryptoJSWordArray(bArr) {
  var latin1StrLength = bArr.length;
  // Convert
  var words = [];
  for (var i = 0; i &lt; bArr.length; i++) {
    words[i &gt;&gt;&gt; 2] |= (bArr[i] &amp; 0xff) &lt;&lt; (24 - (i % 4) * 8);
  }
  return new CryptoJS.lib.WordArray.init(words, bArr.length);
}

function toByteArray(str) {
  var bArr = [];
  for (var i=0; i&lt;str.length; i++) {
    bArr.push( str.charCodeAt(i) );
  }
  return bArr;
}
</code></pre>

<p>This creates a WordArray from my bytearray and then encrypts and decrypts. The decrypted data comes back correctly.</p>
","3938","<javascript><encryption><aes><cryptojs>","2","1","2","2015-01-04 16:29:24","27757570","5","0","","","","2015-01-03 15:48:31",""
"46889186","JS libraries required for CryptoJS Encryption","<p>I am trying to use CryptoJS for encryption using the code snippets from an upvoted answer of <a href=""https://stackoverflow.com/questions/41432896/cryptojs-aes-encryption-and-java-aes-decryption"">CryptoJS AES encryption and Java AES decryption</a>.</p>

<pre><code>var text = ""The quick brown fox jumps over the lazy dog.  "";
var secret = ""Ren ber"";
var encrypted = CryptoJS.AES.encrypt(text, secret);
encrypted = encrypted.toString();
console.log(""Cipher text: "" + encrypted);
</code></pre>

<p>But it does not mention how to include the JS files required for this. I tried using the below links to include them.</p>

<pre><code>'aes':'http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes',
'enc-base64-min':'http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min'
</code></pre>

<p>But it gives an error ""Refused to execute script from  because its MIME type ('text/html') is not executable, and strict MIME type checking is enabled.""</p>

<p>Can some one tell me how do I get the scripts executed, any other URL to be included or is it possible to manually include these js files.</p>

<p>Here is how my main.js looks like </p>

<pre><code>requirejs.config({
    // Path mappings for the logical module names
    paths: {
        'knockout': '../../js/libs/knockout/knockout-3.4.0',
        'jquery': '../../js/libs/jquery/jquery-1.9.1',
        'jqueryui': '../../js/libs/jquery/jquery-ui-1.10.4.custom',
        'ojs': '../../js/libs/oj/v3.2.0/min',
        'ojL10n': '../../js/libs/oj/v3.2.0/ojL10n',
        'ojtranslations': '../../js/libs/oj/v3.2.0/resources',
        'text': '../../js/libs/require/text',
        'jqueryui-amd': '../../js/libs/jquery/jqueryui-amd-1.12.0',
        'promise': '../../js/libs/es6-promise/es6-promise',
        'hammerjs': '../../js/libs/hammer/hammer-2.0.8',
        'ojdnd': '../../js/libs/dnd-polyfill/dnd-polyfill-1.0.0',
        'signals': '../../js/libs/js-signals/signals',
        'customElements': '../../js/libs/webcomponents/CustomElements',
        'proj4': '../../js/libs/proj4js/dist/proj4-src',
        'css': '../../js/libs/require-css/css',
        'crypto-js': 'crypto-js/crypto-js-develop'
    },// Shim configurations for modules that do not expose AMD
    shim: {
        'jquery': {
            exports: ['jQuery', '$']
        },
        'jqueryui': {
            deps: ['jquery']
        }
    },
    config: {
        ojL10n: {
            merge: {  
            }
        }
    },
    catchError: true
});

require([ 'ojs/ojcore', 'knockout', 'jquery', 'commonController', 'ojs/ojknockout','ojs/ojmodule','ojs/ojcomponents',
        'ojs/ojaccordion', 'ojs/ojcollapsible', 'ojs/ojselectcombobox', 'ojs/ojtoolbar',
        'ojs/ojprogressbar', 'ojs/ojinputnumber', 'ojs/ojrouter', 'ojs/ojtable', 'ojs/ojarraytabledatasource','promise','ojs/ojinputtext','crypto-js'], 
         function(oj, ko, $, commonController) {


    $(function() {

        function init() {
            oj.Router.sync().then(function() {

                ko.applyBindings(commonController, document.getElementById('globalBody'));
            }, function(error) {
                oj.Logger.error('Error in root start: ' + error.message);
                alert(error);
            });
        }

        init();
    });
});

requirejs.onError = function (err){
    //alert(err);
};
</code></pre>
","<p>The AES and base64 are parts of CryptoJS already. No need to include more scripts.</p>

<p>From the <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">project's github page</a>:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

// Encrypt
var ciphertext = CryptoJS.AES.encrypt('my message', 'secret key 123');

// Decrypt
var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), 'secret key 123');
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>To use with requireJS:</p>

<pre><code>require.config({
    packages: [
        {
            name: 'crypto-js',
            location: 'path-to/bower_components/crypto-js',
            main: 'index'
        }
    ]
});
</code></pre>

<p>You'll need to change the location to the path of the crypto-js distribution. Also, you should change your use of cryptoJS like so</p>

<pre><code>require([""crypto-js""], function (CryptoJS) {
    // Encrypt
    var ciphertext = CryptoJS.AES.encrypt('my message', 'secret key 123');

    // Decrypt
    var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), 'secret key 123');
    var plaintext = bytes.toString(CryptoJS.enc.Utf8);

    console.log(plaintext);

});
</code></pre>
","3790","<javascript><encryption><aes><cryptojs>","1","3","1","2017-10-23 14:02:16","46889336","2","","1502017","","2017-10-23 13:59:59","2017-10-23 12:18:22",""
"41156123","_crypto is not defined","<p>I've been digging on this for about an hour, but can't figure out what's causing the issue. I'm using webpack, browser-sync, and react with react-redux. Here's the error from the console:</p>

<pre><code>Uncaught ReferenceError: _crypto is not defined
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:5:11)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:20:3)
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:21:30)
    at Object.&lt;anonymous&gt; (bundle.js:881)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:3:11)
    at eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:46:30)
    at Object.&lt;anonymous&gt; (bundle.js:875)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:833), &lt;anonymous&gt;:4:14)
</code></pre>
","<p>I just encountered this too. The solution for me was to upgrade the crypto-browserify dependency: </p>

<pre><code>npm install crypto-browserify@3.11.0
</code></pre>

<p><strong>EDIT 1</strong>: For reasons I don't quite grasp, this only fixed the problem temporarily. As soon as I restarted webpack, it stopped working again.</p>

<p><strong>EDIT 2</strong>: This happens only in one of my projects, which is rather complex, so it's hard to pin down exactly what the differences are between the two, but as a temporary fix, you can just declare the variable:</p>

<pre><code>window._crypto = null;
</code></pre>

<p>It's not pretty, but hopefully this will be temporary.</p>
","3702","<webpack><browser-sync><cryptojs>","0","1","3","2016-12-28 08:55:01","41183485","0","","","","","2016-12-15 03:48:57",""
"41156123","_crypto is not defined","<p>I've been digging on this for about an hour, but can't figure out what's causing the issue. I'm using webpack, browser-sync, and react with react-redux. Here's the error from the console:</p>

<pre><code>Uncaught ReferenceError: _crypto is not defined
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:5:11)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:20:3)
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:21:30)
    at Object.&lt;anonymous&gt; (bundle.js:881)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:3:11)
    at eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:46:30)
    at Object.&lt;anonymous&gt; (bundle.js:875)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:833), &lt;anonymous&gt;:4:14)
</code></pre>
","<p>that is a super out of date version of crypto browserify, rng.js has been gone since at least 3.9.8 which was released almost a year ago, something is requiring an out of date version.</p>
","3702","<webpack><browser-sync><cryptojs>","0","0","3","2016-12-28 08:55:01","41183485","0","","","","","2016-12-15 03:48:57",""
"41156123","_crypto is not defined","<p>I've been digging on this for about an hour, but can't figure out what's causing the issue. I'm using webpack, browser-sync, and react with react-redux. Here's the error from the console:</p>

<pre><code>Uncaught ReferenceError: _crypto is not defined
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:5:11)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:20:3)
    at eval (eval at &lt;anonymous&gt; (bundle.js:881), &lt;anonymous&gt;:21:30)
    at Object.&lt;anonymous&gt; (bundle.js:881)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:3:11)
    at eval (eval at &lt;anonymous&gt; (bundle.js:875), &lt;anonymous&gt;:46:30)
    at Object.&lt;anonymous&gt; (bundle.js:875)
    at __webpack_require__ (bundle.js:20)
    at Object.eval (eval at &lt;anonymous&gt; (bundle.js:833), &lt;anonymous&gt;:4:14)
</code></pre>
","<p>I've had the same problem, and found the reason.</p>

<p>As you use webpack 1.x, the <code>node-libs-browser@7.0</code> with <code>crypto-browserify@3.3.0</code> (maybe earlier) will be installed at the same time.</p>

<p>So, if you just <code>require('crypto')</code> directly, webpack will use the <code>@3.3.0</code>, which has the <code>rng.js</code>, and not the newest version you installed by yourself.</p>

<p><img src=""https://cloud.githubusercontent.com/assets/7287198/21517670/f788b102-cd1b-11e6-8b97-03a6f3fb44ce.png"" alt=""image""></p>

<p>The solution I tried is just <code>npm install node-libs-browser --save</code>, and npm will update it in webpack, and @3.11.0 will be found. </p>
","3702","<webpack><browser-sync><cryptojs>","0","0","3","2016-12-28 08:55:01","41183485","0","","","","","2016-12-15 03:48:57",""
"39607485","SHA256 in React Native","<p>I need to calculate SHA256 hash value of many files in Android and iOS using React Native.  When files are selected by a user, my app will start calculating SHA256 for each file.</p>

<p>For web pages, I have been using crypto-js.  But for Andoid and iOS applications, I am concerned that performance of crypto-js may not be fast enough as a file (eg. video file) may be >400 MB.  </p>

<p>Is there any way that I can call Android/iOS native api to calculate SHA256, instead of using crypto-js for performance sake?</p>
","<p>There isn't anything built into react-native itself to natively calculate a sha-256, but there are a few options.</p>

<p>As @Morre pointed out, <a href=""https://github.com/itinance/react-native-sha256"" rel=""nofollow noreferrer"">react-native-sha256</a> is an open source project that supports calculating the sha-256 of a string using native components.</p>

<p>Another open source react-native project - <a href=""https://github.com/itinance/react-native-fs"" rel=""nofollow noreferrer"">react-native-fs</a> - has support for calculating the sha-256 of a file using native components, specifically the <a href=""https://github.com/itinance/react-native-fs#hashfilepath-string-algorithm-string-promisestring"" rel=""nofollow noreferrer"">hash</a> function.</p>

<p>As @Morre has pointed out, you could write your own native code to provide the same functionality if you would prefer that option. Both of the libraries I mentioned here are open source, so the source code there can be a good reference for what the specific Android/iOS code would need to be written. There are also code examples here on StackOverflow for both <a href=""https://stackoverflow.com/q/3103652/567493"">java</a> and <a href=""https://stackoverflow.com/q/35749197/567493"">swift</a>. React-Native's <a href=""https://facebook.github.io/react-native/docs/native-modules-android.html"" rel=""nofollow noreferrer"">native module documentation (Android)</a> and <a href=""https://facebook.github.io/react-native/docs/native-modules-ios.html"" rel=""nofollow noreferrer"">iOS</a> is extensive.</p>
","3694","<react-native><sha><cryptojs>","2","2","1","2017-12-14 21:29:01","47822332","4","1","","","","2016-09-21 04:18:59",""
"40606146","CryptoJS how to generate a key every time?","<p>Let assume that I have an Phonegap mobile app, and I want to store some user data(username/pass_hash) in local indexed db for providing login to app in offline.
I want to encrypt that data of course, and my app already use CryptoJS.
As I understood, first I need to generate encryption_key by password using PBKDF2, and then just encrypt CryptoJS.AES.
Example code:</p>

<pre><code>function generateKey(p){
var salt = CryptoJS.lib.WordArray.random(128/8);
return CryptoJS.PBKDF2(p, salt, { keySize: 512/32, iterations: 1000 });     
}

var pass = ""test1""; 
var iv  = CryptoJS.lib.WordArray.random(16);
key512Bits1000Iterations = generateKey(pass);
var encrypted = CryptoJS.AES.encrypt(""Message"", key512Bits1000Iterations, { iv: iv });
var decrypted = CryptoJS.AES.decrypt(encrypted, key512Bits1000Iterations, { iv: iv });

//decrypting with another key step
key512Bits1000Iterations2 = generateKey(pass);
var decrypted2 = CryptoJS.AES.decrypt(encrypted, key512Bits1000Iterations2, { iv: iv });
console.log(""decrypted "" + decrypted.toString(CryptoJS.enc.Utf8));
console.log(""decrypted2 "" + decrypted2.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Dynamic salt and iv are used.
But when I second time generate key for decryption by same password I'm getting wrong result.(decrypted2 is empty)
<strong>So I want to ask, what I should store between encryption sessions, 
salt and iv to ?(but as I understood it should be dynamic )</strong>
Thanks!</p>
","<p>You are generating a new salt in <code>generateKey(...)</code>. This makes <strong>PBKDF2</strong> derived a new key.</p>

<pre><code>function generateKey(p){
    var salt = CryptoJS.lib.WordArray.random(128/8);
    return CryptoJS.PBKDF2(p, salt, { keySize: 512/32, iterations: 1000 });     
}
</code></pre>

<p>You would need to store the <strong>salt</strong> and <strong>iv</strong> between sessions. These two values don't need to be secret.</p>
","3592","<javascript><cordova><encryption><cryptojs>","0","0","1","2016-11-15 10:44:06","","2","","","","","2016-11-15 09:22:34",""
"32654749","Decrypt openssl AES with CryptoJS","<p>I'm trying to decrypt a file encrypted with openssl using <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow"">CryptoJS 3.1.5</a>.</p>

<p>Everything works fine if I encrypt and decrypt using CryptoJS, same goes for OpenSSL in shell, but when I try to mix CryptoJS with OpenSSL everything goes wrong.</p>

<p>The file is created using this command:</p>

<pre><code>openssl enc -aes-256-cbc -in file.txt -out file.enc -k password
</code></pre>

<p>and I try to decrypt like this:</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.enc', function(err, data) {
  var decrypted = CryptoJS.AES.decrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC }
                  );

  console.log(decrypted.toString(CryptoJS.enc.Utf8));
});

// Give me this err: Uncaught Error: Malformed UTF-8 data
</code></pre>

<p>And in the other way, I do :</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.txt', function(err, data) {
  var encrypted = CryptoJS.AES.encrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC });

  fs.writeFile('file.enc', encrypted);
});
</code></pre>

<p>And then in Shell:</p>

<pre><code>openssl enc -d -aes-256-cbc -in file.enc -out file2.txt -k password
// Give me this err: bad magic number
</code></pre>

<p>Am I missing something obvious ?</p>
","<p>Not definitely an answer yet but too much for comments:</p>

<p>Commandline <code>openssl enc</code> by default uses password-based encryption (PBE) with salt, which means the actual encryption key, and IV when applicable which it is for CBC, are computed from the given password and a random salt value by a <a href=""https://en.wikipedia.org/wiki/Key_derivation_function"" rel=""nofollow noreferrer"">Password Based Key Derivation Function</a> that makes it more difficult for an adversary to try password-guessing attacks. I don't know your JS module (or much JS at all) but the webpage you link lists a variety of low-level primitives suggesting it does not automatically do PBE. A text string like ""password"" is (possibly) suitable for PBE, but not direct AES encryption where the key must be exactly 128, 192 or 256 bits and should be random binary data. </p>

<p>If you want openssl's semi-standard <strong>PBE</strong>, match it on the JS side; the item <code>evpkey</code> sounds possibly helpful, since <code>EVP</code> is the openssl module involved and I know no other (PB)KDF scheme that would be called EVP. If not, the <code>enc</code> default PBE is just MD5 of the password concatenated with the salt, iterated with feedback as many times as needed which in this case is three. See <a href=""https://superuser.com/questions/455463/openssl-hash-function-for-generating-aes-key"">https://superuser.com/questions/455463/openssl-hash-function-for-generating-aes-key</a> for an example in (mostly) perl. OpenSSL prefixes the 8 ASCII chars ""Salted__"" and the 8 bytes of salt to the file, so you need to remove those (and use the salt) before decrypt, or add them after encrypt.</p>

<p>If you want <strong>raw encryption</strong>, choose a more suitable key (on whichever side), and a unique and unpredictable IV unless you always use a new key in which case you can use a fixed IV, and on the openssl side use <code>-K</code> (note uppercase) and <code>-iv</code> to specify those values <em>in hex</em>. See the manpage on any Unix system with openssl installed or <a href=""https://www.openssl.org/docs/manmaster/apps/enc.html"" rel=""nofollow noreferrer"">https://www.openssl.org/docs/manmaster/apps/enc.html</a> .</p>

<p>Plus in either case <code>enc</code> defaults to ""PKCS#5"" (really PKCS#7) <strong>padding</strong>. I don't know if your JS module does; if not you should specify it. Unless you can guarantee your plaintexts will always be an exact multiple of 16 bytes (after any encoding like UTF8); then you could specify (or maybe default) no padding on the JS side and specify <code>-nopad</code> on the openssl side.</p>
","3542","<node.js><encryption><openssl><cryptojs>","1","2","4","2019-11-08 15:08:41","32678388","3","1","1022444","","2016-03-25 11:26:10","2015-09-18 14:41:16",""
"32654749","Decrypt openssl AES with CryptoJS","<p>I'm trying to decrypt a file encrypted with openssl using <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow"">CryptoJS 3.1.5</a>.</p>

<p>Everything works fine if I encrypt and decrypt using CryptoJS, same goes for OpenSSL in shell, but when I try to mix CryptoJS with OpenSSL everything goes wrong.</p>

<p>The file is created using this command:</p>

<pre><code>openssl enc -aes-256-cbc -in file.txt -out file.enc -k password
</code></pre>

<p>and I try to decrypt like this:</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.enc', function(err, data) {
  var decrypted = CryptoJS.AES.decrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC }
                  );

  console.log(decrypted.toString(CryptoJS.enc.Utf8));
});

// Give me this err: Uncaught Error: Malformed UTF-8 data
</code></pre>

<p>And in the other way, I do :</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.txt', function(err, data) {
  var encrypted = CryptoJS.AES.encrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC });

  fs.writeFile('file.enc', encrypted);
});
</code></pre>

<p>And then in Shell:</p>

<pre><code>openssl enc -d -aes-256-cbc -in file.enc -out file2.txt -k password
// Give me this err: bad magic number
</code></pre>

<p>Am I missing something obvious ?</p>
","<p>This PHP code, which includes command line <strong>OpenSSL</strong> encryption:</p>

<p><a href=""http://pastebin.com/sivmZvSw"" rel=""nofollow"">http://pastebin.com/sivmZvSw</a></p>

<p>...is compatible with this <strong>CryptoJS</strong> code, which I normally run on the command line using <code>jsc</code> on my Mac:</p>

<p><a href=""http://pastebin.com/LcDBG7yj"" rel=""nofollow"">http://pastebin.com/LcDBG7yj</a></p>

<p>(This code was written with <code>CryptoJS</code> 3.1.2, although I wouldn't expect a major difference between that and 3.1.5.)</p>

<p>The tricks are:</p>

<ol>
<li><p>As indicated by the other answer, you need to specify the exact key and IV on both sides in order for it to work.</p></li>
<li><p>Even though AES-256 can theoretically handle 128-bit keys, I have found that only 256-bit keys seem to work.</p></li>
<li><p>In these examples I have avoided using a salt value. You could arguably make it more secure by including salt, but make sure you specify it correctly in both places.</p></li>
<li><p>The other thing that catches people out is they think they can just pass a string to the <code>CryptoJS.decrypt()</code> function. This is not correct. <code>CryptoJS.decrypt()</code> expects a <code>cipherParams</code> object. (See example.)</p></li>
<li><p>Regarding padding: both <code>CryptoJS</code> and <code>OpenSSL</code> default to PKCS#7, which is functionally equivalent to PKCS#5 except PKCS#7 can handle any block size. When we're talking about 8-byte block sizes, they are identical. Anyway, you shouldn't need to specify the padding in <code>CrytoJS</code>.</p></li>
</ol>

<p>Good luck!</p>
","3542","<node.js><encryption><openssl><cryptojs>","1","2","4","2019-11-08 15:08:41","32678388","3","1","1022444","","2016-03-25 11:26:10","2015-09-18 14:41:16",""
"32654749","Decrypt openssl AES with CryptoJS","<p>I'm trying to decrypt a file encrypted with openssl using <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow"">CryptoJS 3.1.5</a>.</p>

<p>Everything works fine if I encrypt and decrypt using CryptoJS, same goes for OpenSSL in shell, but when I try to mix CryptoJS with OpenSSL everything goes wrong.</p>

<p>The file is created using this command:</p>

<pre><code>openssl enc -aes-256-cbc -in file.txt -out file.enc -k password
</code></pre>

<p>and I try to decrypt like this:</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.enc', function(err, data) {
  var decrypted = CryptoJS.AES.decrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC }
                  );

  console.log(decrypted.toString(CryptoJS.enc.Utf8));
});

// Give me this err: Uncaught Error: Malformed UTF-8 data
</code></pre>

<p>And in the other way, I do :</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.txt', function(err, data) {
  var encrypted = CryptoJS.AES.encrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC });

  fs.writeFile('file.enc', encrypted);
});
</code></pre>

<p>And then in Shell:</p>

<pre><code>openssl enc -d -aes-256-cbc -in file.enc -out file2.txt -k password
// Give me this err: bad magic number
</code></pre>

<p>Am I missing something obvious ?</p>
","<p>For the record, this is how I decrypt openssl file.
</p>

<pre><code>//openssl enc -aes-256-cbc -in file.txt -out file.enc -k password

fs.readFile('file.enc', function(err, data) {
  var salt          = data.toString(""hex"", 8, 16),
      enc           = data.toString(""hex"", 16, data.length),
      derivedParams = CryptoJS.kdf.OpenSSL.execute(
                        password,
                        256/32,
                        128/32,
                        CryptoJS.enc.Hex.parse(salt)
                      ),
      cipherParams  = CryptoJS.lib.CipherParams.create({
                       ciphertext : CryptoJS.enc.Hex.parse(enc)
                     }),
      decrypted     = CryptoJS.AES.decrypt(
                        cipherParams,
                        derivedParams.key,
                        { iv : derivedParams.iv }
                      );

  console.log(hex2a(decrypted.toString())); // result is in hexa
});
</code></pre>

<p>And this is how I encrypt to make it work with OpenSSL</p>

<pre><code>fs.readFile('file.txt', function(err, data) {
  var encrypted = CryptoJS.AES.encrypt(data.toString(), password);
      buff      = new Buffer(encrypted.toString(), ""base64"");

  fs.writeFile('file.enc', buff);
});

// openssl enc -d -aes-256-cbc -in file.enc -out file2.txt -k password
</code></pre>

<p>Hope it'll help someone :)</p>
","3542","<node.js><encryption><openssl><cryptojs>","1","7","4","2019-11-08 15:08:41","32678388","3","1","1022444","","2016-03-25 11:26:10","2015-09-18 14:41:16",""
"32654749","Decrypt openssl AES with CryptoJS","<p>I'm trying to decrypt a file encrypted with openssl using <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow"">CryptoJS 3.1.5</a>.</p>

<p>Everything works fine if I encrypt and decrypt using CryptoJS, same goes for OpenSSL in shell, but when I try to mix CryptoJS with OpenSSL everything goes wrong.</p>

<p>The file is created using this command:</p>

<pre><code>openssl enc -aes-256-cbc -in file.txt -out file.enc -k password
</code></pre>

<p>and I try to decrypt like this:</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.enc', function(err, data) {
  var decrypted = CryptoJS.AES.decrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC }
                  );

  console.log(decrypted.toString(CryptoJS.enc.Utf8));
});

// Give me this err: Uncaught Error: Malformed UTF-8 data
</code></pre>

<p>And in the other way, I do :</p>

<pre class=""lang-js prettyprint-override""><code>fs.readFile('file.txt', function(err, data) {
  var encrypted = CryptoJS.AES.encrypt(
                    data.toString(),
                    ""password"",
                    { mode : CryptoJS.mode.CBC });

  fs.writeFile('file.enc', encrypted);
});
</code></pre>

<p>And then in Shell:</p>

<pre><code>openssl enc -d -aes-256-cbc -in file.enc -out file2.txt -k password
// Give me this err: bad magic number
</code></pre>

<p>Am I missing something obvious ?</p>
","<p>You should use <code>-K 70617373776F7264</code> instead of <code>-k password</code> in the shell command. <code>70617373776F7264</code> is the hex code of password.</p>
","3542","<node.js><encryption><openssl><cryptojs>","1","0","4","2019-11-08 15:08:41","32678388","3","1","1022444","","2016-03-25 11:26:10","2015-09-18 14:41:16",""
"35984198","C# SHA256 ComputeHash result different with CryptoJS SHA256 function","<p>I have a C# function as below:</p>

<pre><code>string stringvalue = ""530500480530490480530480480520570480520510500490"";
var encodedvalue= Encoding.Unicode.GetBytes(stringvalue);
using (HashAlgorithm ssp = System.Security.Cryptography.HashAlgorithm.Create(""SHA256""))
        {

            var digest = ssp.ComputeHash(encodedvalue);

            return BitConverter.ToString(digest); 

        }
</code></pre>

<p>I need to create a javascript function that match the code above so that the end result for both C# and JS is the same. </p>

<p>Currently in my JS code, I'm using this: </p>

<pre><code>var hash = CryptoJS.SHA256(""530500480530490480530480480520570480520510500490"");
var hexhash = hash.toString(CryptoJS.enc.hex);
</code></pre>

<p>This is the result of my hexhash:</p>

<pre><code>d956678c8f12c65299daf35019a9a1eb3e6eb9855fd850aeb5aafe46057d179e
</code></pre>

<p>But in my C# code, this line of <code>var digest = ssp.ComputeHash(bPass);</code> return the following array:
<a href=""https://i.stack.imgur.com/oU7Rm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oU7Rm.png"" alt=""enter image description here""></a></p>

<p>I don't know much about encoding. Please tell me what type of result is being populated in the c# code above? If I'm not mistaken, the ComputeHash is returning bytes but I need lots of reading to confirm that which is another long hour of studying</p>

<p>I tried many different ways of converting the JS Sha256 code but no luck. I'm stuck at this particular line for almost a day. </p>

<p>Please help. Thanks</p>

<p>EDIT:
Sorry for the code error. I had updated the C# code. ComputeHash accept an array</p>
","<p>Try </p>

<pre><code>var digest = ssp.ComputeHash(Encoding.UTF8.GetBytes(stringvalue))

return BitConverter.ToString(digest)
                   .Replace(""-"", string.Empty)
                   .ToLowerInvariant();
</code></pre>

<p>That js library is converting the string to UTF8 before calculating its hash.</p>
","3449","<javascript><c#><encoding><cryptojs>","4","0","4","2019-06-06 02:09:52","","1","2","2243398","","2016-03-14 10:00:26","2016-03-14 09:49:22",""
"35984198","C# SHA256 ComputeHash result different with CryptoJS SHA256 function","<p>I have a C# function as below:</p>

<pre><code>string stringvalue = ""530500480530490480530480480520570480520510500490"";
var encodedvalue= Encoding.Unicode.GetBytes(stringvalue);
using (HashAlgorithm ssp = System.Security.Cryptography.HashAlgorithm.Create(""SHA256""))
        {

            var digest = ssp.ComputeHash(encodedvalue);

            return BitConverter.ToString(digest); 

        }
</code></pre>

<p>I need to create a javascript function that match the code above so that the end result for both C# and JS is the same. </p>

<p>Currently in my JS code, I'm using this: </p>

<pre><code>var hash = CryptoJS.SHA256(""530500480530490480530480480520570480520510500490"");
var hexhash = hash.toString(CryptoJS.enc.hex);
</code></pre>

<p>This is the result of my hexhash:</p>

<pre><code>d956678c8f12c65299daf35019a9a1eb3e6eb9855fd850aeb5aafe46057d179e
</code></pre>

<p>But in my C# code, this line of <code>var digest = ssp.ComputeHash(bPass);</code> return the following array:
<a href=""https://i.stack.imgur.com/oU7Rm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oU7Rm.png"" alt=""enter image description here""></a></p>

<p>I don't know much about encoding. Please tell me what type of result is being populated in the c# code above? If I'm not mistaken, the ComputeHash is returning bytes but I need lots of reading to confirm that which is another long hour of studying</p>

<p>I tried many different ways of converting the JS Sha256 code but no luck. I'm stuck at this particular line for almost a day. </p>

<p>Please help. Thanks</p>

<p>EDIT:
Sorry for the code error. I had updated the C# code. ComputeHash accept an array</p>
","<p>In my example I am using  System.Security.Cryptography.SHA256Managed to get SHA256 in C#.</p>

<p>The method SHA256Managed.ComputeHash takes a byte array as a parameter and return another byte array. Now we need to convert back your byte array to a string.</p>

<p>The following code return the same result a Javascript SHA-256.</p>

<pre><code> byte[] bytes = Encoding.UTF8.GetBytes(""530500480530490480530480480520570480520510500490"");
 SHA256Managed hashstring = new SHA256Managed();
 byte[] hash = hashstring.ComputeHash(bytes);
 string hashString = string.Empty;
 foreach (byte x in hash)
 {
     hashString += String.Format(""{0:x2}"", x);
 }
 return(hashString);
</code></pre>

<p><em>Just to explain : String.Format(""{0:x2}"", x)</em></p>

<ul>
<li><em>X means Hexadecimal format.</em></li>
<li><em>2 means 2 characters.</em></li>
</ul>
","3449","<javascript><c#><encoding><cryptojs>","4","4","4","2019-06-06 02:09:52","","1","2","2243398","","2016-03-14 10:00:26","2016-03-14 09:49:22",""
"35984198","C# SHA256 ComputeHash result different with CryptoJS SHA256 function","<p>I have a C# function as below:</p>

<pre><code>string stringvalue = ""530500480530490480530480480520570480520510500490"";
var encodedvalue= Encoding.Unicode.GetBytes(stringvalue);
using (HashAlgorithm ssp = System.Security.Cryptography.HashAlgorithm.Create(""SHA256""))
        {

            var digest = ssp.ComputeHash(encodedvalue);

            return BitConverter.ToString(digest); 

        }
</code></pre>

<p>I need to create a javascript function that match the code above so that the end result for both C# and JS is the same. </p>

<p>Currently in my JS code, I'm using this: </p>

<pre><code>var hash = CryptoJS.SHA256(""530500480530490480530480480520570480520510500490"");
var hexhash = hash.toString(CryptoJS.enc.hex);
</code></pre>

<p>This is the result of my hexhash:</p>

<pre><code>d956678c8f12c65299daf35019a9a1eb3e6eb9855fd850aeb5aafe46057d179e
</code></pre>

<p>But in my C# code, this line of <code>var digest = ssp.ComputeHash(bPass);</code> return the following array:
<a href=""https://i.stack.imgur.com/oU7Rm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oU7Rm.png"" alt=""enter image description here""></a></p>

<p>I don't know much about encoding. Please tell me what type of result is being populated in the c# code above? If I'm not mistaken, the ComputeHash is returning bytes but I need lots of reading to confirm that which is another long hour of studying</p>

<p>I tried many different ways of converting the JS Sha256 code but no luck. I'm stuck at this particular line for almost a day. </p>

<p>Please help. Thanks</p>

<p>EDIT:
Sorry for the code error. I had updated the C# code. ComputeHash accept an array</p>
","<p>I finally found the answer after uncountable hours of trial and error. </p>

<p>The C# code <code>var digest = ssp.ComputeHash(encodedvalue)</code> is returning byte array from the result of <code>var encodedvalue= Encoding.Unicode.GetBytes(stringvalue);</code> as Jean replied. In order to create the function in Javascript, I need to ensure that the encodedvalue is producing the correct encoding format and size just like the one in C#.</p>

<p>Using only CryptoJS, I manage to get the matching result from below</p>

<pre><code>function GetHexFromString() {
var stringVal = '8563A578-7402-4567-A6CE-4DE4E0825B021234';
// Convert the string to UTF 16 little-endian
// Result: 560530540510650530550560450550520480500450520530540550450650540670690450520680690520690480560500530660480500490500510520
var utf16le = CryptoJS.enc.Utf16LE.parse(stringVal);  

// Convert to Sha256 format and get the word array
var utf16Sha256 = CryptoJS.SHA256(utf16le);
// Convert the Sha256 word array to Uint8Array to get the 32 byte array just to see the result to ensure it match with the C# function
// Result: 94,203,69,29,35,202,209,149,121,144,44,6,98,250,141,161,102,7,238,35,228,117,111,236,118,115,51,113,134,72,52,69
var utf16sha256Array = convertWordArrayToUint8Array(utf16Sha256); 

// Convert the Sha256 to hex (if i'm not mistaken, it's base 16) format
var hexSha256 = utf16Sha256.toString(CryptoJS.enc.hex);

 // Insert a dash in between 2 characters in the string
 hexSha256 = hexSha256.replace(/(\S{2})/g, ""$1-"");
 // Remove the last dash in the string
 hexSha256 = hexSha256.replace(/-$/, """");

// Final Result: 5E-CB-45-1D-23-CA-D1-95-79-90-2C-06-62-FA-8D-A1-66-07-EE-23-E4-75-6F-EC-76-73-33-71-86-48-34-45
return hexSha256.toUpperCase();
}

function convertWordArrayToUint8Array(wordArray) {
        var len = wordArray.words.length,
            u8_array = new Uint8Array(len &lt;&lt; 2),
            offset = 0, word, i
        ;
        for (i = 0; i &lt; len; i++) {
            var word = wordArray.words[i];                

            u8_array[offset++] = word &gt;&gt; 24;
            u8_array[offset++] = (word &gt;&gt; 16) &amp; 0xff;
            u8_array[offset++] = (word &gt;&gt; 8) &amp; 0xff;
            u8_array[offset++] = word &amp; 0xff;                                              
        }
        return u8_array;
    }
</code></pre>

<p>Hope it help whoever that need such method</p>
","3449","<javascript><c#><encoding><cryptojs>","4","3","4","2019-06-06 02:09:52","","1","2","2243398","","2016-03-14 10:00:26","2016-03-14 09:49:22",""
"35984198","C# SHA256 ComputeHash result different with CryptoJS SHA256 function","<p>I have a C# function as below:</p>

<pre><code>string stringvalue = ""530500480530490480530480480520570480520510500490"";
var encodedvalue= Encoding.Unicode.GetBytes(stringvalue);
using (HashAlgorithm ssp = System.Security.Cryptography.HashAlgorithm.Create(""SHA256""))
        {

            var digest = ssp.ComputeHash(encodedvalue);

            return BitConverter.ToString(digest); 

        }
</code></pre>

<p>I need to create a javascript function that match the code above so that the end result for both C# and JS is the same. </p>

<p>Currently in my JS code, I'm using this: </p>

<pre><code>var hash = CryptoJS.SHA256(""530500480530490480530480480520570480520510500490"");
var hexhash = hash.toString(CryptoJS.enc.hex);
</code></pre>

<p>This is the result of my hexhash:</p>

<pre><code>d956678c8f12c65299daf35019a9a1eb3e6eb9855fd850aeb5aafe46057d179e
</code></pre>

<p>But in my C# code, this line of <code>var digest = ssp.ComputeHash(bPass);</code> return the following array:
<a href=""https://i.stack.imgur.com/oU7Rm.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/oU7Rm.png"" alt=""enter image description here""></a></p>

<p>I don't know much about encoding. Please tell me what type of result is being populated in the c# code above? If I'm not mistaken, the ComputeHash is returning bytes but I need lots of reading to confirm that which is another long hour of studying</p>

<p>I tried many different ways of converting the JS Sha256 code but no luck. I'm stuck at this particular line for almost a day. </p>

<p>Please help. Thanks</p>

<p>EDIT:
Sorry for the code error. I had updated the C# code. ComputeHash accept an array</p>
","<p>An alternative to Koo SengSeng's answer (if you don't want to use CryptoJS library).<br>
<code>SHA256</code> function is from <a href=""https://geraintluff.github.io/sha256/"" rel=""nofollow noreferrer"">here</a>, the <code>arrToUintArr</code> function is from Koo SengSeng's answer.</p>

<pre><code>var SHA256=function a(b){function c(a,b){return a&gt;&gt;&gt;b|a&lt;&lt;32-b}for(var d,e,f=Math.pow,g=f(2,32),h=""length"",i="""",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o={},p=2;64&gt;n;p++)if(!o[p]){for(d=0;313&gt;d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+=""\x80"";b[h]%64-56;)b+=""\x00"";for(d=0;d&lt;b[h];d++){if(e=b.charCodeAt(d),e&gt;&gt;8)return;j[d&gt;&gt;2]|=e&lt;&lt;(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e&lt;j[h];){var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64&gt;d;d++){var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&amp;l[5]^~v&amp;l[6])+m[d]+(q[d]=16&gt;d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s&gt;&gt;&gt;3)+q[d-7]+(c(t,17)^c(t,19)^t&gt;&gt;&gt;10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&amp;l[1]^u&amp;l[2]^l[1]&amp;l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8&gt;d;d++)l[d]=l[d]+r[d]|0}for(d=0;8&gt;d;d++)for(e=3;e+1;e--){var y=l[d]&gt;&gt;8*e&amp;255;i+=(16&gt;y?0:"""")+y.toString(16)}return i};
var arrToUintArr=function(a){for(var l=a.length,b=new Uint8Array(l&lt;&lt;2),o=0,w,i=0;i&lt;l;i++) w=a[i],b[o++]=w&gt;&gt;24,b[o++]=(w&gt;&gt;16)&amp;0xff,b[o++]=(w&gt;&gt;8)&amp;0xff,b[o++]=w&amp;0xff;return b;}
var computeHash=function(k){for(var a=[],s=SHA256(k),i=0;i&lt;8;i++) a.push(parseInt(s.substr(i*8,8),16));return arrToUintArr(a);}
</code></pre>

<p><code>computeHash(k)</code> will return an array of numbers representing bytes.  </p>

<p>This is equal to below code in C#:</p>

<pre><code>new System.Security.Cryptography.SHA256CryptoServiceProvider().ComputeHash(Encoding.UTF8.GetBytes(k));
</code></pre>
","3449","<javascript><c#><encoding><cryptojs>","4","0","4","2019-06-06 02:09:52","","1","2","2243398","","2016-03-14 10:00:26","2016-03-14 09:49:22",""
"13362796","How to call an external JavaScript files methods from JMeter","<p>I'm trying to produce a HMAC SHA256 signature for a SOAP/XML-RPC JMeter Request that I am building.
I have found a JavaScript library that should do the trick for me:</p>

<p><a href=""http://code.google.com/p/crypto-js/#HMAC"" rel=""nofollow"">http://code.google.com/p/crypto-js/#HMAC</a></p>

<p>The issue is that I can't find a way to call the external JavaScript files methods from JMeter.</p>

<p>Any help would really be appreciated with this or a suggestion for an alternative to preform the task.</p>
","<p>You don't need to use any external JS libraries to generate HMAC. This functionality <a href=""https://stackoverflow.com/a/3208472/841064"">is available in Java SE</a>. You can use Beanshell Sampler to execute Java code.</p>

<p>If this functionality wouldn't be available in Java SE, you could:</p>

<ul>
<li>use <a href=""http://jmeter.apache.org/usermanual/component_reference.html#OS_Process_Sampler"" rel=""nofollow noreferrer"">OS Process Sampler</a></li>
<li>use <a href=""http://jmeter.apache.org/usermanual/component_reference.html#BSF_Sampler"" rel=""nofollow noreferrer"">BSF Sampler</a>, set language to javascript and attach file with script</li>
<li>put Jar of chosen library to Jmeter's lib folder. Then this library will be loaded by JMeter  at startup time and you can use it through Beanshell sampler</li>
</ul>
","3378","<javascript><jmeter><hmac><sha256><cryptojs>","3","2","1","2012-11-14 09:42:55","13367400","0","1","","","","2012-11-13 14:45:51",""
"35472396","How does CryptoJS get an IV when none is specified?","<p>When using <code>CryptoJS.AES.encrypt</code> how does it come up with an Initialization Vector if the third argument is not passed to the function? Is there a way to get it out of the encrypted string?</p>

<p>The reason I need this is I need to decrypt something <code>CryptoJS.AES.encrypt</code> returned using Lua, but I only have the key that was provided.</p>
","<p>CryptoJS' <code>CryptoJS.&lt;BlockCipher&gt;.encrypt</code> has two modes of encryption. </p>

<ol>
<li><p>If you pass in a key that <em>is not a string</em>, but rather a WordArray (CryptoJS's internal representation format for binary data), the key is taken as-is. This mode expects an IV for all modes of operation except ECB, which doesn't use an IV, so you don't have to specify one. If no IV is passed, it will default (through some JavaScript magic) to a zero filled IV (consisting of a full block of 0x00 bytes).</p></li>
<li><p>If you pass in a ""key"" that <em>is a string</em>, it will assume the ""key"" is a password. In order to derive a key from the password, it uses the OpenSSL-compatible derivation function <a href=""https://openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html"" rel=""nofollow""><code>EVP_BytesToKey</code></a>. This mode generates a new 8 byte random salt and uses it along with the password to generate a key and IV. Even if you explicitly pass in an IV, it won't be used.</p>

<pre><code>CryptoJS.AES.encrypt(msg, password).toString()
</code></pre>

<p>results in a Base64-encoded ciphertext that contains the string ""Salted__"" at the beginning followed by the 8 byte salt and the actual ciphertext. You can explicitly split this before use with:</p>

<pre><code>var ct = CryptoJS.AES.encrypt(msg, password);
var saltHex = ct.salt.toString();     // random salt
var ctHex = ct.ciphertext.toString(); // actual ciphertext
var ivHex = ct.iv.toString();         // generated IV
</code></pre>

<p>If you need to recreate the same key derivation. Have a look at <a href=""https://raw.githubusercontent.com/CryptoStore/crypto-js/3.1.2/build/components/evpkdf.js"" rel=""nofollow"">the code</a> and <a href=""https://openssl.org/docs/manmaster/crypto/EVP_BytesToKey.html#KEY-DERIVATION-ALGORITHM"" rel=""nofollow"">the specification</a>.</p>

<p>Keys should have high entropy and be indistinguishable from random noise, which makes it hard for them to be brute-forced. The above mentioned <code>EVP_BytesToKey</code> is not secure, because MD5 hashing is very fast, which enables an attacker to brute-force the password. You either need to use a really long password (20-30 characters) or use an appropriate key derivation function such as PBKDF2, which CryptoJS provides.</p></li>
</ol>
","3347","<javascript><encryption><cryptojs>","5","6","1","2016-05-13 18:56:37","35536933","14","2","1816580","","2016-02-21 13:50:00","2016-02-18 03:41:04",""
"48964610","Hmac sha256 base64 and CryptoJS diffrent for nodejs crypto","<p>Let say we have simple msg and key:</p>

<p>message = 'simple'</p>

<p>private_key = '123456789';
Using that in angular project with CryptoJS:</p>

<pre><code>const signature = CryptoJS.HmacSHA256('simple', '123456789');
const signatureBase = signature.toString(CryptoJS.enc.Base64);
</code></pre>

<p>result for me is:</p>

<blockquote>
  <p>lvs7rQTe1EDTLAS1GVWWsNG5ZaYVCh9aaYc+NoEunC4=</p>
</blockquote>

<p>using that in msg and key in node:</p>

<pre><code>var hmacsignature = crypto.createHmac('sha256', new Buffer(""123456789"", ""base64""))
.update(""simple"")
.digest()
.toString('base64');
</code></pre>

<p>result is:</p>

<blockquote>
  <p>nYu2PGqfRDWnHbT649q0gc+7DcIq8iwcwHAQQa5T2HY=</p>
</blockquote>

<p>Can you tell me which one is correct and how to get same thing is angular?</p>

<p>Thanks</p>
","<p>In browser string encoding usually is UTF-8, so use UTF-8 as string encoding should fix it. BTW, you should explicitly set string encoding in both side to make sure you will get same result.</p>

<pre><code>var hmacsignature = crypto.createHmac('sha256', Buffer.from('123456789', 'utf8'))
.update(""simple"")
.digest()
.toString('base64');
</code></pre>

<p>And <code>new Buffer(string)</code> is deprecated, use <code>Buffer.from(string[, encoding])</code> if you can.</p>
","3251","<javascript><node.js><angular><cryptojs>","1","1","1","2018-02-24 17:50:22","","0","","","","","2018-02-24 15:48:28",""
"28245929","triple des encrypt c# and decrypt in javascript","<p>I have a C# encrypted string that needs to be decrypted in node.js. I am currently using cryptoJS as the decipher.</p>

<p>Below is the code to initially encrypt the string in C#:</p>

<p>The CryptoAgent constructor builds the algorithm key and initialization vector using a Guid. For example, ""<em>A925B4D6-A8D0-11E4-BA34-AC7BA1ACF56B</em>"".</p>

<pre><code>public CryptoAgent(Guid keyGuid)
    {
        _UseSymmetricEncryption = true;
        byte[] guidArr = keyGuid.ToByteArray();
        Array.Resize&lt;byte&gt;(ref guidArr, 24);
        _Key = (byte[])guidArr.Clone();
        Array.Reverse(guidArr);
        _IV = guidArr;
    }
</code></pre>

<p>The encrypt method is pretty straight forward. It takes the plainText and encrypts the data using the key and iv created above, then returns it in a URL friendly string. For example, 
""<em>Email=testuser@gmail.com&amp;ProductUserId=C4B80D7F-A8D0-11E4-BA34-AC7BA1ACF56B</em>""</p>

<pre><code>private string EncryptSymmetric(string plainText)
    {
        if (string.IsNullOrEmpty(plainText))
        {
            throw new ArgumentNullException(""The string to be encrypted cannot be null."");
        }
        ICryptoTransform transform;
        TripleDESCryptoServiceProvider csp = new TripleDESCryptoServiceProvider();
        transform = csp.CreateEncryptor(_Key, _IV);
        MemoryStream memoryStream = new MemoryStream();
        CryptoStream cryptoStream = new CryptoStream(memoryStream, transform, CryptoStreamMode.Write);
        byte[] plaintextBytes = Encoding.Unicode.GetBytes(plainText);
        cryptoStream.Write(plaintextBytes, 0, plaintextBytes.Length);
        cryptoStream.FlushFinalBlock();
        byte[] encryptedData = memoryStream.GetBuffer();
        Console.WriteLine(csp.Mode);
        Console.WriteLine(csp.Padding);
        return UrlNormalize(Convert.ToBase64String(encryptedData, 0, (int)memoryStream.Length));
    }
</code></pre>

<p>The resulting encrypted string would be the following:</p>

<p><em>ZuD6CIEY6b-sh9Q6DRh9SWE0YyC92Jmw1oplTqy7kjETXoNio42hoJxDmMr7V-Sp14aX9lwTxYBM_KjA
bEevElE_7nUzC_C4nM13LHHbpg6aR8xO39RseQjpLCLYj5ZKKWiXZREqpvDBlvtF-F1VuqyAMa0ECYOD
N8ZCcmmyIHuCpalcUkLZ0zZajwutIrtmmqg3VXQNT3E~</em></p>

<p>I am tasked with receiving this encrypted string and decrypting the string in node.js and parsing out the two parameters for further use. Below is my initial file for decryption:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

var text = ""Email=testuser@gmail.com&amp;ProductUserId=C4B80D7F-A8D0-11E4-BA34-AC7BA1ACF56B"";
var key = ""A925B4D6-A8D0-11E4-BA34-AC7BA1ACF56B"";
var useHashing = true;

if (useHashing){
   key = CryptoJS.MD5(key).toString();
   key = key + '0000000000000000';
}

var textWordArray = CryptoJS.enc.Utf16.parse(text);
var keyHex = CryptoJS.enc.Hex.parse(key);

var iv = reverseHexString(keyHex.toString());
var ivHex = CryptoJS.enc.Hex.parse(iv);

console.log('hexadecimal key: ' + keyHex + '\n');

console.log('hexadecimal iv: ' + ivHex + '\n');

var options = {
    mode: CryptoJS.mode.CBC, 
    padding: CryptoJS.pad.Pkcs7,
    iv: ivHex
};

var encrypted = CryptoJS.TripleDES.encrypt(textWordArray, keyHex, options);

var base64String = encrypted.toString();

console.log('base64: ' + base64String + '\n');

var decrypted = CryptoJS.TripleDES.decrypt( {
    ciphertext: CryptoJS.enc.Base64.parse(base64String)
}, keyHex, options);

console.log('decrypted: ' + decrypted.toString(CryptoJS.enc.Utf16));

function reverseHexString(hexStr) {
    var first32 = hexStr.substring(0, 32);
    var reverseFirst32 = first32.split("""").reverse().join("""").split("""");

    var reverseHex = '0000000000000000';

    for (var i = 0; i &lt; reverseFirst32.length; i+=2) {
        reverseHex += reverseFirst32[i+1];
        reverseHex += reverseFirst32[i];
    };

    return reverseHex;
}
</code></pre>

<p>My initial run at a solution has resulted in the decryption failing and producing a line of question marks. </p>

<p>Using the C# code I was able to print out the key and iv values. I attempted to replace the keyHex and ivHex Javascript values with the key and iv values printed from the C#, but the decryption still fails.</p>

<p>Any help that can be provided is greatly appreciated.</p>

<p>Thank you</p>
","<p>The reason this doesn't work is probably the key generation: You use ASCII zeros instead of <code>\0</code> and you have 16 of them and not 8 (MD5 gives 16 bytes and you want a 24 byte TDES key). This isn't bad for the key as CryptoJS will just disregard the additional bytes, but since you reverse the key to get the IV, you get a wrong IV instead.</p>
","3166","<javascript><c#><node.js><cryptojs><tripledes>","3","0","1","2015-01-30 23:12:13","28246166","1","","","","","2015-01-30 22:49:36",""
"23149282","SHA512 hashes differ on android, php and javascript","<p>I am using the SHA512 hash to transfer some encrypted data between my app and it's backend. However, I'm having a odd situation and have no idea what might be causing it.</p>

<p>So, I've got following setups tested:</p>

<p>Android 2x SHA512</p>

<p>Android 1x SHA512 -> CryptoJS 1x SHA512</p>

<p>PHP 2x SHA512</p>

<p>So, when I do the first 2x Android hashing, I get the same result as when I do the 1x android -> 1x cryptojs.
However, when I do the PHP 2x, I get the same result as I get on the first Android pass, but the second encryption pass of the PHP is different.</p>

<p>On PHP, I've tried both the hash() and openssl_digest() functions with raw bytes as output.</p>

<p>PHP:</p>

<pre><code>$firstpass = base64_encode(hash('sha512', $enteredPassword, true));
//$firstpass = base64_encode(hash('sha512', $enteredPassword, true));

//$secondpass = base64_encode(openssl_digest($firstpass, 'sha512', true));
$secondpass = base64_encode(hash('sha512', $firstpass, true));
</code></pre>

<p>Android:</p>

<pre><code>public static String encryptPassword(String password) {
    MessageDigest md = null;
    try {
        md = MessageDigest.getInstance(""SHA-512"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    if (md != null) {
        md.update(password.getBytes());
        byte byteData[] = md.digest();
        String base64 = Base64.encodeToString(byteData, Base64.DEFAULT);

        return base64;
    }
    return password;
}
</code></pre>

<p>CryptoJS:</p>

<pre><code>var password = cryptojs.SHA512(req.params.password);
var basepassword = password.toString(cryptojs.enc.Base64);
</code></pre>

<p>Why would my first hash be correct and my second not and how could I fix this?</p>
","<p>SHA1 is not made for security, don't use it for this.
Grab any implementation of BCrypt and do security right.
As for the different hashes: Most likely an encoding issue related to Strings.</p>
","3146","<php><android><hash><sha512><cryptojs>","0","0","1","2014-04-18 07:38:35","23149654","0","4","772229","","2014-04-18 07:22:06","2014-04-18 07:15:46",""
"50679221","AES 128 Encryption in Angular 4 and decryption in Java","<p>I am using a CryptoJS(AES) for encryption in Angular 4 using below code:</p>

<pre><code>const key = CryptoJS.enc.Utf8.parse('7061737323313233');
const iv = CryptoJS.enc.Utf8.parse('7061737323313233');
const encrypted = CryptoJS.AES.encrypt('String to encrypt', key, {
  keySize: 16,
  iv: iv,
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.Pkcs7
});
console.log('Encrypted :' + encrypted);
</code></pre>

<p>and below java code to decrypt using AES:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

private static SecretKeySpec secretKey;
private static byte[] key;

public static void setKey(String myKey)
{
    MessageDigest sha = null;
    try {
        key = myKey.getBytes(""UTF-8"");
        sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        secretKey = new SecretKeySpec(key, ""AES"");
    }
    catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
    catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
}

public static String encrypt(String strToEncrypt, String secret)
{
    try
    {
        setKey(secret);
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(""UTF-8"")));
    }
    catch (Exception e)
    {
        System.out.println(""Error while encrypting: "" + e.toString());
    }
    return null;
}

public static String decrypt(String strToDecrypt, String secret)
{
    try
    {
        setKey(secret);
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));
    }
    catch (Exception e)
    {
        System.out.println(""Error while decrypting: "" + e.toString());
    }
    return null;
}
 }
</code></pre>

<p>and </p>

<pre><code>public class Test {
public static void main(String[] args) {
    final String secretKey = ""7061737323313233"";
    String originalString = ""Response from angular"";
    String decryptedString = Encryption.decrypt(originalString, secretKey);
    System.out.println(decryptedString);
}
 }
</code></pre>

<p>Angular and java both code works fine if i run it independently for Encryption and Decryption. but when i encrypt using angular and decrypt using java it gives error:</p>

<blockquote>
  <p>Error while decrypting: javax.crypto.BadPaddingException: Given final block not properly padded</p>
</blockquote>

<p>Now my issues are there is a diffrence of padding in angular and java. In angular it is Pkcs7 and in java it is Pkcs5 but this link <a href=""https://crypto.stackexchange.com/questions/9043/what-is-the-difference-between-pkcs5-padding-and-pkcs7-padding"">Padding</a>
says both are same then, why this error is comming. Please help me</p>
","<p>My code to generate key was generating bad key in java. So i changed it to : </p>

<pre><code> Key key = new SecretKeySpec(key.getBytes(""UTF-8""),""AES"" );
</code></pre>

<p>Now its working fine</p>
","3144","<java><angular><aes><cryptojs>","3","1","1","2018-06-05 05:37:44","","0","","8495123","","2018-06-04 11:11:24","2018-06-04 11:11:02",""
"37467723","Encrypting and decrypting with DES and Base64 with JavaScript","<p>I am encrypting something previously encoded in base64. </p>

<p>The steps are:<br/>
 1. Encode the plain (readable) text in base64<br/>
 2. Encrypt the base64 encoded text with DES/CBC/PKCS7PADDING using CryptoJS<br/>
 3. Encode again in base64 the information obtained in step 2<br/>
<br/>
This is my code in Javascript:</p>

<pre><code>function encryptDesCbcPkcs7Padding(message, key) {
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var iv = new Uint8Array(0);
    var ivHex = CryptoJS.enc.Hex.parse(CryptoJS.enc.Utf8.parse(iv).toString(CryptoJS.enc.Hex));

    var encrypted = CryptoJS.DES.encrypt(message, keyHex, { iv: ivHex, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });


    return encrypted;//.toString(CryptoJS.enc.Utf8);
}

var plainText = ""hola"";
console.log(""Plain text: "", plainText);
var base64Coded = window.btoa(plainText);
console.log(""Base64 coded text: "", base64Coded);

var encrypted = encryptDesCbcPkcs7Padding(base64Coded, ""12345678"");
console.log(""Encrypted: "", encrypted);
var finalEncrypted = CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
console.log(""Final encrypted: "", finalEncrypted);
alert(""Final encrypted: "" + finalEncrypted);
</code></pre>

<p>With this code I get the information encryped with the previous steps.</p>

<p>Problem: I can't make the reverse steps. What am I doing wrong?</p>

<p>These is the code I use for the reverse:</p>

<pre><code>function decryptDesCbcPkcs7Padding(message, key) {
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var iv = new Uint8Array(0);
    var ivHex = CryptoJS.enc.Hex.parse(CryptoJS.enc.Utf8.parse(iv).toString(CryptoJS.enc.Hex));

    var decrypted = CryptoJS.DES.decrypt(message, keyHex, { iv: ivHex, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });


    return decrypted.toString(CryptoJS.enc.Utf8);
}

var base64Decoded = CryptoJS.enc.Base64.parse(finalEncrypted).toString();
console.log(""Base64 decoded"", base64Decoded);

var decrypted = decryptDesCbcPkcs7Padding(base64Decoded, ""12345678"");
console.log(""Decrypted: "", decrypted);

var finalDecrypted = CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
console.log(""Final encrypted: "", finalEncrypted);
alert(""Final encrypted: "" + finalEncrypted);
</code></pre>

<p>I can't make this code work, what am I doing wrong?</p>
","<p>There are many problems with the encodings in your code in addition to copy-paste errors. Here is the fixed code.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function encryptDesCbcPkcs7Padding(message, key) {
    var keyWords = CryptoJS.enc.Utf8.parse(key);
    var ivWords = CryptoJS.lib.WordArray.create([0, 0]);
    var encrypted = CryptoJS.DES.encrypt(message, keyWords, { iv: ivWords});
  
    return encrypted;//.toString(CryptoJS.enc.Utf8);
}

var plainText = ""hola"";
console.log(""Plain text: "", plainText);
var base64Coded = window.btoa(plainText);
console.log(""Base64 coded text: "", base64Coded);

var encrypted = encryptDesCbcPkcs7Padding(base64Coded, ""12345678"");
console.log(""Encrypted: "", encrypted);
var finalEncrypted = CryptoJS.enc.Base64.stringify(encrypted.ciphertext);
console.log(""Final encrypted: "", finalEncrypted);
alert(""Final encrypted: "" + finalEncrypted);

function decryptDesCbcPkcs7Padding(message, key) {
    var keyWords = CryptoJS.enc.Utf8.parse(key);
    var ivWords = CryptoJS.lib.WordArray.create([0, 0]);

    var decrypted = CryptoJS.DES.decrypt({ciphertext: message}, keyWords, { iv: ivWords });

    return decrypted.toString(CryptoJS.enc.Utf8);
}

var base64Decoded = CryptoJS.enc.Base64.parse(finalEncrypted);
console.log(""Base64 decoded"", base64Decoded);

var decrypted = decryptDesCbcPkcs7Padding(base64Decoded, ""12345678"");
console.log(""Decrypted: "", decrypted);

var finalDecrypted = CryptoJS.enc.Base64.parse(decrypted.toString(CryptoJS.enc.Utf8)).toString(CryptoJS.enc.Utf8);
console.log(""Final decrypted: "", finalDecrypted);
alert(""Final decrypted: "" + finalDecrypted);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/tripledes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3136","<javascript><encryption><cryptojs>","0","2","1","2017-07-30 12:27:51","37468518","6","","","","","2016-05-26 17:42:50",""
"49622946","CryptoJs + TripleDES encryption and Decryption with CBC Mode using Javascript","<p>I am trying to encrypt given plain text by Triple DES algorithm with CBC mode, but unable to get Desired Cipher Text which i have given below.</p>

<p>I need this encryption and decryption by CryptoJs using Javascript, but unable to do this. </p>

<p><strong>Plain Text:</strong> ""AN=1234567890;EA=test@mycompany.com;TS=2009-06-03 17:04:39""
<strong>Desired Cipher Text:</strong> ""LK0Y/C2GWAfVguTEwFBIzlLBKsp4v61yHCUTj0iKtxcG60Hzprx/zlCofYHsjYWnJt78ao9l6cA7TE
fIl+u0QA==""</p>

<p>Key = ""1234567890ABCDEFGHIJKLMN""</p>

<p>IV = ""12345678""</p>

<p>Mode: ""CBC""</p>

<p>Algorithm : ""TripleDES""</p>

<p>Javascript Code: </p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Testing Encryption &amp; Decryption&lt;/title&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/core.js""&gt; 
&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/rollups/tripledes.js""&gt; 
&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/mode-ecb.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/pad-nopadding.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
var key = 'E821752166E916AEEF940855';
//CBC Mode encryption 
function encryptByDESModeCBC(message) {
var keyHex = CryptoJS.enc.Utf8.parse(key);
var ivHex = 'E8217521';//CryptoJS.enc.Utf8.parse(key);
console.log(ivHex);
encrypted = CryptoJS.DES.encrypt(message, keyHex, {
iv:ivHex,
mode: CryptoJS.mode.CBC
}
);
return encrypted.ciphertext.toString(); 
//CBC Schema decryption 
function decryptByDESModeCBC(ciphertext2) {
var keyHex = CryptoJS.enc.Utf8.parse(key);
var ivHex = CryptoJS.enc.Utf8.parse(key);
// direct decrypt ciphertext
var decrypted = CryptoJS.DES.decrypt({
ciphertext: CryptoJS.enc.Hex.parse(ciphertext2)
}, keyHex, {
iv:ivHex,
mode: CryptoJS.mode.CBC
});
return decrypted.toString(CryptoJS.enc.Utf8);
}
function test(){
 var source = $(""#source"").val();
 var cc = encryptByDESModeCBC(CryptoJS.enc.Utf8.parse(source));
 $(""#target"").val(cc);
}
function test1(){
var source = $(""#sourceS"").val();
var dd = decryptByDESModeCBC(source);
$(""#jiemi"").val(dd);
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    Before encryption &lt;textarea id=""source"" value="""" 
     style=""width:500px;height:90px;"" /&gt;&lt;/textarea&gt;
   &lt;hr&gt;
  After encryption &lt;textarea id=""target"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  &lt;input type=""button"" onclick=""test();"" name="""" value="" encryption "" /&gt;
  &lt;hr&gt;
  ciphertext &lt;textarea id=""sourceS"" value="""" width=""400px"" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  After decryption &lt;textarea id=""jiemi"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  &lt;input type=""button"" onclick=""test1();"" name="""" value="" Decrypt ""/&gt;
  &lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
","<p>You can try this</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Testing Encryption &amp; Decryption&lt;/title&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/core.js""&gt; 
&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/rollups/tripledes.js""&gt; 
&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/mode-ecb.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/pad-nopadding.js""&gt;&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    Before encryption &lt;textarea id=""source"" value="""" 
     style=""width:500px;height:90px;"" /&gt;&lt;/textarea&gt;
   &lt;hr&gt;
  After encryption &lt;textarea id=""target"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  &lt;!-- &lt;input type=""button"" onclick=""test();"" name="""" value="" encryption "" /&gt;
   --&gt;
  &lt;input type=""button"" id=""js-encypt"" name="""" value="" encryption "" /&gt;
  &lt;hr&gt;
  ciphertext &lt;textarea id=""sourceS"" value="""" width=""400px"" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  After decryption &lt;textarea id=""jiemi"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
   &lt;input type=""button"" id=""js-decrypt"" name="""" value="" Decrypt ""/&gt;
&lt;!--   &lt;input type=""button"" onclick=""test1();"" name="""" value="" Decrypt ""/&gt;
 --&gt;  &lt;/div&gt;
  &lt;/body&gt;
  &lt;script type=""text/javascript""&gt;
var key = 'E821752166E916AEEF940855';
//CBC Mode encryption 

function encryptByDESModeCBC(message) {
    var ivHex = 'E8217521';//CryptoJS.enc.Utf8.parse(key);
    console.log(ivHex);
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    console.log(encrypted.toString());
    return encrypted.toString();

}


function decryptByDESModeCBC(ciphertext) {
    var keyHex = CryptoJS.enc.Utf8.parse(key);
    // direct decrypt ciphertext
    var decrypted = CryptoJS.DES.decrypt({
        ciphertext: CryptoJS.enc.Base64.parse(ciphertext)
    }, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    return decrypted.toString(CryptoJS.enc.Utf8);
}



$(document).on('click','#js-encypt',function(){
   var source = $(""#source"").val();
   var cc = encryptByDESModeCBC(CryptoJS.enc.Utf8.parse(source));
   $(""#target"").val(cc);
});

$(document).on('click','#js-decrypt',function(){
 var source = $(""#sourceS"").val();
 var dd = decryptByDESModeCBC(source);
 $(""#jiemi"").val(dd);
})

&lt;/script&gt;
  &lt;/html&gt;
</code></pre>
","3123","<javascript><cryptojs><tripledes><cbc-mode>","-1","0","2","2019-09-08 15:37:57","","0","","","","","2018-04-03 05:37:07",""
"49622946","CryptoJs + TripleDES encryption and Decryption with CBC Mode using Javascript","<p>I am trying to encrypt given plain text by Triple DES algorithm with CBC mode, but unable to get Desired Cipher Text which i have given below.</p>

<p>I need this encryption and decryption by CryptoJs using Javascript, but unable to do this. </p>

<p><strong>Plain Text:</strong> ""AN=1234567890;EA=test@mycompany.com;TS=2009-06-03 17:04:39""
<strong>Desired Cipher Text:</strong> ""LK0Y/C2GWAfVguTEwFBIzlLBKsp4v61yHCUTj0iKtxcG60Hzprx/zlCofYHsjYWnJt78ao9l6cA7TE
fIl+u0QA==""</p>

<p>Key = ""1234567890ABCDEFGHIJKLMN""</p>

<p>IV = ""12345678""</p>

<p>Mode: ""CBC""</p>

<p>Algorithm : ""TripleDES""</p>

<p>Javascript Code: </p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Testing Encryption &amp; Decryption&lt;/title&gt;
&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/core.js""&gt; 
&lt;/script&gt;
&lt;script src=""http://cdn.bootcss.com/crypto-js/3.1.2/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/rollups/tripledes.js""&gt; 
&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/mode-ecb.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.bootcss.com/crypto-js/3.1.2/components/pad-nopadding.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
var key = 'E821752166E916AEEF940855';
//CBC Mode encryption 
function encryptByDESModeCBC(message) {
var keyHex = CryptoJS.enc.Utf8.parse(key);
var ivHex = 'E8217521';//CryptoJS.enc.Utf8.parse(key);
console.log(ivHex);
encrypted = CryptoJS.DES.encrypt(message, keyHex, {
iv:ivHex,
mode: CryptoJS.mode.CBC
}
);
return encrypted.ciphertext.toString(); 
//CBC Schema decryption 
function decryptByDESModeCBC(ciphertext2) {
var keyHex = CryptoJS.enc.Utf8.parse(key);
var ivHex = CryptoJS.enc.Utf8.parse(key);
// direct decrypt ciphertext
var decrypted = CryptoJS.DES.decrypt({
ciphertext: CryptoJS.enc.Hex.parse(ciphertext2)
}, keyHex, {
iv:ivHex,
mode: CryptoJS.mode.CBC
});
return decrypted.toString(CryptoJS.enc.Utf8);
}
function test(){
 var source = $(""#source"").val();
 var cc = encryptByDESModeCBC(CryptoJS.enc.Utf8.parse(source));
 $(""#target"").val(cc);
}
function test1(){
var source = $(""#sourceS"").val();
var dd = decryptByDESModeCBC(source);
$(""#jiemi"").val(dd);
}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    Before encryption &lt;textarea id=""source"" value="""" 
     style=""width:500px;height:90px;"" /&gt;&lt;/textarea&gt;
   &lt;hr&gt;
  After encryption &lt;textarea id=""target"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  &lt;input type=""button"" onclick=""test();"" name="""" value="" encryption "" /&gt;
  &lt;hr&gt;
  ciphertext &lt;textarea id=""sourceS"" value="""" width=""400px"" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  After decryption &lt;textarea id=""jiemi"" value="""" 
  style=""width:500px;height:90px;"" &gt;&lt;/textarea&gt;
  &lt;hr&gt;
  &lt;input type=""button"" onclick=""test1();"" name="""" value="" Decrypt ""/&gt;
  &lt;/div&gt;
  &lt;/body&gt;
  &lt;/html&gt;
</code></pre>
","<p>Just use CryptoJS's TripleDes method (<code>CryptoJS.TripleDES.encrypt</code>) to encrypt. Should do the work. This matches what you want as you mentioned in your question.</p>

<p>Make sure to parse as UTF-8.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let data = ""AN=1234567890;EA=test@mycompany.com;TS=2009-06-03 17:04:39""
let key = ""1234567890ABCDEFGHIJKLMN""
let IV = ""12345678""
let cipher = CryptoJS.TripleDES.encrypt(data, CryptoJS.enc.Utf8.parse(key), {
  iv: CryptoJS.enc.Utf8.parse(IV),
  mode: CryptoJS.mode.CBC
});

console.log(cipher.toString())</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","3123","<javascript><cryptojs><tripledes><cbc-mode>","-1","0","2","2019-09-08 15:37:57","","0","","","","","2018-04-03 05:37:07",""
"34110192","How to encode md5 sum to base64 in Javascript","<p>I have a login web form, user writes his password and I must encrypt it on MD5 and the sum to base 64. I'm doing like this with CryptoJS:</p>

<pre><code>var hash = CryptoJS.MD5(cred.password); // password is `password`
cred.password = hash.toString(CryptoJS.enc.Base64); // X03MO1qnZdYdgyfeuILPmQ==  --  IT IS OK!
</code></pre>

<p>This works fine. Then I must convert the following string to MD5 and Base64 too:</p>

<pre><code>var digest = ""john.doe,""+hash.toString()+"",QCiTzbXCAYA3AvDgYN3MuBwY/1i89q6TfW7aVS1Av1c="";
</code></pre>

<p>again I do:</p>

<pre><code>var hash1 = CryptoJS.MD5(digest);
digestResult = hash1.toString(CryptoJS.enc.Base64);
</code></pre>

<p>It returns <code>i4a9M2b6l+yBZLHc3bXWMA==</code> but the expected by the server for this conbination is <code>6R1HZqYJFfRQUA0L/hqCEA==</code></p>

<p>I guess Crypto is not working for a base64/md5 inside the string to convert?</p>

<p>I dont get why it returns bad</p>
","<p>The function <code>CryptoJS.MD5(cred.password)</code> returns a <code>typedArray</code>, not a string. It has a <code>toString</code> function which returns the common hexadecimal representation. All of that won't fit very well together. You'll need to probe the client/server strings to see what one sends and the other accepts but you should use the hexadecimal string representation all the way up to the final base64 encoding, mixing them is not very healthy.
<strong>EDIT</strong> after some comments given by the OP</p>

<pre><code>var hash = CryptoJS.MD5(cred.password); // password is `password`
// ""hash"" contains a typed array, needs to be base64
hash = hash.toString(CryptoJS.enc.Base64); // X01jw2Jap2XWHYMn3riCz5k=
var digest = ""john.doe,""+hash+"",QCiTzbXCAYA3AvDgYN3MuBwY/1i89q6TfW7aVS1Av1c="";
digest = CryptoJS.MD5(digest);
digest = digest.toString(CryptoJS.enc.Base64); // jH+dH56sKswaDDfeCzDY0A==
// send ""digest"" to server
</code></pre>

<p>Cannot go further without knowledge of server-side code.</p>
","3118","<javascript><base64><md5><cryptojs>","0","4","1","2015-12-05 21:15:43","34110413","6","2","760180","","2015-12-05 20:29:50","2015-12-05 20:00:14",""
"51239747","CryptoJS : key.clamp is not a function","<pre><code>TypeError: key.clamp is not a function
  at Object.init (path/node_modules/crypto-js/hmac.js:58:18)
</code></pre>

<p>The error above occurs when I try to create JWT in Javascript with the relevant code below.</p>

<pre><code>const CryptoJS = require('crypto-js');
var hash = CryptoJS.HmacSHA256(token.join("".""), secret);
</code></pre>

<p>crypto-js/hmac.js:58:18 has <code>key.clamp();</code> and I'm not sure what would be the best approach. I tried with <code>HmacSHA512</code> but it returns the same error. </p>

<p>I'm running with <code>npm 6.1.0</code> <code>node v6.10.3</code> <code>crypto-js ^3.1.9-1</code>.</p>
","<p>From <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">their samples</a>, <code>secret</code> (or <code>key</code> as they call it), should be a <code>string</code>.</p>

<p>As such, using <code>CryptoJS</code> like this should work just fine:</p>

<pre><code>const token = ""a,b"";
const secret = ""mySecret"";
const CryptoJS = require('crypto-js');
var hash = CryptoJS.HmacSHA256(token.join("".""), secret);
console.log(hash);
</code></pre>
","3049","<javascript><jwt><cryptojs>","5","1","1","2018-07-09 07:44:15","51240380","3","","","","","2018-07-09 07:00:12",""
"51493662","How to encrypt and decrypt string/object in nodejs","<p>I would like to encrypt an object then decrypt it. The encryption works very well but the decryption fails. Below my code :</p>

<p><strong>crypto_ext.js</strong></p>

<pre><code>const crypto = require(""crypto"")
const password = ""shared_key""
const algorithm = ""aes256""

export const encrypt = (text) =&gt; {
    if(!text) return ''
    const cipher = crypto.createCipher(algorithm, password);
    let crypted = cipher.update(text, 'utf-8', 'base64');
    crypted += cipher.final('base64');
    return crypted;
}

export const decrypt = (text) =&gt; {
    if(!text) return ''
    const decipher = crypto.createDecipher(algorithm, password);
    let decrypted = decipher.update(text, 'base64', 'utf-8');
    decrypted += decipher.final('utf-8');
    return decrypted;
}
</code></pre>

<p>and in my <strong>test.js</strong>, I have :</p>

<pre><code>import {encrypt, decrypt} from './crypto_ext.js'
let test = {key1: val1, key2: val2}
test = encrypt(JSON.stringify(test)) || test
console.log(""Encrypt : "", test)
console.log(""Decrypt : "", decrypt(test)) // I should have my object as string here
</code></pre>

<p>And this is what I'm getting as error :</p>

<pre><code>Uncaught Error: unable to decrypt data
at unpad (decrypter.js:83)
at Decipher.webpackJsonp../node_modules/browserify-aes/decrypter.js.Decipher._final (decrypter.js:38)
at Decipher.webpackJsonp../node_modules/cipher-base/index.js.CipherBase._finalOrDigest (index.js:76)
at decrypt (crypto_ext.js:17)
...
</code></pre>

<p>Can you please tell me what I'm doing wrong ?</p>
","<p>Try to use 'bcrypt' package it will help you in the encryption for passwords.
If you want to encryption for Data. Then use crypto or node-rsa</p>

<p>Link <a href=""https://www.npmjs.com/package/bcrypt"" rel=""nofollow noreferrer"">npm bcrypt package</a></p>

<p><a href=""https://www.npmjs.com/package/node-rsa"" rel=""nofollow noreferrer"">Node-RSA</a></p>
","3019","<node.js><encryption><cryptojs><node-crypto>","1","-2","2","2019-04-17 11:06:50","","2","","","","","2018-07-24 08:12:00",""
"51493662","How to encrypt and decrypt string/object in nodejs","<p>I would like to encrypt an object then decrypt it. The encryption works very well but the decryption fails. Below my code :</p>

<p><strong>crypto_ext.js</strong></p>

<pre><code>const crypto = require(""crypto"")
const password = ""shared_key""
const algorithm = ""aes256""

export const encrypt = (text) =&gt; {
    if(!text) return ''
    const cipher = crypto.createCipher(algorithm, password);
    let crypted = cipher.update(text, 'utf-8', 'base64');
    crypted += cipher.final('base64');
    return crypted;
}

export const decrypt = (text) =&gt; {
    if(!text) return ''
    const decipher = crypto.createDecipher(algorithm, password);
    let decrypted = decipher.update(text, 'base64', 'utf-8');
    decrypted += decipher.final('utf-8');
    return decrypted;
}
</code></pre>

<p>and in my <strong>test.js</strong>, I have :</p>

<pre><code>import {encrypt, decrypt} from './crypto_ext.js'
let test = {key1: val1, key2: val2}
test = encrypt(JSON.stringify(test)) || test
console.log(""Encrypt : "", test)
console.log(""Decrypt : "", decrypt(test)) // I should have my object as string here
</code></pre>

<p>And this is what I'm getting as error :</p>

<pre><code>Uncaught Error: unable to decrypt data
at unpad (decrypter.js:83)
at Decipher.webpackJsonp../node_modules/browserify-aes/decrypter.js.Decipher._final (decrypter.js:38)
at Decipher.webpackJsonp../node_modules/cipher-base/index.js.CipherBase._finalOrDigest (index.js:76)
at decrypt (crypto_ext.js:17)
...
</code></pre>

<p>Can you please tell me what I'm doing wrong ?</p>
","<ol>
<li>Method <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password_options"" rel=""nofollow noreferrer"">createCipher</a> deprecated. Use <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createcipheriv_algorithm_key_iv_options"" rel=""nofollow noreferrer"">createCipheriv</a> instead.</li>
<li>Try to use <code>aes192</code> algorithm.</li>
</ol>
","3019","<node.js><encryption><cryptojs><node-crypto>","1","1","2","2019-04-17 11:06:50","","2","","","","","2018-07-24 08:12:00",""
"31888289","Decrypting AES and HMAC with PyCrypto","<p>Having a bit of trouble getting a AES cipher text to decrypt. </p>

<p>In this particular scenario, I am encrypting data on the client side with Crypto-JS and decrypting it back on a python server with PyCrypto.</p>

<p>encrypt.js:</p>

<pre><code>  var password = 'BJhtfRjKnTDTtPXUBnErKDxfkiMCOLyP';
  var data = 'mytext';

  var masterKey = CryptoJS.SHA256(password).toString();

  // Derive keys for AES and HMAC
  var length = masterKey.toString().length / 2
  var encryptionKey = masterKey.substr(0, length);
  var hmacKey = masterKey.substr(length);

  var iv = CryptoJS.lib.WordArray.random(64/8);

  var encrypted = CryptoJS.AES.encrypt(
    data,
    encryptionKey,
    {
      iv: iv,
      mode: CryptoJS.mode.CFB
    }
  );

  var concat = iv + encrypted;

  // Calculate HMAC using iv and cipher text
  var hash = CryptoJS.HmacSHA256(concat, hmacKey);

  // Put it all together
  var registrationKey = iv + encrypted + hash;

  // Encode in Base64
  var basemessage = btoa(registrationKey);
</code></pre>

<p>decrypt.py:</p>

<pre><code>class AESCipher:
    def __init__(self, key):
        key_hash = SHA256.new(key).hexdigest()
        # Derive keys
        encryption_key = key_hash[:len(key_hash)/2]
        self.key = encryption_key            
        self.hmac_key = key_hash[len(key_hash)/2:]


    def verify_hmac(self, input_cipher, hmac_key):
        # Calculate hash using inputted key
        new_hash = HMAC.new(hmac_key, digestmod=SHA256)
        new_hash.update(input_cipher)
        digest = new_hash.hexdigest()

        # Calculate hash using derived key from local password
        local_hash = HMAC.new(self.hmac_key, digestmod=SHA256)
        local_hash.update(input_cipher)
        local_digest = local_hash.hexdigest()

        return True if digest == local_digest else False


    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        hmac = enc[60:]
        cipher_text = enc[16:60]

        # Verify HMAC using concatenation of iv + cipher like in js
        verified_hmac = self.verify_hmac((iv+cipher_text), self.hmac_key)

        if verified_hmac:
            cipher = AES.new(self.key, AES.MODE_CFB, iv)
            return cipher.decrypt(cipher_text)


password = 'BJhtfRjKnTDTtPXUBnErKDxfkiMCOLyP'

input = 'long base64 registrationKey...'

cipher = AESCipher(password)
decrypted = cipher.decrypt(input)
</code></pre>

<p>I'm successful in re-calculating the HMAC but when I try and then decrypt the cipher I get something that seems encrypted with 's in the result.</p>

<p>I was getting errors about input length of cipher text but when I switched to CFB mode that fixed it so I don't think it's a padding issue.</p>
","<p>There are many problems with your code.</p>

<h1>Client (JavaScript):</h1>

<ul>
<li><p>AES has a block size of 128 bit and CFB mode expects a full block for the IV. Use</p>

<pre><code>var iv = CryptoJS.lib.WordArray.random(128/8);
</code></pre></li>
<li><p>The <code>iv</code> and <code>hash</code> variables are WordArray objects, but <code>encrypted</code> is not. When you force them to be converted to strings by concatenating them (<code>+</code>), <code>iv</code> and <code>hash</code> are Hex-encoded, but <code>encrypted</code> is formatted in an OpenSSL compatible format and Base64-encoded. You need to access the <code>ciphertext</code> property to get the encrypted WordArray:</p>

<pre><code>var concat = iv + encrypted.ciphertext;
</code></pre>

<p>and</p>

<pre><code>var registrationKey = iv + encrypted.ciphertext + hash;
</code></pre></li>
<li><p><code>registrationKey</code> is hex-encoded. There is no need to encode it again with Base64 and bloat it even more:</p>

<pre><code>var basemessage = registrationKey;
</code></pre>

<p>If you want to convert the hex encoded <code>registrationKey</code> to base64 encoding, use:</p>

<pre><code>var basemessage = CryptoJS.enc.Hex.parse(registrationKey).toString(CryptoJS.enc.Base64);
</code></pre></li>
<li><p><code>concat</code> is a hex-encoded string of the IV and ciphertext, because you forced the stringification by ""adding"" (<code>+</code>) <code>iv</code> and <code>encrypted</code>. The <code>HmacSHA256()</code> function takes either a WordArray object or a string. When you pass a string in, as you do, it will assume that the data is UTF-8 encoded and try to decode it as UTF-8. You need to parse the data yourself into a WordArray:</p>

<pre><code>var hash = CryptoJS.HmacSHA256(CryptoJS.enc.Hex.parse(concat), hmacKey);
</code></pre></li>
<li><p>The <code>CryptoJS.AES.encrypt()</code> and <code>CryptoJS.HmacSHA256()</code> expect the key either as a WordArray object or as a string. As before, if the key is supplied as a string, a UTF-8 encoding is assumed which is not the case here. You better parse the strings into WordArrays yourself:</p>

<pre><code>var encryptionKey = CryptoJS.enc.Hex.parse(masterKey.substr(0, length));
var hmacKey = CryptoJS.enc.Hex.parse(masterKey.substr(length));
</code></pre></li>
</ul>

<h1>Server (Python):</h1>

<ul>
<li><p>You're not verifying anything in <code>verify_hmac()</code>. You hash the same data with the same key twice. What you need to do is hash the IV+ciphertext and compare the result with the hash (called tag or HMAC-tag) that you slice off the full ciphertext.</p>

<pre><code>def verify_hmac(self, input_cipher, mac):
    # Calculate hash using derived key from local password
    local_hash = HMAC.new(self.hmac_key, digestmod=SHA256)
    local_hash.update(input_cipher)
    local_digest = local_hash.digest()

    return mac == local_digest
</code></pre>

<p>And later in <code>decrypt()</code>:</p>

<pre><code>verified_hmac = self.verify_hmac((iv+cipher_text), hmac)
</code></pre></li>
<li><p>You need to correctly slice off the MAC. The 60 that is hardcoded is a bad idea. Since you're using SHA-256 the MAC is 32 bytes long, so you do this</p>

<pre><code>hmac = enc[-32:]
cipher_text = enc[16:-32]
</code></pre></li>
<li><p>The CFB mode is actually a set of similar modes. The actual mode is determined by the segment size. CryptoJS only supports segments of 128 bit. So you need tell pycrypto to use the same mode as in CryptoJS:</p>

<pre><code>cipher = AES.new(self.key, AES.MODE_CFB, iv, segment_size=128)
</code></pre>

<p>If you want to use CFB mode with a segment size of 8 bit (default of pycrypto), you can use a modified version of CFB in CryptoJS from my project: <a href=""https://github.com/artjomb/cryptojs-extension#cfb"" rel=""nofollow noreferrer"">Extension for CryptoJS</a></p></li>
</ul>

<p>Full client code:</p>

<pre class=""lang-js prettyprint-override""><code>var password = 'BJhtfRjKnTDTtPXUBnErKDxfkiMCOLyP';
var data = 'mytext';

var masterKey = CryptoJS.SHA256(password).toString();
var length = masterKey.length / 2
var encryptionKey = CryptoJS.enc.Hex.parse(masterKey.substr(0, length));
var hmacKey = CryptoJS.enc.Hex.parse(masterKey.substr(length));

var iv = CryptoJS.lib.WordArray.random(128/8);

var encrypted = CryptoJS.AES.encrypt(
    data,
    encryptionKey,
    {
      iv: iv,
      mode: CryptoJS.mode.CFB
    }
);

var concat = iv + encrypted.ciphertext; 
var hash = CryptoJS.HmacSHA256(CryptoJS.enc.Hex.parse(concat), hmacKey);
var registrationKey = iv + encrypted.ciphertext + hash;
console.log(CryptoJS.enc.Hex.parse(registrationKey).toString(CryptoJS.enc.Base64));
</code></pre>

<p>Full server code:</p>

<pre><code>from Crypto.Cipher import AES
from Crypto.Hash import HMAC, SHA256
import base64
import binascii

class AESCipher:
    def __init__(self, key):
        key_hash = SHA256.new(key).hexdigest()
        self.hmac_key = binascii.unhexlify(key_hash[len(key_hash)/2:])
        self.key = binascii.unhexlify(key_hash[:len(key_hash)/2])

    def verify_hmac(self, input_cipher, mac):
        local_hash = HMAC.new(self.hmac_key, digestmod=SHA256)
        local_hash.update(input_cipher)
        local_digest = local_hash.digest()

        return SHA256.new(mac).digest() == SHA256.new(local_digest).digest() # more or less constant-time comparison

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        hmac = enc[-32:]
        cipher_text = enc[16:-32]

        verified_hmac = self.verify_hmac((iv+cipher_text), hmac)

        if verified_hmac:
            cipher = AES.new(self.key, AES.MODE_CFB, iv, segment_size=128)
            return cipher.decrypt(cipher_text)
        else:
            return 'Bad Verify'


password = 'BJhtfRjKnTDTtPXUBnErKDxfkiMCOLyP'

input = ""btu0CCFbvdYV4B/j7hezAra6Q6u6KB8n5QcyA32JFLU8QRd+jLGW0GxMQsTqxaNaNkcU2I9r1ls4QUPUpaLPQg==""

obj = AESCipher(password)
decryption = obj.decrypt(input)

print 'Decrypted message:', decryption
</code></pre>
","2958","<python><encryption><hmac><pycrypto><cryptojs>","1","7","1","2017-01-21 07:48:38","31891184","0","1","1816580","","2015-08-08 08:25:39","2015-08-08 00:11:16",""
"31230994","What's the best option using cryptojs, have the key stored in client and server sides, or generate the key and pass it some way to the other side?","<p>I want to encrypt and decrypt the data passed between the client and the server using cryptojs. To decrypt the data it is necessary to know the key used, so Imhave two options:</p>

<ul>
<li>Use a fixed key stored in both sides.</li>
<li>Generate randomly the key and pass it to the other side with the data.</li>
</ul>

<p>In both cases, if the petition is captured, you can resend it to the server and access to the page.</p>

<p>If I use a fixed key, if you get the key, you can decrypt all the messages, except if you change the key.</p>

<p>If I pass the key with the data, you get the key with the data (I pass in a no clear way, so you have to know what part is the key and what part is the data). But this key changes with every petition.</p>

<p>Anyway, I think the attacker could just see the client side code and discover the procedure used to encrypt the data and do the opposite procedure.</p>

<p>What's the best option?</p>

<p>PD: I know that https is the way, but I want tp do this too.</p>
","<p><strong>Option: 1</strong></p>

<p>Assuming that you want to use CryptoJS and you want to use HTTP, and you don't want the attacker to know the secret key, you can use <a href=""http://%60https://code.google.com/p/crypto-js/%60"" rel=""nofollow"">PBKDF2</a>.</p>

<blockquote>
  <p>PBKDF2 is a password-based key derivation function</p>
</blockquote>

<p>You can generate a key from the user's password on browser and use it to encrypt the data encryption key.  </p>

<p>On server side, assuming that you will have access to user's password from the user database, you can re-generate the same PBDKF2 key using the password and decrypt the data encryption key.</p>

<p>Once both server and client have agreed on a shared data encryption key, they can have future exchange of data using that key.  In this process, a hacker may not get access to the data encryption key as it was exchanged in encrypted form.  Also, it requires a human to enter a password whose value hacker is not aware of.</p>

<p><strong><em>NOTE 1:</strong> This solution will not work if you are authenticating user against third party authentication provider and you do not have access to user's password.</em></p>

<p><strong><em>NOTE 2:</strong> CryptoJS seems to support only symmetric ciphers - hence, there will be a need to exchange key between client and server.  The key has to be exchanged via a shared secret that is not shared using the same channel on which key will be used.</em></p>

<p><strong>Option: 2</strong></p>

<p>If you cant use PBDKF2 for some reason, and still want to exchange keys securely between client and server, then, you will have to employ asymmetric encryption.  A library <a href=""http://travistidwell.com/jsencrypt/"" rel=""nofollow"">JSEncrypt</a> provides RSA encryption.</p>

<p>If this library is employed, then, client (browser) can generate a key usng CryptoJS and encrypt it with a RSA public key using JSEncrypt and send the encrypted key to server.  Server can decrypt the encrypted-key using RSA private key.  This process will result in safe exchange of key.</p>
","2943","<javascript><encryption><cryptojs>","0","2","1","2015-07-05 17:22:13","31231595","6","1","1806780","","2015-07-05 14:38:05","2015-07-05 13:43:19","2015-07-06 07:41:34"
"11567290","CryptoJS and Pycrypto working together","<p>I'm encrypting a string in a web application using CryptoJS (v 2.3), and I need to decrypt it on the server in Python, so I'm using PyCrypto. I feel like I'm missing something because I can't can it working.</p>

<p>Here's the JS:</p>

<pre class=""lang-js prettyprint-override""><code>Crypto.AES.encrypt('1234567890123456', '1234567890123456',
                   {mode: new Crypto.mode.CBC(Crypto.pad.ZeroPadding)})
// output: ""wRbCMWcWbDTmgXKCjQ3Pd//aRasZ4mQr57DgTfIvRYE=""
</code></pre>

<p>The python:</p>

<pre class=""lang-py prettyprint-override""><code>from Crypto.Cipher import AES
import base64
decryptor = AES.new('1234567890123456', AES.MODE_CBC)
decryptor.decrypt(base64.b64decode(""wRbCMWcWbDTmgXKCjQ3Pd//aRasZ4mQr57DgTfIvRYE=""))
# output: '\xd0\xc2\x1ew\xbb\xf1\xf2\x9a\xb9\xb6\xdc\x15l\xe7\xf3\xfa\xed\xe4\xf5j\x826\xde(m\xdf\xdc_\x9e\xd3\xb1'
</code></pre>
","<p>Here is a version with CryptoJS 3.1.2. Always beware of the following things (use the same in both languages):</p>

<ul>
<li>Mode of operation (CBC in this case)</li>
<li>Padding (Zero Padding in this case; better use PKCS#7 padding)</li>
<li>Key (the same derivation function or clear key)</li>
<li>Encoding (same encoding for key, plaintext, ciphertext, ...)</li>
<li>IV (generated during encryption, passed for decryption)</li>
</ul>

<p>If a string is passed as the <code>key</code> argument to the CryptoJS <code>encrypt()</code> function, the string is used to derive the actual key to be used for encryption. If you wish to use a key (valid sizes are 16, 24 and 32 byte), then you need to pass it as a WordArray.</p>

<p>The result of the CryptoJS encryption is an OpenSSL formatted ciphertext string. To get the actual ciphertext from it, you need to access the <code>ciphertext</code> property on it.</p>

<p>The IV must be random for each encryption so that it is semantically secure. That way attackers cannot say whether the same plaintext that was encrypted multiple times is actually the same plaintext when only looking at the ciphertext.</p>

<p>Below is an example that I have made.</p>

<p>JavaScript:</p>

<pre class=""lang-js prettyprint-override""><code>var key = CryptoJS.enc.Utf8.parse('1234567890123456');

function encrypt(msgString, key) {
    // msgString is expected to be Utf8 encoded
    var iv = CryptoJS.lib.WordArray.random(16);
    var encrypted = CryptoJS.AES.encrypt(msgString, key, {
        iv: iv
    });
    return iv.concat(encrypted.ciphertext).toString(CryptoJS.enc.Base64);
}

function decrypt(ciphertextStr, key) {
    var ciphertext = CryptoJS.enc.Base64.parse(ciphertextStr);

    // split IV and ciphertext
    var iv = ciphertext.clone();
    iv.sigBytes = 16;
    iv.clamp();
    ciphertext.words.splice(0, 4); // delete 4 words = 16 bytes
    ciphertext.sigBytes -= 16;

    // decryption
    var decrypted = CryptoJS.AES.decrypt({ciphertext: ciphertext}, key, {
        iv: iv
    });
    return decrypted.toString(CryptoJS.enc.Utf8);
}
</code></pre>

<p>Python code:</p>

<pre class=""lang-py prettyprint-override""><code>BLOCK_SIZE = 16
key = b""1234567890123456""

def pad(data):
    length = BLOCK_SIZE - (len(data) % BLOCK_SIZE)
    return data + chr(length)*length

def unpad(data):
    return data[:-ord(data[-1])]

def encrypt(message, passphrase):
    IV = Random.new().read(BLOCK_SIZE)
    aes = AES.new(passphrase, AES.MODE_CBC, IV)
    return base64.b64encode(IV + aes.encrypt(pad(message)))

def decrypt(encrypted, passphrase):
    encrypted = base64.b64decode(encrypted)
    IV = encrypted[:BLOCK_SIZE]
    aes = AES.new(passphrase, AES.MODE_CBC, IV)
    return unpad(aes.decrypt(encrypted[BLOCK_SIZE:]))
</code></pre>

<hr>

<p><strong>Other considerations:</strong></p>

<p>It seems that you want to use a passphrase as a key. Passphrases are usually human readable, but keys are not. You can derive a key from a passphrase with functions such as PBKDF2, bcrypt or scrypt.</p>

<p>The code above is not fully secure, because it lacks authentication. Unauthenticated ciphertexts may lead to viable attacks and unnoticed data manipulation. Usually the an encrypt-then-MAC scheme is employed with a good MAC function such as HMAC-SHA256.</p>
","2908","<javascript><python><encryption><pycrypto><cryptojs>","0","5","1","2019-04-10 05:35:49","31011115","2","","1816580","","2015-06-23 18:52:29","2012-07-19 18:42:58",""
"21847182","Decipher an AES enciphered binary file with Crypto.JS","<p><strong>What I'm trying to achieve</strong></p>

<p>I'm working on a browser based quiz game with prerecorded audio clues which get sent to the user. To take load of the servers as well as having the audio already transmitted the files are already sent way earlier before the game starts to the user. As the game is to be played in real time and competetively, it is of importance that the player has no chance to listen to the audio files before. My idea now was to basically send AES enciphered files to the user, send only the password of the file in real time over websockets, decipher it in the browser using <strong>crypto.js</strong> and play it instantly.</p>

<p><strong>The Problem</strong></p>

<p>For some reason I can't get binary files decrypted properly using crypto.js so I can feed it into decodeAudioData of an audio context. I get empty responses from decrypt or gibberish back.</p>

<p><strong>What I tried</strong></p>

<p>The audio (in this case an mp3) is AES encrypted according to the docs using the following call:</p>

<pre><code>openssl enc -aes-256-cbc -in infile -out outfile -pass pass:""testpass"" -e -base64
</code></pre>

<p>The resulting file is then loaded via XMLHTTPRequest with request type text (I already tried arraybuffer but failed too) and the result is stored in a variable (<code>this.protectedBuffer</code>).</p>

<p>According to Crypto.js docs, this should now decrypt the file:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(this.protectedBuffer, 'testpass');
// next step obviously doesn't work as decrypted is
// is not an arraybuffer.
context.decodeAudioData(decrypted, function() { ... }); 
</code></pre>

<p>This however results in nothing playable and returns only a wordlist. I know I'm missing some step but I have absolutely no clue right now what is not working and would be more than glad if someone could point me in the right direction and tell me what I did wrong.</p>

<p><strong>EDIT:</strong> Here is a jsfiddle with what I'm trying to achieve <a href=""http://jsfiddle.net/HKu3n/1/"" rel=""nofollow"">http://jsfiddle.net/HKu3n/1/</a></p>
","<p>When <code>openssl</code> generates a base64-encoded file, it inserts a lot of whitespace.  In particular, it breaks the output up into 64-byte lines:</p>

<pre class=""lang-none prettyprint-override""><code>U2FsdGVkX18AVcl/JumJawmKlaYWjQwo6wDcETza5AX6VK6aVCMtHXic2xtDIw1G
PJfxbKLJKWgvKXLNGO0jgPTI6qFPllts6VAIzvZ3uqV8BBPd0ge4YJe/q7e7ZGmx
QJyvFnyumo3b2pMxxMWngtl8qpxcsaiSrALnBXZizJ70PcTsyfk7aym1twkj0ofY
...
</code></pre>

<p>And at the end, a final newline.  The <code>crypto-js</code> encryption utilities do not like all of that whitespace, so you must remove it (which I do with a split/join).  For example:</p>

<pre><code>$.get('/audio.aes', function(data){
    var decrypted = CryptoJS.AES.decrypt(data.split(/\s/).join(''), 'testpass');
    // ...
});
</code></pre>

<p>What <code>CryptoJS.AES.decrypt</code> returns is a <code>WordArray</code> object.  To convert it to a string, you must call <code>toString</code> and provide an encoding:</p>

<pre><code>decrypted.toString(CryptoJS.enc.Utf8);
decrypted.toString(CryptoJS.enc.Base64);
</code></pre>

<p>I didn't have any audio files handy, but I was able to make this work end-to-end with an image (served up at <code>/image.aes</code>):</p>

<pre><code>$.get('/image.aes', function(data){
    var decrypted = CryptoJS.AES.decrypt(data.split(/\s/).join(''), 'testpass');
    $('#imageContainer').append('&lt;img src=""data:image/jpeg;base64,'
        + decrypted.toString(CryptoJS.enc.Base64) + '""&gt;');
    });
});
</code></pre>

<p>And I saw an image on the other end!  You might have to get some wrangling to get the decoded data into the right format for your audio output, but I hope this will get you over the hump.</p>

<p><strong>UPDATE</strong></p>

<p>I got it working with your example jsFiddle, using your audio.  To get the <code>ArrayBuffer</code> necessary, I used <code>base64DecToArr</code> available <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding#Appendix.3A_Decode_a_Base64_string_to_Uint8Array_or_ArrayBuffer"" rel=""nofollow"">here</a>:</p>

<pre><code>var decoded = CryptoJS.AES.decrypt(request.response.split(/\s/).join(''),
    'testpass');

var arr = base64DecToArr(decoded.toString(CryptoJS.enc.Base64));
context.decodeAudioData(arr.buffer, function (buffer) {
    alert('success decoding buffer');
}, function (err) {
    alert('couldn\'t decode buffer');
});
</code></pre>

<p>Working jsFiddle here: <a href=""http://jsfiddle.net/BTnpL/"" rel=""nofollow"">http://jsfiddle.net/BTnpL/</a></p>

<p>There's probably a more efficient way to convert the <code>WordArray</code> object returned from the <code>crypto-js</code> functions to the <code>ArrayBuffer</code> used by <code>decodeAudioData</code>, but I'll leave that as an exercise for you.</p>
","2904","<javascript><aes><binaryfiles><cryptojs><arraybuffer>","0","2","1","2014-02-18 08:58:57","21848309","4","3","1753412","","2014-02-18 08:24:52","2014-02-18 07:43:29",""
"37187554","Crypto-js lib is not available anymore","<p>I have used following library for many years and now it is not available.
<a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js</a></p>

<p>Can someone help to find alternative?</p>
","<p>Download the library sources you need from here: <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow"">https://code.google.com/archive/p/crypto-js/downloads</a></p>

<p>Then put them on your own server ... then replace
<a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js</a>
by
/directory_where_you_put_the_download/rollups/md5.js</p>

<p>It works for me.</p>
","2889","<cryptojs>","2","4","2","2019-07-26 12:39:34","37216529","1","","","","","2016-05-12 12:54:47",""
"37187554","Crypto-js lib is not available anymore","<p>I have used following library for many years and now it is not available.
<a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/md5.js</a></p>

<p>Can someone help to find alternative?</p>
","<p>It is still hosted on cdnjs, I found the working URLs for it  See my answer <a href=""https://stackoverflow.com/questions/14733374/how-to-generate-an-md5-file-hash-in-javascript/57220077#57220077"">How to generate an MD5 file hash in JavaScript?</a></p>

<p>the URLs to the individual js files such as md5.js have changed(and besides that , you need to load core.js first)</p>

<p>try <code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core.js""&gt;&lt;/script&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/md5.js""&gt;&lt;/script&gt;</code> and see <a href=""https://cdnjs.com/libraries/crypto-js"" rel=""nofollow noreferrer"">https://cdnjs.com/libraries/crypto-js</a> for URLs</p>

<p>and you can use code such as e.g.</p>

<pre><code>var hash = CryptoJS.MD5(""Message"");
console.log(hash);
</code></pre>
","2889","<cryptojs>","2","0","2","2019-07-26 12:39:34","37216529","1","","","","","2016-05-12 12:54:47",""
"39112096","Calcuate MD5 hash of a large file using javascript","<p>How do you upload a 500mb file and get a MD5 hash with CryptoJS?</p>

<p>Here is my code:</p>

<pre><code>$('#upload-file').change(function(){
    var reader = new FileReader();
    reader.addEventListener('load',function () {
        var hash = CryptoJS.MD5(CryptoJS.enc.Latin1.parse(this.result));
        window.md5 = hash.toString(CryptoJS.enc.Hex);
    });

    reader.readAsBinaryString(this.files[0]);
});
</code></pre>

<p>If the file is under 200mb, it works. Anything bigger, this.result is an empty """".</p>

<p>I've tried:</p>

<p><a href=""https://stackoverflow.com/questions/25810051/filereader-api-on-big-files"">filereader api on big files</a></p>

<p><a href=""https://stackoverflow.com/questions/14438187/javascript-filereader-parsing-long-file-in-chunks"">javascript FileReader - parsing long file in chunks</a></p>

<p>and almost got this to work , but console is complaining about .join("""")</p>

<p><a href=""http://dojo4.com/blog/processing-huge-files-with-an-html5-file-input"" rel=""nofollow noreferrer"">http://dojo4.com/blog/processing-huge-files-with-an-html5-file-input</a></p>
","<p>You don't need to read the whole file at once and feed it all in one go to CryptoJS routines.</p>

<p>You can create the hasher object, and feed chunks as you read them, and then get the final result.</p>

<p>Sample taken from the <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">CryptoJS documentation</a></p>

<pre><code>var sha256 = CryptoJS.algo.SHA256.create();
sha256.update(""Message Part 1"");
sha256.update(""Message Part 2"");
sha256.update(""Message Part 3"");
var hash = sha256.finalize();
</code></pre>
","2888","<javascript><md5><filereader><cryptojs>","1","0","2","2016-08-24 03:05:05","39112502","2","3","-1","","2017-05-23 12:09:02","2016-08-23 23:14:43",""
"39112096","Calcuate MD5 hash of a large file using javascript","<p>How do you upload a 500mb file and get a MD5 hash with CryptoJS?</p>

<p>Here is my code:</p>

<pre><code>$('#upload-file').change(function(){
    var reader = new FileReader();
    reader.addEventListener('load',function () {
        var hash = CryptoJS.MD5(CryptoJS.enc.Latin1.parse(this.result));
        window.md5 = hash.toString(CryptoJS.enc.Hex);
    });

    reader.readAsBinaryString(this.files[0]);
});
</code></pre>

<p>If the file is under 200mb, it works. Anything bigger, this.result is an empty """".</p>

<p>I've tried:</p>

<p><a href=""https://stackoverflow.com/questions/25810051/filereader-api-on-big-files"">filereader api on big files</a></p>

<p><a href=""https://stackoverflow.com/questions/14438187/javascript-filereader-parsing-long-file-in-chunks"">javascript FileReader - parsing long file in chunks</a></p>

<p>and almost got this to work , but console is complaining about .join("""")</p>

<p><a href=""http://dojo4.com/blog/processing-huge-files-with-an-html5-file-input"" rel=""nofollow noreferrer"">http://dojo4.com/blog/processing-huge-files-with-an-html5-file-input</a></p>
","<p>CryptoJS has a <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""noreferrer"">progressive api for hash digests</a>. The rest is taken form <a href=""https://stackoverflow.com/a/28318964/5108418"">alediaferia's answer</a> with slight modifications.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function process() {
  getMD5(
    document.getElementById(""my-file-input"").files[0],
    prog =&gt; console.log(""Progress: "" + prog)
  ).then(
    res =&gt; console.log(res),
    err =&gt; console.error(err)
  );
}

function readChunked(file, chunkCallback, endCallback) {
  var fileSize   = file.size;
  var chunkSize  = 4 * 1024 * 1024; // 4MB
  var offset     = 0;
  
  var reader = new FileReader();
  reader.onload = function() {
    if (reader.error) {
      endCallback(reader.error || {});
      return;
    }
    offset += reader.result.length;
    // callback for handling read chunk
    // TODO: handle errors
    chunkCallback(reader.result, offset, fileSize); 
    if (offset &gt;= fileSize) {
      endCallback(null);
      return;
    }
    readNext();
  };

  reader.onerror = function(err) {
    endCallback(err || {});
  };

  function readNext() {
    var fileSlice = file.slice(offset, offset + chunkSize);
    reader.readAsBinaryString(fileSlice);
  }
  readNext();
}

function getMD5(blob, cbProgress) {
  return new Promise((resolve, reject) =&gt; {
    var md5 = CryptoJS.algo.MD5.create();
    readChunked(blob, (chunk, offs, total) =&gt; {
      md5.update(CryptoJS.enc.Latin1.parse(chunk));
      if (cbProgress) {
        cbProgress(offs / total);
      }
    }, err =&gt; {
      if (err) {
        reject(err);
      } else {
        // TODO: Handle errors
        var hash = md5.finalize();
        var hashHex = hash.toString(CryptoJS.enc.Hex);
        resolve(hashHex);
      }
    });
  });
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/md5.js""&gt;&lt;/script&gt;
&lt;input id=""my-file-input"" type=""file""&gt;
&lt;button onclick=""process()""&gt;Process&lt;/button&gt;</code></pre>
</div>
</div>
</p>
","2888","<javascript><md5><filereader><cryptojs>","1","9","2","2016-08-24 03:05:05","39112502","2","3","-1","","2017-05-23 12:09:02","2016-08-23 23:14:43",""
"39080204","crypto: var keyWords = key.words: TypeError: Cannot read property 'words' of undefined","<p>having an issue using crypto.  i'm pretty sure my issue is on line 75 in the saveAccounts function.  I believe at this point the accounts var will consist of an empty [] as assigned in the getAccounts function (since there is nothing to 'getItemSync' from 'accounts' in 'storage'.  I have a feeling the problem has something to do with the format of the data i'm trying to encrypt but i can't wrap my head around it. been trouble shooting for some time now.  days.  full-error report at below my code.</p>

<pre><code>console.log('starting password manager');
var crypto = require(""crypto-js"");
var storage = require('node-persist');
storage.initSync();

var argv = require('yargs')
    .command('create', 'Create a new account', function(yargs){
        yargs.options({
            name: {
                demand: true,
                alias: 'n',
                description: ""Account name (eg: Github, SnapChat)."",
                type: 'string'
            },
            username: {
                demand: true,
                alias: 'u',
                description: ""Please provide a username for your account."",
                type: 'string'
            },
            password: {
                demand: true,
                alias: 'p',
                description: ""Please provide a password for your account."",
                type: 'string'
            },
            masterPassword: {
                demand: true,
                alias: 'm',
                description: ""Please provide a MASTER password."",
                type: 'string'
            }
        }).help('help');
    })
    .command('get', 'Get an existing account', function(yargs){
        yargs.options({
            name: {
                demand: true,
                alias: 'n',
                description: ""Account name (eg: Github, SnapChat)."",
                type: 'string'
            },
            masterPassword: {
                demand: true,
                alias: 'm',
                description: ""Please provide a MASTER password."",
                type: 'string'
            }
        }).help('help');
    })
    .help('help')
    .argv;


var command = argv._[0];


function getAccounts (masterPassword){
    console.log(""function getAccounts has been run"");
    var encryptedAccount = storage.getItemSync('accounts');
    var accounts = [];
    // decrypt
    if (typeof encryptedAccount !== 'undefined') {
        var bytes = crypto.AES.decrypt(encryptedAccount, masterPassword);
        accounts = JSON.parse(bytes.toString(crypto.enc.Utf8));
    }

    // return accoutns array
    return accounts;
}

function saveAccounts (accounts, masterPassword){
    console.log(""function saveAccounts has been run"");
    // encrypt accounts
    var encryptedAccounts = crypto.AES.encrypt(JSON.stringify(accounts), masterPassword);
    // setItemSync
    storage.setItemSync('accounts', encryptedAccounts.toString());
    // return accounts
    return accounts;
}


function createAccount(account, masterPassword){
    var accounts = getAccounts(masterPassword);

    accounts.push(account);
    console.log(""back to function createAccount"");
    saveAccounts(account, masterPassword);
}


function getAccount(accountName, masterPassword){
    var accounts = getAccounts(masterPassword);
    var matchedAccount;

    accounts.forEach(function(account){
        if (account.name === accountName) {
            matchedAccount = account;
        }
    });

    return matchedAccount;
}




if (command === ""create"") {
    var createdAccount = createAccount({
        name: argv.name,
        username: argv.username,
        password: argv.password
    }, argv.masterPassword);
    console.log('Account created!');
    console.log(createdAccount);
} else if (command === ""get"") {
    if (masterPassword !== argv.m || typeof masterPassword === undefined) {
        console.log(""Your password was incorrect."");
    } else {
    var accountReturned = getAccount(argv.name, argv.masterPassword);
        if(typeof(accountReturned) === undefined){
            console.log(""This account doesn't exist."");
        } else {
        console.log(""Your account info:"");
        console.log(accountReturned);
        }
    }
}
</code></pre>

<p>the full error code looks like this</p>

<pre><code>starting password manager
function getAccounts has been run
back to function createAccount
function saveAccounts has been run
/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/aes.js:96
                var keyWords = key.words;
                                  ^

TypeError: Cannot read property 'words' of undefined
    at Object.C_algo.AES.BlockCipher.extend._doReset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/aes.js:96:32)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.reset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:119:19)
    at Object.CryptoJS.lib.Cipher.C_lib.BlockCipher.Cipher.extend.reset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:457:27)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:104:19)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.C_lib.Base.create (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:95:32)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.createEncryptor (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:63:26)
    at Object.CryptoJS.lib.Cipher.C_lib.SerializableCipher.Base.extend.encrypt (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:669:37)
</code></pre>
","<p>You should compare typeof to the string  'undefined'.  <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof"" rel=""nofollow noreferrer"">See typeof docs</a>    </p>

<pre><code>else if (command === ""get"") {
if (masterPassword !== argv.m || typeof masterPassword === 'undefined') {
    console.log(""Your password was incorrect."");
} else {
var accountReturned = getAccount(argv.name, argv.masterPassword);
    if(typeof(accountReturned) === 'undefined'){
        console.log(""This account doesn't exist."");
    } else {
    console.log(""Your account info:"");
    console.log(accountReturned);
    }
}
</code></pre>

<p>I am working on the same Udemy course I think. Good luck!</p>
","2886","<javascript><node.js><npm><cryptojs>","0","0","2","2017-04-16 01:00:03","41047602","4","","","","","2016-08-22 12:57:49",""
"39080204","crypto: var keyWords = key.words: TypeError: Cannot read property 'words' of undefined","<p>having an issue using crypto.  i'm pretty sure my issue is on line 75 in the saveAccounts function.  I believe at this point the accounts var will consist of an empty [] as assigned in the getAccounts function (since there is nothing to 'getItemSync' from 'accounts' in 'storage'.  I have a feeling the problem has something to do with the format of the data i'm trying to encrypt but i can't wrap my head around it. been trouble shooting for some time now.  days.  full-error report at below my code.</p>

<pre><code>console.log('starting password manager');
var crypto = require(""crypto-js"");
var storage = require('node-persist');
storage.initSync();

var argv = require('yargs')
    .command('create', 'Create a new account', function(yargs){
        yargs.options({
            name: {
                demand: true,
                alias: 'n',
                description: ""Account name (eg: Github, SnapChat)."",
                type: 'string'
            },
            username: {
                demand: true,
                alias: 'u',
                description: ""Please provide a username for your account."",
                type: 'string'
            },
            password: {
                demand: true,
                alias: 'p',
                description: ""Please provide a password for your account."",
                type: 'string'
            },
            masterPassword: {
                demand: true,
                alias: 'm',
                description: ""Please provide a MASTER password."",
                type: 'string'
            }
        }).help('help');
    })
    .command('get', 'Get an existing account', function(yargs){
        yargs.options({
            name: {
                demand: true,
                alias: 'n',
                description: ""Account name (eg: Github, SnapChat)."",
                type: 'string'
            },
            masterPassword: {
                demand: true,
                alias: 'm',
                description: ""Please provide a MASTER password."",
                type: 'string'
            }
        }).help('help');
    })
    .help('help')
    .argv;


var command = argv._[0];


function getAccounts (masterPassword){
    console.log(""function getAccounts has been run"");
    var encryptedAccount = storage.getItemSync('accounts');
    var accounts = [];
    // decrypt
    if (typeof encryptedAccount !== 'undefined') {
        var bytes = crypto.AES.decrypt(encryptedAccount, masterPassword);
        accounts = JSON.parse(bytes.toString(crypto.enc.Utf8));
    }

    // return accoutns array
    return accounts;
}

function saveAccounts (accounts, masterPassword){
    console.log(""function saveAccounts has been run"");
    // encrypt accounts
    var encryptedAccounts = crypto.AES.encrypt(JSON.stringify(accounts), masterPassword);
    // setItemSync
    storage.setItemSync('accounts', encryptedAccounts.toString());
    // return accounts
    return accounts;
}


function createAccount(account, masterPassword){
    var accounts = getAccounts(masterPassword);

    accounts.push(account);
    console.log(""back to function createAccount"");
    saveAccounts(account, masterPassword);
}


function getAccount(accountName, masterPassword){
    var accounts = getAccounts(masterPassword);
    var matchedAccount;

    accounts.forEach(function(account){
        if (account.name === accountName) {
            matchedAccount = account;
        }
    });

    return matchedAccount;
}




if (command === ""create"") {
    var createdAccount = createAccount({
        name: argv.name,
        username: argv.username,
        password: argv.password
    }, argv.masterPassword);
    console.log('Account created!');
    console.log(createdAccount);
} else if (command === ""get"") {
    if (masterPassword !== argv.m || typeof masterPassword === undefined) {
        console.log(""Your password was incorrect."");
    } else {
    var accountReturned = getAccount(argv.name, argv.masterPassword);
        if(typeof(accountReturned) === undefined){
            console.log(""This account doesn't exist."");
        } else {
        console.log(""Your account info:"");
        console.log(accountReturned);
        }
    }
}
</code></pre>

<p>the full error code looks like this</p>

<pre><code>starting password manager
function getAccounts has been run
back to function createAccount
function saveAccounts has been run
/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/aes.js:96
                var keyWords = key.words;
                                  ^

TypeError: Cannot read property 'words' of undefined
    at Object.C_algo.AES.BlockCipher.extend._doReset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/aes.js:96:32)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.reset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:119:19)
    at Object.CryptoJS.lib.Cipher.C_lib.BlockCipher.Cipher.extend.reset (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:457:27)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:104:19)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.subtype.init (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:68:46)
    at Object.C_lib.Base.create (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/core.js:95:32)
    at Object.CryptoJS.lib.Cipher.C_lib.Cipher.BufferedBlockAlgorithm.extend.createEncryptor (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:63:26)
    at Object.CryptoJS.lib.Cipher.C_lib.SerializableCipher.Base.extend.encrypt (/media/david/08053ee9-7733-4986-97be-f5cac7a80746/david/Projects/Node-Password-Manager/node_modules/crypto-js/cipher-core.js:669:37)
</code></pre>
","<p>I had the same problem, and after trying different things, I found the error was the type of object to encrypt. ---> <code>$crypto.encrypt(""string"",""string"")</code>. Simple as that. When you try to decrypt with an object instead of string, you get that error. </p>
","2886","<javascript><node.js><npm><cryptojs>","0","0","2","2017-04-16 01:00:03","41047602","4","","","","","2016-08-22 12:57:49",""
"31123925","Is binary hashing possible with CryptoJS?","<p>I want to create an HOTP client using javascript similar to <a href=""https://github.com/markbao/speakeasy/blob/master/lib/speakeasy.js"" rel=""nofollow"">SpeakEasy</a></p>

<p>The above library is intended for server side javascript usage and it uses NodeJS.</p>

<p>I want to do the same thing on front end javascript in a browser but I haven't been able to use CryptoJS to achieve this behavior. </p>

<pre><code>         var key = ""abc"";
         var counter = ""123"";

         // create an octet array from the counter
         var octet_array = new Array(8);

         var counter_temp = counter;

         for (var i = 0; i &lt; 8; i++) {
             var i_from_right = 7 - i;

             // mask 255 over number to get last 8
             octet_array[i_from_right] = counter_temp &amp; 255;

             // shift 8 and get ready to loop over the next batch of 8
             counter_temp = counter_temp &gt;&gt; 8;
         }

        // There is no such class called as Buffer on Browsers (its node js)
         var counter_buffer = new Buffer(octet_array);

         var hash = CryptoJS.HmacSHA1(key,counter_buffer);

         document.write(""hex value ""+ hash);
         document.write(""hash value ""+    CryptoJS.enc.Hex.stringify(hash));
</code></pre>

<p>I know this is possible on a native platform like java (android) or objective c (ios) 
Here is the corresponding implementation <a href=""http://oathtoken.googlecode.com/svn-history/r42/trunk/Classes/HOTP.m"" rel=""nofollow"">HOTP in Objective C</a> but I doubt if it's possible to do on a web based front end. </p>

<p>Also, I highly doubt if such a thing is secure in browser because javascript is viewable from any browser. Any inputs suggestions would be useful. I am doing this for a POC. I am curious if anyone has used Hotp on web based platform.</p>
","<p>There is no such language that supports binary data strings in the code. You need to encode the binary data into some format such as Hex or Base64 and let CryptoJS decode it into it's own internal binary format which you then can pass to the various CryptoJS functions:</p>

<pre><code>var wordArrayFromUtf = CryptoJS.enc.Utf8.parse(""test"");
var wordArrayFromHex = CryptoJS.enc.Hex.parse(""74657374""); // ""test""
var wordArrayFromB64 = CryptoJS.enc.Base64.parse(""dGVzdA==""); // ""test""
</code></pre>

<p>Other functions are:</p>

<pre><code>wordArrayFromHex.toString(CryptoJS.enc.Utf8)  // ""test""
CryptoJS.enc.Utf8.stringify(wordArrayFromB64) // ""test""
</code></pre>

<p>If you pass a string into a CrypoJS function (not these here), it will be assumed to be a Utf8-encoded string. If you don't want that, you need to decode it yourself.</p>
","2795","<javascript><hash><sha><cryptojs><one-time-password>","3","3","2","2015-06-30 06:47:07","31124690","5","","1816580","","2015-06-30 06:47:07","2015-06-29 19:26:27",""
"31123925","Is binary hashing possible with CryptoJS?","<p>I want to create an HOTP client using javascript similar to <a href=""https://github.com/markbao/speakeasy/blob/master/lib/speakeasy.js"" rel=""nofollow"">SpeakEasy</a></p>

<p>The above library is intended for server side javascript usage and it uses NodeJS.</p>

<p>I want to do the same thing on front end javascript in a browser but I haven't been able to use CryptoJS to achieve this behavior. </p>

<pre><code>         var key = ""abc"";
         var counter = ""123"";

         // create an octet array from the counter
         var octet_array = new Array(8);

         var counter_temp = counter;

         for (var i = 0; i &lt; 8; i++) {
             var i_from_right = 7 - i;

             // mask 255 over number to get last 8
             octet_array[i_from_right] = counter_temp &amp; 255;

             // shift 8 and get ready to loop over the next batch of 8
             counter_temp = counter_temp &gt;&gt; 8;
         }

        // There is no such class called as Buffer on Browsers (its node js)
         var counter_buffer = new Buffer(octet_array);

         var hash = CryptoJS.HmacSHA1(key,counter_buffer);

         document.write(""hex value ""+ hash);
         document.write(""hash value ""+    CryptoJS.enc.Hex.stringify(hash));
</code></pre>

<p>I know this is possible on a native platform like java (android) or objective c (ios) 
Here is the corresponding implementation <a href=""http://oathtoken.googlecode.com/svn-history/r42/trunk/Classes/HOTP.m"" rel=""nofollow"">HOTP in Objective C</a> but I doubt if it's possible to do on a web based front end. </p>

<p>Also, I highly doubt if such a thing is secure in browser because javascript is viewable from any browser. Any inputs suggestions would be useful. I am doing this for a POC. I am curious if anyone has used Hotp on web based platform.</p>
","<p>The code at <a href=""http://caligatio.github.io/jsSHA/"" rel=""nofollow"">http://caligatio.github.io/jsSHA/</a> works fine for <code>SHA-512</code>.</p>

<p>Drop the .js files, look in their test/test.html at line 515. It might look like a string to you but it is binary hex.</p>

<p>So their input is binary which is unmistaken. Don't get hung up on the fact it is sitting in a big string.</p>
","2795","<javascript><hash><sha><cryptojs><one-time-password>","3","1","2","2015-06-30 06:47:07","31124690","5","","1816580","","2015-06-30 06:47:07","2015-06-29 19:26:27",""
"14152897","How do i encrypt and decrypt Uint8Array using javascript?","<p>I want encryption and decryption of a Uint8Array for that i have downloaded CryptoJS library from this <a href=""http://code.google.com/p/crypto-js/"" rel=""nofollow noreferrer"">link</a>.</p>

<p>I have tested aes cipher algorithm on a dummy string its working fine.</p>

<p>Now i want it to implement it on Uint8Array. This array is holding a video file data.</p>

<p>Since the encryption and decryption works on a string, i have to convert it to a string for that i have referenced this question posted on the stackoverflow <a href=""https://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers"">click here</a></p>

<p>Code for encryption is :</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(String.fromCharCode.apply(null, uInt8Array), ""test"");
</code></pre>

<p>But when i ran the code following error is coming:</p>

<pre><code> Uncaught RangeError: Maximum call stack size exceeded 
</code></pre>

<p>How do i make it working?</p>
","<p>That error is due the <code>String.fromCharCode.apply(null, uInt8Array)</code> part, CryptoJS is never called.</p>

<p>Note that full syntax of <code>fromCharCode</code> is <code>String.fromCharCode(n1, n2, ..., nX)</code>, so all elements of the given buffer must be moved to the stack in order to <code>apply</code> the function.</p>

<p>You must be using a very big buffer, a video file you said, so that must be the reason you got a stackoverflow error.</p>

<p>Try to use a `CryptoJS.lib.WordArray' instead, as described here:</p>

<p><a href=""http://groups.google.com/group/crypto-js/browse_thread/thread/4ce6fddad709954d?pli=1"" rel=""nofollow"">http://groups.google.com/group/crypto-js/browse_thread/thread/4ce6fddad709954d?pli=1</a></p>
","2765","<javascript><arraybuffer><cryptojs>","0","2","1","2013-01-04 12:44:34","","0","","-1","","2017-05-23 12:18:46","2013-01-04 07:23:20",""
"53956787","ReferenceError: CryptoJs is not defined","<p>I tried to hash a text in client-side. I used following code to hash it, but it shows this Reference Error.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html&gt;

&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/md5.js""&gt;
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script&gt;
    var plaintext = ""hiii"";
    var encrptedText = CryptoJs.md5(plaintext);
    alert(""Encrpted Text : "" + encrptedText.toString());
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","<p>Use the entire package - not just the md5 module - change the <code>src</code> in your <code>script</code> tag </p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js""&gt;&lt;/script&gt;&lt;/head&gt;
&lt;body&gt;
&lt;script&gt;
var plaintext=""hiii"";
var encrptedText = CryptoJS.MD5(plaintext)
alert(""Encrpted Text : ""+ encrptedText.toString());
&lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
","2705","<javascript><hash><md5><cryptojs>","0","4","2","2019-06-19 13:18:59","53957126","3","","4642212","","2018-12-28 10:21:19","2018-12-28 10:09:35",""
"53956787","ReferenceError: CryptoJs is not defined","<p>I tried to hash a text in client-side. I used following code to hash it, but it shows this Reference Error.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html&gt;

&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/md5.js""&gt;
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script&gt;
    var plaintext = ""hiii"";
    var encrptedText = CryptoJs.md5(plaintext);
    alert(""Encrpted Text : "" + encrptedText.toString());
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","<p>If for you important the size of extended libraries, that you can use <a href=""https://www.npmjs.com/package/pure-md5"" rel=""nofollow noreferrer"">pure-md5</a> (4.76kb) instead <code>crypto-js</code> (187.44kb).</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html&gt;

&lt;head&gt;
&lt;script src=""https://unpkg.com/pure-md5@latest/lib/index.js""&gt;
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script&gt;
    var plaintext = ""hiii"";
    var encrptedText = md5(plaintext);
    alert(""Encrpted Text : "" + encrptedText.toString());
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","2705","<javascript><hash><md5><cryptojs>","0","0","2","2019-06-19 13:18:59","53957126","3","","4642212","","2018-12-28 10:21:19","2018-12-28 10:09:35",""
"16680631","How do I encrypt Crypto-JS keys with JSBN?","<p>I'm using <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/"" rel=""nofollow"">JSBN</a> to encrypt/decrypt data using public/private keypairs.  It works great for text data, including hex strings.</p>

<p>My problem is now I have binary data, specifically <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">Crypto-JS</a> Word Arrays, that I need to encrypt with a public key and send along to another platform.</p>

<p>So consider this:</p>

<pre><code>var key = CryptoJS.lib.WordArray.random(256/8);
var rsa = new RSAKey();
rsa.setPublic(modulus, exponent);
var encrypted_key = rsa.encrypt(key.toString());
</code></pre>

<p>This works but it means 'encrypted_key' is infact a hex string that's been encrypted, not the actual key.  I need to encrypt the actual key.</p>

<p>So I see two challenges here:</p>

<p>1) I'm not 100% sure how to get the actual bytes out of a CryptoJS.lib.WordArray -- though that doesn't seem totally insurmountable.</p>

<p>2) I have no idea if it's even possible to encrypt binary data using JSBN.  I'd love pointers to figure out how to do it.</p>

<p>Any thoughts?</p>
","<p>The JSBN library contains a function, namely pkcs1pad2(), wherein it converts the text to numeric values using JavaScript's charCodeAt() function.  You'll see that conversion code in the first while() loop:</p>

<pre><code>function pkcs1pad2(s,n) {
  if(n &lt; s.length + 11) { // TODO: fix for utf-8
    alert(""Message too long for RSA"");
    return null;
  }
  var ba = new Array();
  var i = s.length - 1;
  while(i &gt;= 0 &amp;&amp; n &gt; 0) {
    var c = s.charCodeAt(i--);
    if(c &lt; 128) { // encode using utf-8
      ba[--n] = c;
    }
    else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) {
      ba[--n] = (c &amp; 63) | 128;
      ba[--n] = (c &gt;&gt; 6) | 192;
    }
    else {
      ba[--n] = (c &amp; 63) | 128;
      ba[--n] = ((c &gt;&gt; 6) &amp; 63) | 128;
      ba[--n] = (c &gt;&gt; 12) | 224;
    }
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n &gt; 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}
</code></pre>

<p>If you wish to encrypt binary data then you'll likely have to modify this function so it converts the input in the way you want it. </p>

<p>Below is an example of pkcs1pad2() modified to accept binary data in the form of a hex string. If you use this version of pkcs1pad2() then you can convert your CryptoJS.lib.WordArray into hex and pass that hex string to rsa.encrypt().</p>

<pre><code>function pkcs1pad2(hexPlaintext,n) {
  if(n &lt; hexPlaintext.length/2 + 11) {
    alert(""Message too long for RSA"");
    return null;
  }
  var ba = new Array();
  var i = hexPlaintext.length;
  while(i &gt;= 2 &amp;&amp; n &gt; 0) {
    ba[--n] = parseInt(hexPlaintext.slice(i-2,i),16);
    i-=2;
  }
  ba[--n] = 0;
  var rng = new SecureRandom();
  var x = new Array();
  while(n &gt; 2) { // random non-zero pad
    x[0] = 0;
    while(x[0] == 0) rng.nextBytes(x);
    ba[--n] = x[0];
  }
  ba[--n] = 2;
  ba[--n] = 0;
  return new BigInteger(ba);
}
</code></pre>

<p>Alternatively, you could modify it to take the WordArray directly and convert that to the array format that is used by JSBN, but I'll leave that as an exercise for the reader.</p>
","2620","<javascript><rsa><cryptojs><jsbn>","2","2","2","2013-12-26 16:58:43","16705380","0","","569976","","2013-12-26 16:58:43","2013-05-21 22:34:27",""
"16680631","How do I encrypt Crypto-JS keys with JSBN?","<p>I'm using <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn/"" rel=""nofollow"">JSBN</a> to encrypt/decrypt data using public/private keypairs.  It works great for text data, including hex strings.</p>

<p>My problem is now I have binary data, specifically <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">Crypto-JS</a> Word Arrays, that I need to encrypt with a public key and send along to another platform.</p>

<p>So consider this:</p>

<pre><code>var key = CryptoJS.lib.WordArray.random(256/8);
var rsa = new RSAKey();
rsa.setPublic(modulus, exponent);
var encrypted_key = rsa.encrypt(key.toString());
</code></pre>

<p>This works but it means 'encrypted_key' is infact a hex string that's been encrypted, not the actual key.  I need to encrypt the actual key.</p>

<p>So I see two challenges here:</p>

<p>1) I'm not 100% sure how to get the actual bytes out of a CryptoJS.lib.WordArray -- though that doesn't seem totally insurmountable.</p>

<p>2) I have no idea if it's even possible to encrypt binary data using JSBN.  I'd love pointers to figure out how to do it.</p>

<p>Any thoughts?</p>
","<p>the pkcs1pad2 function converted from javascript to java:</p>

<pre><code>public BigInteger pkcs1pad2(String data,int keysize){
    byte[] buffer=new byte[keysize];
    Random rg=new Random();

    if(keysize &lt; data.length()+11)
        return null;

    int i = data.length() - 1;
    while(i &gt;= 0 &amp;&amp; keysize &gt; 0){
        --keysize;
        buffer[keysize] = (byte) data.charAt(i);
        i--;
    }
    --keysize;
    buffer[keysize] = 0;
    while(keysize &gt; 2){
        --keysize;
        buffer[keysize] = (byte) (rg.nextInt(254)+1);
    }
    --keysize;
    buffer[keysize] = 2;
    --keysize;
    buffer[keysize] = 0;

    return new BigInteger(buffer);
}
</code></pre>

<p>the rsa encription:</p>

<p><a href=""http://hc.apache.org/downloads.cgi"" rel=""nofollow"">http://hc.apache.org/downloads.cgi</a></p>

<pre><code>//you need httpcomponents-client-4.3.1-bin.zip from apache.org
//this contains working Base64 encoder!
import org.apache.commons.codec.binary.Base64;
public String encrypt(String data,String modulus,String exponent) throws UnsupportedEncodingException{
    byte[] exp=Helper.hexToBytes(exponent.toCharArray());
    byte[] mod=Helper.hexToBytes(modulus.toCharArray());

    BigInteger expB=new BigInteger(exp);
    BigInteger modB=new BigInteger(mod);

    BigInteger data2=this.pkcs1pad2(data, (modB.bitLength()+7)&gt;&gt;3);
    BigInteger data3=data2.modPow(expB, modB);

    byte[] encoding = (new Base64()).encode(Helper.hexToBytes(data3.toString(16).toCharArray()));
    return new String(encoding, ""US-ASCII"");
}
</code></pre>

<p>and the Helper.HexToBytes:</p>

<pre><code> public static byte[] hexToBytes(char[] hex)throws IllegalArgumentException{
     byte[] data = new byte[hex.length / 2];
     for (int i = 0, j = 0; j &lt; data.length; ++j){
         int hi = Character.digit(hex[i++], 16);
         int lo = Character.digit(hex[i++], 16);
         if ((hi &lt; 0) || (lo &lt; 0))
             throw new IllegalArgumentException();
         data[j] = (byte) (hi &lt;&lt; 4 | lo);
     }
     return data;
 }
</code></pre>
","2620","<javascript><rsa><cryptojs><jsbn>","2","0","2","2013-12-26 16:58:43","16705380","0","","569976","","2013-12-26 16:58:43","2013-05-21 22:34:27",""
"20022772","Efficiently encrypt/decrypt large file with cryptojs","<p>I want to encrypt large string (200 MB).
The string come from dataUrl (base64) corresponding to file.</p>

<p>I'm doing my encryption in the browser.</p>

<p>My issue is that at the moment, i chunked string into small part into an array.
Then i encrypt this chunks.</p>

<p>At the moment encrypting the string will full the memory.
Here is how i'm doing it.</p>

<pre><code>var encryptChunk = function(chunk, index){
  encryptedChunks.push( aesEncryptor.process( chunk ));
  sendUpdateMessage( ""encryption"", index+1, numberOfChunks );
}
chunkedString.forEach(encryptChunk);
encryptedChunks.push( aesEncryptor.finalize() );
</code></pre>

<p>I assume that, there should be a better way of doing this. But i can't find a memroy efficient way of doing this.</p>
","<p>What are you doing with the encrypted chunks? If you're, say, uploading them over the network, you don't need to store them in an array first.  Instead, you can upload the encrypted file chunk by chunk, either writing your own chunked upload implementation (it's not terribly hard) or by <a href=""https://stackoverflow.com/questions/9683263/html5-resumable-and-chunked-upload-of-large-files-500mb"">using an existing library.</a></p>

<p>Ditto for the input: you can encrypt it as you read it.  You can use the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/File"" rel=""nofollow noreferrer"">JS File API</a> to read the file in chunks, using the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Blob/slice"" rel=""nofollow noreferrer""><code>.slice()</code></a> method.</p>

<p>Other than that, your code looks just like the recommended way to <a href=""https://code.google.com/p/crypto-js/#Progressive_Ciphering"" rel=""nofollow noreferrer"">progressively encrypt</a> a file.</p>
","2589","<encryption><browser><large-files><cryptojs>","2","1","2","2017-04-05 10:57:36","26270156","0","1","","","","2013-11-16 19:27:54",""
"20022772","Efficiently encrypt/decrypt large file with cryptojs","<p>I want to encrypt large string (200 MB).
The string come from dataUrl (base64) corresponding to file.</p>

<p>I'm doing my encryption in the browser.</p>

<p>My issue is that at the moment, i chunked string into small part into an array.
Then i encrypt this chunks.</p>

<p>At the moment encrypting the string will full the memory.
Here is how i'm doing it.</p>

<pre><code>var encryptChunk = function(chunk, index){
  encryptedChunks.push( aesEncryptor.process( chunk ));
  sendUpdateMessage( ""encryption"", index+1, numberOfChunks );
}
chunkedString.forEach(encryptChunk);
encryptedChunks.push( aesEncryptor.finalize() );
</code></pre>

<p>I assume that, there should be a better way of doing this. But i can't find a memroy efficient way of doing this.</p>
","<p>I am doing something similar to you. To directly answer your question of ""is there a more memory efficient way?"" .. well I use a web worker for processing progressive ciphering which seems to work. </p>

<pre><code>  //pass in what you need here
  var worker = new Worker(""path/to/worker.js"");

  worker.postMessage({
                key: getKeyAndIvSomehow(),
                file: file,
                chunkSize: MY_CHUNK_SIZE
            });

  worker.addEventListener('message', function (e) {
               // create the blob from e.data.encrypted
            });
</code></pre>

<p>You will need to import the cryptoJS script into your worker: <code>importScripts('cryptoJS.all.min.js')</code></p>
","2589","<encryption><browser><large-files><cryptojs>","2","1","2","2017-04-05 10:57:36","26270156","0","1","","","","2013-11-16 19:27:54",""
"33914764","How to read a binary file with FileReader in order to hash it with SHA-256 in CryptoJS?","<p>how do I convert a UTF-8 string to Latin1 encoded string using javascript?</p>

<p>Here is what I am trying to do:</p>

<ol>
<li>I get a file, split that in chunks by reading as arraybuffer </li>
<li>then, I parse the arraybuffer as string</li>
<li><p>and passing it to cryptoJS for hash computation using following code:</p>

<pre><code>cryptosha256 = CryptoJS.algo.SHA256.create();
cryptosha256.update(text);
hash = cryptosha256.finalize();
</code></pre></li>
</ol>

<p>It all works well for a text file. I get problems when using the code for hashing a non-text files (image/.wmv files). I saw in another blog and there the CryptoJS author requires the bytes to be sent using Latin1 format instead of UTF-8 and that's where I am stuck.</p>

<p>Not sure, how can I generate the bytes (or strings) using Latin1 format from arraybuffer in javascript?</p>

<pre><code>$('#btnHash').click(function () {
    var fr = new FileReader(), 
        file = document.getElementById(""fileName"").files[0];
    fr.onload = function (e) {
        calcHash(e.target.result, file);
    };
    fr.readAsArrayBuffer(file);
});
function calcHash(dataArray, file) {
    cryptosha256 = CryptoJS.algo.SHA256.create();
    text = CryptoJS.enc.Latin1.parse(dataArray);
    cryptosha256.update(text);
    hash = cryptosha256.finalize();
}
</code></pre>
","<p>CryptoJS doesn't understand what an ArrayBuffer is and if you use some text encoding like Latin1 or UTF-8, you will inevitably lose some bytes. Not every possible byte value has a valid encoding in one of those text encodings.</p>

<p>You will have to convert the ArrayBuffer to CryptoJS' internal WordArray which holds the bytes as an array of words (32 bit integers). We can view the ArrayBuffer as an array of unsigned 8 bit integers and put them together to build the WordArray (see <code>arrayBufferToWordArray</code>).</p>

<p>The following code shows a full example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function arrayBufferToWordArray(ab) {
  var i8a = new Uint8Array(ab);
  var a = [];
  for (var i = 0; i &lt; i8a.length; i += 4) {
    a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]);
  }
  return CryptoJS.lib.WordArray.create(a, i8a.length);
}

function handleFileSelect(evt) {
  var files = evt.target.files; // FileList object

  // Loop through the FileList and render image files as thumbnails.
  for (var i = 0, f; f = files[i]; i++) {
    var reader = new FileReader();

    // Closure to capture the file information.
    reader.onloadend = (function(theFile) {
      return function(e) {
        var arrayBuffer = e.target.result;

        var hash = CryptoJS.SHA256(arrayBufferToWordArray(arrayBuffer));
        var elem = document.getElementById(""hashValue"");
        elem.value = hash;
      };

    })(f);
    reader.onerror = function(e) {
      console.error(e);
    };

    // Read in the image file as a data URL.
    reader.readAsArrayBuffer(f);
  }
}

document.getElementById('upload').addEventListener('change', handleFileSelect, false);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;form method=""post"" enctype=""multipart/form-data""&gt;
  Select image to upload:
  &lt;input type=""file"" name=""upload"" id=""upload""&gt;
  &lt;input type=""text"" name=""hashValue"" id=""hashValue""&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</p>

<p>You can extend this code with the techniques in <a href=""https://stackoverflow.com/a/28213834/1816580"">my other answer</a> in order to hash files of arbitrary size without freezing the browser.</p>
","2552","<javascript><utf-8><character-encoding><cryptojs><latin1>","5","11","1","2017-07-31 19:20:03","33918579","12","1","1816580","","2015-11-25 14:51:39","2015-11-25 11:00:06",""
"25135917","AES ECB No padding","<p>I am trying to implement AES/ECB/NoPadding with cryptojs.</p>

<p>On the Java side I have this:</p>

<pre><code>public static String encrypt(String input, String key) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/ECB/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    return DatatypeConverter.printHexBinary(cipher.doFinal(padToMultipleOf32(input.getBytes())));
}

public static byte[] padToMultipleOf32(final byte[] bytes) {
    int n16 = ((bytes.length + 31) / 32);
    int paddedLen = n16 * 32;

    byte[] result = new byte[paddedLen];

    for (int i = 0; i &lt; bytes.length; i++) {
        result[i] = bytes[i];
    }

    for (int i = bytes.length; i &lt; paddedLen; i++) {
        result[i] = 0x00;
    }

    System.out.println(new String(result).length());

    return result;
}
</code></pre>

<p>Running Test.encrypt(""test"", ""4g2ef21zmmmhe678"")
Gives me: C24F53DDEAD357510A27AA283C74BBF4638B3F81F8EB44652D424D7C32897525</p>

<p>How would I do the same in cryptojs, what I have currently doesnt work:</p>

<pre><code>var pwd = CryptoJS.AES.encrypt(""test"", ""4g2ef21zmmmhe678"", {
        mode : CryptoJS.mode.ECB,
        padding : CryptoJS.pad.NoPadding
    });
    expect(pwd.ciphertext.toString(CryptoJS.enc.Base64)).toEqual(""C24F53DDEAD357510A27AA283C74BBF4638B3F81F8EB44652D424D7C32897525"");
</code></pre>

<p>Please help</p>
","<p>The documentation of <em>CryptoJS</em> says that when passing a plain passphrase (i.e. a String) to <code>encrypt ()</code> , it will automatically generate a 256 bit key (Java implements the 128 bit version) using that password as the seed.</p>

<p>To prevent that you can use this function to directly convert your passphrase to a key:</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse(""password"");
</code></pre>

<p>Possibly you will also have to synchronize the encodings of the ciphertexts. See <a href=""http://blog.cloudme.org/2013/08/interoperable-aes-encryption-with-java-and-javascript/"" rel=""nofollow"">here</a> for a detailed example on how to perform interoperable encryption  with Java and <em>CryptoJS</em>.</p>
","2546","<javascript><encryption><cryptojs>","0","0","1","2014-08-05 13:03:05","","1","2","","","","2014-08-05 09:55:13",""
"13058977","NodeJS Crypto with RC4 yields blank","<p>I have a php function that generates an RC4 encrypted string. I would like to decode that string using Node - ideally using the built in Crypto module. But I am unable to do so - I just get a blank string.</p>

<p>The PHP code is here <a href=""http://code.google.com/p/rc4crypt/"" rel=""nofollow"">http://code.google.com/p/rc4crypt/</a></p>

<p>My JS code is</p>

<pre><code>crypto = require('crypto');
decipher = crypto.createDecipher(""rc4"", ""MY SECRET KEY"");
text = ""HELLO"";
decrypted = decipher.update(text, ""utf8"", ""hex"");
decrypted += decipher.final(""hex"");
console.log(decrypted);
</code></pre>

<p>I don't get any output. I have checked that my OpenSSL implementation has RC4 using openssl list-message-digest-algorithms</p>

<p>I am on OSX 10.8, latest node.</p>

<p>I am open to using another module to decrypt - I tried the cryptojs module but did not figure out how to make it work - gave me errors when I tried RC4.</p>

<p>Thanks</p>
","<p>Figured it out</p>

<p>First one must use crypto.createDecipheriv otherwise the key is - I believe - md5 hashed instead of used raw.</p>

<p>Secondly the input encoding mut be set to binary.</p>

<p>Third - in my case I was dealing with POST data instead of a hardcoded string and I had to urldecode it - decodeURIComponent() jsut choked - but unescape() with removal of + signs did the trick ex: </p>

<pre><code>var text = unescape((response.post.myvar + '').replace(/\+/g, '%20'))

var crypto = require('crypto');
decipher = crypto.createDecipheriv(""rc4"", key, '');    
decrypted = decipher.update(text, ""binary"", ""utf8"");
decrypted += decipher.final(""utf8"");
console.log(decrypted);
</code></pre>
","2512","<javascript><node.js><cryptojs><rc4-cipher><node-crypto>","5","4","1","2016-06-27 09:40:26","13060315","0","","972240","","2016-06-27 09:40:26","2012-10-24 22:44:12",""
"49535641","Crypto js r.randomBytes is not a function","<p>I'm encountering an issue when trying to set auth0 with ionic.</p>

<p>However, I think it's not related with it and it's more of a crypto js / config issue.</p>

<p>This is the error I'm getting:</p>

<blockquote>
  <p><code>main.7c4444f936ddaf5620f8.bundle.js:formatted:15919 ERROR Error:</code> </p>
  
  <p><code>Uncaught (in promise): TypeError: r.randomBytes is not a function</code></p>
  
  <p><code>TypeError: r.randomBytes is not a function at n.generateProofKey (main.7c4444f936ddaf5620f8.bundle.js:formatted:844)</code></p>
</blockquote>

<p>and below is my crypto js file:</p>

<pre class=""lang-js prettyprint-override""><code>import * as crypto from 'crypto-js';

function base64UrlSafeEncode(string) {
  return string.toString('base64')
      .replace(/+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '');
}

function sha256(buffer) {
  return crypto.createHash('sha256').update(buffer).digest();
}

exports.generateProofKey = function generateProofKey() {
  var codeVerifier = base64UrlSafeEncode(crypto.randomBytes(32)); 
  var codeChallenge = base64UrlSafeEncode(sha256(codeVerifier)); 
  return { codeVerifier: codeVerifier, codeChallenge: codeChallenge };
};

exports.generateState = function generateState() {
  return base64UrlSafeEncode(crypto.randomBytes(32));
}
</code></pre>

<p>Edit: with crypto.lib.WordArray.random(32) now says</p>

<p>c is not a function
</p>

<pre><code>p.prototype.authorize = function(t, n) {
            if (!n || ""function"" != typeof n)
                throw new Error(""callback not specified or is not a function"");
            var e = this;
            i(function(l, i) {
                if (l)
                    return n(l);
                var o = c()
                  , a = e.client
                  , f = e.redirectUri
                  , p = t.state || h(
</code></pre>

<p>Cordova Auth0</p>

<pre><code>callbackFromNative: function (callbackId, isSuccess, status, args, keepCallback) {
        try {
            var callback = cordova.callbacks[callbackId];
            if (callback) {
                if (isSuccess &amp;&amp; status === cordova.callbackStatus.OK) {
                    callback.success &amp;&amp; callback.success.apply(null, args);
                } else if (!isSuccess) {
                    callback.fail &amp;&amp; callback.fail.apply(null, args);
                }
                /*
                else
                    Note, this case is intentionally not caught.
                    this can happen if isSuccess is true, but callbackStatus is NO_RESULT
                    which is used to remove a callback from the list without calling the callbacks
                    typically keepCallback is false in this case
                */
                // Clear callback if not expecting any more results
                if (!keepCallback) {
                    delete cordova.callbacks[callbackId];
                }
            }
        } catch (err) {
            var msg = 'Error in ' + (isSuccess ? 'Success' : 'Error') + ' callbackId: ' + callbackId + ' : ' + err;
            console &amp;&amp; console.log &amp;&amp; console.log(msg);
            cordova.fireWindowEvent('cordovacallbackerror', { 'message': msg });
            throw err;
        }
</code></pre>
","<p>Seen on this <a href=""https://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/"" rel=""nofollow noreferrer"">site</a>:</p>

<pre><code>// Creates a word array filled with random bytes.
// @param {number} nBytes The number of random bytes to generate.
var wordArray = CryptoJS.lib.WordArray.random(16);
</code></pre>

<p>So, I think you should probably use <code>crypto.lib.WordArray.random(32)</code> instead.</p>
","2512","<javascript><angular><webpack><auth0><cryptojs>","-4","3","1","2018-08-03 06:07:13","","1","","9564244","","2018-03-28 20:02:19","2018-03-28 13:16:46",""
"22073453","Encrypt (cryptojs) - Decrypt (.NET)","<p>Passwords are going to be encrypted in .NET using AES and stored in a database. In another application, using javascript (on top of a Rhino engine) and the cryptojs library, I'll need to decrypt the password and then use it.</p>

<p>The solution doesn't need to be complex, all I'm seeking is a simple implementation of how I can get these two guys to work together.</p>

<p>Followed this guide: <a href=""http://www.aspsnippets.com/Articles/AES-Encryption-Decryption-Cryptography-Tutorial-with-example-in-ASPNet-using-C-and-VBNet.aspx"" rel=""nofollow"">http://www.aspsnippets.com/Articles/AES-Encryption-Decryption-Cryptography-Tutorial-with-example-in-ASPNet-using-C-and-VBNet.aspx</a></p>

<p>Successfully encrypted a simple string (""SFTPPass"") with a key of (""Key"") in .NET, but once I get to decrypting in javascript not sure how to do it. </p>

<p>This is what I have in javascript:</p>

<pre><code>var encryptedPass = 'StrmZO1Vjd8noHYzXs8hiQQBQDJZA5Bpg3t4BcmrViU=';

var iv = CryptoJS.enc.Base64.parse('1Ph1oX+N+q/kzpdyaIKBpA==');
var key = CryptoJS.enc.Base64.parse('k/W+Xeenh3kSLneZ/DYXVpvshGbsFVdyfOFdFTJb1yE=');

var SFTPPass = CryptoJS.AES.decrypt(encryptedPass, 'Key', key, {iv: iv});
</code></pre>

<p>However when I write my output to a file it's empty.</p>

<p>Any suggestions or alternative solutions are greatly welcomed!</p>

<p>EDIT:
With the recommendation by alancnet, I'm now getting output but the string doesn't match the original which is ""1234"". So I followed the guide in the link above down to the wire using the same Key Phrase and input string. Captured the hex of both the key &amp; iv using BitConverter.toString in .NET.</p>

<pre><code>key = ""752DA9F0D612540EEF1DE07A144781261A3D604DE339174ADAC5D5D6A695ABFF""
iv = ""9714413594225F1D14FA02101C0D584D""
</code></pre>

<p>What my javascript looks like now: </p>

<pre><code>var encryptedPass = 'Ao5ZnFYo344iWqv/Jr9euw==';

var iv = CryptoJS.enc.Hex.parse('9714413594225F1D14FA02101C0D584D');
var key = CryptoJS.enc.Hex.parse('752DA9F0D612540EEF1DE07A144781261A3D604DE339174ADAC5D5D6A695ABFF');

var decryptedString = CryptoJS.AES.decrypt(encryptedPass, key, {iv: iv});
</code></pre>
","<p>Your code:</p>

<pre><code>var SFTPPass = CryptoJS.AES.decrypt(encryptedPass, 'Key', key, {iv: iv});
</code></pre>

<p><code>'Key'</code> is an unexpected parameter, and should be removed.</p>

<p>I ported your code to Node:</p>

<pre><code>var CryptoJS = new require(""cryptojs"").Crypto;

var encryptedPass = 'StrmZO1Vjd8noHYzXs8hiQQBQDJZA5Bpg3t4BcmrViU=';

var iv = CryptoJS.util.base64ToBytes('1Ph1oX+N+q/kzpdyaIKBpA==');
var key = CryptoJS.util.base64ToBytes('k/W+Xeenh3kSLneZ/DYXVpvshGbsFVdyfOFdFTJb1yE=');

var SFTPPass = CryptoJS.util.bytesToBase64(
        CryptoJS.AES.decrypt(
            encryptedPass, 
            key, 
            {
                iv: iv, 
                asBytes: true
            }
        )
    );

console.log(SFTPPass);
</code></pre>

<p>and it ouput: <code>UABfRxZLApVrt/t8JtoHMhCxfYUPWDwMLuBmWe50tDw=</code></p>

<p>Good luck :)</p>
","2487","<javascript><.net><cryptojs>","3","2","2","2014-02-27 18:20:33","22075271","11","1","2725938","","2014-02-27 18:09:55","2014-02-27 15:47:54",""
"22073453","Encrypt (cryptojs) - Decrypt (.NET)","<p>Passwords are going to be encrypted in .NET using AES and stored in a database. In another application, using javascript (on top of a Rhino engine) and the cryptojs library, I'll need to decrypt the password and then use it.</p>

<p>The solution doesn't need to be complex, all I'm seeking is a simple implementation of how I can get these two guys to work together.</p>

<p>Followed this guide: <a href=""http://www.aspsnippets.com/Articles/AES-Encryption-Decryption-Cryptography-Tutorial-with-example-in-ASPNet-using-C-and-VBNet.aspx"" rel=""nofollow"">http://www.aspsnippets.com/Articles/AES-Encryption-Decryption-Cryptography-Tutorial-with-example-in-ASPNet-using-C-and-VBNet.aspx</a></p>

<p>Successfully encrypted a simple string (""SFTPPass"") with a key of (""Key"") in .NET, but once I get to decrypting in javascript not sure how to do it. </p>

<p>This is what I have in javascript:</p>

<pre><code>var encryptedPass = 'StrmZO1Vjd8noHYzXs8hiQQBQDJZA5Bpg3t4BcmrViU=';

var iv = CryptoJS.enc.Base64.parse('1Ph1oX+N+q/kzpdyaIKBpA==');
var key = CryptoJS.enc.Base64.parse('k/W+Xeenh3kSLneZ/DYXVpvshGbsFVdyfOFdFTJb1yE=');

var SFTPPass = CryptoJS.AES.decrypt(encryptedPass, 'Key', key, {iv: iv});
</code></pre>

<p>However when I write my output to a file it's empty.</p>

<p>Any suggestions or alternative solutions are greatly welcomed!</p>

<p>EDIT:
With the recommendation by alancnet, I'm now getting output but the string doesn't match the original which is ""1234"". So I followed the guide in the link above down to the wire using the same Key Phrase and input string. Captured the hex of both the key &amp; iv using BitConverter.toString in .NET.</p>

<pre><code>key = ""752DA9F0D612540EEF1DE07A144781261A3D604DE339174ADAC5D5D6A695ABFF""
iv = ""9714413594225F1D14FA02101C0D584D""
</code></pre>

<p>What my javascript looks like now: </p>

<pre><code>var encryptedPass = 'Ao5ZnFYo344iWqv/Jr9euw==';

var iv = CryptoJS.enc.Hex.parse('9714413594225F1D14FA02101C0D584D');
var key = CryptoJS.enc.Hex.parse('752DA9F0D612540EEF1DE07A144781261A3D604DE339174ADAC5D5D6A695ABFF');

var decryptedString = CryptoJS.AES.decrypt(encryptedPass, key, {iv: iv});
</code></pre>
","<p>I figured it out, it was the format of how I was outputting the decrypted string. </p>

<p>Played around with multiple versions...</p>

<pre><code> FileWrite(decryptedString);
 FileWrite(decryptedString.toString());
</code></pre>

<p>Ultimately what got it working was:</p>

<pre><code> FileWrite(decryptedString.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Mind you the lower case of ""t"" and ""f"", tried doing ""UTF8"" and it gave me completely different output as well. </p>

<p>Thanks again to alancnet for pointing out the main mistake I was doing in trying to use an invalid parameter, i probably wouldn't have noticed that till later in the day.</p>
","2487","<javascript><.net><cryptojs>","3","0","2","2014-02-27 18:20:33","22075271","11","1","2725938","","2014-02-27 18:09:55","2014-02-27 15:47:54",""
"51013299","malformed utf-8 data cryptoJS","<p>I am trying to create a JSON object, encrypt it using AES, and then send the data, however I am getting an error when I decrypt it.
The following code works perfectly, it encrypts, and decrypts the needed info.</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(JSON.stringify(token), 'AGsrv54SDG2DA');
console.log(""token is :"" + encrypted.toString());
//U2FsdGVkX19QYpU9XWLESHzRB7uvFMtc1J/pCbJjXelTHyeEmU4LCsIMpYZGl9Bs157sX2f47fGeAW4EIaCGiPATxX2PdpZ YMdvPKDIaPYPnmlEJa9yZWyfXf80FNbkRM9Jo9M8GrMiAg8baK6S8GH7GdwxeZEVVkLJpFpgFBUPS3xn2sy/bMHWvOK0lPT0

var bytes = CryptoJS.AES.decrypt(encrypted.toString(), 'AGsrv54SDG2DA');
console.log('BYTES BEFORE:' + bytes);
//bytes : 7b2254797065223a22415554485f434f4445222c22554944223a226e6866476a424c30306c5866735763783332333275587171306c6932222c22434944223a22486f6d655370616365434944222c2245584154223a22546875204d617920333120323031382031373a32333a323920474d542b30303030202855544329227d
var decryptedData = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
console.log(""auth token UID for test is "" + decryptedData.UID); //this works 100%

return {token : encrypted.toString()};
</code></pre>

<p>the <code>return</code> statement returns the stringed version of the encrypted data back to my web page. the token is then sent back to another cloud function which attempts to decrypt it as following:</p>

<pre><code>inToken = req.body.code;
console.log(""auth token given:"" + inToken);
//U2FsdGVkX19QYpU9XWLESHzRB7uvFMtc1J/pCbJjXelTHyeEmU4LCsIMpYZGl9Bs157sX2f47fGeAW4EIaCGiPATxX2PdpZ YMdvPKDIaPYPnmlEJa9yZWyfXf80FNbkRM9Jo9M8GrMiAg8baK6S8GH7GdwxeZEVVkLJpFpgFBUPS3xn2sy/bMHWvOK0lPT0

var bytes = CryptoJS.AES.decrypt(inToken, 'AGsrv54SDG2DA');
console.log('BYTES AFTER:' + bytes);
//7b2254797065223a22415554485f434f4445222c22554944223a226e6866476a424c30306c5866735763783332333275587171306c6932222c22434944223a22486f6d655370616365434944222c2245584154223a22546875204d617920333120323031382031373a32333a323920474d542b30303030202855544329227d
var jsonToken = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>however this throws 
<code>Error: Malformed UTF-8 data at Object.stringify</code></p>
","","2419","<javascript><encryption><aes><google-cloud-functions><cryptojs>","1","","0","2018-07-09 08:21:31","","12","0","2650325","","2018-07-09 08:21:31","2018-06-24 19:30:21",""
"41719248","Import Crypto-JS into Angular 2 project","<p>I am using typescript and SystemJS for Angular 2 development and wanted to include crypto-js.
Here is systemjs.config.js file:</p>

<pre><code>(function (global) {
  System.config({
    paths: {
      'npm:': 'node_modules/'
    },
    map: {
      app: 'app',

      // angular bundles
      '@angular/core': 'npm:@angular/core/bundles/core.umd.js',
      '@angular/common': 'npm:@angular/common/bundles/common.umd.js',
      '@angular/compiler': 'npm:@angular/compiler/bundles/compiler.umd.js',
      '@angular/platform-browser': 'npm:@angular/platform-browser/bundles/platform-browser.umd.js',
      '@angular/platform-browser-dynamic': 'npm:@angular/platform-browser-dynamic/bundles/platform-browser-dynamic.umd.js',
      '@angular/http': 'npm:@angular/http/bundles/http.umd.js',
      '@angular/router': 'npm:@angular/router/bundles/router.umd.js',
      '@angular/forms': 'npm:@angular/forms/bundles/forms.umd.js',

      // other libraries
      'rxjs':                      'npm:rxjs',
      'crypto-js':                 'npm:crypto-js/core.js',
      'crypto-js/sha256':          'npm:crypto-js/sha256.js',
    },

    packages: {
      app: {
        main: './main.js',
        defaultExtension: 'js'
      },
      rxjs: {
        defaultExtension: 'js'
      },
      'crypto-js': {
        defaultExtension: 'js'
      }
    }
  });
})(this);
</code></pre>

<p>And in service.ts:</p>

<pre><code>import 'crypto-js/sha256';
</code></pre>

<p>When I run the app this is the error I get: </p>

<pre><code>http://localhost:3000/node_modules/crypto-js/core as ""./core"" from http://localhost:3000/node_modules/crypto-js/sha256.js
</code></pre>

<p>How can I make this work?</p>
","<p>Turns out, all I had to do was to add defaultJSExtensions: 'js', like this:</p>

<pre><code>packages: {
        '.': {
            defaultJSExtensions: 'js'
        },
        app: {
            main: './main.js'
        }
    }
</code></pre>
","2349","<angular><typescript><systemjs><cryptojs>","3","0","1","2017-01-27 08:21:36","","0","","","","","2017-01-18 12:19:30",""
"54882406","Compatible AES encryption and decryption for Flutter and javascript","<p>I am trying to write two function in flutter and Javascript which I can use throughout my project to encrypt or decrypt data using AES when data is exchanged.
For Flutter I am using the pointycastle package based on instructions
<a href=""https://gist.github.com/proteye/e54eef1713e1fe9123d1eb04c0a5cf9b?signup=true"" rel=""nofollow noreferrer"">https://gist.github.com/proteye/e54eef1713e1fe9123d1eb04c0a5cf9b?signup=true</a></p>

<pre><code>import 'dart:convert';
import 'dart:typed_data';
import ""package:pointycastle/export.dart"";

import ""./convert_helper.dart"";

// AES key size
const KEY_SIZE = 32; // 32 byte key for AES-256
const ITERATION_COUNT = 1000;

class AesHelper {
  static const CBC_MODE = 'CBC';
  static const CFB_MODE = 'CFB';

  static Uint8List deriveKey(dynamic password,
      {String salt = '',
      int iterationCount = ITERATION_COUNT,
      int derivedKeyLength = KEY_SIZE}) {
    if (password == null || password.isEmpty) {
      throw new ArgumentError('password must not be empty');
    }

    if (password is String) {
      password = createUint8ListFromString(password);
    }

    Uint8List saltBytes = createUint8ListFromString(salt);
    Pbkdf2Parameters params =
        new Pbkdf2Parameters(saltBytes, iterationCount, derivedKeyLength);
    KeyDerivator keyDerivator =
        new PBKDF2KeyDerivator(new HMac(new SHA256Digest(), 64));
    keyDerivator.init(params);

    return keyDerivator.process(password);
  }

  static Uint8List pad(Uint8List src, int blockSize) {
    var pad = new PKCS7Padding();
    pad.init(null);

    int padLength = blockSize - (src.length % blockSize);
    var out = new Uint8List(src.length + padLength)..setAll(0, src);
    pad.addPadding(out, src.length);

    return out;
  }

  static Uint8List unpad(Uint8List src) {
    var pad = new PKCS7Padding();
    pad.init(null);

    int padLength = pad.padCount(src);
    int len = src.length - padLength;

    return new Uint8List(len)..setRange(0, len, src);
  }

  static String encrypt(String password, String plaintext,
      {String mode = CBC_MODE}) {
    Uint8List derivedKey = deriveKey(password);
    KeyParameter keyParam = new KeyParameter(derivedKey);
    BlockCipher aes = new AESFastEngine();

    var rnd = FortunaRandom();
    rnd.seed(keyParam);
    Uint8List iv = rnd.nextBytes(aes.blockSize);

    BlockCipher cipher;
    ParametersWithIV params = new ParametersWithIV(keyParam, iv);
    switch (mode) {
      case CBC_MODE:
        cipher = new CBCBlockCipher(aes);
        break;
      case CFB_MODE:
        cipher = new CFBBlockCipher(aes, aes.blockSize);
        break;
      default:
        throw new ArgumentError('incorrect value of the ""mode"" parameter');
        break;
    }
    cipher.init(true, params);

    Uint8List textBytes = createUint8ListFromString(plaintext);
    Uint8List paddedText = pad(textBytes, aes.blockSize);
    Uint8List cipherBytes = _processBlocks(cipher, paddedText);
    Uint8List cipherIvBytes = new Uint8List(cipherBytes.length + iv.length)
      ..setAll(0, iv)
      ..setAll(iv.length, cipherBytes);

    return base64.encode(cipherIvBytes);
  }

  static String decrypt(String password, String ciphertext,
      {String mode = CBC_MODE}) {
    Uint8List derivedKey = deriveKey(password);
    KeyParameter keyParam = new KeyParameter(derivedKey);
    BlockCipher aes = new AESFastEngine();

    Uint8List cipherIvBytes = base64.decode(ciphertext);
    Uint8List iv = new Uint8List(aes.blockSize)
      ..setRange(0, aes.blockSize, cipherIvBytes);

    BlockCipher cipher;
    ParametersWithIV params = new ParametersWithIV(keyParam, iv);
    switch (mode) {
      case CBC_MODE:
        cipher = new CBCBlockCipher(aes);
        break;
      case CFB_MODE:
        cipher = new CFBBlockCipher(aes, aes.blockSize);
        break;
      default:
        throw new ArgumentError('incorrect value of the ""mode"" parameter');
        break;
    }
    cipher.init(false, params);

    int cipherLen = cipherIvBytes.length - aes.blockSize;
    Uint8List cipherBytes = new Uint8List(cipherLen)
      ..setRange(0, cipherLen, cipherIvBytes, aes.blockSize);
    Uint8List paddedText = _processBlocks(cipher, cipherBytes);
    Uint8List textBytes = unpad(paddedText);

    return new String.fromCharCodes(textBytes);
  }

  static Uint8List _processBlocks(BlockCipher cipher, Uint8List inp) {
    var out = new Uint8List(inp.lengthInBytes);

    for (var offset = 0; offset &lt; inp.lengthInBytes;) {
      var len = cipher.processBlock(inp, offset, out, offset);
      offset += len;
    }

    return out;
  }
}
</code></pre>

<p>and class flutter convert_helper.dart</p>

<pre><code>import ""dart:typed_data"";
import 'dart:convert';
import 'package:convert/convert.dart' as convert;

Uint8List createUint8ListFromString(String s) {
  var ret = new Uint8List(s.length);
  for (var i = 0; i &lt; s.length; i++) {
    ret[i] = s.codeUnitAt(i);
  }
  return ret;
}

Uint8List createUint8ListFromHexString(String hex) {
  var result = new Uint8List(hex.length ~/ 2);
  for (var i = 0; i &lt; hex.length; i += 2) {
    var num = hex.substring(i, i + 2);
    var byte = int.parse(num, radix: 16);
    result[i ~/ 2] = byte;
  }
  return result;
}

Uint8List createUint8ListFromSequentialNumbers(int len) {
  var ret = new Uint8List(len);
  for (var i = 0; i &lt; len; i++) {
    ret[i] = i;
  }
  return ret;
}

String formatBytesAsHexString(Uint8List bytes) {
  var result = new StringBuffer();
  for (var i = 0; i &lt; bytes.lengthInBytes; i++) {
    var part = bytes[i];
    result.write('${part &lt; 16 ? '0' : ''}${part.toRadixString(16)}');
  }
  return result.toString();
}

List&lt;int&gt; decodePEM(String pem) {
  var startsWith = [
    ""-----BEGIN PUBLIC KEY-----"",
    ""-----BEGIN PRIVATE KEY-----"",
    ""-----BEGIN ENCRYPTED MESSAGE-----"",
    ""-----BEGIN PGP PUBLIC KEY BLOCK-----\r\nVersion: React-Native-OpenPGP.js 0.1\r\nComment: http://openpgpjs.org\r\n\r\n"",
    ""-----BEGIN PGP PRIVATE KEY BLOCK-----\r\nVersion: React-Native-OpenPGP.js 0.1\r\nComment: http://openpgpjs.org\r\n\r\n"",
  ];
  var endsWith = [
    ""-----END PUBLIC KEY-----"",
    ""-----END PRIVATE KEY-----"",
    ""-----END ENCRYPTED MESSAGE-----"",
    ""-----END PGP PUBLIC KEY BLOCK-----"",
    ""-----END PGP PRIVATE KEY BLOCK-----"",
  ];
  bool isOpenPgp = pem.indexOf('BEGIN PGP') != -1;

  for (var s in startsWith) {
    if (pem.startsWith(s)) {
      pem = pem.substring(s.length);
    }
  }

  for (var s in endsWith) {
    if (pem.endsWith(s)) {
      pem = pem.substring(0, pem.length - s.length);
    }
  }

  if (isOpenPgp) {
    var index = pem.indexOf('\r\n');
    pem = pem.substring(0, index);
  }

  pem = pem.replaceAll('\n', '');
  pem = pem.replaceAll('\r', '');

  return base64.decode(pem);
}

List&lt;int&gt; decodeHex(String hex) {
  hex = hex
      .replaceAll(':', '')
      .replaceAll('\n', '')
      .replaceAll('\r', '')
      .replaceAll('\t', '');

  return convert.hex.decode(hex);
}
</code></pre>

<p>For the Javascript solution I am using CryptoJS</p>

<pre><code>var AESKey = ""20190225165436_15230006321670000""
cc = CryptoJS.AES.encrypt( (""abcdef ha ha ""), AESKey, { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 } ).toString()
CryptoJS.AES.decrypt(cc, AESKey).toString(CryptoJS.enc.Utf8);  //return abcdef ha ha 
</code></pre>

<p>Both solutions work well within their own environment, however the flutter or Javascript hashes can't be exchanged, they will not decrypt. My guess is that the character encoding has something to do with it, hence why the base64 sizes differ so much. Does anyone have a idea to get this working together? Thanks!</p>

<p>Does anyone have a idea to get this working together? Thanks!</p>
","<p>The main problem is that the two key derivation algorithms are different.
In your Dart/PC code you are using PBKDF2, but the KDF used by <code>CryptoJS.AES.encrypt</code> is OpenSSL's <a href=""https://www.openssl.org/docs/manmaster/man3/EVP_BytesToKey.html"" rel=""nofollow noreferrer"">EVP_BytesToKey</a></p>

<p>You could implement the equivalent of <code>EVP_BytesToKey</code> in Dart using PC. However it would probably be easier to change the JavaScript code to derive its key using PBKDF2, which is already <a href=""https://cryptojs.gitbook.io/docs/#pbkdf2"" rel=""nofollow noreferrer"">supported by CryptoJS</a>. That will give you a key and IV to be used <a href=""https://cryptojs.gitbook.io/docs/#custom-key-and-iv"" rel=""nofollow noreferrer"">like this</a>:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>
","2313","<dart><flutter><cryptojs><pointycastle>","0","0","1","2019-10-12 01:24:32","","5","","6044788","","2019-02-26 10:33:04","2019-02-26 09:37:23",""
"33147445","How to generate hash(SHA1) using beanshell in JMeter?","<p>How do I want to generate a hash using beanshell(SHA1) in JMeter to sign up to a application? </p>

<p>I'm not able to get a substantial answer yet from net</p>
","<p>Generating a hash is pretty easy, just use <a href=""https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html"" rel=""nofollow"">DigestUtils</a> class from Apache <a href=""https://commons.apache.org/proper/commons-codec/"" rel=""nofollow"">Commons Codec</a> library (it's a part of JMeter so you won't need to install anything external)</p>

<p>Something like:</p>

<pre><code>import org.apache.commons.codec.digest.DigestUtils;

String foo = ""bar"";
String sha1Hex = DigestUtils.sha1Hex(foo);
</code></pre>

<p>Usually SHA1 is being required for signing requests to OAuth-protected applications, if it is your case, I believe <a href=""https://blazemeter.com/blog/how-run-performance-tests-oauth-secured-apps-jmeter"" rel=""nofollow"">How to Run Performance Tests on OAuth Secured Apps with JMeter</a> will be extremely helpful.</p>
","2268","<jmeter><sha1><cryptojs><beanshell>","2","2","2","2017-11-15 07:38:18","33152370","1","1","7294900","","2017-11-15 07:38:18","2015-10-15 11:33:11",""
"33147445","How to generate hash(SHA1) using beanshell in JMeter?","<p>How do I want to generate a hash using beanshell(SHA1) in JMeter to sign up to a application? </p>

<p>I'm not able to get a substantial answer yet from net</p>
","<p>There's a new JMeter function <code>__digest</code>, currently in <a href=""https://builds.apache.org/job/JMeter-trunk/lastSuccessfulBuild/artifact/trunk/dist/"" rel=""nofollow noreferrer"">nightly builds</a> which can be used to encode strings</p>

<p><img src=""https://i.imgur.com/Du59fBG.png"" alt=""""></p>

<p>In your case to save in sha1Value variable the result of myVar variable use the following:</p>

<pre><code>${__digest(SHA-1,${myVar},,,sha1Value)}
</code></pre>

<p>4th parameter is uppercase, so you can send true to automatically uppercase it.</p>
","2268","<jmeter><sha1><cryptojs><beanshell>","2","0","2","2017-11-15 07:38:18","33152370","1","1","7294900","","2017-11-15 07:38:18","2015-10-15 11:33:11",""
"35532660","Compatibility between node crypto and crypto-js encryption and decryption","<p>How do I properly encrypt/decrypt data between node.js with the crypto module (server side) and crypto-js (client side, react-native)?</p>

<p>NOTE: 
I'm using cryptojs in a react-native project, thus I can't use crypto on client.
replacing crypto server side is not an option for me.</p>

<p>Server-side code:</p>

<pre><code>var Crypto = require(""crypto"");

var Cipher = {
  pass: ""0123456789abcdef0123456789abcdef"",
  iv: ""0123456789abcdef"",
  encript: function (msg) {
    try {
      var cipher = Crypto.createCipheriv(""aes-256-cbc"", this.pass, this.iv);
      var hash = cipher.update(msg, 'utf8', ""hex"");
      var hex = hash + cipher.final(""hex"");
      return hex;
    } catch (err) {
      console.error(err);
      return """";
    }
  },
  decript: function (hex){
    try {
      var decipher = Crypto.createDecipheriv(""aes-256-cbc"", this.pass, this.iv);
      var dec = decipher.update(hex, ""hex"", 'utf8');
      return dec + decipher.final('utf8');
    } catch (err) {
      console.error(err);
      return """";
    }
  }
}
Cipher.encript(""i have an apple""); // 577267026f88f82ea286baf6bf089acb
Cipher.decript(""577267026f88f82ea286baf6bf089acb""); // i have an apple
</code></pre>

<p>Client-side code</p>

<pre><code>var CryptoJS = require(""crypto-js"");
var Cipher = {
  pass: CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef""),
  iv: CryptoJS.enc.Hex.parse(""0123456789abcdef""),
  encript: function (msg) {
    try {
      var options = { mode: CryptoJS.mode.CBC, iv: this.iv};
      var json = CryptoJS.AES.encrypt(msg, this.pass, options);
      return json.ciphertext.toString(CryptoJS.enc.Hex);
    } catch (err) {
      console.error(err);
      return """";
    }
  },
  decript: function (hex){
    try {
      // ???????????????????????????????????
      // ???????????????????????????????????

    } catch (err) {
      console.error(err);
      return """";
    }
  }
}

Cipher.encript(""i have an apple""); // 405552d9a77ea9e29442057d27cd7aee
Cipher.decript(?????);  // I have no Idea
</code></pre>
","<p>Your ""password"" (it is used as a key instead of a password) has two different encodings on client-side and server-side. On the client, you're parsing it as Hex, but on the server, you're passing it as a binary string, which is used as-is.</p>

<p>You either need parse it on the server (now it is AES-128 and not AES-256):</p>

<pre><code>pass: new Buffer(""0123456789abcdef0123456789abcdef"", ""hex""),
</code></pre>

<p>Or change the encoding on the client (from AES-128 to AES-256):</p>

<pre><code>pass: CryptoJS.enc.<b>Utf8</b>.parse(""0123456789abcdef0123456789abcdef""),</code></pre>

<hr>

<pre><code>  encript: function (msg) {
    try {
      var options = { mode: CryptoJS.mode.CBC, iv: this.iv};
      var json = CryptoJS.AES.encrypt(msg, this.pass, options);
      return json.ciphertext.toString(CryptoJS.enc.Hex);
    } catch (err) {
      console.error(err);
      return """";
    }
  },
  decript: function (hex){
    try {
      var options = { mode: CryptoJS.mode.CBC, iv: this.iv};
      var json = CryptoJS.AES.decrypt({
        ciphertext: CryptoJS.enc.Hex.parse(hex)
      }, this.pass, options);
      return json.toString(CryptoJS.enc.Utf8);
    } catch (err) {
      console.error(err);
      return """";
    }
  }
</code></pre>

<hr>

<p>You still have security problems:</p>

<ul>
<li><p>The IV has to be randomly chosen for every encryption under the same key to achieve semantic security. It doesn't have to be secret, so you can simply send it along with the ciphertext. It's common to prepend it to the ciphertext and slice it off before decryption.</p></li>
<li><p>It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme with a strong MAC like HMAC-SHA256, which CryptoJS provides.</p></li>
</ul>
","2266","<javascript><node.js><encryption><cryptojs><node-crypto>","1","2","1","2016-06-27 09:31:23","35534602","0","1","972240","","2016-06-27 09:31:23","2016-02-21 05:28:15",""
"20433467","How to get the same result with PHP and CryptoJS using SHA256?","<p>I'm trying to decode Firefox Sync data using javascript, porting one php library which does it (<a href=""https://github.com/mikerowehl/firefox-sync-client-php"" rel=""nofollow"">https://github.com/mikerowehl/firefox-sync-client-php</a>). The idea is to decode sync data without sending sync key to the server. This is just context, the problem I have is much more specific.</p>

<p>One portion of code requires using sha256 to obtain certain key. I would like to replicate it in javascript. The approach I've tried, with CryptoJS, is this:</p>

<p>PHP code:</p>

<pre><code>$key = hash_hmac(""sha256"",'OLA K ASE','CLAVE', false);
print $key;
</code></pre>

<p>Equivalent Javascript code (previously, I've included <a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js</a>):</p>

<pre><code>var hash = CryptoJS.HmacSHA256(""OLA K ASE"", ""CLAVE"");
console.log(hash.toString());
</code></pre>

<p>This works fine. In each case, output is 9591d44df0c8e2d7a1f400f41117c536e10f58d7e28bdc1cad9d81e70290bc1b, which I suppose is correct. </p>

<p>But, when I'm trying to encode non-ascii strings, results differ. For example, with this PHP code:</p>

<pre><code>function hexstring($str){
    return preg_replace('/\\\\x([0-9a-f]{2})/e', 'chr(hexdec(\'$1\'))', $str);
}
$text = hexstring('\x00\x44\xb0\x2c\x0b');
$key = hexstring('\xd6\xf8\xb0\x2c\x0b');
$hash = hash_hmac(""sha256"",$text,$key, false);
print $hash;
</code></pre>

<p>I get <code>0697f5528c996006ffeb09b9130bf8e9056563245656d405e233bcafdbffb645</code>. But with the 'equivalent' javascript code:</p>

<pre><code>var text = ""\x00\x44\xb0\x2c\x0b"";
var key = ""\xd6\xf8\xb0\x2c\x0b"";
hash = CryptoJS.HmacSHA256(text,key);
console.log(hash.toString());
</code></pre>

<p>I get <code>13c983b69f82c277815c03d13e90b1ec1e9cbca2b6912ad1f8224f3de8b82130</code>, a different value.</p>

<p>I thought it could be caused by non-ascii character, so I did a quick test:</p>

<pre><code>$text = '';
for($i = 0;$i &lt; 10; $i++){
    $text .= chr($i);
}
$key = '';
for($i = 0;$i &lt; 10; $i++){
    $key .= chr($i*2);
}
$hash = hash_hmac(""sha256"",$text,$key, false);
print $hash;
</code></pre>

<p>And, javascript equivalent:</p>

<pre><code>var text = '';
for(i = 0;i &lt; 10; i++){
    text += String.fromCharCode(i);
}
var key = '';
for(i = 0;i &lt; 10; i++){
    key += String.fromCharCode(i*2);
}
var hash = CryptoJS.HmacSHA256(text, key);
console.log(hash.toString());
</code></pre>

<p>In both cases, output is <code>c5d7adbbabcec5416c6b7a1f01e17e42d95a529f5bcc805d9b04b93f33994c9d</code>.</p>

<p>This is a big WTF? for me. Could somebody give me a piece of advice of how to continue with this?</p>
","<p>Try that:</p>

<pre><code>$text = ""\x00\x44\xb0\x2c\x0b"";
$key = ""\xd6\xf8\xb0\x2c\x0b"";
$hash = hash_hmac(""sha256"",$text,$key, false);
print $hash;
</code></pre>

<p>It's proabably because the preg_* functions have a problem with these special characters.
And PHP supports \x12 hex-encoding without any function.</p>
","2262","<javascript><php><character-encoding><iso-8859-1><cryptojs>","0","0","2","2013-12-07 20:58:04","20446517","0","","3075824","","2013-12-07 20:58:04","2013-12-06 20:58:21",""
"20433467","How to get the same result with PHP and CryptoJS using SHA256?","<p>I'm trying to decode Firefox Sync data using javascript, porting one php library which does it (<a href=""https://github.com/mikerowehl/firefox-sync-client-php"" rel=""nofollow"">https://github.com/mikerowehl/firefox-sync-client-php</a>). The idea is to decode sync data without sending sync key to the server. This is just context, the problem I have is much more specific.</p>

<p>One portion of code requires using sha256 to obtain certain key. I would like to replicate it in javascript. The approach I've tried, with CryptoJS, is this:</p>

<p>PHP code:</p>

<pre><code>$key = hash_hmac(""sha256"",'OLA K ASE','CLAVE', false);
print $key;
</code></pre>

<p>Equivalent Javascript code (previously, I've included <a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js</a>):</p>

<pre><code>var hash = CryptoJS.HmacSHA256(""OLA K ASE"", ""CLAVE"");
console.log(hash.toString());
</code></pre>

<p>This works fine. In each case, output is 9591d44df0c8e2d7a1f400f41117c536e10f58d7e28bdc1cad9d81e70290bc1b, which I suppose is correct. </p>

<p>But, when I'm trying to encode non-ascii strings, results differ. For example, with this PHP code:</p>

<pre><code>function hexstring($str){
    return preg_replace('/\\\\x([0-9a-f]{2})/e', 'chr(hexdec(\'$1\'))', $str);
}
$text = hexstring('\x00\x44\xb0\x2c\x0b');
$key = hexstring('\xd6\xf8\xb0\x2c\x0b');
$hash = hash_hmac(""sha256"",$text,$key, false);
print $hash;
</code></pre>

<p>I get <code>0697f5528c996006ffeb09b9130bf8e9056563245656d405e233bcafdbffb645</code>. But with the 'equivalent' javascript code:</p>

<pre><code>var text = ""\x00\x44\xb0\x2c\x0b"";
var key = ""\xd6\xf8\xb0\x2c\x0b"";
hash = CryptoJS.HmacSHA256(text,key);
console.log(hash.toString());
</code></pre>

<p>I get <code>13c983b69f82c277815c03d13e90b1ec1e9cbca2b6912ad1f8224f3de8b82130</code>, a different value.</p>

<p>I thought it could be caused by non-ascii character, so I did a quick test:</p>

<pre><code>$text = '';
for($i = 0;$i &lt; 10; $i++){
    $text .= chr($i);
}
$key = '';
for($i = 0;$i &lt; 10; $i++){
    $key .= chr($i*2);
}
$hash = hash_hmac(""sha256"",$text,$key, false);
print $hash;
</code></pre>

<p>And, javascript equivalent:</p>

<pre><code>var text = '';
for(i = 0;i &lt; 10; i++){
    text += String.fromCharCode(i);
}
var key = '';
for(i = 0;i &lt; 10; i++){
    key += String.fromCharCode(i*2);
}
var hash = CryptoJS.HmacSHA256(text, key);
console.log(hash.toString());
</code></pre>

<p>In both cases, output is <code>c5d7adbbabcec5416c6b7a1f01e17e42d95a529f5bcc805d9b04b93f33994c9d</code>.</p>

<p>This is a big WTF? for me. Could somebody give me a piece of advice of how to continue with this?</p>
","<p>Solved. It was a problem with character codes. Instead of this:</p>

<pre><code>var text = ""\x00\x44\xb0\x2c\x0b"";
var key = ""\xd6\xf8\xb0\x2c\x0b"";
hash = CryptoJS.HmacSHA256(text,key);
</code></pre>

<p>I should indicate CryptoJS that they were Latin-1 encoded strings:</p>

<pre><code>var text = CryptoJS.enc.Latin1.parse(""\x00\x44\xb0\x2c\x0b"");
var key = CryptoJS.enc.Latin1.parse(""\xd6\xf8\xb0\x2c\x0b"");
hash = CryptoJS.HmacSHA256(text,key);
</code></pre>

<p>I don't know clearly why is this happening, so if somebody could explain it with a little bit of detail it would be great.</p>
","2262","<javascript><php><character-encoding><iso-8859-1><cryptojs>","0","1","2","2013-12-07 20:58:04","20446517","0","","3075824","","2013-12-07 20:58:04","2013-12-06 20:58:21",""
"14400729","CryptoJS.AES and Golang","<p>i already managed to share a random symetric key via rsa.
However i fail to make aes-encryption work with it.
Problem seems to be the salt and initialization vector, that cryptoJS uses.</p>

<p>First it's output is along the lines of:</p>

<pre><code>U2FsdGVkX19wbzVqqOr6U5dnuG34WyH+n1A4PX9Z+xBhY3bALGS7DOa/aphgnubc 
</code></pre>

<p>Googling for the reoccuring ""U2FsdGVkX"" or ""cryptoJS.AES output"" sadly is of no use.</p>

<p>On the other hand, golang's aes requires only a 32bit key and input of 32bit length each.
Which means i have to somehow split the above into the corresponding blocks and figure out, how to create the 32bit key out of the secret key and the data above (which proably includes salt + init vector).</p>

<p>Sadly neither <a href=""http://code.google.com/p/crypto-js"" rel=""nofollow"">http://code.google.com/p/crypto-js</a> nor any google search provide me with a solution.</p>

<p>By the way - my encryption right now:</p>

<pre><code>var arr = new Array(32);
symetricKey = """";
var symHex = """";
rng.nextBytes(arr);
for(var i = 0; i &lt; arr.length; i++){
    symetricKey += String.fromCharCode(arr[i]);
    //symHex= arr[i].toString(16), added a 0 if needed (so length always increases by 2)
}
//submit symetric via rsa. This is working, the server gets that key
var enc = CryptoJS.AES.encrypt(unencrypted, symetricKey)
//submit enc, stuck now - what to do with it on the server?
</code></pre>

<p><br>
<strong>Edit:</strong> After the Base64 response:<br>
Thanks for the base64 input.<br>
However i still don't manage to bring it to work.
<br>Especially since the encoded string starts with ""SALTED"",
i believe, that there might be a problem.</p>

<p>Way i try to encode now:<br>
Encoded on Client by:<br></p>

<pre><code>var unencrypted = ""{mail:test,password:test}""
var enc = CryptoJS.AES.encrypt(unencrypted, symKey)
</code></pre>

<p>On Server, the variables enc and symKey are the same as on Client:</p>

<pre><code>baseReader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(enc))
encData, err := ioutil.ReadAll(baseReader)
//if err != nil { ....}, doesn't happen here
cipher, err := aes.NewCipher(symKey)
//if err != nil { ....}, doesn't happen here
byteData := make([]byte, len(encData))
cipher.Decrypt(byteData, encData)
fmt.Println(""Dec: "", string(byteData))
//Outputs unrepresentable characters
</code></pre>

<p>Any idea?</p>
","<pre><code>U2FsdGVkX19wbzVqqOr6U5dnuG34WyH+n1A4PX9Z+xBhY3bALGS7DOa/aphgnubc 
</code></pre>

<p>That data is <code>base64</code> encoded, raw it looks something like this:</p>

<pre><code>Salted__po5jSgm[!P8=Yacv,dj`
</code></pre>

<p>(note that there are unrepresentable characters in that string)</p>

<p>And this is exactly 32 bytes long.</p>
","2253","<go><cryptojs>","4","2","4","2014-04-14 15:21:39","14403837","0","1","1977711","","2013-01-18 16:41:01","2013-01-18 14:14:06",""
"14400729","CryptoJS.AES and Golang","<p>i already managed to share a random symetric key via rsa.
However i fail to make aes-encryption work with it.
Problem seems to be the salt and initialization vector, that cryptoJS uses.</p>

<p>First it's output is along the lines of:</p>

<pre><code>U2FsdGVkX19wbzVqqOr6U5dnuG34WyH+n1A4PX9Z+xBhY3bALGS7DOa/aphgnubc 
</code></pre>

<p>Googling for the reoccuring ""U2FsdGVkX"" or ""cryptoJS.AES output"" sadly is of no use.</p>

<p>On the other hand, golang's aes requires only a 32bit key and input of 32bit length each.
Which means i have to somehow split the above into the corresponding blocks and figure out, how to create the 32bit key out of the secret key and the data above (which proably includes salt + init vector).</p>

<p>Sadly neither <a href=""http://code.google.com/p/crypto-js"" rel=""nofollow"">http://code.google.com/p/crypto-js</a> nor any google search provide me with a solution.</p>

<p>By the way - my encryption right now:</p>

<pre><code>var arr = new Array(32);
symetricKey = """";
var symHex = """";
rng.nextBytes(arr);
for(var i = 0; i &lt; arr.length; i++){
    symetricKey += String.fromCharCode(arr[i]);
    //symHex= arr[i].toString(16), added a 0 if needed (so length always increases by 2)
}
//submit symetric via rsa. This is working, the server gets that key
var enc = CryptoJS.AES.encrypt(unencrypted, symetricKey)
//submit enc, stuck now - what to do with it on the server?
</code></pre>

<p><br>
<strong>Edit:</strong> After the Base64 response:<br>
Thanks for the base64 input.<br>
However i still don't manage to bring it to work.
<br>Especially since the encoded string starts with ""SALTED"",
i believe, that there might be a problem.</p>

<p>Way i try to encode now:<br>
Encoded on Client by:<br></p>

<pre><code>var unencrypted = ""{mail:test,password:test}""
var enc = CryptoJS.AES.encrypt(unencrypted, symKey)
</code></pre>

<p>On Server, the variables enc and symKey are the same as on Client:</p>

<pre><code>baseReader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(enc))
encData, err := ioutil.ReadAll(baseReader)
//if err != nil { ....}, doesn't happen here
cipher, err := aes.NewCipher(symKey)
//if err != nil { ....}, doesn't happen here
byteData := make([]byte, len(encData))
cipher.Decrypt(byteData, encData)
fmt.Println(""Dec: "", string(byteData))
//Outputs unrepresentable characters
</code></pre>

<p>Any idea?</p>
","<p>The output of CryptoJS.AES.encrypt is a CipherParams object containing the key, IV, optional salt, and ciphertext.  The string you were referencing was a OpenSSL-compatible formatted string.</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

alert(encrypted.key);        // 74eb593087a982e2a6f5dded54ecd96d1fd0f3d44a58728cdcd40c55227522223
alert(encrypted.iv);         // 7781157e2629b094f0e3dd48c4d786115
alert(encrypted.salt);       // 7a25f9132ec6a8b34
alert(encrypted.ciphertext); // 73e54154a15d1beeb509d9e12f1e462a0

alert(encrypted);            // U2FsdGVkX1+iX5Ey7GqLND5UFUoV0b7rUJ2eEvHkYqA= (OpenSSL-compatible format strategy)
</code></pre>

<p>CryptoJS' default encryption mode is CBC.  You should pass the IV along with your symmetric key during your RSA-encrypted exchange.  With the symmetric key, IV, and cipher text byte arrays on the server, you can decrypt it in Go similar to this:</p>

<pre><code>c, err := aes.NewCipher(key)
cfbdec := cipher.NewCBCDecrypter(c, iv)
plaintext := make([]byte, len(ciphertext))
cfbdec.CryptBlock(plaintext, ciphertext)
</code></pre>
","2253","<go><cryptojs>","4","4","4","2014-04-14 15:21:39","14403837","0","1","1977711","","2013-01-18 16:41:01","2013-01-18 14:14:06",""
"14400729","CryptoJS.AES and Golang","<p>i already managed to share a random symetric key via rsa.
However i fail to make aes-encryption work with it.
Problem seems to be the salt and initialization vector, that cryptoJS uses.</p>

<p>First it's output is along the lines of:</p>

<pre><code>U2FsdGVkX19wbzVqqOr6U5dnuG34WyH+n1A4PX9Z+xBhY3bALGS7DOa/aphgnubc 
</code></pre>

<p>Googling for the reoccuring ""U2FsdGVkX"" or ""cryptoJS.AES output"" sadly is of no use.</p>

<p>On the other hand, golang's aes requires only a 32bit key and input of 32bit length each.
Which means i have to somehow split the above into the corresponding blocks and figure out, how to create the 32bit key out of the secret key and the data above (which proably includes salt + init vector).</p>

<p>Sadly neither <a href=""http://code.google.com/p/crypto-js"" rel=""nofollow"">http://code.google.com/p/crypto-js</a> nor any google search provide me with a solution.</p>

<p>By the way - my encryption right now:</p>

<pre><code>var arr = new Array(32);
symetricKey = """";
var symHex = """";
rng.nextBytes(arr);
for(var i = 0; i &lt; arr.length; i++){
    symetricKey += String.fromCharCode(arr[i]);
    //symHex= arr[i].toString(16), added a 0 if needed (so length always increases by 2)
}
//submit symetric via rsa. This is working, the server gets that key
var enc = CryptoJS.AES.encrypt(unencrypted, symetricKey)
//submit enc, stuck now - what to do with it on the server?
</code></pre>

<p><br>
<strong>Edit:</strong> After the Base64 response:<br>
Thanks for the base64 input.<br>
However i still don't manage to bring it to work.
<br>Especially since the encoded string starts with ""SALTED"",
i believe, that there might be a problem.</p>

<p>Way i try to encode now:<br>
Encoded on Client by:<br></p>

<pre><code>var unencrypted = ""{mail:test,password:test}""
var enc = CryptoJS.AES.encrypt(unencrypted, symKey)
</code></pre>

<p>On Server, the variables enc and symKey are the same as on Client:</p>

<pre><code>baseReader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(enc))
encData, err := ioutil.ReadAll(baseReader)
//if err != nil { ....}, doesn't happen here
cipher, err := aes.NewCipher(symKey)
//if err != nil { ....}, doesn't happen here
byteData := make([]byte, len(encData))
cipher.Decrypt(byteData, encData)
fmt.Println(""Dec: "", string(byteData))
//Outputs unrepresentable characters
</code></pre>

<p>Any idea?</p>
","<p>There are probably a few issues we'll need to work through.</p>

<p>First, you need to make sure you're supplying the correct type of arguments to encrypt(). It looks like you may have realized in a comment that you need to do CryptoJS.enc.Hex.parse(symetricKeyHex), though your original post doesn't reflect this yet.</p>

<p>Second, you need to decide how you're getting or creating the IV on both ends. CryptoJS can create one if you use a passphrase, but you're trying to use an actual key rather than a passphrase. That means you'll have to set the IV like you set the key.</p>

<p>Finally, you'll have to decide how you're going to transmit both the IV and the ciphertext. A typical and simple solution is to prepend the IV to the ciphertext, but really anything that's easily serializable/unserializable will work fine. Just make sure that whatever format you decide on is consistent on both ends.</p>
","2253","<go><cryptojs>","4","0","4","2014-04-14 15:21:39","14403837","0","1","1977711","","2013-01-18 16:41:01","2013-01-18 14:14:06",""
"14400729","CryptoJS.AES and Golang","<p>i already managed to share a random symetric key via rsa.
However i fail to make aes-encryption work with it.
Problem seems to be the salt and initialization vector, that cryptoJS uses.</p>

<p>First it's output is along the lines of:</p>

<pre><code>U2FsdGVkX19wbzVqqOr6U5dnuG34WyH+n1A4PX9Z+xBhY3bALGS7DOa/aphgnubc 
</code></pre>

<p>Googling for the reoccuring ""U2FsdGVkX"" or ""cryptoJS.AES output"" sadly is of no use.</p>

<p>On the other hand, golang's aes requires only a 32bit key and input of 32bit length each.
Which means i have to somehow split the above into the corresponding blocks and figure out, how to create the 32bit key out of the secret key and the data above (which proably includes salt + init vector).</p>

<p>Sadly neither <a href=""http://code.google.com/p/crypto-js"" rel=""nofollow"">http://code.google.com/p/crypto-js</a> nor any google search provide me with a solution.</p>

<p>By the way - my encryption right now:</p>

<pre><code>var arr = new Array(32);
symetricKey = """";
var symHex = """";
rng.nextBytes(arr);
for(var i = 0; i &lt; arr.length; i++){
    symetricKey += String.fromCharCode(arr[i]);
    //symHex= arr[i].toString(16), added a 0 if needed (so length always increases by 2)
}
//submit symetric via rsa. This is working, the server gets that key
var enc = CryptoJS.AES.encrypt(unencrypted, symetricKey)
//submit enc, stuck now - what to do with it on the server?
</code></pre>

<p><br>
<strong>Edit:</strong> After the Base64 response:<br>
Thanks for the base64 input.<br>
However i still don't manage to bring it to work.
<br>Especially since the encoded string starts with ""SALTED"",
i believe, that there might be a problem.</p>

<p>Way i try to encode now:<br>
Encoded on Client by:<br></p>

<pre><code>var unencrypted = ""{mail:test,password:test}""
var enc = CryptoJS.AES.encrypt(unencrypted, symKey)
</code></pre>

<p>On Server, the variables enc and symKey are the same as on Client:</p>

<pre><code>baseReader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(enc))
encData, err := ioutil.ReadAll(baseReader)
//if err != nil { ....}, doesn't happen here
cipher, err := aes.NewCipher(symKey)
//if err != nil { ....}, doesn't happen here
byteData := make([]byte, len(encData))
cipher.Decrypt(byteData, encData)
fmt.Println(""Dec: "", string(byteData))
//Outputs unrepresentable characters
</code></pre>

<p>Any idea?</p>
","<p>Although, it don't directly but maybe you will find it useful to have a look at <a href=""https://github.com/dgryski/dkeyczar"" rel=""nofollow"">https://github.com/dgryski/dkeyczar</a>.</p>

<p>Its Go implementation of <a href=""http://www.keyczar.org/"" rel=""nofollow"">KeyCzar</a>, open source cryptographic toolkit originally developed by members of the Google Security Team</p>

<p>I hope you can learn something from this project</p>
","2253","<go><cryptojs>","4","1","4","2014-04-14 15:21:39","14403837","0","1","1977711","","2013-01-18 16:41:01","2013-01-18 14:14:06",""
"45082597","PHP openssl_encrypt in JavaScript with CryptoJS","<p>I have a problem generating the same ciphertext in JavaScript as provided in a  third party PHP server. The server side uses a simple one-liner to generate a key, but I can't find a way to do the same in my JavaScript client. </p>

<p>I decided to use the CryptoJS library, from <a href=""https://stackoverflow.com/questions/24337317/encrypt-with-php-decrypt-with-javascript-cryptojs"" title=""other answers"">other SO answers </a>, and I did generate a ciphertext but it was different that the one from a PHP server.</p>

<p>PHP encryption:</p>

<pre><code>echo openssl_encrypt(""5905"",""AES-256-CBC"",""FbcCY2yCFBwVCUE9R+6kJ4fAL4BJxxjdRcqy5rHVLwU="",NULL,""e16ce913a20dadb8"");
// phgygAJB3GA0sa4D9k/d8A==
</code></pre>

<p>I have tried several solutions from Stack Overflow which failed to create the same ciphertext.</p>

<p>Also, the parameter ""AES-256-CBC"" in the PHP one-liner bothers me: I know what AES is, but I have no idea what those 256 or CBC parts are, and I don't know where to set those on the CryptoJS side.</p>

<p>My current attempt:</p>

<pre><code>var key = 'FbcCY2yCFBwVCUE9R+6kJ4fAL4BJxxjdRcqy5rHVLwU=';
var iv = 'e16ce913a20dadb8';
var encrypted = CryptoJS.AES.encrypt(""5905"", CryptoJS.enc.Hex.parse(key), { iv: CryptoJS.enc.Hex.parse(iv) });
var r1 = encrypted.ciphertext.toString(); // def44f8822cfb3f317a3c5b67182b437
var r2 = CryptoJS.enc.Base64.stringify(encrypted.ciphertext) // 3vRPiCLPs/MXo8W2cYK0Nw==
</code></pre>

<p>My guess is that I am missing ""256"" and ""CBC"" parameters somewhere in JavaScript.</p>
","<p>Your ""key"" is 44 characters long which also equates to 44 bytes in PHP. This is not a valid key size. AES only supports 16, 24 and 32 byte keys. Anyway, this ""key"" will be truncated to 32 byte. So your actual key in PHP is:</p>

<pre><code>""FbcCY2yCFBwVCUE9R+6kJ4fAL4BJxxjd""
</code></pre>

<p>Your IV is 16 characters (and byte) long, so it has the correct length and used as-is.</p>

<p>This is also why you can treat the key and IV in CryptoJS as strings:</p>

<pre><code>CryptoJS.AES.encrypt(""5905"", CryptoJS.enc.Utf8.parse(key), { iv: CryptoJS.enc.Utf8.parse(iv) });
</code></pre>

<p><strong>But</strong> the correct way would be to decode the key from Base64 and generate a proper IV which is twice as long when encoded to Hex. It should be decoded from Hex before use.</p>

<p>The IV must be unpredictable (read: random). Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. The IV is not secret, so you can send it along with the ciphertext. Usually, it is simply prepended to the ciphertext and sliced off before decryption.</p>
","2253","<javascript><encryption><encoding><cryptojs>","3","5","1","2017-07-13 19:25:14","45089403","0","","1816580","","2017-07-13 19:25:14","2017-07-13 13:47:57",""
"17368972","match cryptojs with c# hmacsha512","<p>Why are my HMACs different?<br>
I've created a visual studio 2012 solution here: <a href=""https://github.com/tonyeung/hmacsha512"" rel=""nofollow"">https://github.com/tonyeung/hmacsha512</a></p>

<p>My js</p>

<pre><code>    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha512.js""&gt;&lt;/script&gt;

    var rawSig = ""abc:123:Fri, 28 Jun 2013 15:03:00 GMT"";
    var token = ""c22b31a2-780b-4ac5-8bd5-1296b05130f4""
    var hash = CryptoJS.HmacSHA512(rawSig, token);
    var sig = hash.toString(CryptoJS.enc.Base64);
</code></pre>

<p>my c#</p>

<pre><code>    public JsonResult hmac(string sig, string token)
    {
        var signature = string.Empty;
        using (var hmac = new HMACSHA512(Encoding.UTF8.GetBytes(token)))
        {
            var hash = hmac.ComputeHash(Encoding.UTF8.GetBytes(sig));
            signature = Convert.ToBase64String(hash);
        }

        return Json(signature);
    }
</code></pre>

<p>the result:  </p>

<pre><code>CryptoJS Result
93de274be49d5120f5fef8f7c7c91982ba3ad7ae4e967ef86bdd73cf9e5e67a133ffb185e6993b33a323aade155173bb6a2ddd61fde19a6d09f40260d732dbe3

C# Result  
k94nS+SdUSD1/vj3x8kZgro6165Oln74a91zz55eZ6Ez/7GF5pk7M6Mjqt4VUXO7ai3dYf3hmm0J9AJg1zLb4w==
</code></pre>
","<p>I needed to flip the cryptojs reference</p>

<p>from</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha512.js""&gt;&lt;/script&gt;
</code></pre>

<p>to</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha512.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>

<p>found this site to be immensely helpful: <a href=""http://jokecamp.wordpress.com/2012/10/21/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/"" rel=""nofollow"">http://jokecamp.wordpress.com/2012/10/21/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/</a></p>
","2251","<c#><hmac><cryptojs>","2","1","1","2013-06-28 17:48:21","17370737","0","1","","","","2013-06-28 16:02:40",""
"22601095","CryptoJS no method mixIn","<p>I am getting the following error in my browser (Chrome):</p>

<pre><code>Uncaught TypeError: Object [object global] has no method 'mixIn' aes.js:28
    d.CipherParams.l.extend.init aes.js:28
    c.hasOwnProperty.c.init sha1.js:7
    e jQuery.js:7
    Wc jQuery.js:7
    Wc jQuery.js:7
    n.param jQuery.js:7
    n.extend.ajax jQuery.js:7
    saveCurrentNote (index):88
    selectNote (index):97
    (anonymous function) (index):125
    n.event.dispatch jQuery.js:6
    r.handle
</code></pre>

<p>Here is the source code:</p>

<pre><code>&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/jQuery.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/cryptojs/rollups/sha1.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/cryptojs/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/cryptojs/rollups/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/cryptojs/rollups/sha3.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/Basic.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""&lt;?php echo Yii::app()-&gt;request-&gt;baseUrl ?&gt;/js/Auth.js""&gt;&lt;/script&gt;
</code></pre>

<p>Inside Basic.js:</p>

<pre><code>function encrypt(data, key) {
return CryptoJS.AES.encrypt(data, key);
}

function decrypt(data, key) {
return CryptoJS.AES.decrypt(data, key);
}
</code></pre>

<p>And the usage of these functions:</p>

<pre><code>data[""name""] = encrypt(data[""name""], recall(""key""));
data[""text""] = encrypt(data[""text""], recall(""key""));
</code></pre>

<p>Here is the link to the CryptoJS library: <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a></p>

<p>Is there something I am not doing?</p>
","<p>This is an old question but i just ran into same issue. The problem is that the CryptoJS.AES.encrypt method returns an object not a string. </p>

<p>All you need to do is modify your encrypt function as follows:</p>

<pre><code>function encrypt(data, key) {
   return CryptoJS.AES.encrypt(data, key).toString();
}
</code></pre>

<p>Likewise, the decrypt function also returns an object so to get the string use:</p>

<pre><code>function decrypt(data, key) {
   return CryptoJS.AES.decrypt(data, key).toString(CryptoJS.enc.Utf8);
}
</code></pre>
","2245","<javascript><jquery><cryptojs>","1","6","1","2015-05-29 22:17:36","","0","","","","","2014-03-24 04:27:29",""
"26186377","AES encrypt java and javascript different output","<p>Since a couple of days i try to figure out why i have in javascript(cryptojs) and java different encryption output. Im at a dead end and dont know what to change anymore, i think i will lose my head on this. This is the complete code and should be easy to copy paste for testing. You are my last hope. ^^</p>

<pre><code>plainText = plaintext
password = password
salt = 3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55
iv = 3C46C00F42A6044A""
</code></pre>

<blockquote>
  <p>Javascript result = zbohHpV5RtmHiH3cKDY15w==</p>
  
  <p>Java result = wVdRQiIqkyVlttkWpCMSpQ==</p>
</blockquote>

<p><strong>Javascript html:</strong> updated and changed iterations to 10</p>

<pre><code>&lt;!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""     ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""&gt;
&lt;html xmlns=""http://www.w3.org/1999/xhtml""&gt;
    &lt;head&gt;
        &lt;meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" /&gt;
        &lt;title&gt;Aes Test&lt;/title&gt;
        &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/pbkdf2.js""&gt;&lt;/script&gt;
        &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=""result""&gt;&lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;


var password = ""password"";
var salt = ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"";

var plainText = ""plaintext"";
var iv = ""3C46C00F42A6044A"";

var key = CryptoJS.PBKDF2(password, CryptoJS.enc.Hex.parse(salt), {keySize: 128/32, iterations: 10});

var a = CryptoJS.AES.encrypt(plainText, key, {iv: CryptoJS.enc.Hex.parse(iv)}).ciphertext.toString(CryptoJS.enc.Base64);


var result = ""encypted: "" + a + ""&lt;br \&gt;"";
document.getElementById(""result"").innerHTML = result;
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Java Main.class</strong></p>

<pre><code>public class main {

    public static void main(String[] args) throws Exception {
        String result = Aes.encrypt(""plaintext"", ""password"", ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"", ""3C46C00F42A6044A"");
        System.out.println(result);    
    }  
}
</code></pre>

<p><strong>Java Aes.class</strong></p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Aes { 
    private static final int pswdIterations = 10;
    private static final int keySize =  128;

    public static String encrypt(String plainText, String password, String salt, String initializationVector) throws NoSuchAlgorithmException, InvalidKeySpecException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] saltBytes = salt.getBytes(""UTF-8"");
        byte[] ivBytes = initializationVector.getBytes(""UTF-8"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes, pswdIterations, keySize);
        SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivBytes));
        byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes());
        return new Base64().encodeAsString(encryptedTextBytes);
    } 
}
</code></pre>
","<p>First of all your JavaScript code is wrong. Try the code below to see that your keySize and iterationCount variables are undefined.</p>

<pre><code>Aes.generateKey = function(salt, passPhrase) {
  console.log(this.keySize);
  console.log(this.iterationCount);
  var key = CryptoJS.PBKDF2(
          passPhrase, 
          CryptoJS.enc.Hex.parse(salt),
          { keySize: this.keySize, iterations: this.iterationCount });
  return key;
 }
</code></pre>

<p>The result from JavaScript should be Bttn5HNBIFDQ5hb1IbOFXQ==</p>

<pre><code>var password = ""password"";
var salt = ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"";

var plainText = ""plaintext"";
var iv = ""3C46C00F42A6044A"";

var key = CryptoJS.PBKDF2(password, CryptoJS.enc.Hex.parse(salt), {keySize: 128/32, iterations: 10000});

var a = CryptoJS.AES.encrypt(plainText, key, {iv: CryptoJS.enc.Hex.parse(iv)}).ciphertext.toString(CryptoJS.enc.Base64);

console.log(a);
</code></pre>
","2192","<java><javascript><encryption><aes><cryptojs>","0","0","2","2015-09-30 04:15:14","26187498","8","4","3879820","","2014-10-03 22:36:39","2014-10-03 20:31:51",""
"26186377","AES encrypt java and javascript different output","<p>Since a couple of days i try to figure out why i have in javascript(cryptojs) and java different encryption output. Im at a dead end and dont know what to change anymore, i think i will lose my head on this. This is the complete code and should be easy to copy paste for testing. You are my last hope. ^^</p>

<pre><code>plainText = plaintext
password = password
salt = 3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55
iv = 3C46C00F42A6044A""
</code></pre>

<blockquote>
  <p>Javascript result = zbohHpV5RtmHiH3cKDY15w==</p>
  
  <p>Java result = wVdRQiIqkyVlttkWpCMSpQ==</p>
</blockquote>

<p><strong>Javascript html:</strong> updated and changed iterations to 10</p>

<pre><code>&lt;!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN""     ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""&gt;
&lt;html xmlns=""http://www.w3.org/1999/xhtml""&gt;
    &lt;head&gt;
        &lt;meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" /&gt;
        &lt;title&gt;Aes Test&lt;/title&gt;
        &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/pbkdf2.js""&gt;&lt;/script&gt;
        &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=""result""&gt;&lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;


var password = ""password"";
var salt = ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"";

var plainText = ""plaintext"";
var iv = ""3C46C00F42A6044A"";

var key = CryptoJS.PBKDF2(password, CryptoJS.enc.Hex.parse(salt), {keySize: 128/32, iterations: 10});

var a = CryptoJS.AES.encrypt(plainText, key, {iv: CryptoJS.enc.Hex.parse(iv)}).ciphertext.toString(CryptoJS.enc.Base64);


var result = ""encypted: "" + a + ""&lt;br \&gt;"";
document.getElementById(""result"").innerHTML = result;
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Java Main.class</strong></p>

<pre><code>public class main {

    public static void main(String[] args) throws Exception {
        String result = Aes.encrypt(""plaintext"", ""password"", ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"", ""3C46C00F42A6044A"");
        System.out.println(result);    
    }  
}
</code></pre>

<p><strong>Java Aes.class</strong></p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Aes { 
    private static final int pswdIterations = 10;
    private static final int keySize =  128;

    public static String encrypt(String plainText, String password, String salt, String initializationVector) throws NoSuchAlgorithmException, InvalidKeySpecException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] saltBytes = salt.getBytes(""UTF-8"");
        byte[] ivBytes = initializationVector.getBytes(""UTF-8"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes, pswdIterations, keySize);
        SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivBytes));
        byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes());
        return new Base64().encodeAsString(encryptedTextBytes);
    } 
}
</code></pre>
","<p>Finally they are both equal thanks to pasimako to put me on the road. I had to change the way iv and salt was converted to hex and also the lenght of the iv and as mentioned above the keySize and iterationCount variables were undefined aswell.</p>

<p>Here is the complete working code.</p>

<p>They both should output:</p>

<blockquote>
  <p>encypted: 47S4kEkmEoMoOgngftzyFg==</p>
</blockquote>

<p><strong>Javascript</strong></p>

<pre><code>&lt;script&gt;
var password = ""password"";
var salt = ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"";

var plainText = ""plaintext"";
var iv = ""12345678901234567890123456789012"";

var key = CryptoJS.PBKDF2(password, CryptoJS.enc.Hex.parse(salt), {keySize: 128/32, iterations: 10});

var a = CryptoJS.AES.encrypt(plainText, key, {iv: CryptoJS.enc.Hex.parse(iv)}).ciphertext.toString(CryptoJS.enc.Base64);


var result = ""encypted: "" + a + ""&lt;br \&gt;"";
document.getElementById(""result"").innerHTML = result;
&lt;/script&gt;
</code></pre>

<p><strong>Java Main.class</strong></p>

<pre><code>public class main {

public static void main(String[] args) throws Exception {
    String result = Aes.encrypt(""plaintext"", ""password"", ""3FF2EC019C627B945225DEBAD71A01B6985FE84C95A70EB132882F88C0A59A55"", ""12345678901234567890123456789012"");
    System.out.println(result);    
}  
}
</code></pre>

<p><strong>Java Aes.class</strong></p>

<pre><code>public class Aes { 
private static final int pswdIterations = 10;
private static final int keySize =  128;

public static String encrypt(String plainText, String password, String salt, String initializationVector) throws NoSuchAlgorithmException, NoSuchPaddingException, DecoderException, InvalidKeySpecException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException  {
             Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
             SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
             KeySpec spec = new PBEKeySpec(password.toCharArray(), Hex.decodeHex(salt.toCharArray()), pswdIterations, keySize);
             SecretKey key = new SecretKeySpec(factory.generateSecret(spec).getEncoded(), ""AES"");
             cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(Hex.decodeHex(initializationVector.toCharArray())));
             byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes());
             return new Base64().encodeAsString(encryptedTextBytes);
} 
}
</code></pre>
","2192","<java><javascript><encryption><aes><cryptojs>","0","1","2","2015-09-30 04:15:14","26187498","8","4","3879820","","2014-10-03 22:36:39","2014-10-03 20:31:51",""
"22262033","AES algorithm value differences between .NET and nodejs, CryptoJS","<p>The below AES algorithm in C# returns an encrypted value that is different from what node js and CryptoJS returns. NodeJS Crypto library and CryptoJS return the same values but .NET's AesCryptoServiceProvider returns a different value. Any ideas?</p>

<p><strong>C# example</strong></p>

<pre><code>    private const string AesIV = @""!QAZ2WSX#EDC4RFV"";
    private const string AesKey = @""5TGB&amp;YHN7UJM(IK&lt;"";


    public static void Main()
    {
        try
        {
            string original = ""HelloWorld"";
            Console.WriteLine(Encrypt(original));
        }
        catch (Exception e)
        {
            Console.WriteLine(""Error: {0}"", e.Message);
        }
    }
    /// &lt;summary&gt;
    /// AES Encryption
    /// &lt;/summary&gt;
    private static string Encrypt(string text)
    {
        // AesCryptoServiceProvider
        AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
        aes.BlockSize = 128;
        aes.KeySize = 128;
        aes.IV = Encoding.UTF8.GetBytes(AesIV);
        aes.Key = Encoding.UTF8.GetBytes(AesKey);
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;

        // Convert string to byte array
        byte[] src = Encoding.Unicode.GetBytes(text);

        // encryption
        using (ICryptoTransform encrypt = aes.CreateEncryptor())
        {
            byte[] dest = encrypt.TransformFinalBlock(src, 0, src.Length);

            // Convert byte array to Base64 strings
            return Convert.ToBase64String(dest);
        }
    }
</code></pre>

<p><strong>NodeJS example:</strong></p>

<pre><code>crypto = require ""crypto""
algo = 'aes-128-cbc'
keyBuffer = new Buffer(""!QAZ2WSX#EDC4RFV"")
ivBuffer = new Buffer(""5TGB&amp;YHN7UJM(IK&lt;"")

cipher = crypto.createCipheriv(algo, keyBuffer, ivBuffer)
textBuffer = new Buffer('HelloWorld')
encrypted = cipher.update(textBuffer)
encryptedFinal = cipher.final()
encryptedText = encrypted.toString('base64') + encryptedFinal.toString('base64')

console.log encryptedText
</code></pre>

<p><strong>CryptoJS example:</strong></p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var key = CryptoJS.enc.Utf8.parse('!QAZ2WSX#EDC4RFV');
    var iv  = CryptoJS.enc.Utf8.parse('5TGB&amp;YHN7UJM(IK&lt;');

    var encrypted = CryptoJS.AES.encrypt(""HelloWorld"", key, { iv: iv });

    alert(encrypted);
&lt;/script&gt;
</code></pre>
","<p>Your C# version uses UTF-16LE to convert HelloWorld to plaintext bytes. The NodeJS one (and presumably hence the CryptoJS one) use UTF-8 bytes. Use Encoding.UTF8.GetBytes() in the C# one.</p>
","2178","<c#><node.js><encryption><aes><cryptojs>","2","3","2","2014-03-07 22:51:03","22262218","2","2","","","","2014-03-07 22:36:22",""
"22262033","AES algorithm value differences between .NET and nodejs, CryptoJS","<p>The below AES algorithm in C# returns an encrypted value that is different from what node js and CryptoJS returns. NodeJS Crypto library and CryptoJS return the same values but .NET's AesCryptoServiceProvider returns a different value. Any ideas?</p>

<p><strong>C# example</strong></p>

<pre><code>    private const string AesIV = @""!QAZ2WSX#EDC4RFV"";
    private const string AesKey = @""5TGB&amp;YHN7UJM(IK&lt;"";


    public static void Main()
    {
        try
        {
            string original = ""HelloWorld"";
            Console.WriteLine(Encrypt(original));
        }
        catch (Exception e)
        {
            Console.WriteLine(""Error: {0}"", e.Message);
        }
    }
    /// &lt;summary&gt;
    /// AES Encryption
    /// &lt;/summary&gt;
    private static string Encrypt(string text)
    {
        // AesCryptoServiceProvider
        AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
        aes.BlockSize = 128;
        aes.KeySize = 128;
        aes.IV = Encoding.UTF8.GetBytes(AesIV);
        aes.Key = Encoding.UTF8.GetBytes(AesKey);
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;

        // Convert string to byte array
        byte[] src = Encoding.Unicode.GetBytes(text);

        // encryption
        using (ICryptoTransform encrypt = aes.CreateEncryptor())
        {
            byte[] dest = encrypt.TransformFinalBlock(src, 0, src.Length);

            // Convert byte array to Base64 strings
            return Convert.ToBase64String(dest);
        }
    }
</code></pre>

<p><strong>NodeJS example:</strong></p>

<pre><code>crypto = require ""crypto""
algo = 'aes-128-cbc'
keyBuffer = new Buffer(""!QAZ2WSX#EDC4RFV"")
ivBuffer = new Buffer(""5TGB&amp;YHN7UJM(IK&lt;"")

cipher = crypto.createCipheriv(algo, keyBuffer, ivBuffer)
textBuffer = new Buffer('HelloWorld')
encrypted = cipher.update(textBuffer)
encryptedFinal = cipher.final()
encryptedText = encrypted.toString('base64') + encryptedFinal.toString('base64')

console.log encryptedText
</code></pre>

<p><strong>CryptoJS example:</strong></p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var key = CryptoJS.enc.Utf8.parse('!QAZ2WSX#EDC4RFV');
    var iv  = CryptoJS.enc.Utf8.parse('5TGB&amp;YHN7UJM(IK&lt;');

    var encrypted = CryptoJS.AES.encrypt(""HelloWorld"", key, { iv: iv });

    alert(encrypted);
&lt;/script&gt;
</code></pre>
","<p>Default padding in NodeJS is PKCS5 (assuming CryptoJS is the same since you said they produce the same result). Your C# code is setting padding to PKCS7.</p>
","2178","<c#><node.js><encryption><aes><cryptojs>","2","1","2","2014-03-07 22:51:03","22262218","2","2","","","","2014-03-07 22:36:22",""
"28383485","Wait for FileReader slice blob entirely","<p>I'm trying to read files data with FileReader API, and I read so many questions with this same problem and tried to implement their solutions, but for some bug in my code (maybe), it keep doing wrong result. To avoid crashing the browser when the file is too large (more than 15MB) I decided to start using the 'slice' method. But the problem is that as the FileReader onload event is async, I get at the part of the code where it should have the completed buffer ready to soon, when it's still incomplete. And I can't make everything inside the onload event, because it have only part of the total buffer. Here is my code:</p>

<pre><code>function readBlob(opt_startByte, opt_stopByte) 
{
    var file = window.files[0];
    var start = parseInt(opt_startByte) || 0;
    var stop = parseInt(opt_stopByte) || file.size - 1;

    var reader = new FileReader();

    // If we use onloadend, we need to check the readyState.
    reader.onload = function(evt) {           
        window.bits.push(CryptoJS.AES.encrypt(evt.target.result, window.password)); 
    };
    var blob = file.slice(start, stop + 1);
    reader.readAsDataURL(blob);
}

function encrypt()
{
    window.files = document.getElementById('encrypt-input').files;
    if (!window.files.length) {
        alert('Please select a file!');
        return;
    }
    window.password = $('#key').val();
    window.bits = [];
    var startByte = 0;              
    var endByte = 0;
    while(startByte &lt;= document.querySelector('input[type=file]').files[0].size - 1)
    {       
        endByte = startByte + 1024;
        readBlob(startByte, endByte);
        startByte = endByte;
        if (startByte &gt;= document.querySelector('input[type=file]').files[0].size)
        {
            alert('Here I want the total array length:' + window.bits.length);      
        }   
    }   
            alert('Here I want the total array length:' + window.bits.length);          
}
</code></pre>

<p>As you can see right above, I tried this:</p>

<pre><code>    if (startByte &gt;= document.querySelector('input[type=file]').files[0].size)
    {
        alert('Here I want the total array length:' + window.bits.length);      
    }   
</code></pre>

<p>But I still getting the length 0 for some reason. How can I process the entire buffer when using the slice method? Another secondary question is: inside the onload event, I call a synchronous function 'CryptoJS.AES.encrypt', but as this event is async, I was expecting that the browser won't freeze while processing the buffer into this event. Is there any way that I can implement something to avoid freezing the browser while processing the file?</p>
","<p>The reason this happens is that <code>reader.readAsDataURL()</code> is asynchronous. You have to pass a callback to <code>readBlob</code> which is called when it is finished:</p>

<pre><code>function readBlob(opt_startByte, opt_stopByte, done) {
    ...
    reader.onload = function(evt) {           
        window.bits.push(CryptoJS.AES.encrypt(evt.target.result, window.password));
        done();
    };
    ...
}

function encrypt() {    
    ...
    var startByte = 0;              
    var endByte = 0;
    var callback = function(){
        alert('Here I want the total array length:' + window.bits.length);
    };
    while(startByte &lt;= document.querySelector('input[type=file]').files[0].size - 1) {
        endByte = startByte + 1024;
        (function(startByte, endByte, newCallback){
            callback = function(){
                readBlob(startByte, endByte, newCallback);
            };
        })(startByte, endByte, callback);
        startByte = endByte;
    }
    callback(); // run the chain
}
</code></pre>

<p>There is simply no other sensible way, because JavaScript doesn't have a <code>sleep</code> function.</p>
","2147","<javascript><html5><cryptojs>","0","0","2","2015-04-28 12:10:28","28384128","0","","","","","2015-02-07 14:44:48",""
"28383485","Wait for FileReader slice blob entirely","<p>I'm trying to read files data with FileReader API, and I read so many questions with this same problem and tried to implement their solutions, but for some bug in my code (maybe), it keep doing wrong result. To avoid crashing the browser when the file is too large (more than 15MB) I decided to start using the 'slice' method. But the problem is that as the FileReader onload event is async, I get at the part of the code where it should have the completed buffer ready to soon, when it's still incomplete. And I can't make everything inside the onload event, because it have only part of the total buffer. Here is my code:</p>

<pre><code>function readBlob(opt_startByte, opt_stopByte) 
{
    var file = window.files[0];
    var start = parseInt(opt_startByte) || 0;
    var stop = parseInt(opt_stopByte) || file.size - 1;

    var reader = new FileReader();

    // If we use onloadend, we need to check the readyState.
    reader.onload = function(evt) {           
        window.bits.push(CryptoJS.AES.encrypt(evt.target.result, window.password)); 
    };
    var blob = file.slice(start, stop + 1);
    reader.readAsDataURL(blob);
}

function encrypt()
{
    window.files = document.getElementById('encrypt-input').files;
    if (!window.files.length) {
        alert('Please select a file!');
        return;
    }
    window.password = $('#key').val();
    window.bits = [];
    var startByte = 0;              
    var endByte = 0;
    while(startByte &lt;= document.querySelector('input[type=file]').files[0].size - 1)
    {       
        endByte = startByte + 1024;
        readBlob(startByte, endByte);
        startByte = endByte;
        if (startByte &gt;= document.querySelector('input[type=file]').files[0].size)
        {
            alert('Here I want the total array length:' + window.bits.length);      
        }   
    }   
            alert('Here I want the total array length:' + window.bits.length);          
}
</code></pre>

<p>As you can see right above, I tried this:</p>

<pre><code>    if (startByte &gt;= document.querySelector('input[type=file]').files[0].size)
    {
        alert('Here I want the total array length:' + window.bits.length);      
    }   
</code></pre>

<p>But I still getting the length 0 for some reason. How can I process the entire buffer when using the slice method? Another secondary question is: inside the onload event, I call a synchronous function 'CryptoJS.AES.encrypt', but as this event is async, I was expecting that the browser won't freeze while processing the buffer into this event. Is there any way that I can implement something to avoid freezing the browser while processing the file?</p>
","<p>It seems that you need to do that the ""sync way"". You can find the documentation here -> <a href=""http://www.w3.org/TR/FileAPI/#FileReaderSync"" rel=""nofollow"">http://www.w3.org/TR/FileAPI/#FileReaderSync</a>.
I have also discovered this library - FileReader.js (<a href=""http://bgrins.github.io/filereader.js/"" rel=""nofollow"">http://bgrins.github.io/filereader.js/</a>) that not only makes your life much easier when it comes to use FileReader, but also has already built in options to use the sync methods to synchronously read the files.
Sorry to not being able to post some example code rigth now! Hope it helped, anyway!</p>
","2147","<javascript><html5><cryptojs>","0","1","2","2015-04-28 12:10:28","28384128","0","","","","","2015-02-07 14:44:48",""
"22513663","Crypto JS SHA3 giving different output on same input","<p>We are using Crypto JS SHA3 to hash our username and password together. </p>

<p>The function takes the inputs from two html input fields for the username and password, concatenates them with the salt, and hashes them. The first hash works successfully, however hashing the same output again yields a different result.</p>

<p>This is the relevant code:</p>

<pre><code>$prehash = $salt + $user + $pass;

$prehash = CryptoJS.enc.Utf8.parse($prehash);
var sha3 = CryptoJS.algo.SHA3.create();
sha3.update($prehash);
var password  = sha3.finalize().toString(CryptoJS.enc.Hex);
sha3.reset();

var sha3 = CryptoJS.algo.SHA3.create();
sha3.update($prehash);
var password2  = sha3.finalize().toString(CryptoJS.enc.Hex);
sha3.reset();

console.log('PREHASH: ' + $prehash);

console.log('HASHWORD: ' + password);

console.log('HASHWORD2: ' + password2);
</code></pre>

<p>The console logs output the following:</p>

<pre><code>PREHASH:  4d616e636865737465722c20436f6e6e65637469637574204d6f62696c65205573657273546f776e20436c65726b68617665206272616e6368657320616476616e63652042656c6769756d

HASHWORD: db90cbb6766f3ca0dc8af39455cd6e224263db31caed3f73f9ad923a02c34211c85cc17a8e3d0166cd82c10d12a137332891c0c201174e16d19a93b6b4d430cf

HASHWORD2:
9ed635963fa0079a0520d8afa59d1e19be601d7bf77f623702304240993ce9bdd2f3023ca6bbd44f2ab30ceb2de1c8f0d3fe3d63292c5a23c44ddd1d485baa71
</code></pre>

<p>EDIT: We have tested on two other devices, and have found that we get the correct output on the other two devices. This behavior is only observed on my coworkers phone. Now we are more confused. Does anybody see why a different device would produce different output?</p>

<p>EDIT: Here is a jsfiddle that demonstrates the problem. It should read true &amp; true. On our android 4.2.2 device it reads false &amp; false <a href=""http://jsfiddle.net/odL57wfo/2/"" rel=""noreferrer"">http://jsfiddle.net/odL57wfo/2/</a></p>
","<p>We were unable to find a solution to this problem so we have opened a bug on the crypto-js project and in the mean time we are using a different hashing algorithm </p>
","2135","<javascript><jquery><cryptojs><sha-3>","6","0","1","2015-08-18 11:26:12","","15","0","1044220","","2015-08-10 15:34:57","2014-03-19 17:29:10",""
"20115661","Using Crypto-JS in Google Apps Script - What is C.lib?","<p>I would like to us <code>Crypto-JS</code> in Google Apps Script and have copied all source files into my project.</p>

<p>When trying to encrypt data with its <code>AES</code>, I can't get it to work because the following reference in <code>aes.js</code> is not valid in Google Apps Script:</p>

<pre><code>var C_lib = C.lib;
</code></pre>

<p>This is my ""JavaScript for Dummies"" question (I am a JavaScript newbie) :-)</p>

<p>How can I reference and use <code>C.lib</code> with Google Apps Script?
What is <code>C.lib</code>? I have not found any good information on Google and SO.</p>
","<p>From <code>core.js</code>:</p>

<pre><code>/**
 * Library namespace.
 */
var C_lib = C.lib = {};
</code></pre>

<p>It seems that every file from the package CryptoJS use it something like:</p>

<pre><code>var C_lib = C.lib;
var WordArray = C_lib.WordArray;
var BlockCipher = C_lib.BlockCipher;
</code></pre>

<p>So, most probably you have to link <code>core.js</code> if you are using development version.</p>

<p>Example from <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS 3.1</a></p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
&lt;/script&gt;
</code></pre>

<p>works without any other links.</p>
","2118","<javascript><c><google-apps-script><cryptojs>","3","2","1","2015-06-22 11:51:33","20121170","0","","","","","2013-11-21 08:18:31",""
"46927119","OpenSSL Node.js Error No Start Line","<p>I started developing an app in node.js for the german Sparkasse (banking provider). 
They provide an API to their service. 
<a href=""https://banking-sandbox.starfinanz.de/ahoi/docs/cookbook/index.html#step-4-call-the-registration-endpoint"" rel=""nofollow noreferrer"">German Link to their API</a></p>

<p>in the secondstep I get a RSA-2048-SHA1 publickey from their server.
in the fourth step, I should use that public key, to encrypt a session key created in step 3. but when encrypting with:</p>

<pre><code>var key = 'password';
var sha256 = crypto.createHash('sha256');
sha256.update(key);
var iv = new Buffer([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);
var cipher = crypto.createCipheriv('aes-256-cbc', sha256.digest(), iv);        
let sessionKey = cipher.final('base64')
let publicKey = response.publicKey.value
crypto.publicEncrypt(publicKey,new Buffer(sessionKey))
</code></pre>

<p>I get the following Error message, that I think is from OpenSSL. I don't really know how to fix that issue as I cannot evaluate if the publicKey I get from the API is valid.</p>

<blockquote>
  <p>Error: error:0906D06C:PEM routines:PEM_read_bio:no start line</p>
</blockquote>
","<p>The public key you received is in the wrong format. It needs to be a ""PEM"" formatted key. You'll have to convert it by wrapping it in  ""BEGIN ..."" and ""END..."" lines, and possibly splitting into 64 character lines.</p>

<p>Here is an example of a properly formatted public key:</p>



<pre class=""lang-none prettyprint-override""><code>-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAytBCDJR5/6JAlB7ErBge
22YwN/u0K63wrnCMLde+hQQCYs7pBuYtbyxXF2PBFuHS+ytD9PSpY9t3NiGbk/9U
s9GYCnqaK+vg2hz+T86LjJVkTJe0HWuE6g+HQ9GjyDGiO7ZBQw31HKxHYA2cMMVj
tiO97VKLR9Fp6c6X33uNtdAaUZg57PjyNl6TjPwc52tJz8H5g0aV4tYelsTMaSSE
4nVwPLBoDzZaT84ktW1RuGToC4gEB/bctFrRBVaxp/KSebpds9P2xGMVweWgrvml
cLnHGLKBxcCxh9kbgHS/nrgYXPjj92hxk2se/C7QmYeRSUs4ikEWO06NJ7Cgk+bQ
8wIDAQAB
-----END PUBLIC KEY-----
</code></pre>
","2110","<node.js><api><openssl><rsa><cryptojs>","2","3","1","2017-10-25 13:05:45","46933170","0","1","","","","2017-10-25 08:05:27",""
"27171390","How to decrypt with CryptoJS using AES?","<p>As the question suggests, I can't seem to get a decrypted value correctly using the required options (AES, ECB Mode &amp; PKCS7).</p>

<p>I'm encrypting as below:</p>

<pre><code>  var ENC_KEY = ""bXlrZXk="";  //""mykey""

  var encrypted = CryptoJS.AES.encrypt(""hello"",  CryptoJS.enc.Base64.parse(ENC_KEY), 
    {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
  console.log('encrypted: ' + encrypted);
</code></pre>

<p>which works as expected and outputs the encrypted value I expect however when I decrypt this using the below, I end up with an empty object being output:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, CryptoJS.enc.Base64.parse(ENC_KEY), 
    {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
    console.log('decrypted: ' + decrypted);
</code></pre>

<p>I have also tried using:</p>

<pre><code>console.log('encrypted is decrypted to: ' + decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>but no joy...</p>
","<p>I tried this in a fiddle(modded a bit to get it to work):</p>

<pre><code>//decrypt gives a hex
function hex2a(hexx) {
    var hex = hexx.toString();//force conversion
    var str = '';
    for (var i = 0; i &lt; hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    return str;
}

var key = CryptoJS.enc.Base64.parse(""Secret Passphrase""); 

alert(key);

var encrypted = CryptoJS.AES.encrypt(""hello"",  key, 
    {
        mode: CryptoJS.mode.ECB
    });

alert('encrypted: ' + encrypted);

var decrypted = CryptoJS.AES.decrypt(encrypted, key, 
    {
        mode: CryptoJS.mode.ECB
    });

alert('decrypted: ' + hex2a(decrypted));
</code></pre>

<p><a href=""http://jsfiddle.net/gttL705r/"" rel=""nofollow"">http://jsfiddle.net/gttL705r/</a></p>

<p>and found that decrypt returned a hex, which may not have been a string... could this be causing your problems? So, with a quick hex2ascii function, 'hello' is return back :)</p>

<p>I also removed the padding specified, since Pkcs7 is said to be the default in the docs and I couldn't find src js i needed to download for it.</p>
","2092","<javascript><encryption><aes><cryptojs>","1","1","1","2014-11-27 14:01:11","27172451","0","","3197788","","2014-11-27 13:11:59","2014-11-27 13:00:11",""
"38627413","CryptoJS passphrase, salt, and iv does not matter?","<p>I'm trying to understand how to use the AES of CryptoJS to encrypt some data. I made a simple HTML page with JavaScript to see CryptoJS AES in action.</p>

<p>At first I thought encryption/decryption was working perfectly. But then I tried to change the passphrase, salt, and IV. I found out that, given the same message, the resulting ciphertext is identical no matter how I change the passphrase, salt, and IV.</p>

<p>I downloaded <code>aes.js</code> and <code>pbkdf2.js</code> from v3.1.2 of <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow noreferrer"">https://code.google.com/archive/p/crypto-js/downloads</a> and referred to <a href=""https://github.com/mpetersen/aes-example"" rel=""nofollow noreferrer"">https://github.com/mpetersen/aes-example</a></p>

<p>Here is my HTML in its entirety (since it is a really simple page I think it's okay to post the entire thing)</p>

<pre><code>&lt;!DOCTYPE html&gt;

&lt;head&gt;
    &lt;title&gt;Decryptor&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;input type=""text"" id=""inputElement"" /&gt;
    &lt;button id=""decrypt""&gt;Decrypt!&lt;/button&gt;
    &lt;br /&gt;
    &lt;p id=""ciphertext""&gt;
        Ciphertext
    &lt;/p&gt;
    &lt;p id=""plaintext""&gt;
        Plaintext
    &lt;/p&gt;
&lt;/body&gt;

&lt;script src=""aes.js""&gt;&lt;/script&gt;
&lt;script src=""pbkdf2.js""&gt;&lt;/script&gt;

&lt;script type=""text/javascript""&gt;
    function decrypt() {
        var input = document.getElementById(""inputElement"").value;
        var ciphertextElement = document.getElementById(""ciphertext"");
        var plaintextElement = document.getElementById(""plaintext"");

        var message = input;
        var passphrase = ""myPassphrase"";
        var salt = ""mySalt"";
        var iv = ""myIV"";

        var key = CryptoJS.PBKDF2(
            passphrase,
            CryptoJS.enc.Hex.parse(salt),
            { keySize: this.keySize, iterations: this.iterationCount }
        );

        var parsedIV = CryptoJS.enc.Hex.parse(iv);

        var encrypted = CryptoJS.AES.encrypt(
            message,
            key,
            { iv: parsedIV }
        );

        var ciphertext = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
        ciphertextElement.innerHTML = ciphertext;

        var cipherParams = CryptoJS.lib.CipherParams.create(
            { ciphertext: CryptoJS.enc.Base64.parse(ciphertext) }
        );
        var decrypted = CryptoJS.AES.decrypt(
            cipherParams,
            key,
            { iv: parsedIV }
        );

        var plaintext = decrypted.toString(CryptoJS.enc.Utf8);
        plaintextElement.innerHTML = plaintext;
    }

   var decryptionButton = document.getElementById(""decrypt"");
    decryptionButton.onclick = decrypt;
&lt;/script&gt;

&lt;/html&gt;
</code></pre>
","<p>I took the advice from @dandavis and @artjom-b.</p>

<p>Because my salt and iv are string, I parse them with Utf8:</p>

<pre><code>CryptoJS.enc.Utf8.parse(salt);
CryptoJS.enc.Utf8.parse(iv);
</code></pre>

<p>And for key generation, I use static values:</p>

<pre><code>        var key = CryptoJS.PBKDF2(
        passphrase,
        CryptoJS.enc.Utf8.parse(salt),
        { keySize: 512/32, iterations: 1000 }
    );
</code></pre>

<p>And now the ciphertext changes as I change the passphrase, salt, and iv values.</p>
","2081","<javascript><encryption><aes><cryptojs>","1","1","1","2019-03-06 15:41:57","","3","","1426539","","2019-03-06 15:41:57","2016-07-28 05:00:34",""
"43315762","In Angular2 the SHA256 hash of a file generated does not match with SHA256 from other sites","<p>I'm trying to generate SHA-256 hash for files.</p>

<p>I have used <a href=""https://www.npmjs.com/package/crypto-js"" rel=""noreferrer"">https://www.npmjs.com/package/crypto-js</a> library for that. please see below code for that. </p>

<pre><code>import { Component, OnInit } from '@angular/core';
var SHA256 = require(""crypto-js/sha256"");
@Component({
  moduleId: module.id,
  selector: 'dashboard',
  templateUrl: './dashboard.component.html',
  styleUrls: ['./dashboard.component.css']
})
export class DashboardComponent implements OnInit {
  hash: string;
  constructor() { }
  ngOnInit() {}

  onFilesChange(fileList : Array&lt;File&gt;){
    this.fileList = fileList;
    console.log(fileList);
    for(var file in fileList){
      this.hash = SHA256(file);
      console.log(this.hash.toString());
    }

  }

}
</code></pre>

<p>File : <a href=""https://file.io/uWoIvh"" rel=""noreferrer"">file for sha-256</a>
with above code I got below sh256 hash : 5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9</p>

<p>but I refer many online sites like <a href=""http://onlinemd5.com/,http://www.online-convert.com/,https://md5file.com/calculator"" rel=""noreferrer"">http://onlinemd5.com/,http://www.online-convert.com/,https://md5file.com/calculator</a></p>

<p>form online site I got below sha256 hash :
27bb4358e847d559bed9f34eeee51ca71f51542afb0de4017b80dd66a0656eca</p>

<p>can anyone tell me why I'm getting different hash?</p>
","<p>You can use:<a href=""https://www.jokecamp.com/blog/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/#js"" rel=""nofollow noreferrer"">https://www.jokecamp.com/blog/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages/#js</a></p>

<pre><code> &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;

&lt;script&gt;
  var hash = CryptoJS.HmacSHA256(""Message"", ""secret"");
  var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
  document.write(hashInBase64);
&lt;/script&gt;
</code></pre>
","2046","<javascript><angular><sha256><cryptojs>","8","-2","1","2019-04-27 05:58:56","","0","","","","","2017-04-10 05:46:37",""
"24455810","Crypto-js returns different values every time it's run when using AES","<p>I'm trying to encrypt something using crypto-js and using the AES type of encryption.</p>

<p>The problem i'm having is that my encrypted value is different every time I encrypt it.</p>

<p>With this simple example, I run the same encryption 5 different times and I get 5 different results. Wtf is going on here?</p>

<p>task.js</p>

<pre><code>var AES = require('crypto-js/aes');
var key = ""abc123"";
var secret = ""encryptThisWord"";

console.log(AES.encrypt(secret, key).toString());
console.log(AES.encrypt(secret, key).toString());
console.log(AES.encrypt(secret, key).toString());
console.log(AES.encrypt(secret, key).toString());
console.log(AES.encrypt(secret, key).toString());
</code></pre>

<p><img src=""https://i.stack.imgur.com/s7II0.jpg"" alt=""enter image description here""></p>
","<p>Check the contents of <code>AES.encrypt(secret, key)</code> - it is an object with a number of fields, <code>iv</code> and <code>salt</code> of particular interest (<a href=""http://jsfiddle.net/Z88RT/"" rel=""noreferrer"">jsFiddle</a>).</p>

<p>Each time you run the <code>AES.encrypt</code> crypto-js chooses new IV and new salt (you can supply your own values, by the way). Random IV means that output will be different even with the same key, and random salt means that the actual encryption key is different too, because it is derived from the the passphrase and salt. </p>

<p>You may (actually, should) ask why the first ten Base64 output characters are the same when both the encryption key and IV are different? That is because calling <code>toString()</code> on the ecnryption result converts it into ""OpenSSL-compatible string"", which is basically <code>Base64(""Salted__"" + salt + ciphertext)</code>, where <code>""Salted__""</code> is the constant prefix which, of course, leads the same prefix in the Base64 output.</p>
","2007","<javascript><node.js><encryption><cryptojs>","8","12","1","2015-11-18 05:28:06","24457100","1","0","","","","2014-06-27 15:43:30",""
"49602276","how to encrypt/decrypt with crypto-js","<p>I'm using crypto-js library:</p>

<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a></p>

<p>I want to encrypt some value and decrypt them.</p>

<p>but it returns wrong output.</p>

<p>my codes:</p>

<pre><code>import CryptoAES from 'crypto-js/aes'

componentDidMount(){
  var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
  var _ciphertext = CryptoAES.decrypt(ciphertext, 'secret key 123');
  console.log(_ciphertext.toString(CryptoAES.Utf8));
}
</code></pre>

<p>but my console doesn't return <code>my message</code>. it returns like this:</p>

<pre><code>6d79206d657373616765
</code></pre>
","<p>I have never used this library, but a small check shows your result is your input's ASCII code as hex string.</p>

<pre><code>0x6d=m
...
0x65=e

6d|79|20|6d|65|73|73|61|67|65
m |y |  |m |e |s |s |a |g |e
</code></pre>

<p>So this code is working correctly. Probably that <code>_ciphertext.toString()</code> mess everything up. You need to check how to use <code>_ciphertext</code> correctly.</p>
","1996","<javascript><reactjs><encryption><cryptojs>","0","2","4","2019-09-23 13:48:29","49602290","1","","","","","2018-04-01 20:20:38",""
"49602276","how to encrypt/decrypt with crypto-js","<p>I'm using crypto-js library:</p>

<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a></p>

<p>I want to encrypt some value and decrypt them.</p>

<p>but it returns wrong output.</p>

<p>my codes:</p>

<pre><code>import CryptoAES from 'crypto-js/aes'

componentDidMount(){
  var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
  var _ciphertext = CryptoAES.decrypt(ciphertext, 'secret key 123');
  console.log(_ciphertext.toString(CryptoAES.Utf8));
}
</code></pre>

<p>but my console doesn't return <code>my message</code>. it returns like this:</p>

<pre><code>6d79206d657373616765
</code></pre>
","<p>Currently you are getting a hexa string <code>6d79206d657373616765</code> as you can check on <a href=""https://codebeautify.org/string-hex-converter"" rel=""nofollow noreferrer"">this convertor</a> when you enter <code>my message</code> it will return you <code>6d79206d657373616765</code></p>

<p>As used in the <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">crypto-js Documentation</a> </p>

<p>You need to make use of <code>.toString()</code> inside your <code>decrypt</code> method as currently you are getting hex for your <code>my message</code> and you need to convert that back to <code>string</code>, So you need to change this :</p>

<pre><code>var _ciphertext = CryptoAES.decrypt(ciphertext, 'secret key 123');
</code></pre>

<p><strong>To</strong> </p>

<pre><code>var _ciphertext = CryptoAES.decrypt(ciphertext.toString(), 'secret key 123');
</code></pre>

<p>It will be like : </p>

<pre><code>import CryptoAES from 'crypto-js/aes'

componentDidMount(){
  var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
  var _ciphertext = CryptoAES.decrypt(ciphertext.toString(), 'secret key 123');
  console.log(_ciphertext.toString(CryptoAES.Utf8));
}
</code></pre>
","1996","<javascript><reactjs><encryption><cryptojs>","0","0","4","2019-09-23 13:48:29","49602290","1","","","","","2018-04-01 20:20:38",""
"49602276","how to encrypt/decrypt with crypto-js","<p>I'm using crypto-js library:</p>

<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a></p>

<p>I want to encrypt some value and decrypt them.</p>

<p>but it returns wrong output.</p>

<p>my codes:</p>

<pre><code>import CryptoAES from 'crypto-js/aes'

componentDidMount(){
  var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
  var _ciphertext = CryptoAES.decrypt(ciphertext, 'secret key 123');
  console.log(_ciphertext.toString(CryptoAES.Utf8));
}
</code></pre>

<p>but my console doesn't return <code>my message</code>. it returns like this:</p>

<pre><code>6d79206d657373616765
</code></pre>
","<p>You can use this. cippertext use output algorytms.</p>

<pre><code>ciphertext.toString(""base64"")
</code></pre>

<p>or</p>

<pre><code>ciphertext.toString(""hex"")
</code></pre>
","1996","<javascript><reactjs><encryption><cryptojs>","0","0","4","2019-09-23 13:48:29","49602290","1","","","","","2018-04-01 20:20:38",""
"49602276","how to encrypt/decrypt with crypto-js","<p>I'm using crypto-js library:</p>

<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a></p>

<p>I want to encrypt some value and decrypt them.</p>

<p>but it returns wrong output.</p>

<p>my codes:</p>

<pre><code>import CryptoAES from 'crypto-js/aes'

componentDidMount(){
  var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
  var _ciphertext = CryptoAES.decrypt(ciphertext, 'secret key 123');
  console.log(_ciphertext.toString(CryptoAES.Utf8));
}
</code></pre>

<p>but my console doesn't return <code>my message</code>. it returns like this:</p>

<pre><code>6d79206d657373616765
</code></pre>
","<pre><code>import CryptoAES from 'crypto-js/aes';
import CryptoENC from 'crypto-js/enc-utf8';

var ciphertext = CryptoAES.encrypt('my message', 'secret key 123');
var _ciphertext = CryptoAES.decrypt(ciphertext.toString(), 'secret key 123');
console.log(_ciphertext.toString(CryptoENC));
</code></pre>

<p><a href=""https://i.stack.imgur.com/taIyb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/taIyb.png"" alt=""enter image description here""></a></p>
","1996","<javascript><reactjs><encryption><cryptojs>","0","0","4","2019-09-23 13:48:29","49602290","1","","","","","2018-04-01 20:20:38",""
"33613008","How to decrypt AES with a known KEY and IV using Javascript?","<p>I'm trying to learn CryptoJS using <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a>
It shows how to encrypt with AES but it does not how how to decrypt using both KEY and IV. I'm looking at the below code.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>

<p></p>

<p>I have tried the below code:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv });
</code></pre>

<p>However, it gives me the wrong plain text. Anyone know what I'm doing wrong?</p>

<p>The output I receive is:</p>

<pre><code>4d657373616765
</code></pre>

<p>The correct plain text should obviously be:</p>

<pre><code>Message
</code></pre>

<p>Am I misunderstanding something?</p>
","<p>ASCII ;-) <a href=""http://www.italysoft.com/utility/converters/asciifull.gif"" rel=""nofollow"">http://www.italysoft.com/utility/converters/asciifull.gif</a></p>

<p>The output are binary ASCII characters.</p>

<p>4d = M
65 = e</p>

<p>etc...</p>
","1988","<javascript><encryption><aes><cryptojs>","1","2","2","2015-11-09 16:33:39","33613009","1","","1816580","","2015-11-09 16:33:39","2015-11-09 15:05:44",""
"33613008","How to decrypt AES with a known KEY and IV using Javascript?","<p>I'm trying to learn CryptoJS using <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a>
It shows how to encrypt with AES but it does not how how to decrypt using both KEY and IV. I'm looking at the below code.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>

<p></p>

<p>I have tried the below code:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv });
</code></pre>

<p>However, it gives me the wrong plain text. Anyone know what I'm doing wrong?</p>

<p>The output I receive is:</p>

<pre><code>4d657373616765
</code></pre>

<p>The correct plain text should obviously be:</p>

<pre><code>Message
</code></pre>

<p>Am I misunderstanding something?</p>
","<p>As hotips said, it's hex for ASCII, CryptoJS has built-in encoders. You can stringify it to Utf8 doing this:</p>

<p><code>var utf8Decrypted = CryptoJS.enc.Utf8.stringify(decrypted);</code></p>

<p>For other encoders see:</p>

<p><a href=""https://code.google.com/p/crypto-js/#Encoders"" rel=""nofollow"">CryptoJS Encoders</a></p>
","1988","<javascript><encryption><aes><cryptojs>","1","1","2","2015-11-09 16:33:39","33613009","1","","1816580","","2015-11-09 16:33:39","2015-11-09 15:05:44",""
"39610952","Java method to decrypt an AES string from Angular-Cryptography","<p>I'm trying to do a login method that keeps the client password secure and encrypted in my server.</p>

<p>The library I'm using from Angular, is <a href=""https://github.com/middleout/angular-cryptography"" rel=""nofollow"">https://github.com/middleout/angular-cryptography</a></p>

<p>The idea is, to follow these steps:</p>

<ol>
<li><p>I set a salt in my module.config: </p>

<pre><code>app.config(['$cryptoProvider', function($cryptoProvider){
    $cryptoProvider.setCryptographyKey('thisismysalt');
}]);
</code></pre></li>
<li><p>I encrypt the password with itself:</p>

<pre><code>user.pw = $crypto.encrypt(user.pw, user.pw);
</code></pre></li>
<li><p>If I'm registering an user, I re-encrypt the password with itself (repeat step 2) and save it in the DB. If I'm logging, I just send the result from the last step, to the server.</p></li>
<li><p>When you decypher the double-encrypted string with the single-encrypted one, you get the single encrypted string again. So if your password was correct, you just compare the result with the single-encrypted string, and you validate the user.</p></li>
</ol>

<hr>

<p>Ok, this method should work (I already did it in Node some time ago), works great with SSL to protect user's passwords even in your server!</p>

<p>But I can't find any library or snippet in Java that can do it. I tried many of them, but they are hard to understand and when I adapt them to my procedure, they just won't work. I tried the following method:</p>

<pre><code>static String IV = ""AAAAAAAAAAAAAAAA"";
static String plaintext = ""test text 123\0\0\0""; /*Note null padding*/
static String encryptionKey = ""0123456789abcdef"";

public static String decrypt(byte[] cipherText, String encryptionKey) throws Exception{
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(""UTF-8"")));
    return new String(cipher.doFinal(cipherText),""UTF-8"");
}
</code></pre>

<p>I passed it as first argument, the double-encrypted password from the DB, and as second argument, the single-encrypted password from the frontend:</p>

<blockquote>
  <p>java.security.InvalidKeyException: Invalid AES key length: 44 bytes</p>
</blockquote>

<p>Am I doing something wrong? Should I use a different algorithm? </p>
","<p>middleout/angular-cryptography uses CryptoJS 3.1.2 <a href=""https://github.com/middleout/angular-cryptography/blob/master/mdo-angular-cryptography.js"" rel=""nofollow noreferrer"">under the hood with the least effort possible</a>.</p>

<p>So </p>

<pre><code>return $crypto.encrypt(plaintext, password);
</code></pre>

<p>is the same as</p>

<pre><code>$cryptoProvider.setCryptographyKey(password); 
return $crypto.encrypt(plaintext, password);
</code></pre>

<p>and the same as </p>

<pre><code>return CryptoJS.AES.encrypt(plaintext, password).toString();
</code></pre>

<p>I describe in my answer <a href=""https://stackoverflow.com/a/29152379/1816580"">here</a> how to do the same thing in Java.</p>

<hr>

<p>If you're using SSL/TLS, there is not much benefit to doing this encryption additionally. The password is already sent in an encrypted way over the internet. Even worse, since the password must be available at the server side, you must store the password in cleartext. <strong>That's not how it is done.</strong></p>

<p>You need to use hashing instead with some strong ones being PBKDF2, bcrypt, scrypt and Argon2. Since hash functions are one-way function, you won't be able to ""decrypt"" the hashes. In order to authenticate your user, you can run the password through the hash function again in order to compare with the hash that is stored in the database. Since you're already using SSL/TLS, the password is already secured during transmission. See more: <a href=""https://security.stackexchange.com/q/211/45523"">How to securely hash passwords?</a></p>
","1978","<java><angularjs><encryption><passwords><cryptojs>","0","1","1","2016-09-21 19:06:21","39624597","0","2","1816580","","2016-09-21 19:06:21","2016-09-21 08:12:30",""
"29424027","Using the nonce and counter correctly for AES-CTR mode","<p>I understand that in AES Counter mode I need to use a 128 bit nonce. The nave way to do that would be to use a random 128 bit nonce, but I'm not sure the algorithm will be able to increment the counter correctly if it's passed as all random bits. I thought the correct way to do it is to use a 96 bit nonce and also a 32 bit counter starting at 0, for example:</p>

<pre><code>var key = CryptoJS.enc.Hex.parse('01ab23cd45ef67089a1b2c3d4e5f6a7b'); // 128 bits / 16 bytes
var nonce = '2301cd4ef785690a1b2c3dab'; // 96 bits / 12 bytes
var counter = '00000000'; // 32 bits / 4 bytes
var nonceAndCounter = nonce + counter;
    nonceAndCounter = CryptoJS.enc.Hex.parse(nonceAndCounter);
var plaintext = 'The quick brown fox jumps over the lazy dog.';

var encryption = CryptoJS.AES.encrypt(plaintext, key, { iv: nonceAndCounter, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
var ciphertext = encryption.ciphertext.toString(CryptoJS.enc.Hex);
</code></pre>

<p>Is this the correct way to do it with the <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS library</a>? Or what is the correct way?</p>
","<p>I'm going to answer my own question as I went digging into the library code to see what it really does.</p>

<p><strong><em>Summary:</em></strong></p>

<p>The answer is you can use either of two methods and it will work as expected:</p>

<p><strong>1)</strong> Pass in a random nonce of 96 bits in length and the library itself will add the 32 bit counter automatically and increment it with every keystream block generated. E.g. </p>

<pre><code>var nonce = CryptoJS.enc.Hex.parse('2301cd4ef785690a1b2c3dab'); // 12 Bytes
var encryption = CryptoJS.AES.encrypt(plaintext, key, { iv: nonce, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
</code></pre>

<p><strong>2)</strong> Pass in a random nonce of 96 bits in length and explicitly specify the 32 bit counter as well if you want to. You can even specify a counter like <code>00000009</code> if you want to start encrypting/decrypting from the 9th block. Below is an example starting from counter 0:</p>

<pre><code>var nonce = '2301cd4ef785690a1b2c3dab';  // 12 Bytes
var counter = '00000000';                // 4 Bytes, start at counter 0
var nonceAndCounter = CryptoJS.enc.Hex.parse(nonce + counter);  // 16 Bytes
var encryption = CryptoJS.AES.encrypt(plaintext, key, { iv: nonceAndCounter, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
</code></pre>

<p><strong><em>Explanation:</em></strong></p>

<p>Using the code in the question with 32 bit counter of <code>00000000</code>, the relevant code is in this file <a href=""https://crypto-js.googlecode.com/svn/tags/3.1.2/src/mode-ctr.js"" rel=""noreferrer"">mode-ctr.js</a>:</p>

<pre><code>/**
 * Counter block mode.
 */
CryptoJS.mode.CTR = (function () {
    var CTR = CryptoJS.lib.BlockCipherMode.extend();

    var Encryptor = CTR.Encryptor = CTR.extend({
        processBlock: function (words, offset) {
            // Shortcuts
            var cipher = this._cipher
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;

            // Generate keystream
            if (iv) {
                counter = this._counter = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);

            // Increment counter
            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

            // Encrypt
            for (var i = 0; i &lt; blockSize; i++) {
                words[offset + i] ^= keystream[i];
            }
        }
    });

    CTR.Decryptor = Encryptor;

    return CTR;
}());
</code></pre>

<p>When running this code in a browser JS debugger using a breakpoint, it converts the <code>nonceAndCounter</code> into a WordArray consisting of 32 bit elements:</p>

<p><code>[587320654, -142251766, 455884203, 0]</code></p>

<p>This is used to encrypt a block. To encrypt the next block it runs this line: </p>

<p><code>counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0</code></p>

<p>Which evaluates to take the <code>counter[3]</code> element i.e. the integer 0 and increments it to:</p>

<p><code>[587320654, -142251766, 455884203, 1]</code></p>

<p>With subsequent blocks and nonces I can see...</p>

<p><code>[587320654, -142251766, 455884203, 2]</code></p>

<p><code>[587320654, -142251766, 455884203, 3]</code></p>

<p><code>[587320654, -142251766, 455884203, 4]</code></p>

<p>And so on. So it appears to be working correctly this way.</p>

<p>Contrast this with how it works if you pass a 128 bit random nonce e.g.</p>

<p><code>var nonceAndCounter = CryptoJS.enc.Hex.parse('2301cd4ef785690a1b2c3dabdf99a9b3');</code></p>

<p>This produces a nonce of:</p>

<p><code>[587320654, -142251766, 455884203, -543577677, 0]</code></p>

<p>So it creates 5 array elements!? Then the function increments the fourth element from <code>-543577677</code> to <code>-543577676</code>, then <code>-543577675</code>, then <code>-543577674</code> and so on. So it still works in a way, but but does not increment as nicely as starting from 0 and is perhaps more error prone.</p>

<p>When I passed in just a 96 bit random nonce, the library automatically added the start counter as 0 to the end of the counter array and incremented it correctly for subsequent blocks. e.g.</p>

<pre><code>[587320654, -142251766, 455884203, 0]
[587320654, -142251766, 455884203, 1]
[587320654, -142251766, 455884203, 2]
</code></pre>
","1978","<javascript><encryption><aes><cryptojs><ctr-mode>","4","5","1","2015-04-05 21:08:16","29430375","0","1","4744436","","2015-04-05 21:01:28","2015-04-02 23:17:15",""
"28342426","How to make a String out of a CryptoJS AES Object?","<p>I have CryptoJS running and I need to do the following:</p>

<p>I have a username and a password. U encrypt the username with the password:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""user"", ""pass"");
</code></pre>

<p>How can I create a String out of this object to store it in my <code>LocalStorage</code>?</p>

<p>At the end I need to load it from my <code>LocalStorage</code> and compare it to:</p>

<pre><code>var encrypted2 = CryptoJS.AES.encrypt(""user"", ""pass"");
</code></pre>

<p>if <code>encrypted === encrypted2</code> all is fine. </p>

<p>But I can't get out a string of <code>encrypted</code> it's an <code>CryptoJS.AES Object</code> and when I use <code>JSON.stringify</code> I get the error: <code>TypeError: Converting circular structure to JSON</code></p>
","<p><code>encrypted2.toString()</code> will get you the OpenSSL formatted representation of the ciphertext. Note that it can't produce the same result, because you're using the password based encryption, during which a random salt is generated to produce the actual key and IV for the encryption. Every ciphertext that you produce with the same parameters will look differently.</p>

<p>Only the decryption of a ciphertext can get you the information whether the key+IV or password+salt were correct and then only when you have some kind of integrity check included (Padding is a poor-mans integrity check). See also: <a href=""https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac"">Should we MAC-then-encrypt or encrypt-then-MAC?</a></p>

<p>If you only want to check whether a username is the same, you should use the same techniques as used for passwords. That is, you should use hashing. CryptoJS provides multiple hash functions including an implementation of PBKDF2 for extra security. This will give you the property that you want when you set the password as the salt for PBKDF2.</p>
","1967","<javascript><json><encryption><cryptojs>","3","4","1","2015-02-05 11:36:46","28342536","0","2","","","","2015-02-05 11:10:42",""
"22587599","How to properly sign a GET request to Amazon's ItemLookup using client-side JavaScript only?","<p>Here's what I have so far:    </p>

<pre><code>function sha256(stringToSign, secretKey) {
  return CryptoJS.HmacSHA256(stringToSign, secretKey);
} 

function getAmazonItemInfo(barcode) {

  var parameters = 
    ""Service=AWSECommerceService&amp;""
    + ""AWSAccessKeyId="" + appSettings.amazon.accessKey + ""&amp;""
    + ""Operation=ItemLookup&amp;""
    + ""ItemId="" + barcode
    + ""&amp;Timestamp="" + Date.now().toString();

  var stringToSign =
    ""GET\n""
    + ""webservices.amazon.com\n""
    + ""/onca/xml\n""
    + parameters;

  var signature = ""&amp;Signature="" + encodeURIComponent(sha256(stringToSign, appSettings.amazon.secretKey));

  var amazonUrl =  
    ""http://webservices.amazon.com/onca/xml?""
    + parameters
    + signature;

  // perform a GET request with amazonUrl and do other stuff

}
</code></pre>

<p>When executed as an HTTP GET request, the value of <code>amazonUrl</code> in the above code results in the following response from Amazon:</p>

<pre><code>&lt;?xml version=""1.0""?&gt; 
  &lt;ItemLookupErrorResponse xmlns=""http://ecs.amazonaws.com/doc/2005-10-05/""&gt;
    &lt;Error&gt;
      &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt;
      &lt;Message&gt;
        The request signature we calculated does not match the signature you provided. 
        Check your AWS Secret Access Key and signing method. Consult the service 
        documentation for details.
      &lt;/Message&gt;
   &lt;/Error&gt;
   &lt;RequestId&gt;[REMOVED]&lt;/RequestId&gt;
  &lt;/ItemLookupErrorResponse&gt;
</code></pre>

<p>Useful links:</p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/ItemLookup.html"" rel=""nofollow"">ItemLookup - Product Advertising API Amazon Documentation</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow"">Example REST Requests</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/BasicAuthProcess.html"" rel=""nofollow"">AWS Authentication Process</a></p>

<p><a href=""https://code.google.com/p/crypto-js/#HMAC"" rel=""nofollow"">CryptoJS</a></p>
","<p>I hacked around with your code and I got it working.</p>

<pre><code>function sha256(stringToSign, secretKey) {
  var hex = CryptoJS.HmacSHA256(stringToSign, secretKey);
  return hex.toString(CryptoJS.enc.Base64);
} 

function timestamp() {
    var date = new Date();
    var y = date.getUTCFullYear().toString();
    var m = (date.getUTCMonth() + 1).toString();
    var d = date.getUTCDate().toString();
    var h = date.getUTCHours().toString();
    var min = date.getUTCMinutes().toString();
    var s = date.getUTCSeconds().toString();

    if(m.length &lt; 2) { m = ""0"" + m; }
    if(d.length &lt; 2) { d = ""0"" + d; }
    if(h.length &lt; 2) { h = ""0"" + h; }
    if(min.length &lt; 2) { min = ""0"" + min; }
    if(s.length &lt; 2) { s = ""0"" + s}

    var date = y + ""-"" + m + ""-"" + d;
    var time = h + "":"" + min + "":"" + s;
    return date + ""T"" + time + ""Z"";
}

function getAmazonItemInfo(barcode) {
    var PrivateKey = """";
    var PublicKey = """";
    var AssociateTag = """";

    var parameters = [];
    parameters.push(""AWSAccessKeyId="" + PublicKey);
    parameters.push(""ItemId="" + barcode);
    parameters.push(""Operation=ItemLookup"");
    parameters.push(""Service=AWSECommerceService"");
    parameters.push(""Timestamp="" + encodeURIComponent(timestamp()));
    parameters.push(""Version=2011-08-01"");
parameters.push(""AssociateTag="" + AssociateTag);

    parameters.sort();
    var paramString = parameters.join('&amp;');

    var signingKey = ""GET\n"" + ""webservices.amazon.com\n"" + ""/onca/xml\n"" + paramString

    var signature = sha256(signingKey,PrivateKey);
        signature = encodeURIComponent(signature);

    var amazonUrl =  ""http://webservices.amazon.com/onca/xml?"" + paramString + ""&amp;Signature="" + signature;
    console.log(amazonUrl);
}
</code></pre>

<p>The Header of the Javascript I used for some reference.</p>

<pre><code>&lt;script src=""hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""amazon.js""&gt;&lt;/script&gt;
</code></pre>

<p>You will need to modify parts of it because I changed some parameters around and don't reference your ""app"" object.</p>

<p>For what I did to fix it (from what I can recall).</p>

<ol>
<li><p>The parameters have to be alphabetical. I placed them in an array and then sort them. I follow this up by a join with the ampersand.</p></li>
<li><p>I modified the sha256 function to return the base64 of the RAW sha256. Before it was returning the hexbits in lowercase, which isn't correct.</p></li>
<li><p>I was going to add a base64 before encoding, but the sha256 now handles all of the signing.</p></li>
<li><p>The date format was incorrect. It was returning a epoch timestamp instead of a string timestamp. I hacked together a simple timestamp option.</p>

<p>This code requires you to include the Base64 Library for CryptoJS also.</p></li>
</ol>
","1965","<javascript><amazon><cryptojs>","5","4","3","2017-11-09 18:51:03","22587717","4","2","","user396070","2014-03-23 08:29:51","2014-03-23 05:55:13",""
"22587599","How to properly sign a GET request to Amazon's ItemLookup using client-side JavaScript only?","<p>Here's what I have so far:    </p>

<pre><code>function sha256(stringToSign, secretKey) {
  return CryptoJS.HmacSHA256(stringToSign, secretKey);
} 

function getAmazonItemInfo(barcode) {

  var parameters = 
    ""Service=AWSECommerceService&amp;""
    + ""AWSAccessKeyId="" + appSettings.amazon.accessKey + ""&amp;""
    + ""Operation=ItemLookup&amp;""
    + ""ItemId="" + barcode
    + ""&amp;Timestamp="" + Date.now().toString();

  var stringToSign =
    ""GET\n""
    + ""webservices.amazon.com\n""
    + ""/onca/xml\n""
    + parameters;

  var signature = ""&amp;Signature="" + encodeURIComponent(sha256(stringToSign, appSettings.amazon.secretKey));

  var amazonUrl =  
    ""http://webservices.amazon.com/onca/xml?""
    + parameters
    + signature;

  // perform a GET request with amazonUrl and do other stuff

}
</code></pre>

<p>When executed as an HTTP GET request, the value of <code>amazonUrl</code> in the above code results in the following response from Amazon:</p>

<pre><code>&lt;?xml version=""1.0""?&gt; 
  &lt;ItemLookupErrorResponse xmlns=""http://ecs.amazonaws.com/doc/2005-10-05/""&gt;
    &lt;Error&gt;
      &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt;
      &lt;Message&gt;
        The request signature we calculated does not match the signature you provided. 
        Check your AWS Secret Access Key and signing method. Consult the service 
        documentation for details.
      &lt;/Message&gt;
   &lt;/Error&gt;
   &lt;RequestId&gt;[REMOVED]&lt;/RequestId&gt;
  &lt;/ItemLookupErrorResponse&gt;
</code></pre>

<p>Useful links:</p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/ItemLookup.html"" rel=""nofollow"">ItemLookup - Product Advertising API Amazon Documentation</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow"">Example REST Requests</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/BasicAuthProcess.html"" rel=""nofollow"">AWS Authentication Process</a></p>

<p><a href=""https://code.google.com/p/crypto-js/#HMAC"" rel=""nofollow"">CryptoJS</a></p>
","<p>Use <a href=""https://github.com/livelycode/aws-lib"" rel=""nofollow"">this Node.js library for AWS</a>.  It even includes <a href=""https://github.com/livelycode/aws-lib/blob/master/examples/prod-adv.js"" rel=""nofollow"">an example</a> specifically for the Product Advertising API.</p>
","1965","<javascript><amazon><cryptojs>","5","1","3","2017-11-09 18:51:03","22587717","4","2","","user396070","2014-03-23 08:29:51","2014-03-23 05:55:13",""
"22587599","How to properly sign a GET request to Amazon's ItemLookup using client-side JavaScript only?","<p>Here's what I have so far:    </p>

<pre><code>function sha256(stringToSign, secretKey) {
  return CryptoJS.HmacSHA256(stringToSign, secretKey);
} 

function getAmazonItemInfo(barcode) {

  var parameters = 
    ""Service=AWSECommerceService&amp;""
    + ""AWSAccessKeyId="" + appSettings.amazon.accessKey + ""&amp;""
    + ""Operation=ItemLookup&amp;""
    + ""ItemId="" + barcode
    + ""&amp;Timestamp="" + Date.now().toString();

  var stringToSign =
    ""GET\n""
    + ""webservices.amazon.com\n""
    + ""/onca/xml\n""
    + parameters;

  var signature = ""&amp;Signature="" + encodeURIComponent(sha256(stringToSign, appSettings.amazon.secretKey));

  var amazonUrl =  
    ""http://webservices.amazon.com/onca/xml?""
    + parameters
    + signature;

  // perform a GET request with amazonUrl and do other stuff

}
</code></pre>

<p>When executed as an HTTP GET request, the value of <code>amazonUrl</code> in the above code results in the following response from Amazon:</p>

<pre><code>&lt;?xml version=""1.0""?&gt; 
  &lt;ItemLookupErrorResponse xmlns=""http://ecs.amazonaws.com/doc/2005-10-05/""&gt;
    &lt;Error&gt;
      &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt;
      &lt;Message&gt;
        The request signature we calculated does not match the signature you provided. 
        Check your AWS Secret Access Key and signing method. Consult the service 
        documentation for details.
      &lt;/Message&gt;
   &lt;/Error&gt;
   &lt;RequestId&gt;[REMOVED]&lt;/RequestId&gt;
  &lt;/ItemLookupErrorResponse&gt;
</code></pre>

<p>Useful links:</p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/ItemLookup.html"" rel=""nofollow"">ItemLookup - Product Advertising API Amazon Documentation</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow"">Example REST Requests</a></p>

<p><a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/BasicAuthProcess.html"" rel=""nofollow"">AWS Authentication Process</a></p>

<p><a href=""https://code.google.com/p/crypto-js/#HMAC"" rel=""nofollow"">CryptoJS</a></p>
","<p>Building on David's great answer, I made some tweaks. The solution below uses <a href=""http://webservices.amazon.com/scratchpad/"" rel=""nofollow noreferrer"">moment.js</a> and <a href=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"" rel=""nofollow noreferrer"">crytpo-js</a>, and can be used to search for items by keyword. I used the <a href=""http://webservices.amazon.com/scratchpad/"" rel=""nofollow noreferrer"">amazon scratch-pad</a> to help build the target call. A couple of things I noticed: </p>

<ul>
<li>The scratch-pad needs to use the same location as your <a href=""https://affiliate-program.amazon.co.uk"" rel=""nofollow noreferrer"">associates account</a>, "".com"" "".co.uk"", etc.</li>
<li>The end point you call to needs to be the same country as your associates account. </li>
<li>The time-stamp you use needs to match the local time in the country your associates account is registered. </li>
</ul>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const getAmazonItemInfo = (keywords) =&gt; {

  let date = moment().startOf().add(-9, 'hours').format(""YYYY-MM-DDThh:mm:ss.000"") + 'Z'
  let SecretKey = ""GENERATED_IN_AFFILATES_ACCOUNT"";
  let AccessKey = ""GENERATED_IN_AFFILATES_ACCOUNT"";
  let AssociateTag = ""FOUND_IN_AFFILATES_ACCOUNT"";
  let parameters = [];
  let url = 'webservices.amazon.co.uk' // UK account
  //let url = 'webservices.amazon.com'// US account

  parameters.push(""AWSAccessKeyId="" + AccessKey);
  parameters.push(""Keywords="" + keywords);
  parameters.push(""Operation=ItemSearch"");
  parameters.push(""SearchIndex=All"");
  parameters.push(""ResponseGroup="" + encodeURIComponent('Images,ItemAttributes,Offers'));
  parameters.push(""Service=AWSECommerceService"");
  parameters.push(""Timestamp="" + encodeURIComponent(date));
  parameters.push(""AssociateTag="" + AssociateTag);
  parameters.sort();

  let paramString = parameters.join('&amp;');
  let string_to_sign = ""GET\n"" + url + ""\n"" + ""/onca/xml\n"" + paramString

  let signature = CryptoJS.HmacSHA256(string_to_sign, SecretKey);
  signature = CryptoJS.enc.Base64.stringify(signature);

  let amazonUrl = ""http://"" + url + ""/onca/xml?"" + paramString + ""&amp;Signature="" + signature;
  return amazonUrl;
}

let keywords = 'iphone'
console.log(getAmazonItemInfo(keywords))</code></pre>
</div>
</div>
</p>
","1965","<javascript><amazon><cryptojs>","5","0","3","2017-11-09 18:51:03","22587717","4","2","","user396070","2014-03-23 08:29:51","2014-03-23 05:55:13",""
"43276850","javascript triple des encryption value and java triple des encryption values not matched why ?","<p>hi guys i have java code which produce triple des encryption code for me now i am trying to use it on javascript using crypto-js but both codes provides different keys I dont know why and how to get the same key here is my code </p>

<pre><code> public String _encrypt(String message) throws Exception {
 MessageDigest md = MessageDigest.getInstance(""SHA-1"");
 byte[] digestOfPassword = md.digest(secretKey.getBytes(""utf-8""));
 byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
 System.out.println(bytesToHex(keyBytes));

 SecretKey key = new SecretKeySpec(keyBytes, ""TripleDES"");
 Cipher cipher = Cipher.getInstance(""TripleDES"");
 cipher.init(Cipher.ENCRYPT_MODE,key);
 byte[] plainTextBytes = message.getBytes(""utf-8"");
 byte[] buf = cipher.doFinal(plainTextBytes);

 System.out.println(bytesToHex(buf));



 byte [] base64Bytes = Base64.encodeBase64(buf);
 String base64EncryptedString = new String(base64Bytes);

 return base64EncryptedString;
}

 public static String bytesToHex(byte[] in) {
 final StringBuilder builder = new StringBuilder();
 for(byte b : in) {
     builder.append(String.format(""%02x"", b));
 }
 return builder.toString();
 }


 public String _decrypt(String encryptedText) throws Exception {

 byte[] message = Base64.decodeBase64(encryptedText.getBytes(""utf-8""));

MessageDigest md = MessageDigest.getInstance(""SHA-1"");
byte[] digestOfPassword = md.digest(secretKey.getBytes(""utf-8""));
byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");

Cipher decipher = Cipher.getInstance(""DESede"");
decipher.init(Cipher.DECRYPT_MODE, key);

byte[] plainText = decipher.doFinal(message);

return new String(plainText, ""UTF-8"");
}
</code></pre>

<p>and my java script code as follows</p>

<pre><code> key = CryptoJS.SHA1(key);
 console.log(key.toString());
 var iv = String.fromCharCode(0) + String.fromCharCode(0) +    String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0) + String.fromCharCode(0);
 var ivHex = CryptoJS.enc.Hex.parse(iv);

var options = {
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7,
iv: ivHex
};

var encrypted = CryptoJS.TripleDES.encrypt(pt, key, options);
var encryptedBase64 = encrypted.toString();
console.log(encryptedBase64);

var ct = {
ciphertext: CryptoJS.enc.Base64.parse(encryptedBase64)
};                                                    
var decrypted = CryptoJS.TripleDES.decrypt(ct, key, options);
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>key =""3ad5485e60a4fecd""
message=""textToEncrypt""</p>

<p>encrypted got from java          chKL5NVtBXesEKfNIokpdw==</p>

<p>encrypted got from javascript    chKL5NVtBXeTFwswp882Vw==</p>

<p>Can anyone help me or give me brief knowledge why this happens.</p>
","<p>There are multiple differences in the two codes:</p>

<ul>
<li><p>You're probably using different <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">modes of operation</a>. Java is using ECB and JS is using CBC.  </p>

<p><strong>Always use a fully qualified Cipher string.</strong> </p>

<p><code>Cipher.getInstance(""TripleDES"");</code> may result in different ciphers depending on the default security provider. It most likely results in <code>""TripleDES/ECB/PKCS5Padding""</code>, but it doesn't have to be. If it changes, you'll lose compatibility between different JVMs. For reference: <a href=""https://stackoverflow.com/q/6258047/1816580"">Java default Crypto/AES behavior</a></p>

<p>Also, PKCS#5 padding and PKCS#7 padding are equal for all intents and purposes.</p></li>
<li><p>Your key is likely different. A SHA-1 hash has an output of 20 bytes, but a full 3DES key is 24 bytes long. The <code>Arrays.copyOf(digestOfPassword, 24);</code> fills the remaining 4 bytes with 0x00 byte values. In CryptoJS, you're directly passing the short key into the <code>encrypt</code> function. You'd need to fill the remaining bytes with 0x00 bytes. Since CryptoJS handles binary data in a <code>WordArray</code>, this can be done in this way:</p>

<pre><code>key = CryptoJS.SHA1(key);
key.sigBytes += 4; // 32 bit more marked
key.words.push(0); // 32 bit of zeros
</code></pre></li>
<li><p>Your IV is strange. It could be so easy:</p>

<pre><code>var ivHex = CryptoJS.enc.Hex.parse('0000000000000000'); // 8 bytes
</code></pre>

<p>This can be done for testing, but in production the IV must be unpredictable (read: random). Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. The IV is not secret, so you can send it along with the ciphertext. Usually, it is simply prepended to the ciphertext and sliced off before decryption.</p></li>
</ul>

<p>I would suggest that you throw away this code (only provides 80 bit of security and uses bad defaults) and use a library for that such as RNCryptor.</p>

<hr>

<h2>Security considerations</h2>

<p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p>

<p><strong>Don't use Triple DES nowadays.</strong> It only provides at best 112 bit of security even if you use the largest key size of 192 bit. If a shorter key size is used, then it only provides 56 or 57 bits of security. AES would be faster (processors have a special AES-NI instruction set) and even more secure with the lowest key size of 128 bit. There is also a practical limit on the maximum ciphertext size with 3DES. See <a href=""https://security.stackexchange.com/q/26179/45523"">Security comparison of 3DES and AES</a>.</p>
","1933","<javascript><java><sha1><cryptojs><tripledes>","1","1","1","2017-04-07 18:25:24","","4","2","","","","2017-04-07 11:20:04",""
"22172588","Garbled output in AES/CBC/NoPadding Decryption","<p>I'm trying to decrypt text in java that is encrypted using CryptoJS. I've read on other posts that they use different default modes and padding so I set them both(java/cryptojs) both to use aes/cbc/nopadding. I no longer get an exception in java, but I am getting a garbled output during decryption</p>

<p>Encryption(JS):</p>

<pre><code>var parsedLogin = JSON.parse(login);
var publicKey = ""abcdefghijklmnio"";
var publiciv =  ""abcdefghijklmnio"";
var key = CryptoJS.enc.Hex.parse(publicKey);
var iv = CryptoJS.enc.Hex.parse(publiciv);
var encrypted = CryptoJS.AES.encrypt(parsedLogin.password, publicKey, {iv: publiciv}, { padding: CryptoJS.pad.NoPadding, mode: CryptoJS.mode.CBC});

// send encrypted to POST request 
</code></pre>

<p>DECRYPT (Java)</p>

<pre><code>String PUBLIC_KEY = ""abcdefghijklmnio"";
String PUBLIC_IV = ""abcdefghijklmnio"";
byte[] byteArr = PUBLIC_KEY.getBytes();
Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
final SecretKeySpec secretKey = new SecretKeySpec(byteArr, ""AES"");
cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(PUBLIC_IV.getBytes()));

byte[] parsed = Base64.decodeBase64(encrypted.getBytes());
//byte[] parsed = DatatypeConverter.parseBase64Binary(encrypted); 

byte[] fin = cipher.doFinal(parsed);
String decryptedString = new String(fin);
</code></pre>

<p>The result that I'm getting is like this: !a{`@""?rkr</p>

<p>I have already tried changing the CHARSET in the getBytes() to US-ASCII, UTF-8 and UTF-16 but all this does is change the garbled text</p>

<p>I have also tried using othe blocking modes and paddings but they failed at the js level. I just need a simple encryption method right now.</p>

<p>NOTE: 
Ignore the security issues...like having the key exposed in js, etc. I'll be handling those later..</p>
","<p>You shouldn't be able to use AES CBC without padding unless the password is always 16 bytes. It probably applies some sort of default padding that may or may not be a good idea.</p>

<p>Anyway: you need to pass your key and iv to CryptoJS as a WordArray; if you give it a string it will assume you're giving it a passphrase and derive a different key from that. As such, your Java decryption code will be using a different key/iv pair. You can create a WordArray from your strings using </p>

<pre><code>var key = CryptoJS.enc.Utf8.parse(""abcdefghijklmnio"")
var iv = ...
</code></pre>
","1889","<java><javascript><encryption><aes><cryptojs>","1","1","1","2014-03-04 13:30:00","","2","2","","","","2014-03-04 12:56:53",""
"27826334","Jquery error : too much recursion","<p>I'm trying to create a file upload system implementing client side encryption using CryptoJS.</p>

<p>The problem I'm having is that execution of the script is stopped by the following error in Firebug's console : <code>too much recursion</code></p>

<p>I have spent half of the day trying to resolve the problem, removing the <code>var jqxhr = $.ajax</code> part removes the error but removes posting functionality from my script. I have tried removing all the encryption lines, separating into different functions, but nothing seems to do it. Any jQuery pros know what's going wrong ?</p>

<p>Here's the code :</p>

<pre><code>$(""#successmsg"").hide();
$(""#errormsg"").hide();

function randomString(n)
{
    var text = '';
    var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

    for(var i=0; i &lt; n; i++)
    {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }

    return text;
}


$(""#upload"").submit(function(event) {
    event.preventDefault();

    input = document.getElementById('file');

    if(!input.files[0]) {
        $(""#errormsg"").html(""No file selected."");
        $(""#successmsg"").hide();
        $(""#errormsg"").show();
    }

    fr = new FileReader();

    fr.onload = function() {
        var fname = input.files[0].name;
        var fkey = CryptoJS.SHA256(randomString(128));
        var skey = CryptoJS.SHA256(fkey);

        var fdata = CryptoJS.AES.encrypt(fr.result, ""TestPassword"");

        var jqxhr = $.ajax({
            url: ""/api/files/upload"",
            type: ""POST"",
            data: {
                'name': fname,
                'data': fdata,
                'key': skey
            },
            cache: false,
            dataType: 'json',
            processData: false
        });
    }

    fr.readAsText(input.files[0]);
});
</code></pre>

<p>Here is a JSFiddle : <a href=""http://jsfiddle.net/wob66Lc0/"" rel=""nofollow"">http://jsfiddle.net/wob66Lc0/</a></p>
","<p>The issue is that <code>CryptoJS</code> functions return objects not strings, so you have to stringify it before you attempt to send it.</p>

<pre><code>    var jqxhr = $.ajax({
        url: ""/api/files/upload"",
        type: ""POST"",
        data: {
            'name': fname,
            'data': fdata.toString(),
            'key': skey.toString()
        }
    });
</code></pre>

<p><a href=""http://jsfiddle.net/wob66Lc0/1/"">http://jsfiddle.net/wob66Lc0/1/</a></p>

<p>Also encryption works on bytes not text so you should read the file as a binary string instead of text</p>

<pre><code>fr.readAsBinaryString(input.files[0]); 
</code></pre>
","1847","<jquery><ajax><recursion><xmlhttprequest><cryptojs>","0","5","1","2016-07-13 03:47:49","27826808","6","1","1113772","","2016-07-13 03:47:49","2015-01-07 18:39:33",""
"36196425","Converting C# Cryptography.Rijndael encryption to Javascript (pref. crypto-js)","<p>I have two system which are sharing a user database, so authentication needs to be the same.</p>

<p>The passwords are currently encrypted using C#'s <code>Cryptography.Rijndael</code>(N.B. <strong>not</strong> RijndaelManaged). Using a custom key and iv (initialisation vector). (CBC mode and Pkcs7 padding)</p>

<p>The C# encryption is as follows:</p>

<pre><code>Rijndael alg = Rijndael.Create();
alg.Key = key;
alg.IV = IV;
CryptoStream cs = new CryptoStream(ms, alg.CreateEncryptor(), CryptoStreamMode.Write);
cs.Write(clearData, 0, clearData.Length);
cs.Close();
byte[] encryptedData = ms.ToArray();
</code></pre>

<p><code>key</code> is 256 bits (32 bytes) and <code>iv</code> (initialisation vector) is 128 bits (16 bytes). The block size is 128 bits (16 bytes).</p>

<p>key and iv are a byte arrays from a base64 strings via: </p>

<pre><code>byte[] key = Convert.FromBase64String(base64Key);
byte[] iv = Convert.FromBase64String(base64IV);
</code></pre>

<p>N.B. I have no control on the C# code (legacy system).</p>

<p>On the javascript based system I have to encrypt the passwords exactly the same way. I've tried using node <code>crypto-js</code> to no avail.
my code looks something like this:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(password), keyCodeWords, {
    iv: ivCodeWords,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>keyCodeWords and ivCodeWords are CryptoJS code words from the same base64 key and iv as follows:</p>

<pre><code>var keyCodeWords = CryptoJS.enc.Base64.parse(base64Key);
var ivCodeWords = CryptoJS.enc.Base64.parse(base64IV);
</code></pre>

<p>The encryption does work (in the sense that I can encrypt and then decrypt to get the same value). However, the issue is that the encrypted value (<code>encrypted.ciphertext</code>) is not the same as the C# one, so I'm unable to authenticate.</p>

<p>The comparison is done base comparing the base64 encrypted output strings.</p>

<p><strong>How do I make crypto-js (or any other javascript encryption library) consistent with C# Rijndael?</strong></p>
","<p>The code works correctly... Your problem is probably in the handling of the password/IV in C# or in Javascript... In C#: <a href=""https://ideone.com/APC4MM"" rel=""nofollow"">https://ideone.com/APC4MM</a> and in Javascript: <a href=""https://jsfiddle.net/jjwy5472/"" rel=""nofollow"">https://jsfiddle.net/jjwy5472/</a></p>

<p>I've used in both cases the same password:</p>

<pre><code>byte[] key = new byte[] 
{ 
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
};

byte[] iv = new byte[] 
{ 
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
};
</code></pre>

<p>the plaintext is</p>

<pre><code>""Hello world! This is a wonderful day! ""
</code></pre>

<p>and in both cases the resulting encrypted text is</p>

<pre><code>aa429aa5c1c928b86d81b43ff3fb6cc46f24cc73957bc7c00829357bf441eb3be9cf8aef2ff6f819f9b95c69886b169b6959c4f7ece0620c6a28f849516adee9
</code></pre>

<p>But note that the <code>encrypted</code> variable in Javascript is a complex object, containing various properties with various versions of your encrypted data. <code>encrypted.toString()</code> returns the base64 version of the encrypted data, <code>encrypted.ciphertext</code> is a <code>WordArray</code> (the equivalent of CryptoJS of <code>byte[]</code>), and <code>encrypted.ciphertext.toString()</code> is the hex version of it (equivalent to doing <code>BitConverter.ToString(encryptedData).Replace(""-"", """").ToLowerInvariant()</code> in C#).</p>
","1843","<javascript><c#><cryptojs><rijndael>","0","3","1","2016-03-24 10:04:15","36197421","7","1","3907388","","2016-03-24 09:56:52","2016-03-24 09:03:09",""
"46263896","Javascript - CryptoJS is not defined","<p>justing any help/suggestions with a continuous issue I've been having throughout the entirety of today. I've gone to almost every other possible forum available to try and find a fix, but I'm still having no form of luck whatsoever. From some other discussions on the topic, I've pulled the following simple script to test the it's functionality (both with local files and via the online src), but still am being prompted with ""Uncaught ReferenceError: CryptoJS is not defined"". Any help would be really appreciated.</p>

<pre><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/aes-min.js""&gt;&lt;/script&gt;

    &lt;script&gt;
        var encryptedAES = CryptoJS.AES.encrypt(""Message"", ""My Secret Passphrase"");
        var decryptedBytes = CryptoJS.AES.decrypt(encryptedAES, ""My Secret Passphrase"");
        var plaintext = decryptedBytes.toString(CryptoJS.enc.Utf8);
    &lt;/script&gt;
</code></pre>
","","1826","<javascript><encryption><aes><cryptojs>","1","","0","2017-09-17 12:08:03","","2","","","","","2017-09-17 12:08:03",""
"21378266","Crypto.js: ""Uint8ClampedArray"" is undefined in IE 11","<p><code>Crypto JS</code> uses <code>Uint8ClampedArray</code> which is not support by any version of <code>IE</code>. Are there any known workarounds?</p>

<p><img src=""https://i.stack.imgur.com/63yTw.png"" alt=""enter image description here""></p>
","<p>There is an issue open in CryptoJS project page:</p>

<p><a href=""http://code.google.com/p/crypto-js/issues/detail?id=81"" rel=""nofollow"">http://code.google.com/p/crypto-js/issues/detail?id=81</a></p>

<p>Some workarounds are discussed there.</p>

<p>An solution might be to use more recent (unreleased) code of CryptoJS.</p>

<p>An issue on MS IE web pages regarding support for types arrays:</p>

<p><a href=""https://connect.microsoft.com/IE/feedback/details/808589/html-canvas-does-not-return-imagedata-as-uint8clampedarray"" rel=""nofollow"">https://connect.microsoft.com/IE/feedback/details/808589/html-canvas-does-not-return-imagedata-as-uint8clampedarray</a></p>
","1818","<javascript><internet-explorer><cryptojs>","4","4","1","2014-03-20 18:12:39","","1","","321731","","2014-03-20 18:12:39","2014-01-27 10:21:35",""
"16558393","CryptoJS AES and Java AES encrypted value mismatch","<p>I am trying to encrypt in client and decrypt in sever using AES,
    so using cryptojs to encrypt in client side with CBC mode and nopadding
    in server side also using <code>Cipher</code> class with same mode and nopadding </p>

<pre class=""lang-js prettyprint-override""><code>function call()
{
  var key = CryptoJS.enc.Hex.parse('roshanmathew1989');
  var iv  = CryptoJS.enc.Hex.parse('roshanmathew1989');
  var encrypted = CryptoJS.AES.encrypt(""roshanmathew1989"",key,{ iv: iv},
      {padding:CryptoJS.pad.NoPadding});
  alert(encrypted.ciphertext.toString(CryptoJS.enc.Base64));
  alert(encrypted.iv.toString());
}
</code></pre>

<p>Server side code</p>

<pre class=""lang-java prettyprint-override""><code>public class Crypto
{ 

  private static byte[] key = null;

  public void setKey(String key){this.key=key.getBytes();}

  public String encrypt(String strToEncrypt)
  {
    String encryptedString =null;
    try
    {
      Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
      final SecretKeySpec secretKey = new SecretKeySpec(key,""AES"");
      System.out.println(""sdfsdf = ""+key.toString());
      IvParameterSpec ips = new IvParameterSpec(key);
      cipher.init(Cipher.ENCRYPT_MODE, secretKey,ips);
      encryptedString = Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes()));
    }
    catch(Exception e)
    {
      System.out.println("" ERROR : ""+e.getMessage());
    }
    return encryptedString;

  } other method omitted ....
</code></pre>

<p>implementation</p>

<pre><code>Crypto cry=new Crypto();
cry.setKey(""roshanmathew1989"");
String s=cry.encrypt(""roshanmathew1989"");
</code></pre>

<p>Results</p>

<pre class=""lang-none prettyprint-override""><code>Browser side value =       O64X/bKNBu7R2Tuq2lUbXeFlQ7wD2YnFasyyhsVUryw=
Server side value of s =   RrNcVIER/75fzdjHr884sw==
</code></pre>

<p>Can anybody point out the mistake?</p>
","<p>There are a few things wrong with the code:</p>

<ul>
<li>you are using hexadecimal decoding of the key in JavaScript, and <code>String.getBytes()</code> - character encoding without specifying the character set - in Java</li>
<li>your key is 16 characters (it should be 16, 24 or 32 randomized <em>bytes</em>), but it is not in hexadecimals</li>
<li>you are encrypting instead of decrypting on the ""server side"", although that one is probably on purpose</li>
</ul>

<p>Take another good look on how to perform encoding and character-encoding, they are essential for good crypto and often performed incorrectly (it's probably the most common issue on Stackoverflow regarding encryption) </p>
","1815","<java><javascript><aes><cryptojs>","0","0","1","2019-01-15 12:41:25","","2","4","474189","","2013-05-15 07:33:28","2013-05-15 06:39:02",""
"27916069","Encryption in jsp and decryption in jQuery with AES","<p>I want to encrypt in jsp and decrypt in jquery, i did below code in jsp </p>

<pre><code>String myKey = ""dfslkskfs"";
MessageDigest sha = null;
key = myKey.getBytes(""UTF-8"");
sha = MessageDigest.getInstance(""SHA-1"");
key = sha.digest(key);
key = Arrays.copyOf(key, 16); // use only first 128 bit
secretKey = new SecretKeySpec(key, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secretKey);
byte[]   bytesEncoded = Base64.encodeBase64(cipher.doFinal(json
        .getBytes(""UTF-8"")));
jsontext =  new String(bytesEncoded );
</code></pre>

<p>html tag in jsp file :-</p>

<pre><code>&lt;input type=""hidden""  id=""jsonid"" value=&lt;%=jsontext%&gt; /&gt;
&lt;input type=""hidden"" name=secretKey id=""secretKey"" value=&lt;%=new String(secretKey.getEncoded())%&gt; /&gt;
</code></pre>

<p>Jquery Code</p>

<p>I used below two js files for decryption
aes.js,mode-ecb-min.js </p>

<pre><code>jsonString      = $(""#jsonid"").val();
secretKey       = $(""#secretKey"").val();
jsonString = escapeStr(jsonString);


var key = CryptoJS.enc.Base64.parse(secretKey);

var decryptedData = CryptoJS.AES.decrypt(jsonString, key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
var decryptedText = decryptedData.toString(CryptoJS.enc.Utf8);
alert(decryptedText);
</code></pre>

<p>If I run above code I got exception ""Uncaught Error: Malformed UTF-8 data"" so please tell me where I went wrong or you can tell me any other gud ways.</p>
","<p>The problem is two-fold.</p>

<p>The secret key is not actually encoded when you call <code>secretKey.getEncoded()</code>. You should encode it as Base64 before putting it into the page. Here are some solutions: <a href=""https://stackoverflow.com/questions/5355466/converting-secret-key-into-a-string-and-vice-versa"">Converting Secret Key into a String and Vice Versa</a></p>

<p>On the client side, you parse the key, but not the ciphertext which you actually encoded as Base64. You should parse both from Base64.</p>
","1797","<jquery><jsp><encryption><aes><cryptojs>","0","0","1","2015-01-13 10:10:12","","3","2","1816580","","2015-01-13 09:58:49","2015-01-13 06:23:57",""
"37641927","AES encryption with CryptoJS and decryption with CodeIgniter","<p>I'm trying to encrypt a username sent via POST request to my server (written in Codeigniter 3), so I'm encrypting on the client side with <a href=""https://github.com/sytelus/CryptoJS"" rel=""nofollow"">CryptoJS</a> like so:</p>

<pre><code>var user = $('.user').val();
var key = ""&lt;? echo($key);?&gt;""; //$key is created on the server side
var encUser = CryptoJS.AES.encrypt(user, key, {
    mode: CryptoJS.mode.CBC
}).toString();
</code></pre>

<p>I get a fine looking 64 characters long string, which I send to my server.</p>

<p>On my server (running CodeIgniter 3) I am using the CI <a href=""https://www.codeigniter.com/user_guide/libraries/encryption.html"" rel=""nofollow"">encryption</a> library and I'm loading it as required, but when I try to decrypt the string like so:</p>

<pre><code>$this-&gt;encryption-&gt;decrypt($this-&gt;input-&gt;post('encUser'), array(
    'cipher' =&gt; 'aes-128',
    'mode' =&gt; 'cbc',
    'hmac' =&gt; FALSE,
    'key' =&gt; $key
));
</code></pre>

<p>the function returns <code>(bool)false</code>, meaning something went wrong.</p>

<p>What am I doing wrong?</p>

<p>Note: not sure how much I need to encrypt with <code>iv</code> because the CI library just uses the first 16 chars from the string itself.  </p>

<p>** <strong>EDIT</strong> **</p>

<p>I'm creating my <code>$kay</code> (passphrase) with the help of the <a href=""https://github.com/paragonie/random_compat"" rel=""nofollow"">random_int</a> polyfill and this is my function:</p>

<pre><code>private function random_str($length, $keyspace = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')
{
    $str = '';
    $max = mb_strlen($keyspace, '8bit') - 1;
    for ($i = 0; $i &lt; $length; ++$i) {
        $str .= $keyspace[random_int(0, $max)];
    }
    return $str;
}
</code></pre>

<p>Which i am calling <code>random_str(32)</code>;</p>

<p>Example generated key: <code>1xB8oBQgXGPhcKoD0QkP1Uj4CRZ7Sy1c</code></p>

<p>** <strong>UPDATE</strong> **
thanks to Artjom.B's answer(and chat <code>:)</code> ) we got it working, using his answer's client side code and fixing the server side code to be:</p>

<pre><code>$user = $this-&gt;encryption-&gt;decrypt(base64_decode($this-&gt;input-&gt;post('encUser')), array(
        'cipher' =&gt; 'aes-256',
        'mode' =&gt; 'cbc',
        'hmac' =&gt; FALSE,
        'key' =&gt; $key
    ));
</code></pre>

<p>and now everything is working.</p>
","<p>In CryptoJS, if <code>key</code> is a string, then it will assume that <code>key</code> is actually a password, generate a random salt and derive the actual key and IV from password+salt (this is done in an OpenSSL-compatible way through <code>EVP_BytesToKey</code>).</p>

<p>CodeIgniter's Encryption library doesn't support this type of key derivation. You will either have to change your CryptoJS code to pass in a parsed <code>WordArray</code>:</p>

<pre><code>var key = CryptoJS.enc.Hex.parse(""&lt;? echo(bin2hex($key));?&gt;"");
var iv = CryptoJS.lib.WordArray.random(128/8);
var encUser = CryptoJS.AES.encrypt(user, key, {
    iv: iv
}).ciphertext;
return iv.concat(encUser).toString(CryptoJS.enc.Base64);
</code></pre>

<p>Since the IV is written in front of the ciphertext, CodeIgniter should read it correctly and it doesn't have to be specified explicitly. Make sure that <code>key</code> is correctly encoded as Hex or Base64, because binary encoding doesn't work in JavaScript correctly. Also, at the PHP side, the ciphertext must be decoded from Base64.</p>

<p>You could also implement <code>EVP_BytesToKey</code> in PHP as I've shown <a href=""https://stackoverflow.com/a/27678978/1816580"">here</a>.</p>
","1782","<php><codeigniter><encryption><cryptojs>","0","0","1","2017-08-10 17:55:16","37642133","2","","3843814","","2016-06-05 15:56:21","2016-06-05 12:29:56",""
"44796371","Sha256 with byte[32] using CryptoJS?","<p>Using CryptoJS i got as a result a byte[8] when I need a 32 one, this code exactly:</p>

<pre><code>CryptoJS.SHA256(word);
</code></pre>

<p>How to get the 32?</p>
","<pre><code>CryptoJS.SHA256(word).toString()
</code></pre>
","1777","<javascript><typescript><cryptojs>","0","-1","3","2017-06-29 06:34:15","","0","","","","","2017-06-28 07:40:04",""
"44796371","Sha256 with byte[32] using CryptoJS?","<p>Using CryptoJS i got as a result a byte[8] when I need a 32 one, this code exactly:</p>

<pre><code>CryptoJS.SHA256(word);
</code></pre>

<p>How to get the 32?</p>
","<p>This feels a bit convoluted, but I don't have a lot of experience with CryptoJS so perhaps there's a solution that requires less steps:</p>

<pre><code>const CryptoJS = require('crypto-js');

let hash   = CryptoJS.SHA256('hello world');
let buffer = Buffer.from(hash.toString(CryptoJS.enc.Hex), 'hex');
let array  = new Uint8Array(buffer);
</code></pre>

<p>If you need a proper JS array (one for which <code>Array.isArray</code> returns <code>true</code>), you can use this:</p>

<pre><code>let array = Array.from( new Uint8Array(buffer) );
</code></pre>
","1777","<javascript><typescript><cryptojs>","0","1","3","2017-06-29 06:34:15","","0","","","","","2017-06-28 07:40:04",""
"44796371","Sha256 with byte[32] using CryptoJS?","<p>Using CryptoJS i got as a result a byte[8] when I need a 32 one, this code exactly:</p>

<pre><code>CryptoJS.SHA256(word);
</code></pre>

<p>How to get the 32?</p>
","<p>The solution was in my case:</p>

<pre><code>let utf16le = CryptoJS.enc.Utf16LE.parse(word);
let utf16Sha256 = CryptoJS.SHA256(utf16le);
return utf16Sha256.toString(CryptoJS.enc.Hex);
</code></pre>

<p>thanks to someone's else question</p>
","1777","<javascript><typescript><cryptojs>","0","0","3","2017-06-29 06:34:15","","0","","","","","2017-06-28 07:40:04",""
"23188593","CryptoJS, check if AES passphrase is correct","<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
</code></pre>

<p>Assuming the encryption and decryption phases are separated (happening in separate parts of the program), is there any way I can check if <code>""Secret Passphrase""</code> is the correct one in the decryption phase?</p>

<p>I've noticed that decrypting with a wrong passphrase will result in <code>decrypted.toString()</code> being an empty string. What then if the original message was an empty string too? Isn't there any other parameter I can use to check if the passphrase is indeed correct?</p>

<hr>

<p><em>Side notes</em></p>

<p>My current solution: always create a non-empty control value, encrypted with the passphrase. If the control values decrypts to """", passphrase was not correct.</p>

<p>EDIT: turns out my solution doesn't work. Very similar passphrases are decrypting the message to different values which are, still, different from an empty string. The security is not compromised, but I still don't have any way to see if the passphrase was correct.</p>

<p><code>this is my very cool key!</code> and <code>this is my very cool key!!</code> are both returning a string, even though only the first one is the actual passphrase used to encrypt.</p>

<p>EDIT 2: the string returned from the wrong passphrase is not valid UTF-8. Hence, calling <code>value.toString(CryptoJS.enc.Utf8)</code> returns an error. I could use this error to check if the passphrase was correct. Still, this solutions sucks very much!</p>
","<p>You have just stumbled onto the subtle but important difference between message confidentiality and message integrity/authentication.</p>

<p>Confidentiality is what you are currently doing it ensures that the message can't be read in transit without the associated key but it can't ensure that the message hasn't been altered during transit (attacks on early crypto systems involved modifying the encrypted message to inject or reveal information about the crypto system). Your problem is a variant of this in that if you happened to find a key that decrypted the message ""surrender"" to ""bombs away"" then there is no way to know that they key was switched.</p>

<p>Integrity deals with ensuring that what is decrypted is what was actually encrypted in the first place and can also ensure Authentication (who encrypted it) depending on the model used. Integrity is best achieved by using a <a href=""http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""noreferrer"">mode of operation</a> the supports it intrinsically such as <a href=""http://en.wikipedia.org/wiki/Galois/Counter_Mode"" rel=""noreferrer"">GCM</a> but from a cursory glance crypto-js doesn't support any integrity modes.</p>

<p>This leaves you with a manual approach which requires producing and sending a <a href=""http://en.wikipedia.org/wiki/Hash-based_message_authentication_code"" rel=""noreferrer"">HMAC</a> along with the encrypted message.</p>

<pre><code>var message = ""Message"";
var passphrase = ""Secret Passphrase"";
var encrypted = CryptoJS.AES.encrypt(message, passphrase).toString();
var hmac = CryptoJS.HmacSHA256(encrypted, CryptoJS.SHA256(passphrase)).toString();
var transitmessage = hmac + encrypted;

//other side

var transithmac = transitmessage.substring(0, 64);
var transitencrypted = transitmessage.substring(64);
var decryptedhmac = CryptoJS.HmacSHA256(transitencrypted, CryptoJS.SHA256(passphrase)).toString();
alert(transithmac == decryptedhmac);
var decrypted = CryptoJS.AES.decrypt(transitencrypted, passphrase).toString(CryptoJS.enc.Utf8);
alert(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>In theory the IV should also be prepended to the encrypted message before the HMAC call but I wasn't sure how to get the IV back out with crypto-js and I was hoping to keep this example simple enough and unless you expect to be a target of the NSA this should be enough as the IV already modifies the encrypted message.</p>
","1756","<javascript><encryption><cryptojs>","1","6","1","2016-11-26 22:24:23","23190781","0","3","1307020","","2014-04-20 23:36:14","2014-04-20 23:08:11",""
"52198298","How to import crypto-js in Ionic 4","<p>I used following npm command to install</p>

<pre><code>npm install crypto-js
</code></pre>

<p>After installing i imported </p>

<pre><code>import CryptoJS from 'crypto-js';
</code></pre>

<p>But i am not getting any when i type Crypto. i dont get any IntelliSense.
I have read on some of the posts which says that i need to add</p>

<pre><code>npm install --save @types/crypto-js
</code></pre>

<p>Tried that as well but then i start getting the error on import statement</p>

<p>I will appreciate if someone can guide me what are the steps i need to follow to make this work.</p>
","<p>You need to import like this:</p>

<pre><code>import * as CryptoJS from 'crypto-js';
</code></pre>
","1750","<javascript><angular><ionic-framework><cryptojs><ionic4>","1","1","1","2018-09-06 09:03:38","","0","","5730444","","2018-09-06 08:42:01","2018-09-06 07:06:07",""
"18751955","Getting an empty string when trying to decode AES-128-CBC ciphertext","<p>Even though I'm sure I have the right data (verified through an online decoder), I'm only getting empty strings as my output from the decoder.</p>

<p>This is my javascript:</p>

<pre><code>var cipher  = CryptoJS.enc.Base64.parse(data.split(""--"")[0]);
var inv     = CryptoJS.enc.Base64.parse(data.split(""--"")[1]);

console.log(""Ciphertext"");
console.log(cipher);                             // as word array
console.log(CryptoJS.enc.Hex.stringify(cipher)); // as hex string
console.log(""IV"");
console.log(inv);                                // as word array
console.log(CryptoJS.enc.Hex.stringify(inv));    // as hex string

// don't worry, this key won't be used in production ;-)
var key = CryptoJS.enc.Utf8.parse(""GzUaLsk7SI9VDja3"");
var decrypted = CryptoJS.AES.decrypt(cipher, key, { iv: inv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });

console.log(decrypted);

decrypted = decrypted.toString(CryptoJS.enc.Utf8);
console.log(decrypted);
</code></pre>

<p><code>data</code> is a string with the ciphertext and IV, both Base64 encoded, separated by 2 dashes ('--').</p>

<p>I pasted the hex representation of the ciphertext and IV into <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow"">this tool</a> to verify whether my data is right, and that gave me the desired result.</p>

<p>Can someone please help me with why I'm getting empty strings (and empty word arrays, for that matter) out of the decrypt function? I do not get any errors with this code at all, by the way.</p>
","<p>As I expected, the problem wasn't the padding. Here is the working code:</p>

<pre><code>var cipher = CryptoJS.enc.Base64.parse(data.split(""--"")[0]);
var inv    = CryptoJS.enc.Base64.parse(data.split(""--"")[1]);

var key = CryptoJS.enc.Utf8.parse(""GzUaLsk7SI9VDja3"");
var aesDecryptor = CryptoJS.algo.AES.createDecryptor(key, { iv: inv });

var decrypted = aesDecryptor.process(cipher);
var plaintext = decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>
","1739","<javascript><aes><cryptojs>","2","4","1","2013-09-15 13:14:50","18812802","4","0","","","","2013-09-11 21:55:12",""
"51978889","How to generate a SHA256 hash of 32 bytes using nodejs (crypto) in order to avoid bad key size error thrown from tweetnacl.js?","<p>I am using the <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto</a> module of node.js to generate a SHA256 hash like this:</p>

<pre><code>const key = crypto.createHmac('sha256', data).digest('hex');
</code></pre>

<p>Now, <a href=""https://github.com/dchest/tweetnacl-js"" rel=""nofollow noreferrer"">tweetnacl</a> throws the error: <code>bad key size</code> when the key is passed in the <code>secretbox</code>:</p>

<pre><code>nacl.secretbox(data, Rnonc, key);
</code></pre>

<p>The parameters are converted into Uint8Array since the <code>secretbox</code> requires arguments to be Uint8Array.</p>

<p>The error: <code>bad key size</code> is throw from <a href=""https://github.com/dchest/tweetnacl-js/blob/master/nacl.js#L925"" rel=""nofollow noreferrer"">here</a> in <code>tweetnacl</code> since the <code>crypto_secretbox_KEYBYTES</code> is defined as <code>32</code> <a href=""https://github.com/dchest/tweetnacl-js/blob/master/nacl.js#L862"" rel=""nofollow noreferrer"">here</a>. The problem is the key returned from <code>crypto</code> is in not 32 bytes size. </p>

<p>I have searched SO and relevant sites, but couldn't find any feasible solution but according to <a href=""https://bitcointalk.org/index.php?topic=1692976.0"" rel=""nofollow noreferrer"">this</a> - the SHA256 hash converted to hex produces: </p>

<blockquote>
  <p>32 separate hexadecimal numbers (or 32 bytes)</p>
</blockquote>

<p>How can I generate a SHA256 key of 32 bytes in order to avoid this error using node.js? Is there something I am doing wrong in generating the SHA256 hash? </p>
","<p>The following code snippet solved the issue of generating a 32 bytes SHA256 hash avoiding the bad key size error thrown from tweetnacl.js:</p>

<pre><code>const CryptoJS = require('crypto-js');

let hash   = CryptoJS.SHA256('hello world');
let buffer = Buffer.from(hash.toString(CryptoJS.enc.Hex), 'hex');
let array  = new Uint8Array(buffer);
</code></pre>

<p>This always generates a <code>Uint8Array</code> of 32 bytes size. Notice here I had to use the <code>crypto-js</code> module although I preferred to use the native <code>crypto</code> module but I guess I would just use it for now as it is a working solution. </p>

<p>Thanks to @Arihant for pointing to <a href=""https://stackoverflow.com/questions/44796371/sha256-with-byte32-using-cryptojs"">this</a> (check the comment section)</p>
","1709","<javascript><node.js><sha256><cryptojs><nacl-cryptography>","1","1","1","2018-08-26 07:59:45","51997639","7","1","4397077","","2018-08-26 07:59:45","2018-08-23 05:29:01",""
"15480590","Decrypting AES encrypted in C# with crypto-js","<p>I am encrypting a string with AES in C# like this :</p>

<pre><code>public static byte[] KeyFromString(string key, int keyBits)// keyBits is 128, 192, or 256.
{ 
    byte[] keyBinary = Encoding.UTF8.GetBytes(key);
    byte[] b = new byte[keyBits / 8];
    for (int i = 0, j = 0; i &lt; b.Length &amp;&amp; j &lt; keyBinary.Length; i++, j++)
    {
        b[i] = keyBinary[j];
    }
    return b;
}

public static string encrypt(string key, string input)
{
    byte[] inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
    byte[] keyBytes = KeyFromString(key, 256);
    byte[] encrypted = null;

    using (RijndaelManaged rijAlg = new RijndaelManaged())
    {
        rijAlg.Mode = CipherMode.CBC;
        rijAlg.Padding = PaddingMode.PKCS7;
        rijAlg.KeySize = 256;

        rijAlg.Key = keyBytes;
        rijAlg.IV = new byte[rijAlg.IV.Length]; //use empty IV

        using(var encryptor = rijAlg.CreateEncryptor())
        {
            encrypted = encryptor.TransformFinalBlock(inputBytes, 0, inputBytes.Length); 
        }
    }

    var res = Convert.ToBase64String(encrypted);
    return res;
}
</code></pre>

<p>And I want to decrypt ciphered text in javascript, I tryed with crypto-js :</p>

<pre><code>var iv = [];
for (var i = 0 ; i &lt; 16 ; i++) iv.push(0); //empty IV
var options = { keySize: 256 / 8, mode: CryptoJS.mode.CBC, iv: iv, padding: CryptoJS.pad.Pkcs7 };
var decrypted = CryptoJS.AES.decrypt(cipheredtext, key, options);
var decryptedText = decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>The decrypted text I got is empty. I tried multiple changes in encoding, key size, etc</p>

<p>I can use another javascript Library if needed</p>
","<p>Perhaps CryptoJS docs don't mention this explicitly enough, but in order for the crypto algorithm of your choice (AES in your case) to use the exact key and IV you provide they must be passed in as a CJS type WordArray.</p>

<p>One way to get the word arrays is to use parse methods of an encoding of your choice:</p>

<pre><code>var iv = CryptoJS.enc.Hex.parse(""HEX ENCODING OF THE KEY"");
var key = CryptoJS.enc.Hex.parse(""HEX ENCODING OF THE IV"");
</code></pre>

<p>after that, all you do should work fine.</p>

<p>Hope someone finds this useful Took me a while to figure this out a couple of days ago.</p>
","1690","<cryptojs>","1","2","1","2013-09-13 13:18:30","","1","","458741","","2013-03-18 15:49:01","2013-03-18 15:29:41",""
"25593574","Progressive Upload and Encryption with CryptoJS","<p>The goal here is to upload a file, encrypt it at the client side, and send the file and its attributes via AJAX to myphpscript.php.  To allow larger files, I want to upload in slices using the FileReader slice method and progressively encrypt the slices using the methods described on the CryptoJS site (<a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a>).  My code below runs, but only ends up storing a a small portion of the intended entire encrypted file.  Can I progressively upload and encrypt in the way I am describing?</p>

<pre><code>&lt;script type=""text/javascript"" src=""js/jquery-1.11.0.min.js""&gt;&lt;/script&gt;
&lt;script src=""js/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    function readBlob(opt_startByte, opt_stopByte) {

        var files = document.getElementById('fileinput').files;
        if (!files.length) {
            alert('Please select a file!');
            return;
        }

        var file = files[0];
        var start = parseInt(opt_startByte) || 0;
        var stop = parseInt(opt_stopByte) || file.size - 1;

        var reader = new FileReader();

        // If we use onloadend, we need to check the readyState.
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE) { // DONE == 2
                window.bits.push(aesEncryptor.process(evt.target.result));
            }
        };

        var blob = file.slice(start, stop + 1);
        reader.readAsBinaryString(blob);
    }

    function handling(evt) {

        // INITIALIZE PROGRESSIVE ENCRYPTION
        var key = CryptoJS.enc.Hex.parse(document.getElementById('pass').value);
        var iv = CryptoJS.lib.WordArray.random(128 / 8);
        window.bits = [];
        window.aesEncryptor = CryptoJS.algo.AES.createEncryptor(key, {iv: iv});

        // LOOP THROUGH BYTES AND PROGRESSIVELY ENCRYPT
        var startByte = 0;
        var endByte = 0;
        while(startByte &lt; document.querySelector('input[type=file]').files[0].size - 1){
            endByte = startByte + 1000000;
            readBlob(startByte, endByte);
            startByte = endByte;
        }

        // FINALIZE ENCRYPTION AND UPLOAD
        var encrypted = aesEncryptor.finalize();
        encrypted = encodeURIComponent(encrypted);
        var filename = document.getElementById('fileinput').value;
        var file_type = document.getElementById('fileinput').files[0].type;
        var url = 'data=' + encrypted + '&amp;filename=' + filename + '&amp;filetype=' + file_type;
        $.ajax({
            url: 'myphpscript.php',
            type: 'POST',
            data: url
        }).success(function(data){
            // Display encrypted data
            document.getElementById('status').innerHTML = 'Upload Complete.';
        });
        alert(encrypted);

    }
&lt;/script&gt;
</code></pre>
","<p>So your problem is the line <code>var encrypted = aesEncryptor.finalize();</code></p>

<p>This is not the encrypted file, but the final 'chunk' produced by the CryptoJS.AES finalizer.</p>

<p>you need to append that to the end of the <code>window.bits</code> buffer to yield the fully encrypted file.</p>

<p>Also, you shouldn't be using <code>window.bits.push</code>, you should keep hold of a reference to each chunk like this (psuedocode):</p>

<pre><code>var prog;
//then in the loop, if chunk is null assign to chunk or else concat:
loop:
    if(!prog)
        prog = cipher.process()
    else
        prog.concat(cipher.process())

//then finalize
prog.concat(cipher.finalize())

//now you're free to do whatever with the encrypted file:
var ciphertext = prog.toString()
</code></pre>
","1675","<filereader><cryptojs>","0","0","2","2015-01-14 23:13:13","26269308","4","","","","","2014-08-31 15:39:12",""
"25593574","Progressive Upload and Encryption with CryptoJS","<p>The goal here is to upload a file, encrypt it at the client side, and send the file and its attributes via AJAX to myphpscript.php.  To allow larger files, I want to upload in slices using the FileReader slice method and progressively encrypt the slices using the methods described on the CryptoJS site (<a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a>).  My code below runs, but only ends up storing a a small portion of the intended entire encrypted file.  Can I progressively upload and encrypt in the way I am describing?</p>

<pre><code>&lt;script type=""text/javascript"" src=""js/jquery-1.11.0.min.js""&gt;&lt;/script&gt;
&lt;script src=""js/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    function readBlob(opt_startByte, opt_stopByte) {

        var files = document.getElementById('fileinput').files;
        if (!files.length) {
            alert('Please select a file!');
            return;
        }

        var file = files[0];
        var start = parseInt(opt_startByte) || 0;
        var stop = parseInt(opt_stopByte) || file.size - 1;

        var reader = new FileReader();

        // If we use onloadend, we need to check the readyState.
        reader.onloadend = function(evt) {
            if (evt.target.readyState == FileReader.DONE) { // DONE == 2
                window.bits.push(aesEncryptor.process(evt.target.result));
            }
        };

        var blob = file.slice(start, stop + 1);
        reader.readAsBinaryString(blob);
    }

    function handling(evt) {

        // INITIALIZE PROGRESSIVE ENCRYPTION
        var key = CryptoJS.enc.Hex.parse(document.getElementById('pass').value);
        var iv = CryptoJS.lib.WordArray.random(128 / 8);
        window.bits = [];
        window.aesEncryptor = CryptoJS.algo.AES.createEncryptor(key, {iv: iv});

        // LOOP THROUGH BYTES AND PROGRESSIVELY ENCRYPT
        var startByte = 0;
        var endByte = 0;
        while(startByte &lt; document.querySelector('input[type=file]').files[0].size - 1){
            endByte = startByte + 1000000;
            readBlob(startByte, endByte);
            startByte = endByte;
        }

        // FINALIZE ENCRYPTION AND UPLOAD
        var encrypted = aesEncryptor.finalize();
        encrypted = encodeURIComponent(encrypted);
        var filename = document.getElementById('fileinput').value;
        var file_type = document.getElementById('fileinput').files[0].type;
        var url = 'data=' + encrypted + '&amp;filename=' + filename + '&amp;filetype=' + file_type;
        $.ajax({
            url: 'myphpscript.php',
            type: 'POST',
            data: url
        }).success(function(data){
            // Display encrypted data
            document.getElementById('status').innerHTML = 'Upload Complete.';
        });
        alert(encrypted);

    }
&lt;/script&gt;
</code></pre>
","<p>One important thing to keep in mind is that <em>the chunks may arrive to the encryptor out of order</em> so you either have to keep track of the order that chunks went into aesEncryptor.process so that you can decrypt in the proper order later <em>or</em> queue the chunks and encrypt them in the proper order to begin with.</p>
","1675","<filereader><cryptojs>","0","0","2","2015-01-14 23:13:13","26269308","4","","","","","2014-08-31 15:39:12",""
"14095259","How to decrypt AesCryptoServiceProvider using JavaScript?","<p>I am using <code>EncryptStringToBytes_Aes</code> method from <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.aescryptoserviceprovider%28v=vs.90%29.aspx"" rel=""nofollow"">MSDN</a> to encrypt some data using custom passphrase like this:</p>

<pre><code>string original = ""some data to encrypt"";
byte[] encrypted;

using (AesManaged aes = new AesManaged())
{
    // Prepare new Key and IV.
    string passphrase = ""somepassphrase"";
    byte[] saltArray = Encoding.ASCII.GetBytes(""somesalt""); 
    Rfc2898DeriveBytes rfcKey = new Rfc2898DeriveBytes(passphrase, saltArray);
    aes.Key = rfcKey.GetBytes(aes.KeySize / 8);
    aes.IV = rfcKey.GetBytes(aes.BlockSize / 8);

    // Encrypt the string to an array of bytes. 
    encrypted = EncryptStringToBytes_Aes(original, aes.Key, aes.IV);

    // Decrypt the bytes to a string. 
    string roundtrip = DecryptStringFromBytes_Aes(encrypted, aes.Key, aes.IV);

    return Convert.ToBase64String(encrypted);
}
</code></pre>

<p>and it works (<code>DecryptStringFromBytes_Aes</code> returns the original string). </p>

<p>My question is how do I decrypt <code>encrypted</code> using JavaScript if I have the same passphrase on the client-side as well? I tried using <a href=""http://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS</a> to decrypt it but had no success. The data gets encrypted in a webservice and I tried passing it to JS as a byte array, string, tried encoding it with various encodings but no matter what I did, I couldn't get the original string. What am I doing wrong here and how can I make this work? Is it even doable like this? Could the saltArray encoding or even the usage of the custom passphrase be the cause of my problems?</p>

<p>Here is for example one of my JS tries (using base64 encoding):</p>

<pre><code>var decoded = CryptoJS.enc.Base64.parse(encrypted);
var decrypted = CryptoJS.AES.decrypt(decoded, ""somepassphrase"");
</code></pre>

<p><em>(edit: I meant to implement random salt later, once I got everything else wokring since it is easier to track what is going on that way)</em></p>
","<p>try using Stanford Javascript Crypto Library.
Link:<a href=""http://crypto.stanford.edu/sjcl/"" rel=""nofollow"">http://crypto.stanford.edu/sjcl/</a></p>
","1673","<c#><javascript><.net><encryption><cryptojs>","2","0","1","2012-12-31 20:22:56","","8","","413785","","2012-12-31 20:22:56","2012-12-30 22:19:42",""
"17929107","CryptoJS (HMAC Sha256) giving incorrect output?","<p>Let me start by saying I'm no expert in cryptography algorithms...</p>

<p>I am trying to build a method which formats an HTTP header for Windows Azure - and this header requires part of its message to be encrypted via HMAC with SHA256 (and then also base64 encoded).</p>

<p>I chose to use <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS</a> because it's got an active user community.</p>

<p>First, my code:</p>

<pre><code>_encodeAuthHeader : function (url, params, date) {
    //http://msdn.microsoft.com/en-us/library/windowsazure/dd179428
    var canonicalizedResource = '/' + this.getAccountName() + url;

    /*
     StringToSign = Date + ""\n"" + CanonicalizedResource
     */
    var stringToSign = date + '\n' + canonicalizedResource;
    console.log('stringToSign &gt;&gt; ' + stringToSign)

    var encodedBits = CryptoJS.HmacSHA256(stringToSign, this.getAccessKey());
    console.log('encodedBits &gt;&gt; ' + encodedBits);

    var base64Bits = CryptoJS.enc.Base64.stringify(encodedBits);
    console.log('base64Bits &gt;&gt; ' + base64Bits);

    var signature = 'SharedKeyLite ' + this.getAccountName() + ':' + base64Bits;
    console.log('signature &gt;&gt; ' + signature);

    return signature;
},
</code></pre>

<p>The method successfully returns a ""signature"" with the appropriate piece encrypted/encoded. However, Azure complains that it's not formatted correctly.</p>

<p>Some example output:</p>

<pre><code>stringToSign &gt;&gt; Mon, 29 Jul 2013 16:04:20 GMT\n/senchaazurestorage/Tables

encodedBits &gt;&gt; 6723ace2ec7b0348e1270ccbaab802bfa5c1bbdddd108aece88c739051a8a767

base64Bits &gt;&gt; ZyOs4ux7A0jhJwzLqrgCv6XBu93dEIrs6IxzkFGop2c=

signature &gt;&gt; SharedKeyLite senchaazurestorage:ZyOs4ux7A0jhJwzLqrgCv6XBu93dEIrs6IxzkFGop2c=
</code></pre>

<p>Doing some debugging, I am noticing that CryptoJS is not returning the same value (HMAC with SHA256) as alternative implementations. For example, the string ""<em>Mon, 29 Jul 2013 16:04:20 GMT\n/senchaazurestorage/Tables</em>"" appears as:</p>

<ul>
<li>""<em>6723ace2ec7b0348e1270ccbaab802bfa5c1bbdddd108aece88c739051a8a767</em>"" via CryptoJS</li>
<li>""<em>faa89f45ef029c63d04b8522d07c54024ae711924822c402b2d387d05398fc9f</em>"" via PHP hash_hmac('sha256', ... )</li>
</ul>

<p>Digging even deeper, I'm seeing that most HMAC/SHA265 algorithms return data which matches the output from PHP... am I missing something in CryptoJS? Or is there a legitimate difference?</p>
","<p>As I mentioned in my first comment, the newline (""\n"") was causing problems. Escaping that (""\ \n"", without the space inbetween) seems to have fixed the inconsistency in HMAC/SHA256 output.</p>

<p>I'm still having problems with the Azure HTTP ""Authorization"" header, but that's another issue.</p>
","1669","<azure-storage><hmac><cryptojs>","3","1","1","2013-07-29 19:53:39","17932981","1","1","","","","2013-07-29 16:21:25",""
"23303410","Why doesn't Googles Javascript code for AES Encryption work in this code?","<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var toEncMes = ""This is a secret message."";
var secPas = ""myPassword"";
var encrypted = CryptoJS.AES.encrypt(toEncMes, secPas);

alert (encrypted);
var decrypted = CryptoJS.AES.decrypt(encrypted, secPas);
alert (decrypted);
&lt;/script&gt;
</code></pre>

<p>I probably just don't understand the concept but I have no idea.</p>

<p>The end result from my code is still just a jumbled mess when I display decrypted result.</p>

<p>I found this here:
<a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a></p>

<p>The original entry looks like this:</p>

<p>The Advanced Encryption Standard (AES) is a U.S. Federal Information Processing Standard (FIPS). It was selected after a 5-year process where 15 competing designs were evaluated.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;    &lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
&lt;/script&gt;
</code></pre>

<p>CryptoJS supports AES-128, AES-192, and AES-256. It will pick the variant by the size of the key you pass in. If you use a passphrase, then it will generate a 256-bit key.</p>
","<p>You are alerting the raw decrypted object - the default encoding for such is hex. It needs to be converted to a string using the appropriate human-readable encoding:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
var toEncMes = ""This is a secret message."";
var secPas = ""myPassword"";
var encrypted = CryptoJS.AES.encrypt(toEncMes, secPas);

alert (encrypted);
var decrypted = CryptoJS.AES.decrypt(encrypted, secPas);
alert (decrypted.toString(CryptoJS.enc.Utf8)); // &lt;---- note specified encoding
&lt;/script&gt;
</code></pre>

<p>Of course, the usual cryptographic warning signs still apply: this doesn't ensure your message has not been tampered with, etc.</p>
","1629","<javascript><encryption><aes><cryptojs>","1","2","1","2014-04-25 23:23:54","23304652","3","","1186778","","2014-04-25 23:08:05","2014-04-25 21:31:44",""
"30220554","Node CryptoJS vs Jsrsasign SHA256withRSA with encrypted pem","<p>So I am running into an issue using jsrsasign. I am not quite what I am doing wrong.
I am attempting to emulate a hash process we are uinsg in NodeJS using angular and it is not clear what the issue is.
Here is the process in we have in NodeJS that works perfect</p>

<pre><code>var restler = require('restler');
var path = require('path');
var fs = require('fs');
var crypto = require('crypto');
var dateFormat = require('dateformat');

var sha_hash = crypto.createHash('SHA1');
var pem = fs.readFileSync('private-key.pem');
var pkey = pem.toString('ascii');

var private_key = {
    key: pkey,
    passphrase:'password'
}

//var current_date = new Date();
//console.log(dateFormat(current_date, ""yyyy/mm/dd HH:MM:ss l""));
var current_date = '2015/05/06 20:07:12 926';

//SToken
sha_hash.update(current_date);
var stoken = sha_hash.digest('hex');
console.log(stoken);

//Signature
var signature = crypto.createSign('RSA-SHA256')
signature.update(stoken);
var sig = signature.sign(private_key, 'base64');
console.log(sig);
</code></pre>

<p>Both the SToken Values and the Signature Values produce the expected results
if we try something similar using angularjs, the Signature value is incorrect.</p>

<p>Here is the index.html:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body ng-app=""main""&gt;
&lt;div ng-view&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;script src=""bower_components/angular/angular.min.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/angular-route/angular-route.min.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/dateformat/dist/dateformat.min.js""&gt;&lt;/script&gt;

&lt;script src=""http://yui.yahooapis.com/2.9.0/build/yahoo/yahoo-min.js""&gt;    &lt;/script&gt;

&lt;script src=""bower_components/crypto-js/core.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/x64-core.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/crypto-js.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/hmac.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/sha1.js""&gt;&lt;/script&gt;
&lt;script src=""bower_components/crypto-js/sha256.js""&gt;&lt;/script&gt;

&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/ext/base64.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/ext/jsbn.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/ext/jsbn2.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/ext/rsa.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/ext/rsa2.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/crypto-1.1.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/rsasign-1.2.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/rsapem-1.1.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/asn1-1.0.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/asn1hex-1.1.js""&gt;&lt;/script&gt;
&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/keyutil-1.0.js""&gt;&lt;/script&gt;

&lt;script src=""modules/authentication/authentication.module.js""&gt;&lt;/script&gt;
&lt;script src=""modules/authentication/authentication.controller.js""&gt;&lt;/script&gt;
&lt;script src=""app.js"" &gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>

<p>And here is the authentication.controller.js file:</p>

<pre><code>(function (authenticationModule) {

    var authenticationController = function($scope, $http, $q, $filter) {

        var deferred = $q.defer()
        var private_key = $http({
            method: 'GET',
            url: 'private-key.pem'
        }).success(function(privateKey) {
            deferred.resolve();

            //var current_date = new Date();
            //var date_string = $filter('date')(current_date, ""yyyy/mm/dd HH:MM:ss SSS"");
            var date_string = '2015/05/06 20:07:12 926';

            //SToken
            var stoken = CryptoJS.SHA1(date_string).toString();
            console.log(stoken);
            $scope.stoken = stoken;

            //Signature
            var sig = new KJUR.crypto.Signature({""alg"": ""SHA256withRSA"", ""prov"": ""cryptojs/jsrsa""});

            sig.init(privateKey, 'password');
            sig.updateString(stoken);
            var signature = sig.sign();
            console.log(signature);
            $scope.signature = signature;
        }).error(function(error) {
            console.error(""there was an error reading file"");
            deferred.reject(error);
        });

    };

    authenticationModule.controller('authenticationController', ['$scope', '$http', '$q', '$filter', authenticationController]);


}(angular.module('authentication')));
</code></pre>

<p>And here is the authentication.module.js file</p>

<pre><code>(function (angular) {

    'use strict';
    //Initialize the Module
    angular.module('authentication',[]);

}(window.angular));
</code></pre>

<p>Here is the app.js file:</p>

<pre><code>(function(angular){

    //Defines my angular main portion of the application
    var module = angular.module('main',['ngRoute', 'authentication']);


    //Defines the routes
    module
        .config(function($routeProvider){
            $routeProvider
                .when('/auth',{     templateUrl:'modules/authentication/authentication.view.html',  controller:'authenticationController'})
                .otherwise({redirectTo:'/auth'});
        });

})(window.angular);
</code></pre>

<p>And finally here is the view:</p>

<pre><code>&lt;div&gt;
    SToken: {{stoken}}
&lt;/div&gt;
&lt;div&gt;
    Signature: {{signature}}
&lt;/div&gt;
</code></pre>

<p>Again, just to repeat, the SToken value appears correct but when I show the signature, it is incorrect. I am not quite sure how to deal with this but any assistance would be appreciated. </p>
","<p>After some research, I realize that I forgot to base64 encode the answer from angularjs</p>

<p>So I changed the controller.js code from this</p>

<pre><code>var signature = sig.sign();
</code></pre>

<p>To this:</p>

<pre><code>var signature = hextob64(sig.sign());
</code></pre>

<p>I also has to update the index.html file to include this library</p>

<pre><code>&lt;script language=""JavaScript"" type=""text/javascript"" src=""bower_components/jsrsasign/base64x-1.1.js""&gt;&lt;/script&gt;
</code></pre>

<p>Everything matched once I added these changes.</p>
","1598","<javascript><angularjs><node.js><rsa><cryptojs>","0","0","1","2015-05-13 16:55:52","30220982","0","","","","","2015-05-13 16:32:43",""
"47201575","CryptoJS decrypt object","<p>I need to decrypt something encrypted with CryptoJS. I have the function used to encrypt, the structure of the object encrypted and data used to encrypt to encrypt but i need to know some values of that object.</p>

<p>The function is:</p>

<pre><code>var c = CryptoJS.enc.Utf8.parse(g.slice(0, 16));
var d = CryptoJS.AES.encrypt(JSON.stringify(collectData), c, {
    iv: c,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
}).toString()
</code></pre>

<p>Later, to the encrypted variable the following is applied: </p>

<pre><code>d.toString().replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '*');
</code></pre>

<p>I tried with this but i cant revert the object:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(coord, key, {
iv: key,
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7
</code></pre>

<p>}
);</p>

<pre><code>console.log('decrypted clean:\n' + decrypted);
console.log('decrypted JSON.stringify():\n'+ JSON.stringify(decrypted));
</code></pre>

<p>thanks!</p>
","<p>Hey your question actually help me to find a solution, encrypt takes in a object, and decrypt takes in a string, so you can do your replace</p>

<p>The other place that could be giving this type of errpr is the key, when parsing the key to Utf8 ensure that the key is exactly 16 characters you can add nulls add the end of the string to ensure it is long enough by appending '/u0000' to your string before parsing</p>

<pre><code>encrypt(data) {
return CryptoJS.AES.encrypt(JSON.stringify(data), this.secret,
 {
    keySize: 128 / 8,
    iv: this.secret,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  }).toString();
}

decrypt(data) {
return JSON.parse(CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(data,  this.secret, 
{
    keySize: 128 / 8,
    iv: this.secret,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
  })));
}
</code></pre>
","1559","<javascript><cryptojs>","1","2","2","2019-05-09 06:21:54","","1","","","","","2017-11-09 12:13:16",""
"47201575","CryptoJS decrypt object","<p>I need to decrypt something encrypted with CryptoJS. I have the function used to encrypt, the structure of the object encrypted and data used to encrypt to encrypt but i need to know some values of that object.</p>

<p>The function is:</p>

<pre><code>var c = CryptoJS.enc.Utf8.parse(g.slice(0, 16));
var d = CryptoJS.AES.encrypt(JSON.stringify(collectData), c, {
    iv: c,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
}).toString()
</code></pre>

<p>Later, to the encrypted variable the following is applied: </p>

<pre><code>d.toString().replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '*');
</code></pre>

<p>I tried with this but i cant revert the object:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(coord, key, {
iv: key,
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7
</code></pre>

<p>}
);</p>

<pre><code>console.log('decrypted clean:\n' + decrypted);
console.log('decrypted JSON.stringify():\n'+ JSON.stringify(decrypted));
</code></pre>

<p>thanks!</p>
","<p><strong>Encryption and decryption of JSON object</strong></p>

<p><strong>Node JS</strong></p>

<pre><code>var CryptoJS = require('node-cryptojs-aes').CryptoJS;

var data = {
  ""glossary"": {
  ""title"": ""example glossary"",
  }
}

var cip = CryptoJS.AES.encrypt(JSON.stringify(data), ""pass"").toString();
console.log(""Encrypted data = "" + cip);
</code></pre>

<p>At browser side- 
<strong>HTML</strong>
<strong>CDN -</strong> ""<a href=""https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js"" rel=""nofollow noreferrer"">https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js</a>""</p>

<pre><code>var decrypted =     CryptoJS.AES.decrypt('U2FsdGVkX1/ps2tRPpM+5elyGhaT7zpp3YL45esS57GmSLoCkhcRdJDBGPUy    uvt0tf4CY6lW2+kugXocBQkc6A==', ""pass"");
    data = CryptoJS.enc.Utf8.stringify(decrypted)
    console.log(""decrypted"", JSON.parse(data))
</code></pre>
","1559","<javascript><cryptojs>","1","0","2","2019-05-09 06:21:54","","1","","","","","2017-11-09 12:13:16",""
"15948699","CryptoJS.AES.decrypt failure reasons?","<p>The <code>CryptoJS.AES.decrypt</code> function is returning an empty WordArray.</p>

<p>My parameters are <code>secret</code>, <code>key</code>, and <code>iv</code>.  key is a 256 bit WordArray and is confirmed to be correct, iv is a 128 bit WordArray and also confirmed to be correct.</p>

<p>secret is encrypted using php's <code>openssl_encrypt()</code> - the plaintext is 32 bytes - the result is 48 bytes (so it seems to be padding correctly).</p>

<p>I've tried secret as a WordArray, Hex string and base64 string but when I call:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(secret, key, {iv: iv});
</code></pre>

<p>decrypted is an empty WordArray.  It's driving me mad... What is failing?  I would think the error is in secret somewhere, with padding formats or something weird, but <code>Cryptojs</code> and o<code>penssl_(encrypt/decrypt)</code> have proved to be compatible with each other for me before.  Please help before I lose my mind.</p>
","<p>OK, so the key to this was that the docs for <code>CryptoJS.AES.decrypt(message, key, {iv:iv})</code> say that you can feed a WordArray, Hex, or Base64 for the <code>message</code> argument.  This doesn't seem to be true.</p>

<p>The only way I can get it to work was by giving it a Base64 string to work with.</p>

<p>key and iv must still be <code>WordArray</code></p>

<p>*When I tried Base64 strings in my hours of monkeying, I must not have changed the output on the server to actually send Base64 - so there you go.</p>

<p>Thanks to @CodesInChaos for bringing up endianess, though.  It started me messing with the encodings again.</p>

<p>...Now to clean up all those <code>console.log()</code>'s and <code>var_dump()</code>'s strewn about the code...</p>
","1543","<javascript><encryption><cryptojs>","2","3","1","2013-04-11 14:54:42","15952068","1","","1596545","","2013-04-11 12:43:50","2013-04-11 12:23:34",""
"25917032","CryptoJS.SHA3 in code behind in c#?","<p>Now I am using below code in aspx page. But Now I need something in code behind in C#. Is there any library available? </p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha3.js""/&gt;
&lt;script&gt;
    var hash = CryptoJS.SHA3(""Message"", { outputLength: 512 });
&lt;/script&gt;
</code></pre>
","<p>There are libraries that implement SHA3 in C#. Some are:</p>

<ul>
<li><a href=""https://hashlib.codeplex.com/"" rel=""nofollow"">Hashlib</a></li>
<li><a href=""https://github.com/drewjcooper/SHA3Net"" rel=""nofollow"">SHA3Net</a></li>
<li><a href=""https://www.nuget.org/packages/SHA3/"" rel=""nofollow"">SHA3 0.9.2</a></li>
</ul>

<p>Checkout their docs for code examples.</p>
","1534","<c#><javascript><asp.net><sha><cryptojs>","1","3","1","2014-09-18 16:01:35","25917306","0","","158008","","2014-09-18 15:43:52","2014-09-18 15:41:56",""
"43524898","using NPM to install cryptoJS","<p>I'm trying to install cryptoJS  at my visual studio 2015.
my npm version is: 4.5.0
my node version is: v6.10.2
I've done:
1. install via nuGet Node.js
2. install via nuGet npm</p>

<p>3.
    npm init --force
which gave the output:</p>

<pre><code>npm : npm WARN using --force I sure hope you know what you are doing.
At line:1 char:1
+ npm init --force
+ ~~~~~~~~~~~~~~~~
+ CategoryInfo          : NotSpecified: (npm WARN using ... you are doing.:String) [], RemoteException
+ FullyQualifiedErrorId : NativeCommandError

Wrote to \myProjectPath\package.json:

{
""name"": ""myProjectName"",
""version"": ""1.0.0"",
""description"": """",
""main"": ""index.js"",
""dependencies"": {
""crypto-js"": ""^3.1.9-1"",
""crypto"": ""^0.0.3"",
""node.js"": ""^0.0.0""
},
""devDependencies"": {},
""scripts"": {
""test"": ""echo \""Error: no test specified\"" &amp;&amp; exit 1""
},
""keywords"": [],
""author"": """",
""license"": ""ISC""
</code></pre>

<p>}</p>

<p>I don't think that output is valid.
When I try to install cryptoJS :</p>

<pre><code>npm install crypto-js
</code></pre>

<p>the output is:</p>

<pre><code>npm : npm WARN MyProjectName@1.0.0 No description
At line:1 char:1
+ npm install crypto-js
+ ~~~~~~~~~~~~~~~~~~~~~
+ CategoryInfo          : NotSpecified: (npm WARN MyProjectName@1.0.0 No description:String) [], RemoteException
+ FullyQualifiedErrorId : NativeCommandError

npm
WARN
MyProjectName@1.0.0 No repository field.
</code></pre>

<p>how can i fix it? thanks</p>
","<p>You should probably test if it is working or not. Please create a new file called <em>crypto.js</em> with the following code:</p>

<pre><code>var sha256 = require(""crypto-js/sha256"");
console.log(sha256(""Hello""));
</code></pre>

<p>Then, run it with <strong>Node</strong>: <code>node crypto.js</code></p>
","1531","<node.js><windows><visual-studio><npm><cryptojs>","0","0","1","2017-04-20 17:28:39","","0","","7789796","","2017-04-20 17:28:39","2017-04-20 16:21:29",""
"38794248","Ionic - Store encrypted values in Local Storage","<p><strong>Use case</strong>: When online, user launches the Ionic app that prompts for username/password. Credentials are checked against the server and user is allowed to log in. Also, the encrypted password is stored locally (ipad).
When offline, instead of checking against the server, validate the credentials against the encrypted password stored locally.</p>

<p><strong>What's working</strong>
Able to use crypto-js library in Ionic to encrypt the password.</p>

<pre><code>var encryptedMessage = CryptoJS.AES.encrypt(password, secretkey);
</code></pre>

<p><strong>What's not working</strong>
Now, I am trying the use the angular-local-storage library to save it in local storage.</p>

<pre><code>localStorageService.set('pwdkey', encryptedMessage );
</code></pre>

<p>It gives me the below error</p>

<pre><code>TypeError: Converting circular structure to JSON
    at Object.stringify (native)
    at toJson (http://localhost:8100/lib/ionic/js/ionic.bundle.js:14637:15)
    at Object.addToLocalStorage (http://localhost:8100/lib/angular-local-storage/dist/angular-local-storage.js:158:19)
    at encryptAndStore (http://localhost:8100/js/controllers.js:550:27)
</code></pre>

<p>The same code works fine if I pass an unecrypted string instead of the encrypted password. So, it has something to do with the encrypted data.</p>

<p>How can I store encrypted data in local storage? </p>
","<p>The problem was solved by using the .toString() method</p>

<pre><code>CryptoJS.AES.encrypt(password, secretkey).toString()
</code></pre>

<p>This way I was able to save the String and then get it back and decrypt it. </p>
","1529","<encryption><ionic-framework><cryptojs><angular-local-storage>","2","2","1","2016-08-09 15:58:31","38855480","0","1","4786655","","2016-08-05 17:00:11","2016-08-05 16:52:07",""
"19826009","Decryption a Picture using CryptoJS and Inserting it into a Page","<p>For a slew of complicated reasons. we need to send images over the network in encrypted state and decrypt them on the other side using AES. On the server side here is what happens:</p>

<pre><code>openssl aes-256-cbc -in pup.jpg -out pup.jpg.enc
base64 pup.jpg.enc &gt; pup.jpg.enc.b64
</code></pre>

<p>On the client side here is the JavaScript we are using:</p>

<pre><code>&lt;img id=""picture""/&gt;
&lt;script&gt;
    var picture = document.getElementById(""picture"");
    var data = new XMLHttpRequest();
    data.open('GET', 'http://server.com/pup.jpg.enc.b64', true);
    data.onreadystatechange = function(){
        if(this.readyState == 4 &amp;&amp; this.status==200){
            var dec = CryptoJS.AES.decrypt(data.responseText, ""password"");
            var plain = CryptoJS.enc.Base64.stringify( dec );
        picture.src = ""data:image/jpeg;base64,""+plain;
        }
    };
    data.send(null);
&lt;/script&gt;
</code></pre>

<p>I am getting a deviation in the input and output, and I can not figure out why, for the life of me. Here is the input and output:</p>

<pre><code>In:  /9j/4RLKRXhpZgAATU0AKgAAAAgADAEAAAMAAAABBADJx...
Out: /9j/4RLKRXhpZgAATU0AKgAAAAgADAEAAAMAAAABBAAAA...
                                               ^-- deviation
</code></pre>

<p>Do I have to specify to the CryptoJS that I am using 256bit encryption?</p>
","<p>From the CryptoJS documentation, it mentions the output of AES.decrypt is the same type as the output of a hash function. In <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">the Hasher Output section</a> there is an example of converting this WordArray to a base 64 encoded string:</p>

<pre><code>    alert(hash.toString(CryptoJS.enc.Base64)); // L3dmip37+NWEi57rSnFFypTG7ZI25Kdz9tyvpRMrL5E=
</code></pre>
","1526","<javascript><cryptojs>","1","0","2","2013-11-07 07:51:38","19830531","0","1","2767589","","2013-11-07 06:27:59","2013-11-07 00:58:50",""
"19826009","Decryption a Picture using CryptoJS and Inserting it into a Page","<p>For a slew of complicated reasons. we need to send images over the network in encrypted state and decrypt them on the other side using AES. On the server side here is what happens:</p>

<pre><code>openssl aes-256-cbc -in pup.jpg -out pup.jpg.enc
base64 pup.jpg.enc &gt; pup.jpg.enc.b64
</code></pre>

<p>On the client side here is the JavaScript we are using:</p>

<pre><code>&lt;img id=""picture""/&gt;
&lt;script&gt;
    var picture = document.getElementById(""picture"");
    var data = new XMLHttpRequest();
    data.open('GET', 'http://server.com/pup.jpg.enc.b64', true);
    data.onreadystatechange = function(){
        if(this.readyState == 4 &amp;&amp; this.status==200){
            var dec = CryptoJS.AES.decrypt(data.responseText, ""password"");
            var plain = CryptoJS.enc.Base64.stringify( dec );
        picture.src = ""data:image/jpeg;base64,""+plain;
        }
    };
    data.send(null);
&lt;/script&gt;
</code></pre>

<p>I am getting a deviation in the input and output, and I can not figure out why, for the life of me. Here is the input and output:</p>

<pre><code>In:  /9j/4RLKRXhpZgAATU0AKgAAAAgADAEAAAMAAAABBADJx...
Out: /9j/4RLKRXhpZgAATU0AKgAAAAgADAEAAAMAAAABBAAAA...
                                               ^-- deviation
</code></pre>

<p>Do I have to specify to the CryptoJS that I am using 256bit encryption?</p>
","<p>The problem appears to be with a bug in CryptoJS that causes the library to not work if input string contains new lines. Encoding the file like this:</p>

<pre><code>openssl enc -aes-256-cbc -in pup.jpg -pass pass:""password"" | base64 | tr -d '\n' &gt; pup.enc
</code></pre>

<p>fixes the issue. The problem want with the javascript, but with the encoding. Well, and with javascript, because there is a bug in cryptojs: <a href=""https://code.google.com/p/crypto-js/issues/detail?id=38"" rel=""nofollow"">https://code.google.com/p/crypto-js/issues/detail?id=38</a></p>
","1526","<javascript><cryptojs>","1","1","2","2013-11-07 07:51:38","19830531","0","1","2767589","","2013-11-07 06:27:59","2013-11-07 00:58:50",""
"28148869","CryptoJS.SHA1 vs MessageDigest.getInstance(""SHA-1"").digest()","<p>i am trying to apply the SHA1 encryption in my javascript code, the same way that java work,
the result as following :
java :</p>

<pre><code>String str = ""123456"";
MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
byte[] hash = sha.digest(str.getBytes());
for(int i =0 ; i&lt;hash.length;i++){
   System.out.print((new Byte(hash[i]))+"" "");
}
</code></pre>

<p>the output for the java :</p>

<pre><code>124 74 -115 9 -54 55 98 -81 97 -27 -107 32 -108 61 -62 100 -108 -8 -108 27
</code></pre>

<p>javascript :</p>

<pre><code>var key = ""123456"";
console.warn(CryptoJS.SHA1(key.getBytes().toString()).toString().getBytes());
</code></pre>

<p>the outpur for javascript :</p>

<pre><code>[54, 49, 52, 49, 51, 100, 55, 99, 53, 49, 50, 102, 100, 99, 98, 48, 98, 53, 53, 55, 57, 98, 55, 53, 56, 55, 50, 54, 53, 102, 55, 53, 99, 99, 98, 51, 53, 50, 52, 52]
</code></pre>

<p>How can I make the JavaScript work exactly how Java does it? So it also must produce an array.</p>

<pre><code>String.prototype.getBytes = function () {
    var bytes = [];
    for (var i = 0; i &lt; this.length; i++){
        bytes.push(this.charCodeAt(i));
    }
    return bytes;
};
</code></pre>
","<p>I don't know what <code>key.getBytes()</code> is supposed to be. You should simply pass the string to the SHA1 function and get a representation of your choice out of it. This produces a matching hex representation of the byte array from your Java code.</p>

<pre><code>&gt; var key = ""123456"";
&gt; CryptoJS.SHA1(key).toString()
""7c4a8d09ca3762af61e59520943dc26494f8941b""
</code></pre>

<p>If you want to create exactly the same array, you can iterate over the <code>words</code> property of the native representation of CryptoJS. Each integer represents 4 bytes in Big-Endian notation.</p>

<pre><code>var key = ""123456"";
var hash = CryptoJS.SHA1(key);
var byteArray = [];
hash.words.forEach(function(i){ 
  var k;
  for(var j = 3; j &gt;= 0; j--){
    k = (i &gt;&gt; (j*8)) &amp; 0xFF;
    k = k &lt; 128 ? k : -(256 - k);
    byteArray.push(k);
  }
});
</code></pre>
","1520","<java><javascript><cryptojs>","0","1","1","2015-01-26 11:49:50","28149007","0","2","1816580","","2015-01-26 11:27:51","2015-01-26 11:01:28",""
"50839750","how to encrypt and decrypt data stored in sessionStorage or localStorage in angular","<p>I am using SessionStorageService of ngx-webstorage to store data in sessionStorage.
But it is visible to user under <strong>Application > Session storage</strong>. Data stored should be encrypted and decrypted.
Any suggestion for same</p>

<p>options may be </p>

<p>secure-web-storage which use cryptoJS, but facing issue while storing object in session. </p>
","","1520","<angular><encryption><local-storage><cryptojs><session-storage>","1","","0","2018-07-18 07:59:29","","2","","4899569","","2018-07-18 07:59:29","2018-06-13 14:28:05",""
"39017458","how to store CryptoJS encrypted password in database","<p>i am quite new to CRYPTO JS encrypted stuff and i am trying to store encryted hash in database(I am trying to store in firebase database).</p>

<pre><code>    var hash = CryptoJS.AES.encrypt('my message', 'secret key 123');
</code></pre>

<p>I am trying to store hash variable in database.
But when i am trying to store, it shows me error that it is function, not possible to store.</p>

<p>PS- i am trying to store encryted hash in databse and want to call encrpted hash  on another page of my application from database and decrypt there.</p>

<p>Is that possible? if yes, then please tell me how.
Thanks</p>
","<p>Your <code>hash</code> is an object, you need to call <code>hash.toString()</code> to convert it into a string.</p>

<p>From the CryptoJS github page:</p>

<pre><code>var hash = CryptoJS.SHA3(""Message"");

//The hash you get back isn't a string yet. It's a WordArray object.
//When you use a WordArray object in a string context,
//it's automatically converted to a hex string. 
alert(hash.toString()); //Same as hash.toString(CryptoJS.enc.Hex);
</code></pre>
","1507","<javascript><encryption><hash><firebase><cryptojs>","1","5","1","2016-08-18 12:02:50","39017741","5","","","","","2016-08-18 11:49:16",""
"24429910","Encrypting with CryptoJS, decrypt with Ruby / AES","<p>This problem almost has me to my knees!</p>

<p>I'm trying do encrypt data that's going to be sent to a RoR-application via AJAX.</p>

<p>I've managed to encrypt a string in Ruby and decrypt it in JavaScript, but now I can't manage to do the reverse.</p>

<p>Here's my JS:</p>

<pre><code>function decrypt(data, key) {
    var index = data.indexOf('!$');
    var iv = data.substr(0, index);
    var crypttext = data.substr(index + 2);

    encrypted = {}
    encrypted.ciphertext = CryptoJS.enc.Base64.parse(crypttext);

    var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: CryptoJS.enc.Base64.parse(iv) });

    return decrypted.toString(CryptoJS.enc.Utf8);
}

function encrypt( data, key ) {
    enc = CryptoJS.AES.encrypt( data, key );

    enc_str = CryptoJS.enc.Base64.stringify(enc.iv) + ""!$"" + CryptoJS.enc.Base64.stringify(enc.ciphertext);

    return enc_str;
}
// ...
var key = 'ABCDEF123ABCDEF123ABCDEF123ABCDEF123ABCDEF123';//CryptoJS.SHA256( 'ABCDEF123' ).toString();
var key2 = 'ABCDEF123ABCDEF123ABCDEF123ABCDEF123ABCDEF123_42'; //CryptoJS.SHA256( 'ABCDEF123_42' ).toString();
code = ""123 456""
    uuid = ""0000000000000000000000000000""

var enc_code    = encrypt( code, key );
var enc_uuid    = encrypt( uuid, key2 );
</code></pre>

<p>I divided the iv and ciphertext because I had some problems with the Decryption in JS.</p>

<p>Here's the ruby code</p>

<pre><code>def decrypt(string, key)
  salt = nil
  if string.include? '$$:'
    sp = string.split '$$:'
    string = sp[0]
    salt   = sp[1].to_i(16).to_s
  end

  parts = string.split '!$'

  @initialization_vector = Base64.decode64(parts[0])

  aes_decrypt(key, Base64.decode64(parts[1]), salt)
end

def aes(key,string)
  cipher = OpenSSL::Cipher::Cipher.new(""aes-256-cbc"")
  cipher.encrypt
  cipher.key = key #Digest::SHA256.digest(key)
  cipher.iv = @initialization_vector = cipher.random_iv# + '#'
  cipher_text = cipher.update(string)
  cipher_text &lt;&lt; cipher.final
  return  cipher_text
end

def aes_decrypt(key, encrypted, salt = nil)
  p encrypted
  cipher = OpenSSL::Cipher::Cipher.new(""aes-256-cbc"")
  cipher.decrypt
  cipher.padding = 0 # I Spent a couple of hours with an exception from Cipher, all I had to do was add this line!!
  cipher.key = key #Digest::SHA256.digest(key)
  cipher.iv = encrypted.slice!(0, 16)
  unless salt.nil?
 #   cipher.pkcs5_keyivgen key, salt
  end
  d = cipher.update(encrypted)
  d &lt;&lt; cipher.final
end
</code></pre>

<p>As you can see I tried to figure out a way to include the salt, but with no luck (Cipher wont accept the salt and asking for an octet)!</p>

<p>The decryption in Ruby just spits out gibbrish.
(The methods work, I've decrypted the string sent to the clientside (which decrypts w/o problems in JS) direct in Ruby, and that works fine!</p>

<p>Here's the weird thing, I tried to decrypt the string in JS right away, but that doesn't work either!
Here's the results:</p>

<pre><code>CryptoJS.AES.decrypt( enc, key, { iv: enc.iv, salt: enc.salt } ).toString() // In encrypt()
// =&gt; 31323320343536
// =&gt; 30303030303030303030303030303030303030303030303030303030

decrypt( enc_code, key ).toString(); // After encrypt
// =&gt; [EMPTY]
</code></pre>

<p>My Google-fu is failing me, I've tried most things I've found!</p>

<p>Any ideas??</p>
","<p>The libraries you are using are using the higher layers of OpenSSL. The higher layers support password based encryption. By default, your CryptoJS code seems to use the proprietary Password Based Key Derivation Function from OpenSSL. However, the Ruby code does less by default; it will simply use the key you've put in as a key, you need to do the key derivation yourself.</p>

<p>So if you want to use just a key (which should be random binary data, not text), you should use a <a href=""https://code.google.com/p/crypto-js/#Custom_Key_and_IV"" rel=""nofollow"">custom key and IV</a> in CryptoJS. On the other hand, if you want to use a password (and therefore salt value), you should be using <a href=""http://ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html#method-i-pkcs5_keyivgen"" rel=""nofollow"">method-i-pkcs5_keyivgen</a>. In that case you may also need to parse the OpenSSL encrypted BLOB.</p>
","1498","<javascript><ruby-on-rails><ruby><encryption><cryptojs>","2","0","1","2014-06-27 09:20:19","","2","","","","","2014-06-26 11:57:20",""
"44469651","How to decrypt a file in javascript which is encrypted by JAVA with AES","<p>I have encrypted JPG file in Java with AES256, but have no idea to decrypt the JPG file in javascript. Anyone has better idea? I'm struggling with it for 4days.</p>

<pre class=""lang-java prettyprint-override""><code> byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 String key = ""1234567890123456789012345678901d"";

 AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
 SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
 Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
 cipher.init(mode, newKey, ivSpec);

 InputStream input = null;
 OutputStream output = null;

 try {
     input = new BufferedInputStream(new FileInputStream(new File(""/home/java/test/aaa.JPG"")));
     output = new BufferedOutputStream(new FileOutputStream(new File(""/home/java/test/bbb.JPG"")));
     byte[] buffer = new byte[1024];
     int read = -1;

     while((read = input.read(buffer)) != -1){
         output.write(cipher.update(buffer, 0, read));
     }

      output.write(cipher.doFinal());
 }
 finally {
     if(output != null){
         try {
             output.close();
         } catch(IOException ie){
             logger.info(ie.getMessage());
         }
     }
     if(input != null){
         try {
             input.close();
         } catch(IOException ie){
             logger.info(ie.getMessage());
         }
     }
 }
</code></pre>

<p>Here is the code I have tried so far. I have used CryptoJS and Decrypt does not return anything.</p>

<pre class=""lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
    &lt;html&gt;
    &lt;head&gt;

    &lt;script type=""text/javascript"" src=""./CryptoJS v3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;script type=""text/javascript"" src=""jquery-3.2.1.min.js""&gt;&lt;/script&gt;
    &lt;meta charset=utf-8 /&gt;
    &lt;title&gt;JS Bin&lt;/title&gt;

    &lt;style&gt;
      article, aside, figure, footer, header, hgroup, 
      menu, nav, section { display: block; }
    &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;input type='file' onchange=""readURL(this);"" /&gt;
        &lt;img id=""blah"" src=""#"" alt=""your image"" /&gt;
        &lt;a class=""download"" href=""""&gt;Download&lt;/a&gt;

        &lt;script&gt;
        var a = $('.download');
        var key =  CryptoJS.enc.Hex.parse(""1234567890123456789012345678901d"");
        var iv =  CryptoJS.enc.Hex.parse(""00000000000000000000000000000000"");

        function readURL(input) {
            if (input.files &amp;&amp; input.files[0]) {
                var reader = new FileReader();

                reader.onload = function (e) {


                    /////////
                    var decrypted = CryptoJS.AES.decrypt(e.target.result, key,
                    {
                            iv: iv,
                            mode: CryptoJS.mode.CBC,
                            padding: CryptoJS.pad.Pkcs7
                        }
                        ).toString(CryptoJS.enc.Latin1);


                    if(!/^data:/.test(decrypted)){
                        alert(""Invalid pass phrase or file! Please try again."");
                        return false;
                    }

                    a.attr('href', decrypted);
                    a.attr('download', input.files[0].name.replace('.enc',''));             


            };

                //reader.readAsDataURL(input.files[0]);
                reader.readAsText(input.files[0]);
            }
        }


        &lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
","<p>Your key is wrong, Java (incorrectly) uses the ASCII representation of the key:</p>

<pre><code>String key = ""1234567890123456789012345678901d"";
...
SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
</code></pre>

<p>which results in a 32 byte key for AES-256. But your JavaScript uses the Hex decoding of the key:</p>

<pre><code>var key =  CryptoJS.enc.Hex.parse(""1234567890123456789012345678901d"");
</code></pre>

<p>which results in a 16 byte key for AES-128.</p>

<p>With wrong keys you will obviously not get the right results.</p>

<p>So you'd either have to encode your key as you did your IV in Java or use a hex decoder (not present in Java by default) or you should ""fix"" your JavaScript to do the same as in Java and use the ASCII encoding of the key string.</p>

<p>Keys, in general, should not be strings.</p>
","1498","<javascript><java><encryption><aes><cryptojs>","0","3","1","2017-06-10 08:25:49","44471180","1","3","1816580","","2017-06-10 08:25:49","2017-06-10 04:50:28",""
"34941233","Why HMAC sha256 return different value on PHP & Javascript","<p>I am trying to build a HMAC SHA256 string in Javascript using CryptoJS, my existing code is written in PHP using the Akamai library.</p>

<p>In some cases I am getting different results compared to PHP &amp; I am unable to understand why it is giving me different results</p>

<pre><code>    /* 
       &lt;php&gt; Using native hash_hmac
       Generating key by concatenating char 
    */ 

      $signature1 = hash_hmac('SHA256', ""st=1453362060~exp=1453363260~acl=/*"", chr(63));
      $signature2 = hash_hmac('SHA256', ""st=1453362060~exp=1453363260~acl=/*"", chr(63) . chr(23));
      $signature3 = hash_hmac('SHA256', ""st=1453362060~exp=1453363260~acl=/*"", chr(63) . chr(23) . chr(253));

    /*
       here is result from php
       signature1 : 3e086bb48ab9aafa85661f9ce1b7dac49befddf117ce2a42d93c92b6abe513ce ( matched: same as JavaScript)
       signature2 : 3667dd414a50f68f7ce083e540f27f68f7d0f18617b1fb1e4788bffeaeab59f6( matched: same as JavaScript)
       signature3 : dd5a20041661046fdee871c8b9e77b3190fbbf85937c098090a1d524719b6aa9 ( not matched: diff from JavaScript)
    */


    /* 
       &lt;JavaScript&gt; using CryptoJS
       Generating key by concatenating three char 
    */ 

    var signature1 = CryptoJS.HmacSHA256(""st=1453362060~exp=1453363260~acl=/*"", String.fromCharCode(63));
    var signature2 = CryptoJS.HmacSHA256(""st=1453362060~exp=1453363260~acl=/*"", String.fromCharCode(63) + String.fromCharCode(23));
    var signature3 = CryptoJS.HmacSHA256(""st=1453362060~exp=1453363260~acl=/*"", String.fromCharCode(63) + String.fromCharCode(23) + String.fromCharCode(253));

    /* 
       here is result from JavaScript
       signature1 : 3e086bb48ab9aafa85661f9ce1b7dac49befddf117ce2a42d93c92b6abe513ce ( matched: same as php)
       signature2 : 3667dd414a50f68f7ce083e540f27f68f7d0f18617b1fb1e4788bffeaeab59f6 ( matched: same as php)
       signature3 : 28075dc75de9f22f83e87772f09a89efb007f2e298167686832eff122ef6eb08 ( not matched: diff from php)
    */
</code></pre>

<p>First two HMAC values are matching but when I append the third char it produces different results, Can anyone please explain why this is. </p>

<p>here is<br>
<a href=""http://codepad.org/qtKsIJtT"" rel=""nofollow"">PHPFiddle</a> &amp; 
<a href=""http://jsfiddle.net/_anil/5c4yyeao/2/"" rel=""nofollow"">JSFiddle</a></p>
","<p>CryptoJS add UTF8 encoding in ""Key"" while creating hash sha256 so that we are getting different value.</p>

<p>If i wrap utf8_encode in PHP side then we will get same hmac value as compare to JavaScript </p>

<pre><code>     // &lt;php&gt;
     $key = chr(63) . chr(23) . chr(253);
     signature3 = hash_hmac('SHA256', ""st=1453362060~exp=1453363260~acl=/*"", utf8_encode($key));
</code></pre>
","1492","<javascript><php><sha256><hmac><cryptojs>","3","2","1","2016-08-17 15:59:22","34945401","0","4","5348307","","2016-08-17 15:59:22","2016-01-22 07:28:40",""
"35156822","Is Javascript's JSON.stringfy the same as PHP's json_encode?","<p>I'm trying to do an HMAC SHA256 hash of stringified data using both JavaScript (CryptoJS Libraries) and PHP (built in HMAC function). I'm concerned that the JavaScript JSON.stringify will not be consistent/identical to the PHP json_encode() function. Is there a better approach to this stringifying of the data (object/array)?</p>

<p>Here's my test, which works. But, I'm concerned about Spanish characters and other encodings/entities that the code may encounter.</p>

<pre><code>&lt;h1&gt;Testing HMAC Javascript to PHP Comparison&lt;/h1&gt;

&lt;br&gt;&lt;br&gt;

&lt;div id=""php_mac""&gt;
&lt;?php
// Testing HMAC
$security_key = '0123456789';
$obj = array(
    'field1' =&gt; 1,
    'field2' =&gt; '2',
    'field3' =&gt; ""'"",
);

// Calculate HMAC SHA256
$str_data = json_encode($obj);
echo ""PHP str_data: "".$str_data.""&lt;br&gt;"";
$hash = hash_hmac('sha256', $str_data, $security_key, true);
$hashInBase64 = base64_encode($hash);
echo ""PHP hashInBase64: "".$hashInBase64;
?&gt;
&lt;/div&gt;

&lt;br&gt;&lt;br&gt;

&lt;div id=""javascipt_hmac""&gt;

    &lt;div id=""javascript_str_data""&gt;&lt;/div&gt;
    &lt;div id=""javascript_hashInBase64""&gt;&lt;/div&gt;

&lt;script&gt;

var security_key = '0123456789';
var obj = {
    'field1': 1,
    'field2': '2',
    'field3': ""'"",
};

// Create security hash based on posted data
var str_data = JSON.stringify(obj);
$('#javascript_str_data').html('str_data: '+str_data);
// Using CryptoJS to HMAC SHA256 the str_data
var hash = CryptoJS.HmacSHA256(str_data, security_key);
var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
$('#javascript_hashInBase64').html('JS hashInBase64: '+hashInBase64)

&lt;/script&gt;

&lt;/div&gt;
</code></pre>

<p>Additional thoughts: I'm worried about spacing/quoting differences with JSON methods. Perhaps I should loop thru the object/array and use the ""values"" only to produce the string of data to be HMAC'ed? Assuming this can be kept to a single array/object, that should produce a consistent ""values"" string. But, then how do you keep a consistent ordering. I assume it could be ordered by key first.</p>
","<p>As @Pointy mentioned in the comments, the output of <code>JSON.stringify</code> and <code>json_encode</code> may have slight differences in two scenarios:</p>

<ol>
<li>An object's key/value ordering (objects are <em>unordered</em>)</li>
<li>""Simple"" values</li>
</ol>

<p>On ""simple"" values, the <a href=""http://php.net/json_encode#refsect1-function.json-encode-notes"" rel=""nofollow"">PHP documentation</a> has this to say:</p>

<blockquote>
  <p>Like the reference JSON encoder, json_encode() will generate JSON that is a simple value (that is, neither an object nor an array) if given a <code>string</code>, <code>integer</code>, <code>float</code> or <code>boolean</code> as an input <code>value</code>. While most decoders will accept these values as valid JSON, some may not, as the specification is ambiguous on this point.<br>
  To summarise, always test that your JSON decoder can handle the output you generate from json_encode().</p>
</blockquote>

<p>If you're worried about the data being 100% faithfully recreated, consider encoding the data before storing it (i.e. base64_encode it).</p>

<p><strong>P.S.</strong> If you're going to HMAC the data, you need to 1) only HMAC the values and 2) make sure you always access the values in the same order every time because JSON makes no ordering promises for anything except arrays.</p>
","1487","<javascript><php><json><cryptojs>","4","2","1","2016-02-02 16:14:48","35158429","2","","816260","","2016-02-02 16:01:49","2016-02-02 14:58:43",""
"36657354","CryptoJS Sha3 and PHP-SHA3","<p>I'm trying to get the same result from using cryptojs sha3 method and the php-sha3 library, but the results just dont' seem to match.</p>

<p>An example:</p>

<p>For CryptoJS</p>

<pre><code>var hash = CryptoJS.SHA3(""qwerty"", { outputLength: 224 }).toString();
</code></pre>

<p>gives me <code>d7a12ecec4442f1b31eea5f7d5470f0ca6169463e09d91a147c3b8e8</code></p>

<p>while with PHP-SHA3</p>

<pre><code>echo sha3(""qwerty"",224);
</code></pre>

<p>gives me <code>13783bdfa4a63b202d9aa1992eccdd68a9fa5e44539273d8c2b797cd</code></p>

<p>I am a complete encryption noob, so I'm guessing I'm missing something fundamental about this.</p>
","<p>Artjom is right.  You can try this JS library, <a href=""https://github.com/emn178/js-sha3"" rel=""nofollow"">https://github.com/emn178/js-sha3</a>.  I am able to use it to generate SHA3 and Keccak hashes.</p>

<p>The you can verify the hash at <a href=""http://emn178.github.io/online-tools/sha3_224.html"" rel=""nofollow"">http://emn178.github.io/online-tools/sha3_224.html</a>. </p>
","1486","<php><hash><cryptojs><sha-3>","1","0","2","2017-05-06 14:10:58","","3","2","1816580","","2016-04-15 21:46:59","2016-04-15 21:46:04",""
"36657354","CryptoJS Sha3 and PHP-SHA3","<p>I'm trying to get the same result from using cryptojs sha3 method and the php-sha3 library, but the results just dont' seem to match.</p>

<p>An example:</p>

<p>For CryptoJS</p>

<pre><code>var hash = CryptoJS.SHA3(""qwerty"", { outputLength: 224 }).toString();
</code></pre>

<p>gives me <code>d7a12ecec4442f1b31eea5f7d5470f0ca6169463e09d91a147c3b8e8</code></p>

<p>while with PHP-SHA3</p>

<pre><code>echo sha3(""qwerty"",224);
</code></pre>

<p>gives me <code>13783bdfa4a63b202d9aa1992eccdd68a9fa5e44539273d8c2b797cd</code></p>

<p>I am a complete encryption noob, so I'm guessing I'm missing something fundamental about this.</p>
","<p>CryptoJS 'sha3' is not actually using the current SHA-3 standard unfortunately - hence your discrepancy. The code is implementing a version of SHA-3 which was superseded. </p>

<blockquote>
  <p>In 2014, NIST made slight changes to the Keccak submission and
  published FIPS 202, which became the official SHA-3 standard in August
  2015.</p>
</blockquote>

<p>Quoted from this source:</p>

<p><a href=""https://medium.com/@ConsenSys/are-you-really-using-sha-3-or-old-code-c5df31ad2b0"" rel=""nofollow noreferrer"">https://medium.com/@ConsenSys/are-you-really-using-sha-3-or-old-code-c5df31ad2b0</a></p>

<p>Which goes on to say:</p>

<blockquote>
  <p>Unfortunately, the readme in Github makes no mention, and the user
  must look at the old site to find the NOTE: I made a mistake when I
  named this implementation SHA-3. It should be named Keccak. So any
  dependents of CryptoJS that uses sha3 is using old code that would be
  better described by a term like Keccak. Also, beware of online sha3
  calculators, because some of them have not been updated to SHA-3.</p>
</blockquote>
","1486","<php><hash><cryptojs><sha-3>","1","3","2","2017-05-06 14:10:58","","3","2","1816580","","2016-04-15 21:46:59","2016-04-15 21:46:04",""
"38927124","Computing Signature/Hash in Javascript and have same result as C#","<p>I have the following code in C#</p>

<pre><code>var apiKey = ""SBB3aWxsIG1ha2UgbXbcQVBJIHN|Y3VyZQ=="";
var apiSecret = ""QaTW3xlf1U5ljdlAJSdltzT71fFF+eZ="";

var key = Convert.FromBase64String(apiSecret);
var provider = new System.Security.Cryptography.HMACSHA256(key);

var hash = provider.ComputeHash(Encoding.UTF8.GetBytes(apiKey));
var signature = Convert.ToBase64String(hash);
</code></pre>

<p>I am trying to get the same result in Javascript using the CryptJS library but from what i can tell i am not converting the key and secret to byte arrays and the encoding is incorrect. first try looks like:</p>

<pre><code>var apiKey = ""SBB3aWxsIG1ha2UgbXbcQVBJIHN|Y3VyZQ=="";
var apiSecret = ""QaTW3xlf1U5ljdlAJSdltzT71fFF+eZ="";
var hash = CryptoJS.HmacSHA256(apiKey, apiSecret);
var sig = hash.toString(CryptoJS.enc.Base64);
</code></pre>
","<p>Inspire by <a href=""https://stackoverflow.com/a/13837543/1810391"">https://stackoverflow.com/a/13837543/1810391</a></p>

<p>Javascript</p>

<pre><code>var CryptoJS = require('crypto-js');

var apiKey = ""SBB3aWxsIG1ha2UgbXbcQVBJIHN|Y3VyZQ=="";
var apiSecret = ""QaTW3xlf1U5ljdlAJSdltzT71fFF+eZ="";

// var key = Convert.FromBase64String(apiSecret);
var key = CryptoJS.enc.Base64.parse(apiSecret);
console.log('key:' + key);

// var prehash = Encoding.UTF8.GetBytes(apiKey);
var prehash = CryptoJS.enc.Utf8.parse(apiKey);
console.log('Pre-hash:' + prehash);

// var provider = new System.Security.Cryptography.HMACSHA256(key);
// var hash = provider.ComputeHash(prehash);
var hash = CryptoJS.HmacSHA256(prehash, key);
console.log('hash:' + hash);

//var signature = Convert.ToBase64String(hash);
var signature = hash.toString(CryptoJS.enc.Base64);
console.log('signature:' + signature);
</code></pre>

<p>Javascript Output</p>

<pre><code>key:41a4d6df195fd54e658dd940252765b734fbd5f145f9e6
Pre-hash:53424233615778734947316861325567625862635156424a49484e7c593356795a513d3d
hash:ecb6cdf5dd39872bb2cbce4321e2725e11b99c01af9c2a620ebbaf3d8d8607e7
signature:7LbN9d05hyuyy85DIeJyXhG5nAGvnCpiDruvPY2GB+c= 
</code></pre>

<p>C#</p>

<pre><code>using System;
using System.Text;

namespace ConsoleApplication
{
    public class Program
    {
        public static void Main(string[] args)
        {
            var apiKey = ""SBB3aWxsIG1ha2UgbXbcQVBJIHN|Y3VyZQ=="";
            var apiSecret = ""QaTW3xlf1U5ljdlAJSdltzT71fFF+eZ="";
            var key = Convert.FromBase64String(apiSecret);
            Console.Write(""key:"");
            prtByte(key);

            Console.Write(""Pre-hash:"");
            prtByte(Encoding.UTF8.GetBytes(apiKey));
            var provider = new System.Security.Cryptography.HMACSHA256(key);
            var hash = provider.ComputeHash(Encoding.UTF8.GetBytes(apiKey));
            Console.Write(""hash:"");
            prtByte(hash);

            var signature = Convert.ToBase64String(hash);
            Console.WriteLine(""signature:"" + signature);
        }
        public static void prtByte(byte[] b)
        {
            for (var i = 0; i &lt; b.Length; i++)
            {
                Console.Write(b[i].ToString(""x2""));
            }
            Console.WriteLine();
        }
    }
}
</code></pre>

<p>C# Output</p>

<pre><code>key:41a4d6df195fd54e658dd940252765b734fbd5f145f9e6
Pre-hash:53424233615778734947316861325567625862635156424a49484e7c593356795a513d3d
hash:ecb6cdf5dd39872bb2cbce4321e2725e11b99c01af9c2a620ebbaf3d8d8607e7
signature:7LbN9d05hyuyy85DIeJyXhG5nAGvnCpiDruvPY2GB+c=
</code></pre>
","1469","<javascript><c#><hash><sha256><cryptojs>","7","14","1","2016-08-18 14:56:06","38988181","7","1","810571","","2016-08-16 19:02:47","2016-08-12 22:11:29",""
"32279004","Decrypting signature and Veryifying JWT","<p>I understand that there exist other libraries which make my life easier to work with JWT (in node.js).  </p>

<p>In this case, I am using ""crypto-js"" to learn JWT in a manual way.  The following gives me the token:</p>

<pre><code>var header = {
    ""alg"": ""HS256"",
    ""typ"": ""JWT""
};
var wordArrayHeader = CryptoJS.enc.Utf8.parse(JSON.stringify(header));
var base64Header = CryptoJS.enc.Base64.stringify(wordArrayHeader);

var payload = {
    ""sub"": ""1234567890"",
    ""name"": ""John Doe"",
    ""admin"": true
};
var wordArrayPayload = CryptoJS.enc.Utf8.parse(JSON.stringify(payload));
var base64Payload = CryptoJS.enc.Base64.stringify(wordArrayPayload);

var signature = CryptoJS.HmacSHA256(base64Header + ""."" + base64Payload , ""secret"");
var base64Sign = CryptoJS.enc.Base64.stringify(signature);
var token = base64Header + ""."" + base64Payload + ""."" + base64Sign;
</code></pre>

<p>I am unable to do the exact opposite, to verify the token.  For example, the following throws me an error when decrypting the signature:</p>

<pre><code>var token = ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"";
var base64Header = ""eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"";
var base64Payload = ""eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9"";
var base64Sign = ""TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"";

var parsedSignArray = CryptoJS.enc.Base64.parse(base64Sign);
var parsedSign = parsedSignArray.toString(CryptoJS.enc.Utf8);
var decrypted = CryptoJS.HmacSHA256.decrypt(parsedSign , ""secret"");
console.log(decrypted);
</code></pre>

<p>What am I missing here?  BTW, just for this example, I am using token from <a href=""http://jwt.io"" rel=""nofollow"">http://jwt.io</a></p>
","<p>There is no such thing as <code>CryptoJS.HmacSHA256.decrypt</code>. Since HMAC, as well as hash functions in general, are one-way functions the only way to verify the ""signature"" would be to run the same one way function over the same string and then compare it with the one that you've got:</p>

<pre><code>var signature = CryptoJS.HmacSHA256(base64Header + ""."" + base64Payload , ""secret"").toString(CryptoJS.enc.Base64);
var valid = signature == base64Sign;
</code></pre>
","1468","<javascript><node.js><jwt><hmac><cryptojs>","3","4","1","2015-08-28 22:50:18","32279189","0","1","1816580","","2015-08-28 22:50:18","2015-08-28 20:05:43",""
"52680879","CryptoJS AES Encryption and Decryption","<p>First of all, I have 2 different systems - one in java, and one in javascript. I have an encrypted string (done in java), I also have secretKey which was used to encrypt it. I can decrypt it using this in Javascript. I know decryption result is correct. So I cant change decryption logic. Here is decryption code: </p>

<pre><code>decrypt = (value) =&gt; {
  const cipher = CryptoJS.enc.Base64.parse(value);
  const dec = CryptoJS.enc.Utf8.stringify(
  CryptoJS.AES.decrypt(
      { ciphertext: cipher },
      secretKey,
      { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }
   )
 );
 return dec;
};
</code></pre>

<p>I am trying to encrypt the result of above to get original encrypted string in javascript. I tried to do exactly opposite of what I did in decrypt. Here is encryption code:</p>

<pre><code>encrypt = (value) =&gt; {
    var encrypted = CryptoJS.enc.Utf8.parse(
        CryptoJS.AES.encrypt(
            value, secretKey,
            { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }
        )
  );
  const cipher = CryptoJS.enc.Base64.stringify(encrypted);
  return cipher;
</code></pre>

<p>}</p>

<p>I am expecting an original string which was passed in, but I am not getting same result.</p>

<pre><code>let decrypted = decrypt(""LJalEgQ81qUjrVzhlgFNw=="");
console.log(""Decrypted:"", decrypted);

encrypted = encrypt(decrypted);
console.log(""Encrypted:"", encrypted);
</code></pre>

<p>Any help is appreciated. Thanks in advance.</p>
","","1451","<encryption><aes><cryptojs>","0","","0","2018-10-06 16:00:21","","3","","","","","2018-10-06 16:00:21",""
"37743218","Change the Key with CryptoJS","<p>I am using CryptoJS to encrypt and decrypt the text. Here, I am just taking the message and showing the both encryption and decryption messages. </p>

<p>I am using DES algorithm for encrypting and decrypting.</p>

<p>This is my HTML file</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src=""tripledes.js""&gt;&lt;/script&gt;
    &lt;script src=""mode-ecb.js""&gt;&lt;/script&gt;
    &lt;style type=""text/css""&gt;
        .maindiv {
            /* Just to center the form on the page */
            margin: 0 auto;
            width: 400px;
            /* To see the outline of the form */
            padding: 1em;
            border: 1px solid #CCC;
            border-radius: 1em;
        }
         div + div {
                margin-top: 1em;
            }
        label {
            /* To make sure that all labels have the same size and are properly aligned */
            display: inline-block;
            width: 90px;
            text-align: right;
        }
        .button {
            /* To position the buttons to the same position of the text fields */
            padding-left: 90px; /* same size as the label elements */
        }

        button {
            /* This extra margin represent roughly the same space as the space
       between the labels and their text fields */
            margin-left: .5em;
        }
        input:focus, textarea:focus {
            /* To give a little highlight on active elements */
            border-color: #000;
        }
        input, textarea {
            /* To make sure that all text fields have the same font settings
       By default, textareas have a monospace font */
            font: 1em sans-serif;
            /* To give the same size to all text field */
            width: 300px;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
            /* To harmonize the look &amp; feel of text field border */
            border: 1px solid #999;
        }
    &lt;/style&gt;
    &lt;script type=""text/javascript""&gt;

        function viewvalue()
        {
            var message = document.getElementById(""msg"").value;
            var key = document.getElementById(""key"").value;
            var encrypted = encryptByDES(message, key);
            document.getElementById(""enctext"").textContent = encrypted;
            document.getElementById(""dectxt"").textContent = decryptByDES(encrypted, key);;


        }

        function encryptByDES(message, key) {

            var keyHex = CryptoJS.enc.Utf8.parse(key);

            var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });
            return encrypted.toString();
        }

        function decryptByDES(ciphertext, key) {
            var keyHex = CryptoJS.enc.Utf8.parse(key);

            var decrypted = CryptoJS.DES.decrypt({
                ciphertext: CryptoJS.enc.Base64.parse(ciphertext)
            }, keyHex, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });

            return decrypted.toString(CryptoJS.enc.Utf8);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=""maindiv""&gt;
        &lt;div&gt;
            &lt;label for=""name""&gt;Message:&lt;/label&gt;
            &lt;input type=""text"" id=""msg"" name=""msg"" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=""mail""&gt;Key:&lt;/label&gt;
            &lt;input type=""text"" id=""key"" name=""key"" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=""msg""&gt;Encrypted Text:&lt;/label&gt;
            &lt;textarea id=""enctext"" name=""enctxt""&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=""msg""&gt;Decrypted Text:&lt;/label&gt;
            &lt;textarea id=""dectxt"" name=""dectxt""&gt;&lt;/textarea&gt;
        &lt;/div&gt;
        &lt;div class=""button""&gt;
            &lt;button onclick=""viewvalue()""&gt;View&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>This is my .js file</p>

<pre><code>/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Electronic Codebook block mode.
 */
CryptoJS.mode.ECB = (function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();

    ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.encryptBlock(words, offset);
        }
    });

    ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.decryptBlock(words, offset);
        }
    });

    return ECB;
}());
</code></pre>

<p>Please anyone can tell me where and how to change the key.</p>
","<p>According to the docs at <a href=""https://code.google.com/archive/p/crypto-js/#Custom_Key_and_IV"" rel=""nofollow"">https://code.google.com/archive/p/crypto-js/#Custom_Key_and_IV</a>, you would need to define and supply both the initialisation vector (IV) and the key if you wish to provide a custom key:</p>

<pre><code>var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f'); 
var iv = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f'); 
var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
</code></pre>
","1448","<javascript><encryption><cryptojs>","0","1","1","2016-06-10 09:06:24","","8","","1816580","","2016-06-10 09:06:24","2016-06-10 08:14:07","2016-06-13 16:17:06"
"41717966","Adding javascript function to jMeter using jsr223","<p>I am trying to get a javascript function work with jMeter test plan uing JSR223.
It is used to decode a string.
I have the below two functions which i need to implement in jmeter:</p>

<pre><code>function AESEncryption(text, passphase, bytessize) {

var key = CryptoJS.enc.Utf8.parse('ABCDEFGHIJKL1234567891234');
var iv = CryptoJS.enc.Utf8.parse('1234567890123456');
var blocksize = bytessize / 2;
var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), passphase, key,
{
    keySize: bytessize,
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
var dta = String(encrypted);
return dta;}


function AESDecryption(text, key, bytessize) {
try {
    //alert(text + "":"" + key + "":"" + bytessize);
    var e = CryptoJS.AES.decrypt(text, key, bytessize);
    //alert(""Ec:"" + e);
    return CryptoJS.AES.decrypt(text, key, bytessize).toString(CryptoJS.enc.Utf8);
}
catch (Error) {
    return """";}}
</code></pre>
","<p>You can import external JavaScript into JSR223 Sampler using <code>load</code> directive. </p>

<ol>
<li>Download latest release of crypto-js from <a href=""https://github.com/brix/crypto-js/releases"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js/releases</a> (I used 3.1.9) and unpack it to JMeter's ""bin"" folder </li>
<li><p>Add the next line to the beginning of your JSR223 script:</p>

<pre><code>load('crypto-js-3.1.9/crypto-js.js');
</code></pre></li>
<li><p>You should be able to access your JavaScript functions directly in the JSR223 Sampler</p>

<p><a href=""https://i.stack.imgur.com/O8WBy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/O8WBy.png"" alt=""JSR223 JavaScript""></a></p></li>
</ol>

<hr>

<p>Be aware that JavaScript being interpreted via Rhino/Nashorn has serious performance drawbacks therefore if you are planning to call this funciton by many threads it makes more sense to rewrite your functions in <a href=""https://www.blazemeter.com/blog/beanshell-vs-jsr223-vs-java-jmeter-scripting-its-performance"" rel=""nofollow noreferrer"">Groovy</a>. </p>
","1443","<javascript><encryption><jmeter><cryptojs><jsr223>","0","2","1","2019-10-09 21:36:54","","1","","","","","2017-01-18 11:15:09",""
"30870556","Encryption decryption with AES Crypto-JS does not work in an android webview?","<p>In a webview in my android app, I am trying to do encryption and decryption with Crypto-JS. Encryption is working fine but decryption does not work. I searched a lot and none of the solution i found worked for me. I am new with javascript. In my another app i am doing this in android and its working fine. But with jquery decryption is not working. Following is the Encryption function I am using:</p>

<pre><code>function encryptText(textvalue, key) {
    var key = CryptoJS.enc.Utf8.parse(key);
    var iv = CryptoJS.lib.WordArray.random(128/8);

    var encrypted = CryptoJS.AES.encrypt(textvalue, key,
       {
          keySize: 128 / 8,
          iv: iv,
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
       });

    var pass = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
    var ivpass = encrypted.iv.toString(CryptoJS.enc.Base64);

    return ivpass+pass;
}
</code></pre>

<p>Its working fine. 
Following is the descryption function I am using:</p>

<pre><code>function decryptText(encrypted, keyParam){
    var key = CryptoJS.enc.Utf8.parse(keyParam);
    var indexOfSeperation = encrypted.indexOf(""==""); 

    var iv = encrypted.substring(0, indexOfSeperation+2);
    var value = encrypted.substring(indexOfSeperation + 2);
    console.log(""iv: ""+iv);
    console.log(""value: ""+value);

    var valueStr  = CryptoJS.enc.Base64.parse(value);
    var ivStr  = CryptoJS.enc.Base64.parse(iv);

    var decrypted = CryptoJS.AES.decrypt(valueStr, key,
       {
          iv: ivStr,
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
       }
   );

   var result = CryptoJS.enc.Utf8.parse(decrypted);
   console.log(""result: ""+result);
}
</code></pre>

<p>result is always empty. Is there anything I am doing wrong.</p>
","<p>The CryptoJS <code>decrypt()</code> function expects the ciphertext either to be OpenSSL formatted or be a speciel object.</p>

<p>The only value that you need to set on the special object is the <code>ciphertext</code> property:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt({
        ciphertext: valueStr
    }, 
    key,
    {
        iv: ivStr,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }
);
</code></pre>

<p>Furthermore, <code>decrypted</code> is a WordArray. You need to use <code>stringify()</code> to get a string out of it:</p>

<pre><code>var result = CryptoJS.enc.Utf8.stringify(decrypted);
</code></pre>
","1422","<javascript><encryption><aes><cryptojs>","0","2","1","2015-06-16 14:57:34","30870710","0","1","1816580","","2015-06-16 14:36:51","2015-06-16 14:29:33",""
"18298387","PBKDF2 result is different in CryptoJS and iOS","<p>PBKDF2 result is different in CryptoJS and iOS.</p>

<p>Here is my code </p>

<p>CryptoJS</p>

<pre><code>var key= CryptoJS.PBKDF2(""gf8uny"", ""2mnfpLsa+5I="", { keySize: 256/32, iterations: 1000 });
console.log(key.toString(CryptoJS.enc.Base64));
// console output ANepH98DqZHtMkkVrIk/CNmfykVPfEFpoax2PF8z5k8=  
</code></pre>

<p>iOS</p>

<pre><code>NSMutableData *key = [NSMutableData dataWithLength:kCCKeySizeAES256];

NSString *password = @""gf8uny"";
NSData*salt =[NSData dataFromBase64String:@""2mnfpLsa+5I=""];

int result = CCKeyDerivationPBKDF(kCCPBKDF2,         // algorithm
                                  password.UTF8String,                // password
                                  password.length,                    // passwordLength
                                  salt.bytes,                         // salt
                                  salt.length,                        // saltLen
                                  kCCPRFHmacAlgSHA1,                              // PRF
                                  1000,                 // rounds
                                  key.mutableBytes,            // derivedKey
                                  key.length);                 // derivedKeyLen

NSString *sKey= [key base64EncodedString];
NSLog(@""key%@"", sKey);
// output AjHjVAwHCpF1SnNDN6ri9ms7ig88VFBPwRVRMppBgnU=
</code></pre>

<p>Can someone help? what I'm doing wrong?</p>

<p>Thanks</p>
","<p>In the javascript version of your code, the salt should be a WordArray object not a javascript string. Basically in your two examples, the salts are different and therefore you are getting two different results.</p>

<p>To verify what I am talking about, try the following piece of code in the browser javascript console:</p>

<pre><code>saltWArray = CryptoJS.lib.WordArray.random(128/8);
saltString = saltWArray.toString(); // same salt but in String format

var key1 = CryptoJS.PBKDF2(""password"", saltWArray, { keySize: 512/32, iterations: 300 });
var key2 = CryptoJS.PBKDF2(""password"", saltString, { keySize: 512/32, iterations: 300 });
</code></pre>

<p>In the above code, key1 and key2 will be different, because the salts are inherently different even though the salt content is the same.</p>
","1397","<ios><cryptojs>","2","0","1","2013-10-18 20:36:08","","0","2","1786132","","2013-08-19 12:02:25","2013-08-18 11:02:03",""
"53965446","How to sign a JWT with a private key (pem) in CryptoJS?","<p>I am trying to create a signed JWT in postman with the following code </p>

<pre><code>function base64url(source) {
    // Encode in classical base64
    encodedSource = CryptoJS.enc.Base64.stringify(source);

    // Remove padding equal characters
    encodedSource = encodedSource.replace(/=+$/, '');

    // Replace characters according to base64url specifications
    encodedSource = encodedSource.replace(/\+/g, '-');
    encodedSource = encodedSource.replace(/\//g, '_');

    return encodedSource;
}

function addIAT(request) {
    var iat = Math.floor(Date.now() / 1000) + 257;
    data.iat = iat;
    return data;
}


var header = {
    ""typ"": ""JWT"",
    ""alg"": ""HS256""
};

var data = {
    ""fname"": ""name"",
    ""lname"": ""name"",
    ""email"": ""email@domain.com"",
    ""password"": ""abc123$""
};

data = addIAT(data);

var secret = 'myjwtsecret';

// encode header
var stringifiedHeader = CryptoJS.enc.Utf8.parse(JSON.stringify(header));
var encodedHeader = base64url(stringifiedHeader);

// encode data
var stringifiedData = CryptoJS.enc.Utf8.parse(JSON.stringify(data));
var encodedData = base64url(stringifiedData);

// build token
var token = encodedHeader + ""."" + encodedData;

// sign token
var signature = CryptoJS.HmacSHA256(token, secret);
signature = base64url(signature);
var signedToken = token + ""."" + signature;

postman.setEnvironmentVariable(""payload"", signedToken);
</code></pre>

<p>Code taken from <a href=""https://gist.github.com/corbanb/db03150abbe899285d6a86cc480f674d"" rel=""noreferrer"">https://gist.github.com/corbanb/db03150abbe899285d6a86cc480f674d</a> .</p>

<p>I've been trying to input the PEM as the secret but does not work. Also can't find any HmacSHA256 overload that takes a PEM.</p>

<p>How can that be done?</p>
","<p>The mention of postman changed this. I have a solution for you, but it's not exactly a clean way by any mean.</p>

<p>You'll need to create a request that you will need to execute whenever you open postman. Go as follows:</p>

<p><a href=""https://i.stack.imgur.com/5IcVL.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/5IcVL.png"" alt=""Side-loading jsrsasign-js""></a></p>

<p>The purpose of this request is to side-load <code>jsrsasign-js</code> and storing it in a global Postman variable.</p>

<p>Once this is done, you can then use this content elsewhere. For every request you need a RSA256 JWT signature, the following pre-request script will update a variable (here, <code>token</code>) with the token:</p>

<pre><code>var navigator = {};
var window = {};
eval(pm.globals.get(""jsrsasign-js""));

function addIAT(request) {
    var iat = Math.floor(Date.now() / 1000) + 257;
    data.iat = iat;
    return data;
}

var header = {""alg"" : ""RS256"",""typ"" : ""JWT""};
var data = {
    ""fname"": ""name"",
    ""lname"": ""name"",
    ""email"": ""email@domain.com"",
    ""password"": ""abc123$""
};

data = addIAT(data);

var privateKey = ""-----BEGIN RSA PRIVATE KEY----- \
MIIBOQIBAAJAcrqH0L91/j8sglOeroGyuKr1ABvTkZj0ATLBcvsA91/C7fipAsOn\
RqRPZr4Ja+MCx0Qvdc6JKXa5tSb51bNwxwIDAQABAkBPzI5LE+DuRuKeg6sLlgrJ\
h5+Bw9kUnF6btsH3R78UUANOk0gGlu9yUkYKUkT0SC9c6HDEKpSqILAUsXdx6SOB\
AiEA1FbR++FJ56CEw1BiP7l1drM9Mr1UVvUp8W71IsoZb1MCIQCKUafDLg+vPj1s\
HiEdrPZ3pvzvteXLSuniH15AKHEuPQIhAIsgB519UysMpXBDbtxJ64jGj8Z6/pOr\
NrwV80/EEz45AiBlgTLZ2w2LjuNIWnv26R0eBZ+M0jHGlD06wcZK0uLsCQIgT1kC\
uNcDTERjwEbFKJpXC8zTLSPcaEOlbiriIKMnpNw=\
-----END RSA PRIVATE KEY-----"";

var sHeader = JSON.stringify(header);
var sPayload = JSON.stringify(data);

var sJWT = KJUR.jws.JWS.sign(header.alg, sHeader, sPayload, privateKey);

pm.variables.set('token', sJWT);
</code></pre>

<p>In order:
- I define mock <code>window</code> and <code>navigator</code> objects as <code>jsrsasign-js</code> needs them.
- I then <code>eval()</code> the content of what we fetched earlier in order to rehydrate everything
- The rest of your code is simple usage of <code>jsrsasign-js</code>. Your token info is there, and I've defined a private key there. You can change this or use an environment variable; it's just there for demo purposes. I then simply use the rehydrated library to sign it, and set the variable to the value of the signed JWT.</p>

<hr>

<p>A <code>PEM</code>, as you refer to it, is a container format specifying a combination of public and/or private key. You're using it to sign using <code>HMAC-SHA256</code>, which operates on a <strong>shared</strong> secret. This obviously isn't going to work (unless you take the poor man's approach and use your public key as the shared secret).</p>

<p>Fortunately enough, there are other signature methods defined in the RFCs. For instance, there is a way to sign using <code>RSA</code>, and a very convenient way of defining a public key as a <a href=""https://tools.ietf.org/html/rfc7517"" rel=""noreferrer"">JSON web key</a> (<code>JWK</code>). We're going to be leveraging both.</p>

<p>I've generated a key pair for testing, they're named <code>out</code> and <code>out.pub</code>. Generation tool is <code>genrsa</code> (and as such, they're an RSA keypair).</p>

<p>In order to sign, we're going to have to change a few things:</p>

<ul>
<li>We're changing algorithms from <code>HS256</code> to <code>RS256</code>, as explained above</li>
<li>We're going to need a new library to do the signing itself, as <code>crypto-js</code> does not support asymmetric key crypto. We'll fall back to the native <code>crypto</code> module, though there are pure-JS alternatives</li>
</ul>

<p>The code:</p>

<pre><code>var CryptoJS = require(""crypto-js"");
var keyFileContent = require(""fs"").readFileSync(""./out"");
var pubkey = require(""fs"").readFileSync(""./out.pub"");
var base64url = require(""base64url"");
var nJwt = require(""njwt"");
function addIAT(request) {
    var iat = Math.floor(Date.now() / 1000) + 257;
    data.iat = iat;
    return data;
}


var header = {
    ""typ"": ""JWT"",
    ""alg"": ""RS256""
};

var data = {
    ""fname"": ""name"",
    ""lname"": ""name"",
    ""email"": ""email@domain.com"",
    ""password"": ""abc123$""
};

data = addIAT(data);

// encode header
var stringifiedHeader = JSON.stringify(header);
var encodedHeader = base64url(stringifiedHeader);

// encode data
var stringifiedData = JSON.stringify(data);
var encodedData = base64url(stringifiedData);

// build token
var token = encodedHeader + ""."" + encodedData;

// sign token
var signatureAlg = require(""crypto"").createSign(""sha256"");
signatureAlg.update(token);
var signature = signatureAlg.sign(keyFileContent);
signature = base64url(signature);
var signedToken = token + ""."" + signature;

console.log(signedToken);

// Verify
var verifier = new nJwt.Verifier();
verifier.setSigningAlgorithm('RS256');
verifier.setSigningKey(pubkey);
verifier.verify(signedToken, function() {
  console.log(arguments);
});
</code></pre>

<p>And that's it! It's quite literally that simple, although I would not recommend rewriting the <code>sign()</code> function from <code>crypto</code> from scratch. Leave it to a library that has had thorough inspection by the community, and crypto is pretty serious business.</p>
","1395","<javascript><jwt><postman><cryptojs>","9","5","1","2019-01-07 18:45:28","53965740","1","2","","","","2018-12-28 23:37:52",""
"50307269","nodejs crypto Is there any encrypt and decrypt text, should give different encryption at every time","<p>I know AES 256 CBC with buffer to give different encrypt but its length <strong>66</strong>.
here is my code </p>

<pre><code>  const crypto = require('crypto');
  const ENCRYPTION_KEY = 'Must256bytes(32characters)secret';
  const IV_LENGTH = 16;
  function encrypt(text) {
    let iv = crypto.randomBytes(IV_LENGTH);
    let cipher = crypto.createCipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let encrypted = cipher.update(text.toString());
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + 'XX' + encrypted.toString('hex');
  }
  function decrypt(text) {
    let textParts = text.split('XX');
    let iv = new Buffer(textParts.shift(), 'hex');
    let encryptedText = new Buffer(textParts.join('XX'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let decrypted = decipher.update(encryptedText);
    try{
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return decrypted.toString();
    }catch(Err){
      return 'NULL';
    }
  }
</code></pre>

<p>Problem is encryption data length is <strong>66</strong> even for text is 1<br>
So is there any encryption and decryption method should give different encryption data at every time with less than <strong>10</strong> characters for text is 1(according to my example)</p>

<p><em>Thank you</em></p>
","<p>Your code works fine on my end, and the long sequence of hex characters seems perfectly normal to me.</p>

<p>Your ciphertext is always 66 characters long (in hex) because you're storing the 32 character IV, the 2 character delimiter (""AP""), and the 32 character (256 bit) ciphertext. Your code uses padding, and as such, the ciphertext will always be the next multiple of 16 bytes (32 hex characters) up from the length of the plaintext, and that's why you're getting such a long string of hex characters for a plaintext string that's only 1 character.</p>

<p>Unfortunately for you, padding is required for AES (at least in the mode you're using), otherwise it wouldn't function.</p>
","1392","<node.js><encryption><aes><cryptojs>","1","1","3","2018-05-12 17:09:46","50308412","2","1","","","","2018-05-12 14:25:23",""
"50307269","nodejs crypto Is there any encrypt and decrypt text, should give different encryption at every time","<p>I know AES 256 CBC with buffer to give different encrypt but its length <strong>66</strong>.
here is my code </p>

<pre><code>  const crypto = require('crypto');
  const ENCRYPTION_KEY = 'Must256bytes(32characters)secret';
  const IV_LENGTH = 16;
  function encrypt(text) {
    let iv = crypto.randomBytes(IV_LENGTH);
    let cipher = crypto.createCipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let encrypted = cipher.update(text.toString());
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + 'XX' + encrypted.toString('hex');
  }
  function decrypt(text) {
    let textParts = text.split('XX');
    let iv = new Buffer(textParts.shift(), 'hex');
    let encryptedText = new Buffer(textParts.join('XX'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let decrypted = decipher.update(encryptedText);
    try{
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return decrypted.toString();
    }catch(Err){
      return 'NULL';
    }
  }
</code></pre>

<p>Problem is encryption data length is <strong>66</strong> even for text is 1<br>
So is there any encryption and decryption method should give different encryption data at every time with less than <strong>10</strong> characters for text is 1(according to my example)</p>

<p><em>Thank you</em></p>
","<p>Yes. You can get a ciphertext of 5 bytes (or 10 hexadecimal characters) or less. But there are catches for such short ciphertexts.</p>

<p>Basically there are two ways. I'll start with the easier one.</p>

<h2>Counter mode (CTR)</h2>

<p>You can use CTR (counter) mode with a nonce. Encrypting X bytes with CTR mode gives you exactly X bytes as a result. CTR mode does not require padding of the plaintext to N times the block size.</p>

<p>This nonce (number-used-once) <em>must</em> be a unique number, <em>or your plaintext is in direct danger of being exposed</em>. You cannot just rely on a random number; a 4 byte random number has a high probability of repetition because of the <em>birthday bound</em>.</p>

<p>So you either need to store the nonce separately or include a 4 byte nonce in your ciphertext. However, if you ever manage to reuse the nonce then you're screwed. For such a low amount of bytes that means that you basically have to keep a 4 byte counter, which means having to store <em>state</em>.</p>

<p>Generally CTR mode encryption routines require you to supply an IV rather than a nonce. This is simply the initial counter value. You <em>must</em> construct this value by getting the nonce, and then <em>right-padding</em> it with zero valued bytes until you get to 16 bytes, the block size of AES.</p>

<p>You can find sample code <a href=""https://stackoverflow.com/a/29430375/589259"">here</a>, don't forget to upvote. Rob also has provided some sample code <a href=""https://stackoverflow.com/a/50308412/589259"">in his answer</a>.</p>

<h2>Format preserving encryption (FPE)</h2>

<p>With format preserving encryption the output of the encryption uses the exact number of bits or even values as the possible values of the input. That sounds great, but FPE consists of a bunch of relatively complex algorithms. Basically you'd have to find a crypto library in JavaScript to implement it.</p>

<p>Note that with FPE the same message will <em>always encrypt to the same ciphertext</em>. Depending on the application this may or may not be a problem.</p>

<hr>

<p>Notes:</p>

<ul>
<li>You are using hexadecimal encoding, that's not the most dense encoding out there, you could use base 64 or even ASCII 85 encoding.</li>
<li>It's more efficient to first concatenate the IV and ciphertext <em>as bytes</em> and then perform the encoding. If you have a static size for the IV you can simply use a constant rather than a separator.</li>
<li>Your key should consist of random bytes, not a text string. Passwords need to be converted using password hashing.</li>
</ul>
","1392","<node.js><encryption><aes><cryptojs>","1","3","3","2018-05-12 17:09:46","50308412","2","1","","","","2018-05-12 14:25:23",""
"50307269","nodejs crypto Is there any encrypt and decrypt text, should give different encryption at every time","<p>I know AES 256 CBC with buffer to give different encrypt but its length <strong>66</strong>.
here is my code </p>

<pre><code>  const crypto = require('crypto');
  const ENCRYPTION_KEY = 'Must256bytes(32characters)secret';
  const IV_LENGTH = 16;
  function encrypt(text) {
    let iv = crypto.randomBytes(IV_LENGTH);
    let cipher = crypto.createCipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let encrypted = cipher.update(text.toString());
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + 'XX' + encrypted.toString('hex');
  }
  function decrypt(text) {
    let textParts = text.split('XX');
    let iv = new Buffer(textParts.shift(), 'hex');
    let encryptedText = new Buffer(textParts.join('XX'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', new Buffer(ENCRYPTION_KEY), iv);
    let decrypted = decipher.update(encryptedText);
    try{
      decrypted = Buffer.concat([decrypted, decipher.final()]);
      return decrypted.toString();
    }catch(Err){
      return 'NULL';
    }
  }
</code></pre>

<p>Problem is encryption data length is <strong>66</strong> even for text is 1<br>
So is there any encryption and decryption method should give different encryption data at every time with less than <strong>10</strong> characters for text is 1(according to my example)</p>

<p><em>Thank you</em></p>
","<p><a href=""https://stackoverflow.com/a/50307837/589259"">Maarten covers</a> most of the major points that I wanted to make, so this is just some elaboration and an example of it in Node.</p>

<p>The changes from your code are:</p>

<ul>
<li>Encode in Base64 rather than Hex. This is much more space-efficient. It would be even better to just use Buffers and not create a string at all; then we could have a 9-byte nonce rather than a 5-byte nonce.</li>
<li>Get rid of separator character between the IV/nonce and the ciphertext. We know how long the IV/nonce is; we don't need a separator.</li>
<li>Use CTR mode rather than CBC mode. This makes output length equal to input length.</li>
<li>Use a nonce rather than an IV. Randomly choose the nonce from a 2^40 space. (Randomly choosing a CTR nonce is very dangerous in general. See below for why it <em>might</em> be acceptable in your use case; it is still never recommended.)</li>
<li>Fix password generation by adding PBKDF2 (you could also just use randomBytes). Your password is highly insecure. It's an ASCII string, which means it represents a tiny fraction of the AES-256 keyspace. On the order of 0.000000000002% of the keyspace. That's how much less secure this is than AES-256.</li>
</ul>

<p>As Maarten notes, it is quite dangerous for CTR mode to duplicate a Key+Nonce pair. If someone does that, they can learn the XOR of the two original messages. With that, they have a good chance of decrypting both messages. For example, if you duplicated your key+nonce on two messages and the attacker used that to discover that their XOR was 3 and knew that the encrypted text was a capital letter, they would know that the two messages had to be one of these:</p>

<pre><code>[('A', 'B'), ('D', 'G'), ('E', 'F'), ('H', 'K'), ('I', 'J'), ('L', 'O'),
 ('M', 'N'), ('P', 'S'), ('Q', 'R'), ('T', 'W'), ('U', 'V')]
</code></pre>

<p>This kind of information is devastating for structured data like human language or computer protocols. It can very quickly be used to decrypt the whole message. Key+nonce reuse is how <a href=""https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy#Weak_security"" rel=""nofollow noreferrer"">WEP was broken</a>. (When you do this by hand, it's basically identical to solving a cryptogram puzzle you'd find in the newspaper.) It is less powerful the more random the encrypted data is, and the less context it provides.</p>

<p>With a random 5-byte nonce, there is a 50% likelihood of a collision after about 1.3M encryptions. With a random 8-byte nonce, there is a 50% likelihood of a collision after about 5.3B encryptions. sqrt(pi/2 * 2^bits)</p>

<p>In cryptographic terms, this is a completely broken. It may or may not be sufficient for your purposes. To do it correctly (which I do not do below), as Maarten notes, you should keep track of your counter and increment it for every encryption rather than using a random one. After 2^40 encryptions (~1T), you change your key. </p>

<p>Assuming that leaking information about two messages per million is acceptable, this is how you would implement that.</p>

<pre><code>const crypto = require('crypto');

const ENCRYPTION_KEY = 'Must256bytes(32characters)secret';
const SALT = 'somethingrandom';
const IV_LENGTH = 16;

const NONCE_LENGTH = 5; // Gives us 8-character Base64 output. The higher this number, the better

function encrypt(key, text) {
  let nonce = crypto.randomBytes(NONCE_LENGTH);
  let iv = Buffer.alloc(IV_LENGTH)
  nonce.copy(iv)

  let cipher = crypto.createCipheriv('aes-256-ctr', key, iv);
  let encrypted = cipher.update(text.toString());
  message = Buffer.concat([nonce, encrypted, cipher.final()]);
  return message.toString('base64')
}

function decrypt(key, text) {
  let message = Buffer.from(text, 'base64')
  let iv = Buffer.alloc(IV_LENGTH)
  message.copy(iv, 0, 0, NONCE_LENGTH)
  let encryptedText = message.slice(NONCE_LENGTH)
  let decipher = crypto.createDecipheriv('aes-256-ctr', key, iv);
  let decrypted = decipher.update(encryptedText);
  try{
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
  }catch(Err){
    return 'NULL';
  }
}

// You could do this one time and record the result. Or you could just
// generate a random 32-byte key and record that. But you should never
// pass an ASCII string to the encryption function.
let key = crypto.pbkdf2Sync(ENCRYPTION_KEY, SALT, 10000, 32, 'sha512')

let encrypted = encrypt(key, ""X"")
console.log(encrypted + "" : "" + encrypted.length)

let decrypted = decrypt(key, encrypted)
console.log(decrypted)
</code></pre>
","1392","<node.js><encryption><aes><cryptojs>","1","2","3","2018-05-12 17:09:46","50308412","2","1","","","","2018-05-12 14:25:23",""
"53845964","Encryption in Typescript ( Angular ) and Decryption in Java","<p>I am currently using Angular7. 
I have Java encryption, decryption code implemented with me given by client, same I need to in Angular.</p>

<p>Below is code for Java.</p>

<pre><code>import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
</code></pre>

<p>Inside Class I have</p>

<pre><code>class EnDc(String passPhrase)
{
    private static final byte[] SALT = { 8 random numbers between -127 to 127 };
    private static final int ITERATION_COUNT = 1000;
    private static final int KEY_LENGTH = 256;
    private static final int IV_LENGTH = 16;
    private Cipher eCipher;
    private Cipher dCipher;
    private byte[] encrypt;
    private byte[] iv;
</code></pre>

<p>Generation of hashed key and iv is as below:</p>

<pre><code>    SecretKeyFactory secretKeyFactory = 
            SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), SALT, 
            1000, 256);
</code></pre>

<p>They have generated temp secret key with keyspec as follows :</p>

<pre><code>    secretKeyTemp = secretKeyFactory.generateSecret(keySpec);
</code></pre>

<p>Generated new secret key with temp key and with ""AES""</p>

<pre><code>    secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), //encode 
            ""AES"");
</code></pre>

<p>Next Steps :</p>

<pre><code>    this.eCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    this.eCipher.init(1, secretKey);
    // 1 - ENCRYPT_MODE, 2 - DECRYPT_MODE
</code></pre>

<p>IV generation : </p>

<pre><code>    this.iv = ((IvParameterSpec)this.eCipher.getParameters().getParameterSpec(IvParameterSpec.class)).getIV();

}
</code></pre>

<p>Actual Encrypt function as below</p>

<pre><code>public String encrypt(String encrypt)
      {
        String encStr = null;
        try
        {
          byte[] bytes = encrypt.getBytes(""UTF8"");
          byte[] encrypted = encrypt(bytes);
          byte[] cipherText = new byte[encrypted.length + this.iv.length];
          System.arraycopy(this.iv, 0, cipherText, 0, this.iv.length);
          System.arraycopy(encrypted, 0, cipherText, this.iv.length, encrypted.length);
          encStr = new String(Base64.getEncoder().encode(cipherText));
        }
        catch (Exception ex)
        {
          ex.printStackTrace();
        }
        return encStr;
      }
</code></pre>

<p>I am trying to implement this in Service file in Angular, Here as per my understanding here SALT byte array is predefined and IV is random which is appended before encrypted string and extracted while decryption,</p>

<p>So JS way I tried as below</p>

<pre><code>import * as CryptoJS from 'crypto-js';

encrypt (msg, pass) {
  const salt = CryptoJS.lib.WordArray.random(128 / 8);

  const key = CryptoJS.PBKDF2( pass, salt, {
      keySize: this.keySize / 32,
      iterations: this.iterations
  });

  const iv =  CryptoJS.lib.WordArray.random(128 / 8);
  const encrypted = CryptoJS.AES.encrypt(msg, key, {
    iv: iv,
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC
  });

  const transitmessage = salt.toString() + iv.toString() + encrypted.toString();
  return transitmessage;
}
</code></pre>

<p>So, I have done this code from link <a href=""http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/"" rel=""nofollow noreferrer"">http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/</a> , so now question is how can I implement SALT which is hard coded in JAVA, and also inside JAVA code they have not sent salt key attached with Encrypted String, but IV only as first 16 bits. How can I implement this ?</p>

<p>I have tried to do like this</p>

<pre><code>salt = CryptoJS.lib.WordArray.create([-67, -85, 13, -28, 75, 112, -126, 103]);
</code></pre>

<p>but key getting generated is object and also I am getting error while decrypting</p>

<p>Edit 1: I want salt to be same each time which I am currently generating as random and attaching to encrypted string. </p>

<p>I don't know if there is some implementation of SecretKeyFactory and Keyspec for Javascript</p>

<p>Help Appreciated, Thanks in Advance. </p>
","<p>When you do below, <code>WordArray.create</code> method uses your numbers as 32-bits integers:</p>

<pre><code>salt = CryptoJS.lib.WordArray.create([-67, -85, 13, -28, 75, 112, -126, 103]);
</code></pre>

<p>In this case your salt in hex is:</p>

<pre><code>ffffffbdffffffab0000000dffffffe40000004b00000070ffffff8200000067
</code></pre>

<p>If you convert javascript <code>Array</code> object to <code>Int8Array</code>, CryptoJS will create the same salt as in Java:</p>

<pre><code>salt = CryptoJS.lib.WordArray.create(new Int8Array([-67, -85, 13, -28, 75, 112, -126, 103]));
</code></pre>

<p>Result:</p>

<pre><code>bdab0de44b708267
</code></pre>
","1390","<angular><encryption><aes><cryptojs>","1","1","2","2019-06-06 10:32:29","56475765","0","0","5978753","","2018-12-19 07:09:35","2018-12-19 06:49:37",""
"53845964","Encryption in Typescript ( Angular ) and Decryption in Java","<p>I am currently using Angular7. 
I have Java encryption, decryption code implemented with me given by client, same I need to in Angular.</p>

<p>Below is code for Java.</p>

<pre><code>import java.security.SecureRandom;
import java.security.spec.KeySpec;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
</code></pre>

<p>Inside Class I have</p>

<pre><code>class EnDc(String passPhrase)
{
    private static final byte[] SALT = { 8 random numbers between -127 to 127 };
    private static final int ITERATION_COUNT = 1000;
    private static final int KEY_LENGTH = 256;
    private static final int IV_LENGTH = 16;
    private Cipher eCipher;
    private Cipher dCipher;
    private byte[] encrypt;
    private byte[] iv;
</code></pre>

<p>Generation of hashed key and iv is as below:</p>

<pre><code>    SecretKeyFactory secretKeyFactory = 
            SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), SALT, 
            1000, 256);
</code></pre>

<p>They have generated temp secret key with keyspec as follows :</p>

<pre><code>    secretKeyTemp = secretKeyFactory.generateSecret(keySpec);
</code></pre>

<p>Generated new secret key with temp key and with ""AES""</p>

<pre><code>    secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), //encode 
            ""AES"");
</code></pre>

<p>Next Steps :</p>

<pre><code>    this.eCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    this.eCipher.init(1, secretKey);
    // 1 - ENCRYPT_MODE, 2 - DECRYPT_MODE
</code></pre>

<p>IV generation : </p>

<pre><code>    this.iv = ((IvParameterSpec)this.eCipher.getParameters().getParameterSpec(IvParameterSpec.class)).getIV();

}
</code></pre>

<p>Actual Encrypt function as below</p>

<pre><code>public String encrypt(String encrypt)
      {
        String encStr = null;
        try
        {
          byte[] bytes = encrypt.getBytes(""UTF8"");
          byte[] encrypted = encrypt(bytes);
          byte[] cipherText = new byte[encrypted.length + this.iv.length];
          System.arraycopy(this.iv, 0, cipherText, 0, this.iv.length);
          System.arraycopy(encrypted, 0, cipherText, this.iv.length, encrypted.length);
          encStr = new String(Base64.getEncoder().encode(cipherText));
        }
        catch (Exception ex)
        {
          ex.printStackTrace();
        }
        return encStr;
      }
</code></pre>

<p>I am trying to implement this in Service file in Angular, Here as per my understanding here SALT byte array is predefined and IV is random which is appended before encrypted string and extracted while decryption,</p>

<p>So JS way I tried as below</p>

<pre><code>import * as CryptoJS from 'crypto-js';

encrypt (msg, pass) {
  const salt = CryptoJS.lib.WordArray.random(128 / 8);

  const key = CryptoJS.PBKDF2( pass, salt, {
      keySize: this.keySize / 32,
      iterations: this.iterations
  });

  const iv =  CryptoJS.lib.WordArray.random(128 / 8);
  const encrypted = CryptoJS.AES.encrypt(msg, key, {
    iv: iv,
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC
  });

  const transitmessage = salt.toString() + iv.toString() + encrypted.toString();
  return transitmessage;
}
</code></pre>

<p>So, I have done this code from link <a href=""http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/"" rel=""nofollow noreferrer"">http://www.adonespitogo.com/articles/encrypting-data-with-cryptojs-aes/</a> , so now question is how can I implement SALT which is hard coded in JAVA, and also inside JAVA code they have not sent salt key attached with Encrypted String, but IV only as first 16 bits. How can I implement this ?</p>

<p>I have tried to do like this</p>

<pre><code>salt = CryptoJS.lib.WordArray.create([-67, -85, 13, -28, 75, 112, -126, 103]);
</code></pre>

<p>but key getting generated is object and also I am getting error while decrypting</p>

<p>Edit 1: I want salt to be same each time which I am currently generating as random and attaching to encrypted string. </p>

<p>I don't know if there is some implementation of SecretKeyFactory and Keyspec for Javascript</p>

<p>Help Appreciated, Thanks in Advance. </p>
","<p>Please find below solution if it works for you.</p>

<pre><code>encrypt (msg, pass) {
    const key = CryptoJS.PBKDF2(pass, this.salt, {
        keySize: this.keySize / 32,
        iterations: this.iterations
    });

    const iv =  CryptoJS.lib.WordArray.random(128 / 8);

    const encrypted = CryptoJS.AES.encrypt(msg, key, {
          iv: iv,
          padding: CryptoJS.pad.Pkcs7,
          mode: CryptoJS.mode.CBC
    });

    const transitmessage = iv + encrypted.ciphertext;
    var tm=CryptoJS.enc.Hex.parse(transitmessage); // This converts to Type Word which is required for below function as input
    return CryptoJS.enc.Base64.stringify(tm); // Encoding
}
</code></pre>
","1390","<angular><encryption><aes><cryptojs>","1","1","2","2019-06-06 10:32:29","56475765","0","0","5978753","","2018-12-19 07:09:35","2018-12-19 06:49:37",""
"27059617","node.js https pfx certificate error","<p>I am trying to send a request to a HTTPS server by attaching a .pfx certificate along with the passphrase. However, I am getting this error:</p>

<pre><code>crypto.js:145
  c.context.loadPKCS12(pfx);
            ^
Error: wrong tag
at Object.exports.createCredentials (crypto.js:145:17)
at Object.exports.connect (tls.js:1331:27)
at Object.createConnection (https.js:79:14)
at new ClientRequest (http.js:1428:26)
at Object.exports.request (https.js:123:10)
at Object.&lt;anonymous&gt; (C:\Users\srmocher\Desktop\Webspaces.js:10:15)
at Module._compile (module.js:456:26)
at Object.Module._extensions..js (module.js:474:10)
at Module.load (module.js:356:32)
at Function.Module._load (module.js:312:12)
</code></pre>

<p>Here is my code:</p>

<pre><code>var https=require('https');
var options={
    hostname:'https://&lt;my-api&gt;'
    method:'GET',
    pfx:""&lt;pfx-data&gt;"",
    passphrase:""&lt;pass&gt;"",
    agent:false
};
var req=https.request(options,function(res){
    res.on('data',function(d){
        console.log(d);
    })
});
</code></pre>

<p>If anyone can help me understand the error, I'd be glad.</p>
","","1390","<javascript><node.js><https><cryptojs>","0","","0","2014-11-21 10:55:08","","4","","4043683","","2014-11-21 10:55:08","2014-11-21 10:53:09",""
"35516656","AES encryption with CryptoJS corrupting unicode emoji","<p>I'm writing a system, where a user can write something (via. mobile browser), and that ""String"" will be encrypted with a password, chosen by the user. Since unicode emojis are often used, they have to be supported too.</p>

<p>As lib for the crypto, I choose CryptoJs - so that the crypto can be done local on the devices.</p>

<p>Currently, when I encrypt a string, and decrypt the same sting, all emojis disappear/ are replaced with random chars.</p>

<pre><code>var key = ""123"";
var content = ""secret text with an emoji, "";

var encrypted = aes_encrypt(key, content); //U2FsdGVkX19IOHIt+eRkaOcmNuZrc1rkU7JepL4iNdUknzhDaLOnSjYBCklTktSe

var decrypted = aes_decrypt(key, encrypted);//secret text with an emoji, &lt;
</code></pre>



<p>I'm using a pair of helper functions like this:</p>

<pre><code>function aes_encrypt(key, content){
  var key_string = key + """";
  var content_string = ascii_to_hex(content) + """";
  var key_sha3 = sha3(key_string);
  var encrypted = CryptoJS.AES.encrypt(content_string, key_sha3, {
      mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.Iso10126});
  return encrypted + """";
};
</code></pre>

<p>Can anybody please tell me what I'm doing wrong?</p>
","<blockquote>
  <p><strong>Warning:</strong> It is extremely difficult to get cryptographic code right. It can be even harder in JavaScript, where you often lack control over the execution environment and (as discussed below) a lack of language support has led to inconsistent conventions. I have not done enough research about the CryptoJS library to know about its design or security, or whether it is being used safely in this context.</p>
  
  <p>Please do not rely on any of this code to be genuinely secure without a professional audit.</p>
</blockquote>

<p>A common issue when working with cryptographic code in JavaScript has been that there was no built-in way to represent binary data. This has been resolved in modern engines (with types <code>Blobs</code> and <code>TypedArrays</code> in the browser and <code>Buffers</code> in Node.js), but there is still a lot code that doesn't take advantage of this for historical or compatibility reasons.</p>

<p>Without these built-in types, one common convention (used by the built-in <a href=""https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob"" rel=""nofollow""><code>atob</code></a> and <a href=""https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa"" rel=""nofollow""><code>btoa</code></a> functions) is to use the built-in string type to hold binary data. A JavaScript string is really a list of two-byte values (usually containing UCS-2/UTF-16-encoded Unicode characters). Users wanting to store binary data will often just use the lower byte, ignoring the higher byte entirely.</p>

<p>If you're only handling ASCII-compatible data, you might get away with ignoring these details when using code like this (i.e. things will work -- but there may be subtle security consequences). This is because text encoded as ASCII looks the same as text encoded as UTF-16 with the high bytes stripped out. But when you venture beyond that, you need to do some encoding.</p>

<p>The most correct thing (aside from using a real binary type) to do would be to take the input string of characters, encode it to UTF-8, and put that data in the lower bytes of an output string. However, JavaScript doesn't provide a built-in function to do that. As a crude but simple alternative, <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent"" rel=""nofollow"">the <code>encodeURIComponent</code> function</a> will encode any valid unicode string into a UTF-8 based representation of entirely URL-safe characters, which are all ASCII-compatible. In the case of your code, that would mean something like this:</p>

<pre><code>var key = ""123"";
var content = ""secret text with an emoji, "";

var encrypted = aes_encrypt(key, encodeURIComponent(content));

var decrypted = decodeURIComponent(aes_decrypt(key, encrypted));
</code></pre>

<p>If you have a lot of non-URL-safe characters, this could result in the encoded data being much larger than necessary, but it should be safe. Also, <code>encodeURIComponent</code> will apparently throw an error for strings that contain ""unpaired surrogate characters"". I don't think these should occur in ordinary input, but someone could craft them.</p>

<p>I expect that there is a more-correct way to handle things like this in CryptoJS, but I am unaware of it.  Please consider looking into this further if you're planning to deploy this code for public use.</p>
","1356","<javascript><unicode><cryptojs>","4","6","2","2017-07-31 05:29:58","35518128","7","1","1114","","2016-02-20 01:40:56","2016-02-19 23:02:18",""
"35516656","AES encryption with CryptoJS corrupting unicode emoji","<p>I'm writing a system, where a user can write something (via. mobile browser), and that ""String"" will be encrypted with a password, chosen by the user. Since unicode emojis are often used, they have to be supported too.</p>

<p>As lib for the crypto, I choose CryptoJs - so that the crypto can be done local on the devices.</p>

<p>Currently, when I encrypt a string, and decrypt the same sting, all emojis disappear/ are replaced with random chars.</p>

<pre><code>var key = ""123"";
var content = ""secret text with an emoji, "";

var encrypted = aes_encrypt(key, content); //U2FsdGVkX19IOHIt+eRkaOcmNuZrc1rkU7JepL4iNdUknzhDaLOnSjYBCklTktSe

var decrypted = aes_decrypt(key, encrypted);//secret text with an emoji, &lt;
</code></pre>



<p>I'm using a pair of helper functions like this:</p>

<pre><code>function aes_encrypt(key, content){
  var key_string = key + """";
  var content_string = ascii_to_hex(content) + """";
  var key_sha3 = sha3(key_string);
  var encrypted = CryptoJS.AES.encrypt(content_string, key_sha3, {
      mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.Iso10126});
  return encrypted + """";
};
</code></pre>

<p>Can anybody please tell me what I'm doing wrong?</p>
","<p>CryptoJS is capable of converting a UTF-8 encoded string to its own binary data format (<code>WordArray</code>). This can be accomplished with <code>var binData = CryptoJS.enc.Utf8.parse(string);</code>:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var password = ""123"";
var content = ""secret text with an emoji, "";

inContent.innerHTML = content;

var encrypted = aes_encrypt(password, content);
var decrypted = aes_decrypt(password, encrypted);

out.innerHTML = decrypted;

function aes_encrypt(password, content) {
  return CryptoJS.AES.encrypt(content, password).toString();
}

function aes_decrypt(password, encrypted) {
  return CryptoJS.AES.decrypt(encrypted, password).toString(CryptoJS.enc.Utf8);
}</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>#inContent { color: blue; }
#out { color: red; }    </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;div&gt;in: &lt;span id=""inContent""&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;out: &lt;span id=""out""&gt;&lt;/span&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>This works because if a string is passed as content to <code>CryptoJS.AES.encrypt</code> then it will be automatically parsed as UTF-8, but you need to convert it back to UTF-8 after decryption yourself. This is done with <code>.toString(CryptoJS.enc.Utf8)</code>.</p>

<hr>

<p>This code only demonstrates that CryptoJS handles UTF-8 already very well. This is not secure, because </p>

<ul>
<li><p>MD5 with a single iteration is used for key derivation from the password. You would need to use something like PBKDF2, which CryptoJS provides. (Don't forget to use a random IV every time. It doesn't have to be secret, so you can send it along with the ciphertext.)</p></li>
<li><p>The ciphertext is not authenticated, which makes it unlikely to detect (malicious) manipulation of the encrypted data. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme with a strong MAC like HMAC-SHA256, which CryptoJS provides.</p></li>
</ul>
","1356","<javascript><unicode><cryptojs>","4","3","2","2017-07-31 05:29:58","35518128","7","1","1114","","2016-02-20 01:40:56","2016-02-19 23:02:18",""
"23209347","How to find a SHA1 encrypted string from the 5-word encrypted hash in Ruby?","<p>Say you're encrypting the string ""alextoul"" with CryptoJS.SHA1.</p>

<p>As explained in the source below you get an object that looks like that:</p>

<blockquote>
  <p>CryptoJS.SHA1(""alextoul"") = {words: { 0: 1025575641 1: -2026381578 2: 1077518901 3: 1028391820 4:
  1049226021 }}</p>
</blockquote>

<p>Turns out if you convert this to a string you get: </p>

<blockquote>
  <p>CryptoJS.SHA1(""alextoul"").ToString() = ""3d210ad98737def64039a2353d4c038c3e89eb25""</p>
</blockquote>

<p>Now what I'm trying to do is find the string above (""3d210ad98737def64039a2353d4c038c3e89eb25"") from the 5 words but in Ruby.</p>

<blockquote>
  <p>thefunctionineed(params[:words]) # Equal to ""3d210ad98737def64039a2353d4c038c3e89eb25""</p>
</blockquote>

<p>Source: <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">https://code.google.com/p/crypto-js/#The_Hasher_Output</a></p>
","<p>Just reading the source:</p>

<p><a href=""https://code.google.com/p/crypto-js/source/browse/tags/3.1.2/src/core.js#181"" rel=""nofollow"">https://code.google.com/p/crypto-js/source/browse/tags/3.1.2/src/core.js#181</a> --> </p>

<p><a href=""https://code.google.com/p/crypto-js/source/browse/tags/3.1.2/src/core.js#306"" rel=""nofollow"">https://code.google.com/p/crypto-js/source/browse/tags/3.1.2/src/core.js#306</a> --></p>

<pre><code>function stringify(wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;

        // Convert
        var hexChars = [];
        for (var i = 0; i &lt; sigBytes; i++) {
            var bite = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff;
            hexChars.push((bite &gt;&gt;&gt; 4).toString(16));
            hexChars.push((bite &amp; 0x0f).toString(16));
        }

        return hexChars.join('');
    }
</code></pre>

<p>Then call</p>

<pre><code>stringify(CryptoJS.SHA1(""alextoul""))
</code></pre>

<p>Sorry I don't know ruby well enough to port that</p>
","1354","<javascript><ruby><encryption><sha1><cryptojs>","0","0","1","2014-04-22 03:01:20","","2","","427824","","2014-04-22 03:00:24","2014-04-22 02:30:14",""
"21240950","Crypto JS AES-128 cipher - equivalent Javascript code","<p>I have the following Java code for creating an AES-128 cipher, where key and iv are both based on the same passphrase.</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
byte[] keyBytes = new byte[16];
byte[] b = passphare.getBytes(""UTF-8"");
int len = b.length;
if (len &gt; keyBytes.length) {
    len = keyBytes.length;
}

System.arraycopy(b, 0, keyBytes, 0, len);
SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
cipher.init(opmode, keySpec, ivSpec);

cipher.doFinal(textToEncrypt.getBytes(""UTF-8""));
</code></pre>

<p>I have tried to use the same approach in Javascript using CryptoJS for generating the same cipher, but with no success. Can you please help me?</p>
","<p>Quoting the JSFiddle from the OP's comment:</p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(128/8);
// Key and iv should be based on the same value. In this example ""1111""
var key = CryptoJS.PBKDF2(""1111"", salt, { keySize: 128/32 });
var iv = key; // Not sure what should be here!!
</code></pre>

<p>You are generating a key from a random salt (see first line), and using that same key as initialization vector... and yet you expect a constant result? (as expected, the result changes in each invocation).</p>

<p>Fix it to use the exact same bytes for <code>key</code> and <code>iv</code> used by the <code>SecretKeySpec</code> and <code>IvParameterSpec</code> from the java code (which you can query using their <code>getEncoded()</code> methods). I do not know whether the AES SecretKeySpec uses PBKDF2 or another key derivation function -- but it should be easy to test. Find the one that matches and stick to it.</p>

<p>Beware also that the default padding in CryptoJS is PKCS7 (see <a href=""http://code.google.com/p/crypto-js/#Block_Modes_and_Padding"" rel=""nofollow"">the docs</a> on ""block modes and padding""); this may differ strongly from the PKCS5 that you specify in your first line of Java code.</p>
","1353","<java><javascript><cryptojs>","3","1","1","2014-01-21 23:21:38","","4","3","699042","","2014-01-21 11:35:21","2014-01-20 17:57:22",""
"45652907","CryptoJS decrypt changes every time","<p>I am using CryptoJS to manually decrypt a string with a provided set of values. The secret is provided and then an SHA256 has is taken of it. The message and initialization vector are base 64 encoded. Here's what I am trying, but every time I run it, the output changes - how can that be?! I'm at the end of my wits...</p>

<pre><code>// Key and take the hash of it
var secretKey = 'TESTING123Secret_Key';
var secretKeyHash = CryptoJS.SHA256(secretKey).toString(CryptoJS.enc.Hex);

// Base 64 encoded values
var accountNumberBase64 = 'nxjYfo4Stw63YBEcnjo3oQ==';
var initializationVectorBase64 = 'HnNcvu9AP9yl09APWkWnDQ==';

// decode the values provided above
var accountNumberEncrypt = atob(accountNumberBase64);
var initializationVector = atob(initializationVectorBase64);

// Use crypto to decrypt
var decrypted = CryptoJS.AES.decrypt(
    {
        ciphertext: accountNumberEncrypt,
        salt: ''
    },
  secretKeyHash,
  {
      mode: CryptoJS.mode.CBC,
      padding: CryptoJS.pad.NoPadding,
      iv: initializationVector,
      salt: ''
  }
);
 console.log('   decrypted, by hand: ' + decrypted.toString(CryptoJS.enc.Hex));
</code></pre>

<p>the last line changes every time this is run (run it on page load) - same values provided every time, output is different. </p>

<p>How it is supposed to work:</p>

<pre><code>Decryption Instructions:
1. A static, secret key will be shared which will be used for decryption (Secret Key TBD).
    a. HASH the secret key with SHA256, encode it to Hex and use the first 32 characters. This will be used as the KEY when decrypting.
2. Two pieces of information will be sent via the POST method
    a. Parameter AN: A Base64 Encoded, AES-256-CBC Encrypted string which will represent the Account Number when decrypted
    b. Parameter IV: A Base64 Encoded initialization vector (IV) string which will be used in decrypting the Account Number string
3. Base64 Decode both parameters
4. Using the AES-256-CBC method, decrypt the encrypted string (which was base64 decoded as part of Step #3) with the initialization vector decoded in Step #3 and the hash created in Step #1a
5. The decryption should then provide you the account number.
</code></pre>

<p><a href=""https://pastebin.com/kdy0NcnK"" rel=""nofollow noreferrer"">Java code</a></p>
","<p>There many issues with your code. It is hard to say what is really responsible for the non-deterministic decryption. I guess it is the fact that you're passing the key as a string which means that CryptoJS will assume that it is a password and try to use EVP_BytesToKey to derive a key from that. Since the salt is not set, CryptoJS probably has a bug that it generates a random salt for decryption (which it should not). You need to parse the key into a <code>WordArray</code> if you want to manually provide the key.</p>

<p>The other main issue is using non-CryptoJS methods for decoding (<code>atob</code>) which means that you get some data format that cannot be directly read by CryptoJS. CryptoJS relies on the internal <code>WordArray</code> for representing all binary data or expects all strings to be UTF-8-encoded.</p>

<p>Working code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Key and take the hash of it
var secretKey = 'TESTING123Secret_Key';
var secretKeyHash = CryptoJS.SHA256(secretKey).toString(CryptoJS.enc.Hex).slice(0,32);
secretKeyHash = CryptoJS.enc.Utf8.parse(secretKeyHash);

// Base 64 encoded values
var accountNumberBase64 = 'nxjYfo4Stw63YBEcnjo3oQ==';
var initializationVectorBase64 = 'HnNcvu9AP9yl09APWkWnDQ==';

var ct = CryptoJS.enc.Base64.parse(accountNumberBase64);
var iv = CryptoJS.enc.Base64.parse(initializationVectorBase64);

// Use crypto to decrypt
var decrypted = CryptoJS.AES.decrypt({
    ciphertext: ct
  },
  secretKeyHash, {
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.NoPadding,
    iv: iv
  }
);
console.log('   decrypted, by hand: ' + decrypted.toString(CryptoJS.enc.Utf8));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/components/pad-nopadding-min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","1347","<javascript><encryption><cryptojs>","1","3","1","2017-08-13 08:37:18","45653289","4","","1816580","","2017-08-13 08:37:18","2017-08-12 17:13:31",""
"53606585","Create 16 byte key for AES Encryption from Salt and Password in Node JS Crypto","<p>I'm trying to match an AES 256 CBC encryption implemented in C# by using node JS crypto module.</p>

<p>This is my C# code</p>

<pre><code>using System;
using System.Security.Cryptography; 
using System.Text;
public class Program
{
    public static void Main()
    {
        Console.WriteLine(EncryptExt(""Hello World""));
        Console.WriteLine(DecryptExt(EncryptExt(""Hello World"")));
    }

    public static string EncryptExt(string raw)

        {

            using (var csp = new AesCryptoServiceProvider())

            {

                ICryptoTransform e = GetCryptoTransformExt(csp, true);

                byte[] inputBuffer = Encoding.UTF8.GetBytes(raw);

                byte[] output = e.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length);



                string encrypted = Convert.ToBase64String(output);



                return encrypted;

            }

        }



        public static string DecryptExt(string encrypted)

        {

            using (var csp = new AesCryptoServiceProvider())

            {

                var d = GetCryptoTransformExt(csp, false);

                byte[] output = Convert.FromBase64String(encrypted);

                byte[] decryptedOutput = d.TransformFinalBlock(output, 0, output.Length);



                string decypted = Encoding.UTF8.GetString(decryptedOutput);

                return decypted;

            }

        }



        private static ICryptoTransform GetCryptoTransformExt(AesCryptoServiceProvider csp, bool encrypting)

        {

            csp.Mode = CipherMode.CBC;

           csp.Padding = PaddingMode.PKCS7;

            var passWord = Convert.ToString(""AvbSkj3BVbf4o6mdlAofDp0/SD0susEWo0pKdmqas"");

            var salt = Convert.ToString(""ABj4PQgf3j5gblQ0iDp0/Gb07ukQWo0a"");



            String iv = Convert.ToString(""aAB1jhPQ89o=f619"");



            var spec = new Rfc2898DeriveBytes(Encoding.UTF8.GetBytes(passWord), Encoding.UTF8.GetBytes(salt), 65536);

            byte[] key = spec.GetBytes(16);





            csp.IV = Encoding.UTF8.GetBytes(iv);

            csp.Key = key;

            if (encrypting)

            {

                return csp.CreateEncryptor();

            }

            return csp.CreateDecryptor();

        }

}
</code></pre>

<p>And this is my Node JS implementation</p>

<pre><code>const crypto = require('crypto'),
  algorithm = 'aes-128-cbc',
  password = 'AvbSkj3BVbf4o6mdlAofDp0/SD0susEWo0pKdmqas',
  salt = 'ABj4PQgf3j5gblQ0iDp0/Gb07ukQWo0a',
  iv = 'aAB1jhPQ89o=f619',
  inputEncoding = 'utf8',
  outputEncoding = 'base64';


 function encrypt(text) {
  let cipher = crypto.createCipheriv(algorithm,createHashPassword(), iv);
  let encrypted = cipher.update(text, inputEncoding, outputEncoding)
  encrypted += cipher.final(outputEncoding);
  return encrypted;
}

function createHashPassword(){
    let nodeCrypto = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(salt), 65536, 16, 'sha1');

    return nodeCrypto || nodeCrypto.toString('hex');
};

function decrypt(encrypted) {
  let decipher = crypto.createDecipheriv(algorithm, Buffer.from(createHashPassword(),""hex""), iv)
  let dec = decipher.update(encrypted, outputEncoding, inputEncoding)
  dec += decipher.final(inputEncoding);
  return dec;
}

console.log(encrypt('Hello World'));
console.log(decrypt(encrypt('Hello World')));
</code></pre>

<p>The encrypted data from both this  options are coming different hence, not able to work this out.</p>

<p>So far what I have seen is,</p>

<ul>
<li>node crypto createCipheriv method takes only 32 byte buffer and if I
pass it a 16 byte buffer it says, invalid length. </li>
<li>If I convert the 16 byte key to hex encoded string, the encrypted value changes and does not match with the C# implementation.</li>
<li>I can't change the C# implementation as its already in production and been used by multiple applications.</li>
<li>So there seems to be an issue with generating key from salt and password in node js, matching what is done in C# and I'm not able to figure that out.</li>
</ul>

<p>Code can be tested in the below link:
C# Implementation: <a href=""https://dotnetfiddle.net/bClrpW"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/bClrpW</a>
Node JS Implementation: <a href=""https://runkit.com/a-vi-nash/5c062544509d8200156f6111"" rel=""nofollow noreferrer"">https://runkit.com/a-vi-nash/5c062544509d8200156f6111</a></p>
","<p>It seems that you are creating a <code>AES-128</code> instance in your <code>C#</code> code, because you are using 16 bytes keylen.</p>

<p><code>AES-256</code> keylen is 32 bytes, not 16 bytes.</p>

<p>Bugs in code:</p>

<ol>
<li>Since you set 16 bytes for key in <code>C#</code>, it uses <code>AES-128</code>, not <code>AES-256</code>. So you need to change <code>node.js</code> to <code>AES-128</code> or change generated key to 32 bytes in both sides.</li>
<li>Since you are using text string salt and password(not <code>base64</code> encoded), your <code>node.js</code> side uses incorrect <code>pbkdf2Sync</code> parameters.</li>
<li><code>IV</code> len for <code>AES</code> algorithm in 16 bytes and you cannot use shorter ones.</li>
</ol>

<p>Since you wanted <code>AES-256</code> here are your changed to both sides:</p>

<p><strong><code>C#</code> side:</strong></p>

<pre><code>String iv = Convert.ToString(""SOME_IV_SOME_IV_""); // 16 bytes IV
....
byte[] key = spec.GetBytes(32); // 32 bytes key
</code></pre>

<p><strong><code>node.js</code> side:</strong></p>

<pre><code>iv = 'SOME_IV_SOME_IV_' // 16 bytes IV similar to C#
...
// Bugs in this function
function createHashPassword(){
    // Change parameters to `base64` only if salt and password are base64. it may be true for salt, but it is can rarely be correct for password.
    let nodeCrypto = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(salt), 65536, 32, 'sha1');

    return nodeCrypto;
};
</code></pre>

<p><strong>IMPORTANT NOTES:</strong></p>

<ol>
<li>Remember that <code>IV</code> must be selected as a random buffer(neither fixed not text) and since it seems that you are sending it over network, you need to send <code>IV</code> with it too.</li>
<li><code>SALT</code> must be a random buffer(not text) and fixed on both sides.</li>
<li>i suggest to use over 100000 iteration for <code>PBKDF2</code> at least.</li>
</ol>
","1339","<node.js><encryption><aes><cryptojs><aescryptoserviceprovider>","0","0","2","2018-12-04 11:14:13","53606910","1","0","1645148","","2018-12-04 07:11:47","2018-12-04 06:00:17",""
"53606585","Create 16 byte key for AES Encryption from Salt and Password in Node JS Crypto","<p>I'm trying to match an AES 256 CBC encryption implemented in C# by using node JS crypto module.</p>

<p>This is my C# code</p>

<pre><code>using System;
using System.Security.Cryptography; 
using System.Text;
public class Program
{
    public static void Main()
    {
        Console.WriteLine(EncryptExt(""Hello World""));
        Console.WriteLine(DecryptExt(EncryptExt(""Hello World"")));
    }

    public static string EncryptExt(string raw)

        {

            using (var csp = new AesCryptoServiceProvider())

            {

                ICryptoTransform e = GetCryptoTransformExt(csp, true);

                byte[] inputBuffer = Encoding.UTF8.GetBytes(raw);

                byte[] output = e.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length);



                string encrypted = Convert.ToBase64String(output);



                return encrypted;

            }

        }



        public static string DecryptExt(string encrypted)

        {

            using (var csp = new AesCryptoServiceProvider())

            {

                var d = GetCryptoTransformExt(csp, false);

                byte[] output = Convert.FromBase64String(encrypted);

                byte[] decryptedOutput = d.TransformFinalBlock(output, 0, output.Length);



                string decypted = Encoding.UTF8.GetString(decryptedOutput);

                return decypted;

            }

        }



        private static ICryptoTransform GetCryptoTransformExt(AesCryptoServiceProvider csp, bool encrypting)

        {

            csp.Mode = CipherMode.CBC;

           csp.Padding = PaddingMode.PKCS7;

            var passWord = Convert.ToString(""AvbSkj3BVbf4o6mdlAofDp0/SD0susEWo0pKdmqas"");

            var salt = Convert.ToString(""ABj4PQgf3j5gblQ0iDp0/Gb07ukQWo0a"");



            String iv = Convert.ToString(""aAB1jhPQ89o=f619"");



            var spec = new Rfc2898DeriveBytes(Encoding.UTF8.GetBytes(passWord), Encoding.UTF8.GetBytes(salt), 65536);

            byte[] key = spec.GetBytes(16);





            csp.IV = Encoding.UTF8.GetBytes(iv);

            csp.Key = key;

            if (encrypting)

            {

                return csp.CreateEncryptor();

            }

            return csp.CreateDecryptor();

        }

}
</code></pre>

<p>And this is my Node JS implementation</p>

<pre><code>const crypto = require('crypto'),
  algorithm = 'aes-128-cbc',
  password = 'AvbSkj3BVbf4o6mdlAofDp0/SD0susEWo0pKdmqas',
  salt = 'ABj4PQgf3j5gblQ0iDp0/Gb07ukQWo0a',
  iv = 'aAB1jhPQ89o=f619',
  inputEncoding = 'utf8',
  outputEncoding = 'base64';


 function encrypt(text) {
  let cipher = crypto.createCipheriv(algorithm,createHashPassword(), iv);
  let encrypted = cipher.update(text, inputEncoding, outputEncoding)
  encrypted += cipher.final(outputEncoding);
  return encrypted;
}

function createHashPassword(){
    let nodeCrypto = crypto.pbkdf2Sync(Buffer.from(password), Buffer.from(salt), 65536, 16, 'sha1');

    return nodeCrypto || nodeCrypto.toString('hex');
};

function decrypt(encrypted) {
  let decipher = crypto.createDecipheriv(algorithm, Buffer.from(createHashPassword(),""hex""), iv)
  let dec = decipher.update(encrypted, outputEncoding, inputEncoding)
  dec += decipher.final(inputEncoding);
  return dec;
}

console.log(encrypt('Hello World'));
console.log(decrypt(encrypt('Hello World')));
</code></pre>

<p>The encrypted data from both this  options are coming different hence, not able to work this out.</p>

<p>So far what I have seen is,</p>

<ul>
<li>node crypto createCipheriv method takes only 32 byte buffer and if I
pass it a 16 byte buffer it says, invalid length. </li>
<li>If I convert the 16 byte key to hex encoded string, the encrypted value changes and does not match with the C# implementation.</li>
<li>I can't change the C# implementation as its already in production and been used by multiple applications.</li>
<li>So there seems to be an issue with generating key from salt and password in node js, matching what is done in C# and I'm not able to figure that out.</li>
</ul>

<p>Code can be tested in the below link:
C# Implementation: <a href=""https://dotnetfiddle.net/bClrpW"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/bClrpW</a>
Node JS Implementation: <a href=""https://runkit.com/a-vi-nash/5c062544509d8200156f6111"" rel=""nofollow noreferrer"">https://runkit.com/a-vi-nash/5c062544509d8200156f6111</a></p>
","<p>If you operate with passwords of 41 characters length, <strong>why don't you instead use an actual key?</strong> A base64 encoded 256 bit key would be 44 characters long. </p>

<p>The purpose of the salt and the iteration for the deviation is to counter the common problem of too short passwords. But why go through all the bother of implementering this in both ends with no added benefits, but more than one disadvantages - like more code &amp; slower solution.</p>
","1339","<node.js><encryption><aes><cryptojs><aescryptoserviceprovider>","0","0","2","2018-12-04 11:14:13","53606910","1","0","1645148","","2018-12-04 07:11:47","2018-12-04 06:00:17",""
"38990630","Converting Java's PBEWithMD5AndDES to JavaScript","<p>I'm trying to replicate the Java code in JavaScript.
below is my Java code:</p>

<pre class=""lang-java prettyprint-override""><code>public static String encrypt(String input)
final byte[] SALT= { (byte) 0x21, (byte) 0x21, (byte) 0xF0, (byte) 0x55, (byte) 0xC3, (byte) 0x9F, (byte) 0x5A, (byte) 0x75                     };
final int   ITERATION_COUNT = 31;
{
    if (input == null)
    {
        throw new IllegalArgumentException();
    }
    try
    {

        KeySpec keySpec = new PBEKeySpec(null, SALT, ITERATION_COUNT);
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(SALT, ITERATION_COUNT);

        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

        Cipher ecipher = Cipher.getInstance(key.getAlgorithm());
        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

        byte[] enc = ecipher.doFinal(input.getBytes());

        String res = new String(Base64.encodeBase64(enc));
        // escapes for url
        res = res.replace('+', '-').replace('/', '_').replace(""%"", ""%25"").replace(""\n"", ""%0A"");
        LOGGER.info(""String Encrypted Successfully"");
        return res;

    }
    catch (Exception e)
    {
        LOGGER.error(""encrypt Exception: ""+e.getMessage());
    }


    return """";

}
</code></pre>

<p>and the JavaScript code, so far hammed up is below:</p>

<pre class=""lang-js prettyprint-override""><code>var encrypt = function(){
    var iterations = 31;
    var key = CryptoJS.MD5(""PBEWithMD5AndDES"");
    var salt = CryptoJS.enc.Hex.parse('0021002100f0005500C3009F005A0075'); 
    var options = {
        mode: CryptoJS.mode.CBC, 
        iv: salt
    };
    var hashedPassword = CryptoJS.MD5($scope.data.webPassword);
    var encryptedPassword = CryptoJS.DES.encrypt(hashedPassword, key,options).toString();
    var result = encryptedPassword.toString(CryptoJS.enc.Base64);
}
</code></pre>

<p>but with both the encryption the encoded string I'm getting is different.</p>
","<p><strong><em>PBEwithMD5andDES is obsolete technology and should not be used nowadays.</strong> This answer is only provided for demonstration purposes.</em></p>

<p>PBEwithMD5andDES is defined in <a href=""ftp://ftp.rsasecurity.com/pub/pkcs/ascii/pkcs-5.asc"" rel=""nofollow"">PKCS#5 v1.5</a> which is nothing more than deriving key+IV using PBKDF1 (with MD5) and encrypting with DES. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var password = CryptoJS.enc.Utf8.parse(""test"");
var salt = CryptoJS.enc.Hex.parse(""2121F055C39F5A75"");
var iterations = 31;

// PBE according to PKCS#5 v1.5 (in other words: PBKDF1)
var md5 = CryptoJS.algo.MD5.create();
md5.update(password);
md5.update(salt);
var result = md5.finalize();
md5.reset();
for(var i = 1; i &lt; iterations; i++) {
    md5.update(result);
    result = md5.finalize();
    md5.reset();
}

// splitting key and IV
var key = CryptoJS.lib.WordArray.create(result.words.slice(0, 2));
var iv = CryptoJS.lib.WordArray.create(result.words.slice(2, 4));

var encrypted = CryptoJS.DES.encrypt(""test"", key, {
    iv: iv
});

enchex.innerHTML = encrypted.ciphertext.toString();
encbase64.innerHTML = encrypted.ciphertext.toString(CryptoJS.enc.Base64);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/tripledes.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/md5.js""&gt;&lt;/script&gt;
&lt;div&gt;Hex: &lt;span id=""enchex""&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;Base64: &lt;span id=""encbase64""&gt;&lt;/span&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://jsfiddle.net/artjomb/Lpbo7yrb/"" rel=""nofollow"">Here is a jsFiddle</a> to experiment with and here is the <a href=""http://ideone.com/By3xUw"" rel=""nofollow"">example Java code</a>. Both produce the same result in Hex: aa8101a7d63093c6.</p>

<hr>

<h3>Security considerations:</h3>

<p>PBEwithMD5andDES should not be used and there are better alternatives like PBEWithHmacSHA256AndAES_128 which require a slightly different approach.</p>

<p>The number of iterations must be large (a thousand to a million) in order to make it hard to brute-force the password. DES only provides 56 bits of security, so it is even possible to brute-force the key directly with today's means.</p>

<p>The salt must be randomly generated in order to achieve semantic security. The salt itself doesn't need to be secret. Since it has a known length it can be simply prepended to the ciphertext and sliced off before decryption.</p>
","1313","<javascript><java><encryption><passwords><cryptojs>","0","3","1","2016-08-19 16:22:56","","2","","1816580","","2016-08-17 18:54:29","2016-08-17 07:32:05",""
"52530769","aes-256-cbc encryption decryption with initial vector in nodejs","<p>I am trying to convert some existing php code into nodejs but node js code returns:</p>

<blockquote>
  <p>TypeError: Salt must be a buffer</p>
</blockquote>

<p>I am using node version => <strong>v8.11.2</strong></p>

<p><strong>PHP Code :</strong></p>

<pre><code>class SecurityModel {

    protected $key;
    protected $method;
    protected $data;
    protected $iv;

    function __construct($data, $key = 'testing', $method = 'AES-256-CBC',$InitialVector = ""aw90rela942f65u2"") {
        $this-&gt;data = $data;
        $this-&gt;key = $this-&gt;passwordDeriveBytes($key, null);
        $this-&gt;method = $method;
        $this-&gt;iv = $InitialVector;
    }

    function passwordDeriveBytes($password, $salt, $iterations = 100, $len = 32) {
        $key = $password . $salt;
        for($i = 0; $i &lt; $iterations; $i++) {
            $key = sha1($key, true);
        }
        if (strlen($key) &lt; $len) {
            $hx = $this-&gt;passwordDeriveBytes($password, $salt, $iterations - 1, 20);
            $counter = 0;
            while (strlen($key) &lt; $len) {
                $counter += 1;
                $key .= sha1($counter . $hx, true);
            }
        }
        return substr($key, 0, $len);
    }

    function encrypt(): string {
        return openssl_encrypt($this-&gt;data, ""aes-256-cbc"", $this-&gt;key, 0, $this-&gt;iv);
    }

    function decrypt(): string {
        return openssl_decrypt($this-&gt;data, ""aes-256-cbc"", $this-&gt;key, 0, $this-&gt;iv);
    }

}

$objSecurityModel = new SecurityModel('437217');
$Encrypted =  $objSecurityModel-&gt;encrypt();
echo ""Encrypted :"".$Encrypted .""&lt;br&gt;""; //returns--&gt;C9xJGa03dRQx9ePm0nLnHg==
$objSecurityModel = new SecurityModel($Encrypted);
echo ""Decrypted::"".$objSecurityModel-&gt;decrypt(); //returns--&gt;437217
</code></pre>

<p>I tried some what in nodejs </p>

<p><strong>NodeJs Code :</strong></p>

<pre><code>const express = require('express');
const app = express();
var crypto = require('crypto');

key = 'testing'
plaintext = '437217'
iv = 'aw90rela942f65u2'

crypto.pbkdf2('testing', null, 100, 32, 'AES-256-CBC', (err, derivedKey) =&gt; {
    if (err) throw err;
    console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'
    key = derivedKey.toString('hex');
});

cipher = crypto.createCipheriv('aes-256-cbc', key,iv)
decipher = crypto.createDecipheriv('aes-256-cbc', key,iv);

var encryptedPassword = cipher.update(plaintext, 'utf8', 'base64');
encryptedPassword += cipher.final('base64')

var decryptedPassword = decipher.update(encryptedPassword, 'base64', 'utf8');
decryptedPassword += decipher.final('utf8');

console.log('original  :', plaintext); 
console.log('encrypted :', encryptedPassword);
console.log('decrypted :', decryptedPassword);
//PORT
const port = process.env.PORT || 3000;
app.listen(port,() =&gt; console.log(`Listening on port ${port}....`));
</code></pre>
","<p>PBKDF2 is a great idea and is what the PHP code should have done in the first place. Unfortunately what happens inside <code>passwordDeriveBytes()</code> is nowhere near PBKDF2. You need to reproduce the looping like what happens inside <code>passwordDeriveBytes()</code> if you want to match it.</p>

<p>Oh and ""<em>Salt must be a buffer</em>"" is solved by converting the IV to a Buffer with <code>Buffer.from(iv)</code> (that is also a sign that a good IV should <em>not</em> be a string but random bytes).</p>

<pre><code>const crypto = require('crypto');

function sha1(input) {
    return crypto.createHash('sha1').update(input).digest();
}

function passwordDeriveBytes(password, salt, iterations, len) {
    var key = Buffer.from(password + salt);
    for(var i = 0; i &lt; iterations; i++) {
        key = sha1(key);
    }
    if (key.length &lt; len) {
        var hx = passwordDeriveBytes(password, salt, iterations - 1, 20);
        for (var counter = 1; key.length &lt; len; ++counter) {
            key = Buffer.concat([key, sha1(Buffer.concat([Buffer.from(counter.toString()), hx]))]);
        }
    }
    return Buffer.alloc(len, key);
}

var password = 'testing';
var plaintext = '437217';
var iv = 'aw90rela942f65u2';

//var key = crypto.pbkdf2Sync(password, '', 100, 32, 'sha1'); // How it should be
var key = passwordDeriveBytes(password, '', 100, 32); // How it is
console.log(key.toString('hex'));

var cipher = crypto.createCipheriv('aes-256-cbc', key, Buffer.from(iv));
var decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(iv));

var part1 = cipher.update(plaintext, 'utf8');
var part2 = cipher.final();
var encrypted = Buffer.concat([part1, part2]).toString('base64');

var decrypted = decipher.update(encrypted, 'base64', 'utf8');
decrypted += decipher.final();

console.log('original  :', plaintext); 
console.log('encrypted :', encrypted);
console.log('decrypted :', decrypted);
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>df07df624db35d0bcf5fe7ff2dfdfffcef93f098939d750ca55595ae1b33925d
original  : 437217
encrypted : C9xJGa03dRQx9ePm0nLnHg==
decrypted : 437217
</code></pre>
","1302","<php><node.js><encryption><cryptojs>","1","1","1","2018-09-28 08:06:37","52551004","4","","1385107","","2018-09-28 06:51:14","2018-09-27 06:29:59",""
"38692856","Encrypt password in angular using crypto service","<p>Being a newbie to angular I'm stuck in doing encryption using crypto service on angular side, while i need to decrypt the password on my server where I'm using JAVA.</p>

<p>however I managed to get part of my answer , but still was unable to decrypt the salt in java.</p>

<p><a href=""https://stackoverflow.com/questions/38990630/converting-javas-pbewithmd5anddes-to-javascript/39004235#39004235"">Converting Java&#39;s PBEWithMD5AndDES to JavaScript</a></p>

<p>Thanks in advance.</p>
","","1298","<angularjs><cryptojs>","0","","0","2016-08-23 06:54:55","","8","","-1","","2017-05-23 12:08:31","2016-08-01 07:09:19",""
"51280576","Trying to add data in unsupported state at Cipher.update","<p>Below code is working</p>

<pre><code>var crypto = require('crypto');
var cipher = crypto.createCipher('aes-128-cbc','abcdefghijklmnop')
var http = require('http')

var userStr = 'a134aad';
var crypted = cipher.update(userStr, 'utf8', 'hex');
crypted += cipher.final('hex');
console.log(crypted);
</code></pre>

<p>But when put into a server callback it doesn't work, and throws below err when a request arriving, and node is crush:</p>

<pre><code>http.createServer(function(req, res){
    var userStr = 'a134aad';
    var crypted = cipher.update(userStr, 'utf8', 'hex');
    crypted += cipher.final('hex');
    console.log(crypted);

    res.end('hello');
}).listen(9888)

---------------------------------

7364aee753f0568f7e5171add6868b75
crypto.js:170
  var ret = this._handle.update(data, inputEncoding);
                         ^
Error: Trying to add data in unsupported state
    at Cipher.update (crypto.js:170:26)
    at Server.&lt;anonymous&gt; (C:\Users\58\Desktop\sha256.js:12:26)
    at emitTwo (events.js:126:13)
    at Server.emit (events.js:214:7)
    at parserOnIncoming (_http_server.js:602:12)
    at HTTPParser.parserOnHeadersComplete (_http_common.js:117:23)
</code></pre>
","<p>Turns out </p>

<p><code>var cipher = crypto.createCipher('aes-128-cbc','abcdefghijklmnop')
</code></p>

<p>should not be reused. I put it into the server callback too and the problem is solved.</p>
","1286","<node.js><cryptojs>","2","5","2","2019-07-10 05:23:38","","0","","","","","2018-07-11 08:22:11",""
"51280576","Trying to add data in unsupported state at Cipher.update","<p>Below code is working</p>

<pre><code>var crypto = require('crypto');
var cipher = crypto.createCipher('aes-128-cbc','abcdefghijklmnop')
var http = require('http')

var userStr = 'a134aad';
var crypted = cipher.update(userStr, 'utf8', 'hex');
crypted += cipher.final('hex');
console.log(crypted);
</code></pre>

<p>But when put into a server callback it doesn't work, and throws below err when a request arriving, and node is crush:</p>

<pre><code>http.createServer(function(req, res){
    var userStr = 'a134aad';
    var crypted = cipher.update(userStr, 'utf8', 'hex');
    crypted += cipher.final('hex');
    console.log(crypted);

    res.end('hello');
}).listen(9888)

---------------------------------

7364aee753f0568f7e5171add6868b75
crypto.js:170
  var ret = this._handle.update(data, inputEncoding);
                         ^
Error: Trying to add data in unsupported state
    at Cipher.update (crypto.js:170:26)
    at Server.&lt;anonymous&gt; (C:\Users\58\Desktop\sha256.js:12:26)
    at emitTwo (events.js:126:13)
    at Server.emit (events.js:214:7)
    at parserOnIncoming (_http_server.js:602:12)
    at HTTPParser.parserOnHeadersComplete (_http_common.js:117:23)
</code></pre>
","<p><strong>Check this out</strong></p>

<p>Thats mainly because every time we run the encrypt or decrypt we should repeat <code>crypto.createCipher('aes192', secrateKey);</code> and <code>crypto.createDecipher('aes192', secrateKey);</code></p>

<pre><code>let secrateKey = ""secrateKey"";
const crypto = require('crypto');


function encrypt(text) {
    encryptalgo = crypto.createCipher('aes192', secrateKey);
    let encrypted = encryptalgo.update(text, 'utf8', 'hex');
    encrypted += encryptalgo.final('hex');
    return encrypted;
}

function decrypt(encrypted) {
    decryptalgo = crypto.createDecipher('aes192', secrateKey);
    let decrypted = decryptalgo.update(encrypted, 'hex', 'utf8');
    decrypted += decryptalgo.final('utf8');
    return decrypted;
}

let encryptedText = encrypt(""hello"");
console.log(encryptedText);

let decryptedText = decrypt(encryptedText);
console.log(decryptedText);
</code></pre>

<p>Hope this helps!</p>
","1286","<node.js><cryptojs>","2","0","2","2019-07-10 05:23:38","","0","","","","","2018-07-11 08:22:11",""
"14814361","How can I decrypt AES CBC Mode in Hex String?","<p>My task is to decrypt AES-128 in CBC Mode as I already have to encrypted hex string and the key (also in hex).
I have tried a simple code like:</p>

<pre><code>function doDecrypt(){
    var encryptedData = ""1d4c76364618b6efce62258353f89810""
    var key = ""11112222333344445555666677778888""; 

    encryptedData = CryptoJS.enc.Hex.parse(encryptedData);
    key = CryptoJS.enc.Hex.parse(key);

        var decrypted = CryptoJS.AES.decrypt(encryptedData, key);
    alert(CryptoJS.enc.Hex.stringify(decrypted));
}
</code></pre>

<p>The result I get is just a blank word array (in ""decrpyted""), can anyone point out that where did i do wrong please?</p>

<p>do I need an additional information such as iv, salt or not?</p>
","<p>""AES-128 in CBC Mode"" is not a data format. There is no universal way of writing encrypted data along with the required metadata. You need to know what you've been handed and how it was generated. Then you can work out how to implement the same with CryptoJS in most cases. In particular, you need to know the following:</p>

<ul>
<li>What algorithm? ""AES-128"" is ambiguous. It could mean ""AES with a 128-bit key size"" or it could mean ""AES with a 128-block size and some other key size.""</li>
<li>What key size (see above)</li>
<li>What mode? (You've answered this: it's CBC.)</li>
<li>What is the padding? The most common is PKCS#7, but there could be no padding. (For CBC mode, it is almost certainly PKCS#7.)</li>
<li>What is the IV? There is <em>always</em> an IV for CBC. Sometimes that IV is incorrectly set to NULL (this makes CBC less secure). It is possible that the IV is generated somehow from a password (this is how OpenSSL works).</li>
<li>Do you have a good key, an insecure key, or a password. A good key is a series of random bytes the size of your key. An insecure key is when a password is treated like a key (by copying human-typed letters into the key buffer). This is insanely insecure, but very common.</li>
<li>If you have a proper password, then what KDF and parameters were used to convert it to a key? For example, did they use the OpenSSL KDF or PBKDF2 or bcrypt or scrypt?</li>
<li>Is there any other metadata, such as an HMAC? (An HMAC is required to secure AES-CBC. Without it, an attacker can sometimes modify the ciphertext to decrypt to a desired plaintext.)</li>
</ul>

<p>When you have these answers, then you can work out how to implement it with CryptoJS.</p>
","1281","<javascript><aes><cryptojs>","0","3","1","2013-02-12 10:29:13","","2","","2061637","","2013-02-12 10:29:13","2013-02-11 14:42:14",""
"17871069","RNCryptor IOS + Javascript encryption / decryption AES 256","<p>I am new to encryption and i am trying to get some symmetric encryption usign AES256 going from a mobile app to a webpage through websockets. </p>

<p>I Encrypt the data using RNCryptor default settings</p>

<p>IOS CODE</p>

<pre><code>   NSString* message = @""testmessage"";
   NSData* pubData = [message dataUsingEncoding:NSUTF8StringEncoding];
   NSData *encryptedData = [RNEncryptor encryptData:pubData
                                        withSettings:kRNCryptorAES256Settings
                                            password:@""test""
                                               error:&amp;error];
    if(error) {
        NSLog(@""Error encrypting %@"", [error localizedDescription]);
    }

    NSString* encryptedString = [encryptedData base64Encoding];
    NSLog(@""Sending message %@"", encryptedString);
    [self.session publishData:[encryptedString dataUsingEncoding:NSUTF8StringEncoding] onTopic:@""test12345""];
</code></pre>

<p>Here is the output going out over websockets 
AgEBnXPPvAkJb7YVapwCVNd5SQw4JwqU7BfLsEXNZyKy9SazfJT8w16Y/hYY7aKxuz3Kuy2tAXXX/cHCc3PMhvG+fzSfrslRVMKvD6L+oWvXLg==</p>

<p>JAVASCRIPT CODE - I receive the message and i try to parse it and display it</p>

<pre><code>function onMessageArrived(message) {

  var rawData = base64.decode(message.payloadString);
  var encryptionSalt = rawData.substr(2,8);
  var hmacSalt = rawData.substr(10,8);
  var iv = rawData.substr(18, 16);
  var ciphertext = rawData.substr(34, rawData.length-34-32);
  var hmac = rawData.substr(rawData.length-32, 32);
  var password = ""test"";

  var key = CryptoJS.PBKDF2(password, encryptionSalt, { keySize: 256 / 32, iterations: 10000});

  var plaintextArray = CryptoJS.AES.decrypt(
    { ciphertext: CryptoJS.enc.Utf8.parse(ciphertext) },
    CryptoJS.enc.Hex.parse(key),
    { iv: CryptoJS.enc.Latin1.parse(iv) }
  );

   showScreen('&lt;span style=""color: blue;""&gt;User: ' + CryptoJS.enc.Latin1.stringify(plaintextArray) + '&lt;/span&gt;');
};
</code></pre>

<p>For some reason the code gets stuck on generating the key (maybe 10k iterations are too much for CryptoJS??? thats the iterations used on IOS ) </p>

<p>I have tried a bunch of different things with this and the output is garbage im not actually getting the message decrypted. Any help would be greatly appreciated. If you are going to recommend SJCL please provide some code . RNCryptor uses its own message format. I use it because of the randomized iv it provides . Please recommend a different library if you know of any as well.</p>

<p>THanks for reading.</p>
","<p>Please follow the documentation for the RNCryptor file format: <a href=""https://github.com/RNCryptor/RNCryptor-Spec/blob/master/RNCryptor-Spec-v3.md"" rel=""nofollow"">https://github.com/RNCryptor/RNCryptor-Spec/blob/master/RNCryptor-Spec-v3.md</a></p>

<p>You should be able to derive all the necessary data from file and add your shared secret...</p>

<p>Specification for RNCryptor data format version 3</p>

<pre><code>Byte:     |    0    |    1    |      2-9       |  10-17   | 18-33 | &lt;-      ...     -&gt; | n-32 - n |
Contents: | version | options | encryptionSalt | HMACSalt |  IV   | ... ciphertext ... |   HMAC   |
</code></pre>

<ul>
<li>version (1 byte): Data format version. Currently 3. </li>
<li>options (1 byte):
bit 0 - uses password </li>
<li>encryptionSalt (8 bytes): iff option includes
""uses password"" </li>
<li>HMACSalt (8 bytes): iff options includes ""uses
password"" </li>
<li>IV (16 bytes) ciphertext (variable) -- Encrypted in CBC
mode HMAC (32 bytes)</li>
</ul>

<p>All data is in network order (big-endian).</p>
","1277","<javascript><ios><cryptojs><rncryptor><sjcl>","3","0","1","2015-10-01 21:14:08","","3","","","","","2013-07-26 00:37:56",""
"31041214","End to End encryption using Codeigniter","<p>I'm working on a web app which will have very serious and sensitive data in it. How do I use Codeigniter on the backend and on the frontend some other library to encrypt data throughout the GET and SET process ( Client server encrypted )</p>

<p><a href=""https://mega.nz/#info"" rel=""nofollow"">https://mega.nz/#info</a></p>

<p>In this website they say they encrypt end to end. I do not know how to implement this.</p>

<p>Any thoughts on this please ? Any security gurus come up and give me a hand please</p>
","<p>I encrypt all my sensitive data (like ids, passwords, serial_numbers, etc.) from the backend to the front end, and when i retrieve data from the front end i just decrypt it, this way all clients that inspects my code in the front end, doesn't know the meaning of some parts, all this with some functions in a helper file, i don't know if this is what you are searching for </p>
","1248","<php><codeigniter><encryption><cryptojs><sjcl>","0","-2","1","2015-06-25 20:05:12","","5","","","","","2015-06-25 04:28:11",""
"28212246","JavaScript File Hash Value Generate with Part of the file","<p>I am working with JavaScript to generate File HASH VALUE for unique file values. Kindly check the below code for the Hash Generation Mechanism Which works good. </p>

<pre><code>&lt;script type=""text/javascript""&gt;
// Reference: https://code.google.com/p/crypto-js/#MD5
function handleFileSelect(evt) 
{   
    var files = evt.target.files; // FileList object
    // Loop through the FileList and render image files as thumbnails.
    for (var i = 0, f; f = files[i]; i++) 
    {
        var reader = new FileReader();
        // Closure to capture the file information.
        reader.onload = (function(theFile) 
        {
            return function(e) 
            {
                var span = document.createElement('span');
                var test = e.target.result;                 
                //var hash = hex_md5(test);
                var hash = CryptoJS.MD5(test);
                var elem = document.getElementById(""hashValue"");
                elem.value = hash;
            };
        })(f);
        // Read in the image file as a data URL.
        reader.readAsBinaryString(f);
    }
}
document.getElementById('videoupload').addEventListener('change', handleFileSelect, false);
&lt;/script&gt;
</code></pre>

<p>However I am facing problem when generating HASH VALUE for large files as in client side the browser Crashed.</p>

<p>Up-till 30MB the HASHING works well but if i try to upload larger than that the system crashes.</p>

<p><strong>My Question is:</strong></p>

<blockquote>
  <ol>
  <li><p>Can I generate HASH Value for part of file than reading the LARGE files and getting crashes? If yes, Can I know how to do that width
  'FileReader';</p></li>
  <li><p>Can I specify any amount of Byte such as 2000 Character of a file to generate HASH Value then generating for large files.</p></li>
  </ol>
</blockquote>

<p>I hope the above two solution will work for larger and small files. Is there any other options? </p>

<p><a href=""http://jsfiddle.net/ea091939/"" rel=""nofollow"">My Fiddle Demo</a></p>
","<blockquote>
  <ol>
  <li>Can I generate HASH Value for part of file than reading the LARGE files and getting crashes? If yes, Can I know how to do that width 'FileReader';</li>
  </ol>
</blockquote>

<p>Yes, you can do that and it is called <a href=""https://code.google.com/p/crypto-js/#Progressive_Hashing"" rel=""nofollow noreferrer"">Progressive Hashing</a>.</p>

<pre><code>var md5 = CryptoJS.algo.MD5.create();

md5.update(""file part 1"");
md5.update(""file part 2"");
md5.update(""file part 3"");

var hash = md5.finalize();
</code></pre>

<blockquote>
  <ol start=""2"">
  <li>Can I specify any amount of Byte such as 2000 Character of a file to generate HASH Value then generating for large files.</li>
  </ol>
</blockquote>

<p>There's an <a href=""http://www.html5rocks.com/en/tutorials/file/dndfiles/#toc-slicing-files"" rel=""nofollow noreferrer"">HTML5Rocks article</a> on how one can use <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Blob.slice"" rel=""nofollow noreferrer""><code>File.slice</code></a> to pass a sliced file to the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/FileReader"" rel=""nofollow noreferrer""><code>FileReader</code></a>:</p>

<pre><code>var blob = file.slice(startingByte, endindByte);
reader.readAsArrayBuffer(blob);
</code></pre>

<h2>Full solution</h2>

<p>I have combined both. The tricky part was to synchronize the file reading, because <a href=""https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer"" rel=""nofollow noreferrer""><code>FileReader.readAsArrayBuffer()</code></a> is asynchronous. I've written a small <code>series</code> function which is modeled after the <a href=""https://github.com/caolan/async#seriestasks-callback"" rel=""nofollow noreferrer""><code>series</code> function of async.js</a>. It has to be done one after the other, because there is is no way to get to the internal state of the hashing function of CryptoJS.</p>

<p>Additionally, CryptoJS doesn't understand what an <code>ArrayBuffer</code> is, so it has to be converted to its native data representation, which is the so-called WordArray:</p>

<pre><code>function arrayBufferToWordArray(ab) {
  var i8a = new Uint8Array(ab);
  var a = [];
  for (var i = 0; i &lt; i8a.length; i += 4) {
    a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]);
  }
  return CryptoJS.lib.WordArray.create(a, i8a.length);
}
</code></pre>

<p>The other thing is that hashing is a synchronous operation where there is no <code>yield</code> to continue execution elsewhere. Because of this, the browser will freeze since JavaScript is single threaded. The solution is to use <a href=""http://www.html5rocks.com/en/tutorials/workers/basics/"" rel=""nofollow noreferrer"">Web Workers</a> to off-load the hashing to a different thread so that the UI thread keeps responsive.<br>
Web workers expect the script file in their constructors, so I used <a href=""https://stackoverflow.com/a/10372280"">this solution</a> by Rob W to have an inline script.</p>

<pre><code>function series(tasks, done){
    if(!tasks || tasks.length === 0) {
        done();
    } else {
        tasks[0](function(){
            series(tasks.slice(1), done);
        });
    }
}

function webWorkerOnMessage(e){
    if (e.data.type === ""create"") {
        md5 = CryptoJS.algo.MD5.create();
        postMessage({type: ""create""});
    } else if (e.data.type === ""update"") {
        function arrayBufferToWordArray(ab) {
            var i8a = new Uint8Array(ab);
            var a = [];
            for (var i = 0; i &lt; i8a.length; i += 4) {
                a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]);
            }
            return CryptoJS.lib.WordArray.create(a, i8a.length);
        }
        md5.update(arrayBufferToWordArray(e.data.chunk));
        postMessage({type: ""update""});
    } else if (e.data.type === ""finish"") {
        postMessage({type: ""finish"", hash: """"+md5.finalize()});
    }
}

// URL.createObjectURL
window.URL = window.URL || window.webkitURL;

// ""Server response"", used in all examples
var response = 
    ""importScripts('https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/md5.js');""+
    ""var md5;""+
    ""self.onmessage = ""+webWorkerOnMessage.toString();

var blob;
try {
    blob = new Blob([response], {type: 'application/javascript'});
} catch (e) { // Backwards-compatibility
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
    blob = new BlobBuilder();
    blob.append(response);
    blob = blob.getBlob();
}
var worker = new Worker(URL.createObjectURL(blob));


var files = evt.target.files; // FileList object    
var chunksize = 1000000; // the chunk size doesn't make a difference
var i = 0, 
    f = files[i],
    chunks = Math.ceil(f.size / chunksize),
    chunkTasks = [],
    startTime = (new Date()).getTime();
worker.onmessage = function(e) {
    // create callback

    for(var j = 0; j &lt; chunks; j++){
        (function(j, f){
            chunkTasks.push(function(next){
                var blob = f.slice(j * chunksize, Math.min((j+1) * chunksize, f.size));
                var reader = new FileReader();

                reader.onload = function(e) {
                    var chunk = e.target.result;
                    worker.onmessage = function(e) {
                        // update callback
                        document.getElementById('num').innerHTML = """"+(j+1)+""/""+chunks;
                        next();
                    };
                    worker.postMessage({type: ""update"", chunk: chunk});
                };
                reader.readAsArrayBuffer(blob);
            });
        })(j, f);
    }
    series(chunkTasks, function(){
        var elem = document.getElementById(""hashValueSplit"");
        var telem = document.getElementById(""time"");
        worker.onmessage = function(e) {
            // finish callback
            elem.value = e.data.hash;
            telem.innerHTML = ""in "" + Math.ceil(((new Date()).getTime() - startTime) / 1000) + "" seconds"";
        };
        worker.postMessage({type: ""finish""});
    });

    // blocking way ahead...
    if (document.getElementById(""singleHash"").checked) {
        var reader = new FileReader();

        // Closure to capture the file information.
        reader.onloadend = (function(theFile) {
            function arrayBufferToWordArray(ab) {
                var i8a = new Uint8Array(ab);
                var a = [];
                for (var i = 0; i &lt; i8a.length; i += 4) {
                    a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]);
                }
                return CryptoJS.lib.WordArray.create(a, i8a.length);
            }
            return function(e) {
                var test = e.target.result;
                var hash = CryptoJS.MD5(arrayBufferToWordArray(test));
                //var hash = ""none"";
                var elem = document.getElementById(""hashValue"");
                elem.value = hash;
            };
        })(f);

        // Read in the image file as a data URL.
        reader.readAsArrayBuffer(f);
    }
};
worker.postMessage({type: ""create""});
</code></pre>

<p><a href=""http://jsfiddle.net/artjomb/g389tpdf/"" rel=""nofollow noreferrer""><strong>DEMO</strong></a> seems to work for big files, but it takes quite a lot of time. Maybe this can be improved using a faster MD5 implementation. It took around 23 minutes to hash a 3 GB file.</p>

<p><a href=""https://stackoverflow.com/a/33918579/1816580"">This answer of mine</a> shows an example without webworkers for SHA-256.</p>
","1246","<javascript><php><hash><md5><cryptojs>","3","5","1","2017-07-31 19:21:41","28213834","0","2","2090453","","2015-01-29 12:29:23","2015-01-29 10:24:13",""
"29927385","Spring 4 Encryptors vs cryptojs","<p>I am processing encryption using Spring 4 Encryptors class this way:</p>

<pre><code>String salt = KeyGenerators.string().generateKey();
TextEncryptor textEncryptor = Encryptors.text(""MY_SECRET_KEY"", salt);
textEncryptor.encrypt(json);
</code></pre>

<p>In the client javascript I am trying to decrypt using CryptoJS</p>

<pre><code>var uncrypted = CryptoJS.AES.decrypt(serverEncrypted, ""MY_SECRET_KEY"");
$(""#encrypted-data"").val(uncrypted);
</code></pre>

<p>I am guessing I need to revert the Hex encoding part, but I don't understand what needs to be done.</p>

<p>I tried parsing before decrypting, but nothing good out of it.</p>

<pre><code>CryptoJS.enc.Hex.parse(serverEncrypted)
</code></pre>

<p>The spring documentation says the text method will encrypt in the hex value in the ""standard"" encryption method and which is 256-bit AES using PKCS #5's PBKDF2</p>

<p><strong>[Search progress]</strong></p>

<p>This is how Spring creates its key:</p>

<pre><code>PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);
SecretKey secretKey = newSecretKey(""PBKDF2WithHmacSHA1"", keySpec);
SecretKeySpec secretKey = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
</code></pre>

<p>And the crypting:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));
</code></pre>

<p>iv is a 8 bytes secured random array and is prepended to the encrypted data.</p>
","<p>After some research, I find out a solution, how to combine Spring 4 Encryptors and CryptoJS.
Spring use in its Encryptors 256-bit AES using PKCS #5's PBKDF2 as provided in the documentation - <a href=""http://docs.spring.io/spring-security/site/docs/current/reference/html/crypto.html#spring-security-crypto-encryption"" rel=""nofollow noreferrer"">Spring Crypto docs</a> with IV size equals 16 bytes. That info is crucial when creating code in CryptoJS. Another thing to remember is to use the same salt and iv during whole process of encryption/decryption <strong>one message</strong>. Armed with this info we can start coding (in this example I encrypt message in CryptoJS and decrypt in Spring):
<em>CryptoJS</em></p>

<pre><code>const keySize = 256;
const ivSize = 128;
const iterations = 1024;

function encrypt(msg, pass) {
    const salt = CryptoJS.lib.WordArray.random(128 / 8);

    const key = CryptoJS.PBKDF2(pass, salt, {
        keySize: keySize / 32,
        iterations: iterations
    });

    const iv = CryptoJS.lib.WordArray.random(ivSize / 8);

    const encrypted = CryptoJS.AES.encrypt(msg, key, {
        iv: iv,
        padding: CryptoJS.pad.Pkcs7,
        mode: CryptoJS.mode.CBC

    });

    // salt, iv will be hex 32 in length
    // append them to the ciphertext for use  in decryption
    return salt.toString() + iv.toString() + encrypted.ciphertext.toString();
}
</code></pre>

<p>As you can see result of all encryption is concatenation of <em>salt</em> + <em>iv</em> + <em>encryptedMessage</em>. What is also important that in Spring code I found that key is created with 256 length and in 1024 iterations:</p>

<pre><code>PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), Hex.decode(salt), 1024, 256);
</code></pre>

<p>Now this prepared result we can take to our Spring code and decrypt:</p>

<pre><code>private static String decrypt(String encryptedData, String keyStr) {
        final String salt = encryptedData.substring(0, 32);
        final String encryptedPart = encryptedData.substring(32);
        final TextEncryptor textEncryptor = Encryptors.text(keyStr, salt);
        return textEncryptor.decrypt(encryptedPart);
}
</code></pre>

<p>Spring AES encryptor will cut part with IV and use it for decryption process by itself. Of course everything will has to be <em>Hex encoded</em>, but that's how Spring TextEncrytpors works.</p>

<p>The reverse procedure (encrypt in Spring and decrypt in CryptoJS) will be pretty much the same. In CryptoJS we have to extract <em>salt</em> and <em>iv</em>:</p>

<pre><code>const keySize = 256;

function decrypt (encryptedMessage, pass) {
  var salt = CryptoJS.enc.Hex.parse(encryptedMessage.substr(0, 32));
  var iv = CryptoJS.enc.Hex.parse(encryptedMessage.substr(32, 32))
  var encrypted = encryptedMessage.substring(64);

  var key = CryptoJS.PBKDF2(pass, salt, {
      keySize: keySize / 32,
      iterations: iterations
    });

  var decrypted = CryptoJS.AES.decrypt(encrypted, key, { 
    iv: iv, 
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC

  })
  return decrypted;
}
</code></pre>

<p>I hope it will help somebody :)</p>

<p>Cheers!</p>
","1237","<java><javascript><spring><encryption><cryptojs>","1","2","1","2017-04-16 09:57:38","","9","3","624980","","2015-04-29 13:40:21","2015-04-28 18:41:31",""
"52347404","create RSA SHA256 using crypto for jsonwebtoken on nodejs","<p>I see how to create HMAC 256 encrypted JWTs in NodeJS using Crypto, and the jsonwebtoken library. It's pretty easy</p>

<pre><code>    //encrypt &amp; sign with HS256
    const jwt   = require('jsonwebtoken');
    const pass  = crypto.randomBytes(256).toString('hex');
    const A     = {algorithm:'HS256'};

    const token = jwt.sign({ foo: 'bar' }, pass, A);

   //decrypt &amp; verify
   jwt.verify(token, pass, A, function(err, decoded)
   {
      console.log('decode ',decoded);
      console.log('err    ',err);

      res.send({error:err, text:decoded});
   });
</code></pre>

<p>I would like to replace 'pass' with an 'RSA 256 SHA', and A with {algorithm:'RS256'}</p>

<p>In node crypto JS's documentation I see the command</p>

<pre><code>const sign = crypto.createSign('RSA-SHA256');
</code></pre>

<p><a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">to create the rsa-sha256</a> </p>

<p>However then the documentation has the function</p>

<pre><code>getPrivateKeySomehow()
</code></pre>

<p>Which is not defined or part of crypto.getPrivateKeySomehow() </p>

<p>So I guess I just need help getting the RSA-SHA-256 string returned from crypto, so that I can pass that into jsonwebtoken to sign my JWT.</p>

<p><strong><em>Note:</em></strong> I do not want to read a private.key from a static file on my server because i see having a single private key for all my users as too big a security risk, hence why i am generating my own 256 bytes passwords and storing them off-site (not included in this post)</p>

<p>also, i'm not sure if i should do something like this (without using something like openssl from command line?)</p>

<pre><code>const begin = '-----BEGIN RSA PRIVATE KEY-----\n';
const enc   = crypto.randomBytes(256).toString('base64') + '\n';
const end   = '-----END RSA PRIVATE KEY-----'
const pass = sign.sign(begin + enc + end);
const A = {algorithm:'RS256'};
const token = jwt.sign({ foo: 'bar' }, pass, A);
</code></pre>
","<p>Take a look at this example bellow:</p>

<pre><code>signExample = (str) =&gt; {
    crypto.generateKeyPair('rsa', {
        modulusLength: 1024,
        publicKeyEncoding: {
        type: 'spki',
        format: 'pem'
        },
        privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem'
        }
    }, (err, publicKey, privateKey) =&gt; {
        // sign String
        var signerObject = crypto.createSign(""RSA-SHA256"");
        signerObject.update(str);
        var signature = signerObject.sign({key:privateKey,padding:crypto.constants.RSA_PKCS1_PSS_PADDING}, ""base64"");
        console.info(""signature: %s"", signature);
        //verify String
        var verifierObject = crypto.createVerify(""RSA-SHA256"");
        verifierObject.update(str);
        var verified = verifierObject.verify({key:publicKey, padding:crypto.constants.RSA_PKCS1_PSS_PADDING}, signature, ""base64"");
        console.info(""is signature ok?: %s"", verified);
    });
}
</code></pre>

<p>Steps:</p>

<ul>
<li>First you create an key pair with crypto.generateKeyPair('rsa', { ... desired key options</li>
<li>Create a Sign object - crypto.createSign(""RSA-SHA256"")</li>
<li>The string wanted to be signed - SignerObject.update(str)</li>
<li>Sign the string with your private key - signerObject.sign( </li>
<li>Option to salt - padding:crypto.constants.RSA_PKCS1_PSS_PADDING</li>
</ul>
","1227","<node.js><encryption><jwt><cryptojs>","0","1","1","2019-06-01 02:17:25","","0","","1709076","","2018-09-15 18:16:25","2018-09-15 17:57:06",""
"20359212","Making CryptoJS and pycrypto compatible","<p>I'm trying to figure out how to use the CryptoJS library for AES but the documentation is somewhat scarce.</p>

<p>I've followed their example but I can't seem to decode something that I encoded in PyCrypto</p>

<p>I've formatted as follows:</p>

<pre><code>key = '0f3f0fe38eb5f216cb4ef0649f81d761'
ciphertext = 'Y+gwBI6R37Ko1lQmwZ57gg==FqUSqQ=='
</code></pre>

<p>The ciphertext has two components</p>

<pre><code>iv: Y+gwBI6R37Ko1lQmwZ57gg==
encoded message: FqUSqQ==
</code></pre>

<p>I tried running the code below but it didn't work. It logs """" in the console. It should be resolving to 'Test'</p>

<pre><code>var decrypted =CryptoJS.AES.decrypt(ciphertext, key);
console.log( decrypted.toString(CryptoJS.enc.Utf8) );
</code></pre>

<p>Any pointers would great. Thanks</p>
","<p>I don't have direct experience with CryptoJS, but many years of experience with a variety of other crypto libraries.  It's almost certainly the case the CryptoJS.AES.decrypt expects a different ciphertext format than the one you're using.  Your ciphertext is the contanenation of two separate Base64-encoded entities:</p>

<p>Base64(IV) + Base64(Enc(Message))</p>

<p>If CryptoJS.AES.decrypt expects the IV to be specified as part of the ciphertext (which it may not), and expects Base64-encoded ciphertext input at all (which it may not), then I would try passing:</p>

<p>Base64( (binary IV) + (binary Enc(Message)) )</p>

<p>Looking at the CryptoJS doc, I share your frustration with it.  But there's an encryption example with ""manually specified IV"" that may provide a clue.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
    var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');

    var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });
&lt;/script&gt;
</code></pre>

<p>Sorry I can't be more helpful-</p>
","1223","<javascript><python><aes><pycrypto><cryptojs>","0","0","2","2013-12-18 21:51:37","20669193","0","","2465313","","2013-12-04 19:43:36","2013-12-03 18:47:43",""
"20359212","Making CryptoJS and pycrypto compatible","<p>I'm trying to figure out how to use the CryptoJS library for AES but the documentation is somewhat scarce.</p>

<p>I've followed their example but I can't seem to decode something that I encoded in PyCrypto</p>

<p>I've formatted as follows:</p>

<pre><code>key = '0f3f0fe38eb5f216cb4ef0649f81d761'
ciphertext = 'Y+gwBI6R37Ko1lQmwZ57gg==FqUSqQ=='
</code></pre>

<p>The ciphertext has two components</p>

<pre><code>iv: Y+gwBI6R37Ko1lQmwZ57gg==
encoded message: FqUSqQ==
</code></pre>

<p>I tried running the code below but it didn't work. It logs """" in the console. It should be resolving to 'Test'</p>

<pre><code>var decrypted =CryptoJS.AES.decrypt(ciphertext, key);
console.log( decrypted.toString(CryptoJS.enc.Utf8) );
</code></pre>

<p>Any pointers would great. Thanks</p>
","<p>I ran into this problem as well and unfortunately it was very tricky to get <code>pycrypto</code> to talk to <code>crypto-js</code>.  Here are the combination that worked for me:</p>

<ol>
<li>Use <code>MODE_CFB</code> with <code>segment_size=128</code> when encrypting in Python</li>
<li>You must pad your string with Pkcs7 as per RFC 2315 [Page 21]</li>
<li>Once you have received the base64 version of ciphertext in JS, you need to wrap it in
<code>CryptoJS.lib.CipherParams.create({ ... })</code></li>
</ol>

<p>Take a look at the code that works for me (Python 2.7.x):<br>
<a href=""https://gist.github.com/marcoslin/8026990"" rel=""nofollow"">https://gist.github.com/marcoslin/8026990</a></p>
","1223","<javascript><python><aes><pycrypto><cryptojs>","0","2","2","2013-12-18 21:51:37","20669193","0","","2465313","","2013-12-04 19:43:36","2013-12-03 18:47:43",""
"51953592","SHA256 is undefined","<p>I was experimenting with CryptoJS library and came across with the problem that my imported hash function isn't visible inside a class. Here's my code:</p>

<pre><code>CryptoJS = require('crypto-js');
SHA256 = require('crypto-js/sha256');

class trCrypt {
  constructor(input,key) {
this.input = input;
this.key = SHA512(key).toString();
  }
  encrypt(){
    this.step1 = CryptoJS.AES.encrypt(this.input,this.key);
    return this.step1.toString()
  }
  decrypt(){
    const bytes =  CryptoJS.AES.decrypt(this.step1);
    this.dec1 = bytes.toString(CryptoJS.enc.Utf8);
    return this.dec1
  }
}
a = new trCrypt('hello','world');
console.log(a.encrypt());
console.log(a.decrypt());
</code></pre>

<p>[SOLVED] Thanks for answer!</p>
","<p>In your code you've imported the CryptoJs module and the SHA256 function, but you've not imported the SHA512 function.</p>

<p>Try adding:</p>

<pre><code>SHA512 = require('crypto-js/sha512');
</code></pre>

<p>On top of the script</p>
","1218","<javascript><node.js><aes><sha256><cryptojs>","0","2","1","2018-08-22 10:21:03","51953666","3","","9950309","","2018-08-22 10:21:03","2018-08-21 17:06:10",""
"41001901","How can I compare encrypted password strings correctly?","<p>I have a basic html page with a username and password input boxes. Along with a login button. I am using <code>cryptojs</code> to try and compare encryption strings.</p>

<p>I believe my problem is because I'm randomly generating my key and iv. Do y'all have any suggestions on what I could change? </p>

<pre><code>app.post('/authenticate',function(req,res){
conn.open(connString, function(err){
if(err) return console.log(err);

var loginID = req.body.LoginID,
    passWord = req.body.PassWord;

//-------------------------Security---------------------------
    // create random Word Arrays for key and Salt
    var key = CryptoJS.lib.WordArray.random(16);
    var iv  = CryptoJS.lib.WordArray.random(16);

    // Encrypt Password using key and Salt. Changes every time but will always decrypt to same password.
    var encrypted = CryptoJS.AES.encrypt(passWord, key, { iv: iv }).toString();
    var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv }).toString();

    console.log(decrypted);

//-------------------------END Security------------------------    

conn.query(""SELECT PassWord from pub.User WHERE LoginID ='"" + loginID  + ""'"",function(err,data){

    if(err) return console.log(err);   
    res.json(data);

    setValue(data);

    function setValue(value) {
    someVar = value;
    }
        for(key in someVar) {
            if(someVar.hasOwnProperty(key)) {
                var value = someVar[key];
                console.log(value.PassWord);
                console.log(encrypted);

                    if(value.PassWord == encrypted)
                    {
                        console.log(""pass"");
                    }
                    else
                    {
                        console.log(""Fail"");
                    }
            }
        }

        conn.close(function(){
        console.log('Login Complete');
        }); 
    }); // conn.query

}); //END conn.open(connString, function(err){
}); // END app.post('/authenticate'
</code></pre>

<p>Thank You,</p>
","<p>Why did you choose Cryptojs?, I think there are better alternatives, like Bcrypt (that is what I commonly use), they expose a function to compare the string directly with the hash value, and that's it.</p>

<p>Give it a try: <a href=""https://www.npmjs.com/package/bcrypt"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/bcrypt</a></p>
","1209","<javascript><node.js><cryptojs>","1","-1","2","2016-12-07 12:53:02","41002001","1","","7258499","","2016-12-07 12:53:02","2016-12-06 18:01:07",""
"41001901","How can I compare encrypted password strings correctly?","<p>I have a basic html page with a username and password input boxes. Along with a login button. I am using <code>cryptojs</code> to try and compare encryption strings.</p>

<p>I believe my problem is because I'm randomly generating my key and iv. Do y'all have any suggestions on what I could change? </p>

<pre><code>app.post('/authenticate',function(req,res){
conn.open(connString, function(err){
if(err) return console.log(err);

var loginID = req.body.LoginID,
    passWord = req.body.PassWord;

//-------------------------Security---------------------------
    // create random Word Arrays for key and Salt
    var key = CryptoJS.lib.WordArray.random(16);
    var iv  = CryptoJS.lib.WordArray.random(16);

    // Encrypt Password using key and Salt. Changes every time but will always decrypt to same password.
    var encrypted = CryptoJS.AES.encrypt(passWord, key, { iv: iv }).toString();
    var decrypted = CryptoJS.AES.decrypt(encrypted, key, { iv: iv }).toString();

    console.log(decrypted);

//-------------------------END Security------------------------    

conn.query(""SELECT PassWord from pub.User WHERE LoginID ='"" + loginID  + ""'"",function(err,data){

    if(err) return console.log(err);   
    res.json(data);

    setValue(data);

    function setValue(value) {
    someVar = value;
    }
        for(key in someVar) {
            if(someVar.hasOwnProperty(key)) {
                var value = someVar[key];
                console.log(value.PassWord);
                console.log(encrypted);

                    if(value.PassWord == encrypted)
                    {
                        console.log(""pass"");
                    }
                    else
                    {
                        console.log(""Fail"");
                    }
            }
        }

        conn.close(function(){
        console.log('Login Complete');
        }); 
    }); // conn.query

}); //END conn.open(connString, function(err){
}); // END app.post('/authenticate'
</code></pre>

<p>Thank You,</p>
","<p>You are correct. By using a randomly generated key/iv, your <code>encrypted</code> password string will always be different, even though it will <code>decrypt</code> to the same value. So, you won't be able to compare encrypted strings the way you are doing it.</p>

<p>I think the first question you should ask yourself is, do you really need to be able to decrypt your passwords once they are stored in the database? If not, you might be better off using a simple hash. You can use Node's built-in <code>Crypto</code> package for that -- and that is what I typically use to store hashed passwords. I have a few utility methods that I put into a <code>Utils</code> package, like:</p>

<pre class=""lang-js prettyprint-override""><code>const crypto = require('crypto');

/**
 * hashPassword creates a password hash from the supplied password and
 * salt values.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {string}
 */
function hashPassword(password, salt) {
    let seed = sha1Base64(password, salt);
    return sha256Hex(seed);
}

/**
 * sha1Base64 returns a signature using the supplied string and key.
 *
 * @param {string} str
 * @param {string} key
 * @returns {string}
 */
function sha1Base64(str, key) {
    return crypto.createHmac('sha1', key)
        .update(new Buffer(str, 'utf8'))
        .digest('base64');
}

/**
 * sha256Hex returns a string hash of the supplied data.
 *
 * @param {string|number|object} data
 * @returns {string}
 */
function sha256Hex(data) {
    return crypto.createHash('sha256')
        .update(data)
        .digest('hex');
}
</code></pre>

<p>The <code>hashPassword</code> function will create a 64 character string of hex digits. You get the general idea of hashing the password to store it in the database and then hashing the user's password on submission of the login form. Same thing here, only this doesn't require any outside packages. </p>

<p>However, you will still need to use the same salt each time. You can assign a system-wide salt through an environment variable (more secure), keep one in the database either on a per-user or per-account basis (less secure), or put one in a config file somewhere (probably a bad idea). It really depends on what you are trying to protect as to how fanatical you have to be -- are you creating a login area for a personal blog or a consumer-facing website for Chase Bank? Just make sure your salt is sufficiently long and random. You can use a function to generate a random string of whatever length you want:</p>

<pre class=""lang-js prettyprint-override""><code>/**
 * randomString returns a random alphanumeric string of the specified length.
 *
 * @param {number} [length]
 * @param {boolean} [special]
 * @returns {string}
 */
function randomString(length = 10, special = false) {
    let chars = 'abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    if (special) chars += '-_%!@#$^&amp;*';
    let cLength = chars.length,
        sRandom = '';
    for (let i = 0; i &lt; length; i++) {
        sRandom += chars[Math.floor(Math.random() * cLength)];
    }

    return sRandom;
}
</code></pre>

<p>For most of the stuff I've ever done, using a hash like this is sufficient.</p>

<p>Hope this helps!</p>
","1209","<javascript><node.js><cryptojs>","1","0","2","2016-12-07 12:53:02","41002001","1","","7258499","","2016-12-07 12:53:02","2016-12-06 18:01:07",""
"20522661","How to calculate a 256-bit HMAC_SHA3 hash with CryptoJS?","<p>Recent CryptoJS versions support SHA3 hashing. </p>

<p>SHA3 can output different hash sizes, including 512-bit (default) and 256-bit. These two work fine:</p>

<pre><code>var sha3_512_hash = CryptoJS.SHA3( 'test' );
var sha3_256_hash = CryptoJS.SHA3( 'test' , { outputLength:256 } );
</code></pre>

<p>Similarly, CryptoJS can also calculate HMAC values. However, I can't figure out how to change the default output size there:</p>

<pre><code>var sha3_512_hmac = CryptoJS.HmacSHA3( 'test' , 'key' );
var sha3_256_hmac = CryptoJS.HmacSHA3( 'test' , 'key' , { outputLength:256 } );
</code></pre>

<p>The first works OK (the result is a 512-bit hmac value) but the second is the <em>same</em> (i.e. also 512-bit), as if it ignores the {outputLength:256} parameter!</p>

<p>Here's a live example: <a href=""http://jsfiddle.net/M8xf3/"" rel=""nofollow"">http://jsfiddle.net/M8xf3/</a> (using hmac-sha3.js from CryptoJS 3.1.2)</p>

<p>Does anyone know how to create 256-bit SHA3-based HMAC hashes?</p>

<p>P.S. For the SHA2 family of functions, CryptoJS has separate Hmac functions for each output size (that's HmacSHA256 and HmacSHA512). But this doesn't seem to be the case for SHA3?</p>
","<p>This doesn't answer the actual question, but note that with SHA3 you don't really need HMAC hashes. Unlike SHA1 and SHA2 and MD5, SHA3 is <em>not</em> vulnerable to length-extension attacks.</p>

<p>Therefore with SHA3 it would suffice to just prepend or append the secret key to your input.</p>

<p>Or, if you're paranoid of a single hash step becoming compromised (not to be expected in the foreseeable future, especially not with SHA3, but still) you could do something like SHA3(key+SHA3(key+data)) or SHA3(key+SHA3(key+data)+data) (obviously with ""+"" denoting binary concatenation).</p>
","1194","<hash><sha><hmac><cryptojs>","1","2","2","2014-05-19 16:16:11","","0","","1072269","","2013-12-11 15:35:47","2013-12-11 15:09:02",""
"20522661","How to calculate a 256-bit HMAC_SHA3 hash with CryptoJS?","<p>Recent CryptoJS versions support SHA3 hashing. </p>

<p>SHA3 can output different hash sizes, including 512-bit (default) and 256-bit. These two work fine:</p>

<pre><code>var sha3_512_hash = CryptoJS.SHA3( 'test' );
var sha3_256_hash = CryptoJS.SHA3( 'test' , { outputLength:256 } );
</code></pre>

<p>Similarly, CryptoJS can also calculate HMAC values. However, I can't figure out how to change the default output size there:</p>

<pre><code>var sha3_512_hmac = CryptoJS.HmacSHA3( 'test' , 'key' );
var sha3_256_hmac = CryptoJS.HmacSHA3( 'test' , 'key' , { outputLength:256 } );
</code></pre>

<p>The first works OK (the result is a 512-bit hmac value) but the second is the <em>same</em> (i.e. also 512-bit), as if it ignores the {outputLength:256} parameter!</p>

<p>Here's a live example: <a href=""http://jsfiddle.net/M8xf3/"" rel=""nofollow"">http://jsfiddle.net/M8xf3/</a> (using hmac-sha3.js from CryptoJS 3.1.2)</p>

<p>Does anyone know how to create 256-bit SHA3-based HMAC hashes?</p>

<p>P.S. For the SHA2 family of functions, CryptoJS has separate Hmac functions for each output size (that's HmacSHA256 and HmacSHA512). But this doesn't seem to be the case for SHA3?</p>
","<p>You can just edit hmac-sha3.js and change the outputLength to 256-bit instead of 512-bit.</p>

<ol>
<li>Open hmac-sha3.js file, using your text editor.</li>
<li>Find ""{outputLength:512}"" and replace it with ""{outputLength:256}""</li>
</ol>

<p>Then the hash output will be 256-bit in length.</p>

<p>To be sure that you did not messed up things, double check your 256-bit hmac-sha3 output with some test cases available on the internet, for example: <a href=""http://www.di-mgt.com.au/hmac_sha3_testvectors.html"" rel=""nofollow"">http://www.di-mgt.com.au/hmac_sha3_testvectors.html</a></p>
","1194","<hash><sha><hmac><cryptojs>","1","1","2","2014-05-19 16:16:11","","0","","1072269","","2013-12-11 15:35:47","2013-12-11 15:09:02",""
"45082857","Crypto-JS hash functions return object","<p>I'm trying to hash a string using the crypto-js library in a react/typescript project. I'm using crypto-js 3.1.9 and @types/crypto-js 3.1.33.</p>

<p>Here's some code: </p>

<pre><code>import CryptoJS = require(""crypto-js"");

export const hashString= (str: string): string =&gt; {
  const hash = CryptoJS.MD5(str);
  return hash;
}
</code></pre>

<p>I expect <code>hash</code> to be of type string, as specified in the documentation of the crypto-js implementation. But the function returns an object, that contains a wordarray. </p>

<p>I also tried calling</p>

<pre><code>hash.toString(CryptoJS.enc.Hex) 
</code></pre>

<p>but that didn't work, because typescript also assumes that <code>hash</code> will be a string. So a parameterized <code>toString</code> function is not allowed. </p>

<p>What am I doing wrong?</p>
","","1193","<javascript><typescript><cryptojs>","5","","0","2017-07-13 14:02:37","","3","","","","","2017-07-13 13:57:30",""
"47240110","CryptoJS is not defined at","<p>I am trying to use DES encryption/decryption on Google chrome. In my folder I have three files.</p>

<ol>
<li>tripledes.js</li>
<li>mode-ecb.js</li>
<li>CryptoJS-DES.html</li>
</ol>

<p>The scripts in my html file is defined as follows :-</p>

<pre><code>&lt;script type=""text/javascript"" src=""tripledes.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""mode-ecb.js""&gt;&lt;/script&gt;
</code></pre>

<p>and another script file which is :-
    
    function encryptByDES(message, key) {</p>

<pre><code>var keyHex = CryptoJS.enc.Utf8.parse(key);

var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});

return encrypted.toString();
}

function decryptByDES(ciphertext, key) {
var keyHex = CryptoJS.enc.Utf8.parse(key);

// direct decrypt ciphertext
var decrypted = CryptoJS.DES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(ciphertext)
}, keyHex, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});

return decrypted.toString(CryptoJS.enc.Utf8);
}

var message = 'Message';
var key = 'abcd1234';

var ciphertext = encryptByDES(message, key);
// ciphertext: 8dKft9vkZ4I=
console.log('ciphertext:', ciphertext);
var plaintext = decryptByDES(ciphertext, key);
// plaintext : Message
console.log('plaintext :', plaintext);
&lt;/script&gt;
</code></pre>

<p>The <strong>des.js</strong> file is as follows
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>(function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo;

    // Permuted Choice 1 constants
    var PC1 = [
        57, 49, 41, 33, 25, 17, 9,  1,
        58, 50, 42, 34, 26, 18, 10, 2,
        59, 51, 43, 35, 27, 19, 11, 3,
        60, 52, 44, 36, 63, 55, 47, 39,
        31, 23, 15, 7,  62, 54, 46, 38,
        30, 22, 14, 6,  61, 53, 45, 37,
        29, 21, 13, 5,  28, 20, 12, 4
    ];

    // Permuted Choice 2 constants
    var PC2 = [
        14, 17, 11, 24, 1,  5,
        3,  28, 15, 6,  21, 10,
        23, 19, 12, 4,  26, 8,
        16, 7,  27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ];

    // Cumulative bit shift constants
    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

    // SBOXes and round permutation constants
    var SBOX_P = [
        {
            0x0: 0x808200,
            0x10000000: 0x8000,
            0x20000000: 0x808002,
            0x30000000: 0x2,
            0x40000000: 0x200,
            0x50000000: 0x808202,
            0x60000000: 0x800202,
            0x70000000: 0x800000,
            0x80000000: 0x202,
            0x90000000: 0x800200,
            0xa0000000: 0x8200,
            0xb0000000: 0x808000,
            0xc0000000: 0x8002,
            0xd0000000: 0x800002,
            0xe0000000: 0x0,
            0xf0000000: 0x8202,
            0x8000000: 0x0,
            0x18000000: 0x808202,
            0x28000000: 0x8202,
            0x38000000: 0x8000,
            0x48000000: 0x808200,
            0x58000000: 0x200,
            0x68000000: 0x808002,
            0x78000000: 0x2,
            0x88000000: 0x800200,
            0x98000000: 0x8200,
            0xa8000000: 0x808000,
            0xb8000000: 0x800202,
            0xc8000000: 0x800002,
            0xd8000000: 0x8002,
            0xe8000000: 0x202,
            0xf8000000: 0x800000,
            0x1: 0x8000,
            0x10000001: 0x2,
            0x20000001: 0x808200,
            0x30000001: 0x800000,
            0x40000001: 0x808002,
            0x50000001: 0x8200,
            0x60000001: 0x200,
            0x70000001: 0x800202,
            0x80000001: 0x808202,
            0x90000001: 0x808000,
            0xa0000001: 0x800002,
            0xb0000001: 0x8202,
            0xc0000001: 0x202,
            0xd0000001: 0x800200,
            0xe0000001: 0x8002,
            0xf0000001: 0x0,
            0x8000001: 0x808202,
            0x18000001: 0x808000,
            0x28000001: 0x800000,
            0x38000001: 0x200,
            0x48000001: 0x8000,
            0x58000001: 0x800002,
            0x68000001: 0x2,
            0x78000001: 0x8202,
            0x88000001: 0x8002,
            0x98000001: 0x800202,
            0xa8000001: 0x202,
            0xb8000001: 0x808200,
            0xc8000001: 0x800200,
            0xd8000001: 0x0,
            0xe8000001: 0x8200,
            0xf8000001: 0x808002
        },
        {
            0x0: 0x40084010,
            0x1000000: 0x4000,
            0x2000000: 0x80000,
            0x3000000: 0x40080010,
            0x4000000: 0x40000010,
            0x5000000: 0x40084000,
            0x6000000: 0x40004000,
            0x7000000: 0x10,
            0x8000000: 0x84000,
            0x9000000: 0x40004010,
            0xa000000: 0x40000000,
            0xb000000: 0x84010,
            0xc000000: 0x80010,
            0xd000000: 0x0,
            0xe000000: 0x4010,
            0xf000000: 0x40080000,
            0x800000: 0x40004000,
            0x1800000: 0x84010,
            0x2800000: 0x10,
            0x3800000: 0x40004010,
            0x4800000: 0x40084010,
            0x5800000: 0x40000000,
            0x6800000: 0x80000,
            0x7800000: 0x40080010,
            0x8800000: 0x80010,
            0x9800000: 0x0,
            0xa800000: 0x4000,
            0xb800000: 0x40080000,
            0xc800000: 0x40000010,
            0xd800000: 0x84000,
            0xe800000: 0x40084000,
            0xf800000: 0x4010,
            0x10000000: 0x0,
            0x11000000: 0x40080010,
            0x12000000: 0x40004010,
            0x13000000: 0x40084000,
            0x14000000: 0x40080000,
            0x15000000: 0x10,
            0x16000000: 0x84010,
            0x17000000: 0x4000,
            0x18000000: 0x4010,
            0x19000000: 0x80000,
            0x1a000000: 0x80010,
            0x1b000000: 0x40000010,
            0x1c000000: 0x84000,
            0x1d000000: 0x40004000,
            0x1e000000: 0x40000000,
            0x1f000000: 0x40084010,
            0x10800000: 0x84010,
            0x11800000: 0x80000,
            0x12800000: 0x40080000,
            0x13800000: 0x4000,
            0x14800000: 0x40004000,
            0x15800000: 0x40084010,
            0x16800000: 0x10,
            0x17800000: 0x40000000,
            0x18800000: 0x40084000,
            0x19800000: 0x40000010,
            0x1a800000: 0x40004010,
            0x1b800000: 0x80010,
            0x1c800000: 0x0,
            0x1d800000: 0x4010,
            0x1e800000: 0x40080010,
            0x1f800000: 0x84000
        },
        {
            0x0: 0x104,
            0x100000: 0x0,
            0x200000: 0x4000100,
            0x300000: 0x10104,
            0x400000: 0x10004,
            0x500000: 0x4000004,
            0x600000: 0x4010104,
            0x700000: 0x4010000,
            0x800000: 0x4000000,
            0x900000: 0x4010100,
            0xa00000: 0x10100,
            0xb00000: 0x4010004,
            0xc00000: 0x4000104,
            0xd00000: 0x10000,
            0xe00000: 0x4,
            0xf00000: 0x100,
            0x80000: 0x4010100,
            0x180000: 0x4010004,
            0x280000: 0x0,
            0x380000: 0x4000100,
            0x480000: 0x4000004,
            0x580000: 0x10000,
            0x680000: 0x10004,
            0x780000: 0x104,
            0x880000: 0x4,
            0x980000: 0x100,
            0xa80000: 0x4010000,
            0xb80000: 0x10104,
            0xc80000: 0x10100,
            0xd80000: 0x4000104,
            0xe80000: 0x4010104,
            0xf80000: 0x4000000,
            0x1000000: 0x4010100,
            0x1100000: 0x10004,
            0x1200000: 0x10000,
            0x1300000: 0x4000100,
            0x1400000: 0x100,
            0x1500000: 0x4010104,
            0x1600000: 0x4000004,
            0x1700000: 0x0,
            0x1800000: 0x4000104,
            0x1900000: 0x4000000,
            0x1a00000: 0x4,
            0x1b00000: 0x10100,
            0x1c00000: 0x4010000,
            0x1d00000: 0x104,
            0x1e00000: 0x10104,
            0x1f00000: 0x4010004,
            0x1080000: 0x4000000,
            0x1180000: 0x104,
            0x1280000: 0x4010100,
            0x1380000: 0x0,
            0x1480000: 0x10004,
            0x1580000: 0x4000100,
            0x1680000: 0x100,
            0x1780000: 0x4010004,
            0x1880000: 0x10000,
            0x1980000: 0x4010104,
            0x1a80000: 0x10104,
            0x1b80000: 0x4000004,
            0x1c80000: 0x4000104,
            0x1d80000: 0x4010000,
            0x1e80000: 0x4,
            0x1f80000: 0x10100
        },
        {
            0x0: 0x80401000,
            0x10000: 0x80001040,
            0x20000: 0x401040,
            0x30000: 0x80400000,
            0x40000: 0x0,
            0x50000: 0x401000,
            0x60000: 0x80000040,
            0x70000: 0x400040,
            0x80000: 0x80000000,
            0x90000: 0x400000,
            0xa0000: 0x40,
            0xb0000: 0x80001000,
            0xc0000: 0x80400040,
            0xd0000: 0x1040,
            0xe0000: 0x1000,
            0xf0000: 0x80401040,
            0x8000: 0x80001040,
            0x18000: 0x40,
            0x28000: 0x80400040,
            0x38000: 0x80001000,
            0x48000: 0x401000,
            0x58000: 0x80401040,
            0x68000: 0x0,
            0x78000: 0x80400000,
            0x88000: 0x1000,
            0x98000: 0x80401000,
            0xa8000: 0x400000,
            0xb8000: 0x1040,
            0xc8000: 0x80000000,
            0xd8000: 0x400040,
            0xe8000: 0x401040,
            0xf8000: 0x80000040,
            0x100000: 0x400040,
            0x110000: 0x401000,
            0x120000: 0x80000040,
            0x130000: 0x0,
            0x140000: 0x1040,
            0x150000: 0x80400040,
            0x160000: 0x80401000,
            0x170000: 0x80001040,
            0x180000: 0x80401040,
            0x190000: 0x80000000,
            0x1a0000: 0x80400000,
            0x1b0000: 0x401040,
            0x1c0000: 0x80001000,
            0x1d0000: 0x400000,
            0x1e0000: 0x40,
            0x1f0000: 0x1000,
            0x108000: 0x80400000,
            0x118000: 0x80401040,
            0x128000: 0x0,
            0x138000: 0x401000,
            0x148000: 0x400040,
            0x158000: 0x80000000,
            0x168000: 0x80001040,
            0x178000: 0x40,
            0x188000: 0x80000040,
            0x198000: 0x1000,
            0x1a8000: 0x80001000,
            0x1b8000: 0x80400040,
            0x1c8000: 0x1040,
            0x1d8000: 0x80401000,
            0x1e8000: 0x400000,
            0x1f8000: 0x401040
        },
        {
            0x0: 0x80,
            0x1000: 0x1040000,
            0x2000: 0x40000,
            0x3000: 0x20000000,
            0x4000: 0x20040080,
            0x5000: 0x1000080,
            0x6000: 0x21000080,
            0x7000: 0x40080,
            0x8000: 0x1000000,
            0x9000: 0x20040000,
            0xa000: 0x20000080,
            0xb000: 0x21040080,
            0xc000: 0x21040000,
            0xd000: 0x0,
            0xe000: 0x1040080,
            0xf000: 0x21000000,
            0x800: 0x1040080,
            0x1800: 0x21000080,
            0x2800: 0x80,
            0x3800: 0x1040000,
            0x4800: 0x40000,
            0x5800: 0x20040080,
            0x6800: 0x21040000,
            0x7800: 0x20000000,
            0x8800: 0x20040000,
            0x9800: 0x0,
            0xa800: 0x21040080,
            0xb800: 0x1000080,
            0xc800: 0x20000080,
            0xd800: 0x21000000,
            0xe800: 0x1000000,
            0xf800: 0x40080,
            0x10000: 0x40000,
            0x11000: 0x80,
            0x12000: 0x20000000,
            0x13000: 0x21000080,
            0x14000: 0x1000080,
            0x15000: 0x21040000,
            0x16000: 0x20040080,
            0x17000: 0x1000000,
            0x18000: 0x21040080,
            0x19000: 0x21000000,
            0x1a000: 0x1040000,
            0x1b000: 0x20040000,
            0x1c000: 0x40080,
            0x1d000: 0x20000080,
            0x1e000: 0x0,
            0x1f000: 0x1040080,
            0x10800: 0x21000080,
            0x11800: 0x1000000,
            0x12800: 0x1040000,
            0x13800: 0x20040080,
            0x14800: 0x20000000,
            0x15800: 0x1040080,
            0x16800: 0x80,
            0x17800: 0x21040000,
            0x18800: 0x40080,
            0x19800: 0x21040080,
            0x1a800: 0x0,
            0x1b800: 0x21000000,
            0x1c800: 0x1000080,
            0x1d800: 0x40000,
            0x1e800: 0x20040000,
            0x1f800: 0x20000080
        },
        {
            0x0: 0x10000008,
            0x100: 0x2000,
            0x200: 0x10200000,
            0x300: 0x10202008,
            0x400: 0x10002000,
            0x500: 0x200000,
            0x600: 0x200008,
            0x700: 0x10000000,
            0x800: 0x0,
            0x900: 0x10002008,
            0xa00: 0x202000,
            0xb00: 0x8,
            0xc00: 0x10200008,
            0xd00: 0x202008,
            0xe00: 0x2008,
            0xf00: 0x10202000,
            0x80: 0x10200000,
            0x180: 0x10202008,
            0x280: 0x8,
            0x380: 0x200000,
            0x480: 0x202008,
            0x580: 0x10000008,
            0x680: 0x10002000,
            0x780: 0x2008,
            0x880: 0x200008,
            0x980: 0x2000,
            0xa80: 0x10002008,
            0xb80: 0x10200008,
            0xc80: 0x0,
            0xd80: 0x10202000,
            0xe80: 0x202000,
            0xf80: 0x10000000,
            0x1000: 0x10002000,
            0x1100: 0x10200008,
            0x1200: 0x10202008,
            0x1300: 0x2008,
            0x1400: 0x200000,
            0x1500: 0x10000000,
            0x1600: 0x10000008,
            0x1700: 0x202000,
            0x1800: 0x202008,
            0x1900: 0x0,
            0x1a00: 0x8,
            0x1b00: 0x10200000,
            0x1c00: 0x2000,
            0x1d00: 0x10002008,
            0x1e00: 0x10202000,
            0x1f00: 0x200008,
            0x1080: 0x8,
            0x1180: 0x202000,
            0x1280: 0x200000,
            0x1380: 0x10000008,
            0x1480: 0x10002000,
            0x1580: 0x2008,
            0x1680: 0x10202008,
            0x1780: 0x10200000,
            0x1880: 0x10202000,
            0x1980: 0x10200008,
            0x1a80: 0x2000,
            0x1b80: 0x202008,
            0x1c80: 0x200008,
            0x1d80: 0x0,
            0x1e80: 0x10000000,
            0x1f80: 0x10002008
        },
        {
            0x0: 0x100000,
            0x10: 0x2000401,
            0x20: 0x400,
            0x30: 0x100401,
            0x40: 0x2100401,
            0x50: 0x0,
            0x60: 0x1,
            0x70: 0x2100001,
            0x80: 0x2000400,
            0x90: 0x100001,
            0xa0: 0x2000001,
            0xb0: 0x2100400,
            0xc0: 0x2100000,
            0xd0: 0x401,
            0xe0: 0x100400,
            0xf0: 0x2000000,
            0x8: 0x2100001,
            0x18: 0x0,
            0x28: 0x2000401,
            0x38: 0x2100400,
            0x48: 0x100000,
            0x58: 0x2000001,
            0x68: 0x2000000,
            0x78: 0x401,
            0x88: 0x100401,
            0x98: 0x2000400,
            0xa8: 0x2100000,
            0xb8: 0x100001,
            0xc8: 0x400,
            0xd8: 0x2100401,
            0xe8: 0x1,
            0xf8: 0x100400,
            0x100: 0x2000000,
            0x110: 0x100000,
            0x120: 0x2000401,
            0x130: 0x2100001,
            0x140: 0x100001,
            0x150: 0x2000400,
            0x160: 0x2100400,
            0x170: 0x100401,
            0x180: 0x401,
            0x190: 0x2100401,
            0x1a0: 0x100400,
            0x1b0: 0x1,
            0x1c0: 0x0,
            0x1d0: 0x2100000,
            0x1e0: 0x2000001,
            0x1f0: 0x400,
            0x108: 0x100400,
            0x118: 0x2000401,
            0x128: 0x2100001,
            0x138: 0x1,
            0x148: 0x2000000,
            0x158: 0x100000,
            0x168: 0x401,
            0x178: 0x2100400,
            0x188: 0x2000001,
            0x198: 0x2100000,
            0x1a8: 0x0,
            0x1b8: 0x2100401,
            0x1c8: 0x100401,
            0x1d8: 0x400,
            0x1e8: 0x2000400,
            0x1f8: 0x100001
        },
        {
            0x0: 0x8000820,
            0x1: 0x20000,
            0x2: 0x8000000,
            0x3: 0x20,
            0x4: 0x20020,
            0x5: 0x8020820,
            0x6: 0x8020800,
            0x7: 0x800,
            0x8: 0x8020000,
            0x9: 0x8000800,
            0xa: 0x20800,
            0xb: 0x8020020,
            0xc: 0x820,
            0xd: 0x0,
            0xe: 0x8000020,
            0xf: 0x20820,
            0x80000000: 0x800,
            0x80000001: 0x8020820,
            0x80000002: 0x8000820,
            0x80000003: 0x8000000,
            0x80000004: 0x8020000,
            0x80000005: 0x20800,
            0x80000006: 0x20820,
            0x80000007: 0x20,
            0x80000008: 0x8000020,
            0x80000009: 0x820,
            0x8000000a: 0x20020,
            0x8000000b: 0x8020800,
            0x8000000c: 0x0,
            0x8000000d: 0x8020020,
            0x8000000e: 0x8000800,
            0x8000000f: 0x20000,
            0x10: 0x20820,
            0x11: 0x8020800,
            0x12: 0x20,
            0x13: 0x800,
            0x14: 0x8000800,
            0x15: 0x8000020,
            0x16: 0x8020020,
            0x17: 0x20000,
            0x18: 0x0,
            0x19: 0x20020,
            0x1a: 0x8020000,
            0x1b: 0x8000820,
            0x1c: 0x8020820,
            0x1d: 0x20800,
            0x1e: 0x820,
            0x1f: 0x8000000,
            0x80000010: 0x20000,
            0x80000011: 0x800,
            0x80000012: 0x8020020,
            0x80000013: 0x20820,
            0x80000014: 0x20,
            0x80000015: 0x8020000,
            0x80000016: 0x8000000,
            0x80000017: 0x8000820,
            0x80000018: 0x8020820,
            0x80000019: 0x8000020,
            0x8000001a: 0x8000800,
            0x8000001b: 0x0,
            0x8000001c: 0x20800,
            0x8000001d: 0x820,
            0x8000001e: 0x20020,
            0x8000001f: 0x8020800
        }
    ];

    // Masks that select the SBOX input
    var SBOX_MASK = [
        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
    ];

    /**
     * DES block cipher algorithm.
     */
    var DES = C_algo.DES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Select 56 bits according to PC1
            var keyBits = [];
            for (var i = 0; i &lt; 56; i++) {
                var keyBitPos = PC1[i] - 1;
                keyBits[i] = (keyWords[keyBitPos &gt;&gt;&gt; 5] &gt;&gt;&gt; (31 - keyBitPos % 32)) &amp; 1;
            }

            // Assemble 16 subkeys
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey &lt; 16; nSubKey++) {
                // Create subkey
                var subKey = subKeys[nSubKey] = [];

                // Shortcut
                var bitShift = BIT_SHIFTS[nSubKey];

                // Select 48 bits according to PC2
                for (var i = 0; i &lt; 24; i++) {
                    // Select from the left 28 key bits
                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] &lt;&lt; (31 - i % 6);

                    // Select from the right 28 key bits
                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] &lt;&lt; (31 - i % 6);
                }

                // Since each subkey is applied to an expanded 32-bit input,
                // the subkey can be broken into 8 values scaled to 32-bits,
                // which allows the key to be used without expansion
                subKey[0] = (subKey[0] &lt;&lt; 1) | (subKey[0] &gt;&gt;&gt; 31);
                for (var i = 1; i &lt; 7; i++) {
                    subKey[i] = subKey[i] &gt;&gt;&gt; ((i - 1) * 4 + 3);
                }
                subKey[7] = (subKey[7] &lt;&lt; 5) | (subKey[7] &gt;&gt;&gt; 27);
            }

            // Compute inverse subkeys
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i &lt; 16; i++) {
                invSubKeys[i] = subKeys[15 - i];
            }
        },

        encryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
        },

        decryptBlock: function (M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
        },

        _doCryptBlock: function (M, offset, subKeys) {
            // Get input
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];

            // Initial permutation
            exchangeLR.call(this, 4,  0x0f0f0f0f);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeLR.call(this, 1,  0x55555555);

            // Rounds
            for (var round = 0; round &lt; 16; round++) {
                // Shortcuts
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;

                // Feistel function
                var f = 0;
                for (var i = 0; i &lt; 8; i++) {
                    f |= SBOX_P[i][((rBlock ^ subKey[i]) &amp; SBOX_MASK[i]) &gt;&gt;&gt; 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f;
            }

            // Undo swap from last round
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;

            // Final permutation
            exchangeLR.call(this, 1,  0x55555555);
            exchangeRL.call(this, 8,  0x00ff00ff);
            exchangeRL.call(this, 2,  0x33333333);
            exchangeLR.call(this, 16, 0x0000ffff);
            exchangeLR.call(this, 4,  0x0f0f0f0f);

            // Set output
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
        },

        keySize: 64/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    // Swap bits across the left and right words
    function exchangeLR(offset, mask) {
        var t = ((this._lBlock &gt;&gt;&gt; offset) ^ this._rBlock) &amp; mask;
        this._rBlock ^= t;
        this._lBlock ^= t &lt;&lt; offset;
    }

    function exchangeRL(offset, mask) {
        var t = ((this._rBlock &gt;&gt;&gt; offset) ^ this._lBlock) &amp; mask;
        this._lBlock ^= t;
        this._rBlock ^= t &lt;&lt; offset;
    }

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
     */
    C.DES = BlockCipher._createHelper(DES);

    /**
     * Triple-DES block cipher algorithm.
     */
    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
        _doReset: function () {
            // Shortcuts
            var key = this._key;
            var keyWords = key.words;

            // Create DES instances
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
        },

        encryptBlock: function (M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
        },

        decryptBlock: function (M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
        },

        keySize: 192/32,

        ivSize: 64/32,

        blockSize: 64/32
    });

    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
     */
    C.TripleDES = BlockCipher._createHelper(TripleDES);
}());</code></pre>
</div>
</div>
</p>

<p>When i run the html file in google. i get the following error :-</p>

<ol>
<li><strong>ReferenceError: CryptoJS is not defined at tripledes.js:3 at tripledes.js:750</strong></li>
<li><strong>CryptoJS is not defined at mode-ecb.js:4</strong></li>
<li><strong>CryptoJS is not defined
at encryptByDES (CryptoJS-DES.html:51)
at CryptoJS-DES.html:106</strong> </li>
</ol>
","","1193","<javascript><html><node.js><cryptojs>","0","","0","2017-11-11 16:23:01","","1","","","","","2017-11-11 16:23:01",""
"47250628","How to get CryptoJS result as hash_hmac PHP (SHA1)","<p>Try to genegarate HMAC on JS with CryptoJS lib from UTF8 string with UTF8 secret. Like PHP hash_hmac('sha1','...','...',true);</p>

<p>PHP :</p>

<pre><code>$buf = ' accept';
$bufferedSecret = 'xDx4J?)#';

hash_hmac('sha1', $buf, $bufferedSecret, false);
/* d301cae776ed8c5d46ac93bd7441b01af4d1b888 */
hash_hmac('sha1', $buf, $bufferedSecret, true);
/* v]FtA */
</code></pre>

<p>JavaScript : </p>

<pre><code>var buf = ' accept';
var bufferedSecret = 'xDx4J?)#';

CryptoJS.HmacSHA1(buf, bufferedSecret).toString();
/* d301cae776ed8c5d46ac93bd7441b01af4d1b888 */
var forBase64 = CryptoJS.HmacSHA1(buf, bufferedSecret);
CryptoJS.enc.Base64.stringify(forBase64);
/* 0wHK53btjF1GrJO9dEGwGvTRuIg= */
</code></pre>

<p>How get same HMAC(SHA1) UTF8 value on JS?</p>
","<h2>Buffer to UTF8</h2>

<p>You can take your Buffer and convert it to UTF-8 in JavaScript using the toString method; make sure you specify which format in the parameters, suitable values are <code>hex</code> and <code>utf8</code>, read more <a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"" rel=""nofollow noreferrer"">here</a>.</p>

<pre><code>var buf = ' accept';
var bufferedSecret = 'xDx4J?)#';

CryptoJS.HmacSHA1(buf, bufferedSecret).toString('utf8');
</code></pre>
","1191","<javascript><php><hmac><cryptojs><hmacsha1>","0","0","2","2017-11-13 20:03:20","47272613","0","","8833582","","2017-11-12 16:18:36","2017-11-12 15:40:03",""
"47250628","How to get CryptoJS result as hash_hmac PHP (SHA1)","<p>Try to genegarate HMAC on JS with CryptoJS lib from UTF8 string with UTF8 secret. Like PHP hash_hmac('sha1','...','...',true);</p>

<p>PHP :</p>

<pre><code>$buf = ' accept';
$bufferedSecret = 'xDx4J?)#';

hash_hmac('sha1', $buf, $bufferedSecret, false);
/* d301cae776ed8c5d46ac93bd7441b01af4d1b888 */
hash_hmac('sha1', $buf, $bufferedSecret, true);
/* v]FtA */
</code></pre>

<p>JavaScript : </p>

<pre><code>var buf = ' accept';
var bufferedSecret = 'xDx4J?)#';

CryptoJS.HmacSHA1(buf, bufferedSecret).toString();
/* d301cae776ed8c5d46ac93bd7441b01af4d1b888 */
var forBase64 = CryptoJS.HmacSHA1(buf, bufferedSecret);
CryptoJS.enc.Base64.stringify(forBase64);
/* 0wHK53btjF1GrJO9dEGwGvTRuIg= */
</code></pre>

<p>How get same HMAC(SHA1) UTF8 value on JS?</p>
","<p>I was found a way for get UTF-8 RAW. </p>

<p>Used ""convertWordArrayToUint8Array()"" from here:
<a href=""https://gist.github.com/getify/7325764"" rel=""nofollow noreferrer"">https://gist.github.com/getify/7325764</a>
and just decode it.</p>

<pre><code>var wordArr = CryptoJS.HmacSHA1(buf, bufferedSecret);
var utf8Arr = convertWordArrayToUint8Array(wordArr);
var string = new TextDecoder('utf-8').decode(utf8Arr);
</code></pre>
","1191","<javascript><php><hmac><cryptojs><hmacsha1>","0","1","2","2017-11-13 20:03:20","47272613","0","","8833582","","2017-11-12 16:18:36","2017-11-12 15:40:03",""
"48377148","CryptoJS AES Encryption in React Native","<p>How do I <code>encrypt</code> and <code>decrypt</code> an <code>epub/zip</code> file in react native? I am using react-native-fetch-blob for file streaming. I have also posted this question previously in detail with no result. Here is the <a href=""https://stackoverflow.com/questions/48238373/cryptojs-aes-decryption-not-giving-original-zip-epub-file-in-react-native"">link</a> if you need. Also the link of <a href=""https://github.com/brix/crypto-js#aes-encryption"" rel=""nofollow noreferrer"">CryptoJS</a>.</p>

<p>I was reading the epub/zip file in <code>base64</code> format which I think as equivalent of reading in binary format (or Am I wrong?). It works with single text file though.</p>

<p>Any Solutions? Thankyou.</p>
","","1190","<encryption><react-native><aes><cryptojs><react-native-fetch-blob>","1","","0","2018-01-22 08:13:37","","0","","","","","2018-01-22 08:13:37",""
"46202245","Follow same encryption in android as developed in CryptoJS","<p>I would like to encrypt this javascript code in android. </p>

<pre><code>let base64Key = CryptoJS.enc.Base64.parse(key);

let encryptedValue = CryptoJS.AES.encrypt(value, base64Key, {
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7,
iv: base64Key
});
return encryptedValue.toString();
</code></pre>

<p>Code:</p>

<pre><code>String encryptedKey = Base64.encodeToString(keyword.getBytes(), Base64.NO_WRAP);
Key key = new SecretKeySpec(encryptedKey.getBytes(), algorithm);
Cipher chiper = Cipher.getInstance(""AES"");
chiper.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = chiper.doFinal(plainText.getBytes());
String encryptedValue = Base64.encodeToString(encVal, Base64.NO_WRAP);
return encryptedValue;
</code></pre>

<p>But it returns a completely different value.</p>

<p>The first line of the code itself returns a different value in both cases:</p>

<p>So I got this part working.
I just needed to add the following lines to the android code:</p>

<pre><code>byte[] decoded = Base64.decode(key.getBytes());
        String hexString = Hex.encodeHexString(decoded);
</code></pre>

<p>This is the equivalent of <code>CryptoJS.enc.Base64.parse(key);</code> this line in CryptoJS.</p>

<p>But still trying to figure out the end result though. Both are different.</p>
","<p>Check out related question <a href=""https://stackoverflow.com/questions/15554296/simple-java-aes-encrypt-decrypt-example"">here</a> and <a href=""https://www.owasp.org/index.php/Using_the_Java_Cryptographic_Extensions"" rel=""nofollow noreferrer"">page on Java Cryptographic Extensions</a></p>
","1179","<java><android><encryption><aes><cryptojs>","0","0","3","2017-09-15 06:31:09","46233109","0","3","","user2893564","2017-09-13 18:13:27","2017-09-13 16:09:03",""
"46202245","Follow same encryption in android as developed in CryptoJS","<p>I would like to encrypt this javascript code in android. </p>

<pre><code>let base64Key = CryptoJS.enc.Base64.parse(key);

let encryptedValue = CryptoJS.AES.encrypt(value, base64Key, {
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7,
iv: base64Key
});
return encryptedValue.toString();
</code></pre>

<p>Code:</p>

<pre><code>String encryptedKey = Base64.encodeToString(keyword.getBytes(), Base64.NO_WRAP);
Key key = new SecretKeySpec(encryptedKey.getBytes(), algorithm);
Cipher chiper = Cipher.getInstance(""AES"");
chiper.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = chiper.doFinal(plainText.getBytes());
String encryptedValue = Base64.encodeToString(encVal, Base64.NO_WRAP);
return encryptedValue;
</code></pre>

<p>But it returns a completely different value.</p>

<p>The first line of the code itself returns a different value in both cases:</p>

<p>So I got this part working.
I just needed to add the following lines to the android code:</p>

<pre><code>byte[] decoded = Base64.decode(key.getBytes());
        String hexString = Hex.encodeHexString(decoded);
</code></pre>

<p>This is the equivalent of <code>CryptoJS.enc.Base64.parse(key);</code> this line in CryptoJS.</p>

<p>But still trying to figure out the end result though. Both are different.</p>
","<p>To turn a text string (UTF-8 encoded) into a base-64 string, you need:</p>

<pre><code>var textString = 'Hello world'; // Utf8-encoded string
var words = CryptoJS.enc.Utf8.parse(textString); // WordArray object
var base64 = CryptoJS.enc.Base64.stringify(words); // string: 'SGVsbG8gd29ybGQ='
</code></pre>
","1179","<java><android><encryption><aes><cryptojs>","0","0","3","2017-09-15 06:31:09","46233109","0","3","","user2893564","2017-09-13 18:13:27","2017-09-13 16:09:03",""
"46202245","Follow same encryption in android as developed in CryptoJS","<p>I would like to encrypt this javascript code in android. </p>

<pre><code>let base64Key = CryptoJS.enc.Base64.parse(key);

let encryptedValue = CryptoJS.AES.encrypt(value, base64Key, {
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7,
iv: base64Key
});
return encryptedValue.toString();
</code></pre>

<p>Code:</p>

<pre><code>String encryptedKey = Base64.encodeToString(keyword.getBytes(), Base64.NO_WRAP);
Key key = new SecretKeySpec(encryptedKey.getBytes(), algorithm);
Cipher chiper = Cipher.getInstance(""AES"");
chiper.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = chiper.doFinal(plainText.getBytes());
String encryptedValue = Base64.encodeToString(encVal, Base64.NO_WRAP);
return encryptedValue;
</code></pre>

<p>But it returns a completely different value.</p>

<p>The first line of the code itself returns a different value in both cases:</p>

<p>So I got this part working.
I just needed to add the following lines to the android code:</p>

<pre><code>byte[] decoded = Base64.decode(key.getBytes());
        String hexString = Hex.encodeHexString(decoded);
</code></pre>

<p>This is the equivalent of <code>CryptoJS.enc.Base64.parse(key);</code> this line in CryptoJS.</p>

<p>But still trying to figure out the end result though. Both are different.</p>
","<p>Finally got it working in Android using the below code, if anyone else faces the issue:</p>

<pre><code>public static String encrypt(String key, String value) {
    try {
        SecretKey secretKey = new SecretKeySpec(Base64.decode(key.getBytes(), Base64.NO_WRAP), ""AES"");
        AlgorithmParameterSpec iv = new IvParameterSpec(Base64.decode(key.getBytes(), Base64.NO_WRAP));
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);

        return new String(Base64.encode(cipher.doFinal(value.getBytes(""UTF-8"")), Base64.NO_WRAP));

    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>
","1179","<java><android><encryption><aes><cryptojs>","0","1","3","2017-09-15 06:31:09","46233109","0","3","","user2893564","2017-09-13 18:13:27","2017-09-13 16:09:03",""
"28352882","Decryption is failing with cryptojs","<p>I have this javascript. When I'm trying to decrypt it is not giving any output.
Encrypt is working fine but not decrypt
what wrong am I doing.</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script language = ""javascript""&gt;


    var JsonFormatter = {
        stringify: function (cipherParams) {
            // create json object with ciphertext
            var jsonObj = {
                ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
            };

            // optionally add iv and salt
            if (cipherParams.iv) {
                jsonObj.iv = cipherParams.iv.toString();
            }
            if (cipherParams.salt) {
                jsonObj.s = cipherParams.salt.toString();
            }

            // stringify json object
            return JSON.stringify(jsonObj);
        },

        parse: function (jsonStr) {
            // parse json string
            var jsonObj = JSON.parse(jsonStr);

            // extract ciphertext from json object, and create cipher params object
            var cipherParams = CryptoJS.lib.CipherParams.create({
                ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
            });

            // optionally extract iv and salt
            if (jsonObj.iv) {
                cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv)
            }
            if (jsonObj.s) {
                cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s)
            }

            return cipherParams;
        }
    };

    var AES = CryptoJS.AES;
    var key =  ""B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF"";
    var iv =  CryptoJS.enc.Hex.parse('7E892875A52C59A3B588306B13C31FBD');   
    var aeskey = CryptoJS.enc.Hex.parse(key);
    var secret = ""50585"";

    alert(""attempt 1"");  
    var e1 = AES.encrypt(secret, aeskey, { iv: iv , format: JsonFormatter });
    var encJSON  = JSON.parse(e1); 
    var encresult  = encJSON['ct'];  
    var encres = encodeURIComponent(encresult);     
    alert(""encrypted = "" + encresult);      
    alert(""e1.iv = "" + e1.iv);
    alert(""encoded = "" + encres);   

    alert(""attempt 2"");
    var decoderesult = decodeURIComponent(encres);    
    var encObj = CryptoJS.lib.CipherParams.create({
        ciphertext: CryptoJS.enc.Base64.parse(decoderesult)
    }); 
    var decrypt = AES.decrypt(encObj, aeskey, { iv: iv , format: JsonFormatter });
    var decrypted = decrypted.toString(CryptoJS.enc.Utf8); 
    alert(""decoded = "" + decoderesult); 
    alert(""decrypted = "" + decrypted);      
    alert(""decrypt.iv = "" + decrypt.iv);


&lt;/script&gt;
</code></pre>

<p>Encryption alerts are coming but not decryption. Why and where it is failing</p>
","<p>I think you have only a typo in the line <code>var decrypted = decrypted.toString(CryptoJS.enc.Utf8);</code> it should be <code>var decrypted = decrypt.toString(CryptoJS.enc.Utf8)</code>.</p>

<p>After this you are getting a <code>decoderesult</code> and <code>decrypted</code>. But <code>decrypt.iv</code> still returns undefined. Not sure what's wrong here.</p>

<p>For a demo see below and here at <a href=""http://jsfiddle.net/awolf2904/vyjzLurj/"" rel=""nofollow"">jsFiddle</a>.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var log = function(text) {
  output.innerHTML += '&lt;p&gt;' + text + '&lt;/p&gt;\n';  
}

var JsonFormatter = {
        stringify: function (cipherParams) {
            // create json object with ciphertext
            var jsonObj = {
                ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
            };

            // optionally add iv and salt
            if (cipherParams.iv) {
                jsonObj.iv = cipherParams.iv.toString();
            }
            if (cipherParams.salt) {
                jsonObj.s = cipherParams.salt.toString();
            }

            // stringify json object
            return JSON.stringify(jsonObj);
        },

        parse: function (jsonStr) {
            // parse json string
            var jsonObj = JSON.parse(jsonStr);

            // extract ciphertext from json object, and create cipher params object
            var cipherParams = CryptoJS.lib.CipherParams.create({
                ciphertext: CryptoJS.enc.Base64.parse(jsonObj.ct)
            });

            // optionally extract iv and salt
            if (jsonObj.iv) {
                cipherParams.iv = CryptoJS.enc.Hex.parse(jsonObj.iv)
            }
            if (jsonObj.s) {
                cipherParams.salt = CryptoJS.enc.Hex.parse(jsonObj.s)
            }

            return cipherParams;
        }
    };

    var AES = CryptoJS.AES;
    var key =  ""B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF"";
    var iv =  CryptoJS.enc.Hex.parse('7E892875A52C59A3B588306B13C31FBD');   
    var aeskey = CryptoJS.enc.Hex.parse(key);
    var secret = ""50585"";

    //alert(""attempt 1"");  
    var e1 = AES.encrypt(secret, aeskey, { iv: iv , format: JsonFormatter });
    var encJSON  = JSON.parse(e1); 
    var encresult  = encJSON['ct'];  
    var encres = encodeURIComponent(encresult);     
    console.log('encres', encresult);
    console.log('e1.iv=', e1.iv);
    console.log('encoded=', encres);
    log('encres= ' + encresult);
    log('e1.iv=' + e1.iv);
    log('encoded=' + encres);
    //alert(""encrypted = "" + encresult);      
    //alert(""e1.iv = "" + e1.iv);
    //alert(""encoded = "" + encres);   

    //alert(""attempt 2"");
    var decoderesult = decodeURIComponent(encres);    
    var encObj = CryptoJS.lib.CipherParams.create({
        ciphertext: CryptoJS.enc.Base64.parse(decoderesult)
    }); 
    var decrypt = AES.decrypt(encObj, aeskey, { iv: iv , format: JsonFormatter });
    console.log(decrypt);
    var decrypted = decrypt.toString(CryptoJS.enc.Utf8); //decrypted --&gt; decrypt
    console.log(""decoded = "" + decoderesult); 
    console.log(""decrypted = "" + decrypted);      
    console.log(""decrypt.iv = "" + decrypt.iv);
    log(""decoded = "" + decoderesult); 
    log(""decrypted = "" + decrypted);      
    log(""decrypt.iv = "" + decrypt.iv);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;

&lt;div id=""output""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","1179","<javascript><encryption><cryptojs>","-1","-1","1","2015-02-05 22:34:53","28353323","1","","","","","2015-02-05 19:57:00",""
"26259009","Decrypt in Crypto-JS gives numeric hexadecimal output instead of original plaintext string","<p>I put together a simple test using the example from the <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow noreferrer"">Crypto-JS source site at Google code</a>:</p>

<p>In page header:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
</code></pre>

<p>In a Javascript function:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");

alert('encrypted: '+encrypted+'  decrypted: '+decrypted);
</code></pre>

<p>but the output is:</p>

<pre><code>encrypted: U2FsdGVkX19hsNqFBS5xcUoVBCu/hPHepEwZchqnUVU=
decrypted: 4d657373616765
</code></pre>

<p><img src=""https://i.stack.imgur.com/C6Ash.png"" alt=""image of decrypted output""></p>

<p>What am I missing?</p>
","<pre><code>decrypted.toString(CryptoJS.enc.Utf8) // ""Message""
</code></pre>

<p>See <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"">https://code.google.com/p/crypto-js/#The_Hasher_Output</a></p>

<blockquote>
  <p>The hash you get back isn't a string yet. It's a <strong>WordArray</strong> object. When you use a WordArray object in a string context, it's automatically converted to a <strong>hex</strong> string.</p>
  
  <p>You can convert a WordArray object to <strong>other</strong> <strong>formats</strong> by explicitly calling the <strong>toString</strong> method and passing an <strong>encoder</strong>.</p>
</blockquote>
","1178","<javascript><cryptojs>","5","6","1","2014-10-08 14:38:06","26259216","2","","710446","","2014-10-08 14:38:06","2014-10-08 14:08:33",""
"28795151","Progressive AES decryption with CryptoJS","<p>I try to use progressive ciphering from CryptoJS to decrypt files.
The files are encrypted &amp; base64 encoded with OpenSSL as shown in the CryptoJS documentation (<a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">CryptoJS</a>).</p>

<p>When I use CryptoJS.AES.decrypt everything works fine:</p>

<pre><code>var encryptedText = ""U2FsdGVkX19X2wD+xFnLd3WLuzW5qA0dppGtV+VPOFdjslLsZpwfdqd02BOe4pvxG2zZok06DchVfZBBBS/JWg=="";

var key = CryptoJS.enc.Hex.parse(""A6420198998C341308AF100CF7CCAC95884E4084581A4F8CFB8DFA7FEAD045EF"");
var iv =  CryptoJS.enc.Hex.parse(""7F418B4532F8BC83261639DBA60C0A50"");

var decrypted = CryptoJS.AES.decrypt(encryptedText, key, {iv: iv});
var base64 = CryptoJS.enc.Base64.stringify(decrypted);
var result = atob(base64);
</code></pre>

<p>But when I try progressive decryption the result is corrupted: </p>

<pre><code>var decrypted;
var cipher = CryptoJS.algo.AES.createDecryptor(key, { iv: iv});
decrypted = cipher.process(encryptedText);
decrypted.concat(cipher.finalize());
var base64 = CryptoJS.enc.Base64.stringify(decrypted);
var result = atob(base64);
</code></pre>

<p>Has anyone an idea what I am doing wrong?</p>
","<p>The problem is that <code>encryptedText</code> is a string which is OpenSSL formatted. It is not the pure ciphertext which you get from the <code>ciphertext</code> property after encryption:</p>

<pre><code>var ct = CryptoJS.AES.encrypt(plaintext, key, {iv: iv}).ciphertext;
</code></pre>

<p>The <code>Cipher.process</code> function <a href=""https://github.com/CryptoStore/crypto-js/tree/3.1.2/src/cipher-core.js#L110"" rel=""nofollow"">only accepts a <code>WordArray</code> or the data string</a> and <code>encryptedText</code> is neither. You either need to use <a href=""https://github.com/CryptoStore/crypto-js/tree/3.1.2/src/cipher-core.js#L597"" rel=""nofollow""><code>CryptoJS.format.OpenSSL.parse()</code></a> to retrieve the ciphertext <code>WordArray</code>:</p>

<pre><code>var ct = CryptoJS.format.OpenSSL.parse(encryptedText).ciphertext;
</code></pre>

<p>or directly retrieve <code>ciphertext</code> when you encrypt it like in the first snippet.</p>

<p>After that, you can do:</p>

<pre><code>var decrypted = cipher.process(ct);
decrypted = decrypted.concat(cipher.finalize());
</code></pre>

<p>I'm also not sure why you stringify as Base64 and then use <code>atob</code>, because there is an easier way to get the original string back:</p>

<pre><code>console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","1163","<javascript><encryption><cryptojs>","0","0","1","2016-05-13 19:06:02","28795886","0","","","","","2015-03-01 15:12:37",""
"29731329","CryptoJS SHA256 Large File Progressive Checksum","<p>I am trying to use CryptoJS to get the checksum of large files( bigger than 500MB) so browser doesn't crash. I am already using a Web Worker with chunking. So, I am try to progressively use each chunk when I iterate through the chunks to update CryptoJS to start creating the checksum. However, it's still returning the wrong checksum at the end when I finalize. It's seems like it's only returning the checksum of the last chunk not the checksum of all the chunks. Can you let me know what I am doing wrong.</p>

<p>Also, I don't have to use CryptoJS as I find it to be slow but it seems the only library that can handle progressive encryption.</p>

<pre><code> var sha256 = CryptoJS.algo.SHA256.create(),
     sha256Update,
     checksum = [],
     chunker = function(workerData) {                            

       var file = workerData.fileBlob,
           totalFileSize = file.size,
           chunkLength = 3145728,
           start = 0,
           stop = chunkLength,
           i = 0, readSlicer,
           fileSlicer,
           chunk,
           chunkUint8,
           timerCounter = 0,
           hashConvert;

      var checker = function() {

          start = stop;
          stop += chunkLength;

          if(start &gt;= totalFileSize) {
               console.log(""Done reading file!"", stop, totalFileSize);
               sha256Update.finalize();

               console.log(""CheckSum : "", sha256Update._hash.toString(CryptoJS.enc.Hex));
               return;
                               }
               readBlock(start, chunkLength, file);
      };

      var readBlock = function(start, chunkLength, file) {

          readSlicer = new FileReaderSync();
          fileSlicer = file.slice(start, stop + 1);

          chunk = readSlicer.readAsArrayBuffer(fileSlicer);
          chunkUint8 = new Uint8Array(chunk);
          var wordArr = CryptoJS.lib.WordArray.create(chunkUint8);
              sha256Update = sha256.update(wordArr);
              checksum.push(sha256Update);
              checker();

      };

          readBlock(start, chunkLength, file);
   };
</code></pre>
","","1145","<javascript><hash><sha256><cryptojs><chunking>","3","","0","2016-05-16 01:06:03","","5","","1816580","","2015-04-19 16:17:48","2015-04-19 14:41:20",""
"47296733","Decrypting openssl aes-256-cbc using node.js?","<p>I'm encrypting my file on the command line using:</p>

<pre><code>openssl aes-256-cbc -e -in test.env -out test.env.encrypted
</code></pre>

<p>and then trying to decrypt on node.js with:</p>

<pre><code>crypto    = require('crypto')
algorithm = 'aes-256-cbc'
password  = 'test'

fs = require 'fs'
decrypt = (text) -&gt;
  decipher = crypto.createDecipher(algorithm, password)
  dec = decipher.update(text, 'hex', 'utf8')
  dec += decipher.final('utf8')
  dec

file = fs.readFileSync './test.env.encrypted', 'utf-8'

console.log decrypt file
</code></pre>

<p>But i'm getting the following error:</p>

<pre><code>TypeError: Bad input string at Decipher.update (crypto.js:168:26) at decrypt (/Users/h/tmp/encrypt_test/test.coffee:10:18) at Object.&lt;anonymous&gt; (/Users/h/tmp/encrypt_test/test.coffee:16:13) at Object.&lt;anonymous&gt; (/Users/h/tmp/encrypt_test/test.coffee:1:1) at Module._compile (module.js:569:30) at Object.CoffeeScript.run (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/index.js:63:23) at compileScript (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:265:29) at compilePath (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:220:14) at Object.exports.run (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:141:20) at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/coffeescript/bin/coffee:15:45) at Module._compile (module.js:569:30) at Object.Module._extensions..js (module.js:580:10) at Module.load (module.js:503:32) at tryModuleLoad (module.js:466:12) at Function.Module._load (module.js:458:3) at Function.Module.runMain (module.js:605:10) at startup (bootstrap_node.js:158:16) at bootstrap_node.js:575:3
</code></pre>

<p>What am i doing wrong?</p>

<hr>

<h2>UPDATE:</h2>

<p>As per James note i'm now sending a ""hex"" string to my decrypt function:</p>

<pre><code>crypto    = require('crypto')
algorithm = 'aes-256-cbc'
password  = 'test'

fs = require 'fs'

decrypt = (text) -&gt;
  decipher = crypto.createDecipher(algorithm, password)
  dec = decipher.update(text, 'hex', 'utf8')
  dec += decipher.final('utf8')
  dec

file = fs.readFileSync './test.env.encrypted'

console.log decrypt file.toString('hex')
</code></pre>

<p>But then it's yielding a new error:</p>

<pre><code>Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
    at Decipher.final (crypto.js:181:26)
    at decrypt (/Users/h/tmp/encrypt_test/test.coffee:12:19)
    at Object.&lt;anonymous&gt; (/Users/h/tmp/encrypt_test/test.coffee:17:13)
    at Object.&lt;anonymous&gt; (/Users/h/tmp/encrypt_test/test.coffee:1:1)
    at Module._compile (module.js:569:30)
    at Object.CoffeeScript.run (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/index.js:63:23)
    at compileScript (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:265:29)
    at compilePath (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:220:14)
    at Object.exports.run (/usr/local/lib/node_modules/coffeescript/lib/coffeescript/command.js:141:20)
    at Object.&lt;anonymous&gt; (/usr/local/lib/node_modules/coffeescript/bin/coffee:15:45)
    at Module._compile (module.js:569:30)
    at Object.Module._extensions..js (module.js:580:10)
    at Module.load (module.js:503:32)
    at tryModuleLoad (module.js:466:12)
    at Function.Module._load (module.js:458:3)
    at Function.Module.runMain (module.js:605:10)
    at startup (bootstrap_node.js:158:16)
    at bootstrap_node.js:575:3
</code></pre>

<p>File was encrypted using:</p>

<pre><code>openssl aes-256-cbc -e -in test.env -out test.env.encrypted
</code></pre>

<p>with </p>

<pre><code>test
</code></pre>

<p>as password</p>
","<p>Your call to <code>decipher.update</code> expects a <code>hex</code> encoded string but you're passing a <code>utf-8</code> string. </p>

<p>Either change your <code>readFileSync</code> to read with <code>hex</code> encoding or change the <code>update</code> call to expect <code>utf-8</code> input.</p>
","1142","<node.js><cryptojs>","-1","1","1","2017-11-15 01:10:32","","1","","608639","","2017-11-15 01:10:32","2017-11-14 23:06:00",""
"30379084","Sign Key HMAC SHA1 with Javascript","<p>For some reason I am not able to create a signature from a private key in JS. Using this online help from google:</p>

<p><a href=""https://m4b-url-signer.appspot.com/"" rel=""nofollow"">https://m4b-url-signer.appspot.com/</a></p>

<p>URL:<a href=""https://google.maps.com/maps/api/geocode/json?address=New+York&amp;client=test"" rel=""nofollow"">https://google.maps.com/maps/api/geocode/json?address=New+York&amp;client=test</a></p>

<p>Example Key (fake for the purposes of the exercise)
Key: QNade5DtdJKKZbidTsrIgONupc4=</p>

<p>(Result) Signature: XDsiH5JAY7kJLgA1K2PWlhTdO1k=</p>

<p>However, my javascript code:</p>

<pre><code>var keyString = 'QNade5DtdJKKZbidTsrIgONupc4=';
    console.log(keyString)

var urlString = encodeURIComponent('/maps/api/geocode/json?address=New+York&amp;client=test');
console.log(urlString)

// We need to decode private key to binary
var decoded_key_words = CryptoJS.enc.Utf8.parse(keyString);
var decoded_key = CryptoJS.enc.Base64.stringify(decoded_key_words);

console.log(decoded_key);

var signature = CryptoJS.HmacSHA1(decoded_key,urlString);
console.log(signature);

//  Encode binary signature to base 64
var encoded_signature = CryptoJS.enc.Base64.stringify(signature);
console.log(encoded_signature)
</code></pre>

<p>Gives me a signature:</p>

<p>bOenVNeXI6xI1xlSa77oqGKssyY=</p>

<p>I can't seem to figure out what I'm doing wrong. Am I decoding base64 incorrectly?</p>
","<p>For the record, this worked:</p>

<pre><code>&lt;script src=""sha.js""&gt;&lt;/script&gt;

var url = '/maps/api/geocode/json?address=New+York&amp;client=test';
var key = 'QNade5DtdJKKZbidTsrIgONupc4='

var hmacObj = new jsSHA(url, 'TEXT');
var hmacOutput = hmacObj.getHMAC(key,'B64','SHA-1','B64');

console.log(hmacOutput)
</code></pre>

<p>Giving me:</p>

<p>XDsiH5JAY7kJLgA1K2PWlhTdO1k=</p>
","1134","<javascript><google-maps-api-3><utf-8><base64><cryptojs>","2","0","1","2015-05-22 14:36:32","","3","","4465819","","2015-05-21 21:29:00","2015-05-21 16:11:16",""
"31523583","Can array of bytes be used as a key with CryptoJS.RC4.encrypt?","<p>I need to use an array of bytes (non-printable characters) as a key for RC4 encryption. The plaintext is a string. It seems that <code>CryptoJS.RC4.encrypt</code> expects only strings for both plaintext and key.  Am I correct?  If not, how do I call <code>encrypt()</code> with string and array of bytes?</p>
","<p>If you want to create a key value from a list of byte values, your best bet is to use the <a href=""https://code.google.com/p/crypto-js/#Encoders"" rel=""nofollow"">hex encoder function, <code>CryptoJS.enc.Hex.parse</code></a>:</p>

<pre><code>CryptoJS.enc.Hex.parse('48656c6c6f2c20576f726c6421');
</code></pre>

<p>This will parse your input string as a list of two-character pairs that each described a byte value. In this case, the hex values would be <code>48</code>, <code>65</code>, <code>6c</code>, <code>6c</code>, <code>6f</code>, etc. You can pass the result of the <code>parse</code> call directly into the encrypt/decrypt methods as the <code>key</code> parameter. (The result is a CryptoJS type called ""<code>WordArray</code>,"" but you don't need to worry about the mechanics of this type; just pass it in as the key paramemter.)</p>

<p>If you want to transform an array of numbers to a hex string, you can do this easily with a simple loop and <code>.toString(16)</code>:</p>

<pre><code>var byteArr = [72, 101, 108, 108, 111, 44],
    str = """",
    byteVal;
for(var i=0; i&lt;byteArr.length; i++) {
    byteVal = byteArr[i];
    if(byteVal &lt; 16) { str += ""0""; }
    str += byteVal.toString(16);
};
</code></pre>
","1131","<javascript><character-encoding><cryptojs><rc4-cipher><symmetric-key>","1","3","1","2015-07-20 18:40:30","31523792","0","","710446","","2015-07-20 18:40:30","2015-07-20 18:18:45",""
"40848757","CryptoJS - Decrypt an encrypted file","<p>I'm trying to write an application to do end-to-end encryption for files with JS in browser. However I don't seem to be able to get all files decrypted correctly.</p>

<p><strong>TL;DR</strong> As it's impractical to encrypt files bigger than 1MB as a whole, I'm trying to encrypt them chunk by chunk. After doing so I try to write the encrypted words (resulted from <code>CryptoJS</code>'s WordArray) into a blob. As for decryption I read the files and split them to chunks according to map generated while encrypting the chunks and try to decrypt them. The problem is decrypted result is 0 bits!</p>

<p>I guess I'm not reading the chunks while decrypting correctly. Please take a look at the code below for the function <code>getBlob</code> (writing data to the blob) and the last part of <code>decryptFile</code> for reading chunks.</p>

<p><strong>More explanation</strong></p>

<p>I'm using CryptoJS AES with default settings.</p>

<p>Right now my code looks like this:</p>

<pre><code>function encryptFile (file, options, resolve, reject) {
  if (!options.encrypt) {
    return resolve(file)
  }
  if (!options.processor || !options.context) {
    return reject('No encryption method.')
  }

  function encryptBlob (file, optStart, optEnd) {
    const start = optStart || 0
    let stop = optEnd || CHUNK_SIZE
    if (stop &gt; file.size - 1) {
      stop = file.size
    }

    const blob = file.slice(start, stop)
    const fileReader = new FileReader()

    fileReader.onloadend = function () {
      if (this.readyState !== FileReader.DONE) return

      const index = Math.ceil(optStart / CHUNK_SIZE)
      const result = CryptoJS.lib.WordArray.create(this.result)
      encryptedFile[index] = encrypt(result)

      chunksResolved++
      if (chunksResolved === count) {
        const {sigBytes, sigBytesMap, words} = getCipherInfo(encryptedFile)
        const blob = getBlob(sigBytes, words)

        resolve(blob, Object.keys(sigBytesMap))
      }
    }
    fileReader.readAsArrayBuffer(blob)
  }

  let chunksResolved = 0
  const encryptedFile = []
  const CHUNK_SIZE = 1024*1024
  const count = Math.ceil(file.size / CHUNK_SIZE)
  const encrypt = value =&gt; options.processor.call(
    options.context, value, 'file',
    (v, k) =&gt; CryptoJS.AES.encrypt(v, k))

  for (let start = 0; (start + CHUNK_SIZE) / CHUNK_SIZE &lt;= count; start+= CHUNK_SIZE) {
    encryptBlob(file, start, start + CHUNK_SIZE - 1)
  }
}
</code></pre>

<p>As you can see I'm trying to read the file chunk by chunk (each chunk is 1MB or <code>fileSize % 1MB</code>) as ArrayBuffer, converting it to WordArray for CryptoJS to understand and encrypt it.</p>

<p>After encrypting all the chunks I try to write each word they have to a blob (using a code I found in CryptoJS's issues in Google Code, mentioned below) and <strong>I guess here is what goes wrong</strong>. I also generated a map for where encrypted chunks end so I can later use it to get the chunks out of the binary file for decryption.</p>

<p>And here's how I decrypt the files:</p>

<pre><code>function decryptFile (file, sigBytesMap, filename, options, resolve, reject) {
  if (!options.decrypt) {
    return resolve(file)
  }
  if (!options.processor || !options.context) {
    return reject('No decryption method.')
  }

  function decryptBlob (file, index, start, stop) {
    const blob = file.slice(start, stop)
    const fileReader = new FileReader()

    fileReader.onloadend = function () {
      if (this.readyState !== FileReader.DONE) return

      const result = CryptoJS.lib.WordArray.create(this.result)
      decryptedFile[index] = decrypt(result)

      chunksResolved++
      if (chunksResolved === count) {
        const {sigBytes, words} = getCipherInfo(decryptedFile)
        const finalFile = getBlob(sigBytes, words)

        resolve(finalFile, filename)
      }
    }
    fileReader.readAsArrayBuffer(blob)
  }

  let chunksResolved = 0
  const count = sigBytesMap.length
  const decryptedFile = []
  const decrypt = value =&gt; options.processor.call(
    options.context, value, 'file',
    (v, k) =&gt; CryptoJS.AES.decrypt(v, k))

  for (let i = 0; i &lt; count; i++) {
    decryptBlob(file, i, parseInt(sigBytesMap[i - 1]) || 0, parseInt(sigBytesMap[i]) - 1)
  }
}
</code></pre>

<p>Decryption is exactly like the encryption but doesn't work. Although chunks are not 1MB anymore, they are limited to sigBytes mentioned in the map. There is no result for the decryption! <code>sigBytes: 0</code>.</p>

<p>Here's the code for generating a blob and getting sigbytesMap:</p>

<pre><code>function getCipherInfo (ciphers) {
  const sigBytesMap = []
  const sigBytes = ciphers.reduce((tmp, cipher) =&gt; {
    tmp += cipher.sigBytes || cipher.ciphertext.sigBytes
    sigBytesMap.push(tmp)
    return tmp
  }, 0)

  const words = ciphers.reduce((tmp, cipher) =&gt; {
    return tmp.concat(cipher.words || cipher.ciphertext.words)
  }, [])

  return {sigBytes, sigBytesMap, words}
}

function getBlob (sigBytes, words) {
  const bytes = new Uint8Array(sigBytes)
  for (var i = 0; i &lt; sigBytes; i++) {
    const byte = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff
    bytes[i] = byte
  }

  return new Blob([ new Uint8Array(bytes) ])
}
</code></pre>

<p>I'm guessing the issue is the method I'm using to read the encrypted chunks. Or maybe writing them!</p>

<p>I should also mention that previously I was doing something different for encryption. I was stringifying each WordArray I got as the result for <code>CryptoJS.AES.encrypt</code> using the <code>toString</code> method with the default encoding (which I believe is <code>CryptoJS.enc.Hex</code>) but some files didn't decrypt correctly. It didn't have anything to do with the size of the original file, rather than their types. Again, I'm guessing!</p>
","<p>Turns out the problem was the <code>WordArray</code> returned by <code>CryptoJS.AES.decrypt(value, key)</code> has 4 extra words as padding which should not be included in the final result. CryptoJS tries unpadding the result but only changes <code>sigBytes</code> accordingly and doesn't change <code>words</code>. So when decrypting, before writing chunks to file pop those extra words. 4 words for full chunks and 3 for smaller ones (last chunk).</p>
","1124","<javascript><file><encryption><cryptojs>","4","0","1","2016-12-05 12:23:48","40974218","9","0","3139132","","2016-11-29 12:05:43","2016-11-28 16:10:25",""
"28069885","AES encrypt with android from JavaScript code","<p>I have to emulate and JavaScript code in Android to do an AES encrytion and decrytion, but my Android code isn't working as JavaScrip code.</p>

<p>I have to do the same as this code  in JavaScript:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/pad-zeropadding-min.js""&gt;&lt;/script&gt;    
&lt;!-- jquery --&gt;
&lt;script src=""http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js""&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=""0""&gt;&lt;/div&gt;
&lt;div id=""1""&gt;&lt;/div&gt;
&lt;div id=""2""&gt;&lt;/div&gt;
&lt;div id=""3""&gt;&lt;/div&gt;
&lt;div id=""4""&gt;&lt;/div&gt;
&lt;script&gt;
var key = CryptoJS.enc.Utf8.parse('a5240ba5b7cbde89e8075db30138ce64');
var iv  = CryptoJS.enc.Utf8.parse('1ec9b4a4767e582b8a1e3dcad1782f80');
var message = ""message"";
$('#0').text(""Message: ""+message);
var encrypted = CryptoJS.AES.encrypt(message, key, { iv: iv, padding: CryptoJS.pad.ZeroPadding, mode: CryptoJS.mode.CBC});
$('#1').text(""Encrypted BASE64: ""+encrypted);
$('#2').text(""Encrypted HEX: ""+encrypted.ciphertext);

var decrypted = CryptoJS.AES.decrypt(encrypted,key, { iv: iv, padding: CryptoJS.pad.ZeroPadding, mode: CryptoJS.mode.CBC});
$('#3').text(""Decrypted HEX: ""+decrypted);
$('#4').text(""Decrypted TEXT: ""+decrypted.toString(CryptoJS.enc.Utf8));
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>I have to do it with bouncycastle lib because the IV has 32 bytes length as you can see, I do it but my code doesn't return the same as this JavaScript code. Anyone know what I am doing wrong, in the android code?</p>

<p>This is the android code:</p>

<pre><code>private static final String ZERO_PADDING_KEY = ""a5240ba5b7cbde89e8075db30138ce64"";
private static final String IV = ""1ec9b4a4767e582b8a1e3dcad1782f80"";
public String encryptURL(String url) {
    try {
        Hex hex = new Hex();

        byte[] key = ZERO_PADDING_KEY.getBytes(""UTF-8"");
        byte[] iv = IV.getBytes(""UTF-8"");

        PaddedBufferedBlockCipher c = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());
        c.init(true, new ParametersWithIV(new KeyParameter(key), iv));

        byte[] res = cipherData(c, url.getBytes(""UTF-8""));
        String resul = bytesToHex(res);

        return resul;
    } catch (Exception e) {
        Log.e(""ENCRYPT ERROR"", e.getMessage());
        e.printStackTrace();
    }
    return """";
}

public String decryptUrl(String encrypted) {
    try {
        Hex hex = new Hex();
        byte[] key = ZERO_PADDING_KEY.getBytes(""UTF-8"");
        byte[] iv = IV.getBytes(""UTF-8"");


        PaddedBufferedBlockCipher c = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());
        c.init(false, new ParametersWithIV(new KeyParameter(key), iv));

        byte[] decryptedText = cipherData(c, (byte[]) hex.decode(encrypted));
        String decrypted = new String(decryptedText, ""UTF-8"");
        Log.d(""DECRYPTED"", decrypted);

        return decrypted;
    } catch (Exception e) {
        try {
            throw new CryptoException(""Unable to decrypt"", e);
        } catch (CryptoException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }
    return """";
}

private static byte[] cipherData(PaddedBufferedBlockCipher cipher, byte[] data) throws Exception {

    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];
    System.arraycopy(outBuf, 0, result, 0, result.length);
    return result;
}

public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for (int j = 0; j &lt; bytes.length; j++) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}
</code></pre>
","<p>You have <code>new RijndaelEngine(256)</code> in your Android code. It is Rijndael with a block size of 256. CryptoJS only supports AES which is Rijndael with a block size of 128.</p>

<p>Since CryptoJS only supports AES with a block size of 128, the IV size also must be 128. You should parse the IV as Hex. CryptoJS doesn't seem to mind that a bigger IV is passed. In CryptoJS:</p>

<pre><code>var iv = CryptoJS.enc.Hex.parse('1ec9b4a4767e582b8a1e3dcad1782f80');
</code></pre>

<p>And in Android you can use the Hex class that you already have in your code.</p>

<p>If you don't want to change the JavaScript code, you can use only the first 128-bit of the IV in Android (I suspect this is what CryptoJS does, but couldn't verify it):</p>

<pre><code>byte[] iv = Arrays.copyOf(IV.getBytes(""UTF-8""), 16);
</code></pre>
","1100","<javascript><android><encryption><cryptojs>","0","1","1","2015-01-21 15:14:34","28070039","0","1","2015426","","2015-01-21 15:00:22","2015-01-21 14:40:58",""
"37663373","How to check if the decryption is correct?","<p>I'm working on chat room that encrypt messages for more than one users and each user might have different encryption and key/password. The user's key won't work with all the message, therefore; return errors.</p>

<pre><code>var message =""secret message"";
var encrypted = CryptoJS.AES.encrypt(message, ""Secret Passphrase"");
try {
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase123"").toString(CryptoJS.enc.Utf8);
    if (decrypted.length &gt; 0) {
        alert(decrypted);
    } else {
        alert(""false"");
    }
} catch(e) {
    alert(""false"");
}
</code></pre>

<p>I'm currently catching the error, but sometimes the decryption returns with jumbled up letters and symbols. The current way I'm doing this is not efficient. Is there a better way?</p>
","<p>This makes sense, most of the time you'll get an error if the bytes don't fit neatly into <code>CryptoJS.enc.Utf8</code>.  But on occasion, like you said the user might get lucky (or unlucky) and submit a key that decrypts to valid <code>Utf8</code> bytes and it doesn't really know the difference.  I'd be curious to know how often this happens.</p>

<p>My solution would be to parse the decrypted string and look for a few 'indicators' that the message looks like a normal English sentence, instead of a random string of random characters.  First thing I would do would be to check for the number of spaces in the string.  This would probably be the single best indicator.</p>
","1094","<javascript><encryption><cryptojs>","4","0","4","2016-06-06 19:09:46","37664062","16","","1816580","","2016-06-06 19:09:46","2016-06-06 17:20:47",""
"37663373","How to check if the decryption is correct?","<p>I'm working on chat room that encrypt messages for more than one users and each user might have different encryption and key/password. The user's key won't work with all the message, therefore; return errors.</p>

<pre><code>var message =""secret message"";
var encrypted = CryptoJS.AES.encrypt(message, ""Secret Passphrase"");
try {
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase123"").toString(CryptoJS.enc.Utf8);
    if (decrypted.length &gt; 0) {
        alert(decrypted);
    } else {
        alert(""false"");
    }
} catch(e) {
    alert(""false"");
}
</code></pre>

<p>I'm currently catching the error, but sometimes the decryption returns with jumbled up letters and symbols. The current way I'm doing this is not efficient. Is there a better way?</p>
","<p>I'm not a security expert. You might consider asking a question on <a href=""https://security.stackexchange.com/"">Information Security</a> for a better opinion (read their FAQ first), but:</p>

<p>1) You shouldn't be trying to decrypt a message with the wrong key in the first place. That's just not something that should be happening. If a message is intended for a particular user and was encrypted using their key then include in your message <em>who it's for</em> and on the receiving end check <em>if the message was for you</em>:</p>

<p>Sending:</p>

<pre><code>var message = { user: 1122, body: encryptedMessage };
send(message);
</code></pre>

<p>Recieving:</p>

<pre><code>if (message.user == myUserId) {
    decyptMessage(message.body);
} else {
    // this message isn't for you
}
</code></pre>

<p>2) If for some reason that doesn't work, then you would need to insert something in the message that you can use to confirm that it's decypted properly. A <a href=""https://en.wikipedia.org/wiki/Checksum"" rel=""nofollow noreferrer"">checksum</a> would achieve this:</p>

<p>Sending:</p>

<pre><code>var message = originalMessage + CalcChecksum(originalMessage);
send(encypt(message));
</code></pre>

<p>Recieving:</p>

<pre><code>var decrypted = decrypt(message);
var msg = getTheBodyPartOfTheMessage(decrypted);
var chk = getTheChecksumPartOfTheMessage(decrypted);
if (chk == CalcChecksum(msg) {
    // this is a good message
} else {
    // this message isn't for you
}
</code></pre>

<p>You can used a fixed length checksum so that, say, the last two characters are always the checksum or you could use some character (that won't otherwise appear) as a delimiter.</p>

<p>I like the checksum better than the idea of prefixing (or postfixing) some known string to every message because the checksum will be different for each message (well, not quite - but you won't be able to predict it).</p>
","1094","<javascript><encryption><cryptojs>","4","0","4","2016-06-06 19:09:46","37664062","16","","1816580","","2016-06-06 19:09:46","2016-06-06 17:20:47",""
"37663373","How to check if the decryption is correct?","<p>I'm working on chat room that encrypt messages for more than one users and each user might have different encryption and key/password. The user's key won't work with all the message, therefore; return errors.</p>

<pre><code>var message =""secret message"";
var encrypted = CryptoJS.AES.encrypt(message, ""Secret Passphrase"");
try {
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase123"").toString(CryptoJS.enc.Utf8);
    if (decrypted.length &gt; 0) {
        alert(decrypted);
    } else {
        alert(""false"");
    }
} catch(e) {
    alert(""false"");
}
</code></pre>

<p>I'm currently catching the error, but sometimes the decryption returns with jumbled up letters and symbols. The current way I'm doing this is not efficient. Is there a better way?</p>
","<p>Put a prefix at the beginning of each message, e.g.</p>

<pre><code>encrypt(""ABCD"" + message);
</code></pre>

<p>Then when you decrypt, check if the result begins with <code>""ABCD""</code>.</p>

<p>This isn't foolproof, since it's possible that an incorrect decryption could have the same prefix, but it's very unlikely (make it longer to reduce the chance).</p>

<p>However, there's a security implication, since if someone knows that every message begins with the same prefix, it can help them analyze and try to break the encryption (similar to how you can use known letter frequencies when trying to break a simple Caesar cypher).</p>

<p>A slightly better method would be to generate a random string, and then put it in two places in the string before encrypting. Then check that they match.</p>

<pre><code>random = random_string(10);
encrypt(random + message + random);
</code></pre>

<p>Then after decrypting, check if the first and last 10 characters match.</p>
","1094","<javascript><encryption><cryptojs>","4","1","4","2016-06-06 19:09:46","37664062","16","","1816580","","2016-06-06 19:09:46","2016-06-06 17:20:47",""
"37663373","How to check if the decryption is correct?","<p>I'm working on chat room that encrypt messages for more than one users and each user might have different encryption and key/password. The user's key won't work with all the message, therefore; return errors.</p>

<pre><code>var message =""secret message"";
var encrypted = CryptoJS.AES.encrypt(message, ""Secret Passphrase"");
try {
    var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase123"").toString(CryptoJS.enc.Utf8);
    if (decrypted.length &gt; 0) {
        alert(decrypted);
    } else {
        alert(""false"");
    }
} catch(e) {
    alert(""false"");
}
</code></pre>

<p>I'm currently catching the error, but sometimes the decryption returns with jumbled up letters and symbols. The current way I'm doing this is not efficient. Is there a better way?</p>
","<p>What is needed it authenticated encryption, see <a href=""https://en.wikipedia.org/wiki/Authenticated_encryption"" rel=""nofollow noreferrer"">Wikipedia</a>.</p>

<p>Essentially HMAC the encrypted data with the encryption key and append the result to the encrypted data.</p>

<p>Prior to decryption HMAC the encrypted data with the decryption key and compare to the appended HMAC value. (Use a constant time comparison function.)</p>

<p><a href=""https://i.stack.imgur.com/zelPI.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/zelPI.jpg"" alt=""enter image description here""></a></p>
","1094","<javascript><encryption><cryptojs>","4","6","4","2016-06-06 19:09:46","37664062","16","","1816580","","2016-06-06 19:09:46","2016-06-06 17:20:47",""
"29507772","Unable to load CryptoJS library in my application which is not an open source","<p>I need to use CryptoJS for JavaScript encryption and decryption in my application (QIK technology).</p>

<p>When I try to do that, the CryptoJS libraries fail to load with the following message:</p>

<pre><code>""javascript failure error and the CryptoJS  is undefined""
</code></pre>

<p>I have attached the error screen shot which I am getting here.</p>

<p>The test example I am trying to do is given below as Fiddle 1 and Fiddle 2. Do I need to do any external setup to access CryptoJS to my application?</p>

<p><img src=""https://i.stack.imgur.com/jKQ6e.png"" alt=""enter image description here""></p>

<p>My fiddles: <a href=""http://jsfiddle.net/1qgzk9j8/"" rel=""nofollow noreferrer"">Fiddle 1</a> and <a href=""http://jsfiddle.net/6gunq2nx/"" rel=""nofollow noreferrer"">Fiddle 2</a>.</p>
","<p>There is not special setup. Just include the library as per the documentation :</p>

<ul>
<li><a href=""https://code.google.com/p/crypto-js/#The_Cipher_Output"" rel=""nofollow"" title=""AES Cypher Output"">The Cipher Output</a></li>
<li><a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">AES</a></li>
</ul>

<p>I've updated your fiddle with a working example (i've moved your Js code from the HTML panel to the javascript one and added the jQuery library to display the results) :
<a href=""http://jsfiddle.net/1qgzk9j8/4/"" rel=""nofollow"">JsFiddle</a></p>

<p>HTML :</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
</code></pre>

<p>Javascript</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>I've added a <a href=""http://plnkr.co/5H2mn8lFpkQvtqgwGlxg"" rel=""nofollow"">Plunkr</a> as well, to show you the setup on a more realistic page :</p>

<p>Hope it helps !</p>
","1069","<javascript><encryption><aes><cryptojs>","-2","1","1","2015-10-24 16:05:59","","3","","472495","","2015-10-24 16:05:59","2015-04-08 06:48:57",""
"18105285","HMAC in client side JavaScript and identity spoofing","<p>CryptoJS has functions to create HMAC from a message and the secret key.</p>

<p>How can this be secure considering that the secret key must be stored in plain sight in the JavaScript source deployed on the client ?</p>

<p>Anyone can take the key and issue similar requests to the server under the identity of the original client of the API. Isn't ""identity"" the problem that HMAC is supposed to solve ?</p>

<p>All in all, I do not understand the purpose of HMAC in client side JS since the key can't be kept secret. </p>

<p>Is there a use case to computing HMAC in JavaScript ?</p>
","<p>JavaScript now has WebRTC where two clients can communicate peer-to-peer, this would be a scenario where clients can generate and use their own ""secret"".</p>

<p>There are some cases where client -> server could be usable as well. If your server was ""dynamically"" serving the JavaScript then it could insert a ""secret"" based on the clients current session/login. Assuming you are using HTTPS (if not there could be a man in the middle slurping up the ""secret"") then it's not unreasonable to assume that communication to the server signed with that specific ""secret"" (even over unsecured HTTP) belongs to only that client.</p>
","1065","<javascript><hmac><cryptojs>","2","4","2","2015-05-31 17:41:09","18105421","0","","867395","","2013-08-08 07:37:13","2013-08-07 13:52:44",""
"18105285","HMAC in client side JavaScript and identity spoofing","<p>CryptoJS has functions to create HMAC from a message and the secret key.</p>

<p>How can this be secure considering that the secret key must be stored in plain sight in the JavaScript source deployed on the client ?</p>

<p>Anyone can take the key and issue similar requests to the server under the identity of the original client of the API. Isn't ""identity"" the problem that HMAC is supposed to solve ?</p>

<p>All in all, I do not understand the purpose of HMAC in client side JS since the key can't be kept secret. </p>

<p>Is there a use case to computing HMAC in JavaScript ?</p>
","<blockquote>
  <p>How can this be secure considering that the secret key must be stored in plain sight in the JavaScript source deployed on the client ?</p>
</blockquote>

<p>Each client should get their own key/secret which enables them access to the resources they are supposed to have access to.  This is effectively no different than a user knowing their own username and password.  Their user/pass combo only allows access to the resources they need.  The same should go for the key pair.</p>

<blockquote>
  <p>Anyone can take the key and issue similar requests to the server under the identity of the original client of the API. Isn't ""identity"" the problem that HMAC is supposed to solve ?</p>
</blockquote>

<p>Yes, of course if someone gets your key and secret they can issue requests as if they came from you.  Simply don't give out your secret to others.  Having it in JavaScript doesn't matter at all.  Sure, the user can see it but unless they take that key and secret and put it somewhere else, it isn't a problem.</p>

<p>I have a system where a user logs in through normal means (username/password, OAuth, OpenID, etc.) and is immediately issued a key/secret for making API calls.  The client-side application uses this key/secret to actually do its work.  The issuance of this key/secret is done over HTTPS.  I wanted to use HMAC for my API since I wanted the user to be able to pre-sign requests to be used in the open.  This method enables me to keep HMAC for the usual administrative GUI as well.</p>
","1065","<javascript><hmac><cryptojs>","2","1","2","2015-05-31 17:41:09","18105421","0","","867395","","2013-08-08 07:37:13","2013-08-07 13:52:44",""
"46251506","CryptoJS PBKDF2 and salt hash method not working","<p>I am trying to use PBKDF2 and salt hashing from CryptoJS to store my password. This is the part where I hash the user password from registration:</p>

<pre><code>var passwordInput = document.getElementById(""txtPasswordInput"").value;
var salt = CryptoJS.lib.WordArray.random(128/8);
var key512Bits1000Iterations = CryptoJS.PBKDF2(passwordInput, salt, { keySize: 512/32, iterations: 1000 });

console.log(salt.toString());
console.log(key512Bits1000Iterations.toString());
</code></pre>

<p>With abcd1234 as password, I managed to store these into my database:</p>

<pre><code>Salt: cec16a7e68e0f3e49f729dfd90b0893a
Password: d974b96a494f39aec7f1fa6c495b4783b43e579c070b695...
</code></pre>

<p>At my login page, I am trying to compute the hash again based on user input to verify the credential:</p>

<pre><code>var passwordInput = document.getElementById(""txtPassword"").value;
// retrieve from firebase
var password = accountData.password;
var salt = accountData.salt;
var key512Bits1000Iterations = CryptoJS.PBKDF2(passwordInput, salt, { keySize: 512/32, iterations: 1000 });
console.log(salt.toString());
console.log(key512Bits1000Iterations.toString());

if(password != key512Bits1000Iterations){
console.log('wrong');
}else{
console.log('correct');
}
</code></pre>

<p>However, it kept returning me 'wrong'. I printed out the hashsed password and both of them are different though.</p>

<p>Also, after I pressed on the register or login button, the hashing algorithm actually took a while to compute before my browser returns to responsive again. Is the algorithm designed to be slow in computing? Any ideas how to overcome this?</p>

<p>Any ideas? Thanks!</p>
","<p>On login page, the salt needs to be parsed as hex. </p>

<p>Yes, PBKDF2 is designed to be slow.  You can speed it up with fewer iterations  at the cost of security. </p>
","1063","<javascript><hash><salt><cryptojs>","0","1","1","2017-09-16 07:58:47","","0","","","","","2017-09-16 07:45:45",""
"19720219","cryptojs doesn't return true base64 string after encryption","<p>I need to do encryption on plain text using AES CBC techinque but on javascript side. Basically i need to encrypt the URL 
and launch that  URL via ajax call. The system where URL is going to decrypt is wrote in c#. So i have to reply on their
encryption method which is written in c#. I need to use same logic in my javascript so that way it can be decrypt easily in c#</p>

<p>Javascript code</p>

<pre><code>var Base64encodedandencryptedtext = ""username=abc|password=xyz""
// have a password need to hash on that and then pass into aes encryption function
var hash =  CryptoJS.SHA512(""234-234-1231""); //password key
var finalhash = hash.toString((CryptoJS.enc.Base64));
Base64encodedandencryptedtext = CryptoJS.AES.encrypt(Base64encodedandencryptedtext ,finalhash)

var Base64encodedkey = Base64.encode(""encodedkey"");
var baseURL = ""https://www.xyz.com/""
var DHINquery = baseURL+""?key=""+Base64encodedkey+""&amp;value=""+Base64encodedandencryptedtext;

//launch via ajax

    $.ajax({
            type : 'GET',
            async : true,
            url : DHINquery,
            dataType : 'html',
            data : {},          
            success : function (htmlcontent) {
                $(""#htmlpage"").html(htmlcontent)                
            }, // end success
            complete : function (htmlcontent) {

            }, // end complete
            error : function (htmlcontent) {
            alert(""error"")
            }
        });
</code></pre>

<p>C# encryption on their side</p>

<pre><code>string Base64encodedandencryptedtext = ""username=abc|password=xyz""
Encrypt(Base64encodedandencryptedtext ,passwordkey, ""AES"") // call that function

 public static string Encrypt(string text, string keyguid, string cryptoService)
    {
        ICryptoTransform transform;
        string text1 = keyguid;
        UTF8Encoding enc = new UTF8Encoding();
        byte[] bytes = enc.GetBytes(text);
        string str = CalculateHashToBase64String(text1, enc, ""SHA512"");
        string s = str.Substring(4, 24);
        string str3 = str.Substring(0, 4) + str.Substring(0x1c, 4);
        string str4 = str.Substring(0, 4) + str.Substring(28, 12);
        string str5 = str.Substring(0, 4) + str.Substring(0x1c, 20);
        byte[] rgbKey = enc.GetBytes(s);
        string str7 = cryptoService;
        byte[] buffer3 = enc.GetBytes(str4);
        AesCryptoServiceProvider provider2 = new AesCryptoServiceProvider();
        provider2.Padding = PaddingMode.PKCS7;
        provider2.Mode = CipherMode.CBC;
        provider2.KeySize = 0x100;
        transform = provider2.CreateEncryptor(rgbKey, buffer3);
        return Convert.ToBase64String(Transform(bytes, transform)); // return the base64 string
    }
    private static byte[] Transform(byte[] input, ICryptoTransform CryptoTransform)
    {
        byte[] buffer;
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream stream2 = new CryptoStream(stream, CryptoTransform, CryptoStreamMode.Write))
            {
                stream2.Write(input, 0, input.Length);
                stream2.FlushFinalBlock();
                stream.Position = 0L;
                buffer = stream.ToArray();
            }
        }
        return buffer;
    }
</code></pre>

<p>While doing debuging on javascript side i am still getting base64string after encryption but c# encryption base64string and javascript
encryption base64string looks different. For that reason webservice doesn't succefully return the data.</p>

<p>I wonder aes plugin i were using is not doing exactly what they are doing in c# side.</p>

<p>Anybody have any idea why? Any help would be a great input.</p>
","<p>I see quite a few significant difference between how the two compute a key. In the JS, you're hashing a password key, then representing that hash's binary data as base64. Whereas in your C# code, it looks like you're representing the hash's binary data base base64, then taking a substring of that base64 string, then getting the UTF8 bytes of the base64 characters. Those are some really significant differences. The JS side can be simplified a bit, and the C# side can be simplified a lot. On both sides, take the hash of the password key, and use that hash itself as the key. Don't convert the hash to base64. Don't do any other manipulations.</p>

<p>** It would actually be better to use something like PBKDF2, but let's get both sides in sync first.</p>

<p>** Actually since the data is being sent through ajax, if you can use HTTPS, that would be the best option.</p>
","1046","<c#><javascript><encryption><aes><cryptojs>","0","0","1","2013-11-05 19:22:29","","5","","589259","","2013-11-03 14:09:55","2013-11-01 03:16:47",""
"28418128","CryptoJS equivalent of PyCrypto","<p>I'm trying to user CryptoJS under node to decrypt messages. I've got working Python code for decrypting the messages, but I need to run this under nodejs and would rather not call out to python for every message.</p>

<pre><code>from Crypto.Cipher import AES
from Crypto import Random
import base64

encrypted='tBIFLLdvl/Bp8XAwXBYatbJSYkNTl9/dXkHZd4OjbZ0I9Jg6xrAx/bxuQHuZrNSzYZOBEKbyMlTTT8nQEDza8wQ22mrRaZlQqT3aWpdZe6aiWAEIvTHoQPglgVbz1HnYOHfZtGmu3a3cwfpFMK+ouczTWM545nWvG/I4zV4uFgna1rW9sznxumN/3RKSbC1USZ2TM9PrG967M5Mu+riQfh9i/yt6ubwj3kln2+C0WsRRr44ELyDKGdS69YExa535z42bfXTORjvaiMvizvkz55c343s0G4ziT6tLfDCGELsrAu/2NViKxJZZRg8Dmm0FnchB9OQ4ujVCBoDUXvfx3iHjzquC+OftbOovQUecoXb7UfuwIxMekgSJnonLC45S'
key = '22&lt;\\09\\8e.==\\4#{{+!%i=]%Y/upi8!Z'
iv = '{+!%i=]%Y/upi8!Z'

cipher = AES.new(key, AES.MODE_CBC, iv)
print cipher.decrypt(base64.b64decode(encrypted))
</code></pre>

<p>This prints out my decrypted string from python. I'm sure my CryptoJS version is completely wrong at this point.</p>

<pre><code>var node_cryptojs = require('node-cryptojs-aes');
var CryptoJS = node_cryptojs.CryptoJS;
var key = CryptoJS.enc.Latin1.parse('22&lt;\\09\\8e.==\\4#{{+!%i=]%Y/upi8!Z');
var iv  = CryptoJS.enc.Latin1.parse('{+!%i=]%Y/upi8!Z');
var encrypted = 'tBIFLLdvl/Bp8XAwXBYatbJSYkNTl9/dXkHZd4OjbZ0I9Jg6xrAx/bxuQHuZrNSzYZOBEKbyMlTTT8nQEDza8wQ22mrRaZlQqT3aWpdZe6aiWAEIvTHoQPglgVbz1HnYOHfZtGmu3a3cwfpFMK+ouczTWM545nWvG/I4zV4uFgna1rW9sznxumN/3RKSbC1USZ2TM9PrG967M5Mu+riQfh9i/yt6ubwj3kln2+C0WsRRr44ELyDKGdS69YExa535z42bfXTORjvaiMvizvkz55c343s0G4ziT6tLfDCGELsrAu/2NViKxJZZRg8Dmm0FnchB9OQ4ujVCBoDUXvfx3iHjzquC+OftbOovQUecoXb7UfuwIxMekgSJnonLC45S';
var plaintextArray = CryptoJS.AES.decrypt({ ciphertext: encrypted }, key, { iv: iv } );
console.log(CryptoJS.enc.Latin1.stringify(plaintextArray));
</code></pre>

<p>All I get out of this version is a bunch of garbled text such as</p>

<pre><code>{)Lu[?[ )d0(g  99db*qf pr(&gt;?C$M#&lt;o_s=,)u&lt;XDPq|f^IiaJ__Njbp8.}ucsLq&amp;LYLh
</code></pre>
","<p>Turns out I was one encoding away from correct. The Latin1 parses are correct. It was just the decode from base64 on the input that was missing. Must have missed that combination earlier.</p>

<pre><code>var node_cryptojs = require('node-cryptojs-aes');
var CryptoJS = node_cryptojs.CryptoJS;
var key = CryptoJS.enc.Latin1.parse('22&lt;\\09\\8e.==\\4#{{+!%i=]%Y/upi8!Z');
var iv  = CryptoJS.enc.Latin1.parse('{+!%i=]%Y/upi8!Z');
var encrypted = 'tBIFLLdvl/Bp8XAwXBYatbJSYkNTl9/dXkHZd4OjbZ0I9Jg6xrAx/bxuQHuZrNSzYZOBEKbyMlTTT8nQEDza8wQ22mrRaZlQqT3aWpdZe6aiWAEIvTHoQPglgVbz1HnYOHfZtGmu3a3cwfpFMK+ouczTWM545nWvG/I4zV4uFgna1rW9sznxumN/3RKSbC1USZ2TM9PrG967M5Mu+riQfh9i/yt6ubwj3kln2+C0WsRRr44ELyDKGdS69YExa535z42bfXTORjvaiMvizvkz55c343s0G4ziT6tLfDCGELsrAu/2NViKxJZZRg8Dmm0FnchB9OQ4ujVCBoDUXvfx3iHjzquC+OftbOovQUecoXb7UfuwIxMekgSJnonLC45S';
var plaintextArray = CryptoJS.AES.decrypt({ ciphertext: CryptoJS.enc.Base64.parse(encrypted) }, key, { iv: iv } );
console.log(CryptoJS.enc.Latin1.stringify(plaintextArray));
</code></pre>
","1042","<python><node.js><encryption><cryptojs>","0","0","1","2015-02-09 21:22:51","28419642","2","","4547744","","2015-02-09 21:16:47","2015-02-09 19:54:05",""
"49708927","Encryption and decryption with AES Crypto-JS does not work as it should","<p>I have two difference html page, in the first one there is a form that on submit call a Javascript function to encrypt two different parameter after that these two parameter are sent in get to the second page, following the code of the first html page:</p>

<p>

    
        
        
        </p>

<pre><code>    &lt;meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"" /&gt;
    &lt;title&gt;Test Encrypt&lt;/title&gt;

    &lt;script type=""text/javascript""&gt;


    /**
    Function to encrypt in AES tex
    **/
    function encText(plainText){

        var salt = CryptoJS.enc.Utf8.parse(""12345678"");

        var password = ""test"";
        var keyBits = CryptoJS.PBKDF2(password, salt, {
            hasher: CryptoJS.algo.SHA1,
            keySize: 8,
            iterations: 2048
        });
        console.log(keyBits.toString(CryptoJS.enc.Base64));

        var iv = CryptoJS.enc.Base64.parse(""dGVzdGFhYTAxMjM1Njc4OQ=="");

        var encrypted = CryptoJS.AES.encrypt(plainText, keyBits, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
        });

        //var decrypted = CryptoJS.AES.decrypt(encrypted, key).toString(CryptoJS.enc.Utf8);
        //var decrypted = encrypted.toString(CryptoJS.enc.Utf8)

        //var decrypted = CryptoJS.enc.Utf8.stringify(encrypted);
        return encrypted.toString();


    }

    function formEncrypt(){
        var name = document.getElementById(""name"").value;
        var surname = document.getElementById(""surname"").value;

        var encName = encText(name);
        var encSurname = encText(surname);

        document.getElementById(""name"").value = encName;
        document.getElementById(""surname"").value = encSurname;

    }

    &lt;/script&gt;
&lt;/head&gt;


&lt;form action=""/decrypt.php""  method=""get"" name=""myForm""&gt;
    name: &lt;input type=""text"" name=""name"" id=""name""&gt;&lt;br&gt;
    surname: &lt;input type=""text"" name=""surname"" id=""surname""&gt;&lt;br&gt;
&lt;input type=""submit"" value=""Submit"" onclick=""formEncrypt()""&gt;
</code></pre>

<p></p>

<p></p>

<p>In the second page using a JavaScript function I try to  decipher the two parameters values, following the code of the second page:</p>

<p>

    
        
        
        
        </p>

<pre><code>    &lt;meta http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"" /&gt;
    &lt;title&gt;Decrypt&lt;/title&gt;

    &lt;?php
    echo '&lt;script type=""text/javascript""&gt;';
    echo 'var encName = \'' . base64_encode ( $_GET['name'] ). '\';';
    echo 'var encSurname = \'' . base64_encode ( $_GET['surname'] ) . '\';';
    echo '&lt;/script&gt;';
    ?&gt;

    &lt;script type=""text/javascript""&gt;

        function decText(encryptedText){

            //var message = CryptoJS.enc.Base64.parse(encryptedText);

            var salt = CryptoJS.enc.Utf8.parse(""12345678"");

            var password = ""test"";
            var keyBits = CryptoJS.PBKDF2(password, salt, {
                hasher: CryptoJS.algo.SHA1,
                keySize: 8,
                iterations: 2048
            });
            console.log(keyBits.toString(CryptoJS.enc.Base64));

            var iv = CryptoJS.enc.Base64.parse(""dGVzdGFhYTAxMjM1Njc4OQ=="");

            var result = CryptoJS.AES.decrypt(CryptoJS.enc.Base64.parse(encryptedText), keyBits, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            });

            console.log(result.toString(CryptoJS.enc.Utf8));

            return result.toString(CryptoJS.enc.Utf8)
        }

        function yoo(){
            console.log(encName);
            console.log(encSurname);
            var name = decText(encName);
            var surname = decText(encSurname);
            $('#pName').text(name);
            $('#pSurname').text(surname);
            //document.getElementById(""pName"").value += name;
            //document.getElementById(""pSurname"").value += surname;
        }


    &lt;/script&gt;


&lt;/head&gt;
&lt;body&gt;

    &lt;p&gt;Yooooo&lt;/p&gt;

    &lt;p id=""pName""&gt; &lt;/p&gt;
    &lt;p id=""pSurname""&gt; &lt;/p&gt;

    &lt;button onclick=""yoo()""&gt;clearText&lt;/button&gt;

&lt;/body&gt;
</code></pre>

<p></p>

<p>But the result is always a blank string, I think there is a mistake but I don't find where.</p>
","<p>To decode a base64 string, pass the parsed object containing the word array to the stringify function for the Utf8 encoder. <em>i.e.</em> <code>CryptoJS.enc.Utf8.stringify(parsedObjectContainingWordArray)</code></p>

<pre><code>const encName = '&lt;?php echo base64_encode($_POST[""surname""]); ?&gt;';
const encSurname = '&lt;?php echo base64_encode($_POST[""name""]); ?&gt;';

function decText(encryptedText) {
  const salt = CryptoJS.enc.Utf8.parse(""12345678"");
  const password = ""test"";
  const keyBits = CryptoJS.PBKDF2(password, salt, {
    hasher: CryptoJS.algo.SHA1,
    keySize: 8,
    iterations: 2048
  });
  const iv = CryptoJS.enc.Base64.parse(""dGVzdGFhYTAxMjM1Njc4OQ=="");
  const result = CryptoJS.AES.decrypt(
    // This here is where the action is. If the wrong value gets passed,
    // result turns out to be empty string.
    CryptoJS.enc.Utf8.stringify(CryptoJS.enc.Base64.parse(encryptedText)),
    keyBits, {
      iv: iv,
      padding: CryptoJS.pad.Pkcs7,
      mode: CryptoJS.mode.CBC
    }
  );

  return result.toString(CryptoJS.enc.Utf8)
}

function yoo() {
  const nameNode = document.getElementById(""pName"");
  const surnameNode = document.getElementById(""pSurname"");
  nameNode.textContent = decText(encName);
  surnameNode.textContent = decText(encSurname);
}
</code></pre>
","1038","<javascript><html><encryption><aes><cryptojs>","0","2","1","2018-04-07 20:00:50","49710171","1","","","","","2018-04-07 15:29:53",""
"48963747","How to decrypt data in PHP encrypted with JSEncrypt","<p>I'm trying to secure communication between a JS front-end and a PHP backend by using symmetric and asymmetric encryption. I'm creating a symmetric key on the client and encrypting it with the server's public key with JSEncrypt and sending it to the server for future use. However, I'm getting stuck when I get the data on the server side. openssl_open requires an envelope to decrypt the symmetric key and I'm not even positive what data is supposed to be in the envelope. I was under the impression that the envelope is the symmetric key that was encrypted with the public key, but using that has not worked. I've also tried different combinations of decoding as I've read that JSEncrypt encodes the message in base 64 and the key in hex, but those attempts are fruitless as well.</p>

<p><b>JS encryption code:</b></p>

<pre><code>let pub = ""-----BEGIN PUBLIC KEY-----...-----END PUBLIC KEY-----"";

//I have a function that just creates a random string of characters
let key = generateKey(32);
let aesData = CryptoJS.AES.encrypt( ""test"", key );
let symKey = aesData.key + "":::"" + aesData.iv;
let msg = aesData.toString();

let rsa = new JSEncrypt();
rsa.setPublicKey( pub );
let cryptKey = rsa.encrypt( symKey );

//I'm passing the data through a hidden form field
$(""#key"").val(cryptKey + "":::"" + msg);
</code></pre>

<p><b>PHP decryption code:</b></p>

<pre><code>$key = openssl_get_privatekey( file_get_contents( $_SERVER[""PRIV_KEY""]) );
$encryptedKey = explode( "":::"", $msg )[0];
$realMsg = base64_decode(explode( "":::"", $msg )[1]);

openssl_open($realMsg, $decrypted, $encryptedKey, $key);
return $decrypted;
</code></pre>

<p>The code above outputs nothing because the openssl_open call fails (returns false). When I base 64 decode the $encryptedKey variable, I get:</p>

<pre><code>vEipd_@JE
</code></pre>

<p>but the symmetric key changes every time, so the output changes every time as well. Like I said, I've tried different encoding combinations, but they all return similar nonsense. As the JS code shows, I've encrypted the message ""test"".</p>

<p>I've never implemented encryption before, so I might be way off the mark here, but after staring at this code for days, any insight would be appreciated.</p>

<p>Edit: I'm having problems decrypting with my private key in PHP, not with the symmetric key</p>
","<p>Figured it out!!! So, I found out that PHP has a function to decrypt without needing an envelope called <a href=""http://php.net/manual/en/function.openssl-private-decrypt.php"" rel=""nofollow noreferrer"">openssl_private_decrypt</a> that uses a private key to decrypt a message. By using that function and base 64 decoding the encrypted key, I am able to decrypt the symmetric key on the server side and will hopefully be able to decrypt the message symmetrically now. For those interested, my code on the server side is:</p>

<pre><code>$key = openssl_get_privatekey( file_get_contents( $_SERVER['PRIV_KEY'] ) );
$encryptedKey = base64_decode(explode( "":::"", $msg )[0]);

if( openssl_private_decrypt($encryptedKey, $decrypted, $key) )
{
    return $decrypted;
}
return $encryptedKey;
</code></pre>

<p>And on the client side, my code is the same as it was above. Hope this helps someone!</p>
","1030","<php><cryptojs><encryption-asymmetric><php-openssl><jsencrypt>","2","2","1","2018-02-25 19:16:32","","5","2","9405842","","2018-02-24 19:49:18","2018-02-24 14:12:00",""
"50979762","Uncaught TypeError: Cannot read property '0' of undefined CryptoJS","<p>I am using CryptoJS and I keep getting Uncaught TypeError.
Basically, when I try to send the message an encrypt it, that is when I end up getting the error.</p>

<p>The error I am getting is within the cryptoJS package. Line 256 starts at 
<code>var encrypted = CryptoJS.AES.encrypt(myString, myPassword);</code></p>

<p>I am assuming the issue is within the piece of code I have listed below, or there it is when I have been importing the package.</p>

<p><a href=""https://i.stack.imgur.com/SAJVy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/SAJVy.png"" alt=""enter image description here""></a></p>

<pre><code>    var myString = messageInput.value;
    var myPassword = 11111;
    var encrypted = CryptoJS.AES.encrypt(myString, myPassword);
</code></pre>
","<p>Answer written from comments in OP.</p>

<p>Password be a string not a number. Rather than entering ""11111"" to test try ""testpassword"".</p>
","1018","<javascript><cryptojs>","3","2","1","2018-06-22 02:57:57","50980023","4","","2487517","","2018-06-22 02:54:34","2018-06-22 02:18:33",""
"16123580","PHP Equivalent of sha1.toString(CryptoJS.enc.Base64)","<p>I am converting a JS script into PHP.
The script uses the CryptoJS library and generates a hash using the following line:</p>

<pre><code>var sha1 = CryptoJS.SHA1(""message"");
var sig = sha1.toString(CryptoJS.enc.Base64);
</code></pre>

<p>I have tried this php code</p>

<pre><code>$sha1 = sha1(""message"");
$sig = base64_encode($sha1);
</code></pre>

<p>But the signature isn't the same, it's longer in php.</p>

<p>Your help is very much appreciated and needed !</p>

<p>John</p>
","<p>Ok I just needed to set $raw_output to true in the sha1 function !</p>

<pre><code>$sha1 = sha1(""message"", true);
</code></pre>

<p>Now I look silly</p>
","1013","<base64><sha1><cryptojs>","0","1","1","2013-04-20 18:23:09","16123698","0","","","","","2013-04-20 18:09:16",""
"45923666","crypto-js decrypt from Hex","<p>I am trying to make a JavaScript function with package crypto-js to decode AES (CBC mode).</p>

<p>I input the data in an online decoding tool and it decrypted correctly, so I am sure the following data is correct, but I just can't reproduce it by JavaScript.</p>

<p>Here is the online decrypting (so I'm sure the data, key, iv are correct): <a href=""http://aes.online-domain-tools.com/link/deb718giF4dUxZylq/"" rel=""nofollow noreferrer"">http://aes.online-domain-tools.com/link/deb718giF4dUxZylq/</a></p>

<p>My code with crypto-js@3.1.8: </p>

<pre><code>// data, key, iv are all Hex
var data = ""bd6e0a73147a2c224c7c20346d0e9a138b744a5d94463cdff6dbb965055f974f097104399d2c40af2f0ac667f3857e70e9703bf27f6411f7e97c3449e8921f3c98e665914689b4b77b5bbcc8d8bc319e680eb89eedb1c25178923ae57fb3fb476755d6009f1aed88fffcb9b2ed3b4cf6f23d9c4c56da1dde6619e45a8d6f06412853ae1941cf554b6824112a913750a7485ed67fb38b950411310410de998f2597c2fcc81a305b0df369f54b75426176"";
var key = 'befce5c6da98837ea421811c832817ae';
var iv = ""a884a7edd5d06a48d6da9ad11fd36a75"";
// transfer Hex to WordArray
var _data = CryptoJS.enc.Hex.parse(data);
var base64_data = _data.toString(CryptoJS.enc.Base64);
var _key = CryptoJS.enc.Hex.parse(key);
var _iv = CryptoJS.enc.Hex.parse(iv);

decrypted = CryptoJS.AES.decrypt(
  base64_data, // pass base64
  _key,  // pass WordArray
  {iv: _iv, // pass WordArray
   mode: CryptoJS.mode.CBC,
   padding: CryptoJS.pad.ZeroPadding
  })
console.log(decrypted.toString(CryptoJS.enc.Utf8));
// out put fail to match Utf8
</code></pre>

<p>It output Error: Malformed UTF-8 data</p>

<p>The decoded string should be: (the link is not important)</p>

<pre><code>https://emogo-media-testing.s3.amazonaws.com/1503342403787_blob?AWSAccessKeyId=AKIAI5MUDCK6XYWKGAKA&amp;Expires=1534882403&amp;Signature=t1PFesQuOpOlIMKoOqje%2Bs7I%2Fhg 
</code></pre>

<p>Any hint is appreciated. Thank you!</p>
","<p>I know it has been a while since you asked the question but I will respond just so the next person does not stumble upon an unanswered question.</p>

<p>Your code works fine, it decrypts AES.CBC encrypted data correct, the problem lies with your input <code>data</code>.</p>

<p>Your encrypted <code>data</code> string should have looked like:</p>

<pre><code>80b7c4881334675693ef9c95259e70b24d0736e98f8424233d5e37f353261c2a589287bc3f675449f7d8ed4e2289a4c06b22d7f83efc09cfb72abe3a76e193a8efbdc968232d29b9b58135bfa24d51e60e34791f652a0aa806d0be7734dd61a930a30c99f31f08740cdb182af07b19d5b4274deb958d984b3ccb9d6e2be0cfa3a026dd6b734dbf1dd3635bc7bcceface9c55dfb9455ca834a6dbd1aa0f3c23923ce6aeba59acbc80d681fee73487b9004496540830d44102b94e35eac291c4e3b8c9ac168ae799e46cde45ee652415ae69992d0f7527045fd42b82e9e6946cfb2dbcc3b93f19ff0e5035ab12250f7a917975b2f7c069cbd8a0ba0d94b318634a
</code></pre>

<p>for this example to work correctly.</p>

<p>The key you used is not a hex string but a text string. Your online example is no longer valid but I figured it out after a couple of tries.</p>

<p>If change the following line:</p>

<pre><code>var _key = CryptoJS.enc.Hex.parse(key);
</code></pre>

<p>to:</p>

<pre><code>var _key = CryptoJS.enc.Utf8.parse(key);
</code></pre>

<p>Your code example will work fine with your original data string.</p>

<p>When you decrypted the text on <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://aes.online-domain-tools.com/</a> you probably had the plaintext textbox selected instead of hex for your key input.</p>
","1004","<aes><cryptojs>","0","1","1","2018-03-22 17:42:17","49435206","0","","","","","2017-08-28 16:36:51",""
"31650675","Encrypting with CryptoJS and decrypt with php: What is the use of the IV?","<p>I am looking for a way, to encrypt a password in CryptoJS and then decrypt it in php. I have looked at other posts concerning the same subject, but I need someone to explain all that IV and key stuff.</p>

<p>My CryptoJS encryption code:</p>

<pre><code>password = document.getElementById(""usrp"").value;
password = CryptoJS.AES.encrypt(password, &lt;?php echo '""'.$_SESSION['adk'].'""'; ?&gt;);
</code></pre>
","<h1>IV</h1>

<p>You're using the CBC mode of operation which requires an IV. If you use a static IV for all your ciphertexts then you miss out on an important property of encryption which is semantic security. If you use the same IV, attackers may observe your ciphertext and determine whether you sent the same plaintext with the same key, because the ciphertext will be the same.</p>

<p>To prevent that, you can generate a random IV for each encryption you do. The IV doesn't have to be secret, but it has to be unpredictable. Since it doesn't have to be secret, you can simply prepend it to the ciphertext and slice it off before decryption or send it otherwise in a structured fashion. You need to use IV during decryption. Otherwise, the first block will be different from the original plaintext.</p>

<p>Keep in mind that CryptoJS' <code>WordArray.random()</code> uses <code>Math.random()</code> internally which is not cryptographically secure. It would be better to use a better randomness source. You can use this drop in replacement from <a href=""https://github.com/artjomb/cryptojs-extension/blob/master/src/random.js"" rel=""nofollow"">my project</a> of that function for semi-modern browsers which uses the WebCrypto API:</p>

<pre><code>(function(C){
    var WordArray = C.lib.WordArray;
    var crypto = window.crypto;
    var TypedArray = Int32Array;
    if (TypedArray &amp;&amp; crypto &amp;&amp; crypto.getRandomValues) {
        WordArray.random = function(nBytes){
            var array = new TypedArray(Math.ceil(nBytes / 4));
            crypto.getRandomValues(array);
            return new WordArray.init(
                    [].map.call(array, function(word){
                        return word
                    }),
                    nBytes
            );
        };
    } else {
        console.log(""No cryptographically secure randomness source available"");
    }
})(CryptoJS);
</code></pre>

<p>and use it like this:</p>

<pre><code>var iv = CryptoJS.lib.WordArray.random(128/8);
</code></pre>

<h1>Key</h1>

<p>The key is trickier, because it needs to be kept confidential. The basic way is:</p>

<p>Let the user type in the password that is also present on the server and derive the key from the password by for example using PBKDF2 which CryptoJS also provides. <em>Perfectly secure as long as you use TLS and the developers don't change the code.</em></p>
","996","<javascript><php><encryption><cryptojs><initialization-vector>","-1","2","1","2015-07-27 17:37:23","31651483","8","","1816580","","2015-07-27 11:08:42","2015-07-27 10:25:21",""
"47890732","Digital Envelope Routines: Bad Decrypt","<p>I am encrypting an <code>object</code> in the frontend and sending an HTTP POST request with the encrypted data. In the backend I am trying to decrypt this object but it fails.</p>

<p>The tests are passing but when integrated to the actual project this <code>decrypt</code> method fails with error:</p>

<blockquote>
  <p>Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt at Error (native) at Decipher.final (crypto.js:158:26) at Object.exports.decrypt.error [as decrypt]</p>
</blockquote>

<p>Here is the relevant code:</p>

<pre><code>export const decrypt = text =&gt; {
  if (!text)
    throw Error('Decrypt: Text may not be blank');
  const decipher = crypto.createDecipher(encryptAlgorithm, 
  encryptionKey)
  let decrypted = decipher.update(text, textEncodingHex, 
  textEncodingUtf8)
  decrypted += decipher.final(textEncodingUtf8)
  return decrypted
}
</code></pre>

<p>And this is how I am using it</p>

<pre><code>authSignInWeb(): any {
  return async (request: any, reply: any) =&gt; {
    try {
      let decrytedRequestPayload = request.payload;
      if (process.env.REACT_APP_ENCRYPT) {
        decrytedRequestPayload = JSON.parse(cryptoHelper.decrypt(request.payload))
      }
      ...
    } catch (error) {
       reply(error);
      ...
    }
  };
};
</code></pre>
","<p>After going through the Documentation and other online resources I managed to solve this problem. What made this fail is that HapiJs takes the incoming payload, parses it, and pass it down to the <code>authSignInWeb()</code> as a Javascript object with the actual payload as the key in that object it makes on my behalf.</p>

<p>To solve this I had to, in the frontend, encrypt the data, manually create an object and assign the encrypted information. And then in the backend access the payload's key of the object.</p>

<p>In code:</p>

<p>The frontend is like so:</p>

<pre><code>let encryptedData = {};
if (process.env.REACT_APP_ENCRYPT) {
  encryptedData.data = Crypt.encrypt(JSON.stringify(requestBody))
}
</code></pre>

<p>and then in the backend (inside <code>authSignInWeb()</code>) do:</p>

<pre><code> let userAuthData = request.payload;
 if (process.env.REACT_APP_ENCRYPT) {
   userAuthData = JSON.parse(cryptoHelper.decrypt(userAuthData.data))
 }
</code></pre>
","996","<javascript><hapijs><cryptojs>","0","0","1","2017-12-19 16:35:17","47891254","1","","6219957","","2017-12-19 16:35:17","2017-12-19 15:58:56",""
"33050368","CryptoJS not decrypting non-Latin characters faithfully","<p>I am trying to use CryptoJS AES, like so:</p>

<pre><code>var msg = ""caf"";
var key = ""something"";
var c = CryptoJS.AES.encrypt(msg, key).toString();
CryptoJS.AES.decrypt(c, key).toString(CryptoJS.enc.Latin1);
</code></pre>

<p>Unfortunately this returns <code>caf</code>, not <code>caf</code>. Clearly Latin1 is not the right encoding to use, but I can't find a better one. Is there a solution?</p>

<p>Thanks.</p>
","<p>You are just missing the format <br/>
The proper way is using  <code>CryptoJS.enc.Utf8</code></p>

<p>So, Please try:</p>

<p><code>CryptoJS.AES.decrypt(c, key).toString(CryptoJS.enc.Utf8);</code></p>
","995","<javascript><cryptojs><latin1>","1","2","3","2015-10-10 05:34:12","33050439","0","","","","","2015-10-10 04:41:46",""
"33050368","CryptoJS not decrypting non-Latin characters faithfully","<p>I am trying to use CryptoJS AES, like so:</p>

<pre><code>var msg = ""caf"";
var key = ""something"";
var c = CryptoJS.AES.encrypt(msg, key).toString();
CryptoJS.AES.decrypt(c, key).toString(CryptoJS.enc.Latin1);
</code></pre>

<p>Unfortunately this returns <code>caf</code>, not <code>caf</code>. Clearly Latin1 is not the right encoding to use, but I can't find a better one. Is there a solution?</p>

<p>Thanks.</p>
","<p>You are trying to decrypt your data as a Latin1 string, even though your input string is not in Latin1. The encoding used by CryptoJS internally is not the same as the encoding you use to write the input file.</p>

<p>You need to specify the same encoding both when encrypting (for the string -> byte array conversion) and when decrypting (for the byte array -> string conversion).</p>
","995","<javascript><cryptojs><latin1>","1","-2","3","2015-10-10 05:34:12","33050439","0","","","","","2015-10-10 04:41:46",""
"33050368","CryptoJS not decrypting non-Latin characters faithfully","<p>I am trying to use CryptoJS AES, like so:</p>

<pre><code>var msg = ""caf"";
var key = ""something"";
var c = CryptoJS.AES.encrypt(msg, key).toString();
CryptoJS.AES.decrypt(c, key).toString(CryptoJS.enc.Latin1);
</code></pre>

<p>Unfortunately this returns <code>caf</code>, not <code>caf</code>. Clearly Latin1 is not the right encoding to use, but I can't find a better one. Is there a solution?</p>

<p>Thanks.</p>
","<p><a href=""https://code.google.com/p/crypto-js/#The_Hasher_Input"" rel=""nofollow"">https://code.google.com/p/crypto-js/#The_Hasher_Input</a></p>

<blockquote>
  <p>The hash algorithms accept either strings or instances of CryptoJS.lib.WordArray [...] an array of 32-bit words. When you pass a string, it's <strong><em>automatically converted to a WordArray encoded as UTF-8</em></strong>.</p>
</blockquote>

<p>So, when you pass a string (and don't use CryptoJS.enc.* to generate a <code>WordArray</code>) it automatically converts the string (<code>message</code>) to a utf8 <code>WordArray</code>.</p>

<p>See here for sample roundtrip encrypt/decrypt:
<a href=""https://code.google.com/p/crypto-js/#The_Cipher_Output"" rel=""nofollow"">https://code.google.com/p/crypto-js/#The_Cipher_Output</a></p>

<p>Here's a jsfiddle to play with CryptoJS
<a href=""https://jsfiddle.net/8qbf4746/4/"" rel=""nofollow"">https://jsfiddle.net/8qbf4746/4/</a></p>

<pre><code>var message = ""caf"";
var key = ""something"";

var encrypted = CryptoJS.AES.encrypt(message, key);
//equivalent to CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(message), key);
var decrypted = CryptoJS.AES.decrypt(encrypted, key);

$('#1').text(""Encrypted: ""+encrypted);
$('#2').text(""Decrypted: ""+decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>To emphasize my point here is the same thing using Latin1 encoding:
<a href=""https://jsfiddle.net/3a8tf48f/2/"" rel=""nofollow"">https://jsfiddle.net/3a8tf48f/2/</a></p>

<pre><code>var message = ""caf"";
var key = ""something"";

var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Latin1.parse(message), key);
var decrypted = CryptoJS.AES.decrypt(encrypted, key);

$('#1').text(""Encrypted: "" + encrypted);
$('#2').text(""Decrypted: "" + decrypted.toString(CryptoJS.enc.Latin1));
</code></pre>

<p>On a side note, the API would probably be better if it only accepted <code>WordArray</code> and didn't overload the toString method (which is just a convenience interface to CryptoJS.enc.*.stringify).  The string conversion magic is a little misleading.</p>
","995","<javascript><cryptojs><latin1>","1","2","3","2015-10-10 05:34:12","33050439","0","","","","","2015-10-10 04:41:46",""
"43891039","Need help decrypting an AES encrypted string with Javascript (using crypto-js)","<p>I found that someone had written a demo page that encrypts data on the client side with CryptoJS, which is here:</p>

<pre><code>https://github.com/odedhb/AES-encrypt
</code></pre>

<p>It only has an encrypt function, so I added what I thought would be a decrypt function but end up with completely different text as a result.</p>

<p>My entire test page:</p>

<pre><code>&lt;html&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;

&lt;br&gt;text:&lt;input id='text' type='text' value='0.1'/&gt;

&lt;br&gt;password:&lt;input id='pass' type='text' value='cool'/&gt;

&lt;br&gt;&lt;button onclick=""encrypt()""&gt;encrypt&lt;/button&gt;
&lt;br&gt;&lt;button onclick=""decrypt()""&gt;decrypt&lt;/button&gt;


&lt;br&gt;encrypted:&lt;br&gt;&lt;input id='result'&gt;&lt;/input&gt;


&lt;br&gt;decrypted:&lt;br&gt;&lt;span id=""decode""&gt;&lt;/span&gt;

&lt;script&gt;
    function encrypt(){

        var encrypted = CryptoJS.AES.encrypt(document.getElementById(""text"").value, document.getElementById(""pass"").value);
        document.getElementById(""result"").value = encrypted;
    }

    function decrypt(){

        var decrypted = CryptoJS.AES.decrypt(document.getElementById(""result"").value, document.getElementById(""pass"").value);
        document.getElementById(""decode"").innerHTML = decrypted;
    }

&lt;/script&gt;

&lt;/html&gt;
</code></pre>

<p>On this page, if I enter <code>Hi I'm Lucas</code> as the plaintext (no quotes), with a password of <code>passwd</code>, I receive back a string of this: <code>U2FsdGVkX1/S3TobCOdyJ7k7eaBhdFKRpJkDBTpV1D0=</code></p>

<p>If i go on to click the decrypt button, I don't get any errors, but i just get a result of <code>48692049276d204c75636173</code>.</p>

<p>Obviously, I've done something wrong, and am hoping for an assist here :)</p>
","<p>From <a href=""https://github.com/brix/crypto-js#plain-text-encryption"" rel=""nofollow noreferrer"">this</a>, it seems the following should work:</p>

<pre><code>document.getElementById(""decode"").innerHTML = decrypted.toString(CryptoJS.enc.Utf8)
</code></pre>
","993","<javascript><encryption><encoding><aes><cryptojs>","0","1","1","2017-05-10 18:08:46","43891154","0","","1816580","","2017-05-10 18:08:46","2017-05-10 11:22:57","2017-05-10 18:08:51"
"54087514","Asymmetric Encryption using Nodejs Crypto module","<p>I want to use the crypto module of nodejs10, to make an asymmetric encryption. </p>

<p>I find the answer <a href=""https://stackoverflow.com/questions/8750780/encrypting-data-with-public-key-in-node-js"">here</a> 
But when I try to run the code below I got this error: </p>

<pre><code>return method(toBuf(key), buffer, padding, passphrase);
           ^
Error: error:0608B096:digital envelope routines:EVP_PKEY_encrypt_init:operation not supported for this keytype.
</code></pre>

<p>The code:</p>

<pre><code>var crypto = require(""crypto"");
var path = require(""path"");
var fs = require(""fs"");
const passphrase = ""mySecret""

var encryptStringWithRsaPublicKey = function(toEncrypt, relativeOrAbsolutePathToPublicKey) {
  var absolutePath = path.resolve(relativeOrAbsolutePathToPublicKey);
  var publicKey = fs.readFileSync(absolutePath, ""utf8"");
  var buffer = new Buffer(toEncrypt);
  var encrypted = crypto.publicEncrypt(publicKey, buffer);
  return encrypted.toString(""base64"");
};

var decryptStringWithRsaPrivateKey = function(toDecrypt, relativeOrAbsolutePathtoPrivateKey) {
  var absolutePath = path.resolve(relativeOrAbsolutePathtoPrivateKey);
  var privateKey = fs.readFileSync(absolutePath, ""utf8"");
  var buffer = new Buffer(toDecrypt, ""base64"");
  //var decrypted = crypto.privateDecrypt(privateKey, buffer);
  const decrypted = crypto.privateDecrypt(
    {
      key: privateKey.toString(),
      passphrase: passphrase,
    },
    buffer,
  )
  return decrypted.toString(""utf8"");
};

const { writeFileSync } = require('fs')
const { generateKeyPairSync } = require('crypto')

function generateKeys() {
  const { privateKey, publicKey } = generateKeyPairSync('ec', {
    namedCurve: 'secp256k1',
    publicKeyEncoding: {
      type: 'spki',
      format: 'pem',
    },
    privateKeyEncoding: {
      type: 'pkcs8',
      format: 'pem',
      cipher: 'aes-256-cbc',
      passphrase: passphrase,
    },
  })

  writeFileSync('private.pem', privateKey)
  writeFileSync('public.pem', publicKey)
}

generateKeys();

let a = encryptStringWithRsaPublicKey(""hello"", ""public.pem"")
let b = decryptStringWithRsaPrivateKey(a, ""private.pem"");
console.log(b)
</code></pre>

<p>I didn't find what is the problem, it seems like the problem with the passphrase.</p>
","<p>Updating a few parameters on the private key generation will make this work:</p>

<pre><code>var crypto = require(""crypto"");
var path = require(""path"");
var fs = require(""fs"");
const passphrase = ""mySecret""

var encryptStringWithRsaPublicKey = function(toEncrypt, relativeOrAbsolutePathToPublicKey) {
    var absolutePath = path.resolve(relativeOrAbsolutePathToPublicKey);
    var publicKey = fs.readFileSync(absolutePath, ""utf8"");
    var buffer = new Buffer(toEncrypt);
    var encrypted = crypto.publicEncrypt(publicKey, buffer);
    return encrypted.toString(""base64"");
};

var decryptStringWithRsaPrivateKey = function(toDecrypt, relativeOrAbsolutePathtoPrivateKey) {
    var absolutePath = path.resolve(relativeOrAbsolutePathtoPrivateKey);
    var privateKey = fs.readFileSync(absolutePath, ""utf8"");
    var buffer = new Buffer(toDecrypt, ""base64"");
    //var decrypted = crypto.privateDecrypt(privateKey, buffer);
    const decrypted = crypto.privateDecrypt(
        {
            key: privateKey.toString(),
            passphrase: passphrase,
        },
        buffer,
    )
    return decrypted.toString(""utf8"");
};

const { writeFileSync } = require('fs')
const { generateKeyPairSync } = require('crypto')

function generateKeys() {
    const { publicKey, privateKey } = generateKeyPairSync('rsa', 
    {
            modulusLength: 4096,
            namedCurve: 'secp256k1', 
            publicKeyEncoding: {
                type: 'spki',
                format: 'pem'     
            },     
            privateKeyEncoding: {
                type: 'pkcs8',
                format: 'pem',
                cipher: 'aes-256-cbc',
                passphrase: passphrase
            } 
    });

    writeFileSync('private.pem', privateKey)
    writeFileSync('public.pem', publicKey)
}

generateKeys();

let a = encryptStringWithRsaPublicKey(""hello"", ""public.pem"")
let b = decryptStringWithRsaPrivateKey(a, ""private.pem"");
console.log(b)
</code></pre>
","989","<node.js><cryptojs><encryption-asymmetric>","1","2","1","2019-01-13 05:28:06","54088190","0","1","1033581","","2019-01-13 05:28:06","2019-01-08 08:04:17",""
"45034471","Password-based AES encryption on Android and decryption with CryptoJS","<p>On Android I have no problem encrypting a message and getting the iv.</p>

<pre><code>String Test = ""Lorem ipsum dolor sit amet, ..."";
String password = ""test"";

KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(password.getBytes(""UTF8""));
kgen.init(256, sr);
SecretKey skey = kgen.generateKey();

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
SecretKeySpec skeySpec = new SecretKeySpec(skey.getEncoded(), ""AES"");
c.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] decrypted = c.doFinal(Test.getBytes());
decrypted = Base64.encodeBase64(decrypted);
byte[] iv = Base64.encodeBase64(c.getIV());
Log.d(""encryptString"", new String(decrypted));
Log.d(""encryptString iv"", new String(iv));
</code></pre>

<p>Output example:</p>

<pre><code>encryptString: 2NVoJzMkPphwUJc2h/4LfsmAwyJlejbWKGLG2ACNbaI=
encryptStringiv: YX5SF+cFwzv1I4OiGrJk3A==
</code></pre>

<p>When I move over to the JavaScript side I first convert the base64 encoding to bytes. Then I run it through the CryptoJS AES Decrypt function.</p>

<pre><code>var decrypt = CryptoJS.enc.Base64.parse(""2NVoJzMkPphwUJc2h/4LfsmAwyJlejbWKGLG2ACNbaI="");
var iv = CryptoJS.enc.Base64.parse(""YX5SF+cFwzv1I4OiGrJk3A=="");
var password = ""test"";

var encrypted = CryptoJS.AES.decrypt(decrypt.toString(), password, {
    iv: iv,
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>

<p>Output is always empty. Is there something else I am missing on Android that I also need to pass to CryptoJS?</p>
","<p>Found the problem and it was not an padding issue. </p>

<p>As other people have stated it have to do with the fact I was using SecureRandom.getInstance(""SHA1PRNG""). </p>

<p>I corrected the problem in my code was generating a key with PBEKeySpec on Android and PBKDF2 on CryptoJS. Then just following the same steps:</p>

<pre><code>String Test = ""Lorem ipsum dolor sit amet, ..."";
String password = ""test"";

byte[] salt = new String(""12345678"").getBytes(""Utf8"");
int iterationCount = 2048;
int keyStrength = 256;

SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyStrength);
SecretKey tmp = factory.generateSecret(spec);

Log.d(""encryptString Key: "", new String(Base64.encodeBase64(tmp.getEncoded())));

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, tmp);
byte[] decrypted = c.doFinal(Test.getBytes());
decrypted = Base64.encodeBase64(decrypted);
byte[] iv = c.getIV();

Log.d(""encryptString: "", new String(decrypted));
Log.d(""encryptString iv:"", new String(Base64.encodeBase64(iv)));
</code></pre>

<p>Example output from run code on Android:</p>

<pre><code>encryptStringKey:: ueTU6u4PXbm86zy+UtlQfeh55xZorA58W3fKKBypheM=
encryptString:: ii8UNoi4xG1zGC8RyzHKu6JMkxixkK7LTPxGMaCHGNk=
encryptStringiv:: nwy2VHctPnXOd/rahPFiWg==
</code></pre>

<p>Now we generate the same PBKDF2 key in a JavaScript and input the output above into our sample code below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var salt = CryptoJS.enc.Utf8.parse(""12345678"");
var password = ""test"";
var keyBits = CryptoJS.PBKDF2(password, salt, {
  hasher: CryptoJS.algo.SHA1,
  keySize: 8,
  iterations: 2048
});

var iv = CryptoJS.enc.Base64.parse(""nwy2VHctPnXOd/rahPFiWg=="");
var message = CryptoJS.enc.Base64.parse(""ii8UNoi4xG1zGC8RyzHKu6JMkxixkK7LTPxGMaCHGNk="");

var encrypted = CryptoJS.AES.decrypt(""ii8UNoi4xG1zGC8RyzHKu6JMkxixkK7LTPxGMaCHGNk="", keyBits, {
  iv: iv,
  padding: CryptoJS.pad.Pkcs7,
  mode: CryptoJS.mode.CBC
});

console.log(encrypted.toString(CryptoJS.enc.Utf8));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!doctype html&gt;

&lt;html&gt;

&lt;head&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;script type=""text/javascript"" src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;
  &lt;script type=""text/javascript"" src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/pbkdf2.min.js""&gt;&lt;/script&gt;
  &lt;script type=""text/javascript"" src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/aes.min.js""&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>Output in JavaScript:</p>

<pre><code>""Lorem ipsum dolor sit amet, ...""
</code></pre>
","980","<javascript><android><encryption><aes><cryptojs>","0","4","1","2017-07-12 16:31:18","","3","3","1816580","","2017-07-12 16:31:18","2017-07-11 12:20:18",""
"53834903","Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding equivalent in Node.js","<p>The data decryption will run in JAVA using <code>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</code> algorithm. So I have to encrypt the data with public key using the algorithm equivalent to <code>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</code> in <code>node.js</code>. </p>

<p>I tried with <code>crypto.publicEncrypt(key, buffer)</code> which uses crypto.constants.RSA_PKCS1_OAEP_PADDING which is not similar to the above algorithm.
So I need algorithm equivalent to ""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"" or how to achieve the same in node.js</p>
","<p>Firstly, you shouldn't use ""ECB"" mode cipher, because:</p>

<ol>
<li>ECB is a block cipher mode, RSA isn't an algorithm based on that mode of operation.</li>
<li>If you use an algorithm based on that mode of operation (for example AES), you shouldn't use ECB, because it doesn't have IV (Initialization Vector), so it's insecure and a crypto analyzer could break the cipher. You could use CBC, it has IV, or GCM, if you want to share sensitive information to external systems and prevent Oracle Padding. I recommend you visit the following link:</li>
</ol>

<p><a href=""https://wiki.sei.cmu.edu/confluence/display/java/MSC61-J.+Do+not+use+insecure+or+weak+cryptographic+algorithms"" rel=""nofollow noreferrer"">MSC61-J. Do not use insecure or weak cryptographic algorithms</a>  </p>

<p>So, in this case, you just need to use OAEP for RSA encryption, because it's a padding scheme and it helpts to prevent Oracle Padding for asymetric algorithms, then change your code for: <code>RSA/None/OAEPWithSHA-256AndMGF1Padding</code>. Maybe, you could get compatibility with Node.js. Also, I recommend you visit the official web site:</p>

<p><a href=""https://docs.oracle.com/javase/7/docs/technotes/guides/security/crypto/CryptoSpec.html"" rel=""nofollow noreferrer"">JCA Reference Guide</a></p>

<p>I hope this information helps you.</p>

<p>Good luck.</p>
","978","<java><node.js><encryption><cryptojs>","1","-2","2","2019-01-03 14:21:56","54024177","4","","7649349","","2018-12-18 14:34:02","2018-12-18 14:10:41",""
"53834903","Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding equivalent in Node.js","<p>The data decryption will run in JAVA using <code>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</code> algorithm. So I have to encrypt the data with public key using the algorithm equivalent to <code>RSA/ECB/OAEPWithSHA-256AndMGF1Padding</code> in <code>node.js</code>. </p>

<p>I tried with <code>crypto.publicEncrypt(key, buffer)</code> which uses crypto.constants.RSA_PKCS1_OAEP_PADDING which is not similar to the above algorithm.
So I need algorithm equivalent to ""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"" or how to achieve the same in node.js</p>
","<p>I finally found the answer. 
Equivalent to ""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"" can be achieved via node-forge npm module. <a href=""https://www.npmjs.com/package/node-forge#rsa"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/node-forge#rsa</a></p>

<pre><code>    // encrypt data with a public key using RSAES-OAEP/SHA-256/MGF1-SHA-1
// compatible with Java's RSA/ECB/OAEPWithSHA-256AndMGF1Padding
var encrypted = publicKey.encrypt(bytes, 'RSA-OAEP', {
  md: forge.md.sha256.create(),
  mgf1: {
    md: forge.md.sha256.create()
  }
});
</code></pre>

<p>Thank you</p>
","978","<java><node.js><encryption><cryptojs>","1","1","2","2019-01-03 14:21:56","54024177","4","","7649349","","2018-12-18 14:34:02","2018-12-18 14:10:41",""
"31841942","Converting a 64 bit number string to word array using CryptoJS","<p>I want to know if a string with integer data can be converted to a CryptoJS word array correctly?
Example. Can I convert ""175950736337895418"" into a word array the same way I can create a word array out of 175950736337895418 (int value). </p>

<p>I have some code that converts integer values to word array</p>

<pre><code> // Converts integer to byte array
 function getInt64Bytes( x ){
    var bytes = [];
    for(var i = 7;i&gt;=0;i--){
        bytes[i] = x &amp; 0xff;
        x = x&gt;&gt;8;
    }
    return bytes;
}

//converts the byte array to hex string
function bytesToHexStr(bytes) {
    for (var hex = [], i = 0; i &lt; bytes.length; i++) {
        hex.push((bytes[i] &gt;&gt;&gt; 4).toString(16));
        hex.push((bytes[i] &amp; 0xF).toString(16));
    }
    return hex.join("""");
}

// Main function to convert integer values to word array
function intToWords(counter){
    var bytes = getInt64Bytes(counter);
    var hexstr = bytesToHexStr(bytes);
    var words = CryptoJS.enc.Hex.parse(hexstr);
    return words;
}
</code></pre>

<p>Even this code doesn't work correctly as very large integer numbers (exceeding javascript limit of numbers 2^53 - 1) get rounded off. Hence I wanted a solution that could take the integer value as string and convert it to a word array correctly.</p>

<p>PS. I need this word array to calculate the HMAC value using the following code</p>

<pre><code>CryptoJS.HmacSHA512(intToWords(counter), CryptoJS.enc.Hex.parse(key))
</code></pre>
","<p>What you want is to parse big numbers from strings. Since this is necessary for RSA, you can use Tom Wu's JSBN to get that functionality. Be sure to include jsbn.js <em>and</em> jsbn2.js. Then you can use it like this:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function intToWords(num, lengthInBytes) {
    var bigInt = new BigInteger();
    bigInt.fromString(num, 10); // radix is 10
    var hexNum = bigInt.toString(16); // radix is 16
    
    if (lengthInBytes &amp;&amp; lengthInBytes * 2 &gt;= hexNum.length) {
        hexNum = Array(lengthInBytes * 2 - hexNum.length + 1).join(""0"") + hexNum;
    }

    return CryptoJS.enc.Hex.parse(hexNum);
}

var num = ""175950736337895418"";
numWords = intToWords(num);

document.querySelector(""#hexInt"").innerHTML = ""hexNum: "" + numWords.toString();
document.querySelector(""#hexIntShort"").innerHTML = ""hexNumShort: "" + intToWords(""15646513"", 8).toString();

var key = CryptoJS.enc.Hex.parse(""11223344ff"");

document.querySelector(""#result"").innerHTML = ""hexHMAC: "" + 
        CryptoJS.HmacSHA512(numWords, key).toString();</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/jasondavies/jsbn/master/jsbn.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/jasondavies/jsbn/master/jsbn2.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/hmac-sha512.js""&gt;&lt;/script&gt;
&lt;div id=""hexInt""&gt;&lt;/div&gt;
&lt;div id=""hexIntShort""&gt;&lt;/div&gt;
&lt;div id=""result""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>If you need the result in a specific length, then you can pass the number of required bytes as the second argument.</p>
","960","<javascript><biginteger><cryptojs>","0","1","1","2017-07-30 09:30:19","31852477","0","","1816580","","2015-08-06 09:54:54","2015-08-05 20:10:36",""
"25548834","Nodejs Crypto Sign/Verify :: Error: PEM routines:PEM_read_bio:no start line","<p>I am attempting to use the nodejs crypto lib to sign/verify strings of information using the following code:</p>

<pre><code>// Generated by CoffeeScript 1.8.0
(function() {
  var crypto, tPriv, tPub1, tPub2, tSig, __Key, __Sign, __Verify;

  crypto = require('crypto');

  __Sign = function(aObj, aPrivKey) {
    var tRet, tSign;
    tSign = crypto.createSign('RSA-SHA256');
    tSign.update(aObj);
    tRet = tSign.sign(aPrivKey, 'base64');
    console.log(tRet);
    return tRet;
  };

  __Verify = function(aObj, aPubKey) {
    var tRet, tVerify;
    tVerify = crypto.createVerify('RSA-SHA256');
    tRet = tVerify.verify(aObj, aPubKey, 'base64');
    console.log(tRet);
    return tRet;
  };

  __Key = crypto.getDiffieHellman('modp5');
  __Key.generateKeys();
  tPub1 = __Key.getPublicKey('base64');
  tPub2 = __Key.getPublicKey('base64');
  tPriv = __Key.getPrivateKey('base64');
  tSig = __Sign(tPub1, tPriv);
  console.log(__Verify(tSig, tPub2));
}).call(this);
</code></pre>

<p>however, when run it is giving the following error:</p>

<pre><code># 140735266407184:error:0906D06C:PEM routines:PEM_read_bio:no start line:../deps/openssl/openssl/crypto/pem/pem_lib.c:703:Expecting: ANY PRIVATE KEY# 
# 
# crypto.js:398
#   var ret = this._binding.sign(toBuf(key));
#                           ^
# Error: SignFinal error
#     at Sign.sign (crypto.js:398:27)
#     at __Sign (~/testSig.js:11:18)
#     at Object.&lt;anonymous&gt; (~/testSig.js:34:10)
#     at Object.&lt;anonymous&gt; (~/testSig.js:38:4)
#     at Module._compile (module.js:456:26)
#     at Object.Module._extensions..js (module.js:474:10)
#     at Module.load (module.js:356:32)
#     at Function.Module._load (module.js:312:12)
#     at Function.Module.runMain (module.js:497:10)
#     at startup (node.js:119:16)
</code></pre>

<p>I have read through the docs @ <a href=""http://nodejs.org/api/crypto.html#crypto_crypto_createsign_algorithm"" rel=""nofollow"">http://nodejs.org/api/crypto.html#crypto_crypto_createsign_algorithm</a> but I honestly dont even know where to begin with this error.  I think its complaining about the private key, but the private key I am giving it is from its own library.</p>

<p>If anyone could point me in the right direction, I would appreciate it.</p>
","","950","<javascript><node.js><cryptojs>","3","","0","2014-08-28 12:27:02","","2","","","","","2014-08-28 12:27:02",""
"38951553","Unable to decrypt message using Crypto-Js","<p>I am new to encryption. What I am trying to do is decrypt a cipher text using javascript library, <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">CryptoJS</a>. This code example works fine. The encryption part returns ciphertext ""ae06b481cecfa67c98c125"" (which is right) while decrypting the same object returns the original string ""Hello World"".</p>

<pre><code> var key = CryptoJS.enc.Latin1.parse(""bad8deadcafef00d"");
 var iv = CryptoJS.enc.Latin1.parse(""bad8deadcafef00d"");
 var encrypted = CryptoJS.AES.encrypt(""Hello World"", key, {iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
 alert(encrypted.ciphertext);

 var decryptedData = CryptoJS.AES.decrypt(encrypted, key, {iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
 originalData = decryptedData.toString(CryptoJS.enc.Utf8);
 alert(originalData);
</code></pre>

<p>Well this part works fine but when I try this chunk of code by passing the cipher text as a string independently, I don't get the decrypted message. </p>

<pre><code>var key = CryptoJS.enc.Latin1.parse(""bad8deadcafef00d"");
var iv = CryptoJS.enc.Latin1.parse(""bad8deadcafef00d"");
var ciphertext = ""ae06b481cecfa67c98c125"";
// raw = CryptoJS.enc.Base64.parse(cipher);
var decryptedData = CryptoJS.AES.decrypt(ciphertext, key, {iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
originalData = decryptedData.toString(CryptoJS.enc.Utf8);
alert(originalData);
console.log(originalData);
</code></pre>

<p>Can somebody please point out why? </p>

<p>I have the following libraries included in the html file.</p>

<pre><code>&lt;script src=""js/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""js/components/mode-ctr.js""&gt;&lt;/script&gt;
&lt;script src=""js/components/pad-nopadding.js""&gt;&lt;/script&gt;
</code></pre>
","<p><code>CryptoJS.AES.decrypt</code> expects either a <code>CipherParams</code> object or an OpenSSL-formatted string. If the passed key is a string then the OpenSSL-formatted string is expected and otherwise the <code>CipherParams</code> object.</p>

<p>Since your key is not a string, you need this:</p>

<pre><code>var decryptedData = CryptoJS.AES.decrypt({
    ciphertext: CryptoJS.enc.Hex.parse(""ae06b481cecfa67c98c125"")
}, key, {
    iv: iv, 
    mode: CryptoJS.mode.CTR, 
    padding: CryptoJS.pad.NoPadding
});
</code></pre>

<p>If the key is a string, then it isn't actually a key, but assumed to be a password and a key will be derived from that password with a random 8 byte salt. This would be comparable to OpenSSL's <code>EVP_BytesToKey</code> function.</p>
","949","<javascript><encryption><cryptojs>","2","0","1","2018-01-29 16:41:31","38960683","0","","","","","2016-08-15 08:14:39",""
"32526298","Porting AES decryption from CryptoJS to PyCrypto","<p>Here is a JavaScript part which decodes a string with AES encryption</p>

<pre><code>var p = 'some large string'
var s = 'Q05WTmhPSjlXM1BmeFd0UEtiOGg=' 
var y = CryptoJS.AES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(p)
}, CryptoJS.enc.Base64.parse(s), {
    iv  CryptoJS.enc.Hex.parse(""random"")
});
var v = y.toString(CryptoJS.enc.Utf8)
</code></pre>

<p>I am trying to code a similar decoding function in python with importing AES.</p>

<p>Could anyone help me with this one. I can't figure out all equivalent code for js to python.</p>

<p>I looked up this page 
<a href=""https://stackoverflow.com/questions/24638786/python-aes-decryption-routine-code-help"">Python AES Decryption Routine (Code Help)</a>
and </p>

<p><a href=""https://stackoverflow.com/questions/18236761/aes-encryption-with-crypto-node-js-decryption-with-pycrypto-python"">AES - Encryption with Crypto (node-js) / decryption with Pycrypto (python)</a></p>

<p>Not sure if they have the code similar to the js I have here</p>

<pre><code>""y.toString(CryptoJS.enc.Utf8)""
</code></pre>

<p>This in python what it means</p>

<p>I have tried something like this from another source</p>

<pre><code>from base64 import b64decode
from Crypto.Cipher import AES

iv = 'random'
key = 'Q05WTmhPSjlXM1BmeFd0UEtiOGg='
encoded = b64decode('some large string')

dec = AES.new(key=key, mode=AES.MODE_CBC, IV=iv)
value = dec.decrypt(encoded)
</code></pre>
","<p>There are multiple problems with your CryptoJS code and Python code.</p>

<h1>Wrong key size</h1>

<p>Your key <code>s</code> contains only 20 bytes (160 bit) which doesn't constitute any of the valid key sizes for AES which are 128 (10), 192 (12) and 256 bit (14 rounds). CryptoJS will silently run the key schedule for a 160 bit key with 11 rounds which <strong>PyCrypto doesn't support</strong> (see <a href=""https://github.com/dlitz/pycrypto/blob/master/src/AES.c"" rel=""nofollow noreferrer"">AES.c</a>).</p>

<p>You can reduce the key to 128 bit like this in CryptoJS:</p>

<pre><code>var key = CryptoJS.enc.Base64.parse('Q05WTmhPSjlXM1BmeFd0UEtiOGg=');
key.sigBytes = 16;
key.clamp();
</code></pre>

<p>or in Python:</p>

<pre><code>key = b64decode('Q05WTmhPSjlXM1BmeFd0UEtiOGg=')[:16]
</code></pre>

<h1>Wrong character encoding</h1>

<p>You forgot to decode the key from a Base64 string in Python and you forgot to decode the IV from hex. The character <code>'0'</code> and the byte 0x00 are entirely different. There's an easier way to define an all zero IV:</p>

<pre><code>iv = ""\0""*16
</code></pre>

<h1>No unpadding</h1>

<p>CryptoJS uses PKCS#7 padding by default, but PyCrypto doesn't implement any padding and only handles data as a multiple of the block size. After you decrypt something, you need to remove the padding yourself in Python:</p>

<pre><code>value = value[:value[-1]]
</code></pre>

<p>(the last byte determines how many bytes are padding bytes). More on that <a href=""https://stackoverflow.com/a/14205319"">here</a>.</p>

<hr>

<p><strong>Other considerations:</strong></p>

<p>You really shouldn't be setting the IV to a static value. The IV should be randomly generated for every encryption using the same key. Otherwise, you will lose semantic security. Since the IV doesn't have to be secret, you can put it in front of the ciphertext and slice it off before decryption.</p>
","943","<javascript><python><encryption><encoding><cryptojs>","0","2","1","2015-09-16 13:02:57","32527531","1","","-1","","2017-05-23 11:51:49","2015-09-11 14:50:04",""
"18738090","crypto-js DES encryption and padding","<p>I need Crypto-JS to perform a DES encryption on an 8-byte block (for now). However, I am having problems achieving this in crypto-js without padding.</p>

<p>When I perform:</p>

<pre><code>var skl = CryptoJS.DES.encrypt ( CryptoJS.enc.Hex.parse ( ""0000000000000000"" ), CryptoJS.enc.Hex.parse ( ""0000000000000000""), 
                                 { iv : CryptoJS.enc.Hex.parse ( ""0000000000000000"" ), mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.NoPadding } );
</code></pre>

<p>I get no output. CBC mode does not require padding, but I have tried all other block modes (OFB / CFB etc), and still no output.  When I use Pkcs7, it does provide an output but it pads the input block resulting in 16 bytes of ciphermessage.  I guess when you specify padding it always pads even when the block size is compatible?</p>

<pre><code>var skl = CryptoJS.DES.encrypt ( CryptoJS.enc.Hex.parse ( ""0000000000000000"" ), CryptoJS.enc.Hex.parse ( ""0000000000000000""), 
                                 { iv : CryptoJS.enc.Hex.parse ( ""0000000000000000"" ), mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 } );
</code></pre>

<p>Am I specifying the input data in the correct way (via a hex parse)? It is important that I encrypt raw bytes of fixed sizes &amp; there don't seem to be any examples of this. </p>

<p>What is the correct way to DES encrypt data without padding?</p>
","","940","<javascript><encryption><cryptojs>","3","","0","2013-09-11 09:57:35","","0","","","","","2013-09-11 09:57:35",""
"49277447","Is it possible to verify and sign data in Node.js ""native"" (without using external call to OpenSSL)?","<p>I have tried to find any package or solution to do a S/MIME sign/verify signature in Node.js but only found solutions using external calls (child process) to OpenSSL.
I need to run my code in AWS Lambda as Node.js so calling OpenSSL binary is not an option...</p>

<p>Is it at all possible to verify and sign X.509 pkcs7-signature S/MIME (Base64) signatures using only Node.js?</p>

<p>Sample public key:</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIIDwzCCAqugAwIBAgIIKHUtBJ7PgSwwDQYJKoZIhvcNAQELBQAwRjELMAkGA1UE
BhMCU0UxEjAQBgNVBAcMCVN0b2NraG9sbTEMMAoGA1UECgwDQVMyMRUwEwYDVQQD
DAx0ZXN0LmFzMi5uZXQwHhcNMTgwMzE0MTI1MTAzWhcNMTkwMzE0MTI1MTAzWjBG
MQswCQYDVQQGEwJTRTESMBAGA1UEBwwJU3RvY2tob2xtMQwwCgYDVQQKDANBUzIx
FTATBgNVBAMMDHRlc3QuYXMyLm5ldDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCC
AQoCggEBALXXVK5jP9H9JjOe9Iiba1235Xz/WuFUVP5I2Pl1ClkvGlUZRIQrje7K
Ar3OBuh8iOiNko+HuWXN505WvmiVESH9mrSSfXHDUU+JcCDkbNLDFJKiEAeZni6f
cTMMU7eWL/ZwVvAaOVXIjCC6l+nf6+rI9HNIKUpr96iIWDUMot5PQURFNUEg0OQ4
HFsuXtrm8CvbD/v3dj/2nke+HzIra27+2v3hFFP0EPCRz4+okh3a6pWrXnozrmRn
e+FFRH8mq0N0UH1AtiArDpCspnZJEGsquvj2/ruSHCarQpOS12MfPY6uFlGym3fZ
H1AxpDn11KIC3L3iNAMNCh7DWtxyrbcCAwEAAaOBtDCBsTAMBgNVHRMEBTADAQH/
MB0GA1UdDgQWBBTOWGctZLOpraEmeF77hpPcbHzbZzB1BgNVHSMEbjBsgBTOWGct
ZLOpraEmeF77hpPcbHzbZ6FKpEgwRjELMAkGA1UEBhMCU0UxEjAQBgNVBAcMCVN0
b2NraG9sbTEMMAoGA1UECgwDQVMyMRUwEwYDVQQDDAx0ZXN0LmFzMi5uZXSCCCh1
LQSez4EsMAsGA1UdDwQEAwICvDANBgkqhkiG9w0BAQsFAAOCAQEAQNhK/jVm6PRd
ui2ptx0wLd4QD7duPxULfYdhbab+Odp/LbQ08Mp1FZ8JjnJnH/z1H7SH4kPjEHIC
22VDvK1+MAjTq4iPKgpmtBSdC8dJ/S8rNE9nzpfuheM79ES8ERPNTi2Mumq1OM8L
43J+LMVwNyWx4JlI7egJgqzP5NKaPo35pI1Z/71eVGn6uPwlOdP9s8unwtOYSGZ+
mVUwQ/wiGuJ7VsxCeGPpG2rV38zUGQGiOqerkqHCLDL2K3ondA53M/myAhA7M2qP
BNPee9guEEXiI/W038rzPVSE8lETbNEnsTLxCI1uN68tEBRSZlBQwu/r/pOXP3fw
/HaEGP0gsQ==
-----END CERTIFICATE-----
</code></pre>

<p>Sample message signed with the matching Private Key:</p>

<pre><code>This is an S/MIME signed message

------FF336B91207E7B459FAC35C0D274B8F8
Content-Type: text/plain

UNB+UNOC:3+esab+postnet+111101:1954+6045++++++'UNH+12011+INVOIC:D:93A:UN:EDIT30'BGM+380::9+006124412+9'DTM+137:20111101:102'UNT+55+12011'UNZ+1+6045'       
------FF336B91207E7B459FAC35C0D274B8F8
Content-Type: application/pkcs7-signature; name=""smime.p7s""
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename=""smime.p7s""

MIIGTwYJKoZIhvcNAQcCoIIGQDCCBjwCAQExCTAHBgUrDgMCGjALBgkqhkiG9w0B
BwGgggPHMIIDwzCCAqugAwIBAgIIKHUtBJ7PgSwwDQYJKoZIhvcNAQELBQAwRjEL
MAkGA1UEBhMCU0UxEjAQBgNVBAcMCVN0b2NraG9sbTEMMAoGA1UECgwDQVMyMRUw
EwYDVQQDDAx0ZXN0LmFzMi5uZXQwHhcNMTgwMzE0MTI1MTAzWhcNMTkwMzE0MTI1
MTAzWjBGMQswCQYDVQQGEwJTRTESMBAGA1UEBwwJU3RvY2tob2xtMQwwCgYDVQQK
DANBUzIxFTATBgNVBAMMDHRlc3QuYXMyLm5ldDCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBALXXVK5jP9H9JjOe9Iiba1235Xz/WuFUVP5I2Pl1ClkvGlUZ
RIQrje7KAr3OBuh8iOiNko+HuWXN505WvmiVESH9mrSSfXHDUU+JcCDkbNLDFJKi
EAeZni6fcTMMU7eWL/ZwVvAaOVXIjCC6l+nf6+rI9HNIKUpr96iIWDUMot5PQURF
NUEg0OQ4HFsuXtrm8CvbD/v3dj/2nke+HzIra27+2v3hFFP0EPCRz4+okh3a6pWr
XnozrmRne+FFRH8mq0N0UH1AtiArDpCspnZJEGsquvj2/ruSHCarQpOS12MfPY6u
FlGym3fZH1AxpDn11KIC3L3iNAMNCh7DWtxyrbcCAwEAAaOBtDCBsTAMBgNVHRME
BTADAQH/MB0GA1UdDgQWBBTOWGctZLOpraEmeF77hpPcbHzbZzB1BgNVHSMEbjBs
gBTOWGctZLOpraEmeF77hpPcbHzbZ6FKpEgwRjELMAkGA1UEBhMCU0UxEjAQBgNV
BAcMCVN0b2NraG9sbTEMMAoGA1UECgwDQVMyMRUwEwYDVQQDDAx0ZXN0LmFzMi5u
ZXSCCCh1LQSez4EsMAsGA1UdDwQEAwICvDANBgkqhkiG9w0BAQsFAAOCAQEAQNhK
/jVm6PRdui2ptx0wLd4QD7duPxULfYdhbab+Odp/LbQ08Mp1FZ8JjnJnH/z1H7SH
4kPjEHIC22VDvK1+MAjTq4iPKgpmtBSdC8dJ/S8rNE9nzpfuheM79ES8ERPNTi2M
umq1OM8L43J+LMVwNyWx4JlI7egJgqzP5NKaPo35pI1Z/71eVGn6uPwlOdP9s8un
wtOYSGZ+mVUwQ/wiGuJ7VsxCeGPpG2rV38zUGQGiOqerkqHCLDL2K3ondA53M/my
AhA7M2qPBNPee9guEEXiI/W038rzPVSE8lETbNEnsTLxCI1uN68tEBRSZlBQwu/r
/pOXP3fw/HaEGP0gsTGCAlIwggJOAgEBMFIwRjELMAkGA1UEBhMCU0UxEjAQBgNV
BAcMCVN0b2NraG9sbTEMMAoGA1UECgwDQVMyMRUwEwYDVQQDDAx0ZXN0LmFzMi5u
ZXQCCCh1LQSez4EsMAcGBSsOAwIaoIHYMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0B
BwEwHAYJKoZIhvcNAQkFMQ8XDTE4MDMxNDEzMzgwM1owIwYJKoZIhvcNAQkEMRYE
FOLO/ihBaZEe6+s2HipYsy+ie9WLMHkGCSqGSIb3DQEJDzFsMGowCwYJYIZIAWUD
BAEqMAsGCWCGSAFlAwQBFjALBglghkgBZQMEAQIwCgYIKoZIhvcNAwcwDgYIKoZI
hvcNAwICAgCAMA0GCCqGSIb3DQMCAgFAMAcGBSsOAwIHMA0GCCqGSIb3DQMCAgEo
MA0GCSqGSIb3DQEBAQUABIIBAH4HrlzhccYzwmxlDjRWa0cn2eOIz6tYnOKqjcgQ
wVVM0BEkXusnz+3o/KMqpCjTDWcC4yOrJqJVVGKl11yGkUs/3PKZZyEGcKR0PRl0
R+2tTcwt7CT8uqH64sth23DUU7r4tAnbmMhI6Gwsc/6ttLC5qVJrg80dcWmmUx7J
AWrigTQUW70yU3HbyIm+fA87j0vilgL/eXMAWT/TB73x3zRz+UVRkEyPM+JWK0Xj
voMK1drjXrSm/xJrzo6/5p2o0X/yhi9V/QEctCU9nfrv1+uDVJek0uMTR/xwRUs6
Jua/lzQjxJwCGSGabfQ8VbAABZZNBzMAAMzgQEvfQZb8enA=

------FF336B91207E7B459FAC35C0D274B8F8--
</code></pre>
","<p>Yes, it is possible with a combination of <code>crypto</code> and <code>node-forge</code>!</p>

<pre><code>function verify() {
  var crypto = require('crypto');
  // pkg_sig is the extracted Signature from the S/MIME
  // with added -----BEGIN PKCS7----- around it
  var msg = pkcs7.messageFromPem(pkg_sig);
  var sig = msg.rawCapture.signature;

  // pkg is the ""clean"" signed data from the S/MIME
  var buf = new Buffer(pkg, 'binary');

  var verifier = crypto.createVerify(""RSA-SHA256"");
  verifier.update(buf);
  var verified = verifier.verify(cert, sig, 'binary');

  console.log(verified);
}

function sign() {
  /*
  // Verified working AW, 2018-03-15
  // Signature successfully verified by OPENSSL

  openssl smime -verify -in packageCopy.txt -CAfile test.as2.net-sscert.pem
    Content-Type: text/plain

    UNB+UNOC:3+esab+postnet+111101:1954+6045++++++'UNH+12011+INVOIC:D:93A:UN:EDIT30'BGM+380::9+006124412+9'DTM+137:20111101:102'UNT+55+12011'UNZ+1+6045'       Verification successful
  */

  var p7 = pkcs7.createSignedData();
  p7.content = forge.util.createBuffer(pkg);
  p7.addCertificate(cert);
  p7.addSigner({
    key: forge.pki.privateKeyFromPem(key),
    certificate: cert,
    digestAlgorithm: forge.pki.oids.sha256
  });
  p7.sign();
  var pem = pkcs7.messageToPem(p7);
  console.log(pem);
}
</code></pre>
","939","<node.js><cryptojs>","2","1","1","2018-03-22 21:56:56","49439112","2","","1254707","","2018-03-14 13:37:05","2018-03-14 12:09:13",""
"40048164","AES-256 CBC encryption succeeds in Ruby/PHP, but decryption fails with CryptoJS","<p>I can AES-256 CBC encrypt a string in PHP or Ruby (using the gem <a href=""https://rocketjob.github.io/symmetric-encryption/api.html"" rel=""nofollow"">symmetric-encryption</a>) and get the same result.</p>

<pre class=""lang-php prettyprint-override""><code>&lt;?php
openssl_encrypt(
  'Hello!', 'aes-256-cbc', '1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF', 0, '1234567890ABCDEF1234567890ABCDEF'
); // =&gt; 'BAd5fmmMTvRE4Ohvf3GpCw=='
</code></pre>

<pre class=""lang-ruby prettyprint-override""><code>ruby_cipher = SymmetricEncryption::Cipher.new(key: ""1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF"", iv: ""1234567890ABCDEF1234567890ABCDEF"", cipher_name: 'aes-256-cbc')
ruby_cipher.encrypt(""Hello!"") # =&gt; ""BAd5fmmMTvRE4Ohvf3GpCw==""
</code></pre>

<p>But I fail to decrypt the same string with Javascript, using <a href=""https://code.google.com/archive/p/crypto-js/wikis/QuickStartGuide_v3beta.wiki"" rel=""nofollow"">CryptoJS</a>. As far as I can interpret the documentation:</p>

<blockquote>
  <p>var encrypted = CryptoJS.AES.encrypt(""Message"", key, { iv: iv });</p>
  
  <p>var decrypted = CryptoJS.AES.decrypt(""Message"", key, { iv: iv });</p>
</blockquote>

<p>Check out my failed attempt in <a href=""https://jsfiddle.net/xjr8jhob/"" rel=""nofollow"">my jsfiddle</a> or here:</p>

<pre class=""lang-js prettyprint-override""><code>var key            = CryptoJS.enc.Hex.parse(""1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF"");
var iv             = CryptoJS.enc.Hex.parse""1234567890ABCDEF1234567890ABCDEF"");

var ruby_encrypted = ""BAd5fmmMTvRE4Ohvf3GpCw=="";                            // Output from the Ruby encryption
var js_encrypted   = CryptoJS.AES.encrypt(""Hello!"", key, { iv: iv });       // Test to confirm that CryptoJS can decrypt its own encrypted

var ruby_decrypted = CryptoJS.AES.decrypt(ruby_encrypted, key, { iv: iv }); // Object { words: Array[4], sigBytes: -129 }
var js_decrypted   = CryptoJS.AES.decrypt(js_encrypted, key, { iv: iv });   // Object { words: Array[4], sigBytes: 6 }

console.log(ruby_decrypted.toString(CryptoJS.enc.Utf8));                    //
console.log(js_decrypted.toString(CryptoJS.enc.Utf8));                      // Hello!
</code></pre>

<p>Any idea why the decryption fails?</p>
","<p>PHP and Ruby take the key and IV as a binary string. They don't assume that it is Hex-encoded which means that only the first 32 characters of your 64 character key will be used. OpenSSL silently uses only the number of bytes it needs and doesn't throw an error (which it should in this case).</p>

<p>You probably want something like this in CryptoJS:</p>

<pre><code>var key    = CryptoJS.enc.Utf8.parse(""1234567890ABCDEF1234567890ABCDEF"");
var iv     = CryptoJS.enc.Utf8.parse(""1234567890ABCDEF"");
</code></pre>

<p>So, although this key has 256 bits in it, the security is actually only 128 bits, because each character has only 4 bit in a Hex-encoded string.</p>
","923","<javascript><encryption><encoding><aes><cryptojs>","0","0","1","2016-10-15 09:38:52","40048318","1","","1816580","","2016-10-14 16:53:40","2016-10-14 16:44:06",""
"49729914","Encrypt / decrypt file (CryptoJS)","<p>When working on the task ""Encrypt / decrypt file (CryptoJS.AES)"" I encountered a problem:
the official <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">documentation</a> is not described the process of encrypting and decrypting files.</p>

<p>The problem was that after decryption the file was corrupted. This was due to improper decoding of the decrypt files.
After decryption it is necessary to execute the code:</p>

<pre><code>decryptFile.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>I want to share with you my decision:</p>

<pre><code>import CryptoJS from 'crypto-js';
import fs from ""fs"";

const key = 'SECRET_KEY',
      iv = '9De0DgMTCDFGNokdEEial'; // You must dynamically create

const encrypt = (filePath)=&gt; {
    const dataFile = fs.readFileSync(filePath),
          dataBase64 = dataFile.toString('base64'),
          encryptFile = CryptoJS.AES.encrypt(dataBase64, key, {iv: iv}),
          buffer = new Buffer(encryptFile.toString(), 'base64');

    fs.writeFileSync(filePath, buffer);
}

const decrypt = (filePath, fileType)=&gt; {
    const dataFile = fs.readFileSync(filePath);
    const decryptFile = CryptoJS.AES.decrypt(dataFile.toString('base64'), 
      key, {iv: iv});

     // Return data: URL
     return 'data:' + fileType + ';base64,' + 
       decryptFile.toString(CryptoJS.enc.Utf8);

    // Or save decrypt file
    // const result = decryptFile.toString(CryptoJS.enc.Utf8);
    // const buffer = new Buffer(result, 'base64');
    // fs.writeFileSync(filePath, buffer);
}
</code></pre>
","","923","<javascript><encryption><cryptojs>","4","","0","2018-04-09 09:40:54","","2","1","","","","2018-04-09 09:40:54",""
"26517935","Encrypting in CryptoJS and decrypting in mCrypt not working properly","<p>For the past 2 days I have been struggling with what I first thought would be a breeze to implemenent.</p>

<p>I am in need of a very simple and <em>non-secure</em> way to send a cipher thru AJAX and decrypt it server-side</p>

<p><strong>I am using AES from <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">CryptoJS</a>:</strong></p>

<p><strong>JS encryption</strong></p>

<pre><code>    msg = ""message"";
    var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
    var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');
    var encrypted = CryptoJS.AES.encrypt(msg, key, { iv: iv });

    var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64); 
    var iv_base64   = encrypted.iv.toString(CryptoJS.enc.Base64);       
    var key_base64  = encrypted.key.toString(CryptoJS.enc.Base64);

    console.log(data_base64,iv_base64,key_base64) //If I use these keys in the PHP decryption it works

    return encrypted.toString();
</code></pre>

<hr>

<p>...and <strong>PHP decryption using <a href=""http://php.net/manual/en/book.mcrypt.php"" rel=""nofollow"">mCrypt</a></strong></p>

<pre><code>$encrypted = ""f82126a59b76d86946a013d9f575d0d4""; //this is what the JS function above returned.
$key = ""000102030405060708090a0b0c0d0e0f""; //same key as in JS function
$iv = ""101112131415161718191a1b1c1d1e1f""; //same IV as in JS function

$plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_256, $key, $encrypted, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );

echo ""Original string : "" . $encrypted . ""&lt;br /&gt;\n""; 
echo ""Decrypted string : "" . $plaintext . ""&lt;br /&gt;\n"";
</code></pre>

<p>Since I am using the same <code>IV</code>'s and <code>key</code>'s to encrypt I would expect that this would work decrypt just fine. However I seem to be missing something since I still see gibberish in the <code>plaintext.</code></p>

<p><strong>EDIT:</strong></p>

<blockquote>
  <p>Well it seems that the whole purpose of AES is that the <code>keys</code> and
  <code>IV</code>'s I must use are output by CryptoJS (see the <code>console.log</code>'s in
  the JS function). If I use those the function seems to run just fine.
  But I don't want that actually since those keys are dynamically
  generated thus each time I ran the JS function they change. <em>I just
  need a shared private-key</em> between client and server that is used to
  encrypt/decrypt and is static. As simple as that.</p>
</blockquote>
","<p>Your key is 128 bit (the length of $key is 32 hexadecimal characters, which means 16 byte or 128 bit). However, in your mcrypt_decrypt() call you're telling PHP to use <code>MCRYPT_RIJNDAEL_256</code> with a 256-bit key. Try using <code>MCRYPT_RIJNDAEL_128</code> instead. Normally ciphers should adapt to the length of the passed key, but it could be that PHP is padding the key with null bytes to use 256-bit encryption.</p>

<p>Secondly, in PHP mcrypt_decrypt is set to use the CBC mode (see <code>MCRYPT_MODE_CBC</code>). You don't specify which mode CryptoJS should use. Luckily for you, according to docs for CryptoJS, the CBC mode is the one used by default; however, since you're writing portable code you should consider making that explicit.</p>

<h2>edit</h2>

<p>If it tells you that the key is too long, it's because you're not packing them. You're giving PHP an hex-encoded string long 32 bytes (256 bit), which is not your key! To get the binary data you need to do:</p>

<pre><code>$key = pack('H*', ""000102030405060708090a0b0c0d0e0f"");
$iv = pack('H*', ""101112131415161718191a1b1c1d1e1f"");
</code></pre>

<p>the <code>pack('H*', $str);</code> function converts an hex representation to the binary string.</p>
","919","<javascript><php><encryption><cryptojs>","0","0","2","2014-10-24 06:41:09","","0","","1814486","","2014-10-22 22:38:20","2014-10-22 22:06:15",""
"26517935","Encrypting in CryptoJS and decrypting in mCrypt not working properly","<p>For the past 2 days I have been struggling with what I first thought would be a breeze to implemenent.</p>

<p>I am in need of a very simple and <em>non-secure</em> way to send a cipher thru AJAX and decrypt it server-side</p>

<p><strong>I am using AES from <a href=""https://code.google.com/p/crypto-js/#AES"" rel=""nofollow"">CryptoJS</a>:</strong></p>

<p><strong>JS encryption</strong></p>

<pre><code>    msg = ""message"";
    var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
    var iv  = CryptoJS.enc.Hex.parse('101112131415161718191a1b1c1d1e1f');
    var encrypted = CryptoJS.AES.encrypt(msg, key, { iv: iv });

    var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64); 
    var iv_base64   = encrypted.iv.toString(CryptoJS.enc.Base64);       
    var key_base64  = encrypted.key.toString(CryptoJS.enc.Base64);

    console.log(data_base64,iv_base64,key_base64) //If I use these keys in the PHP decryption it works

    return encrypted.toString();
</code></pre>

<hr>

<p>...and <strong>PHP decryption using <a href=""http://php.net/manual/en/book.mcrypt.php"" rel=""nofollow"">mCrypt</a></strong></p>

<pre><code>$encrypted = ""f82126a59b76d86946a013d9f575d0d4""; //this is what the JS function above returned.
$key = ""000102030405060708090a0b0c0d0e0f""; //same key as in JS function
$iv = ""101112131415161718191a1b1c1d1e1f""; //same IV as in JS function

$plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_256, $key, $encrypted, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );

echo ""Original string : "" . $encrypted . ""&lt;br /&gt;\n""; 
echo ""Decrypted string : "" . $plaintext . ""&lt;br /&gt;\n"";
</code></pre>

<p>Since I am using the same <code>IV</code>'s and <code>key</code>'s to encrypt I would expect that this would work decrypt just fine. However I seem to be missing something since I still see gibberish in the <code>plaintext.</code></p>

<p><strong>EDIT:</strong></p>

<blockquote>
  <p>Well it seems that the whole purpose of AES is that the <code>keys</code> and
  <code>IV</code>'s I must use are output by CryptoJS (see the <code>console.log</code>'s in
  the JS function). If I use those the function seems to run just fine.
  But I don't want that actually since those keys are dynamically
  generated thus each time I ran the JS function they change. <em>I just
  need a shared private-key</em> between client and server that is used to
  encrypt/decrypt and is static. As simple as that.</p>
</blockquote>
","<p><code>MCRYPT_RIJNDAEL_256</code> is not the same as AES. The <code>256</code> relates to the <em>block size</em> of the cipher, not the key size.</p>

<p>Quick history lesson - AES was a competition that was eventually won by an algorithm called Rijndael. Rinjdael is a cipher defined for several block sizes (128, 160, 192, 224 and 256 bits). However, for AES only the 128-bit block size was selected.</p>

<p>The block size defines the size of the IV, when you use a mode that needs an IV (like CBC-mode). So for AES, you'll always need a 128-bit IV, regardless of key size. The supported key sizes are 128, 192 or 256 bits.</p>

<p>In PHP, one can use AES by using the cipher <code>MCRYPT_RIJNDAEL_128</code>.</p>
","919","<javascript><php><encryption><cryptojs>","0","0","2","2014-10-24 06:41:09","","0","","1814486","","2014-10-22 22:38:20","2014-10-22 22:06:15",""
"40601928","Various HMAC_SHA256 functions in classic ASP gives different results","<p>Somehow I need to generate a hash in Classic ASP which is equivalent to PHP's following function's output:</p>

<pre><code>$hash = hash_hmac('SHA256', $message, pack('H*', $secret));
</code></pre>

<p>where <code>$message = 'stackoverflow'; $secret = '1234567890ABCDEF';</code>. I tried quite a lot approaches online, but none matches the PHP result:</p>

<pre><code>bcb3452cd48c0f9048e64258ca24d0f3399563971d4a5dcdc531a7806b059e36
</code></pre>

<p><strong>Method 1: Using dvim_brix_crypto-js-master_VB.asp online (using CrytoJS)</strong></p>

<pre><code>Function mac256(ent, key) 
    Dim encWA
    Set encWA = ConvertUtf8StrToWordArray(ent)
    Dim keyWA
    Set keyWA = ConvertUtf8StrToWordArray(key)
    Dim resWA
    Set resWA = CryptoJS.HmacSHA256(encWA, key)
    Set mac256 = resWA
End Function

Function ConvertUtf8StrToWordArray(data)
    If (typename(data) = ""String"") Then
        Set ConvertUtf8StrToWordArray = CryptoJS.enc.Utf8.parse(data)
    Elseif (typename(data) = ""JScriptTypeInfo"") Then
        On error resume next
        'Set ConvertUtf8StrToWordArray = CryptoJS.enc.Utf8.parse(data.toString(CryptoJS.enc.Utf8)) 
        Set ConvertUtf8StrToWordArray = CryptoJS.lib.WordArray.create().concat(data) 'Just assert that data is WordArray
        If Err.number&gt;0 Then
            Set ConvertUtf8StrToWordArray = Nothing
        End if
        On error goto 0
    Else
        Set ConvertUtf8StrToWordArray = Nothing
    End if
End Function
</code></pre>

<p>The script can be found <a href=""https://github.com/ictmanagement/redsysHMAC256_API_ASP/blob/master/include/dvim_brix_crypto-js-master_VB.asp"" rel=""nofollow noreferrer"">here</a>. This method gives:</p>

<pre><code>c8375cf0c0db721ecc9c9b3a034284117d778ee8594285196c41d5020917f78c
</code></pre>

<hr>

<p><strong>Method 2: Pure Classic ASP Approach</strong></p>

<pre><code>Public Function HMAC_SHA256(prmKey, prmData)
    Dim theKey : theKey = prmKey
    Dim Block_Size, O_Pad, I_Pad
    Block_Size = 64
    O_Pad = 92 'HEX: 5c'
    I_Pad = 54 'HEX: 36'

    Dim iter, iter2
    If Len(theKey) &lt; Block_Size Then
        For iter = 1 to Block_Size - Len(theKey)
            theKey = theKey &amp; chr(0)
        Next
    ElseIf Len(theKey) &gt; Block_Size Then
        theKey = SHA256(theKey)
    End If

    Dim o_key_pad : o_key_pad = """"
    Dim i_key_pad : i_key_pad = """"
    For iter = 1 to Block_Size
        o_key_pad = o_key_pad &amp; Chr(Asc(Mid(theKey,iter,1)) xor O_Pad)
        i_key_pad = i_key_pad &amp; Chr(Asc(Mid(theKey,iter,1)) xor I_Pad)
    Next

    HMAC_SHA256 = SHA256(o_key_pad &amp; SHA256(i_key_pad &amp; prmData))
End Function
result = HMAC_SHA256(secret, message)
</code></pre>

<p>This method gives:</p>

<pre><code>bc0511316791176484c7d80bc8faaecd8388b75fb97516181ba6b361fd032531
</code></pre>

<hr>

<p><strong>Method 3: Using Amazon AWS's sha256.wsc (using CrytoJS)</strong></p>

<pre><code>Dim sha
Set sha = GetObject( ""script:"" &amp; Server.MapPath(""sha256.wsc"") )
sha.hexcase = 0
result = sha.b64_hmac_sha256(secret, message)
</code></pre>

<p>The WSC can be found <a href=""https://forums.aws.amazon.com/servlet/JiveServlet/download/9-34858-139271-2601/sha256.wsc"" rel=""nofollow noreferrer"">here</a>. This method gives (same result as Method 1):</p>

<pre><code>c8375cf0c0db721ecc9c9b3a034284117d778ee8594285196c41d5020917f78c
</code></pre>

<hr>

<p>I think the problem is the <code>pack()</code> part, which changes the Hex string to binary. Therefore, I found a way to reproduce the <code>pack()</code> function in ASP:</p>

<pre><code>Dim key2, hexarr, binstr
key2 = ""12 34 56 78 90 AB CD EF""
hexarr = Split(key2)
ReDim binarr(UBound(hexarr))

For i = 0 To UBound(hexarr)
  binarr(i) = Chr(CInt(""&amp;h"" &amp; hexarr(i)))
Next

binstr = Join(binarr, """")
</code></pre>

<p>where the <code>key2</code> is the original secret with space added in every 2 characters. By replacing the <code>secret</code> with <code>binstr</code>, the methods now produce:</p>

<pre><code>Method 1: 8ab9e595eab259acb10aa18df7fdf0ecc5ec593f97572d3a4e09f05fdd3aeb8f
Method 2: d23fcafb41d7b581fdae8c2a4a65bc3b19276a4bd367eda9e8e3de43b6a4d355
Method 3: 8ab9e595eab259acb10aa18df7fdf0ecc5ec593f97572d3a4e09f05fdd3aeb8f
</code></pre>

<p>None of the above results is identical to PHP's one. What did I miss now?</p>
","<p>Check out the following example.</p>

<p>The only requirement with this approach is Microsoft .Net Framework 2.0 (preinstalled starting from Windows Server 2003 R2) to use Com Interops.</p>

<p>I tried to be descriptive in the comments but feel free to ask questions about it.</p>



<pre class=""lang-vb prettyprint-override""><code>'Returns Byte(), UTF-8 bytes of unicode string
Function Utf8Bytes(text)
    With Server.CreateObject(""System.Text.UTF8Encoding"")
        Utf8Bytes = .GetBytes_4(text)
    End With
End Function

'Returns String, sequential hexadecimal digits per byte
'data As Byte()
Function BinToHex(data)
    With Server.CreateObject(""MSXML2.DomDocument"").CreateElement(""b64"")
        .dataType = ""bin.hex""
        .nodeTypedValue = data
        BinToHex = .text
    End With
End Function

'Returns Byte(), a keyed hash generated using SHA256 method
'data As String, key As Byte()
Function HashHmacSha256(data, key)
    With Server.CreateObject(""System.Security.Cryptography.HMACSHA256"")
        .Key = key
        HashHmacSha256 = .ComputeHash_2(UTF8Bytes(data))
    End With
End Function

'Returns Byte(), of a packed hexadecimal string
'instead of PHP's pack('H*'
Function HexToBin(data)
    With Server.CreateObject(""MSXML2.DomDocument"").CreateElement(""b64"")
        .dataType = ""bin.hex""
        .text = data
        HexToBin = .nodeTypedValue
    End With
End Function

packed_secret = HexToBin(""1234567890ABCDEF"")
message = ""stackoverflow""
binary_hash = HashHmacSha256(message, packed_secret)
string_hash = BinToHex(binary_hash)

Response.Write string_hash
</code></pre>
","897","<php><asp-classic><cryptojs>","4","4","1","2019-01-24 20:54:09","40608248","9","","","","","2016-11-15 04:14:31",""
"26501852","CryptoJS decryption fails when string with Unicode emosy chars","<p>I use CryptoJS for encryption and decryption of message in my app. Here is my code.</p>

<p><strong>//encryption</strong></p>

<pre><code>var msg = ""Hello"";
var passStr= '54472f2f7a7c41da0a001739';
var iv = CryptoJS.enc.Hex.parse('0000000000000000');
var passSHA256 = CryptoJS.SHA256(CryptoJS.enc.Utf8.parse(passStr));

var encrypted = CryptoJS.AES.encrypt(messageStr, passSHA256, { iv: iv });
var messageTosend = encrypted.toString(); 
</code></pre>

<p><strong>//decryption</strong></p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(messageTosend , passSHA256, { iv: iv });
var messageGot = decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>This works fine but some time fails with error( Malformed UTF-8 data)  when message contains Unicode chars like this.</p>

<pre><code>msg = """".
</code></pre>

<p>This gives me empty string.</p>
","","897","<javascript><encryption><unicode><cryptojs>","1","","0","2014-10-22 06:54:14","","2","","","","","2014-10-22 06:54:14",""
"24091915","Cordova calculate sha1 hash of large file without running out of memory","<p>I am trying to use sha1 hashes as a means of checking for file changes, the problem is that when trying to calculate the hash of a larger file(50-100MB) the app throws a Fatal Exception because it ran out of memory.</p>

<p>Version information:</p>

<ul>
<li>Cordova 3.5</li>
<li>Android 4.2.2</li>
<li>Galaxy Tab 2</li>
<li>org.apache.cordova.file 1.1.0</li>
<li>CryptoJS latest?</li>
<li>lib-typedarrays(module for CryptoJS) latest?</li>
<li>qjs latest</li>
</ul>

<p>Here is what im using:</p>

<pre><code>function _getFileChecksum(file){

    var deferred = Q.defer();
    if(typeof CryptoJS === 'undefined'){
        if(DEBUG){
            console.log('CryptoJS is required.');
        }
        return deferred.reject(new Error('CryptoJS is required.'));
    }

    var reader = new FileReader();

    reader.onload = function (evt) {
        if(DEBUG){
            console.log('_getFileChecksum: reader finished loading');
        }
        var arrayBuffer = evt.target.result;
        var wordArray = CryptoJS.lib.WordArray.create(arrayBuffer);
        var hash = CryptoJS.SHA1(wordArray);
        if(DEBUG){
            console.log('_getFileChecksum: hash = '+hash);
        }
        deferred.resolve(hash);
    };
    reader.onerror = function(anError){
        if(DEBUG){
            console.log('_getFileChecksum: reader error');
        }
        deferred.reject(anError);
    };
    reader.readAsArrayBuffer(file);

    return deferred.promise;
}
</code></pre>

<p>Now this works just fine for smaller files. But when i get to the larger ones thats where the problem happens. Does anyone know how i would calculate a sha1 has of a large file without running out of memory in the application?</p>
","<p>I was able to get around the out of memory issue by adding</p>

<pre><code>android:largeHeap=""true""
</code></pre>

<p>in my AndroidManifest.xml in the <code>&lt;application /&gt;</code> tag</p>

<pre><code>&lt;application android:hardwareAccelerated=""true"" android:icon=""@drawable/icon"" android:label=""@string/app_name"" android:largeHeap=""true""&gt;
</code></pre>
","896","<javascript><cordova><sha1><cordova-3><cryptojs>","1","2","1","2014-06-06 23:39:23","24092125","0","","","","","2014-06-06 23:10:12",""
"45856413","Angular4/Typescript sign Kraken API call (CryptoJS)","<p>I am trying to call the <a href=""https://www.kraken.com/help/api"" rel=""nofollow noreferrer"">Kraken API</a> from my Agnular4 project. I am using the <code>crypto-js</code> library <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a>.</p>

<p>Kraken requires this signature:</p>

<pre><code>API-Sign = Message signature using HMAC-SHA512 of (URI path + SHA256(nonce + POST data)) and base64 decoded secret API key

Correct result:
gy+Ljq8nPD2kFFCQSofQ46pbPV8z8D7klrU78Kxvl6jyior/Ev2FiclhKs+zoqrmL8u8u1Y9CXzIw0n3CswtNA==

Result from:
CryptoJS.HmacSHA512(path + CryptoJS.enc.Hex.stringify(hashDigest), secret);

DWtQpzZJkcHw7Ai1aFUNAR8ne0h3P/GaHc1OIUGsITifOOE+IAWF9f5HxspSY5wF6qcQwCKx9Bz1MDwFhu01QA==
</code></pre>

<p>I have made these calls before out of an Android App and it worked (see code and result at the bottom of this post).</p>

<p>I have also tried out a lot of things for several days. I have probably made a dumb mistake :D</p>

<p>Thanks in advance for reading and hopefully replying to this :)</p>

<p>Here is my Angular4 client code:</p>

<pre><code>import * as CryptoJS from 'crypto-js';
...
this.API_SECRET = ""0a...g=="";
...
private getMessageSignature(path: string, request: string, nonce: number) {
    console.log('getMessageSignature', path, request, nonce);
    console.log('request', request);
    const message = nonce + request;
    var secret = CryptoJS.enc.Base64.parse(this.API_SECRET);
    var hashDigest = CryptoJS.SHA256(message);
    var hashDigestBase64 = CryptoJS.enc.Base64.stringify(hashDigest);
    console.log('hashDigest', CryptoJS.enc.Base64.stringify(hashDigest)); // correct
    console.log('hashDigest', CryptoJS.enc.Hex.stringify(hashDigest)); // correct

    var hmacDigest = CryptoJS.HmacSHA512(path + hashDigest, secret);
    console.log('hmacDigest', CryptoJS.enc.Base64.stringify(hmacDigest));
    var hmacDigest1 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Base64.stringify(hashDigest), secret);
    console.log('hmacDigest1', CryptoJS.enc.Base64.stringify(hmacDigest1));
    var hmacDigest2 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Hex.stringify(hashDigest), secret);
    console.log('hmacDigest2', CryptoJS.enc.Base64.stringify(hmacDigest2));
    var hmacDigest3 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Latin1.stringify(hashDigest), secret);
    console.log('hmacDigest3', CryptoJS.enc.Base64.stringify(hmacDigest3));

    var hmacDigest4 = CryptoJS.HmacSHA512(path + hashDigest, this.API_SECRET);
    console.log('hmacDigest4', CryptoJS.enc.Base64.stringify(hmacDigest4));
    var hmacDigest5 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Base64.stringify(hashDigest), this.API_SECRET);
    console.log('hmacDigest5', CryptoJS.enc.Base64.stringify(hmacDigest5));
    var hmacDigest6 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Hex.stringify(hashDigest), this.API_SECRET);
    console.log('hmacDigest6', CryptoJS.enc.Base64.stringify(hmacDigest6));
    var hmacDigest7 = CryptoJS.HmacSHA512(path + CryptoJS.enc.Latin1.stringify(hashDigest), this.API_SECRET);
    console.log('hmacDigest7', CryptoJS.enc.Base64.stringify(hmacDigest7));

    return CryptoJS.enc.Base64.stringify(hmacDigest);
}
</code></pre>

<p>Angular4 result:</p>

<pre><code>getMessageSignature /0/private/Balance nonce=1503065538999 1503065538999
request nonce=1503065538999
hashDigest EcvBaI+IvdvibXZ4UiNlcuAvT8fPPdAItwhBrCNx7q8=
hashDigest 11cbc1688f88bddbe26d767852236572e02f4fc7cf3dd008b70841ac2371eeaf
hmacDigest DWtQpzZJkcHw7Ai1aFUNAR8ne0h3P/GaHc1OIUGsITifOOE+IAWF9f5HxspSY5wF6qcQwCKx9Bz1MDwFhu01QA==
hmacDigest1 3f+oCR9hagmWESRcaZhfU6gHlMNFnnRCP25Yslc1nitfFvkq+/SikcByeWNQFWICkTLUOxMxQr4LBw2mcGwC9g==
hmacDigest2 DWtQpzZJkcHw7Ai1aFUNAR8ne0h3P/GaHc1OIUGsITifOOE+IAWF9f5HxspSY5wF6qcQwCKx9Bz1MDwFhu01QA==
hmacDigest3 87Zs0C/7b1fPuINnkB8WHQ1LhUG9u3hMMIt1hGOKszWZ4yHfohdlLLe2eUdpZr+c2B24ecYaqc/r6WRcDp5sdg==
hmacDigest4 MySDdpd+ufXJLp6BhP2oGpvnCrs1FUlIFp5+4P6oW0Zf3H9CfuQ3Z6BioUr9l2O3Y1VXfo9qhHNtRO/F8NS5Ag==
hmacDigest5 ndMT5/pjEgYI1qd7cpaloiJJ6Q6ktBl2R9Kgi4kL3UwSiSix/jLi9sFQdZTNqmqJIt70GFNqbDUyQII+FOj/tw==
hmacDigest6 MySDdpd+ufXJLp6BhP2oGpvnCrs1FUlIFp5+4P6oW0Zf3H9CfuQ3Z6BioUr9l2O3Y1VXfo9qhHNtRO/F8NS5Ag==
hmacDigest7 iOU29TPq7vm2gQ6totB9UbVrQGUBNbxK5G7nbqMXWJFjdO2BTTpQD59bCPjkijPz3hgQkwdHpdHimJfCIXYYAw==
</code></pre>

<p>Android Code:</p>

<pre><code>private static String calculateSignature(String nonce, String data, String path) {
    System.out.println(""calculateSignature "" + nonce + "" "" + data + "" "" + path);
    String signature = """";
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update((nonce + data).getBytes());
        Mac mac = Mac.getInstance(""HmacSHA512"");
        mac.init(new SecretKeySpec(Base64.decode(API_SECRET.getBytes(), Base64.NO_WRAP), ""HmacSHA512""));
        mac.update(path.getBytes());
        byte[] digest = md.digest();
        System.out.println(""digest = "" + Base64.encodeToString(digest, Base64.NO_WRAP));
        signature = Base64.encodeToString(mac.doFinal(digest), Base64.NO_WRAP);
        System.out.println(""signature = "" + signature);
    } catch(Exception e) {}
    return signature;
}
</code></pre>

<p>Android result:</p>

<pre><code>calculateSignature 1503065538999 nonce=1503065538999 /0/private/Balance
digest = EcvBaI+IvdvibXZ4UiNlcuAvT8fPPdAItwhBrCNx7q8=
signature = gy+Ljq8nPD2kFFCQSofQ46pbPV8z8D7klrU78Kxvl6jyior/Ev2FiclhKs+zoqrmL8u8u1Y9CXzIw0n3CswtNA==
</code></pre>
","<p>The problem was that the methods provided by <code>@types/crypto-js</code> only include string methods.</p>

<p>So I removed the package and can use the <code>update</code> methods, etc.</p>

<pre><code>private getMessageSignature(apiSecret: string, path: string, request: string, nonce: number) {
  const secret = CryptoJS.enc.Base64.parse(apiSecret);
  const hashDigest = CryptoJS.SHA256(nonce + request);

  const hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA512, secret);
  hmac.update(path);
  hmac.update(hashDigest);

  return CryptoJS.enc.Base64.stringify(hmac.finalize());
}
</code></pre>
","890","<angular><typescript><cryptojs>","2","2","1","2017-10-15 08:38:36","46753240","0","4","","","","2017-08-24 08:17:45",""
"47307282","CryptoJS HmacSHA256 Encryption results differ from Python","<p>CryptoJS encrypted string can pass different parameters in python can only pass a string? How to implement the second CryptoJS implementation in python
 ,how to get clientKey2,This will only give the first result.Thanks!</p>

<pre><code>&gt; saltedPassword=CryptoJS.PBKDF2(""key"", ""salt"", {keySize: 8,iterations:500,hasher: CryptoJS.algo.SHA256});    
&gt; clientKey1=CryptoJS.HmacSHA256(saltedPassword.toString(), ""Client Key"")
&gt; clientKey2=CryptoJS.HmacSHA256(saltedPassword, ""Client Key"")
&gt; clientKey1.toString()
&gt; ""857ef8988876a3bb6bcadb85ca257787074e73e830d7dc14c1f838ba46aef1f5""
&gt; clientKey2.toString()
&gt; ""9a8574da9b276ee1162dcb92071df587f4513bc03060bda1e9b3897d46233416""
&gt; saltedPassword.toString()
&gt; ""6e441ccd26e6b35198b4b17457dc0266d36b751d0062b5850b0e302ceb1d6dcc""
</code></pre>

<p>i use this way can get clientKey1,</p>

<pre><code>import hashlib
import hmac

def HmacSHA256(k,v):
    message = bytes(k).encode('utf-8')
    secret = bytes(v).encode('utf-8')
    signature = hmac.new(secret, message, digestmod=hashlib.sha256).hexdigest()
    return signature

signature = HmacSHA256(""6e441ccd26e6b35198b4b17457dc0266d36b751d0062b5850b0e302ceb1d6dcc"",""Client Key"")

print signature
</code></pre>

<p>How to get the second result in Python,Thanks!</p>
","<p>To get the desired <code>clientKey2</code> you need to encode the hex digits of your <code>saltedPassword</code> string to bytes. One way to do that which works on both Python 2 &amp; Python 3 is to use <a href=""https://docs.python.org/3/library/binascii.html#binascii.unhexlify"" rel=""nofollow noreferrer""><code>binascii.unhexlify</code></a>.</p>

<p>Your <code>HmacSHA256</code> function is a bit odd. It won't work on Python 3, since <code>bytes</code> objects don't have an <code>.encode</code> method. In Python 2, <code>bytes</code> is just a synonym for <code>str</code>.</p>

<p>Anyway, here's some code that works on both Python 2 &amp; Python 3.</p>

<pre><code>from __future__ import print_function
import hashlib
import hmac
import binascii

key = ""Client Key"".encode()
salted = ""6e441ccd26e6b35198b4b17457dc0266d36b751d0062b5850b0e302ceb1d6dcc""
raw = binascii.unhexlify(salted)

signature = hmac.new(key, salted.encode(), digestmod=hashlib.sha256).hexdigest()
print(signature)

signature = hmac.new(key, raw, digestmod=hashlib.sha256).hexdigest()
print(signature)
</code></pre>

<p><strong>output</strong></p>

<pre><code>857ef8988876a3bb6bcadb85ca257787074e73e830d7dc14c1f838ba46aef1f5
9a8574da9b276ee1162dcb92071df587f4513bc03060bda1e9b3897d46233416
</code></pre>

<p>The output is identical on Python 2 &amp; Python 3.</p>

<p>BTW, it would be simpler to do this task in Python 3, which makes a clean distinction between text and byte strings. Also, the Python 3 <code>hashlib</code> module has a <a href=""https://docs.python.org/3/library/hashlib.html#hashlib.pbkdf2_hmac"" rel=""nofollow noreferrer""><code>pbkdf2</code> function</a>.</p>
","886","<python><hmac><cryptojs>","1","2","1","2017-11-15 13:04:24","47308168","1","","8944964","","2017-11-15 12:45:06","2017-11-15 12:21:08",""
"40819242","Convert crypto class to async code","<p>For my app, I will heavily use <code>ecdh</code>, <code>aes</code> and <code>ecdsa</code> for securing the authentication of users and maintaining secure lines.</p>

<p>Current code for <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto module</a> is entirely synchronous in nature. I have made a utils folder as follows</p>

<pre><code>'use strict'

// Make async later on for performance
// Add bluebird for better error handling
const crypto = require('crypto');

let cipher = {};

cipher.createCipher = (pw) =&gt; {
  return crypto.createCipher('aes192', pw);
}

cipher.encryptText = (cipher, plainText, callback) =&gt; {
  try {
    if (!callback &amp;&amp; !callback instanceof Function) {
      throw new Error(""callback must be passed"")
    }
    if (!plainText instanceof String) {
      throw new Error(""2nd param must be plain text"")
    }
    let encrypted = '';
    cipher.on('readable', () =&gt; {
      var data = cipher.read();
      if (data)
        encrypted += data.toString('hex');
    });
    cipher.on('end', () =&gt; {
      callback(null, encrypted);
    });
    cipher.write(plainText);
    cipher.end();
  } catch (e) {
    callback(e, null);
  }
}

cipher.decryptText = (cipher, cipherText, callback) =&gt; {

}

module.exports = cipher;
</code></pre>

<p>In my test class, I am calling the functions as</p>

<pre><code>const cipher = require('../components/cipher.js');
cipher.encryptText(cipher.createCipher(key), paramOne, (err, data) =&gt; {
  console.log('\n  func 1 \n');
  console.log(data);
})

console.log('break');

cipher.encryptText(cipher.createCipher('1'), 'paramTwo', (err, data) =&gt; {
  console.log('\n func 2 \n');
  console.log(data);
})
</code></pre>

<p>paramOne is around 10-12 lines of text, in an asyc function, the lower function should get executed first. However, that is not the case.</p>

<p>Is there any way in which I can modify my <code>components/cipher.js</code> class to covert the encrypting and decryption functions to be truely asynchronous.</p>

<p>Multi authorization attempts will require multi key exchanges which is very expensive cpu usage.</p>

<p>Using tests, I have confirmed that the <code>encryptText()</code> function is being called for the second time, only after it has returned a value from its from execution, i.e. it waits until <code>callback</code> one is done.</p>

<p>need some advice/ help please guys. TiA </p>
","<blockquote>
  <p>Is there any way in which I can modify my components/cipher.js class
  to covert the encrypting and decryption functions to be truely
  asynchronous.</p>
</blockquote>

<p>In node.js, the only way to convert a truly synchronous CPU-bound operation to an asynchronous operation is to either invoke it in another process or write/modify native code that can use native threads/processes and hook that into node.js as a module.</p>

<p>So, if you really want to keep it from blocking the main node.js executino thread, you'd have to move it out of the node.js process.  You could startup a group of child processes (probably making them simple http servers would be simplest) and then use a work queue to queue up info for each crypto process.  Each crypto process would just listen for a request to do some crypto work.  Since the request to that child process would be an http request, it would be asynchronous from the main node.js thread.  You could fire up as many crypto processes as you had CPUs (minus one) in your computer.  Or, yo could even use other computers for the crypto processes (that doesn't really matter since you're talking to them with http requests).</p>

<p>There's nothing that says the other servers have to be web servers.  They could be webSocket servers or you could make your own protocol on top of TCP.  I suggested web servers just because they are so simple (just a couple lines of code in node.js) and they are easy to scale.</p>

<p>One simple idea might be to create a clustered crypto http server.  Then, you could just blindly make requests of it and the nodejs clustering would automatically handle the load balancing and scaling for you.</p>
","885","<node.js><asynchronous><encryption><bluebird><cryptojs>","0","1","2","2018-12-03 10:18:41","","0","","","","","2016-11-26 14:14:34",""
"40819242","Convert crypto class to async code","<p>For my app, I will heavily use <code>ecdh</code>, <code>aes</code> and <code>ecdsa</code> for securing the authentication of users and maintaining secure lines.</p>

<p>Current code for <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto module</a> is entirely synchronous in nature. I have made a utils folder as follows</p>

<pre><code>'use strict'

// Make async later on for performance
// Add bluebird for better error handling
const crypto = require('crypto');

let cipher = {};

cipher.createCipher = (pw) =&gt; {
  return crypto.createCipher('aes192', pw);
}

cipher.encryptText = (cipher, plainText, callback) =&gt; {
  try {
    if (!callback &amp;&amp; !callback instanceof Function) {
      throw new Error(""callback must be passed"")
    }
    if (!plainText instanceof String) {
      throw new Error(""2nd param must be plain text"")
    }
    let encrypted = '';
    cipher.on('readable', () =&gt; {
      var data = cipher.read();
      if (data)
        encrypted += data.toString('hex');
    });
    cipher.on('end', () =&gt; {
      callback(null, encrypted);
    });
    cipher.write(plainText);
    cipher.end();
  } catch (e) {
    callback(e, null);
  }
}

cipher.decryptText = (cipher, cipherText, callback) =&gt; {

}

module.exports = cipher;
</code></pre>

<p>In my test class, I am calling the functions as</p>

<pre><code>const cipher = require('../components/cipher.js');
cipher.encryptText(cipher.createCipher(key), paramOne, (err, data) =&gt; {
  console.log('\n  func 1 \n');
  console.log(data);
})

console.log('break');

cipher.encryptText(cipher.createCipher('1'), 'paramTwo', (err, data) =&gt; {
  console.log('\n func 2 \n');
  console.log(data);
})
</code></pre>

<p>paramOne is around 10-12 lines of text, in an asyc function, the lower function should get executed first. However, that is not the case.</p>

<p>Is there any way in which I can modify my <code>components/cipher.js</code> class to covert the encrypting and decryption functions to be truely asynchronous.</p>

<p>Multi authorization attempts will require multi key exchanges which is very expensive cpu usage.</p>

<p>Using tests, I have confirmed that the <code>encryptText()</code> function is being called for the second time, only after it has returned a value from its from execution, i.e. it waits until <code>callback</code> one is done.</p>

<p>need some advice/ help please guys. TiA </p>
","<p>Use the <a href=""https://github.com/ronomon/crypto-async"" rel=""nofollow noreferrer"">@ronomon/crypto-async</a> module. It provides truly asynchronous cipher, hash, and HMAC operations executed in Node's threadpool for multi-core throughput. You can run multiple operations in parallel (up to 4x-8x depending on how many cores your machine has).</p>
","885","<node.js><asynchronous><encryption><bluebird><cryptojs>","0","0","2","2018-12-03 10:18:41","","0","","","","","2016-11-26 14:14:34",""
"34125223","PHP encryption and CryptoJS decryption","<p>I have a problem when decrypting (using CryptoJs) my PHP encrypted data.
Here is my PHP encryption:</p>

<pre><code>function encrypt($pure_string, $encryption_key, $iv) {
    $encrypted_string = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $encryption_key, utf8_encode($pure_string), MCRYPT_MODE_CBC, $iv);
    return $encrypted_string;
}

function cripto()
{
    $crypto_key = ""230e8cb8c43d532f389ff0e2b5337919"";
    $data_to_encrypt = ""Data to encrypt"";

    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);

    $ciphertext = $this-&gt;encrypt($data_to_encrypt, $crypto_key, $iv);
    return array(""iv"" =&gt; pack('H*', $iv), ""chipertext"" =&gt; base64_encode($ciphertext),""key"" =&gt; $crypto_key);

}
</code></pre>

<p>And here is my JavaScript code (the result of php crypto function is stored in encrypted variable):</p>

<pre><code>var ciphertext = &lt;?php echo '""'.$encrypted[""ciphertext""].'""'; ?&gt;;
var iv = &lt;?php echo '""'.$encrypted[""iv""].'""'; ?&gt;;
var crypto_key = &lt;?php echo '""'.$encrypted[""key""].'""'; ?&gt;;

iv = CryptoJS.enc.Hex.parse(iv);
ciphertext = CryptoJS.enc.Base64.parse(ciphertext);

var decrypted = CryptoJS.AES.decrypt(ciphertext, crypto_key,{ iv: iv });
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>My decrypted value is always an empty string and I can't figure out why.</p>
","<p>You have two problems:</p>

<ul>
<li>PHP uses Zero padding (padding of 0-15 bytes of 0x00), but CryptoJS uses PKCS#7 padding by default. Those are incompatible.</li>
<li>CryptoJS' <code>decrypt()</code> function expects a CipherParams object which you can simply emulate by passing an object with the <code>ciphertext</code> property set.</li>
</ul>

<p>Together:</p>

<pre><code>iv = CryptoJS.enc.Hex.parse(iv);
ciphertext = CryptoJS.enc.Base64.parse(ciphertext);

var decrypted = CryptoJS.AES.decrypt({ ciphertext: ciphertext }, crypto_key, {
    iv: iv,
    padding: CryptoJS.pad.ZeroPadding
});
console.log(decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Don't forget to include <a href=""https://raw.githubusercontent.com/CryptoStore/crypto-js/3.1.2/build/components/pad-zeropadding-min.js"" rel=""nofollow noreferrer"">pad-zeropadding-min.js</a>.</p>

<hr>

<p>Keep in mind that JavaScript cryptography has its <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">problems for justification</a>. You really should be using SSL, because without SSL, this is just obfuscation (key is sent along with the ciphertext).</p>

<p>It would be better to do the <a href=""https://stackoverflow.com/a/27590539/1816580"">PKCS#7 padding in PHP</a> and keep the default in CryptoJS.</p>
","884","<javascript><php><encryption><cryptojs>","-1","1","1","2016-05-13 18:55:34","","0","","5648061","","2016-01-15 15:24:38","2015-12-07 01:49:01",""
"53369397","TripleDES encrypt and decrypt in javascript - CryptoJS","<p>I'm using CryptoJS library to <code>TripleDES</code> function but the decrypt data doesn't work. my decrypted data dons't return the origin string.</p>

<pre><code>var t = ""a"";
var d = ""john"";
var key = CryptoJS.MD5(t).toString()
var param = CryptoJS.TripleDES.encrypt(d, key).toString();
console.log('decrypt',CryptoJS.TripleDES.decrypt(param, key).toString())
console.log('encrypt',param) // it should return `john`. but it returns a different value.
</code></pre>

<p>the result of this encryption:</p>

<pre><code>decrypt 6a6f686e
encrypt U2FsdGVkX19Ww0uMTSo+qAV5PVzsEhSR
</code></pre>

<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a></p>
","<p>solved:</p>

<p>You should <code>CryptoJS.enc.Utf8</code> inside <code>toString</code> function.</p>

<pre><code>console.log('decrypt',CryptoJS.TripleDES.decrypt(param, key).toString(CryptoJS.enc.Utf8))
</code></pre>
","875","<javascript><react-native><encryption><cryptojs>","0","0","1","2018-11-19 06:42:44","","0","","","","","2018-11-19 06:31:17",""
"37579400","CryptoSwift + CryptoJS Swift","<p>I really need some help here with decrypting server response encrypted with CryptoJS.</p>

<p>I use <a href=""https://github.com/krzyzanowskim/CryptoSwift"" rel=""nofollow"">CryptoSwift</a> to decrypt response.</p>

<p>Here is a sample of server response data I get.</p>

<blockquote>
  <p>{\""ct\"":\""TwQY1XIhFW+SHG9L8ONyUAH8XWbgY7Yhef/ibb6jKkMX+nDq2U78553/0hXlXvKnp6XsAGc0Zg+2AVkCcsHLKrJRsIlvGZmdckLParBZIa3Z2DRozegrKrctin2fK4pkn0xiidnbeth0uMdiNUrdFXoEIRQLfFobgqDz5VIRDw9tvhL3Ftz169ooEg1duTag0BQ5Qu4TP1K4VsTD78KWr4C2A4qYpj1bAQRJrsabDAhhbVjRGIoSy5D30H10e9RE9IEGDwSFuoXW0+2n5NhFSWpuWADV45t6FuNZ5Ptc/l1NjvPTi2CZGhiW4Vl8pX3HuzPeFpJE9UUNuPr2E8/vhqt8Hx+JjT0LOoszHCUJ4eWv2l6TEAwxk5I1MNz7XMKVrAYUt7jyu2Ob8iTE+zJAatIOkHhRI1HeU9wMevEs6sdP2jDQflm6Rb2v3vNhtRQwgqlCG+RNpSGG0zQUMtOKO6mrN/vJadMtPYjbgP1o5IcKrR5vvsvYI3aEJwrjkitpPY/hVK8OA8OvMZjuWsNcPeJFlww8adEgAWrBzZYGusZsooc8/O5obJVspzqrOHtFfAo8sBms2ovJEs5wgyCBEW33I1Ka8D1EJG+ncyR7h/rOjwpy8ynbWc0qBN9QKBNFRdxLqVRR8g6cHRrEzGvVPlx8AyPmfSAhzf/KppAX0YPmF1v29rjWKBCWOrSlISA7UulkZzHVdrGX3pEL+MPI2bQB9MyAjHHRKjAT2t6k8FFxKzvmckRULllm/K9Ax3DUqnmUbJ6sChBlG+Cl3VFEQZZwJ1Mjw09CKLGFCOi06bEBKp9apqBRkrYBosUnLAM6cnM7/tqItgD//Fx88bGqNL0wc8gygKsT+nVxc+VwcNis88pDcZht4Ey5eE3Wy8loKcEUZoC7T8//Qp72tmUrFZPULzn45lQMZ2Z83Fd115JoNIV/HjEOQgx88OgtPcs6Q3MP7KD5xxeKtQ6hoTT5WFzxetdGSeZffIZvRZHts05hBtjvND5N10lyISFIegD9kTbtlkSO2PQIDEmt3Xi2M/jP9+Tz9kbKUs2VqjB8hfh27f8/MrLNHJbOqGJmHBSwVQ9TvzTfeKbb090Hg3AQz3KbzlmFcoj6KcO1eHAKhixgOJfKX93NII2mfjfbSUgCtR/Sl/UEsHjYquQBlsGaQRSqr7dpgo55/aT055y+4V1LxLkOdTq6gnxPkzYUSmlTlsmxgmsyGKbWolvyBCz8NA7PnNLR3Ym/EHGucFMLhtDUAq07HItAhSZ/b6F6zsyMbEro8FbRK8DS9GI/3/KmhXgQ+0LdeCT/F2hAB/YnCnsjHBiLoMX+28vAhBZbEKkZUK94UxBVXuURs573s6j6yZMCBNb2cc2YFlw4LanzXi8jT8mRGZhBXsdqUQeZ58k0jNdYZPljM0m7Mqj7I5HjJiuyq3wTKdEFFIh3zoMNVmr9PGiwBq9nGjwuB3jGLYnJx1NX0xt+X8HnFytD7rkHImi8ljC4b+Fcv7K4saKx3BZCSq54SAzfrYQDOkbEG0Y+CxxXoqjiMMk9knJbyFcYYQ+xgtdAGyd+3RUK3xLhjozL8jioWhvhtse/MvLD8B8jbS6FfJDeB1ZDddfbHRBKdIEpvnhU/fUOdB+1kM59cMoZe0o9S22bzAS8pzv9Fv0OEeSQDsSZukzR4VgrLwj5z/eYfRwJOdqfkwEkL3EWJ3pAESTnVc8Ew1fOGTAnrmo9GYtIuoOWeeP9kvJef0YfTMTJ6jX/jzjsqpsz6YEVT4eGwES3ky817WfMya2R/8iVlrL5be5axzw7JIkjFhZTnsnLts58DCuoVqmTnGRDbAXIPxCDfqdw4J9rx03cnssuvf40rySgx7jUWxolz/Hs/u18mvy2e7+MnuO7hlnAmhfLGlrlt7uF9fnByZHgBaTfAWUg9WY05wmBN3n2ghbmqMACWFxvmZvTxoG8DiJHoBW6suV/3iQbKHpIBAFpP9mgeG9uoccnreH0tC4wDbQyCbFBeDewYF+2utopXHDqTRSzamV4sh0IigRU89LkxCqDKUKLebKqsa9Gd9FiN0Moa3H/FcpPChdcYcSVxOVDp6AKMnu6R9eeWUvYBDKE8liWkLsvB7GSweRi3m4l3DEar7HhO2NQBmzQ03RRgg5+BC4UtaSDHwU0BVV+Zh9KjTk2As1XjCoeUsYOS6LUa4DKx2UHKpe5jHb6ZcAmp8ZPfJy4TuwlzKSzuIBI92z3fFEeYTacxd9XMOR2jGN2RZAUMBDGQwXq0v3hH6TTDguAeLTB/eWGNNXodGtRfUI624afI6NZ2BrT5vHDMCKHBf/arw8NOW9h2Ek8s0vJq0A1435C30G0WQC73JrKw32jaYO8IvG0vnsZWF385sDaX3JNJ0L8l4BtQH8z/cUaiqUlAmtIbQ2opaNpniNZROe+z5/REO0XmFtit7vdDUq1HpRhTY/n3EoWe1ChhLbDVoM6TOXH2D51f40eJ0/Qs+Ch4dbrqYtYxEhkLJB+Ha+7ePSJqmUDSRQHXOGUKCnUh/vm425ZpuxIgE4E+KdslAuWTx1u1/WagVywjyj12OeZ84xsXVf0kJs1nCFvnkhb3wEjJrbSRbBvcBkP4zZsMTzcgFrzugqhtZ2LhZFtdUaQYa/tXjAF8DBdq+hlF+8RPul1riAczQoqDQkonYMH2WA9utWLWTYmPVJODLPEO5mL+yXqX9iCh3YycR8ssJgCkBmeN+yLydUoWLDfIC8NGnlcprpDqXrM0aDTwxADiBG4yWIgAxoZXCQEKIUxK0NuOssW9Z6tCB6yxDPzJdRqeOC2I2ky82YsIrLhPutspqycPAf4B8gbsUBcIqtflYhebiz50T3gk4gNS/2HNShGdzjPhjBvqk+GzETAu9t0JmbWBkuHq07r0lvM8zn474YHvzYIXOBUuZJKpGWPK+fvbEP1qXOTP4EkBSdgU0pcNO/Y7D3g4R26qTWmyWvnFKFAAGjXawwxKqBcdSJZxNkOgg/uekCAhRSwUq9qaeJHU1dl+M9OOwa7iGwlXtUPht0+1FGbN14=\"",\""iv\"":\""d6d6bd8ee407bc25a7b23d8d36b7bce9\"",\""s\"":\""b8e72892c801c87c\""}""}</p>
</blockquote>

<p>Simple string parsing clears the encrypted string and gives me the following data:</p>

<pre><code>let iv = ""d6d6bd8ee407bc25a7b23d8d36b7bce9"" 
let salt = ""b8e72892c801c87c""
</code></pre>

<p>and a key formend with other data</p>

<pre><code>let key = ""8aa1ec1e6948b481d1ee450c94ffb2edc774877325df4d05aca2e5827497ed33""
</code></pre>

<p>Here is the peace of code I use to decrypt response:</p>

<pre><code>// transforming key to [UInt8]
    let keyChars = Array(key.characters)
    let keyBytes = 0.stride(to: keyChars.count, by: 2).map {
        UInt8(String(keyChars[$0 ..&lt; $0+2]), radix: 16) ?? 0
    }

    // transforming iv to [UInt8]
    let ivChars = Array(iv.characters)
    let ivBytes = 0.stride(to: ivChars.count, by: 2).map {
        UInt8(String(ivChars[$0 ..&lt; $0+2]), radix: 16) ?? 0
    }

    // transforming encryptedData to [UInt8]
    let messageData = encrypted.dataFromHexadecimalString()
    let byteArray = messageData!.arrayOfBytes()


    do {
        let decryptedBytes: [UInt8] = try AES(key: keyBytes, iv: ivBytes, blockMode: .CFB).decrypt(byteArray)
        let data = NSData.withBytes(decryptedBytes)
        let decrypted = data.base64EncodedStringWithOptions([])
        let json = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions())
        print(""decrypted = \(json)"")
    } catch {
        print(""error = \(error)"")
    }
</code></pre>

<p>What ever I do I get either error = Decrypt or base64 string that does not decode to a JSON as it suppose to.</p>

<p>P.S.: I did try CryptoJS.swift but the result was ""undefined""</p>

<p><strong>UPD</strong></p>

<p><a href=""https://github.com/maksTheAwesome/decryptorSample"" rel=""nofollow"">Sample project</a>
This is how data encrypted on back end:</p>

<pre><code>CryptoJS.AES.encrypt(JSON.stringify(options.params), key, { format: JsonFormatter }).toString()
</code></pre>

<p>This is how data decrypted on back end:</p>

<pre><code>JSON.parse(CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(raw, key, { format: JsonFormatter })))
</code></pre>

<p>I tried to to something similar in my sample project but for some reason it did not work for me.</p>

<p><strong>UPD2</strong></p>

<p>Update from back end</p>

<pre><code>// Nodejs import
var node_cryptojs   = require('node-cryptojs-aes');
var CryptoJS        = node_cryptojs.CryptoJS;
var JsonFormatter   = node_cryptojs.JsonFormatter;
// Data to encrypt and encryption key
var data            = {'hello':'world'};
var key             = '8aa1ec1e6948b481d1ee450c94ffb2edc774877325df4d05aca2e5827497ed33';
// Encryption of the data
var encrypted       = CryptoJS.AES.encry

var decrypted       = JSON.parse(CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(encrypted, key, { format: JsonFormatter })))
</code></pre>

<p><strong>UPD3</strong></p>

<p>No, the name is similar but the API is different. We used npmjs.com/package/node-cryptojs-aes on the server-side (encryption+ decryption) and code.google.com/archive/p/crypto-js client-side on our site (also encryption+decryption)</p>

<p><strong>Sample of encrypted data</strong></p>

<blockquote>
  <p>{""_id"":""5687ad129b65920a00b56a9b"",""type"":""user"",""created"":""2016-01-02T10:57:22.851Z"",""uuid"":""d9df3412cee97ec1d0a8c547f73e4bb6"",""secret"":""307a14f6ffc667c7941e6263edca4149"",""profile"":{""lastname"":""Mmm"",""gender"":""Male"",""firstname"":""Mmm"",""email"":""mmm@mmm.mmm"",""dob"":""1993-10-31T00:00:00.000+0200""},""avatar"":{""large"":""<a href=""https://graph.facebook.com/v2.4/1122734811071660/picture?width=120&amp;height=120"" rel=""nofollow"">https://graph.facebook.com/v2.4/1122734811071660/picture?width=120&amp;height=120</a>""},""location"":{""country"":{""filename"":""greece"",""code"":""GR"",""continent"":""Europe"",""name"":""Greece""},""state"":{""id"":""Aitolia
  kai Akarnania"",""country"":""GR"",""name"":""Aitolia kai
  Akarnania""}},""auth"":{""facebook"":{""userID"":""1122734811071660""}},""notifications"":{""new_window"":{""sms"":false,""email"":true,""push"":false},""new_live"":{""sms"":false,""email"":true,""push"":false},""new_premium"":{""sms"":true,""email"":true,""push"":false},""reminder"":{""sms"":true,""email"":true,""push"":false},""new_arcade"":{""sms"":true,""email"":true,""push"":false},""ranking"":{""sms"":false,""email"":true,""push"":false}},""metas"":{},""stats"":{""game"":{""time"":{""total"":1084452,""maze"":{""mean"":180436,""stdev"":423,""min"":180013,""max"":180859,""sum"":360872},""wordsearch"":{""mean"":111639.5,""stdev"":68379.5,""min"":43260,""max"":180019,""sum"":223279},""trivia"":{""mean"":22410,""stdev"":0,""min"":22410,""max"":22410,""sum"":22410},""brokenword"":{""mean"":40399,""stdev"":0,""min"":40399,""max"":40399,""sum"":40399},""imagelabel"":{""mean"":38349.5,""stdev"":22808.5,""min"":15541,""max"":61158,""sum"":76699},""scramble"":{""mean"":180174,""stdev"":0,""min"":180174,""max"":180174,""sum"":180174},""sort"":{""mean"":180619,""stdev"":0,""min"":180619,""max"":180619,""sum"":180619}},""score"":{""total"":4500,""maze"":{""mean"":null,""stdev"":null,""min"":null,""max"":null,""sum"":0},""wordsearch"":{""mean"":1000,""stdev"":0,""min"":1000,""max"":1000,""sum"":1000},""trivia"":{""mean"":800,""stdev"":0,""min"":800,""max"":800,""sum"":800},""brokenword"":{""mean"":800,""stdev"":0,""min"":800,""max"":800,""sum"":800},""imagelabel"":{""mean"":950,""stdev"":50,""min"":900,""max"":1000,""sum"":1900},""scramble"":{""mean"":null,""stdev"":null,""min"":null,""max"":null,""sum"":0},""sort"":{""mean"":null,""stdev"":null,""min"":null,""max"":null,""sum"":0}}},""positions"":{""position"":{""avg"":0}},""played"":{""window"":1,""total"":232,""live"":120,""arcade"":101,""live-duplicate"":10}},""credits"":487,""utm"":""false"",""perms"":{""root"":true},""undefined"":null,""value"":{""credits"":520,""usd"":52,""bought"":3},""premium"":true}</p>
</blockquote>
","","856","<ios><swift><encryption><cryptojs><cryptoswift>","0","","0","2018-02-07 06:08:38","","5","","699944","","2018-02-07 06:08:38","2016-06-01 21:52:02",""
"28111839","Create CryptoJS AES Cipher Encryptor to Decrypt in .NET","<p>I'm trying to create Encryption/Decryption that will work between server/client. I have CryptoJS for my client side and ASP.Net (VB.Net) for my server side. The server side is being used in numerous places so cannot change so the CryptoJS needs work around what the .NET is doing. I can't get my CryptoJS to imitate the .NET 100%. </p>

<p>FYI the .NET code can't change, the JS has to match .NET functionality.</p>

<blockquote>
  <p><em>Code removed upon request</em></p>
</blockquote>

<h3>The error I get in .NET when I try and decrypt the client side encryption:</h3>

<blockquote>
  <p>Padding is invalid and cannot be removed.</p>
</blockquote>

<h3>Extra Information</h3>

<p>If I just push through a Hex as the key (remove the <code>.toString(CryptoJS.enc.Latin1)</code>), I don't get enough characters (seems to change to 128bit instead of 256bit).</p>

<p>The actual data returned by MD5_Key in JS <em>seems to</em> match Validate_MD5 in .NET...</p>

<p>Am I trying to achieve the impossible?</p>
","<p>CryptoJS supports only AES which is basically Rijndael but limited to the block size of 128-bit. It supports key sizes of 128, 192 and 256-bit. You .net code uses Rijndael with a block size of 256 which is not supported by CryptoJS. CryptoJS happily takes the big IV and only uses the first 16 bytes.</p>

<p>You will have to find another library that supports this since you can't change the .net code.</p>
","851","<javascript><asp.net><aes><md5><cryptojs>","2","0","1","2017-02-24 18:16:38","28113945","2","","2117156","","2015-03-03 11:42:41","2015-01-23 14:15:40",""
"31124285","Google OAuth2 Service Account HTTP/REST Authentication","<p>I am attempting to make a access token request using the documentation found below:
<a href=""https://developers.google.com/identity/protocols/OAuth2ServiceAccount"" rel=""nofollow"">https://developers.google.com/identity/protocols/OAuth2ServiceAccount</a></p>

<p>I am leveraging the jsrsasign library to generate my JWT</p>

<p>For clarity I am deploying the code to Parse.com cloud code, everything executes fine with exception of the failed response from Google.</p>

<p>jsrsasign [<a href=""http://kjur.github.io/jsrsasign/]"" rel=""nofollow"">http://kjur.github.io/jsrsasign/]</a>
<a href=""https://kjur.github.io/jsrsasign/api/symbols/KJUR.jws.JWS.html#.sign"" rel=""nofollow"">https://kjur.github.io/jsrsasign/api/symbols/KJUR.jws.JWS.html#.sign</a></p>

<pre><code>Parse.Cloud.define(""testBase"", function(request, response) {

  var createJWT = function(){

    var creds = {
      private_key_id: ""532ca15e518a0&lt;foobar&gt;74dd81d48a9cb24"",
      private_key: ""-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcw&lt;foobar&gt;QCzxcu5ae3l7JXT\nZzI2kHA3lYay/2DIcC4KXqQWCMejQacRlFROftfnqRrf9qmEewH/0TMSMlOFt0G6\n9hjznhOHu3rxZcAxuK5bh7UnmoUWYksdtb+6VgCGF9Z5piTASrLxssILAUqY6EjT\nHKp3IQk6aqMqe6NhymCS/o0K9NvGA98znpv28ilD9dd5HXhfTdeGm7PDkZGIXIbR\nG+sQN8+tW46N1PaYnoz8iNGfvGk2Y04WDC2HJ590z4DAk41jbcWtnZnr/UyIJzTq\nTBjCWwAcF0qwSabf/mlWSf2S7DeCZKYNveMSN7F6meI8uYshuVoNqd95u/KGfQ4q\ns+wMdF3tAgMBAAECggEAcQ2MhnelUhisSBv3qfS/fVUdNmf/d02ExqSpz+mJkpNw\n+08qjYqbQGZKLloyVMv+f+ARm/nmKIsMXQTywBHC+nLeZ/yzFxGrJIh9VgCIfYEm\n9/IaNpZrEejfyfS/2+WeDv15pe4T+YDqe0jlsrEl2oTBQ7ApGRBqF0bZb/B4XVd3\ngZ6kya+UL5j+PSgNcaGABUfj7pDXZIRmVnWJxXSYhvvbD+SrXIhBMS3wXZ+vka1J\nkW/bwhzayu9/nI24WN7pALxf6/zB3Ewyoj5n1pnxbkvBMcK+PBiX9yAPvfH5cGQF\nQZx86L11maYpWHxufrbclow16qZHP41O+1eePGbIgQKBgQDmOY04z02RIMX32I7k\nbtokmG8qDnR8iu8dkLSRU4Ib7ZPzIBpjg9neaRib9A2fPVjyuxjvsUbob11BuklZ\nGCMu9SFV8w4LpUQ3clL+kBiGncuSmBfZWbj7uqLuzsNeeu3pihVTlkeWeagTAR36\nhi8K4IVQi5SmPF2dPiw9A8oXkQKBgQDH5j1smCFu9d+F2HIwDFXsW1wlyWhtcgfV\n70uCXdImnU25pJDARLX8vqaZp0KHIPmXLgUV/sU3oAX9NRdgV56bJTo7vwO3DATM\ntK14h7GZCKSYniOqX+3FdweNyn89qlHeAkZdvCZhGX5rOVXtlhpey7Eu8fQnPs1S\nbxd1EXRKnQKBgH+m1Yj0WLvpghskdkZuuIGmC600Cp6rol2wSI5z0SaPGoOp/zfC\neeD6QOzn602qBFHCL9dnYjuq0/iHw/ekjI2S2YMAm38Vibd8qkv/tbmecKu9rSuU\nth7No13qQyV138ioCZ8pKlRi7DBtZCPultLfHsxEOI3b1sRDHuBN45YhAoGAGbKe\niNxRx/rxvjoiC806KoVgJjdrJk63dSgrE9pNzssAF/Jw7Van8pLrxer7oXV6wJWY\n78ftwIXg3zk5BRieeiFiCBY5OwnfgBVmC42eJic3SatiuF9WqMDxhqfWja3ckmbG\ndvxeDrOBTfVz93QJddBHudo+4eCv8n33jQQuZ/0CgYEAsYXmQWOUndqBaZgho3ZV\njrRFmwiwiqJ1hqJdflBXbKlTQOpqea8QoQOQqyeMVQ1X7x3rDcHbhFSbd65GJT5j\n65B/OXrBpIBhb5u0/x6ytJhlM9sPRIL+G/m5QYnBY7dcQo6jlKxTUKHPEV/mwT2m\nt/ZxkAmz/9DKWFKtDc4ZshI\u003d\n-----END PRIVATE KEY-----\n"",
      client_email: ""&lt;foobar&gt;-t18b3hrkab6urireblm8kb4kt45c92a2@developer.gserviceaccount.com"",
      client_id: ""&lt;foobar&gt;-t18b3hrkab6urireblm8kb4kt45c92a2.apps.googleusercontent.com"",
      type: ""service_account""
    };

    var header = {
      alg:""RS256"",
      typ:""JWT""
    };

    var data = {
      iss: creds.client_email,
      scope:""https://www.googleapis.com/auth/analytics.readonly"",
      aud:""https://www.googleapis.com/oauth2/v3/token"",
      exp: KJUR.jws.IntDate.get('now + 1hour'),
      iat: KJUR.jws.IntDate.get('now')
    };

    console.log(""Preparing to generate RS256 JWT"");
    var sJWT = KJUR.jws.JWS.sign(""RS256"", JSON.stringify(header), JSON.stringify(data), creds.private_key);
    console.log(""RS256 JWT generation complete:"");

    console.log(sJWT)
    return sJWT;
  }

  console.log(""############################## "")


  try{
      console.log(""Preparing assertion..."")
      var jwt = createJWT()
      console.log(""Assertion: ""+jwt);

      var options = {
          method: 'POST',
          headers: {
            'Content-Type':'application/x-www-form-urlencoded'
          },
          url: ""https://www.googleapis.com/oauth2/v3/token"",
          params: {
            grant_type: ""urn:ietf:params:oauth:grant-type:jwt-bearer"",

            assertion: jwt
          }
      };

      console.log(""------------------------"");
      console.log(options);
      console.log(""------------------------"");

      Parse.Cloud.httpRequest(options).done(function(rsp){
          var r = (_.isString(rsp.text)) ? JSON.parse(rsp.text) : rsp.text;
          console.log(""Reponse from Google:"");
          console.log(rsp)
          // console.log({ body: req.body, params: req.params, query: req.query, o: options, r: r });
          // res.send(r);
          response.success(r);

      }).fail(function(err){
          // console.error(err);
          console.error(""Failed response from Google:"")
          console.error(err.text)
          response.error(err);

      });
    }catch(err){
        console.error(err);
        response.error(err);
    }
});
</code></pre>

<p>The console output:</p>

<pre><code>I2015-06-29T19:42:17.315Z]############################## 
I2015-06-29T19:42:17.316Z]Preparing assertion...
I2015-06-29T19:42:17.317Z]Preparing to generate RS256 JWT
I2015-06-29T19:42:17.401Z]RS256 JWT generation complete:
I2015-06-29T19:42:17.402Z]eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2MDQ4Mjk2NTQ1MzktdDE4YjNocmthYjZ1cmlyZWJsbThrYjRrdDQ1YzkyYTJAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvYW5hbHl0aWNzLnJlYWRvbmx5IiwiYXVkIjoiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL3Rva2VuIiwiZXhwIjoxNDM1NjEwNTM3LCJpYXQiOjE0MzU2MDY5Mzd9.nGbApndzwwtadeL2Jr2zU__JZrBZ6tYGJ17sTDksiSsFRXop_6CFAsV7fkXC6Xd-Nf3KfYzNuqGzLciQTzc9AhGNFTk_aUXU-ndMbYiVh3EpTkBI0olkS5rkgnmm3Q_yfaOswkyvMwE12RvgTTjymVzHGTZ8xC_x22Ep1n07Ap3TQn3WpeFeJlHciiwcxMTG7TsxAvHEgaqLzZ79feFmZanj6pqEH1kfZeJUQK1n3bwKtU92qpPn7b4dFtJs8I7El62HLExU1B2l7qdSyp4CRxmUPViUfWykElDZeqDzPoX38QEMDmmTgCYUXna7wJB6O0qC3aJpxkCAmzPCDkXkZQ
I2015-06-29T19:42:17.403Z]Assertion: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2MDQ4Mjk2NTQ1MzktdDE4YjNocmthYjZ1cmlyZWJsbThrYjRrdDQ1YzkyYTJAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvYW5hbHl0aWNzLnJlYWRvbmx5IiwiYXVkIjoiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL3Rva2VuIiwiZXhwIjoxNDM1NjEwNTM3LCJpYXQiOjE0MzU2MDY5Mzd9.nGbApndzwwtadeL2Jr2zU__JZrBZ6tYGJ17sTDksiSsFRXop_6CFAsV7fkXC6Xd-Nf3KfYzNuqGzLciQTzc9AhGNFTk_aUXU-ndMbYiVh3EpTkBI0olkS5rkgnmm3Q_yfaOswkyvMwE12RvgTTjymVzHGTZ8xC_x22Ep1n07Ap3TQn3WpeFeJlHciiwcxMTG7TsxAvHEgaqLzZ79feFmZanj6pqEH1kfZeJUQK1n3bwKtU92qpPn7b4dFtJs8I7El62HLExU1B2l7qdSyp4CRxmUPViUfWykElDZeqDzPoX38QEMDmmTgCYUXna7wJB6O0qC3aJpxkCAmzPCDkXkZQ
I2015-06-29T19:42:17.404Z]------------------------
I2015-06-29T19:42:17.405Z]{""method"":""POST"",""headers"":{""Content-Type"":""application/x-www-form-urlencoded""},""url"":""https://www.googleapis.com/oauth2/v3/token"",""params"":{""grant_type"":""urn:ietf:params:oauth:grant-type:jwt-bearer"",""assertion"":""eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI2MDQ4Mjk2NTQ1MzktdDE4YjNocmthYjZ1cmlyZWJsbThrYjRrdDQ1YzkyYTJAZGV2ZWxvcGVyLmdzZXJ2aWNlYWNjb3VudC5jb20iLCJzY29wZSI6Imh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvYW5hbHl0aWNzLnJlYWRvbmx5IiwiYXVkIjoiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vb2F1dGgyL3YzL3Rva2VuIiwiZXhwIjoxNDM1NjEwNTM3LCJpYXQiOjE0MzU2MDY5Mzd9.nGbApndzwwtadeL2Jr2zU__JZrBZ6tYGJ17sTDksiSsFRXop_6CFAsV7fkXC6Xd-Nf3KfYzNuqGzLciQTzc9AhGNFTk_aUXU-ndMbYiVh3EpTkBI0olkS5rkgnmm3Q_yfaOswkyvMwE12RvgTTjymVzHGTZ8xC_x22Ep1n07Ap3TQn3WpeFeJlHciiwcxMTG7TsxAvHEgaqLzZ79feFmZanj6pqEH1kfZeJUQK1n3bwKtU92qpPn7b4dFtJs8I7El62HLExU1B2l7qdSyp4CRxmUPViUfWykElDZeqDzPoX38QEMDmmTgCYUXna7wJB6O0qC3aJpxkCAmzPCDkXkZQ""}}
I2015-06-29T19:42:17.406Z]------------------------
I2015-06-29T19:42:17.504Z]Failed response from Google:
I2015-06-29T19:42:17.506Z]{
 ""error"": ""invalid_grant"",
 ""error_description"": ""Bad Request""
}
</code></pre>

<p><strong>Final Solution:</strong>
Import the google service account credentials json file (renamed to google-service-account-credentials.js), generate jwt, apply jwt as body in the Parse.Request instead of params.</p>

<pre><code>var fs = require('fs');
var moment = require('moment');
var _ = require('underscore');
var KJUR = require(""cloud/lib/jsrsasign/npm/lib/jsrsasign.js"");
var googleServiceAccountCredentials = JSON.parse(fs.readFileSync('cloud/google-service-account-credentials.js'));


var createJWT = function(args, credentials){

  var header = {
    alg:""RS256"",
    typ:""JWT""
  };

  var now = moment().unix();

  var defaults = {
    iss: credentials.client_email,
    scope:""https://www.googleapis.com/auth/analytics.readonly"",
    aud:""https://www.googleapis.com/oauth2/v3/token"",
    exp: now + (15*60),
    iat: now
  };

  var data = {};

  _.extend(data, defaults, args);

  var sJWT = KJUR.jws.JWS.sign(""RS256"", JSON.stringify(header), JSON.stringify(data), credentials.private_key );
  return sJWT;
};

Parse.Cloud.define(""testBase"", function(request, response) {


  try{
      var now = moment().unix();

      var options = {
          method: 'POST',
          headers: {
            'Content-Type':'application/x-www-form-urlencoded'
          },
          url: ""https://www.googleapis.com/oauth2/v3/token"",
          body: {
            grant_type: encodeURI(""urn:ietf:params:oauth:grant-type:jwt-bearer""),
            assertion: createJWT({
              exp: now + (60*60),
              iat: now
            }, googleServiceAccountCredentials)
          }
      };

      Parse.Cloud.httpRequest(options).done(function(rsp){
          var r = (_.isString(rsp.text)) ? JSON.parse(rsp.text) : rsp.text;
          console.log(""Reponse from Google:"");
          console.log(r.access_token);
          console.log(r.expires_in);
          console.log(r.token_type);
          response.success(r);

      }).fail(function(err){
          console.error(""Failed response from Google:"")
          console.error(err.text)
          response.error(err);

      });
    }catch(err){
        console.error(err);
        response.error(err);
    }
});
</code></pre>
","<p>Use body instead of params in your request options</p>
","850","<node.js><parse-platform><google-oauth><cryptojs><service-accounts>","3","2","1","2016-02-11 14:48:22","31152987","7","","1523882","","2015-07-01 03:15:18","2015-06-29 19:46:24",""
"19436882","Different output encryption both CryptoJS and Java Code","<p>I need to encrypt certainly string from client-side (JavaScript) and decrypt from server-side (Java), so I found CryptoJS and I write the code with the same params/configuration of mi Java Code but the output is always different, do you have any idea or what happen?</p>

<p>I'm using <strong>CBC with NoPadding</strong></p>

<p><strong>CryptoJS</strong></p>

<p><a href=""http://jsfiddle.net/Soldier/gCHAG/"" rel=""nofollow"">http://jsfiddle.net/Soldier/gCHAG/</a></p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;
&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/pad-nopadding-min.js""&gt;&lt;/script&gt;
&lt;script&gt;

    function padString(source) {
        var paddingChar = ' ';
        var size = 16;
        var x = source.length % size;
        var padLength = size - x;

        for (var i = 0; i &lt; padLength; i++) source += paddingChar;

        return source;
    }

    var key = CryptoJS.enc.Hex.parse('0123456789abcdef');
    var iv  = CryptoJS.enc.Hex.parse('fedcba9876543210');
    var message = ""soldier"";
    var padMsg = padString(message);

    var encrypted = CryptoJS.AES.encrypt(padMsg, key, { iv: iv, padding: CryptoJS.pad.NoPadding, mode: CryptoJS.mode.CBC});

    console.log(""Encrypted: ""+encrypted);
    console.log(""Encrypted text: ""+encrypted.ciphertext);

&lt;/script&gt;
</code></pre>

<p><strong>Java Code</strong></p>

<pre><code>import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.*;

public class AesCipher {

    private static final String algorithm = ""AES/CBC/NoPadding"";

    private static final byte[] keyValue = new byte[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    private static final byte[] ivValue = new byte[] { 'f', 'e', 'd', 'c', 'b', 'a', '9', '8', '7', '6', '5', '4', '3', '2', '1', '0' };

    private static final IvParameterSpec ivspec = new IvParameterSpec(ivValue);
    private static final SecretKeySpec keyspec = new SecretKeySpec(keyValue, ""AES"");

    final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();

    public static String encrypt(String Data) throws Exception {
        Cipher c = Cipher.getInstance(algorithm);
        c.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        byte[] encVal = c.doFinal(Data.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encVal);
        return encryptedValue;
    }

    public static String decrypt(String encryptedData) throws Exception {
        Cipher c = Cipher.getInstance(algorithm);
        c.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }

    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for ( int j = 0; j &lt; bytes.length; j++ ) {
            v = bytes[j] &amp; 0xFF;
            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
        }
        return new String(hexChars);
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++)
        {
            source += paddingChar;
        }
        return source;
      }

    public static void main(String[] args) throws Exception {

        String password = ""soldier"";
        String passwordEnc = AesCipher.encrypt(padString(password));
        String passwordDec = AesCipher.decrypt(passwordEnc);

        System.out.println(""Plain Text : "" + password);
        System.out.println(""Encrypted Text : "" + passwordEnc);
        System.out.println(""Decrypted Text : "" + passwordDec);
    }

}
</code></pre>

<p>Original string: </p>

<pre><code>soldier
</code></pre>

<p>Output from CryptoJS: </p>

<pre><code>Encrypted: VNzZNKJTqfRbM7zO/M4cDQ==
Encrypted Hex: 54dcd934a253a9f45b33bccefcce1c0d
</code></pre>

<p>Output from Java Code:</p>

<pre><code>Encrypted: j6dSmg2lfjY2RpN91GNgNw==
Encrypted Hex: 6a3664536d67326c666a593252704e3931474e674e773d3d
</code></pre>

<p>The base64 string encrypted has same length but not the hex.
If I put the output result of CryptoJS in Java Code, the decryption is incorrect.</p>

<p>Regards,</p>
","<p>One problem here is that you're using 64 bit keys and iv's. </p>

<p>CryptoJS supports AES-128, AES-192, and AES-256, and AFAIK Java supports AES-128, so you should probably be specifying 128 bit keys and IVs. That might be the whole problem - I'm sure using the wrong key size is undefined behavior.</p>

<p>As for the difference in output lengths, 22 base64 characters is 132 bits of information, so it's a 128 bit answer (There isn't a unique 128 bit length, 21 characters would have been too few).  CryptoJS is outputting 32 hex characters, which is 128 bits of information. This seems correct.</p>

<p>The Java code is outputting 48 hex characters which is 192 bits of information. So it's the java code that's wrong. I'm not sure why it's outputting more, though.</p>
","843","<java><aes><cryptojs><cbc-mode>","0","0","1","2013-10-21 19:51:15","","1","4","1347435","","2013-10-17 21:08:30","2013-10-17 20:43:24",""
"48673427","CryptoJS with hex key not decrypting properly","<p>I have a dataset that was encrypted that I'm trying to decrypt with CryptoJS.  I've tried various combination of things but for some reason the result is not what I'm expecting.  I have provided the key below and also the text I want to decrypt.  What I'm expecting at msg1 is 32 characters long but I keep getting 48.  Its as of its padding it with an extra 16 characters. </p>

<p>Thanks in advance for the help.</p>

<pre><code>key = 'd13484fc2f28fd0426ffd201bbd2fe6ac213542d28a7ca421f17adc0cf234381';
text = '8bf3955488af91feb7bd87220910cee0';


decrypt(text: string): void{

       let msg1 = CryptoJS.AES.decrypt(text, CryptoJS.enc.Hex.parse(key), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
       msg1 = CryptoJS.enc.Hex.stringify(msg1 );

}
</code></pre>
","<p>Given:<br>
<code>key = 'd13484fc2f28fd0426ffd201bbd2fe6ac213542d28a7ca421f17adc0cf234381';</code><br>
<code>text = '8bf3955488af91feb7bd87220910cee0';</code>. </p>

<p>Decrypting the text with the key actually produces: <code>C5640000B550000079320000217C0000</code>.</p>

<p>See <a href=""http://extranet.cryptomathic.com/aescalc?key=d13484fc2f28fd0426ffd201bbd2fe6ac213542d28a7ca421f17adc0cf234381&amp;iv=00000000000000000000000000000000&amp;input=8bf3955488af91feb7bd87220910cee0&amp;mode=ecb&amp;action=Decrypt&amp;output="" rel=""nofollow noreferrer"">AES Calc</a></p>

<p>Verify the encoding that <code>CryptoJS.AES.decrypt</code> requires for it's inputs and output encoding.</p>
","833","<node.js><encryption><cryptojs>","0","0","2","2018-02-08 00:56:27","48675011","1","","9329798","","2018-02-08 00:56:27","2018-02-07 21:19:52",""
"48673427","CryptoJS with hex key not decrypting properly","<p>I have a dataset that was encrypted that I'm trying to decrypt with CryptoJS.  I've tried various combination of things but for some reason the result is not what I'm expecting.  I have provided the key below and also the text I want to decrypt.  What I'm expecting at msg1 is 32 characters long but I keep getting 48.  Its as of its padding it with an extra 16 characters. </p>

<p>Thanks in advance for the help.</p>

<pre><code>key = 'd13484fc2f28fd0426ffd201bbd2fe6ac213542d28a7ca421f17adc0cf234381';
text = '8bf3955488af91feb7bd87220910cee0';


decrypt(text: string): void{

       let msg1 = CryptoJS.AES.decrypt(text, CryptoJS.enc.Hex.parse(key), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
       msg1 = CryptoJS.enc.Hex.stringify(msg1 );

}
</code></pre>
","<p>Solving it is pretty simple, but reading the docs and the code, I'm not quite clear why.</p>

<p>This is clearly wrong:</p>

<pre><code>let msg1 = CryptoJS.AES.decrypt(text, CryptoJS.enc.Hex.parse(key), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
</code></pre>

<p>Given your description, you are expecting the byte sequence represented by the hex digits ""8bf3955488af91feb7bd87220910cee0"" to be the body. But that's not what your passing. You're passing the <em>characters</em>. So when it decrypts it, the first byte is the ASCII value of <code>8</code> (0x38), not 0x8b. Given that, you should be parsing the hex like this:</p>

<pre><code>let msg1 = CryptoJS.AES.decrypt(CryptoJS.enc.Hex.parse(text), ...
</code></pre>

<p>But, for reasons I'm having trouble understanding, that doesn't work. <code>decrypt</code> expects Base64 (or at least it will accept Base64). I can't find any documentation that says this, and the code creates the <code>decrypt</code> function magically in a way that I don't fully understand, and this is why I really hate doing crypto work in JavaScript.</p>

<p>That's out of my system now, so let's get to the answer:</p>

<pre><code>cipher = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Hex.parse(text))

let msg1 = CryptoJS.AES.decrypt(cipher, CryptoJS.enc.Hex.parse(key), { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding});
</code></pre>

<p>And that should give you the result you're expecting.</p>
","833","<node.js><encryption><cryptojs>","0","1","2","2018-02-08 00:56:27","48675011","1","","9329798","","2018-02-08 00:56:27","2018-02-07 21:19:52",""
"33629702","How can I encrypt/decrypt a ""file"" (instead of text) using cryptojs?","<p>How can I encrypt/decrypt a ""file"" (instead of text) using cryptojs?<br>
I want to do this inside a cordova app and using AES algorithm.<br>
(Using crypto.js is not a requirement and any other appropriate library would be helpful)<br>
Thanks in advance</p>
","","822","<javascript><cordova><encryption><file-io><cryptojs>","3","","0","2019-01-30 17:38:34","","7","1","1816580","","2015-11-10 12:26:12","2015-11-10 12:11:55",""
"38007738","Why doesn't JQuery work with CryptoJS?","<p>I have an encoding program which allows the user to enter some text and a password to send messages securely.</p>

<p>However, when I try to run the following code, JQuery does not work properly:</p>

<pre><code>text = CryptoJS.AES.encrypt(text, pass);
$(""#encodedText"").html(text);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
  &lt;link rel=""icon"" sizes=""192x192"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""apple-touch-startup-image"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""shortcut icon"" href="""" type=""image/icon""&gt;
  &lt;link rel=""icon"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico"" type=""image/icon""&gt;
  &lt;meta name=""viewport"" content=""width = device-width""&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;meta name=""apple-mobile-web-app-capable"" content=""yes""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js""&gt;&lt;/script&gt;
  &lt;link rel=""stylesheet"" href=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js""&gt;&lt;/script&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;title&gt;ENCRYPT&lt;/title&gt;
  &lt;meta charset=""UTF-8""&gt;
&lt;/head&gt;

&lt;style&gt;
  #first {
    font-family: ""courier"";
    text-align: center;
    color: #00FF04;
  }
  #second {
    color: white;
  }
  #myDIV {
    border: 1px solid green;
    margin-bottom: 10px;
  }
  button {
    border-radius: 50%;
    background-color: #00FF04;
    border-color: #00FF04;
    color: white;
    font-size: 40px;
    transition-duration: 0.4s;
    width: 25%;
    height: 80px;
  }
  button:hover {
    box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
    background-color: red;
    border-color: red;
  }
  .searchTxt {
    color: #00FF04;
    font-family: ""courier"";
    border: solid #00FF04;
    border-radius: 5px;
    background-color: black;
  }
  .heading {
    font-size: 80px
  }
&lt;/style&gt;

&lt;body bgcolor=""black"" id=""first""&gt;

  &lt;p class=""heading""&gt;ENCODE TEXT&lt;/p&gt;
  &lt;p&gt;
    Your text:
  &lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToEncode""&gt;
  &lt;br&gt;
  &lt;p&gt;Your password:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToRedact""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""encodeButton""&gt;Encode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""encodedText""&gt;&lt;/p&gt;


  &lt;p class=""heading""&gt;DECODE TEXT&lt;/p&gt;
  &lt;p&gt;Text:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToDecode""&gt;
  &lt;br&gt;
  &lt;p&gt;Key:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""keyForDecode""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""decodeButton""&gt;Decode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""decodedText""&gt;&lt;/p&gt;


  &lt;script&gt;
    var text = """";
    var word = """";
    var redacted = """";
    var encodedInfo = [];
    var key = """";
    var pass = """";

    $(""#encodeButton"").on(""click"", function() {
      $(""#key"").html("""");
      $(""#encodedText"").html("""");
      encodedInfo = [];
      redacted = """";
      text = $(""#textToEncode"").val();
      pass = $(""#textToRedact"").val();
      text = CryptoJS.AES.encrypt(text, pass);
      alert(""Your encrypted message is as such: "" + text);
      $(""#encodedText"").html(text);
    });


    $(""#decodeButton"").on(""click"", function() {
      $(""#decodedText"").html("""");
      redacted = """";
      word = ""REDACTED"";
      text = $(""#textToDecode"").val();
      key = $(""#keyForDecode"").val();
      decrypted = CryptoJS.AES.decrypt(text, key);
      decrypted = decrypted.toString(CryptoJS.enc.Utf8);
      if (decrypted === """") {
        alert(""FAIL!!! Wrong password."");
      } else {
        $(""#decodedText"").html(decrypted);
        alert(""The message is: "" + decrypted);
      }

    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>As you can see in the snippet it correctly alerts you the encoded message, but it does not change the value of <code>#encodedText</code>. Why might this be so?</p>

<p>LIVE DEMO: <a href=""http://redacted.ga/advance.html"" rel=""nofollow"">redacted.ga/advance.html</a></p>
","<p>After checking I found that <code>CryptoJS.AES.encrypt()</code> function returns the <code>object</code> and not the <code>string</code>. Hence <code>$.html()</code> doesn't work. So to make it work you have to call it as <code>$(""#encodedText"").html(text.toString());</code> OR you can call like <code>$(""#encodedText"").text(text);</code>. The later one implicitly converts the <code>object</code> to <code>string</code> before assigning it to DOM. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
  &lt;link rel=""icon"" sizes=""192x192"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""apple-touch-startup-image"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""shortcut icon"" href="""" type=""image/icon""&gt;
  &lt;link rel=""icon"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico"" type=""image/icon""&gt;
  &lt;meta name=""viewport"" content=""width = device-width""&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;meta name=""apple-mobile-web-app-capable"" content=""yes""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js""&gt;&lt;/script&gt;
  &lt;link rel=""stylesheet"" href=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js""&gt;&lt;/script&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;title&gt;ENCRYPT&lt;/title&gt;
  &lt;meta charset=""UTF-8""&gt;
&lt;/head&gt;

&lt;style&gt;
  #first {
    font-family: ""courier"";
    text-align: center;
    color: #00FF04;
  }
  #second {
    color: white;
  }
  #myDIV {
    border: 1px solid green;
    margin-bottom: 10px;
  }
  button {
    border-radius: 50%;
    background-color: #00FF04;
    border-color: #00FF04;
    color: white;
    font-size: 40px;
    transition-duration: 0.4s;
    width: 25%;
    height: 80px;
  }
  button:hover {
    box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
    background-color: red;
    border-color: red;
  }
  .searchTxt {
    color: #00FF04;
    font-family: ""courier"";
    border: solid #00FF04;
    border-radius: 5px;
    background-color: black;
  }
  .heading {
    font-size: 80px
  }
&lt;/style&gt;

&lt;body bgcolor=""black"" id=""first""&gt;

  &lt;p class=""heading""&gt;ENCODE TEXT&lt;/p&gt;
  &lt;p&gt;
    Your text:
  &lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToEncode""&gt;
  &lt;br&gt;
  &lt;p&gt;Your password:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToRedact""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""encodeButton""&gt;Encode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""encodedText""&gt;&lt;/p&gt;


  &lt;p class=""heading""&gt;DECODE TEXT&lt;/p&gt;
  &lt;p&gt;Text:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToDecode""&gt;
  &lt;br&gt;
  &lt;p&gt;Key:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""keyForDecode""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""decodeButton""&gt;Decode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""decodedText""&gt;&lt;/p&gt;


  &lt;script&gt;
    var text = """";
    var word = """";
    var redacted = """";
    var encodedInfo = [];
    var key = """";
    var pass = """";

    $(""#encodeButton"").on(""click"", function() {
      $(""#key"").html("""");
      $(""#encodedText"").text("""");
      encodedInfo = [];
      redacted = """";
      text = $(""#textToEncode"").val();
      pass = $(""#textToRedact"").val();
      text = CryptoJS.AES.encrypt(text, pass);
	  alert(""Your encrypted message is as such: "" + text);
      $(""#encodedText"").html(text.toString());
    });


    $(""#decodeButton"").on(""click"", function() {
      $(""#decodedText"").text("""");
      redacted = """";
      word = ""REDACTED"";
      text = $(""#textToDecode"").val();
      key = $(""#keyForDecode"").val();
      decrypted = CryptoJS.AES.decrypt(text, key);
      decrypted = decrypted.toString(CryptoJS.enc.Utf8);
      if (decrypted === """") {
        alert(""FAIL!!! Wrong password."");
      } else {
        $(""#decodedText"").text(decrypted);
        alert(""The message is: "" + decrypted);
      }

    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","817","<jquery><cryptojs>","1","0","2","2016-06-24 09:25:13","38008181","0","","","","","2016-06-24 07:18:50",""
"38007738","Why doesn't JQuery work with CryptoJS?","<p>I have an encoding program which allows the user to enter some text and a password to send messages securely.</p>

<p>However, when I try to run the following code, JQuery does not work properly:</p>

<pre><code>text = CryptoJS.AES.encrypt(text, pass);
$(""#encodedText"").html(text);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
  &lt;link rel=""icon"" sizes=""192x192"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""apple-touch-startup-image"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico""&gt;
  &lt;link rel=""shortcut icon"" href="""" type=""image/icon""&gt;
  &lt;link rel=""icon"" href=""http://www.tdat.byethost10.com/web_images/favicon.ico"" type=""image/icon""&gt;
  &lt;meta name=""viewport"" content=""width = device-width""&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;meta name=""apple-mobile-web-app-capable"" content=""yes""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js""&gt;&lt;/script&gt;
  &lt;link rel=""stylesheet"" href=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/themes/smoothness/jquery-ui.css""&gt;
  &lt;script src=""https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.4/jquery-ui.min.js""&gt;&lt;/script&gt;
  &lt;meta name=""mobile-web-app-capable"" content=""yes""&gt;
  &lt;title&gt;ENCRYPT&lt;/title&gt;
  &lt;meta charset=""UTF-8""&gt;
&lt;/head&gt;

&lt;style&gt;
  #first {
    font-family: ""courier"";
    text-align: center;
    color: #00FF04;
  }
  #second {
    color: white;
  }
  #myDIV {
    border: 1px solid green;
    margin-bottom: 10px;
  }
  button {
    border-radius: 50%;
    background-color: #00FF04;
    border-color: #00FF04;
    color: white;
    font-size: 40px;
    transition-duration: 0.4s;
    width: 25%;
    height: 80px;
  }
  button:hover {
    box-shadow: 0 12px 16px 0 rgba(0, 0, 0, 0.24), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
    background-color: red;
    border-color: red;
  }
  .searchTxt {
    color: #00FF04;
    font-family: ""courier"";
    border: solid #00FF04;
    border-radius: 5px;
    background-color: black;
  }
  .heading {
    font-size: 80px
  }
&lt;/style&gt;

&lt;body bgcolor=""black"" id=""first""&gt;

  &lt;p class=""heading""&gt;ENCODE TEXT&lt;/p&gt;
  &lt;p&gt;
    Your text:
  &lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToEncode""&gt;
  &lt;br&gt;
  &lt;p&gt;Your password:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToRedact""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""encodeButton""&gt;Encode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""encodedText""&gt;&lt;/p&gt;


  &lt;p class=""heading""&gt;DECODE TEXT&lt;/p&gt;
  &lt;p&gt;Text:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""textToDecode""&gt;
  &lt;br&gt;
  &lt;p&gt;Key:&lt;/p&gt;
  &lt;br&gt;
  &lt;input class=""searchTxt"" size=""50"" id=""keyForDecode""&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;button id=""decodeButton""&gt;Decode!&lt;/button&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;br&gt;
  &lt;p id=""decodedText""&gt;&lt;/p&gt;


  &lt;script&gt;
    var text = """";
    var word = """";
    var redacted = """";
    var encodedInfo = [];
    var key = """";
    var pass = """";

    $(""#encodeButton"").on(""click"", function() {
      $(""#key"").html("""");
      $(""#encodedText"").html("""");
      encodedInfo = [];
      redacted = """";
      text = $(""#textToEncode"").val();
      pass = $(""#textToRedact"").val();
      text = CryptoJS.AES.encrypt(text, pass);
      alert(""Your encrypted message is as such: "" + text);
      $(""#encodedText"").html(text);
    });


    $(""#decodeButton"").on(""click"", function() {
      $(""#decodedText"").html("""");
      redacted = """";
      word = ""REDACTED"";
      text = $(""#textToDecode"").val();
      key = $(""#keyForDecode"").val();
      decrypted = CryptoJS.AES.decrypt(text, key);
      decrypted = decrypted.toString(CryptoJS.enc.Utf8);
      if (decrypted === """") {
        alert(""FAIL!!! Wrong password."");
      } else {
        $(""#decodedText"").html(decrypted);
        alert(""The message is: "" + decrypted);
      }

    });
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>As you can see in the snippet it correctly alerts you the encoded message, but it does not change the value of <code>#encodedText</code>. Why might this be so?</p>

<p>LIVE DEMO: <a href=""http://redacted.ga/advance.html"" rel=""nofollow"">redacted.ga/advance.html</a></p>
","<p>Because <code>CryptoJS.AES.encrypt</code> does not return a string with HTML but an object, as you can see if you use the browser console:</p>

<pre><code>console.log(text);
</code></pre>

<blockquote>
  <p>Object { $super={...},  ciphertext={...},  key={...},  ms...}</p>
</blockquote>

<p>The object has a properly defined toString() method:</p>

<pre><code>console.log(text.toString());
</code></pre>

<blockquote>
  <p>U2FsdGVkX1+r/YSe+2AafmlH+fLkrfUoioilEJ3qay0=</p>
</blockquote>

<p>... so it's very easy to get a plain text representation of the hash and you don't need to deal with raw binary output. But you still need to manipulate it as what it is, plain text:</p>

<pre><code>$(""#encodedText"").text(text);
</code></pre>
","817","<jquery><cryptojs>","1","0","2","2016-06-24 09:25:13","38008181","0","","","","","2016-06-24 07:18:50",""
"27598524","How to implement CFB8 mode with Triple DES for decryption using CryptoJS","<p>I have to decrypt the data which encrypted in java server.
In java server encrypted text using triple des(mode:CFB8, padding:NoPadding)
For decrypt, I tried encrypting such as java server
Below is posted the java source code.  </p>

<pre><code>private final static String keyString = ""123456789012345678901234"";
private final static String ivString = ""abcdefgh"";


public static String encrypt(String data) throws Exception {


    KeySpec keySpec = new DESedeKeySpec(keyString.getBytes());
    SecretKey key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec);
    IvParameterSpec iv = new IvParameterSpec(ivString.getBytes());
    Cipher ecipher = Cipher.getInstance(""DESede/CFB8/NoPadding"");
    ecipher.init(Cipher.ENCRYPT_MODE, key, iv);

    byte[] valeur = data.getBytes(""UTF-8"");
    byte[] enc = ecipher.doFinal(valeur);

    return new String(Base64.encode(enc, Base64.DEFAULT), ""UTF-8"");
}
</code></pre>

<p>And below code is my code.</p>

<pre><code>var key=""123456789012345678901234"";
var iv = ""abcdefgh"";   
var iv1 = CryptoJS.enc.Utf8.parse(iv);   
var key1 = CryptoJS.enc.Utf8.parse(key);   
var encrypted = CryptoJS.TripleDES.encrypt(""asdfg"", key1, { 
    iv:iv1,
    mode:CryptoJS.mode.CFB,
    padding:CryptoJS.pad.NoPadding
});
</code></pre>

<p>But I can't get the same result of both.</p>

<p>When I changed ""CFB8"" to ""CFB"" in the Java code, I get the same result.</p>

<p>How can implement the CFB8 in CryptoJS?</p>
","<p>CFB is mode of operation with a shift register. The encryption and decryption happens in segments which have the same size as the shift register and are smaller than the block size.</p>

<p>The problem is that CryptoJS' CFB implementation only supports segment sizes exactly the same as the block size of the used block cipher. This means that when you use AES it will be a segment size of 128-bit.</p>

<p>I've implemented a variable segment size version of CFB which supports all segment sizes that are a power of 2 including 1-bit up to the block size:</p>

<pre class=""lang-js prettyprint-override""><code>/**
 * Cipher Feedback block mode with segment size parameter according to
 * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf. 
 * The segment size can be anything from 1 bit up to the block size of the 
 * underlying block cipher.
 * 
 * Current limitation: only segment sizes that divide the block size evenly 
 * are supported.
 */
CryptoJS.mode.CFBb = (function () {
    var C = CryptoJS;
        CFBb = C.lib.BlockCipherMode.extend(),
        WordArray = C.lib.WordArray;

    /**
     * Shifts the array by n bits to the left. Zero bits are added as the 
     * least significant bits. This operation modifies the current array.
     * 
     * @param {WordArray} wordArray WordArray to work on
     * @param {int} n Bits to shift by
     * 
     * @returns the WordArray that was passed in
     */
    var bitshift = function(wordArray, n){
        var carry = 0,
            words = wordArray.words,
            wres,
            skipped = 0,
            carryMask;
        if (n &gt; 0) {
            while(n &gt; 31) {
                // delete first element:
                words.splice(0, 1);

                // add `0` word to the back
                words.push(0);

                n -= 32;
                skipped++;
            }
            if (n == 0) {
                // 1. nothing to shift if the shift amount is on a word boundary
                // 2. This has to be done, because the following algorithm computes 
                // wrong values only for n==0
                return carry;
            }
            for(var i = words.length - skipped - 1; i &gt;= 0; i--) {
                wres = words[i];
                words[i] &lt;&lt;= n;
                words[i] |= carry;
                carry = wres &gt;&gt;&gt; (32 - n);
            }
        } else if (n &lt; 0) {
            while(n &lt; -31) {
                // insert `0` word to the front:
                words.splice(0, 0, 0);

                // remove last element:
                words.length--;

                n += 32;
                skipped++;
            }
            if (n == 0) {
                // nothing to shift if the shift amount is on a word boundary
                return carry;
            }
            n = -n;
            carryMask = (1 &lt;&lt; n) - 1;
            for(var i = skipped; i &lt; words.length; i++) {
                wres = words[i] &amp; carryMask;
                words[i] &gt;&gt;&gt;= n;
                words[i] |= carry;
                carry = wres &lt;&lt; (32 - n);
            }
        }
        return carry;
    };

    /**
     * Negates all bits in the WordArray. This manipulates the given array.
     * 
     * @param {WordArray} wordArray WordArray to work on
     * 
     * @returns the WordArray that was passed in
     */
    var neg = function(wordArray){
        var words = wordArray.words;
        for(var i = 0; i &lt; words.length; i++) {
            words[i] = ~words[i];
        }
        return wordArray;
    };

    CFBb.Encryptor = CFBb.extend({
        processBlock: function(words, offset){
            processBlock.call(this, words, offset, true);
        }
    });

    CFBb.Decryptor = CFBb.extend({
        processBlock: function(words, offset){
            processBlock.call(this, words, offset, false);
        }
    });

    function processBlock(words, offset, encryptor) {
        // Shortcuts
        var self = this;
        var cipher = self._cipher;
        var blockSize = cipher.blockSize * 32; // in bits
        var prev = self._prevBlock;
        var segmentSize = cipher.cfg.segmentSize; // in bits
        var i, j;
        var currentPosition;

        // Create a bit mask that has a comtinuous slice of bits set that is as big as the segment
        var fullSegmentMask = [];
        for(i = 31; i &lt; segmentSize; i += 32) {
            fullSegmentMask.push(0xffffffff);
        }
        // `s` most signiicant bits are set:
        fullSegmentMask.push(((1 &lt;&lt; segmentSize) - 1) &lt;&lt; (32 - segmentSize));
        for(i = fullSegmentMask.length; i &lt; words.length; i++) {
            fullSegmentMask.push(0);
        }

        fullSegmentMask = WordArray.create(fullSegmentMask);

        // some helper variables
        var slidingSegmentMask = fullSegmentMask.clone(),
            slidingSegmentMaskShifted = slidingSegmentMask.clone(),
            slidingNegativeSegmentMask,
            prevCT;

        // shift the mask according to the current offset
        bitshift(slidingSegmentMaskShifted, -offset * 32);

        for(i = 0; i &lt; blockSize/segmentSize; i++) {
            if (!prev) {
                prev = self._iv.slice(0); // clone

                // Remove IV for subsequent blocks
                self._iv = undefined;
            } else {
                // Prepare the iteration by concatenating the unencrypted part of the previous block and the previous ciphertext

                prev = WordArray.create(prev);
                bitshift(prev, segmentSize);
                prev = prev.words;
                previousCiphertextSegment = self._ct;

                // fill previous ciphertext up to the block size
                while(previousCiphertextSegment.length &lt; blockSize / 32) {
                    previousCiphertextSegment.push(0);
                }
                previousCiphertextSegment = WordArray.create(previousCiphertextSegment);

                // move to the back
                bitshift(previousCiphertextSegment, -blockSize + segmentSize);

                // put together
                for (var j = 0; j &lt; prev.length; j++) {
                    prev[j] |= previousCiphertextSegment.words[j];
                }
            }

            currentPosition = offset * 32 + i * segmentSize;

            // move segment in question to the front of the array
            var plaintextSlice = WordArray.create(words.slice(0));
            bitshift(plaintextSlice, currentPosition);

            if (!encryptor) {
                self._ct = plaintextSlice.words.slice(0, Math.ceil(segmentSize / 32));
            }

            var segKey = prev.slice(0); // clone
            cipher.encryptBlock(segKey, 0);

            // Encrypt segment
            for (j = 0; j &lt; Math.ceil(segmentSize / 32); j++) {
                plaintextSlice.words[j] ^= segKey[j];
            }

            // Filter only the current segment
            for (j = 0; j &lt; plaintextSlice.words.length; j++) {
                plaintextSlice.words[j] &amp;= fullSegmentMask.words[j];
            }

            if (encryptor) {
                self._ct = plaintextSlice.words.slice(0, Math.ceil(segmentSize / 32));
            }

            // remove the segment from the plaintext array
            slidingNegativeSegmentMask = neg(slidingSegmentMaskShifted.clone());
            for (j = 0; j &lt; words.length; j++) {
                words[j] &amp;= slidingNegativeSegmentMask.words[j];
            }

            // move filtered ciphertext segment to back to the correct place
            bitshift(plaintextSlice, -currentPosition);

            // add filtered ciphertext segment to the plaintext/ciphertext array
            for (j = 0; j &lt; words.length; j++) {
                words[j] |= plaintextSlice.words[j];
            }

            // shift the segment mask further along
            bitshift(slidingSegmentMask, -segmentSize);
            bitshift(slidingSegmentMaskShifted, -segmentSize);
        }
        self._prevBlock = prev;
    }

    return CFBb;
}());
</code></pre>

<p>You should use an appropriate padding. CryptoJS uses PKCS#7 padding by default. The best padding for CFB8 would be no padding at all (which you already use).</p>

<p>Example:</p>

<pre><code>var iv = CryptoJS.lib.WordArray.random(128/8);
var encrypted = CryptoJS.TripleDES.encrypt(""message"", key, {
    iv: iv, 
    mode: CryptoJS.mode.CFBb, 
    padding: CryptoJS.pad.NoPadding,
    segmentSize: 8
});
var recoveredPlaintext = CryptoJS.TripleDES.decrypt(encrypted, key, {
    iv: iv,
    mode: CryptoJS.mode.CFBb,
    padding: CryptoJS.pad.NoPadding,
    segmentSize: 8
});
console.log(recoveredPlaintext.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>Since this is using a random IV, the only way to see whether the Java and JavaScript implementations are compatible, is to encrypt in one and decrypt in the other in both directions.</p>

<p>Keep in mind that since the IV is random, you need to send it along with the ciphertext. Since it doesn't need to be secret, you can easily prepend it to the ciphertext and slice it off before decryption.</p>

<p>This code is a custom copy from my repository on GitHub: <a href=""https://github.com/artjomb/cryptojs-extension"" rel=""nofollow""><strong>artjomb/cryptojs-extension</strong></a>.</p>
","804","<javascript><java><cryptojs><cfb-mode>","0","0","1","2015-07-23 08:37:20","","0","2","1816580","","2015-07-23 08:37:20","2014-12-22 07:43:34",""
"28359128","How to decipher string in node js which is encrypted in crypto js in javascript","<p>My client side code:</p>

<pre><code>data.username = CryptoJS.AES.encrypt(user.username, ""password"");
data.password = CryptoJS.AES.encrypt(user.password, ""password"");
</code></pre>

<p>Then I am sending 'data' to server which is express.js</p>

<pre><code>var user = req.body;
var decipher = crypto.createDecipher('aes256', ""password"");
var decrypted = decipher.update(user.username, 'hex', 'utf-8');
decrypted += decipher.final('utf-8'); 
</code></pre>

<p>I am getting this error:</p>

<pre><code>Error: DecipherInit error
at new Decipher (crypto.js:368:17)
at Object.Decipher (crypto.js:365:12)
</code></pre>
","<p>CryptoJS' <code>encrypt</code> function with a password uses the same <code>EVP_BytesToKey</code> function node.js' <code>createCipher</code>, with the important difference that CryptoJS uses a random salt to derive whereas <a href=""http://nodejs.org/api/crypto.html#crypto_crypto_createcipher_algorithm_password"" rel=""nofollow"">node does not</a> (emphasis mine):</p>

<blockquote>
  <p>Note: createCipher derives keys with the OpenSSL function EVP_BytesToKey with the digest algorithm set to MD5, one iteration, and <strong>no salt</strong>.</p>
</blockquote>

<p>Either you directly use CryptoJS in node which is possible, because CryptoJS doesn't have any dependencies, or you do the key derivation yourself on both ends and use <code>crypto.createCipheriv</code>. If you do the former, you would have to additionally pass the salts of the username and password encryptions to node. </p>

<p>Note that <code>data.username</code> is the CryptoJS cipherParams object which contains the salt and the IV, but when you convert this to string with <code>data.username.toString()</code>, the salt is not included anymore, but the IV is. This is not the <code>data</code> that you would put into the node.js functions. Send <code>data.username.ciphertext</code> instead.</p>
","797","<javascript><node.js><express><cryptojs>","1","0","1","2015-02-06 08:11:03","","1","","","","","2015-02-06 05:27:45",""
"44436943","Crypto JS: TripleDES not encrypting properly","<p>When using crypto js tripleDES to encrypt, I noticed that all strings to encrypt which are of small length e.g ""01"", ""111"", ""20"" encrypt properly but with long strings like ""5000021234567890000"", the output isn't correct or is not the value I am expecting.
For example for this <em>""5000021234567890000""</em>, I am expecting this: <strong><em>""HctDaKc/U9avOwZMSS5mEi62kfojDHA4""</em></strong> but I get this instead: <em>HctDaKc/U9bNnFy6eZHqHj3SemorJxQM</em>.</p>

<p>This is the code I found and using to encrypt</p>

<pre><code>let key = CryptoJS.MD5(enckey);
key.words[4] = key.words[0];
key.words[5] = key.words[1];
let iv = CryptoJS.lib.WordArray.create(64/8);
CryptoJS.TripleDES.encrypt(""5000021234567890000"", key, {iv: iv});
</code></pre>

<p>Your help would be very much appreciated.</p>
","<p>Looking at the encrypted data the first blocks match and the following two blocks do not.</p>

<pre>
    HctDaKc/U9avOwZMSS5mEi62kfojDHA4
    1DCB4368A73F53D6 AF3B064C492E6612 2EB691FA230C7038

    HctDaKc/U9bNnFy6eZHqHj3SemorJxQM
    1DCB4368A73F53D6 CD9C5CBA7991EA1E 3DD27A6A2B27140C
</pre>

<p>The IV is presumably all 0x00 bytes.</p>

<p>THis indicates one is using ECB m ode and the other is using CBC mode.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">Block cipher mode of operation</a>, specifically ECB and CBC modes.</p>

<p>ECB mode encrypted each block independly, CBC mode xors the previous block with the data to be encrypted and for the first block the IV. Since the IV is all 0x00 values no change is made to the first block.</p>

<p>Options can be specified in the createion of the encryptor, you need to see the documentation page, good luck with that.</p>

<p>It would look something like:</p>

<pre><code>encryptor = crypto.createCipheriv( mode, key, iv)
</code></pre>

<p>where mode is one of: <code>'des-ede', 'des-ede-cbc', 'des-ede3', 'des-ede3-cbc', 'des3'</code></p>
","795","<javascript><node.js><encryption><cryptojs><tripledes>","1","2","1","2017-06-08 14:41:56","44438343","4","","5250853","","2017-06-08 13:47:06","2017-06-08 13:21:22",""
"40572177","The wordArray that CryptoJS.AES.decrypt() output was padded with 0x8080808","<p>I use CryptoJS to decrypt an encryption from my web server(use php and AES-128-ECB), but I can't get the right wordArray , it's length is too long. Here is my test code:</p>

<pre><code>var pwd = ""abcdefghijklmnop"";
var words = [0x86C5464, 0x7335231];
var plain_array= CryptoJS.lib.WordArray.create(words);
var base64_pwd = CryptoJS.enc.Utf8.parse(pwd).toString(CryptoJS.enc.Base64);
var pwd_key = CryptoJS.enc.Base64.parse(base64_pwd);
var encryption = AES.encrypt(plain_array,pwd_key, {mode: CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7}).toString();
var decrypt = AES.decrypt(encryption,pwd_key, {mode: CryptoJS.mode.ECB,padding: CryptoJS.pad.Pkcs7});
</code></pre>

<p>And The <strong><em>decrypt</em></strong> is :</p>

<pre><code>decrypt == {
    sigBytes : 8,
    words : [0x86C5464, 0x7335231, 0x8080808, 0x8080808]    
}
</code></pre>

<p>Why <strong><em>decrypt.words</em></strong> was padded with <strong><em>0x8080808</em></strong>? How can I get the right length wordArray?</p>

<p>Thanks in advance.</p>
","<p>AES is a block cipher and requires input in block size chunks, 16-bytes for AES. If the data to be encrypted is not an even multiple of the block size padding bytes need to be added. PKCS#7 padding is a common padding mode. Most AES libraries support a PKCS#7 padding mode which will add padding on encryption and remove the padding on decryption.</p>

<p>In this case 8-bytes of paddig was added and that is eight bytes of the value 0x08.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS#7 padding</a>.</p>

<blockquote>
  <p>Note: Do not use ECB mode, it is insecure, see <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29"" rel=""nofollow noreferrer"">ECB mode</a>, scroll down to the Penguin. Instead use CBC mode with a random IV, just prefix the encrypted data with the IV for use in decryption.</p>
</blockquote>
","792","<javascript><aes><cryptojs>","2","0","1","2016-11-13 12:12:30","40573678","0","","7145388","","2016-11-13 09:07:51","2016-11-13 08:59:20",""
"34929811","Why is base64 using CryptoJS different than a standard base64 encode?","<p>To communicate with a server, I need to send the password SHA1 &amp; base64 encoded the same way CryptoJS does this.</p>

<p>My problem is that I'm using VB.NET. The typical base64 encoding (UTF-8) result is different than the results of CryptoJS.</p>

<p>How can I base64 encode the SHA1 string in .NET the same way CryptoJS encodes it?</p>

<p>You can see both results here: <a href=""https://jsfiddle.net/hn5qqLo7/"" rel=""nofollow noreferrer"">https://jsfiddle.net/hn5qqLo7/</a></p>

<pre><code>var helloworld = ""Hello World"";
var helloword_sha1 = CryptoJS.SHA1(helloworld);
document.write(""SHA1: "" + helloword_sha1);

var helloword_base64 = helloword_sha1.toString(CryptoJS.enc.Base64);
document.write(""1) Base64: "" + helloword_base64);
document.write(""2) Base64: "" + base64_encode(helloword_sha1.toString()));
</code></pre>

<p>where <code>base64_encode</code> converts a given string to a Base 64 encoded string.</p>

<p>I saw a similar question, but I don't understand it.
<a href=""https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs"">Decode a Base64 String using CryptoJS</a></p>
","<p>In (1) of your fiddle the CryptoJS calculates the SHA1 value of the string, and then, converts the raw bytes to Base64. However (2) first calculates the SHA1 value of 'Hello World' and then puts it in hexadecimal form (consisting of only 0-9 and a-f), and then converts this hexadecimal form of SHA1 to base64. So that is why you end up with two different results.</p>
","784","<javascript><encoding><base64><cryptojs>","0","2","1","2016-01-23 13:35:54","34930165","0","","-1","","2017-05-23 12:23:30","2016-01-21 17:00:34",""
"34869340","Different Values in CryptoJS and C# HMAC256 in Ionic, AngularJS","<p>I'm following <a href=""http://www.primaryobjects.com/2015/05/08/token-based-authentication-for-web-service-apis-in-c-mvc-net/"" rel=""nofollow"">this site</a> to have a token based authentication from an ionic+angularJs mobile client to C# Web API REST Client.</p>

<p>The JS code to generate token is as following:</p>

<pre><code>generate: function (username, domain, password) {

            if (username &amp;&amp; domain &amp;&amp; password) {
                // If the user is providing credentials, then create a new key.
                this.logout();
            }

            //Set the username
            SecurityManager.username = SecurityManager.username || username;


            //Set the domain
            SecurityManager.domain = SecurityManager.domain || domain;

            // Set the key to a hash of the user's password + salt.
            SecurityManager.key = SecurityManager.key || CryptoJS.enc.Base64.stringify(CryptoJS.HmacSHA256([password, SecurityManager.salt].join(':'), SecurityManager.salt));

            $log.log(""security key: "" + SecurityManager.key);

            // Set the client IP address.
            SecurityManager.ip = SecurityManager.ip || this.getIp();

            // Persist key pieces.
            if (SecurityManager.username) {
                localStorage['SecurityManager.username'] = SecurityManager.username;
                localStorage['SecurityManager.domain'] = SecurityManager.domain;
                localStorage['SecurityManager.key'] = SecurityManager.key;
            }

            // Get the (C# compatible) ticks to use as a timestamp. http://stackoverflow.com/a/7968483/2596404
            var ticks = ((new Date().getTime() * 10000) + 621355968000000000);

            // Construct the hash body by concatenating the username, domnain, ip, and userAgent.
            var message = [SecurityManager.username, SecurityManager.domain, SecurityManager.ip, navigator.userAgent.replace(/ \.NET.+;/, ''), ticks].join(':');


            $log.log(""values are:"" + message.split(':'));


            // Hash the body, using the key.
            var hash = CryptoJS.HmacSHA256(message, SecurityManager.key);

            $log.log(""security key hash: "" + hash);


            // Base64-encode the hash to get the resulting token.
            var token = CryptoJS.enc.Base64.stringify(hash);

            $log.log(""base 64 encoded hash: "" + token);

            // Include the username, domain and timestamp on the end of the token, so the server can validate.
            var tokenId = [SecurityManager.username, SecurityManager.domain, ticks].join(':');

            // Base64-encode the final resulting token.
            var tokenStr = CryptoJS.enc.Base64.parse([token, tokenId].join(':'));

            var finalToken = CryptoJS.enc.Base64.stringify(tokenStr);

            $log.log(""Token is "" + finalToken);

            return finalToken;
 }
</code></pre>

<p>This gets the output:</p>

<pre><code>1     414448   log      security key:  LGlemne7vnKZMI35qNw2pgv7YsLerXTaegcycy6x5n0=
2     414562   log      values are:joe,cs,127.0.0.1,Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586,635887772145620000
3     414564   log      security key hash: d27a0346ea0ad6b50ae158cdc4433a129f957a1c965e126d9b2060f9fb11c0b7
4     414565   log      base 64 encoded hash: 0noDRuoK1rUK4VjNxEM6Ep+VehyWXhJtmyBg+fsRwLc=
5     414566   log      Token is 0noDRuoK1rUK4VjNxEM6Ep+VehyWXhJtmyBg+fsRwLc=
</code></pre>

<p>The C# Code to Generate Token is:</p>

<pre><code>public static string GenerateToken(string username, string domain, string password, string ip, string userAgent, long ticks)
    {
        string hash = string.Join("":"", new string[] { username,  domain, userAgent, ticks.ToString() });
        string hashLeft = string.Empty;
        string hashRight = string.Empty;

        using (HMAC hmac = HMACSHA512.Create(_alg))
        {
            hmac.Key = Encoding.UTF8.GetBytes(GetHashedPassword(password));
            **var a = System.Text.Encoding.UTF8.GetString(hmac.Key); //correct**

            hmac.ComputeHash(Encoding.UTF8.GetBytes(hash));                
            hashLeft = Convert.ToBase64String(hmac.Hash);
            hashRight = string.Join("":"", new string[] { username, domain, ticks.ToString() });
        }

        var c =  Convert.ToBase64String(Encoding.UTF8.GetBytes(string.Join("":"", hashLeft, hashRight)));
        return c;
    }
private static string GetHashedPassword(string password)
    {
        string key = string.Join("":"", new string[] { password, _salt });

        using (HMAC hmac = HMACSHA512.Create(_alg))
        {
            // Hash the key.
            hmac.Key = Encoding.UTF8.GetBytes(_salt);
            hmac.ComputeHash(Encoding.UTF8.GetBytes(key));

            return Convert.ToBase64String(hmac.Hash);
        }
    }
</code></pre>

<p>When I run the test in C# passing in the same long ticks, string username, string password, string domain, string ip and string user agent I'm getting a different token.</p>

<pre><code>[TestMethod]
    public void GenerateTokenTest2()
    {
        string username = ""joe"";
        string domain = ""cs"";
        string password = ""password"";
        string ip = ""127.0.0.1"";            
        string userAgent = ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586"";

        long ticks = 635887772145620000;

        var token = SecurityManager.GenerateToken(username, domain, password, ip, userAgent, ticks);

        Assert.IsNotNull(token);           
    }
</code></pre>

<p>The C# and JS security key match. LGlemne7vnKZMI35qNw2pgv7YsLerXTaegcycy6x5n0=</p>

<p>But the final tokens do not. </p>

<p>The post has more explanation on what they're trying to achieve. I added the domain bit to it, not that it works without it.</p>

<p>The salt is also the same:9eiPO7M99Xphj9WQf76t</p>

<p>I've also referenced the following libraries in the web page.</p>

<pre><code> &lt;!--Crypto-JS--&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
</code></pre>
","<p>I found my mistake. I wasn't using ip as part of the hash in C#. </p>

<p>Also,</p>

<pre><code> // Base64-encode the final resulting token.
            var tokenStr = CryptoJS.enc.Utf8.parse([token, tokenId].join(':'));
</code></pre>

<p>should be</p>

<pre><code> // Base64-encode the final resulting token.
            var tokenStr = CryptoJS.enc.Base64.parse([token, tokenId].join(':'));
</code></pre>

<p>But this above was only because I was trying different things.</p>
","764","<c#><angularjs><cryptojs>","1","0","1","2016-01-19 09:12:32","","0","1","5308318","","2016-01-19 08:00:35","2016-01-19 05:47:41",""
"54501320","Decode(Base64) and Decrypt(AES/CBC/PKCS5PADDING) with CryptoJS - React","<p>I am working on the web application using react as front-end and spring mvc as back-end. I need to store some user information in local storage of the browser. I do not want to store that info in local storage as a plain text. So I thought to go for AES encryption at server side and pushing those data back to JS side. For that I need client side decryption framework. I found crypto-js as very useful for all these things. I am not able to understand where I am lacking at client side to decrypt and decode.</p>

<p>I am explaining my Spring Side Encryption Code first which is absolutely fine:</p>

<pre><code>public class EncryptDecrypt {

        private static final String SECRET_KEY_1 = ""ssdkF$HUy2A#D%kd"";
        private static final String SECRET_KEY_2 = ""weJiSEvR5yAC5ftB"";

        private IvParameterSpec ivParameterSpec;
        private SecretKeySpec secretKeySpec;
        private Cipher cipher;

        public EncryptDecrypt() throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException {
            ivParameterSpec = new IvParameterSpec(SECRET_KEY_1.getBytes(""UTF-8""));
            secretKeySpec = new SecretKeySpec(SECRET_KEY_2.getBytes(""UTF-8""), ""AES"");
            cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        }

        public String encrypt(String toBeEncrypt) throws NoSuchPaddingException, NoSuchAlgorithmException, 
            InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
            byte[] encrypted = cipher.doFinal(toBeEncrypt.getBytes());
            return Base64.encodeBase64String(encrypted);
        }
}
</code></pre>

<p>At the client side, I am not able to decode and decrypt the code with simple things. Here is my client side code: </p>

<pre><code>var CryptoJS = require(""crypto-js"");

var data = ""Ggydx4oA1+SKBw+unA8BUUm2tnvkQbp1terdF2PEGFYSEZL/ye08op/0b0BauGtIl1dBIodrlKXo2de3MykYmocd3ctxFtIIki01V+M8XeQj6B384o0G+H7NpVx5tCJjPDvdqVRObtxCTqu3r8QRzYTNcMM5bRhbYxCYl8/NRyPQJnmcJDlRBeVOoJiQNA7Qd5UJD/mNivoyMUfYGV7/DlpylQWWwEAHVdgcb865i8jnf3vqURehAXYoaD6Bgodi1EM4H007uv0o6NEOk3H4jQ=="";

var key = ""weJiSEvR5yAC5ftB"";

// Decode the base64 data so we can separate iv and crypt text.
var rawData = atob(data);
var iv = ""ssdkF$HUy2A#D%kd"";
var crypttext = rawData.substring(16);

console.log(rawData);

// Decrypt...
var plaintextArray = CryptoJS.AES.decrypt(
  { ciphertext: CryptoJS.enc.Base64.parse(crypttext) },
  key,
  { iv: iv }
);

console.log(plaintextArray);

console.log(CryptoJS.enc.Base64.stringify(plaintextArray));

var decryptedData = JSON.parse(CryptoJS.enc.Base64.stringify(plaintextArray).toString(CryptoJS.enc.Utf8));

console.log(decryptedData);
</code></pre>

<p>P.S: I have sent JSON to client side and so that I am parsing it in the end. I am newbie for encryption and decryption. I am really stuck with what my client side code should look a like. Please help. </p>
","<p>You shouldn't pass string as key in <code>CryptoJS</code>. In this case it considers this string not as key, but as password. And generate key from password by using <code>PBKDF</code>. Working example below:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var data = ""Ggydx4oA1+SKBw+unA8BUUm2tnvkQbp1terdF2PEGFYSEZL/ye08op/0b0BauGtIl1dBIodrlKXo2de3MykYmocd3ctxFtIIki01V+M8XeQj6B384o0G+H7NpVx5tCJjPDvdqVRObtxCTqu3r8QRzYTNcMM5bRhbYxCYl8/NRyPQJnmcJDlRBeVOoJiQNA7Qd5UJD/mNivoyMUfYGV7/DlpylQWWwEAHVdgcb865i8jnf3vqURehAXYoaD6Bgodi1EM4H007uv0o6NEOk3H4jQ=="";
var rawData = CryptoJS.enc.Base64.parse(data);
var key = CryptoJS.enc.Latin1.parse(""weJiSEvR5yAC5ftB"");
var iv = CryptoJS.enc.Latin1.parse(""ssdkF$HUy2A#D%kd"");
var plaintextData = CryptoJS.AES.decrypt(
    { ciphertext: rawData },
    key,
    { iv: iv });
var plaintext = plaintextData.toString(CryptoJS.enc.Latin1);
console.log(plaintext);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>BTW, you shouldn't use the same IV every time. In this case you miss the base purpose of IV and CBC mode. Your overall security becomes equal to ECB mode.</p>
","761","<encryption><base64><aes><decode><cryptojs>","6","1","1","2019-02-05 12:12:49","54534070","4","","","","","2019-02-03 08:55:29",""
"30232629","Using CryptoJS for decryption after OpenSSL encryption","<p>I am using OpenSSL to encrypt a txt file, with ""Hello World"" inside, using the following command at the terminal:</p>

<pre><code>openssl enc -aes-128-ctr -in file.txt -out file-out-64.txt -base64 -A
-K 0123456789abcdef0123456789abcdef -iv 00000000000000000000000000000000`
</code></pre>

<p>So, I am using AES-128 (CTR mode) with that dummy key and IV and generating a base64 at the end, producing the following output: Mc6prldI+uuh5Ko=</p>

<p>I want to decrypt this with CryptoJS and I am using the following code:</p>

<pre><code>CryptoJS.AES.decrypt(
  ""Mc6prldI+uuh5Ko="",
  CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef""),
  { 
    iv   : CryptoJS.enc.Hex.parse(""00000000000000000000000000000000""),
    mode : CryptoJS.mode.CTR 
  }
);
</code></pre>

<p>I was expecting ""Hello World"" output but it's producing an empty string result. Can anybody help?</p>
","<p>Tried this?</p>

<pre><code>var decrypt = CryptoJS.AES.decrypt(CryptoJS.enc.Base64.parse(""Mc6prldI+uuh5Ko=""), CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef""), { iv: CryptoJS.enc.Hex.parse(""00000000000000000000000000000000""), mode: CryptoJS.mode.CTR });
</code></pre>
","758","<javascript><openssl><cryptojs>","2","0","2","2016-03-25 11:22:07","","0","1","1022444","","2016-03-25 11:22:07","2015-05-14 08:24:30",""
"30232629","Using CryptoJS for decryption after OpenSSL encryption","<p>I am using OpenSSL to encrypt a txt file, with ""Hello World"" inside, using the following command at the terminal:</p>

<pre><code>openssl enc -aes-128-ctr -in file.txt -out file-out-64.txt -base64 -A
-K 0123456789abcdef0123456789abcdef -iv 00000000000000000000000000000000`
</code></pre>

<p>So, I am using AES-128 (CTR mode) with that dummy key and IV and generating a base64 at the end, producing the following output: Mc6prldI+uuh5Ko=</p>

<p>I want to decrypt this with CryptoJS and I am using the following code:</p>

<pre><code>CryptoJS.AES.decrypt(
  ""Mc6prldI+uuh5Ko="",
  CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef""),
  { 
    iv   : CryptoJS.enc.Hex.parse(""00000000000000000000000000000000""),
    mode : CryptoJS.mode.CTR 
  }
);
</code></pre>

<p>I was expecting ""Hello World"" output but it's producing an empty string result. Can anybody help?</p>
","<p>I found the solution. In the options parameter I had to add padding with NoPadding</p>

<pre><code>var decoded   = CryptoJS.AES.decrypt(""Mc6prldI+uuh5Ko="", CryptoJS.enc.Hex.parse(""0123456789abcdef0123456789abcdef""), { iv: CryptoJS.enc.Hex.parse(""00000000000000000000000000000000""), padding: CryptoJS.pad.NoPadding, mode: CryptoJS.mode.CTR });
</code></pre>
","758","<javascript><openssl><cryptojs>","2","1","2","2016-03-25 11:22:07","","0","1","1022444","","2016-03-25 11:22:07","2015-05-14 08:24:30",""
"38893985","why encrypt result is different using same AES algorithm and same key between CryptoJS and node built-in crypto module","<p>I was developing server with Node.js and client with Ionic framework</p>

<p>I made API for login request from client</p>

<p>when client request login, sends encrypted id and password string</p>

<p>and server decrypt received id and password string and check validation</p>

<p>I used crypto-js(<a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">https://code.google.com/archive/p/crypto-js/</a>) library for client encryption </p>

<p>client encryption code below</p>

<pre><code>var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"";
var encrypted = CryptoJS.AES.encrypt(id, password);
console.log(encrypted.toString());  // U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU=
</code></pre>

<p>For server-side decryption I used node built-in crypto module</p>

<pre><code>const crypto = require('crypto');
var method = 'aes256';
var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU="" // suppose we received with no loss
var decipher = crypto.createDecipher(method, secret);
decipher.update(id,'base64','utf8');
var deciphered = decipher.final('utf8');
console.log(deciphered);
</code></pre>

<p>server-side decrypt code crash with error message below</p>

<pre><code>crypto.js:153
  var ret = this._handle.final();
                         ^

Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
    at Error (native)
    at Decipher.Cipher.final (crypto.js:153:26)
    at Object.&lt;anonymous&gt; (...\routes\index.js:33:27)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.&lt;anonymous&gt; (...\app.js:18:14)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
</code></pre>

<p>As error message was 'bad decrypt' so I tried to encrypt same text with each library</p>

<p>[crypto-js]</p>

<pre><code>var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"";
var encrypted = CryptoJS.AES.encrypt(id, password);
console.log(encrypted.toString());  // U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU=
</code></pre>

<p>[crypto module]</p>

<pre><code>const crypto = require('crypto');
var method = 'aes256';
var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"" 
var cipher= crypto.createCipher(method, secret);
cipher.update(id,'base64','utf8');
var ciphered = decipher.final('utf8');
console.log(ciphered.toString()); // WAsd61C2bfG7UbO5STo13A==
</code></pre>

<p>I found out result of library is different</p>

<pre><code>plain text : 'someId'
crpyto-js  : 'U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU='
crpyto module : 'WAsd61C2bfG7UbO5STo13A=='
</code></pre>

<p>I tried to understand the source code of each library</p>

<p>but it was too complicate so, I couldn't understand </p>

<p>I want to know how each library's encrytion works and what cause the different result</p>
","<p>You are using two different systems which may have different defaults.  Do not rely on defaults, but explicitly specify everything to be the same on both sides.  Crypto is designed to fail if even the smallest thing does not match.  You will need to specify the character to byte mapping used, the crypto mode, the IV (if needed), the key and the padding method.</p>

<p>Your different outputs are different lengths, so initially I suspect that padding is the first thing to look at.  Set both sides to PKCS#7 padding and see if that helps.</p>

<p>For further diagnosis, check that the key and IV are <strong>byte-for-byte</strong> the same on each side.</p>
","755","<node.js><encryption><cryptojs>","1","0","2","2016-08-11 11:54:34","","3","","","","","2016-08-11 10:37:09",""
"38893985","why encrypt result is different using same AES algorithm and same key between CryptoJS and node built-in crypto module","<p>I was developing server with Node.js and client with Ionic framework</p>

<p>I made API for login request from client</p>

<p>when client request login, sends encrypted id and password string</p>

<p>and server decrypt received id and password string and check validation</p>

<p>I used crypto-js(<a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">https://code.google.com/archive/p/crypto-js/</a>) library for client encryption </p>

<p>client encryption code below</p>

<pre><code>var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"";
var encrypted = CryptoJS.AES.encrypt(id, password);
console.log(encrypted.toString());  // U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU=
</code></pre>

<p>For server-side decryption I used node built-in crypto module</p>

<pre><code>const crypto = require('crypto');
var method = 'aes256';
var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU="" // suppose we received with no loss
var decipher = crypto.createDecipher(method, secret);
decipher.update(id,'base64','utf8');
var deciphered = decipher.final('utf8');
console.log(deciphered);
</code></pre>

<p>server-side decrypt code crash with error message below</p>

<pre><code>crypto.js:153
  var ret = this._handle.final();
                         ^

Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
    at Error (native)
    at Decipher.Cipher.final (crypto.js:153:26)
    at Object.&lt;anonymous&gt; (...\routes\index.js:33:27)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.&lt;anonymous&gt; (...\app.js:18:14)
    at Module._compile (module.js:409:26)
    at Object.Module._extensions..js (module.js:416:10)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
</code></pre>

<p>As error message was 'bad decrypt' so I tried to encrypt same text with each library</p>

<p>[crypto-js]</p>

<pre><code>var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"";
var encrypted = CryptoJS.AES.encrypt(id, password);
console.log(encrypted.toString());  // U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU=
</code></pre>

<p>[crypto module]</p>

<pre><code>const crypto = require('crypto');
var method = 'aes256';
var secret = 'abcdefghijklmnopqrstuvwxyz123456';
var id = ""someId"" 
var cipher= crypto.createCipher(method, secret);
cipher.update(id,'base64','utf8');
var ciphered = decipher.final('utf8');
console.log(ciphered.toString()); // WAsd61C2bfG7UbO5STo13A==
</code></pre>

<p>I found out result of library is different</p>

<pre><code>plain text : 'someId'
crpyto-js  : 'U2FsdGVkX19EfjjBwydSZL509wKl5TEX+4f3vakEejU='
crpyto module : 'WAsd61C2bfG7UbO5STo13A=='
</code></pre>

<p>I tried to understand the source code of each library</p>

<p>but it was too complicate so, I couldn't understand </p>

<p>I want to know how each library's encrytion works and what cause the different result</p>
","<p>All parameters must be specified and correct. Do not rely on defaults, they are implementation dependent and will very between implementations.</p>

<p>In general you should use:  </p>

<ol>
<li><p>CBC mode with a random iv, on encryption create a random iv, prepend it to the encrypted data for use on decryption. For AES the iv should be 16-bytes, the block size. Do not use ECB mode, it is insecure, see <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29"" rel=""nofollow"">ECB mode</a>, scroll down to the Penguin.</p></li>
<li><p>PKCS#7 padding (sometimes called PKCS#5). This is needed because AES is a block cipher and input and output must be an exact multiple of the block size. This padding will be automatically added during encryption and removed during decryption.</p></li>
<li><p>Ensure the iv and key are <strong>exactly</strong> the correct size.</p></li>
<li><p>For debugging display all inputs and outputs in hexadecimal. It can be helpful during debugging to dump all inputs and outputs just prior to and after encryption and decryption. Hexadecimal allows one to see each byte, Base64 combines 3 bytes into 4 bytes and makes it harder to understand.</p></li>
</ol>

<p>When all this is exactly the same the outputs will also be exactly the same.</p>
","755","<node.js><encryption><cryptojs>","1","0","2","2016-08-11 11:54:34","","3","","","","","2016-08-11 10:37:09",""
"52523776","Migrating from 'crypto' to crypto-js library: Binary encoding","<p>I'm trying to generate SHA256 and HmacSHA512 hashes on a device which unfortunately has no support for the standard Node <code>crypto</code> library. So I am adjusting the code to use CryptoJS instead. However, CryptoJS cannot encode the Hash as in binary (only Hex, Base64 and Latin1 are available encoders).</p>

<p>Below is the function I'm trying to migrate. Previous (unusable) code is commented out.</p>

<pre><code>const getMessageSignature = (path, request, secret, nonce) =&gt; {
    // Expected outcome:
    // API-Sign = Message signature using HMAC-SHA512 of (URI path + SHA256(nonce + POST data)) and base64 decoded secret API key
    const message = JSON.stringify(request);

    const secret_buffer = btoa(secret);
    const hash = CryptoJS.algo.SHA256.create();
    const hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, secret_buffer);
    const hash_digest = hash.update(nonce + message).finalize().toString(CryptoJS.enc.Base64);
    const hmac_digest = hmac.update(path + hash_digest).finalize().toString(CryptoJS.enc.Base64);

    // CANNOT USE BELOW (Buffer and crypto not supported)
    // const secret_buffer = new Buffer(secret, 'base64');
    // const hash = new crypto.createHash('sha256');
    // const hmac = new crypto.createHmac('sha512', secret_buffer);
    // const hash_digest = hash.update(nonce + message).digest('binary');
    // const hmac_digest = hmac.update(path + hash_digest, 'binary').digest('base64');

    return hmac_digest;
};
</code></pre>
","<p>I found the answer. First of all: <code>btoa()</code> is not necessary, as CryptoJS has its own functionality to turn Base64 into its own format (WordLists): <code>CryptoJS.enc.Base64.parse</code>. Next up is that <code>path</code> and <code>hash_digest</code> cannot be merged properly as there's a Type Mismatch (string and binary), so JS uses the string representation. The solution is to first create a SHA512 HMAC using <code>CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA512, secret)</code> and then update it step-by-step for each value with <code>hmac.update(value, secret)</code>. Finally, you'll also have to use CryptoJS' built-in Base64 decoder to finally produce the signature string.</p>

<pre><code>const getMessageSignature = (path, request, secret, nonce) =&gt; {
    // API-Sign = Message signature using HMAC-SHA512 of (URI path + SHA256(nonce + POST data)) and base64 decoded secret API key
    const message = JSON.stringify(request);
    const hash = CryptoJS.SHA256(nonce + message);
    const secret_buffer = CryptoJS.enc.Base64.parse(secret);
    const hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA512, secret_buffer);
    hmac.update(path, secret_buffer);
    hmac.update(hash, secret_buffer);
    return hmac.finalize().toString(CryptoJS.enc.Base64);
};
</code></pre>
","744","<node.js><cryptojs><node-crypto>","1","1","1","2018-09-27 08:38:53","52532805","0","","","","","2018-09-26 18:07:30",""
"43636332","Will this CryptoJS AES encryption code produce secure output?","<p>I believe that because the key passed to AES.encrypt is a string, the function will automatically generate an IV. So is the code below producing a well secured encrypted version of string_to_encrypt?</p>

<pre><code>pass  = document.getElementById('pass').value; // user entered pwrd    salt  = 'some system determined salt';
its   = 9000 + getKeyIterationModifier(pass); // iterations depend on pass
key   = CryptoJS.PBKDF2(pass, salt, { keySize: 512/32, iterations: its });

encrypted = CryptoJS.AES.encrypt(string_to_encrypt, key.toString());
</code></pre>

<p>Or should I be adding 'mode' and 'padding' values to harden it further? If so, what are the current industry standard values?</p>

<p>In other words, should I ideally be using something <em>like</em> the following (perhaps without the iv if that's done automatically) and if so what's ideal:</p>

<pre><code>key = CryptoJS.enc.Base64.parse(key);
encrypted = CryptoJS.AES.encrypt(string_to_encrypt, key, {
    iv: iv, 
    mode: CryptoJS.mode.CBC, 
    padding: CryptoJS.pad.Pkcs7
});
</code></pre>
","<p><code>CryptoJS.AES.encrypt</code> uses EVP_BytesToKey to expand the passed ""key"" (considered a password) to an actual AES-256 key and IV if the ""key"" was a string. It uses a random salt for that, so the ciphertext is randomized. In your second snippet, you need to handle the IV yourself.</p>

<p>What you're essentially asking is whether EVP_BytesToKey is a secure password expansion function. That's not something that can be easily answered. The fact that it uses MD5 means that the first snippet has <em>at least</em> the security of AES-128 which should be good.</p>

<p>The other issue is that the IV should be unpredictable (read: random) for absolutely every encryption. Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. This suggestion is a given in the first snippet, but you would have to work for that realization in the second snippet which might introduce other issues.</p>

<p><strong>If you're not comfortable with CryptoJS and cryptography, go with the first snippet. Otherwise, try to improve the second snippet.</strong></p>

<hr>

<h3>Security considerations:</h3>

<p>If you're using only symmetric encryption in the browser you need the exact same key at the server and the client. If you send the encryption key from the server to the client or the other way around you need to encrypt your symmetric encryption key. The easiest way to do this would be to use TLS. If you use TLS, then the data as well as key are encrypted, so you don't need to encrypt it yourself. This doesn't provide any security, just a little bit of obfuscation. You should read: <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/</a></p>

<p>You should think about integrating authenticated encryption through an authenticated mode like GCM or EAX, or through the use of an encrypt-then-MAC scheme with a strong MAC like HMAC-SHA256.</p>
","744","<javascript><aes><padding><cryptojs><pbkdf2>","1","1","1","2017-04-26 22:32:08","43640656","6","","1163264","","2017-04-26 22:32:08","2017-04-26 13:57:25",""
"25733528","What kind of data does crypto-js function return?","<p>I am using crypto-js to encrypt a password with PBKDF2 to pass a key to AES encryption function.</p>

<pre><code>var PBKDF2hash = crypto.PBKDF2(req.body.password, salt, { keySize: 256/32 });
</code></pre>

<p>When I use crypto-js hash functions, <code>console.log(PBKDF2hash)</code> returns this weird data in console:</p>

<pre><code>    { init: [Function],
  '$super': 
   { init: [Function],
     toString: [Function],
     concat: [Function],
     clamp: [Function],
     clone: [Function],
     random: [Function],
     '$super': 
      { extend: [Function],
        create: [Function],
        init: [Function],
        mixIn: [Function],
        clone: [Function] } },
  words: 
   [ 162340080,
     -1329278032,
     -946859974,
     1516294488,
     -1059418968,
     60522350,
     440072457,
     -2049460689,
     -571434654,
     1087160278 ],
  sigBytes: 32 }
</code></pre>

<p>What kind of data is this? Isn't function supposed to return a usual hashed password in form of a string? </p>
","<p>From <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">the documentation</a>:</p>

<blockquote>
  <p>The hash you get back isn't a string yet. It's a WordArray object. When you use a WordArray object in a string context, it's automatically converted to a hex string.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>You can convert a WordArray object to other formats by explicitly calling the toString method and passing an encoder.</p>
</blockquote>
","739","<javascript><node.js><encryption><cryptojs><pbkdf2>","2","4","1","2014-09-08 21:44:03","25733593","0","","","","","2014-09-08 21:39:39",""
"32174323","Can I include CryptoJS files in my Chrome extension?","<p>I'm working on a Chrome extension and it's almost done. It uses CryptoJS, though, and I was wondering if it's okay to have those files (eg sha1.js) inside the extension package when I publish it (I downloaded CryptoJS and copied the SHA script file into the extension directory.)</p>

<p>The alternative of course would be to include the URL in the script tag but that didn't work right off the bat.</p>

<p>Any help would be appreciated.</p>
","<p>I've done this, but only tested on my dev machine, not publishing to the Chrome Web Store.  You just have to include it in your manifest.json file:</p>

<pre><code>{
...
    ""background"": {
        ""scripts"": [
            ""cryptojs.js"",
            ""main.js""]
}
...
}
</code></pre>
","732","<javascript><google-chrome><google-chrome-extension><cryptojs>","0","1","2","2015-08-24 12:58:55","32180175","3","0","","","","2015-08-24 04:10:58",""
"32174323","Can I include CryptoJS files in my Chrome extension?","<p>I'm working on a Chrome extension and it's almost done. It uses CryptoJS, though, and I was wondering if it's okay to have those files (eg sha1.js) inside the extension package when I publish it (I downloaded CryptoJS and copied the SHA script file into the extension directory.)</p>

<p>The alternative of course would be to include the URL in the script tag but that didn't work right off the bat.</p>

<p>Any help would be appreciated.</p>
","<p>There are pros and cons. Mostly pros.</p>

<ul>
<li>A local file will load faster - disk latency is lower than network latency.</li>
<li>A local file will ensure your extension works offline / in poor connectivity.</li>
<li>A local file is more reliable in case CDN has problems.</li>
<li>A local file enjoys additional protection (at least on Windows/Mac platforms), as CWS will generate checksums for all files and a store-installed extension will be stopped from loading if the files are tampered with.</li>
<li>A local file is safe from network MITM attacks.</li>
<li>A local file is frozen at a particular version - you don't run the risk of a library updating and breaking compatibility.</li>
<li>Using external code in main extension code (not content scripts) requires <a href=""https://developer.chrome.com/extensions/contentSecurityPolicy#relaxing-remote-script"" rel=""nofollow"">a modification of CSP</a> and a HTTPS-enabled CDN (for the MITM-attack reason).</li>
<li>Using external code in content scripts may require additional permissions (depending on the CDN's CORS configuration)</li>
</ul>

<p>However, it will be up to you to keep the library updated.</p>

<ul>
<li>If there is a critical bug/exploit in the library, a CDN-served file (if it points to ""latest"" version) can be silently updated to mitigate that. In case of a local file, you need to learn about the update and apply it yourself.</li>
<li>A local file cannot be updated without publishing a new version to CWS. An externally-hosted file can be updated independently.</li>
</ul>
","732","<javascript><google-chrome><google-chrome-extension><cryptojs>","0","1","2","2015-08-24 12:58:55","32180175","3","0","","","","2015-08-24 04:10:58",""
"40617764","TripleDES: Encrypt (.Net) - Decrypt (CryptoJS)","<p>I have a C# application that uses the following methods for encrypt and decrypt passwords in a database:</p>

<pre><code>public static string Encrypt(string input, string key)
{
    TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
    tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
    tripleDES.Mode = CipherMode.ECB;
    tripleDES.Padding = PaddingMode.PKCS7;
    ICryptoTransform cTransform = tripleDES.CreateEncryptor();

    byte[] inputArray = UTF8Encoding.UTF8.GetBytes(input);

    byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
    tripleDES.Clear();

    return Convert.ToBase64String(resultArray, 0, resultArray.Length);
}

public static string Decrypt(string input, string key)
{
    byte[] inputArray = Convert.FromBase64String(input);

    TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
    tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
    tripleDES.Mode = CipherMode.ECB;
    tripleDES.Padding = PaddingMode.PKCS7;
    ICryptoTransform cTransform = tripleDES.CreateDecryptor();

    byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
    tripleDES.Clear();

    return UTF8Encoding.UTF8.GetString(resultArray);
}
</code></pre>

<p>So if I encrypt the password <code>testing</code> with the key <code>0123456789012345</code> then the result will be <code>+dc6bsOFg00=</code>.</p>

<p>Now I have to read these passwords from a NodeJS application (using CryptoJS), but I'm not sure how to do it, since in C# the encryption is <em>byte oriented</em> (note that in the code both <code>input</code> and <code>key</code> are converted to <code>byte[]</code>) while in CryptoJS it's more <em>string oriented</em>. </p>

<p>I tried using this JavaScript function with no success:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

function decrypt(input, key) {
    var inputArray = new Buffer(input, 'base64');
    var inputString = inputArray.toString();
    var resultArray = CryptoJS.TripleDES.decrypt(inputString, key, {'mode': CryptoJS.mode.ECB, 'pad': CryptoJS.pad.Pkcs7});
    return resultArray.toString();
}

console.log(decrypt(""+dc6bsOFg00="", ""0123456789012345""));
</code></pre>

<p><strong>Update:</strong> I know that encrypting passwords is a bad idea, and that <em>Triple DES</em> is not the best algorithm, but the C# application can't be modified (at least not for now), so I can't change how the password are encrypted, I must read them as they currently are. </p>
","<p><em>(Posted on behalf of the OP)</em>.</p>

<p>Thanks for the suggestion, but using <code>inputArray.toString('binary')</code> did not work.</p>

<p>What I finally did solve my problem is to use <a href=""http://tjanczuk.github.io/edge/#/"" rel=""nofollow noreferrer"">Edge.js</a>: since I have the code of the C# methods used for encrypt and decrypt, I can use Edge.js to execute these methods from the Node application.</p>
","728","<c#><.net><node.js><encryption><cryptojs>","1","-1","1","2016-11-17 12:13:23","","5","","472495","","2016-11-17 12:13:23","2016-11-15 19:06:04",""
"33587355","Javascript crypto library cant encrypt and decrypt a string in a simple example program","<p>I am trying to learn javascript and am following a tutorial and I think I type everything in correctly but for some reason the string I encrypted using cypto-js library cant be unencrypted correct.  I don't get an error but the unencrypted string is not correct.  I am using a macintosh and ""crypto-js"": ""^3.1.5"".</p>

<p>Here is my sample code.</p>

<pre><code>var crypto = require('crypto-js');

var secretMessage = 'I hid the chips under the couch.';
var secretKey = '123abc';

var encryptedMessage = crypto.AES.encrypt(secretMessage, secretKey);
console.log('encryptedMessage: ' + encryptedMessage);

var bytes = crypto.AES.decrypt(encryptedMessage, secretKey);
var decryptedMessage = bytes.toString(crypto.enc.utf8);
console.log('decrpt2: ' + decryptedMessage);
</code></pre>

<p>Here are the results I get</p>

<pre><code>   $ node example-encryption.js
    encryptedMessage: U2FsdGVkX180KTEpMiLEjZDSAkhNkmbBuRa9RXFwCgx6gA/PUFr+KOIv6Gr6TgIYrkfUu3F+OM/kRJ3sTTgsfg==
    decrpt2: 49206869642074686520636869707320756e6465722074686520636f7563682e
</code></pre>

<p>Can someone please help?</p>

<p>Thanks,
Greg</p>
","<p>There are a few issues with your code, the main ones being that you need to supply a key of the right length and you also need to pass a cipherParams object to the decrypt() method rather than the ciphertext itself.</p>

<p>Here's some code that works and, for bonus points, is generally compatibable with the OpenSSL binaries and PHP libraries found on most systems:</p>

<pre><code>var CryptoJS = require( 'crypto-js' );

var secretMessage = 'I hid the chips under the couch.';
var secretKey = 'b52b4f45b6e9337b57869d7cb718c693';

var encryptedMessage = CryptoJS.AES.encrypt(secretMessage, CryptoJS.enc.Hex.parse(secretKey),
                       { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });

console.log('encryptedMessage: ' + encryptedMessage.ciphertext);

cipherParams = CryptoJS.lib.CipherParams.create(
               {ciphertext: CryptoJS.enc.Hex.parse(encryptedMessage.ciphertext.toString())});

var bytes = CryptoJS.AES.decrypt(cipherParams,CryptoJS.enc.Hex.parse(secretKey),
            { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });

console.log( 'Decrypted:' + bytes.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>There is no Initiatlization Vector because we're using ECB rather than CBC. If you want something secure, use CBC with a random IV for every message.</p>
","727","<javascript><node.js><cryptojs>","1","1","1","2015-11-09 01:55:46","33601234","4","","57135","","2015-11-07 20:31:10","2015-11-07 20:22:00",""
"31896441","Javascript AES encryption doesn't match iOS AES encryption","<p>I am encrypting an <code>NSString</code> in iOS like this which encodes and decodes fine:</p>

<pre><code>NSString *stringtoEncrypt = @""This string is to be encrypted"";
NSString *key = @""12345678901234567890123456789012"";

// Encode
NSData *plain = [stringtoEncrypt dataUsingEncoding:NSUTF8StringEncoding];
NSData *cipher = [plain AES256EncryptWithKey:key];

NSString *cipherBase64 = [cipher base64EncodedString];
NSLog(@""ciphered base64: %@"", cipherBase64);

// Decode
NSData *decipheredData = [cipherBase64 base64DecodedData];
NSString *decoded = [[NSString alloc] initWithData:[decipheredData AES256DecryptWithKey:key] encoding:NSUTF8StringEncoding];
NSLog(@""%@"", decoded);
</code></pre>

<p>NSData extension:</p>

<pre><code>- (NSData *)AES256EncryptWithKey:(NSString *)key
{
    // 'key' should be 32 bytes for AES256, will be null-padded otherwise
    char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)
    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)

    // fetch key data
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];

    NSUInteger dataLength = [self length];

    //See the doc: For block ciphers, the output size will always be less than or
    //equal to the input size plus the size of one block.
    //That's why we need to add the size of one block here
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);

    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                          keyPtr, kCCKeySizeAES256,
                                          NULL /* initialization vector (optional) */,
                                          [self bytes], dataLength, /* input */
                                          buffer, bufferSize, /* output */
                                          &amp;numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        //the returned NSData takes ownership of the buffer and will free it on deallocation
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    }

    free(buffer); //free the buffer;
    return nil;
}
</code></pre>

<p>I can successfully pass the resulting Base64 string to <code>Node.js</code> and have it decode the message. What I also need, is the same encoding method written in <code>Javascript</code>.
Here is what I have so far:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
...
var text = ""This string is to be encrypted"";
var key = ""12345678901234567890123456789012"";
var iv  = '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00';
var encrypted = CryptoJS.AES.encrypt(text, key, {iv: iv});
console.log(""Base64 encoded: "" + window.btoa(encrypted.ciphertext));
</code></pre>

<p>However the resulting Base64 string does not match the one generated by iOS.
Any ideas?</p>
","<p>CryptoJS uses a password-based encryption compatible with OpenSSL when you pass a string as a key. Since you already have a full key and IV, you need to convert them into CryptoJS' native type which is a WordArray:</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse(""12345678901234567890123456789012"");
var iv  = CryptoJS.lib.WordArray.create([0, 0, 0, 0]); // each number is a word of 32 bit
</code></pre>

<p>By calling <code>btoa()</code> on a WordArray object, you're forcing it to the stringified. The default hex-encoding is used for this. Afterwards <code>btoa()</code> encodes this hex-encoded string into Bas64 which bloats it even more.</p>

<p>You can directly encode a WordArray into Base64:</p>

<pre><code>encrypted.ciphertext.toString(CryptoJS.enc.Base64)
</code></pre>
","725","<javascript><objective-c><encryption><encoding><cryptojs>","1","2","1","2015-08-08 20:00:36","31896553","2","","1816580","","2015-08-08 17:17:17","2015-08-08 17:05:08",""
"45462400","java encryption aes value and javascript encryption value does not match","<p>I have java code which produce aes encryption code for me now I am trying to use it on javascript using crypto-js but both codes provides different keys I dont know why and how to get the same key here is my code</p>

<pre><code>public static String encrypt(String text, byte[] iv, byte[] key)throws Exception{ 

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); 
    SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
    System.out.println(""KEY SPECCCC: ""+keySpec); 
    IvParameterSpec ivSpec = new IvParameterSpec(iv); 
    cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec); 
    byte [] results = cipher.doFinal(text.getBytes(""UTF-8"")); 
    BASE64Encoder encoder = new BASE64Encoder(); 
    return encoder.encode(results); 
} 
</code></pre>

<p>JavaScript code</p>

<pre><code>  require([""crypto-js/core"", ""crypto-js/aes""], function (CryptoJS, AES) {
        ciphertext = CryptoJS.AES.encrypt(JSON.stringify(jsondata),
                        arr.toString(),arr.toString());
  });
</code></pre>

<p>string to utf-8 </p>

<pre><code>var utf8 = unescape(encodeURIComponent(key));
var arr = [];
for (var i = 0; i &lt; utf8.length; i++) {
    arr.push(utf8.charCodeAt(i));
}
</code></pre>
","<p>First of all even tough your code works fine you wont be able to decrypt it back properly because while you are creating your AES cipher in Java you are using CBC  Cipher and You are implementing a Padding algorithm which is PKCS5Padding.
So your java code does the followings;
When it gets the input it first divide it into the 16 bits blocks then if your input doesnt divide into the 16 overall then the reminders will be padded for filling the block with the same number of reminder.You can see what i mean by the following picture.</p>

<p><a href=""https://i.stack.imgur.com/IT1cJ.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/IT1cJ.png"" alt=""enter image description here""></a></p>

<p>So it will do the encryption with the padded ciphers in the java side  but in the Javascript Part You neither declare what type of Mode Aes will use nor declaring the what type of Padding it suppose to do. So you should add those values into the your code.You can make search following code parts. </p>

<pre><code>                        mode:CryptoJS.mode.CBC,
                        padding: CryptoJS.pad.Pkcs7
</code></pre>

<p>About the different keys it is occuring because you are sending a Byte[] in to the your Encrypt method then use this unknown Byte[] while you are creating your Key.You didnt mention why your encryption method will be used in your program  but you should create that ""Byte[] key"" same way in the both method.For instance you can refer following code as a example of generating that but it is not secure way of generating keys I just added it for showing you what I mean by you should generate both keys in the same way.</p>

<pre><code>    //DONT USE THIS IMPLEMENTATION SINCE IT IS NOT SAFE!
    byte[] key = (username + password).getBytes(""UTF-8"");
</code></pre>
","723","<javascript><java><encryption><aes><cryptojs>","1","1","2","2019-07-12 13:02:04","","3","4","1816580","","2017-08-02 18:33:16","2017-08-02 13:34:15",""
"45462400","java encryption aes value and javascript encryption value does not match","<p>I have java code which produce aes encryption code for me now I am trying to use it on javascript using crypto-js but both codes provides different keys I dont know why and how to get the same key here is my code</p>

<pre><code>public static String encrypt(String text, byte[] iv, byte[] key)throws Exception{ 

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); 
    SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
    System.out.println(""KEY SPECCCC: ""+keySpec); 
    IvParameterSpec ivSpec = new IvParameterSpec(iv); 
    cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec); 
    byte [] results = cipher.doFinal(text.getBytes(""UTF-8"")); 
    BASE64Encoder encoder = new BASE64Encoder(); 
    return encoder.encode(results); 
} 
</code></pre>

<p>JavaScript code</p>

<pre><code>  require([""crypto-js/core"", ""crypto-js/aes""], function (CryptoJS, AES) {
        ciphertext = CryptoJS.AES.encrypt(JSON.stringify(jsondata),
                        arr.toString(),arr.toString());
  });
</code></pre>

<p>string to utf-8 </p>

<pre><code>var utf8 = unescape(encodeURIComponent(key));
var arr = [];
for (var i = 0; i &lt; utf8.length; i++) {
    arr.push(utf8.charCodeAt(i));
}
</code></pre>
","<p>Java code generates an encrypted string and for JavaScript to also generate same encrypted string, Following code works!</p>

<pre><code>(function (CryptoJS) {
    var C_lib = CryptoJS.lib;
    // Converts ByteArray to stadnard WordArray.
    // Example: CryptoJS.MD5(CryptoJS.lib.ByteArray ([ Bytes ])).toString(CryptoJS.enc.Base64);
    C_lib.ByteArray = function (arr) {
        var word = [];
        for (var i = 0; i &lt; arr.length; i += 4) {
            word.push (arr[i + 0] &lt;&lt; 24 | arr[i + 1] &lt;&lt; 16 | arr[i + 2] &lt;&lt; 8 | arr[i + 3] &lt;&lt; 0);
        }
        return C_lib.WordArray.create (word, arr.length);
    };
})(CryptoJS);


var IVstring = CryptoJS.lib.ByteArray(your IV bytearray).toString(CryptoJS.enc.Base64);
var keystring = CryptoJS.lib.ByteArray(your KEY bytearray).toString(CryptoJS.enc.Base64);
var text = 'texttobeencrypted';
var key = CryptoJS.enc.Base64.parse(keystring);
var iv  = CryptoJS.enc.Base64.parse(IVstring);
var encrypted = CryptoJS.AES.encrypt(text, key, {iv: iv});
console.log(encrypted.toString());
</code></pre>

<p><strong>Edited</strong>: Removed dangerous third party resource reference.</p>

<p><a href=""/questions/tagged/aes"" class=""post-tag"" title=""show questions tagged &#39;aes&#39;"" rel=""tag"">aes</a> <a href=""/questions/tagged/encryption"" class=""post-tag"" title=""show questions tagged &#39;encryption&#39;"" rel=""tag"">encryption</a> <a href=""/questions/tagged/javascript"" class=""post-tag"" title=""show questions tagged &#39;javascript&#39;"" rel=""tag"">javascript</a> <a href=""/questions/tagged/cryptojs"" class=""post-tag"" title=""show questions tagged &#39;cryptojs&#39;"" rel=""tag"">cryptojs</a> <a href=""/questions/tagged/java"" class=""post-tag"" title=""show questions tagged &#39;java&#39;"" rel=""tag"">java</a></p>
","723","<javascript><java><encryption><aes><cryptojs>","1","0","2","2019-07-12 13:02:04","","3","4","1816580","","2017-08-02 18:33:16","2017-08-02 13:34:15",""
"35900083","Php and cryptoJS IV","<p>I encrypt and decrypt data using PHP like this:</p>

<pre><code>&lt;?php 
function encrypt($data, $secret){
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    return base64_encode($iv.openssl_encrypt($data, 'aes-256-cbc', $secret, 0, $iv));
}

function decrypt($encryptedData, $secret){
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $data = base64_decode($encryptedData);
    $iv = substr($data, 0, $iv_size);
    return openssl_decrypt(substr($data, $iv_size), 'aes-256-cbc', $secret, 0, $iv);
}
?&gt;
</code></pre>

<p>I am now wanting to be able to encrypt my data locally (identically to the PHP method) using <a href=""https://code.google.com/archive/p/crypto-js/#AES"" rel=""nofollow"">Crypto-JS</a>. I have done the same as above to get the key and iv:</p>

<pre><code>var key = '&lt;?php echo $secret;?&gt;';
var iv = '&lt;?php echo base64_encode(mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND));?&gt;';
</code></pre>

<p>Now when using <a href=""https://code.google.com/archive/p/crypto-js/#AES"" rel=""nofollow"">Crypto-JS</a> I have tried to encrypt using:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), CryptoJS.enc.Hex.parse(key), { iv: CryptoJS.enc.Hex.parse(iv) });
</code></pre>

<p>But I also need to store the IV like I do with PHP So I have added:</p>

<pre><code>var withIV = iv+encrypted;
</code></pre>

<p>but that is not encoded. So I have added:</p>

<pre><code>CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(withIV));
</code></pre>

<p>But this is not the same encoding as the PHP above for some reason?</p>
","<p>Here's how I encrypt data with CryptoJS:</p>

<pre><code>function encrypt(str, key, iv) {
    var key = CryptoJS.enc.Hex.parse(key);
    var iv = CryptoJS.enc.Hex.parse(iv);
    return CryptoJS.AES.encrypt(str, key, { iv: iv }).toString();
};
</code></pre>

<p>In PHP, I decrypt the encrypted string produced by that function using this line of code:</p>

<pre><code>openssl_decrypt($encrypted_data_string, ""AES-128-CBC"", hex2bin($key_hex_string), 0, hex2bin($iv_hex_string));
</code></pre>

<p>I suppose you could encode/decode the encrypted data in base 64 instead of hexadecimal if you wanted to. Anyway, hope this helps!</p>
","717","<javascript><php><encryption><cryptojs>","1","0","2","2017-07-30 12:28:53","","4","","2768038","","2016-03-11 17:33:54","2016-03-09 18:47:39",""
"35900083","Php and cryptoJS IV","<p>I encrypt and decrypt data using PHP like this:</p>

<pre><code>&lt;?php 
function encrypt($data, $secret){
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);
    return base64_encode($iv.openssl_encrypt($data, 'aes-256-cbc', $secret, 0, $iv));
}

function decrypt($encryptedData, $secret){
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $data = base64_decode($encryptedData);
    $iv = substr($data, 0, $iv_size);
    return openssl_decrypt(substr($data, $iv_size), 'aes-256-cbc', $secret, 0, $iv);
}
?&gt;
</code></pre>

<p>I am now wanting to be able to encrypt my data locally (identically to the PHP method) using <a href=""https://code.google.com/archive/p/crypto-js/#AES"" rel=""nofollow"">Crypto-JS</a>. I have done the same as above to get the key and iv:</p>

<pre><code>var key = '&lt;?php echo $secret;?&gt;';
var iv = '&lt;?php echo base64_encode(mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND));?&gt;';
</code></pre>

<p>Now when using <a href=""https://code.google.com/archive/p/crypto-js/#AES"" rel=""nofollow"">Crypto-JS</a> I have tried to encrypt using:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), CryptoJS.enc.Hex.parse(key), { iv: CryptoJS.enc.Hex.parse(iv) });
</code></pre>

<p>But I also need to store the IV like I do with PHP So I have added:</p>

<pre><code>var withIV = iv+encrypted;
</code></pre>

<p>but that is not encoded. So I have added:</p>

<pre><code>CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(withIV));
</code></pre>

<p>But this is not the same encoding as the PHP above for some reason?</p>
","<p>It seems you have trouble concatenating IV and the ciphertext in CryptoJS. This is rather easy, because CryptoJS' native binary data format (<code>WordArray</code>) supports the <code>concat</code> function:</p>

<pre><code>var ivWords = CryptoJS.enc.Hex.parse(iv); // WordArray instance
var plaintext = CryptoJS.enc.Utf8.parse(text); // WordArray instance
var keyWords = CryptoJS.enc.Hex.parse(key); // WordArray instance
var encrypted = CryptoJS.AES.encrypt(plaintext, keyWords, { iv: ivWords }); // CipherParams instance

var ct = ivWords.clone().concat(encrypted.ciphertext); // WordArray instance
var ct = ct.toString(CryptoJS.enc.Base64); // string instance
console.log(ct);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// example data
var iv = ""0102030405060708090a0b0c0d0e0f"";
var text = ""text"";
var key = ""1112131415161718191a1b1c1d1e1f"";

// actual code
var ivWords = CryptoJS.enc.Hex.parse(iv); // WordArray instance
var plaintext = CryptoJS.enc.Utf8.parse(text); // WordArray instance
var keyWords = CryptoJS.enc.Hex.parse(key); // WordArray instance
var encrypted = CryptoJS.AES.encrypt(plaintext, keyWords, { iv: ivWords }); // CipherParams instance

var ct = ivWords.clone().concat(encrypted.ciphertext); // WordArray instance
var ct = ct.toString(CryptoJS.enc.Base64); // string instance
output.innerHTML = ct;</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;div id=""output""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>This would produce the same output as </p>

<pre><code>base64_encode($iv.openssl_encrypt($data, 'aes-256-cbc', $secret, 0, $iv));
</code></pre>

<p>as long as <code>iv</code> is actually hex-encoded string with that contains the same bytes as the decoded version in <code>$iv</code>. The same must be true for <code>text</code> (except for the encoding), <code>key</code> and <code>$data</code>, <code>$secret</code>, respectively.</p>
","717","<javascript><php><encryption><cryptojs>","1","0","2","2017-07-30 12:28:53","","4","","2768038","","2016-03-11 17:33:54","2016-03-09 18:47:39",""
"12783220","How do I make sure the data sent to WebService using jQuery AJAX is through my site and not some attack","<p>My Code:</p>

<pre><code> function HandleSignUp() {
    var CurrentURL = document.URL;
    var obj, val;
    //ajax call started
    $.ajax({
        type: ""POST"",
        url: ""../../webservice/GetAjaxDataWebService.asmx/RegisterNewUser"",
        data: ""{'UserFullName': '"" + $('#SignUpName').val() + ""','Email': '"" + $('#SignUpEmail').val() + ""','Password': '"" + $('#SignUpPassword').val() + ""'}"",
        contentType: ""application/json; charset=utf-8"",
        dataType: ""json"",
        success: function (msg) {
            //msg.d contains the return value from web service call
            $.colorbox.close();

            val = eval(msg);
            obj = jQuery.parseJSON(val.d);

            UpdateLogin(obj.Email, obj.FirstName);

        }
    });
    //ajax call ended
}
</code></pre>

<p>How do I make sure the data sent to WebService using jQuery AJAX is through my site and not some attack.</p>

<p>I have a similar ajax call for Login, where I pass userid and password to a webservice and authenticate. </p>

<p>Is there a way to have a one time request-response token to make sure its a valid web service call.</p>

<p>Let me know if my question is not clear.</p>
","<p>You could implement a lightweight MAC-ing mechanism  using a Hash Key (known only to you)</p>

<ol>
<li>Before each call to the webservice feed the first <code>n</code> bytes of your message payload to the hash key and compute a hash value.</li>
<li>Make the call to your webservice, sending the hash value in an http header (I recommend the <a href=""http://www.httpwatch.com/httpgallery/authentication/"" rel=""nofollow"">authorization header</a>, you can create a custom header tho.</li>
<li>In your webservice, before honouring any service request, you verify the authenticity of the message by computing the hashvalue using the same data i.e. the first N bytes and compare with the hash value in the authorization header. Honour the request only if the value checks out.</li>
</ol>

<p>There is a little processing overhead here and it assumes that the transmission is happening over a secure line, otherwise, the message could still be hijacked. But you solve the problem of bogus calls.</p>
","716","<web-services><jquery><security><cryptojs>","2","2","2","2012-10-11 06:46:55","12792698","2","0","1530938","","2012-10-11 06:46:55","2012-10-08 13:56:25",""
"12783220","How do I make sure the data sent to WebService using jQuery AJAX is through my site and not some attack","<p>My Code:</p>

<pre><code> function HandleSignUp() {
    var CurrentURL = document.URL;
    var obj, val;
    //ajax call started
    $.ajax({
        type: ""POST"",
        url: ""../../webservice/GetAjaxDataWebService.asmx/RegisterNewUser"",
        data: ""{'UserFullName': '"" + $('#SignUpName').val() + ""','Email': '"" + $('#SignUpEmail').val() + ""','Password': '"" + $('#SignUpPassword').val() + ""'}"",
        contentType: ""application/json; charset=utf-8"",
        dataType: ""json"",
        success: function (msg) {
            //msg.d contains the return value from web service call
            $.colorbox.close();

            val = eval(msg);
            obj = jQuery.parseJSON(val.d);

            UpdateLogin(obj.Email, obj.FirstName);

        }
    });
    //ajax call ended
}
</code></pre>

<p>How do I make sure the data sent to WebService using jQuery AJAX is through my site and not some attack.</p>

<p>I have a similar ajax call for Login, where I pass userid and password to a webservice and authenticate. </p>

<p>Is there a way to have a one time request-response token to make sure its a valid web service call.</p>

<p>Let me know if my question is not clear.</p>
","<p>Sessions might be the easiest solution to this problem, depending on your server framework.  </p>

<p>After a successful login, open a session on the server and set a value; check for the session value before processing any of your other web service APIs.</p>
","716","<web-services><jquery><security><cryptojs>","2","1","2","2012-10-11 06:46:55","12792698","2","0","1530938","","2012-10-11 06:46:55","2012-10-08 13:56:25",""
"39223938","Use js crypto frameworks or browser's Web Crypto API?","<p>I want to use encryption algorithms in browser. I see two ways to do that. First, using available javascript crypto frameworks like cryptojs, sjcl, etc. or the browser's inbuilt Web Crypto API. I am confused on which one is better. Can anyone please help me on this?</p>

<p>Thanks</p>
","<p>Because browsers are more integrated with the underlying system than any JavaScript library can be, they will provide a better guarantee of security (e.g. for random number generation).</p>
","716","<javascript><cryptojs><webcrypto-api>","0","3","1","2016-08-31 08:38:07","39227497","4","","1640234","","2016-08-31 08:38:07","2016-08-30 09:38:34",""
"42523928","how to get cryptojs to work with out ""rollup"" files","<p>I'm trying to upgrade the old version of cryptoJS that can be found <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow noreferrer"">here</a> to a newer version on github that can be found <a href=""https://github.com/brix/crypto-js/tree/develop/src"" rel=""nofollow noreferrer"">here</a> because, there are some functions on the old version that is going to be deprecated. Unfortunately, the newer don't have rollup files, so im trying to get it to work using the core files but, I keep getting the error(s) that something is ""undefined"" like ""<a href=""https://groups.google.com/forum/#!topic/crypto-js/0YBuugpJfNE"" rel=""nofollow noreferrer"">cfg.hasher is undefined</a>"".</p>

<pre><code>&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/core.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/evpkdf.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/x64-core.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/cipher-core.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/aes.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/pbkdf2.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/hmac.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/lib-typedarrays.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""crypto-js3.1.9-1/format-hex.js""&gt;&lt;/script&gt;
</code></pre>

<p>I tried adding all the core files and even changing the orders of them, but I think I'm still missing something.</p>

<p>If I use the rollup files, this simple code below works just fine on it, but it fail on the newer version. Hopefully someone with more experience with cryptoJS can help me out.</p>

<pre><code>&lt;script type=""text/javascript""&gt;
    var string = ""asdfasdfsadfdsa"";
    var key = ""asdfasfasfs"";
    var encrypted = CryptoJS.AES.encrypt(string, key);
    var decrypted = CryptoJS.AES.decrypt(encrypted, key);
    alert(decrypted);
&lt;/script&gt;
</code></pre>

<hr>

<p>UPDATE!! I can get SHA256 to work just fine with out uses of require.js so I don't thing the problem is Modular include and the lib should be able to run ""without RequireJS"", but I'm still running into encryption and decryption error: ""cfg.hasher is undefined"".</p>

<pre><code>&lt;script type=""text/javascript"" src=""CryptoJS/components/core.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""CryptoJS/components/sha256.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
    console.log(CryptoJS.SHA256(""Message""));
&lt;/script&gt;
</code></pre>
","<p>You would have to do modular includes </p>

<p>Modular include using require js:</p>

<pre><code>require.config({
    packages: [
        {
            name: 'crypto-js',
            location: 'path-to/bower_components/crypto-js',
            main: 'index'
        }
    ]
});

require([""crypto-js/aes"", ""crypto-js/sha256""], function (AES, SHA256) {
    console.log(SHA256(""Message""));
});
</code></pre>

<p><a href=""https://gist.github.com/janthony/b1cde9747d48c27b8e1c92ef461a8123"" rel=""nofollow noreferrer"">Here</a> is a full gist</p>
","714","<javascript><cryptojs>","1","1","1","2017-03-01 14:42:50","","0","","4592767","","2017-03-01 14:42:50","2017-03-01 05:31:38",""
"46480959","Coinbase GDAX NodeJS - Invalid API Key","<p>I'm trying to write a script that will cancel all my orders on GDAX. According to <a href=""https://docs.gdax.com/#cancel-an-order"" rel=""nofollow noreferrer"">the documentation for Cancel an Order</a> I need to send a DELETE request to /delete. But I assume before I can do that I need to <a href=""https://docs.gdax.com/#signing-a-message"" rel=""nofollow noreferrer"">sign the message</a> first.</p>

<p>When I submit the request using fetch in Node, I get this response: <strong>{ message: 'Invalid API Key' }</strong></p>

<p>Here is the a code sample I am working on, with the confidential stuff replaced of course:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var crypto = require('crypto');
var fetch = require('fetch');

const coinbaseSecret = 'abc...';
const coinbaseAPIKey = 'abc...';
const coinbasePassword = 'abc...';
const coinbaseRestAPIURL = ""https://api-public.sandbox.gdax.com"";

function start(){
	getTime(function(time){
		cancelAll(time, function(){
			console.log('done');
		});
	});
}

function getTime(callback){
	fetch.fetchUrl(coinbaseRestAPIURL + '/time', null, function(error, meta, body){
		var response = JSON.parse(body.toString());
		console.log('response', response);

		var timeStamp = response.epoch;
		callback(timeStamp);
	});
}

function cancelAll(timeStamp, callback) {
	// Refer to https://docs.gdax.com/#cancel-an-order

	var signature = getSignature('DELETE', '/delete', """");
	console.log('signature', signature);
	
	var headers = {
		'Content-Type': 'application/json',
		'CB-ACCESS-KEY': coinbaseAPIKey,
		'CB-ACCESS-SIGN': signature,
		'CB-ACCESS-TIMESTAMP': timeStamp, //Date.now() / 1000,
		'CB-ACCESS-PASSPHRASE': coinbasePassword
	};
	console.log('headers', headers);

	fetch.fetchUrl(coinbaseRestAPIURL + '/delete', {
		method: 'DELETE',
		headers: headers
	}, function(error, meta, body){
		var response = JSON.parse(body.toString());
		console.log('response', response);
		callback();
	})
}

function getSignature(method, requestPath, body) {
	// Refer to https://docs.gdax.com/#signing-a-message

	const secret = coinbaseSecret;
	const timestamp = Date.now() / 1000;
	const what = timestamp + method + requestPath + body;
	const key = Buffer(secret, 'base64');
	const hmac = crypto.createHmac('sha256', key);
	const signature = hmac.update(what).digest('base64');

	return signature;
}

start();</code></pre>
</div>
</div>
</p>
","<p>I got the same reject when using PHP call and tried several combination of the rights/IP whitelist when creating the key, no one works. </p>

<p>However the same code works for the sandbox so I think it might not be a problem in the code, unless, sandbox and live requires different header and that will be quite surprising. The sandbox does not work properly neither, the ticker endpoint returns constantly ""Internal server error"" at the moment I write this...</p>

<p>Not yet find a solution.</p>
","712","<node.js><fetch><cryptojs><coinbase-api><gdax-api>","0","0","2","2018-01-03 12:59:38","","0","","1965609","","2017-09-29 02:44:44","2017-09-29 02:36:17",""
"46480959","Coinbase GDAX NodeJS - Invalid API Key","<p>I'm trying to write a script that will cancel all my orders on GDAX. According to <a href=""https://docs.gdax.com/#cancel-an-order"" rel=""nofollow noreferrer"">the documentation for Cancel an Order</a> I need to send a DELETE request to /delete. But I assume before I can do that I need to <a href=""https://docs.gdax.com/#signing-a-message"" rel=""nofollow noreferrer"">sign the message</a> first.</p>

<p>When I submit the request using fetch in Node, I get this response: <strong>{ message: 'Invalid API Key' }</strong></p>

<p>Here is the a code sample I am working on, with the confidential stuff replaced of course:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var crypto = require('crypto');
var fetch = require('fetch');

const coinbaseSecret = 'abc...';
const coinbaseAPIKey = 'abc...';
const coinbasePassword = 'abc...';
const coinbaseRestAPIURL = ""https://api-public.sandbox.gdax.com"";

function start(){
	getTime(function(time){
		cancelAll(time, function(){
			console.log('done');
		});
	});
}

function getTime(callback){
	fetch.fetchUrl(coinbaseRestAPIURL + '/time', null, function(error, meta, body){
		var response = JSON.parse(body.toString());
		console.log('response', response);

		var timeStamp = response.epoch;
		callback(timeStamp);
	});
}

function cancelAll(timeStamp, callback) {
	// Refer to https://docs.gdax.com/#cancel-an-order

	var signature = getSignature('DELETE', '/delete', """");
	console.log('signature', signature);
	
	var headers = {
		'Content-Type': 'application/json',
		'CB-ACCESS-KEY': coinbaseAPIKey,
		'CB-ACCESS-SIGN': signature,
		'CB-ACCESS-TIMESTAMP': timeStamp, //Date.now() / 1000,
		'CB-ACCESS-PASSPHRASE': coinbasePassword
	};
	console.log('headers', headers);

	fetch.fetchUrl(coinbaseRestAPIURL + '/delete', {
		method: 'DELETE',
		headers: headers
	}, function(error, meta, body){
		var response = JSON.parse(body.toString());
		console.log('response', response);
		callback();
	})
}

function getSignature(method, requestPath, body) {
	// Refer to https://docs.gdax.com/#signing-a-message

	const secret = coinbaseSecret;
	const timestamp = Date.now() / 1000;
	const what = timestamp + method + requestPath + body;
	const key = Buffer(secret, 'base64');
	const hmac = crypto.createHmac('sha256', key);
	const signature = hmac.update(what).digest('base64');

	return signature;
}

start();</code></pre>
</div>
</div>
</p>
","<p>Go to the <a href=""https://github.com/coinbase/gdax-node"" rel=""nofollow noreferrer"">Gdax-Node Github repo</a> and take a look at their code and examples.</p>

<p>1) Create an authenticatedClient by configuring it with your api details,
2) Then simply use the authedClient object and calncelAllOrders method: </p>

<pre><code>authedClient.cancelAllOrders({product_id: 'BTC-USD'}, callback);
</code></pre>

<p>You could wrap this with a function to call 'x' amount of times (it states in the documentation), or you cold think of something fancier if you'd like.</p>

<p>Note:- make sure you pull the github repo and do not install from npm directly as there are a few bugs and issues that have been fixed on the git repo but NOT pushed to npm.</p>

<p>...so use <code>npm install coinbase/gdax-node</code> when downloading your gdax package.</p>

<p>Hope that helps a little...</p>
","712","<node.js><fetch><cryptojs><coinbase-api><gdax-api>","0","0","2","2018-01-03 12:59:38","","0","","1965609","","2017-09-29 02:44:44","2017-09-29 02:36:17",""
"42337852","CryptoJS - AES encryption performance to slow","<p>Im using this CryptoJs (<a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a> to) encryt data in Javascript (Decryption is later on done in .net backend)</p>

<p>I'm encrypting 5'000'000 records one by one with the following code: </p>

<pre><code>CryptoJS.AES.encrypt(field, encryptionParams.communicationKey, {
      iv: encryptionParams.communicationIV,
      mode: CryptoJS.mode.CBC,
});
</code></pre>

<p>It's way slower than expected (15 minutes)</p>

<p>Is there any performance boost possible? In my opinion it gets exponentially slower the higher the iteration count and sounds similar to that issue here: <a href=""https://code.google.com/archive/p/crypto-js/issues/65"" rel=""nofollow noreferrer"">https://code.google.com/archive/p/crypto-js/issues/65</a></p>

<p>I'm using chromium engine on electron.</p>
","","711","<javascript><performance><encryption><aes><cryptojs>","0","","0","2017-02-20 06:29:49","","7","1","","","","2017-02-20 06:29:49",""
"43027136","using cryptojs to generate RFC 2104-compliant HMAC with SHA256 algorithm","<p>im am following <a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow noreferrer"">this amazon documentation</a> in an attempt to find the algorithm to generate a signature in javascript. I cannot seem to get it to work.</p>

<pre><code>// html
// &lt;head&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/sha256.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/hmac.min.js""&gt;&lt;/script&gt;
// body (javascript)
var test_string = ""GET\nwebservices.amazon.com\n/onca/xml\nAWSAccessKeyId=AKIAIOSFODNN7EXAMPLE&amp;AssociateTag=mytag-20&amp;ItemId=0679722769&amp;Operation=ItemLookup&amp;ResponseGroup=Images%2CItemAttributes%2COffers%2CReviews&amp;Service=AWSECommerceService&amp;Timestamp=2014-08-18T12%3A00%3A00Z&amp;Version=2013-08-01""

var signature2 = CryptoJS.HmacSHA256(test_string, ""1234567890"");
console.log(signature2.toString());
</code></pre>

<p>I amd getting <code>8fb6d93342d767d797799aee4ea5a6d8322f0d8554537c313cfa69fa25f1cd07</code></p>

<p>I should be getting <code>j7bZM0LXZ9eXeZruTqWm2DIvDYVUU3wxPPpp+iXxzQc=</code></p>

<p>Hmmm anyone knows whats wrong?</p>
","<p>There's nothing wrong, it's just that the string you got represents an array of bytes (with their hex representation). So all you need to do is Base 64 encode this array of bytes and you will get the exact same result. Checkout it out here, paste your hex represented byte array and base 64 encode it: <a href=""http://tomeko.net/online_tools/hex_to_base64.php?lang=en"" rel=""nofollow noreferrer"">http://tomeko.net/online_tools/hex_to_base64.php?lang=en</a></p>

<p>As far as how this can be done, well, you may have a look at <a href=""https://stackoverflow.com/questions/23190056/hex-to-base64-converter-for-javascript"">this question</a> or <a href=""https://stackoverflow.com/questions/30613897/converting-a-hexadecimal-string-to-base64-in-javascript"">this one</a>.</p>

<hr>

<p>UPDATE:</p>

<p>As pointed out in the comments it seems that there's a built-in way in cryptojs to convert directly to base64:</p>

<pre><code>console.log(signature2.toString(CryptoJS.enc.Base64));
</code></pre>
","710","<javascript><amazon-web-services><cryptojs>","1","2","2","2017-08-01 00:12:39","43027167","0","","","","","2017-03-26 09:33:11",""
"43027136","using cryptojs to generate RFC 2104-compliant HMAC with SHA256 algorithm","<p>im am following <a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow noreferrer"">this amazon documentation</a> in an attempt to find the algorithm to generate a signature in javascript. I cannot seem to get it to work.</p>

<pre><code>// html
// &lt;head&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/sha256.min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/hmac.min.js""&gt;&lt;/script&gt;
// body (javascript)
var test_string = ""GET\nwebservices.amazon.com\n/onca/xml\nAWSAccessKeyId=AKIAIOSFODNN7EXAMPLE&amp;AssociateTag=mytag-20&amp;ItemId=0679722769&amp;Operation=ItemLookup&amp;ResponseGroup=Images%2CItemAttributes%2COffers%2CReviews&amp;Service=AWSECommerceService&amp;Timestamp=2014-08-18T12%3A00%3A00Z&amp;Version=2013-08-01""

var signature2 = CryptoJS.HmacSHA256(test_string, ""1234567890"");
console.log(signature2.toString());
</code></pre>

<p>I amd getting <code>8fb6d93342d767d797799aee4ea5a6d8322f0d8554537c313cfa69fa25f1cd07</code></p>

<p>I should be getting <code>j7bZM0LXZ9eXeZruTqWm2DIvDYVUU3wxPPpp+iXxzQc=</code></p>

<p>Hmmm anyone knows whats wrong?</p>
","<pre><code> let hash = CryptoJS.HmacSHA256(message, secret_key);
 let result = CryptoJS.enc.Base64.stringify(hash);
</code></pre>

<p>I'm posting this solution here since I'm trying to do this exact same exercise in ReactNative, and ReactNative doesn't like npm's base crypto package. CryptoJS works as a replacement. </p>

<p>NOTE: (this was infuriating) I had to get rid of the first \n, though Amazon specifically tells you to prepend the lines with breaks and the GET has a line space above it in their example.. </p>

<p><em>FULL SOLUTION:</em></p>

<pre><code> let secret_key = ""1234567890"";
 let message = 'GET' +
 '\nwebservices.amazon.com' +
 '\n/onca/xml' +
 '\nAWSAccessKeyId=AKIAIOSFODNN7EXAMPLE&amp;AssociateTag=mytag-20&amp;ItemId=0679722769&amp;Operation=ItemLookup&amp;ResponseGroup=Images%2CItemAttributes%2COffers%2CReviews&amp;Service=AWSECommerceService&amp;Timestamp=2014-08-18T12%3A00%3A00Z&amp;Version=2013-08-01'

 let hash = CryptoJS.HmacSHA256(message, secret_key);
 let result = CryptoJS.enc.Base64.stringify(hash);
 console.log('MARK: RESULT ', result);
</code></pre>
","710","<javascript><amazon-web-services><cryptojs>","1","1","2","2017-08-01 00:12:39","43027167","0","","","","","2017-03-26 09:33:11",""
"16739229","Saving CryptoJS's CryptoMD5 state as a string and restoring it later","<p>I gradually compute the MD5 hash of a large file, during an upload, then at some point I want to save to HTML5 <code>localStorage</code> what I have calculated so far, to be able to resume later.</p>

<p>From what I know, <code>localStorage</code> can store strings, so I have to store the progressive MD5 value as a string and then restore them, when the user opens the browser at a later time.</p>

<p>Basically my code looks like this:</p>

<pre><code>var md5_full = CryptoJS.algo.MD5.create();

var wordArray = CryptoJS.lib.WordArray.create(chunk);

md5_full.update(wordArray);
</code></pre>

<p>At this point, I want to convert <code>md5_full</code> to a string, to be able to save to <code>localStorage</code>. And then, at a later time, when the user wants to resume the upload, to be able to retrieve the <code>md5_full</code> from <code>localStorage</code>, unstringify, and continue to update it with chunks.</p>

<p>In the end I should be able to call <code>md5_full.finalize();</code> to get the final full MD5 hash digest.</p>
","<p>I think the problem may be with function serialization - CryoJS apparently attempts to serialize functions but it may not restore references correctly (the scope is lost). </p>

<p>The code below circumvents this problem by restoring only data, not functions. <a href=""http://jsfiddle.net/RC3Vv/"" rel=""nofollow"">JSFiddle</a>.</p>

<p>(De)serialization functions:</p>

<pre><code>/** Serialize MD5 object. */
function stringify_md5(md5) {
    return JSON.stringify(md5);
}

/** Deserialize MD5 object. */
function parse_md5(serialized_md5) {
    var md5 = CryptoJS.algo.MD5.create();
    restore_data(JSON.parse(serialized_md5), md5);
    return md5;    
}

/** Recursively copy properties from object source to object target. */
function restore_data(source, target) {
    for (var prop in source) {
        var value = source[prop];
        if (typeof value == ""object"") {
            if (typeof target[prop] != ""object"") {
                target[prop] = {};
            }
            restore_data(source[prop], target[prop]);
        } else {
            target[prop] = source[prop];
        }
    }
}
</code></pre>

<p>Example of usage:</p>

<pre><code>var chunk1 = ""abc"", chunk2 = ""def"";

// The correct hash:
var md5_full_1 = CryptoJS.algo.MD5.create();
md5_full_1.update(chunk1);
md5_full_1.update(chunk2);
var correct_hash = md5_full_1.finalize();

// Using stringify/parse
var md5_full_2 = CryptoJS.algo.MD5.create();
md5_full_2.update(chunk1);
var md5_serialized = stringify_md5(md5_full_2); // serialize
md5_full_2 = parse_md5(md5_serialized);  // deserialize
md5_full_2.update(chunk2);
var result_hash = md5_full_2.finalize();

alert(correct_hash.toString() == result_hash.toString()); // true
</code></pre>

<p>(<em>Using WordArray threw me an error in CryptoJS for some reason</em>)</p>
","707","<javascript><cryptojs>","5","4","1","2013-05-30 19:18:43","16844198","2","","1114","","2013-05-24 16:11:34","2013-05-24 16:06:36",""
"39953420","ionic 2 build android cryptojs","<p>I'm newbie with Ionic2. I've started developing in the browser
I had many problems to intall the module 'crypto-js' and use it, but finally I got it.</p>

<p>Now I've installed the android platform in the project and now I get this error at building time:</p>

<pre><code>[09:20:04]  ionic-app-scripts 0.0.30
[09:20:04]  build prod started ...
[09:20:04]  clean started ...
[09:20:04]  clean finished in 26 ms
[09:20:04]  copy started ...
[09:20:04]  ngc started ...
[09:20:04]  lint started ...
[09:20:04]  copy finished in 226 ms
[09:20:05]  lint finished in 1.14 s
[09:20:23]  ngc: Error: Error at C:/cygwin/home/SEDI/mobile/ionic2/papp/.tmp/app/plrt-connections/plrt-connections.ts:6:27: Cannot find module 'crypto-js'.
Error at C:/cygwin/home/SEDI/mobile/ionic2/papp/.tmp/app/plrt-connections/plrt-connections.ts:19:9: Return type of public method from exported class has or is using name 'Observable' from external module ""C:/cygwin/home/SEDI/mobile/ionic2/papp/node_modules/rxjs/Observable"" but cannot be named.
    at check (C:\cygwin\home\SEDI\mobile\ionic2\papp\node_modules\@angular\tsc-wrapped\src\tsc.js:31:15)
    at Tsc.typeCheck (C:\cygwin\home\SEDI\mobile\ionic2\papp\node_modules\@angular\tsc-wrapped\src\tsc.js:86:9)
    at C:\cygwin\home\SEDI\mobile\ionic2\papp\node_modules\@angular\tsc-wrapped\src\main.js:33:23
    at process._tickCallback (internal/process/next_tick.js:103:7)
    at Function.Module.runMain (module.js:449:11)
    at startup (node.js:146:18)
    at node.js:404:3


[09:20:23]  ngc: Compilation failed


[09:20:23]  ngc failed:  NGC encountered an error
[09:20:23]  Error: NGC encountered an error
    at ChildProcess.&lt;anonymous&gt; (C:\cygwin\home\SEDI\mobile\ionic2\papp\node_modules\@ionic\app-scripts\dist\ngc.js:62:24)
    at emitTwo (events.js:100:13)
    at ChildProcess.emit (events.js:185:7)
    at ChildProcess.cp.emit (C:\cygwin\home\SEDI\mobile\ionic2\papp\node_modules\cross-spawn\lib\enoent.js:40:29)
    at maybeClose (internal/child_process.js:850:16)
    at Socket.&lt;anonymous&gt; (internal/child_process.js:323:11)
    at emitOne (events.js:90:13)
    at Socket.emit (events.js:182:7)
    at Pipe._onclose (net.js:475:12)
Error running ionic app script ""build"": Error: NGC encountered an error
</code></pre>

<p>This error only shows after run ""ionic build android"" or ""ionic run android"", but It's ok with ""ionic serve"". I've googled but i didn't find anybody with this problem with crypto-js or another module.</p>

<p>packages.json:</p>

<pre><code>{
  ""name"": ""papp"",
  ""author"": ""Ionic Framework"",
  ""homepage"": ""http://ionicframework.com/"",
  ""private"": true,
  ""scripts"": {
    ""build"": ""ionic-app-scripts build"",
    ""watch"": ""ionic-app-scripts watch"",
    ""serve:before"": ""watch"",
    ""emulate:before"": ""build"",
    ""deploy:before"": ""build"",
    ""build:before"": ""build"",
    ""run:before"": ""build""
  },
  ""dependencies"": {
    ""@ionic/storage"": ""^1.0.3"",
    ""crypto-js"": ""^3.1.6"",
    ""ionic-angular"": ""^2.0.0-rc.0"",
    ""ionic-native"": ""^2.0.3"",
    ""ionicons"": ""^3.0.0"",
    ""ng2-translate"": ""^3.1.0"",
    ""@ionic/app-scripts"": ""latest"",
    ""typescript"": ""^2.0.3""
  },
  ""devDependencies"": {

  },
  ""description"": ""papp: An Ionic project"",
  ""cordovaPlugins"": [
    ""cordova-plugin-device"",
    ""cordova-plugin-console"",
    ""cordova-plugin-whitelist"",
    ""cordova-plugin-splashscreen"",
    ""cordova-plugin-statusbar"",
    ""ionic-plugin-keyboard""
  ],
  ""cordovaPlatforms"": []
}
</code></pre>

<p>Don't hesitate to ask me more information and thanks in advance.</p>
","","705","<android><cordova><ionic2><cryptojs>","1","","0","2018-08-03 06:14:15","","0","","","","","2016-10-10 07:42:37",""
"37729038","Webpack and Loading custom scripts","<p>For the life of me I dont understand how webpack works. Please can somebody help me. Im going to explain with my situation but its actually more of a conceptual question of how to go about using webpack</p>

<p>So im working on an angular 2 project with a webpack starter. I have some js scripts that i got from AWS (my SDK for API-Gateway). Its about 10 js files. Currently i have those 10 files listed in my index.html, and that works great. Obviously this isnt actually great because that means 10 round trips to the server to collect them. So hence my journey into trying to get webpack to include them in a bundle starts</p>

<p>So what i tried to do was to import the files one by one in my main typescript file. The file where my app gets bootstrapped. Just like this for example:</p>

<pre><code>import 'assets/aws-sdk/lib/axios/dist/axios.standalone.js';
import 'assets/aws-sdk/lib/CryptoJS/rollups/hmac-sha256.js';
import 'assets/aws-sdk/lib/CryptoJS/rollups/sha256.js';
...
</code></pre>

<p>Is this even remotely the right thing to do. This doesnt work. It complains about CryptoJS not being available in the files that require it. There are some crypto-js files in those that i bring in, and the files that use the variable 'CryptoJS' dont seem to see it.</p>

<p>I found in my webpack config a ProvidePlugin that seems to load jquery like this</p>

<pre><code>new webpack.ProvidePlugin({
  jQuery: 'jquery',
  $: 'jquery',
  /*CryptoJS: 'CryptoJS'*/
}),
</code></pre>

<p>So i added Crypto thinking it needs that. Doesnt work. </p>

<p>My question is this. The js files i need to use internally use a variable called CryptoJS to do things like this:</p>

<pre><code>function hash(value) {
   return CryptoJS.SHA256(value);
}
</code></pre>

<p>That works fine including all the scripts in index.html, but how do i get my webpack app to understand what that means. How do i import and bundle these files, and how do i use a varable internal to those files like CryptoJS.</p>
","<p>Okay nevermind after hours of struggling i managed to figure it out. The import i was doing was wrong, to add the js files to the global space (equivalent of adding them to the index.html) is to import them like so</p>

<pre><code>require('script!./assets/aws-sdk/lib/axios/dist/axios.standalone.js');
</code></pre>

<p>That script loader does the magic. Youll need that in your project as well can be installed from npm</p>
","701","<angular><webpack><cryptojs>","1","2","1","2016-06-09 16:24:22","","0","","","","","2016-06-09 14:39:20",""
"29572158","json_decode returns NULL after the json string was decrypted with mcrypt_decrypt (aes)","<p>I want to send the ""message"" to php as json data. But The ""message"" has to be a String. If I ""stringfy"" my json data in Javascript and encrypt them with ""CryptoJS.AES.encrypt"", I cannot get the single contents in PHP because ""json_decode"" always returns NULL.<br><br>I have used ""json_last_error"" and it returned 3. When I encode it with ""utf8_encode"" and json_encode them, it returns 0.  <br><br>""mcrypt_decrypt"" is the PHP AES-decryptor.<br><br>
I really don't know what to do. Please help me and thanks in advance!<br><br></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//JAVASCRIPT
    var encrypted = CryptoJS.AES.encrypt(
        JSON.stringfy({'message':'message','messageA':'messageA','messageB':'messageB'}),
        key512Bits500Iterations, {iv:iv});

    var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
    var iv_base64 = encrypted.iv.toString(CryptoJS.enc.Base64);
    var key_base64 = encrypted.key.toString(CryptoJS.enc.Base64);

    $.ajax({
		url: 'http://localhost/workspace/messageAppl.php',
		type: 'POST',
		data: {
          'data_base64':data_base64,
          'iv_base64':iv_base64,
          'key_base64':key_base64 //key_base64 will be encrypted with RSA
		},
    	success: function(data){
        	alert(data);
        },
        error: function(){
          alert('Index-Error');
    	}	
    });

//    PHP

    // I can get the jsonString but I can't get the single message like 'message', 'messageA' or 'messageB'
         ...
         
     //Decryption in PHP
         public function jsMessage($data_base64, $iv_base64, $key_base64){
			$data_enc = base64_decode($data_base64); // data_base64 from JS
			$iv        = base64_decode($iv_base64);   // iv_base64 from JS
			$key       = base64_decode($key_base64);  // key_base64 from JS
		
			$plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $key, $data_enc, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );
			return $plaintext;
		}

         
    $json_string = aes_decrypt($_POST['data_base64'], $_POST['iv_base64'], $_POST['key_base64']);


    // json_decode returns NULL but WHY?
    $array=json_decode($json_string);

    $message=$array-&gt;message
    $messageA=$array-&gt;messageA
    $messageB=$array-&gt;messageB</code></pre>
</div>
</div>
</p>

<pre><code>**Edit 1**
The error message I get is:
**""Control character error, possibly incorrectly encoded""**

but the Json which I get in php after the decryption is valid:
{""message"":""blablabalbalbalaballab"",""messageA"":""blablabalbalbalaballab"" ,""messageB"":""blablabalbalbalaballab""}
</code></pre>

<p>and to be sure I'have tested the json again and again <a href=""http://codebeautify.org/jsonviewer"" rel=""nofollow noreferrer"">here</a><br><br><br><br>
**Edit 2 **<br><br>
<img src=""https://i.stack.imgur.com/g0BCa.png"" alt=""""><br><br>
I cannot post it with these signs that's the reason I've made a photo.</p>
","<p>It looks like you are base64 encoding the encrypted json string. However you are not base64 decoding it in your PHP example before you attempt to decrypt.</p>

<p>Also if your decrypt function is <a href=""https://php.net/manual/en/function.mcrypt-decrypt.php"" rel=""nofollow"">mcrypt_decrypt</a> then you are passing the parameters wrong, it needs to be mcrypt_decrypt($cipher, $key, $data, $mode, $iv).</p>

<p>Edit: more info</p>

<p>It also appears that you are base64 encoding the other values you pass in your ajax call but don't decode them on php side in your example, will need to do thast as well.</p>
","699","<php><json><cryptojs>","0","0","3","2015-09-19 12:01:12","","9","","3402221","","2015-04-11 23:46:47","2015-04-10 23:25:05",""
"29572158","json_decode returns NULL after the json string was decrypted with mcrypt_decrypt (aes)","<p>I want to send the ""message"" to php as json data. But The ""message"" has to be a String. If I ""stringfy"" my json data in Javascript and encrypt them with ""CryptoJS.AES.encrypt"", I cannot get the single contents in PHP because ""json_decode"" always returns NULL.<br><br>I have used ""json_last_error"" and it returned 3. When I encode it with ""utf8_encode"" and json_encode them, it returns 0.  <br><br>""mcrypt_decrypt"" is the PHP AES-decryptor.<br><br>
I really don't know what to do. Please help me and thanks in advance!<br><br></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//JAVASCRIPT
    var encrypted = CryptoJS.AES.encrypt(
        JSON.stringfy({'message':'message','messageA':'messageA','messageB':'messageB'}),
        key512Bits500Iterations, {iv:iv});

    var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
    var iv_base64 = encrypted.iv.toString(CryptoJS.enc.Base64);
    var key_base64 = encrypted.key.toString(CryptoJS.enc.Base64);

    $.ajax({
		url: 'http://localhost/workspace/messageAppl.php',
		type: 'POST',
		data: {
          'data_base64':data_base64,
          'iv_base64':iv_base64,
          'key_base64':key_base64 //key_base64 will be encrypted with RSA
		},
    	success: function(data){
        	alert(data);
        },
        error: function(){
          alert('Index-Error');
    	}	
    });

//    PHP

    // I can get the jsonString but I can't get the single message like 'message', 'messageA' or 'messageB'
         ...
         
     //Decryption in PHP
         public function jsMessage($data_base64, $iv_base64, $key_base64){
			$data_enc = base64_decode($data_base64); // data_base64 from JS
			$iv        = base64_decode($iv_base64);   // iv_base64 from JS
			$key       = base64_decode($key_base64);  // key_base64 from JS
		
			$plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $key, $data_enc, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );
			return $plaintext;
		}

         
    $json_string = aes_decrypt($_POST['data_base64'], $_POST['iv_base64'], $_POST['key_base64']);


    // json_decode returns NULL but WHY?
    $array=json_decode($json_string);

    $message=$array-&gt;message
    $messageA=$array-&gt;messageA
    $messageB=$array-&gt;messageB</code></pre>
</div>
</div>
</p>

<pre><code>**Edit 1**
The error message I get is:
**""Control character error, possibly incorrectly encoded""**

but the Json which I get in php after the decryption is valid:
{""message"":""blablabalbalbalaballab"",""messageA"":""blablabalbalbalaballab"" ,""messageB"":""blablabalbalbalaballab""}
</code></pre>

<p>and to be sure I'have tested the json again and again <a href=""http://codebeautify.org/jsonviewer"" rel=""nofollow noreferrer"">here</a><br><br><br><br>
**Edit 2 **<br><br>
<img src=""https://i.stack.imgur.com/g0BCa.png"" alt=""""><br><br>
I cannot post it with these signs that's the reason I've made a photo.</p>
","<p><strong>Explanation</strong><br>
Scenario: In JS I encrypt the jsonString with cryptojs. In PHP I decrypt it with ""mcrypt_decrypt"".<br>
But the JsonString which I get in php after the decryption has some funny characters in the end.<br> I can only see these characters if I copy the output of var_dump() and paste it to the IDE (i.e. notepad++, eclipse, etc.).<br><br>
These characters are always 12. I do not know where they come from (Maybe while the message is encrypted or decrypted), but after ""substring"" them, I can get a valid jsonString for ""json_decode()"".
<br><br>
<strong>solution</strong><br>
I just substring the 12 invisible characters after the last curly bracket and <strong>it works</strong>. I hope it helps someone.<br></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>json_decode(substr( $json, 0, strlen( $jsonString)-12));</code></pre>
</div>
</div>

<br><br>
<strong>EDIT</strong><br><br> <strong>Better use this:</strong><br></p>

<pre><code>$strPad = ord($json[strlen($json)-1]);
$n_data = substr($json, 0, -$strPad); 
$row=json_decode($n_data );
</code></pre>

<p><strong>than</strong><br></p>

<pre><code>json_decode(substr( $json, 0, strlen( $jsonString)-12));
</code></pre>

<p>So You don't need to count the points you have to delete like I did.</p>
","699","<php><json><cryptojs>","0","-1","3","2015-09-19 12:01:12","","9","","3402221","","2015-04-11 23:46:47","2015-04-10 23:25:05",""
"29572158","json_decode returns NULL after the json string was decrypted with mcrypt_decrypt (aes)","<p>I want to send the ""message"" to php as json data. But The ""message"" has to be a String. If I ""stringfy"" my json data in Javascript and encrypt them with ""CryptoJS.AES.encrypt"", I cannot get the single contents in PHP because ""json_decode"" always returns NULL.<br><br>I have used ""json_last_error"" and it returned 3. When I encode it with ""utf8_encode"" and json_encode them, it returns 0.  <br><br>""mcrypt_decrypt"" is the PHP AES-decryptor.<br><br>
I really don't know what to do. Please help me and thanks in advance!<br><br></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>//JAVASCRIPT
    var encrypted = CryptoJS.AES.encrypt(
        JSON.stringfy({'message':'message','messageA':'messageA','messageB':'messageB'}),
        key512Bits500Iterations, {iv:iv});

    var data_base64 = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
    var iv_base64 = encrypted.iv.toString(CryptoJS.enc.Base64);
    var key_base64 = encrypted.key.toString(CryptoJS.enc.Base64);

    $.ajax({
		url: 'http://localhost/workspace/messageAppl.php',
		type: 'POST',
		data: {
          'data_base64':data_base64,
          'iv_base64':iv_base64,
          'key_base64':key_base64 //key_base64 will be encrypted with RSA
		},
    	success: function(data){
        	alert(data);
        },
        error: function(){
          alert('Index-Error');
    	}	
    });

//    PHP

    // I can get the jsonString but I can't get the single message like 'message', 'messageA' or 'messageB'
         ...
         
     //Decryption in PHP
         public function jsMessage($data_base64, $iv_base64, $key_base64){
			$data_enc = base64_decode($data_base64); // data_base64 from JS
			$iv        = base64_decode($iv_base64);   // iv_base64 from JS
			$key       = base64_decode($key_base64);  // key_base64 from JS
		
			$plaintext = rtrim( mcrypt_decrypt( MCRYPT_RIJNDAEL_128, $key, $data_enc, MCRYPT_MODE_CBC, $iv ), ""\t\0 "" );
			return $plaintext;
		}

         
    $json_string = aes_decrypt($_POST['data_base64'], $_POST['iv_base64'], $_POST['key_base64']);


    // json_decode returns NULL but WHY?
    $array=json_decode($json_string);

    $message=$array-&gt;message
    $messageA=$array-&gt;messageA
    $messageB=$array-&gt;messageB</code></pre>
</div>
</div>
</p>

<pre><code>**Edit 1**
The error message I get is:
**""Control character error, possibly incorrectly encoded""**

but the Json which I get in php after the decryption is valid:
{""message"":""blablabalbalbalaballab"",""messageA"":""blablabalbalbalaballab"" ,""messageB"":""blablabalbalbalaballab""}
</code></pre>

<p>and to be sure I'have tested the json again and again <a href=""http://codebeautify.org/jsonviewer"" rel=""nofollow noreferrer"">here</a><br><br><br><br>
**Edit 2 **<br><br>
<img src=""https://i.stack.imgur.com/g0BCa.png"" alt=""""><br><br>
I cannot post it with these signs that's the reason I've made a photo.</p>
","<p><a href=""https://secure.php.net/manual/en/function.mcrypt-decrypt.php"" rel=""nofollow"">the user notes on mcrypt_decrypt()</a> has the answer</p>

<blockquote>
  <p>It appears that mcrypt_decrypt pads the <em>RETURN STRING</em> with nulls ('\0') to fill out to n * blocksize</p>
</blockquote>

<pre><code>$json = rtrim($json, ""\0"");
</code></pre>
","699","<php><json><cryptojs>","0","1","3","2015-09-19 12:01:12","","9","","3402221","","2015-04-11 23:46:47","2015-04-10 23:25:05",""
"14268833","how to recreate the .net membership hmacsha1 hash in javascript","<p>I'm trying to reproduce the same hmacsha1 hash and base64 encoding from .net membership provider in a javascript function.  I've tried using crypto-js and am getting different results.  The .net code will hash ""test"" into ""W477AMlLwwJQeAGlPZKiEILr8TA=""</p>

<p>Here's the .net code</p>

<pre><code>string password = ""test"";
HMACSHA1 hash = new HMACSHA1();
hash.Key = Encoding.Unicode.GetBytes(password);
string encodedPassword = Convert.ToBase64String(hash.ComputeHash(Encoding.Unicode.GetBytes(password)));
</code></pre>

<p>And here's the javascript method I tried using crypto-js that does not produce the same output</p>

<pre><code>var hash = CryptoJS.HmacSHA1(""test"", """");
var encodedPassword = CryptoJS.enc.Base64.stringify(hash);
</code></pre>

<p>How can I get my javascript hash to match the hash being generated from .net.</p>
","<p>You don't specify a key in .NET:</p>

<pre><code>var secretKey = """";
var password = ""test"";

var enc = Encoding.ASCII;
System.Security.Cryptography.HMACSHA1 hmac = new System.Security.Cryptography.HMACSHA1(enc.GetBytes(secretKey));
hmac.Initialize();

byte[] buffer = enc.GetBytes(password);
var encodedPassword = Convert.ToBase64String(hmac.ComputeHash(buffer));
</code></pre>

<p>Edit: as @Andreas mentioned, your problem is the encoding. So you just need to replace UTF by ANSI in your own code:</p>

<pre><code>string password = ""test"";
System.Security.Cryptography.HMACSHA1 hash = new System.Security.Cryptography.HMACSHA1();
hash.Key = Encoding.ASCII.GetBytes("""");
string encodedPassword = Convert.ToBase64String(hash.ComputeHash(Encoding.ASCII.GetBytes(password)));   
</code></pre>
","698","<javascript><hash><asp.net-membership><cryptojs>","1","0","2","2013-01-11 02:22:16","14270666","0","","","","","2013-01-10 22:59:44",""
"14268833","how to recreate the .net membership hmacsha1 hash in javascript","<p>I'm trying to reproduce the same hmacsha1 hash and base64 encoding from .net membership provider in a javascript function.  I've tried using crypto-js and am getting different results.  The .net code will hash ""test"" into ""W477AMlLwwJQeAGlPZKiEILr8TA=""</p>

<p>Here's the .net code</p>

<pre><code>string password = ""test"";
HMACSHA1 hash = new HMACSHA1();
hash.Key = Encoding.Unicode.GetBytes(password);
string encodedPassword = Convert.ToBase64String(hash.ComputeHash(Encoding.Unicode.GetBytes(password)));
</code></pre>

<p>And here's the javascript method I tried using crypto-js that does not produce the same output</p>

<pre><code>var hash = CryptoJS.HmacSHA1(""test"", """");
var encodedPassword = CryptoJS.enc.Base64.stringify(hash);
</code></pre>

<p>How can I get my javascript hash to match the hash being generated from .net.</p>
","<pre><code>//not sure why crypt-js's utf16LE function doesn't give the same result
//words = CryptoJS.enc.Utf16LE.parse(""test"");
//utf16 = CryptoJS.enc.Utf16LE.stringify(""test"");

function str2rstr_utf16le(input) {
  var output = [],
      i = 0,
      l = input.length;

  for (; l &gt; i; ++i) {
    output[i] = String.fromCharCode(
      input.charCodeAt(i)        &amp; 0xFF,
      (input.charCodeAt(i) &gt;&gt;&gt; 8) &amp; 0xFF
    );
  }

  return output.join('');
}

var pwd = str2rstr_utf16le(""test"");
var hash = CryptoJS.HmacSHA1(pwd, pwd);

var encodedPassword = CryptoJS.enc.Base64.stringify(hash);
alert(encodedPassword);
</code></pre>
","698","<javascript><hash><asp.net-membership><cryptojs>","1","1","2","2013-01-11 02:22:16","14270666","0","","","","","2013-01-10 22:59:44",""
"50492082","Encrypt and decrypt video file in JavaScript using CryptoJS","<p>I would like to know how to encrypt and decrypt a video file with JavaScript. I have tried to do it with the Crypto-js library but I can't reproduce it after decrypting it. In the following code I try to take the input video to encrypt it and after decrypting it play it from HTML and download the file:</p>

<pre><code> input.on('change', function (e) {
      let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = function () {
        let fileLeida = reader.result;
        let videoEncriptado = CryptoJS.AES.encrypt(fileLeida, getCookie('clave')).toString();
        let videoDesencriptado = CryptoJS.AES.decrypt(videoEncriptado, getCookie('clave')).toString(CryptoJS.enc.Utf8);
        var videoNode = document.getElementsByTagName('video')[0];
        let blob = new Blob([videoDesencriptado], {type: ""video/mp4""});
        let url = URL.createObjectURL(blob);
        let element = document.createElement('a');
        videoNode.setAttribute('href', url);
        videoNode.play();
        element.setAttribute('href', url);
        element.setAttribute('download', 'Blurred Bokeh Video 2.mp4');
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);

      };
      reader.readAsText(file);
});
</code></pre>

<p>Thank you in advance. </p>

<hr>

<p>Code updated but still not working:</p>

<pre><code>let file = e.target.files[0];
      let reader = new FileReader();
      reader.onload = function () {
        var fileLeida = CryptoJS.lib.WordArray.create(reader.result);
        console.log(fileLeida);
        let videoEncriptado = CryptoJS.AES.encrypt(fileLeida, getCookie('clave'));
        let videoDesencriptado = CryptoJS.AES.decrypt(videoEncriptado, getCookie('clave'));
        console.log(videoDesencriptado);
        var videoNode = document.getElementsByTagName('video')[0];
        let blob = new Blob([videoDesencriptado], {type: ""video/mp4""});
        let url = URL.createObjectURL(blob);
        let element = document.createElement('a');
        videoNode.setAttribute('href', url);
        videoNode.play();
        element.setAttribute('href', url);
        element.setAttribute('download', 'Blurred Bokeh Video 2.mp4');
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);

      };
    reader.readAsArrayBuffer(file);
</code></pre>
","<p>You can't convert binary data to a string because it is inherently not a string...  Anywhere in your code that you have <code>toString</code> is a mistake.</p>

<p>Your video file is binary data that is in video format.  Not in UTF8 format.  Why you are trying to build a string out of it is beyond me.</p>
","694","<javascript><encryption><html5-video><aes><cryptojs>","1","0","1","2018-05-24 10:45:59","","0","","6304714","","2018-05-24 10:45:59","2018-05-23 15:22:06",""
"51157821","AES decryption returning empty string","<p>Hello i'm trying to encrypt and decrypt files (in Uint8Array format) using CryptoJS Library (3.1.2)
This is my code:</p>

<pre><code>var WPAES = {
    keySize: 256,
    ivSize: 128,
    saltSize: 128,
    iterations:1000,
    encrypt: function(data,passphrase)
    {
        try
        {
            var iv = CryptoJS.lib.WordArray.random(this.ivSize/8);
            console.log(iv.toString());
            var salt = CryptoJS.lib.WordArray.random(this.saltSize/8);
            console.log(salt.toString());

            var key = CryptoJS.PBKDF2(passphrase, salt, {
              keySize: this.keySize/32,
              iterations: this.iterations
            });
            var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.u8array.parse(data), key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC

            });

            var encryptedIv = CryptoJS.enc.u8array.stringify(iv);
            var encryptedSalt = CryptoJS.enc.u8array.stringify(salt);
            var encryptedArray = CryptoJS.enc.u8array.stringify(encrypted.ciphertext);

            var message = new Uint8Array(encryptedIv.length + encryptedSalt.length + encryptedArray.length);
            message.set(encryptedIv);
            message.set(encryptedSalt, encryptedIv.length);
            message.set(encryptedArray, encryptedIv.length+encryptedSalt.length);
            return message;
        }
        catch(e)
        {
            console.log(e);
            return false;
        }

    },
    decrypt: function(data,passphrase)
    {
        try
        {
            var iv = CryptoJS.enc.u8array.parse(data.slice(0, this.ivSize/8));
            console.log(iv.toString());
            var salt = CryptoJS.enc.u8array.parse(data.slice(this.ivSize/8, this.ivSize/8+this.saltSize/8))
            console.log(salt.toString());
            var encrypted = CryptoJS.enc.u8array.parse(data.slice(this.ivSize/8+this.saltSize/8));
            var key = CryptoJS.PBKDF2(passphrase, salt, {
              keySize: this.keySize/32,
              iterations: this.iterations
            });
            var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC

            });
            var res = CryptoJS.enc.u8array.stringify(decrypted.ciphertext);

            return res;
        }
        catch(e)
        {
            console.log(e);
            return false;
        }

    }
}
</code></pre>

<p>I'm also use:</p>

<pre><code>CryptoJS.enc.u8array = {
        stringify: function (wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var u8 = new Uint8Array(sigBytes);
            for (var i = 0; i &lt; sigBytes; i++) {
                var byte = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff;
                u8[i]=byte;
            }
            return u8;
        },
        parse: function (u8arr) {
            var len = u8arr.length;
            var words = [];
            for (var i = 0; i &lt; len; i++) {
                words[i &gt;&gt;&gt; 2] |= (u8arr[i] &amp; 0xff) &lt;&lt; (24 - (i % 4) * 8);
            }
            return CryptoJS.lib.WordArray.create(words, len);
        }
    };
</code></pre>

<p>But when i decrypt the file the results is empty. Ialso check the iv, salt and the encrypted message. All seems work except for the decryption that always returns an empty value.</p>

<p>How can i fix this problem?</p>

<p>Thank you!</p>
","<p>I solved using:</p>

<pre><code> var decrypted = CryptoJS.AES.decrypt({ciphertext:encrypted}, key, {
       iv: iv,
       padding: CryptoJS.pad.Pkcs7,
       mode: CryptoJS.mode.CBC

 });
</code></pre>

<p>in decrypt function.</p>
","692","<encryption><aes><cryptojs>","0","2","2","2019-01-15 12:35:01","","0","1","","","","2018-07-03 15:07:28",""
"51157821","AES decryption returning empty string","<p>Hello i'm trying to encrypt and decrypt files (in Uint8Array format) using CryptoJS Library (3.1.2)
This is my code:</p>

<pre><code>var WPAES = {
    keySize: 256,
    ivSize: 128,
    saltSize: 128,
    iterations:1000,
    encrypt: function(data,passphrase)
    {
        try
        {
            var iv = CryptoJS.lib.WordArray.random(this.ivSize/8);
            console.log(iv.toString());
            var salt = CryptoJS.lib.WordArray.random(this.saltSize/8);
            console.log(salt.toString());

            var key = CryptoJS.PBKDF2(passphrase, salt, {
              keySize: this.keySize/32,
              iterations: this.iterations
            });
            var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.u8array.parse(data), key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC

            });

            var encryptedIv = CryptoJS.enc.u8array.stringify(iv);
            var encryptedSalt = CryptoJS.enc.u8array.stringify(salt);
            var encryptedArray = CryptoJS.enc.u8array.stringify(encrypted.ciphertext);

            var message = new Uint8Array(encryptedIv.length + encryptedSalt.length + encryptedArray.length);
            message.set(encryptedIv);
            message.set(encryptedSalt, encryptedIv.length);
            message.set(encryptedArray, encryptedIv.length+encryptedSalt.length);
            return message;
        }
        catch(e)
        {
            console.log(e);
            return false;
        }

    },
    decrypt: function(data,passphrase)
    {
        try
        {
            var iv = CryptoJS.enc.u8array.parse(data.slice(0, this.ivSize/8));
            console.log(iv.toString());
            var salt = CryptoJS.enc.u8array.parse(data.slice(this.ivSize/8, this.ivSize/8+this.saltSize/8))
            console.log(salt.toString());
            var encrypted = CryptoJS.enc.u8array.parse(data.slice(this.ivSize/8+this.saltSize/8));
            var key = CryptoJS.PBKDF2(passphrase, salt, {
              keySize: this.keySize/32,
              iterations: this.iterations
            });
            var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC

            });
            var res = CryptoJS.enc.u8array.stringify(decrypted.ciphertext);

            return res;
        }
        catch(e)
        {
            console.log(e);
            return false;
        }

    }
}
</code></pre>

<p>I'm also use:</p>

<pre><code>CryptoJS.enc.u8array = {
        stringify: function (wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var u8 = new Uint8Array(sigBytes);
            for (var i = 0; i &lt; sigBytes; i++) {
                var byte = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff;
                u8[i]=byte;
            }
            return u8;
        },
        parse: function (u8arr) {
            var len = u8arr.length;
            var words = [];
            for (var i = 0; i &lt; len; i++) {
                words[i &gt;&gt;&gt; 2] |= (u8arr[i] &amp; 0xff) &lt;&lt; (24 - (i % 4) * 8);
            }
            return CryptoJS.lib.WordArray.create(words, len);
        }
    };
</code></pre>

<p>But when i decrypt the file the results is empty. Ialso check the iv, salt and the encrypted message. All seems work except for the decryption that always returns an empty value.</p>

<p>How can i fix this problem?</p>

<p>Thank you!</p>
","<p>Given it a long try and finally got it. </p>

<p>1). CryptoJS uses hex values while java uses bytes for the same String.</p>

<p>2.) The two other factors which need to be same (apart from the key) are initVector and padding. </p>

<p>Considering both above we first have to validate that both Java are CryptoJS and encrypting to the same value given the above parameters are same. </p>

<p>Here is the code for Java</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.util.Base64;

public class JavaEncryptor {

    private static final String key = ""aesEncryptionKey"";
    private static final String initVector = ""encryptionIntVec"";

    public static String toHex(String arg) throws UnsupportedEncodingException {
        return String.format(""%020x"", new BigInteger(1, arg.getBytes(""UTF-8"")));
    }


    /**
     * Use these hex value in CryptoJS
     * @throws Exception
     */
    public static void printHexForJS() throws Exception {
        System.out.println(""HexKeyForJS :  ""+ toHex(key));
        System.out.println(""HexInitVectorForJS :  ""+ toHex(initVector));
    }

    public static String encrypt(String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");


            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes()); 
            return Base64.getEncoder().encodeToString(encrypted);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) throws Exception {
        printHexForJS();
        System.out.println(encrypt(""MyPlainTextToBeEncrypted""));
    }

}
</code></pre>

<p>Output of the above program is </p>

<blockquote>
  <p>HexKeyForJS :  616573456e6372797074696f6e4b6579 
  HexInitVectorForJS : 656e6372797074696f6e496e74566563
  MURKOx14eSOo2vs8ZQyCpXpsoKg8Uzlvyj3byQreVBk=</p>
</blockquote>

<p>And then for JS encryption use the HexKeyForJS  and HexInitVectorForJS as in below code</p>

<pre><code>var text = ""ManishMudgal"";
var key = CryptoJS.enc.Hex.parse(HexKeyForJS);
var iv  = CryptoJS.enc.Hex.parse(HexInitVectorForJS);

var encrypted = CryptoJS.AES.encrypt(text, key, {iv: iv, padding: CryptoJS.pad.Pkcs7});
console.log(encrypted.toString());
</code></pre>

<blockquote>
  <p>Output of the above JS code should be  kBgYcrSxz+kbXRnyKIFmSw==</p>
</blockquote>

<p>Which is the same encrypted key generated through Java code 
MURKOx14eSOo2vs8ZQyCpXpsoKg8Uzlvyj3byQreVBk=</p>

<p>Now Decryption at Crypto End</p>

<pre><code>CryptoJS.AES.decrypt('MURKOx14eSOo2vs8ZQyCpXpsoKg8Uzlvyj3byQreVBk=', CryptoJS.enc.Hex.parse(HexKeyForJS), {iv: CryptoJS.enc.Hex.parse(HexInitVectorForJS), padding: CryptoJS.pad.Pkcs7}).toString(CryptoJS.enc.Utf8);
</code></pre>

<p>Cheers :) </p>
","692","<encryption><aes><cryptojs>","0","1","2","2019-01-15 12:35:01","","0","1","","","","2018-07-03 15:07:28",""
"39203851","AES 256 Encryption in Java, Decryption in CryptoJS","<p>I have a Java AES 256 encryption code like this :</p>

<pre><code>public class EncryptDecryptTwo {
static {
    try {
        Field field = Class.forName(""javax.crypto.JceSecurity"").getDeclaredField(""isRestricted"");
        field.setAccessible(true);
        field.set(null, java.lang.Boolean.FALSE);
    } catch (Exception ex) {
    }
}

private static String keyEnc = ""BtDMQ7RfNVoRzJ7GYE32"";

// Performs Encryption
public static String encrypt(String plainText) throws Exception {
    String passphrase = keyEnc;
    byte[] iv = DatatypeConverter.parseHexBinary(""2aba86027a6f79dd463b81b0539bacb5"");
    byte[] salt = DatatypeConverter.parseHexBinary(""0f3d1b0d514ca313"");
    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
    SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(passphrase, salt);

    Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    c.init(Cipher.ENCRYPT_MODE, sKey, ivParameterSpec);
    byte[] encryptedData = c.doFinal(plainText.getBytes());
    return DatatypeConverter.printBase64Binary(encryptedData);

}

public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {

    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 1, 256);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    SecretKey secretKey = keyFactory.generateSecret(keySpec);

    return new SecretKeySpec(secretKey.getEncoded(), ""AES"");
}

public static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i &lt; len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character.digit(s.charAt(i + 1), 16));
    }
    return data;
}
}
</code></pre>

<p>In this case, I hardcoded the salt bytes and iv bytes just to make sure my coding is encrypt the message right, so it can be read by cryptoJS in another server. But when I send the encrypted text by calling the encrypt method, it is always rejected by the cryptoJS, saying that my encrypted message is not correct </p>

<p>The CryptoJS is in another server and it is like this :</p>

<pre><code>var CryptoJSAesJson = {
  stringify: function (cipherParams) {
    var j = {ct: cipherParams.cipherText.toString(CryptoJS.enc.Base64)};
    if (cipherParams.iv) j.iv = cipherParams.iv.toString();
    if (cipherParams.salt) j.s = cipherParams.salt.toString();
    return JSON.stringify(j);
  },
  parse: function (jsonStr) {
    var j = JSON.parse(jsonStr);
    var cipherParams = CryptoJS.lib.CipherParams.create({ciphertext: CryptoJS.enc.Base64.parse(j.ct)});
    if (j.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(j.iv)
    if (j.s) cipherParams.salt = CryptoJS.enc.Hex.parse(j.s)
    return cipherParams;
  }
}
var encrypted = CryptoJS.AES.encrypt(JSON.stringify($scope.loginData.password), __ENV.AES_KEY, { format: CryptoJSAesJson}).toString();
</code></pre>

<p>Can anybody help me finding what's wrong in my java code? Thank you very much</p>

<p>Edited :
According to Artjom.B's comment and advise, I tried this :</p>

<pre><code>static {
    try {
        Field field = Class.forName(""javax.crypto.JceSecurity"").getDeclaredField(""isRestricted"");
        field.setAccessible(true);
        field.set(null, java.lang.Boolean.FALSE);
    } catch (Exception ex) {
    }
}

public static void main(String[] args) throws UnsupportedEncodingException, GeneralSecurityException {
    String plaintext = ""someplaintext"";
    String password = ""BtDMQ7RfNVoRzWGjS2DK"";
    int keySize = 256;
    int ivSize = 128;

    byte[] salt = DatatypeConverter.parseHexBinary(""5ba2b0e0bb968f47""); // yes, for testing, I use a fixed salt

    byte[] key = new byte[keySize/8];
    byte[] iv = new byte[ivSize/8];
    EvpKDF(password.getBytes(""UTF-8""), keySize, ivSize, salt, key, iv);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""), new IvParameterSpec(iv));
    byte[] encryptedText = cipher.doFinal((plaintext).getBytes());

    System.out.println(""SALT : "" + DatatypeConverter.printHexBinary(salt));
    System.out.println(""IV : "" + DatatypeConverter.printHexBinary(iv));
    System.out.println(""CT : "" + DatatypeConverter.printBase64Binary(encryptedText));
// I sent salt, IV, and ciphertext to CryptoJS
}

public static byte[] EvpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    return EvpKDF(password, keySize, ivSize, salt, 1, ""MD5"", resultKey, resultIv);
}

public static byte[] EvpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    keySize = keySize / 32;
    ivSize = ivSize / 32;
    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords &lt; targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i &lt; iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv
}

/**
 * Copied from http://stackoverflow.com/a/140861
 * */
public static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i &lt; len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}
</code></pre>

<p>But still no avail. The CryptoJS keep saying that I pass an incorrect password.
Can anybody help? Thank you very much</p>
","","688","<java><encryption><aes><cryptojs>","0","","0","2016-09-13 05:44:57","","10","3","3521966","","2016-09-13 05:44:57","2016-08-29 10:20:26",""
"18093316","MS CryptoAPI giving wrong RC4 Results?","<p>I am working on a product that needs to be able to consume files created with an older product. Some of these files contain content encrypted with RC4 encryption using MS CryptoAPI.  I have thus far been unable to successfully decrypt the content using other crypto libraries.  After some experimentation, it appears that CryptoAPI's RC4 output is ""correct"" (i.e. agrees with other libraries) when the key is ASCII, but is ""wrong"" (differs from other libraries that all agree) when the key is not ASCII (e.g. a hash of a password).</p>

<p>Since all the content I'm interested in consuming was encrypted with a key that was derived from a password via hashing, I'm a bit stuck at the moment.  I've written up a small test to show the issue that includes 3 test cases as you can see below in the code.  Botan (C++) and CryptoJS (JS) always agree on output. MS CryptoAPI, however, only agrees for the ASCII keys.</p>

<p>Before I go to MS with this issue, is anyone aware of something I'm misunderstanding or doing wrong that could cause this issue?</p>

<p>Also, I apologize for my atrocious javascript.</p>

<pre><code>#pragma pack (push, 1)
struct PlainTextKeyBlob
{
    BLOBHEADER _hdr;
    DWORD      _cbKey;
    BYTE       _key[1];
};
#pragma pack (pop)

void TestBotanAndMSCryptoRC4()
{
    struct TestItem
    {
        std::string key;
        std::string plainText;
    };

    TestItem TestItems[] = {
    { ""Secret"",               ""Attack at dawn"" },  // Example taken from Wikipedia RC4 page to verify output.
    { ""!\\\""#$%&amp;'()*+"",       ""Encrypt me"" } ,     // Key with various ASCII symbols.
    { ""\xF4\xE7\xA8\x74\x0D"", ""Encrypt me"" }       // Key is first 5 bytes of SHA1 hash of ""Secret"".
    };
    DWORD NumTestItems = _countof(TestItems);

    for( DWORD i = 0; i &lt; NumTestItems; i++ )
    {
        // Botan Encryption
        Botan::SymmetricKey symmKey((BYTE*)TestItems[i].key.c_str(), TestItems[i].key.size());
        Botan::Pipe pipe(Botan::get_cipher(""ARC4"", symmKey, Botan::ENCRYPTION));
        pipe.process_msg(TestItems[i].plainText);
        SecureByteVector&amp; encryptedBuff = pipe.read_all();

        // MS Crypto API Encryption
        AutoCryptProv CryptProv;
        if( !CryptAcquireContext( CryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            ASSERT(false);
            return;
        }

        DWORD blobKeySize = TestItems[i].key.size();
        DWORD blobSize    = sizeof(PlainTextKeyBlob) + blobKeySize - 1;
        CByteArray keyBlob;
        keyBlob.SetSize(blobSize);

        PlainTextKeyBlob *pKeyBlob = reinterpret_cast&lt;PlainTextKeyBlob*&gt;(keyBlob.GetData());
        pKeyBlob-&gt;_hdr.bType       = PLAINTEXTKEYBLOB;
        pKeyBlob-&gt;_hdr.bVersion    = CUR_BLOB_VERSION;
        pKeyBlob-&gt;_hdr.reserved    = 0;
        pKeyBlob-&gt;_hdr.aiKeyAlg    = CALG_RC4;
        pKeyBlob-&gt;_cbKey           = TestItems[i].key.size();
        memcpy_s(pKeyBlob-&gt;_key, blobKeySize, TestItems[i].key.c_str(), TestItems[i].key.size());

        AutoCryptKey CryptKey;
        if( !CryptImportKey(CryptProv, reinterpret_cast&lt;BYTE*&gt;(pKeyBlob), blobSize, NULL, 0, CryptKey) )
        {
            ASSERT(false);
            return;
        }

        CByteArray dataBytes;
        dataBytes.SetSize(TestItems[i].plainText.size());
        memcpy_s(dataBytes.GetData(), dataBytes.GetSize(), TestItems[i].plainText.c_str(), TestItems[i].plainText.size());

        DWORD buffSize = dataBytes.GetSize();
        if( !CryptEncrypt(CryptKey, 0, TRUE, 0, dataBytes.GetData(), &amp;buffSize, dataBytes.GetSize()) )
        {
            ASSERT(false);
            return;
        }

        ASSERT(encryptedBuff.size() == dataBytes.GetSize());
        ASSERT( 0 == memcmp(encryptedBuff.begin(), dataBytes.GetData(), dataBytes.GetSize()) );
    }
}

&lt;html&gt;
&lt;body&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/rc4.js""&gt;&lt;/script&gt;
&lt;div id=""output"" /&gt;
&lt;script&gt;
    var key1 = CryptoJS.enc.Hex.parse('536563726574'); // Secret
    var message1 = ""Attack at dawn"";
    var encrypted1 = CryptoJS.RC4.encrypt(message1, key1);

    var key2 = CryptoJS.enc.Hex.parse('215c22232425262728292a2b'); // !\""#$%&amp;'()*+
    var message2 = ""Encrypt me"";
    var encrypted2 = CryptoJS.RC4.encrypt(message2, key2);

    var key3 = CryptoJS.enc.Hex.parse('f4e7a8740d'); // First 5 bytes of hash of ""Secret""
    var message3 = ""Encrypt me"";
    var encrypted3 = CryptoJS.RC4.encrypt(message3, key3);

    var elem = document.getElementById(""output"");
    elem.innerHTML = ""Key1: "" + encrypted1.key + ""&lt;br&gt; ciphertext1: "" + encrypted1.ciphertext + ""&lt;br&gt;&lt;br&gt;"" +
                     ""Key2: "" + encrypted2.key + ""&lt;br&gt; ciphertext2: "" + encrypted2.ciphertext + ""&lt;br&gt;&lt;br&gt;"" +
                     ""Key3: "" + encrypted3.key + ""&lt;br&gt; ciphertext3: "" + encrypted3.ciphertext;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","<p>I just wanted to follow up with the answer I found in case this is useful to someone else in the future.</p>

<p>First and foremost, the answer was to RTFM! As it turns out, by default, CryptDeriveKey adds a ""salt"" to 40-bit symmetric keys consisting of all 0's. When I looked at our old CryptoAPI code and saw that we weren't passing any flags into it, I assumed this meant nothing special was going on and I didn't read through the details of all possible flags on MSDN. Furthermore, since MS considers this portion of the key a salt <strong>it is not included when you export the key</strong> so that was also a dead end.</p>

<p>I eventually found my way to <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387695(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa387695(v=vs.85).aspx</a> which explains the salt mechanism for 40-bit keys and the line that caught my eye was that, for compatibility, you should create keys with the CRYPT_NO_SALT flag.  In our case, we already have encrypted content with such keys, so we simply modified our Botan/CryptoJS code to append 11 bytes of 0s to the end of the base 40-bit key.</p>

<p>The details for the various CryptDeriveKey flags can be found here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx</a></p>
","686","<cryptoapi><cryptojs><botan><rc4-cipher>","0","0","1","2013-09-27 16:30:10","19055779","0","","","","","2013-08-07 01:45:11",""
"42779492","How to translate CryptoJS AES into java code","<p>I want to translate CryptoJS code into java code .This is the javascript code:</p>

<pre><code>CryptoJS.AES.encrypt('hello',CryptoJS.enc.Utf8.parse(CryptoJS.MD5(""http://stackoverflow.com"")), {iv: CryptoJS.enc.Utf8.parse(""1234567812345678"")})
</code></pre>

<p>Above the code result invoke to string is 'QtzDsbCgmA9+XBVEsEm70w=='</p>

<p>Then I get the key value by CryptoJS.MD5(""<a href=""http://stackoverflow.com"">http://stackoverflow.com</a>"").toString() method(key =  57f4dad48e7a4f7cd171c654226feb5a)</p>

<p>This is the java code:</p>

<pre><code> try {
        String content = ""hello"";
        String key = ""57f4dad48e7a4f7cd171c654226feb5a"";
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128, new SecureRandom(key.getBytes(""utf-8"")));
        SecretKey secretKey = kgen.generateKey();
        byte[] enCodeFormat = secretKey.getEncoded();


        SecretKeySpec key1 = new SecretKeySpec(enCodeFormat, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        byte[] byteContent = content.getBytes(""utf-8"");


        cipher.init(Cipher.ENCRYPT_MODE, key1,new IvParameterSpec(""1234567812345678"".getBytes(""UTF-8"")));

        byte[] result = cipher.doFinal(byteContent);
        System.out.println(new String(result).equals(""QtzDsbCgmA9+XBVEsEm70w==""));

    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
</code></pre>

<p>but the output result is false.How to fix the java code to change the result to true.</p>
","<p>According to @Luka Park advice,I have solve to my question.This is my solution:</p>

<pre><code>    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] raw = sKey.getBytes();
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    IvParameterSpec iv = new IvParameterSpec(ivParameter.getBytes());
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
    byte[] encrypted = cipher.doFinal(sSrc.getBytes(""utf-8""));
    return new BASE64Encoder().encode(encrypted);
</code></pre>
","685","<encryption><cryptojs>","1","0","1","2017-03-16 02:20:59","","2","3","","","","2017-03-14 06:54:37",""
"54193730","nodejs crypto module privateEncrypt() always return same result","<p>I am using RSA encryption with nodejs crypto module.</p>

<p>I want encrypt message with PRIVATE KEY and decrypt with PUBLIC KEY.
also always make different result with same message using padding scheme like encryption using public key.</p>

<p>So I used basic crypto module like below</p>

<pre><code>var crypto = require('crypto');
var fs = require('fs');
const path = require('path');


var PRIVKEY = fs.readFileSync(path.join(__dirname, 'private.key'), 'utf8');
var PUBKEY = fs.readFileSync(path.join(__dirname, 'pub.key'), 'utf8');

// RSA PRIVATE ENCRYPT -&gt; PUBLIC DECRYPT //
myMSG = ""apple"";
console.log('myMSG SIZE:', myMSG.length);

function privENC_pubDEC(originMSG){
 encmsg = crypto.privateEncrypt(PRIVKEY, Buffer.from(originMSG, 'utf8') ).toString('base64');
 msg = crypto.publicDecrypt(PUBKEY, Buffer.from(encmsg, 'base64'));
 console.log(""Encrypted with private key : ""+encmsg);
 console.log(msg.toString());
}

// RSA PUBLIC ENCRYPT -&gt; PRVATE DECRYPT //
function pubENC_privDEC(originMSG){
 encmsg = crypto.publicEncrypt({key:PUBKEY, padding:crypto.constants.RSA_PKCS1_PADDING}, Buffer.from(originMSG, 'utf8') ).toString('base64');
 msg = crypto.privateDecrypt({key:PRIVKEY, padding:crypto.constants.RSA_PKCS1_PADDING}, Buffer.from(encmsg, 'base64'));
 console.log(""\nEncrypted with public key : ""+encmsg);
 console.log(msg.toString());
}

privENC_pubDEC(myMSG);
pubENC_privDEC(myMSG);
</code></pre>

<p>Result</p>

<pre><code>C:\Users\LSW&gt;node crypto.js
myMSG SIZE: 5
Encrypted with private key : fbUZwj+UZP92HQYRc+EJTqSztJTY/Sit5axPZ0NVBuDAC8ZwvvC96pxxDGpra4Yg8MjcXyjvnT8rrrgHu0T0wA==
apple

Encrypted with public key : ze+5TdWtR8hkpNPIVa5HSasOxs3Pr8FA/1/zUGqDUQmIhs/miWt5pgU9kIAiryKfgGa0+p9RfHPMwZ1VMSA7Bw==
apple

C:\Users\LSW&gt;node crypto.js
myMSG SIZE: 5
Encrypted with private key : fbUZwj+UZP92HQYRc+EJTqSztJTY/Sit5axPZ0NVBuDAC8ZwvvC96pxxDGpra4Yg8MjcXyjvnT8rrrgHu0T0wA==
apple

Encrypted with public key : OdEpjloUDWI8+YjWkE5cmBC/fJL2QnRLKBXfjaP5h5qyB1OMcm9JGGNSTiAAL2u8O5jjdQAavB9Rn+cdRDjLyA==
apple

C:\Users\LSW&gt;node crypto.js
myMSG SIZE: 5
Encrypted with private key : fbUZwj+UZP92HQYRc+EJTqSztJTY/Sit5axPZ0NVBuDAC8ZwvvC96pxxDGpra4Yg8MjcXyjvnT8rrrgHu0T0wA==
apple

Encrypted with public key : INspxkyFu2AWGVYwSvOGOPH1fhE3qVVxiqz+SmyHU8wTDNKHj4gVVHqO+8AZOJvi4NfyekI2MMwpFDU4mUjEXA==
apple
</code></pre>

<p>PUBLIC ENCRYPT -> PRVATE DECRYPT  is operated well I expected. it always return different result because of padding scheme.</p>

<p>But PRIVATE ENCRYPT -> PUBLIC DECRYPT is always return same message although used padding scheme.</p>

<p>Is there any solution make it different message with Nodejs crypto module???</p>
","<p>This is expected behavior according to the padding schemes for RSA signing and encryption as implemented by OpenSSL, <a href=""https://nodejs.org/api/crypto.html#crypto_crypto"" rel=""nofollow noreferrer"">which <code>crypto</code> leverages</a>.</p>

<p>I am not sure what you want to use the functions <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_privateencrypt_privatekey_buffer"" rel=""nofollow noreferrer""><code>privateEncrypt()</code></a> and <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_publicdecrypt_key_buffer"" rel=""nofollow noreferrer""><code>publicDecrypt()</code></a> for. If your intent is to sign data, then see my update below. Anyway, for these functions, the <code>crypto</code> documentation explains that it only exposes <code>RSA_PKCS1_PADDING</code> which OpenSSL maps to the deterministic RSASSA-PKCS1-v1_5 padding scheme under the hood. This means that for the same key and the same data, the resulting data will be the same.</p>

<p>For encryption and decryption, with <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_publicencrypt_key_buffer"" rel=""nofollow noreferrer""><code>publicEncrypt()</code></a> and <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_publicencrypt_key_buffer"" rel=""nofollow noreferrer""><code>privateDecrypt()</code></a>, you have selected the <code>RSA_PKCS1_PADDING</code> mode. This translates to the RSAES-PKCS1-v1_5, a scheme that includes random elements, which cause the different outputs that you observe in your repeated runs. According to the documentation, <code>crypto</code> uses <code>RSA_PKCS1_OAEP_PADDING</code> padding by default. This stands for <a href=""https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding"" rel=""nofollow noreferrer"">Optimal asymmetric encryption padding</a>, which is non-deterministic as well.</p>

<p>For a summary of the PKCS#1-defined schemes, see <a href=""https://en.wikipedia.org/wiki/PKCS_1#Schemes"" rel=""nofollow noreferrer"">PKCS#1 Schemes</a>.</p>

<hr>

<p>Update: You may want to use the <a href=""https://nodejs.org/api/crypto.html#crypto_class_sign"" rel=""nofollow noreferrer""><code>Sign class</code></a> instead of the <code>privateEncrypt()</code> and <code>publicDecrypt()</code> functions. Its <a href=""https://nodejs.org/api/crypto.html#crypto_sign_sign_privatekey_outputencoding"" rel=""nofollow noreferrer""><code>sign</code>()</a> function does support a probabilistic padding mode, which OpenSSL supports via RSASSA-PSS. Using your example code as a starting point, it would look something like this:</p>

<pre><code>const sign = crypto.createSign('SHA256')
sign.update(Buffer.from(originMSG, 'utf8'))
signature = sign.sign({key:PRIVKEY, padding:crypto.constants.RSA_PKCS1_PSS_PADDING}).toString('base64')
</code></pre>

<p>The signature will be different every time. Note that you can not ""decrypt"" it, it is a one-way operation. You can only verify it, using the public key with the <a href=""https://nodejs.org/api/crypto.html#crypto_class_verify"" rel=""nofollow noreferrer""><code>Verify</code></a> class:</p>

<pre><code>const verify = crypto.createVerify('SHA256')
verify.update(Buffer.from(originMSG, 'utf8'))
verifyRes = verify.verify({key:PUBKEY, padding:crypto.constants.RSA_PKCS1_PSS_PADDING}, Buffer.from(signature, 'base64'))
</code></pre>
","681","<javascript><node.js><encryption><rsa><cryptojs>","3","5","1","2019-01-15 17:20:07","54194706","6","","","","","2019-01-15 06:29:15",""
"38275326","get name files of a mega.nz folder in nodejs","<p>Request to api of mega.nz, parse url for get private key of folder, and try decode name of files from responde of request, by crypto of nodejs.</p>

<p>My code:</p>

<pre><code>const crypto = require('crypto')
const parse = require('url').parse
const request = require('request')

const link = 'https://mega.nz/#F!gE5WkDpS!Yh6AQtYHPgi-rEkir_gAEw'
const api = 'https://eu.api.mega.co.nz/cs?id=-1771463320&amp;n=MBwjmCqR'

function d64 (s) {
  s += '=='.substr((2 - s.length * 3) &amp; 3)
  s = s.replace(/-/g, '+').replace(/_/g, '/').replace(/,/g, '')
  return new Buffer(s, 'base64')
}

function from256to128 (s) {
  var o = new Buffer(16)
  for (var i = 0; i &lt; 16; i++) {
    o[i] = s[i] ^ s[i + 16]
  }
  return o
}

function decodeName (at) {
  var end = at.length
  while (!at.readUInt8(end - 1)) end--
  return at.slice(0, end).toString()
}

const url = parse(link)
const split = url.hash.split('!')
const k0 = d64(split[2])

request({
  method: 'POST', uri: api, body: '[{""a"":""f"",""c"":1,""r"":1,""ca"":1}]'
}, (e, r, b) =&gt; {
  if (!e &amp;&amp; r.statusCode === 200) {
    for (let file of JSON.parse(b)[0].f) {
      if (file.t === 1) {
        let k = d64(file.k.split(':')[1])
        let a = d64(file.a)
        let aes = crypto.createDecipheriv('aes-128-ecb', k0, Buffer(0))
        aes.setAutoPadding(false)
        let kdec = aes.update(k)
        aes = crypto.createDecipheriv('aes-128-cbc', kdec, Buffer(16))
        aes.setAutoPadding(false)
        let name = decodeName(aes.update(a))
        console.log(name)
      } else {
        let k = d64(file.k.split(':')[1])
        let a = d64(file.a)
        let aes = crypto.createDecipheriv('aes-128-ecb', k0, Buffer(0))
        aes.setAutoPadding(false)
        let k2dec = from256to128(aes.update(k))
        aes = crypto.createDecipheriv('aes-128-cbc', k2dec, Buffer(16))
        aes.setAutoPadding(false)
        let name = decodeName(aes.update(a))
        console.log(name)
      }
    }
  }
})
</code></pre>

<p>My output is more broken text, i try change url and get more broken text:</p>

<pre><code>MzM+,BWpK
</code></pre>
","<p>There are two errors in your code:</p>



<pre class=""lang-js prettyprint-override""><code>const link = 'https://mega.nz/#F!gE5WkDpS!Yh6AQtYHPgi-rEkir_gAEw'
const api = 'https://eu.api.mega.co.nz/cs?id=-1771463320&amp;n=MBwjmCqR'
</code></pre>

<p>You're requesting <code>MBwjmCqR</code> folder info but using <code>gE5WkDpS</code> key.</p>

<pre class=""lang-js prettyprint-override""><code>let aes = crypto.createDecipheriv('aes-128-ecb', k0, Buffer(0))
aes = crypto.createDecipheriv('aes-128-cbc', kdec, Buffer(16))
</code></pre>

<p>Using <code>Buffer(size)</code> will not initialize it, so the Buffer will contain data that was previously in memory. Use <code>Buffer.alloc(size, 0)</code> to initialize it with zeroes, which will match MEGA's implementation.</p>
","680","<javascript><node.js><request><cryptojs>","2","1","1","2016-12-06 21:09:47","","2","1","","","","2016-07-08 20:59:52",""
"45628726","Crypto.js equivalent module in python for AES encryption and decryption","<p>I am trying to decrypt a file in python which was encrypted using CryptoJS(AES) in Node.js. I know there is an equivalent module in python (Pycrypto) but I don't know how to use it or which mode of AES decryption to use for decrypting the data(I have the cipher and the key but don't have any iv).<br> Here is the code(Node.js) which i am trying to translate to Python:</p>

<pre><code>  function fileEncrypt(plaintext, password){        
     return CryptoJS.AES.encrypt(plaintext,password).toString();

}
function fileDecrypt(ciphertext, password){     
    return CryptoJS.AES.decrypt(ciphertext,password).toString(CryptoJS.enc.Latin1);     
}   
</code></pre>

<p>As you can see, no iv has been passed here. Please help me translate the code to Python. Thank you in advance :)</p>
","","680","<python><node.js><encryption><pycrypto><cryptojs>","0","","0","2017-08-11 17:13:38","","7","","1816580","","2017-08-11 17:13:38","2017-08-11 06:50:35",""
"43103343","CryptoJS encrypt Go decrypt","<p>I have the following Go code</p>

<pre><code>ciphertext := ""Zff9c+F3gZu/lsARvPhpMau50KUkMAie4j8MYfb12HMWhkLqZreTk8RPbtRB7RDG3QFw7Y0FXJsCq/EBEAz//XoeSZmqZXoyq2Cx8ZV+/Rw=""
decodedText, _ := base64.StdEncoding.DecodeString(ciphertext)
decodedIv, _ := base64.StdEncoding.DecodeString(""u9CV7oR2w+IIk8R0hppxaw=="")
newCipher, _ := aes.NewCipher([]byte(""~NB8CcOL#J!H?|Yr""))
cfbdec := cipher.NewCBCDecrypter(newCipher, decodedIv)
cfbdec.CryptBlocks(decodedText, decodedText)
data, _ := base64.StdEncoding.DecodeString(string(decodedText))
println(string(data))
</code></pre>

<p>The output is <code>{""data"":{""value"":300}, ""SEQN"":700 , ""msg"":""IT WORKS!!""</code></p>

<p>It's encrypted with the following CryptoJS    </p>

<pre><code>function encrypt(message, key) {
  let keyHex = CryptoJS.enc.Hex.parse(parseToHex(key))
  let iv = CryptoJS.lib.WordArray.random(128 / 8);
  let wordArray = CryptoJS.enc.Utf8.parse(message);
  let base64 = CryptoJS.enc.Base64.stringify(wordArray);
  let encrypted = CryptoJS.AES.encrypt(base64, keyHex, { iv: iv });
  return {
    cipher: encrypted.ciphertext.toString(CryptoJS.enc.Base64),
    iv: CryptoJS.enc.Base64.stringify(iv),
    length: base64.length,
    size: encrypted.ciphertext.sigBytes,
  }
}
</code></pre>

<p>And can be decrypted with </p>

<pre><code>function decrypt(message, key, iv) {
  let ivEX = CryptoJS.enc.Hex.parse(decodeToHex(iv));
  let keyEX = CryptoJS.enc.Hex.parse(parseToHex(key));
  let bytes = CryptoJS.AES.decrypt(message, keyEX , { iv: ivEX});
  let plaintext = bytes.toString(CryptoJS.enc.Base64);
  return decodeToString(decodeToString(plaintext));
}
</code></pre>

<p>The output is <code>{""data"":{""value"":300}, ""SEQN"":700 , ""msg"":""IT WORKS!!"" }</code> - this is the correct output</p>

<p>Why Go has different output?</p>
","<p>Check your errors please. ALWAYS</p>

<p><code>illegal base64 data at input byte 75</code></p>

<p><a href=""https://play.golang.org/p/dRLIT51u4I"" rel=""nofollow noreferrer"">https://play.golang.org/p/dRLIT51u4I</a></p>

<p>More specifically, the value at byte 75 is <code>5</code>, which is out of the range of characters available to base64. In ascii, it is the ENQ (enquiry) character. As to why this ends up in your final base64 string is beyond me.</p>

<p>EDIT: OK found the issue. For whatever reason, the base64 padding character <code>=</code> at the end is being decrypted as 5 consecutive bytes containing the value <code>5</code>. Here is a playground link that shows it fixed. <a href=""https://play.golang.org/p/tf3OZ9XG1M"" rel=""nofollow noreferrer"">https://play.golang.org/p/tf3OZ9XG1M</a></p>

<p>EDIT: As per matt's comments. I updated the fix function to simply remove all the PKCS7 block padding and use <code>RawStdEncoding</code> for the last base64 decode. This should now be a reasonable fix.</p>
","673","<encryption><go><aes><cryptojs>","1","2","1","2017-03-29 22:46:10","43104371","4","","6435651","","2017-03-29 20:39:56","2017-03-29 20:17:51",""
"32161948","CryptoJs aes impacting cordova applications with Cordova-Plugin_camera","<p>I have been struggling for figuring out the reason for failure of Cordova-plugin-camera for the last 45 days. </p>

<p>This really bugged me like hell and consumed more than required time for this.</p>

<p>I have nailed it now.</p>

<p>I was using cyrptojs aes to encrypt the device local stored user sensitive information.</p>

<p>It is being used inside winjs.xhr. </p>

<p>Not sure what is the reason but it is some how impacting the ""state"" of the application and any external operations such as ""file"" browsing/Camera click save and return to app is exiting the app.</p>

<p>Please reply if anybody has any information about this negative impact.</p>

<p>this cryptojs aes is from google.</p>

<p>CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License</p>

<p>anybody from google who may have done this utility, please reply.</p>
","","669","<cordova><plugins><camera><aes><cryptojs>","0","","0","2015-08-23 00:04:40","","3","","","","","2015-08-23 00:04:40",""
"41338431","CryptoJS key generator","<p>I have a reference to CryptoJS v3.1.2 and when trying the following javascript code:</p>

<pre><code>var txtpassword = document.getElementById(""myPassword"").value.trim();
var salt = CryptoJS.lib.WordArray.random(128 / 8);
var key256Bits = CryptoJS.PBKDF2(txtpassword, salt, { keySize: 256 / 32 });
</code></pre>

<p>It blows up on PBKDF2, proclaiming ""Object doesn't support property or method 'PBKDF2'"".  I see many references online to calling PBKDF2 like this, what am I missing?</p>
","<p>I was missing all the rest of the associated js files.  I was able to download the complete library from here</p>

<p><a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow noreferrer"">https://code.google.com/archive/p/crypto-js/downloads</a></p>
","665","<javascript><cryptojs>","0","0","1","2016-12-31 01:31:33","","2","","","","","2016-12-27 02:53:29",""
"40379484","How to decrypt a String in java","<p>I am trying to decrypt a string which is encrypted in front end(angualrjs) while calling a rest service in java using angular js. I am able to encrypt the string using <code>$crypto.encrypt</code> ( using CryptoJS).I am passing encrypted value as argument using <code>$http.get</code> method.</p>

<p>But I am not familiar on how to decrypt the value in java.</p>

<p>encryption key in my config:</p>

<pre><code>app.config(['$cryptoProvider', function($cryptoProvider){
       $cryptoProvider.setCryptographyKey('ABCD123');
}]);
</code></pre>

<p>Thanks in Advance.</p>
","<p>Seeing that you're using CryptoJS, there is already an answer posted.</p>

<p><a href=""https://stackoverflow.com/questions/29151211/how-to-decrypt-an-encrypted-aes-256-string-from-cryptojs-using-java/29152379#29152379"">How to decrypt an encrypted AES-256 string from CryptoJS using Java?</a></p>

<p>However, if you're using SSL/TLS, this encryption is not very effective. Because, even as the password is sent encrypted, there is need to store the password in clear text on the server-side for this purpose - which is not advisable. It is better to securely hash your passwords for authentication.</p>
","661","<java><angularjs><encryption><aes><cryptojs>","1","1","1","2016-11-02 12:20:16","","3","","4137489","","2016-11-02 12:07:09","2016-11-02 12:02:36",""
"46077614","cryptoJS deciphering/decrypting messages AES CFB mode","<p>I am encrypting some string in Ruby, sending it to a client and attempting to decrypt the string there. I am not using the aes rollup (though I have tried with the same result). I have included the aes.js, core.js and cipher-core.js packages as assets. I have checked that the function that is reported as not found does exist in cipher-core.js. I am getting the error:</p>

<pre><code>Uncaught TypeError: Cannot read property 'createDecryptor' of undefined
at Object.reset (aes.self-9251f7d.js?body=1:28)
at Object.init (aes.self-9251f7d.js?body=1:25)
at Object.c.hasOwnProperty.c.init (aes.self-9251f7d.js?body=1:8)
at Object.c.hasOwnProperty.c.init (aes.self-9251f7d.js?body=1:8)
at Object.c.hasOwnProperty.c.init (aes.self-9251f7d.js?body=1:8)
at Object.create (aes.self-9251f7d.js?body=1:8)
at Object.createDecryptor (aes.self-9251f7d.js?body=1:25)
at Object.decrypt (aes.self-9251f7d.js?body=1:31)
at Object.decrypt (aes.self-9251f7d.js?body=1:32)
at Object.decrypt (aes.self-9251f7d.js?body=1:26)
</code></pre>

<p>Here is the code:</p>

<pre><code>function decipher(encipheredMessage, password, iv) {
  var parts = encipheredMessage.split('--', 2),
      enciphered = replaceHex(parts[0])

  deciphered = CryptoJS.AES.decrypt(
    enciphered,
    password,
    { iv: iv,
      mode: CryptoJS.mode.CFB,
      padding: CryptoJS.pad.NoPadding }
    ).toString(CryptoJS.enc.Utf8)

  return deciphered
}
</code></pre>

<p>Deciphering works when I load the code into node and give it the key/iv that Ruby uses to encipher the string. Has anyone got any idea what is going on?</p>

<p>EDIT</p>

<p>I've been trying to get this working in a number of ways. I've tried making the key a hex encoded string and a hex encoded char array, neither made any change. I'm really struggling with this as I am not a JS programmer, none of the stack exchange answers to other issues with cryptoJS seem to apply.</p>
","<p>After reading the cryptoJS source I discovered that I needed to include two more modules into my application.js the complete set of necessary js files was:</p>

<pre><code>cryptoJS/components/aes
cryptoJS/components/core
cryptoJS/components/cipher-core
cryptoJS/components/mode-cfb
cryptoJS/components/pad-(whichever padding used)
</code></pre>

<p>the aes rollup did not work as it was missing some of these components so I feel it is best to include the components individually.</p>
","658","<javascript><encryption><cryptojs>","0","1","1","2017-09-07 14:14:36","46098651","4","","1010873","","2017-09-07 13:26:14","2017-09-06 14:17:11",""
"31299236","CryptoJS AES Increase File Size","<p>Thank you for your help.</p>

<p>I have a problem with sjcl library or cryptojs aes library.
Everytime i encrypt my file with aes the file size is * 2.
For example: When i upload a 4mb file then there is a 8mb file on my server.</p>

<p>I split the file on block which bytesize can be divided by 16.</p>

<p>Please help me</p>

<p>This is the way i encrypt the file:</p>

<pre><code>var l_EncryptetData = CryptoJS.AES.encrypt(p_ChunkData, p_FileKey).toString();
</code></pre>

<p>And this is a example array with block sizes from the 4mb file:</p>

<pre><code>0: 1572864
1: 1572864
2: 867005
length: 3
</code></pre>

<p>And the FileKey is a SHA-256 Hash</p>
","<p>You are converting the cipher output (a <code>CipherParams</code> object) to a character string. By default, CryptoJS does this by representing the result in hexadecimal, where each byte is encoded as two hex digits. You can override this behavior by providing a <a href=""https://code.google.com/p/crypto-js/#The_Cipher_Output"" rel=""nofollow"">custom format strategy.</a> Or better yet, don't convert the cipher text to a character string; keep it as binary data.</p>

<p>Please warn users of your application that it is not secure.</p>
","645","<encryption><aes><cryptojs><sjcl>","1","2","1","2015-07-08 19:06:54","","2","","4517888","","2015-07-08 17:25:13","2015-07-08 17:10:14",""
"41827428","Encrypting a file with Nodejs (Crypto) throw an error: bad base64 decode","<p>Hello and sorry if my question is stupid, I'm just beginning on nodejs and bring a heavy luggage from PHP world.</p>

<p>I'm trying to encrypt a file using a public key generated through linux command line using the GnuPG command.</p>

<p>On my app I use Express, fs and Crypto to create a buffer from the file and get the public key content and then use publicEncrypt to get the encrypted data.</p>

<p>When I do so the application stops and throw an error complaining about the PEM format: bad base64 decode.</p>

<pre><code>Error: error:0906D064:PEM routines:PEM_read_bio:bad base64 decode
</code></pre>

<p>Here you have the main parts of this code:</p>

<pre><code>var encryptStringWithRsaPublicKey = function(toEncrypt, relativeOrAbsolutePathToPublicKey) {
var absolutePath = path.resolve(relativeOrAbsolutePathToPublicKey);
var publicKey = fs.readFileSync(absolutePath, ""utf8"");
if(typeof toEncrypt !=='object') return false;
var buffer = new Buffer(toEncrypt);
console.log(publicKey);
var encrypted = crypto.publicEncrypt(publicKey, buffer);
return encrypted.toString(""base64"");
</code></pre>

<p>};</p>

<pre><code>        fs.readFile(req.files[0].path, function (err, data){
            var encrypted = encryptStringWithRsaPublicKey(data, '/home/app/data/pub_key.txt');
            if(!encrypted) {
                fs.writeFile(""/home/app/data/uploads/enc1/test.pdf"", encrypted, function(err) {
                    if(err) {
                        return console.log(err);
                    }

                    console.log(""The file was saved!"");
                    res.end(req.files[0].filename);
                }); 
            }
            else {
                res.end({error:'encryption failed. all data deleted.'});
            }
        });
</code></pre>

<p>Maybe the Public Key has some end of line bad characters somewhere or maybe Crypto requires a very special format?</p>

<p>This is the content of the pub key:</p>

<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1

mQENBFiFz2ABCADGk6E2IgbaGYIHO7EVNotxiDjB4k5UZJ4xx41RwY9LeG0c+SLW
rC/ijPFJZ/kN3nrpvTAZEYpnK51olqvw/OOgt5p3k32mW47HALx91vU9WRrykt2Y
DMj+aeMDi5QZnda8qTnWCW3E+OBg4W0ZdpwPs+eOyHWRjp6zuBFxZfrtKQuFlzHs
6KKczdGidemUQCZL7ve34EQmgeh4rDJ1oNC8QzSFOYZHiSVQDXGvZSFirc3OMZus
JiflY1Al3Y0fJj2m8catu/i9bKfAPA+YE+yU86BrgV05Skn82px2K3coiI/+eSjp
j/ROxijvwzLf/F98B3/AiMJjx8pD/9APmnSbABEBAAG0MVBheSBGaWxlIChDdWJl
IEluc3BpcmUpIDxwYXlmaWxlQGN1YmVpbnNwaXJlLmNvbT6JATgEEwECACIFAliF
z2ACGwMGCwkIBwMCBhUIAgkKCwQWAgMBAh4BAheAAAoJEBeEp+MzfXEgefgH/0bJ
Oug/m66vlENqR+y6Z+mbC7RzFnhvojJ51EB6JlJe9EJ2VwtcirxorY5zL9DjTyB2
ys/kzdeN0+FmuIIO0To7ksB1ASZ5jsg1UdQEvLuLeSZSJRzbmz9M7jvxEfR+vz0h
RJPqs6EfgAOtRyDs8C/IXyWTrhu1wI+09CChjBH0/tCJ2sO074f4xMY1IYzf8nm7
ohuiGpN1egHOVjIjIajpmb94dGBXnbGNq/tzNwGZu9GUtaeTs3+kuqqy0+eIQDvR
7AU4Gt43etwpFz4dbWVDd77OxKUFshilaChIAwGmngfFn3ksnrl/AZVsGIJrxmy0
ja5t+yZOwl7KdC82SOa5AQ0EWIXPYAEIAOHRdsrEm/WFG3Fps++Mo6xUf/CFTyz3
WQr2nkOoBxAzcHPQd/3muDNKUblRhxZMrwuVZcnOZVOOz9rMqaM5kYSAB84PpVpG
26QcYFUn5WCmR3KSn9MiKqtSFJDn695ysaCdzzEW5Y/eKgxydG4rhFOy07VcKTev
dBC19XcukjxAbzmnZ7qUFhaRrS2u11mA+s0FmRz+EVOd0uxQdJq/Lps1nMvZ3UfL
saHJuBDgX+gCarbt+7uSx3aC/jBDzrq63Ry7nqN5mypSMRBeEAmi7kKToIRDj0Uj
xwqCgU4NVj8zCG2iBlOzrfKPk9oMLgHBvMPQYDW9wLz5rQnoVr4RkrUAEQEAAYkB
HwQYAQIACQUCWIXPYAIbDAAKCRAXhKfjM31xIBDYB/0VTjC/zvFHJwD5t+8DzHjN
UqPg7Mk0kYbu6dyPYb0/S2G5uZa3LoJ99EgOhgFlfUHM9k0GBC0OTxKiUEqKtENH
+W/wBouTltqGGyzDit+KlqzKz9gsyWF/HO3GTg1Df9D8o3MhUHRGjEeuik0BbJyd
Hy4YfDk5a4qUYtFztbmUSxVqdLlFBZ7oMn3n+A25HaDtohv9g1ZC3gTLD+yTTMsG
ruOEs6ZMIOENn6pgsjFdMIUmJVP3tt9n538jVfbVf7EgTrPt+JKjoQF3EfTysTnO
Y0IuotQuA83+5Fa6IY+iFLLvkNABr1WACVOKMUzBJJJG7EnlvgPufZL3eJE4LUZ9
=rpky
-----END PGP PUBLIC KEY BLOCK-----
</code></pre>
","<p>I've found the solution to my problem.</p>

<p>In fact the method publicEncrypt is a wrapper of OpenSSL and then it expect a public/private key on that format. A key from GPG won't do it.</p>

<p>By generating the private and public keys with the following command the code work as expected:</p>

<pre><code>$ openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048
$ openssl rsa -pubout -in private_key.pem -out public_key.pem
</code></pre>
","642","<node.js><encryption><public-key-encryption><gnupg><cryptojs>","2","0","1","2017-01-27 14:43:44","","2","","","","","2017-01-24 11:45:55",""
"24241923","OpenSSL EVP and CryptoJS","<p>CryptoJS is said to be OpenSSL compatible what can be noticed <a href=""https://code.google.com/p/crypto-js/#With_OpenSSL"" rel=""nofollow"">running the demo</a>.</p>

<p>Now I want to implement the same behavior using the OpenSSL EVP API: chipher a string using a passphrase and exchange the result with CryptoJS which must be able to decrypt it (knowing the passphrase).</p>

<p>My doubt is about the standard way to exchange the iv (which I see as the key of CryptoJS and OpenSSL compatibility).</p>

<p>How am I supposed to send the iv along with the ciphered message?</p>

<p>PS: Please do not concern about client-side encryption/decryption because I am comfortable with the use case.</p>

<p><strong>Update</strong></p>

<p>Ciphering with OpenSSL command line tool</p>

<pre><code>$ echo ""Hello World"" | openssl enc -aes-256-cbc -pass pass:""Secret Passphrase"" -e -base64
</code></pre>

<p>U2FsdGVkX18Z8dTy1NR6/gm+9IxmbuT8iCblIjvV76E=</p>

<p>Deciphering with CryptoJS</p>

<pre><code>var de = CryptoJS.AES.decrypt(""U2FsdGVkX18Z8dTy1NR6/gm+9IxmbuT8iCblIjvV76E="",""Secret Passphrase"",{keySize: 256/32});

de.toString(CryptoJS.enc.Utf8); // output: Hello World
</code></pre>

<p>In my use case I want to cipher using the EVP API instead of openssl command line tool.
I am missing how to ""package"" the ciphered text, iv and salt altogether in one string as it was on ""U2FsdGVkX18Z8dTy1NR6/gm+9IxmbuT8iCblIjvV76E=""</p>

<p><strong>Update 2</strong></p>

<p>I took <a href=""http://saju.net.in/code/misc/openssl_aes.c.txt"" rel=""nofollow"">the Saju Pillai example</a> as start point.</p>

<p><strong>Update 3</strong></p>

<p>My problem is about ""interchangeability"" of the ciphered text.
I am getting the following parts</p>

<ul>
<li><strong>key :</strong> 79A38D896D90DBFE5E151A326602BC3A4A9081F3F9BEAC08EF058B96BA51CF19</li>
<li><strong>iv  :</strong> 76614325D3DA73698DDD220431AE298E00000000000000000000000000000000</li>
<li><strong>cipher text:</strong> QfCKTtVPlDcTOhC5ylwKFQ==</li>
</ul>

<p>I am looking to send a single string to the client which must be able to decipher the string and get the parts required to the decryption process (it is exactly what I observe between CryptoJS and OpenSSL)</p>
","","642","<openssl><cryptojs><evp-cipher>","3","","0","2014-06-17 08:31:08","","8","0","3640825","","2014-06-17 08:31:08","2014-06-16 10:46:27",""
"26165821","CryptoJS Decrypt Of C# DES Encrypted File Failing","<p>We have an xml file that tracks a users progress through lessons in a stand-alone training application. The xml is DES encrypted -> converted to base64 string -> written to file via the following c# code</p>

<pre><code>protected static byte[] key = new byte[] { 0x8c, 0x04, 0xD1, 0x1E, 0x14, 0xE2, 0x51, 0xDD };
protected static byte[] iv  = new byte[] { 0x96, 0xCF, 0x3A, 0x0D, 0x7D, 0x80, 0xDA, 0xA8 };
protected static int DefBlockSize = 64;

public static string Encrypt(string originalString)
{
    if (String.IsNullOrEmpty(originalString))
    {
        throw new ArgumentNullException(""Cannot decrypt a null input string"");
    }

    DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
    cryptoProvider.BlockSize = DefBlockSize;
    MemoryStream memoryStream = new MemoryStream();
    CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateEncryptor(key, iv), CryptoStreamMode.Write);
    StreamWriter writer = new StreamWriter(cryptoStream);
    writer.Write(originalString);
    writer.Flush();
    cryptoStream.FlushFinalBlock();
    writer.Flush();
    return Convert.ToBase64String(memoryStream.GetBuffer(), 0, (int) memoryStream.Length);
}

public static void EncryptToFile(string originalString, string filePath)    
{
    string base64String = DESEncryption.Encrypt(originalString);
    File.WriteAllBytes(filePath, Convert.FromBase64String(base64String));                                   
}
</code></pre>

<p>Decrypting works fine in the standalone application with the following code:</p>

<pre><code>protected override StreamReader LoadAsTextFile (string fileSystemPath)
{                   
    String base64EncryptedString = Convert.ToBase64String(File.ReadAllBytes(fileSystemPath));                               
    CryptoStream cs =  DESEncryption.DecryptToCryptoStream(base64EncryptedString);          
    StreamReader sr = new StreamReader(cs, true);
    return sr;
}
public static CryptoStream DecryptToCryptoStream(string base64EncryptedString)
{
    if (string.IsNullOrEmpty(base64EncryptedString))
    {
        throw new ArgumentNullException(""Cannot decrypt a null input string"");
    }

    DESCryptoServiceProvider cryptoProvider = new DESCryptoServiceProvider();
    cryptoProvider.BlockSize = DefBlockSize;
    MemoryStream memoryStream = new MemoryStream(Convert.FromBase64String(base64EncryptedString));
    CryptoStream cryptoStream = new CryptoStream(memoryStream, cryptoProvider.CreateDecryptor(key, iv), CryptoStreamMode.Read);
    return cryptoStream;
}
</code></pre>

<p>As a simpler test,  I DES encrypted a DateTime string <strong>""10/2/2014 10:54:25 AM""</strong> in this format. It's base64 string after encryption is <strong>P3Zj7NFQ8nUdM3FchVMxWEERB0oyOr4z</strong>. If I manually set this base64 string in the js/cryptojs (see below), I'm able to successfully decrypt the originally (c#) encrypted datetime in js/cryptojs. </p>

<pre><code>var base64 = ""P3Zj7NFQ8nUdM3FchVMxWEERB0oyOr4z"";
var utf8 = base64.toString(CryptoJS.enc.Utf8);  
var decrypted = CryptoJS.DES.decrypt(utf8, key, { iv: iv });                        
var decText = decrypted.toString(CryptoJS.enc.Utf8);
// decrypts correctly to 10/2/2014 10:54:25 AM
</code></pre>

<p>I just can't seem to load the data back from a saved file using either readAsArrayBuffer or readAsBinaryString. If I use readAsBinaryString with the js below, the base64 string I get after reading the file->converting to base64 is slightly different than the value I see in c# prior to saving the file. ( <strong>""P3Zjw6zDkVDDsnUdM3FcwoVTMVhBEQdKMjrCvjM=""</strong> in javascript and <strong>""P3Zj7NFQ8nUdM3FchVMxWEERB0oyOr4z""</strong> in c# pre-write to file).</p>

<pre><code>            if (window.File &amp;&amp; window.FileReader &amp;&amp; window.FileList &amp;&amp; window.Blob) 
            {
                var r = new FileReader();
                var parser = new DOMParser();
                r.onload = function(e)
                {

                    var key = CryptoJS.enc.Hex.parse('8c04D11E14E251DD');
                    var iv  = CryptoJS.enc.Hex.parse('96CF3A0D7D80DAA8');       

                    var data = e.target.result;
                    var parsedWordArray = CryptoJS.enc.Utf8.parse(data);
                    var base64string = CryptoJS.enc.Base64.stringify(parsedWordArray);
                    var utf8 = base64string.toString(CryptoJS.enc.Utf8);    
                    var decrypted = CryptoJS.DES.decrypt(utf8, key, { iv: iv });                        
                    var decText = decrypted.toString(CryptoJS.enc.Utf8);
                    alert(""Made it past decryption"");                       
                }
                //r.readAsArrayBuffer(gXMLFile);    
                r.readAsBinaryString(gXMLFile);
            }
</code></pre>
","<p>I have the same issue here. My password are stored by Unity but I have to read them using JS. Thanks to your post, it espired me. And I finally come out with some result.</p>

<p>Are you sure ""10/2/2014 10:54:25 AM"" after Base64 will be ""P3Zj7NFQ8nUdM3FchVMxWEERB0oyOr4z"" ? I think this is your problem.</p>

<p>BTW, I use this function, it works fine:</p>

<pre><code>CryptoJS.decodePasswardForUnity = function (encryted, key = '71617A7365646366', iv = ""1234567890abcdef"") {
    let C = CryptoJS;
    encrytedBase64 = C.enc.Base64.parse(encryted);
    toDecrypt = C.enc.Hex.parse(encrytedBase64.toString());
    let res = C.DES.decrypt(C.lib.CipherParams.create({ ciphertext: toDecrypt }), C.enc.Hex.parse(key), { iv: C.enc.Hex.parse(iv), mode: C.mode.CBC});
    return C.enc.Utf8.stringify(C.enc.Hex.parse(res.toString()));
};

CryptoJS.encodePasswardAsUnity = function (password, key = '71617A7365646366', iv = ""1234567890abcdef"") {
    let C = CryptoJS;
    toEncode = C.enc.Hex.parse(C.enc.Utf8.parse(password).toString());
    let res = C.DES.encrypt(toEncode, C.enc.Hex.parse(key), { iv: C.enc.Hex.parse(iv), mode: C.mode.CBC}).ciphertext;
    return C.enc.Base64.stringify(res);
};
</code></pre>

<p>hope this can help you</p>
","632","<javascript><c#><encryption><cryptojs>","0","1","1","2018-11-28 11:22:50","","3","","3191570","","2014-10-06 13:41:09","2014-10-02 17:03:57",""
"40945349","How to add crypto-js in webpack with angular 2","<p>I want to use <strong>crypto-js</strong> in angular 2 for encrypt password.Can any one tell me how I add crypto-js plugin in webpack. I don't have any idea about this.Please help me. </p>
","<p>Here is answer, that may give you some clue. However this is for angularjs ( angular 1).  This is how my app.js looks like.</p>

<pre><code>var jquery = require('jquery');
&lt;other requires&gt;
var CryptoJS = require('crypto-js');

var appRequires = [ngRoute, ngCookies, ngChart];
var app = angular.module('myModule', appRequires)
                 .config{...}; (hidden config goes here)

//  connect controllers services filters
require('./services/couchdbService')(app);
&lt;other controllers and services&gt;
require('./controllers/authCtrl')(app, CryptoJS);
</code></pre>

<p>Nota BENE, how above I did pass CryptoJS into authCtrl module.
Now lets investigate my authCtrl:</p>

<pre><code>module.exports = function(myModule, CryptoJS) {
  myModule.controller('authCtrl',[
   '$scope', '$http', '$routeParams', 'WebappService',
   function ($scope, $http, $routeParams, WebappService) {
   HERE GOES CONTROLLER BUSINESS LOGIC
   console.log(CryptoJS.SHA256('Taras Vaskiv'));
}]);
}
</code></pre>

<p>To be honest I had some trouble to apply webpack to angularjs. It doesnt seem that easy as it sounds.</p>
","632","<angular><webpack><cryptojs>","2","0","1","2018-04-06 17:14:57","","0","","6751153","","2016-12-03 16:37:35","2016-12-03 07:27:10",""
"25928509","Symfony2 password encoder function in Javascript","<p>I created a Symfony2 application using FOSUserBundle and FOSRestBundle. I'd like to connect other application with my Symfony application using rest api. 
I need to write the Symfony password encoder function in Javascript.
Actually in PHP, it goes like:</p>

<pre><code>$salt = ""secret"";
$password = ""azerty"";
$salted = $password.'{'.$salt.'}';
$digest = hash('sha512', $salted, true);

for ($i = 1; $i &lt; 5000; $i++) {
    $digest = hash('sha512', $digest.$salted, true);
}
$digest = base64_encode($digest);

return $digest;
</code></pre>

<p>In Javascript, I tried to use CryptoJS library. My code is:</p>

<pre><code>var salt = 'secret',
    password = 'azerty',
    salted = password + '{' + salt + '}'
    digest = CryptoJS.SHA512(salted);

for (var i=1; i&lt;5000; i++) {
    digest = CryptoJS.SHA512(digest+salted);
}

digest = digest.toString(CryptoJS.enc.Base64);

return digest;
</code></pre>

<p>But guess what ? It does not work and i don't know why.
Can anyone help please ? :)</p>

<p>Regards,
Colzak.</p>
","<p>It doesn't work because ""[t]he hash you get back isn't a string yet. It's a WordArray object. When you use a WordArray object in a string context, it's automatically converted to a hex string."" (<a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">source</a>)
By using <code>digest = CryptoJS.SHA512(digest+salted);</code> digest is converted into a hex string.
If you change your PHP code to</p>

<pre><code>$salt = ""secret"";
$password = ""azerty"";
$salted = $password.'{'.$salt.'}';
$digest = hash('sha512', $salted, false);

for ($i = 1; $i &lt; 5000; $i++) {
    $digest = hash('sha512', $digest.$salted, false);
}

return $digest;
</code></pre>

<p>and return the digest as a hex string (<code>digest + ''</code> or <code>digest.toString(CryptoJS.enc.Hex)</code> will do) it will work.
I'm not sure how to change the JavaScript code to match the original PHP code though.</p>
","626","<javascript><php><symfony><password-encryption><cryptojs>","1","0","2","2016-06-26 17:45:10","25937167","7","","","","","2014-09-19 07:23:37",""
"25928509","Symfony2 password encoder function in Javascript","<p>I created a Symfony2 application using FOSUserBundle and FOSRestBundle. I'd like to connect other application with my Symfony application using rest api. 
I need to write the Symfony password encoder function in Javascript.
Actually in PHP, it goes like:</p>

<pre><code>$salt = ""secret"";
$password = ""azerty"";
$salted = $password.'{'.$salt.'}';
$digest = hash('sha512', $salted, true);

for ($i = 1; $i &lt; 5000; $i++) {
    $digest = hash('sha512', $digest.$salted, true);
}
$digest = base64_encode($digest);

return $digest;
</code></pre>

<p>In Javascript, I tried to use CryptoJS library. My code is:</p>

<pre><code>var salt = 'secret',
    password = 'azerty',
    salted = password + '{' + salt + '}'
    digest = CryptoJS.SHA512(salted);

for (var i=1; i&lt;5000; i++) {
    digest = CryptoJS.SHA512(digest+salted);
}

digest = digest.toString(CryptoJS.enc.Base64);

return digest;
</code></pre>

<p>But guess what ? It does not work and i don't know why.
Can anyone help please ? :)</p>

<p>Regards,
Colzak.</p>
","<p>Ok @timothymctim 's response helped me. Actually, I think it's an issue about character encoding.
Here's a (strange) solution :</p>

<p>The PHP:</p>

<pre><code>$salt = ""secret"";
$password = ""azerty"";
$salted = $password.'{'.$salt.'}';
$digest = hash('sha512', $salted, true);

for ($i = 1; $i &lt; 5000; $i++) {
    $digest = hash('sha512', utf8_encode($digest).$salted, true);
}
$digest = base64_encode($digest);

return $digest;
</code></pre>

<p>And the Javascript :</p>

<pre><code>var salt = 'secret',
password = 'azerty',
salted = password + '{' + salt + '}'
digest = CryptoJS.SHA512(salted);

for (var i=1; i&lt;5000; i++) {
    digest = CryptoJS.SHA512(digest.toString(CryptoJS.enc.Latin1)+salted);
}

digest = digest.toString(CryptoJS.enc.Base64);

return digest;
</code></pre>

<p>I don't know what to think.
Thanks anyway everybody who helped !</p>
","626","<javascript><php><symfony><password-encryption><cryptojs>","1","2","2","2016-06-26 17:45:10","25937167","7","","","","","2014-09-19 07:23:37",""
"29832579","different sha256 hash value of file vs. file contents as WordArray","<p>I made a test text file, the contents are:
<code>aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh</code></p>

<p>The sha256 hex digest for this value as a string is:
<code>75eef9680de51f6f70291057e9afc5975470960dfec5f37f83db69aa625786e5</code></p>

<p>I get this same value when hashing it in python using hashlib, js using Crypto.js, or using ssl on the file from the command line.</p>

<p>however, in js, when I read the file in like this:</p>

<pre><code>var fr = new FileReader();
fr.readAsArrayBuffer(file);
console.log(fr.result.byteLength); // it's 64...
var input = CryptoJS.lib.WordArray.create(new Uint8Array(fr.result));
CryptoJS.SHA256(input).toString();
</code></pre>

<p>I get:
<code>8f76bf13468fb12ac4e59610adff70fd10282e8494a2749db4677f81e2c6e998</code></p>

<p>UPDATE: from the crypto.js docs:</p>

<pre><code>/**
 * cryptojs use WordArray (CryptoJS.lib.WordArray) as parameter/result frequently.
 *    A WordArray object represents an array of 32-bit words. When you pass a string,
 * it's automatically converted to a WordArray encoded as UTF-8.
 */
</code></pre>

<p>suspecting it could be a utf-8 vs ascii thing, or something like that, but have no idea how to check.</p>
","<p>I found <a href=""https://github.com/vibornoff/asmcrypto.js"" rel=""nofollow"">asmCrypto.js</a> which accepts both ArrayBuffers and Uint8Arrays as input - I'm now getting the expected result (It's also pretty fast).  I use it like this:</p>

<pre><code>var fr = new FileReader();
fr.readAsArrayBuffer(file);
console.log(fr.result.byteLength); // it's still 64...
asmCrypto.SHA256.hex(new Uint8Array(fr.result));
asmCrypto.SHA256.hex(fr.result); // this also works
</code></pre>
","621","<javascript><hash><cryptojs><arraybuffer>","1","2","1","2015-04-30 05:24:27","29838953","10","","2712644","","2015-04-23 19:35:17","2015-04-23 19:24:11",""
"31954441","CryptoJS AES encryption output not matching","<p>I am having issue with CryptoJS. </p>

<p>I tried to encrypt the a string but it is giving the different output.</p>

<p>String: ""test message""
Key: ""123456""</p>

<p>This is the testing code I tried to run</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
   var encrypted = CryptoJS.AES.encrypt(""test message"", ""123456"");


   alert(encrypted);              //U2FsdGVkX19Nf4gjPS3MUcbKBD10P/Ty/4EwUF1PMhc=
&lt;/script&gt;
</code></pre>

<p>and it returned the output U2FsdGVkX19Nf4gjPS3MUcbKBD10P/Ty/4EwUF1PMhc=</p>

<p>But in this website <a href=""http://aesencryption.net/"" rel=""nofollow"">http://aesencryption.net/</a> I am getting fulfuBaIGS0AqxwyXoPCgw== as the result.</p>

<p>How do I use CryptoJS to generate the encrypted output as fulfuBaIGS0AqxwyXoPCgw==? </p>
","<p>Those sites are bad, because they don't tell you what actually happens when you encrypt something. The two example codes below the online-encryption are different and don't produce the same thing as the online-encryption.</p>

<p>It seems <a href=""https://stackoverflow.com/a/28219990"">this answer</a> provides a working code in C# for that site. If this is true, then you can't reproduce this in CryptoJS, because CryptoJS only supports AES, whereas that example C# code uses Rijndael (note the block size of 256 bit).</p>

<p>AES is only defined for a fixed block size of 128 bit, but Rijndael supports 128, 192 and 256 bit block sizes. Both support key sizes of 128, 192 and 256 bit. CryptoJS actually implements only AES, but that site does not use AES despite its name.</p>
","620","<javascript><encryption><aes><cryptojs>","0","1","1","2015-08-12 09:33:00","31961308","1","","1816580","","2015-08-12 06:10:57","2015-08-12 01:06:28",""
"48832870","Using node.js module on jsfiddle","<p>I have working algorithm on my own project and I need it to be uploaded on jsfiddle and working as expected. The bad thing is I have no idea how to use <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto module</a> to work there.</p>

<pre><code>this.getOffset = function(forcedOffset){
    return Bluebird.try(function () {
        if (forcedOffset != undefined) return forcedOffset;

        return CryptoJS.randomBytes(4);
    }).then(function (randomBytes) {
        var random = Number.parseInt(randomBytes.toString('hex'), 16) / 4294967295;
        var maxVal = 1000000;
        return Math.floor(random * maxVal);
    });
};
</code></pre>

<p>and for my project I'm just requiring it, but how to handle this situation here?</p>
","<p>You need to find it on a CDN and load it.</p>

<p>After googling ""cryptojs cdn"" i found this list of the resources </p>

<p><a href=""https://cdnjs.com/libraries/crypto-js"" rel=""nofollow noreferrer"">https://cdnjs.com/libraries/crypto-js</a></p>
","615","<node.js><jsfiddle><cryptojs>","-1","1","1","2018-02-16 18:36:49","","2","","","","","2018-02-16 18:30:51",""
"48705662","Nodejs generate secure random characters not including given chars","<p>I was reading about generating secure random generator in nodejs.
I tried this and works well to generate secure random characters.</p>

<pre><code>const crypto = require('crypto');

var length = 22
var generated = crypto.randomBytes(Math.ceil(length / 2))
                      .toString('hex').slice(0, length);
//it returned ""14cf777d3ca307f5e78496""
</code></pre>

<p>How can I generate secure random characters not including given <code>pattern</code> in nodejs.
Ex: <code>['a', '2']</code>, it should return secure chars without given pattern <code>14cf777d3cr307f5e78496</code></p>
","<p>The <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto module</a> does not offer directly what you are looking for. 
Although, what you can do, is to keep recursively generating your crypto until none of the patterns are found inside.</p>

<p>For that, you can use the following:</p>

<pre><code>async function generateRandomCrypto(length, patterns) {
    const generated = await crypto.randomBytes(Math.ceil(length / 2)).toString('hex').slice(0, length);

    let isValid = true;
    for (pattern of patterns) {
        if (generated.indexOf(pattern) !== -1) {
            isValid = false;
            break;
        }
    }

    if (!isValid) {
        return await generateRandomCrypto(length, patterns);
    }

    return generated;  
}
</code></pre>

<p>Now, the function will keep generating until it finds one that does not include any of the strings provided in the <code>patterns</code> array.</p>

<p>If you are somehow worried about any kind of performance impact - there is no need to.</p>

<p>Assuming your patterns are not single letter strings, it is very unlikely that they will appear in the random sequence - thus, the generation might run only once. </p>

<p>And <em>even if</em>, I did a test for you - I ran this with a patterns array looking like that:</p>

<pre><code>const patterns = ['a', 'b'];
</code></pre>

<p>And I had 4 - 8 function executions on average.</p>
","612","<node.js><random><cryptojs>","1","1","1","2018-02-09 13:22:07","48706862","3","0","","","","2018-02-09 12:17:09",""
"20262472","MD5.ComputeHash(Encoding.Unicode.GetBytes(value)) into javascript","<p>I need to translate the line below from vb.net to javascript</p>

<pre><code>MD5.ComputeHash(Encoding.Unicode.GetBytes(value))
</code></pre>

<p>Im trying to use CryptoJS but I get diffrent results as I need to pass a string into that but a byte array into the MD5 function in VB.net</p>

<p>Can anyone help?</p>

<p>Thank you</p>
","<p><code>Encoding.Unicode</code> is a (misleading) name used by Windows for the UTF-16LE encoding.</p>

<p>However the CryptoJS functions, when given a string, encode it to bytes using the (more common) UTF-8, not UTF-16LE:</p>

<blockquote>
  <p>The hash algorithms accept either strings or instances of CryptoJS.lib.WordArray. A WordArray object represents an array of 32-bit words. When you pass a string, it's automatically converted to a WordArray encoded as UTF-8.</p>
</blockquote>

<p>So you will need to create a WordArray from the string yourself before passing it in to MD5. With a new enough CryptoJS there's a function to do that for you:</p>

<pre><code>CryptoJS.MD5(CryptoJS.enc.Utf16LE.parse(str))
</code></pre>
","608","<javascript><vb.net><unicode><md5><cryptojs>","0","0","1","2013-11-30 18:01:04","","1","","","","","2013-11-28 09:39:54",""
"36998066","Node js equivalent code for android AES encryption","<p>I am trying to encrypt my message in android and decrypt in node js server.</p>

<p>Android Code :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>SecretKeySpec secretkeyspec = new SecretKeySpec(""password"".getBytes(), ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, secretkeyspec);
byte[] encoded = cipher.doFinal(s.getBytes());
System.out.println(Arrays.toString(encoded));</code></pre>
</div>
</div>
</p>

<p>Node JS Code :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var crypto = require('crypto');
var CIPHER_ALGORITHM = 'aes-128-cbc';
var key = 'password';
var ivBuffer = new Buffer(16);
ivBuffer.fill(0);

var cipher = crypto.createCipheriv(CIPHER_ALGORITHM, new Buffer(key, 'utf-8'), ivBuffer);
var encryptedBuffer = cipher.update(plainText, 'utf-8');
var fBuf = new Int8Array(Buffer.concat([encryptedBuffer, cipher.final()]));
console.log(fBuf);</code></pre>
</div>
</div>
</p>

<p>When i try to print the buffers im getting different values between android and node js.</p>

<p>Node Buffer : </p>

<p>[26,
   116,
   2,
   -56,
   -70,
   121,
   -44,
   66,
   101,
   84,
   -46,
   127,
   -70,
   -42,
   67,
   31,
   124,
   -104,
   -24,
   88,
   74,
   4,
   -22,
   -70,
   -39,
  48,
 -120,
 -21,
  37,
 -15,
 -24,
 -30 ]</p>

<p>Android Buffer :</p>

<p>[26, 116, 2, -56, -70, 121, -44, 66, 101, 84, -46, 127, -70, -42, 67, 31, -92, 97, 16, -101, -45, -68, 108, 89, -125, 17, -71, 53, 2, -13, 31, -79]</p>

<p>could someone tell whats the android default AES equivalent node js decryption code.</p>
","<p>Make sure mode of operation (for example, CBC) and padding (for example, PKCS5) are match between both implementations. </p>
","607","<android><node.js><encryption><aes><cryptojs>","1","0","2","2016-05-03 08:25:34","","0","2","","","","2016-05-03 07:21:58",""
"36998066","Node js equivalent code for android AES encryption","<p>I am trying to encrypt my message in android and decrypt in node js server.</p>

<p>Android Code :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>SecretKeySpec secretkeyspec = new SecretKeySpec(""password"".getBytes(), ""AES"");
Cipher cipher = Cipher.getInstance(""AES"");
cipher.init(Cipher.ENCRYPT_MODE, secretkeyspec);
byte[] encoded = cipher.doFinal(s.getBytes());
System.out.println(Arrays.toString(encoded));</code></pre>
</div>
</div>
</p>

<p>Node JS Code :</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var crypto = require('crypto');
var CIPHER_ALGORITHM = 'aes-128-cbc';
var key = 'password';
var ivBuffer = new Buffer(16);
ivBuffer.fill(0);

var cipher = crypto.createCipheriv(CIPHER_ALGORITHM, new Buffer(key, 'utf-8'), ivBuffer);
var encryptedBuffer = cipher.update(plainText, 'utf-8');
var fBuf = new Int8Array(Buffer.concat([encryptedBuffer, cipher.final()]));
console.log(fBuf);</code></pre>
</div>
</div>
</p>

<p>When i try to print the buffers im getting different values between android and node js.</p>

<p>Node Buffer : </p>

<p>[26,
   116,
   2,
   -56,
   -70,
   121,
   -44,
   66,
   101,
   84,
   -46,
   127,
   -70,
   -42,
   67,
   31,
   124,
   -104,
   -24,
   88,
   74,
   4,
   -22,
   -70,
   -39,
  48,
 -120,
 -21,
  37,
 -15,
 -24,
 -30 ]</p>

<p>Android Buffer :</p>

<p>[26, 116, 2, -56, -70, 121, -44, 66, 101, 84, -46, 127, -70, -42, 67, 31, -92, 97, 16, -101, -45, -68, 108, 89, -125, 17, -71, 53, 2, -13, 31, -79]</p>

<p>could someone tell whats the android default AES equivalent node js decryption code.</p>
","<p>I finally found the answer.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var cipher = crypto.createCipheriv(CIPHER_ALGORITHM, new Buffer(key, 'utf-8'), '');
  var encryptedBuffer = cipher.update(plainText, 'utf-8');
  var finalEncryptedBuffer = new Int8Array(Buffer.concat([encryptedBuffer, cipher.final()]));
  console.log(encodeBytes(finalEncryptedBuffer));</code></pre>
</div>
</div>
</p>
","607","<android><node.js><encryption><aes><cryptojs>","1","1","2","2016-05-03 08:25:34","","0","2","","","","2016-05-03 07:21:58",""
"53836196","Angular 7 AES encrypting password with crypt-js","<p>I am trying to encrypt the password using AES technique and sending it to api which is developed on .net. Issue I am facing is I am getting error: </p>

<p>I am using Crypto-JS typed version: <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">Crypto-JS Doc</a> </p>

<blockquote>
  <p>Padding is invalid and cannot be removed.</p>
</blockquote>

<p>My typescript code is :</p>

<pre><code>let encrypted = CryptoJS.AES.encrypt('Coll@123', '16ad55fd-598b-45d7-a371-a1e011ec1345', {iv: '6fcc45cc3a8a4764'}).ciphertext.toString();
console.log(""Encrypted: "", encrypted);
let decrypted = CryptoJS.AES.decrypt(encrypted, ""16ad55fd-598b-45d7-a371-a1e011ec1345"", {iv: '6fcc45cc3a8a4764'}).toString(CryptoJS.enc.Base64)
console.log(""Decrypted: "", decrypted);
</code></pre>

<p>My .net code is :</p>

<pre><code>public static string encrypt(string encryptString, string EncryptionKey)
{
    Cryptography cript = new Cryptography();
    string ivString = AppConstants.EncryptionKey_IV_Default; //16 character IV
    string key = cript.getHashSha256(EncryptionKey, 32);
    string cipherText = cript.Encrypt(encryptString, key, ivString);
    return cipherText;
}
</code></pre>

<p>Note: I have not developed the .net code I am consuming someone else API.</p>

<p>Please help I dont know what I am doing wrong here. Is there something which I am missing here.</p>
","","603","<c#><angular><typescript><cryptojs>","0","","0","2018-12-18 15:28:50","","3","","1260204","","2018-12-18 15:28:50","2018-12-18 15:23:23",""
"54024763","Encrypt a file in node and decrypt in java using ""AES/GCM/NoPadding"". Basically AES/GCM/NoPadding equivalent in node.js","<p>I have encrypt the file using node.js and decrypt in JAVA. Decryption is done in JAVA using ""AES/GCM/Nopadding"" algorithm and it is third party app hence I cannot change the JAVA code.
I am encrypting the file in node.js using ""aes-256-gcm"" (not sure if it is equivalent to ""AES/GCM/Nopadding"") algorithm. </p>

<p>I have tried with crypto, node-forge npm module also tried setting cipher.setAutoPadding(false). But no luck.
Could you please guide me where I am going wrong.</p>

<p>code in node.js</p>

<pre><code>const
 algorithm = 'aes-256-gcm',
 randomKey = crypto.randomBytes( 32 ),
 randomIv = crypto.randomBytes( 16 );
const
 cipher = crypto.createCipheriv( algorithm, randomKey, randomIv ),
 input = fs.createReadStream( './imageTest.jpg.gz' ), //gzip image 
 output = fs.createWriteStream( './imageTest.jpg.gz.enc' );

input.pipe( cipher ).pipe( output );
</code></pre>

<p>code to decrypt in JAVA</p>

<pre><code>byte[] decrypt(byte[] encrptedData, byte[] key, byte[] iv) {

    GCMParameterSpec ivSpec = new GCMParameterSpec(128, iv);
    Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), ivSpec);
    return cipher.doFinal(encryptedData);
}
</code></pre>

<p>When decrypting the file I get the below error at <code>cipher.doFinal(encryptedData)</code> step</p>

<pre><code>Caused by: javax.crypto.AEADBadTagException: Tag mismatch!
    at com.sun.crypto.provider.GaloisCounterMode.decryptFinal(GaloisCounterMode.java:571)
    at com.sun.crypto.provider.CipherCore.finalNoPadding(CipherCore.java:1046)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:983)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:845)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:446)
    at javax.crypto.Cipher.doFinal(Cipher.java:2165)
</code></pre>

<p>so I need to know how to achieve an equivalent in node.js </p>
","<p>Add this line into NodeJs after the decryption is finished to get the authentication tag.</p>

<pre><code>const tag = cipher.getAuthTag();
</code></pre>

<p>Transmit this tag, too.</p>

<p>And. in Java part, append it before <code>dofinal</code></p>

<pre><code>cipher.update(textBytes);
</code></pre>
","601","<java><node.js><encryption><cryptojs>","1","0","1","2019-01-03 16:04:27","54025311","1","0","7248342","","2019-01-03 16:04:27","2019-01-03 14:57:54",""
"33472621","Unable to send Crypto JS encrypted data via ajax call","<p>I am trying to encrypt a password and store it on Mongo LAB via Ajax call post.
I am getting the following error : 
I searched for the error but not getting what it means that it is pointing circularly.
Error:</p>

<pre><code>TypeError: Converting circular structure to JSON
    at Object.stringify (native)
    at n.$scope.signup (file:///C:/Users/naval.joshi/Desktop/eWallet/Assignment/Assignment/register.js:26:32)
    at fn (eval at &lt;anonymous&gt; (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:212:409), &lt;anonymous&gt;:4:209)
    at f (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:253:485)
    at n.$eval (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:133:221)
    at n.$apply (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:133:451)
    at HTMLButtonElement.&lt;anonymous&gt; (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:254:36)
    at HTMLButtonElement.Hf.c (https://ajax.googleapis.com/ajax/libs/angularjs/1.4.7/angular.min.js:35:217)
</code></pre>

<p>Code:</p>

<pre><code>var reg = angular.module('register', ['ngRoute']);
reg.controller('regCntrl', function($scope,$http) {
     $scope.signup = function() {

        $scope.encryptedData = CryptoJS.AES.encrypt($scope.password, ""123""); 
        alert($scope.encryptedData);

        //alert(""naval"");

                      var inventory = {
                        name: $scope.name ,
                        email: $scope.email,
                        password: $scope.encryptedData,
                        phoneno:$scope.phoneno
                          };
            $.ajax({
                url: ""https://api.mongolab.com/api/1/databases/geolocation/collections/boom?apiKey=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"",
                type: ""POST"",
                data: JSON.stringify( inventory ),
                contentType: ""application/json; charset=utf-8""
            }).done(function( msg ) {
                console.log(msg);
            });
 };
    // populate the code to fill mongo DB
});
</code></pre>
","<p>The fix I believe ( similar to <a href=""https://stackoverflow.com/questions/36874335/how-to-pass-encrypted-data-via-browser-html5-session-variable?noredirect=1#comment61315667_36874335"">How to pass encrypted data via browser (HTML5) session variable</a>) is to add <code>.toString()</code> to your encrypted object. So change your encryption line to this:</p>

<pre><code>$scope.encryptedData = CryptoJS.AES.encrypt($scope.password, ""123"").toString(); 
</code></pre>

<p>Also just a tip, rather than <code>alert</code>ing values, <code>console.log</code> will show you what the actual value is of the variable you're dealing with)</p>
","600","<ajax><angularjs><http><cryptojs>","0","1","1","2016-04-26 20:12:35","","0","","","","","2015-11-02 07:26:39",""
"35853392","Encrypt string using vb.net AES/CBC and need to decrypt using JavaScript CryptoJS","<p>I have a vb.net Windows form app that encrypts a string to a file.  I now need JavaScript to decrypt that value.  I have attempted to use CryptoJS but I am struggling with syntax and how to get the passphrase, salt and init vector in the right format to use in CryptoJS.PBKDF2 (assuming that is the right thing to use).</p>

<p><strong>Calling Method</strong>  </p>

<pre><code>Dim encryptedComplianceValue = encrypt2(complianceValue, ""Password"", ""Salt Value"", ""SHA1"", 2, ""@1B2c3D4e5F6g7H8"", 256)
</code></pre>

<p><strong>Encryption Method</strong></p>

<pre><code>Public Function encrypt2(ByVal plainText As String, ByVal passPhrase As String, ByVal saltValue As String, ByVal hashAlgorithm As String, ByVal passwordIterations As Integer, ByVal initVector As String, ByVal keySize As Integer) As String

    Dim initVectorBytes As Byte()
    initVectorBytes = Encoding.ASCII.GetBytes(initVector)

    Dim saltValueBytes As Byte()
    saltValueBytes = Encoding.ASCII.GetBytes(saltValue)

    Dim plainTextBytes As Byte()
    plainTextBytes = Encoding.UTF8.GetBytes(plainText)

    Dim password As Rfc2898DeriveBytes
    password = New Rfc2898DeriveBytes(passPhrase, saltValueBytes, passwordIterations)

    Dim keyBytes As Byte()
    keyBytes = password.GetBytes(keySize / 8)

    Dim symmetricKey As RijndaelManaged
    symmetricKey = New RijndaelManaged()

    symmetricKey.Mode = CipherMode.CBC

    Dim encryptor As ICryptoTransform
    encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes)

    Dim memoryStream As MemoryStream
    memoryStream = New MemoryStream()

    Dim cryptoStream As CryptoStream
    cryptoStream = New CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write)
    cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length)
    cryptoStream.FlushFinalBlock()

    Dim cipherTextBytes As Byte()
    cipherTextBytes = memoryStream.ToArray()

    memoryStream.Close()
    cryptoStream.Close()

    Dim cipherText As String
    cipherText = Convert.ToBase64String(cipherTextBytes)

    Return cipherText
End Function
</code></pre>

<p><strong>JavaScript</strong>  </p>

<pre class=""lang-js prettyprint-override""><code>function decryptMsg256() 
{
    var keySize = 256;
    var iterations = 2;
    var algorithm = 'AES-256-CBC';

    // the password that user provides
    var userPass = ""Password""; 
    console.log(""user pass : "" + userPass);

    // get the encrypted msg 
    var encMsg64 = ""v6shkblimfQMOoa8VxICjQ=="";
    var encMsg = CryptoJS.enc.Base64.parse(encMsg64);



    //var salt =CryptoJS.enc.Utf8.parse(""Mon,07-Mar-2016 18:50:46 GMT"");
    var salt = ""Salt Value"";
    console.log('salt:  '+ salt);
    varsaltbytes=[];

    for(vari=0;i&lt;salt.length;++i){
        saltbytes.push(salt.charCodeAt(i));
    }
    console.log('saltbytes:  '+ saltbytes);

    //var iv =CryptoJS.enc.Utf8.parse(""@1B2c3D4e5F6g7H8"");
    var iv = ""@1B2c3D4e5F6g7H8"";
    console.log('IV:  '+ iv);
    varivbytes=[];

    for(vari=0;i&lt;iv.length;++i){
        ivbytes.push(iv.charCodeAt(i));
    }
    console.log('ivbytes:  '+ ivbytes);

    //var saltBuffer = new Buffer(salt);
    //var passwordBuffer = new Buffer(userPass);

    var key = CryptoJS.PBKDF2(userPass, saltbytes,{keyBytes: 32,      iterations: 2 });
    //var key = CryptoJS.PBKDF2(userPass, salt, iterations, keySize/8);
    //var decipher = CryptoJS.createDecipheriv(algorithm, key, iv);

    console.log( 'key: '+ key);
    varkeybytes=[];

    for(vari=0;i&lt;key.length;++i){
        keybytes.push(key.charCodeAt(i));
    }
    console.log('keybytes:  '+ keybytes);


    //var plainText=""Hello, World!"";

    //console.log('Plain Text  '+ plainText );

    //var encMsg = CryptoJS.AES.encrypt(plainText, key,  {
         //               iv:iv,
          //            mode: CryptoJS.mode.CBC,
           //             padding: CryptoJS.pad.Pkcs7
    //      });


    //console.log('Encrypted Message  '+ encMsg );




    var decText = '';

    var decMsg = CryptoJS.AES.decrypt( encMsg, key, {
                    iv:iv,
                    mode: CryptoJS.mode.CBC,
                    //padding: CryptoJS.pad.Pkcs7
                    } );
    //console.log( ""decryptedData = "" + decMsg );

    // convert to UTF8 string
    decText = decMsg.toString( CryptoJS.enc.Utf8);
    console.log( ""decryptedText = "" + decText );

}
</code></pre>
","<p>You have multiple issues:</p>

<ul>
<li><p>Your IV is a simple ASCII string, so you can easily parse it to a binary format with </p>

<pre><code>var iv = CryptoJS.enc.Utf8.parse(""@1B2c3D4e5F6g7H8"");
</code></pre></li>
<li><p>Don't use your custom ""binary"" format with <code>saltbytes.push(salt.charCodeAt(i));</code> or similar. You need to use CryptoJS' native format, which is available through</p>

<pre><code>CryptoJS.enc.&lt;Encoder&gt;.parse(string)
</code></pre></li>
<li><p>The output size of PBKDF2 is specified with <code>keySize</code> and not <code>keyBytes</code>:</p>

<pre><code>var key = CryptoJS.PBKDF2(userPass, salt, {keySize: 256/32,      iterations: 2 });
</code></pre></li>
<li><p>The decryption function expects the ciphertext to be a CipherParams object. Good thing, duck-typing works:</p>

<pre><code>var decMsg = CryptoJS.AES.decrypt({
    ciphertext: encMsg
}, key, {
    iv: iv
});
</code></pre></li>
</ul>
","598","<node.js><vb.net><encryption><aes><cryptojs>","1","2","1","2016-03-07 21:21:21","35854279","1","","1816580","","2016-03-07 21:06:29","2016-03-07 20:29:49",""
"15145521","Encoding AES in Go and Decoding in CryptoJS","<p>I have these in Go:</p>

<pre><code>var commonIV = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
plaintext := []byte(""hello, world"")
key_text := ""32o4908go293hohg98fh40gh""
c, err := aes.NewCipher([]byte(key_text))
if err != nil {
    fmt.Printf(""Error: NewCipher(%d bytes) = %s"", len(key_text), err)
    return
}
cfbdec := cipher.CBCEncrypter(c, commonIV)
ciphertext := make([]byte, len(plaintext))
cfbdec.CryptBlock(ciphertext, plaintext)
fmt.Printf(""%x"", ciphertext) //HEX
</code></pre>

<p>Output:</p>

<blockquote>
  <p>e0df84c3b83681a8133e1787</p>
</blockquote>

<p>and I import the following urls:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/mode-cfb-min.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1/build/components/pad-nopadding.js""&gt;&lt;/script&gt;
</code></pre>

<p>and my code in JS is the following:</p>

<pre><code>var data = CryptoJS.enc.Hex.parse(""e0df84c3b83681a8133e1787"");
console.log(data);
var key = ""32o4908go293hohg98fh40gh"";
var iv = CryptoJS.enc.Base64.parse(""AAAAAAAAAAAAAAAAAAAAAA=="");
console.log(iv);

var encrypted = {};
encrypted.key=key;
encrypted.iv=iv;
encrypted.ciphertext = data;

var dec = CryptoJS.AES.decrypt(encrypted, key, { mode: CryptoJS.mode.CFB, iv: iv,  padding: CryptoJS.pad.NoPadding  });

console.log(dec);
console.log(dec.toString());
console.log(dec.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>What i'm doing wrong?</p>
","<p>Don't you want a CBCEncrypter in the Go code?</p>
","593","<javascript><go><cryptojs>","0","1","2","2013-03-02 02:46:59","15170129","1","","707202","","2013-03-01 17:38:47","2013-02-28 20:59:05",""
"15145521","Encoding AES in Go and Decoding in CryptoJS","<p>I have these in Go:</p>

<pre><code>var commonIV = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
plaintext := []byte(""hello, world"")
key_text := ""32o4908go293hohg98fh40gh""
c, err := aes.NewCipher([]byte(key_text))
if err != nil {
    fmt.Printf(""Error: NewCipher(%d bytes) = %s"", len(key_text), err)
    return
}
cfbdec := cipher.CBCEncrypter(c, commonIV)
ciphertext := make([]byte, len(plaintext))
cfbdec.CryptBlock(ciphertext, plaintext)
fmt.Printf(""%x"", ciphertext) //HEX
</code></pre>

<p>Output:</p>

<blockquote>
  <p>e0df84c3b83681a8133e1787</p>
</blockquote>

<p>and I import the following urls:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/mode-cfb-min.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1/build/components/pad-nopadding.js""&gt;&lt;/script&gt;
</code></pre>

<p>and my code in JS is the following:</p>

<pre><code>var data = CryptoJS.enc.Hex.parse(""e0df84c3b83681a8133e1787"");
console.log(data);
var key = ""32o4908go293hohg98fh40gh"";
var iv = CryptoJS.enc.Base64.parse(""AAAAAAAAAAAAAAAAAAAAAA=="");
console.log(iv);

var encrypted = {};
encrypted.key=key;
encrypted.iv=iv;
encrypted.ciphertext = data;

var dec = CryptoJS.AES.decrypt(encrypted, key, { mode: CryptoJS.mode.CFB, iv: iv,  padding: CryptoJS.pad.NoPadding  });

console.log(dec);
console.log(dec.toString());
console.log(dec.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>What i'm doing wrong?</p>
","<p>It looks like you are using <code>CBCEncrypter</code> (block counter mode) in the Go but <code>CryptoJS.mode.CFB</code> (cypher feedback mode) in the JS code.  As far as I know, these are not compatible block modes.</p>
","593","<javascript><go><cryptojs>","0","1","2","2013-03-02 02:46:59","15170129","1","","707202","","2013-03-01 17:38:47","2013-02-28 20:59:05",""
"51127116","Encrypt Arraybuffer with cryptojs","<p>I try to encrypt an ArrayBuffer with AES so convert is to an wordArray and then to a string:</p>

<pre><code>private encrypt(file: ArrayBuffer, key: string): string {
    const wordArray = CryptoJS.lib.WordArray.create(file);
    const str = CryptoJS.enc.Hex.stringify(wordArray);
    console.log(str); //6920616d206120737472696e67
    return CryptoJS.AES.encrypt(str, key).toString();
}
</code></pre>

<p>Now I want to decrypt back to an ArrayButter, but the printed strings do not even match:</p>

<pre><code>private decrypt(file: string, key: string) {
    const decrypted = CryptoJS.AES.decrypt(file, key);
    console.log(decrypted.toString()); //3639323036313664323036313230373337343732363936653637
}
</code></pre>

<p>I think I messed up some step but I don't know where. </p>

<p><em>Update</em>: I need to convert the string to utf to generate a wordarray:</p>

<pre><code>private decrypt(file: string, key: string) {
    const decrypted = CryptoJS.AES.decrypt(file, key);
    const str = decrypted.toString(CryptoJS.enc.Utf8);
    const wordArray = CryptoJS.enc.Hex.parse(str);
}
</code></pre>

<p>Now I am only one step away from converting it to an ArrayBuffer again</p>
","","593","<javascript><cryptojs>","0","","0","2018-07-01 22:19:14","","9","","4776831","","2018-07-01 22:19:14","2018-07-01 21:21:06",""
"48007423","Implement encrypt function from crypto-js library in Java","<p><a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a> is used by javascript developers to encrypt text. Its simple to use.  </p>

<pre><code>var CryptoJS = require(""crypto-js"");

// Encrypt
var ciphertext = CryptoJS.AES.encrypt('my message', 'secret key 123');

// Decrypt
var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), 'secret key 123');
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>In this example <em>encrypt</em> function is taking only two arguments messageToEncrypt and salt. Rest of the configuration would be inside its definition. I am not a javascript guy so its difficult to find and understand <em>encrypt</em> definition.   </p>

<p>I want to achieve same <code>AES</code> encryption using java. So for same input argument e.g. messageToEncrypt and salt I should get same encrypted text using crypto-js library and Java implementation.  </p>

<p>I tried <code>javax.crypto</code> by exploring some links on google.  </p>

<pre><code>String plainText = ""messageToEncrypt"";
String key = ""mySalt"";
SecretKey secKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
Cipher aesCipher = Cipher.getInstance(""AES"");
aesCipher.init(Cipher.ENCRYPT_MODE, secKey);
byte[] x = aesCipher.doFinal(plainText.getBytes());
System.out.println(x);
</code></pre>

<p>But this is not working for me because I dont know exact parameters like keySize and iterationCount.  </p>

<p>I tried to use <a href=""https://github.com/mpetersen/aes-example/blob/master/src/main/java/org/cloudme/sample/aes/AesUtil.java"" rel=""nofollow noreferrer"">https://github.com/mpetersen/aes-example/blob/master/src/main/java/org/cloudme/sample/aes/AesUtil.java</a> also but again I am not sure about keySize and iterationCount.  </p>

<p>How can I create simple exact implementation of crypto-js's AES encryption in java?</p>
","<p>After some hit and trial I got working implementation in Java.  </p>

<pre><code>import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TestAES {

    static String encrypt(String textToEncrypt, String myOwnSalt) throws Exception {
        final byte[] pass = textToEncrypt.getBytes(StandardCharsets.UTF_8);
        final byte[] salt = (new SecureRandom()).generateSeed(8);
        final byte[] inBytes = myOwnSalt.getBytes(StandardCharsets.UTF_8);

        final byte[] passAndSalt = array_concat(pass, salt);
        byte[] hash = new byte[0];
        byte[] keyAndIv = new byte[0];
        for (int i = 0; i &lt; 3 &amp;&amp; keyAndIv.length &lt; 48; i++) {
            final byte[] hashData = array_concat(hash, passAndSalt);
            final MessageDigest md = MessageDigest.getInstance(""MD5"");
            hash = md.digest(hashData);
            keyAndIv = array_concat(keyAndIv, hash);
        }

        final byte[] keyValue = Arrays.copyOfRange(keyAndIv, 0, 32);
        final byte[] iv = Arrays.copyOfRange(keyAndIv, 32, 48);
        final SecretKeySpec key = new SecretKeySpec(keyValue, ""AES"");

        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] data = cipher.doFinal(inBytes);
        data =  array_concat(array_concat(""Salted__"".getBytes(StandardCharsets.UTF_8), salt), data);
        return Base64.getEncoder().encodeToString( data );
    }

    private static byte[] array_concat(final byte[] a, final byte[] b) {
        final byte[] c = new byte[a.length + b.length];
        System.arraycopy(a, 0, c, 0, a.length);
        System.arraycopy(b, 0, c, a.length, b.length);
        return c;
    }

    public static void main(String[] args) throws Exception {
        String s = encrypt(""myPassword"", ""2ErFG"");
        System.out.println(s);
    }

}
</code></pre>
","587","<javascript><java><aes><cryptojs><javax.crypto>","0","-1","1","2017-12-28 17:44:22","","1","","","","","2017-12-28 12:20:36",""
"46212368","CryptoJS AES encrypt equivalent in Rails","<p>I am using 'crypto-js' package in front-end to encrypt values like this:</p>

<pre><code>import CryptoJS from 'crypto-js';
var value_to_encrypt = '1-2345-689'
var encrypted_value = CryptoJS.AES.encrypt(value_to_encrypt, 'my_secret_key').toString()

==&gt; 'U2FsdGVkX1/JWm47UWAgxMKyf2qC6EukAtk0pZbW3pk='
</code></pre>

<p>For backend that i am using Rails OpenSSL like this:</p>

<pre><code>cipher = OpenSSL::Cipher::Cipher.new('aes-128-cbc')    
cipher.encrypt    
cipher.key = 'my_secret_key'    
text = cipher.update(""1-2345-689"") + cipher.final    
encrypted_value = Base64.strict_encode64(text)

==&gt; 'pBTaRw/fZTRkrw4THDCGLQ=='
</code></pre>

<p>I found few solutions but they all suggested to use 128bit key and iv for encryption in the front-end which is not possible at this stage because i already have a lot of records saved using the same encryption method.</p>

<p>Can anyone please suggest what would be rails equivalent to that method? </p>
","<p>It is not possible to encrypt using key &amp; iv and decrypt it without using them (and vice versa). I had to decrypt the old encrypted data and encrypt that again using iv and key.</p>

<p>In Front-end (reactJs):</p>

<pre><code>import CryptoJS from 'crypto-js';

const iv = CryptoJS.enc.Base64.parse(INITIALIZATION_VECTOR)
const key = CryptoJS.enc.Hex.parse(ENCRYPTION_KEY)

encrypted_value = CryptoJS.AES.encrypt(input,  key,  {mode: CryptoJS.mode.CBC,  iv : iv}).toString()

decrypted_value = CryptoJS.AES.decrypt(input,  key,  {mode: CryptoJS.mode.CBC,  iv : iv}).toString(CryptoJS.enc.Utf8)
</code></pre>

<p>In Back-end (Ruby on Rails):</p>

<pre><code>iv = Base64.decode64(INITIALIZATION_VECTOR)
key = [ENCRYPTION_KEY].pack(""H*"")
cipher = OpenSSL::Cipher::Cipher.new('aes-128-cbc')
cipher.encrypt
cipher.key = key
cipher.iv = iv
text = cipher.update(plain_text) + cipher.final
encrypted_text = Base64.strict_encode64(text)
</code></pre>
","585","<ruby-on-rails><ruby><reactjs><encryption><cryptojs>","1","1","1","2018-02-28 10:55:27","","0","3","2194055","","2018-02-28 10:55:27","2017-09-14 06:51:35",""
"35822552","hash_hmac() with RAW Binary OUTPUT in JavaScript","<p>I have the php code to generate <strong>hash_hmac</strong></p>

<pre><code>key = base64_encode(hash_hmac('sha1',$public_key, $private_key,TRUE));
</code></pre>

<p>I've tried the <strong>CryptoJS</strong> library to solve it. </p>

<p>According to the documentation:</p>

<pre><code>var public_key = 'msg',
    private_key = 'key';
var hash = CryptoJS.HmacSHA1(public_key, private_key)
</code></pre>

<p>I don't know how to set the Raw Output to <strong>Binary</strong> like set <code>$raw_output</code> to <code>true</code> in php.</p>

<p>Can anyone help me?</p>

<p>Thanks:)</p>
","<p>php code </p>

<pre><code>echo base64_encode(hash_hmac('SHA1', 'shanghai', '0', true).'beijing');
</code></pre>

<p>php output</p>

<pre><code>xvBv49PpaYvXAIfy3iOSDWNQj89iZWlqaW5n
</code></pre>

<p>node code</p>

<pre><code>var crypto = require('crypto');
var buf1 = crypto.createHmac(""sha1"", ""0"").update(""shanghai"").digest();
var buf2 = Buffer.from('beijing');
console.log(Buffer.concat([buf1, buf2]).toString('base64'));    
</code></pre>

<p>node output</p>

<pre><code>xvBv49PpaYvXAIfy3iOSDWNQj89iZWlqaW5n
</code></pre>
","583","<javascript><php><binary><base64><cryptojs>","4","1","1","2017-09-22 12:45:03","","3","","","","","2016-03-06 02:53:21",""
"36185680","Can't decrypt using CryptoJS (works in Java, Python)","<p>I have a file that I encrypt using AES. Historically, I've had a set of tools (Java, Python) each of which is capable to both encrypt and decrypt these files. However, I've been having problems decrypting these files using CryptoJS.</p>

<p>The encrypted file has IV stored in the first 16 bytes, the rest is payload. During encryption key is formed by using hashing the password string via SHA-1 and using first 32 characters from the hex digest. I've gotten to the point where I can confirm that both IV and key used by CryptoJS is byte-wise identical to the ones used by other tools yet <code>AES.decrypt()</code> produces a buffer that I can't convert back to text.</p>

<p>Here's the decryption code. <code>content</code> and <code>iv</code> are binary strings read directly from file. <code>password</code> is a string with textual password. The code fails trying to convert the result to UTF8 (which I assume is due to the fact that decryption did not succeed).</p>

<pre><code>function string2bytes(s) {
    var bytes = [];

    for (var i = 0; i &lt; s.length; i++) {
        bytes.push(s.charCodeAt(i));
    }

    return bytes;
}


function decryptData(content, ivx, password) {
    // build a key out of text password
    var key = CryptoJS.SHA1(password).toString(CryptoJS.enc.Hex).substring(0, 32);
    console.log(""key0: "", key);

    key = string2bytes(key)
    console.log(key);

    // Convert IV from binary string to WordArray
    var iv = CryptoJS.enc.Latin1.parse(ivx);
    console.log(""IV: "", iv.toString(CryptoJS.enc.Hex));


    var decrypted = CryptoJS.AES.decrypt(content, key, { iv: iv });

    console.log(""raw decrypted: "", decrypted);
    console.log(""decrypted: "", iv.toString(CryptoJS.enc.Latin1));
    console.log(""decrypted: "", iv.toString(CryptoJS.enc.Utf8));
}
</code></pre>

<p>Any help would be appreciated.</p>
","<p>Found a solution by sticking to WordArrays (even for the arguments where a binary string is ostensibly OK): The following function does work. The arguments are as follows:</p>

<ul>
<li><code>data</code> is a base64 string with encrypted text</li>
<li><code>password</code> is a regular string with password</li>
<li><code>iv</code> is a base64 string with an IV.</li>
</ul>

<p>so</p>

<pre><code> function decryptData(data, password, iv) {
    var data = CryptoJS.enc.Base64.parse(data);
    var key = CryptoJS.SHA1(password).toString(CryptoJS.enc.Hex).substring(0, 32);
    key = CryptoJS.enc.Base64.parse(btoa(key));

    var iv  = CryptoJS.enc.Base64.parse(iv);
    var decrypted = CryptoJS.AES.decrypt({ciphertext: data}, key, {iv: iv});
    return decrypted.toString(CryptoJS.enc.Utf8);
}
</code></pre>
","583","<javascript><encryption><cryptojs>","0","0","1","2016-03-23 21:21:15","","3","","","","","2016-03-23 18:12:05",""
"31697913","mcrypt_encrypt in CFB mode function in CryptoJS","<p>I'm trying to convert an <code>mcrypt_encrypt</code> function written in php to node.js, I am using CryptoJS in node.js and tried all kinds of config options and I am not having any luck figuring this thing out.</p>

<p>PHP CODE:</p>

<pre><code>base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,md5($secretKey),$ldapPwd,MCRYPT_MODE_CFB,$initialVector))
</code></pre>

<p>JavaScript Code That I tried do not know what I am doing wrong:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(password, keyBase64,
{
    keySize: 128 / 8,
    iv: iv,
    mode: CryptoJS.mode.CFB,
    padding: CryptoJS.pad.NoPadding
});
</code></pre>
","<p>The Cipher Feedback (CFB) mode is a family of block cipher modes with a segment size parameter. Mcrypt only supports CFB8 whereas CryptoJS only supports CFB128. They are incompatible.</p>

<p>I've implemented <a href=""https://github.com/artjomb/cryptojs-extension#cfb"" rel=""nofollow"">CFB<em>b</em> in CryptoJS</a> which also supports 8-bit segments, but it is only tested for CryptoJS 3.1.2 and not the CryptoJS 2 version which is available through NPM.</p>
","572","<php><node.js><mcrypt><cryptojs><cfb-mode>","0","1","2","2015-07-29 20:17:44","31698913","3","","1816580","","2015-07-29 11:19:57","2015-07-29 10:30:02",""
"31697913","mcrypt_encrypt in CFB mode function in CryptoJS","<p>I'm trying to convert an <code>mcrypt_encrypt</code> function written in php to node.js, I am using CryptoJS in node.js and tried all kinds of config options and I am not having any luck figuring this thing out.</p>

<p>PHP CODE:</p>

<pre><code>base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128,md5($secretKey),$ldapPwd,MCRYPT_MODE_CFB,$initialVector))
</code></pre>

<p>JavaScript Code That I tried do not know what I am doing wrong:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(password, keyBase64,
{
    keySize: 128 / 8,
    iv: iv,
    mode: CryptoJS.mode.CFB,
    padding: CryptoJS.pad.NoPadding
});
</code></pre>
","<p>In PHP, when you use <code>mcrypt_module_open</code> with Rijndael-128, you have to pass a <strong>32 byte key</strong> and a <strong>16 byte</strong> IV.</p>

<p>So with nodeJs, you can use the <strong>crypto</strong> module, for example : </p>

<pre><code>var crypto = require('crypto');

//Declare our secret key
var key = 'fcda0ssdegfffc9441581bdd86484513dd9cb1547df2jsd';

//Declare our alogrithm
var algorithm = 'AES-256-CFB';

//Generate IV to hex format, so 8 * 2 = 16 bytes
var iv = crypto.randomBytes(8).toString('hex');

//Declare our string to encrypt
var password = 'HELLO WORLD';


var handler = {};

handler.encrypt64 = function(algorithm, key, vector, password){

    //create a cipher with an IV
    var cipher = crypto.createCipheriv(algorithm, key.substr(0,32), iv);

    //Encrypt our password from utf8 to hex
    var encrypted = cipher.update(password, 'utf8', 'base64'); 

    //Return any remaining enciphered data to hex format
    encrypted += cipher.final('base64');

    //Return a base64 String
    return encrypted;
};

handler.decrypt64 = function(algorithm, key, vector, password){

    //create a decipher with an IV
    var decipher = crypto.createDecipheriv(algorithm, key.substr(0, 32), iv);

    //Decrypt our encode data from base64 to utf8
    var decrypted = decipher.update(encode, 'base64', 'utf8');

    decrypted += decipher.final('utf8');


    //Return a utf8 string
    return decrypted;
};

var encode = handler.encrypt64(algorithm, key, iv, password);

var decode = handler.decrypt64(algorithm, key, iv, encode);
</code></pre>
","572","<php><node.js><mcrypt><cryptojs><cfb-mode>","0","1","2","2015-07-29 20:17:44","31698913","3","","1816580","","2015-07-29 11:19:57","2015-07-29 10:30:02",""
"50059498","AES Encryption with CryptoJS and PHP","<p>I want to implement AES encryption using JavaScript. Used AES CBC Mode. I have managed to do it in PHP. It looks like:</p>

<pre><code> public function encrypt($value) {
        if (empty($value)) {
          return $value;
        }
        $value = Unicode::convertToUtf8($value, 'UTF-8');
        if ($key = $this-&gt;getEncryptionKey()) {
          // Generates from key 1st 16 bytes.
          $iv = mb_substr($key, 0, 16);
          //encrypt message with key
          $message = openssl_encrypt($value, 'AES-256-CBC', $key, OPENSSL_RAW_DATA, $iv);
          return base64_encode($message);
        }
    }

    public function getEncryptionKey() {
        $key = 'secret';
        $key = Unicode::convertToUtf8($key, 'UTF-8');

        // Make sure the key is the correct size.
        if (strlen($key) &lt; 32) {
          $key = str_pad($key, 32, ""\0"");
        }

        if (strlen($key) &gt; 32) {
          $key = mb_substr($key, 0, 32);
        }

        return $key;
    }
</code></pre>

<p>If I give $value = retest2; it gives me <strong>ukUCH0SvgdmM8vTqQumAVg==</strong> output</p>

<p>I know it's right, I tried it using C# as well got the same result. But when I try to replicate this using JavaScript, I wasn't able to produce same PHP's output. Below is the javascript code that I have tried:</p>

<pre><code>const message = utf8.encode('retest2');
const password = utf8.encode('secret').padEnd(32, '\0');
const key =  CryptoJS.enc.Hex.parse(password);
const iv =  CryptoJS.enc.Hex.parse(password.substring(0, 16));

const encrypted = CryptoJS.AES.encrypt(message, key, {
    iv: iv
});
console.log(btoa(encrypted.toString()));
</code></pre>

<p>Using the same value I get <strong>dzd4bjNwenduQT09</strong>. 
I have also read other similar questions asked on the same topic here, but I can't seem to figure out where I am going wrong?
Thanks!</p>
","<p>These should be comments but space is limited....</p>

<p>You shouldn't be using the key or data derived from it as your initialization vector.</p>

<blockquote>
  <p>I know it's right, I tried it using C# as well</p>
</blockquote>

<p>You should have shown us the code.</p>

<p>Your openssl call invokes the <a href=""https://www.openssl.org/docs/manmaster/man3/EVP_BytesToKey.html"" rel=""nofollow noreferrer"">key derivation function</a> to create a (better?) encryption key from the data you pass in the third parameter. OTOH, in crypto.js there is <a href=""https://github.com/jakubzapletal/crypto-js/blob/master/README.md"" rel=""nofollow noreferrer"">no implicit key derivation</a>.</p>
","561","<javascript><php><aes><cryptojs>","1","0","2","2018-05-14 23:09:18","50340236","3","","9709547","","2018-04-27 10:21:03","2018-04-27 09:36:11",""
"50059498","AES Encryption with CryptoJS and PHP","<p>I want to implement AES encryption using JavaScript. Used AES CBC Mode. I have managed to do it in PHP. It looks like:</p>

<pre><code> public function encrypt($value) {
        if (empty($value)) {
          return $value;
        }
        $value = Unicode::convertToUtf8($value, 'UTF-8');
        if ($key = $this-&gt;getEncryptionKey()) {
          // Generates from key 1st 16 bytes.
          $iv = mb_substr($key, 0, 16);
          //encrypt message with key
          $message = openssl_encrypt($value, 'AES-256-CBC', $key, OPENSSL_RAW_DATA, $iv);
          return base64_encode($message);
        }
    }

    public function getEncryptionKey() {
        $key = 'secret';
        $key = Unicode::convertToUtf8($key, 'UTF-8');

        // Make sure the key is the correct size.
        if (strlen($key) &lt; 32) {
          $key = str_pad($key, 32, ""\0"");
        }

        if (strlen($key) &gt; 32) {
          $key = mb_substr($key, 0, 32);
        }

        return $key;
    }
</code></pre>

<p>If I give $value = retest2; it gives me <strong>ukUCH0SvgdmM8vTqQumAVg==</strong> output</p>

<p>I know it's right, I tried it using C# as well got the same result. But when I try to replicate this using JavaScript, I wasn't able to produce same PHP's output. Below is the javascript code that I have tried:</p>

<pre><code>const message = utf8.encode('retest2');
const password = utf8.encode('secret').padEnd(32, '\0');
const key =  CryptoJS.enc.Hex.parse(password);
const iv =  CryptoJS.enc.Hex.parse(password.substring(0, 16));

const encrypted = CryptoJS.AES.encrypt(message, key, {
    iv: iv
});
console.log(btoa(encrypted.toString()));
</code></pre>

<p>Using the same value I get <strong>dzd4bjNwenduQT09</strong>. 
I have also read other similar questions asked on the same topic here, but I can't seem to figure out where I am going wrong?
Thanks!</p>
","<p>As @symcbean said, </p>

<blockquote>
  <p>You shouldn't be using the key or data derived from it as your
  initialization vector.</p>
</blockquote>

<p>I assume, you have no option and you have to use key or data derived from it as your initialization vector.</p>

<p>A few months ago, I had the exact same situation and I did something like this,</p>

<pre><code>const message = 'retest2';
let password = 'secret';
if (password.length &lt; 32) {
    password = password.padEnd(32, '\0');
}
const iv = CryptoJS.enc.Utf8.parse(password.substring(0, 16));
password = CryptoJS.enc.Utf8.parse(password);
const encrypted = CryptoJS.AES.encrypt((message), (password), {
    iv: iv
});
console.log(CryptoJS.enc.Base64.stringify(encrypted.ciphertext));
</code></pre>
","561","<javascript><php><aes><cryptojs>","1","0","2","2018-05-14 23:09:18","50340236","3","","9709547","","2018-04-27 10:21:03","2018-04-27 09:36:11",""
"36874335","How to pass encrypted data via browser (HTML5) session variable","<p>I am trying to pass encrypted data via a <strong>browser/client session variable</strong> - not to be confused with <strong>server-side session variable</strong>:</p>

<p>encrypt:</p>

<pre><code>var encrypted_user_id = CryptoJS.AES.encrypt(user_id, cipher_pass);
var encrypted_user_password = CryptoJS.AES.encrypt(password, cipher_pass);

sessionStorage.setItem('user_id', encrypted_user_id);
sessionStorage.setItem('user_password', encrypted_user_password);
</code></pre>

<p>decrypt:</p>

<pre><code>var encrypted_user_id = sessionStorage.getItem('user_id');
var encrypted_user_password = sessionStorage.getItem('user_password');

var plaintext_user_id = CryptoJS.AES.decrypt(encrypted_user_id, cipher_pass).toString(CryptoJS.enc.Utf8);
var plaintext_user_password = CryptoJS.AES.decrypt(encrypted_user_password, cipher_pass).toString(CryptoJS.enc.Utf8);
</code></pre>

<p><strong>There is no error, but the plaintext is empty string.</strong>  </p>

<p>If I perform the exact same encryption/decryption using <code>variables</code> instead of <code>sessionStorage</code> it works fine.  </p>

<p>What am I not understanding?  Is there something about session variables that is different than a local variable?</p>
","<p>So I've made a <a href=""https://jsfiddle.net/MarmeeK/zkx4mh78/3/"" rel=""nofollow noreferrer"">fiddle</a> to test it out. And I think the problem (although in fairness your original code seemed to work for me too) is that for the encryption you should do this instead:</p>

<pre><code>var encrypted_user_id = CryptoJS.AES.encrypt(user_id, cipher_pass).toString();
</code></pre>

<p>Why? Without the to string, you're storing an object that JSON can't serialize, so when you're getting your object back from session storage you're getting back something different than you intended.</p>
","559","<javascript><html5><encoding><session-variables><cryptojs>","2","4","1","2018-08-31 08:25:39","36874767","6","","1816580","","2016-04-26 20:32:44","2016-04-26 19:43:36",""
"28671430","sync AES ecnryption between cryptoJS and openSSL (ruby)","<p>I can't get same result when encrypting using CryptoJS or Ruby's OpenSSL</p>

<p>JS code </p>

<pre><code>k=CryptoJS.enc.Hex.parse('ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb');
iv=CryptoJS.enc.Hex.parse('3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d');
r=CryptoJS.AES.encrypt(""hello"", k, { iv: iv });
alert(r.ciphertext.toString(CryptoJS.enc.Base64));
</code></pre>

<p>and in Rails</p>

<pre><code>cipher = OpenSSL::Cipher::AES.new(256, :CBC)
cipher.encrypt
cipher.key = 'ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb'
cipher.iv = '3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d'
enc = cipher.update('hello')+cipher.final
puts Base64.encode64(enc)
</code></pre>

<p>the 2 results do not give the same encrypted message. </p>
","<p>The IV has to be 16 bytes or 128-bit long, because AES has a blocksize of 128-bit. Your current IV has 32 bytes. So there is probably a difference between how CryptoJS and OpenSSL treat an IV that is too long.</p>
","557","<ruby-on-rails><encryption><openssl><aes><cryptojs>","1","3","1","2015-02-23 10:59:43","28672202","0","","1713823","","2015-02-23 10:30:03","2015-02-23 10:19:12",""
"37524290","Crypto js encrypted string not decrypt in php","<p>I am using following js code to encrypt string</p>

<pre><code>var text = 'should be decrypted!';
var key = 'HighlySecretKeyForJsEncryption!!';
var encrypted = CryptoJS.AES.encrypt(text, key);
console.log(encrypted.toString());
</code></pre>

<p>output : U2FsdGVkX19vf+s6/+eB8A+3iKFCl1A0e+oe0BSbcMVGxb64FL35Q3CB/LZNu4ng</p>

<p>and this what I did in php to decrypt this</p>

<pre><code>function decrypt($toDecrypt) {
    $key = ""HighlySecretKeyForJsEncryption!!"";
    $iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
    $toDecrypt = base64_decode($toDecrypt);
    return rtrim(mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, substr($toDecrypt, $iv_size), MCRYPT_MODE_CBC, substr($toDecrypt, 0, $iv_size)));
}
</code></pre>

<p>But this is not working, it gives me garbage string.</p>
","<p>From <a href=""https://code.google.com/archive/p/crypto-js/#Quick-start_Guide"" rel=""nofollow noreferrer"">docs</a>:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
</code></pre>

<blockquote>
  <p>CryptoJS supports AES-128, AES-192, and AES-256. It will pick the
  variant by the size of the key you pass in. If you use a passphrase,
  then it will generate a 256-bit key.</p>
</blockquote>

<p>You probabily need to pass the constant <code>MCRYPT_RIJNDAEL_256</code> when decrypting php-side</p>

<p>More about AES encryption / decrytption in php: <a href=""https://stackoverflow.com/a/3422787/4499267"">https://stackoverflow.com/a/3422787/4499267</a></p>
","556","<php><encryption><aes><cryptojs>","1","-1","1","2016-05-30 14:11:34","","4","","1816580","","2016-05-30 14:11:34","2016-05-30 11:14:41",""
"45541019","crypto js :global module exports may only appear at top level angular typings","<p>I'm trying to integrate crypto-js with my angular 2 app.</p>

<p><strong>Global module exports may only appear at top level angular typings.</strong></p>

<p>I have read the below contents
<a href=""https://stackoverflow.com/questions/37023369/in-webpack-how-do-i-fix-import-declarations-may-only-appear-at-top-level-of-a-m"">link 1</a></p>

<p><a href=""https://stackoverflow.com/questions/37023369/in-webpack-how-do-i-fix-import-declarations-may-only-appear-at-top-level-of-a-m"">In webpack how do I fix &#39;import declarations may only appear at top level of a module&#39;?</a></p>

<p>But i'm not able to implement a solution </p>

<p>below are the steps i followed.</p>

<p>1) Installed crypto-js using type
--> npm install --save @types/crypto-js</p>

<p>2) Then in my service added reference. Below is the service file</p>

<pre><code>/// &lt;reference path=""../../../typings/index.d.ts"" /&gt;

import { Injectable } from '@angular/core';
import { LocalStorageService } from 'angular-2-local-storage';

import * as CryptoJS from 'crypto-js';

@Injectable()
export class AppLocalStorageService {

    constructor(public localStorageService: LocalStorageService) { }

    public setItem(key:any,value:any) {

        var enc = CryptoJS.MD5(key);
        console.log(enc);

    }

    public getItem(key:any) {
        return key;


    }

}
</code></pre>

<p>Still getting the error.Anything else i should do?</p>

<p>Thanks</p>
","<p>For my scenario it was ionic appication, i faced the same issue while using typings. After some research i found that instead of typings it is best to use @type. So i used below npm package </p>

<p><a href=""https://www.npmjs.com/package/@types/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/@types/crypto-js</a></p>

<p>After that i imported the module as below</p>

<p>import * as CryptoJS from 'crypto-js';</p>

<p>Hope it will work for you. </p>

<p>Enjoy your coding :)</p>
","552","<angular><typescript><ecmascript-6><cryptojs>","0","2","1","2017-10-10 15:41:51","","2","","1215485","","2017-08-07 09:00:46","2017-08-07 06:58:59",""
"27418611","How to get original string back in CryptoJS using TripleDES?","<p>I'm trying to encrypt and decrypt in JavaScript using <a href=""https://code.google.com/p/crypto-js/#DES,_Triple_DES"" rel=""nofollow"">TripleDES.js</a>. Here is my code snippet:</p>

<p><strong>Encryption Method:</strong></p>

<pre><code>encrypt_string = function (plainData) {

   var encrypted = CryptoJS.TripleDES.encrypt(plainData, ""My Secret Key"");

   alert(""Encrypted: "" + encrypted);

}
</code></pre>

<p><strong>Decryption Method:</strong></p>

<pre><code>decrypt_string = function (cipherData) {

   var decrypted = CryptoJS.TripleDES.decrypt(cipherData, ""My Secret Key"");

   alert(""Decrypted: "" + decrypted);

}
</code></pre>

<p>While passing <code>plainData</code> as <code>Gokul Nath</code>, to <code>encrypt_string()</code>, the alert message shows: </p>

<pre>
U2FsdGVkX1/huVhh9IQhJF72gcs26f1l0+hNSsWEXsc=
</pre>

<p>While passing <code>cipherData</code> as <code>U2FsdGVkX1/huVhh9IQhJF72gcs26f1l0+hNSsWEXsc=</code>, to <code>decrypt_string()</code>, the alert message shows: </p>

<pre>
476f6b756c204e617468
</pre>

<p><strong><em>Question:</em></strong> How to get the original plain data while decrypting?</p>
","<p><code>476f6b756c204e617468</code> is the hex representation of the original string:</p>

<pre><code>47 6f 6b 75 6c 20  4e 61 74 68
G  o  k  u  l  |/  N  a  t  h
               |
               +-&gt; this is a space
</code></pre>

<p>You can use something like <code>decrypted.toString(CryptoJS.enc.Latin1)</code> to get the string value, as per:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/tripledes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var encrypted = CryptoJS.TripleDES.encrypt(""Gokul Nath"", ""My Secret Key"");
    var decrypted = CryptoJS.TripleDES.decrypt(encrypted, ""My Secret Key"");
    alert(""Decrypted: "" + decrypted.toString(CryptoJS.enc.Latin1));
&lt;/script&gt;
</code></pre>

<p>which gives:</p>

<p><img src=""https://i.stack.imgur.com/70koL.jpg"" alt=""enter image description here""></p>
","550","<javascript><encryption><cryptojs><tripledes>","0","4","1","2014-12-11 09:06:02","27418704","0","","1816580","","2014-12-11 09:06:02","2014-12-11 08:44:12",""
"19770715","Generate IV and key using CryptoJs","<p>I'm using CryptoJS on a small project. For a time I used simple encryption methods. By passing a passphrase, and letting crypto-js produce the IV and KEY. This used to work very well.
Now i want to use progressive cyphering. To do this i need to explicitly provide IV and KEY.
I'm wondering how i can produce theses from a passphrase ?</p>
","<p>This is exactly the kind of thing PBKDF2 is for (password-based key derivation function).</p>
","548","<key><cryptojs><passphrase>","0","0","1","2013-11-05 19:27:27","","0","","","","","2013-11-04 15:09:20",""
"40643742","crypto-js trouble with index.html (Angular 2 project)","<p>I used the following command to get crypto-js into my node_modules folder</p>

<pre><code>npm install crypto-js
</code></pre>

<p>Then, after I had it downloaded, within my index.html file I use the following command so that I can call the CryptoJS.SHA256() method.</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src=""node_modules/crypto-js/sha256""&gt;&lt;/script&gt;
  &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p>(I left out the other script calls, meta and title tags)</p>

<p>However when I run my project using 'npm start', I get the following errors</p>

<p><a href=""https://i.stack.imgur.com/dBe9u.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dBe9u.png"" alt=""enter image description here""></a></p>

<p>What exactly does this mean? I am not sure how to solve something that is 'not found' even though it is where is should be. Am I maybe missing something else?</p>
","<p>Your using external javascript that is not exposed to angular.  Only the web dom is aware of the crypto js module. It looks like you just want to use SHA256.  I would just implement a type script version of the function and go from there.  Here is an example.</p>

<p><a href=""https://github.com/dchest/fast-sha256-js"" rel=""nofollow noreferrer"">https://github.com/dchest/fast-sha256-js</a></p>
","546","<html><angular><typescript><sha256><cryptojs>","0","0","1","2016-11-16 23:52:19","","0","","","","","2016-11-16 22:49:06",""
"32468734","InternalError: too much recursion when sending an crypted object in Socket.IO","<p>I'm trying to send crypted file that I have uploaded from client to <code>node.js</code> server, but everytime I get the error: </p>

<blockquote>
  <p>InternalError: too much recursion</p>
</blockquote>

<p>I've crypted uploaded file using <code>Crypto-JS</code> library:<br><br>
<strong>main.js</strong><br></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function loaded(evt) {

    var arrayFileBuffer = evt.target.result;

    var arrayFileTyped = new Uint8Array(arrayFileBuffer);

    var wordArray = CryptoJS.lib.WordArray.create(arrayFileTyped);

    var encrypted = CryptoJS.AES.encrypt(wordArray, m_secret_key_x.toString());

    socket.emit('send_file', encrypted);

}</code></pre>
</div>
</div>
</p>

<p>And the <code>socket.emit('send_file', encrypted)</code> is the part where it crashes. <br><br>
In Mozilla Firebug, I can see that function <code>_hasBinary()</code> from <code>Socket.IO</code> has been called numerous times and I think it's causing too much recursion error.
<br><br>
Any help with solving this problem would be appreciated, thank you in advance!</p>
","","545","<javascript><node.js><sockets><socket.io><cryptojs>","6","","0","2015-09-08 23:49:47","","0","","4001497","","2015-09-08 23:49:47","2015-09-08 23:26:49",""
"49631384","ReferenceError: cryptoJS is not defined in rails javascript","<p>i am trying to implement this code to get one of my payment method work but everytime returned with error ""Exception occured encryptionString:ReferenceError: cryptoJS is not defined""</p>

<p>the error is due to the code ""var key = cryptoJS.enc.Hex.parse(keyValue);""</p>

<p>i am running this in rails so please help to advise if there is anything wrong with the code.</p>

<p><strong>Gemfile</strong></p>

<pre><code>gem 'cryptojs-rails', '~&gt; 2.5', '&gt;= 2.5.3'
</code></pre>

<p><strong>app/assets/javascripts/application.js</strong></p>

<pre><code>//= require crypto
</code></pre>

<p><strong>app/assets/javascripts/maybank.js</strong></p>

<pre><code>var getEncryptionString = function (arrayM2U, envType) {    
try {
    var ITERATIONS = 2;
    var salt='Maybank2u simple encryption';
    var keyValue='000102030405060708090a0b0c0d0e0f';

    var amount = arrayM2U.amount;
    var accountNumber =arrayM2U.accountNumber;
    var payeeCode = arrayM2U.payeeCode;
    var refNum = arrayM2U.refNumber;
    var redirectionurl = arrayM2U.callbackUrl;
    var m_sReqSendString = """";

    if( (accountNumber == undefined || accountNumber == """") &amp;&amp; (refNum != undefined &amp;&amp;  refNum != """"))
     m_sReqSendString = 'Login$' +payeeCode+ '$1$' + amount + '$1$' + refNum + '$$$' + redirectionurl;
    else if((accountNumber != undefined &amp;&amp; accountNumber != """" ) &amp;&amp; (refNum == undefined ||  refNum == """"))
     m_sReqSendString = 'Login$' + payeeCode + '$1$' + amount + '$$$1$' + accountNumber + '$' + redirectionurl;
    else
    m_sReqSendString = 'Login$' + payeeCode + '$1$' + amount + '$1$'+refNum+'$1$' + accountNumber + '$' +redirectionurl ;

    console.log(keyValue);
    var key = cryptoJS.enc.Hex.parse(keyValue);
    console.log(keyValue);
    var valueToEnc = null;
    var eValue = m_sReqSendString;
    for (var i = 0; i &lt; ITERATIONS; i++) {
        valueToEnc = salt + eValue;
        var encrypted = cryptoJS.AES.encrypt(valueToEnc, key, {
            mode: cryptoJS.mode.ECB,
            padding: cryptoJS.pad.Pkcs7
        });
        eValue = encrypted;
    }

    var fullEncryptedString = encodeURIComponent(eValue);

    switch (envType) {
      case 1:
          actionUrl = ""https://m2upayuat.maybank2u.com.my/testM2uPayment"";
          break;
      case 2:
          actionUrl = ""https://www.maybank2u.com.my/mbb/m2u/m9006_enc/m2uMerchantLogin.do"";
          break;
      default:
          actionUrl = ""https://api.maybanksandbox.com/v1.0/testM2uPayment"";
    }

    var json = {};

    json.encryptedString = fullEncryptedString;

    json.actionUrl = actionUrl;

        return json;

} catch (err) {
    console.log(""Exception occured encryptionString:""+err)
      return ""FAIL""

}
</code></pre>

<p>}</p>
","<p>Well I just had a look at the gem source code, it was fast. There's no chance you can get this gem to work. I suppose it was a test by the author, but he must not have given up quickly about it (this is really likely, given that you the github repository has been removed, and there's only been one version of that gem).</p>

<p>The 2.5.3 cryptojs library should contain all those files : </p>

<pre><code>  tree tags/2.5.3/src

 AES.js
 BlockModes.js
 Crypto.js
 CryptoMath.js
 DES.js
 HMAC.js
 MARC4.js
 MD5.js
 PBKDF2.js
 PBKDF2Async.js
 Rabbit.js
 SHA1.js
 SHA256.js

0 directories, 13 files
</code></pre>

<p>And the gem that you're using only contains the basic files needed for a gem and <code>Crypto.js</code>, which is mostly an empty shell at this point, and that is why your code doesn't work.</p>

<pre><code>  tree gems/ruby-2.3.3/gems/cryptojs-rails-2.5.3/

 LICENSE
 README.md
 app
  assets
      javascripts
          crypto.js
 lib
     cryptojs-rails
      version.rb
     cryptojs-rails.rb

5 directories, 5 files
</code></pre>

<p>In a nutshell, I think you'll have to import cryptojs in your project through another channel (rails-assets, npm/yarn, bower, manually into vendor or any other means that I couldn't think of).</p>
","540","<javascript><ruby-on-rails><cryptojs>","0","0","1","2018-04-03 17:09:52","","0","","","","","2018-04-03 13:29:59",""
"24940404","Decrypting a file using CryptoJS produces random results","<p>I have a file that was encrypted using openssl, like this:</p>

<pre><code>openssl enc -aes-256-cbc -in /tmp/file.zip -out /tmp/file.zip.enc -pass pass:""abcdefg"" -e -base64
</code></pre>

<p>I want to decrypt that file using CryptoJs. I load the file from a FileReader object, like thus:</p>

<pre><code>$(""#inputFile"").change( function( e )
{
    var files = e.target.files; // FileList object

    var file = files[0];

    var reader = new FileReader();
    reader.onload = function( e ){
        var result = e.target.result;
        var decrypted = CryptoJS.AES.decrypt(result.split(/\s/).join(''), ""abcdefg"");

        var string = CryptoJS.enc.Base64.stringify( decrypted );
        console.log( string.substring(0,20) );      
    };

    reader.readAsDataURL( file );
});
</code></pre>

<p>Every time I reload the page, and load the exact same file, the output in console.log changes. I want to eventually turn the decrypted file into a Blob and return it to the user, but I obviously can't get there until I can decrypt the file correctly first.</p>
","<p>You should first base 64 decode, then decrypt. Not decrypt, then base 64 encode. Just switching <code>encrypt</code> to <code>decrypt</code> won't do it if you also encode your ciphertext.</p>
","540","<javascript><encryption><openssl><cryptojs>","0","0","1","2014-07-25 02:51:17","","1","","608639","","2014-07-25 02:51:17","2014-07-24 17:37:46",""
"44850789","trying to mock github webhook request, get: ""X-Hub-Signature does not match blob signature""","<p>Here is a little proxy server setup to handle github webhooks:</p>

<pre><code>require('dotenv').config();
var http = require('http');
var createHandler = require('github-webhook-handler');
var handler = createHandler({
  path: '/webhook',
  secret: process.env.GIT_WEBHOOK_SECRET
});

http
  .createServer(function(req, res) {
    handler(req, res, function(err) {
      res.statusCode = 404;
      res.end('no such location');
    });
  })
  .listen(8080);

handler.on('error', function(err) {
  console.error('Error:', err.message);
});

handler.on('push', function(event) {
  console.log(
    'Received a push event for %s to %s',
    event.payload.repository.name,
    event.payload.ref
  );
});

handler.on('issues', function(event) {
  console.log(
    'Received an issue event for %s action=%s: #%d %s',
    event.payload.repository.name,
    event.payload.action,
    event.payload.issue.number,
    event.payload.issue.title
  );
});
</code></pre>

<p>In postman, I have these headers set:</p>

<p><a href=""https://i.stack.imgur.com/8KouL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8KouL.png"" alt=""Headers""></a></p>

<p>The raw body is here: <a href=""https://developer.github.com/v3/activity/events/types/#pullrequestreviewevent"" rel=""nofollow noreferrer"">https://developer.github.com/v3/activity/events/types/#pullrequestreviewevent</a></p>

<p>Here is my pre-request script:</p>

<pre><code>var payload = request.data;
console.log(""Using payload as "" + payload)
var hash = CryptoJS.HmacSHA1(payload, environment.secret).toString(CryptoJS.enc.Hex)
postman.setGlobalVariable(""signature"", hash);
</code></pre>

<p>I can confirm that the <code>GIT_WEBHOOK_SECRET</code> in .env is the same as what is set in <code>secret</code> in my Postman environment settings.</p>
","<p>You need to set content of <code>X-Hub-Signature</code> as parameters with <code>sha1</code> field : </p>

<pre><code>var payload = request.data;
console.log(""Using payload as "" + payload)
var hash = CryptoJS.HmacSHA1(payload, environment.secret).toString(CryptoJS.enc.Hex)
postman.setGlobalVariable(""signature"", ""sha1="" + hash);
</code></pre>

<p>From <a href=""https://developer.github.com/webhooks/securing/#validating-payloads-from-github"" rel=""nofollow noreferrer"">validating payloads from Github</a> :</p>

<blockquote>
  <p>No matter which implementation you use, the hash signature starts with
  sha1=, using the key of your secret token and your payload body.</p>
</blockquote>
","539","<node.js><github><webhooks><hmac><cryptojs>","4","2","1","2017-07-14 15:45:45","45106605","0","2","","","","2017-06-30 16:09:28",""
"41136495","After adding js file with the custom module in magento,checkout page is not working","<p>I want to add the js file along with the custom module.After adding it in layout file of my module.Payment method stop to work.Can somebody tell me what is the problem.
here is the code-
custom_layout.xml</p>

<pre><code>     &lt;?xml version=""1.0""?&gt;
     &lt;layout version=""0.1.0""&gt;
     &lt;default&gt;
     &lt;reference name=""head""&gt;
     &lt;action method=""addJs""&gt;&lt;script&gt;custom_module/crypto.js&lt;/script&gt;
     &lt;/action&gt;   
     &lt;/reference&gt;
     &lt;/default&gt;
     &lt;/layout&gt;
</code></pre>

<p>config.xml</p>

<pre><code>    &lt;frontend&gt;
    &lt;layout&gt;
    &lt;updates&gt;
     &lt;ideal&gt;
     &lt;file&gt;custom_layout.xml&lt;/file&gt;
        &lt;/ideal&gt;
    &lt;/updates&gt;
     &lt;/layout&gt;
     &lt;/frontend&gt;
</code></pre>

<p>After adding crypto js,it is available in header but checkout page is not working.here is the screenshots-
<a href=""https://i.stack.imgur.com/eSTxb.png"" rel=""nofollow noreferrer"">screenshot of console</a></p>

<p><a href=""https://i.stack.imgur.com/MqZpk.png"" rel=""nofollow noreferrer"">screenshot of non clickable checkout page</a></p>
","<p>I think its conflict issue so you can add group of js like</p>

<pre><code>&lt;action  method=""addItem""&gt;
&lt;type&gt;js&lt;/type&gt;&lt;name&gt;custom_module/crypto.js&lt;/name&gt;
&lt;group&gt;cust_js&lt;/group&gt;
&lt;/action&gt;
</code></pre>

<p>try to add js mentioned as above. This will fix conflict issue hope its help :)</p>
","535","<javascript><magento-1.9><cryptoapi><cryptojs>","0","2","1","2017-01-17 07:18:15","","0","","","","","2016-12-14 06:54:25",""
"35744859","Encrypt with AES using phpseclib and decrypt with CryptoJS","<p>I'm trying to encrypt a string using phpseclib AES in CBC mode (library's default):</p>

<pre><code>$cipher = new Crypt_AES();
$cipher-&gt;setKey('abcdefghijklmnop');
$cipher-&gt;setIV(crypt_random_string($cipher-&gt;getBlockLength() &gt;&gt; 3));
$cipher-&gt;encrypt(""hello world"")
</code></pre>

<p>Then, I need to decrypt on nodejs using CryptoJS or similar.. I've tried different libs but no luck so far. I guess the issue is kind of related to the encoded output differ from each library.</p>

<p>Does anyone have a working example of how to implement this interoperability scenario?</p>

<p>Other library such as Crypto can be used.
An example Base64 output is <code>MF9lCR4DaW1R0adIe03VEw==</code></p>

<p>So the idea is to decrypt as follows:</p>

<pre><code>var helloWorld = CryptoJS.AES.decrypt(""MF9lCR4DaW1R0adIe03VEw=="", key).toString();
</code></pre>
","<p>You need the previously generated IV during decryption. It doesn't have to be secret, but it has to be unpredictable (which it is in your case). You can send it along with the ciphertext. A common way is to prepend it to the ciphertext and slice it off during decryption.</p>

<p>CryptoJS supports two types of encryption. If you pass the key as a string, it will use OpenSSL's key derivation function to derive a new key with a salt. You don't want that, because you're using an explicit key. For that, you need to pass the key as WordArray (CryptoJS' native binary data structure). Additionally, the ciphertext is expected to be either an OpenSSL formatted string or a CipherParams object:</p>

<pre><code>var message = CryptoJS.AES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(""MF9lCR4DaW1R0adIe03VEw=="")
}, CryptoJS.enc.Utf8.parse('abcdefghijklmnop'), {
    iv: iv // retrieve the IV somehow
}).toString(CryptoJS.enc.Utf8);
</code></pre>
","532","<node.js><encryption><aes><phpseclib><cryptojs>","1","3","1","2016-03-02 15:39:59","35751297","4","","1816580","","2016-03-02 15:22:37","2016-03-02 10:41:53",""
"54864722","Encrypt Object via Laravel 5.7 PHP and Decrypt via VueJS Javascript","<p>I have a Laravel 5.7 application which encrypts an object and returns the encrypted object to my VueJS application.</p>

<blockquote>
  <p><strong>PLEASE NOTE</strong> the below code is for explanation purposes and I am not
  using in this way, however, the concept is.</p>
</blockquote>

<p><strong>Laravel Function triggered by a route</strong></p>

<pre><code>public function license() {
  var data = [{id: 1}, {expiry_date: '2019-02-25T10:47:12+00:00'}];
  $encrypted = \Crypt::encrypt(JSON.stringify(data));
  return $encrypted;
}
</code></pre>

<p><strong>Vue JS Method for Retrieving Object</strong></p>

<pre><code>checkLicense() {
      this.$http.get(LARAVEL_ROUTE).then(res =&gt; {
        var key = 'LARAVEL_APP_KEY'; // NOT REAL
        var bytes = CryptoJS.AES.decrypt(res.data, 'LARAVEL_APP_KEY');
        var plaintext = bytes.toString(CryptoJS.enc.Utf8);
      });
}
</code></pre>

<p><strong>The above produces the following:</strong></p>

<blockquote>
  <p>Uncaught (in promise) Error: Malformed UTF-8 data</p>
</blockquote>

<p><strong>Things I've tried:</strong></p>

<ul>
<li><p>I have checked the LARAVEL_APP_KEY and I can see that it is prefixed
with 'base64:' so I have tried removing this from my VueJS method
where I declare the key but this made no difference. </p></li>
<li><p>I have also removed the object and tried encrypting a string which
produces the same result as above.</p></li>
</ul>

<p><strong>Additional question:</strong></p>

<p>I'd also like to encrypt the string / object with something other than the LARAVEL_APP_KEY as I don't want to store that value in my VueJS application. The key doesn't need to be super secure however I would rather not use the LARAVEL_APP_KEY</p>
","<p>From my experience, I would suggest the following.</p>

<p>Firstly, I'm not sure why you are wanting to encrypt data on the server and then decrypt on the client. The only benefit that I could see for that is to prevent MITM attacks, in which case you should be using SSL.</p>

<p>Secondly, I'm fairly sure that the encryption key is the base64 encoded value after the prefix <code>base64:</code>. So you will need to remove this and then base64 encode the remaining string in VueJS before trying to decrypt with the key.</p>

<p>In answer to your question about encrypting/decrypting with anything other than the APP_KEY, you can't have multiple keys that will decrypt the same value. Cryptography only works when you have the correct key.</p>

<p>I would really not recommend decrypting data on the client, anybody can then obtain your encryption key and if there was a vulnerability elsewhere and were able to access your database, they could decrypt any data that they like.</p>
","530","<javascript><php><laravel><encryption><cryptojs>","1","3","1","2019-02-25 11:09:51","","4","","","","","2019-02-25 11:02:05",""
"23992957","decryption at client side with javascript?","<p>I am getting an encrypted text on the client side which has been encrypted at server(with java) using AES-256 bit , and SHA-256 (2048 bit), i have no idea how to decrypt it.
(provided that i am having a key at the client side which has been used at server side for the encryption purpose and i am using symmetric key cryptography).</p>

<p>i am using SJCL for this and have tried this code</p>

<pre><code>decodedData = sjcl.decrypt(key,encryptedData);
</code></pre>

<p>but it is giving the error </p>

<p><strong><em>""json decode: this isn't json! ""</em></strong> </p>

<p>if you can suggest any other library(along with the code will be better).</p>

<p>any help will be greatly appreciated.</p>

<p><strong>EDIT-</strong></p>

<p>yes i was using the SHA-256 as key for AES-256, but going further i will not use SHA-256 so now i need the answer only for how to decrypt the data which has been Encrypted with AES-256 .</p>

<p>EDIT- </p>

<p>i tried it with pidcrypt since the data which i was trying to decrypt was encrypted using cbc mode that sjcl doesn't have but picrypt, i tried the following code </p>

<pre><code>var data = ""IFoRnqsmfPN9qKXu+oIKTIZxj1nRyVKP0FjGqefBZ8BMZ0ocBv9Hhfg560lM+CZhg00Yk29bn+/U5kOYNV9nSeTwdJTeXFX2H+m7ttE++1cJ7fjeYEiJv1JMvFRWm/PTZbmcmy+0pgXzuCzF0R3AEmEIuD+tpOX/Knc1FODIRNYb2yxKNW2iNRVKq9g/Qyuqn6w5Bp1cfdnTHNcNZL+GMHKoimKswgxPsR6NfbR/BMs"";

var key  = ""fdgfg787kim9om89"";

var aes = new pidCrypt.AES.CBC();
var decryptedData = aes.decryptText(crypted, key);
</code></pre>

<p>but it is returning null(no error), any guess what is wrong with this?</p>
","","530","<java><javascript><cryptojs><sjcl><pidcrypt>","0","","0","2014-06-03 07:49:04","","5","0","2345845","","2014-06-03 07:49:04","2014-06-02 11:00:08",""
"48844609","Crypto with Express","<p>I have one problem, with crypto package from npm.</p>

<p>I wan't to to send encrypted string to server to decrypt with express router params.</p>

<p>But there is a big problem, if i enter invalid string, server gives me this error:</p>

<pre><code>TypeError: Bad input string
at Decipher.update (crypto.js:144:26)
at decrypt (APPDIRECTORY\encryption.js:17:22)
at app.get (APPDIRECTORY\encryption.js:35:17)
at Layer.handle [as handle_request] (APPDIRECTORY\node_modules\express\lib\router\layer.js:95:5)
at next (APPDIRECTORY\node_modules\express\lib\router\route.js:137:13)
at Route.dispatch (APPDIRECTORY\node_modules\express\lib\router\route.js:112:3)
at Layer.handle [as handle_request] (APPDIRECTORY\node_modules\express\lib\router\layer.js:95:5)
at APPDIRECTORY\node_modules\express\lib\router\index.js:281:22
at param (APPDIRECTORY\node_modules\express\lib\router\index.js:354:14)
at param (APPDIRECTORY\node_modules\express\lib\router\index.js:365:14)
</code></pre>

<p>I just wan't to know, how to disable this error, and enter my own error!</p>

<p>Thanks!</p>

<p>EDIT:</p>

<pre><code>const express = require('express')
const app = express();

var crypto = require('crypto'),
    algorithm = 'aes-256-ctr',
    password = 'd6F3Efeq';

function encrypt(text){
  var cipher = crypto.createCipher(algorithm,password)
  var crypted = cipher.update(text,'utf8','hex')
  crypted += cipher.final('hex');
  return crypted;
}

function decrypt(text){
  var decipher = crypto.createDecipher(algorithm,password)
  var dec = decipher.update(text,'hex','utf8')
  dec += decipher.final('utf8');
  return dec;
}


app.get('/decrypt/:string', (request, response) =&gt; {

  let string = request.params.string;
  response.send(decrypt(string));

})

app.listen(3030, (request, response) =&gt; {
  console.log(""Server started succesfully!"")
})
</code></pre>

<p>If string is not aes-256-ctr format, i got errors. So is there someway to validate string if string is aes-256-ctr format?</p>
","<p>You just need try-catch:</p>

<pre><code>function decrypt(text){
  try {
    var decipher = crypto.createDecipher(algorithm,password)
    var dec = decipher.update(text,'hex','utf8')
    dec += decipher.final('utf8');
    return { result: dec };
  } catch(err) {
    return { error: 'INVALID_ENCRYPTED_TEXT' };
  }
}


app.get('/decrypt/:string', (request, response) =&gt; {
  let string = request.params.string;
  const dec = decrypt(string);
  if (dec.error) {
    response.status(400).end();
  } else {
    response.send(dec.result);
  }
});
</code></pre>
","520","<node.js><string><validation><encryption><cryptojs>","-2","0","1","2018-02-21 20:59:10","48873938","3","","7673263","","2018-02-18 10:07:20","2018-02-17 18:34:19",""
"37060729","Encrypted result in java and cryptoJS are different","<p>I'm trying to encrypt and decrypt AES using java and cryptoJS, everything good if i encrypt and decrypt a short text in either way. But if i put a long text, the result is wrong when cryptoJS try to decrypt it, in other way is working fine. Please help me to answer my problem. Here is my code.</p>

<p><strong>java code</strong></p>

<pre><code>public void setKey(String myKey){
        secretKey = new SecretKeySpec(Base64.decodeBase64(myKey), ""AES"");
    }

public String generateKey(int len) {
        final String AB = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";
        Random rnd = new Random();
        StringBuilder sb = new StringBuilder(len);
        for (int i = 0; i &lt; len; i++) {
            sb.append(AB.charAt(rnd.nextInt(AB.length())));
        }
        return sb.toString();
    }

public void encrypt(String strToEncrypt)
    {
        try
        {
            Cipher cipher = Cipher.getInstance(""AES/ECB/Iso10126Padding"");

            cipher.init(Cipher.ENCRYPT_MODE, secretKey);


            setEncryptedString(Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(""UTF-8""))));

        }
        catch (Exception e)
        {

            System.out.println(""Error while encrypting: ""+e.toString());
        }
    }
    public void decrypt(String strToDecrypt)
    {
        try
        {
            Cipher cipher = Cipher.getInstance(""AES/ECB/Iso10126PADDING"");

            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            setDecryptedString(new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt))));

        }
        catch (Exception e)
        {

            System.out.println(""Error while decrypting: ""+e.toString());
        }
    }
</code></pre>

<p><strong>Javascript code</strong></p>

<pre><code>function encrypt(string,key){
    var keyInside = CryptoJS.enc.Base64.parse(key);
    var encrypted = CryptoJS.AES.encrypt(string, keyInside, {mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Iso10126});
    return encrypted;
  }
function decrypt(string,key){
  var keyInside = CryptoJS.enc.Base64.parse(key);
  var decrypted = CryptoJS.AES.decrypt(string, keyInside, {mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Iso10126});
  return decrypted.toString(CryptoJS.enc.Utf8);
}
function generateKey(length)
{
    var text = """";
    var possible = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"";
    for( var i=0; i &lt; length; i++ )
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    return text;
}
</code></pre>

<p>thanks for helping me :)</p>
","","515","<javascript><java><encryption><aes><cryptojs>","1","","0","2016-05-05 22:24:09","","2","2","6297672","","2016-05-05 22:24:09","2016-05-05 21:39:04",""
"38628496","cryptojs sha256 hash length getting 64 bit instead of 32 bit","<p>I am using the crypto js from the <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">https://code.google.com/archive/p/crypto-js/</a></p>

<p>I am facing an issue as the <strong>.NET</strong> generated <code>sha256 hash</code> is 32 bit but the hash generated with the cryptojs is 64 bit .. </p>

<p>Please advice how to get the 32 bit hash from cryptojs <code>sha256</code> algorithm.</p>

<pre><code>CryptoJS.SHA256(""xxxxxxxxxxxxxxxxxxx.."").toString()
</code></pre>
","","514","<sha256><cryptojs>","0","","0","2016-07-28 07:04:19","","2","","6534219","","2016-07-28 07:04:19","2016-07-28 06:21:41",""
"52234916","Nodejs - encode to base64 with 'private key' and be able to decode only in server","<p>My use case is as follows:</p>

<ol>
<li>Incoming http request to server to login</li>
<li><p>User token is generated. The token is a Json object build from various fields. Then convert to String and Base64.</p>

<pre><code>const stringObject = {
  elementA: stringA,
  elementB: stringB
};

const bufferString = new Buffer(`${JSON.stringify(stringObject)}`);
const encodedAccessToken = bufferString.toString('base64');
</code></pre></li>
</ol>

<p>The generated string can now be decoded anywhere.
Is there a way I can encode it in such as way that only my server will be able to decode it? Like encoding it with some sort of a key.</p>

<p>Thanks.</p>
","<p>This does not directly answer your question, but I think your overall approach is wrong. What you are trying to achieve is to have session data. You don't need to send this data to the client and back. That is not a very good practice. Instead you should store this data on the server, preferably in a database.</p>

<p>What you would do is to create a unique key, something randomly generated. You would store the user data using this key, and send the key to the client to be used on requests. You do it by setting it as a cookie variable as well. </p>

<p>The user data can have additional fields variables for more secure access. Like the IP of the client, and possibly a expiry time for cleanup.</p>
","514","<javascript><node.js><base64><cryptojs>","0","0","3","2018-09-08 18:18:20","","3","","","","","2018-09-08 11:35:47",""
"52234916","Nodejs - encode to base64 with 'private key' and be able to decode only in server","<p>My use case is as follows:</p>

<ol>
<li>Incoming http request to server to login</li>
<li><p>User token is generated. The token is a Json object build from various fields. Then convert to String and Base64.</p>

<pre><code>const stringObject = {
  elementA: stringA,
  elementB: stringB
};

const bufferString = new Buffer(`${JSON.stringify(stringObject)}`);
const encodedAccessToken = bufferString.toString('base64');
</code></pre></li>
</ol>

<p>The generated string can now be decoded anywhere.
Is there a way I can encode it in such as way that only my server will be able to decode it? Like encoding it with some sort of a key.</p>

<p>Thanks.</p>
","<p>use jsonwebtoken instead. it can encrypt your object with a secret phrase. library like <code>node-jsonwebtoken</code> is very easy to use. </p>
","514","<javascript><node.js><base64><cryptojs>","0","0","3","2018-09-08 18:18:20","","3","","","","","2018-09-08 11:35:47",""
"52234916","Nodejs - encode to base64 with 'private key' and be able to decode only in server","<p>My use case is as follows:</p>

<ol>
<li>Incoming http request to server to login</li>
<li><p>User token is generated. The token is a Json object build from various fields. Then convert to String and Base64.</p>

<pre><code>const stringObject = {
  elementA: stringA,
  elementB: stringB
};

const bufferString = new Buffer(`${JSON.stringify(stringObject)}`);
const encodedAccessToken = bufferString.toString('base64');
</code></pre></li>
</ol>

<p>The generated string can now be decoded anywhere.
Is there a way I can encode it in such as way that only my server will be able to decode it? Like encoding it with some sort of a key.</p>

<p>Thanks.</p>
","<p>You can use JWT token Node Module : <a href=""https://www.npmjs.com/package/jsonwebtoken"" rel=""nofollow noreferrer"">link</a></p>

<p><strong>Encode data and generate token</strong> :</p>

<pre><code>var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
</code></pre>

<blockquote>
  <p>{ foo: 'bar' } is your feilds that you encrypt</p>
</blockquote>

<p><strong>Decode by same key <code>shhhhh</code></strong></p>

<pre><code>// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});
</code></pre>
","514","<javascript><node.js><base64><cryptojs>","0","1","3","2018-09-08 18:18:20","","3","","","","","2018-09-08 11:35:47",""
"29212037","Node.js and Mongodb security + encryption options for source code","<p>I opened this thread cause i'm having hard time deciding on some issues i have with my project.
The issues are:</p>

<ol>
<li>Encrypting source code files(not obfuscation, need encryption that can be ran).</li>
<li>Encrypting documents stored in mongodb, mainly username and passwords.</li>
<li>Mongodb login - is it possible to demand a username &amp; password to open connection to the server?
<ul>
<li><strong>Little bit of info:</strong> My project is to be installed on customer servers, so it's very important that the code will not be viewable and hopefully uncrackable(minimum security).</li>
</ul></li>
</ol>

<p><strong>1</strong> - For the first item, i found JXCORE and it seems promising, but i was unsuccessful at finding proof or reviews of users who used it in production.
Anyone can recommend other methods? or if anyone can review the option i listed i'll appriciate it.</p>

<p><strong>2</strong> -  For encryption i want to use AES256 and i found the library crypto-js to be able to answer the requirements.
Unfortunately, it doesn't provide assistance with node.js(none that i could find).</p>

<p>For example when i run this code, i want to see both the encrypted and the decrypted items:</p>

<pre><code>var AES = require(""crypto-js/aes"");    
var temp = AES.encrypt(""Message"", ""secret password"").ciphertext.toString();
    console.log(temp);
    console.log(AES.decrypt(temp, ""secret password""));
</code></pre>

<p><strong>Only the encrypted ciphertext is presented, not sure how to access the decrypted text.</strong></p>

<p><em>On a side note</em>, does anyone recommend using SHA3 combined with AES256?</p>

<p><strong>What is the recommended approach for securing username&amp;password mongodb DB?</strong></p>

<p>If you got a documentation link or useful tutorial for crypto-js in node.js please link in the comments.
My JS skills aren't pro so it might be in there and i fail to see it, so apologizes if this was a noob thread.</p>

<p>Thanks.</p>
","<p>Ended up using crypto for aes256 and JXCORE for obfuscation.</p>
","513","<javascript><node.js><mongodb><encryption><cryptojs>","1","1","1","2015-05-21 10:02:50","29675586","2","","3730436","","2015-03-23 13:58:46","2015-03-23 13:53:24",""
"48515282","node js encrypt values by public key error TypeError: Data must be a buffer","<p>I have a back end service that works with payment gateway, for this purpose I need to encrypt a few parameters. I'm using <strong>crypto</strong> library but in signing value that contains sum of values let <code>value = a+b+c+d</code> its returns an error message like below : </p>

<blockquote>
  <p>TypeError: Data must be a buffer<br>
      at Sign.sign (crypto.js:331:26)</p>
</blockquote>

<p>this is my function for encrypting</p>

<pre><code>const sign = (value) =&gt; {
    let sign = crypto.createSign('SHA1');
    sign.update(Buffer.from(value), 'utf8');
    return sign.sign(PrivateKey, 'base64');
}
</code></pre>

<p>which my PrivateKey is something like this 123</p>
","<blockquote>
  <p>which my PrivateKey is something like this 123</p>
</blockquote>

<p>Your <code>PrivateKey</code> is wrong. Execute the following command to generate PrivateKey <code>openssl genrsa  -out privkey.pem 1024</code>.</p>

<pre><code> let pem = fs.readFileSync('./privkey.pem');
 let PrivateKey = pem.toString('ascii');
</code></pre>

<p><code>crypto</code> module description is</p>

<blockquote>
  <p>The crypto module provides cryptographic functionality that includes a set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify functions.</p>
</blockquote>
","511","<javascript><node.js><encryption><cryptojs>","1","0","1","2018-01-30 07:30:35","","5","","5550507","","2018-01-30 07:30:35","2018-01-30 06:33:41",""
"40478389","Auto - Download encrypted file","<p>I am trying to encrypt and then download files from folder on client side. I have the below code, but the actual encrypted file is not getting downloaded. Building the download URL is where I am having issues.</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta content=""text/html; charset=utf-8"" http-equiv=""Content-Type"" /&gt;
&lt;title&gt;Get Directory&lt;/title&gt;
&lt;!-- Update your jQuery version??? --&gt;
&lt;script src=""http://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js""&gt;&lt;/script&gt;
&lt;script src=""assets/js/aes.js""&gt;&lt;/script&gt;
&lt;script&gt; // type=""text/javascript"" is unnecessary in html5

// Short version of doing `$(document).ready(function(){`
// and safer naming conflicts with $
jQuery(function($) { 

    $('#file-input').on('change', function() {

        // You can't use the same reader for all the files
         var array1 = new Array

        $.each(this.files, function(i, file) {

            // Uses different reader for all files
            var reader = new FileReader
            var downloadUrl = ''
            reader.onload = function() {
                // reader.result refer to dataUrl
                // theFile is the blob... CryptoJS wants a string...
                var encrypted = CryptoJS.AES.encrypt(reader.result, '12334')
                downloadUrl = 'data:application/octet-stream,' + encrypted;
                array1.push(downloadUrl);
                setTimeout(""window.location.assign('"" + downloadUrl + file.name + '.encrypted'+ ""');"", 500)
            }

            reader.readAsDataURL(file)
            $('#thelist').append('FILES: ' + file.name + '&lt;br&gt;')

        })

    })
})
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;input type=""file"" id=""file-input"" webkitdirectory="""" directory=""""&gt;
&lt;div id=""thelist""&gt;&lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre>
","<p>In case anyone is looking for this one, I was able to resolve it as below.</p>

<pre><code>              var reader = new FileReader();
                reader.onload = function (e) {
                var encrypted = CryptoJS.AES.encrypt(reader.result, '12345');
                var dataUrl = 'data:data:application/octet-stream,' + encrypted;
                array1.push('href=data:data:application/octet-stream,' + encrypted);

                var link = document.createElement(""a"");
                link.download = file.name + '.encrypted';
                link.target = ""_blank"";

                // Construct the uri
                link.href = dataUrl;
                document.body.appendChild(link);
                link.click();

                // Cleanup the DOM
                document.body.removeChild(link);
                delete link;
                };
                $('#thelist').append('FILES: ' + file.name + '&lt;br&gt;')
                reader.readAsDataURL(file);
              })
</code></pre>
","510","<javascript><jquery><encryption><filereader><cryptojs>","-1","0","1","2016-11-15 20:03:26","","3","","","","","2016-11-08 03:20:59",""
"30295911","Converting a cryptojs MD5 script into PHP","<p>I've got a piece of javascript which someone has written to convert an ID into a particular hashed ID used by a program.</p>

<p>Note that the javascript output cannot be changed. It replicates the hashing done by the above mentioned 3rd-party program. I am trying to likewise replicate the hashing in PHP.</p>

<p>My aim is to convert this into PHP, so I can run the conversion in some back-end scripts.</p>

<p>However, it uses the cryptoJS library, and I can't find a way to convert it to PHP properly, as the MD5 in cryptoJS seems to have an array passed to it, and the PHP MD5 is passed a string. See below for some code examples</p>

<p>What they have (javascript)</p>

<pre><code>var id = bigInt(12345678912345678);
var parts = [0x42,0x45,0,0,0,0,0,0,0,0];

for (var i = 2; i &lt; 10; i++) {
    var res = id.divmod(256);
    id = res.quotient; 
    parts[i] = res.remainder.toJSNumber();
}

var wordArray = CryptoJS.lib.WordArray.create(new Uint8Array(parts));
$(""#newid"").val(CryptoJS.MD5(wordArray));
</code></pre>

<p>What I've got in PHP</p>

<pre><code>$id = 12345678912345678;
$parts = [0x42,0x45,0,0,0,0,0,0,0,0];

for ($i=2; $i &lt; 10; $i++){
    $quo = (int)($id / 256);
    $rem = $id % 256;
    $id = $quo;
    $parts[$i] = $rem;
}

$hash = md5($parts);
echo $hash;
</code></pre>

<p>This of course, returns an error due to MD5 not taking an array.</p>

<p>I've tried something simple such as join()ing the array, but that doesn't return the same hash.</p>

<p>I've had a look into the cryptoJS library, and I've done tons of google searches, and looked through SO (inc: <a href=""https://stackoverflow.com/questions/17283581/generate-tha-same-md5-using-javascript-and-php"">Generate the same MD5 using javascript and PHP</a> , <a href=""https://stackoverflow.com/questions/23149282/sha512-hashes-differ-on-android-php-and-javascript"">SHA512 hashes differ on android, php and javascript</a> etc) but can't seem to find anything which answers this question.</p>

<p>I have a feeling that the issue is me not understanding exactly what the wordArray is passing into the MD5 (and thus not being able to reproduce properly in PHP)... but I'm not familiar enough with the cryptoJS library to be sure.</p>

<p>Some output...</p>

<pre><code>ID used: 12345678912345678

using join('',$parts)
PHP: d378d1609e6a2854b129b012aa6363ea
JS: 61bb919806ee7c4ad6f781b49a89dfcf

using json_encode($parts)
PHP: 3e2393c173558194b6ba1bbedc9314e1
JS: 61bb919806ee7c4ad6f781b49a89dfcf
</code></pre>
","","508","<javascript><php><hash><md5><cryptojs>","0","","0","2015-05-18 11:34:46","","8","","-1","","2017-05-23 11:58:12","2015-05-18 05:49:54",""
"43790620","JavaScript base64 encode btoa() vs CryptoJS why they differ?","<p>Fiddle <a href=""https://jsfiddle.net/rthunm9j/96/"" rel=""nofollow noreferrer"">here</a>:</p>

<pre><code>var canonicalString = 'GET'+'\n'
  +'/?a=&amp;b=c'+'\n'
  +'application/json'+'\n'
  +'\n'
  +'Mon, 26 Mar 2007 19:37:58 +0000';

console.log(canonicalString);
canonicalString = CryptoJS.HmacSHA256(canonicalString, 'bar');

console.log(CryptoJS.enc.Base64.stringify(canonicalString));
console.log(btoa(canonicalString.toString()));
</code></pre>

<p>I can't understand why the results are different. Where I'm wrong? By the way, the right one should be the <code>btoa()</code> version.</p>
","<p>Using a <a href=""http://tomeko.net/online_tools/base64.php?lang=en"" rel=""nofollow noreferrer"">Base64 online decoder</a> we can see the input was in different encodings:</p>

<pre>
7Sbw7FL9uyWDsrrW+Hi9sjdWoOtHT52Fqp9gfViFW1E=
ED26F0EC52FDBB2583B2BAD6F878BDB23756A0EB474F9D85AA9F607D58855B51

ZWQyNmYwZWM1MmZkYmIyNTgzYjJiYWQ2Zjg3OGJkYjIzNzU2YTBlYjQ3NGY5ZDg1YWE5ZjYwN2Q1ODg1NWI1MQ==
65643236663065633532666462623235383362326261643666383738626462323337353661306562343734663964383561613966363037643538383535623531
</pre>

<p>In the first case the initial original character was ""E""<br>
In the second case the initial original characters were ""65""</p>

<p>The ASCII character ""E"" is ""65"" in hexadecimal encoding.</p>

<p>This the first case encoded a character representation while the decomnd case encoded a hexadecimal representations. Different Base64 implementations handle input encodings differently.</p>

<p>Missing from the question are the code examples, there needs to be a <a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, and Verifiable example</a>.</p>
","499","<javascript><base64><cryptojs>","-1","0","1","2017-05-04 19:20:52","","3","","","","","2017-05-04 18:47:53",""
"45928187","AES encryption on iOS with base64 key from CryptoJS","<p>I'm generating and exporting a key with CryptoJS:</p>

<pre><code>const password = crypto.lib.WordArray.random(128 / 8);
const salt = crypto.lib.WordArray.random(128 / 8);
const encryptionKey = crypto.PBKDF2(password, salt, {keySize: 128 / 32});
return encryptionKey.toString();
</code></pre>

<p>Now I'm trying to encrypt some data with the key on iOS:</p>

<pre><code>const char *s = [encryptionKey cStringUsingEncoding:NSASCIIStringEncoding];
NSData *keyData= [NSData dataWithBytes:s length:strlen(s)];

NSMutableData *ivData = [NSMutableData dataWithLength:kCCBlockSizeAES128];
SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivData.mutableBytes);
NSData *iv = [NSData dataWithData:ivData];

size_t outLength;

NSMutableData *cipherData = [NSMutableData dataWithLength:dataString.length + kCCBlockSizeAES128];
CCCrypt(kCCEncrypt, // operation
    kCCAlgorithmAES128, // Algorithm
    kCCOptionPKCS7Padding, // options
    keyData.bytes, // key
    keyData.length, // keylength
    iv.bytes,// iv
    jsonData.bytes, // dataIn
    jsonData.length, // dataInLength,
    cipherData.mutableBytes, // dataOut
    cipherData.length, // dataOutAvailable
    &amp;outLength); // dataOutMoved

    cipherData.length = outLength;

NSString *cipherText = [cipherData base64EncodedStringWithOptions:NSUTF8StringEncoding];
NSString *ivText = [iv base64EncodedStringWithOptions:NSUTF8StringEncoding];

return [ivText stringByAppendingString:cipherText]
</code></pre>

<p>This all works so far. Trying to decrypt the data with CryptoJS however fails:</p>

<pre><code>const iv = crypto.enc.Base64.parse(message.substr(0, 24));
const encrypted = crypto.enc.Base64.parse(message.substring(24));

const decrypted = crypto.AES.decrypt(encrypted, encryptionKey, {
  iv: iv,
  padding: crypto.pad.Pkcs7,
  mode: crypto.mode.CBC
});
console.log(decrypted.toString(crypto.enc.Utf8))
</code></pre>

<p>The problem seems to be in the passing of the key from CryptoJS to iOS. What is the correct format to pass to CCCrypt?</p>
","<p>The option to <code>base64EncodedStringWithOptions</code> is incorrect and will add line ending characters to the Base64 encoded iv and encrypted data.</p>

<p>You do not want line endings options, by default, no line endings are inserted. Just specify <code>0</code>:</p>

<pre><code>NSString *cipherText = [cipherData base64EncodedStringWithOptions:0];
NSString *ivText = [iv base64EncodedStringWithOptions:0];
</code></pre>

<p>The option Note that <code>NSUTF8StringEncoding</code> is not an encoding option for the method <code>base64EncodedStringWithOptions</code>. The options are:</p>

<pre><code>NSDataBase64Encoding64CharacterLineLength
NSDataBase64Encoding76CharacterLineLength
NSDataBase64EncodingEndLineWithCarriageReturn
NSDataBase64EncodingEndLineWithLineFeed`
</code></pre>

<p>which are all line separator options. </p>
","496","<ios><objective-c><encryption><aes><cryptojs>","0","1","2","2017-08-29 06:41:44","","3","","","","","2017-08-28 22:29:46",""
"45928187","AES encryption on iOS with base64 key from CryptoJS","<p>I'm generating and exporting a key with CryptoJS:</p>

<pre><code>const password = crypto.lib.WordArray.random(128 / 8);
const salt = crypto.lib.WordArray.random(128 / 8);
const encryptionKey = crypto.PBKDF2(password, salt, {keySize: 128 / 32});
return encryptionKey.toString();
</code></pre>

<p>Now I'm trying to encrypt some data with the key on iOS:</p>

<pre><code>const char *s = [encryptionKey cStringUsingEncoding:NSASCIIStringEncoding];
NSData *keyData= [NSData dataWithBytes:s length:strlen(s)];

NSMutableData *ivData = [NSMutableData dataWithLength:kCCBlockSizeAES128];
SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivData.mutableBytes);
NSData *iv = [NSData dataWithData:ivData];

size_t outLength;

NSMutableData *cipherData = [NSMutableData dataWithLength:dataString.length + kCCBlockSizeAES128];
CCCrypt(kCCEncrypt, // operation
    kCCAlgorithmAES128, // Algorithm
    kCCOptionPKCS7Padding, // options
    keyData.bytes, // key
    keyData.length, // keylength
    iv.bytes,// iv
    jsonData.bytes, // dataIn
    jsonData.length, // dataInLength,
    cipherData.mutableBytes, // dataOut
    cipherData.length, // dataOutAvailable
    &amp;outLength); // dataOutMoved

    cipherData.length = outLength;

NSString *cipherText = [cipherData base64EncodedStringWithOptions:NSUTF8StringEncoding];
NSString *ivText = [iv base64EncodedStringWithOptions:NSUTF8StringEncoding];

return [ivText stringByAppendingString:cipherText]
</code></pre>

<p>This all works so far. Trying to decrypt the data with CryptoJS however fails:</p>

<pre><code>const iv = crypto.enc.Base64.parse(message.substr(0, 24));
const encrypted = crypto.enc.Base64.parse(message.substring(24));

const decrypted = crypto.AES.decrypt(encrypted, encryptionKey, {
  iv: iv,
  padding: crypto.pad.Pkcs7,
  mode: crypto.mode.CBC
});
console.log(decrypted.toString(crypto.enc.Utf8))
</code></pre>

<p>The problem seems to be in the passing of the key from CryptoJS to iOS. What is the correct format to pass to CCCrypt?</p>
","<p>My original code contained three errors.</p>

<ol>
<li><p>The resulting strings need to be encoded using no parameter as suggested by zaph:</p>

<pre><code>NSString *cipherText = [cipherData base64EncodedStringWithOptions:0];
NSString *ivText = [iv base64EncodedStringWithOptions:0];
</code></pre></li>
<li><p>To correctly convert the encryption key to <code>NSData</code>, I use the method provided <a href=""https://stackoverflow.com/questions/7317860/converting-hex-nsstring-to-nsdata"">here</a> and call it like this:</p>

<pre><code>NSData *keyData= [self dataFromHexString:encryptionKey];
</code></pre></li>
<li><p>The <code>decrypt</code> function of CryptoJS requires an object like this:</p>

<pre><code>const encrypted = crypto.enc.Base64.parse(message.substring(24));

const params = {
  ciphertext: encrypted,
  salt: ''
};

const decrypted = crypto.AES.decrypt(params, crypto.enc.Hex.parse(this.encryptionKey.toString()), {
  iv: iv,
  padding: crypto.pad.Pkcs7,
  mode: crypto.mode.CBC
});

return decrypted.toString(crypto.enc.Utf8);
</code></pre></li>
</ol>

<p>Thanks for your help!</p>
","496","<ios><objective-c><encryption><aes><cryptojs>","0","0","2","2017-08-29 06:41:44","","3","","","","","2017-08-28 22:29:46",""
"46454876","AWS Cognito and Amazon API Gateway integration within Telerik NativeScript","<p>I am developing a Telerik NativeScript application with Amazon Web Services (AWS)
and I am stuck on how to implement the logging method using Amazon Cognito.</p>

<p>I have two questions : </p>

<p>First - I have installed 'nativescript-aws' (an 'npm' library which integrates the 'aws-sdk' <a href=""https://github.com/aws/aws-sdk-js/releases"" rel=""nofollow noreferrer"">AWS JavaScript SDK</a> for JavaScript) and it seems working on the application, but the problem comes with AWS Cognito, I have integrated AWS Cognito through 'amazon-cognito-identity-js' <a href=""https://github.com/aws/amazon-cognito-identity-js"" rel=""nofollow noreferrer"">Amazon Cognito Identity SDK for JavaScript</a> but when I run the application through 'tns debug android' it stucks on ""Failed to find module: ""crypto"", relative to: app/tns_modules/""... I have made a research and it seems that NativeScript does not support Crypto JS yet.</p>

<p>Second - If in any chance I succeeded to run the application I want to generate an SDK through Amazon API Gateway and integrate it within my project, thoses are the files that I need to use into the project :</p>

<pre><code>&lt;script type=""text/javascript"" src=""lib/axios/dist/axios.standalone.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/CryptoJS/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/CryptoJS/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/CryptoJS/components/hmac.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/CryptoJS/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/url-template/url-template.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/apiGatewayCore/sigV4Client.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/apiGatewayCore/apiGatewayClient.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/apiGatewayCore/simpleHttpClient.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""lib/apiGatewayCore/utils.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript"" src=""apigClient.js""&gt;&lt;/script&gt;
</code></pre>

<p>In summary, I want to know the best way to integrate all those libraries into my project and make it work.</p>
","<p>Check out <a href=""https://github.com/EddyVerbruggen/nativescript-nodeify"" rel=""nofollow noreferrer"">nativescript-nodeify</a> for instructions. The cognito-specific stuff is at the very bottom. The nativescript-aws-sdk has now been deprecated so that's not a good option anymore</p>
","495","<amazon-web-services><aws-sdk><nativescript><cryptojs>","3","-1","1","2018-09-25 00:44:43","","8","","1079075","","2018-09-25 00:44:43","2017-09-27 18:31:21",""
"49066575","Proper way to decrypt CryptoJS DES encoded string using Java?","<p>In JavaScript side I use:</p>

<pre><code>CryptoJS.DES.encrypt('Content', 'password').toString()
</code></pre>

<p>The result:</p>

<pre><code>U2FsdGVkX1/25rW2q0X7/pOtExFyP7MD
</code></pre>

<p>In Java side I try to decrypt it:</p>

<pre><code>public static void main(String[] args) throws Exception {

String password = ""password"";
String encryptedString = ""U2FsdGVkX1/25rW2q0X7/pOtExFyP7MD"";

DESKeySpec key = new DESKeySpec(password.getBytes());
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DES"");

Cipher cipher = Cipher.getInstance(""DES/CBC/PKCS5Padding"");

SecureRandom secureRandom = new SecureRandom();
byte[] ivspec = new byte[cipher.getBlockSize()];
secureRandom.nextBytes(ivspec);

IvParameterSpec iv = new IvParameterSpec(ivspec);

    cipher.init(Cipher.DECRYPT_MODE, keyFactory.generateSecret(key), iv);
    byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedString.getBytes()));

    System.out.println(new String(Base64.getEncoder().encode(decryptedBytes)));
}
</code></pre>

<p>But I'm getting the bad padding error:</p>

<pre><code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
</code></pre>

<p>Can anyone tell me what went wrong and what is the proper way to decrypt it? Assuming that the JavaScript side code cannot be changed (i.e the way to encrypt the string using DES). Thank you very much.</p>
","<p>The IV must be the same for both encryption  and decryption. in the example a new random IV is being created for decryption: <code>secureRandom.nextBytes(ivspec);</code>.</p>

<p>You need to carefully and fully review the <code>CryptoJS</code> documentation to determine how the IV is being handled. Often the IV is prepended to the encrypted data for use during decryption.</p>

<p>The <code>encryptedString</code> seems to be Base64 encoded and the decoded length is 32-bytes, just right for a 16-byte IV and 16-byte encrypted data+padding.</p>
","495","<javascript><java><encryption><cryptojs><des>","-1","1","1","2018-03-02 11:51:29","","5","0","","","","2018-03-02 09:47:06",""
"54463854","""EVP_DecryptFinal_ex:wrong final block length"" in nodejs crypto package","<p>The value of the data input is encoded with a AES-128 mechanism, where the first 16 characters is the client_secret of my application, which serves as a key to the decoding process.I tried to decode it,it not work.
The code I tried
`</p>

<pre><code>const express=require('express');
const bodyParser=require('body-parser');
var app=express();
var crypto=require('crypto');
app.use(express.static(__dirname+'/public'));
app.use(bodyParser.urlencoded({extended:true}));
app.post('/',(req,res)=&gt;{
    var app_secret_key=""my secret key"";
    var abc=JSON.stringify(req.body.data);
    var key_app_secret_key=app_secret_key.substring(0,16);
    function decrypt(key,data){
        var decipher = crypto.createDecipher('aes-128-cbc',key);
        var decrypted = decipher.update(data,'binary', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    }
    console.log(decrypt(key_app_secret_key,abc));
 });
app.listen(3000,()=&gt;{
    console.log('Server running in port 3000');
})
</code></pre>

<p>`
The error I am getting attach below. Please advise me how to solve this issue. Thanks in advance. </p>

<pre><code>Error: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
    at Decipher.final (crypto.js:183:26)
    at decrypt (c:\xampp\htdocs\cameacoins\encryptPract\app.js:18:25)
    at app.post (c:\xampp\htdocs\cameacoins\encryptPract\app.js:22:14)
    at Layer.handle [as handle_request] (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\layer.js:95:5)
    at next (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\route.js:137:13)
    at Route.dispatch (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\route.js:112:3)
    at Layer.handle [as handle_request] (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\layer.js:95:5)
    at c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\index.js:281:22
    at Function.process_params (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\index.js:335:12)
    at next (c:\xampp\htdocs\cameacoins\node_modules\express\lib\router\index.js:275:10)
</code></pre>
","","489","<javascript><node.js><encryption><cryptojs>","0","","0","2019-01-31 15:24:24","","12","","","","","2019-01-31 15:24:24",""
"47351742","Encrypt in VB.NET Rijndael Managed and Decrypt in Javascript CryptoJS","<p>I'm making an app that has to decrypt QRs and well... It doesn't, because i get the QR string but i cannot decrypt it.</p>

<p>I'm using this encryption method in VB.NET, and it works perfectly when i read an decrypt from VB.NET:</p>

<pre><code>Private Function GetCodedQR(ByVal str As String) As String
    Dim sToEncrypt As String = str

    Dim encrypted() As Byte
    ' Create an Rijndael object
    ' with the specified key and IV.
    Using rijAlg = Rijndael.Create()

        rijAlg.Padding = PaddingMode.Zeros
        rijAlg.Mode = CipherMode.CBC
        rijAlg.KeySize = 256
        rijAlg.BlockSize = 256
        rijAlg.Key = System.Text.Encoding.ASCII.GetBytes(""12345678912345678912345678912345"")
        rijAlg.IV = System.Text.Encoding.ASCII.GetBytes(""123452hheeyy66#cs!9hjv887mxx7@8y"")

        ' Create an encryptor to perform the stream transform.
        Dim encryptor As ICryptoTransform = rijAlg.CreateEncryptor(rijAlg.Key, rijAlg.IV)
        ' Create the streams used for encryption.
        Using msEncrypt As New MemoryStream()
            Using csEncrypt As New CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write)
                Using swEncrypt As New StreamWriter(csEncrypt)

                    'Write all data to the stream.
                    swEncrypt.Write(sToEncrypt)
                End Using
                encrypted = msEncrypt.ToArray()
            End Using
        End Using
    End Using

    sToEncrypt = Convert.ToBase64String(encrypted)

    Return sToEncrypt
End Function
</code></pre>

<p>But when im using JS (CryptoJS) to decrypt the message it just dont work!</p>

<pre><code>var iv = CryptoJS.enc.Utf8.parse('123452hheeyy66#cs!9hjv887mxx7@8y');
var decrypted = CryptoJS.AES.decrypt(encrypted, '12345678912345678912345678912345', { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.ZeroPadding });
</code></pre>

<p>Please help me I'm doing my best but JS is not my thing.</p>
","","484","<javascript><vb.net><encryption><aes><cryptojs>","1","","0","2017-11-17 13:27:26","","1","","","","","2017-11-17 13:27:26",""
"38787349","Translation from Python to JavaScript: HMAC-SHA256","<p>I'd like to convert the following piece of Python code to JavaScript:</p>

<pre class=""lang-py prettyprint-override""><code>signature_string = self.format(""{apip_id}{identity_id}{method}{uri}{content_hash}{timestamp}{nonce}"") # pyhton unicode string in UTF-8 format
signature_bytes = signature_string.encode('utf-8') # previous string is converted in a python bytes string
apip_key_bytes = base64.b64decode(self.apip_key.encode('utf-8')) # pyhton unicode string is converted in a python bytes string and then in ??
hasher = hmac.new(apip_key_bytes, signature_bytes, hashlib.sha256) # hash is calculated
hash_bytes = hasher.digest() # hash coded in a python bytes string
return base64.b64encode(hash_bytes).decode('utf-8') # the hash in bytes is converted to a base64 string
</code></pre>

<p>I tried to use crypto.JS and developed following code but I don't think I get the correct result, This is my conversion in JavaScript of the above code</p>

<pre><code>function stringToAsciiByteArray(str) {
    var bytes = [];
    for (var i = 0; i &lt; str.length; ++i) {
        var charCode = str.charCodeAt(i);
        if (charCode &gt; 0xFF) // char &gt; 1 byte since charCodeAt returns the    UTF-16 value
        {
        throw new Error('Character ' + String.fromCharCode(charCode) + '  can\'t be represented by a US-ASCII byte.');
        }
       bytes.push(charCode);
    }
    return bytes;
}

var signature_bytes = stringToAsciiByteArray(signature_string);
var apip_key_bytes = stringToAsciiByteArray(apip_key);

CryptoJS.enc.u8array = {
    stringify: function(wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;

        // Convert
        var u8 = new Uint8Array(sigBytes);
        for (var i = 0; i &lt; sigBytes; i++) {
            var byte = (words[i &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (i % 4) * 8)) &amp; 0xff;
            u8[i] = byte;
        }

        return u8;
    },
    parse: function(u8arr) {
        // Shortcut
        var len = u8arr.length;

        // Convert
        var words = [];
        for (var i = 0; i &lt; len; i++) {
            words[i &gt;&gt;&gt; 2] |= (u8arr[i] &amp; 0xff) &lt;&lt; (24 - (i % 4) * 8);
        }

        return CryptoJS.lib.WordArray.create(words, len);
    }
};

var wordArray1 = CryptoJS.enc.u8array.parse(signature_bytes);
var wordArray2 = CryptoJS.enc.u8array.parse(apip_key_bytes);
var hash_bytes = CryptoJS.HmacSHA256(wordArray1, wordArray2);
return window.btoa(hash_bytes);
</code></pre>

<p>The hash code I get after this procedure I don't think it's correct, it doesn't work, am I doing something wrong?</p>
","","483","<javascript><python><sha256><hmac><cryptojs>","2","","0","2016-08-05 17:22:31","","7","","1816580","","2016-08-05 17:22:31","2016-08-05 10:46:13",""
"28681409","PBKDF2 hashing in javascript and iOS generating different keys","<p>This is a question related to the post: <a href=""https://groups.google.com/forum/#!topic/crypto-js/t_HeWo5QhLk"" rel=""nofollow"">https://groups.google.com/forum/#!topic/crypto-js/t_HeWo5QhLk</a></p>

<p>I have tried to solution mentioned in the post but still cannot figure out the problem with my code:</p>

<p><strong>using Crypto.js</strong></p>

<pre><code>var key= CryptoJS.PBKDF2(""gf8uny"", ""2mnfpLsa+5I="", { keySize: 256/32, iterations: 1000 });
console.log(key.toString());
console.log(btoa(key.toString()));
//OUTPUT: MDBkN2E5MWZkZjAzYTk5MWVkMzI0OTE1YWM4OTNmMDhkOTlmY2E0NTRmN2M0MTY5YTFhYzc2M2M1ZjMzZTY0Zg==
</code></pre>

<p><strong>using CommonCrypto in iOS:</strong></p>

<pre><code>NSMutableData *webKey = [NSMutableData dataWithLength:64];
NSData *salt = [@""2mnfpLsa+5I="" dataUsingEncoding:NSUTF8StringEncoding];
NSString* password = @""gf8uny"";
CCKeyDerivationPBKDF(kCCPBKDF2, password.UTF8String, password.length, salt.bytes,salt.length, kCCPRFHmacAlgSHA1, 1000, webKey.mutableBytes, webKey.length);

NSString* skey = [webKey base64EncodedStringWithOptions:0];
NSLog(@""key %@"",skey);
//OUTPUT: ANepH98DqZHtMkkVrIk/CNmfykVPfEFpoax2PF8z5k+jrwa0yTNt0tQedQ4bxqV/T0gXbsyKHiVx8DuJdlkufA==
</code></pre>

<p>The output string in both codes is base64 encoded.</p>

<p>Can anyone point out what is wrong with this code?</p>

<p>Thanks!</p>
","<p>The reason that the output looks different is that the input to Base64 is different; the reason for that is that in the JavsScript code, you've called</p>

<pre><code>key.toString()
</code></pre>

<p>So, in JavaScript, you have base64-encoded the 64-character string</p>

<pre><code>""00d7a91fdf03a991ed324915ac893f08d99fca454f7c4169a1ac763c5f33e64f""
</code></pre>

<p>And jn Objective-C, you have base64-encoded the raw 32-byte sequence</p>

<pre><code>0x00 0xd7 0xa9 0x1f 0xdf ... 0xe6 0x4f
</code></pre>

<p>In both cases, your PBKDF2 code has come up with the same key. You have just encoded the key differently in each case.</p>

<p>You can get CryptoJS to create the same Base64 output by serializing the key directly, like this:</p>

<pre><code>key.toString(CryptoJS.enc.Base64)
</code></pre>

<p>(See <a href=""https://code.google.com/p/crypto-js/#The_Hasher_Output"" rel=""nofollow"">https://code.google.com/p/crypto-js/#The_Hasher_Output</a> for the documentation. You may have to include another script file for this output format to be available)</p>
","482","<javascript><ios><cryptojs><pbkdf2>","1","2","1","2015-02-23 20:47:50","28681510","0","","","","","2015-02-23 19:04:36",""
"32500342","Encrypt/decrypt with two different keys","<h2>My code</h2>

<p>I'm encrypting a string with two different keys with CryptoJS:</p>

<pre><code>var password = ""testpassword"";
var serverkey = ""randomkey"";
var text = document.getElementById(""new_note"").value;
var encrypted1 = CryptoJS.AES.encrypt(text, password);
encrypted1 = encrypted1.toString();
var encrypted = CryptoJS.AES.encrypt(encrypted1,serverkey);
</code></pre>

<p>And trying to decrypt it with this code:</p>

<pre><code>var password = ""testpassword"";
var serverkey = ""randomkey"";
var encrypted_text = localStorage.getItem(""encrypted"");
var decrypted1 = CryptoJS.AES.decrypt(encrypted_text,serverkey);
decrypted1 = decrypted.toString();
var decrypted = CryptoJS.AES.decrypt(decrypted1,password);
decrypted = decrypted.toString(CryptoJS.enc.Utf8);
document.getElementById(""decrypted"").innerHTML = decrypted;
</code></pre>

<h2>What isn't working</h2>

<p>While the encryption seems to work fine, when I try to convert <code>decrypted1</code> to a string in order to decrypt it the second time, I get <code>Cannot read property 'toString' of undefined</code> on the chrome console. This should mean that the first decryption process returns an empty string.</p>

<h2>My question</h2>

<p>How can I fix this problem?</p>
","<p>There is a typo in your variable names. Check where you define <code>decrypted</code> and where you use it. You meant to use <code>decrypted1</code>.</p>

<p>Additionally, you have a problem with the encoding. The first <code>decrypted1.toString();</code> will encode the string into Hex, but earlier you called <code>encrypted1.toString();</code> which does not encode to Hex, but a special Base64 encoding (OpenSSL compatible). You will need to encode to UTF-8 in order to get to the same encoding that you had before during encryption.</p>

<p>Here is the working code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>document.getElementById(""enc_button"").onclick = function(){
  var password = ""testpassword"";
  var serverkey = ""randomkey"";
  var text = document.getElementById(""new_note"").value;
  var encrypted1 = CryptoJS.AES.encrypt(text, password);
  encrypted1 = encrypted1.toString();
  var encrypted = CryptoJS.AES.encrypt(encrypted1, serverkey);

  var decrypted1 = CryptoJS.AES.decrypt(encrypted,serverkey);
  decrypted1 = decrypted1.toString(CryptoJS.enc.Utf8);
  var decrypted = CryptoJS.AES.decrypt(decrypted1,password);
  decrypted = decrypted.toString(CryptoJS.enc.Utf8);
  document.getElementById(""decrypted"").innerHTML = decrypted;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;div id=""decrypted""&gt;Please wait...&lt;/div&gt;
&lt;div&gt;
  Insert new note:
  &lt;input type=""text"" id=""new_note""&gt;
  &lt;input type=""button"" id=""enc_button"" value=""Encrypt &amp; Decrypt""&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","482","<javascript><encryption><encoding><cryptojs>","1","2","2","2017-07-30 22:04:21","32500623","0","","1816580","","2015-09-10 11:26:40","2015-09-10 11:13:11",""
"32500342","Encrypt/decrypt with two different keys","<h2>My code</h2>

<p>I'm encrypting a string with two different keys with CryptoJS:</p>

<pre><code>var password = ""testpassword"";
var serverkey = ""randomkey"";
var text = document.getElementById(""new_note"").value;
var encrypted1 = CryptoJS.AES.encrypt(text, password);
encrypted1 = encrypted1.toString();
var encrypted = CryptoJS.AES.encrypt(encrypted1,serverkey);
</code></pre>

<p>And trying to decrypt it with this code:</p>

<pre><code>var password = ""testpassword"";
var serverkey = ""randomkey"";
var encrypted_text = localStorage.getItem(""encrypted"");
var decrypted1 = CryptoJS.AES.decrypt(encrypted_text,serverkey);
decrypted1 = decrypted.toString();
var decrypted = CryptoJS.AES.decrypt(decrypted1,password);
decrypted = decrypted.toString(CryptoJS.enc.Utf8);
document.getElementById(""decrypted"").innerHTML = decrypted;
</code></pre>

<h2>What isn't working</h2>

<p>While the encryption seems to work fine, when I try to convert <code>decrypted1</code> to a string in order to decrypt it the second time, I get <code>Cannot read property 'toString' of undefined</code> on the chrome console. This should mean that the first decryption process returns an empty string.</p>

<h2>My question</h2>

<p>How can I fix this problem?</p>
","<p>It looks like decripted IS empty.
you have initialized decripted1
    var decrypted1 = CryptoJS.AES.decrypt(encrypted_text,serverkey);
and then tryed to ""toString()"" the uninitialized decrypted var
    decrypted1 = decrypted.toString();
Although I think you don't need this line... (?).</p>
","482","<javascript><encryption><encoding><cryptojs>","1","0","2","2017-07-30 22:04:21","32500623","0","","1816580","","2015-09-10 11:26:40","2015-09-10 11:13:11",""
"26259614","CryptoJS AES. How to repeat encryption","<p>I have a problem with AES encryption.
I have any encrypted text.</p>

<pre><code>var keyString = 'b46393431e8dfaa3feec333b6ba02d0b277b8552f092e49e3a2e9b9739ac23ea';
var message1 = ""message to encrypt"";
var encrypted = CryptoJS.AES.encrypt(message1, keyString, {mode: CryptoJS.mode.CFB});
console.log(encrypted); //U2FsdGVkX1862TrLeAHJssPnGWVfQ9AzPtF64560nerd1xOM+72ad+ZdyXMl5sLF
</code></pre>

<p>And now, I want to check, that at next time I'll encrypted the same text. I don't have variable message, but I have encrypted text.</p>

<pre><code>var message2 = ""message to encrypt"";
var iv = CryptoJS.enc.Hex.parse(encrypted.iv.toString());
var key = CryptoJS.enc.Hex.parse(keyString);
var encrypted1 = CryptoJS.AES.encrypt(message2, key, {iv: iv, mode: CryptoJS.mode.CFB});
console.log(encrypted1); //xbPp9LFwl12hkLKwlvjpMaVj5Rss7YUbR0fP61wFXw8=
</code></pre>

<p>But if variable message1 == message2, I want to get the same encrypted text.
If I'll set iv and key as in second time - I'll get the next time the same result. But as first time I want to generate IV in encription function random. Is it possible?</p>
","<p>First of all, CryptoJS treats keys and passwords differently. If you provide a string it will automatically derive a key and IV from the password and a salt. So you will need to provide an identical salt if your <code>keyString</code> is indeed a string, or an identical IV if it is a key. </p>

<p>You could prefix the IV (generated before calling <code>encrypt</code>) to the ciphertext if you want to retrieve it later on. If I'm not mistaken the salt is already put into the ciphertext for passwords (OpenSSL) compatible, so you can retrieve it from byte 8..15 after decoding.</p>

<p>Note that re-use of the IV or salt is normally not safe for any mode of operation (CFB in your example), although it depends on the mode of operation <em>how</em> unsafe a repeat of the IV is. It's fine for making a compare but I would not store multiple ciphertexts with identical IV or salt.</p>

<p>Usually there are better ways of creating the same functionality for peculiar schemes as you've described above.</p>
","476","<encryption><aes><cryptojs>","0","0","1","2014-10-08 16:16:52","","2","","","","","2014-10-08 14:35:42",""
"34901654","PBKDF2 (php) produces different output than CryptoJS.PBKDF2 (js)","<p>As you can see below, my php implementation produces different key than JS version (running on Extend Script if that makes any difference). PHP side uses default hash_pbkdf2, JS side uses CryptoJS library. Both use SHA256. </p>

<p>Am I missing something here?</p>

<hr>

<p><strong>PHP side</strong></p>

<pre><code>$salt = CryptoLib::randomString(128/8);
$password = ""test"";
$hasher = ""sha256"";
$iterations = 1000;
$outsize = 256;

$key = hash_pbkdf2($hasher, $password, $salt, $iterations, $outsize/8, true);
$key = bin2hex($key);
</code></pre>

<p><strong><em>salt output:</em></strong> 523554455475374b5942304448317468</p>

<p><strong><em>key output:</em></strong> cfb478a18d08030fe97beed34fd2da3abf89bb7975ffdaae9e39102a3b2ea1a2</p>

<hr>

<p><strong>JS side</strong></p>

<pre><code>var salt = ""523554455475374b5942304448317468"";
var password = ""test"";
var iterations = 1000;
var keySize = 256;

var key = CryptoJS.PBKDF2(password, salt, {keySize: 256/32, iterations: 1000, hasher:CryptoJS.algo.SHA256});
</code></pre>

<p><strong><em>key output:</em></strong> 1264aa07aeab3cf93d4ee86a074697165efffe4914ce98e6d6efd7f28c371b97</p>
","<p>It turned out to be a problem with ExtendScript. If you're using minified versions of CryptoJS, make sure you switch to full js versions because for some reason ExtendScript will generate different values:</p>

<p>Example:</p>

<p><strong>with minified Base64 CryptoJS module included:</strong></p>

<pre><code>salt.toString(CryptoJS.enc.Base64) 
= ADAASDASHFDSFKSD/ASDAHSDJAGLDFblablabla
</code></pre>

<p><strong>with full Base64 CryptoJS module included:</strong></p>

<pre><code>salt.toString(CryptoJS.enc.Base64)
= Zl0gFqZIc3CczOo/FBlNSn3NPAAsw=
</code></pre>
","474","<encryption><openssl><cryptojs><pbkdf2>","0","1","1","2016-01-22 17:06:50","34952245","4","0","","","","2016-01-20 13:40:39",""
"47441602","SHA256 Hash to float number","<p>I've been trying to convert a hash to a float number, so far I have only achieved to generate a number from it.</p>

<p>How would I convert a SHA256 Hash to a float number ranging from 0.0 to 1.0?</p>

<p>How I got a number,</p>

<pre><code>var hash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
var number = hash.substr(0, 8);
number = parseInt(number, 16);
number = Math.abs(number) % 11;
console.log('Number (0 - 10): ' + number);
</code></pre>
","<p>Something like this:</p>

<pre><code>var hash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
var number = 0.0;
for(let i=0;i&lt;hash.length;i++) {
    number += parseInt(hash.charAt(i), 16) / 16;
}
number /= hash.length;
console.log('number = ' + number);
</code></pre>

<p>In this example, I give the equal weight to each of the 32 numbers (which seems reasonable since a hash is really not a number). But, you can give different weights to different bytes. For instance, you can give a weight of 2^31 to the first byte, and 2^30 for the second byte, etc. and normalize the final number accordingly.</p>

<p>Edit: You can also do the comparison for multiple bytes at a time. E.g., 16 numbers with each coming from 2 bytes, or 8 numbers with each coming from 4 bytes, etc. As you increase the ""unit"" size, the resulting final number will have a ""higher fidelity"" to the original hash value.</p>
","473","<javascript><sha256><cryptojs>","-1","0","2","2017-11-26 01:37:08","","11","","8390842","","2017-11-22 18:38:22","2017-11-22 18:27:10",""
"47441602","SHA256 Hash to float number","<p>I've been trying to convert a hash to a float number, so far I have only achieved to generate a number from it.</p>

<p>How would I convert a SHA256 Hash to a float number ranging from 0.0 to 1.0?</p>

<p>How I got a number,</p>

<pre><code>var hash = 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855';
var number = hash.substr(0, 8);
number = parseInt(number, 16);
number = Math.abs(number) % 11;
console.log('Number (0 - 10): ' + number);
</code></pre>
","<p>The comment by Mrre contains the best answer. Simply take the first 52-bits of the hash (or any convenient 52 bits of the hash) and assign it to a javascript number. A 52-bit integer can be stored exactly as an IEEE 754 double. Then simply divide the number by 2<sup>52</sup>, which should only effect the exponent bits of the number. The result is a floating point number x, 0 &lt;= x &lt; 1, with as much entropy as is possible given the constraints.</p>
","473","<javascript><sha256><cryptojs>","-1","1","2","2017-11-26 01:37:08","","11","","8390842","","2017-11-22 18:38:22","2017-11-22 18:27:10",""
"45514311","Decode JWT payload and header in JavaScript","<p>The page below uses CrypoJS to create a JWT. Works fine. (I don't use the CDNs for CryptoJS because of security/firewall issues at client site.)</p>

<p>How do I decode? I can use, on the server side, JavaScript or VBScript with JS preferred. Given the token passed in with the HTTP Request, I assume I'd ecode the payload to find the claims, etc. and then simply compare the signature with a stored signature for this user.</p>

<p>When I try to do a CryptoJS.enc.UTF8.parse() of the ""encodedData"" variable, I get an empty string. </p>

<p>Thanks in advance!</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script type=""text/javascript""&gt;
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,s){var f={},g=f.lib={},q=function(){},m=g.Base={extend:function(a){q.prototype=this;var c=new q;a&amp;&amp;c.mixIn(a);c.hasOwnProperty(""init"")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&amp;&amp;(this[c]=a[c]);a.hasOwnProperty(""toString"")&amp;&amp;(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=g.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||k).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e&lt;a;e++)c[b+e&gt;&gt;&gt;2]|=(d[e&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(e%4)&amp;255)&lt;&lt;24-8*((b+e)%4);else if(65535&lt;d.length)for(e=0;e&lt;a;e+=4)c[b+e&gt;&gt;&gt;2]=d[e&gt;&gt;&gt;2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c&gt;&gt;&gt;2]&amp;=4294967295&lt;&lt;
32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d&lt;a;d+=4)c.push(4294967296*h.random()|0);return new r.init(c,a)}}),l=f.enc={},k=l.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b&lt;a;b++){var e=c[b&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(b%4)&amp;255;d.push((e&gt;&gt;&gt;4).toString(16));d.push((e&amp;15).toString(16))}return d.join("""")},parse:function(a){for(var c=a.length,d=[],b=0;b&lt;c;b+=2)d[b&gt;&gt;&gt;3]|=parseInt(a.substr(b,
2),16)&lt;&lt;24-4*(b%8);return new r.init(d,c/2)}},n=l.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b&lt;a;b++)d.push(String.fromCharCode(c[b&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(b%4)&amp;255));return d.join("""")},parse:function(a){for(var c=a.length,d=[],b=0;b&lt;c;b++)d[b&gt;&gt;&gt;2]|=(a.charCodeAt(b)&amp;255)&lt;&lt;24-8*(b%4);return new r.init(d,c)}},j=l.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(""Malformed UTF-8 data"");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},
u=g.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){""string""==typeof a&amp;&amp;(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var g=0;g&lt;a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);c.sigBytes-=b}return new r.init(g,b)},clone:function(){var a=m.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});g.Hasher=u.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){u.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&amp;&amp;this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new t.HMAC.init(a,
d)).finalize(c)}}});var t=f.algo={};return f}(Math);
(function(h){for(var s=CryptoJS,f=s.lib,g=f.WordArray,q=f.Hasher,f=s.algo,m=[],r=[],l=function(a){return 4294967296*(a-(a|0))|0},k=2,n=0;64&gt;n;){var j;a:{j=k;for(var u=h.sqrt(j),t=2;t&lt;=u;t++)if(!(j%t)){j=!1;break a}j=!0}j&amp;&amp;(8&gt;n&amp;&amp;(m[n]=l(h.pow(k,0.5))),r[n]=l(h.pow(k,1/3)),n++);k++}var a=[],f=f.SHA256=q.extend({_doReset:function(){this._hash=new g.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],j=b[3],h=b[4],m=b[5],n=b[6],q=b[7],p=0;64&gt;p;p++){if(16&gt;p)a[p]=
c[d+p]|0;else{var k=a[p-15],l=a[p-2];a[p]=((k&lt;&lt;25|k&gt;&gt;&gt;7)^(k&lt;&lt;14|k&gt;&gt;&gt;18)^k&gt;&gt;&gt;3)+a[p-7]+((l&lt;&lt;15|l&gt;&gt;&gt;17)^(l&lt;&lt;13|l&gt;&gt;&gt;19)^l&gt;&gt;&gt;10)+a[p-16]}k=q+((h&lt;&lt;26|h&gt;&gt;&gt;6)^(h&lt;&lt;21|h&gt;&gt;&gt;11)^(h&lt;&lt;7|h&gt;&gt;&gt;25))+(h&amp;m^~h&amp;n)+r[p]+a[p];l=((e&lt;&lt;30|e&gt;&gt;&gt;2)^(e&lt;&lt;19|e&gt;&gt;&gt;13)^(e&lt;&lt;10|e&gt;&gt;&gt;22))+(e&amp;f^e&amp;g^f&amp;g);q=n;n=m;m=h;h=j+k|0;j=g;g=f;f=e;e=k+l|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+j|0;b[4]=b[4]+h|0;b[5]=b[5]+m|0;b[6]=b[6]+n|0;b[7]=b[7]+q|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;
d[e&gt;&gt;&gt;5]|=128&lt;&lt;24-e%32;d[(e+64&gt;&gt;&gt;9&lt;&lt;4)+14]=h.floor(b/4294967296);d[(e+64&gt;&gt;&gt;9&lt;&lt;4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=q.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=q._createHelper(f);s.HmacSHA256=q._createHmacHelper(f)})(Math);
(function(){var h=CryptoJS,s=h.enc.Utf8;h.algo.HMAC=h.lib.Base.extend({init:function(f,g){f=this._hasher=new f.init;""string""==typeof g&amp;&amp;(g=s.parse(g));var h=f.blockSize,m=4*h;g.sigBytes&gt;m&amp;&amp;(g=f.finalize(g));g.clamp();for(var r=this._oKey=g.clone(),l=this._iKey=g.clone(),k=r.words,n=l.words,j=0;j&lt;h;j++)k[j]^=1549556828,n[j]^=909522486;r.sigBytes=l.sigBytes=m;this.reset()},reset:function(){var f=this._hasher;f.reset();f.update(this._iKey)},update:function(f){this._hasher.update(f);return this},finalize:function(f){var g=
this._hasher;f=g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f))}})})();


/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){var h=CryptoJS,j=h.lib.WordArray;h.enc.Base64={stringify:function(b){var e=b.words,f=b.sigBytes,c=this._map;b.clamp();b=[];for(var a=0;a&lt;f;a+=3)for(var d=(e[a&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(a%4)&amp;255)&lt;&lt;16|(e[a+1&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*((a+1)%4)&amp;255)&lt;&lt;8|e[a+2&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*((a+2)%4)&amp;255,g=0;4&gt;g&amp;&amp;a+0.75*g&lt;f;g++)b.push(c.charAt(d&gt;&gt;&gt;6*(3-g)&amp;63));if(e=c.charAt(64))for(;b.length%4;)b.push(e);return b.join("""")},parse:function(b){var e=b.length,f=this._map,c=f.charAt(64);c&amp;&amp;(c=b.indexOf(c),-1!=c&amp;&amp;(e=c));for(var c=[],a=0,d=0;d&lt;
e;d++)if(d%4){var g=f.indexOf(b.charAt(d-1))&lt;&lt;2*(d%4),h=f.indexOf(b.charAt(d))&gt;&gt;&gt;6-2*(d%4);c[a&gt;&gt;&gt;2]|=(g|h)&lt;&lt;24-8*(a%4);a++}return j.create(c,a)},_map:""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=""}})();



// Defining our token parts
var header = {
  ""alg"": ""HS256"",
  ""typ"": ""JWT""
};

var data = {
  ""id"": 1337,
  ""username"": ""john.doe""
};

var secret = ""My very confidential secret!!!"";

function base64url(source) {
  // Encode in classical base64
  encodedSource = CryptoJS.enc.Base64.stringify(source);

  // Remove padding equal characters
  encodedSource = encodedSource.replace(/=+$/, '');

  // Replace characters according to base64url specifications
  encodedSource = encodedSource.replace(/\+/g, '-');
  encodedSource = encodedSource.replace(/\//g, '_');

  return encodedSource;
}

  var stringifiedHeader = CryptoJS.enc.Utf8.parse(JSON.stringify(header));
  var encodedHeader = base64url(stringifiedHeader);


  var stringifiedData = CryptoJS.enc.Utf8.parse(JSON.stringify(data));
  var encodedData = base64url(stringifiedData);

  var signature = encodedHeader + ""."" + encodedData;
  signature = CryptoJS.HmacSHA256(signature, secret);
  signature = base64url(signature);

  window.onload = function what(){
  document.getElementById(""payload"").innerText = encodedData;
  document.getElementById(""signature"").innerText = signature;
  document.getElementById(""header"").innerText = encodedHeader;
}
&lt;/script&gt;

&lt;style&gt;
body {
  font-family: Arial;
  background: #222;
  font-size: 14px;
  color: #bbb;
}

#header {
  color: green;
}

#payload {
  color: orange;
}

#signature {
  color: red;
}
&lt;/style&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;
  &lt;strong&gt;JSON Web Token:&lt;/strong&gt;&lt;br/&gt;
  &lt;span id=""header""&gt;  &lt;/span&gt;.&lt;span id=""payload""&gt;   &lt;/span&gt;.&lt;span id=""signature""&gt;  &lt;/span&gt; &lt;br /&gt;
&lt;/p&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
","","468","<javascript><base64><jwt><cryptojs>","0","","0","2017-08-04 19:38:27","","4","","","","","2017-08-04 19:38:27",""
"47797205","digest('hex') function not found using CryptoJS","<p>I am using crypto-js.js and creating a <code>sha512</code> function there for creating a variable <code>hash1</code>. we are successfully creating the hash and then updating hash with password but after that not able to use digest function.</p>

<pre><code>var sha512 = function (password, salt) {

    var hash1 = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA512, salt); /** Hashing algorithm sha512 */

    hash1.update(password);

    var value = hash1.digest('hex');
    return {
        salt: salt,
        passwordHash: value
    };
};
</code></pre>

<p>Does anybody know how to fix this?</p>
","<p><code>digest</code> is an HMAC method in the Node.js <strong>crypto</strong> module.  The equivalent method in CryptoJS is <code>finalize</code>.  The result of <code>finalize</code> is a CryptoJS <code>WordArray</code> object.  To get a hex string, use the <code>WordArray</code> in a context where it will be treated as a string.  Specifically, replace your:</p>

<pre><code>    var value = hash1.digest('hex');
</code></pre>

<p>with:</p>

<pre><code>    var value = '' + hash1.finalize();
</code></pre>
","466","<javascript><salt><cryptojs>","0","0","1","2017-12-14 09:17:11","","0","","354577","","2017-12-13 16:29:47","2017-12-13 15:52:32",""
"49998326","javascript - Different SHA256 using the same file in Angularjs app and bash","<p>I need to get the digest of an uploaded file in my AngularJS app, but the result digest is different from the file digest I get with bash. </p>

<p>I started using <a href=""https://github.com/h2non/jshashes"" rel=""nofollow noreferrer"">jshashes</a>, but when I saw that the resultant hash (on the web app) was different from the one which I get locally using bash I decided to move to <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a>. But the result is the same,the hash from the uploaded file is still different.</p>

<p>Here's my code:</p>

<pre><code>var reader = new FileReader();    
reader.readAsBinaryString(controller.file);
controller.fileHash = CryptoJS.SHA256(reader.result).toString(CryptoJS.enc.Hex);
</code></pre>

<p>As you can see the code is quite simple, just reads the uploaded file from the variable using <code>FileReader</code> and convert the value into a BinaryString, hash the content and finally assign the result to another controller valriable to show it in the html.</p>

<p>In my shell (local environment) to get the file digest I run the following command:</p>

<pre><code>$ shasum -a 256 [path/to/file]
</code></pre>

<p>In order to upload files, i'm using <a href=""https://github.com/danialfarid/ng-file-upload"" rel=""nofollow noreferrer"">ng-file-upload</a></p>

<p>What I'm missing? If anyone can help me or guide me to see the solution I will be very greatful.</p>

<p>Thank you in advance.</p>

<p><strong>Update 1</strong>:
As @destroyer said in the comments below <code>readAsBinaryString</code> is deprecated and it's an asynchronous method, so here's my actual code:</p>

<pre><code>var reader = new FileReader();
reader.onload = function() {
    controller.fileHash = CryptoJS.SHA256(reader.result).toString(CryptoJS.enc.Hex);
};
reader.readAsArrayBuffer(controller.file);
</code></pre>

<p>I tried <a href=""https://stackoverflow.com/a/32556944/2132144"">this</a> solution in order to convert the <code>ArrayBuffer</code> object into a <code>BinaryString</code>. But the result is still wrong.</p>

<p><strong>Update 2</strong>: 
Here's an image of a console log og the object I want to hash
<a href=""https://i.stack.imgur.com/2Y0zD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2Y0zD.png"" alt=""File object console.log""></a></p>
","<p><a href=""https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString"" rel=""nofollow noreferrer""><code>readAsBinaryString</code></a> is deprecated, you should use <a href=""https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsArrayBuffer"" rel=""nofollow noreferrer""><code>readAsArrayBuffer</code></a>.</p>

<p>Either way, those functions start an asynchronous operation, the result of which you read inside the <code>FileReader</code> instance's <code>load</code> event.</p>

<pre><code>var reader = new FileReader();    
reader.onload = function(){
  controller.fileHash = CryptoJS.SHA256(reader.result).toString(CryptoJS.enc.Hex);
};
reader.readAsArrayBuffer(controller.file);
</code></pre>

<p>Reflecting on our conversation in comments: the problem was that <code>crypto-js</code> does not operate on binary files, but on strings.</p>

<p>You can get a SHA256 implementation that supports <code>ArrayBuffer</code>s directly in <a href=""https://github.com/emn178/js-sha256"" rel=""nofollow noreferrer""><code>js-sha256</code></a>.</p>
","458","<javascript><angularjs><sha256><cryptojs><ng-file-upload>","0","1","1","2018-04-24 16:54:05","50002592","5","","2132144","","2018-04-24 14:00:42","2018-04-24 09:41:16",""
"51784721","nodejs pbkdf2sync TypeError: Pass phrase must be a buffer","<p>I am working on mean stack application. I am using crypto for password encryption but it is throwing below error.</p>

<p><strong>TypeError: Pass phrase must be a buffer</strong></p>

<blockquote>
  <p>TypeError: Pass phrase must be a buffer
      at pbkdf2 (crypto.js:702:20)
      at Object.exports.pbkdf2Sync (crypto.js:687:10)
      at model.userSchema.methods.setPassword (C:\CMT_Platform\server\models\user.model.js:24:24)
      at Object.module.exports.register (C:\CMT_Platform\server\services\auth.service.js:16:13)
      at exports.register (C:\CMT_Platform\server\controllers\auth.controller.js:22:39)
      at Layer.handle [as handle_request] (C:\CMT_Platform\node_modules\express\lib\router\layer.js:95:5)
      at next (C:\CMT_Platform\node_modules\express\lib\router\route.js:137:13)
      at Route.dispatch (C:\CMT_Platform\node_modules\express\lib\router\route.js:112:3)
      at Layer.handle [as handle_request] (C:\CMT_Platform\node_modules\express\lib\router\layer.js:95:5)
      at C:\CMT_Platform\node_modules\express\lib\router\index.js:281:22
      at Function.process_params (C:\CMT_Platform\node_modules\express\lib\router\index.js:335:12)
      at next (C:\CMT_Platform\node_modules\express\lib\router\index.js:275:10)
      at Function.handle (C:\CMT_Platform\node_modules\express\lib\router\index.js:174:3)
      at router (C:\CMT_Platform\node_modules\express\lib\router\index.js:47:12)
      at Layer.handle [as handle_request] (C:\CMT_Platform\node_modules\express\lib\router\layer.js:95:5)
      at trim_prefix (C:\CMT_Platform\node_modules\express\lib\router\index.js:317:13) ::1
  - - [11/Aug/2018:08:33:55 +0000] ""POST /register HTTP/1.1"" 400 42 ""-"" ""Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,
  like Gecko) Chrome/68.0.3440.106 Safari/537.36""</p>
</blockquote>

<p><strong>Code:</strong></p>

<pre><code>var custschema= new mongoose.Schema({
    email: { type: String, unique: true, required: true },
    name: { type: String, required: true },
    role: { type: String },
    hash: String,
    salt: String
});

custschema.methods.setPassword = function(password) {
    this.salt = crypto.randomBytes(16).toString('hex');
    //this.hash = crypto.pbkdf2Sync(password, this.salt, 1000, 64, 'sha512').toString('hex');
    var buffer = new Buffer(this.salt, ""binary"");
    console.log(this.salt);
    console.log(buffer);
    this.hash = crypto.pbkdf2Sync(password, buffer, 1000, 64, 'sha512').toString('hex');
};

custschema.methods.validPassword = function(password) {
    //var hash = crypto.pbkdf2Sync(password, this.salt, 1000, 64, 'sha512').toString('hex');
    var hash = crypto.pbkdf2Sync(password, newBuffer(this.salt,'binary'), 1000, 64, 'sha512').toString('hex');
    return this.hash === hash;
};
</code></pre>

<p>Can somebody please guide me or enlighten me whether they have face this issue or not. Let me know if you want any more details.</p>

<p>Thanks</p>
","<p><code>crypto.pbkdf2Sync</code> returns Buffer and you are storing in the string OR you can convert buffer to string and store. </p>

<p>You can change the hast type to the Buffer and try Check mongoose data types <a href=""http://mongoosejs.com/docs/schematypes.html"" rel=""nofollow noreferrer"">here</a> </p>
","455","<angularjs><node.js><mean-stack><cryptojs>","0","0","1","2018-08-13 08:02:17","","2","","2169104","","2018-08-11 08:36:02","2018-08-10 10:41:40",""
"19933542","CryptoJS AES encryption is not symmetric?","<p>I can't seem to get CryptoJS.AES to properly decrypt what it encrypted. Please look at this javascript code:</p>

<pre><code>var plaintext = ""Message"";
var encrypted = CryptoJS.AES.encrypt(plaintext, ""Secret Passphrase"");
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");
console.log(plaintext);
console.log(encrypted.toString());
console.log(decrypted.toString());
</code></pre>

<p>The resulting output is </p>

<pre><code>Message
U2FsdGVkX18Y2Cs77gkggFx8fkEajT1uztVYRkSkt/E
4d657373616765
</code></pre>

<p>Why aren't I getting back the original <code>""Message""</code>?</p>
","<pre><code>decrypted.toString(CryptoJS.enc.Utf8)
</code></pre>
","454","<javascript><encryption><cryptojs>","0","3","1","2013-11-12 16:03:54","19933782","3","","","","","2013-11-12 15:44:30",""
"55196601","Cannot read property 'encrypt' of undefined","<p>When I use crypto-js to encrypt text, it throws an error <code>Cannot read property 'encrypt' of undefined</code>. What's wrong with my code?</p>

<pre><code>...
const Cookies = require('js-cookie');
const request = require('browser-request');
const CryptoJS = require('crypto');

class OssHelper extends Helper {
    addFetchEvent (urlFunction) {
        const createTime = new Date().getTime();
        const encryptUuid = CryptoJS.AES.encrypt(Cookies.get('CLIPUUID'), createTime);
    };
}
...
</code></pre>
","<p>The error tells you that ""AES"" is undefined.
Please check how you should use CryptoJS. It seems you did not instanciate an AES object. Shouldn't you require(crypto/aes) and assign it to an AES constant? </p>

<pre><code>const AES = require('crypto-js/aes');
...
const encryptUuid = AES.encrypt
</code></pre>

<p>See <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a></p>
","449","<javascript><cryptojs>","1","1","2","2019-03-16 22:30:26","","1","","","","","2019-03-16 12:10:12",""
"55196601","Cannot read property 'encrypt' of undefined","<p>When I use crypto-js to encrypt text, it throws an error <code>Cannot read property 'encrypt' of undefined</code>. What's wrong with my code?</p>

<pre><code>...
const Cookies = require('js-cookie');
const request = require('browser-request');
const CryptoJS = require('crypto');

class OssHelper extends Helper {
    addFetchEvent (urlFunction) {
        const createTime = new Date().getTime();
        const encryptUuid = CryptoJS.AES.encrypt(Cookies.get('CLIPUUID'), createTime);
    };
}
...
</code></pre>
","<p>you are installing crypto-js with command (if you are using npm of course) npm install crypto-js, not crypto, (crypto is other built in module of nodeJS), so you got to require crypto-js not crypto with code: <code>var CryptoJS = require('crypto-js')</code></p>
","449","<javascript><cryptojs>","1","0","2","2019-03-16 22:30:26","","1","","","","","2019-03-16 12:10:12",""
"35696713","openssl_decrypt and base64_decode randomly fail to decode/decrypt ciphertext from CryptoJS","<p>I work with CryptoJS and php 5.5.12 using <a href=""https://stackoverflow.com/a/27582253"">example code</a> from Brain Foo Long.</p>

<p>I crypt client side with the following code:</p>

<pre><code>var msg = 'String to crypt';
var key = 'password';
var crypt_text = CryptoJS.AES.encrypt(JSON.stringify(msg), key, {format: CryptoJSAesJson}).toString();
sendString = ""msg="" + crypt_text +""&amp;key="" + k ; 
//... call jQuery.ajax
</code></pre>

<p>I decrypt server side with the following code:</p>

<pre><code>function cryptoJsAesDecrypt($passphrase, $jsonString){
    $jsondata = json_decode($jsonString, true);
    try {
        $salt = hex2bin($jsondata[""s""]);
        $iv  = hex2bin($jsondata[""iv""]);
    } catch(Exception $e) { return null; }
    $ct = base64_decode($jsondata[""ct""]);
    $concatedPassphrase = $passphrase.$salt;
    $md5 = array();
    $md5[0] = md5($concatedPassphrase, true);
    $result = $md5[0];
    for ($i = 1; $i &lt; 3; $i++) {
        $md5[$i] = md5($md5[$i - 1].$concatedPassphrase, true);
        $result .= $md5[$i];
    }
    $key = substr($result, 0, 32);
    $data = openssl_decrypt($ct, 'aes-256-cbc', $key, true, $iv);
    return json_decode($data, true);
}
</code></pre>

<p>Randomly, the server code <code>openssl_decrypt</code> return false.
Often, I saw that <code>$ct = base64_decode($jsondata[""ct""]);</code> go in error for ""base64 outside alphabet"", but I tried to check in js before sending and it seems correct. The code is the following:</p>

<pre><code>var Base64={_keyStr:""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghij ............"" };
var sendString = ""msg="" + crypt_text +""&amp;key="" + k ; 
if( Base64.decode( Base64.encode(sendString) )=== sendString  ){
    // ok
} else {
    alert('base 64 error');
    return;
}
</code></pre>
","","448","<php><encryption><encoding><base64><cryptojs>","1","","0","2016-02-29 19:07:29","","7","","-1","","2017-05-23 11:59:44","2016-02-29 10:05:10",""
"35840228","PHP -- calculating correct HMAC signature as nodejs script","<p>So I am working on a PHP script that queries an API which uses HMAC authentication headers. However, I have been banging my head trying to encode the HMAC signature correctly. I have a preexisting nodejs script to work from as a template. </p>

<p>In the nodejs script, the HMAC signature is calculated using the following:</p>

<pre class=""lang-js prettyprint-override""><code>var crypto = require('crypto');
var hmac = [];
hmac.secret = 'ODc0YTM3YzUxODFlMWQ1YTdhMGQwY2NiZmE1N2Y1ODdjYzM5NTgyMDJhZjVkYTE4MmQxYzQ5ODk0M2QzNWQxYw==';
hmac.timestamp = 1457326475000;
hmac.path = '/account/';
hmac.message = hmac.path +'\n' + hmac.timestamp;
var sig = crypto.createHmac('sha512', new Buffer(hmac.secret, 'base64'));
hmac.signature = sig.update(hmac.message).digest('base64');

console.log(hmac);
</code></pre>

<p>This <em>correctly</em> calculates the HMAC signature as:
bWjIFFtFmWnj0+xHLW2uWVa6M6DpbIV81uyUWwRFCJUg+0Xyt40QWZWQjGvfPUB/JbjGZHUoso0Qv5JHMYEv3A==.</p>

<p>Meanwhile, in PHP, I am using:</p>

<pre class=""lang-php prettyprint-override""><code>&lt;?php
$hmac['secret'] = 'ODc0YTM3YzUxODFlMWQ1YTdhMGQwY2NiZmE1N2Y1ODdjYzM5NTgyMDJhZjVkYTE4MmQxYzQ5ODk0M2QzNWQxYw==';
$hmac['nonce'] = '1457326475000';
$hmac['path'] = '/account/';
$hmac['message'] = $hmac['path'].""\n"".$hmac['nonce'] ;
$hmac['signature'] = base64_encode(hash_hmac('sha512',$hmac['message'],
$hmac['secret'], true));

print_r($hmac);
</code></pre>

<p>The above code, will calculate the HMAC signature as:
vqP49m/bk9nA4S3nMqW2r+kc2+yBfwhY/jWGUfz6dlKJUMkC2ktiPnuCcymdSWl4XezZT5VKCATYfus86Hz/Gg==</p>

<p>Working from the principle that ""<em>one million monkeys hacking away at a million keyboards</em>""  might one day be able to encode a valid HMAC signature, I have even tested a loop that iterates through all the permutations of the above PHP code (with/without base64 encoding the message, secret; with/without binary encoding of the HMAC, etc.)... to no avail.</p>

<p>Any suggestions for this here, one exhausted simian?</p>
","<p>The problem is that you're not decoding your <code>$hmac['secret']</code> first before passing it to <code>hash_hmac()</code>.</p>

<p>Try:</p>

<pre><code>$hmac['secret'] = base64_decode($hmac['secret']);
$hmac['signature'] = base64_encode(
  hash_hmac('sha512', $hmac['message'], $hmac['secret'], true)
);
</code></pre>
","446","<php><node.js><authentication><hmac><cryptojs>","2","2","1","2016-03-07 09:43:16","35840430","0","","","","","2016-03-07 09:31:04",""
"42698423","PassportJS - Getting payload data before it is passed to passport.authenticate as request parameter","<p>There is a <a href=""https://www.npmjs.com/package/passport-ldapauth"" rel=""nofollow noreferrer""><code>passport.js</code></a> implementation which is being used for <code>LDAP-auth</code> which works. Now the next step is to encrypt the password on the client-side using <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer""><code>Crypto-js</code></a> as follows:</p>

<p><code>Client-side angular-js controller</code></p>

<pre><code>$scope.authenticate = function () {      
  var auth = new login();
  auth.username = $scope.username;
  auth.password = CryptoJS.AES.encrypt($scope.password); //// HERE  

  auth.$save(function (response){
    console.log(response);
  },function(err){
    console.log(err);
  });
}
</code></pre>

<p><code>Server-side service</code></p>

<pre><code>.....
.....
app.post('/login', passport.authenticate('ldapauth'), (req, res) =&gt; {

    console.log(""req.user: "",req.user);
    req.session.username = req.user[ldap.username];
    req.session.userModel = req.user;
    res.status(200).send({""success"": 'success'});
});
.....
</code></pre>

<p>On the server-side service before calling <code>passport.authenticate</code> with the request 'req' the aes encrypted password needs to be decrypted. How can that be implemented here? (The question is not about encryption but how to get data before it gets passed to passport.authenticate as request)</p>
","<p>@Abhijay Ghildyal I don't think they understood your question. It is indeed possible to intercept the request before it gets passed to passport.authenticate(). What you'd want to do is to add this passage of code to your express.js or whichever file you did your express server implementation in. Also I am decrypting the request.body here instead of req.user since at that point of time the user is not yet logged in, however if it's different in your case then that's fine you can decrypt req.user the same way. (<strong>The variable app here is the name of your server i.e var app = express();</strong>)</p>

<pre><code>app.use(function(req, res, next) {
    if(req.url === '/login'){
        //CryptoJS.AES.decrypt() is Assumed to be the decrypter function here.
        req.body = CryptoJS.AES.decrypt(req.body);
        console.log(req.body); //To view decrypted body
    }
    next();
});
</code></pre>

<p>That is it. This middleware function will be reached first before the passport.authenticate() function. Just make sure if you're applying this to req.body you add these lines of codes first, after importing the bodyParser (<strong>bodyParser = require('body-parser');</strong>) before the passage above.</p>

<pre><code>app.use(bodyParser.urlencoded({
    extended: true
}));
app.use(bodyParser.json());
</code></pre>
","446","<javascript><angularjs><node.js><passport.js><cryptojs>","1","2","1","2017-09-11 01:55:08","46147222","6","","5082406","","2017-03-09 18:21:29","2017-03-09 14:51:40",""
"50302987","Encrypt with Javascript (cryptojs), Decrypt with php openssl, can't recreate message key","<p>I'm having trouble getting a message encrypted with cryptojs decrypted with php.</p>

<p>On the javascript side, the code to create the encryption is:</p>

<pre><code>var keySize = 256;
var ivSize = 128;
var saltSize = 256;
var iterations = 100;

var message = ""This is my test"";
var password = ""thepassword"";


function encrypt(msg, pass) {

// Generate salt, key and iv
var salt = CryptoJS.lib.WordArray.random(saltSize / 8);

var key = CryptoJS.PBKDF2(pass, salt, {
    keySize: 256 / 32,
    iterations: iterations
});

console.log('Message key: ' + key);

var iv = CryptoJS.lib.WordArray.random(ivSize / 8);


// encrypt message
var encrypted = CryptoJS.AES.encrypt(msg, key, {
    iv: iv,
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC

});

// convert encrypted message to hex
var encryptedHex = base64ToHex(encrypted.toString());

// Prepare result to transmit
var base64result = hexToBase64(salt + iv + encryptedHex);

return base64result;

}
</code></pre>

<p>This creates a string like:</p>

<blockquote>
  <p>g281MRrrEdiysHSAolnMmy3Au3yYkb2TK1t7iF4dv8X2k9Fod1DkOt/LF8eLgX8OxRvkSOMqtrcGEMaCL7A8YVBcugcirNg44HcWGWt+hfA=</p>
</blockquote>

<p>When I bring that into php, I can correctly pull back the pieces sent (salt, iv, message), but can't decode the message.</p>

<pre><code>$text_key = 'thepassword';
$cipher = ""aes-256-cbc"";


$received_message = $_REQUEST['message'];

// Decode message and pull out pieces:
$decoded = base64_decode($received_message);

$hex_version = bin2hex($decoded);

// Pull out salt, iv and encrypted message
$salt = substr($hex_version, 0,64);
$iv = substr($hex_version, 64,32);
$encrypted_string = substr($hex_version, 96);

// Message key
$generated_key = bin2hex(openssl_pbkdf2($text_key, $salt, 32, 100, 'sha256'));

// Decode Message
$result = openssl_decrypt($text_encoded, $cipher, $generated_key, $options=0, hex2bin($iv));
</code></pre>

<p>If I replace $generated_key with the key displayed in the javascript console, however, the message decrypts successfully.</p>

<p>What am I doing incorrectly to generate the key in php? </p>
","<p>After creating a routine to run through all possible algorithms for openssl_pbkdf2 and the hash_pbkdf2 functions, discovered that the hash_pbkdf2 function is the one that will create the key:</p>

<pre><code>$generated_key = hex2bin(hash_pbkdf2('sha1', $text_key, hex2bin($salt), 100, 64, FALSE));
</code></pre>

<p>Once the right algorithm and size was in place, the decryption works as expected.</p>
","445","<php><cryptojs>","1","0","1","2018-05-15 03:12:50","50341790","0","","7505411","","2018-05-12 07:06:24","2018-05-12 04:59:51",""
"41229949","saving encrypted object as file - cryptojs","<p>I am using cryptojs to encrypt and decrypt a file. I also have a web service to upload the encrypted files to a server. I can upload and save the ecnrypted object as a file on the server, but when I decrypt it, the file does not open correctly. My concern is if I am saving the ecnrypted object correctly or not. </p>

<p>Tutorial that I followed initially: <a href=""http://tutorialzine.com/2013/11/javascript-file-encrypter/"" rel=""nofollow noreferrer"">http://tutorialzine.com/2013/11/javascript-file-encrypter/</a></p>

<p>encryt method:</p>

<pre><code>function encrypt() {
      var folderPath = ""C:\\User\\test\\javascript-file-encrypter\\"";
      selectedFiles = document.getElementById(""MainContent_file1"");
      var sfile = selectedFiles.files[0];
      var read = new FileReader();
      read.onload = function (e) {
        var encrypted = CryptoJS.AES.encrypt(read.result, '123456');
        var ct2 = encrypted.toString();
      $.ajax({
        async: 'true',
        url: ""http://localhost:51936/WebService1.asmx/FileUpload"",
        method: ""POST"",
        processData: 'false',
        headers: {
            'content-type': ""application/x-www-form-urlencoded"",
            'cache-control': ""no-cache""
        },
        data: { 'folderPath': folderPath, 'uploadData': ct2, 'fileName': sfile.name + '.encrypted' },

        success: function (response) {
            console.log(response);
            debugger;
        },
        error: function (xhr, textStatus, error) {
            debugger;
            console.log(xhr.statusText);
        }
    });
    }
    read.readAsDataURL(sfile);
    }
</code></pre>

<p>decrypt method:</p>

<pre><code>function decrypt() {

var sfiles = document.getElementById(""MainContent_file1"");
var sfile = sfiles.files[0];
var freader = new FileReader();
freader.onload = function (e) {

    var decrypted = CryptoJS.AES.decrypt(freader.result, '123456');
    var dct = decrypted.toString(CryptoJS.enc.Latin1);
    //var dct2 = decrypted.toString();
    //console.log(dct);
    //console.log(dct2);
    debugger;
    $.ajax({
        async: 'true',
        url: ""http://localhost:51936/WebService1.asmx/FileUpload"",
        method: ""POST"",
        processData: 'false',
        headers: {
            'content-type': ""application/x-www-form-urlencoded"",
            'cache-control': ""no-cache""
        },
        data: { 'folderPath': folderPath, 'uploadData': dct, 'fileName': sfile.name.replace('.encrypted', '') },

        success: function (response) {
            console.log(response);
            debugger;
        },
        error: function (xhr, textStatus, error) {
            debugger;
            console.log(xhr.statusText);
        }
    });

};

freader.readAsText(sfile);

}
</code></pre>

<p>webservice method:</p>

<pre><code>[WebMethod]
    public bool FileUpload(string folderPath, string uploadData, string fileName)
    {

        bool returnValue = false;
        try
        {
            File.WriteAllText(folderPath + fileName, uploadData);
            returnValue = true;

        }
        catch (Exception ex)
        {
            returnValue = false;
        }

        return returnValue;
    }
</code></pre>
","","444","<javascript><c#><encryption><cryptojs>","1","","0","2016-12-19 20:23:37","","8","1","6827682","","2016-12-19 20:23:37","2016-12-19 19:47:55",""
"50819992","CryptoJS encryption/decryption example with binary files on clients sites","<p>I want use CryptoJS for encrypt/decrypt only on client site.
But I can't find why is my code working incorrect. Encryption looks ok but I am not able to decrypt after I encrypt some binary file. Maybe it is because I am using wrong encryption parameters in my code for encrypt binary file. 
I am attaching my code which I am using to encrypt binary file (mp3, avi or other) but no luck with it. It is possible to tell me where I am making mistake?
I was also looking for some examples where I will be able to see possible usage of CryptoJS for binary file but I spend two days on internet and didn't find relevant answer. There are many examples for encryption on client site and decryption on server site but didn't find any example of client site encryption client site decryption (pure javascript implementation)...
Therefore I am asking here which is my final try to find solution to my problem. Any help will be grateful!!!
THX</p>

<p>I am using CryptoJS v3.1.2</p>

<pre><code>$(""#ffle"").change(function(){
    var file = this.files[0];
    var reader = new FileReader();

    var key =  CryptoJS.enc.Utf8.parse(""Halo"");
    var iv =  CryptoJS.enc.Utf8.parse(""123"");

    reader.onload = function (e) {

        var encdata = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(e.target.result), key,
        {
            keySize: 256,
            iv: iv,
            mode: CryptoJS.mode.CBC,    //padding: CryptoJS.pad.Pkcs7
        });

        var finData = encodeURIComponent(encdata);
        var form_data = new FormData();                 
        form_data.append('file_enc', finData);

        var xhr = new XMLHttpRequest();    

        xhr.open('POST', 'https://crypt.xxxxxxx.net/fileenc4/save.php', true); 
        xhr.send(form_data);
        xhr.onload = function () {

        };

    }

    reader.readAsText(this.files[0]);     
});
</code></pre>
","","440","<javascript><encryption><aes><cryptojs>","0","","0","2018-06-12 14:47:53","","5","1","2020002","","2018-06-12 14:47:53","2018-06-12 14:46:17",""
"50274899","C - tiny-aes-c and Javascript CryptoJS interoperability","<p>Using <a href=""https://github.com/kokke/tiny-AES-c"" rel=""nofollow noreferrer"">tiny-aes-c</a>. Consider the following C code:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[6] = { 's','e','c','r','e','t' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };

    uint8_t in[6]  = { 'm','e','s','a','g','e'};

    uint8_t out[6] = {0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34};
    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 6);    

    printf(""idx\t encrypted\t expected"");
    for(int i=0 ; i&lt;6 ; i++){
        printf(""\n[%i]\t %.2x\t\t %.2x"" , i , in[i], out[i]);
    }

    return 0;
}
</code></pre>

<p>The code encrypts a message and compares the results with the expected output. The code works fine and the output is as follows:</p>

<pre><code>idx      encrypted       expected
[0]      17              17
[1]      8d              8d
[2]      c3              c3
[3]      a1              a1
[4]      56              56
[5]      34              34
</code></pre>

<p>I have another service, a NodeJS server which uses <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a>.<br>
<strong>My question is</strong>: How can I transform the C results (<code>{0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34}</code>) so it will match something CryptoJS could handle?</p>

<hr>

<p><strong>Edit:</strong>
Elaborating a bit. for the purpose of this discussion, the C result is transmitted over the network, so it should be transformed to a String. As far as I know, CryptoJS uses base64 as an input for it's AES method, decrypts to bytes that later can be converted to plain text:</p>

<pre><code>var bytes  = CryptoJS.AES.decrypt(BASE_64_STRING, SECRET);
var plaintext = bytes.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>The encrypted result for the same message + secret with CryptoJS is: <code>U2FsdGVkX1/TAYUIFnXzC76zb+sd8ol+2DfKCkwITfY=</code> (<a href=""https://jsfiddle.net/gcdfs3oo/113/"" rel=""nofollow noreferrer"">JS Fiddle</a>) and changes on each run.</p>

<p><strong>Update 2:</strong><br>
Thanks to @MDTech.us_MAN answer I've made some changes to both the JS and C code, but I'm still missing a puzzle pice.</p>

<p>C:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[16] = { 's','e','c','r','e','t','s','e','c','r','e','t','1','2','3','4' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };
    uint8_t in[7]  = { 'm','e','s','s','a','g','e'};

    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 7);

    printf(""Encrypted: "");
    for(int i=0 ; i&lt;7 ; i++){
        printf(""%.2x"" , in[i]);
    }

    return 0;
}
</code></pre>

<p>The encrypted HEX string C output: <code>cba9d5bc84113c</code>, when converted to Base64 result is :<code>y6nVvIQRPA==</code></p>

<p>On the JS side, I'm explicitly using CTR mode with no padding, and initiating (hopefully) same iv like so:</p>

<pre><code>const CryptoJS = require(""crypto-js"");
let iv = CryptoJS.enc.Hex.parse('f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'); // 16 Bytes (same as the C code)
let message = CryptoJS.AES.decrypt(""y6nVvIQRPA=="", ""secretsecret1234"", { iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
console.log(message.toString());
</code></pre>

<p>The decrypted result: <code>a47172dfe151c7</code> and not the expected result ""message"".</p>

<p>What am I missing?</p>
","<p>You are doing two things</p>

<ol>
<li>Encrypt</li>
<li>Convert to base64</li>
</ol>

<p>Upon receiving, you must do the reverse operations of both of these, in the reverse order they were applied before transmitting</p>

<ol>
<li>Convert from base64</li>
<li>Decrypt</li>
</ol>

<p>You can also swap the order of the steps, but then the order must be swapped on both the transmitting and receiving sides.</p>

<p>Also make sure the secret is on the same format on both sides.</p>
","440","<javascript><c><node.js><aes><cryptojs>","8","2","3","2018-05-13 21:18:20","50315665","4","4","1115237","","2018-05-13 09:23:08","2018-05-10 14:09:24",""
"50274899","C - tiny-aes-c and Javascript CryptoJS interoperability","<p>Using <a href=""https://github.com/kokke/tiny-AES-c"" rel=""nofollow noreferrer"">tiny-aes-c</a>. Consider the following C code:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[6] = { 's','e','c','r','e','t' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };

    uint8_t in[6]  = { 'm','e','s','a','g','e'};

    uint8_t out[6] = {0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34};
    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 6);    

    printf(""idx\t encrypted\t expected"");
    for(int i=0 ; i&lt;6 ; i++){
        printf(""\n[%i]\t %.2x\t\t %.2x"" , i , in[i], out[i]);
    }

    return 0;
}
</code></pre>

<p>The code encrypts a message and compares the results with the expected output. The code works fine and the output is as follows:</p>

<pre><code>idx      encrypted       expected
[0]      17              17
[1]      8d              8d
[2]      c3              c3
[3]      a1              a1
[4]      56              56
[5]      34              34
</code></pre>

<p>I have another service, a NodeJS server which uses <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a>.<br>
<strong>My question is</strong>: How can I transform the C results (<code>{0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34}</code>) so it will match something CryptoJS could handle?</p>

<hr>

<p><strong>Edit:</strong>
Elaborating a bit. for the purpose of this discussion, the C result is transmitted over the network, so it should be transformed to a String. As far as I know, CryptoJS uses base64 as an input for it's AES method, decrypts to bytes that later can be converted to plain text:</p>

<pre><code>var bytes  = CryptoJS.AES.decrypt(BASE_64_STRING, SECRET);
var plaintext = bytes.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>The encrypted result for the same message + secret with CryptoJS is: <code>U2FsdGVkX1/TAYUIFnXzC76zb+sd8ol+2DfKCkwITfY=</code> (<a href=""https://jsfiddle.net/gcdfs3oo/113/"" rel=""nofollow noreferrer"">JS Fiddle</a>) and changes on each run.</p>

<p><strong>Update 2:</strong><br>
Thanks to @MDTech.us_MAN answer I've made some changes to both the JS and C code, but I'm still missing a puzzle pice.</p>

<p>C:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[16] = { 's','e','c','r','e','t','s','e','c','r','e','t','1','2','3','4' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };
    uint8_t in[7]  = { 'm','e','s','s','a','g','e'};

    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 7);

    printf(""Encrypted: "");
    for(int i=0 ; i&lt;7 ; i++){
        printf(""%.2x"" , in[i]);
    }

    return 0;
}
</code></pre>

<p>The encrypted HEX string C output: <code>cba9d5bc84113c</code>, when converted to Base64 result is :<code>y6nVvIQRPA==</code></p>

<p>On the JS side, I'm explicitly using CTR mode with no padding, and initiating (hopefully) same iv like so:</p>

<pre><code>const CryptoJS = require(""crypto-js"");
let iv = CryptoJS.enc.Hex.parse('f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'); // 16 Bytes (same as the C code)
let message = CryptoJS.AES.decrypt(""y6nVvIQRPA=="", ""secretsecret1234"", { iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
console.log(message.toString());
</code></pre>

<p>The decrypted result: <code>a47172dfe151c7</code> and not the expected result ""message"".</p>

<p>What am I missing?</p>
","<p>You should read the CryptoJS documentation more carefully. By default it uses CBC mode for the encryption so you should change your tiny-AES implementation to use that.</p>

<blockquote>
  <p>CryptoJS supports the following modes:</p>
  
  <ul>
  <li>CBC (the default)</li>
  </ul>
</blockquote>

<p>Also note that CryptoJS has padding enabled by default, while tiny-AES doesn't have it at all. Therefore, messages must be multiples of 16. (Or you can manually use your own padding implementation)</p>

<blockquote>
  <p>No padding is provided so for CBC and ECB all buffers should be mutiples of 16 bytes. For padding PKCS7 is recommendable.</p>
</blockquote>

<p>Then, notice that CryptoJS autoselects the AES variant by the key size:</p>

<blockquote>
  <p>CryptoJS supports AES-128, AES-192, and AES-256. It will pick the variant by the size of the key you pass in. If you use a passphrase, then it will generate a 256-bit key.</p>
</blockquote>

<p>So, you must consider all of these factors in your tiny-AES code.</p>
","440","<javascript><c><node.js><aes><cryptojs>","8","6","3","2018-05-13 21:18:20","50315665","4","4","1115237","","2018-05-13 09:23:08","2018-05-10 14:09:24",""
"50274899","C - tiny-aes-c and Javascript CryptoJS interoperability","<p>Using <a href=""https://github.com/kokke/tiny-AES-c"" rel=""nofollow noreferrer"">tiny-aes-c</a>. Consider the following C code:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[6] = { 's','e','c','r','e','t' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };

    uint8_t in[6]  = { 'm','e','s','a','g','e'};

    uint8_t out[6] = {0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34};
    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 6);    

    printf(""idx\t encrypted\t expected"");
    for(int i=0 ; i&lt;6 ; i++){
        printf(""\n[%i]\t %.2x\t\t %.2x"" , i , in[i], out[i]);
    }

    return 0;
}
</code></pre>

<p>The code encrypts a message and compares the results with the expected output. The code works fine and the output is as follows:</p>

<pre><code>idx      encrypted       expected
[0]      17              17
[1]      8d              8d
[2]      c3              c3
[3]      a1              a1
[4]      56              56
[5]      34              34
</code></pre>

<p>I have another service, a NodeJS server which uses <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a>.<br>
<strong>My question is</strong>: How can I transform the C results (<code>{0x17, 0x8d, 0xc3, 0xa1, 0x56, 0x34}</code>) so it will match something CryptoJS could handle?</p>

<hr>

<p><strong>Edit:</strong>
Elaborating a bit. for the purpose of this discussion, the C result is transmitted over the network, so it should be transformed to a String. As far as I know, CryptoJS uses base64 as an input for it's AES method, decrypts to bytes that later can be converted to plain text:</p>

<pre><code>var bytes  = CryptoJS.AES.decrypt(BASE_64_STRING, SECRET);
var plaintext = bytes.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>The encrypted result for the same message + secret with CryptoJS is: <code>U2FsdGVkX1/TAYUIFnXzC76zb+sd8ol+2DfKCkwITfY=</code> (<a href=""https://jsfiddle.net/gcdfs3oo/113/"" rel=""nofollow noreferrer"">JS Fiddle</a>) and changes on each run.</p>

<p><strong>Update 2:</strong><br>
Thanks to @MDTech.us_MAN answer I've made some changes to both the JS and C code, but I'm still missing a puzzle pice.</p>

<p>C:</p>

<pre><code>int main(int argc, char const *argv[])
{
    uint8_t key[16] = { 's','e','c','r','e','t','s','e','c','r','e','t','1','2','3','4' };
    uint8_t iv[16]  = { 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff };
    uint8_t in[7]  = { 'm','e','s','s','a','g','e'};

    struct AES_ctx ctx;

    AES_init_ctx_iv(&amp;ctx, key, iv);
    AES_CTR_xcrypt_buffer(&amp;ctx, in, 7);

    printf(""Encrypted: "");
    for(int i=0 ; i&lt;7 ; i++){
        printf(""%.2x"" , in[i]);
    }

    return 0;
}
</code></pre>

<p>The encrypted HEX string C output: <code>cba9d5bc84113c</code>, when converted to Base64 result is :<code>y6nVvIQRPA==</code></p>

<p>On the JS side, I'm explicitly using CTR mode with no padding, and initiating (hopefully) same iv like so:</p>

<pre><code>const CryptoJS = require(""crypto-js"");
let iv = CryptoJS.enc.Hex.parse('f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'); // 16 Bytes (same as the C code)
let message = CryptoJS.AES.decrypt(""y6nVvIQRPA=="", ""secretsecret1234"", { iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
console.log(message.toString());
</code></pre>

<p>The decrypted result: <code>a47172dfe151c7</code> and not the expected result ""message"".</p>

<p>What am I missing?</p>
","<p>Thanks to @MDTech.us_MAN <a href=""https://stackoverflow.com/questions/36909746/aes-ctr-encrypt-in-cryptojs-and-decrypt-in-go-lang"">and this stack overflow question</a>, I've found a solution, after fixing the mode and the padding, the difference was the way I was parsing the secret on the JS side. In the following example, the secret is parsed as a HEX string:</p>

<pre><code>const CryptoJS = require(""crypto-js"");
let iv = CryptoJS.enc.Hex.parse('f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff'); // 16 Bytes
let secret = CryptoJS.enc.Hex.parse('73656372657473656372657431323334'); // 16 Bytes == ""secretsecret1234""
let message = CryptoJS.AES.decrypt(""y6nVvIQRPA=="", secret, { iv: iv, mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding });
console.log(message.toString(CryptoJS.enc.Utf8)); // -&gt; message
</code></pre>
","440","<javascript><c><node.js><aes><cryptojs>","8","3","3","2018-05-13 21:18:20","50315665","4","4","1115237","","2018-05-13 09:23:08","2018-05-10 14:09:24",""
"51764603","OpenResty lua-resty-string: Unable to decrypt cipher encrypted by Crypto-JS (AES default)","<p><a href=""https://github.com/openresty/lua-resty-string"" rel=""nofollow noreferrer"">https://github.com/openresty/lua-resty-string</a></p>

<p>I am not able to decrypt back what was encrypted using Crypto-JS in browser Javascript / NodeJS:</p>

<pre><code>// Encrypt
var ciphertext = CryptoJS.AES.encrypt('testingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtesting', '&amp;&amp;nH8P3bxk+?C4gR');

// Decrypt
var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), '&amp;&amp;nH8P3bxk+?C4gR');
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>I can decrypt it in Java using:</p>

<pre><code>Cipher.getInstance(""AES/CBC/PKCS5Padding"")
</code></pre>

<p>But, I get</p>

<pre><code>nil
</code></pre>

<p>when I try to do it with resty.aes. Here is the code:</p>

<pre><code>local aes = require ""resty.aes""
local cipher = aes.cipher(256)
local aes_256_cbc_md5 = aes:new('&amp;&amp;nH8P3bxk+?C4gR', nil, cipher)

local cipherText = 'U2FsdGVkX1859eIyt4M7VHNBl9BGMdsemPYAADKmqs9sltwKINfzVMci0Vw1NLr73Iti67zQ0+JoqVcL59Gcp+4R5NY6wg2n3r0wqLcQRc7PkIGpgup1UJp4DzhXSIGHz08Eu/nEbt3jAh3S4GVUoVFbXLluf/BvedTGdsqcN2EPL9S/WQOc5QDyl9OQjpBl+QS56nWL0DO6iR/6CIoEuQ+zC/7KTpBw2jQf8sxuDNptZzwKLlDi2sWSaeCkvPj+m8zheAlnZzVc+L5JeLdcx7WkIRQImNs9P5bkhXmiK2nZnw4yco3QHbzRkRBJiB3HgdYDauHsuKmR21zv9VLjAcGTrZjiUbtrBfuTRawKOiAFm599Inbq+Ugu9n4RelQ2CTdxwDfe3ZE3kscP3dyAmg=='
ngx.say(aes_256_cbc_md5:decrypt(cipherText))
</code></pre>

<p>What do I need to change with the server side decryption?</p>
","<p>First, you need to decode base64-encoded encrypted data to bytes.</p>

<p>Second, your encrypted data is salted and stored as described <a href=""http://justsolve.archiveteam.org/wiki/OpenSSL_salted_format"" rel=""nofollow noreferrer"">here</a>:</p>

<blockquote>
  <p>Files have an 8-byte signature, followed by an 8(?)-byte salt. Following the salt is the encrypted data.</p>
  
  <p>Files begin with an 8-byte signature: the ASCII characters ""Salted__"". </p>
</blockquote>

<p>So, you should extract both salt and actual encrypted data from OpenSSL salted format-ted string (<code>Salted__{salt}{data}</code>):</p>

<pre><code>-- aes_demo.lua
local aes = require ""resty.aes""


local encrypted = ngx.decode_base64('U2FsdGVkX1859eIyt4M7VHNBl9BGMdsemPYAADKmqs9sltwKINfzVMci0Vw1NLr73Iti67zQ0+JoqVcL59Gcp+4R5NY6wg2n3r0wqLcQRc7PkIGpgup1UJp4DzhXSIGHz08Eu/nEbt3jAh3S4GVUoVFbXLluf/BvedTGdsqcN2EPL9S/WQOc5QDyl9OQjpBl+QS56nWL0DO6iR/6CIoEuQ+zC/7KTpBw2jQf8sxuDNptZzwKLlDi2sWSaeCkvPj+m8zheAlnZzVc+L5JeLdcx7WkIRQImNs9P5bkhXmiK2nZnw4yco3QHbzRkRBJiB3HgdYDauHsuKmR21zv9VLjAcGTrZjiUbtrBfuTRawKOiAFm599Inbq+Ugu9n4RelQ2CTdxwDfe3ZE3kscP3dyAmg==')

local salt = encrypted:sub(9, 16)   -- skip first 8 bytes, get salt value (8 bytes)
local data = encrypted:sub(17)      -- rest of data is actual encrypted data
local cipher = aes.cipher(256)
local aes_256_cbc_md5 = aes:new('&amp;&amp;nH8P3bxk+?C4gR', salt, cipher)

ngx.say(aes_256_cbc_md5:decrypt(data))
</code></pre>

<hr>

<pre><code>$ resty aes_demo.lua

testingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtestingtesting
</code></pre>
","439","<encryption><lua><aes><cryptojs><openresty>","2","1","1","2019-07-10 23:43:24","","0","","472495","","2019-07-10 23:43:24","2018-08-09 10:26:53",""
"38103587","Encrypt with angular CryptoJS and decrypt with PHP","<p>I'm encrypting the data in ECB 256 AES using a key in the javascript and decrypting at php using the username and key. It is encrypting but i'm failing to decrypt in the php. </p>

<p>I'm trying to do this in ionic app.</p>

<p>In app.js in config:</p>

<pre><code>.config(['$cryptoProvider', function($cryptoProvider){
$cryptoProvider.setCryptographyKey('ABCD1234567890EF');
</code></pre>

<p>}])</p>

<p>In controller:</p>

<pre><code>var encryptedUsername = $crypto.encrypt(username);
var key = 'ABCD1234567890EF';
</code></pre>

<p>In php:</p>

<pre><code>$username = $_POST['encryptedUsername'];
$key =$_POST['key'];

function fnDecrypt($sValue, $sSecretKey)
{
return rtrim(
    mcrypt_decrypt(
        MCRYPT_RIJNDAEL_256, 
        $sSecretKey, 
        base64_decode($sValue), 
        MCRYPT_MODE_ECB
    ), ""\0""
);
}

$plaintext = fnDecrypt($username, $key);
echo $plaintext;
</code></pre>

<p>please tell me where I'm making a mistake.</p>
","","439","<javascript><php><ionic-framework><mcrypt><cryptojs>","1","","0","2016-06-29 15:10:56","","12","","","","","2016-06-29 15:10:56","2016-06-29 15:17:20"
"36442932","different output for JAVA vs javascript AES 256 cbc","<p>Im trying to create an AES 256 cbc encryption using java and I need to emulate EXACTLY this javascript code (I know the iv is the same as the key (turnicated to 16 bytes), that's how it is from the site i'm trying to log into using java)</p>

<pre><code>var recievedStr = ""MDk4NTY1MDAyMjg2MTU1OA==""; //some 
var key =  CryptoJS.enc.Base64.parse(recievedStr);
var iv  =  CryptoJS.enc.Base64.parse(recievedStr);
var pw = ""PASSWORD"";

var encres = CryptoJS.AES.encrypt(pw, key, {iv:iv, keySize: 256, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7});
var finalStr = encres.toString();
</code></pre>

<p>finalStr will be : Su92ZXLm/MdOyruRnWDRqQ==</p>

<p>I need to make a java code that will output exactly the same output as finalStr from the javascript.
Im using bouncy castle for that.</p>

<pre><code>        String recievedStr = ""MDk4NTY1MDAyMjg2MTU1OA=="";
        String pw = ""PASSWORD"";
        AESEngine blockCipher = new AESEngine();
          CBCBlockCipher cbcCipher = new CBCBlockCipher(blockCipher);
    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher (cbcCipher);
    byte[] key = encodeBase64(recievedStr);
    byte [] iv = java.util.Arrays.copyOf(key,16);
    byte[] input = pw.getBytes();
    ParametersWithIV pwIV= new ParametersWithIV(new KeyParameter(key),iv);
    cipher.init(true, pwIV);
    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int outputLen = cipher.processBytes(input, 0, input.length, cipherText, 0);
    try
    {
        cipher.doFinal(cipherText, outputLen);
    }
    catch (CryptoException ce)
    {
        System.err.println(ce);
        }
        System.out.println(new String(Base64.encodeBase64(cipherText)));
</code></pre>

<p>this will output : qEGQ1PC/QKxfAxGBIbLKpQ==</p>

<p>while I can decrypt it to the original input, that is not what i want.
I need my java code to output exactly what the javascript did.
I have 0 ideas left on how to approach this.</p>

<p>Thanks.</p>

<p>EDIT: problem was solved, I had to decode the received string to base64 instead of encoding it. </p>
","<p>I think you are on the right track. But I think you are running with AES-128 instead of AES-256. If you have a look at <a href=""https://stackoverflow.com/questions/992019/java-256-bit-aes-password-based-encryption"">Java 256-bit AES Password-Based Encryption</a> I think maybe you can find something useful.</p>
","437","<javascript><java><aes><bouncycastle><cryptojs>","0","0","1","2016-04-06 14:42:26","","3","","1827217","","2016-04-06 14:42:26","2016-04-06 06:13:38",""
"35241479","Using Crypto-JS (commonjs) in titanium","<p>I am not familiar with commonjs conception, so my strategy might be basically wrong..</p>

<p>I want to use CryptoJS.HMAC() and CryptoJS.SHA256 in titanium </p>

<p>I have downloaded CryptoJS v3.1.2.zip from <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow"">here</a>.</p>

<p>then copy all files under Resources/CryptJS/ .</p>

<p>then I add this last line in core.js</p>

<pre><code>    return C;
}(Math));

module.export = CryptoJS;  //add this line
</code></pre>

<p>now in my app.js</p>

<pre><code>var CryptoJS = require('./CryptoJS/components/core');

CryptoJS.HMAC(CryptoJS.SHA256, dateStamp,  testKey, { asBytes: true});
</code></pre>

<p>however it shows 
</p>

<p><code>undefined is not a function</code>  error when I call CryptoJS.HMAC()</p>

<p>Can I have help?</p>
","<p>You find a commonJS version of Crypto Js on npm: <a href=""https://www.npmjs.com/package/browserify-cryptojs"" rel=""nofollow"">https://www.npmjs.com/package/browserify-cryptojs</a></p>

<p>Maybe you got more luck with that!</p>
","436","<javascript><titanium><commonjs><cryptojs>","1","0","2","2017-05-04 16:12:06","","0","","","","","2016-02-06 13:18:33",""
"35241479","Using Crypto-JS (commonjs) in titanium","<p>I am not familiar with commonjs conception, so my strategy might be basically wrong..</p>

<p>I want to use CryptoJS.HMAC() and CryptoJS.SHA256 in titanium </p>

<p>I have downloaded CryptoJS v3.1.2.zip from <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow"">here</a>.</p>

<p>then copy all files under Resources/CryptJS/ .</p>

<p>then I add this last line in core.js</p>

<pre><code>    return C;
}(Math));

module.export = CryptoJS;  //add this line
</code></pre>

<p>now in my app.js</p>

<pre><code>var CryptoJS = require('./CryptoJS/components/core');

CryptoJS.HMAC(CryptoJS.SHA256, dateStamp,  testKey, { asBytes: true});
</code></pre>

<p>however it shows 
</p>

<p><code>undefined is not a function</code>  error when I call CryptoJS.HMAC()</p>

<p>Can I have help?</p>
","<p>Try adding an <code>s</code> to <code>export</code>, so it becomes:</p>

<pre><code>module.exports = CryptoJS;  //add this line
</code></pre>
","436","<javascript><titanium><commonjs><cryptojs>","1","0","2","2017-05-04 16:12:06","","0","","","","","2016-02-06 13:18:33",""
"38890196","Different Outputs for AES Encryption using CryptoJS and AES Encryption in JavaScript","<p><a href=""https://github.com/jackyrx/AES.Interchange-Cross-Platform-"" rel=""nofollow"">Here is my solution to PHP, Ruby &amp; Swift.</a></p>

<p>I faced issues when using CryptoJS on my test.</p>

<p>my code is like this</p>

<pre><code>var data = ""Hello World"";
var key = ""57119C07F45756AF6E81E662BE2CCE62"";
var iv = ""GsCJsm/uyxG7rBTgBMrSiA=="";

var encryptedData = CryptoJS.AES.encrypt(data, 
    CryptoJS.enc.Hex.parse(key), {
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7,
        iv: CryptoJS.enc.Base64.parse(iv) 
    }
);

console.log(""encryptedData: "" + encryptedData);

// var crypttext = encryptedData.toString();
var crypttext = ""k4wX2Q9GHU4eU8Tf9pDu+w=="";

var decryptedData = CryptoJS.AES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(crypttext) 
}, CryptoJS.enc.Hex.parse(key), {
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7,
    iv: CryptoJS.enc.Base64.parse(iv) 
});

console.log(""decryptedData: "" + decryptedData);
</code></pre>

<p>console.log result</p>

<p><code>encryptedData: 97SwKfGtNARERiSYyZxdAQ==</code></p>

<p><code>decryptedData:</code></p>
","<p>I've looked at your PHP code. You're using a 32 character key which is obviously Hex-encoded, but instead of decoding it to bytes, you're using the characters directly. Therefore the <code>aes-256-cbc</code> cipher is also wrong.</p>

<p>If you don't want to change your misleading PHP code, you can simply make the same mistake in CryptoJS: <code>CryptoJS.enc.Utf8.parse(key)</code> instead of <code>CryptoJS.enc.Hex.parse(key)</code>.</p>

<hr>

<p>Security considerations:</p>

<p>The IV must be unpredictable (read: random). Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. The IV is not secret, so you can send it along with the ciphertext. Usually, it is simply prepended to the ciphertext and sliced off before decryption.</p>

<p>It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p>
","432","<javascript><php><ruby><encryption><cryptojs>","0","1","1","2016-08-11 18:16:26","38903481","0","","","","","2016-08-11 07:40:42",""
"45687317","Video encryption by Crypto.js","<p>How to encrypt and decrypt video and audio streaming url by crypto.js? 
This line of code :</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""#string#"", ""#theKey#"");
</code></pre>

<p>require  data as string.</p>

<p>So what can I do? I just have a video URL.</p>
","<p>It's not as simple as put the url in a variable, you will have to listen to a stream, &amp; when you receive data you will have to download it and encrypt it after.</p>

<p>Just check at ffmpeg node_module if you have specific video stream url (m3u format) or just request if you have a file video url</p>
","432","<javascript><node.js><video-streaming><cryptojs>","-1","0","1","2017-08-15 07:53:50","","5","","5154741","","2017-08-15 06:33:41","2017-08-15 06:08:04",""
"45531486","AES CryptoJS encryption and phpseclib decryption","<p>I have a next problem<br>
On Node.js I have a next code</p>

<pre><code>var iv = CryptoJS.enc.Hex.parse('00000000000000000000000000000000'); //it's for tests, later it will be dynamically generated
var key256Bits = 'A5178B6A965AACF3CD60B07A15061719';

var cipher = CryptoJS.AES.encrypt(
    'Some text', 
    key256Bits, 
    {
        iv: iv,
        padding:CryptoJS.pad.ZeroPadding
    }
).toString();
</code></pre>

<p>Then when I try to decode it with phpseclib</p>

<pre><code>$key = 'A5178B6A965AACF3CD60B07A15061719';
$data = /*text encrypted by JS*/;
$cipher = new AES();
$cipher-&gt;setKeyLength(256);
$cipher-&gt;setKey($key);
$res = $cipher-&gt;decrypt($data);
</code></pre>

<p>And then $res becomes an empty string<br>
What do I do wrong?</p>
","<p>If you pass in a string to <code>CryptoJS.&lt;cipher&gt;.encrypt</code> as a key, CryptoJS treats it as a password and will derive the actual key from that using OpenSSL's <code>EVP_BytesToKey</code> with a random salt and one iteration of MD5. </p>

<p>phpseclib doesn't have an implementation of that, so you could just pass in the actual key:</p>

<pre><code>var key256Bits = CryptoJS.enc.Utf8.parse('A5178B6A965AACF3CD60B07A15061719');
</code></pre>

<p>Since this key is only 32 hexits long, it only has 128 bit of entropy, but still uses AES-256. You need 64 hexits which you can decode before use to get 32 bytes for a secure key size.</p>

<p>Also, phpseclib implements PKCS#7 padding, so you need to use </p>

<pre><code>padding: CryptoJS.pad.Pkcs7
</code></pre>

<p>in CryptoJS.</p>

<p>Example JavaScript code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var iv = CryptoJS.enc.Hex.parse('00000000000000000000000000000000'); //it's for tests, later it will be dynamically generated
var key256Bits = CryptoJS.enc.Utf8.parse('A5178B6A965AACF3CD60B07A15061719');

var cipher = CryptoJS.AES.encrypt(
    'Some text', 
    key256Bits, 
    {
        iv: iv,
        padding: CryptoJS.pad.Pkcs7
    }
).toString();
console.log(cipher)</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>In PHP, you need to make sure to decode the ciphertext before use:</p>

<pre><code>$data = base64_decode(""IWkBG3A46rNrxwWN2JD7xQ=="");

$key = 'A5178B6A965AACF3CD60B07A15061719';
$cipher = new AES();
$cipher-&gt;setKeyLength(256);
$cipher-&gt;setKey($key);
$res = $cipher-&gt;decrypt($data);
var_dump($res);
</code></pre>

<hr>

<h3>Security consideration:</h3>

<p>If you're using only symmetric encryption you need the exact same key at the server and the client. If you send the encryption key from the server to the client or the other way around you need to encrypt your symmetric encryption key. The easiest way to do this would be to use TLS. If you use TLS, then the data as well as key are encrypted, so you don't need to encrypt it yourself. This doesn't provide any security, just a little bit of obfuscation. You should read: <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/</a></p>
","431","<php><node.js><aes><phpseclib><cryptojs>","1","1","1","2017-08-06 22:18:40","45531614","0","","","","","2017-08-06 11:19:43",""
"28538406","Different Outputs for AES Encryption using CryptoJS and AES Encryption in Java","<p>I'm trying to encrypt data using AES encryption using cryptoJS. 
I want to transfer the encrypted data To / From the Device / Server. But i'm getting different AES encrypted outputs from device and server(Java).</p>

<p>Following is my code: </p>

<p>Mobile side(USing Titanium Appcelerator):</p>

<pre><code>var AES_File = require(""aes"");
var Pad_File = require(""pad-nopadding-min"");

function encrypt_data(message) {
    Titanium.API.info(""encrypt_data : ""+message);

    var key = AES_File.CryptoJS.enc.Latin1.parse('0123456789abcdef');
    var iv = AES_File.CryptoJS.enc.Latin1.parse('fedcba9876543210');

    //var key = AES_File.CryptoJS.enc.Hex.parse('0123456789abcdef');
    //var iv = AES_File.CryptoJS.enc.Hex.parse('fedcba9876543210');

    var message = ""soldier"";
    var padMsg = padString(message);

    var encrypted = AES_File.CryptoJS.AES.encrypt(padMsg, key, { iv: iv, pad:    AES_File.CryptoJS.pad.NoPadding, mode: AES_File.CryptoJS.mode.CBC});

    Titanium.API.log(""Encrypted: "" + encrypted);
    Titanium.API.log(""Encrypted text: "" + encrypted.ciphertext);

    return encrypted;
};

function padString(source) {
    var paddingChar = ' ';
    var size = 16;
    var x = source.length % size;
    var padLength = size - x;

    for (var i = 0; i &lt; padLength; i++) source += paddingChar;

    return source;
}

exports.encrypt_data = encrypt_data;
</code></pre>

<p>My Java code on Server :</p>

<pre><code>import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.*;

public class AesCipher {

    private static final String algorithm = ""AES/CBC/NoPadding"";

    private static final byte[] keyValue = new byte[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
    private static final byte[] ivValue = new byte[] { 'f', 'e', 'd', 'c', 'b', 'a', '9', '8', '7', '6', '5', '4', '3', '2', '1', '0' };

    private static final IvParameterSpec ivspec = new IvParameterSpec(ivValue);
    private static final SecretKeySpec keyspec = new SecretKeySpec(keyValue, ""AES"");

    final protected static char[] hexArray = ""0123456789abcdef"".toCharArray();

    public static String encrypt(String Data) throws Exception {
        Cipher c = Cipher.getInstance(algorithm);
        c.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        byte[] encVal = c.doFinal(Data.getBytes());
        String encryptedValue = new BASE64Encoder().encode(encVal);
        return encryptedValue;
    }

    public static String decrypt(String encryptedData) throws Exception {
        Cipher c = Cipher.getInstance(algorithm);
        c.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        return decryptedValue;
    }

    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for ( int j = 0; j &lt; bytes.length; j++ ) {
            v = bytes[j] &amp; 0xFF;
            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
        }
        return new String(hexChars);
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++)
        {
            source += paddingChar;
        }
        return source;
    }

    public static void main(String[] args) throws Exception {

        if (args.length &lt; 1) {
            System.err.println(""Usage: Encrypt [-d] &lt;cleartext&gt;"");
            System.exit(1);
        }
        if (args[0].equals(""-d"")) {
            if (args.length != 2) {
                System.err.println(""Usage: Encrypt [-d] &lt;encrypted_text&gt;"");
                System.exit(1);
            }
            String encryptedText = args[1];
            System.out.println(""encryptedText  is :""+encryptedText);
            String clearText = AesCipher.decrypt(encryptedText);
            System.out.println(clearText);

        } else {
            String clearText = args[0];
            String encryptedText = AesCipher.encrypt(padString(clearText));
            System.out.println(encryptedText);
        }
    }
 }
</code></pre>

<p>Please help me, where am i going wrong?</p>

<p>Titanium SDK - 3.5.0</p>

<p>Target Device - Android(above 4.0) and iOS (above 6.0)</p>

<p>Thanks in Advance.</p>
","","431","<java><javascript><aes><appcelerator><cryptojs>","0","","0","2015-02-16 09:40:16","","8","3","","","","2015-02-16 09:40:16",""
"40623105","Why node.js not remove the padding on the decryption of message which has been encrypted by python code","<p>I'm trying to encrypt some content in Python and decrypt it in a nodejs application and the opposite.</p>

<pre><code>import base64
import hashlib
from Crypto import Random
from Crypto.Cipher import AES

    def Encrypt(self, PlainText, SecurePassword):
        pw_encode = SecurePassword.encode('utf-8')
        text_encode= PlainText.encode('utf-8')

        key = hashlib.md5(pw_encode).digest()
        iv = Random.new().read(16)

        cipher = AES.new(key, AES.MODE_CBC, iv)
        pad_text = pkcs7.encode(text_encode)
        msg = iv + cipher.encrypt(pad_text)

        EncodeMsg = base64.b64encode(msg)
        return EncodeMsg

    def Decrypt(self, Encrypted, SecurePassword):
        decodbase64 = base64.b64decode(Encrypted.decode(""utf-8""))
        pw_encode = SecurePassword.decode('utf-8')

        iv = decodbase64[:AES.block_size]
        key = hashlib.md5(pw_encode).digest()

        cipher = AES.new(key, AES.MODE_CBC, iv)
        msg = cipher.decrypt(decodbase64[AES.block_size:])
        pad_text = pkcs7.decode(msg)

        decryptedString = pad_text.decode('utf-8')
        return decryptedString;
</code></pre>

<p>Here is the pcks7 Padding</p>

<pre><code>import StringIO
import binascii


def decode(bytestring, k=16):
    nl = len(bytestring)
    val = int(binascii.hexlify(bytestring[-1]), 16)
    if val &gt; k:
        raise ValueError('Input is not padded or padding is corrupt')

    l = nl - val
    return bytestring


def encode(bytestring, k=16):
    l = len(bytestring)
    output = StringIO.StringIO()
    val = k - (l % k)
    for _ in xrange(val):
        output.write('%02x' % val)
    return bytestring + binascii.unhexlify(output.getvalue())
</code></pre>

<p>Here is the Node.js code</p>

<pre><code>const crypto = require('crypto');

var AESalgoProv = 'aes-128-cbc';
const IV= Buffer.from([0x15, 0x14, 0x13, 0x12, 0x11,
                0x10, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00]);

    exports.AesEncryption = function(data, key) {
        var encodeKey = crypto.createHash('md5').update(new Buffer(key), 'utf-8').digest();
        var cipher = crypto.createCipheriv(AESalgoProv, encodeKey, IV);
        var encrypted = cipher.update(data, 'utf-8', 'base64');
        encrypted += cipher.final('base64');
        return encrypted;
    };
    exports.AesDecryption = function(encryptedata, key) {
        var encodeKey = crypto.createHash('md5').update(new Buffer(key), 'utf-8').digest();
        var decipher = crypto.createDecipheriv(AESalgoProv, encodeKey, IV);
        var decoded  = decipher.update(encryptedata,'base64', 'utf8');

        decoded += decipher.final('utf8');
        return decoded;
    };
</code></pre>

<p>Here is the Node.js Output when decrypt</p>

<p>!TExample</p>

<p>As you can see above i took the decrypted  Message ""Example"" which i encrypted. Also i got this weird symbols   it looks like padding which node.js failed to decode. Why this Happened and how can i fix it?i don't think i am doing something wrong i cant understand</p>

<p>Here is the Python Output when decode</p>

<pre><code>File""C:\Users\user\...\pkcs7.py"", line 7, in decode
    val = int(binascii.hexlify(text[-1]), 16)
IndexError: string index out of range
</code></pre>
","","429","<javascript><python><encryption><pycrypto><cryptojs>","2","","0","2016-11-20 15:35:22","","0","2","3163824","","2016-11-20 15:35:22","2016-11-16 02:29:50",""
"55308051","AES CBC: JavaScript/CryptoJS Encrypt -> Golang Decrypt","<p><strong>Note: This is only for personal use and learning, I am not trying to roll my own encryption for public use.</strong></p>

<p>I need to AES256 encrypt a string, however my current attempts end up with a string like <code>Salted__V|l8XCQlY</code> server side when it is hex decoded. It should rather be a valid utf8 base64 string when hex-decoded, which can then be decoded to the original string. This is similar to the solution offered <a href=""https://stackoverflow.com/questions/49363652/how-can-i-encrypt-a-string-with-aes-128-cbc-algorithm-in-javascript"">here</a>, however the salt was not the actual problem (despite the answer being accepted) and I have not been able to suppress the salt op by hex decoding the iv before use (as it suggested). Is there a way to do this?</p>

<p>I've tried several different methods and always end up in a similar spot. My latest attempt is such:</p>

<p><strong>encrypt.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};

const SECRET = '394812730425442A472D2F423F452848';
const iv = crypto.getRandomValues(new Uint8Array(16));    

function enc(plainText) {
  var b64 = CryptoJS.AES.encrypt(plainText, SECRET, { 
  	iv,
    mode: CryptoJS.mode.CBC,
    // padding: CryptoJS.pad.NoPadding
  }).toString();

  // Don't need?
  //var e64 = CryptoJS.enc.Base64.parse(b64);
  //var eHex = e64.toString(CryptoJS.enc.Hex);
  console.log(""b64::"", b64);

  return b64;
}

enc(""SUPA_SECRET"");</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Now we take the <code>b64</code> result and paste it into the <code>JS_GEN</code> variable in the server side golang decrypt:</p>

<p><strong>decrypt.go</strong></p>

<p>(<a href=""https://goplay.space/#4EclNtIOpjU"" rel=""nofollow noreferrer"">golang decrypt playground</a>)</p>

<pre><code>package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""encoding/base64""
    ""encoding/hex""
    ""fmt""
)

func main() {
    JS_GEN := ""U2FsdGVkX1+CA3LZTXePlgoGqL8VkdgiDgUenZhH4kc=""
    SECRET := ""394812730425442A472D2F423F452848""
    //msg := ""SUPER_SECRET""

    res, err := DecryptCBC(SECRET, JS_GEN)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(""res::"", res)
}

func DecryptCBC(secret string, target string) (string, error) {
    nilString := """"
    key, _ := hex.DecodeString(secret)
    //ciphertext, err := base64.URLEncoding.DecodeString(target)

    // Decode base64 string
    ciphertext, err := base64.StdEncoding.DecodeString(target)
    if err != nil {
        return nilString, err
    }

    // Create new cipher block
    block, err := aes.NewCipher(key)
    if err != nil {
        return nilString, err
    }

    // The IV needs to be unique, but not secure. Therefore it's common to
    // include it at the beginning of the ciphertext.
    if len(ciphertext) &lt; aes.BlockSize {
        panic(""ciphertext too short"")
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    // CBC mode always works in whole blocks.
    if len(ciphertext)%aes.BlockSize != 0 {
        panic(""ciphertext is not a multiple of the block size"")
    }
    mode := cipher.NewCBCDecrypter(block, iv)

    // CryptBlocks can work in-place if the two arguments are the same.
    mode.CryptBlocks(ciphertext, ciphertext)
    fmt.Println(""ciphertext::"", ciphertext)

    // Output: exampleplaintext
    return string(ciphertext), nil
}
</code></pre>

<p>The output will be something like:</p>

<pre><code>ciphertext:: [136 227 244 124 124 92 162 254 1 147 235 213 8 136 129 150]
res:: ||\
</code></pre>

<p>What am I doing wrong?</p>

<p><strong>EDIT:</strong> I've removed hex encode/decode from the process.</p>
","<p>You seem to be using CBC mode in JavaScript (default), but CFB in golang. Try with <code>NewCBCDecrypter</code> instead.</p>
","428","<javascript><go><encryption><aes><cryptojs>","0","0","2","2019-03-23 18:06:55","55316719","6","","5750392","","2019-03-23 15:51:56","2019-03-22 21:30:43",""
"55308051","AES CBC: JavaScript/CryptoJS Encrypt -> Golang Decrypt","<p><strong>Note: This is only for personal use and learning, I am not trying to roll my own encryption for public use.</strong></p>

<p>I need to AES256 encrypt a string, however my current attempts end up with a string like <code>Salted__V|l8XCQlY</code> server side when it is hex decoded. It should rather be a valid utf8 base64 string when hex-decoded, which can then be decoded to the original string. This is similar to the solution offered <a href=""https://stackoverflow.com/questions/49363652/how-can-i-encrypt-a-string-with-aes-128-cbc-algorithm-in-javascript"">here</a>, however the salt was not the actual problem (despite the answer being accepted) and I have not been able to suppress the salt op by hex decoding the iv before use (as it suggested). Is there a way to do this?</p>

<p>I've tried several different methods and always end up in a similar spot. My latest attempt is such:</p>

<p><strong>encrypt.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// CryptoJS.pad.NoPadding={pad:function(){},unpad:function(){}};

const SECRET = '394812730425442A472D2F423F452848';
const iv = crypto.getRandomValues(new Uint8Array(16));    

function enc(plainText) {
  var b64 = CryptoJS.AES.encrypt(plainText, SECRET, { 
  	iv,
    mode: CryptoJS.mode.CBC,
    // padding: CryptoJS.pad.NoPadding
  }).toString();

  // Don't need?
  //var e64 = CryptoJS.enc.Base64.parse(b64);
  //var eHex = e64.toString(CryptoJS.enc.Hex);
  console.log(""b64::"", b64);

  return b64;
}

enc(""SUPA_SECRET"");</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>Now we take the <code>b64</code> result and paste it into the <code>JS_GEN</code> variable in the server side golang decrypt:</p>

<p><strong>decrypt.go</strong></p>

<p>(<a href=""https://goplay.space/#4EclNtIOpjU"" rel=""nofollow noreferrer"">golang decrypt playground</a>)</p>

<pre><code>package main

import (
    ""crypto/aes""
    ""crypto/cipher""
    ""encoding/base64""
    ""encoding/hex""
    ""fmt""
)

func main() {
    JS_GEN := ""U2FsdGVkX1+CA3LZTXePlgoGqL8VkdgiDgUenZhH4kc=""
    SECRET := ""394812730425442A472D2F423F452848""
    //msg := ""SUPER_SECRET""

    res, err := DecryptCBC(SECRET, JS_GEN)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(""res::"", res)
}

func DecryptCBC(secret string, target string) (string, error) {
    nilString := """"
    key, _ := hex.DecodeString(secret)
    //ciphertext, err := base64.URLEncoding.DecodeString(target)

    // Decode base64 string
    ciphertext, err := base64.StdEncoding.DecodeString(target)
    if err != nil {
        return nilString, err
    }

    // Create new cipher block
    block, err := aes.NewCipher(key)
    if err != nil {
        return nilString, err
    }

    // The IV needs to be unique, but not secure. Therefore it's common to
    // include it at the beginning of the ciphertext.
    if len(ciphertext) &lt; aes.BlockSize {
        panic(""ciphertext too short"")
    }
    iv := ciphertext[:aes.BlockSize]
    ciphertext = ciphertext[aes.BlockSize:]

    // CBC mode always works in whole blocks.
    if len(ciphertext)%aes.BlockSize != 0 {
        panic(""ciphertext is not a multiple of the block size"")
    }
    mode := cipher.NewCBCDecrypter(block, iv)

    // CryptBlocks can work in-place if the two arguments are the same.
    mode.CryptBlocks(ciphertext, ciphertext)
    fmt.Println(""ciphertext::"", ciphertext)

    // Output: exampleplaintext
    return string(ciphertext), nil
}
</code></pre>

<p>The output will be something like:</p>

<pre><code>ciphertext:: [136 227 244 124 124 92 162 254 1 147 235 213 8 136 129 150]
res:: ||\
</code></pre>

<p>What am I doing wrong?</p>

<p><strong>EDIT:</strong> I've removed hex encode/decode from the process.</p>
","<p>I'm still not totally sure why previous attempts have failed. It could have been one of many the different ways the encryption was implemented and/or configured on both server and client.</p>

<p>I've finally found what I was looking for. A simple implementation that just works out of the box. Here we will just use <a href=""https://github.com/brix/crypto-js#api"" rel=""nofollow noreferrer"">crypto-js</a> and <a href=""https://github.com/Luzifer/go-openssl"" rel=""nofollow noreferrer"">go-openssl</a>.</p>

<p><strong>client.js</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const msg = ""SUPA_SECRET""
const key = ""394812730425442A472D2F423F452848"";
const encrypted = CryptoJS.AES.encrypt(msg, key);

console.log(encrypted.toString());</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><strong>server.go</strong></p>

<pre><code>package main

import (
    ""fmt""
    ""github.com/Luzifer/go-openssl""
)

func main() {
    encrypted := ""ENCRYPTED_STRING_HERE""
    secret := ""394812730425442A472D2F423F452848""

    o := openssl.New()

    dec, err := o.DecryptBytes(secret, []byte(encrypted), openssl.DigestMD5Sum)
    if err != nil {
        fmt.Printf(""An error occurred: %s\n"", err)
    }

    fmt.Printf(""Decrypted text: %s\n"", string(dec))
}



// OUTPUT:
// Decrypted text: SUPA_SECRET
</code></pre>
","428","<javascript><go><encryption><aes><cryptojs>","0","0","2","2019-03-23 18:06:55","55316719","6","","5750392","","2019-03-23 15:51:56","2019-03-22 21:30:43",""
"53536766","how to decrypt in angular 5 while data encypted using crypto.js in express.js","<p>I have encrypted some Text using following code in express.js:-</p>

<pre><code>var crypto = require('crypto'),
algorithm = 'aes-256-ctr',
password = '6A80FD8D38D579D1090F6CDB62CA34CA',
iv = '79b67e539e7fcadf';

var cipher = crypto.createCipheriv(algorithm,password,iv)
var crypted = cipher.update('hello world','utf8','hex')
crypted += iv.toString('hex') + cipher.final('hex');
console.log(crypted)
</code></pre>

<p>And now, I wanted to decrypt this encryptedText in angular 5. But I am not able to found any way to do this. I try following code:-</p>

<pre><code>import * as CryptoJS from 'crypto-js';
var key = CryptoJS.enc.Utf8.parse('6A80FD8D38D579D1090F6CDB62CA34CA');
var iv = CryptoJS.enc.Utf8.parse('79b67e539e7fcadf');

var decrypted = CryptoJS.AES.decrypt(encryptedTextHere, key, {
    iv: iv,
    mode: CryptoJS.mode.CTR,
});
</code></pre>

<p>Any help in getting the correct code is highly appreciated. Thanks</p>
","<p>try like this</p>

<pre><code>import { AES, enc, mode } from 'crypto-js';

const key = enc.Utf8.parse('6A80FD8D38D579D1090F6CDB62CA34CA');
const iv = enc.Utf8.parse('79b67e539e7fcadf');

const decrypted = AES.decrypt('encryptedTextHere', key, {
  iv: iv,
  mode: mode.CTR
});
console.log(decrypted.toString(enc.Utf8));
</code></pre>

<p>Also make sure to install the typings</p>

<pre><code>npm i @types/crypto-js --save-dev
</code></pre>
","426","<javascript><node.js><angular><express><cryptojs>","1","0","1","2018-11-29 11:13:03","","0","","4726405","","2018-11-29 10:29:43","2018-11-29 10:23:16",""
"47082971","Why CryptoJS produced different value every time the browser loads","<p>Following code is run on a web page via script tag. Every time I load the page or run the code in the browser console - I am getting different value...</p>

<pre><code>var key = 'key-123:456';
var uid = 1234567890;
var encrypted = CryptoJS.AES.encrypt(id, key);
encrypted.toString();
</code></pre>

<p>How can I have single ""encrypted value""for ""single id"" regardless of how many times I load the page or run the code in console? </p>
","<p>AES is a ""block"" cipher, which means it operates deterministically on fixed-length blocks from plaintext to ciphertext (and vice versa). However, it's typical (and generally preferred) to use a ""<a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">mode of operation</a>"" that adds non-determinism to the encryption process. For example, CBC mode (which CryptoJS uses by default) XORs a random initialization vector with the plaintext before encrypting it (and, correspondingly, after decrypting it):</p>

<p><img src=""https://upload.wikimedia.org/wikipedia/commons/8/80/CBC_encryption.svg"" alt=""diagram of CBC mode showing first plaintext block XORed with initialization vector (IV)""></p>

<p>This is vastly preferred because otherwise an eavesdropper can detect duplicate blocks, which might allow an attacker to eventually understand what is being communicated -- undoing the entire point of your encryption.</p>

<p>However, it sounds like you <em>want</em> your encryption to have this specific weakness, which suggests to me that maybe you don't really want encryption at all. Instead, you might want a <em>hash</em>, which is a deterministic one-way transformation. (<a href=""https://github.com/jakubzapletal/crypto-js#hashers"" rel=""nofollow noreferrer"">CryptoJS supports several hashes.</a>) With a hash, a given input <code>A</code> will always hash to the same hash value <code>H</code>, so you can compare <code>Hash(A) == Hash(B)</code> to see if <code>A == B</code>. (This isn't a perfect comparison, since hashes have an infinite input space and finite output space, but hashes are deliberately designed so that it's <a href=""https://en.wikipedia.org/wiki/Collision_resistance"" rel=""nofollow noreferrer"">very, very difficult to find two inputs that produce the same output</a>.) This is how websites securely store your password: the service stores <code>Hash(password)</code> instead of <code>password</code> itself, then when a user submits a password entry, the sites compares <code>Hash(entry)</code> and <code>Hash(password)</code> to see if the entry is correct.</p>

<pre><code>var hash = CryptoJS.SHA3(message);
</code></pre>

<p>However, if you really do need to reverse the transformed value back into plaintext and not just compare it to another hashed value, then you do need encryption. In that case, you can use the cryptographically inferior ECB mode, which has the weaknesses described above. In CryptoJS, you can do this by supplying an options object with a <code>mode</code> property:</p>

<pre><code>CryptoJS.AES.encrypt(msg, key, { mode: CryptoJS.mode.ECB });
</code></pre>
","426","<javascript><cryptojs>","0","1","1","2017-11-05 16:21:23","47096284","7","","","","","2017-11-02 19:12:18",""
"27901052","Security on hashing passwords with CryptoJS and then use php password_hash()","<p>So I got my own little project that I work on and I have a login for my friends to login and post news and update another thing. This site will never hold any personal information, it's just for my own education.</p>

<p>So my question is:
Do I need to create a self signed certificate and add that to my Web Host, or pay money for that or can I just use CryptoJS to create a hash and then when it's on server side use php's password_hash() before saving it in the database?</p>
","<p>You are talking about two different things. First is SSL and encryption of network second is password hashing in db. To be secure you should use both SSL and password hashing. If you do not want to pay for signed certificate you can create own cert not signed by CA and give it to your friends (in secure manner) they should include it in browser or they should check certificate fingerprint each time they connect to site. Any one who do not have this cert or its fingerprint will not know it there is MITM and browser will complain about it.</p>
","425","<javascript><php><security><hash><cryptojs>","1","1","1","2015-01-13 10:35:00","27920075","0","","","","","2015-01-12 11:35:05",""
"39854414","Encrypt/decrypt binary content on device using CryptoJS","<p>I am working on an Ionic app in which I need to encrypt/decrypt files on the device (ipad).</p>

<p>Use case is that when user marks some files (docx, pdf etc) as sensitive, they are encrypted on the device. Whenever user needs to view any of these files, they are decrypted back and shown to the user.</p>

<p>I am using CrytoJS to encrypt/decrypt the file and $cordovaFile to read/write the file to the device.</p>

<p>Below is the code which encrypts the file on the device. First unencrypted file is read from the device, then it is encrypted and saved back to the device.  </p>

<pre><code>return $cordovaFile.readAsBinaryString($rootScope.dataDirectory, 'abc.docx')
.then(function (binaryData) {
  console.log('Files read, now encrypt them '+binaryData);
  var encryptedWordArray = CryptoJS.AES.encrypt(binaryData, '12345');
  return $cordovaFile.writeFile($rootScope.dataDirectory, 'abc.docx', encryptedWordArray.toString(), true)
})
</code></pre>

<p>This creates the encrypted file in the device but at this point I have no way to tell if the file was correctly generated except for the fact that it is not an empty file. In my example, the original docx file was 13KB but after encryption it is 23KB. </p>

<p>Now, I am taking the same file and trying to decrypt it.</p>

<pre><code>var decrypted = null;
return $cordovaFile.readAsBinaryString($rootScope.dataDirectory, 'abc.docx')
  .then(function(encryptedBinaryData) {
    console.log('Read encrypted file as a binary string '+encryptedBinaryData);

    var decryptedWordArray = CryptoJS.AES.decrypt(encryptedBinaryData, '12345');
    decrypted = decryptedWordArray.toString();
    return $cordovaFile.writeFile($rootScope.dataDirectory, 'abc.docx', decrypted, true)
  })
  .then(function(data) {
    console.log('Decrypted file written');
  })
</code></pre>

<p>This generates a 34KB file on the device. However, when I try to open it, I get an error message stating that File is corrupt.</p>

<p>I think the problem could be somewhere related to dealing with multiple formats. When a file is read we get Binary content. Then CrytoJS gives a WordArray but before saving it to device it needs to be converted back to String. </p>

<p>Any help would be much appreciated. </p>
","","419","<javascript><angularjs><ionic-framework><cryptojs>","2","","0","2016-10-04 14:57:02","","1","2","688924","","2016-10-04 14:57:02","2016-10-04 14:04:27",""
"48812894","How to convert this signature method from crypto (node) to crypto-js (browser)?","<p>I have a signature method that is meant to be used in Node.js but I'd like to implement it client-side with crypto-js. It should work in latest Chrome versions.</p>

<p>I have tried to follow some answers like this one: <a href=""https://stackoverflow.com/questions/25492179/decode-a-base64-string-using-cryptojs"">Decode a Base64 String using CryptoJS</a></p>

<p>But I either get errors such as ""Error: Malformed UTF-8 data"", or a different result than the expected hmacDigest.</p>

<p>I am not sure how I could find an alternative to the ""binary"" digest although I found this question: 
<a href=""https://stackoverflow.com/questions/29432506/how-to-get-digest-representation-of-cryptojs-hmacsha256-in-js"">How to get digest representation of CryptoJS.HmacSHA256 in JS</a></p>

<p>The method is supposed to answer the following:</p>

<blockquote>
  <p>""Message signature using HMAC-SHA512 of (URI path + SHA256(nonce + POST data)) and base64 decoded secret API key""</p>
</blockquote>

<p><strong>This is the Nodejs version (with crypto):</strong></p>

<pre><code>const crypto = require('crypto')

function sign(path, params, secret) {
  const message = querystring.stringify(params)
  const secretBase64 = Buffer.from(secret, 'base64')
  const hash = crypto.createHash('sha256')
  const hmac = crypto.createHmac('sha512', secretBase64)

  const hashDigest = hash.update(params.nonce + message).digest('binary')
  const hmacDigest = hmac.update(path + hashDigest, 'binary').digest('base64')

  return hmacDigest
}
</code></pre>

<p>note: querystring is just an helper module that can also run in browsers: <a href=""https://nodejs.org/api/querystring.html"" rel=""nofollow noreferrer"">https://nodejs.org/api/querystring.html</a></p>

<p><strong>This is my attempt (wip) at implementing with crypto-js:</strong></p>

<pre><code>import cryptojs from 'crypto-js')

function sign (path, params, secret) {
  const message = querystring.stringify(params)
  const secretParsed = cryptojs.enc.Base64.parse(secret)
  const secretDecoded = cryptojs.enc.Utf8.stringify(secretParsed) // -&gt; this throws an error as ""Error: Malformed UTF-8 data""

  const hash = cryptojs.SHA256(params.nonce + message).toString(cryptojs.enc.hex)
  const hmac = cryptojs.HmacSHA512(path + hash, secretDecoded).toString(cryptojs.enc.hex)
  return hmac
}
</code></pre>
","<p>Try this ! I think this is what you looking for !</p>

<pre><code>const crypto = require(""crypto"")

const sign = (path, params, secret) =&gt; {
    const message = querystring.stringify(params)
    const secret = Buffer.from(secret, 'base64')
    let sign = params.nonce + message
    let hash = crypto.createHmac('sha256', secret)
                     .update(sign)
                     .digest(""base64"").toString()

    let encoded = encodeURIComponent(hash)
    return encoded
}
</code></pre>
","418","<javascript><node.js><cryptojs>","2","0","1","2018-02-16 08:35:17","","5","2","741657","","2018-02-16 08:35:17","2018-02-15 17:19:35",""
"18546676","Properly enabling security for filepicker.io in Meteor","<p>Filepicker by default allows pretty much everybody to add files to your S3 bucket who was clever enough to copy your API key out of the client code and luckily also offers a security option with expiring policies.</p>

<p>But I have no idea how to implement this in Meteor.js. Tried back and forth, installing meteor-crypto-base package, trying to generate the hashes on the server, tried RGBboy's urlsafe-base64 algorithm on <a href=""https://github.com/RGBboy/urlsafe-base64"" rel=""nofollow"">https://github.com/RGBboy/urlsafe-base64</a>. But I just do not get any further. Maybe someone can help! Thank you in advance.</p>
","<p>This is an example of how to do filepicker signed URLs in meteor, based on the documentation <a href=""https://developers.inkfilepicker.com/docs/security/"" rel=""nofollow"">here</a>:</p>

<pre><code>var crypto = Npm.require('crypto');
var FILEPICKER_KEY = 'Z3IYZSH2UJA7VN3QYFVSVCF7PI';
var BASE_URL = 'https://www.filepicker.io/api/file';

Meteor.methods({
  signedUrl: function(handle) {
    var expiry = Math.floor(new Date().getTime() / 1000 + 60 * 60);

    var policy = new Buffer(JSON.stringify({
      handle: handle,
      expiry: expiry
    })).toString('base64');

    var signature = crypto
      .createHmac('sha256', FILEPICKER_KEY)
      .update(policy)
      .digest('hex');

    return BASE_URL + ""/"" + handle +
      ""?signature="" + signature + ""&amp;policy="" + policy;
  }
});
</code></pre>

<p>Note this will need to exist somewhere inside of your <code>server</code> directory so you don't ship the key to the client. To demonstrate that it works, on the client side you can call it like so:</p>

<pre><code>Meteor.call('signedUrl', 'KW9EJhYtS6y48Whm2S6D', function(err, url){console.log(url)});
</code></pre>

<p>If everything worked, you should see a photo when you visit the returned URL.</p>
","416","<node.js><amazon-s3><meteor><filepicker.io><cryptojs>","1","2","1","2013-08-31 15:17:19","18549611","0","3","","","","2013-08-31 09:36:49",""
"21599675","cryptoJs equivalent for sign in nodejs","<p>I created the signed url using node.js</p>

<p>Using Node.js</p>

<pre><code>    var crypto = require('crypto');
    var sign = crypto.createSign('RSA-SHA1');
    var key = pem.toString('ascii');//PEM 
    var signature = sign.sign(key, 'base64');
</code></pre>

<p>But I need to create the signed url for the client side.  For that i have to use cryptoJs. I included the js also The syntax they gave like this</p>

<pre><code> var hash = CryptoJS.SHA1(""Message"");
</code></pre>

<p>I have to use the private key but i dont know where to use the private key here.</p>

<p>Can anyone help me in this</p>
","","414","<javascript><sha1><cryptojs>","0","","0","2014-02-06 10:07:40","","2","","","","","2014-02-06 10:07:40",""
"45277154","Javascript sha1 + HMCASHA1 Crypto JS encryption for .Net code","<p>Following is how the encyption has been done on backend useing .Net. </p>

<pre><code>public static string ShaEncrypt(string input,string keyStr) {

           byte[] key = Encoding.ASCII.GetBytes(keyStr);
           HMACSHA1 myhmacsha1 = new HMACSHA1(key);
           byte[] byteArray = Encoding.ASCII.GetBytes(input);
           MemoryStream stream = new MemoryStream(byteArray);
           return myhmacsha1.ComputeHash(stream).Aggregate("""", (s, e) =&gt; s + String.Format(""{0:x2}"", e), s =&gt; s);
}
</code></pre>

<p>For the same I need to do this in front end Javascript. 
I have tried by using google code for Crypto using sha1.</p>

<p><strong>var hash = CryptoJS.SHA1(keyString);
var test = CryptoJS.enc.Base64.Stringify(hash);</strong></p>

<p>But I am getting CryptoJS.enc as undefined. Please help me.</p>
","<p>I forgot to include the <strong>core-min.js, enc-base64-min.js</strong>.</p>

<p>Also below is the Javascript code to convert Hashed values.</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse(apiSecret);                                       
var prehash = CryptoJS.enc.Utf8.parse(apiKey);                                       
var hash = CryptoJS.HmacSHA1(prehash, key);   
return hash;
</code></pre>
","413","<javascript><.net><sha1><cryptojs><hmacsha1>","-1","0","1","2017-07-26 06:33:53","45319159","2","","6634591","","2017-07-24 09:52:15","2017-07-24 09:39:11",""
"40232017","CryptoSwift + CryptoJS making wrong JSON in Swift 2.3","<pre><code>do {
let JSONObject:[String:String] = 
[
""username"" : ""username"",
""password"" : ""Password"",
""domain"": ""domain""
]
let my64data:NSData = NSData(base64EncodedString:Credentials.SecretKey, options: NSDataBase64DecodingOptions(rawValue: UInt(0)))!

let jsonData = try NSJSONSerialization.dataWithJSONObject(JSONObject, options: NSJSONWritingOptions.PrettyPrinted)

let myString = String(data: jsonData, encoding: NSUTF8StringEncoding)

    // let jsonString = AES1.encrypt(myString!, secretKey: Credentials.SecretKey, options:[""iv"":my64data])
    // print("" My Encrypted Json = \(jsonString)"")
    //            
    // let Decrypt = AES1.decrypt(jsonString, secretKey: Credentials.SecretKey, options: [""iv"":my64data])
    //print("" My Decrypted Json = \(Decrypt)"")

let iv: Array&lt;UInt8&gt; = AES.randomIV(128/8)
let salt: Array&lt;UInt8&gt; = AES.randomIV(128/8)

let value = try! PKCS5.PBKDF2(password: Credentials.SecretKey.utf8.map({$0}), salt: salt, iterations: 1000, variant: .sha256).calculate()
                value.toHexString()

                _ = CryptoJS.mode.ECB()
                _ = CryptoJS.pad.Iso97971()
                _ = CryptoJS.pad.AnsiX923()
                _ = CryptoJS.pad.Iso10126()
                _ = CryptoJS.pad.ZeroPadding()

                let encrypted : Array&lt;UInt8&gt;

                     encrypted = try AES(key: value, iv: iv, blockMode: .CBC, padding: PKCS7()).encrypt((myString?.utf8.map({$0}))!)
                    let decrypted = try AES(key: value, iv: iv, blockMode: .CBC, padding: PKCS7()).decrypt(encrypted)

    //            let jsonString = AES1.encrypt(myString!, secretKey: String(value), options:[""iv"":iv.toHexString(),""mode"":CryptoJS.mode().ECB,""padding"":CryptoJS.pad().ZeroPadding])
                print("" My Encrypted Json = \(encrypted.toHexString())"")
    //            
    //            let pkcs = PKCS7()
    //            
    //            let Decrypt = AES1.decrypt(jsonString, secretKey: String(value), options: [""iv"":iv.toHexString(),""mode"":CryptoJS.mode().ECB,""padding"":pkcs])
               print("" My Decrypted Json = \(decrypted.toHexString())"")

                let myInputIV : String = String(iv.toHexString())
                let myInputSalt :String = String(salt.toHexString())

                let finalJSONObject:[String:String] = [

                    ""ciphertext"" : ""\(encrypted.toHexString())"",
                    ""iv"" : ""\(myInputIV)"",
                    ""salt"": ""\(myInputSalt)""

                ]

    print(""Final Json Object = \(finalJSONObject)"")

                let requestURL: NSURL = NSURL(string:""&lt;myURL&gt;"")!
                print(requestURL)
                let urlRequest: NSMutableURLRequest = NSMutableURLRequest(URL: requestURL)
                urlRequest.HTTPMethod = ""POST""
                urlRequest.addValue(""application/json"", forHTTPHeaderField: ""Content-Type"")
                urlRequest.HTTPBody = try!NSJSONSerialization.dataWithJSONObject(finalJSONObject, options:.PrettyPrinted)

                let session = NSURLSession.sharedSession()
                let task = session.dataTaskWithRequest(urlRequest, completionHandler:{
                    data, response, error -&gt; Void in

                    // Asynchronously call...
                    if (data != nil) {

                        print(""Dataaa = \(data!)"")

                        self.loginServiceResponse(data!)

                    }else{

                        Singleton.SharedInstance.myAlert(alertTitle:Constants.SERVER_ERROR_TITLE, alertMessage: Constants.SERVER_ERROR_MESSAGE, alertButtonTitle:Constants.OK)
                        self.activityIndicator.stopAnimating()

                    }


                })

                task.resume()

            } catch {
                print(error)

            }
</code></pre>

<p>I got this error:</p>

<blockquote>
  <p>Error with Json Error Domain=NSCocoaErrorDomain Code=3840 ""Invalid value around character 0."" UserInfo={NSDebugDescription=Invalid value around character 0.}</p>
</blockquote>
","<p>To use Common Crypto from Swift</p>

<ol>
<li>Add a bridging header</li>
<li>Add <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code> to the header.</li>
</ol>

<p>The example uses CBC mode and prefixes the encrypted data with the IV which is a method generally used for handling the IV.</p>

<h1>Example from deprecated documentation section:</h1>

<p>AES encryption in CBC mode with a random IV (Swift 3.0)</p>

<p>The iv is prefixed to the encrypted data</p>

<p><code>aesCBC128Encrypt</code> will create a random IV and prefixed to the encrypted code.<br>
<code>aesCBC128Decrypt</code> will use the prefixed IV during decryption.</p>

<p>Inputs are the data and key are Data objects. If an encoded form such as Base64 if required convert to and/or from in the calling method.</p>

<p>The key should be exactly 128-bits (16-bytes), 192-bits (24-bytes) or 256-bits (32-bytes) in length. If another key size is used an error will be thrown.</p>

<p><a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS#7 padding</a> is set by default.</p>

<p>This example requires Common Crypto<br>
It is necessary to have a bridging header to the project:<br>
    <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code><br>
    Add the <code>Security.framework</code> to the project.</p>

<p>This is example, not production code.</p>

<pre><code>enum AESError: Error {
    case KeyError((String, Int))
    case IVError((String, Int))
    case CryptorError((String, Int))
}

// The iv is prefixed to the encrypted data
func aesCBCEncrypt(data:Data, keyData:Data) throws -&gt; Data {
    let keyLength = keyData.count
    let validKeyLengths = [kCCKeySizeAES128, kCCKeySizeAES192, kCCKeySizeAES256]
    if (validKeyLengths.contains(keyLength) == false) {
        throw AESError.KeyError((""Invalid key length"", keyLength))
    }

    let ivSize = kCCBlockSizeAES128;
    let cryptLength = size_t(ivSize + data.count + kCCBlockSizeAES128)
    var cryptData = Data(count:cryptLength)

    let status = cryptData.withUnsafeMutableBytes {ivBytes in
        SecRandomCopyBytes(kSecRandomDefault, kCCBlockSizeAES128, ivBytes)
    }
    if (status != 0) {
        throw AESError.IVError((""IV generation failed"", Int(status)))
    }

    var numBytesEncrypted :size_t = 0
    let options   = CCOptions(kCCOptionPKCS7Padding)

    let cryptStatus = cryptData.withUnsafeMutableBytes {cryptBytes in
        data.withUnsafeBytes {dataBytes in
            keyData.withUnsafeBytes {keyBytes in
                CCCrypt(CCOperation(kCCEncrypt),
                        CCAlgorithm(kCCAlgorithmAES),
                        options,
                        keyBytes, keyLength,
                        cryptBytes,
                        dataBytes, data.count,
                        cryptBytes+kCCBlockSizeAES128, cryptLength,
                        &amp;numBytesEncrypted)
            }
        }
    }

    if UInt32(cryptStatus) == UInt32(kCCSuccess) {
        cryptData.count = numBytesEncrypted + ivSize
    }
    else {
        throw AESError.CryptorError((""Encryption failed"", Int(cryptStatus)))
    }

    return cryptData;
}

// The iv is prefixed to the encrypted data
func aesCBCDecrypt(data:Data, keyData:Data) throws -&gt; Data? {
    let keyLength = keyData.count
    let validKeyLengths = [kCCKeySizeAES128, kCCKeySizeAES192, kCCKeySizeAES256]
    if (validKeyLengths.contains(keyLength) == false) {
        throw AESError.KeyError((""Invalid key length"", keyLength))
    }

    let ivSize = kCCBlockSizeAES128;
    let clearLength = size_t(data.count - ivSize)
    var clearData = Data(count:clearLength)

    var numBytesDecrypted :size_t = 0
    let options   = CCOptions(kCCOptionPKCS7Padding)

    let cryptStatus = clearData.withUnsafeMutableBytes {cryptBytes in
        data.withUnsafeBytes {dataBytes in
            keyData.withUnsafeBytes {keyBytes in
                CCCrypt(CCOperation(kCCDecrypt),
                        CCAlgorithm(kCCAlgorithmAES128),
                        options,
                        keyBytes, keyLength,
                        dataBytes,
                        dataBytes+kCCBlockSizeAES128, clearLength,
                        cryptBytes, clearLength,
                        &amp;numBytesDecrypted)
            }
        }
    }

    if UInt32(cryptStatus) == UInt32(kCCSuccess) {
        clearData.count = numBytesDecrypted
    }
    else {
        throw AESError.CryptorError((""Decryption failed"", Int(cryptStatus)))
    }

    return clearData;
}
</code></pre>

<p>Example usage:</p>

<pre><code>let clearData = ""clearData0123456"".data(using:String.Encoding.utf8)!
let keyData   = ""keyData890123456"".data(using:String.Encoding.utf8)!
print(""clearData:   \(clearData as NSData)"")
print(""keyData:     \(keyData as NSData)"")

var cryptData :Data?
do {
    cryptData = try aesCBCEncrypt(data:clearData, keyData:keyData)
    print(""cryptData:   \(cryptData! as NSData)"")
}
catch (let status) {
    print(""Error aesCBCEncrypt: \(status)"")
}

let decryptData :Data?
do {
    let decryptData = try aesCBCDecrypt(data:cryptData!, keyData:keyData)
    print(""decryptData: \(decryptData! as NSData)"")
}
catch (let status) {
    print(""Error aesCBCDecrypt: \(status)"")
}
</code></pre>

<p>Example Output:</p>

<pre><code>clearData:   &lt;636c6561 72446174 61303132 33343536&gt;
keyData:     &lt;6b657944 61746138 39303132 33343536&gt;
cryptData:   &lt;92c57393 f454d959 5a4d158f 6e1cd3e7 77986ee9 b2970f49 2bafcf1a 8ee9d51a bde49c31 d7780256 71837a61 60fa4be0&gt;
decryptData: &lt;636c6561 72446174 61303132 33343536&gt;
</code></pre>

<p>Notes:<br>
One typical problem with CBC mode example code is that it leaves the creation and sharing of the random IV to the user. This example includes generation of the IV, prefixed the encrypted data and uses the prefixed IV during decryption. This frees the casual user from the details that are necessary for <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29"" rel=""nofollow noreferrer"">CBC mode</a>.</p>

<p>For security the encrypted data also should have authentication, this example code does not provide that in order to be small and allow better interoperability for other platforms.</p>

<p>Also missing is key derivation of the key from a password, it is suggested that <a href=""https://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow noreferrer"">PBKDF2</a> be used is text passwords are used as keying material.</p>

<p>For robust production ready multi-platform encryption code see <a href=""https://github.com/RNCryptor"" rel=""nofollow noreferrer"">RNCryptor</a>.</p>
","410","<ios><swift><encryption><swift2><cryptojs>","0","0","1","2017-10-13 14:01:54","","5","","2227743","","2016-10-28 13:18:28","2016-10-25 05:30:14",""
"45942297","how to solve circular structure in node.js","<p>i want to use <a href=""/questions/tagged/cryptojs"" class=""post-tag"" title=""show questions tagged &#39;cryptojs&#39;"" rel=""tag"">cryptojs</a> to <a href=""/questions/tagged/encrypt"" class=""post-tag"" title=""show questions tagged &#39;encrypt&#39;"" rel=""tag"">encrypt</a> <a href=""/questions/tagged/cookies"" class=""post-tag"" title=""show questions tagged &#39;cookies&#39;"" rel=""tag"">cookies</a>, i want to encrypt user id with his network card mac address.<br>
cryptoJS needs to JSON.stringify this data then encrypts.<br>
but i see this error in console:  </p>

<pre><code>TypeError: Converting circular structure to JSON
</code></pre>

<p>this is a snippet of my code:  </p>

<pre><code>var mac = 'e0:23:e3:46:57:52'
var userInfo = JSON.stringify({_id: user._id, mac: mac})
var cookie = crypto.AES.encrypt(userInfo, 'secret key')
res.cookie('userInfo', cookie, { expires: new Date(Date.now() + 900000000) })
</code></pre>
","<p><code>user._id</code> is <code>ObjectId</code>, just convert it to string:</p>

<pre><code>var userInfo = JSON.stringify({ _id: user._id.toString(), mac: mac });
</code></pre>

<p>Also try to use <code>util.inspect</code>, it automatically replaces circular links with <code>[Circular]</code>.</p>
","409","<javascript><json><encryption><cookies><cryptojs>","0","0","1","2017-08-29 15:02:03","","5","","","","","2017-08-29 14:54:04",""
"49524823","encrypt AES 256 with crypto js and decrypt in openssl_decrypt php","<p>I am tyring to decrypted in php a ecrypted text crytposjs with AES 256 and try all these links: </p>

<p><a href=""https://stackoverflow.com/questions/41222162/encrypt-in-php-openssl-and-decrypt-in-javascript-cryptojs/43438494#_=_"">https://stackoverflow.com/questions/41222162/encrypt-in-php-openssl-and-decrypt-in-javascript-cryptojs/43438494#<em>=</em></a></p>

<p>but none of them works and openssl_decrypt just simply returns false.</p>

<p>could you please help me to find any sample code?</p>

<p>Thanks much for ur help</p>
","","402","<cryptojs>","1","","0","2018-03-28 01:45:27","","0","","","","","2018-03-28 01:45:27",""
"45217676","Is it possible to decrypt openssl -aes-256-cbc encrypted data using javascript?","<p>I am trying to decrypt the openssl -aes-256-cbc encrypted mp4 file. But after decrypting using CryptoJS i am not getting valid data. Is it possible to decrypt openssl -aes-256-cbc encrypted data using javascript?</p>

<pre><code>var eKey = CryptoJS.enc.Hex.parse(key);
var eIv =  CryptoJS.enc.Hex.parse(iv);
var bytes  = CryptoJS.AES.decrypt(
    CryptoJS.lib.CipherParams.create({
        ciphertext: CryptoJS.enc.Hex.parse(encrypted)
    }),
    eKey,
    {
        iv: eIv, 
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7 
    }
);
</code></pre>

<p>OR</p>

<pre><code>var bytes  = CryptoJS.AES.decrypt(encrypted, eKey, {
    iv: eIv, 
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7 
});
</code></pre>
","","401","<javascript><encryption><openssl><aes><cryptojs>","0","","0","2017-07-20 18:20:08","","4","","1816580","","2017-07-20 18:20:08","2017-07-20 14:29:44",""
"51022191","Alternatives to repeating a cryptojs aes encryption in node.js","<p>I have an encrypted email id which I am storing in the database.</p>

<p>The next time the same email id comes in, I wanted to encrypt it and query the db whether the same exists.
As I have come to know, the randomness of the AES is one of the key aspects of it being secure therefore, this approach is not possible. I should not set the IV to repeat the pattern.</p>

<p>What is a more suitable approach to take here in this case? Other than getting all the ids and doing a client side decrypt and match?</p>

<p>Any pointers appreciated.</p>
","<p>As long as you use the same Key and the same IV (initialisation vector), you'll get the same result, e.g. </p>

<pre><code>const crypto = require('crypto');

function encrypt(plainText, keyBase64, ivBase64) {

    var key = Buffer.from(keyBase64, 'base64');
    var iv = Buffer.from(ivBase64, 'base64');

    /* Using 128 Bit AES with CBS. */
    var cipher = crypto.createCipheriv('aes-128-cbc', key, iv);
    cipher.update(plainText, 'utf8', 'base64')
    return cipher.final('base64');
};


var keyBase64 = ""sTEhO2zJ8f2Lck59VppiCQ=="";
var ivBase64 = 'Xpu5CSY5hz0PeDnNF0TM4A==';

var plainText = 'Sample email text';

console.log('Plaintext: ', plainText);

var cipherText = encrypt(plainText, keyBase64, ivBase64);
console.log('Ciphertext: ', cipherText);

var cipherText2 = encrypt(plainText, keyBase64, ivBase64);
console.log('Ciphertext 2: ', cipherText2);
</code></pre>

<p>You could also consider hashing the email and saving the hash, e.g.</p>

<pre><code>var sha256 = crypto.createHash('sha256').update(plainText).digest(""hex"");
console.log('SHA256: ', sha256);
</code></pre>

<p>The hash will be stable for a given email body. </p>
","400","<javascript><node.js><encryption><aes><cryptojs>","-1","0","1","2018-06-25 11:35:48","51022549","0","","5427866","","2018-06-25 11:32:25","2018-06-25 11:16:15",""
"50240432","Error unexpected token when using crypto-js with angular 5 project","<p>I need to encrypt data sent from angular-5 to php script and decrypt it in php then process it. I am new to these stuff.</p>

<p>Firstly, I installed the crypto-js lib:</p>

<p><code>npm install --save crypto-js</code></p>

<p>Then I imported it into <code>app.module.ts</code>:</p>

<pre><code>import * as crypto from 'crypto-js';
</code></pre>

<p>And added it to imports:</p>

<pre><code>@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    crypto
</code></pre>

<p>Inside my <code>app.component.ts</code> file I am trying to encrypt a variable and test the result:</p>

<pre><code>import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'app';
  this.crypto...
}
</code></pre>

<p>I've got an error on the <code>this.</code>:</p>

<blockquote>
  <p>Unexpected token. A constructor, method, accessor, or property was
  expected.</p>
</blockquote>
","<p>Rather importing * from crypto-js my team has simply put the crypto-js dependency in the scripts array in the .angular-cli.json.</p>

<p>Once you've done this at the top of the ts file you plan to use crypto you can add declare const CryptoJS; and then use it normally.</p>

<p>This method can also be used on any other non es6 or ts packaged dependency.</p>
","399","<angular><encryption><angular5><cryptojs>","0","1","1","2018-05-08 19:57:43","","5","","","","","2018-05-08 18:49:45",""
"22086959","which library are used for cryptojs","<pre><code>var result=CryptoJS.AES.decrypt(data,name).toString(CryptoJS.enc.Utf8);
</code></pre>

<p>I try to decrypt json data using  <code>cryptojs</code>. I want to use this code in c# . Which library/libraries is/are needed for this? It gives error <code>CryptoJs does not exist in current context</code>.</p>

<p>i use this one</p>

<p>public static void Main(string[] args)
        {</p>

<pre><code>        Class1 class1obj = new Class1();
        string baseUrl = ""http://www.whatsonindia.com"";
        WebRequest request = HttpWebRequest.Create(baseUrl);
        WebResponse response = request.GetResponse();
        string cookiesVals = response.Headers[HttpResponseHeader.SetCookie];

        string url = ""http://www.whatsonindia.com/appi/user?channelgenre=all&amp;context=applicationname%3Dsourcebits%3Bheadendid%3D0&amp;dateselected=0&amp;mode=getTVGuideInfo&amp;pageno=1&amp;responseformat=json&amp;responselanguage=English&amp;starthour=0&amp;totalhrdata=24&amp;userid=-1"";
        WebClient client = new WebClient();
        client.Headers.Add(HttpRequestHeader.Cookie, cookiesVals);
        var data = client.DownloadString(url);
        Console.WriteLine(data);
        Console.WriteLine(""dynamic object...."");
        Console.ReadLine();
         JavaScriptSerializer serializer = new JavaScriptSerializer();
         dynamic item = serializer.Deserialize&lt;object&gt;(data);
         string name = item[""pki""];
        //JavaScriptSerializer serializer1 = new JavaScriptSerializer();

        var result=CryptoJS.AES.decrypt(data,name).toString(CryptoJS.enc.Utf8);

        var obj = (JObject)JsonConvert.DeserializeObject(data);
       // var dict = obj.First.First.Children().Cast&lt;JProperty&gt;().ToDictionary();
        var dt = (string)obj[""data""];
        Console.WriteLine(dt);
                 Console.ReadLine();




    }
</code></pre>
","<p>CryptoJS is JavaScript library and can't be used in C# project. To do AES decrypt in C# you need to use .Net crypto library which is covered in this answer: <a href=""https://stackoverflow.com/questions/273452/using-aes-encryption-in-c-sharp"">Using AES encryption in C#</a>.</p>

<p>In above linked answer you will see line that decrypts the string:</p>

<pre><code>string decrypted = DecryptStringFromBytes(encrypted, myRijndael.Key, myRijndael.IV);
</code></pre>

<p>The 2nd parameter is where you can pass the key (I assume pki is byte array key that you used to encrypt the string). The 3rd parameter is the type of algorithm which you should make sure is in sync with CryptoJS when you encrypted the string.</p>
","395","<c#><cryptojs>","1","1","1","2014-02-28 08:11:19","","0","","3363463","","2014-02-28 06:34:53","2014-02-28 05:25:35",""
"52936159","How to generate mnemonics in React Native?","<p>I want to generate mnemonics in React Native.  I have cloned <a href=""https://github.com/markspereira/react-native-web3-boilerplate.git"" rel=""nofollow noreferrer"">this project</a>. I imported bip39 but I am getting this error in mobile/simulator. Works fine in debug mode in Chrome browser. </p>

<pre><code>library Error: Secure random number generation is not supported by this browser
</code></pre>

<p>I installed bip39 react native library. But when I use that module app is not opening and gets stuck in the splash screen. I tried to use other libraries like bit core bip39, but every lib has the same problem.</p>

<p>How can I create mnemonics in React Native using the above repository which I cloned React Native web3 boiler plate?</p>
","<p>Working with web3 in react-native i faced this issue a few. You are probably using the bip39 node.js package. The output you get means that is using a browser library that is not present in react-native(it is probably added as dependency in node). What you should use is bip39 for react native, <a href=""https://www.npmjs.com/package/react-native-bip39"" rel=""nofollow noreferrer"">here</a> is a link to it.</p>
","394","<reactjs><react-native><cryptojs><web3><mnemonics>","0","0","1","2018-11-01 13:51:14","","1","","472495","","2018-10-22 19:40:23","2018-10-22 19:04:35",""
"48196656","Using CryptoJS to encrypt and Aes Manager to decrypt","<p>I am using CryptoJS to encrypt a message and send it to the server, and decrypting it on the other end in C# using Aes Manager. I get a response back when I send it to the server, but it isn't correct.</p>

<p>Javascript:</p>

<pre><code>this.CryptoJS=require(""crypto-js"");
var temp=this.CryptoJS.AES.encrypt(""hello"",""yyyyyyyyyyyyyyyyyyyyyyyyyyyyykey"",{
  keySize:128/8,
  iv:this.CryptoJS.enc.Utf8.parse(""helllooohelllooo""),
  mode:this.CryptoJS.mode.CBC,
  padding:this.CryptoJS.pad.ZeroPadding
});
data.text=temp.toString(); // This is how I send it to the server
</code></pre>

<p>C#:</p>

<pre><code>byte[] Key = UTF8Encoding.UTF8.GetBytes(""yyyyyyyyyyyyyyyyyyyyyyyyyyyyykey"");
byte[] toBytes = UTF8Encoding.UTF8.GetBytes(""helllooohelllooo"");
AesManaged aes = new AesManaged();
aes.Key = Key;
aes.IV = toBytes;
aes.Padding = PaddingMode.Zeros;
aes.Mode = CipherMode.CBC;
aes.KeySize = 128;
aes.BlockSize = 128;
byte[] bytes = Convert.FromBase64String(data.text);
UTF8Encoding utf8 = new UTF8Encoding();

using (ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
{
    MemoryStream MS = new MemoryStream(bytes);
    CryptoStream CS = new CryptoStream(MS, decryptor, CryptoStreamMode.Write);
    CS.Write(bytes, 0, bytes.Length);
    CS.FlushFinalBlock();
    MS.Position = 0;
    bytes = new byte[MS.Length];
    MS.Read(bytes, 0, bytes.Length);
    Plaintext = utf8.GetString(bytes);
    var temp = 5;
}
</code></pre>

<p>This is what I get as a result from the <code>Plaintext</code> variable: <code>tk\a``\u007f\f^,F~\u0017\u001fp#5\u007f\\</code></p>
","<p>You should explicitly pass the key, plaintext and IV as binary data rather than strings:</p>

<pre><code>let iv = CryptoJS.enc.Utf8.parse(""helllooohelllooo"");
let pt = CryptoJS.enc.Utf8.parse(""hello"");
let key = CryptoJS.enc.Utf8.parse(""yyyyyyyyyyyyyyyyyyyyyyyyyyyyykey"");
</code></pre>

<p>Then use in the code like so:</p>

<pre><code>CryptoJS.AES.encrypt(pt, key, ...);
</code></pre>

<p>Note that your use of zero padding, fixed IV, and no HMAC or AEAD mode makes the code you have completely insecure.  You definitely should not use it.  Consult <a href=""https://github.com/luke-park/SecureCompatibleEncryptionExamples"" rel=""nofollow noreferrer"">this GitHub repository</a> for examples of secure encryption between JavaScript and C#.</p>
","394","<javascript><c#><encryption><aes><cryptojs>","-1","1","2","2018-01-11 17:09:57","","0","0","8718143","","2018-01-11 02:18:15","2018-01-10 21:49:00",""
"48196656","Using CryptoJS to encrypt and Aes Manager to decrypt","<p>I am using CryptoJS to encrypt a message and send it to the server, and decrypting it on the other end in C# using Aes Manager. I get a response back when I send it to the server, but it isn't correct.</p>

<p>Javascript:</p>

<pre><code>this.CryptoJS=require(""crypto-js"");
var temp=this.CryptoJS.AES.encrypt(""hello"",""yyyyyyyyyyyyyyyyyyyyyyyyyyyyykey"",{
  keySize:128/8,
  iv:this.CryptoJS.enc.Utf8.parse(""helllooohelllooo""),
  mode:this.CryptoJS.mode.CBC,
  padding:this.CryptoJS.pad.ZeroPadding
});
data.text=temp.toString(); // This is how I send it to the server
</code></pre>

<p>C#:</p>

<pre><code>byte[] Key = UTF8Encoding.UTF8.GetBytes(""yyyyyyyyyyyyyyyyyyyyyyyyyyyyykey"");
byte[] toBytes = UTF8Encoding.UTF8.GetBytes(""helllooohelllooo"");
AesManaged aes = new AesManaged();
aes.Key = Key;
aes.IV = toBytes;
aes.Padding = PaddingMode.Zeros;
aes.Mode = CipherMode.CBC;
aes.KeySize = 128;
aes.BlockSize = 128;
byte[] bytes = Convert.FromBase64String(data.text);
UTF8Encoding utf8 = new UTF8Encoding();

using (ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
{
    MemoryStream MS = new MemoryStream(bytes);
    CryptoStream CS = new CryptoStream(MS, decryptor, CryptoStreamMode.Write);
    CS.Write(bytes, 0, bytes.Length);
    CS.FlushFinalBlock();
    MS.Position = 0;
    bytes = new byte[MS.Length];
    MS.Read(bytes, 0, bytes.Length);
    Plaintext = utf8.GetString(bytes);
    var temp = 5;
}
</code></pre>

<p>This is what I get as a result from the <code>Plaintext</code> variable: <code>tk\a``\u007f\f^,F~\u0017\u001fp#5\u007f\\</code></p>
","<p>I was able to fix my problem i was not converting the original key to utf8 and once i did that it fixed itself </p>

<p><a href=""https://social.msdn.microsoft.com/Forums/vstudio/en-US/47800a60-4461-4f8e-a8d1-751fa62c7884/aes-encrypt-in-javascript-and-decrypt-in-c?forum=csharpgeneral"" rel=""nofollow noreferrer"">Resource</a></p>
","394","<javascript><c#><encryption><aes><cryptojs>","-1","0","2","2018-01-11 17:09:57","","0","0","8718143","","2018-01-11 02:18:15","2018-01-10 21:49:00",""
"41521245","How can convert this code from golang to reactjs in crypto hmac sha256 hex","<p>Golang code is as below</p>

<pre><code>func GenerateClientToken(secret, user, timestamp, info string) string {
    token := hmac.New(sha256.New, []byte(secret))
    token.Write([]byte(user))
    token.Write([]byte(timestamp))
    token.Write([]byte(info))
    return hex.EncodeToString(token.Sum(nil))
}
</code></pre>

<p>How can I convert from this to reactjs code.
I am trying like this</p>

<pre><code>import CryptoJS from 'crypto-js'

generateClientToken(secret, user, timestamp, info) {
        var hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, secret);

        hmac.update(user);
        hmac.update(timestamp);
        hmac.update(info);

        var hash = hmac.finalize();
        console.log(""hmac: "", hash.toString(CryptoJS.enc.Base64))
        console.log(""hmac: "", hash.toString(CryptoJS.enc.Hex))
    }
</code></pre>

<p>but result is not same with golang result. What am I wrong? and How will I do?</p>
","<p>Go code: <a href=""https://play.golang.org/p/7pXgn5GPQm"" rel=""nofollow noreferrer"">https://play.golang.org/p/7pXgn5GPQm</a></p>

<p>React:</p>

<ul>
<li>Package used: ""crypto-js"": ""^3.1.9-1""</li>
<li>React v15.4.2</li>
</ul>

<p>Inside a React Component, a function:</p>

<pre><code>    generateClientToken(secret, user, timestamp, info) {
      let hmac = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, secret);

      hmac.update(user);
      hmac.update(timestamp);
      hmac.update(info);

      let hash = hmac.finalize();

      console.log(""hmac: "", hash.toString(CryptoJS.enc.Hex))
  }
</code></pre>

<p>Inside render()</p>

<pre><code>const secret = ""test"";
const user = ""Dennis"";
const timestamp = ""1"";
const info = ""qwerty"";
this.generateClientToken(secret, user, timestamp, info);
</code></pre>
","392","<javascript><go><cryptojs>","0","0","1","2017-01-10 01:12:08","41559665","0","2","","","","2017-01-07 12:04:33",""
"43839593","Encrypt in Java and Dycrypt in JavaScript using Crypto JS not working","<p>I am newbee in both Java and JS and trying to Encrypt Password in java, which should be decrypted by my existing JS code.  (Do not want to change my JS !)</p>

<p>I think it has something to do with KEY and IV, which I am totally unaware about. </p>

<p>** JAVA PROGRAM ** </p>

<pre><code>public class Helper {

public Cipher dcipher, ecipher;

// Responsible for setting, initializing this object's encrypter and
// decrypter Chipher instances
public Helper(String passPhrase) {

    // 8-bytes Salt
    byte[] salt = {(byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03};

    // Iteration count
    int iterationCount = 19;

    try {
        // Generate a temporary key. In practice, you would save this key
        // Encrypting with DES Using a Pass Phrase
        KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), salt, iterationCount);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

        ecipher = Cipher.getInstance(key.getAlgorithm());

        // Prepare the parameters to the cipthers
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);            

    } catch (InvalidAlgorithmParameterException e) {
        System.out.println(""EXCEPTION: InvalidAlgorithmParameterException"");
    } catch (InvalidKeySpecException e) {
        System.out.println(""EXCEPTION: InvalidKeySpecException"");
    } catch (NoSuchPaddingException e) {
        System.out.println(""EXCEPTION: NoSuchPaddingException"");
    } catch (NoSuchAlgorithmException e) {
        System.out.println(""EXCEPTION: NoSuchAlgorithmException"");
    } catch (InvalidKeyException e) {
        System.out.println(""EXCEPTION: InvalidKeyException"");
    }
}

// Encrpt Password
@SuppressWarnings(""unused"")
public String encrypt(String str) {
    try {
        // Encode the string into bytes using utf-8
        byte[] utf8 = str.getBytes(""UTF8"");
        System.out.println(""\n UTF8 : "" + utf8);
        // Encrypt
        byte[] enc = ecipher.doFinal(utf8);
        System.out.println(""\n enc: "" + enc);
        // Encode bytes to base64 to get a string
        return new sun.misc.BASE64Encoder().encode(enc);

    } catch (BadPaddingException e) {
    } catch (IllegalBlockSizeException e) {
    } catch (UnsupportedEncodingException e) {
    }
    return null;
}


public static void main(String[] args) {
    try {

        Helper encrypter = new Helper("""");

        System.out.print(""Enter a password : "");
        String password = input.nextLine();

        String encrypted = encrypter.encrypt(password);
        System.out.println(""encrypted String:"" + encrypted);
    } catch (Exception e) {
    }

}
</code></pre>

<p>}</p>

<p>Above program should Encrypt key - which will be decrypted by following JS : </p>

<pre><code>var encryptedpassword=this.bodyParams.password;

        var bytes  = CryptoJS.AES.decrypt(encryptedpassword.toString(), accKey);
        var newpassword = bytes.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>WHERE accKey = ""<em>Nqnzu3RhCJ1h8ql5fdKOaKUAbsuURze</em>*********_</p>
","<p>Your problem is that you encrypt with DES and decrypt with AES.</p>

<p>Also you are generating a key from passphrase on your Java code, but using it directly on your JavaScript code.</p>

<p>You use salt on the Java side, but do not appear to incorporate the salt in the message. Having the salt+passphrase you can recover the key and iv.</p>

<p>You will need to look around for a another set of examples that use AES on both ends, that generate the key in the same way, and uses the same padding. </p>

<p>Something along the lines of this:</p>

<pre><code>// Generate a temporary key. In practice, you would save this key
// Encrypting with AES Using a Pass Phrase
 KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128);
 SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
 SecretKey aesKey = keyFactory.generateSecret(keySpec);
ecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

// Prepare the parameters to the cipthers
IvParameterSpec ivParameterSpec = new IvParameterSpec(aesKey.getEncoded());
ecipher.init(Cipher.ENCRYPT_MODE, aesKey, ivParameterSpec);
</code></pre>

<p>You also need to consider TLS for communication as someone just mentioned in the comments, as it is fairly difficult to secure symmetric encryption keys/passphrases on the JS side.            </p>
","387","<javascript><java><encryption><cryptojs>","0","1","1","2017-05-08 05:23:40","","8","3","3350007","","2017-05-08 04:13:08","2017-05-08 04:06:54",""
"49809074","Node.js: Getting Invalid RSAES-OAEP padding when trying to decrypt an encrypted symmetric key","<p>I have a usecase where I want to encrypt my data first with a symmetric key and then encrypt the symmetric key with the client's public key. I tried to mock the scenario, but getting 'Invalid RSAES-OAEP padding' error.</p>

<p>Code:</p>

<pre><code>var forge = require('node-forge');
var _crypto = require('crypto');
var rsa = forge.pki.rsa;

var masterKey = _crypto.randomBytes(32);
var keypair = rsa.generateKeyPair(2048);
var encryptedVal = keypair.publicKey.encrypt(masterKey, 'RSA-OAEP');
var decryptedVal = keypair.privateKey.decrypt(encryptedVal, 'RSA-OAEP');
console.log(masterKey,decryptedVal)
</code></pre>

<p>Do I have to convert the symmetric key format before encrypting it? And if yes, to what?</p>
","<p><code>masterKey</code> is a <a href=""https://nodejs.org/api/buffer.html"" rel=""nofollow noreferrer"">Buffer</a>. You need to convert it to bytes so forge can use it</p>

<p>Try this function (I didn't test it...)</p>

<pre><code>function toBytes(buf) {
    var byteString = '';
    for (var i = 0; i &lt; buf.length; ++i) {
        byteString += String.fromCodePoint(buf[i]);
    }
    return byteString;
}
</code></pre>

<p>Usage</p>

<pre><code>var masterKey = toBytes(_crypto.randomBytes(32));
</code></pre>
","385","<node.js><encryption><aes><rsa><cryptojs>","2","1","1","2018-04-13 06:00:28","","0","","","","","2018-04-13 03:55:16",""
"37186896","CryptoJS suddenly stopped working","<p>I've been using CryptoJS in a web view on <code>iOS</code> for a while now without issue, however today I am starting to get the error <code>Can't find variable: CryptoJS</code></p>

<p>The links to <code>http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha256.js</code> and <code>http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js</code> seem to have gone.</p>

<p>Does anyone know of an alternative location for this?</p>
","","385","<javascript><cryptojs>","0","","0","2016-05-12 12:28:06","","4","1","","","","2016-05-12 12:28:06",""
"53723989","CryptoJS AES encrypt, then decrypt in PHP with openssl_decrypt","<p>I'm doing some encrypt in a API, and I have some problem with AES encrypt using <code>CryptoJS</code> and <code>openssl_decrypt</code> in <code>PHP</code>.</p>

<p><strong>JS</strong></p>

<pre><code>        var key = ""B-LOGIN"",
            iv = ""c5b8cfc6992807e2c78a8cda6193bca1"",
            json = JSON.stringify({email : ""example@example.com"", password: ""123456"", ""domainUrl"" : ""http://www.example.com/""}),
            enc = CryptoJS.AES.encrypt(
                JSON.stringify({email : ""example@example.com"", password: ""123456"", ""domainUrl"" : ""http://www.example.com/""}), 
                CryptoJS.enc.Utf8.parse(key), 
                { iv: CryptoJS.enc.Utf8.parse(iv.substring(0, 16)) }
            );

console.log( enc.ciphertext.toString() ); // b53284ed65e1810b7250e2760d10f3be2b31e188f356dd36da5e906c59bea877b2cd322cfb1228035c4a06920e2504657beaa2440c94f5ff7dd6485be7b7bbd82d5e91f22d64c98322a47b0413d4b724b0e2cbf2314472b6f72b4e19a5e44052
</code></pre>

<p><strong>PHP</strong></p>

<p>For decrypt in php I have the following code, and It gaves me a false in <code>$rawText</code>. </p>

<pre><code>$iv = ""c5b8cfc6992807e2"";
$str = ""b53284ed65e1810b7250e2760d10f3be2b31e188f356dd36da5e906c59bea877b2cd322cfb1228035c4a06920e2504657beaa2440c94f5ff7dd6485be7b7bbd82d5e91f22d64c98322a47b0413d4b724b0e2cbf2314472b6f72b4e19a5e44052"";
$rawText = openssl_decrypt( $str,'aes-128-cbc' , 'B-LOGIN', 0, (strlen($iv) &gt; 16 ? substr($iv, 0 ,16) : $iv) ); // close
</code></pre>

<p>I think <code>CryptoJS</code> it gives the response in Hex format. </p>

<p>Thanks in advance.</p>
","","385","<php><encryption><cryptojs>","2","","0","2018-12-11 12:19:08","","2","","4836891","","2018-12-11 12:19:08","2018-12-11 12:13:21",""
"28309387","Need Encryption to store values in database","<p>See here: <a href=""https://code.google.com/p/crypto-js"" rel=""nofollow"">https://code.google.com/p/crypto-js</a></p>

<p>Which one of these encryption methods is best for storing encrypted values in a database? I need some method of encryption that lets the process convert the string back and forth in the same manner every time. </p>

<p>For example: ""sadfjpihdsf3njdasf"" would convert to ""hello world"" and ""hello world"" always converts to ""sadfjpihdsf3njdasf"". The encryption methods I have tried yet seem to give me a different encrypted string each time.</p>

<p>The purpose of this is mainly to reduce the visibility of passwords stored in a secure database, so the level of security involved is rather basic.</p>
","<p>All the symmetric ciphers in CryptoJS can be used in the way you described. The reason you see a different value every time is because a new random IV is generated every time. You can generate the IV yourself for every unique value you have as seen <a href=""https://code.google.com/p/crypto-js/#Custom_Key_and_IV"" rel=""nofollow"">here</a>.</p>

<p>Generally, passwords are not encrypted, but iteratively hashed with a salt. So, when the user authenticates the next time, the application can hash the typed in password and check if the values match. The salt and the number of iterations would be stored in additional columns or along side the hash.</p>

<p>CryptoJS provides a good hashing method for this case if you want to do this on the client side or anywhere where JavaScript is runnable, because CryptoJS basically has no dependencies: <a href=""https://code.google.com/p/crypto-js/#PBKDF2"" rel=""nofollow"">PBKDF2</a></p>
","380","<javascript><encryption><cryptojs>","0","2","2","2015-02-04 18:16:38","28309580","6","","1816580","","2015-02-03 21:53:19","2015-02-03 21:47:41",""
"28309387","Need Encryption to store values in database","<p>See here: <a href=""https://code.google.com/p/crypto-js"" rel=""nofollow"">https://code.google.com/p/crypto-js</a></p>

<p>Which one of these encryption methods is best for storing encrypted values in a database? I need some method of encryption that lets the process convert the string back and forth in the same manner every time. </p>

<p>For example: ""sadfjpihdsf3njdasf"" would convert to ""hello world"" and ""hello world"" always converts to ""sadfjpihdsf3njdasf"". The encryption methods I have tried yet seem to give me a different encrypted string each time.</p>

<p>The purpose of this is mainly to reduce the visibility of passwords stored in a secure database, so the level of security involved is rather basic.</p>
","<p>You would want to encrypt information when you are moving it through an insecure channel (WiFi, or data cables that could be sniffed) or if you want to store documents that only a selected group of people should access.</p>

<p>For those applications you should check the cyphers that library provides (and investigate each one to consider their pro/cons).</p>

<p>But for a login implementation there's no a valid reason to be able to decrypt the user password. Nobody should be able to retrieve a password. The standard procedure is to ""hash"" the password. </p>

<p>Like 'let me eat your password, digest it, and storage what's left'.
When the user want to authenticate with your application you do the same procedure with the password he/she provided and compare 'what's left' with what you have in your database.</p>

<p>Read this carefully <a href=""https://crackstation.net/hashing-security.htm"" rel=""nofollow"">https://crackstation.net/hashing-security.htm</a></p>
","380","<javascript><encryption><cryptojs>","0","1","2","2015-02-04 18:16:38","28309580","6","","1816580","","2015-02-03 21:53:19","2015-02-03 21:47:41",""
"51144763","cryptojs library not loading","<p>I want to use cryptoJS library in my angular application. I am using node and installing all the dependencies by a package.json file</p>

<p>i gave in my dependency in package.json as </p>

<pre><code>  ""dependencies"": {
""babel-plugin-transform-es2015-for-of"": ""^6.6.0"",
""babel-plugin-transform-es2015-modules-systemjs"": ""^6.24.1"",
""babel-preset-es2015"": ""^6.24.1"",
""crypto-js"": ""^3.1.9-1"",
""lodash"": ""^4.17.4"",
""mocha"": ""^3.2.0""},
</code></pre>

<p>and importing the cryptojs as </p>

<pre><code>import  CryptoJS from 'crypto-js';
</code></pre>

<p>i am getting the following error</p>

<p>Plugin Error
Fetch error: 404 Not Found Instantiating <a href=""http://localhost:3000/public/crypto-js"" rel=""nofollow noreferrer"">http://localhost:3000/public/crypto-js</a> Loading <a href=""http://localhost:3000/public/plugins/xxxx-simple-json-datasource/datasource.js"" rel=""nofollow noreferrer"">http://localhost:3000/public/plugins/xxxx-simple-json-datasource/datasource.js</a> Loading plugins/xxxx-simple-json-datasource/module</p>
","<p>CryptoJS is a package, use its function according to requirements.</p>

<p>Try </p>

<pre><code>import * as CryptoJS from 'crypto-js';
var encrypted = CryptoJS.AES.encrypt(myString, myPassword);
var decrypted = CryptoJS.AES.decrypt(encrypted, myPassword);
decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>
","380","<javascript><node.js><cryptojs>","0","0","1","2018-07-03 07:11:32","","0","","","","","2018-07-02 23:19:10",""
"35239337","Node JS Symmetric key encryption","<p>I am using AES 256 to save the data in DB after encryption. <br/>
Is there a way by which I can secure the encryption key from other junior developers?</p>
","","380","<node.js><encryption><cryptojs><symmetric-key>","0","","0","2016-02-06 09:33:22","","2","","1816580","","2016-02-06 09:33:22","2016-02-06 09:18:29",""
"31375291","AES encryption different outputs in java and javascript","<p>I have Java code which does AES and I am trying to implement same in jQuery using cryptoJs. But the output varies in jQuery. I am not able to figure it out where I am doing it wrong. I am new to encryption, please help me out.</p>

<p>Java Code</p>

<pre><code>public static String Encrypt(String text, String key) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    byte[] keyBytes = new byte[16];
    byte[] b = key.getBytes(""UTF-8"");
    int len = b.length;
    if (len &gt; keyBytes.length) len = keyBytes.length;
    System.arraycopy(b, 0, keyBytes, 0, len);
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
    String result = Base64.encodeToString(results, 0);
    return result;
}
</code></pre>

<p>JavaScript Code</p>

<pre><code>var plainText = ""abc""
var password = ""password"";
var key = CryptoJS.enc.Hex.parse(password);
var iv = CryptoJS.enc.Hex.parse(password);

var encrypted = CryptoJS.AES.encrypt(plainText, key, { iv: iv });
</code></pre>
","","376","<javascript><java><encryption><aes><cryptojs>","1","","0","2015-07-13 09:01:02","","4","3","3211778","","2015-07-13 09:01:02","2015-07-13 04:09:59",""
"43108292","Progressive encryption/decryption using the WebCrypto API?","<p>So, I started looking into the WebCrypto API as it seems very fast, the api seems fairly simple to use and I managed to implement encryption/decryption quite easily.</p>

<p>Now I'm trying to see if it's possible to do progressive encryption/decryption using it. I currently use CryptoJs and there are many situations where I deal with chunked download and upload of files, meaning that files are broken into smaller pieces and the processing of those pieces are done separately. </p>

<p>On CryptoJs it's possible to keep an instance of the ""<code>Encryptor</code>"" open so you can keep passing the chunks to it as you get them from the source and you can call a <code>finalize()</code> function when you're done.</p>

<p>I've been searching on Google and StackOverflow for hours for a way to achieve the same thing using WebCrypto but I can't find an answer.</p>

<p>Does anyone know how to do it or if it's even possible to be done using the current apis?</p>
","<p>Unfortunately WebCrypto API was not defined with streams support, there are a few reasons but I suspect the main two are that not all algorithms support this and it is the sort of thing that can be added later.</p>

<p>Here is the bug tracking streams support - <a href=""https://github.com/w3c/webcrypto/issues/73"" rel=""nofollow noreferrer"">https://github.com/w3c/webcrypto/issues/73</a></p>
","373","<javascript><encryption><frontend><cryptojs><webcrypto-api>","2","2","1","2017-03-30 05:31:42","43109004","0","","1816580","","2017-03-30 05:31:42","2017-03-30 03:57:22",""
"20016659","CryptoJS aes decrypt throws ""Unexpected token U""","<p>When I copied the content of <a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js</a> to local asp.net project
CryptoJS.AES decrypt throws exception ""Unexpected token U"".  </p>

<p>Does any one met this issue before?  Reference the original js (<a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js"" rel=""nofollow"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js</a>) works fine.</p>

<p>The code was simple:</p>

<pre><code>&lt;!DOCTYPE html&gt;

&lt;html xmlns=""http://www.w3.org/1999/xhtml""&gt;
&lt;head runat=""server""&gt;
    &lt;script type=""text/javascript"" src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;script type=""text/javascript""&gt;
function load() {
    var pb = document.getElementById('pwd');
    var ct = document.getElementById('ct');
    var ce = document.getElementById('ce');
    document.getElementById('bce').onclick = function () {
        try {
            ce.value = CryptoJS.AES.encrypt(ct.value, pb.value);
        } catch (e) {
            alert(e);
        }
    };
    document.getElementById('bcd').onclick = function () {
        try {
            ct.value = CryptoJS.AES.decrypt(ce.value, pb.value);
        } catch (e) {
            alert(e);
        }

    };
}
    &lt;/script&gt;
    &lt;style type=""text/css""&gt;
        .auto-style2 { height: 12px;}
        .auto-style3 {height: 5px;}#ct {height: 246px;width: 542px;}#ce {height: 245px;width: 496px;}#st {height: 160px;width: 538px;}#se {height: 158px;width: 503px;}#pwd {width: 494px;}
    &lt;/style&gt;
&lt;/head&gt;
&lt;body onload=""load();""&gt;
    &lt;form id=""form1"" runat=""server""&gt;
    &lt;div&gt;
       &lt;input id=""pwd"" value=""pwd"" type=""text"" /&gt;
       &lt;table style=""height: 456px; width: 853px""&gt;
           &lt;tr&gt;&lt;td class=""auto-style3""&gt;Client:&lt;/td&gt;&lt;td class=""auto-style3""&gt;&lt;/td&gt;&lt;td class=""auto-style3""&gt;&lt;/td&gt;&lt;/tr&gt;
           &lt;tr&gt;&lt;td&gt;&lt;textarea id=""ct""&gt;&lt;/textarea&gt;&lt;/td&gt;&lt;td&gt;&lt;input id=""bce"" type=""button"" value=""Encrypt""/&gt;&lt;br/&gt;&lt;input id=""bcd"" type=""button"" value=""Decrypt""/&gt;&lt;/td&gt;&lt;td&gt;&lt;textarea id=""ce""&gt;&lt;/textarea&gt;&lt;/td&gt;&lt;/tr&gt;
       &lt;/table&gt;
    &lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","<p>Got the solution, download the js file instead of copying the js content from browser directly.</p>
","372","<encryption><aes><cryptojs>","1","1","1","2013-11-16 09:38:01","","0","1","2673228","","2013-11-16 09:35:26","2013-11-16 09:05:26",""
"40661220","CryptoJS splitting word array in two","<p>I'm not too handy with byte conversions, so I want to make sure I'm not doing anything dangerous.</p>

<p>I'm simply generating a 512 bit key using CryptoJS pbkdf2. </p>

<p>I then want to split this key in half to generate two 256 bit keys. </p>

<pre><code>generateKeyPair = function(input, salt) {
     var output = CryptoJS.PBKDF2(input, salt, { keySize: 512/32 });

     var firstHalf = _.clone(output);
     var secondHalf = _.clone(output);
     var sigBytes = output.sigBytes/2;

     firstHalf.words = output.words.slice(0, 10);
     secondHalf.words = output.words.slice(10, 20);
     firstHalf.sigBytes = sigBytes;
     secondHalf.sigBytes = sigBytes;

     return [firstHalf.toString(), secondHalf.toString()];
   }
</code></pre>

<p>The output I get for <code>generateKeyPair(""hello"", ""world"")</code> is:</p>

<blockquote>
  <p>[""798ef2617367d80daeacf8b457af7903eebf6d1f384c9fed762b14186036e912"",
  ""0a9782aa773bdafcd9cd259e95381ac9ab26d026fe6a3375a93dc6b2a69e7ac3""]</p>
</blockquote>

<p>The underscore here is using lodash. Does this look right?</p>
","<p>Your solution seems fine. I recently solved this problem just by splitting the hex string in half. My example takes a key in WordArray format and returns each half in WordArray format.</p>

<pre><code>function splitKey(key) {
    const keyString = key.toString()
    const firstHalf = keyString.slice(0,keyString.length/2)
    const secondHalf = keyString.slice(keyString.length/2,keyString.length)

    return [CryptoJS.enc.Hex.parse(firstHalf), CryptoJS.enc.Hex.parse(secondHalf)]
}
</code></pre>
","372","<javascript><byte><cryptojs>","0","0","1","2017-10-06 04:17:30","","0","","","","","2016-11-17 17:20:13",""
"40270272","C# & JS encryption methods return different results","<p>I have legacy encryption code in C# and now I have to do same encryption in JavaScript.
I've done some research and tried 3 different libraries, however couldn't get same results. Last library I used is CryptoJS and I must figure out why I'm getting different results.</p>

<p>Here are both code snippets:</p>

<p>C# code:</p>

<pre><code>text = ""chocolate"";

    PasswordHash = ""hashhash"";
    SaltKey = ""saltsaltsaltsa"";
    VIKey = ""iviviviviviviviv"";

    byte[] plainTextBytes = Encoding.UTF8.GetBytes(text);

    byte[] keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
    var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.Zeros };
    var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));

    byte[] cipherTextBytes;

    using (var memoryStream = new MemoryStream())
    {
      using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
      {
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();
        cipherTextBytes = memoryStream.ToArray();
        cryptoStream.Close();
      }
      memoryStream.Close();
    }
    var result = Convert.ToBase64String(cipherTextBytes);
</code></pre>

<p><strong>result ==> ""8AbNsyyqHHfi/PEF/bbiew==""</strong></p>

<p>JavaScript code:</p>

<pre><code>pass = 'chocolate';
//Creating the Vector Key
var iv = CryptoJS.enc.Utf8.parse('iviviviviviviviv');
//Encoding the Password in from UTF8 to byte array
var passHash = CryptoJS.enc.Utf8.parse('hashhash');
//Encoding the Salt in from UTF8 to byte array
var Salt = CryptoJS.enc.Utf8.parse(""saltsaltsaltsa"");

//Creating the key in PBKDF2 format to be used during the encryption
var key128Bits1000Iterations = CryptoJS.PBKDF2(passHash, Salt, { keySize: 256 / 8, iterations: 1000 });

//Encrypting the string contained in cipherParams using the PBKDF2 key
var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(pass), key128Bits1000Iterations, { mode: CryptoJS.mode.CBC, iv: iv, padding: CryptoJS.pad.ZeroPadding  });
var result = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>

<p><strong>result = ""dpgTA41PDyrM8ef9C1c8iA==</strong></p>
","<p>The problem is with your PBKDF2 salts.  CryptoJS uses a <code>WordArray</code> as the primitive to store salts.  That is, an array of 32-bit values.  Where as C# uses 8-bit values (obviously, it is a <code>byte</code> array).</p>

<p>Notice then that, in JS:</p>

<pre><code>var Salt = CryptoJS.lib.WordArray.create([1, 2]);
</code></pre>

<p>Is, in C#, the same as:</p>

<pre><code>byte[] Salt = new byte[] { 0, 0, 0, 1, 0, 0, 0, 2 };
</code></pre>

<p>You can demonstrate this by outputting the following in JS:</p>

<pre><code>var Salt = CryptoJS.lib.WordArray.create([1, 2]);
console.log(Salt.toString(CryptoJS.enc.Base64));
-&gt; AAAAAQAAAAI=
</code></pre>

<p>CryptoJS doesn't like strings to be used as salts.  It doesn't like it at all.  You shouldn't be using a string or phrase as the salt anyway, it should be randomly generated and stored alongside the password hash.</p>
","370","<javascript><c#><encryption><cryptojs>","2","0","2","2016-10-27 16:50:58","40290212","2","1","2840103","","2016-10-26 19:37:23","2016-10-26 19:05:54",""
"40270272","C# & JS encryption methods return different results","<p>I have legacy encryption code in C# and now I have to do same encryption in JavaScript.
I've done some research and tried 3 different libraries, however couldn't get same results. Last library I used is CryptoJS and I must figure out why I'm getting different results.</p>

<p>Here are both code snippets:</p>

<p>C# code:</p>

<pre><code>text = ""chocolate"";

    PasswordHash = ""hashhash"";
    SaltKey = ""saltsaltsaltsa"";
    VIKey = ""iviviviviviviviv"";

    byte[] plainTextBytes = Encoding.UTF8.GetBytes(text);

    byte[] keyBytes = new Rfc2898DeriveBytes(PasswordHash, Encoding.ASCII.GetBytes(SaltKey)).GetBytes(256 / 8);
    var symmetricKey = new RijndaelManaged() { Mode = CipherMode.CBC, Padding = PaddingMode.Zeros };
    var encryptor = symmetricKey.CreateEncryptor(keyBytes, Encoding.ASCII.GetBytes(VIKey));

    byte[] cipherTextBytes;

    using (var memoryStream = new MemoryStream())
    {
      using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
      {
        cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
        cryptoStream.FlushFinalBlock();
        cipherTextBytes = memoryStream.ToArray();
        cryptoStream.Close();
      }
      memoryStream.Close();
    }
    var result = Convert.ToBase64String(cipherTextBytes);
</code></pre>

<p><strong>result ==> ""8AbNsyyqHHfi/PEF/bbiew==""</strong></p>

<p>JavaScript code:</p>

<pre><code>pass = 'chocolate';
//Creating the Vector Key
var iv = CryptoJS.enc.Utf8.parse('iviviviviviviviv');
//Encoding the Password in from UTF8 to byte array
var passHash = CryptoJS.enc.Utf8.parse('hashhash');
//Encoding the Salt in from UTF8 to byte array
var Salt = CryptoJS.enc.Utf8.parse(""saltsaltsaltsa"");

//Creating the key in PBKDF2 format to be used during the encryption
var key128Bits1000Iterations = CryptoJS.PBKDF2(passHash, Salt, { keySize: 256 / 8, iterations: 1000 });

//Encrypting the string contained in cipherParams using the PBKDF2 key
var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(pass), key128Bits1000Iterations, { mode: CryptoJS.mode.CBC, iv: iv, padding: CryptoJS.pad.ZeroPadding  });
var result = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>

<p><strong>result = ""dpgTA41PDyrM8ef9C1c8iA==</strong></p>
","<p>Finally got a solution. Thanks to Luke Park who advised me that CryptoJS is using 4-byte (word) structure.</p>

<p>The issue which led to different results is that the key-size is (apparently) different. 
In C# 256/8 is actually 32 bytes length, however in CryptoJS, since using 4-bytes, 256/8 translates practically to 128 bytes length :(</p>

<p>Once I change the key size in the JS snippet to 256/32 ((256/32)*4 = 32) it worked perfectly and echo same results as the C# encryption method.</p>

<p>Thank you all
Nir</p>
","370","<javascript><c#><encryption><cryptojs>","2","0","2","2016-10-27 16:50:58","40290212","2","1","2840103","","2016-10-26 19:37:23","2016-10-26 19:05:54",""
"53813676","SHA256withRSA Signature Verification in nodejs returning false every time","<p>I am trying to verify signature added to a XML as per the instructions on the link below. It is returning false. I tried some code in Java too but will prefer NodeJS to work. Any other module recommendation is also welcome. </p>

<p><a href=""https://uidai.gov.in/authentication/authentication-devices-documents/aadhaar-paperless-offline-e-kyc-verification.html"" rel=""nofollow noreferrer"">Instructions on the website for Validation</a></p>

<p><strong>Steps to validate signature :</strong></p>

<ol>
<li><p>Read the entire XML and separate the s=""xxxx"" tag from it.</p></li>
<li><p>Use a signature validation algorithm leveraging ""SHA256withRSA"" based hashing and encryption technique</p></li>
<li><p>Signature value present in ""s"" tag, remaining XML (without ""s"" tag) and UIDAI public key (available here.) is to be fed to the algorithm to validate digital signature.</p></li>
<li><p>Sample code snippets provided here.</p></li>
</ol>

<p><strong>Please find below my code: [using NodeJS Crypto module]</strong></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var crypto = require('crypto');
let fs = require('fs');

const CERT = '-----BEGIN CERTIFICATE-----\n' +
    'MIIDhTCCAm2gAwIBAgIEYhPgKjANBgkqhkiG9w0BAQsFADBrMQswCQYDVQQGEwJJ\n' +
    'TjESMBAGA1UECBMJS2FybmF0YWthMRIwEAYDVQQHEwlCYW5nYWxvcmUxEDAOBgNV\n' +
    'BAoTB2hjbC1hdWExEDAOBgNVBAsTB2hjbC1hdWExEDAOBgNVBAMTB2hjbC1hdWEw\n' +
    'HhcNMTgwMTAzMTMyNTQ5WhcNMTkwMTAzMTMyNTQ5WjBrMQswCQYDVQQGEwJJTjES\n' +
    'MBAGA1UECBMJS2FybmF0YWthMRIwEAYDVQQHEwlCYW5nYWxvcmUxEDAOBgNVBAoT\n' +
    'B2hjbC1hdWExEDAOBgNVBAsTB2hjbC1hdWExEDAOBgNVBAMTB2hjbC1hdWEwggEi\n' +
    'MA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCBgQBr8wRk6QbtUsq6YvxEnY22\n' +
    'wr9mW62qVXpaWLVHYcbuVtBALf5LXFK3WnLAY15xKKQ9m9WZa8w2ZMpo20UePoLM\n' +
    'QSda0Gk4gFhe0Dl+czlNSLMnMlYc4qWrPrpUlFTi7KZKDLKrQKpQjacY/OKqUVYj\n' +
    '98IPsbp/IivpSvkwIaS3J1cyORNYCdtDLhpAbUUX0rCrJJXl3245BCJ/3jbtpQ+F\n' +
    '7Cc81sBVYT31b+L04G3h5Ih3hsFg24xrJES1WglsBZBNAbFnSE2CjMfNLUIikZjz\n' +
    'RfcQ5MZgU2/mGjlgGrLV/GX+8yQ0VRryWEmTNDDb0skGkY3ZQafgOHa0Vxg9AgMB\n' +
    'AAGjMTAvMA4GA1UdDwEB/wQEAwIHgDAdBgNVHQ4EFgQUagX6xg6PhyaYYI6cjAip\n' +
    'lBHT5S8wDQYJKoZIhvcNAQELBQADggEBAG1z3DQoXjo9u+QfflnymFvcwRcc+vQ1\n' +
    'xE/5n85G5Gl6PD1fw0HSOOEMbt2obx/L367UVX0+bSi0eG7lFADSfL9G5B+RN+wP\n' +
    '0ItLNoG8uc9F0SbQMUw21WLEnkQydjjg+7wp4PXPxyEtaRNYLjus7UbU/xnHTf6W\n' +
    'ltI9ngHEr1w69H9d17KiQsFBeGjg0qfH9CGhhKT2q0ETKWQSPI3fwCx3Z4AmS2nZ\n' +
    'tog4WzWZlOMLHoPeYsFGv4gTgzbRWX0jc6HZ0057TDo+XWErcSuxBSGX8jEGLfp2\n' +
    'tW4LOAE3autC9HsG4OQBiR+nEbMEHbm3Pv8meRvfgTV6P6qQiICeMaI=\n' +
    '-----END CERTIFICATE-----\n';

verifier = crypto.createVerify('sha256WithRSAEncryption');
verifier.update('&lt;OKV v=""1"" n=""Ravi Krishna Nalagatla"" i=""/9j/4AAQSkZJRgABAgAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCADIAKADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwDyTI60Zq2bVgOgNMa2f+7+VOyXUggpN+KkaBh/AfyppjI6qaQbjdxpd5FJs5o2mi4rC76N/rTdrUm0+lFx2Hb+cZpd3Tmo8H0o3U7k2Jd5POaTzDzUBY9lNG7jJ4/Gi47FiNg7Y3KPdqR3VWxlT7g1AGB6Z/KkKg9aTY0TmZB6D8ahe4i4BOaQxjrik8tfSlcBVu4z608XCE53VGYgelKIgD0ouPqSiUHjIpQ4xUQAHQUuDSA2+3WjNBpPxqQA/SjGaTp9KWkAhA9KaY0P8Ip/8qM0AR+RH/dqP7KhPVh9DVjikzg0agV/sa4+8aT7IMcGrJpwXIzRcCkbRuxFNNq+Ku45pDwOaLsCgbdxj5T+dNML91atH0NJ+BouFjNMbehoEZPTmtMqKYwGaOYCh5Teho8l6uEU0jmjmAy7qU27BcAk1Zt08yJWOQSKZdWRuGDBgMDvVqGMRxqmc4GKd9C9LaF/rRVk6bqC/e06+H1tnH9Kje2uI/vwSr/vIRSvqRYhopC6j+NfzoDq3RgfoaSY7C0UCnpG0rhVGWp7iGDk8ClKFRlh/wDWqw+23jK7AZRg8VnSyO0x6A8jAYfp0FNILEzzReVhOTnkkEVBNciID93kMOgpisFbPIA68c1FcCAKrCV/mJ7dPzq0gFF5KoDeWWXrjOP0ojvjNMEKAEnjnrUUciANhpCp6jdyaz7gsG3D5QPWhoZ0728sSgygKW7ZFKttM4BSJ3B7qpNc/BfzOuGJkI7ntWpaXlzGVkDOMHkgnj2PPSo5QtYsONhw/wApHrUZIYnkH6Guo0XUbS9nMF1PMlyOE3Xku2TPoN2M+3866CSyV0CiVwPfD/8AoQNZt2eoHmpHHSm4Fd6dBgJy8nmd/nt4P6RimS6FCylUisx7/Z8f+gsKXMBwmM0AV2DeGogrFlt2A5wqSKfz8w0NoFnJZh4bfErKCFMzADOO5Dfyp8wGkdLsMgixtuOn7lf8Kl8mJPuIqY/ujFTlfX8qiZhnA5NeEqkrbm1iFkY/8t7hR/s3Dr/I1Wa1Vmybi9P+9eykf+hVaY9utRnn/GrVWovtBZFX7JCoJwTj/noxfHv82axp7iOOVvLSIIAcGOMKT9cACreu6gtpb+UrESy9COoFctHdsdxZRhj3Oa9LBqclzyZnK3QdO8905ZsBOgPrVYs/m4Q4HTA6U6aViSXYgn+E9f0qukoBI7mu5ElqaORQsjE/3enT8KdyY137TkdTxx9aIiXtGjBUkcrkdP8ACq8n7+IbXO9Ox4qkIrk+WWA9euelVJz1BOcmrYmUELNGMeoGDUMnkknaTnGOaBkdoCJPlA9K32Pk2yiTIJHbBx9RWbYRLw56juP/AK4p1/I6kcHHbjpR1AW6ulLRlCCVHHqK9L8KXq+ILHCX+y7hA82J4wxx2IOeR/nvXkxJfg9ueBiuh8D3z2Hia1lV2Cyt5LqTgENx/PH/AOuokk0J7aHrI0W6PC3kZOO8WP6mqF7aX9nsJ8h1ZtpwxyPwxXVJvADdGxWTq+4tbo/JMnHA575rnasEW3uY90PLglBOSEOe3amJ8qqvYDFPvuROPZhUQPNSUSMWPXIHoOtRP8vXv0A6mmXsxS0ndPlxGx3Yyelc7HaGW2R/tl0jOoJ2SY7fSvOw+GdZOz2NJSsdA2T149hQR6jiuae1kXpqF8P+25qq8dwo/wCQlfEf9fDV0f2e/wCYn2iI/FDkaqrcDYigDH1rEjn3cuE6/lUuqmQygySPI395zkn6ms3zCg7Zr0aUOSCiJu7Ls82QcLjn2qGMCVshgGFQkSNgKcjHpTl+UgsMN7VdxWLBnMUTxLkMfvZ/lVBJ2D5DHIq0+JQBncRwCBzTTaSAj5DmnzIFFhkygtgA98VG0RPbvWjaWLFcFGLHgYFacNgeQ0TdPSs5VEjVU2zGtEYbsqwwP0pt3t3AKxYnua1riAo2AmKzJ7dgaammS6bRSztOSefQdqntp3t5EmjIDowZfYjkVE6lTjj3oiR5pVjUFnc7VVRkkngAD3qyGj6YSOSa3ikjdWR1DBgeGBGQaw79JVvLJZWLkztjP+6eldjb2my1hUD5VjUYH0rm9UVX1S0A6Kzv+hH9a5ZIUJaNHN3f35P97+tQjr+FNnfO4+rf1qMOeakZDfSH+z7hXKvIIm3ELgHg9ueKyImZLeMDsoFXr64tb3Tby4sLhZIYwUY7GB5+orMWXEY9hiqw9J03JNCk7oV33D71V3GRUhYHt1qFsV0kGLrCkNG2MjmsV8ySYHc8CuyubG3u9McAyfad2VwRtA9DxkmsTSNMebWooZFIIOSPpU86NYwej7l7SdHlmABUkntXRR+C1mXLMFJ9RmpZrn+yBtt4y0hrMl13UYXd3mK+277tcr556p2On3Y6Wubtv4Gt48fv8H1210Vt4I0byd0jPM+c/OcAfQCuAh8ZXcbjdiVP7y810OmeLxcAKwZMjoaiUKkdWaRlF6WOntvD9vCpW3jiC9B3/Wq914et1JbcGeoH1tYIVkdiFPTvXP3/AI5hhZlUM38qztKWyLbjHcfqGhr5fyKM45xXL31m0WQy4NaX/CXTzuCq4X+7gmq8uri+zDcRgPn5GArVU6kdTJzjI42cMs7KRiul+HejtrPjXTbfB8qGT7TKc4wqfN/6FtH41lazB5V0hA+8K9W+Csem29tqEh8w6rJk7dpwbddv3fX5zz/wH8exTvG5yTT1SPV5XVV2hsMcEAdTXKa3CsOvQhRx9lkc9+cqK6ISbzJLHbk4PDHoxHAA9K5zXC/9vFpAAUtJAQDkclKwlqRyuOhxUuSOnU1HjG7ippAMrjHWmYGDxUMo86i16e1sp7XyB5czbm4Oc8f4CnDxEoHzQN+BqSe2maUF4VRV6ndVWWSMjA289+f8K7Oa+rJsWR4htT1WQH6CnDWrRujn8qxJIx14Y1CITjG0e2TQB2djfQyqY42UsDu69RVvSIhLrskzDaFiwv51w9o0lpcqwPT0r0LRHH2oyBSFeBWBJ77mzXPVhZ3R005pw5exr6lo0s8YlgUvhcHHOK54aQghurWUBGkUYk25ZcHP4g/h3rvdOvlQjcMjuK0J9L0/VBnb8x6HGMflXIpuLOnl5keSQ6TDYxTtPGZZZFCptIAXnr161Z0jT5J7uNBGSoPzEdAK9Cn8I2kOWkcyAdB0FEFvDEmyNFRV5+Ue9XOs2EaKRQ8RaCYtDEsQ3P5e5QDndg8152lgt0JVOVkKfuyemffHSvatTlzolojAHh8H1+auWHh62vGMkGEkzyOxNTCpyscqdzg7HQZ1WSW9VooxF8gLkvv9gCRjg9fX8RasdPku9qvHucHIbFd3D4RckGaUqnoDnNWrm3tNPgKQqARxkjmqnWbIVLlPNdXsV/tG0jkxtw2ffGP8a7b4eWko1uS4SNDHFAykF9uQ3GOh9/8Avk1zOqpHLqMbufljRnOB0GQf6V634V0Q6Po8aSKRdTAST5PQ9l/DOPrk1or6GVSSjF92bC6s6P5A0W/EajHmboNv5eZu/SuY1i5E+t35UMNlmhwwwecjkf8AAa6plNcVqJI1vWWPT7JAv/j81U5X0OJLW5z8g5X68VH2PTr3p75yKiY7UY+lTY0OHbU7a9haK4/d57pVf7LphH/H7IPqf/rVkLk8CnlD14rs5exJqLYacxx/aAA/2mAqdNFs5D+6v1b6EGsQL7UFcH3ot5jL+q6YNPeLEhcPnmuwtZY49G0qWKVCrQlGQdUIPII9zk5rgRu245x9a6PTPEsZ8PQ6DPbHdDdGeK438DIIKlce/r+HepqRuioOz0Oxs7g5BJxmumspwgyMhsdQOa4qzlKkKScVsrqKQpulcBQO5rzpx10PQi7I6G+u5HtnILMwU5qC2tzHCrbtxIz161hy+J7M2k0athmjYA/XiuPh8S3Npchmmm8teoLZX8v8KcaUmN1Yo9Zvir6XaqBlomkz7Btp/wAf1rMsi1veHH3G5+lcNqXj5jA0NrG5kP8AEQAo/Xn9K0PD3iNXs3lvHJkJwDgcAf8A66UqUrXH7SF7JneXF8DGcjJxxXL6neHkZBznpUz6hFPDvRwykZFc/f3PJ560oRbYpS0HaTEt1q/2mUEpAy8D+LnJB/SvQG8WT9oUHPPFcLpa31vYoY7a3ZZcybnnZSc9MjYe2K0A10cAiJD+Lf4V0nnzfMzpH8V3faOPH0rKuNRaZ7l2jXfOAHbPYZI/mfzrKdb4/duLcD0MDH/2emeXdn79xF/wGEj+bGgmxK33hUTDIIIyD1BpY0kVjvlZ+O4Ax+QqEwuXLC6mAPO3CYH6ZoA8xjBzU+zPateLw+8PF1PDCT/CDvYH6Dj9a0NN0oX6M2l2moamEO12tLdpVB99oOPzrtEcwIzViy0y81O9SzsLaa6uX+7FAhdj74HQepPAr2Tw38H5L9Y7vXomsYSMpaxENM/OfnblUHsMk56qRivVNI0TS/Dth9i0rT4bSIn5lhXlj6sx5Y+5yaBpHgmjfBPxVqDKb1LXTIifm+0Sh5APUImQfoWWtvVfAuh+ENDuQtiL6+ZTH9qujlunzOifdjAP3TyRn7xIwfbXkVEO1NzYwTXI+PNGC+D7mSMHziFMz7uTyBk/kB+XpUzvYq1tTxLTpt6bDnenXPenau0jWwKZC5+bHespbvy5i6D7rFTjuAauzXSXECgMee3YVhKGvMjojK6szM2iNA7I7AnsKsBUeI77VvLI6shI/PtVmHeMII9wHFJJqotMqYZNp6hBmle+g4pFEWoKkxWLtGD95Y2K/wDfWMVFu+coIHjI6bhnB9v8+taCasLshFSZR6MAM1O7JsIK0N2G4p7EWjXUhR43JwoyKfdzKZFTaHDHLqDj5e/NVkuI7ZHxjnrUelzNeakYEDyXL5AhGMuAM4U/3uDx3pqF5XIlLljY9C8mU2SXZiYQNj5scKSeh9OePrgVGRgZ5rvvA7Q674ViuoDHNgeXJGR8rjABDZ79fw4NTt8KfCMxd/7KktJm/itruVAPoobaPyqvZXMHbdHm5B96YevSu01H4P2627Pp3ibVbZw2f9KZZowPTaAh/WuD1bw14u0eXCo+oQZ4kskExx7ptDj3OCo9aXsZdBa72Hn75PtTCa56PxK5lZX+zyMOCithgeevJxVyLW4JABJG8Zxz/EB+I/wqXTaFc9j03wH4X8OhZHsGvLjOftF4nnMDnghQNqn3VQf51teIvP8A7Ale1uHikRTKwSQxv5aj5sHqMcdMenekkuhE8SSSKzxSbeeCykZBx361oTWS3Sxyu4ikVWAKgHKnG5TkdDgenQc12NaG8ocqTPNvDnjLXIYHWBZdStLZmlu57ly52EfKqMPuAAZ3Pu3Hd0GMej6ZqttqloLrT2MiE4eM8NG2MlXHY8g+hGCMgg1Z023gtbILF5YVmJYoAoJzXP8Airwvby6NdXOkJLZarDEz272UrQM5GG8s7SAQ2Mc+uazs0yZuLlojooAqyYcgvjOB/D9amuIIbu2kgnRZIZVKOp6MDwRXB/Da31WXSdQv7+7upftE/lQLcSFsLHkMcH7p3lgc8/IK7O1luJ1iZrfy7d4w/wAxIkRuPlZfX8e1O6JmrM+U/EWhzeFfFOoaNMzssMuYnbrJGeUbPqRwfcH0qmGdRuQ4HXivqTxB4R0zxDAPt9olxIqlRvPIB9D1B9CPf1rxTxX8NrzQmabSpJb21A3GFh++jH0H3h9Bn2PWk4t6o1px5locva6sgAVyEfjr0NWLrVIXjOUiY46kA1gsVkHQNURjTpkisrJvUeqNyDUIeCAinucVXvtTRsrEQcjkAdDWSIU/vU4KF6MB9BStG+ga2sOQM7Auxx6Vatbe4F7FdWj+VdROskMg/hdTlT+YFNtbd5XG1T9TXUadpjLgsvPXpUVKnKNQueleDtWW2uotRsoBBZ+I0a5MGPkt7yM7Z07deSPXDdgBXpNtcknbKeT0JryHw7Yu3hvWoow27TbqDWICB0bDLIo9dyRuPrJXp8T+bEOOcc5H610QkpK5nyKzRJe2syysys7xHnGSdp+npWS00LNtyxx26fqa6K3uCX8mQ5OPkb+8P8afPZ29yCJolb36EfjWqlbRlwrcmkkc6bQah+6kMEidAsnzD6cisu9+GmjXvJ0m1jJOT5KiEk+pKbSa6CbSjbOXgnUIf4XH+HWk07xBbO0qPOrRRyNH5h4wVO1uvYEEfhQ3fY1lJy1p6/I5KS5muZJBJMWARGRjgMAdxHTv0rTaeSe1X7TKzRgYwW4OKyTmGaZJFwVCrgjqMtx/n1pzzPIQWbOex/oK3uj1/ZqUVY6/R5fPsE4wu5sDp3rSaJSjhh8uDnP0rM8NoP7HiPfL/wDoRrcC/LjA5rCT1PBxGlWVu55prXinW9P15Uh2woqBQJIspP3LdRnrjgj3rXsfiHbHYNXszZqzhTOj+ZEmeAWJAKjpzggZ5OASOmvNGs7+BobmFJYy24Kw+6fUEcg8nkVzOq+Cka0nWydg7KcRyHg/Q/4/nUFxlSnZSVjtQQRkHIqvdWMF4p82JS2MBiOfz615HoPjjUvDCrp13avdWEXCxH5ZoVx0Unhl9AcdeGwAB6ro+tafrtgLzTrlZoc7WxwyN/dYHkHkcH1HrRqmKth6lB3e3c818d/ChdSWTU9DUJqOS8luSAlz9D/C/oT17nuPEmgdHeORGjkjYo6OuGVgcEEHoQe1fYUkiqvzAkE4AHJJrgfHfgew1cS6zawf8TCJf9IRFyZ1AHYdXUdD1IGOcLiJ7EQm2/ePnoQZIwK09P0R7lwzKQufTrXW2+iWI2ugyDyDjtWhDFDEWWNQMCuSVXTQ6VDuUbPSIYUXCAVox22DgAVMp56CplxzziuaTuapI2/CjfZNZZmkIimtZIjHjIZ8qVJ+gDD/AIFXa2I3IFHMiDDD1/z6/wCRxGhb4pmuNgYcoo7+px+n0/GtmHxXpNpfR2v22L7fI5UQAhmz1w2MhRwepHSvTw0bUrszqUtOZdTT0y7utWV86de6dLEqSxtcxgBsk8dfbkcEZ9wabqHivSLK6eG81O2iuYsK1oH3zKeoxGuWJOR0ByCKp+IfEWv6ckksFjYxWSLGTcvO0juzEgoibRgg4OScYPQ8gQanp1xI5vIHJh8lWdtx3Meckjvxj/IrSOrszOjSU377silqmv6jqyvb2CT6dat8r3MmBcOv/TNP+WeR3bB5+6DyKQhiSKKCKLy4ohhUHTgY5PU/1qSVPssXEffrjrVJ7qXeP1xWiVj2KNGFLSJeupo57qSWORX8xvMYjjknP/1ufSmKRyc1naLeJBeAyKr/ADrGXAzg5I/mtd1C0TDfu4xxWqHUq+xXKlsXvDKAaNCVPBLnI/32raqCzZXtIyhyMYzU9c8tz56rLmm35gBikZQwwaWipMzjta8Hx6hPIHEbQuxZSSVZCewIrmL3wdq/haVdY8NahK80YHnwOmfNUdiBw45Py9eSVOcCvULyTyoN+MgEA1Va6hkjwFJ49MVoryWp2wxNVxSeqOd8OePbLWEjh1ONbK7OAG3fupD0+Vj909OG7nAJrrVgVFxGAOS34nk1xuqeFLK8ne4iHkvIDv2jKyZ67l7n3/PNQWU2teGsC33ajp6/ftGOJIx/0yJPTGflPHAA2jJpODWqHUoRmual9xS8YeGhpl1/aNsMWUzfvFH/ACxcn9FJ6eh4zyAOYSPD5JI98Zr2e0vLHXNN8yIrNbTJh0YdiOQw+hryrxLpU3h/Vkt33PbS5a2lPO5e6n/aXjJPUEH1A4qtL7SIpVPsyKfOcdfenZIHv2WkjlRlDsdv0qvqkmNPuFhAMmxsL17VzNHQmdjZ+Ebu/uLb+17mWDS4MpHaW5INw3OXlYfw9SF6cjJySK67TvD+kafpb6dZ2EcVoxIZNp+cjuSeT04J9BjjFcB8Ktf1XV9OvYtYna4WNhJayvjcVJIZeOMAjj647Cu9kvzbSRIrDazBMfXPP4dfwr0ltoctZzctzFvBdaPcWkM0IuLNGkEbFiduBkFlCkkhcjgjucNxjTsfFWmzWUUk5a1lYlTA6EsCCR0A5BxkH0K9MgVrSQ22oWzQ3EEc0G4fJKgYEjBBwfQ/yrO1TQNOvLSONI47aZZFeCWNMFXBJyMYzxu/AmquZ86l8Rxmp+Ibc38z28oktovlktnA3lS3DKO4Izj6AHBJpHGn3wMlsyNjqIz8y9uR2/GtHxJptlK1vb2dparMm4yMsA5LAZ6dMkAk+qjvyOZ1PRNWS4xZGxkgCIrJNI8buFAwAQCowQOSDwB05NWtUenQqe4mjOthG2szhH4JiY4PHDNkf+O/rXR3OupaLhCGY0UVT3O2t8Rd0HxG1zcHT5pADMd0Sg4JOOR16d/wNdpaQzeVsYujRH5GOcMPofyooqJKx42NgozTXUvLu4LHBxyB0zTqKKg4yK5hFxbvEf4h+vasdbN4GYPIo/CiiqjJo0pza0Rn3Ou2FtcC1a4jeRcb1QjIJxgdevI/MetW2jEuHUAnHPoRRRW0T0JQUIRkt2WY9N3JHd2bfZ7peGI+7IAejev1681DrVjB4i0qXTLxfs1396B2GdkgBAdT34JBAIOCRRRXPJK7POl8TPIWt7pJ3s7uLyrqAmKZDztOQeOmQQFIPcEHvShZghSFBuclVOME57e56UUVxzS5rHTTd1qdpolnb+G9MtrfrcLbRxTFWOGYFmY+2WdjWzYTpPefbLqRUjT5UznliM4H5fpRRXY97FVFeSiad54gs7S3ch3Pl8nYvU9QOcVzzeNBJMDHaBxt2KGn2lB3/hOSR/nmiitVBHoYfAUHC8lcqzeIZLogrZfZ9qBQquX7sSckCqZvmBZ5YpS57kYAoop2O6OHpxXKkf/Z"" d=""10121993"" e=""ac342bb947d5aa49847a0a05f87c388759a6cb156e04eac6ae995e9dca5ba1d9"" m=""254618fd06a2e7308247c7f0fb547f58174ab3b99e7b042d6705a5457235f32a"" g=""male"" a=""S/O Narasimham, 45, 74, 4, 7, Secunderabad, Hyderabad, Andhra Pradesh - 500003"" r=""328020181115111938451""/&gt;'); //XML without S attribute
const signature =""VFKxVswVqlPDYOnp7rHUTtLVR3/NQN/p1dI61s1KSy102OgRI5YbXLj9Ng8Cy1fo6a5S62d0NldczYpztM5/E8Z6YUhtknhdVLD24fPijrFoUEqVC2S2fr8FUsCdVXNJEYd2v+UZ2grGYYi68rslaLO7z8SChoedsupRj2F1mwRyrof4u6kdAK5BxvubHPlEZ34Gv3ivuyJnJAKEyDkoymlm2GOAnaLUIxN5vdyBANZMOv9geH2poFOdUGVvOjDbpTPBF3Y5ADosYQYoErsONJ68x3iJsiZcG6dw1gPIW5J3B+X2vgXtFbF9xjFs7rZV9jk7Q8bJos5W8JuVjwV37g==""; //value of S attribute

var result = verifier.verify(CERT, signature);

console.log(result, 'result'); // **It is returning false always**. </code></pre>
</div>
</div>
</p>
","<p>Seems like the certificate in sample code and the certificate to be used are different. Try using below certificate I found in the URL you shared.</p>

<p><a href=""https://uidai.gov.in/images/ekyc_public_key.cer"" rel=""nofollow noreferrer"">https://uidai.gov.in/images/ekyc_public_key.cer</a></p>

<p>Also, the sample data seems invalid. I tried it on Live data XML(can't share here) with the certificate. It returned me true after two changes:</p>

<ol>
<li>One extra space needs to be removed from XML after the <code>s</code> element is removed. </li>
<li><p>Pass Signature as a buffer with base64 decoding. </p>

<p><code>const signature = new Buffer(""hchpGi49Pm8z5KDAnnmqHEUzVSE1ovQsWzhjx0RnRrh33H0oHYOpw1vQ9HuQwOtjtoNtKrpU+2ikduVkxw1DXI0jVnNsw6F0vQeELBOBw2qQ4QdJ0Zwx0A3+nBF0zHVaJE/fUhIhzLjGsfoGF5ohEotkQxtFcP5lrlfQDUj69LEu2RpcW7kBYH9PAQCGcs0b5hhcdP0eR6F2gYhi7dV5ieDL1c6Ta6NW1HroWEQI0Lk0NmeXuh2efzJfk4S8uc0MrhBUzLAa4N9WDUyegYcfTKJHtt6vpxVIyqs3ObQn9osHj9WmDMWVZiJvRz7tMaQdDU6gh74p734UPjk5CioUnw=="", 'base64');</code></p></li>
</ol>
","369","<javascript><node.js><rsa><sha256><cryptojs>","1","1","1","2018-12-17 12:41:05","53815476","1","","","","","2018-12-17 10:52:00",""
"48106525","Invalid_Signature on Bittrex Account API Request [javascript]","<p>I'm trying to work out an api request for bittrex (account, not public) via ajax. Kicking back mention of Invalid Signature. I've already worked though the nonce, cors proxy and sha512 implementation. I seem to be missing something over here. Never had issues with ajax request, but haven't worked much with added encryption either.</p>

<p>Here are my setup variables &amp; my request, followed by the error response.</p>

<p>Setup (w/ keys removed):</p>

<pre><code>var apikey      = 'removed12345';
var apisecret   = 'removed12345';
var nonce       = Math.floor(Date.now() /1000);
var proxy       = 'https://cors-anywhere.herokuapp.com/';
var uri = proxy + 'https://bittrex.com/api/v1.1/account/getbalances?apikey='+apikey+'&amp;nonce='+nonce;
var sign        = CryptoJS.SHA512(uri, apisecret).toString();
</code></pre>

<p>Request:</p>

<pre><code>$.ajax({
    url: uri,
    headers: {'apisign': sign},
    type: ""GET"",
    crossDomain: true,
    dataType: ""json"",
    success: function(bittrex) {
        console.log(bittrex);
    },

    error: function(xhr, status) { 
        console.log(""error""); 
        console.log(status);
    }
});
</code></pre>

<p>Response:</p>

<pre><code>{success: false, message: ""INVALID_SIGNATURE"", result: null}
</code></pre>
","","367","<javascript><ajax><api><cryptojs><sha512>","0","","0","2018-04-29 14:52:50","","2","","","","","2018-01-05 02:48:53",""
"15096511","Encrypto in JavaScript and Decrypto in PHP","<p>I want to encrypt in the javascript. decrypt in the PHP.<br />
JavaScript AES crypto library is CryptoJS.<br />
PHP AES crypto library is mcrypt.</p>

<p>I was get incorrect result.<br />
get result like 'I4L$""""E_zHeV:'.</p>

<ul>
<li>encrypt (JavaScript) <br /></li>
</ul>

<blockquote>
  <p><code>encrypt = CryptoJS.AES.encrypt('HelloWorld', 'test', {mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.ZeroPadding });</code>
  <br /></p>
</blockquote>

<ul>
<li>decrypt (PHP) <br /></li>
</ul>

<blockquote>
  <p>$ivSize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC); <br />
  $iv = mcrypt_create_iv($ivSize, MCRYPT_RAND); <br />
  mcrypt_decrypt(MCRYPT_RIJNDAEL_256, 'test', $encrypt, MCRYPT_MODE_CBC, $iv);</p>
</blockquote>

<p>is wrong somewhere?<br />
Thank you.</p>
","<p>As noted in the comments above, SSL is the only way you will acutally protect any data because</p>

<ol>
<li>Without SSL, anyone could make changes to or sniff your Javascript or webpage and so it cannot be trusted.</li>
<li>Javascript really doesn't allow for non-character based data very well. (i.e. hashes, encoded video, etc.) as all data is usually silently converted to utf-16 or utf-8 internally.</li>
</ol>

<p>This last point is likly what is causing your problem. The AES library on each end encrypts as if it had access to binary data, however, Javascript is telling the transfer that the encrypted data is in a certain characterset. You may want to try utf8decode or play with iconv() to get it converted to true binary data.</p>
","366","<php><javascript><encryption><cryptojs>","2","0","1","2013-04-24 14:22:24","","5","","","","","2013-02-26 18:25:48",""
"19385412","Is correct to use CBC with NoPadding in AES Encryption?","<p>I'm currently working with mcrypt.java To encrypt and decrypt data from server side and cryptojs on client side but I have some problems because when I encrypt any string, both java and JavaScript display different results.</p>

<p>Well, I was reading  about methods and padding schemes of AES encryption and some blogs talking about is incorrect to use CBC mode with NoPadding and is better/correct use CBC with Pkcs7 or another padding.</p>

<p>Anyone can explain me something related with that?</p>
","<p>Padding your plaintext is required if you perform AES encryption in ECB/CBC block cipher mode, unless your plaintext is a multiple of the blocksize. You could of course make sure that your plaintext is always precisely N blocks, but in effect you would be creating your own padding mode.</p>

<p>Many libraries (e.g. mcrypt in PHP) don't specify any padding while they secretly <strong>do</strong> pad. They just fill up the last block with <code>00</code> valued bytes. The effect of this is that you can encrypt <strong>ASCII compatible</strong> text, which will then be <em>null terminated</em>. In most languages (that do not use null termination) it is also possible to use a <code>trim</code> method to remove this padding. This is however not an official padding mode. Of course this scheme only works <em>if your plain text does not end with control characters</em>. So it is not suitable for any binary plaintext.</p>

<p>It is definitely better to use PKCS#7 padding. Removing PKCS#7 padding is deterministic for <em>any</em> plaintext. This means you can encrypt any value, including UTF-16 encoded text and any binary value. If PKCS#7 padding is not available it is relatively easy to implement it yourself - this is certainly worth the effort. The only disadvantage of PKCS#7 padding for CBC mode is that it <em>may require an additional block of padding</em> when the plaintext is already N times the block size. The reason for this is that the plaintext may otherwise be misinterpreted as being padding.</p>

<p>Note that padding and padding errors are <em>not suitable</em> to detect if the ciphertext was changed in transit. Padding Oracles are very easy to implement and may reveal your plaintext in 128 times the size of your plaintext in bytes (!!!). So use an authenticated mode of operation or a MAC (HMAC or CMAC) if you want to provide integrity and authenticity to your plaintext.</p>

<p>If you really cannot miss the bytes used for padding, please look at CTR or a similar stream mode of operation for your block cipher.</p>

<hr>

<p><strong>EDIT</strong></p>

<p>there is also <em>ciphertext stealing</em> or CTS that can be used for CBC mode. It is not used much and as there are three different versions of it, you should make sure which one is used.</p>

<p>Nowadays it is more common to use counter mode (CTR mode) or an authenticated mode which is based on it (if a block cipher is used at all). CTR mode doesn't require any padding as it is a streaming mode of operation.</p>
","366","<encryption><aes><cryptojs>","1","5","1","2019-01-05 21:33:30","19385783","0","","","","","2013-10-15 15:41:16",""
"49780633","How to decrypt using crypto-js with typescript?","<p>I have an encrypted code snippet, which I would like to decrypt by using <code>crypto-js</code>. Below I've tried to convert it w/o success. I dont see any response, any idea what is a correct way to decrypt?</p>

<p>this is my code:</p>

<pre><code>import * as CryptoJS from 'crypto-js';
const encryptedValue = ""MIIBCAQEAuPFrd+xVq/ciJKo5xQjL8KHtaDA/IHgWMuaeg2rB9FptbUa+nE7Qx9TL2HLaTDQvF"" 

private decryptStr(args): string {
        const decrypted = CryptoJS.decrypt(args, {
            keySize: 128 / 8,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });
        return  console.log('EncryptMethod',  decrypted);
    }

this.decryptStr(encryptedValue);
</code></pre>
","","365","<javascript><typescript><encryption><cryptojs>","1","","0","2018-07-16 21:16:55","","1","1","949346","","2018-07-16 21:16:55","2018-04-11 16:54:31",""
"54864320","decrypt AES input on Flutter, when on web use cryptoJS AES","<p>On web, I'm using CryptoJS for decrypto JS:</p>

<blockquote>
  <p>CryptoJS.AES.decrypt(inputBase64, key).toString(CryptoJS.enc.Utf8);</p>
</blockquote>

<p>Example:</p>

<blockquote>
  <p>input: ""tzfwnxVwE/qNoaWRRfqLp11ZyhB4UtKO+0/Lvv5B7eE=""
  key: ""20190225165436_15230006321670000_15510884759030000""</p>
</blockquote>

<p>On flutter I can't find any library to decrypt with a key of any length.</p>

<p>I know ""For AES, NIST selected three members of the Rijndael family, each with a block size of 128 bits, but three different key lengths: 128, 192 and 256 bits.
""</p>

<p>But I don't know how to convert any length key to 128 bit format?</p>
","<p>When you pass CryptoJS a string as the key it treats it as a passphrase and generates the key from it using a key derivation function - in this case PBKDF2. It generates a 256 bit key and a 128 bit initialization vector (IV). It then uses those for the encryption/decryption. You also need to find out what chaining method CryptoJS uses (probably cipher block chaining (CBC)) and what padding method it uses (to make sure that the plain text is a round number of 128 bit blocks - probably PKCS#7).</p>

<p>CryptoJS has this ""works out of the box"" mode, but it isn't particularly clear what it's doing under the hood - you'd need to read the source code or scour the documentation.</p>

<p>When trying to inter-operate between two systems/languages it's best if you remain in charge of things, rather than letting one end make arbitrary decisions. That way you can make sure that you have the settings the same at each end.</p>

<p>So, you might choose to:</p>

<ul>
<li>Use PBKDF2 to generate a 128 bit key and 128 bit IV from the string
passphrase - with, say, 9999 rounds</li>
<li>Use PKCS#7 padding</li>
<li>Use AES in CBC mode</li>
</ul>

<p>The <a href=""https://pub.dartlang.org/packages/pointycastle"" rel=""nofollow noreferrer"">pointycastle</a> package supports all the above in Dart. It looks like CryptoJS supports all of those too.</p>

<p>Start with a passphrase and make sure you can generate the same key and IV in JS and Dart. Then move onto creating the ciphers.</p>

<p>Remember, too, <em>never</em> to encrypt two messages with the same key/IV pair. Use a message sequence number, for example, to slightly change the IV for each message.</p>
","363","<encryption><flutter><aes><cryptojs>","0","1","2","2019-02-26 01:28:40","54869521","1","","4156841","","2019-02-25 11:28:26","2019-02-25 10:39:07",""
"54864320","decrypt AES input on Flutter, when on web use cryptoJS AES","<p>On web, I'm using CryptoJS for decrypto JS:</p>

<blockquote>
  <p>CryptoJS.AES.decrypt(inputBase64, key).toString(CryptoJS.enc.Utf8);</p>
</blockquote>

<p>Example:</p>

<blockquote>
  <p>input: ""tzfwnxVwE/qNoaWRRfqLp11ZyhB4UtKO+0/Lvv5B7eE=""
  key: ""20190225165436_15230006321670000_15510884759030000""</p>
</blockquote>

<p>On flutter I can't find any library to decrypt with a key of any length.</p>

<p>I know ""For AES, NIST selected three members of the Rijndael family, each with a block size of 128 bits, but three different key lengths: 128, 192 and 256 bits.
""</p>

<p>But I don't know how to convert any length key to 128 bit format?</p>
","<p>I have searched the library pointycastle
but it's too little for me to do for my work
Do you have any similar examples written in dart, and on the web use cryptoJS</p>
","363","<encryption><flutter><aes><cryptojs>","0","0","2","2019-02-26 01:28:40","54869521","1","","4156841","","2019-02-25 11:28:26","2019-02-25 10:39:07",""
"48238373","CryptoJS AES Decryption Not Giving original ZIP/EPUB file in react native","<p>I am using CryptoJS to encrypt my <code>epub (or zip)</code> file and decrypt it. I am using <code>react native</code> to create the app. But I don't know why the decrypted file is not the original epub file. The error while opening the decrypted epub file is: <code>Error in opening zip file.</code> And I am using <code>react-native-fetch-blob</code> for file reading and writing.</p>

<p>Here is my code:</p>

<h1>Encryption</h1>

<pre><code>  encrypt() {

    // ENCRYPTION

    RNFetchBlob.fs.readFile(`${RNFetchBlob.fs.dirs.DownloadDir}/startup.epub`, 'base64')
    .then(result =&gt; {
      console.log('startup.epub read data: ', result);

      // Encrypt 
      const ciphertext = AES.encrypt(result, key);

      // Write encrypted file
      RNFetchBlob.fs.writeFile(RNFetchBlob.fs.dirs.DownloadDir + '/startup_enc.dat', ciphertext.toString(), 'base64')
      .then(() =&gt; {
        console.log('startup_enc.dat file wrtten');
        this.decrypt();
      })
      .catch(error =&gt; {
        console.log('startup_enc.dat file writing error', error);
      });
    })
    .catch(err =&gt; {
      console.log('read error: ', err);
    });
  }
</code></pre>

<blockquote>
  <p>I read the epub file in <code>base64</code> format. I encrypted the result with AES as <code>ciphertext</code> Then I wrote the <code>ciphertext.toString()</code> to <code>startup_enc.dat</code> file in <code>base64</code> encoding. </p>
</blockquote>

<h1>Decryption</h1>

<pre><code>  decrypt() {

    //  DECRYPTION

    RNFetchBlob.fs.readFile(`${RNFetchBlob.fs.dirs.DownloadDir}/startup_enc.dat`, 'base64')
    .then(result =&gt; {
      console.log('startup_enc.dat data: ', result);

      // Decrypt
      const bytes = AES.decrypt(result, key);

      const plaintext = bytes.toString(enc.Base64);

      // Write decrypted file
      RNFetchBlob.fs.writeFile(RNFetchBlob.fs.dirs.DownloadDir + '/startup_dec.epub', plaintext, 'base64')
      .then(() =&gt; {
        console.log('startup_dec.epub file wrtten');
      })
      .catch(error =&gt; {
        console.log('startup_dec.epub file writing error', error);
      });
    })
    .catch(err =&gt; {
      console.log('read error: ', err);
    });
  }
</code></pre>

<blockquote>
  <p>Then I read the encrypted <code>startup_enc.dat</code> file in <code>base64</code> encoding. I decrypted the file and converted to <code>base64</code> format. Then I wrote the decrypted <code>plaintext</code> to <code>startup_dec.epub</code> again in <code>base64</code> encoding format.</p>
</blockquote>

<p>The size of original epub file is <code>2.49 MB</code>, encrypted file is <code>3.11 MB</code> and the decrypted epub file is also <code>3.11 MB</code> unlike <code>2.49 MB</code>.</p>

<p>I am unable to find where the problem is, either in <code>encryption</code> or in <code>decryption</code> process. Can anybody help?</p>

<ol>
<li>React-native-fetch-blob file streaming <a href=""https://github.com/wkh237/react-native-fetch-blob/wiki/File-System-Access-API"" rel=""nofollow noreferrer"">DOCS</a></li>
<li>CryptoJS AES Encryption <a href=""https://github.com/brix/crypto-js#aes-encryption"" rel=""nofollow noreferrer"">DOCS</a></li>
</ol>
","","363","<encryption><react-native><aes><cryptojs><react-native-fetch-blob>","1","","0","2018-01-13 08:58:02","","0","0","","","","2018-01-13 08:58:02",""
"39143264","How to create a valid signature for the mws amazon (javascript)?","<pre><code>var protocol = ""https"";
var method = ""POST"";
var host = ""mws.amazonservices.com"";
var uri = ""/Products/2011-10-01"";
var marketPlaceId = ""ATVPDKIKX0DER"";

function generateRequest(asin, action){
    var today = new Date();
    time = today.toISOString();
    var parameters = {
        // ""ASINList.ASIN.1"":asin,
        ""Query"":asin,
        ""AWSAccessKeyId"":AWSAccessKeyId,
        ""Action"": action,
        ""MarketplaceId"":marketPlaceId,
        ""SellerId"": SellerId,
        ""SignatureMethod"":""HmacSHA256"",
        ""SignatureVersion"":""2"",
        ""Timestamp"":time,
        ""Version"":""2011-10-01""
    };

    parameters = $.param( parameters );
    var messageToEncrypt =  method+""\n""+host+""\n""+uri+""\n""+parameters;
    var sig = CryptoJS.HmacSHA256(messageToEncrypt, SecretKey);
    sig = sig.toString(CryptoJS.enc.Base64);
    sig = encodeURIComponent(sig);
    parameters = parameters+""&amp;Signature=""+sig;
    var mwsRequest = protocol+""://""+host+uri+""?""+parameters;

    return mwsRequest;
}

// var asaUrl = generateRequest('B01I94N9TC','GetMatchingProduct');
var asaUrl = generateRequest('B01I94N9TC','ListMatchingProducts');

$.ajax({
    url:asaUrl,
    method: ""POST"",
    success: function(data){
        console.log(data)
    }
});
</code></pre>

<p>It gives an error
""Check your AWS Secret Access Key and signing method. Consult the service documentation for details""</p>

<p>but if you send to Get Matching Product is operating normally</p>
","","362","<javascript><amazon-web-services><base64><hmac><cryptojs>","2","","0","2016-08-25 20:18:09","","0","","1816580","","2016-08-25 20:18:09","2016-08-25 10:48:33",""
"54660233","JSON decrypt in JavaScript encrypt in PHP","<p>I am encrypting with PHP a JSON file like this:</p>

<pre><code>0: {ID: 0, NAME: ""London"", REGION: ""ENGLAND"", }
1: {ID: 1, NAME: ""Rome"", REGION: ""ITALY"", }
</code></pre>

<p>And I am using this library <a href=""https://www.codesd.com/item/encrypt-with-php-decrypt-with-javascript-cryptojs.html"" rel=""nofollow noreferrer"">crypt in PHP decrypt in JS AES</a></p>

<pre><code>function cryptoJsAesEncrypt($passphrase, $value){
$salt = openssl_random_pseudo_bytes(8);
$salted = '';
$dx = '';
while (strlen($salted) &lt; 48) {
    $dx = md5($dx.$passphrase.$salt, true);
    $salted .= $dx;
}
$key = substr($salted, 0, 32);
$iv  = substr($salted, 32,16);
$encrypted_data = openssl_encrypt(json_encode($value), 'aes-256-cbc', $key, true, $iv);
$data = array(""ct"" =&gt; base64_encode($encrypted_data), ""iv"" =&gt; bin2hex($iv), ""s"" =&gt; bin2hex($salt));
return json_encode($data);
}
</code></pre>

<p>I can easily encrypt in PHP and write to server (writing a JSON file) with a 128bit key like</p>

<pre><code>$key = ""TjWnZq4t7w!z%C*F"";
$ForecastArray_crypt= cryptoJsAesEncrypt($key, $ForecastArray);
file_put_contents('ukforecastlist_example_crypt.json', $ForecastArray_crypt);
</code></pre>

<p>The problem is that when I try to decrypt in JavaScript with the call</p>

<pre><code>var ukforecastlist_decrypt = JSON.parse(CryptoJS.AES.decrypt(myjson.ct, ""TjWnZq4t7w!z%C*F"", {format: CryptoJSAesJson}).toString(CryptoJS.enc.Utf8));
</code></pre>

<p>The console returns:</p>

<pre><code>Uncaught SyntaxError: Unexpected token V in JSON at position 0
at JSON.parse (&lt;anonymous&gt;)
at Object.parse (core_uk.js:33)
at Object._parse (aes.js:30)
at Object.decrypt (aes.js:31)
at Object.decrypt (aes.js:25)
at &lt;anonymous&gt;:1:54
</code></pre>

<p>Where <code>V</code> is indeed the first letter of <code>myjson.ct</code>.</p>

<p>What am I doing wrong? I did get the JSON with jQuery and parsed and stored it in myjson variable.</p>
","<p>Solved.
I am now using this simple PHP class:</p>

<p><a href=""https://github.com/henrya/projects/blob/master/JsEncode/jsencode.class.php"" rel=""nofollow noreferrer"">https://github.com/henrya/projects/blob/master/JsEncode/jsencode.class.php</a></p>

<p>I can encode in PHP with:</p>

<pre><code>$json_data = json_encode($myArray);

$d = new jsEncode();

$myArray_enc = $d-&gt;encodeString($json_data,$key);
</code></pre>

<p>And decode in JS with:</p>

<pre><code>var myArray_decoded = JSON.parse(jsEncode.encode(myArray_enc,key));
</code></pre>
","359","<javascript><php><aes><cryptojs>","1","0","1","2019-05-28 15:07:11","","6","","10607772","","2019-05-28 15:07:11","2019-02-12 23:26:28",""
"48525764","CryptoJS encryption and java side decryption","<p>I am trying to encrypt password with cryptojs and then I will decrypt the encrypted string on server side. I added script </p>

<pre><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/aes.js""&gt;&lt;/script&gt; 
 var key=""abcdef"";
 var password = document.getElementById('password').value;
var encrypted = CryptoJS.AES.encrypt(password, key);
</code></pre>

<p>I am getting error 
ReferenceError: CryptoJS is not defined</p>

<p>Can someone tell me how can i do encryption in jsp and decrypt it on java side with key defined on jsp.
Thank you.</p>

<p>I found core library and Now I can encrypt and decrypt on Jsp </p>

<pre><code> var encryptedpassword=CryptoJS.AES.encrypt(password,'abcd');
          var ciphertext = encryptedpassword.ciphertext.toString(CryptoJS.enc.Base64);
          console.log(ciphertext);
</code></pre>

<p>and decrypted using following </p>

<pre><code>  var decryptedpassword=CryptoJS.AES.decrypt(encryptedpassword,'abcd');
          var plaintext = decryptedpassword.toString(CryptoJS.enc.Utf8);
         console.log(plaintext);
</code></pre>

<p>My problem now is I want to decrypt the encrypted password on java side can some one tell me how can I do it?</p>
","","358","<javascript><cryptojs>","1","","0","2018-01-31 05:45:32","","5","","9218729","","2018-01-31 05:45:32","2018-01-30 16:05:31",""
"38483378","How to AES decrypt data encrypted in Javascript with Python?","<p>I have a javascript code from a page that looks like</p>

<pre><code>    var link = '{""ct"":""AAQz1rUDqp849MRxu0tqGRGvPcLzVG24xa5zbYxpwVHH6Z2p95xPPzNhMIRMcaTPvijE71RQU1X3cQhtnXdRScA6UBiLWNs9vMul2gldnMTpT92sDYHl+hKBGy2dR22Un7ElToipSqeqRrwhEK8T9ROMChrBw8i7JOICpOYoVhqDB72BH2RG\/PqjRqsKittES5BVhTTY9cs+zQI0rM+FQA62bVCL57P3RD+E+aWJJLjUvoXBqct6Jc5W7li9mk9udgn9rPKkCbXSCvwIxcWS5C1kw4uSO7y0IlovaTWLAIw5nY0l4REjbC1wPWrtxDWLlr8J+\/sQdDF+P61VHz6yiC+w56QLDjVwz4kBl3r3uP\/VZ7kUuLwWHSHnbmmXv31f"",""iv"":""feae762ac889376169708872d9676319"",""s"":""9b2328e8a4ee2717""}';
    var msg = ""f12c8b59265dc1e898135211cc30be49"";    
    var finalUrl = JSON.parse(CryptoJS.AES.decrypt(link, msg, {format: CryptoJSAesJson}).toString(CryptoJS.enc.Utf8));
</code></pre>

<p>I figure that ct is encrypted msg, s is for Salt and iv is iv</p>

<p>I am trying to decode the finalUrl with python.</p>

<pre><code>    AES=AESDecrypter()
    decryptor = AES.new(s, AES.MODE_CBC, IV=iv)
    dec = decryptor.decrypt(ct)
</code></pre>

<p>I know it is not going to work as I can't figure how to use </p>

<pre><code>    var msg = ""f12c8b59265dc1e898135211cc30be49"" in Python.
</code></pre>

<p>Also figured that CryptoJSAesJson may have some extra function.
Someone please show me steps how I can retrieve the finalUrl with Python with the data given here.
Any suggestion is really appreciated. Apology for my poor coding knowledge.</p>
","","346","<javascript><python><aes><pycrypto><cryptojs>","2","","0","2016-07-21 01:14:12","","0","2","190597","","2016-07-21 01:14:12","2016-07-20 13:58:20",""
"27890943","C# equivalents for JavaScript Cryptography API functions","<p>The new Cryptography API for Javascript has these functions:</p>

<pre><code>window.crypto.subtle.sign

window.crypto.subtle.importKey
</code></pre>

<p>Please what are their equivalents in C#</p>

<p>Thanks.</p>

<p>EDIT:
I am asking for the c# equivalents of the JavaScript Cryptography functions implemented here: <a href=""http://www.w3.org/TR/WebCryptoAPI/"" rel=""nofollow"">http://www.w3.org/TR/WebCryptoAPI/</a></p>
","<p>You can find the equlivalents(most of them) residing in following namespace.</p>

<pre><code>using System.Security.Cryptography;
</code></pre>

<p>Here's a more detailed list of the available algorithms : <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography%28v=vs.110%29.aspx"" rel=""nofollow"">MSDN Reference</a></p>
","345","<c#><cryptojs>","0","4","1","2015-01-11 21:03:02","27891967","3","1","44080","","2015-01-11 21:03:02","2015-01-11 19:07:04",""
"45953260","Encrypt string in android and decrypt in node.js is not working","<p>I have to encrypt data in Android app and decrypt in Node.js.  But in web-end decryption is not working.</p>

<p>I need to Implement AES256 encryption and in web-end cryptoJS encryption library is used.  </p>

<p>This is the string to be encrypted: <code>{""email"":""jhon@gmail.com"",""device_type"":""iOS"",""password"":""123456"",""device_id"":""14105DA4-CEE5-431E-96A2-2331CDA7F062"",""device_token"":""B44777563552882EC3139A0317E401B55D6FC699D0AC3D279F392927CAF9B566""}</code></p>

<p>And result should be </p>

<pre><code>""U2FsdGVkX19hTYqle0GhmGoOK2oKGPfPXDkKsH8MdANABQROPiQ7hxnSA289rRT4fds5yZG4FX7BoTKqzV40NLIpeBoRJw6Uazax8kiKyxRYDUBPNpevD7vveDLoWekRL2cLZTV3S0gkynhL\/fKMg7BUFfT3Lt9BZeiFxYKZKD++ul5DG1isRycwG06l5ZgQJDwfyNAlRz7WbJXrevvCQPMagoCqrB4i49Mgj2ANMLFzUDyImhn9gX3PGrlzlY8xgzhg2oQfHF\/5USd5pqXswTRzVhGxUoUhNahf3pFZtbscr0AyvvE8ffF6ftRo4ZLYRt72aB9Br\/vqshXxr9VYuQ==""
</code></pre>

<p>Currenly I am using below code: </p>

<p>// Encrypt where jo is input, and query is output and ENCRPYTION_KEy is key</p>

<pre><code>String secret = ""LSC@SD2017@ps"";
        byte[] input = new byte[0];
        String query = null;
        try {
            input = cipherText1.getBytes();

            byte[] cipherData = Base64.decode(cipherText1.getBytes(), Base64.NO_WRAP);
            byte[] saltData = Arrays.copyOfRange(cipherData, 8, 16);

            MessageDigest md5 = MessageDigest.getInstance(""MD5"");

            final byte[][] keyAndIV = GenerateKeyAndIV(32, 16, 1, saltData, secret.getBytes(""UTF-8""), md5);


            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] thedigest = md.digest(secret.getBytes(""UTF-8""));
            SecretKeySpec skc = new SecretKeySpec(thedigest, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, skc);

            byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
            int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
            ctLength += cipher.doFinal(cipherText, ctLength);

             query = Base64.encodeToString(cipherText, Base64.NO_WRAP);

            System.out.println(""NEw code\n"" + query);

        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (ShortBufferException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        }
</code></pre>

<p>In iOS code is perfectly working and they are using : <a href=""https://github.com/etienne-martin/CryptoJS.swift"" rel=""nofollow noreferrer"">https://github.com/etienne-martin/CryptoJS.swift</a></p>

<p>Please help me getting same output. </p>
","","344","<java><android><encryption><aes><cryptojs>","0","","0","2017-08-30 06:19:20","","4","","","","","2017-08-30 06:19:20",""
"43233746","C# MD5 to CryptoJS and postman","<p>Hi can anyone help me on matching my c# code to cryptojs</p>

<p>heres the method </p>

<pre><code>   private string getRequestBase64content(HttpRequest req)
    {
        byte[] hash = ComputeHash(req.Body);
        var requestContentBase64String = """";
        if (hash != null)
        {
            requestContentBase64String = Convert.ToBase64String(hash);
        }

        return requestContentBase64String;
    }
</code></pre>

<p>and here is the code for computehash</p>

<pre><code>       private byte[] ComputeHash(Stream body)
    {
        using (MD5 md5 = MD5.Create())
        {
            byte[] hash = null;
            var content = ReadFully(body);
            if (content.Length != 0)
            {
                hash = md5.ComputeHash(content);
            }
            return hash;
        }
    }

    private byte[] ReadFully(Stream input)
    {
        byte[] buffer = new byte[16 * 1024];
        using (MemoryStream ms = new MemoryStream())
        {
            int read;
            while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0)
            {
                ms.Write(buffer, 0, read);
            }
            return ms.ToArray();
        }
    }
</code></pre>

<p>Im trying to match it using postman but no luck the values are different  here is my pre-request script</p>

<pre><code>var requestBody = """";
var firstpass = true;
for(var param in request.data)
{
    if(!firstpass){
        requestBody += ""&amp;"";
    }
    requestBody += param + ""="" + request.data[param];
    firstpass = false;
}

var requestContentBase64String = """";
if(requestBody){
    // MD5 hash and convert the request body string to base 64
    requestContentBase64String = CryptoJS.MD5(requestBody).toString(CryptoJS.enc.Base64);
}

postman.setGlobalVariable(""signatureContent"", requestContentBase64String);
</code></pre>

<p>BTW im using asp.net core 
Any help would be appreciated Thanks</p>
","","339","<c#><asp.net><postman><hmac><cryptojs>","1","","0","2017-04-05 14:13:05","","2","","","","","2017-04-05 14:13:05",""
"24248503","Why does encrypt, then decrypt give me a different output?","<p>In my code I encrypt some data two times. First in jQuery:</p>

<pre><code>var text = '' + CryptoJS.Rabbit.encrypt(""12345"", ""PassPhrase"");
</code></pre>

<p>then this is posted with ajax to php and encrypted again:</p>

<pre><code>function mc_encrypt($encrypt, $key){
    $encrypt = serialize($encrypt);
    $iv = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_CBC), MCRYPT_DEV_URANDOM);
    $key = pack('H*', $key);
    $mac = hash_hmac('sha256', $encrypt, substr(bin2hex($key), -32));
    $passcrypt = mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $encrypt.$mac, MCRYPT_MODE_CBC, $iv);
    $encoded = base64_encode($passcrypt).'|'.base64_encode($iv);
    return $encoded;
}
</code></pre>

<p>Afterwards, this is stored in a database. If a user wants to access the value again, I retrieve it from the database and then decrypt it:</p>

<pre><code>function mc_decrypt($decrypt, $key){
    $decrypt = explode('|', $decrypt);
    $decoded = base64_decode($decrypt[0]);
    $iv = base64_decode($decrypt[1]);
    $key = pack('H*', $key);
    $decrypted = trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, $decoded, MCRYPT_MODE_CBC, $iv));
    $mac = substr($decrypted, -64);
    $decrypted = substr($decrypted, 0, -64);
    $calcmac = hash_hmac('sha256', $decrypted, substr(bin2hex($key), -32));
    if($calcmac!==$mac){ return false; }
    $decrypted = unserialize($decrypted);
    return $decrypted;
}
</code></pre>

<p>This is then posted back to the jQuery and decrypted again:</p>

<pre><code>var text = CryptoJS.Rabbit.decrypt(text, ""PassPhrase"");
text = text.toString();
console.log(text);
</code></pre>

<p>However, the value logged in the console is quite different from the value ('12345') at the beginning. I don't know why this is happening and I've been looking at this problem for the last two days, yet I can't seem to figure out the problem...</p>
","<p>CryptoJS.Rabbit.decrypt is returning a <strong>word array</strong>, and you are calling <strong>toString</strong> on it. For ""12345"" I would guess that the result you are seeing is ""3132333435"".</p>

<p>Use CryptoJS <strong>stringify</strong>, e.g. CryptoJS.enc.Utf16.stringify(text) or CryptoJS.enc.Utf8.stringify(text), depending on the original encoding.</p>

<p>You can choose the encoding on the way in by modifying your code like this, for example:</p>

<pre><code>p = CryptoJS.enc.Utf8.parse(""12345"");
text = '' + CryptoJS.Rabbit.encrypt(p, ""PassPhrase"");
</code></pre>

<p>Then on the return trip:</p>

<pre><code>var text = CryptoJS.Rabbit.decrypt(text, ""PassPhrase"");
text = CryptoJS.enc.Utf8.stringify(text); // use same encoding as original input
console.log(text);
</code></pre>
","336","<php><jquery><encryption><cryptojs>","0","0","1","2014-06-22 01:25:01","","10","","","","","2014-06-16 16:47:45",""
"48273846","JavaScript AJAX to Coinbase API, getting ""request timestamp expired"" error using server time","<p>I've been working on some code that will call the <a href=""https://developers.coinbase.com/api/v2?ruby#list-accounts"" rel=""nofollow noreferrer"">List Accounts</a> call from the Coinbase API. I am using the <a href=""https://developers.coinbase.com/api/v2?javascript#api-key"" rel=""nofollow noreferrer"">API Key</a> to authenticate and <a href=""https://code.google.com/archive/p/crypto-js/downloads"" rel=""nofollow noreferrer"">CryptoJSv3.1.2</a> to handle the encryption. I believe that I am correctly signing my request but I haven't done a lot of encryption in JavaScript before so please double check my work.</p>

<p>The issue that I am having is that my request for accounts is being rejected and the message I'm getting back from Coinbase is <code>{""errors"":[{""id"":""authentication_error"",""message"":""request timestamp expired""}]}</code></p>

<p>I am aware the of the 30 second restriction for requests however I am using the Coinbase server time that I am getting back from the <a href=""https://developers.coinbase.com/api/v2?javascript#get-current-time"" rel=""nofollow noreferrer"">Get Current Time</a> call. Also, the total run time for both calls is &lt;1 second so my timestamp should be the current time. Any guidance would be very helpful. Thanks in advance.</p>

<p>Here is my code:</p>

<pre><code>var LOGIN_DATA = {
    Coinbase: {
        apiKey: ""XXXXXXXXXXXXXXXX"",
        apiSecret: ""XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"",
        version: ""2018-01-05""
    }
}
var Coinbase = new (function(){
    var cb = this;
    var baseURL = ""https://api.coinbase.com/v2"";

    this.listAccounts = function(){
        var start = new Date();
        var method = ""GET"";
        var url = baseURL + ""/accounts"";
        var header = buildRequestHeader(method, url);

        var accounts = connect(method, url, header);
        var finish = new Date();
        console.debug(""time elapsed: "", (finish.getTime() - start.getTime()))
        return accounts;
    }

    function buildRequestHeader(method, url, data){
        var timeStamp = getServerTime();
        console.debug(""timeStamp: "", timeStamp)
        var header = {
            ""CB-ACCESS-KEY"": LOGIN_DATA.Coinbase.apiKey,
            ""CB-ACCESS-SIGN"": buildSignature(timeStamp, method, url, data),
            ""CB-ACCESS-TIMESTAMP"": timeStamp
        }
        console.debug(""header: "", header);
        return header;
    }

    function buildSignature(timeStamp, method, requestPath, data){
        var message = timeStamp + method.toUpperCase() + requestPath + (data == null ? """" : data)
        console.debug(""signature message: "", message);
        var hash = CryptoJS.HmacSHA256(message, LOGIN_DATA.Coinbase.apiSecret);
        var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);

        return hashInBase64
    }

    function getServerTime(){
        var method = ""GET""
        var url = baseURL + ""/time"";
        var onSuccess = function(data){
            return (new Date(data.data.iso)).getTime();
        }

        return connect(method, url, null, null, onSuccess);
    }

    function connect(method, url, header, data, onSuccess, onError){
        var rtn = null;
        header = (header == null ? {} : header)
        data = (data === null ? {} : data)
        if(header[""CB-VERSION""] === undefined){
            header[""CB-VERSION""] = LOGIN_DATA.Coinbase.version
        }
        console.debug(""final header: "", header);
        console.debug(""final data: "", data);
        $.ajax({
            url: url,
            type: method,
            async: false,
            timeout: 5000,
            data: data,
            beforeSend: function(xhr) {
                for(var key in header){
                    xhr.setRequestHeader(key, header[key]);
                }
            },
            success: function(data, textStatus, jqXHR) {
                console.log(""Coinbase connect successful: "", data);
                if(!onSuccess){
                    onSuccess = function(data){ return data; }
                }
                rtn = onSuccess(data, textStatus, jqXHR);
            },
            error: function(jqXHR, textStatus, errorThrown) {
                console.error(""Coinbase connect failed: "", textStatus, errorThrown, jqXHR);
                if(onError){
                    rtn = onError(jqXHR, textStatus, errorThrown);
                }
            }
        });

        return rtn;
    }
});
</code></pre>

<p>Also here is a screenshot of my console log statements incase they help:
<a href=""https://i.stack.imgur.com/QgCJd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/QgCJd.png"" alt=""Chrome Console""></a></p>
","<p>Quoting the <a href=""https://developers.coinbase.com/api/v2?javascript#api-key"" rel=""nofollow noreferrer"">Coinbase API</a>:</p>

<blockquote>
  <p>The CB-ACCESS-TIMESTAMP header MUST be number of seconds since Unix Epoch.</p>
</blockquote>

<p>Your timestamp is in milliseconds, not seconds.</p>

<p>If I'm not mistaken the signature should be encoded in hex, not base64 (<a href=""https://developers.coinbase.com/docs/wallet/api-key-authentication"" rel=""nofollow noreferrer"">source</a>):</p>

<pre><code>var hash = CryptoJS.HmacSHA256(message, LOGIN_DATA.Coinbase.apiSecret);
var hexDigest = hash.toString(CryptoJS.enc.Hex)
</code></pre>
","329","<javascript><cryptojs><coinbase-api>","0","1","1","2018-01-16 21:10:35","","0","1","1824363","","2018-01-16 14:51:24","2018-01-16 03:52:23",""
"55226500","""Minimal"" AES in CryptoJS sample not working","<p>I have the following ""minimal"" AES test page:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=""core.js""&gt;&lt;/script&gt;
&lt;script src=""cipher-core.js""&gt;&lt;/script&gt;
&lt;script src=""enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""enc-utf8.js""&gt;&lt;/script&gt;
&lt;script src=""aes.js""&gt;&lt;/script&gt;

&lt;script type=""text/javascript""&gt;
    function test_aes ()
    {
        var ciphertext = ""0f71bc632c6aa13da599f310a54f0d280bcea1cbd96bbd214c5c3f9be7694de96755779a957416e8d8b1ebb635ad5f40"";
        var key = ""0123456789abcdef"";
        document.getElementById(""output"").innerHTML = 
            CryptoJS.AES.decrypt(ciphertext,key).toString(CryptoJS.enc.Utf8);
    }
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;AES Test&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Decrypted:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output""&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;input type=""submit"" value="" Go! "" onclick=""test_aes();""/&gt;&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>I'm using the CryptoJS 3.1.9-1 files downloaded from <a href=""https://cdnjs.com/libraries/crypto-js/3.1.9-1"" rel=""nofollow noreferrer"">https://cdnjs.com/libraries/crypto-js/3.1.9-1</a> (which in turn points to Cloudfare's downloads --- e.g., <a href=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.js"" rel=""nofollow noreferrer"">https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/core.js</a>, <a href=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/aes.js"" rel=""nofollow noreferrer"">https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/aes.js</a>, etc.)</p>

<p>All of the included files are present  (I do Right-Click  View Source, then individually click on each of the <code>.js</code> files, and I see them).</p>

<p>If I run it exactly as above, I get error:</p>

<pre><code>TypeError: Base64 is undefined
</code></pre>

<p>at cipher-core.js, line 619.</p>

<p>In addition to why does it not work, I have a general question about AES in CryptoJS: where is the mode of operation (CBC, etc.), the block size (AES-128, 192, 256), and the initialization vector?  (I guess that CrytpoJS.AES invokes some default).  Please clarify, or point me to any documentation (which I can't seem to find).</p>
","<p>The problem with your code is the decrypt function takes input as object not the only string. </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=""aes.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
    function test_aes()
    {
		var plaintext = (""0f71bc632c6aa13da599f310a54f0d280bcea1cbd96bbd214c5c3f9be7694de96755779a957416e8d8b1ebb635ad5f40"");
        var key = (""0123456789abcdef"");
		var output = CryptoJS.AES.encrypt(plaintext,key);
		var original = CryptoJS.AES.decrypt(output,key);
		document.getElementById(""output1"").innerHTML = plaintext;
		document.getElementById(""output2"").innerHTML = output.ciphertext;
		document.getElementById(""output3"").innerHTML = original.toString(CryptoJS.enc.Utf8);
    }
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;AES Test&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Plaintext:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output1""&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Encrypted:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output2""&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decrypted:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output3""&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;input type=""submit"" value="" Go! "" onclick=""test_aes();""/&gt;&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>In above code, you can see output.ciphertext attribute is displayed only but object is passed.
Since I have used cryptoJS earlier for my college project, that AES.js file is used by me. that file is giving me correct output. Maybe there's problem in aes.js file.
Here aes.js file that I used.
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&amp;&amp;c.mixIn(a);c.hasOwnProperty(""init"")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&amp;&amp;(this[c]=a[c]);a.hasOwnProperty(""toString"")&amp;&amp;(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k&lt;a;k++)c[j+k&gt;&gt;&gt;2]|=(e[k&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(k%4)&amp;255)&lt;&lt;24-8*((j+k)%4);else if(65535&lt;e.length)for(k=0;k&lt;a;k+=4)c[j+k&gt;&gt;&gt;2]=e[k&gt;&gt;&gt;2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c&gt;&gt;&gt;2]&amp;=4294967295&lt;&lt;
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e&lt;a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j&lt;a;j++){var k=c[j&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(j%4)&amp;255;e.push((k&gt;&gt;&gt;4).toString(16));e.push((k&amp;15).toString(16))}return e.join("""")},parse:function(a){for(var c=a.length,e=[],j=0;j&lt;c;j+=2)e[j&gt;&gt;&gt;3]|=parseInt(a.substr(j,
2),16)&lt;&lt;24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j&lt;a;j++)e.push(String.fromCharCode(c[j&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(j%4)&amp;255));return e.join("""")},parse:function(a){for(var c=a.length,e=[],j=0;j&lt;c;j++)e[j&gt;&gt;&gt;2]|=(a.charCodeAt(j)&amp;255)&lt;&lt;24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error(""Malformed UTF-8 data"");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){""string""==typeof a&amp;&amp;(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q&lt;a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&amp;&amp;this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r&lt;p;r+=3)for(var w=(l[r&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*(r%4)&amp;255)&lt;&lt;16|(l[r+1&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*((r+1)%4)&amp;255)&lt;&lt;8|l[r+2&gt;&gt;&gt;2]&gt;&gt;&gt;24-8*((r+2)%4)&amp;255,v=0;4&gt;v&amp;&amp;r+0.75*v&lt;p;v++)d.push(t.charAt(w&gt;&gt;&gt;6*(3-v)&amp;63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("""")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&amp;&amp;(t=d.indexOf(t),-1!=t&amp;&amp;(l=t));for(var t=[],r=0,w=0;w&lt;
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))&lt;&lt;2*(w%4),b=s.indexOf(d.charAt(w))&gt;&gt;&gt;6-2*(w%4);t[r&gt;&gt;&gt;2]|=(v|b)&lt;&lt;24-8*(r%4);r++}return p.create(t,r)},_map:""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=""}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&amp;a|~n&amp;c)+e+k;return(b&lt;&lt;j|b&gt;&gt;&gt;32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&amp;c|a&amp;~c)+e+k;return(b&lt;&lt;j|b&gt;&gt;&gt;32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b&lt;&lt;j|b&gt;&gt;&gt;32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b&lt;&lt;j|b&gt;&gt;&gt;32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64&gt;x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16&gt;a;a++){var c=n+a,e=q[c];q[c]=(e&lt;&lt;8|e&gt;&gt;&gt;24)&amp;16711935|(e&lt;&lt;24|e&gt;&gt;&gt;8)&amp;4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c&gt;&gt;&gt;5]|=128&lt;&lt;24-c%32;var e=u.floor(a/
4294967296);n[(c+64&gt;&gt;&gt;9&lt;&lt;4)+15]=(e&lt;&lt;8|e&gt;&gt;&gt;24)&amp;16711935|(e&lt;&lt;24|e&gt;&gt;&gt;8)&amp;4278255360;n[(c+64&gt;&gt;&gt;9&lt;&lt;4)+14]=(a&lt;&lt;8|a&gt;&gt;&gt;24)&amp;16711935|(a&lt;&lt;24|a&gt;&gt;&gt;8)&amp;4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4&gt;a;a++)c=n[a],n[a]=(c&lt;&lt;8|c&gt;&gt;&gt;24)&amp;16711935|(c&lt;&lt;24|c&gt;&gt;&gt;8)&amp;4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length&lt;q;){n&amp;&amp;s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a&lt;p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&amp;&amp;this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return(""string""==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return(""string""==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d&lt;b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c&lt;&lt;24|c&lt;&lt;16|c&lt;&lt;8|c,l=[],n=0;n&lt;c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1&gt;&gt;&gt;2]&amp;255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&amp;&amp;b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&amp;&amp;1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return""string""==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256&gt;c;c++)a[c]=128&gt;c?c&lt;&lt;1:c&lt;&lt;1^283;for(var e=0,j=0,c=0;256&gt;c;c++){var k=j^j&lt;&lt;1^j&lt;&lt;2^j&lt;&lt;3^j&lt;&lt;4,k=k&gt;&gt;&gt;8^k&amp;255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y&lt;&lt;24|y&gt;&gt;&gt;8;r[e]=y&lt;&lt;16|y&gt;&gt;&gt;16;w[e]=y&lt;&lt;8|y&gt;&gt;&gt;24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y&lt;&lt;24|y&gt;&gt;&gt;8;x[k]=y&lt;&lt;16|y&gt;&gt;&gt;16;q[k]=y&lt;&lt;8|y&gt;&gt;&gt;24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j&lt;a;j++)if(j&lt;d)e[j]=c[j];else{var k=e[j-1];j%d?6&lt;d&amp;&amp;4==j%d&amp;&amp;(k=l[k&gt;&gt;&gt;24]&lt;&lt;24|l[k&gt;&gt;&gt;16&amp;255]&lt;&lt;16|l[k&gt;&gt;&gt;8&amp;255]&lt;&lt;8|l[k&amp;255]):(k=k&lt;&lt;8|k&gt;&gt;&gt;24,k=l[k&gt;&gt;&gt;24]&lt;&lt;24|l[k&gt;&gt;&gt;16&amp;255]&lt;&lt;16|l[k&gt;&gt;&gt;8&amp;255]&lt;&lt;8|l[k&amp;255],k^=H[j/d|0]&lt;&lt;24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d&lt;a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4&gt;d||4&gt;=j?k:b[l[k&gt;&gt;&gt;24]]^x[l[k&gt;&gt;&gt;16&amp;255]]^q[l[k&gt;&gt;&gt;
8&amp;255]]^n[l[k&amp;255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r&lt;m;r++)var q=d[g&gt;&gt;&gt;24]^e[h&gt;&gt;&gt;16&amp;255]^j[k&gt;&gt;&gt;8&amp;255]^l[n&amp;255]^c[p++],s=d[h&gt;&gt;&gt;24]^e[k&gt;&gt;&gt;16&amp;255]^j[n&gt;&gt;&gt;8&amp;255]^l[g&amp;255]^c[p++],t=
d[k&gt;&gt;&gt;24]^e[n&gt;&gt;&gt;16&amp;255]^j[g&gt;&gt;&gt;8&amp;255]^l[h&amp;255]^c[p++],n=d[n&gt;&gt;&gt;24]^e[g&gt;&gt;&gt;16&amp;255]^j[h&gt;&gt;&gt;8&amp;255]^l[k&amp;255]^c[p++],g=q,h=s,k=t;q=(f[g&gt;&gt;&gt;24]&lt;&lt;24|f[h&gt;&gt;&gt;16&amp;255]&lt;&lt;16|f[k&gt;&gt;&gt;8&amp;255]&lt;&lt;8|f[n&amp;255])^c[p++];s=(f[h&gt;&gt;&gt;24]&lt;&lt;24|f[k&gt;&gt;&gt;16&amp;255]&lt;&lt;16|f[n&gt;&gt;&gt;8&amp;255]&lt;&lt;8|f[g&amp;255])^c[p++];t=(f[k&gt;&gt;&gt;24]&lt;&lt;24|f[n&gt;&gt;&gt;16&amp;255]&lt;&lt;16|f[g&gt;&gt;&gt;8&amp;255]&lt;&lt;8|f[h&amp;255])^c[p++];n=(f[n&gt;&gt;&gt;24]&lt;&lt;24|f[g&gt;&gt;&gt;16&amp;255]&lt;&lt;16|f[h&gt;&gt;&gt;8&amp;255]&lt;&lt;8|f[k&amp;255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();</code></pre>
</div>
</div>
</p>

<p>And the questions you have asked maybe </p>

<p><a href=""https://cryptojs.gitbook.io/docs/#ciphers"" rel=""nofollow noreferrer"">this link can help</a></p>

<p>Hope this helps!!</p>

<p>Updated code:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=""aes.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
    function test_aes()
    {
		var plaintext = ""0f71bc632c6aa13da599f310a54f0d280bcea1cbd96bbd214c5c3f9be7694de96755779a957416e8d8b1ebb635ad5f4"";
        var key = ""0123456789abcdef"";
		var parameters = CryptoJS.lib.CipherParams.create({ciphertext : (plaintext)});
		var original = CryptoJS.AES.decrypt(parameters,key,{iv:key, mode: CryptoJS.mode.CBC});
		document.getElementById(""output1"").innerHTML = plaintext;
		document.getElementById(""output2"").innerHTML = parameters.ciphertext;
		document.getElementById(""output3"").innerHTML = original.toString();
    }
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;AES Test&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Plaintext:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output1""&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paramete.ciphertext:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output2""&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Decrypted:&lt;/strong&gt;&amp;nbsp;&lt;span id=""output3""&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;input type=""submit"" value="" Go! "" onclick=""test_aes();""/&gt;&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://i.stack.imgur.com/qIkBt.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/qIkBt.png"" alt=""output""></a></p>
","327","<javascript><aes><cryptojs>","0","1","1","2019-03-24 15:44:37","","7","","","","","2019-03-18 17:02:12",""
"32711322","SHA1 calculation returns wrong value","<p>I am trying to calculate SHA1 value of a file using javascript.
The file is located on the same directory as index.html and it is loaded using ajax by the name given as a query param.</p>

<p>for example, calling <a href=""http://localhost:7070/index.html?file=file.zip"" rel=""nofollow"">http://localhost:7070/index.html?file=file.zip</a> should calculate SHA1 for file.zip</p>

<p>The following code calculates SHA1 <strong>but the result is different</strong> than what i get using this online tool with SHA1 and uploading the file <a href=""http://onlinemd5.com/"" rel=""nofollow"">http://onlinemd5.com/</a></p>

<pre><code>$(document).ready(function(){
   var file = utils.getUrlVars() &amp;&amp; utils.getUrlVars().file;

   if (!file) throw ""error - no URL was found. set 'file' in query string."";

   $.ajax({

       url: file,
       success: function(data){
           var sha1= CryptoJS.SHA1(data).toString();
           console.log('sha1 - success', sha1);
       },
       error: function(error){
           console.log('ERROR');
       }

   })
});
</code></pre>

<p>What is the difference? i guess that the online tool calculates it right (and it also gives me the exact result i get when calculating using Java code), so something in this JS code does it slightly different.</p>

<p>The problem is definitely not in the CryptoJS package since when calculating the string 'hello' using the script generates the following output:</p>

<pre><code>sha1 - success aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
</code></pre>

<p>And using the online tool you get the same (in uppercase):</p>

<pre><code>AAF4C61DDCC5E8A2DABEDE0F3B482CD9AEA9434D
</code></pre>

<p>The problem is definitely in the format of the data after loading it or the way of using it.</p>

<p>When i use Java to calculate SHA1 i get the same result by calculating it on the files byte array, so it points to the fact that the bytearray i get using this script is somehow different / partial.</p>
","<p>According to <a href=""https://api.jquery.com/jQuery.ajax/"" rel=""nofollow"">the manual for .ajax</a> you need to set the <code>dataType</code> option to <code>text</code>, otherwise it will try to guess the type and then <code>text</code> is never an option.</p>
","326","<javascript><ajax><sha1><cryptojs>","1","0","2","2015-10-06 05:10:12","32962150","13","","1254238","","2015-09-24 05:09:14","2015-09-22 07:52:16",""
"32711322","SHA1 calculation returns wrong value","<p>I am trying to calculate SHA1 value of a file using javascript.
The file is located on the same directory as index.html and it is loaded using ajax by the name given as a query param.</p>

<p>for example, calling <a href=""http://localhost:7070/index.html?file=file.zip"" rel=""nofollow"">http://localhost:7070/index.html?file=file.zip</a> should calculate SHA1 for file.zip</p>

<p>The following code calculates SHA1 <strong>but the result is different</strong> than what i get using this online tool with SHA1 and uploading the file <a href=""http://onlinemd5.com/"" rel=""nofollow"">http://onlinemd5.com/</a></p>

<pre><code>$(document).ready(function(){
   var file = utils.getUrlVars() &amp;&amp; utils.getUrlVars().file;

   if (!file) throw ""error - no URL was found. set 'file' in query string."";

   $.ajax({

       url: file,
       success: function(data){
           var sha1= CryptoJS.SHA1(data).toString();
           console.log('sha1 - success', sha1);
       },
       error: function(error){
           console.log('ERROR');
       }

   })
});
</code></pre>

<p>What is the difference? i guess that the online tool calculates it right (and it also gives me the exact result i get when calculating using Java code), so something in this JS code does it slightly different.</p>

<p>The problem is definitely not in the CryptoJS package since when calculating the string 'hello' using the script generates the following output:</p>

<pre><code>sha1 - success aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d
</code></pre>

<p>And using the online tool you get the same (in uppercase):</p>

<pre><code>AAF4C61DDCC5E8A2DABEDE0F3B482CD9AEA9434D
</code></pre>

<p>The problem is definitely in the format of the data after loading it or the way of using it.</p>

<p>When i use Java to calculate SHA1 i get the same result by calculating it on the files byte array, so it points to the fact that the bytearray i get using this script is somehow different / partial.</p>
","<p>We managed to solve this eventually, the solution is pure JS with no Ajax involved:</p>

<pre><code>$(document).ready(function(){

var url = utils.getUrlVars() &amp;&amp; utils.getUrlVars().url;

if (!url) throw ""error - no URL was found. set 'url' in query string."";

var oReq = new XMLHttpRequest();
oReq.open(""GET"", url, true);
oReq.responseType = ""blob"";

oReq.onreadystatechange = function(e) {

    if (oReq.readyState == 4 &amp;&amp; oReq.status == 200) {
        console.log('xhr success');
        success(e);
    } else if (oReq.readyState == 4 &amp;&amp; oReq.status != 200){
        console.log('xhr error');
        error(e);
    }
}

var success = function() {
    var blob = oReq.response; 
    var sha1 = CryptoJS.algo.SHA1.create(); 
    var reader = new FileReader();
    reader.readAsArrayBuffer(blob);

    reader.onload = function(e) {
        var arrbuffer = e.target.result.slice(0, e.target.result.byteLength);
        var bytes = CryptoJS.enc.u8array.parse(new Uint8Array(arrbuffer));
        sha1.update(bytes);
        var sha1res = sha1.finalize().toString(CryptoJS.enc.Hex);
        // print results
        console.log('sha1 - success', sha1res);
    }
};

var error = function(){
    IJavaScriptImplementer.onError(JSON.stringify(error));
    IJavaScriptImplementer.log(JSON.stringify(error));
}

oReq.send(null);
});
</code></pre>

<p>As you cam see, the file is requested as a blob and is being read as one slice (you can also do it slice by slice but in my case the files are small), then the bytes are read and calculated into the SHA1 value.</p>
","326","<javascript><ajax><sha1><cryptojs>","1","0","2","2015-10-06 05:10:12","32962150","13","","1254238","","2015-09-24 05:09:14","2015-09-22 07:52:16",""
"44973478","providing values to Crypto-js","<p>I've got CyryptoJs working (as a service), but I don't think I'm observing best practices with it.</p>

<pre><code>import { Injectable } from '@angular/core';
import * as CryptoJS from ""crypto-js"";

@Injectable()
export class EncryptionService {

    constructor() {
    }

    secretKey: string = ""fnord"";

    encrypt(jsonObj) {
        return CryptoJS.AES.encrypt(JSON.stringify(jsonObj), this.secretKey);
    }

    decrypt(data) {
        if (data !==null &amp;&amp; data.length &gt; 0) {
            var bytes = CryptoJS.AES.decrypt(data.toString(), this.secretKey);
            return bytes.toString(CryptoJS.enc.Utf8);
        } else {
            return """";
        }
    }
}
</code></pre>

<p><strong>secretKey</strong> should probably not be exposed like that. What would be a smart way to deliver that value?</p>
","<p>There are a few security issues.</p>

<ol>
<li><p>The encryption key needs to be unique for each user.</p></li>
<li><p>Use a full length key: 128, 192 or 256 bits for AES.</p></li>
<li><p>It is best to use a full length encryption key of random bytes obtained from a CSPRNG (Cryptographically Secure Random Number Generator).</p></li>
<li><p>Using a string for the key, especially a short one is not secure. If you need the user to enter a password use a key derivation function such as PBKDF2 (Password Based Key Derivation Function 2) function to derive a secure encryption key.</p></li>
<li><p>There needs to an IV (Initialization Vector) supplied and it needs to be a random byte array from a CSPRNG unique for each encryption. Just prefix the encrypted data with the IV for use during decryption, it does not need to be secret.</p></li>
<li><p>It is best to fully specify all encryptions parameters such as mode and padding for interoperability.</p></li>
<li><p>If there is the possibility of entering an incorrect key or an attacker replacing a file add encryption authentication.</p></li>
<li><p>Add a version indicator to the encrypted data so changes can be made in the future if necessary.</p></li>
<li><p>Finally, how are you going to store the encryption key, there is no easy answer to that.</p></li>
</ol>
","326","<angularjs><cryptojs>","0","0","1","2017-07-07 15:44:52","","2","","","","","2017-07-07 14:35:52",""
"27174971","How to decrypt a field sent from client to Node server using CryptoJS?","<p>I am trying to adapt the following solution into my Node application to decrypt a field sent from the client browser via POST: </p>

<p><a href=""https://stackoverflow.com/questions/27171390/how-to-decrypt-with-cryptojs-using-aes"">How to decrypt with CryptoJS using AES?</a></p>

<p>Seem to be going round in circles in getting values to match in the console. The values for the encryption of 'hello' match both applied from Server and from client (sending 'hello' however there is now no decryption value showing for either. </p>

<p>The server side code in a Node POST Route:</p>

<pre><code>var ENC_KEY = ""c2VjcmV0""; //'secret'
app.post('/hello', function (req, res) {
    console.log('POST /hello');

    var key = CryptoJS.enc.Base64.parse(ENC_KEY);

    console.log('key: ' + key);


    console.log('client msg (""hello""): ' + req.body.msg_hello);

    var encrypted = CryptoJS.AES.encrypt(""hello"", key, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    console.log('server msg ""hello"" encrypted to: ' + encrypted);

    var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    console.log('server msg decrypted: ' + hex2a(decrypted));

    var decryptedClient = CryptoJS.AES.decrypt(req.body.msg_hello, key, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });



    console.log('client msg decrypted: ' + hex2a(decryptedClient));

    res.end(JSON.stringify('{ response: ""response"" }'));
});
</code></pre>

<p>Any help appreciated!</p>
","","324","<javascript><node.js><encryption><aes><cryptojs>","0","","0","2014-11-27 16:44:52","","6","","-1","","2017-05-23 12:12:46","2014-11-27 16:19:15",""
"53769391","AES encryption in JS equivalent of C#","<p>I need to encrypt a string using AES encryption. This encryption was happening in C# earlier, but it needs to be converted into JavaScript (will be run on a browser). </p>

<p>The current code in C# for encryption is as following - </p>

<pre><code>public static string EncryptString(string plainText, string encryptionKey)
{
    byte[] clearBytes = Encoding.Unicode.GetBytes(plainText);

    using (Aes encryptor = Aes.Create())

    {
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(encryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
        encryptor.Key = pdb.GetBytes(32);
        encryptor.IV = pdb.GetBytes(16);
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))

            {
                cs.Write(clearBytes, 0, clearBytes.Length);
                cs.Close();
            }
            plainText = Convert.ToBase64String(ms.ToArray());
        }
    }
    return plainText;
}
</code></pre>

<p>I have tried to use CryptoJS to replicate the same functionality, but it's not giving me the equivalent encrypted base64 string. Here's my CryptoJS code - </p>

<pre><code>function encryptString(encryptString, secretKey) {
    var iv = CryptoJS.enc.Hex.parse('Ivan Medvedev');
    var key = CryptoJS.PBKDF2(secretKey, iv, { keySize: 256 / 32, iterations: 500 });

    var encrypted = CryptoJS.AES.encrypt(encryptString, key,{iv:iv);
    return encrypted;
}
</code></pre>

<p>The encrypted string has to be sent to a server which will be able to decrypt it. The server is able to decrypt the encrypted string generated from the C# code, but not the encrypted string generated from JS code. I tried to compare the encrypted strings generated by both the code and found that the C# code is generating longer encrypted strings. For example keeping 'Example String' as plainText and 'Example Key' as the key, I get the following result - </p>

<pre><code>C# - eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=
JS - 9ex5i2g+8iUCwdwN92SF+A==
</code></pre>

<p>The length of JS encrypted string is always shorter than the C# one. Is there something I am doing wrong? I just have to replicated the C# code into the JS code.</p>

<p><strong>Update:</strong><br>
My current code after <a href=""https://stackoverflow.com/a/53784853/1079901"">Zergatul's answer</a> is this - </p>

<pre><code>function encryptString(encryptString, secretKey) {
    var keyBytes = CryptoJS.PBKDF2(secretKey, 'Ivan Medvedev', { keySize: 48 / 4, iterations: 1000 });
    console.log(keyBytes.toString());

    // take first 32 bytes as key (like in C# code)
    var key = new CryptoJS.lib.WordArray.init(keyBytes.words, 32);
    // skip first 32 bytes and take next 16 bytes as IV
    var iv = new CryptoJS.lib.WordArray.init(keyBytes.words.splice(32 / 4), 16);

    console.log(key.toString());
    console.log(iv.toString());

    var encrypted = CryptoJS.AES.encrypt(encryptString, key, { iv: iv });
    return encrypted;
}
</code></pre>

<p>As illustrated in his/her answer that if the C# code converts the plainText into bytes using ASCII instead of Unicode, both the C# and JS code will produce exact results. But since I am not able to modify the decryption code, I have to convert the code to be equivalent of the original C# code which was using Unicode.</p>

<p>So, I tried to see, what's the difference between both the bytes array between ASCII and Unicode byte conversion in C#. Here's what I found - </p>

<pre><code>ASCII Byte Array: [69,120,97,109,112,108,101,32,83,116, 114, 105, 110, 103]
Unicode Byte Array: [69,0,120,0,97,0,109,0,112,0,108,0,101,0,32,0,83,0,116,0, 114,0, 105,0, 110,0, 103,0]
</code></pre>

<p>So some extra bytes are available for each character in C# (So Unicode allocates twice as much bytes to each character than ASCII).</p>

<p>Here's the difference between both Unicode and ASCII conversion respectively - </p>

<pre><code>ASCII
clearBytes: [69,120,97,109,112,108,101,32,83,116,114,105,110,103,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eQus9GLPKULh9vhRWOJjog==

Unicode:
clearBytes: [69,0,120,0,97,0,109,0,112,0,108,0,101,0,32,0,83,0,116,0,114,0,105,0,110,0,103,0,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=
</code></pre>

<p>So since both the key and iv being generated have exact same byte array in both Unicode and ASCII approach, it should not have generated different output, but somehow it's doing that. I think it's because of clearBytes' length, as it's using its length to write to CryptoStream.</p>

<p>I tried to see what's the output of the generated bytes in the JS code is and found that it uses words which needed to be converted into Strings using <code>toString()</code> method.  </p>

<pre><code>keyBytes: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d654a2eb12ee944fc53a9d30df93d76a7
key: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d
iv: 654a2eb12ee944fc53a9d30df93d76a7
</code></pre>

<p>Since, I am not able to affect the generated encrypted string's length in the JS code (No access to the write stream directly), thus still stuck here.</p>
","<p>Here is the example how to reproduce the same ciphertext between <code>C#</code> and <code>CryptoJS</code>:</p>

<pre><code>static void Main(string[] args)
{
    byte[] plainText = Encoding.Unicode.GetBytes(""Example String""); // this is UTF-16 LE
    string cipherText;
    using (Aes encryptor = Aes.Create())
    {
        var pdb = new Rfc2898DeriveBytes(""Example Key"", Encoding.ASCII.GetBytes(""Ivan Medvedev""));
        encryptor.Key = pdb.GetBytes(32);
        encryptor.IV = pdb.GetBytes(16);
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(plainText, 0, plainText.Length);
                cs.Close();
            }
            cipherText = Convert.ToBase64String(ms.ToArray());
        }
    }

    Console.WriteLine(cipherText);
}
</code></pre>

<p>And JS:</p>

<pre><code>var keyBytes = CryptoJS.PBKDF2('Example Key', 'Ivan Medvedev', { keySize: 48 / 4, iterations: 1000 });
// take first 32 bytes as key (like in C# code)
var key = new CryptoJS.lib.WordArray.init(keyBytes.words, 32);
// skip first 32 bytes and take next 16 bytes as IV
var iv = new CryptoJS.lib.WordArray.init(keyBytes.words.splice(32 / 4), 16);
// use the same encoding as in C# code, to convert string into bytes
var data = CryptoJS.enc.Utf16LE.parse(""Example String"");
var encrypted = CryptoJS.AES.encrypt(data, key, { iv: iv });
console.log(encrypted.toString());
</code></pre>

<p>Both codes return: <code>eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=</code></p>
","323","<javascript><c#><encryption><aes><cryptojs>","3","3","2","2018-12-15 14:28:30","53784853","3","0","1079901","","2018-12-14 22:43:38","2018-12-13 20:12:22",""
"53769391","AES encryption in JS equivalent of C#","<p>I need to encrypt a string using AES encryption. This encryption was happening in C# earlier, but it needs to be converted into JavaScript (will be run on a browser). </p>

<p>The current code in C# for encryption is as following - </p>

<pre><code>public static string EncryptString(string plainText, string encryptionKey)
{
    byte[] clearBytes = Encoding.Unicode.GetBytes(plainText);

    using (Aes encryptor = Aes.Create())

    {
        Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(encryptionKey, new byte[] { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 });
        encryptor.Key = pdb.GetBytes(32);
        encryptor.IV = pdb.GetBytes(16);
        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, encryptor.CreateEncryptor(), CryptoStreamMode.Write))

            {
                cs.Write(clearBytes, 0, clearBytes.Length);
                cs.Close();
            }
            plainText = Convert.ToBase64String(ms.ToArray());
        }
    }
    return plainText;
}
</code></pre>

<p>I have tried to use CryptoJS to replicate the same functionality, but it's not giving me the equivalent encrypted base64 string. Here's my CryptoJS code - </p>

<pre><code>function encryptString(encryptString, secretKey) {
    var iv = CryptoJS.enc.Hex.parse('Ivan Medvedev');
    var key = CryptoJS.PBKDF2(secretKey, iv, { keySize: 256 / 32, iterations: 500 });

    var encrypted = CryptoJS.AES.encrypt(encryptString, key,{iv:iv);
    return encrypted;
}
</code></pre>

<p>The encrypted string has to be sent to a server which will be able to decrypt it. The server is able to decrypt the encrypted string generated from the C# code, but not the encrypted string generated from JS code. I tried to compare the encrypted strings generated by both the code and found that the C# code is generating longer encrypted strings. For example keeping 'Example String' as plainText and 'Example Key' as the key, I get the following result - </p>

<pre><code>C# - eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=
JS - 9ex5i2g+8iUCwdwN92SF+A==
</code></pre>

<p>The length of JS encrypted string is always shorter than the C# one. Is there something I am doing wrong? I just have to replicated the C# code into the JS code.</p>

<p><strong>Update:</strong><br>
My current code after <a href=""https://stackoverflow.com/a/53784853/1079901"">Zergatul's answer</a> is this - </p>

<pre><code>function encryptString(encryptString, secretKey) {
    var keyBytes = CryptoJS.PBKDF2(secretKey, 'Ivan Medvedev', { keySize: 48 / 4, iterations: 1000 });
    console.log(keyBytes.toString());

    // take first 32 bytes as key (like in C# code)
    var key = new CryptoJS.lib.WordArray.init(keyBytes.words, 32);
    // skip first 32 bytes and take next 16 bytes as IV
    var iv = new CryptoJS.lib.WordArray.init(keyBytes.words.splice(32 / 4), 16);

    console.log(key.toString());
    console.log(iv.toString());

    var encrypted = CryptoJS.AES.encrypt(encryptString, key, { iv: iv });
    return encrypted;
}
</code></pre>

<p>As illustrated in his/her answer that if the C# code converts the plainText into bytes using ASCII instead of Unicode, both the C# and JS code will produce exact results. But since I am not able to modify the decryption code, I have to convert the code to be equivalent of the original C# code which was using Unicode.</p>

<p>So, I tried to see, what's the difference between both the bytes array between ASCII and Unicode byte conversion in C#. Here's what I found - </p>

<pre><code>ASCII Byte Array: [69,120,97,109,112,108,101,32,83,116, 114, 105, 110, 103]
Unicode Byte Array: [69,0,120,0,97,0,109,0,112,0,108,0,101,0,32,0,83,0,116,0, 114,0, 105,0, 110,0, 103,0]
</code></pre>

<p>So some extra bytes are available for each character in C# (So Unicode allocates twice as much bytes to each character than ASCII).</p>

<p>Here's the difference between both Unicode and ASCII conversion respectively - </p>

<pre><code>ASCII
clearBytes: [69,120,97,109,112,108,101,32,83,116,114,105,110,103,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eQus9GLPKULh9vhRWOJjog==

Unicode:
clearBytes: [69,0,120,0,97,0,109,0,112,0,108,0,101,0,32,0,83,0,116,0,114,0,105,0,110,0,103,0,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=
</code></pre>

<p>So since both the key and iv being generated have exact same byte array in both Unicode and ASCII approach, it should not have generated different output, but somehow it's doing that. I think it's because of clearBytes' length, as it's using its length to write to CryptoStream.</p>

<p>I tried to see what's the output of the generated bytes in the JS code is and found that it uses words which needed to be converted into Strings using <code>toString()</code> method.  </p>

<pre><code>keyBytes: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d654a2eb12ee944fc53a9d30df93d76a7
key: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d
iv: 654a2eb12ee944fc53a9d30df93d76a7
</code></pre>

<p>Since, I am not able to affect the generated encrypted string's length in the JS code (No access to the write stream directly), thus still stuck here.</p>
","<p><strong>TL;DR</strong> the final code looks like this - </p>

<pre><code>function encryptString(encryptString, secretKey) {
    encryptString = addExtraByteToChars(encryptString);
    var keyBytes = CryptoJS.PBKDF2(secretKey, 'Ivan Medvedev', { keySize: 48 / 4, iterations: 1000 });
    console.log(keyBytes.toString());
    var key = new CryptoJS.lib.WordArray.init(keyBytes.words, 32);
    var iv = new CryptoJS.lib.WordArray.init(keyBytes.words.splice(32 / 4), 16);
    var encrypted = CryptoJS.AES.encrypt(encryptString, key, { iv: iv, });
    return encrypted;
}

function addExtraByteToChars(str) {
    let strResult = '';
    for (var i = 0; i &lt; str.length; ++i) {
        strResult += str.charAt(i) + String.fromCharCode(0);
    }
    return strResult;
}
</code></pre>

<p><strong>Explanation:</strong> </p>

<p>The C# code in the <a href=""https://stackoverflow.com/a/53784853/1079901"">Zergatul's answer</a> (Thanks to him/her) was using ASCII to convert the plainText into bytes, while my C# code was using Unicode. Unicode was assigning extra byte to each character in the resultant byte array, which was not affecting the generation of both key and iv bytes, but affecting the result since the length of the encryptedString was dependent on the length of the bytes generated from plainText.<br>
As seen in the following bytes generated for each of them using ""Example String"" and ""Example Key"" as the plainText and secretKey respectively - </p>

<pre><code>ASCII
clearBytes: [69,120,97,109,112,108,101,32,83,116,114,105,110,103,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eQus9GLPKULh9vhRWOJjog==

Unicode:
clearBytes: [69,0,120,0,97,0,109,0,112,0,108,0,101,0,32,0,83,0,116,0,114,0,105,0,110,0,103,0,]
encryptor.Key: [123,213,18,82,141,249,182,218,247,31,246,83,80,77,195,134,230,92,0,125,232,210,135,115,145,193,140,239,228,225,183,13,]
encryptor.IV: [101,74,46,177,46,233,68,252,83,169,211,13,249,61,118,167,]
Result: eAQO+odxOdGlNRB81SHR2XzJhyWtz6XmQDko9HyDe0w=
</code></pre>

<p>The JS result was similar too, which confirmed that it's using ASCII byte conversion - </p>

<pre><code>keyBytes: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d654a2eb12ee944fc53a9d30df93d76a7
key: 7bd512528df9b6daf71ff653504dc386e65c007de8d2877391c18cefe4e1b70d
iv: 654a2eb12ee944fc53a9d30df93d76a7  
</code></pre>

<p>Thus I just need to increase the length of the plainText to make it use Unicode equivalent byte generation (Sorry, not familiar with the term). Since Unicode was assigning 2 space for each character in the byteArray, keeping the second space as 0, I basically created gap in the plainText's characters and filled that gap with character whose ASCII value was 0 using the <code>addExtraByteToChars()</code> function. And it made all the difference.</p>

<p>It's a workaround for sure, but started working for my scenario. I suppose this may or may not prove useful to others, thus sharing the findings. If anyone can suggest better implementation of the <code>addExtraByteToChars()</code> function (probably some term for this conversion instead of ASCII to Unicode or a better, efficient, and not hacky way to do that), please suggest it.</p>
","323","<javascript><c#><encryption><aes><cryptojs>","3","2","2","2018-12-15 14:28:30","53784853","3","0","1079901","","2018-12-14 22:43:38","2018-12-13 20:12:22",""
"28095610","Why would a hash computation using CryptoJS cause a $rootScope:infdig error in Angular?","<p>I have a simple page that shows the hash of a string as someone types it into the page. I found that the page had a JavaScript error</p>

<p>Error: [$rootScope:infdig] <a href=""http://errors.angularjs.org/1.2.26/"" rel=""nofollow"">http://errors.angularjs.org/1.2.26/</a>$rootScope/infdig?p0=10&amp;p1=%5B%5B%22sha175651%2C1080464653%2C-772792499%5D%2C%5C%22sigBytes%5C%22%3A20%7D%22%5D%5D</p>

<p>A very simplified version of the page is</p>

<pre><code>&lt;html lang=""en""&gt;
&lt;head&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha1.js""&gt;&lt;/script&gt;
    &lt;script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.2.26/angular.min.js""&gt;&lt;/script&gt;
    &lt;script&gt;
        function MyCtrl($scope) {
            $scope.sha1 = function(pwd) {
                return CryptoJS.SHA1(pwd);
            };
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=""app"" ng-app ng-controller=""MyCtrl""&gt;
        &lt;span ng-bind=""sha1('bar')""&gt;&lt;/span&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>which is available as Plunker <a href=""http://plnkr.co/edit/vmBtH8B2EKsdcfZVGlMH"" rel=""nofollow"">http://plnkr.co/edit/vmBtH8B2EKsdcfZVGlMH</a>.</p>

<p>What I am trying to do in the original page is recalculate the hash as someone types into the form field, and the input field definition looked like this</p>

<pre><code>&lt;input id=""password"" ng-model=""password"" type=""text"" placeholder=""Password""&gt;
</code></pre>

<p>and the ng-bind is really <code>ng-bind=""sha1(password)""</code>, but the simple static case in the Plunker exhibits the same behavior. </p>

<p>I gather that the infdig error has to do with too many $digest cycles, but I don't see how that would happen here. It looks like the hash computation triggers the error, because returning a static string from the sha1 function causes no error.</p>
","<p>Providing <code>ng-bind=""sha1('bar')""</code> makes the digest cycle unstable, everytime sha1 function returns a different object (reference is different) and your digest cycle has to run again to stabilize it and every digest cycle again evaluates the ng-bind function expression and it goes on till it reaches the max limit set (10). You can also easily replicate this issue by just doing <code>return []</code> in your scope method. This is just a side effect of not so good practice of binding a function expression to <code>ng-bind</code> as it runs every digest cycle, if at all used it should be carefully evaluated.</p>

<p>One simple solution is to bind ng-change/ng-blur event on your password or any other trigger and just bind ng-bind to a property instead of a function expression.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>angular.module('app',[])
.constant('Crypto', window.CryptoJS);
function MyCtrl($scope, Crypto) {
   $scope.encrypt = function() {
     $scope.encrypted = Crypto.SHA1($scope.password);
   };
 }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;html lang=""en"" ng-app=""app""&gt;

&lt;head&gt;
  &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha1.js""&gt;&lt;/script&gt;
  &lt;script src=""http://ajax.googleapis.com/ajax/libs/angularjs/1.2.26/angular.min.js""&gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;
  &lt;div class=""app"" ng-app ng-controller=""MyCtrl""&gt;
    &lt;input id=""password"" ng-model=""password""  type=""password"" placeholder=""Password"" ng-change=""encrypt()""&gt;
    &lt;span ng-bind=""encrypted""&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
</div>
</div>
</p>

<p>For better usage of DI i have placed crpto in a constant and inject it where needed.</p>
","317","<javascript><angularjs><cryptojs>","0","0","1","2015-01-22 23:09:12","28095806","0","","1009603","","2015-01-22 23:09:12","2015-01-22 17:58:47",""
"54522471","Crypto vs Bcrypt for Specific Data","<p>I am currently building a 'Renters Portal' application with Node.js and I would like to encrypt the users ""Applications"" for renting a house.  I am new to encryption and hope someone could explain whether Bcrypt or Crypto would be better in this instance.</p>

<p>I am currently using Crypto and it seems to be working fine, however, from a security standpoint, I would like to know if changing it to Bcrypt would be better.</p>

<p>From the research that I have gathered, I see that Bcrypt is good for passwords due to the hashing, but that is the extent of it.  So is it fair to say that Bcrypt is good for data in which you are not returning data back to the client (i.e. passwords)?</p>
","<p>Bcrypt is a hashing function as stated in <a href=""https://en.wikipedia.org/wiki/Bcrypt"" rel=""nofollow noreferrer"">Wikipedia</a> and <a href=""https://github.com/kelektiv/node.bcrypt.js#readme"" rel=""nofollow noreferrer"">README</a> of its npm package. And it is really a good one.</p>

<p>Node.js' built-in <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto</a> library on the other hand provides various kinds of encryption/hashing techniques.</p>

<p>If you plan to encrypt the ""applications"" in a reversible manner, use crypto, otherwise go with bcrypt.</p>
","316","<javascript><node.js><encryption><bcrypt><cryptojs>","0","1","1","2019-02-04 19:05:37","54522670","1","","","","","2019-02-04 18:48:00","2019-02-04 19:07:10"
"51347704","Stripe verify web-hook signature HMAC sha254 HAPI.js","<p>I'm trying to verify a webhook sent by stripe in my hapi.js app.
I've followed the instructions detailed here:</p>

<p><a href=""https://stripe.com/docs/webhooks/signatures"" rel=""nofollow noreferrer"">https://stripe.com/docs/webhooks/signatures</a></p>

<p>(I've obviously not posted my endpoint secret here :)</p>

<pre><code>&lt;!-- language: lang-js --&gt;

const enpointSecret = ######;

const sig = _.fromPairs(request.headers[""stripe-signature""].split(',')
.map(s =&gt; s.split('=')));
// produces object eg { t: '1111', v1: '111111..', v0: '...'} etc


const signed_payload = `${sig.t}.${JSON.stringify(request.payload)}`;

const hmac = crypto.createHmac('sha256', endpointSecret)
.update(signed_payload)
.digest('hex');
</code></pre>

<p>The generated hmac does NOT match the signature in the header (sig.v1). I can't figure out what I'm doing wrong...</p>

<p>I'm developing locally - and using ngrok, so that i can test my webhooks. Could this be an issue? Thanks</p>
","<p>In Hapi 17,
Following on from the comments - in Hapi 17, you must prevent the body from being parsed. I was dancing around the houses setting the output of the payload config... but you don't need to do this. Simple set payload.parse to false</p>

<pre><code>&lt;!-- language: lang-js --&gt;

    module.exports = {
        method: 'POST',
        path: '/api/webhook',
        config: {
            auth: false,
            payload: {
             parse: false // the important bit
            },
        handler: async (request, h) =&gt; {
</code></pre>

<p>I was then able to use the built in stripe method</p>

<pre><code>&lt;!-- language: lang-js --&gt;

    try {
       let event = stripe.webhooks.constructEvent( request.payload.toString(), request.headers[""stripe-signature""], endpointSecret);
            console.log(event);
    }
    catch (err) {
       console.log(err)
    }
</code></pre>

<p>The real credit should go to Karl Reid - so while I have posted this here, I have not marked it as the accepted answer.</p>
","315","<node.js><stripe-payments><hapijs><cryptojs><ngrok>","0","3","1","2018-07-16 10:52:39","51352122","3","","714950","","2018-07-15 20:43:17","2018-07-15 10:55:57",""
"36412535","HMAC C# and JavaScript","<p>Having trouble getting C# and Javascript to generate the same HMAC:</p>

<p>C#:</p>

<pre><code>string data = String.Format(""{0}{1}{2}{3}{4}{5}"", APPId, requestHttpMethod, requestUri, requestTimeStamp, nonce, requestContentBase64String);

        var secretKeyBytes = Convert.FromBase64String(sharedKey);

        byte[] signature = Encoding.UTF8.GetBytes(data);

        using (HMACSHA256 hmac = new HMACSHA256(secretKeyBytes))
        {
            byte[] signatureBytes = hmac.ComputeHash(signature);                
            return (incomingBase64Signature.Equals(Convert.ToBase64String(signatureBytes), StringComparison.Ordinal));
        }
</code></pre>

<p>Produces: apZUyGrS23BcEd2q5guGS4uQWVvcCvaDXIjCrLn/Hp4=</p>

<p>Javascript:</p>

<pre><code>var signatureRawData = """".concat(appId, requestHttpMethod, requestUri, requestTimeStamp, nonce, requestContentBase64String);

var hash = CryptoJS.HmacSHA256(signatureRawData, apiKey);
var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
</code></pre>

<p>Produces: mFZyyKT03OOThRnt/9dG/0x+jRde3jCMvI6Rd0eKhEE=</p>
","<p>Where is the apiKey in the c# code? Is it sharedKey? Is sercretKeyBytes a string, char[], or byte[]? I suspect secrtetKeyBytes is being converted to a string which is the cause of the issue.</p>
","314","<javascript><c#><hmac><cryptojs>","-1","0","1","2016-04-04 21:19:16","36413063","4","","","","","2016-04-04 20:45:07",""
"51643526","CryptoJS v3.1.2 SHA3 (512) decryption","<p>I am writing a site that needs to use multiple encryptions through out the entire process. I started to use CryptoJS v3.1.2 vSHA3 (512) and am able to encrypt the data no problem. Where I'm having trouble is decrypting the data once it's been encrypted. I have been searching the web for the last week or 2 and have only been able to find ways to encrypt the data but no way to decrypt it. If there is no way to decrypt the data, I will have to look for a different encryption. Any help here would be gratefully appreciated.  </p>
","<p><a href=""https://en.wikipedia.org/wiki/SHA-3"" rel=""nofollow noreferrer"">SHA3</a> is a <a href=""https://en.wikipedia.org/wiki/Cryptographic_hash_function"" rel=""nofollow noreferrer"">hash function</a>, and hash functions are not reversible -- that is, not decryptable. You may instead need a symmetric algorithm such as AES.</p>

<p>That being said, getting the nuances of cryptography right to avoid vulnerabilities is notoriously hard even for veterans, much less someone new to these concepts. Try very, <em>very</em>, VERY hard to rely on standard and ready-made solutions. Use things like HTTPS, for example, or your database's built-in security features.</p>
","311","<encryption><cryptojs>","-2","0","1","2018-08-01 23:41:06","51643659","0","","","","","2018-08-01 23:22:28",""
"33154525","async.eachSeries RangeError: Maximum call stack size exceeded","<p>I am running this on node.js v0.10.33 with async@0.9.0 trying to test <code>crypto.createCipher</code> but end up getting error: <code>RangeError: Maximum call stack size exceeded</code></p>

<pre><code>/**
 * New node file
 */
var crypto = require('crypto');
var async = require('async');
var _ = require('underscore');

var l = [];
var o = [];
for (var i=0; i&lt;4899; i++) {
    l.push(String(i));
}

var key = 'mykey';
var algorithm = 'aes256';

async.eachSeries(l, function(item, callback) {
    var cipher = crypto.createCipher(algorithm, key);
    var encrypted = cipher.update(item, 'utf8', 'hex') + cipher.final('hex');
    var decipher = crypto.createDecipher(algorithm, key);
    var decrypted = decipher.update(encrypted, 'hex', 'utf8') + decipher.final('utf8');
    o.push(encrypted);
    callback(null);
}, function(err) {
    console.log('err', err, 'o', o.length, 'o-uniq', _.uniq(o).length)
    var le = _.map(o, function(i) {
        return i.length
    })
    console.log('le', le.length, 'le-uniq', _.uniq(le).length, le[0])
})
</code></pre>

<p>Error stack:</p>

<pre><code>node.js:896
    var fn = runInThisContext(source, this.filename, true);
             ^
RangeError: Maximum call stack size exceeded
</code></pre>
","","303","<node.js><asynchronous><cryptojs>","0","","0","2015-10-15 17:09:30","","2","1","","","","2015-10-15 17:09:30",""
"40930369","Alternate Code in JavaScript for javax.crypto","<p>I want to implement below code in JavaScript instead of using javax.crypto packages.</p>

<p>Below code will generate key using AES.  </p>

<pre><code>    KeyGenerator kgen;
    String key;
    try {
        kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128);
        SecretKey secretkey = kgen.generateKey();
        BASE64Encoder encode = new BASE64Encoder();
        key = encode.encode(secretkey.getEncoded());
    } catch (NoSuchAlgorithmException e) {
       // exceptionLogFile(e, null);
        e.printStackTrace();
        key = ""Error@SecretKeyGeneration: No Such Algorith Exception. "" + e.getMessage();
    } catch (Exception e) {
       // exceptionLogFile(e, null);
        e.printStackTrace();
        key = ""Error@SecretKeyGeneration: "" + e.getMessage();
    }
    return key;
</code></pre>

<p>This is perfectly working in Java, Now can anyone suggest me alternative in JavaScript.</p>

<p>I got to know about <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">Crypto.js</a> but how i can use here, not understanding.</p>

<p>For Encrypt and Decrypt, I am using <code>""AES/ECB/PKCS5Padding""</code> so is it compatible with the javascript code ?</p>

<p>Please help. </p>

<p>Thanks in advance.</p>
","<p>An AES key consists simply of random bytes. So for a 128 byte key you can just do:</p>

<pre><code>var key = CryptoJS.lib.WordArray.random(128/8);
</code></pre>

<p>and to encode it:</p>

<pre><code>var keyBase64 = CryptoJS.enc.Base64.stringify(key);
</code></pre>

<p>Of course the key won't be identical to the one you generated before, you need to decode the previously generated base 64 encoded key to do that.</p>

<hr>

<p>To use the key, use the explicit key parameters:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""Message"", key, { mode: CryptoJS.mode.ECB});
</code></pre>

<p>PKCS#7 padding - which is identical to PKCS#5 padding - is already the default and ECB doesn't use an IV.</p>
","301","<javascript><encryption><aes><cryptojs><key-generator>","3","3","1","2016-12-03 10:40:52","40946849","2","","","","","2016-12-02 10:46:43",""
"52912510","sign a string by xml privateKey in node js","<p>I have an sh1 hashed string which I want to sign it by an xml private key in my node js code.how can I do it?I used crypto to do so but it does not support xml private key.so can any one please tell me what to do ?here is my code:</p>

<pre><code>   var sha1 = crypto.createHash('sha1');
   const crypto = require('crypto');

   const sign = crypto.createSign('RSA-SHA1');
   const TerminalCode = 123;
   const MerchantCode = 4566;
   const privateKey =""&lt;RSAKeyValue&gt;&lt;Modulus&gt;tew9OJzFRBF0UbAU5M3vF18UDWxCseQkWtQI7tTrQcJisT31oqSv0uvwx3zQf0oGj9VnxeNeytm+xFxVt1lq+oGP5icJdiFdPHl2P5lD+T4sEyKGsiuPqXXkpWG3oY1V2t4BHmnJTr4jPRYInSQi9RvOWDUtRlgFLEQxgV2flvc=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;P&gt;3ElB9JPqabnMPzr8K1Fi4qd8YxIdbJln2JMx54G0ISjMzhv29GW3g3jOpAAtKlR49HTnz5F4T65mWm3jRhK4NQ==&lt;/P&gt;&lt;Q&gt;02rAXLUMpPu/CByB2TamTkVDpRsDRteGZ2dBjtOB4D6YQir6hsuQpnhCR7vzz7p8IFf06flL/Ly7ZL1Bpo5v+w==&lt;/Q&gt;&lt;DP&gt;HYWX2D5GiRrEW6j9CJUkqnmFuwU/ekFo4GaBpqQETvlX0TuAMiq7mFwFXYdEhkrB1wkf0/qL5CncP7xAXDDADQ==&lt;/DP&gt;&lt;DQ&gt;WSN5V50+Z5F9Sf47AUp5dCbgDo0FJKlakd6HVaD38YRyzfMxDgRmSMoLqBMnCT6ndzuel8f0seshV6g0NfV4YQ==&lt;/DQ&gt;&lt;InverseQ&gt;g7bnQMwCsRSOtPCBYub7P4AHJgvv+kbc4Kacq0UlZk8f+uMSoPU14stoiNHeo3htW8rx/XySW72EuLG6ej6OWA==&lt;/InverseQ&gt;&lt;D&gt;nsISix0EaWpx//eRxDqSs+qdLTmU2nkl4L25LfNReomQZuyTN+RQK9kKvowFx49qOosZjG/ngU6UU/fgNakq2QkKw8D9w+cbwF7kyDpr6AkngfY0w+X3q5hZUEcCFKiA6P0nw55TvSoGvtQK+zAdVAjJGmHCZ4qIWzXLX1CcOUE=&lt;/D&gt;&lt;/RSAKeyValue&gt;""





    var string =`#${MerchantCode}#${TerminalCode}#123#$12344566#$12342326#http://kalno.ir/pasargad/payback#${1003}#$434536`
    sha1.update(string);
    sha1 = sha1.digest('hex');
    sign.write(toString(sha1));
// sign.end();
    privateKey = sign.sign(privateKey, 'base64')
</code></pre>

<p>but when I do so , crypto sign gives me an error containing that this xml private key is not correct.""Error: error:0906D06C:PEM routines:PEM_read_bio:no start line""</p>
","<p>Convert your XML key to PEM using <a href=""https://superdry.apphb.com/tools/online-rsa-key-converter"" rel=""nofollow noreferrer"">Online Converter</a> or use libraries like <a href=""https://www.npmjs.com/package/rsa-xml"" rel=""nofollow noreferrer"">rsa-xml</a> to convert it in Node.JS</p>

<pre><code>const RSAXML = require('rsa-xml');
const xmlKey = '&lt;RSAKeyValue&gt;...&lt;/RSAKeyValue&gt;';
const pemKey = new RSAXML().exportPemKey(xmlKey);

console.log(pemKey); // -----BEGIN RSA PRIVATE KEY----- ...
</code></pre>
","300","<node.js><private-key><cryptojs>","1","1","1","2018-10-21 07:53:18","52913197","1","","5053201","","2018-10-21 06:33:35","2018-10-21 05:58:45",""
"53716552","OpenSSL and CryptoJS SHA256 encryption conversion","<p>My problem is that the newer versions of OpenSSL aren't compatible with default settings of CryptoJS.</p>

<blockquote>
  <p>The default hash used by openssl enc for password-based key derivation
  changed in 1.1.0 to SHA256 versus MD5 in lower versions.
  <a href=""https://unix.stackexchange.com/questions/344150/why-can-one-box-decrypt-a-file-with-openssl-but-another-one-cant/344586#344586"">https://unix.stackexchange.com/questions/344150/why-can-one-box-decrypt-a-file-with-openssl-but-another-one-cant/344586#344586</a></p>
</blockquote>

<p>By default, <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">CryptoJS</a> uses MD5 for its key derivation. OpenSSL used MD5, but now in OpenSSL versions >=1.1.0 it's using SHA256.</p>

<p>So if I pass <code>-md md5</code> to OpenSSL, CryptoJS is compatible:</p>

<pre><code>echo ""Hello World"" | openssl enc -aes-256-cbc -md md5 -pass pass:""Secret Passphrase"" -e -base64
</code></pre>

<p>output: <code>U2FsdGVkX19aufvaqQQ89scaApBos6oFCyqPj7IKUFk=</code></p>

<p>CryptoJS:</p>

<pre><code>CryptoJS.AES.decrypt('U2FsdGVkX19aufvaqQQ89scaApBos6oFCyqPj7IKUFk=', 'Secret Passphrase').toString(CryptoJS.enc.Utf8);
</code></pre>

<p>output: <code>""Hello World""</code></p>

<hr>

<p><strong>But now if I want to use SHA256 instead of MD5 (removing the <code>-md md5</code>):</strong></p>

<pre><code>echo ""Hello World"" | openssl enc -aes-256-cbc -pass pass:""Secret Passphrase"" -e -base64
</code></pre>

<p>output: <code>U2FsdGVkX1/5LLkFkTpawh1im4a/fCco5hS42cjn/fg=</code></p>

<p>CryptoJS:</p>

<pre><code>CryptoJS.AES.decrypt('U2FsdGVkX1/5LLkFkTpawh1im4a/fCco5hS42cjn/fg=', 'Secret Passphrase').toString(CryptoJS.enc.Utf8);
</code></pre>

<p>output: null</p>

<p>How do I tell CryptoJS to use SHA256 instead of MD5 for its key derivation?</p>
","<p>It seems that CryptoJS ""as-is"" does not provide this flexibility. This is because the use of MD5 is hard coded into the function used to derive the key from the passphrase. You can see it happening <a href=""https://github.com/brix/crypto-js/blob/3.1.9/cipher-core.js#L780"" rel=""nofollow noreferrer"">here in OpenSSLKdf</a>:</p>

<pre><code>var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
</code></pre>

<p>KDF stands for Key Derivation Function, and no digest is provided when it is created. That <code>EvpKDF.create()</code> in itself does have the possibility for different types of digests, as you can see in <a href=""https://github.com/brix/crypto-js/blob/3.1.9/evpkdf.js#L37"" rel=""nofollow noreferrer"">its configuration options</a>:</p>

<pre><code>        cfg: Base.extend({
            keySize: 128/32,
            hasher: MD5,
            iterations: 1
        }),
</code></pre>

<p>It also shows that MD5 is the default.</p>

<p>All of this implies that the decryption will work if you modify that first line to the following:</p>

<pre><code>var key = EvpKDF.create({ keySize: keySize + ivSize, hasher: C_algo.SHA256 }).compute(password, salt);
</code></pre>

<p>and indeed, after editing (as a test) that file <code>cipher-core.js</code> in your locally installed module, your last line of code does result in the desired <code>Hello World</code>.</p>

<p>The only way I see to reproduce this without modifying the CryptoJS module itself is by duplicating a whole chunk of code from the module into your own code.</p>
","294","<linux><encryption><openssl><sha256><cryptojs>","3","3","1","2018-12-11 06:14:06","53718402","0","","","","","2018-12-11 02:34:22",""
"48229296","AWS: signing key for Signature Version 4: how to do it using Web Cryptography API?","<p>For my webapp I want to communicate with DynamoDB directly from a client, without intermediate API Gateway and Lambda. And I do not want to use JS SDK just for a few http calls and keys signing. I stumbled upon with <a href=""https://docs.aws.amazon.com/general/latest/gr/signature-v4-examples.html"" rel=""nofollow noreferrer"">key signing</a> - examples given for a few languages but not for native js module <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle"" rel=""nofollow noreferrer"">Crypto</a>. Example using <code>crypto-js</code>:</p>

<pre><code>Crypto.HmacSHA256(regionName, kDate);
</code></pre>

<p>I tried:</p>

<pre><code>const kSecret  = '41575334774a616c725855746e46454d492f4b374d44454e472b62507852666943594558414d504c454b4559',
    dateStamp = '20120215'


function _binaryToHex(array) {
    return array.map(b =&gt; ('00' + b.toString(16)).slice(-2)).join('');
}


/**
 * https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey
 */
async function _importKey(keyDataArrayBuffer) {
    return crypto.subtle.importKey(
        'raw',
        keyDataArrayBuffer,
        {'name': 'hmac', 'hash': {'name': 'SHA-256'}},
        false,
        ['sign']);
}

const kDate = _binaryToHex(
    Array.from(
        new Uint8Array(
            await crypto.subtle.sign(
                'HMAC',
                await _importKey(
                    new TextEncoder().encode(kSecret)
                ),
                new TextEncoder().encode(dateStamp)
            )
        )
    )
);
console.log(kDate);
/* Must be
 * '969fbb94feb542b71ede6f87fe4d5fa29c789342b0f407474670f0c2489e0a0d'
 */ 
</code></pre>

<p>But output not the same as in example.</p>
","<p>As usual, I must be attentive and thoughtful - here simple bug - input key <code>kSecret</code> already encoded to the hexadecimal - but must be original human-readable value for</p>

<p><code>new TextEncoder().encode('AWS4wJalrXUtnFEMI/K7MDENG+bPxRfiCYEXAMPLEKEY')</code></p>
","293","<javascript><amazon-web-services><amazon-cognito><cryptojs><webcrypto-api>","0","0","1","2018-01-13 20:33:36","48244059","9","","1879101","","2018-01-13 16:56:43","2018-01-12 15:29:37",""
"37651230","Encrypt with CryptoJs and Decrypt with Phalcon","<p>I am trying to Encrypt some text from CryptoJS and decrypt it with Phalcon. </p>

<p>I encrypt as follows,</p>

<pre><code>CryptoJS.AES.encrypt(""MyText"", 'key123');
</code></pre>

<p>Now to compare I encrypt the same value with Phalcon as,</p>

<pre><code>$this-&gt;crypt = new Crypt();
$this-&gt;crypt-&gt;encrypt(""MyText"", 'key123');
</code></pre>

<p>Now the values I get from JS and PHP are different. </p>

<p>Phalcon default encryption is AES and so do in CryptoJS. </p>

<p>Please help me on this. I want to have the same value in both sides.</p>
","<p>The default cipher in Phalcon is Rijndael-256, which is not supported by CryptoJS. It would be necessary to change that to Rijndael-128 (AES). It's also necessary to use some kind of padding mode in Phalcon in order to be able to encrypt arbitrary binary data.</p>

<pre><code>$keyHex = ""0102030405060708090a0b0c0d0e0f"";

$this-&gt;crypt = new Crypt();
$this-&gt;crypt-&gt;setPadding($this-&gt;crypt-&gt;PADDING_PKCS7);
$this-&gt;crypt-&gt;setCipher(""rijndael-128"");

// encryption
$ct = base64_encode($this-&gt;crypt-&gt;encrypt(""MyText"", hex2bin($keyHex)));

// decryption
var_dump($this-&gt;crypt-&gt;decrypt(base64_decode($ct), hex2bin($keyHex)));
</code></pre>

<p>The 128 bit initialization vector is prefixed to the ciphertext, so it has to be done in the same way in CryptoJS.</p>

<pre><code>var key = CryptoJS.enc.Hex.parse(""0102030405060708090a0b0c0d0e0f"");
var iv = CryptoJS.lib.WordArray.random(128/8);
var ct = CryptoJS.AES.encrypt(""MyText"", key, {
    iv: iv
}).ciphertext;
return iv.concat(ct).toString(CryptoJS.enc.Base64);
</code></pre>

<hr>

<p>Things to note:</p>

<ul>
<li><p>The key must be randomly generated. This is an example 16 byte key (32 hexits) and it has to have a specific length. AES supports key sizes of 16, 24 and 32 bytes (32, 48, 64 hexits).</p></li>
<li><p>The IV is generated randomly for every encryption, so it is not possible to encrypt the same text with the same key in CryptoJS and Phalcon to check compatibility. It is necessary to encrypt in one and decrypt in the other.</p></li>
<li><p>Symmetric encryption without authentication can be very dangerous. It might be possible to mount a padding-oracle attack in your case. A common way to add authentication is to run a message authentication code over the IV + ciphertext with a separate key. HMAC-SHA256 with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme is a strong choice in that regard.</p></li>
<li><p>If the ""key"" is passed as a string to <code>CryptoJS.AES.encrypt</code>, then it invokes an OpenSSL compatible key derivation function (<code>EVP_BytesToKey</code>). The given ""key"" is assumed to be a password, therefore it generates a random salt, and derives the actual key and IV from those two.</p></li>
<li><p>Phalcon uses mcrypt, which is abandonware and has many bugs.</p></li>
</ul>
","289","<javascript><php><encryption><phalcon><cryptojs>","3","3","1","2016-06-06 08:00:23","","2","1","","","","2016-06-06 06:55:12",""
"54446260","How to fix crypto.pbkdf2 error on node.js","<p>I'm attempting to add the crypto.pbkdf2 to my system and I keep returning a digest issue when using mocha to test the various functionalities. My code for the hash method is:</p>

<pre><code>Account.prototype.hashPassword = function (password, salt, callback) {
// we use pbkdf2 to hash and iterate 10k times by default 
 var iterations = 10000,
    keylen = 64; //64 bit.
this.crypto.pbkdf2(password, salt, iterations, keylen,'sha1', callback);
};
</code></pre>

<p>I've tried to change the digest ('sha1') to many things, including 'shah256', 'null' or digest. But my tests are still failing with the error:</p>

<pre><code> TypeError [ERR_INVALID_ARG_TYPE]: The ""digest"" argument must be one of type string or null. Received type undefined
  at check (internal/crypto/pbkdf2.js:56:13)
  at Object.pbkdf2Sync (internal/crypto/pbkdf2.js:45:5)
  at UserMock.seedUsers (test\user-mock.js:32:39)
  at Context.&lt;anonymous&gt; (test\account-test.js:296:27)
</code></pre>

<p>How do I solve the error I am facing?</p>
","<p>You have probably fixed this by now, but just in case someone else also has this problem - as I did:
The functionality of the function <code>crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)</code> changed in Node 6 to make <strong><em>digest</em></strong> compulsory.  Up until Node 10, if <em>digest</em> wasn't provided then 'sha1' was used. But Node 10 requires it.
Finding that out resolved my near as damn it identical message to the one you were getting.</p>
","288","<javascript><node.js><mocha><cryptojs>","0","0","1","2019-08-21 13:53:04","","7","","9657933","","2019-01-30 17:39:45","2019-01-30 17:29:40",""
"47769934","How to decrypt hash get from this function","<p>we are encrypting our password in the app using this function.How to decrypt them when we need actual string.<code>var crypto = require('crypto');</code></p>

<pre><code>function encryptPassword(password) {
    var salt = new Buffer('priotzen', 'base64');
    return crypto.pbkdf2Sync(password, salt, 10000, 64).toString('base64');
}
</code></pre>

<p>Thanks :)</p>
","<p>The code you've provided generates a one-way hash. If you use this, then you validate passwords by comparing hashed values. There is no way to decrypt the existing password. If the user forgets their password, then you do a password reset.</p>

<p>If you really want to have retrievable passwords, then you need to look at encryption rather than hashing algorithms. For this type of application, symmetric key encryption, such as AES may be suitable.</p>

<p>Keep in mind that encryption is computationally much more expensive than hashing, and less secure. Hashing is nearly always preferred for passwords. Unless there is some extremely compelling reason to have retrievable passwords, you should steer your client towards one-way hash passwords.</p>
","287","<node.js><cryptojs>","0","1","1","2017-12-12 10:31:36","47770385","1","","","","","2017-12-12 10:08:08",""
"55586710","how to encrypt decrypt data between angular app and django app","<p>We are having a scenario in which our angular app calls our backend APIs (developed using django rest framework). We are using Jwt for API authentication. We have one endpoint url which takes username and password (POST request) and authenticate the user using django backends. We have deployed both the application on APACHE HTTP Server and using SSL (Https) for encryption. </p>

<p>But we also want to encrypt the request payload (data sent to the django API). In current case encrypt the username and password from angular app and decrypt the corresponding data in django. For this, we are using CryptoJs in angular app and Pycrypto in Django. But we are unable to decrypt the data in django.</p>

<p>Here is the decrypt function code we are using on django app:</p>

<pre><code>MODE = AES.MODE_CBC

key = 'k%eu6sy)h&amp;vue#5yrpok#1)^1ya#l1t('

def decrypt(ciphertext,key, mode):
    encobj = AES.new('k%eu6sy)h&amp;vue#5yrpok#1)^1ya#l1t(', AES.MODE_CBC)
    decrypted = encobj.decrypt(ciphertext)
    return decrypted.decode('utf-8')



ciphertext_user_name=request.data['username'].encode(""utf8"")
ciphertext_pwd=request.data['password'].encode(""utf8"")
usr = decrypt(ciphertext_user_name,key,MODE)
pwd = decrypt(ciphertext_pwd,key,MODE)

</code></pre>

<p>We are using CBC mode in CryptoJs as well. </p>

<p>Above code is just a sample code. Can somebody suggest, is this the right approach to go, or we should change the approach and do something else.</p>

<p>Thanks in advance !</p>
","<blockquote>
  <p>Can somebody suggest, is this the right approach to go</p>
</blockquote>

<p>Why do you want to encrypting the payload separately (outside ssl)? </p>

<p>When it comes to credentials (username, password), if you encrypt in the browser, you need to have a key inside the script somewhere. That doesn't add anything to security, only increases the solution complexity. </p>

<p>You may use an asymmetric cipher (RSA, ECC) to encrypt data using server's public key. Oh, wait - HTTPS does that already for you.</p>

<p>Client side encryption may have its place where you don't want the server to access the data (e.g. secured messaging, password manager, ..), however for username and password the server needs to read and process the credentials anyway. </p>

<blockquote>
  <p>But we are unable to decrypt the data in django.</p>
</blockquote>

<p>Here we have no idea how do you encrypt data on the client side. You may try to edit your question and add the encryption code and error message</p>

<blockquote>
  <p>or we should change the approach and do something else</p>
</blockquote>

<p>Though there are definitely some issues in your code (I am unable to tell if it's all of them)</p>

<ul>
<li>ciphertext (encrypted data) are usually binary (having non-printable characters). That's why when passing as parameters, the data are usually encoded to printable common characters (hex, base64, ..). I see you directly decrypt the parameters, are you sure the data are not encoded / posted  correctly?</li>
<li>I see you are not using any IV (initialization vector for CBC mode). I assume you library used will just use zero array IV. Using static / zero IV is VERY unsafe for CBC mode (or any mode generally). Are you sure the client doesn't include some sort of IV? </li>
<li>CBC mode is malleable, you should apply some integrity check (with the integrity secret in the client script it doesn't add any value either)</li>
</ul>

<p>This all is already done (and done well) using HTTPS, so so you are just trying to implement another layer of encryption with not really added value (and as well with apparent weaknesses). I believe common advice here is to lean on HTTPS with confidence</p>
","283","<encryption><cryptojs><pycrypto>","0","1","1","2019-04-09 11:56:08","","0","","","","","2019-04-09 06:51:31",""
"37027805","What are meaning of the parameters of CryptoJs.AES function?","<p>Can anyone tell me what are meaning of these two parameters in CryptoJS.AES.encrypt function (message, password)? And can i just put in one parameter, the parameter of the password that i want to encrypt?</p>

<p>For example:</p>

<p>CryptoJS.AES.encrypt( <em>message ,password</em> );</p>

<p>Thanks!</p>
","<p>I do not have any experience with CryptoJS but after a quick search I found the following.</p>

<p>The <code>message</code> parameter is the text you want to encrypt.
The <code>password</code> parameter is needed when you want to decrypt the message.</p>

<p>Example code:</p>

<pre><code>var secretMessage = ""Hello World!"";

// Encrypt our secret message.
var encrypted = CryptoJS.AES.encrypt(secretMessage, ""Secret Passphrase"");

// Decrypt our message.
var decrypted = CryptoJS.AES.decrypt(encrypted, ""Secret Passphrase"");

// Since the decrypted message is a Base64 string, to read the message we first need to convert it.
var message = decrypted.toString(CryptoJS.enc.Utf8); // Hello World!
</code></pre>

<p><a href=""http://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/"" rel=""nofollow"">Here's</a> the article I found.</p>

<p>Hope this helps</p>
","282","<javascript><encryption><cryptojs>","-1","0","1","2016-05-04 13:37:50","37029510","0","0","","","","2016-05-04 12:25:57",""
"52796267","AES encryption using CryptoSwift and CryptoJS","<p>I was to trying encrypt a text using CryptoSwift for ios application, and CryptoJS for web application, which has to be decrypted in Java platform. I could able to encrypt successfully in javascript by using the following code.</p>

<pre><code>var message = ""Hello""
var password = ""samplepasswordky""

function encrypt(message, password) {
  var salt = CryptoJS.enc.Hex.parse(""00000000000000000000000000000000"");
  var key = CryptoJS.PBKDF2(pass, salt, {
    keySize: keySize/32,
    iterations: iterations
  });

  var iv = CryptoJS.enc.Hex.parse(""00000000000000000000000000000000"");
  var encrypted = CryptoJS.AES.encrypt(msg, key, {
    iv: iv
  });
  var encryptedMessage = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
  return encryptedMessage;
}
</code></pre>

<p>For the same in CryptoSwift I am doing the following, but I could not decrypt the text in Java. </p>

<pre><code>let salt: [UInt8] = Array(""0000000000000000"".utf8)
let password: [UInt8] = Array(""samplepasswordky"".utf8)
let iv: [UInt8] = Array(""0000000000000000"".utf8)
let derivedKey = try! PKCS5.PBKDF2(password: password, salt: salt , iterations: 100, keyLength: 16, variant: .sha1).calculate()
let encrypted = try! AES(key: derivedKey, blockMode: CBC(iv: iv), padding: .pkcs5).encrypt(input)
print(encrypted.toHexString())
</code></pre>

<p>Kindly help me to make this work.</p>
","<p>This line:</p>

<pre><code>var salt = CryptoJS.enc.Hex.parse(""00000000000000000000000000000000"");
</code></pre>

<p>Is not the same as this line:</p>

<pre><code>let salt: [UInt8] = Array(""0000000000000000"".utf8)
</code></pre>

<p>The utf8 encoding of ""0000000000000000"" is, in hex, 30303030303030303030303030303030 (0x30 is the UTF-8 encoding of the character ""0"").</p>

<p>What you meant to use here is <code>Array(repeating: UInt8(0), count: 16)</code>.</p>

<p>You're also outputting a Base64 string in JavaScript, and a hex string in Swift, which are not the same things.</p>

<p>Unrelated side-note: </p>

<p>This implementation is working pretty hard to get little security.  If your password is static, you could do much better by using a random key (i.e. 32 completely random bytes 0-255, not a string of characters). PKBDF2 isn't really buying you much here, excepting slowing down the system (not slowing down the attacker; just your app). Adding a random IV would significantly improve this system as well with little cost.</p>
","281","<swift><encryption><cryptojs><cryptoswift>","0","2","1","2018-10-13 19:17:36","52796372","0","","","","","2018-10-13 18:58:14",""
"29300977","AES decryption in vb.net","<p>I am using the below javascript code to encrypt the values. This is working fine. I would like to decrypt the values in vb.net code behind. Please help me to do this.</p>

<pre><code>    var key = CryptoJS.enc.Utf8.parse('7061737323313233');
    var iv = CryptoJS.enc.Utf8.parse('7061737323313233');
    function Encryption() {

        var min = 1;
        var max = 6;

        var now = new Date();
        var validDate = now.getDate() + '-' + now.getMonth() + '-' + now.getFullYear();
        var random = Math.floor(Math.random() * (max - min + 1)) + min;

        var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(getRandomKey(random, validDate)), key,
        {
            keySize: 128 / 8,
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        });

    }
</code></pre>
","","280","<vb.net><encryption><aes><cryptojs>","0","","0","2015-03-30 03:52:25","","3","","4665858","","2015-03-30 03:52:25","2015-03-27 12:43:02",""
"45870064","Port Node js Crypto.publicEncrypt to Java","<p>I have a the following code in Node.js</p>

<pre><code>    let publicKeyString = '-----BEGIN PUBLIC KEY-----RANDOMPUBLICKEYOMITTED-----END PUBLIC KEY-----\n';

    let publicKey = {
      key: publicKeyString,
      padding: 1
    }
    function _encrypt(input, key) {
        let buf = new Buffer(input, 'utf8');
        console.log('******');
        console.log(buf.length);
        console.log(buf);
        console.log('******');
        let encryptedBuffer = crypto.publicEncrypt(key, buf);
        return encryptedBuffer.toString('base64');
    }
    let card =  {
       ""card_type"": ""ABCD"",
       ""card_number"": ""1111222233334444"",
       ""expiration_month"": 01,
       ""expiration_year"": 2222,
       ""security_code"": ""321""
    };

   let encryptedPayload = _encrypt(JSON.stringify(card), publicKey);

   console.log(encryptedPayload);
</code></pre>

<p>I also have test cases to determine if code has been encrypted properly (I can not share these though)
I would like to have the equivalent encryption code in Java.  I have referenced some other stackoverflow questions such as <a href=""https://stackoverflow.com/questions/10562908/encryption-of-strings-works-encryption-of-byte-array-type-does-not-work"">Encryption of Strings works, encryption of byte[] array type does not work </a>
where keys are generated. This does not work for me because I need to be able to set the public key's string. <a href=""https://stackoverflow.com/questions/36740355/porting-node-crypto-code-to-java"">Porting Node &#39;crypto&#39; code to Java</a> does not work for me because I do not believe I need a cipher and the node js code does not contain a cipher, <a href=""https://stackoverflow.com/questions/7787773/encrypt-with-node-js-crypto-module-and-decrypt-with-java-in-android-app"">Encrypt with Node.js Crypto module and decrypt with Java (in Android app)</a> does not work for me because I can not set the public key's encryption string, and <a href=""https://stackoverflow.com/questions/45104691/java-encrypt-method-equivalent-in-node-js-crypto"">java Encrypt method equivalent in node js crypto</a> does not work because my node js code does not contain a cipher.  I have also referenced this snippet of code in java :</p>

<pre><code>    public static PublicKey getKey(String key){
    try{
        byte[] byteKey = Base64.getDecoder().decode(key.getBytes(""UTF-8""));
        System.out.println(byteKey.length);
        X509EncodedKeySpec X509publicKey = new X509EncodedKeySpec(byteKey);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");

        return kf.generatePublic(X509publicKey);
    }
    catch(Exception e){
        e.printStackTrace();
    }

    return null;
}
</code></pre>

<p>However I am not getting the correct encryption when I simple plug in the public key string. I am also unsure how padding is implemented in Node js and what the default encryption algorithm for crypto.publicencrypt is.</p>

<p>Any help would be appreciated. </p>
","","278","<java><cryptojs><node-crypto><javax.crypto>","1","","0","2017-08-24 20:06:27","","0","","","","","2017-08-24 20:06:27",""
"53127530","Encrypt in CryptoJS and decrypt in NodeJS Crypto module","<p>I have searched here and googled, but couldn't really find what I am looking for. Looks like this should be pretty easy but few similar threads went unanswered as SO. I am hoping if I get the answer. So I have this fiddle <a href=""https://jsfiddle.net/vikasbhandari2/4ovzwbnk/15/"" rel=""nofollow noreferrer"">JS Fiddle</a> which encrypts and decrypts in CryptoJS, no problem so far. Code is here:</p>

<pre><code>var options = { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, keySize: 256 };  

var encrypted = CryptoJS.AES.encrypt('encrypt me', 'A37u172sSFS9O9JNHs82u38djdncnvyz', options);


var decrypted = CryptoJS.AES.decrypt(encrypted, ""A37u172sSFS9O9JNHs82u38djdncnvyz"", options);  
var plaintext = decrypted.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>But when I take the encrypted string, and I try to decrypt, I am unable to. See this node fiddle: <a href=""https://runkit.com/vikas-eb/5b8e65c02b73f60012d271c3"" rel=""nofollow noreferrer"">Node Fiddle</a>, and code is: </p>

<pre><code>const crypto = require('crypto');

const mykey = crypto.createDecipher('aes-256-cbc', 'A37u172sSFS9O9JNHs82u38djdncnvyz');

//A37u172sSFS9O9JNHs82u38djdncnvyz9
const mystr = mykey.update('U2FsdGVkX18mFQOkolgDJ0cjOfYqiqKCUGdNoA2nESI=', 'base64', 'utf8');
</code></pre>

<p>Ideally, the mystr string should return to me the text 'encrypt me', but it shows some gibberish characters. I know it should be easy to find, but I am unable to understand what I am doing wrong. I am totally noob when it comes to encryption. Any help here?</p>
","","278","<node.js><encryption><cryptojs><node-crypto>","1","","0","2018-11-09 02:00:51","","4","1","7633665","","2018-11-09 02:00:51","2018-11-03 01:10:07",""
"32105457","SJCL not concatenating bit arrays","<p>I am trying to use RNCryptor-JS which uses SJCL but for some reason, SJCL bit array concatenation does not seem to work.</p>

<pre><code>var SALT_SIZE = 64/8;

var plaintext = ""Hello, World!"";

var password = ""myPassword"";

function keyForPassword(password, salt){
    // Using CryptoJS for pbkdf2, aes, sha256, and random word arrays
    var pbkdf2_key = CryptoJS.PBKDF2(
        password,
        salt,
        {
          keySize: 256/32,
          iterations: 1000,
          hasher: CryptoJS.algo.SHA256
        }
      );
    return pbkdf2_key;
}

var encryption_salt = CryptoJS.lib.WordArray.random(SALT_SIZE);
var encryption_key = keyForPassword(password, encryption_salt);

var hmac_salt = CryptoJS.lib.WordArray.random(SALT_SIZE);
var hmac_key = keyForPassword(password, hmac_salt);

var iv = CryptoJS.lib.WordArray.random(128/8);

var version = sjcl.codec.hex.toBits(""03"");
var options = sjcl.codec.hex.toBits(""01"");

var message = sjcl.bitArray.concat(version, iv);
message = sjcl.bitArray.concat(message, encryption_salt);
message = sjcl.bitArray.concat(message, hmac_salt);
message = sjcl.bitArray.concat(message, iv);

// Progressive cipher
var aesEncryptor = CryptoJS.algo.AES.createEncryptor(encryption_key, {iv: iv});
var ciphertext = aesEncryptor.process(plaintext);

message = sjcl.bitArray.concat(message, ciphertext);    

var hmac = new sjcl.misc.hmac(hmac_key).encrypt(message);

var encrypted_data = sjcl.bitArray.concat(message, hmac);
var output = sjcl.codec.hex.fromBits(encrypted_data);

console.log(output);
</code></pre>

<p>When I log the output of <code>message</code> after the first set of <code>sjcl.bitArray.concat</code> is done, all that returns is the first concatenation of <code>version</code> and <code>iv</code>. The final hex output is just that first concatenation and <code>hmac</code> concatenated. This reinforces my suspicion that it might be CryptoJS's fault because the output concatenation works and is between two sjcl variables.</p>

<p>I tried using SJCL random bit arrays but had some trouble. SJCL's generator, <code>prng</code>, did not work when using </p>

<pre><code>new sjcl.prng.randomWords(32/4);
</code></pre>

<p>or </p>

<pre><code>new sjcl.prng(32/4);
</code></pre>

<p>And <code>sjcl.random.randomWords</code> does not seem to work anymore.</p>
","<p>CryptoJS (<a href=""https://github.com/CryptoStore/crypto-js/tree/3.1.2/src/core.js#L145"" rel=""nofollow""><code>WordArray</code></a>) and SJCL (<a href=""https://github.com/bitwiseshiftleft/sjcl/blob/master/core/bitArray.js"" rel=""nofollow""><code>bitArray</code></a>) have different internal representations of data. You can't simply concatenate them.</p>

<p>The easiest way would be probably to encode it into an intermediate format such as Hex and let the other side decode into its internal format:</p>

<pre><code>message = sjcl.bitArray.concat(version, sjcl.codec.hex.toBits(iv.toString()));
</code></pre>

<p><code>WordArray#toString()</code> automatically uses Hex encoding. You would have to do this for all lines, but this is a little overkill, since you can concatenate Hex strings as strings:</p>

<pre><code>message = sjcl.codec.hex.toBits(""03"" + iv + encryption_salt + hmac_salt + iv);
</code></pre>

<p>This should work as expected, because adding a <code>WordArray</code> such as <code>iv</code> to a string automatically calls its <code>toString()</code> function which in turn produces a big-endian hex-encoded string.</p>

<p>I wonder why you're using <code>iv</code> twice. Perhaps you meant <code>options</code> on one of them.</p>

<hr>

<p>What needs to change:</p>

<pre><code>function convert(wordArray){
    return sjcl.codec.hex.toBits(wordArray.toString());
}
var message = ""0301"" + encryption_salt + hmac_salt + iv;

var ciphertext = CryptoJS.AES.encrypt(plaintext, encryption_key, {iv: iv}).ciphertext;

message += ciphertext;
message = sjcl.codec.hex.toBits(message);

var hmac = new sjcl.misc.hmac(convert(hmac_key)).encrypt(message);

var encrypted_data = sjcl.bitArray.concat(message, hmac);
var output = sjcl.codec.hex.fromBits(encrypted_data);

console.log(output);
</code></pre>
","277","<javascript><cryptojs><bitarray><rncryptor><sjcl>","1","2","1","2016-05-13 19:03:17","32105993","0","","","","","2015-08-19 20:51:10",""
"37789525","Ciphertext is not converting to plain text and is not being alerted","<p>I am not able to decrypt a ciphertext. I have to test that my decryption is working properly or not. So, I created a simple html file which take cipher text and than convert it into plain text. </p>

<p>I just here hardcoding the value and than converting ciphertext into plain text.</p>

<p>When I tried it it was not working at all. I don't understand what is the issue.</p>

<p>This is my code</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src=""tripledes.js""&gt;&lt;/script&gt;
    &lt;script src=""mode-ecb.js""&gt;&lt;/script&gt;
    &lt;style type=""text/css""&gt;
&lt;script type=""text/javascript""&gt;

        function decryptByDES(aHJHDJSHJhjsak=, highishjdhsjhjs) {
            var keyHex = CryptoJS.enc.Utf8.parse(highishjdhsjhjs);

            var decrypted = CryptoJS.DES.decrypt({
                ciphertext: CryptoJS.enc.Base64.parse(aHJHDJSHJhjsak=)
            }, keyHex, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });

            return decrypted.toString(CryptoJS.enc.Utf8);
            alert ( decrypted);
        }


    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=""maindiv""&gt;
        &lt;div&gt;
            &lt;label for=""name""&gt;Message:&lt;/label&gt;
            &lt;input type=""text"" id=""msg"" name=""msg"" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=""mail""&gt;Key:&lt;/label&gt;
            &lt;input type=""text"" id=""key"" name=""key"" /&gt;
        &lt;/div&gt;

        &lt;div class=""button""&gt;
            &lt;button onclick=""decryptByDES()""&gt;View&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>and my  mode-ecb.js file is</p>

<pre><code>/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Electronic Codebook block mode.
 */
CryptoJS.mode.ECB = (function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();

    ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.encryptBlock(words, offset);
        }
    });

    ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.decryptBlock(words, offset);
        }
    });

    return ECB;
}());
</code></pre>

<p>I need to show my decrypted text in an alert. But nothing is happening. </p>
","<p>I'm not familiar with CryptoJS, but... It looks like you need to move the alert before the <code>return decrypted.toString(CryptoJS.enc.Utf8);</code> line, as the alert won't get called once the function returns.</p>

<p>Also, it would be better practice to make your key and cipher text variable strings, then call it from the button passing in those variables (although you may want to store your key in the javascript, and only pass in the cipherTextString).</p>

<pre><code>&lt;script type=""text/javascript""&gt;
    function decryptByDES(cipherTextString, keyString) {
        var keyHex = CryptoJS.enc.Utf8.parse(keyString);

        var decrypted = CryptoJS.DES.decrypt({
            ciphertext: CryptoJS.enc.Base64.parse(cipherTextString)
        }, keyHex, {
            mode: CryptoJS.mode.ECB,
            padding: CryptoJS.pad.Pkcs7
        });

        var decryptedStringified = decrypted.toString(CryptoJS.enc.Utf8);

        alert(decryptedStringified);

        return decryptedStringified;
    }
&lt;/script&gt;
</code></pre>

<p>And then call it from your button, passing in the correct variables:</p>

<pre><code>&lt;button onclick=""decryptByDES('aHJHDJSHJhjsak=', 'highishjdhsjhjs');""&gt;View&lt;/button&gt;
</code></pre>
","271","<javascript><encryption><cryptojs>","1","1","2","2016-06-14 10:40:12","37789840","0","","1816580","","2016-06-13 16:54:57","2016-06-13 12:10:32",""
"37789525","Ciphertext is not converting to plain text and is not being alerted","<p>I am not able to decrypt a ciphertext. I have to test that my decryption is working properly or not. So, I created a simple html file which take cipher text and than convert it into plain text. </p>

<p>I just here hardcoding the value and than converting ciphertext into plain text.</p>

<p>When I tried it it was not working at all. I don't understand what is the issue.</p>

<p>This is my code</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script src=""tripledes.js""&gt;&lt;/script&gt;
    &lt;script src=""mode-ecb.js""&gt;&lt;/script&gt;
    &lt;style type=""text/css""&gt;
&lt;script type=""text/javascript""&gt;

        function decryptByDES(aHJHDJSHJhjsak=, highishjdhsjhjs) {
            var keyHex = CryptoJS.enc.Utf8.parse(highishjdhsjhjs);

            var decrypted = CryptoJS.DES.decrypt({
                ciphertext: CryptoJS.enc.Base64.parse(aHJHDJSHJhjsak=)
            }, keyHex, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.Pkcs7
            });

            return decrypted.toString(CryptoJS.enc.Utf8);
            alert ( decrypted);
        }


    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div class=""maindiv""&gt;
        &lt;div&gt;
            &lt;label for=""name""&gt;Message:&lt;/label&gt;
            &lt;input type=""text"" id=""msg"" name=""msg"" /&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=""mail""&gt;Key:&lt;/label&gt;
            &lt;input type=""text"" id=""key"" name=""key"" /&gt;
        &lt;/div&gt;

        &lt;div class=""button""&gt;
            &lt;button onclick=""decryptByDES()""&gt;View&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>and my  mode-ecb.js file is</p>

<pre><code>/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/**
 * Electronic Codebook block mode.
 */
CryptoJS.mode.ECB = (function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();

    ECB.Encryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.encryptBlock(words, offset);
        }
    });

    ECB.Decryptor = ECB.extend({
        processBlock: function (words, offset) {
            this._cipher.decryptBlock(words, offset);
        }
    });

    return ECB;
}());
</code></pre>

<p>I need to show my decrypted text in an alert. But nothing is happening. </p>
","<p><sup><em>In addition to Jem's answer...</em></sup></p>

<p>If you want to hardcode a key, then you can do many things, but all of them should involve some kind of code obfuscation, because a client might just open the developer tools and read the key.</p>

<p>Ways to hardcode the key, here are two simple ways that don't leak the key to the global object ...</p>

<ol>
<li><p>In the local scope of the function that does the encryption/decryption</p>

<pre><code>function decryptByDES(cipherTextString) {
    var keyHex = CryptoJS.enc.Utf8.parse(""mykeystring12345"");
    var decrypted = CryptoJS.DES.decrypt({
    //...
}
</code></pre></li>
<li><p>In an wrapper scope (here used in an IIFE), but not in global scope</p>

<pre><code>(function(){
    var keyHex = CryptoJS.enc.Utf8.parse(""mykeystring12345"");
    function decryptByDES(cipherTextString) {
        var decrypted = CryptoJS.DES.decrypt({
        //...
    }
})();
</code></pre></li>
</ol>

<p>A few things to note:</p>

<ul>
<li><p>If you hardcode the key, then this doesn't provide any real security if the file the key is in is transmitted insecurely. You definitely need HTTPS, but if you have HTTPS you likely don't need the encryption provided by CryptoJS. (<a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">Ref</a>)</p></li>
<li><p>DES supports only one key size of exactly 8 <em>bytes</em>. If you cannot supply keys (which should look like random noise), then you're probably supplying a password, which does not need to have this specific length requirements. Since passwords <strong>cannot</strong> be used as keys, you will need to derive a key from that password. CryptoJS supports PBKDF2 for that. If you're supplying a key that does not have the required size, then you will get strange results, but don't expect an error from CryptoJS.</p></li>
<li><p><strong>Don't use DES nowadays.</strong> It only provides 56 bit of security. AES would be a much better, because it's more secure with the lowest key size of 128 bit. There is also a practical limit on the maximum ciphertext size with DES. See <a href=""https://security.stackexchange.com/q/26179/45523"">Security comparison of 3DES and AES</a>.</p></li>
<li><p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p></li>
</ul>
","271","<javascript><encryption><cryptojs>","1","1","2","2016-06-14 10:40:12","37789840","0","","1816580","","2016-06-13 16:54:57","2016-06-13 12:10:32",""
"20549235","javascript encoding not working properly","<p>I am facing problem in encoding in JavaScript, I am not getting expected result here</p>

<p>here are few things that I want to list down
- 1) when I am doing encoding in ruby then getting expected result.
- 2) but when I am tring to follow same steps in JavaScript then not getting expected result</p>

<hr>

<p>1) <strong>please find below the code of ruby which is working fine.</strong></p>

<pre><code>require 'openssl'
require ""base64""
key =  Base64.decode64(""yZQungXDXtksG4Ypcl0f6moRXWTCHh/CYDViXnZvbC0="")
data = ""&lt;content&gt;&lt;app-id&gt;9cd73144-46ca-4a02-852b-fa452b1d8bdc&lt;/app-id&gt;&lt;hmac&gt;HMACSHA256&lt;/hmac&gt;&lt;signing-time&gt;2013-11-19T12:06:11.409Z&lt;/signing-time&gt;&lt;/content&gt;""
result  = OpenSSL::HMAC.digest('sha256', key , data)
final_result = Base64.encode64(result)
</code></pre>

<p><strong>ruby output: received expected output</strong> </p>

<pre><code>Key =  ""\xC9\x94.\x9E\x05\xC3^\xD9,\e\x86)r]\x1F\xEAj\x11]d\xC2\x1E\x1F\xC2`5b^vol-""
result = ""\xC4\x9B\x94\x9C\anQT\xF9';\xE9$\x1C\x98k\xEE)\xD77\xFD\xCA\a\xD1L\xBB\x9B\xD2r\xE9\x1A\xA8""
final_result = ""xJuUnAduUVT5JzvpJByYa+4p1zf9ygfRTLub0nLpGqg=\n""
</code></pre>

<p>2) <strong>please find below the code of JavaScript which is not working as expected</strong></p>

<ul>
<li>Used crypo.js for encoding and decoding</li>
</ul>

<hr>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;

    &lt;script&gt;
      key = window.atob(""yZQungXDXtksG4Ypcl0f6moRXWTCHh/CYDViXnZvbC0="");
      data = ""&lt;content&gt;&lt;app-id&gt;9cd73144-46ca-4a02-852b-fa452b1d8bdc&lt;/app-id&gt;&lt;hmac&gt;HMACSHA256&lt;/hmac&gt;&lt;signing-time&gt;2013-11-19T12:06:11.409Z&lt;/signing-time&gt;&lt;/content&gt;"";
      console.log(""key"");
      console.log(key);
      result = CryptoJS.HmacSHA256(data, key);
      console.log(""result"");
      console.log(result.toString());
      final_result = CryptoJS.enc.Base64.stringify(result);
      console.log(""final_result"");
      console.log(final_result.toString());
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Javascript output: received expected output</strong> </p>

<pre><code>Key =  "".^,)r]j]d`5b^vol-""
result = ""035a028de6bea2c7843b4310b28b57f5193d7597840ea2f23c255cb889d77d60""
final_result = ""A1oCjea+oseEO0MQsotX9Rk9dZeEDqLyPCVcuInXfWA=""
</code></pre>

<p>so here I am not understanding, why i am getting <code>key</code>, <code>result</code> and <code>final_result</code> different in <code>ruby and JavaScript</code></p>

<p>Please share your experience, it would help me alot</p>

<p>Thanks </p>
","<p>you may need to use Base64.strict_encode64 (<a href=""http://ruby-doc.org/stdlib-1.9.3/libdoc/base64/rdoc/Base64.html#method-i-strict_encode64"" rel=""nofollow"">http://ruby-doc.org/stdlib-1.9.3/libdoc/base64/rdoc/Base64.html#method-i-strict_encode64</a>)
strict_encode is fully RFC compliant, whereas .encode is not.  Most implementations don't care about this specific issue (has to do w/new line characters), but some do.</p>
","269","<javascript><ruby><encoding><decoding><cryptojs>","2","-1","2","2013-12-16 13:41:05","","0","","1753188","","2013-12-13 08:05:47","2013-12-12 16:46:00",""
"20549235","javascript encoding not working properly","<p>I am facing problem in encoding in JavaScript, I am not getting expected result here</p>

<p>here are few things that I want to list down
- 1) when I am doing encoding in ruby then getting expected result.
- 2) but when I am tring to follow same steps in JavaScript then not getting expected result</p>

<hr>

<p>1) <strong>please find below the code of ruby which is working fine.</strong></p>

<pre><code>require 'openssl'
require ""base64""
key =  Base64.decode64(""yZQungXDXtksG4Ypcl0f6moRXWTCHh/CYDViXnZvbC0="")
data = ""&lt;content&gt;&lt;app-id&gt;9cd73144-46ca-4a02-852b-fa452b1d8bdc&lt;/app-id&gt;&lt;hmac&gt;HMACSHA256&lt;/hmac&gt;&lt;signing-time&gt;2013-11-19T12:06:11.409Z&lt;/signing-time&gt;&lt;/content&gt;""
result  = OpenSSL::HMAC.digest('sha256', key , data)
final_result = Base64.encode64(result)
</code></pre>

<p><strong>ruby output: received expected output</strong> </p>

<pre><code>Key =  ""\xC9\x94.\x9E\x05\xC3^\xD9,\e\x86)r]\x1F\xEAj\x11]d\xC2\x1E\x1F\xC2`5b^vol-""
result = ""\xC4\x9B\x94\x9C\anQT\xF9';\xE9$\x1C\x98k\xEE)\xD77\xFD\xCA\a\xD1L\xBB\x9B\xD2r\xE9\x1A\xA8""
final_result = ""xJuUnAduUVT5JzvpJByYa+4p1zf9ygfRTLub0nLpGqg=\n""
</code></pre>

<p>2) <strong>please find below the code of JavaScript which is not working as expected</strong></p>

<ul>
<li>Used crypo.js for encoding and decoding</li>
</ul>

<hr>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;

    &lt;script&gt;
      key = window.atob(""yZQungXDXtksG4Ypcl0f6moRXWTCHh/CYDViXnZvbC0="");
      data = ""&lt;content&gt;&lt;app-id&gt;9cd73144-46ca-4a02-852b-fa452b1d8bdc&lt;/app-id&gt;&lt;hmac&gt;HMACSHA256&lt;/hmac&gt;&lt;signing-time&gt;2013-11-19T12:06:11.409Z&lt;/signing-time&gt;&lt;/content&gt;"";
      console.log(""key"");
      console.log(key);
      result = CryptoJS.HmacSHA256(data, key);
      console.log(""result"");
      console.log(result.toString());
      final_result = CryptoJS.enc.Base64.stringify(result);
      console.log(""final_result"");
      console.log(final_result.toString());
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Javascript output: received expected output</strong> </p>

<pre><code>Key =  "".^,)r]j]d`5b^vol-""
result = ""035a028de6bea2c7843b4310b28b57f5193d7597840ea2f23c255cb889d77d60""
final_result = ""A1oCjea+oseEO0MQsotX9Rk9dZeEDqLyPCVcuInXfWA=""
</code></pre>

<p>so here I am not understanding, why i am getting <code>key</code>, <code>result</code> and <code>final_result</code> different in <code>ruby and JavaScript</code></p>

<p>Please share your experience, it would help me alot</p>

<p>Thanks </p>
","<p>I have tried a lot and find the solution below.</p>

<pre><code>&lt;html&gt;
  &lt;head&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/hmac-sha256.js""&gt;&lt;/script&gt;
    &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js""&gt;&lt;/script&gt;
    &lt;script src=""jquery.base64.js""&gt;&lt;/script&gt;
    &lt;script&gt;
      var key = Base64.decode(""yZQungXDXtksG4Ypcl0f6moRXWTCHh/CYDViXnZvbC0="");
      console.log(key)
      words = CryptoJS.enc.Latin1.parse(key);
      words = CryptoJS.enc.Hex.parse(words.toString());
     result = CryptoJS.HmacSHA256(""&lt;content&gt;&lt;app-id&gt;9cd73144-46ca-4a02-852b-fa452b1d8bdc&lt;/app-id&gt;&lt;hmac&gt;HMACSHA256&lt;/hmac&gt;&lt;signing-time&gt;2013-11-19T12:06:11.409Z&lt;/signing-time&gt;&lt;/content&gt;"", words);
     console.log(result);
     final_result = CryptoJS.enc.Base64.stringify(result);
     console.log(final_result);
   &lt;/script&gt;
 &lt;/head&gt;
&lt;/html&gt;
</code></pre>

<p><strong>Now I am getting expected result.</strong></p>

<pre><code>key = "".^,)r]j]d`5b^vol-""
result = ""c49b949c076e5154f9273be9241c986bee29d737fdca07d14cbb9bd272e91aa8""
final_result = ""xJuUnAduUVT5JzvpJByYa+4p1zf9ygfRTLub0nLpGqg=""
</code></pre>
","269","<javascript><ruby><encoding><decoding><cryptojs>","2","0","2","2013-12-16 13:41:05","","0","","1753188","","2013-12-13 08:05:47","2013-12-12 16:46:00",""
"53775159","Error of bad decrypt when decrypting using private decrypt (publicEncrypt, privateDecrypt)","<p>I am <a href=""https://nodejs.org/docs/latest-v10.x/api/crypto.html"" rel=""nofollow noreferrer"">crypto</a> of NodeJs v10.14.2 to create asymmetric key pair.
Public and private keys are generated successfully. After that i want to encrypt a string using public key and wants to decrypt using private key but in this case encryption works fine with publicEncrypt but after that using privateDecrypt is gives error of bad decrypt</p>

<pre><code>Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt.
</code></pre>

<p>Here is my code</p>

<pre><code>const { writeFileSync } = require('fs')
const { generateKeyPairSync, publicEncrypt, publicDecrypt, privateEncrypt, privateDecrypt } = require('crypto')
const passphrase = ""1234567890""
function generateKeys() {
    const {
        privateKey,
        publicKey
    } = generateKeyPairSync('rsa', {
        modulusLength: 1024,
        publicKeyEncoding: {
            type: 'pkcs1',
            format: 'pem',
        },
        privateKeyEncoding: {
            type: 'pkcs1',
            format: 'pem',
            cipher: 'aes-256-cbc',
            passphrase,
        },
    })

    encryptD(publicKey, privateKey) 
}
let string = ""Hello this string will be encrypted""
function encryptD(publicKey, privateKey)
{
    let buf = Buffer.from(string)
    console.log(buf)
    //&lt;Buffer 48 65 6c 6c 6f 20 74 68 69 73 20 73 74 72 69 6e 67 20 77 69 6c 6c 20 62 65 20 65 6e 63 72 79 70 74 65 64&gt;
    let encData = publicEncrypt(publicKey, buf)
    console.log(""Encrypted Buffer"", encData)
    //Encrypted Buffer &lt;Buffer 1b bc fb ee ba c3 90 ca 87 37 3c 6a 0b 38 4b bd 92 8a 7c 1e 7c dd 06 26 58 5f 0b 35 f6 81 8f 55 58 03 db e2 a5 4d 2b d2 41 32 31 5e 6b 2a 62 e7 d6 b6 ... &gt;
    let dncData = privateDecrypt(privateKey, encData)
    //Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
    console.log(""decrypted "", dncData)
}
generateKeys()
</code></pre>

<p>I have no clue where i am doing wrong
Thanks for the help</p>
","","265","<node.js><cryptojs><encryption-asymmetric>","1","","0","2018-12-14 07:30:28","","1","","7488168","","2018-12-14 07:30:28","2018-12-14 07:24:04",""
"47273020","Generate SHA1 HMAC with UTF-8 input on JavaScript (not Node.js)","<p>With that lib : 
<a href=""http://locutus.io/php/misc/pack/"" rel=""nofollow noreferrer"">http://locutus.io/php/misc/pack/</a>
Bufferize secret for hmac:</p>

<pre><code>var packedSecr = pack('H*', $secret);
</code></pre>

<p>Than pack time:</p>

<pre><code>var packedTime = pack('NN', 0, Math.floor((time() + $time_offset) / 30));
</code></pre>

<p>both strings has UTF-8 characters and fully coincide with PHPs packed.
Than I need create hash_hmac and here has a troubles:</p>

<pre><code>function hash_hmac(str,key){
    var hash = CryptoJS.HmacSHA1(str, key);
    var resInUTF8 = convertWordArrayToUint8Array(hash);
    var string = new TextDecoder('utf-8').decode(resInUTF8);
    console.log(hash.toString());
    /* 5cdc66cb8cf2a08b78f149502e05b9538c7a72a9*/
    console.log(string);
    /* \fxIP.Szr */
    return string;
}
</code></pre>

<p>But PHP make defferent hmac:</p>

<pre><code>$hmac = hash_hmac('sha1', $packedTime, $bufferedSecret, true);
echo $hmac;
/* vjqV */
$hmac = hash_hmac('sha1', $packedTime, $bufferedSecret, false);
echo $hmac;
/* 17761ff6f06ad0db71f0a588fcf002d756c1d1eb */
</code></pre>

<p>For convert WordArray used that mini lib:
<a href=""https://gist.github.com/getify/7325764"" rel=""nofollow noreferrer"">https://gist.github.com/getify/7325764</a></p>

<p>If I just create hmac with ""A-z"" and ""0-9"" symbols all is coincide.
PHP:</p>

<pre><code>$string = ""aBc059"";
$secret = ""Tcs437"";
echo hash_hmac('sha1', $string, $secret, false); 
/* 00012176b13b26f8fdb9f8dfcaf553e9aa0401ac */
echo hash_hmac('sha1', $string, $secret, true);
/* !v;&amp;S */
</code></pre>

<p>JS:</p>

<pre><code>var string = ""aBc059"";
var secret = ""Tcs437"";

hash_hmac(string,secret)

function hash_hmac(str,key){
    var hash = CryptoJS.HmacSHA1(str, key);
    var resInUTF8 = convertWordArrayToUint8Array(hash);
    var string = new TextDecoder('utf-8').decode(resInUTF8);
    console.log(hash.toString());
    /* 00012176b13b26f8fdb9f8dfcaf553e9aa0401ac */
    console.log(string);
    /* !v;&amp;S */
    return string;
}
</code></pre>
","","262","<javascript><utf-8><hmac><cryptojs><hmacsha1>","1","","0","2017-11-13 20:37:58","","0","1","8833582","","2017-11-13 20:37:58","2017-11-13 20:29:32",""
"34029274","Coldfusion decrypt won't work with CryptoJS: Given final block not properly padded","<p>I'm struggling with encrypting a username and password using CryptoJS and decrypting it on a remote CFC on my Coldfusion/Railo server. The error message I receive is: <em>Given final block not properly padded</em>. I have seen related topics but I can't 'translate' the solution to my case.</p>

<p>Here is the JavaScript that calls the function on the server:</p>

<pre><code>var username = ""hr_muller@blabla.com""
var password = ""12345""
var ident = username.concat('|',password)

var key = CryptoJS.enc.Utf8.parse(""dotterbloem20151"");
var key  = CryptoJS.enc.Base64.stringify(key);

var encrypted = CryptoJS.AES.encrypt(ident, key, {iv: key});

//In my JS the encryption/decryption works fine
var decrypted = CryptoJS.AES.decrypt(encrypted, key, {iv: key});
document.write(decrypted.toString(CryptoJS.enc.Utf8));
document.write('&lt;BR&gt;')
document.write(decrypted.toString(key));

var url = ""cfc/roland.cfc?method=checkLoginstatus"";
$.ajax({
     url: url,
     type: 'POST',
     dataType: ""json"",
     data: { ""webkey"" : encrypted.toString() }, 
     success: function(response) {
     }
});
</code></pre>

<p>And here is the function in my CFC:</p>

<pre><code>&lt;cffunction name=""checkLoginstatus"" access=""remote"" returntype=""any"" returnformat=""plain""&gt;

    &lt;cfargument name=""webkey"" /&gt;

    &lt;cfoutput&gt;
        &lt;cfset myKey = Tobase64(""dotterbloem20151"") /&gt;
        &lt;cfset myIV = charsetDecode(""dotterbloem20151"", ""utf-8"" )&gt;
        #Decrypt(ARGUMENTS.webkey, myKey, ""AES/CBC/PKCS5Padding"", ""base64"", myIV)#
    &lt;/cfoutput&gt;

&lt;/cffunction&gt;
</code></pre>
","<p>I don't know Coldfusion, but it looks like you're using the same password to derive a key and IV from it, but each of them differently.</p>

<p>You can do this in CryptoJS:</p>

<pre class=""lang-js prettyprint-override""><code>var iv = CryptoJS.enc.Utf8.parse(""dotterbloem20151"");
var key = CryptoJS.enc.Base64.stringify(iv);

var encrypted = CryptoJS.AES.encrypt(ident, key, {iv: iv});
</code></pre>

<p>This is a strange way to derive a key, because the 16 character password is encoded to Base 64 resulting in 24 encoded characters. 16 bytes and 24 bytes are both valid key sizes for AES, but using Base 64 to derive a key is at the very least strange.</p>

<hr>

<p>This code is not very secure. If you have passwords, then you need to derive the key from that password in a secure fashion. You would need to utilize PBKDF2 with a random salt and many iterations. See <a href=""https://security.stackexchange.com/q/211/45523"">How to securely hash passwords?</a></p>

<p>The IV also has to be randomly generated. It doesn't have to be secret, so you can simply send it along with the ciphertext.</p>
","261","<encryption><coldfusion><aes><cryptojs>","0","2","1","2015-12-01 22:11:47","","0","1","1816580","","2015-12-01 22:11:47","2015-12-01 20:13:40",""
"34542736","Encrypt (cryptojs) - Decrypt (erlang)","<p>I have a value encrypted with cryptoJS (AES) and need to decrypt using Erlang crypto library. The problem for me lies in the fact that to be able to decrypt in Erlang using <code>aes_cbc_128_decrypt(Key, IVec, Cipher)</code> I presume, I will need to know what the IVec is that was used and how the Key should be made up. </p>

<pre><code>var ciphertext = Crypt.AES.encrypt(""message here"", ""4445"");  
// U2FsdGVkX1+ZxppJRvcbdWJW1xAxSlm2akm7ZFnY9GU=
</code></pre>
","<p>IVec = &lt;&lt;0:128>>, and the length of the key should be a multiple of 16.</p>
","261","<encryption><erlang><cryptojs><kdf>","3","0","1","2017-04-17 08:31:03","","1","","1816580","","2015-12-31 08:36:16","2015-12-31 07:19:56",""
"55875275","CryptoJS decryption results in Malformed UTF-8 data","<p>So here is my problem.</p>

<p>I am encrypting a value through a nodeJS script on my local machine (MacBook Pro) and uploading the resulting encoded value as a string to firebase.</p>

<p>I have an angular app that reads the value from values decrypts it and converts it to a UTF8 string. However, I am getting malformed UTF8 error.</p>

<p>Now, I know the encryption is correct since if I decrypt the cipherText in the same script on my macbook, it decrypts it fine. Here is the encryption code running my my local machine:</p>

<pre><code>const cipherBytes = CryptoJS.AES.encrypt(strVal, key, opts);
const cipherText = cipherBytes.toString();

// This works fine on my local machine
console.log('Decrypted', CryptoJS.AES.decrypt(cipherText, key, opts).toString(CryptoJS.enc.Utf8));
</code></pre>

<p>For example, here is a sample cipherText from a run </p>

<blockquote>
  <p>U2FsdGVkX19wrG5ar3MGcBf8EXxDyO7HuE9vvaTsBvA=</p>
</blockquote>

<p>This string gets stored in Firebase.</p>

<p>Next I upload the cipherText to firebase. My angular app will read it and get the error. Note that the angular app has no problem decrypting ciphers that it encrypted. The problem is trying to decrypt ciphers encrypted on my local Mac.</p>

<p>I am suspecting this has to do with how a Mac represents binary data vs Google's servers, but not sure what the solution is here</p>
","","257","<javascript><node.js><angular><firebase><cryptojs>","0","","0","2019-06-13 07:22:13","","0","1","","","","2019-04-26 21:45:04",""
"35137122","How to call Tether.to API in Angular.js using CryptoJS","<p>I'm developing an app in Angularjs which calls some APIs of the Tether.to site (<a href=""http://platform.tether.to/"" rel=""nofollow"">http://platform.tether.to/</a>).</p>

<p>The API requires to send header following this form:</p>

<pre><code>Authorization: APIAuth TetherAPIKey:Signature
</code></pre>

<p>The Authorization header is computed as following:</p>

<pre><code>Authorization = APIAuth +   + TetherAPIKey + : + Signature;
Signature = Base64( HMAC-SHA1( TetherAPISecret, StringToSign ) );
StringToSign = Content-Type + , + Content-MD5 + , + URI + , + Timestamp; 
</code></pre>

<p>I implemented using below code in AngularJS:</p>

<pre><code>var url, timestamp, stringToSign, signature, request, r,
    apiKey = 'xxxxxxx', apiSecret = 'xxxxxxxPo95gm9eoCeFyTTw3zeCFf';
url = 'https://wallet.tether.to/api/v1/transactions';
timestamp = new Date().toUTCString();
stringToSign = 'application/json,' + CryptoJS.MD5('') + ',' + url + ',' + timestamp;
signature = CryptoJS.enc.Base64.stringify(CryptoJS.HmacSHA1(stringToSign, apiSecret));
request = {
    headers: { 'Authorization': 'APIAuth ' + apiKey + ':' + signature }
};
r = $http.get(url, request).success(function(data) {
    console.log(data);
});
</code></pre>

<p>Where's the wrong in my code? Why does the API (""/transactions"") always return <code>{""code"":401,""error"":""Unauthorized""}</code>?</p>
","<p>CryptoJS encodes by default to Hex when you force the WordArray to be converted to string, but <code>Content-MD5</code> must be Base 64 encoded (judging from the ruby code of the project).</p>

<p>Try:</p>

<pre><code>stringToSign = 'application/json,' + CryptoJS.MD5('').toString(CryptoJS.enc.Base64) + ',' + url + ',' + timestamp;
</code></pre>
","253","<angularjs><cryptojs>","0","0","1","2016-02-01 20:27:03","","0","","1816580","","2016-02-01 20:27:03","2016-02-01 17:53:03",""
"32376492","Integrating CryptoJS library with jQuery-file-upload","<p>I want to integrate <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow noreferrer"">CryptoJS</a> library with <a href=""https://github.com/blueimp/jQuery-File-Upload"" rel=""nofollow noreferrer"">jQuery-file-upload</a> widget by blueimp. I want to implement cilent-side encryption for file upload and <a href=""https://stackoverflow.com/questions/12786320/how-should-i-implement-client-side-encryption-in-a-jquery-file-upload-plugin"">this</a> question was asked but not answered.</p>

<p>I am currently doing following procedure. But the file being uploaded is not the encrypted one that I am creating in js. Where am I making a mistake? Or is there a better way to do this? </p>

<p>I know that data.files[index_number] gives the file which is stored as a blob. I want to replace the file with the encrypted version of the same. So I do</p>

<pre><code>    var reader = new window.FileReader();
    var myFile = data.files[0];

    //create a blob
    var inputBlob = myFile.slice(0,myFile.size);
    reader.readAsText(inputBlob);

    reader.onload(function() {
        var strToEncrypt = reader.result();

        //get key and iv
        var key = CryptoJS.enc.Base64.parse(""my_key"");
        var iv = CryptoJS.enc.Base64.parse(""my_iv"");

        //encrypt
        var encryptedObject = CryptoJS.AES.encrypt(strToEncrypt , key, { iv: iv });

        //extract and stringify ciphertext from encrypted file object
        var encryptedString = CryptoJS.enc.Base64.stringify(encryptedObject.ciphertext);

        //do this procedure to convert to blob
        var byteChars = atob(encryptedString);
        var byteNumbers = new Array(byteChars.length);
        for (var i = 0; i &lt; byteChars.length; i++) {
             byteNumbers[i] = byteChars.charCodeAt(i);
        }
        var byteArray = new Uint8Array(byteNumbers);
    }
        var outputBlob = new Blob([byteArray], {type: ""file""});

        //function to create a file from blob
        function blobToFile(theBlob, fileName){
        //A Blob() is almost a File() - it's just missing the two properties below which we will add now
                    theBlob.lastModifiedDate = new Date();
                    theBlob.name = fileName;
                    return theBlob;
        }

        //make the final file
        var outputFile = blobToFile(outputBlob, ""encr_file"");

        //replace original file with this file
        data.files[0] = outputFile;
</code></pre>

<p>Please help.</p>
","","253","<javascript><jquery><file-upload><blueimp><cryptojs>","1","","0","2015-09-03 13:40:42","","0","1","-1","","2017-05-23 11:44:03","2015-09-03 13:05:35",""
"52269567","Digitally sign HTML-form using hwcrypto","<p>I'm looking for a way to digitally sign an HTML-form with PKCS#11 (smart card) with <a href=""https://github.com/hwcrypto/hwcrypto.js/wiki/ModernAPI"" rel=""nofollow noreferrer"">hwcrypto</a>. </p>

<p>Context: at our company we use <a href=""https://www.combodo.com/itop-193"" rel=""nofollow noreferrer"">Combodo's iTop</a> as CMDB. Company devices need to be registered and the employee needs to sign a proof of loan. I like to make this proof digitally. Since we use full PKI enabled company cards, employees can sign these proof digitally with their card (and pin). 
I've written a simple <a href=""https://www.itophub.io/wiki/page?id=2_4_0%3Acustomization%3Aadd-menu-sample"" rel=""nofollow noreferrer"">plugin for iTop</a> to generate a proof (PDF) prefilled for the device. But when I want to save the signed PDF back to iTop (via <a href=""https://www.itophub.io/wiki/page?id=2_2_0%3Aadvancedtopics%3Arest_json"" rel=""nofollow noreferrer"">REST API</a>) it turned out to be such a hassle.</p>

<p>Now working on a way to generate a base64-encoded stream of HTML-fields and signing details to offer the REST-API of iTop.
I installed <code>hwcrypto.js</code> on the server. In Firefox I installed the <a href=""https://github.com/open-eid/firefox-pkcs11-loader"" rel=""nofollow noreferrer"">Firefox PKCS11 loader plugin</a> from ID. But I keep getting:</p>

<blockquote>
  <p>Debug: hwcrypto.js 0.0.13 with failing backend No implementation getCertificate() failed: Error: no_implementation</p>
</blockquote>

<p>Does someone know how to connect the hwcrypto.js to the physical card reader? Firefox sees it (Options - Advanced - Security Devices.    </p>
","","252","<javascript><cryptojs><pkcs#11><cmdb>","2","","0","2018-09-11 07:21:33","","0","","3187077","","2018-09-11 07:21:33","2018-09-11 06:02:10",""
"40482862","CryptoJS to OpenSSL encryption conversion","<p>I need to port some JavaScript code to a C99 backend. In the Javascript code they use CryptoJS to perform AES encryption:</p>

<pre><code>var key = CryptoJS.MD5(Math.random().toString()).toString();
key = CryptoJS.enc.Hex.parse(key);

var iv = CryptoJS.MD5(Math.random().toString()).toString();
iv = CryptoJS.enc.Hex.parse(iv);

var data = ""testdata"";
var encrypted = CryptoJS.AES.encrypt(data, key, { iv:iv, mode:CryptoJS.mode.CBC, padding:CryptoJS.pad.ZeroPadding });
</code></pre>

<p>Now I need to implement the same code in C with the OpenSSL library. I have created the random MD5 strings without problem but I cannot see how to implement the AES encryption with zero padding. This is what I have:</p>

<pre><code>bool crypto_aes_encrypt(const char* data, unsigned char *key, unsigned char *iv, unsigned char **out_buf, int *out_buf_len)
{
    ERR_load_crypto_strings();
    OPENSSL_add_all_algorithms_conf();

    /* Initialize the cipher context */
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if(!ctx) {
        return NULL;
    }

    /* Initialize the AES encryption */
    if(EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv) != 1) {
        return NULL;
    }

    /* Encrypt the data */
    *out_buf = (unsigned char*) malloc(2048 * sizeof(char));
    *out_buf_len = 0;
    if(EVP_EncryptUpdate(ctx, *out_buf, out_buf_len, (const unsigned char*) data, strlen(data)) != 1) {
        free(out_buf);
        return NULL;
    }

    if(EVP_EncryptFinal(ctx, *out_buf + *out_buf_len, out_buf_len) != 1) {
        free(out_buf);
        return NULL;
    }

    EVP_CIPHER_CTX_free(ctx);
    EVP_cleanup();
    ERR_free_strings();

    return true;
}
</code></pre>

<p>How can I implement the ZeroPadding in OpenSSL which is used in CryptoJS?</p>
","","252","<javascript><c><encryption><openssl><cryptojs>","1","","0","2016-11-09 11:17:56","","5","","608639","","2016-11-09 11:17:56","2016-11-08 09:08:02",""
"26262182","reading encrypted object in javascript","<pre><code>var token = ""WMwiDeJrawUKHif7D5a8yd4ne6Mv"";
var salt =  ""ERtrg56hfg5"";

var key = CryptoJS.enc.Hex.parse('B374A26A71490437AA024E4FADD5B497FDFF1A8EA6FF12F6FB65AF2720B59CCF');
var iv  = CryptoJS.enc.Hex.parse('7E892875A52C59A3B588306B13C31FBD');

var encrypted = CryptoJS.AES.encrypt(token, key, { iv: iv });

context.setVariable(""encryptedtoken"", encrypted);
</code></pre>

<p>but it is not setting to variable saying it is an object.
what I need to do </p>
","<p>I think you have to use <code>encrypted.ciphertext</code></p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(token, key, { iv: iv });

context.setVariable(""encryptedtoken"", encrypted.ciphertext);
</code></pre>

<p>From CryptoJS <a href=""https://code.google.com/p/crypto-js/#The_Cipher_Output"" rel=""nofollow"">documentation</a>: </p>

<p><strong>The ciphertext you get back after encryption isn't a string yet</strong>. It's a CipherParams object. A CipherParams object gives you access to all the parameters used during encryption. When you use a CipherParams object in a string context, it's automatically converted to a string according to a format strategy. The default is an OpenSSL-compatible format.</p>

<pre><code>&lt;script&gt;
    var encrypted = CryptoJS.AES.encrypt(""Message"", ""Secret Passphrase"");

    alert(encrypted.key);        // 74eb593087a982e2a6f5dded54ecd96d1fd0f3d44a58728cdcd40c55227522223
    alert(encrypted.iv);         // 7781157e2629b094f0e3dd48c4d786115
    alert(encrypted.salt);       // 7a25f9132ec6a8b34
    alert(encrypted.ciphertext); // 73e54154a15d1beeb509d9e12f1e462a0

    alert(encrypted);            // U2FsdGVkX1+iX5Ey7GqLND5UFUoV0b7rUJ2eEvHkYqA=
&lt;/script&gt;
</code></pre>
","251","<javascript><cryptojs>","0","0","1","2018-06-25 10:12:59","26262317","2","","1033581","","2018-06-25 10:12:59","2014-10-08 16:47:29",""
"50884630","Node.JS crypto.createHmac('sha256') command line analog","<p>In Node.js I use following code</p>

<pre><code>hash = crypto.createHmac('sha256', SECRET).update(file).digest('hex');
</code></pre>

<p>to calculate HMAC. However Linux command line analog produces different hash code:</p>

<pre><code>&gt; openssl sha256 -hmac ""SECRET"" file
</code></pre>

<p>What is wrong in command line? What are correct arguments?</p>
","","248","<node.js><linux><command-line><sha256><cryptojs>","1","","0","2018-06-16 03:08:49","","6","","","","","2018-06-16 03:08:49",""
"27982781","certificate Installation in Mozilla and Chrome","<p>how can i install a server generated browser certificate in Mozilla and Chrome using java script. ia have this method </p>

<pre><code>( 
var certData = document.getElementById(""certdata"").value;
 window.crypto.importUserCertificates(null, certData, false);
 )
</code></pre>

<p>but it is outdated and it doesn't works.</p>
","<p>The solution mentioned in comments - using content type ""application/x-x509-user-cert"" - has <a href=""https://blog.chromium.org/2016/02/chrome-49-beta-css-custom-properties.html"" rel=""nofollow noreferrer"">stopped working in Chrome since 2016</a> (Chrome 49). This feature has been <a href=""https://bugs.chromium.org/p/chromium/issues/detail?id=514767"" rel=""nofollow noreferrer"">deprecated</a>. The long-term alternative is to use the <a href=""https://www.w3.org/TR/WebCryptoAPI/"" rel=""nofollow noreferrer"">WebCrypto API</a>, or a higher-level API based on it, like <a href=""https://pkijs.org/"" rel=""nofollow noreferrer"">PKI.js</a>. </p>
","242","<javascript><google-chrome-devtools><cryptojs><firefox-developer-tools><ejbca>","3","1","2","2018-08-19 13:14:07","","5","1","2801530","","2015-01-16 11:21:41","2015-01-16 11:14:22",""
"27982781","certificate Installation in Mozilla and Chrome","<p>how can i install a server generated browser certificate in Mozilla and Chrome using java script. ia have this method </p>

<pre><code>( 
var certData = document.getElementById(""certdata"").value;
 window.crypto.importUserCertificates(null, certData, false);
 )
</code></pre>

<p>but it is outdated and it doesn't works.</p>
","<p>You can not.</p>

<p>Take a look at fortofyapp.com for some middleware that enables this use case.</p>
","242","<javascript><google-chrome-devtools><cryptojs><firefox-developer-tools><ejbca>","3","0","2","2018-08-19 13:14:07","","5","1","2801530","","2015-01-16 11:21:41","2015-01-16 11:14:22",""
"49432247","dbms_crypto output mismatches with crypto-js","<p>I'm working on creating an hmac-sha1 hash in Cerner's proprietary language, CCL. It's similar to PL/SQL and has access to native oracle functions. The idea is to mimic a hash created inside javascript. Oracle is using DBMS_CRYPTO and javascript is using CRYPTO.JS. Below are my two implementations, however I'm unable to get the hashes to match with basic testing strings.</p>

<p>If anyone can shed some light on what I'm doing wrong, I'd appreciate it! I've tried playing around with how I'm giving the data to the dbms_crypto.mac() function, but I'm not able to get it to match.</p>

<p>Javascript output: bad02f0a5324ad708bb8100220bae499e2c127b8</p>

<p>Codepen: <a href=""https://codepen.io/bookluvr416/pen/jzmVWx"" rel=""nofollow noreferrer"">https://codepen.io/bookluvr416/pen/jzmVWx</a></p>

<pre><code>var consumerKey = ""testConsumer"";  
var secretKey = ""testSecret"";  
var valueToSign = consumerKey + secretKey;  
var hmac = Crypto.HMAC(Crypto.SHA1, valueToSign.toLowerCase(), 
secretKey.toLowerCase(), { asBytes: false });  
</code></pre>

<p>DBMS_CRYPTO output: 0BCC191B3A941C95ECAA46C8F825394706096E62</p>

<p>PL/SQL Sample that I'm trying to base my CCL on:</p>

<pre><code>DECLARE
    typ       INTEGER := DBMS_CRYPTO.SH1;
    key       RAW(100) := 'testsecret';
    mac_value RAW(100);
BEGIN

mac_value := DBMS_CRYPTO.MAC('testconsumertestsecret', typ, key);

END;
</code></pre>

<p>Caveat - I'm not able to actually test the PL/SQL version, since I don't have an oracle sandbox to play in. I'm also not allowed to post the proprietary code on external websites, so I can't show my actual implementation.</p>
","<p>I was using an incorrect or outdated example.</p>

<pre><code>DBMS_CRYPTO.mac(UTL_I18N.string_to_raw(l_oauth_base_string, 'AL32UTF8') 
           ,DBMS_CRYPTO.hmac_sh1 
           ,UTL_I18N.string_to_raw(l_oauth_key, 'AL32UTF8'));
</code></pre>
","239","<plsql><cryptojs><hmacsha1><dbms-crypto>","0","1","1","2018-03-22 17:07:50","","0","","","","","2018-03-22 15:13:50",""
"48269945","Python bytestring => Javascript?","<p>I'm attempting to port some Python code to Javascript. Here is the Python code:</p>

<pre><code># Python 
import codecs
from Crypto.Cipher import AES
key = b""\xc3\x99\xff\xff\xc3\x99\xff\xff\xc3\x99\xff\xff\xc3\x99\xff\xff""
...
aes = AES.new(key, AES.MODE_ECB)
token = aes.encrypt(""HELLO\x00\x00"".encode(""utf-8""))
token_hex = codecs.encode(token, ""hex"").decode(""utf-8"")
</code></pre>

<p>I'm not exactly sure how to port my Python <code>key</code> variable. Should it be UInt16Array...or a string?</p>

<p>This is my Javascript so far:</p>

<pre><code>// Javascript
const crypto = require('crypto');
const key = '???' // &lt;-- This is one place I am stuck. String? Byte array?
....
const cipher = crypto.createCipher('aes-128-ecb', key);
let tokenHex = cipher.update('HELLO\x00\x00', 'utf8', 'hex');
tokenHex = tokenHex.toString('utf8')
</code></pre>

<p>I appreciate any insight you can provide as to how I can get a matching <code>tokenHex</code> in Javascript.</p>

<p>Thank you!</p>
","<p>What you are after is <a href=""https://nodejs.org/api/buffer.html#buffer_new_buffer_string_encoding"" rel=""nofollow noreferrer""><code>Buffer</code></a>, which represents a collection of bytes.</p>

<p>You probably want to instantiate the key variable similar to this:</p>

<pre><code>let key = Buffer.from(""c399ff..."", ""hex"");
</code></pre>
","238","<javascript><python><node.js><encryption><cryptojs>","0","2","1","2019-11-07 19:50:36","48269986","1","","","","","2018-01-15 20:05:43",""
"48430211","Python HMAC to CryptoJS","<p>My question is very similar to <a href=""https://stackoverflow.com/questions/38787349/translation-from-python-to-javascript-hmac-sha256"">Translation from Python to JavaScript: HMAC-SHA256</a>, however that question was never answered.</p>

<p>The following Python code produces the correct hash:</p>

<pre><code>def sign_api_request(api_secret, api_key, method, url):
    encoded_url = urllib.parse.quote(url.lower(), '').lower()
    timestamp = int(time.time())print(""timestamp: "" + str(timestamp))
    nonce = str(uuid.uuid4())

    signature = api_key + method + encoded_url + str(timestamp) + nonce

    secret_bytes = base64.b64decode(api_secret)

    signature_bytes = signature.encode('UTF8')

    signature_hash = hmac.new(secret_bytes, signature_bytes, hashlib.sha256).digest()
    base64_signature_hash = base64.b64encode(signature_hash).decode()

    print(base64_signature_hash)
</code></pre>

<p>I'm trying to generate the same hash string using Javascript (as a Postman pre-request script). Here's what I've got:</p>

<pre><code>function epochTime() {
    var d = new Date();
    var t = d.getTime();
    var o = t + """";
    return o.substring(0, 10);
}

function newGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r &amp; 0x3 | 0x8; return v.toString(16); });
}

var uri_path = encodeURIComponent(request.url.toLowerCase()).toLowerCase();
var payload = uri_path; //.toLowerCase();

timestamp = epochTime();
nonce = newGuid();
signature = environment.api_key + ""GET"" + payload + timestamp + nonce;

secret_bytes = atob(environment.api_secret);

var hash = CryptoJS.HmacSHA256(signature, secret_bytes);
var hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
var sig = ""amx "" + environment.api_key + "":"" + hashInBase64 + "":"" + nonce + "":"" + timestamp;
postman.setGlobalVariable(""signature"", sig);
</code></pre>

<p>If I use the same <code>timestamp</code> and <code>nonce</code> (by setting them explicitly rather than generating them at runtime) and the same <code>api_key</code> and <code>api_secret</code> (which are constant across calls) I expect to get the same value in <code>sig</code> (Javascript) as I do in <code>base64_signature_hash</code> (Python), however that's not the case.</p>

<p>I understand that this might be an encoding problem, but my js-fu is weak. Any ideas?</p>

<p>Edit to add: the <code>method</code> and <code>url</code> used for each are also the same.</p>
","<p>Basically, there are two issues. First, in both Python and JS code <strong>secret_bytes</strong> should be base64 encoded string. Second, in JavaScript code <strong>secret_bytes</strong> was not correctly decoded from base64 string. Please find below corrected Python and JavaScript examples.</p>

<p>Python:</p>

<pre class=""lang-py prettyprint-override""><code>import hmac
import time
import uuid
import base64
import hashlib
import urllib.parse


def sign_api_request(api_secret, api_key, method, url):
    encoded_url = urllib.parse.quote(url.lower(), '').lower()
    # timestamp = int(time.time())
    # nonce = str(uuid.uuid4())
    timestamp = str(1569158586);
    nonce = '708b7df1-7494-49fa-812c-e5f6c24aeab6'

    signature = api_key + method + encoded_url + timestamp + nonce
    # print(signature)

    secret_bytes = base64.standard_b64decode(api_secret)
    # print(secret_bytes)

    signature_bytes = signature.encode('UTF8')

    signature_hash = hmac.new(secret_bytes, signature_bytes, hashlib.sha256).digest()
    base64_signature_hash = base64.b64encode(signature_hash).decode()
    return base64_signature_hash 


base64_signature_hash = sign_api_request('MTIzNDU2NzgxMjM0NTY3ODEyMzQ1Njc4MTIzNDU2Nzg=', '0987654321', 'POST', '/signin')
print(base64_signature_hash)
</code></pre>

<p>JavaScript:</p>

<pre class=""lang-js prettyprint-override""><code>const CryptoJS = require('crypto-js');

function epochTime() {
    var d = new Date();
    var t = d.getTime();
    var o = t + """";
    return o.substring(0, 10);
}

function newGuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : r &amp; 0x3 | 0x8; return v.toString(16); });
}

let api_secret = 'MTIzNDU2NzgxMjM0NTY3ODEyMzQ1Njc4MTIzNDU2Nzg=';
let api_key = '0987654321';
let method = 'POST';
let url_path = '/signin';

let encoded_url = encodeURIComponent(url_path.toLowerCase()).toLowerCase();
let timestamp = '1569158586';
let nonce = '708b7df1-7494-49fa-812c-e5f6c24aeab6';

let signature = api_key + method + encoded_url + timestamp + nonce;
// console.log(signature);

let secret_bytes = new Buffer.from(api_secret, 'base64');
secret_bytes = secret_bytes.toString('ascii');
// console.log(secret_bytes);

let hash = CryptoJS.HmacSHA256(signature, secret_bytes);
let hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
console.log(hashInBase64);
</code></pre>

<p>Output should be same for both:</p>

<pre><code>1Hw92JPDJPFB3Je4MvwapODmn5S6KdIbvot3MAvg0jM=
</code></pre>
","237","<javascript><python><hmac><cryptojs>","2","0","1","2019-09-22 12:29:08","","0","","","","","2018-01-24 19:28:10",""
"53894466","CryptoJS AES-128-ECB and PHP openssl_encrypt don't match","<p>I have some code on PHP, which can't be edited and a database full of encrypted this way messages.</p>

<pre><code>$key = '297796CCB81D2553B07B379D78D87618'
return $encrypted = openssl_encrypt($data, 'AES-128-ECB', $key);
</code></pre>

<p>I have to write some JS code to encrypt and decrypt these messages. I'm using CryptoJS for this purpose. </p>

<pre><code>const key = '297796CCB81D2553B07B379D78D87618'
let k = CryptoJS.enc.Base64.parse(key)
let cypher = CryptoJS.AES.encrypt(this.text, k, {mode: CryptoJS.mode.ECB})
this.cypher = CryptoJS.enc.Base64.stringify(cypher.ciphertext)
</code></pre>

<p>I can not get these codes to produce the same results. For 'test' string i got following results: <code>JS: H1AG6j/i/iSqifSNCG5JKw==</code>, <code>PHP: Nqrur4UMEicEMwJC39qq0A==</code></p>

<p>I'm trying to work this out for 3 days, but I cannot find the issue. 
The only code I can edit is JS. </p>
","<p>I figured out what problem is.
openssl_encrypt in PHP takes the key as a UTF-8 string. After taking enough length, it ignores next characters, so our key: '297796CCB81D2553B07B379D78D87618' trims to '297796CCB81D2553'. 
This code is working:</p>

<pre><code>// JS 
const key = '297796CCB81D2553'
let k = CryptoJS.enc.Utf8.parse(key)
let cypher = CryptoJS.AES.encrypt(this.text, k, {mode: CryptoJS.mode.ECB})
this.cypher = CryptoJS.enc.Base64.stringify(cypher.ciphertext) 
</code></pre>
","237","<javascript><php><openssl><cryptojs>","1","0","1","2018-12-24 16:30:33","","2","","7931513","","2018-12-22 14:29:34","2018-12-22 09:23:23",""
"54947975","PHP Converting mcrypt to openssl","<p>I know 3DES and MD5 are insecure. I will work on replacing them once I have it working again,</p>

<p>I have a mobile app that is using 3DES with an MD5 of a key as a SECRET KEY to talk to a PHP Application.</p>

<p>Now this code worked perfectly on <strong>PHP 5.3</strong> (this is an example I have generated)</p>

<pre><code>mcrypt_decrypt(
    MCRYPT_3DES, 
    md5(
        utf8_encode(
            ""MobileAppSecureKey""
        ),
        true
    ), 
    base64_decode(""bkCfcseIt/TPsgNCdyX9fv2/4MjOJdaPXakNNbxQT3n6tXHa5bDoXojQ3g7jPLCu+wjwD0guQzw3hCFUSVx47PmDNHASk7g/kJ4K4tX0VGI=""), 
    MCRYPT_MODE_CBC, 
    base64_decode(""cTOCJ/iYL18="")
)
</code></pre>

<p>Now I have ported it over to use OpenSSL method my new code is</p>

<pre><code>openssl_decrypt(
    base64_decode(""bkCfcseIt/TPsgNCdyX9fv2/4MjOJdaPXakNNbxQT3n6tXHa5bDoXojQ3g7jPLCu+wjwD0guQzw3hCFUSVx47PmDNHASk7g/kJ4K4tX0VGI=""), 
    'DES-EDE3-CBC', 
    md5(
        utf8_encode(
            ""MobileAppSecureKey""
        ),
        true
    ), 
    0, 
    base64_decode(""cTOCJ/iYL18="")
)
</code></pre>

<p>But the new code does not work, It gives the error <code>error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length</code> from <code>openssl_error_string()</code></p>

<p>I'm unsure why it's complaining about final block length when this worked perfectly in mcrypt</p>

<p>The code used to generate the test data was from the mobile the mobile app is a Cordova app and uses the <a href=""https://github.com/sytelus/CryptoJS"" rel=""nofollow noreferrer"">CryptoJS library</a></p>

<pre><code>key = CryptoJS.MD5(key);

// copy 3DES subkey 1 to the last 64 bit to make a full 192-bit key
key.words[4] = key.words[0];
key.words[5] = key.words[1];

if(typeof(iv) === ""undefined""){
    iv = CryptoJS.lib.WordArray.random(8);
}

var encrypted = CryptoJS.TripleDES.encrypt(pt, key, {iv: iv});
return {""str"":encrypted.toString(), ""iv"":CryptoJS.enc.Base64.stringify(iv)};
</code></pre>

<p>The Encrypted payload was</p>

<pre><code>{""jsonrpc"":""2.0"",""method"":""events.enableParentGenres"",""params"":[159],""id"":1}
</code></pre>

<p>Modifications that have been tried, </p>

<p>As per <strong>yivi</strong> suggestion, options have been set to <code>OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING</code></p>

<p>As per <strong>Tuckbros</strong> suggestion, the message has been padded </p>

<pre><code>$message_padded = base64_decode(""bkCfcseIt/TPsgNCdyX9fv2/4MjOJdaPXakNNbxQT3n6tXHa5bDoXojQ3g7jPLCu+wjwD0guQzw3hCFUSVx47PmDNHASk7g/kJ4K4tX0VGI="");
$message_padded = str_pad($message_padded,
        strlen($message_padded) + 8 - strlen($message_padded) % 8, ""\0"");
</code></pre>

<p>Both of these prevented the error about final block length however the encrypted payload when running through the code did not decrypt.</p>
","<p>The parameters you are passing in <code>openssl_decrypt</code> seem to be wrong; you are passing the <code>OPTIONS</code> parameter as <code>0</code>, which you have to set to <code>OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING</code> because you provide the function with raw data (<code>base64_decode</code>).</p>

<p>The key also needs to be converted to a 192 bits key, as in the javascript code:</p>

<pre><code>$key = md5(utf8_encode(""MobileAppSecureKey""), true);

//key.words[4] = key.words[0];
//key.words[5] = key.words[1];

for($i = 0; $i &lt; 8; $i++) {
    $key[$i + 16] = $key[$i];
}
</code></pre>

<p>Try this one out:</p>

<pre><code>$key = md5(utf8_encode(""MobileAppSecureKey""), true);
$data = base64_decode(""bkCfcseIt/TPsgNCdyX9fv2/4MjOJdaPXakNNbxQT3n6tXHa5bDoXojQ3g7jPLCu+wjwD0guQzw3hCFUSVx47PmDNHASk7g/kJ4K4tX0VGI="");

for($i = 0; $i &lt; 8; $i++) {
    $key[$i + 16] = $key[$i];
}

$decoded = openssl_decrypt(
    $data,
    'DES-EDE3-CBC',
    $key,
    OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING,
    base64_decode(""cTOCJ/iYL18="")
);

echo ""\$decoded = {$decoded}"";

// Will output:
// $decoded = {""jsonrpc"":""2.0"",""method"":""events.enableParentGenres"",""params"":[159],""id"":1}
</code></pre>
","237","<php><mcrypt><cryptojs><php-openssl>","4","4","1","2019-03-07 12:07:51","55043413","11","","623150","","2019-03-07 11:40:28","2019-03-01 15:45:59",""
"50513837","what would the equivalent php version be of the following nodejs md5 hashing source code?","<p>I'm migrating from nodejs to PHP and I couldn't obtain a similar output md5 hash digest for the below snippet having the same input.Perhaps there's something I'm missing.</p>

<pre><code>var md5sum = crypto.createHash('md5');
md5sum.update(new Buffer(str, 'binary'));
md5_result = md5sum.digest('hex');
</code></pre>

<p>Thanks in advance for your help!!!, Btw, my nodejs version is 10.1.0, and npm version is 5.6.0. And for the ones asking, this source code equivalent is not <code>md5($str)</code> and it is not my code, I'm just converting it. For example, for the following input <code>42b86318d761e13ef90c126c3e06058237240391</code> the obtained digest is <code>9860bd2248c069c7b65045917c215596</code>.</p>

<p>I just tried to run the following snippet at <a href=""https://www.tutorialspoint.com/execute_nodejs_online.php"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/execute_nodejs_online.php</a>, taking into account your proposals but they don't work:</p>

<pre><code>const crypto = require('crypto');
var str = ""42b86318d761e13ef90c126c3e06058237240391"";
var md5sum = crypto.createHash('md5');
md5sum.update(new Buffer(str, 'binary'));
const md5_result = md5sum.digest('hex');
const md5 = crypto.createHash('md5').update(str).digest('hex');
const expected_digest = ""9860bd2248c069c7b65045917c215596"";
console.log(""original version digest:"" + md5_result);
console.log(""proposed equivalent digest:"" + md5);
console.log(""expected digest:"" + expected_digest);
</code></pre>

<p>What I get on that site is:
<code>original version digest:9860bd2248c069c7b65045917c215596
proposed equivalent digest:b8ee918f782fe7135b25c1fa59339094
expected digest:9860bd2248c069c7b65045917c215596</code></p>

<p>Other sites such as <a href=""https://www.katacoda.com/courses/nodejs/playground"" rel=""nofollow noreferrer"">https://www.katacoda.com/courses/nodejs/playground</a>,<a href=""https://repl.it/"" rel=""nofollow noreferrer"">https://repl.it/</a> ,<a href=""https://www.jdoodle.com/execute-nodejs-online"" rel=""nofollow noreferrer"">https://www.jdoodle.com/execute-nodejs-online</a> support my claim (i.e. md5 digest is <code>9860bd2248c069c7b65045917c215596</code>), however,so far, this site <a href=""http://rextester.com/l/nodejs_online_compiler"" rel=""nofollow noreferrer"">http://rextester.com/l/nodejs_online_compiler</a> outputs what some of you obtained(i.e. <code>b8ee918f782fe7135b25c1fa59339094</code>). As I said before, please, help me find a PHP EQUIVALENT version of the first nodejs snippet of code.</p>
","<p>You shouldn't use: <code>new Buffer(str, 'binary')</code> just:</p>

<pre><code>const md5 = crypto
    .createHash('md5')
    .update(string)
    .digest('hex');
</code></pre>

<p>Using that, you will get the same output with php <code>md5</code>, linux <code>md5sum</code>, and node.</p>

<p>For your input: <code>42b86318d761e13ef90c126c3e06058237240391</code> the following commands will print the same:</p>

<p><strong>md5sum</strong></p>

<pre><code>echo -n ""42b86318d761e13ef90c126c3e06058237240391"" | md5sum
</code></pre>

<p><strong>PHP</strong></p>

<pre><code>echo md5(""42b86318d761e13ef90c126c3e06058237240391"");
</code></pre>

<p><strong>Node</strong></p>

<pre><code>require('crypto')
        .createHash('md5')
        .update(""42b86318d761e13ef90c126c3e06058237240391"")
        .digest('hex');
</code></pre>

<p>All three will output: <code>b8ee918f782fe7135b25c1fa59339094</code></p>

<p><strong>NOTE:</strong></p>

<p><code>new Buffer</code> is deprecated, <code>Buffer.from</code> should be used instead.</p>

<blockquote>
  <p>Other sites such as
  <a href=""https://www.katacoda.com/courses/nodejs/playground,https://repl.it/"" rel=""nofollow noreferrer"">https://www.katacoda.com/courses/nodejs/playground,https://repl.it/</a>
  ,<a href=""https://www.jdoodle.com/execute-nodejs-online"" rel=""nofollow noreferrer"">https://www.jdoodle.com/execute-nodejs-online</a> support my claim (i.e.
  md5 digest is 9860bd2248c069c7b65045917c215596)</p>
</blockquote>

<p><strong>They're not supporting your claim</strong>, you're executing the same code, which is wrong, on many different node.js environment. Of course every Node.js environment will print that output for your code, that doesn't make it right.</p>

<hr>

<p>Since you can't modify the code, and you want the PHP equivalent, here it is:</p>

<pre><code>function utf8_char_code_at($str, $index) {
    $char = mb_substr($str, $index, 1, 'UTF-8');

    if (mb_check_encoding($char, 'UTF-8')) {
        $ret = mb_convert_encoding($char, 'UTF-32BE', 'UTF-8');
        return hexdec(bin2hex($ret));
    } else {
        return null;
    }
}

function myMD5($str) {

     $tmp = """";

     for($i = 0; $i &lt; mb_strlen($str); $i++)
        $tmp .= bin2hex(chr(utf8_char_code_at($str, $i)));

     return md5(hex2bin($tmp));
}

echo myMD5($string);
</code></pre>

<p><code>utf8_char_code_at</code> taken from: <a href=""https://stackoverflow.com/a/18499265/1119863"">https://stackoverflow.com/a/18499265/1119863</a></p>

<p>It will output: <code>9860bd2248c069c7b65045917c215596</code> same as your node snippet.</p>
","236","<php><node.js><md5><cryptojs><digest>","-2","1","1","2018-05-24 20:27:54","50514197","9","","6554472","","2018-05-24 17:12:09","2018-05-24 16:12:38",""
"51594254","Can't install any encryption packages on node.js","<p>I'm running Ubuntu 14.04.5 via Vagrant+Virtualbox on Windows 10.
npm is working great and I haven't had any problems installing any modules.
A few days ago I tried installing bcrypt but the process failed. I tried all of the solutions I could find on stackoverflow threads, and the only one that worked was installing using yarn.
I won't get into it, but I prefer bcrypt to be installed via npm.
Then I tried installing bcryptjs, crypto-js and jsonwebtoken, all FAIL! 
So for some reason all of the cryptography related modules fail when installing via npm...
I tried updating node and npm to the latest version but the I wasn't able to install anything.
Going back to npm v 5.7.1 got me back to where i was before: I can install everything but cryptography related modules.</p>

<p>The error I get trying to install bcrypt:</p>

<pre><code>688 verbose stack Error: ENOENT: no such file or directory, open '/vagrant    /node/test8/node_modules/bcrypt/node_modules/minipass/node_modules/yallist/package.json.1450451485'
694 error path /vagrant/node/test8/node_modules/bcrypt/node_modules/minipass/node_modules/yallist/package.json.1450451485
695 error code ENOENT
696 error errno -2
697 error syscall open
698 error enoent ENOENT: no such file or directory, open '/vagrant/node/test8/node_modules/bcrypt/node_modules/minipass/node_modules/yallist/package.json.1450451485'
699 error enoent This is related to npm not being able to find a file.
</code></pre>

<p>The error(s) I get trying to install bcryptjs:</p>

<pre><code>354 warn rollback Rolling back bcryptjs@2.4.3 failed (this is probably harmless): ETXTBSY: text file is busy, unlink '/vagrant/node/test8/node_modules/bcryptjs/package.json.3007922196'
360 verbose stack Error: ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/bcryptjs/package.json.3007922196' -&gt; '/vagrant/node/test8/node_modules/bcryptjs/package.json'
366 error path /vagrant/node/test8/node_modules/bcryptjs/package.json.3007922196
367 error code ETXTBSY
368 error errno -26
369 error syscall rename
370 error ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/bcryptjs/package.json.3007922196' -&gt; '/vagrant/node/test8/node_modules/bcryptjs/package.json'
</code></pre>

<p>The error(s) I get trying to install crypto-js:</p>

<pre><code>359 verbose stack Error: ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/crypto-js/package.json.3321474119' -&gt; '/vagrant/node/test8/node_modules/crypto-js/package.json'
365 error path /vagrant/node/test8/node_modules/crypto-js/package.json.3321474119
366 error code ETXTBSY
367 error errno -26
368 error syscall rename
369 error ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/crypto-js/package.json.3321474119' -&gt; '/vagrant/node/test8/node_modules/crypto-js/package.json'
</code></pre>

<p>The error(s) I get trying to install jsonwebtoken:</p>

<pre><code>597 verbose stack Error: ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/jwa/package.json.1518470635' -&gt; '/vagrant/node/test8/node_modules/jwa/package.json'
603 error path /vagrant/node/test8/node_modules/jwa/package.json.1518470635
604 error code ETXTBSY
605 error errno -26
606 error syscall rename
607 error ETXTBSY: text file is busy, rename '/vagrant/node/test8/node_modules/jwa/package.json.1518470635' -&gt; '/vagrant/node/test8/node_modules/jwa/package.json'
</code></pre>

<p>any idea what's causing all this?</p>
","<p>There are some cases in which NPM fails to find a file. Try the following and let me know:</p>

<ol>
<li>Run the command <code>vagrant halt</code> to halt the vagrant</li>
<li>Delete the <code>node_modules</code> folder.</li>
<li>Update the NPM and Node to the latest version</li>
<li>Run <code>npm cache clean --force</code></li>
<li>Now try to install</li>
<li>Once everything is done, you can up the vagrant by running <code>vagrant up</code> and if you wanted SSH, then run this command after up, <code>vagrant ssh</code></li>
</ol>

<p>More information related to the similar issues can be seen <a href=""https://www.google.com/search?q=This%20is%20related%20to%20npm%20not%20being%20able%20to%20find%20a%20file"" rel=""nofollow noreferrer"">here</a></p>

<p>Might be useful for you, <a href=""https://stackoverflow.com/a/47091934/2520628"">https://stackoverflow.com/a/47091934/2520628</a></p>

<p>Also on a side note, some modules require a different version of NPM, <a href=""https://www.npmjs.com/package/bcrypt#version-compatibility"" rel=""nofollow noreferrer"">see here</a></p>

<p>So my guess is that you might be trying to install an incompatible version</p>
","234","<node.js><npm><bcrypt><cryptojs>","0","0","1","2018-09-03 14:04:10","","0","","","","","2018-07-30 12:43:28",""
"54365944","TripleDES Encryption result different in C# and Node JS","<p>This might be a possible duplicate but I am unable to fix it.
Below is my code in C# for tripleDES:</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.IO;
using System.Text;

class MainClass {
   public static void Main (string[] args) {

   String encrypt=""5241110000602040"";
   SymmetricAlgorithm sa= SymmetricAlgorithm.Create(""TripleDES"");
   sa.Key= Convert.FromBase64String(""FRSF1P3b6fHiW/DXrK8ZJks5KAiyNpP0"");
   sa.IV=Convert.FromBase64String(""YFKA0QlomKY="");


   byte[] iba=Encoding.ASCII.GetBytes(encrypt);
   MemoryStream mS=new MemoryStream();

   ICryptoTransform trans=sa.CreateEncryptor();
   byte[] buf= new byte[2049];

   CryptoStream cs=new CryptoStream(mS,trans,CryptoStreamMode.Write);

   cs.Write(iba,0,iba.Length);
   cs.FlushFinalBlock();

   Console.WriteLine(Convert.ToBase64String(mS.ToArray()));


 }
}
</code></pre>

<p>Encrypted value is</p>

<blockquote>
  <p>Nj7GeyrbJB93HZLplFZwq5HRjxnvZSvU</p>
</blockquote>

<p>I want to achieve the same thing with crypto-js library of nodejs. Here is nodejs code of what I tried:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

var text = ""5241110000602040"";
var key = ""FRSF1P3b6fHiW/DXrK8ZJks5KAiyNpP0"";

var options = {
//  mode: CryptoJS.mode.ECB, 
//  padding: CryptoJS.pad.Pkcs7,
iv: CryptoJS.enc.Hex.parse(""YFKA0QlomKY="")
};

var textWordArray = CryptoJS.enc.Utf8.parse(text);
var keyHex = CryptoJS.enc.Hex.parse(key);

var encrypted = CryptoJS.TripleDES.encrypt(textWordArray, keyHex, options);

var base64String = encrypted.toString();

console.log('encrypted val: ' + base64String);
</code></pre>

<p>Expected output</p>

<blockquote>
  <p>Nj7GeyrbJB93HZLplFZwq5HRjxnvZSvU</p>
</blockquote>

<p>Actual Output </p>

<blockquote>
  <p>NXSBe9YEiGs5p6VHkzezfdcb5o08bALB</p>
</blockquote>

<p>Encrypted value in nodejs is different than C#. What am I doing wrong?</p>
","<p>You differently decode key and iv.</p>

<p>In c# you use base64:</p>

<pre><code>sa.Key= Convert.FromBase64String(""FRSF1P3b6fHiW/DXrK8ZJks5KAiyNpP0"");
sa.IV=Convert.FromBase64String(""YFKA0QlomKY="");
</code></pre>

<p>in node.js hex:</p>

<pre><code>iv: CryptoJS.enc.Hex.parse(""YFKA0QlomKY="")
var key = ""FRSF1P3b6fHiW/DXrK8ZJks5KAiyNpP0"";
var keyHex = CryptoJS.enc.Hex.parse(key);
</code></pre>

<p>Try to use base64 in both cases.</p>
","233","<c#><node.js><cryptojs><tripledes>","0","1","1","2019-01-25 14:22:10","54367142","3","","1305405","","2019-01-25 13:13:04","2019-01-25 13:07:06",""
"50253089","Angular 5 and PHP cannot decrypt an encrypted variable in php using cryptoJS","<p>I am using the crypto-js library to send some encrypted variables from angular 5 to PHP. Everything is working fine until I added the crypto-aes.php library to my php script.</p>

<pre><code>ngOnInit(){
let user = ""am"";
let key = ""pizza"";
let enc = crypto.AES.encrypt(user, key);
//console.log(enc);
let dec = crypto.AES.decrypt(enc, key);
//console.log(dec.toString(crypto.enc.Utf8));

const headerOptions = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
headerOptions.set('Content-Type', 'Access-Control-Allow-Origin')
const params = new HttpParams().set('name', enc)
this.http.post('http://aff.local/test.php', params, {
    headers: headerOptions
}).subscribe(
        res=&gt;{
            console.log(res);
            alert(res)
        },
        error=&gt;{
            console.log(error);
        }
    )
}
</code></pre>

<p>And here is my PHP script:</p>

<pre><code>&lt;?php
header('Access-Control-Allow-Origin: *');
header('Content-Type: application/json');
header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS');
header('Access-Control-Allow-Headers: *');
error_reporting(E_ALL);

include('./cryptojs-aes.php');
ini_set('log_errors', 0);
ini_set('display_errors', 1);

$host = ""localhost"";
$db = ""dentist"";
$user = ""root"";
$pass = ""root"";

$conn = new PDO(""mysql:host={$host};dbname={$db};"", $user, $pass);
$conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
$conn-&gt;exec(""SET CHARACTER SET utf8mb4"");
$enc = $_POST['name'];
$key = ""pizza"";
$dec = cryptoJSAesDecrypt($key, $enc);
echo $dec;
</code></pre>

<p>The problem is that the alerted and consoled result is <code>null</code></p>
","","231","<php><angular><encryption><angular5><cryptojs>","0","","0","2018-05-09 12:11:30","","6","","","","","2018-05-09 12:11:30",""
"38994575","How do I find out the version of CryptoJS that is installed with Postman?","<p>I need to know which version of CryptoJS is installed with Postman so I can accurately compare .NET and CryptoJS HMAC256 results.</p>
","","231","<postman><hmac><cryptojs>","0","","0","2016-08-17 10:50:12","","2","","","","","2016-08-17 10:50:12",""
"41591768","How to decrypt cipher AES from phpseclib in Node.Js","<p>I tried to encrypt with phpseclib (default)</p>

<pre><code>include 'AES.php';
$aes = new Crypt_AES();
$aes-&gt;setKey('abcdefghijklmnop');

$encrypt = $aes-&gt;encrypt(""hello"");
echo base64_encode($encrypt);
echo ""&lt;br /&gt;"";
echo $aes-&gt;decrypt($encrypt);
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>CAX/zDb/Vdu/063a7fE+qQ==
hello
</code></pre>

<p>and Node.js for decrypt</p>

<pre><code>var CryptoJS = require(""crypto-js"");
var key = 'abcdefghijklmnop';

// Decrypt
var bytes  =     CryptoJS.AES.decrypt(CryptoJS.enc.Base64.parse('CAX/zDb/Vdu/063a7fE+qQ=='), key);
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>However, there are no output.</p>
","<pre><code>var CryptoJS = require(""crypto-js"");
var key = CryptoJS.enc.Utf8.parse('abcdefghijklmnop');
var iv = CryptoJS.enc.Hex.parse('00000000000000000000000000000000');

// Decrypt
var bytes  =     CryptoJS.AES.decrypt({ciphertext: CryptoJS.enc.Base64.parse('CAX/zDb/Vdu/063a7fE+qQ==')}, key, {iv: iv});
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>That worked for me.</p>
","230","<php><node.js><encryption><phpseclib><cryptojs>","1","0","1","2017-01-12 04:52:16","41605344","0","","5486053","","2017-01-11 13:12:18","2017-01-11 13:05:58",""
"23160805","Replicate pass encryption from PHP to JS","<p>I would like to replicate the following PHP code in JS:</p>

<pre><code>    $salted = $raw_pass.""{"".$salt.""}"";
    $iterations = 5000;
    $digest = hash('sha512', $salted, true);

    // ""stretch"" hash
    for ($i = 0; $i &lt; $iterations; $i++) {
        $digest = hash('sha512', $digest.$salted, true);
    }

    return base64_encode($digest);
</code></pre>

<p>It's creating a hash from pass and salt, 5000 iterations. This is actually from Symfony's <a href=""https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/Encoder/MessageDigestPasswordEncoder.php"" rel=""nofollow"">MessageDigestPasswordEncoder</a> (I changed the code a bit for the sake of example, sorry for possible typos).</p>

<p>I want to replicate this in JavaScript and I did this:</p>

<pre><code>var salted = raw_pass + ""{"" + salt + ""}""
var digest = CryptoJS.SHA512(salted);              

for (var i=0;i&lt;5000;i++){
    digest = CryptoJS.SHA512(digest+salted);
}

user.password = CryptoJS.enc.Base64.stringify(digest)
</code></pre>

<p>Everything works ok when I create <code>digest</code> (I get the same string on both sides), but after it reiterates, I get different hashes. The symfony side is working, so the problem is somewhere in this JS. </p>

<p>What am I doing wrong? </p>

<p>Later edit:
I think I have an idea why this is not working. <code>digest</code> is an object and <code>salted</code> is a string. CryptoJS.SHA512 accepts both, but I don't think <code>digest + salted</code> is not what is expecting.</p>
","<p>I think a problem is in here:</p>

<pre><code>&lt;?php
    $salted = $raw_pass.""{""$salt.""}"";
?&gt;
</code></pre>

<p>You forgot a dot ( . ), it should be this:</p>

<pre><code>&lt;?php
    $salted = $raw_pass.""{"".$salt.""}"";
?&gt;
</code></pre>

<p>Also you start one time with 1 and one time with 0 (see post below)</p>
","228","<javascript><php><symfony><cryptojs>","0","0","4","2014-04-19 17:08:48","23160903","3","","472495","","2014-04-18 20:48:23","2014-04-18 19:21:41",""
"23160805","Replicate pass encryption from PHP to JS","<p>I would like to replicate the following PHP code in JS:</p>

<pre><code>    $salted = $raw_pass.""{"".$salt.""}"";
    $iterations = 5000;
    $digest = hash('sha512', $salted, true);

    // ""stretch"" hash
    for ($i = 0; $i &lt; $iterations; $i++) {
        $digest = hash('sha512', $digest.$salted, true);
    }

    return base64_encode($digest);
</code></pre>

<p>It's creating a hash from pass and salt, 5000 iterations. This is actually from Symfony's <a href=""https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/Encoder/MessageDigestPasswordEncoder.php"" rel=""nofollow"">MessageDigestPasswordEncoder</a> (I changed the code a bit for the sake of example, sorry for possible typos).</p>

<p>I want to replicate this in JavaScript and I did this:</p>

<pre><code>var salted = raw_pass + ""{"" + salt + ""}""
var digest = CryptoJS.SHA512(salted);              

for (var i=0;i&lt;5000;i++){
    digest = CryptoJS.SHA512(digest+salted);
}

user.password = CryptoJS.enc.Base64.stringify(digest)
</code></pre>

<p>Everything works ok when I create <code>digest</code> (I get the same string on both sides), but after it reiterates, I get different hashes. The symfony side is working, so the problem is somewhere in this JS. </p>

<p>What am I doing wrong? </p>

<p>Later edit:
I think I have an idea why this is not working. <code>digest</code> is an object and <code>salted</code> is a string. CryptoJS.SHA512 accepts both, but I don't think <code>digest + salted</code> is not what is expecting.</p>
","<p>I think the problem is that in PHP you initialize the loop in <code>1</code>:</p>

<pre><code>for ($i = 1; $i &lt; $iterations; $i++)
</code></pre>

<p>but in JavaScript you initialize the loop in <code>0</code>:</p>

<pre><code>for (var i=0;i&lt;5000;i++)
</code></pre>
","228","<javascript><php><symfony><cryptojs>","0","3","4","2014-04-19 17:08:48","23160903","3","","472495","","2014-04-18 20:48:23","2014-04-18 19:21:41",""
"23160805","Replicate pass encryption from PHP to JS","<p>I would like to replicate the following PHP code in JS:</p>

<pre><code>    $salted = $raw_pass.""{"".$salt.""}"";
    $iterations = 5000;
    $digest = hash('sha512', $salted, true);

    // ""stretch"" hash
    for ($i = 0; $i &lt; $iterations; $i++) {
        $digest = hash('sha512', $digest.$salted, true);
    }

    return base64_encode($digest);
</code></pre>

<p>It's creating a hash from pass and salt, 5000 iterations. This is actually from Symfony's <a href=""https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/Encoder/MessageDigestPasswordEncoder.php"" rel=""nofollow"">MessageDigestPasswordEncoder</a> (I changed the code a bit for the sake of example, sorry for possible typos).</p>

<p>I want to replicate this in JavaScript and I did this:</p>

<pre><code>var salted = raw_pass + ""{"" + salt + ""}""
var digest = CryptoJS.SHA512(salted);              

for (var i=0;i&lt;5000;i++){
    digest = CryptoJS.SHA512(digest+salted);
}

user.password = CryptoJS.enc.Base64.stringify(digest)
</code></pre>

<p>Everything works ok when I create <code>digest</code> (I get the same string on both sides), but after it reiterates, I get different hashes. The symfony side is working, so the problem is somewhere in this JS. </p>

<p>What am I doing wrong? </p>

<p>Later edit:
I think I have an idea why this is not working. <code>digest</code> is an object and <code>salted</code> is a string. CryptoJS.SHA512 accepts both, but I don't think <code>digest + salted</code> is not what is expecting.</p>
","<p>I could not fix it so I had to change the strategy. Considering I'm encoding already encoded (and salted) data and I'm not providing the whole info to the user, I should be safe.</p>

<p>I changed to SHA1 and I'm using <code>btoa()</code> and <code>atobe()</code> JS functions. </p>
","228","<javascript><php><symfony><cryptojs>","0","0","4","2014-04-19 17:08:48","23160903","3","","472495","","2014-04-18 20:48:23","2014-04-18 19:21:41",""
"23160805","Replicate pass encryption from PHP to JS","<p>I would like to replicate the following PHP code in JS:</p>

<pre><code>    $salted = $raw_pass.""{"".$salt.""}"";
    $iterations = 5000;
    $digest = hash('sha512', $salted, true);

    // ""stretch"" hash
    for ($i = 0; $i &lt; $iterations; $i++) {
        $digest = hash('sha512', $digest.$salted, true);
    }

    return base64_encode($digest);
</code></pre>

<p>It's creating a hash from pass and salt, 5000 iterations. This is actually from Symfony's <a href=""https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Security/Core/Encoder/MessageDigestPasswordEncoder.php"" rel=""nofollow"">MessageDigestPasswordEncoder</a> (I changed the code a bit for the sake of example, sorry for possible typos).</p>

<p>I want to replicate this in JavaScript and I did this:</p>

<pre><code>var salted = raw_pass + ""{"" + salt + ""}""
var digest = CryptoJS.SHA512(salted);              

for (var i=0;i&lt;5000;i++){
    digest = CryptoJS.SHA512(digest+salted);
}

user.password = CryptoJS.enc.Base64.stringify(digest)
</code></pre>

<p>Everything works ok when I create <code>digest</code> (I get the same string on both sides), but after it reiterates, I get different hashes. The symfony side is working, so the problem is somewhere in this JS. </p>

<p>What am I doing wrong? </p>

<p>Later edit:
I think I have an idea why this is not working. <code>digest</code> is an object and <code>salted</code> is a string. CryptoJS.SHA512 accepts both, but I don't think <code>digest + salted</code> is not what is expecting.</p>
","<p>Why don't you just use <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">PBKDF2</a> since CryptoJS also provides that, it seems.</p>
","228","<javascript><php><symfony><cryptojs>","0","0","4","2014-04-19 17:08:48","23160903","3","","472495","","2014-04-18 20:48:23","2014-04-18 19:21:41",""
"54616146","How to use crpyto in NodeJs","<p>I am learning NodeJs, and I am trying to implement the crypto library to encrypt and decrpty text,<br>
I am referring the following example -
<a href=""https://www.w3schools.com/nodejs/ref_crypto.asp"" rel=""nofollow noreferrer"">https://www.w3schools.com/nodejs/ref_crypto.asp</a><br></p>

<p><strong>The code to encrypt is as follows -</strong><br></p>

<pre><code>var crypto = require('crypto');

var mykey = crypto.createCipher('aes-128-cbc', 'mypassword');
var mystr = mykey.update('abc', 'utf8', 'hex')
mystr += mykey.update.final('hex');

console.log(mystr); 
</code></pre>

<p><strong>The code to decrypt is as follows -</strong><br></p>

<pre><code>var crypto = require('crypto');

var mykey = crypto.createDecipher('aes-128-cbc', 'mypassword');
var mystr = mykey.update('34feb914c099df25794bf9ccb85bea72', 'hex', 'utf8')
mystr += mykey.update.final('utf8');

console.log(mystr);
</code></pre>

<p>The code samples seem to work on their environment,<br>
But I am getting the following error when I try to run the same code on my machine -<br></p>

<pre><code>mystr += mykey.update.final('hex');
                      ^

TypeError: mykey.update.final is not a function
    at Object.&lt;anonymous&gt; (/home/user/office/pocs/node-apps/sample-apps/Apps/crypto.js:5:23)
    at Module._compile (internal/modules/cjs/loader.js:734:30)
    at Object.Module._extensions..js (internal/modules/cjs/loader.js:745:10)
    at Module.load (internal/modules/cjs/loader.js:626:32)
    at tryModuleLoad (internal/modules/cjs/loader.js:566:12)
    at Function.Module._load (internal/modules/cjs/loader.js:558:3)
    at Function.Module.runMain (internal/modules/cjs/loader.js:797:12)
    at executeUserCode (internal/bootstrap/node.js:526:15)
    at startMainThreadExecution (internal/bootstrap/node.js:439:3)
</code></pre>

<p><strong>Can someone help implement it correctly to encrypt and decrytp text?<br>What am I doing wrong?</strong></p>
","<p>update line </p>

<pre><code>mystr += mykey.update.final('hex');
</code></pre>

<p>to</p>

<pre><code>mystr += mykey.final(""hex"");
</code></pre>

<p>Tried the code according to 
<a href=""https://nodejs.org/api/crypto.html#crypto_cipher_final_outputencoding"" rel=""nofollow noreferrer"">official documentation</a></p>
","227","<node.js><cryptojs>","0","1","1","2019-02-10 12:16:54","54616270","1","","","","","2019-02-10 12:01:23",""
"54925788","Decrypt large file with crypto nodejs","<p>I am decripting a large file (<strong>450mb</strong>). </p>

<p>I am reading the file with <strong>fs.createReadStream</strong> and decrypting with <strong>crypto-js</strong>.</p>

<p>The file has been encrypted in UTF8.</p>

<p>The contents of the file is JSON.</p>

<p><strong>MY FUNCTION:</strong></p>

<pre><code>function decryptFile(srcDir, fileName, destDir) {

    let encryptedPath = path.join(srcDir, fileName);
    let decryptedPath = path.join(destDir, fileName).replace('.xam', '.json');

    console.log('DECRYPTING XAM FILE ' + encryptedPath + ' TO ' + decryptedPath);

    const input = fs.createReadStream(encryptedPath);

    input.once('readable', () =&gt; {

        const decipher = crypto.createDecipher('xxx-xxx-xxx', 'XxxX');

        const output = fs.createWriteStream(decryptedPath);

        input.pipe(decipher).pipe(output).on('finish', () =&gt; {

            console.log('FILE DECRYPTED');

        }).on('error', error =&gt; {

            console.log(error);

        });

    });
}
</code></pre>

<p><em>UPDATE</em>
<strong>ERROR:</strong></p>

<pre><code>Error: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
    at Decipher._flush (crypto.js:158:28)
    at Decipher.prefinish (_stream_transform.js:137:10)
    at emitNone (events.js:106:13)
    at Decipher.emit (events.js:208:7)
    at prefinish (_stream_writable.js:602:14)
    at finishMaybe (_stream_writable.js:610:5)
    at afterWrite (_stream_writable.js:464:3)
    at onwrite (_stream_writable.js:454:7)
    at Decipher.afterTransform (_stream_transform.js:90:3)
    at Decipher._transform (crypto.js:153:3)
</code></pre>

<p><em>UPDATE</em> <em>Title</em></p>
","<p>I've implemented the same to simulate your problem.  i got the same error. You have hit a known issue.   please follow this guide. <a href=""http://vancelucas.com/blog/stronger-encryption-and-decryption-in-node-js/"" rel=""nofollow noreferrer"">http://vancelucas.com/blog/stronger-encryption-and-decryption-in-node-js/</a>  it works. tested it.</p>

<pre><code>const crypto2 = require('crypto');
var fs = require('fs');


function decryptFile(fileName) {

    const input = fs.createReadStream(fileName+'.encrypted');
    const output = fs.createWriteStream(fileName+'.unencrypted');


        const initVect = crypto2.randomBytes(16);
        const CIPHER_KEY = new Buffer('12345678901234567890123456789012');
        const decipher =  crypto2.createDecipheriv('aes-256-cbc', CIPHER_KEY, initVect);


        input.pipe(decipher).pipe(output).on('finish', () =&gt; {

            console.log('FILE DECRYPTED');

        }).on('error', error =&gt; {

            console.log(error);

        });
}

function encryptFile(fileName) {

    const initVect = crypto2.randomBytes(16);
    const CIPHER_KEY = new Buffer('12345678901234567890123456789012');


    var aes = crypto2.createCipheriv('aes-256-cbc', CIPHER_KEY, initVect);

    const input = fs.createReadStream(fileName);
    const output = fs.createWriteStream(fileName+'.encrypted');

    input 
      .pipe(aes)  
      .pipe(output)  
      .on('finish', function () {  
        console.log('done encrypting');
      });
} 

encryptFile('cas_01.cas');
//decryptFile('cas_01.cas');  
</code></pre>
","226","<javascript><node.js><cryptojs>","1","0","1","2019-02-28 19:36:14","","3","1","6034820","","2019-02-28 19:33:10","2019-02-28 12:29:19",""
"32717873","Binary string in javascript above charcode 128","<p>I'm trying to decrypt OpenSSL AES encrypted file, to do so I need to read the salt from the begining of the file, and give it with the password to CryptoJS openssl key derivation function to get the derivated key and iv.</p>

<p>Sadly, CryptoJS expect the salt as a String, and String in JS handle poorly binary data.
A char over 128 is interpreted as 2 bits in JS (see: <a href=""https://stackoverflow.com/questions/26287640/trouble-with-binary-string-in-javascript-above-character-code-128"">Trouble with binary string in javascript above character code 128</a>):</p>

<pre class=""lang-js prettyprint-override""><code>// if you wanna test it, openssl command to generate a file from any file :
// openssl enc -aes-256-cbc -in file.txt -out file.enc -k password
fs.readFile('file.enc', function(err, data) {
    var Salted__ = data.toString(""utf-8"", 0, 8); // 'Salted__' prefix
    var salt = data.toString(""hex"", 8, 16); // the actual salt I want to give to CryptoJS
    // output in hex: 46d69efb7f57380b

    var buf = new Buffer(salt, ""hex"");
    console.log(buf);
    // output &lt;Buffer 46 d6 9e fb 7f 57 38 0b&gt;, exactly what I want, but it is a buffer not a String object.

    // the problem can be seen here:
    var buf2 = new Buffer(buf.toString());
    console.log(buf2);
    // output &lt;Buffer 46 d6 9e ef bf bd 7f 57 38 0b&gt;
    // as you can see, fb =&gt; ef bf bd

    // fun fact, when I try to do it manualy, I get another result (that seem more logical to me):
    var str = '';
    for (var i = 0; i &lt; hex.length; i += 2)
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    console.log(new Buffer(str));
    // output &lt;Buffer 46 c3 96 c2 9e c3 bb 7f 57 38 0b&gt;
    // in this case (I've tryed it char by char to be sure):
    // d6 =&gt; c3 96
    // 9e =&gt; c2 9e
    // fb =&gt; c3 bb

    var derivedParams = CryptoJS.kdf.OpenSSL.execute(password, 256/32, 128/32, buf.toString());
    console.log(derivedParams.key.toString());
    console.log(derivedParams.iv.toString());
    // output a wrong key and a wrong iv (I know what I should get using openssl enc -P option)

});
</code></pre>

<p>Any help or explanation on how JS work with binary string would be appreciated :)</p>
","<p>I've found a solution !</p>

<pre><code>var salt = CryptoJS.enc.Hex.parse(salt);
CryptoJS.kdf.OpenSSL.execute(password, 256/32, 128/32, salt);
</code></pre>
","225","<javascript><string><binary><cryptojs>","0","0","1","2015-09-22 14:01:07","32718972","3","","-1","","2017-05-23 11:58:22","2015-09-22 13:13:33",""
"51737556","Does a XMLHTTP POST request to an HTTPS address use any encryption?","<p>If we use javascript's http request function:</p>

<pre><code>var request = new XMLHttpRequest();
</code></pre>

<p>to an https address, will this use any type of encryption or will a MITM be able to see all data we send?</p>

<p>Example:</p>

<pre><code>function createAuthToken(baseRestURL, callback) {
    var APIPath = ""account/api/session"";
    var CORSPath = ""https://cors-anywhere.herokuapp.com/"";
    var completeRestURL = CORSPath + baseRestURL + APIPath;
    console.log(""REST API URL: "" + completeRestURL);

    var method = ""POST"";
    var postData = ""{\""tokenId\"": \"""" + document.getElementById('api_key').value + ""\"",\""secret\"": \"""" + document.getElementById('secret').value + ""\"",\""loginMode\"": 1,\""applicationType\"": 35}"";
    var async = true;
    var request = new XMLHttpRequest();
    request.onreadystatechange = function() {
        if (request.readyState == 4 &amp;&amp; (request.status == 200 || request.status == 201)) {
            console.log(""ONLOAD"");
            var status = request.status; // HTTP response status, e.g., 200 for ""200 OK""
            console.log(status);
            var response = JSON.parse(request.responseText);
            console.log(response.session_token);       
            return callback(response.session_token);

        }

    }
    request.open(method, completRestURL, async);
    request.setRequestHeader(""Content-Type"", ""application/json"");
    request.setRequestHeader(""Accept"", ""application/json"");
    request.send(postData);
</code></pre>

<p>Follow up question: If not, is there a way to include encryption in our client side javascript that is safe? My thoughts was to use a webisite's public key to encrypt the request before sending it to the server but I can't find anyone else attempting client side encryption. </p>

<p>Rough example:</p>

<p><a href=""https://i.stack.imgur.com/dX7EC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/dX7EC.png"" alt=""enter image description here""></a></p>

<pre><code>var CryptoJS = require(""crypto-js"");
var stackOverflowKey = ""30 82 01 0a 02 82 01...""
var postData = ""{\""tokenId\"": \"""" + document.getElementById('api_key').value + ""\"",\""secret\"": \"""" + document.getElementById('secret').value + ""\"",\""loginMode\"": 1,\""applicationType\"": 35}"";
var encryptedPostData = cryptoJS.hmacSHA256(postData, stackOverflowKey)

//let's skip the callback and request headers as they are the same as above

var request = new XMLHttpRequest();
request.open();
request.send(encryptedPostData);
</code></pre>

<p>I didn't study computer science and couldn't find anything online about this. What are the generally accepted ways of doing this?</p>
","<p>The HTTP in XMLHttpRequest, as is the XML part, is just a left over naming scheme. As the requests used can include more than just http protocol urls, and receive more than just an XML response body.</p>

<p>For instance the initial W3C working drafts introduced the XMLHttpRequest object by saying:</p>

<blockquote>
  <p><a href=""https://www.w3.org/TR/2006/WD-XMLHttpRequest-20060927/#introduction"" rel=""nofollow noreferrer"">https://www.w3.org/TR/2006/WD-XMLHttpRequest-20060927/#introduction</a></p>
  
  <p>The name of the object is XMLHttpRequest for compatibility with the web
  as it doesn't make much sense otherwise. It supports the transport of
  other data formats in addition to XML, <strong>some implementations support</strong>
  <strong>other protocols besides HTTP</strong> (that functionality is not covered in
  this specification though) and the API supports sending data as well.</p>
</blockquote>

<p>Note the <em>""some implementations""</em> as this is a working draft back in 2006 so not everyone was using the same implementation.</p>

<p>The current whatwg spec for XMLHttpRequest has this to say about the name:</p>

<blockquote>
  <p><a href=""https://xhr.spec.whatwg.org/#introduction"" rel=""nofollow noreferrer"">https://xhr.spec.whatwg.org/#introduction</a></p>
  
  <p>The name XMLHttpRequest is historical and has no bearing on its
  functionality.</p>
</blockquote>

<p>So as long as the browser being used implements the XMLHttpRequest according to specs, the request/response will be treated as it would normally by the browser, ie encrypted for https.</p>
","224","<javascript><https><xmlhttprequest><cryptojs>","0","2","1","2018-08-08 02:40:30","51737887","1","","","","","2018-08-08 01:48:17",""
"53620224","Verifying signature in NodeJS","<p>In my logic i am hashing some data based on a secret key. Later I want to verify that signature. I am using the crypto package in nodejs. Specifically, in the verifier.verify function, the docs require a publicKey. How would i go upon doing this as i am using the secret in config?</p>

<p>Any help would be awesome!</p>

<pre><code>let data = {
  ""data"": 15 
}

config: {
  secret: 'mgfwoieWCVBVEW42562tGVWS',
}

let stringData = JSON.stringify(data)

const hash = crypto.createHmac('sha256', config.secret)
                   .update(stringData, 'utf-8')
                   .digest('base64')

const verifier = crypto.createVerify('sha256')
let ver = verifier.verify(publicKey, stringData, 'base64')
console.log(ver);
</code></pre>
","<p>If you want to verify a particular signature in node you can use the following</p>

<pre><code>config: {
secret: ""IloveMyself""
};

var cipherPassword = crypto.createCipher('aes-256-ctr', config.secret);
var dbpassword = cipherPassword.update(dbpassword, 'utf-8', 'hex');
</code></pre>

<p>This will be for creating encryption of the password. Now to verify the password/signature again in NodeJS, you need to do the following:</p>

<pre><code>var cipher = crypto.createDecipher('aes-256-ctr', config.secret);
var dbPassword = cipher.update(dbpassword, 'hex', 'utf-8');
</code></pre>

<p>This will give decrypted password/signature which you can compare easily. I hope it helps!</p>
","222","<javascript><node.js><cryptojs>","0","2","1","2018-12-04 19:48:02","","0","","","","","2018-12-04 19:35:28",""
"56293120","How to make a SHA1 from a file in Angular using a filereader?","<p>I have an input element on my html page, with which I can select 1/multiple file(s).<br>
Once I have chosen my file(s), I would like to read the content of each file using a FileReader to make a SHA1 from it.<br>
Once I have the SHA1 value, I would like to save it somewhere.</p>

<p>The problem is that I receive the SHA1 value only after the .onload of the FileReader is finished and that happens after I try to safe it's value.</p>

<p>I have tried to make the function async and using an await to wait until the file is read but that didn't work.
I have tried to add a Promise but that didn't work either.<br>
I really don't know what to do to have the desired outcome. Please help.</p>

<p>This is my angular function that I call when I have choosen my file(s):</p>

<pre><code>hashFiles(files: Array&lt;any&gt;){
    console.log('start hashing');
    for (const file of files) {
      const myHash = hashFile(file);
      console.log('hash: ', myHash);
      /*I would like to save myHash here*/
    }
    console.log('done hashing');
}
</code></pre>

<p>This is my javascript function that's called from angular that will read the file with a FileReader and then make a sha1 hash from it's content</p>

<pre><code>function hashFile(fileToHandle) {
  console.log('1');

  var reader = new FileReader();

  console.log('2');

  reader.onload = (function() {

    return function(e) {
      console.log('4');

      const hash = CryptoJS.SHA1(arrayBufferToWordArray(e.target.result)).toString();
      console.log('hash result in fileReader: ', hash);
      return hash;
    };
  }) (fileToHandle);
  reader.onerror = function(e) {
    console.error(e);
  };

  console.log('3');

  reader.readAsArrayBuffer(fileToHandle);

  console.log('5');
}

function arrayBufferToWordArray(ab) {
  var i8a = new Uint8Array(ab);
  var a = [];
  for (var i = 0; i &lt; i8a.length; i += 4) {
    a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]);
  }
  return CryptoJS.lib.WordArray.create(a, i8a.length);
}
</code></pre>

<p>When running this code I have the following in my console:</p>

<pre><code>start hashing
1
2
3
5
hash: undefined
done hashing
4
hash result in fileReader: 327c468b64b4ca54377546f8a214d703ccbad64b
</code></pre>

<p>And I need it to be:</p>

<pre><code>start hashing
1
2
3
hash result in fileReader: 327c468b64b4ca54377546f8a214d703ccbad64b
4
5
hash: 327c468b64b4ca54377546f8a214d703ccbad64b
done hashing
</code></pre>

<p>Here is a sample of my code:<br>
<a href=""https://stackblitz.com/edit/sha1-from-file"" rel=""nofollow noreferrer"">https://stackblitz.com/edit/sha1-from-file</a></p>
","<p>You need to either work with call backs or add a promise wrapper (observable would also work) to the native callbacks of the <code>FileReader</code>. Here is how you could do it just by adding a call back.</p>

<p><a href=""https://stackblitz.com/edit/sha1-from-file-xnewux?file=src%2Fscript.js"" rel=""nofollow noreferrer"">Stackblitz</a></p>

<p><strong>app.component.ts</strong></p>

<pre><code>hashFiles(event) {
  console.log('start hashing');

  const numberOfFiles = event.target.files.length;
  var fileCounter = 0;
  for (const file of event.target.files) {
    hashFile(file, (hashedFile, hash) =&gt; {
    console.log('hash: ', hash);
    fileCounter++;
    if(fileCounter === numberOfFiles)
      console.log('Done Hashing!');
    });
  }
}
</code></pre>

<p><strong>script.js</strong></p>

<pre><code>export function hashFile(fileToHandle, callback) {
  var CryptoJS = require(""crypto-js"");

  console.log('1');

  var reader = new FileReader();

  console.log('2');

  reader.onloadend = (function() {
    return function(e) {
      console.log('4');
      const hash = CryptoJS.SHA1(arrayBufferToWordArray(e.target.result)).toString();
      console.log('hash result in fileReader: ', hash);
      callback(fileToHandle, hash);
    };
  }) (fileToHandle);
  reader.onerror = function(e) {
    console.error(e);
  };

  console.log('3');

  reader.readAsArrayBuffer(fileToHandle);
}
</code></pre>
","221","<javascript><angular><filereader><sha1><cryptojs>","1","0","1","2019-05-24 14:03:45","56294271","2","0","11550088","","2019-05-24 13:30:00","2019-05-24 12:53:35",""
"40041447","Crypto-js package with NodeJS","<p>into GitHub is not clear because i must use a second argument ( in this case ""<code>secretKey</code>"" ) for crypting or decrypting :</p>

<pre><code>//Encrypt
var encryptedMessage = crypto.AES.encrypt(secretMessage, secretKey);
console.log(""Encrypted message "" + encryptedMessage);

//Decrypted
var bytes = crypto.AES.decrypt(encryptedMessage, secretKey);
var decryptedMessage = bytes.toString(crypto.enc.Utf8); // convert into string and encoding Utf8
</code></pre>

<p>If i compile without the second argument, Node responde that property ""words"" is undefined. Why?
Thanks all
Morris</p>
","<p>Are you asking why you have to use a secret key for decryption? That's a trivial requirement for having an actually secure implementation for encryption. If your encrypted message could be decrypted WITHOUT using the secret key, then every single person on the planet earth can decrypt your message.</p>

<p>I'm pretty sure you're not asking that, but I don't know what you're asking anyway and looking at your question, that's the closest thing to what you're asking.</p>
","218","<node.js><cryptojs>","0","1","1","2016-10-14 11:02:03","40041581","0","","","","","2016-10-14 10:54:51",""
"34177809","Creating shared key signature fails in CryptoJS","<p>I need help with creating a shared key signature for Azure storage REST.</p>

<p>In chrome I can output the string I am signing:</p>

<pre><code>PUT


11

text/plain;charset=UTF-8






x-ms-blob-type:BlockBlob
x-ms-date:Wed, 09 Dec 2015 11:53:00 GMT
x-ms-version:2015-04-05
/myaccount/logs
</code></pre>

<p>Using Postman the server returned me the following:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;
&lt;Error&gt;
    &lt;Code&gt;AuthenticationFailed&lt;/Code&gt;
    &lt;Message&gt;Server failed to authenticate the request. Make sure the value of Authorization header is formed correctly including the signature.
RequestId:6ca14d01-0001-00cb-5673-32e680000000
Time:2015-12-09T11:20:01.6093647Z&lt;/Message&gt;
    &lt;AuthenticationErrorDetail&gt;The MAC signature found in the HTTP request 'O1Xwmg6TeU53qYoDiKQHgJZc+58uPaJPvotxXL116XQ=' is not the same as any computed signature. Server used following string to sign: 'PUT


11

text/plain;charset=UTF-8






x-ms-blob-type:BlockBlob
x-ms-date:Wed, 09 Dec 2015 11:53:00 GMT
x-ms-version:2015-04-05
/myaccount/logs'.&lt;/AuthenticationErrorDetail&gt;
&lt;/Error&gt;
</code></pre>

<p>As you can see both signed string are the same. I have checked, there is no difference between two texts.</p>

<p>This is the code the I execute to generate the signature:</p>

<pre><code>var accessKeyBytes = CryptoJS.enc.Base64.parse(base64EncodedSharedKey);
var encodedBits = CryptoJS.HmacSHA256(stringToSign, accessKeyBytes);
var result = CryptoJS.enc.Base64.stringify(encodedBits);
return result;
</code></pre>

<p>where base64EncodedSharedKey is the primary key of the Azure storage.</p>

<p>Do you have any ideas? What could I be doing wrong? Should I backslash the \n when forming the JavaScript string to be signed?</p>
","<p>Solved.</p>

<p>The problem is that at the end of the string to be signed I had put a \n.</p>

<p>I should have not put the return carriage at the end of the string.</p>
","211","<javascript><rest><azure><digital-signature><cryptojs>","1","1","1","2015-12-09 15:44:32","","0","1","1816580","","2015-12-09 15:19:38","2015-12-09 11:33:29",""
"54342064","TypeError: Cannot read property 'random' of undefined - crypto-js","<p>I'm using <code>crypto-js</code> inside <code>reactjs</code> and everything works fine on localhost.
but on server with chrome I got this error message:</p>

<pre><code>TypeError: Cannot read property 'random' of undefined
</code></pre>

<p>on firefox:</p>

<pre><code>TypeError: ""r is undefined""
</code></pre>

<p>my code:</p>

<pre><code>import CryptoJS from 'crypto-js';

console.log('text',text); //printed on console as well
var p = randomString(10) 
console.log('p',p) //printed on console as well
var c = CryptoJS.AES.encrypt(text,p).toString(); // error line
console.log('crypted',c+p)//not printed !
</code></pre>

<p>my function:</p>

<pre><code>  function setWindow(text){
    console.log('text',text);
    var p = randomString(10)
    console.log('p',p)
    var c = CryptoJS.AES.encrypt(text,p).toString();
    console.log('crypted',c+p)
    return c+p;
  }
</code></pre>

<hr>

<pre><code>""crypto-js"": ""^3.1.9-1"",
</code></pre>

<p>I don't know where is my problem! I removed <code>node_modules</code>, but I got the same error.
my site:
<a href=""http://posweb.ccg24.com/signin"" rel=""nofollow noreferrer"">http://posweb.ccg24.com/signin</a></p>

<p><strong>updated</strong></p>

<pre><code>  function randomString(length) {
    var text = """";
    var possible = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"";

    for (var i = 0; i &lt; length; i++)
      text += possible.charAt(Math.floor(Math.random() * possible.length));

    return text;
  }
</code></pre>
","<p>You can generate random without using <code>Math.random</code></p>

<pre><code>var _ = require('lodash');
var CryptoJS = require(""crypto-js"");
var p;
function randomString(length) {
  var text = """";
  var possible = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"";

 var text= _.sampleSize(possible , length).join('');

  return text;
}

function setWindow(text){
    console.log('text',text);
     p = randomString(10)
    console.log('p',p)
    var c = CryptoJS.AES.encrypt(text,p).toString();
    console.log('crypted',c+p)
    return c+p;
  }



var ciphertext=setWindow(""plain text"");
var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), p);
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(""decrypte"",plaintext);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function randomString(length) {
    var text = """";
    var possible = ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"";

    for (var i = 0; i &lt; length; i++)
      text += possible.charAt(Math.floor(Math.random() * possible.length));

    return text;
  }




function setWindow(text){
 

    console.log('text',text);
    var p = randomString(10)
    console.log('p',p)
    var c =CryptoJS.AES.encrypt(text,p);
    console.log('crypted',c+p)
    return c+p;
}
var text=""Plain Text"";
setWindow(text);    </code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p>The code here:<a href=""https://repl.it/@ibrahimth/LastSatisfiedBrain"" rel=""nofollow noreferrer"">https://repl.it/@ibrahimth/LastSatisfiedBrain</a></p>
","208","<javascript><reactjs><cryptojs>","0","0","1","2019-01-24 13:32:22","","9","","3369042","","2019-01-24 08:23:24","2019-01-24 08:14:58",""
"41891681","CryptoJs is not decrypting URL on my NodeJS server","<p>I am forwarding API calls from my frontend to my backend. I encrypt the API calls using CryptoJS.AES using the passphrase 'somekey'. </p>

<p>My relevant client code is...</p>

<pre><code>var host = 'http://localhost:3000'

$('.send-button').click(function(){
  var request = $('.request-input').val();
  var encryptedRequest = CryptoJS.AES.encrypt(request, 'somekey');
  console.log(encryptedRequest.toString())  
  var decryptedRequest = CryptoJS.AES.decrypt(encryptedRequest, 'somekey');
  console.log('Decrypted Request: ' + decryptedRequest.toString());
  handleRequest(encryptedRequest.toString());
});

var handleRequest = function(request){
    $.ajax({
        type: ""GET"",
        url: host + '/requests?call=' + request,
        success: function(data) {
        var rawJSON = JSON.stringify(data, null, 2);
        editor.setValue(rawJSON);
        },
        dataType: 'json'
   });
}
</code></pre>

<p>relevant server side code is...</p>

<pre><code>var port = 3000;
var serverUrl = ""127.0.0.1"";

var http = require(""http"");
var path = require(""path"");
var fs = require(""fs"");
var express = require(""express"");
var CryptoJs = require(""crypto-js"");
var app = express(); 

app.get('/requests', function(req, res) {
    console.log('REQUEST: ' + req);
    var call = req.query.call;
    console.log(call)
    console.log(""To send: "" + CryptoJs.AES.decrypt(call, 'somekey'));
}); 
</code></pre>

<p>The problem I keep getting is that it that when I decrypt it it either doesn't get the original URL and instead returns a bunch of jibberish. An example of this is...</p>

<pre><code>Encryption: U2FsdGVkX1/NRbZkyP60pPu3Cb9IcQ4b9n4zJkExp2LNR3O1EdEpqHLNACnYuatN

Decryption: 68747470733a2f2f6e6577736170692e6f72672f76312f61727469636c6573
</code></pre>

<p>OR... It just returns nothing and appears blank. </p>

<p>Ideally I would like something like this.</p>

<pre><code>Encryption: U2FsdGVkX1/NRbZkyP60pPu3Cb9IcQ4b9n4zJkExp2LNR3O1EdEpqHLNACnYuatN

Decryption: https://newsapi.org/v1/articles 
</code></pre>

<p>Can anyone see what I am dong wrong?</p>
","<p>Here is a working jsfiddle:
<a href=""https://jsfiddle.net/5Lr6z4zp/1/"" rel=""nofollow noreferrer"">https://jsfiddle.net/5Lr6z4zp/1/</a></p>

<p>The encryption results in a Base64 string, while the decrypted string is Hex. To get back the Message you need to convert that to Utf8: decryptedRequest.toString(CryptoJS.enc.Utf8)</p>

<p>Here is the relevant part of the code that works:</p>

<pre><code>var request = ""testing decryption"";
var encryptedRequest = CryptoJS.AES.encrypt(request, 'somekey');
console.log(encryptedRequest)  
var decryptedRequest = CryptoJS.AES.decrypt(encryptedRequest, 'somekey');
var decryptedMessage = decryptedRequest.toString(CryptoJS.enc.Utf8)
console.log('Decrypted Request: ' + decryptedMessage);
</code></pre>

<p>Here is a link for a resources that explains the encryption/decryption in more detail:
<a href=""http://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/"" rel=""nofollow noreferrer"">http://www.davidebarranca.com/2012/10/crypto-js-tutorial-cryptography-for-dummies/</a></p>
","204","<javascript><node.js><cryptojs>","1","1","1","2017-01-27 10:46:17","41892127","1","","","","","2017-01-27 10:22:16",""
"41314425","javascript Base64 encoding to python","<p>I have this line in a postman pre-script that uses javascript:</p>

<pre><code>var hash256 = CryptoJS.HmacSHA256(rawSignature, Secret);
var hashbase64 = hash256.toString(CryptoJS.enc.Base64);
</code></pre>

<p>im trying to convert that to a python script (2.7) and have come up with this :</p>

<pre><code>hash256 = hmac.new(Secret, rawSignature, hashlib.sha256).hexdigest()
hashbase64 = base64.b64encode(hash256).decode()
</code></pre>

<p>The sha256 result appears to be the same but when I try to encode with base64 I get a different result. 
I have little to no javascript knowledge but from what I have found it may be something to do with .toString part converting from a word array and may be resulting in the string being base64 encoded in a different format.</p>

<p>I have tried a few different things converting to binary / hex strings and converting etc but still get the wrong result I'm sure if something stupid but can't quite figure it out any ideas ?</p>

<p>thanks</p>

<p>***edit</p>

<p>clarification as requested</p>

<p>an example correctly generated HMAC sha256 was:
d5d2f2c64933c4d45f457f32d892534971d372cfec99956db506afad0e12aefb</p>

<p>the above codes produces these results:
hashbase64(javascript postman) = 1dLyxkkzxNRfRX8y2JJTSXHTcs/smZVttQavrQ4Srvs=
hashbase64(python) = ZDVkMmYyYzY0OTMzYzRkNDVmNDU3ZjMyZDg5MjUzNDk3MWQzNzJjZmVjOTk5NTZkYjUwNmFmYWQwZTEyYWVmYg=='</p>

<p>I have now tried the digest() instead of hexdigest and am now getting the desired result so that was the problem, thanks for the responses appreciate it </p>
","","204","<javascript><python><python-2.7><cryptojs><hashlib>","0","","0","2016-12-27 23:01:13","","3","","7337848","","2016-12-27 23:01:13","2016-12-24 15:11:50",""
"36900701","What's missing in my Sign In request?","<p>I'm trying to access the endpoints of a website (lighterpack.com, github: <a href=""https://github.com/galenmaly/lighterpack"" rel=""nofollow"">https://github.com/galenmaly/lighterpack</a>). To test my ability to do this, I'm trying to make a POST call to the 'signin' function in edit.js (bottom).</p>

<p>I'm using Postman to send the POST request, sending it the object {username: myusername, password: myhashedpasswordandusername}</p>

<p>I'm hashing the object manually right now on my local machine, and copying that out to Postman. I created a JS file with the ""crypto-js"" dependency, and ran the command that the edit.js file uses, after setting var CryptoJS = require('crypto-js'). </p>

<p>This might be the part I messed up, but I can't see where. I</p>

<p>My hashing file code:</p>

<pre><code>var crypto = require('crypto-js')
var pass = ""mypassword""
var name = ""username""
var hash = crypto.SHA3(pass+name)

var hash= hash.toString(crypto.enc.Base64)

console.log(hash)
</code></pre>

<p>I take what the console logs out, and put that in my Postman object as my password. The thing I don't get is that in the edit.js file, CryptoJS doesn't appear defined anywhere, not that I could see anyway. Can someone point me in the right direction?</p>

<p>Original edit.js function:</p>

<pre><code>    $("".signin"").on(""submit"", function(evt) {
        evt.preventDefault();
        var form = this;
        var error = """";
        var username = $("".username"", this).val();
        var password = $("".password"", this).val();
        if (!password) error = ""Please enter a password."";
        if (!username) error = ""Please enter a username."";

        if (error) {
            $("".lpError"", this).text(error).show();
            return;
        }

        $("".lpError"", this).text("""").hide();

        username = username.toLowerCase();
        var hash = CryptoJS.SHA3(password+username);
        hash = hash.toString(CryptoJS.enc.Base64);

        $.ajax({
            url: ""/signin"",
            data: {username: username, password: hash, },
            method: ""POST"",
            error: function(data, textStatus, jqXHR) {
                var error = ""An error occurred."";
                if (data.responseText) error = data.responseText;
                $("".password"", form).val("""").focus();
                $("".lpError"", form).text(error).show();
            },
            success: function(data) {
                $(""#signin, #lpModalOverlay"").fadeOut(""slow"", removeBlackout);
                $("".password, .username"", form).val("""");
                signedIn(data.username);
                library.load(JSON.parse(data.library));
                initWithLibrary();
            }
        });
    });
</code></pre>
","<p>So someone got me the answer. In github, there is a file public/sha3.js that has the CryptoJS variable, and the app.js file declares that file's info (CryptoJS) as a global variable.</p>

<p>I copied sha3.js, and was able to correctly hash my data and then login. Success!</p>
","203","<javascript><node.js><cryptojs>","0","0","1","2016-04-29 10:52:24","","2","1","","","","2016-04-27 20:54:46",""
"21597919","CryptoJS run very slow in IE7","<p>The following CryptoJs code run in normal speed in IE9 but very very slow in IE7, what is the reason behind and any method to speed up the script in IE7?  </p>

<pre><code>var keyLength = 256;  
var iteration = 1000;
var salt = CryptoJS.lib.WordArray.random(128/8);  
var key = CryptoJS.PBKDF2(passphrase, salt, { keySize: keyLength/32, iterations: iteration });  
var iv = CryptoJS.lib.WordArray.random(128/8);  
var loginPassword = document.getElementsByName(""password"")[0].value;
 var encrypted = CryptoJS.AES.encrypt(loginPassword, key, {iv:iv},{mode:CryptoJS.mode.CBC,padding: CryptoJS.pad.Pkcs7});  
</code></pre>
","<p>Microsoft has improved the speed of the JavaScript engine in IE9 to bring it up to par with other modern JS engines (see <a href=""http://en.wikipedia.org/wiki/Chakra_%28JScript_engine%29"" rel=""nofollow"">here</a>). I'm afraid there's nothing that can be done to improve the performance of the IE7 engine. Of course, in this specific case, you could reduce the number of iterations, although I am not familiar enough with PBKDF2 to say how far you can reduce it before the function becomes unsafe. Another option to consider would be moving the password hashing to the server...</p>
","199","<cryptojs>","1","1","1","2014-02-06 09:03:33","","0","","","","","2014-02-06 08:48:10",""
"34381373","Hashing element contents in-place with Crypto-js","<p>I am trying to hash data using JavaScript. When I run the first code it will hash using <code>document.write</code>. Now I try the second code to hash by content id it didn't work. Can anyone explain why?</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;script&gt;
    var hash = CryptoJS.SHA256(""hello"");
    document.write(hash.toString(CryptoJS.enc.Hex));
&lt;/script&gt;
</code></pre>

<p>using this first method will work very fine
<strong>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</strong> </p>

<pre><code>&lt;script&gt;
    var hash = CryptoJS.SHA256;
    var it = (hash.toString(CryptoJS.enc.Hex));
    document.getElementById('hashit').innerHTML = 'it';
&lt;/script&gt;

&lt;p id=""hashit""&gt;Hello&lt;/p&gt;
</code></pre>
","<p>If you want to hash something <em>in-place</em> in an element then you need to read out the value/text, hash it and write the text back:</p>

<pre><code>var element = document.getElementById('hashit');
var hash = CryptoJS.SHA256(element.innerHTML);
element.innerHTML = hash.toString();
</code></pre>

<p>Here is a runnable snippet which changes the value after 2 seconds.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""false"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>setTimeout(function(){
  var element = document.getElementById('hashit');
  var hash = CryptoJS.SHA256(element.innerHTML);
  element.innerHTML = hash.toString();
}, 2000);</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
&lt;p id=""hashit""&gt;Hello&lt;/p&gt;</code></pre>
</div>
</div>
</p>

<p>Keep in mind that JavaScript is not like PHP. You can't simply use variables in strings like this <code>element.innerHTML = 'it';</code>. You have to  use<code>element.innerHTML = it;</code>.</p>
","197","<javascript><html><dom><hash><cryptojs>","0","0","1","2017-07-30 09:29:16","34382602","0","","104223","","2015-12-21 04:22:14","2015-12-20 13:16:35",""
"41444937","How to get hash value from an asynchronous function?","<p>I use CryptoJs to have hash (sha256) of a PDF file. </p>

<p>I already have the hash of my file but I can't get it outside the function.</p>

<p>This is my code :</p>

<pre><code>var reader = new FileReader();
var hash = """";

reader.onloadend = function(evt) {
    if (evt.target.readyState == FileReader.DONE) { // DONE == 2
        var i8a = new Uint8Array(evt.target.result);
        var a = []; for (var i = 0; i &lt; i8a.length; i += 4) { a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]); }
        var wordArray = CryptoJS.lib.WordArray.create(a,i8a.length);
        var hash = CryptoJS.SHA256(wordArray);
        alert(hash);
    }
};

var blob = file.slice(0, file.size + 1);
reader.readAsArrayBuffer(blob);

alert(hash);
</code></pre>

<p>The first alert give me the sha, but the second is empty.
How can I do to get hash defined into the function to use it after?</p>

<p>if I add a callBack function it working. 
But I wanted to make an Ajax request, and when I add the request into a callBack function like this :</p>

<pre><code>function callBack(hash){
     $.ajax({
          type: ""POST"",
          url:""http://..."",
          dataType:'json',
          data:({shaPdf: hash}),
          success: function(data) {
             //...
           },
          error: function(error) {
           }
           });
</code></pre>

<p>I have this error into my console : </p>

<pre><code>Uncaught TypeError: Cannot read property 'words' of undefined
</code></pre>
","<p>You need a call back function:</p>

<pre><code>var reader = new FileReader();
var hash = """";

reader.onloadend = function(evt) {
    if (evt.target.readyState == FileReader.DONE) { // DONE == 2
        var i8a = new Uint8Array(evt.target.result);
        var a = []; for (var i = 0; i &lt; i8a.length; i += 4) { a.push(i8a[i] &lt;&lt; 24 | i8a[i + 1] &lt;&lt; 16 | i8a[i + 2] &lt;&lt; 8 | i8a[i + 3]); }
        var wordArray = CryptoJS.lib.WordArray.create(a,i8a.length);
        var hash = CryptoJS.SHA256(wordArray);
        callBack(hash); // &lt;-- callBack at the end of this function
    }
};

var blob = file.slice(0, file.size + 1);
reader.readAsArrayBuffer(blob);

function callBack(hash)
{
   alert(hash);
}
</code></pre>

<p>Since your <code>reader</code> is loading the file asynchronous, the second <code>alert</code> fires immediately after the other code. The <code>reader</code> is not done yet loading the file, so hash is empty. If we wrap the <code>alert</code> into a function, which we call upon after the <code>onloadend</code>, we are able to use the value outside of the function.</p>
","197","<javascript><cryptojs>","1","1","1","2017-01-03 14:01:47","41445026","0","","6639174","","2017-01-03 14:01:47","2017-01-03 13:45:29","2017-01-03 13:56:11"
"31581350","bower with cryptojslib automatically adds many <script> tags","<p>I've used Yeoman to scaffold my app (bower as dependency management) and <code>cryptojslib</code> is one of the packages I'm using. It ships with many algorithms, I actually only need <code>rollups/sha256.js</code>.</p>

<p><code>bower</code> seems to automatically add <code>&lt;script&gt;</code> tags to the <code>index.html</code> to load all packages, but with <code>cryptojslib</code> it adds around 100 components and rollups and I only need to load one of them.<br>
If I remove this from the <code>index.html</code> file, it comes back on the nexty <code>bower install</code> run.</p>

<p>Can I exclude a package from this html manipulation?</p>
","<p>Remember</p>

<p><strong>-></strong> <em>You can't ignore on behalf of other packages/files if it has the dependency.</em> </p>

<p>The following way you can <code>ignore</code> some files not to add in your project while doing <code>bower install</code> </p>

<p>In your <code>bower.json</code> file add the following -</p>

<p><code>{
  ""ignore"": ""file_name_of_not_to_add"" 
 }</code></p>
","195","<angularjs><bower><cryptojs>","0","0","1","2015-07-23 15:37:57","","0","","1643257","","2015-07-23 08:53:57","2015-07-23 07:56:39",""
"51592526","Signing a message with privateKey (elliptic p256)","<p>How do we sign a message with a givenPrivateKey in java with elliptic curve(p256)</p>

<p>Basically a java implementation of</p>

<pre><code>let elliptic = new EC('p256')
const sig = elliptic.sign(msgHashHex, privateKey, null)
</code></pre>

<p>I dont want to generate new private/public key pair. My privateKey = 'abc'</p>

<p>Also please let me know if there is an online tool to play around with digital signatures.</p>

<p>Thanks a lot in advance.</p>
","<pre><code>PrivateKey privateKey = ; // your  EC p256 private key
byte[] msgHashHex = ; // byte array data

Signature signature = Signature.getInstance(""ECDSA""); // or SHA256WithECDSA etc.
signature.initSign(privateKey);
signature.update(msgHashHex);   
byte[] result = signature.sign();
</code></pre>
","195","<java><node.js><cryptojs>","0","0","1","2018-07-30 12:05:43","","0","1","1276952","","2018-07-30 11:07:24","2018-07-30 11:02:19",""
"39400779","Making requests to Amazon web services REST APIs, cannot get the request Signature to work","<p>So I am attempting to make a request to Amazon's product API but I cannot figure out how to get the signature to work.  I was following another stack overflow post that can be found here: <a href=""https://stackoverflow.com/questions/26915864/how-can-i-create-a-signature-for-aws-in-javascript"">How can I create a signature for AWS in Javascript?</a>, but still cannot fulfill my request.  Here is the request that I am sending, (currently testing through postman).</p>

<p><code>http://webservices.amazon.com/onca/xml?Service=AWSECommerceService&amp;AWSAccessKeyId=[MY_ACCESSKEY]&amp;Operation=ItemSearch&amp;Keywords=the%20hunger%20games&amp;SearchIndex=Books &amp;Timestamp=2016-09-09T12:00:00Z&amp;Signature=9RTSas234dfRTs3R%ErA8%</code></p>

<p>I made up a fake signature similar to the one that I get from this function:</p>

<pre><code>let service = ""AWSECommerceService"";
let timestamp = ""2016-09-09T12:00:00Z"";
let operation = ""ItemSearch"";
let secret = ""MY_AMAZONSECRET"";
let signature = CryptoJS.HmacSHA1(service + operation + timestamp, secret).toString(CryptoJS.enc.Base64);
console.log(signature);
</code></pre>

<p>The result that logs to the console looks like this: <code>9RTSas234dfRTs3R+ErA8=</code></p>

<p>From what I read here <a href=""http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html"" rel=""nofollow noreferrer"">http://docs.aws.amazon.com/AWSECommerceService/latest/DG/rest-signature.html</a>, I thought you needed to replace '+' and '=' to '%' signs.  When I leave the + and = signs as is, I get the following response from AWS:</p>

<pre><code>&lt;?xml version=""1.0""?&gt;
&lt;ItemSearchErrorResponse xmlns=""http://ecs.amazonaws.com/doc/2005-10-05/""&gt;
    &lt;Error&gt;
        &lt;Code&gt;SignatureDoesNotMatch&lt;/Code&gt;
        &lt;Message&gt;The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.&lt;/Message&gt;
    &lt;/Error&gt;
    &lt;RequestId&gt;{MY_REQUESTID}&lt;/RequestId&gt;
&lt;/ItemSearchErrorResponse&gt;
</code></pre>

<p>But when I change them to %'s, I get this response: </p>

<pre><code>&lt;?xml version=""1.0""?&gt;
&lt;ItemSearchErrorResponse xmlns=""http://ecs.amazonaws.com/doc/2005-10-05/""&gt;
    &lt;Error&gt;
        &lt;Code&gt;MissingParameter&lt;/Code&gt;
        &lt;Message&gt;The request must contain the parameter Signature.&lt;/Message&gt;
    &lt;/Error&gt;
    &lt;RequestId&gt;{MY_REQUESTID}&lt;/RequestId&gt;
&lt;/ItemSearchErrorResponse&gt;
</code></pre>

<p>Even though the Signature parameter exists in the request.  Any thoughts on how I can fix this.  I am using crypto-js to create the signature, which can be found here: <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a></p>
","<blockquote>
  <p>I thought you needed to replace '+' and '=' to '%' signs. </p>
</blockquote>

<p>Yes, but you don't just replace them with <code>%</code>.  Use this map:</p>

<pre><code>+ becomes %2B
/ becomes %2F
= becomes %3D
</code></pre>

<p>This is referred to as url-encoding, url-escaping, or percent-encoding.  The characters are replaced by a literal <code>%</code> followed by their 2-digit hex ASCII equivalent.</p>

<pre><code>9RTSas234dfRTs3R+ErA8= becomes 
9RTSas234dfRTs3R%2BErA8%3D
</code></pre>
","191","<javascript><amazon-web-services><request><hmac><cryptojs>","0","0","1","2016-09-09 10:07:07","","1","","-1","","2017-05-23 12:08:23","2016-09-08 21:55:16",""
"31159703","Adding CRC to packet somehow breaks CryptoJS's AES","<p>I am writing a mobile app in javascript (with appcelerator) that communicates with a server app written in Java. 
The communication is encrypted. </p>

<p>Now I want to implement integrity checking via CRC on the client (the server side is finished already by another party). 
While the CRC gets computed correctly, something seems to break the encryption process. It's very strange behaviour and I just can't seem to wrap my head around it.</p>

<p>The server uses bouncycastles for decryption.</p>

<p>The client sends javascript objects to the server in the following way:</p>

<ul>
<li>The object gets converted to a json string</li>
<li>This then gets converted to a byteArray (Titanium.Buffer to be precise) - I'll call this: content</li>
<li>A header gets added with the following information: 

<ul>
<li>5 Bytes specify the packet type </li>
<li>4 bytes for the length of the content</li>
<li>4 bytes for a CRC32 of the header</li>
<li>4 bytes for a CRC32 of the content</li>
</ul></li>
<li>the content gets appended to the header - I'll call this: packet</li>
<li>the packet gets encrypted via cryptoJS AES in CBC mode</li>
<li>the encrypted packet gets a header (via the same method as the one before)</li>
<li>this gets sent to the server</li>
</ul>

<p>The server then throws an exception:</p>

<pre><code>bsc.sdk.security.bouncycastle.crypto.InvalidCipherTextException: pad block corrupted
at bsc.sdk.security.bouncycastle.crypto.paddings.PKCS7Padding.padCount(PKCS7Padding.java:62)
at bsc.sdk.security.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher.doFinal(PaddedBufferedBlockCipher.java:273)
at bsc.sdk.api.crypt.aes.AESCipher.doFinal(AESCipher.java:60)
at bsc.sdk.api.crypt.aes.AESCipher.decrypt(AESCipher.java:36)
</code></pre>

<p>Now here's where the fun part starts: The exception only happens when the header CRC lies in a certain range. 
I tested this by manually writing integers around the original CRC into the header block. It fails when the integer is somewhere around the range between 1963000000 and 1963990000. These numbers are probably not exactly accurate but I didn't test further due to time constraints.</p>

<p>When I write some other Int like for example 2534528925 into the block, everything's fine.</p>

<p>So, does anyone have an idea why certain CRCs seem to break the padding of the AES algorithm?</p>

<p>Here are relevant code snippets of the client (if you need more, just ask):</p>

<pre><code>send: function (command, ) {

    var commandString = JSON.stringify(command, null);
    var commandBuffer = Ti.createBuffer({value: commandString});
    var packageBuffer = this.setHeader(commandBuffer, 2);

    // encrypt and reassign the header
    var encrypted = EncryptionService.encrypt(packageBuffer);
    var words = encrypted.words;
    var encryptedWordsCount = words.length;
    var encryptedBuffer = Ti.createBuffer({length: encryptedWordsCount * 4});

    for (i = 0; i &lt; encryptedWordsCount; i++) {

        Ti.Codec.encodeNumber({
            source: words[i],
            dest: encryptedBuffer,
            position: i * 4,
            type: Ti.Codec.TYPE_INT,
            byteOrder: Ti.Codec.BIG_ENDIAN
        });
    }

    packageBuffer = this.setHeader(encryptedBuffer, 1);            
    Ti.Stream.write(this.socket, packageBuffer, this.writeCallback);  
}

setHeader: function (commandBuffer, type) {

    var commandBufferLength = commandBuffer.length;
    var paddedCommandBufferLength = this.options.headerLength + commandBuffer.length;

    var type = (!type || type == 2) ? 0x00000002 : ((type == 1) ? 0x00000001 : 0x00000000);


    var buffer = Ti.createBuffer({
        length: this.options.headerLength
    });

    // write sync byte
    Ti.Codec.encodeNumber({
        source: 0x55,
        dest: buffer,
        position: 0,
    type: Ti.Codec.TYPE_BYTE,
    byteOrder: Ti.Codec.BIG_ENDIAN
    });

    // write the type
    Ti.Codec.encodeNumber({
        source: type,
        dest: buffer,
        position: 1,
        type: Ti.Codec.TYPE_INT,
        byteOrder: Ti.Codec.BIG_ENDIAN
    });

    // write the contentLength
    Ti.Codec.encodeNumber({
        source: commandBufferLength,
        dest: buffer,
        position: 5,
        type: Ti.Codec.TYPE_INT,
        byteOrder: Ti.Codec.BIG_ENDIAN
    });
    computeChecksumFromByteArray(headerBuffer, buffer, 9, this.crcTable);

    buffer.append(commandBuffer);

    return buffer; 
}

    computeChecksumFromByteArray: function(array, destinationBuffer, destinationOffset, crcTable){
    var crc = -1; 

    for(var i=0, l=array.length; i&lt;l; i++)
    {
        crc = crc &gt;&gt;&gt; 8 ^ crcTable[ crc &amp; 255 ^ array[i] ];
    }
    crc = (crc ^ -1) &gt;&gt;&gt; 0;

    Ti.Codec.encodeNumber({
        source: crc,
        dest: destinationBuffer,
        position: destinationOffset,
        type: Ti.Codec.TYPE_INT,
        byteOrder: Ti.Codec.BIG_ENDIAN
    }); 
}

EncryptionService.encrypt : function(buffer) {

    var key = App.authentication.sharedSecret;

    var bufferLength = buffer.length;
    var bufferHexString = App.Library.Helper.createHexString(buffer);
    var bufferWords = CryptoJS.enc.Hex.parse(bufferHexString);
    var options = {
        iv : CryptoJS.enc.Hex.parse('00000000000000000000000000000000'),
        padding : CryptoJS.pad.Pkcs7,
        mode : CryptoJS.mode.CBC
    };

    var encrypted = CryptoJS.AES.encrypt(bufferWords, key, options);

    return encrypted.ciphertext;

}
</code></pre>
","","188","<javascript><encryption><appcelerator><bouncycastle><cryptojs>","0","","0","2015-07-01 12:31:33","","4","","5053931","","2015-07-01 12:31:33","2015-07-01 11:14:00",""
"26608633","Sharing encrypted data between JS and C#, for dummies","<p>My team must share data between a localnet html/js app, and a server in the same net listening on a websocket.
The first idea was to simply send variables to the server with get </p>

<pre><code>http://192.168.1.100:8080/var=hello
</code></pre>

<p>It's simple and works, but we must add a security level to the data exchange, encrypting all in Aes and then hexing the result to send it as plain string.</p>

<p>The best solution that we found is Crypto-JS <a href=""https://code.google.com/p/crypto-js/"" rel=""nofollow"">https://code.google.com/p/crypto-js/</a>
We are able to follow the examples and encrypting/decrypting data inside the same js block, but are unable to decrypt the data on another software.</p>

<p>we do:</p>

<pre><code>var text = ""Message"";
var password = ""Secret Passphrase"";

var encrypted = CryptoJS.AES.encrypt(text, password);

var EnText = encrypted.ciphertext; //returns the hexed/encrypted text
var Key = encrypted.key;
</code></pre>

<p>It doesn't work with the c# code running on the server, so we tried an online decrypting tool <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow"">http://aes.online-domain-tools.com/</a> passing both the password and the Key, but similarly returns unreadable text</p>

<p>JS generated value for reference</p>

<pre><code>EnText: 5768c9b4d75e0cc32b610d9e6f518c36
Key: 005e316192f5162f7fd104ce2c9fe91de6c6f2977849dcd5878226022a7073be
</code></pre>

<p>What are we missing?</p>
","<p>Ok i got it, the text is in hexadecimal.
Try decyphering it there:</p>

<p><a href=""http://www.unit-conversion.info/texttools/hexadecimal/"" rel=""nofollow"">http://www.unit-conversion.info/texttools/hexadecimal/</a></p>
","187","<javascript><cryptojs>","0","0","1","2014-10-28 12:54:15","","4","","","","","2014-10-28 12:40:38",""
"52181366","pyCrypto: Input must be a multiple of 16 in length","<p>I am trying to decrypt a string encoded with ""crypto-js"" and decode it in python using ""pyCrypto"". I have followed the exact steps on various blogs but still the same error. </p>

<p>Last stackoverflow post i followed was
""<a href=""https://stackoverflow.com/questions/11567290/cryptojs-and-pycrypto-working-together"">CryptoJS and Pycrypto working together</a>"" the answer given  by @Artjom B.</p>

<p>Also tried ""<a href=""https://chase-seibert.github.io/blog/2016/01/29/cryptojs-pycrypto-ios-aes256.html"" rel=""nofollow noreferrer"">https://chase-seibert.github.io/blog/2016/01/29/cryptojs-pycrypto-ios-aes256.html</a>""</p>

<p>My js code is</p>

<pre><code>var pass = CryptoJS.AES.encrypt(text, password_encrypt_key, 
        {
            iv: password_encrypt_iv,
        })
    return password_encrypt_iv.concat(pass.ciphertext).toString(CryptoJS.enc.Base64);
</code></pre>

<p>And my python code is</p>

<pre><code>    BLOCK_SIZE = 16
    KEY = constants.PASSWORD_ENCRYPT_KEY
    # IV = constants.PASSWORD_ENCRYPT_IV
    IV = enc_password[:BLOCK_SIZE]
    MODE = AES.MODE_CBC
    enc_password = base64.b64decode(enc_password)
    aes = AES.new(KEY, MODE, IV)
    password = unpad(aes.decrypt(enc_password[BLOCK_SIZE:]))
</code></pre>

<p>unpad function</p>

<pre><code>def unpad(s):
  return s[:-ord(s[-1])]
</code></pre>
","<p>I found the solution. Not sure how this worked and not the rest of the solution but anyways posting it. Also the solution is from the below link answer by Artjom B. He has given better explaination. I am also posting the same answer.</p>

<p>Link - <a href=""https://stackoverflow.com/questions/36762098/how-to-decrypt-password-from-javascript-cryptojs-aes-encryptpassword-passphras"">How to decrypt password from JavaScript CryptoJS.AES.encrypt(password, passphrase) in Python</a></p>

<p>Javascript - </p>

<pre><code>var KEY = encrypt_key;
var encrypted_txt_obj = CryptoJS.AES.encrypt(text, KEY);
return encrypted_txt_obj.toString();
</code></pre>

<p>python -</p>

<pre><code>from Crypto.Cipher import AES
import base64

BLOCK_SIZE = 16

def bytes_to_key(data, salt, output=48):
    data += salt
    key = md5(data).digest()
    final_key = key
    while len(final_key) &lt; output:
      key = md5(key + data).digest()
      final_key += key
    return final_key[:output]

def decrypt_text(enc):
    try:
        enc = base64.b64decode(enc)
        assert enc[0:8] == b""Salted__""
        salt = enc[8:16]
        key_iv = bytes_to_key(encrypt_key, salt, 32 + 16)
        key = key_iv[:32]
        iv = key_iv[32:]
        aes = AES.new(key, AES.MODE_CBC, iv)
        text = unpad(aes.decrypt(enc[16:]))
        return text
   except Exception as e:
        resp = jsonify({constants.ERR_SERVER: e.message})
        resp.status_code = 403
        logger.error(""Exception %s"", e.message)
        return resp

def unpad(data):
    return data[:-(data[-1] if type(data[-1]) == int else ord(data[-1]))]
</code></pre>
","187","<javascript><python><pycrypto><cryptojs>","1","0","1","2018-09-10 05:31:21","52251625","2","1","","","","2018-09-05 09:12:20",""
"47644697","AWS signature 4: Java and Crypto-JS does not march","<p>I am using java to do some post with AWS signature header. The signing process is below</p>

<pre><code>    private String calculateSignature(String stringToSign) {
        try {
                byte[] signatureKey = getSignatureKey(secretAccessKey, currentDate, regionName, serviceName);
                byte[] signature = HmacSHA256(stringToSign, signatureKey);
                String strHexSignature = bytesToHex(signature);
                return strHexSignature;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
            return null;
    }

    private byte[] HmacSHA256(String data, byte[] key) throws Exception {
        String algorithm = ""HmacSHA256"";
        Mac mac = Mac.getInstance(algorithm);
        mac.init(new SecretKeySpec(key, algorithm));
        return mac.doFinal(data.getBytes(""UTF8""));
    }

    private byte[] getSignatureKey(String key, String date, String regionName, String serviceName) throws Exception {
        byte[] kSecret = (""AWS4"" + key).getBytes(""UTF8"");
        byte[] kDate = HmacSHA256(date, kSecret);
        byte[] kRegion = HmacSHA256(regionName, kDate);
        byte[] kService = HmacSHA256(serviceName, kRegion);
        byte[] kSigning = HmacSHA256(aws4Request, kService);
        return kSigning;
    }

    private String bytesToHex(byte[] bytes) {
        final StringBuilder hexString = new StringBuilder();
        for(byte b : bytes)
            hexString.append(String.format(""%02x"", b));
        return hexString.toString().toLowerCase().trim();
    }
</code></pre>

<p>However, when I send use this signature, it does not match the signature calculated by the server. The server is written in PHP, and it us Crypto-JS to calculate the signature. I have compared two strings need to sign and Canonical Request between Java and PHP. They are matching.</p>

<p>I have checked space, command and other characteries. but cannot figure out why. Are Java HmacSHA256 and crypto-js HmacSHA256 different? Or something wrong with bytesToHex method?</p>

<p>The Java output of Canonical Request</p>

<pre><code>POST
/

content-length:667
content-type:application/json
host:host.name.com
x-amz-date:20171205T012629Z
x-amz-target:_20141201.XXXXXXX

content-length;content-type;host;x-amz-date;x-amz-target
c5b31b699700e6debe4548836a723f89b73ffcef6570e1bed4c534c0f247dc26
</code></pre>

<p>The PHP returns: </p>

<pre><code>POST
/

content-length:667
content-type:application/json
host:host.name.com
x-amz-date:20171205T012629Z
x-amz-target:_20141201.XXXXXXX

content-length;content-type;host;x-amz-date;x-amz-target
c5b31b699700e6debe4548836a723f89b73ffcef6570e1bed4c534c0f247dc26
</code></pre>

<p>Any help or any idea will be appreciated.</p>
","<p>Found the issue. The reason was the algorithm of the secret key was changed, but i was not aware of that change</p>
","183","<java><php><amazon-web-services><cryptojs>","0","0","1","2017-12-06 03:00:11","47665451","1","","2806237","","2017-12-05 01:44:28","2017-12-05 01:32:36",""
"54005518","Using CryptoSwift framework AES encryption with ECB and pkcs7 IN SWIFT4","<p>IN swift I am trying to encrypt text same as <code>CryptoJS</code> encryption. But both are not same here I share with you URL, I need to do the same encryption in Swift. Please help me, here I attach my code also. 
<a href=""https://stackblitz.com/edit/angular-crypto"" rel=""nofollow noreferrer"">Demo CryptoJS encryption</a>
in this URL we are using <code>CryptoJS</code> encryption with <code>ECB</code> and <code>pkcs7</code>. Same code I am doing in ios but not the same </p>

<pre><code>import UIKit
import Foundation
import CryptoSwift
class CryptoViewController: UIViewController {

 let KEY = ""0123456789123456""
    override func viewDidLoad() {
        super.viewDidLoad()
         self.aesCBC_Encrypt(AES_KEY: KEY, payload: ""Hello World!"")
    }
    func aesCBC_Encrypt(AES_KEY: String,payload: String) -&gt; String {
        var result = """"
        do {
            let key: [UInt8] = Array(AES_KEY.utf8) as [UInt8]
            let iv = AES.randomIV(AES.blockSize)
            let bytes = payload.bytes
            let aes = try! AES(key: key, blockMode: ECB(), padding: .pkcs7)
            //let encrypted = try aes.encrypt(Array(self.utf8))
            let encrypted = try aes.encrypt(bytes)
            print(""encrypted: \(encrypted)"")
            result = encrypted.toHexString()
            print(""AES Encryption Result: \(result)"")
        } catch {
            print(""Error: \(error)"")
        }
        return result
    }
}
</code></pre>

<p>From my code, I am getting this Result </p>

<pre><code>AES Encryption Result: 1b8019c2add38f33de9099aefd5369f5
</code></pre>

<p>But when I am try to Encryption from CryptoJS, Then I am getting this Result </p>

<pre><code> Encrypted Text:
Aeoo7GP6b4l/Pdxz2RS+qA==
</code></pre>
","","183","<swift><encryption><cryptojs>","0","","0","2019-01-02 11:46:05","","3","","6380363","","2019-01-02 11:46:05","2019-01-02 11:28:01",""
"53408877","JAVA Decryption AES/CBC/PKCS5Padding with CryptoJS encryption","<p>As <a href=""https://stackoverflow.com/questions/37368710/decrypt-aes-cbc-pkcs5padding-with-cryptojs"">stackoverflow</a> I have implemented JAVA AES encryption and Javascript AES decryption but unable to implement JAvascript AES encryption to JAVA AES decryption. Please check the below code for more information.  </p>

<p>Java Backend Code Example Code:</p>

<pre><code> public static String encryptAES(String data, String secretKey) {
        try {
            byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)
                    .toString().substring(0, 16)
                    .getBytes(Charsets.UTF_8);

            final SecretKey secret = new SecretKeySpec(secretKeys, ""AES"");

            final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secret);

            final AlgorithmParameters params = cipher.getParameters();

            final byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
            final byte[] cipherText = cipher.doFinal(data.getBytes(Charsets.UTF_8));

            return DatatypeConverter.printHexBinary(iv) + DatatypeConverter.printHexBinary(cipherText);
        } catch (Exception e) {
            throw Throwables.propagate(e);
        }
    }


    public static String decryptAES(String data, String secretKey) {
        try {
            byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)
                    .toString().substring(0, 16)
                    .getBytes(Charsets.UTF_8);

            // grab first 16 bytes - that's the IV
            String hexedIv = data.substring(0, 32);

            // grab everything else - that's the cipher-text (encrypted message)
            String hexedCipherText = data.substring(32);

            byte[] iv = DatatypeConverter.parseHexBinary(hexedIv);
            byte[] cipherText = DatatypeConverter.parseHexBinary(hexedCipherText);

            final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secretKeys, ""AES""), new IvParameterSpec(iv));

            return new String(cipher.doFinal(cipherText), Charsets.UTF_8);
        } catch (BadPaddingException e) {
            throw new IllegalArgumentException(""Secret key is invalid"");
        }catch (Exception e) {
            throw Throwables.propagate(e);
        }
    }
</code></pre>

<p>Working Decryption code </p>

<pre><code>var str = 'CB5E759CE5FEAFEFCC9BABBFD84DC80C0291ED4917CF1402FF03B8E12716E44C';

console.log(""Result: "" + CryptoJS.AES.decrypt({
    ciphertext: CryptoJS.enc.Hex.parse(str.substring(32))
}, CryptoJS.enc.Utf8.parse(CryptoJS.SHA1(""test"").toString().substring(0,16)),  
{
  iv: CryptoJS.enc.Hex.parse(str.substring(0,32)),
}).toString(CryptoJS.enc.Utf8))
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/sha1.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
</code></pre>

<p>How to implement Javascript AES encryption to Java AES Decryption code. Please give me inputs how to reslove this issue.   </p>
","","183","<javascript><java><aes><cryptojs>","0","","0","2018-11-21 09:27:21","","1","0","","","","2018-11-21 09:27:21",""
"53318968","How to create and send litecoin testnet transaction in Node js","<p>I am new to blockchain . I have done creation of bitcoin transaction and send its raw transaction to block chain network successfully. I am facing problem in sending raw transaction of litecoin to block chain network. my code is here</p>

<pre><code>var broadcast_tx = function(tx) {
    console.log(""tx in hex = "", tx.toHex());
    var req = {
      method: 'POST',
      url: 'https://chain.so/api/v2/send_tx/LTCTEST',
      headers: {
        'Content-Type': ""application/json""
      },
      data: { ""tx_hex"": tx.toHex() }
     }

     $http(req).then(function(response){
      demo.showNotification(""Operation successful"",""fa fa-check"",2);
     }, function(error){
        demo.showNotification(err,""fa fa-check"",3);

     });
  }
</code></pre>
","","181","<node.js><block><cryptojs><litecoin><bitcoinlib>","0","","0","2018-11-15 11:56:11","","0","","","","","2018-11-15 11:56:11",""
"51438172","Crypto.JS with AES Default Key Expansion - Decrypt in Java","<p>Helo guys, a client application is using the <a href=""https://github.com/sytelus/CryptoJS"" rel=""nofollow noreferrer"">cryptoJs Library</a> for AES Encryption </p>

<p>in the following way:
<code>CryptoJS.AES.encrypt(""Message"", ""SampleKey123456""</code>)
From the documentation: </p>

<blockquote>
  <p>For the key, when you pass a string, it's treated as a passphrase and used to derive an actual key and IV.</p>
</blockquote>

<p>The Java Server is using JDK8 + JCE </p>

<p>Questions: </p>

<ul>
<li>Will the IV be prepended to the Encrypted String (first 16 Bytes)? I guess not, because it says: <code>derive an actual key and IV</code></li>
<li>How can I use the same Key Expansion in Java or which algorithm is it?I've got the Passphrase <code>""SampleKey123456""</code> as Plain Text and would use <code>new SecretKeySpec(keyPlain.getBytes(), ""AES"")</code> if it was the actual key instead of Passphrase</li>
<li>Another Idea would be using a standard Key Expansion/Derivation function like pbkdf, which could easily be used in cryptoJs and Java. </li>
</ul>
","<p>If anyone is interested in a spring-security-crypto compatible Version:
<a href=""http://jsfiddle.net/robertwiesner/14Lhapv0/"" rel=""nofollow noreferrer"">http://jsfiddle.net/robertwiesner/14Lhapv0/</a>
It uses PBKDF2 with Password and Salt</p>

<pre><code>var password = $(""[name='password']"").val();
var salt = CryptoJS.enc.Utf8.parse($(""[name='salt']"").val());
var key = CryptoJS.PBKDF2(password, salt, {
keySize: 256 / 32,
iterations: 1024
});
</code></pre>

<p>In Spring: <code>return Encryptors.standard(cryptoPassword, new 
    String(Hex.encode(Utf8.encode(cryptoKeySalt))));</code> where cryptoPassword and cryptoKeySalt are regular String properties.</p>

<p>Will post a full example on GitHub, soon.     </p>
","180","<javascript><java><encryption><aes><cryptojs>","2","0","1","2018-07-31 18:05:09","","2","","3770728","","2018-07-20 09:46:47","2018-07-20 08:22:26",""
"42387514","ASUS zenfone5 t00j AES 256 decryption issue","<p>I am working on mobile application and client side we are using JavaScript (kony)  at server side its java. This is working fine for all other device except intel chipset devices (ASUS Zenfone). PFB the JS code for encryption</p>

<pre><code>function encryptDataModeCBC() 
{
    var encData = ""Test"";
    try 
    {
        var encText = CryptoJS.AES.encrypt(encData, ""3f4c57006f7d2d9528de3c46b626df06cdc405cb0243b10ca7612d967c688744"", {
            iv: ""31fd1ae51454cd55db81f1fa60a343ed"",
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7
        }).ciphertext.toString(CryptoJS.enc.Base64); 
        alert (""encText =&gt; ""+encText);    
        kony.print(""$$$$ encText =&gt; ""+encText);    
    } 
    catch (e) 
    {
        alert(kony.i18n.getLocalizedString(""technicalError""));      
    }
}
</code></pre>

<p>Here creating IV &amp; secret key using sha256 &amp; sha512 hashing algorithm. </p>

<p>PFB the code snippet which we are using at server side for decrypting the encrypted string </p>

<p>secret key generation code </p>

<pre><code>private SecretKeySpec getKey(String mode, String msgDigest, String encryptionKey, boolean is256) throws Exception {
    byte[] key = encryptionKey.getBytes(""UTF-8"");
    MessageDigest sha = MessageDigest.getInstance(msgDigest); // This is SHA-256
    key = sha.digest(key);
    if (is256) {  // This is true in our case.
      key = Arrays.copyOf(key, 32);
      this.logger.debug(""Secret Key "" + DigestUtils.sha256Hex(encryptionKey).substring(0, 32));
    } else {
      key = Arrays.copyOf(key, 16);
      this.logger.debug(""Secret Key "" + DigestUtils.sha256Hex(encryptionKey).substring(0, 16));
    }
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");
    String modeStr = mode.equals(""ECB"") ? ""AES/ECB/PKCS5Padding"" : ""AES/CBC/PKCS5Padding"";
    cipher = Cipher.getInstance(modeStr);
    return secretKeySpec;
}
</code></pre>

<p>IV generation at server side </p>

<pre><code>private IvParameterSpec getIV(String uid, String pin) throws Exception {
  String ivValue = new StringBuilder(uid).reverse().toString() + new StringBuilder(pin).reverse();
  byte[] key = ivValue.getBytes(""UTF-8"");
  MessageDigest sha = MessageDigest.getInstance(""SHA-256"");
  key = sha.digest(key);
  key = Arrays.copyOf(key, 16);
  IvParameterSpec iv = new IvParameterSpec(key);
  return iv;
}
</code></pre>

<p>As I mentioned above this is failing in intel chipset devices. This is the exception which I am getting while decrypting the string </p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded
  at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
  at com.sun.crypto.provider.SunJCE_f.b(DashoA13*..)
  at com.sun.crypto.provider.AESCipher.engineDoFinal(DashoA13*..)
  at javax.crypto.Cipher.doFinal(DashoA13*..)
</code></pre>

<p>When I tried encrypting the string ""Test"" I am getting ""Tn2SzI8dmgCmEvQrzdqLxw=="" as encrypted string which I have used in below java code and tried to decrypt where I am getting the below error </p>

<pre><code>enc text =&gt; 7b9UNDI4IWNITNAQlYNP8w==
javax.crypto.BadPaddingException: Given final block not properly padded
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:966)
at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
at javax.crypto.Cipher.doFinal(Cipher.java:2165)
at com.ust.Encryptor.decrypt(Encryptor.java:92)
at com.ust.Encryptor.main(Encryptor.java:113)
</code></pre>

<p>Here is the JAVA code which I have used for decrypting </p>

<pre><code>package com.ust;

import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;    
import org.apache.commons.codec.digest.DigestUtils;

public class Encryptor {
    private static final String AES_PASS = ""0ca763dc6b05b5230e44beb6b90e346440204b6d334b09623eafd3fcfbad6a302faca28b0994872e3fd782e7353026684b7ac9385662144e0ed1e2a8e3e14fab79059929681e3794eb97271328ecccda6dbfb3a7991ea1324615cf5908fabdf6""; // Hashed into an AES key later
    private SecretKeySpec keyObj;
    private Cipher cipher;
    private IvParameterSpec ivObj;
    final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();


    public Encryptor() throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException {
        // A constant IV, since CBC requires an IV but we don't really need one

        String ivValue = new StringBuilder(""astring"").reverse().toString() + new StringBuilder(""0ca763dc6b05b5230e44beb6b90e346440204b6d334b09623eafd3fcfbad6a302faca28b0994872e3fd782e7353026684b7ac9385662144e0ed1e2a8e3e14fab"").reverse();
        System.out.println(""ivValue =&gt; ""+ivValue);
        try {
            byte[] ivkey = ivValue.getBytes(""UTF-8"");
            MessageDigest shaIv = MessageDigest.getInstance(""SHA-256"");
            ivkey = shaIv.digest(ivkey);
            ivkey = Arrays.copyOf(ivkey, 16);
            System.out.println(""IV =&gt; ""+bytesToHex(ivkey));
            this.ivObj = new IvParameterSpec(ivkey);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        // Create an SHA-256 256-bit hash of the key
        byte[] key = AES_PASS.getBytes();
        MessageDigest sha = MessageDigest.getInstance(""SHA-256"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 32); // Use only first 256 bit
        System.out.println(""SEC KEY =&gt; ""+bytesToHex(key));
        this.keyObj = new SecretKeySpec(key, ""AES"");

        // Create a Cipher by specifying the following parameters
        //  a. Algorithm name - here it is AES 
        //  b. Mode - here it is CBC mode 
        //  c. Padding - e.g. PKCS7 or PKCS5
        this.cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    }

    public String encrypt(String strDataToEncrypt) throws InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, NoSuchPaddingException {
        String strCipherText = new String();

        this.cipher.init(Cipher.ENCRYPT_MODE, this.keyObj, this.ivObj);

        // Encrypt the Data 
        //  a. Declare / Initialize the Data. Here the data is of type String 
        //  b. Convert the Input Text to Bytes 
        //  c. Encrypt the bytes using doFinal method
        byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();

        byte[] byteCipherText = this.cipher.doFinal(byteDataToEncrypt);

        // b64 is done differently on Android
        strCipherText = Base64.encodeBase64String(byteCipherText);

        return strCipherText;
    }

    public String decrypt(String strCipherText) throws InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, NoSuchPaddingException {
        String strDecryptedText = new String();

        // Initialize the Cipher for Encryption
        this.cipher.init(Cipher.DECRYPT_MODE, this.keyObj, this.ivObj);

        // Decode the Base64 text
        byte[] cipherBytes = Base64.decodeBase64(strCipherText);

        // Decrypt the Data
        //  a. Initialize a new instance of Cipher for Decryption (normally don't reuse the same object)
        //     Be sure to obtain the same IV bytes for CBC mode.
        //  b. Decrypt the cipher bytes using doFinal method
        byte[] byteDecryptedText = this.cipher.doFinal(cipherBytes);
        strDecryptedText = new String(byteDecryptedText);

        return strDecryptedText;
    }
    public static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for ( int j = 0; j &lt; bytes.length; j++ ) {
            v = bytes[j] &amp; 0xFF;
            hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
            hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
        }
        return new String(hexChars);
    }

    public static void main (String args[]) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException{
        Encryptor aesCipher = new Encryptor();
        try {
            String encText = aesCipher.encrypt(""Test"");
            System.out.println(""enc text =&gt; ""+encText);
            String plaintext = aesCipher.decrypt(""Tn2SzI8dmgCmEvQrzdqLxw=="");//(""eat6f1uCCXVqJgTNUA8BCqXSA4kG4GhKajXdkyV0TewK+jgDkbQ/lPVaevv4rW3XdSmtVyOKLVJjPw9Akeblrh+ejIv9u48n7PkRKniwfxq/URuPU7lhS/sO5JMiJ7+ufgKFvJapxhSfftCtigtDc8F6Y2lJIPEUeQeQKOVc1noeLqPFggz55hWjWvDtpYh/sG76MwLlWDM7cj+uu6ru3ImmDA7qoM4tJOWBBkfng8u20R1ZcF3gM45TgDLUdL912AE1WO+grGBGjqzTXlK2/jgu3OOsLVI0jndB49K5q3/oKJc7JEoIZb0eZJcuZ80A"");
            System.out.println(""plain text =&gt; ""+plaintext);
        } catch (InvalidKeyException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
</code></pre>
","<p>CryptoJS assumes that</p>

<ul>
<li>a key which is passed as a string is actually a password and will hash it again along with a randomly generated salt or it will use the key as-is if it is a WordArray and</li>
<li>the IV should be a WordArray</li>
</ul>

<p>WordArray is CryptoJS' internal binary data representation.</p>

<p>The code should be:</p>

<pre><code>try {
    var key = CryptoJS.enc.Hex.parse(""3f4c57006f7d2d9528de3c46b626df06cdc405cb0243b10ca7612d967c688744"");
    var iv = CryptoJS.enc.Hex.parse(""31fd1ae51454cd55db81f1fa60a343ed44"");
    var encText = CryptoJS.AES.encrypt(encData, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    }).ciphertext.toString(CryptoJS.enc.Base64); 
    alert (""encText =&gt; ""+encText);    
    kony.print(""$$$$ encText =&gt; ""+encText);    
} 
catch (e) 
{
    alert(kony.i18n.getLocalizedString(""technicalError""));
}
</code></pre>

<hr>

<p>Something to think about:</p>

<ul>
<li><p>If you send the symmetric key from the server to the client, then anyone who might be listening will get the key and can decrypt the ciphertexts you send. This solution doesn't provide security, but rather obfuscation. You should use TLS which would make the connection actually secure.</p></li>
<li><p>The IV must be unpredictable (read: random). Don't use a static IV, because that makes the cipher deterministic and therefore not semantically secure. An attacker who observes ciphertexts can determine when the same message prefix was sent before. The IV is not secret, so you can send it along with the ciphertext. Usually, it is simply prepended to the ciphertext and sliced off before decryption.</p></li>
<li><p>It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p></li>
</ul>
","176","<javascript><android><encryption><cryptojs><badpaddingexception>","2","2","1","2017-02-25 13:57:10","42454064","1","3","543393","","2017-02-25 13:57:10","2017-02-22 09:26:52",""
"53607169","How to decrypt a file in CryptoJS , encrypted by Nodejs with RC4","<p>I want to decrypt (using cryptojs) an encypted mp4 file(using nodejs crypto rc4).I am unable to decrypt file as am new to nodejs.Any help is appreciated.</p>

<p>Below is code used at nodejs for encrypt(npm package file-encryptor):</p>

<pre><code>var crypto = require('crypto'),
    fs = require('fs');

var Encryptor = {};

Encryptor.encryptFile = function(inputPath, outputPath, key, options, callback) {

  if(typeof options === 'function') {
    callback = options;
    options = {};
  }

  options = Encryptor.combineOptions(options);

  var keyBuf = new Buffer(key);

  var inputStream = fs.createReadStream(inputPath);
  var outputStream = fs.createWriteStream(outputPath);
  var cipher = crypto.createCipher(options.algorithm, keyBuf);

  inputStream.on('data', function(data) {
    var buf = new Buffer(cipher.update(data), 'binary');
    outputStream.write(buf);
  });

  inputStream.on('end', function() {
    try {
      var buf = new Buffer(cipher.final('binary'), 'binary');
      outputStream.write(buf);
      outputStream.end();
      outputStream.on('close', function() {
        return callback();
      });
    } catch(e) {
      fs.unlink(outputPath);
      return callback(e);
    }
  });
};

a
</code></pre>

<blockquote>
  <p>nd below my javascript code am trying using cryptojs</p>
</blockquote>

<pre><code>window.resolveLocalFileSystemURL(inputPath, function (file) {
        file.file(function(ffile) {

                          var reader = new FileReader();
                          var imgBlob = new Blob([ffile], { type: 'video/mp4' });
                          reader.onload = function(e) {

                                var text= Encryptor.Utf8ArrayToStr(e.target.result);
                                  var outputString=CryptoJS.RC4.decrypt(text,key,{padding: CryptoJS.pad.NoPadding} );
                                  var buf = new Buffer([outputString],'binary');
                                  var imgBlob = new Blob([outputString], { type: 'video/mp4' });
                                  fileEntry.createWriter(function(fileWriter) {
                                    fileWriter.write(imgBlob);
                                  });
                            //});

                          };

                          reader.onloadend = function(e) {

                                                          var text= Encryptor.Utf8ArrayToStr(e.target.result);//,function(text){
                                  var outputString=CryptoJS.RC4.decrypt(text,key ,{padding: CryptoJS.pad.NoPadding});
                                  var buf = new Buffer([outputString],'binary');
                                  var imgBlob = new Blob([outputString], { type: 'video/mp4' });
                                  fileEntry.createWriter(function(fileWriter) {
                                    fileWriter.write(imgBlob);
                                  });
                            //});
                          };

                          reader.readAsArrayBuffer(ffile);
                      });
                    });
</code></pre>

<p>Anyone know how to do this? I am stuck with this from long time. </p>
","","174","<javascript><node.js><encryption><cryptojs><node-crypto>","0","","0","2018-12-04 06:49:33","","0","","","","","2018-12-04 06:49:33",""
"43667500","Decrypt each element of an Array","<p>I've got an array of <code>n</code> string elements encrypted with <code>CryptoJS</code> : <code>[krypt1, krypt2, krypt3, ...]</code></p>

<p><strong>The <code>keydecrypt</code> is the same for each element.</strong></p>

<p>I try to decrypt each element of the array and return an array of string decrypted elements like this <code>[dekrypt1, dekrypt2, dekrypt3, ...]</code></p>

<p>My code is:</p>

<pre><code>var urltodecrypt = this.url.chunk;
function decrypteach(x) {
    return CryptoJS.AES.decrypt(x.toString(), keydecrypt).toString(CryptoJS.enc.Utf8);
}
var clearfileurl = urltodecrypt.map(decrypteach);
</code></pre>

<p>When there is 1 element in the array, everything's fine: it return an array of rightly decrypted string element.</p>

<p>When there is >1 elements, <code>var urltodecrypt</code> give still the right array (verified), <strong>but <code>var clearfileurl</code> return an error: <code>Error: Malformed UTF-8 data</code></strong></p>

<p>What am I missing?</p>

<p><strong>EDIT</strong></p>

<p>Tried on @vector advices a <code>loop over each element function</code> on <a href=""https://stackoverflow.com/a/3010848/7281870"">this model</a> : </p>

<pre><code>var urltodecrypt = this.url.chunk;
var arrayLength = urltodecrypt.length;
for (var i = 0; i &lt; arrayLength; i++) {
     var clearfileurl = CryptoJS.AES.decrypt(urltodecrypt.toString(), keydecrypt).toString(CryptoJS.enc.Utf8);
}
console.log (clearfileurl);
</code></pre>

<p>Exact same result = 1 element array :ok / >1 elements array: <code>Error: Malformed UTF-8 data</code></p>

<p><strong>EDIT #2: question close</strong></p>

<p>I just broke my first code (<code>map</code>) into different vars :</p>

<ul>
<li><code>x.toString()</code></li>
<li><code>CryptoJS.AES.decrypt()</code></li>
<li><code>toString(CryptoJS.enc.Utf8)</code></li>
</ul>

<p>I relaunched my server : everything's fine now, from 1 element array to +10 elements array.</p>

<p>Just in case, below my (heavy &amp; superstitious...) tested working code:</p>

<pre><code>var urltodecrypt = this.url.chunk;
console.log (urltodecrypt);
function decrypteach(x) {
    var stringurl = x.toString();
    var bytesfileurl = CryptoJS.AES.decrypt(stringurl, keydecrypt);
    var finaldecrypturl = bytesfileurl.toString(CryptoJS.enc.Utf8);
    return finaldecrypturl;
}
var clearfileurl = urltodecrypt.map(decrypteach);
console.log (clearfileurl);
</code></pre>
","","172","<javascript><cryptojs>","0","","0","2017-04-28 00:07:20","","11","","-1","","2017-05-23 12:09:56","2017-04-27 20:38:13",""
"54526141","Decrypt AES-256 message using CryptoJS which was encrypted using Java / Kotlin","<p>I try to decrypt a message which was encrypted on a Java backend.</p>

<p>To do this I prepared this fiddle:
<a href=""http://jsfiddle.net/Lwp15e8z/1/"" rel=""nofollow noreferrer"">http://jsfiddle.net/Lwp15e8z/1/</a></p>

<pre><code>var secretKeyHash = CryptoJS.SHA256('mySecret')

var bytes = 
  CryptoJS.AES.decrypt(
    CryptoJS.enc.Base64.parse(
      ""mB7DRFjMdC1cG+twH3jKDiWcPGWypqwHlFqf1vOJpC8=""), 
      secretKeyHash, 
      {
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
      })

console.log(""Result: "", bytes.toString(CryptoJS.enc.Utf8))
</code></pre>

<p>Somehow I get an empty <code>bytes</code> WordArray instead the decrypted text.</p>

<p>Any ideas what I'm doing wrong?</p>

<p><strong>The parameters are:</strong></p>

<ul>
<li>Algorithm: AES/CBC/PKCS5Padding</li>
<li>Passphrase: mySecret</li>
<li>Encrypted Base64: mB7DRFjMdC1cG+twH3jKDiWcPGWypqwHlFqf1vOJpC8=</li>
</ul>

<p><strong>Backend Code works like this:</strong></p>

<pre><code>import shadow.com.google.common.hash.Hashing
import shadow.com.google.common.io.BaseEncoding
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec

fun aes256Encrypt(block: ByteArray, key: ByteArray): ByteArray {
    val secretKey = SecretKeySpec(
            Hashing.sha256().hashBytes(key).asBytes(), ""AES"")
    val cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"")
    cipher.init(Cipher.ENCRYPT_MODE, secretKey)
    return cipher.doFinal(block)
}

fun main(args: Array&lt;String&gt;) {
    println(BaseEncoding.base64().encode(
            aes256Encrypt(""Hello World "".toByteArray(), ""mySecret"".toByteArray())))
}
</code></pre>

<p>I made already some observations from the cryptojs documentation: <a href=""https://cryptojs.gitbook.io/docs/#ciphers"" rel=""nofollow noreferrer"">https://cryptojs.gitbook.io/docs/#ciphers</a></p>

<ul>
<li><a href=""https://cryptojs.gitbook.io/docs/#the-cipher-algorithms"" rel=""nofollow noreferrer"">""When passing a passphrase CrptyoJS generates a 256Bit key""</a>: Which hashing algorithm it uses? If it's SHA I don't need to do it by hand.</li>
<li><a href=""https://cryptojs.gitbook.io/docs/#the-cipher-input"" rel=""nofollow noreferrer"">This chapter</a> says: ""when passing a WordArray as Key ... you must also pass the actual IV."" Because of using <code>CryptoJS.SHA256</code> I'm going to pass a WordArray into it. Does it mean I need to parse the IV myself?</li>
</ul>
","","168","<javascript><java><encryption><kotlin><cryptojs>","0","","0","2019-02-05 00:10:36","","1","","","","","2019-02-05 00:10:36",""
"35260418","Meteor accounts-password: get the password of logged in user","<p>I am trying to <strong>encrypt</strong> some fields in a collection in Meteor. The encryption requires the <strong>user's login password</strong>. The password can be obtained when the user logs in. It is stored temporarily as a variable in Meteor. However, when user refreshes their browser, the variable lost its value even though the user is still logged in. Without the password, the encryption cannot be done correctly. </p>

<p>I am using <strong>accounts-password</strong> package to handle user login and sign-up, and I am wondering if it's possible for my app to call a function to get the user's login password whenever I want to do encryption. </p>

<p>If it helps to answer this question, I am using Meteor version 1.3 beta 0.4. Thanks!</p>
","<p>You can use the <a href=""https://atmospherejs.com/meteor/amplify"" rel=""nofollow"">amplify</a> package to store the password temporarily and then continue to process it. Remember to clear the password after the process is done</p>
","168","<encryption><meteor><meteor-accounts><cryptojs>","0","0","2","2016-02-09 01:47:18","35260441","0","","","","","2016-02-07 23:17:32",""
"35260418","Meteor accounts-password: get the password of logged in user","<p>I am trying to <strong>encrypt</strong> some fields in a collection in Meteor. The encryption requires the <strong>user's login password</strong>. The password can be obtained when the user logs in. It is stored temporarily as a variable in Meteor. However, when user refreshes their browser, the variable lost its value even though the user is still logged in. Without the password, the encryption cannot be done correctly. </p>

<p>I am using <strong>accounts-password</strong> package to handle user login and sign-up, and I am wondering if it's possible for my app to call a function to get the user's login password whenever I want to do encryption. </p>

<p>If it helps to answer this question, I am using Meteor version 1.3 beta 0.4. Thanks!</p>
","<p>For those of you who have similar questions, I ended up using <a href=""https://atmospherejs.com/u2622/persistent-session"" rel=""nofollow"">persistent-session</a> package, it uses amplify as a dependency, and it has an <strong>authenticated session variable</strong> which will be cleared automatically when the user logs out. </p>
","168","<encryption><meteor><meteor-accounts><cryptojs>","0","1","2","2016-02-09 01:47:18","35260441","0","","","","","2016-02-07 23:17:32",""
"55756962","Password encryption sha1 php to node js crypto","<p>I have this two function in php.</p>

<pre><code>public function hashSSHA($password) {
    $salt = sha1(rand());
    $salt = substr($salt, 0, 10);
    $encrypted_password = base64_encode(sha1($password . $salt, true).$salt);
    $hash = array(""salt""=&gt;$salt, ""encrypted""=&gt;$encrypted_password);
    return $hash;
}

//Password Decryption 
public function checkhashSSHA($salt, $password) {
    $hash = base64_encode(sha1($password . $salt, true).$salt);
    return $hash;
}
</code></pre>

<p>I am trying to write this two functions in node js.</p>

<p>Here is something I tried.</p>

<pre><code>const hash = crypto.createHash('sha1', 'my different salt from DB');
hash.update(password);
console.log(hash.digest('base64'));
</code></pre>

<p>But they both produced different results.</p>
","<p>These Node.js functions should be equivalent to your PHP code:  </p>

<pre><code>const crypto = require(""crypto"");

function hashSSHA(password){
    let salt = crypto.createHash('sha1').update(crypto.randomBytes(8)).digest('base64');
    salt = salt.substring(0,10);
    const hash = crypto.createHash('sha1');
    hash.update(password + salt);
    return {
        salt: salt,
        encrypted: Buffer.concat([hash.digest(), Buffer.from(salt)]).toString('base64')
    };
};

function checkhashSSHA(salt, password) {
    const hash = crypto.createHash('sha1');
    hash.update(password + salt);
    return Buffer.concat([hash.digest(), Buffer.from(salt)]).toString('base64');
}

const password = ""some password"";
const hashResult = hashSSHA(password);
console.log(""Hash result: "", hashResult);
console.log(""Check hash result: "", checkhashSSHA(hashResult.salt, password));
</code></pre>
","166","<php><node.js><sha1><cryptojs>","0","1","2","2019-04-19 13:37:54","55757919","1","","2930661","","2019-04-19 05:22:45","2019-04-19 05:20:48",""
"55756962","Password encryption sha1 php to node js crypto","<p>I have this two function in php.</p>

<pre><code>public function hashSSHA($password) {
    $salt = sha1(rand());
    $salt = substr($salt, 0, 10);
    $encrypted_password = base64_encode(sha1($password . $salt, true).$salt);
    $hash = array(""salt""=&gt;$salt, ""encrypted""=&gt;$encrypted_password);
    return $hash;
}

//Password Decryption 
public function checkhashSSHA($salt, $password) {
    $hash = base64_encode(sha1($password . $salt, true).$salt);
    return $hash;
}
</code></pre>

<p>I am trying to write this two functions in node js.</p>

<p>Here is something I tried.</p>

<pre><code>const hash = crypto.createHash('sha1', 'my different salt from DB');
hash.update(password);
console.log(hash.digest('base64'));
</code></pre>

<p>But they both produced different results.</p>
","<p>They both show different results because in your PHP code you have salt added while in NodeJs you some other salt. So that's why both have different hashes, but if you compare them using built in functions the result should return true.</p>

<pre><code>npm install bcrypt
</code></pre>

<p>...</p>

<pre><code>var bcrypt = require('bcrypt');
var hash = bcrypt.hashSync(""my password"");

bcrypt.compareSync(""my password"", hash); // true
bcrypt.compareSync(""not my password"", hash); // false
</code></pre>
","166","<php><node.js><sha1><cryptojs>","0","0","2","2019-04-19 13:37:54","55757919","1","","2930661","","2019-04-19 05:22:45","2019-04-19 05:20:48",""
"47510915","Crypto Hmac node.js equivalent for ruby for the following function","<pre><code>function hmac(key, string, encoding) {
  return crypto.createHmac('sha256', key).update(string, 'utf8').digest(encoding);
}
function hash(string, encoding) {
    return crypto.createHash('sha256').update(string, 'utf8').digest(encoding);
}
</code></pre>

<p>For the above function hmac encoding is optional, or else it have value 'hex'
I checked the OpenSsl library in ruby and found similar functions but not getting the same outputs when running in ruby.</p>

<p>Following link is used as reference to some extend but not exactly.Anyone have came across similar use case.Please let me know</p>
","<p>This is a very old question but I was just trying to do the same thing and figured posting an answer for posterity wouldn't hurt.</p>

<p>The Ruby equivalents I came up with are significantly more verbose because I am not aware of a way to pass the encoding as an argument to any of the methods.</p>

<p><strong>Note:</strong> <code>base64</code> and <code>hex</code> encodings are equivalent between JS and Ruby. It looks like there could be a difference in the output of Node's <code>latin1</code> encoding depending on how Ruby is configured, but I believe the raw bytes are equivalent.</p>

<pre class=""lang-ruby prettyprint-override""><code>require 'openssl'
require 'base64'

def hmac(key, string, encoding = 'hex')
  hmac = OpenSSL::HMAC.new(key, 'sha256')
  hmac &lt;&lt; string
  case encoding
    when 'base64'
      Base64.encode64(hmac.digest)
    when 'hex'
      hmac.hexdigest
    else
      hmac.digest
  end
end

def hash(string, encoding = 'hex')
  sha256 = OpenSSL::Digest::SHA256.new
  sha256 &lt;&lt; string
  case encoding
    when 'base64'
      Base64.encode64(sha256.digest)
    when 'hex'
      sha256.hexdigest
    else
      sha256.digest
  end
end

key = ""NjNsSSpyaE83NyZGaGdpYXhLQmFjVUJhZ3UyMENqZWY=""
string = ""this is a test""
encoding = ""hex"";
puts hmac(key, string, encoding) # =&gt; adb2946c2815047327d51459b401836cebb1a31644604303b4886b028bb98e69
puts hash(string, encoding) # =&gt; 2e99758548972a8e8822ad47fa1017ff72f06f3ff6a016851f45c398732bc50c
</code></pre>

<p>And to test, you can simply run the equivalent in node</p>

<pre class=""lang-js prettyprint-override""><code>var key = ""NjNsSSpyaE83NyZGaGdpYXhLQmFjVUJhZ3UyMENqZWY=""
var string = ""this is a test""
var encoding = ""hex"";
console.log(hmac(key, string, encoding)) // =&gt; adb2946c2815047327d51459b401836cebb1a31644604303b4886b028bb98e69
console.log(hash(string, encoding)) // =&gt; 2e99758548972a8e8822ad47fa1017ff72f06f3ff6a016851f45c398732bc50c
</code></pre>
","165","<node.js><ruby><openssl><hmac><cryptojs>","0","1","1","2018-09-29 23:42:21","","0","","","","","2017-11-27 12:22:13",""
"51211923","Encrypt in node and decrypt in PHP 7 with openssl","<p>I found this post how to encrypt in php and decrypt in node and it works:
<a href=""https://stackoverflow.com/questions/41792883/encrypt-in-php-7-decrypt-in-node-js"">Encrypt in PHP 7 decrypt in Node JS</a></p>

<p>But I have problem to do the same in oposite direction.</p>

<p>I tried like this:</p>

<p>Node:</p>

<pre><code>const crypto = require('crypto');

const data = ""data to encrypt"";
const key = ""315a5504d921f8327f73a356d2bbcbf1"";
const iv = new Buffer(data.substring(0, 32), 'hex');

const cipher = crypto.createCipher('aes-256-cbc', key, iv);
let crypted = cipher.update(data, 'utf8', 'hex')
crypted += cipher.final('hex');
console.log(crypted);
</code></pre>

<p>PHP: </p>

<pre><code>&lt;?php
$encryptedMessage = '3aa3fc237aaf34a26482674cfcef1210';
$encryptionMethod = 'aes-256-cbc';
$secretHash = ""315a5504d921f8327f73a356d2bbcbf1"";

//To Decrypt
$iv_size = openssl_cipher_iv_length($encryptionMethod);
$iv = hex2bin(substr($encryptedMessage, 0, $iv_size * 2));

$decryptedMessage = openssl_decrypt(substr($encryptedMessage, $iv_size * 2), $encryptionMethod, $secretHash, 0, $iv);

echo ""Decrypted: $decryptedMessage"";
</code></pre>

<p>But not working, any idea how to make this work?</p>
","<p>The IV should be random and the same IV needs to be used in both the encryption and decryption process.  </p>

<p>Your initialization vector is based on the unecrypted string, which is a very bad idea as you'd be leaking part of your unecrypted data if you send the IV with the encrypted data.</p>
","162","<php><node.js><encryption><openssl><cryptojs>","0","0","1","2018-07-06 14:01:27","","1","","","","","2018-07-06 13:49:59",""
"45590205","Different outputs from Crypt(3) and CryptoJS","<p>I am hashing passwords in MariaDB using:</p>

<p><code>ENCRYPT('password', CONCAT('$6$', SUBSTRING(SHA(RAND()), -16))</code></p>

<p>Which produces something like:</p>

<p><code>$6$3b502db443d64283$BNSYWsf3T0e4xT23GJW/QPpKvzLidio5zk9v7kCE.wk4dtNo4avMzBxvqoWc0Y5ihj/zVwtGCwZRfTFur0BnI1</code></p>

<p>The format here is <code>$6</code> meaning SHA512, then the <code>$salt$</code> and then the computed password hash. So the computed hash alone is </p>

<p><code>BNSYWsf3T0e4xT23GJW/QPpKvzLidio5zk9v7kCE.wk4dtNo4avMzBxvqoWc0Y5ihj/zVwtGCwZRfTFur0BnI1</code></p>

<p>As I understand it this uses crypt(3) in the background. If I write a short bit of C such as:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;crypt.h&gt;
#include &lt;stdio.h&gt;

int main() {
  char * blah = crypt(""password"", ""$6$3b502db443d64283"");
  puts(blah);
}
</code></pre>

<p>Taking care to put in the same random salt as the <code>RAND()</code> function generated for MySQL and prepending the <code>$6</code> to use SHA512, then I do indeed get the same result:</p>

<p><code>$6$3b502db443d64283$BNSYWsf3T0e4xT23GJW/QPpKvzLidio5zk9v7kCE.wk4dtNo4avMzBxvqoWc0Y5ihj/zVwtGCwZRfTFur0BnI1</code></p>

<p>Again the computed hash itself is:</p>

<p><code>BNSYWsf3T0e4xT23GJW/QPpKvzLidio5zk9v7kCE.wk4dtNo4avMzBxvqoWc0Y5ihj/zVwtGCwZRfTFur0BnI1</code></p>

<p>Now if I use CryptoJS and wanted to compare that Hash in JS code rather than in the DB (or in - heaven forfend! - C), then I find that I have a problem. For example here is my CryptoJS code:</p>

<pre><code>var CryptoJS = require('crypto-js');
var SHA512 = require('crypto-js/sha512');
  console.log(SHA512(""3b502db443d64283password"")).toString();
</code></pre>

<p>I prepend the salt to the password as this function takes only a single argument. The result is:</p>

<p><code>105865ba5bf0649410927131204a1228260e59e95b1b53942001b98835dca4aedfe7039a00060fdba8531c44c83cd3b7bec4864865915938d2ed7ed477254f61</code></p>

<p>Ok. So I recognise that that is a Hex encoding of the Hashed password. So I'll change the encoding...but to what? I'll try Base64:</p>

<pre><code>  `console.log(SHA512(""3b502db443d64283password"")).toString(CryptoJS.enc.Base64);`
</code></pre>

<p>The output is:</p>

<p><code>EFhlulvwZJQQknExIEoSKCYOWelbG1OUIAG5iDXcpK7f5wOaAAYP26hTHETIPNO3vsSGSGWRWTjS7X7UdyVPYQ==</code></p>

<p>I'm starting to see a problem here. The encoding used by crypt(3) isn't base64. What is it? I look in the man page:</p>

<blockquote>
  <p>The characters in ""salt"" and ""encrypted"" are drawn from the set
  [a-zA-Z0-9./].</p>
</blockquote>

<p>So I'm left with these questions:</p>

<ol>
<li><p>What is the encoding used by crypt(3)? Is it a standard or just a chosen character set.</p></li>
<li><p>Is there any way to compare hashes generated with two different character sets like this? I mean is there an underlying representation they share of the hashed password? Can I access it?</p></li>
<li><p>How do I know how many rounds each function is making? Is there any way to know without examining the source code?</p></li>
<li><p>Is my assumption that I prepend the salt correct when using CryptoJS?</p></li>
</ol>
","","162","<javascript><c><mariadb><cryptojs><crypt>","2","","0","2017-08-09 16:42:46","","10","","1970775","","2017-08-09 16:42:46","2017-08-09 12:05:07",""
"49815850","Nodejs, Crypto: Encrypting multiple strings using same cipher","<p>I am trying to encrypt multiple strings using same cipher with the code</p>

<pre><code>var iv = _crypto.randomBytes(16).slice(0, 12);
var salt = _crypto.randomBytes(64);
var key = _crypto.pbkdf2Sync(symmetricKey, salt, 2145, 32, 'sha512');

var cipher = _crypto.createCipheriv('aes-256-gcm', key,iv);

var a = Buffer.concat([cipher.update(""data1"", 'utf8'), cipher.final()]);
var b = Buffer.concat([salt, iv, a]).toString('base64');

var c = Buffer.concat([cipher.update(""data2"", 'utf8'), cipher.final()]);
</code></pre>

<p>The execution failed in the last line without showing any error.
""TypeError: error:00000000:lib(0):func(0):reason(0)""</p>

<p>On investigating further, I came to know that we can't use the cipher once we have done cipher.final(). But if I won't do it earlier(during encryption of data1), during decryption of ""encrypted format of data1"", it would fail since cipher.final returns any remaining enciphered contents which gets appended with the original encrypted string.</p>

<p>What's the best way to encrypt multiple strings then, or should I create separate ciphers for all the strings?</p>
","","162","<node.js><encryption><cryptojs><aes-gcm><symmetric-key>","1","","0","2018-04-13 11:47:47","","1","","","","","2018-04-13 11:23:08",""
"51288956","Why does my crypto.createHmac() generate a different HMAC for the same input?","<p>I am trying to match the HMAC in Node.js to the HMAC in PHP for API authorization. The problem is in Node.js, the createHmac() function generates a different HMAC for the same input, and therefore does not match with the HMAC in PHP.</p>

<p>Here is my JS code:</p>

<pre><code>events: {
  proxyReq: (proxyReq, req) =&gt; {
    const API_KEY = 125;
    const API_SECRET_KEY = 'abc';

    let hmac = crypto.createHmac('sha512', API_SECRET_KEY);
    hmac.update('0');
    const s = hmac.digest('base64');

    proxyReq.setHeader('x-api-key', API_KEY);
    proxyReq.setHeader('x-api-signature', s);
    proxyReq.setHeader('x-api-date', date);
  },
</code></pre>

<p>PHP:</p>

<pre><code>$API_SECRET_KEY = 'abc';
$client_signature = $request-&gt;header('x-api-signature');
$hmac = base64_encode(hash_hmac('sha512', '0', base64_decode($API_SECRET_KEY), true));

Log::error($client_signature);
Log::error($hmac);
</code></pre>

<p>Latest outputs:</p>

<pre><code>[2018-07-11 15:25:28] local.ERROR: dO50o/LcS0/UOXOu/5lHbOMXLe+l225vUU13fWEHeOoUHV7SlcSOE9rQq2UhTlys5N6C4hkq8QTALnpRehtlCg==  
[2018-07-11 15:25:28] local.ERROR: 7W2U/3uEKIMD0s39jmZLlJItwTcSSDQdW7WTYdslvIjuUeGydyqwwAuZzaMP0Do5v1zRJxmPITFdy4EHTY5r6A==  

[2018-07-11 15:25:33] local.ERROR: UYsXZFyoAB2zELZzwjWyktPEHlYqIP3cgLeb/LXK0X8pnkVxiqEaFWK7c1YIWd6hFPpZHn5j1YdbDhpAL7hQ5A==  
[2018-07-11 15:25:33] local.ERROR: 7W2U/3uEKIMD0s39jmZLlJItwTcSSDQdW7WTYdslvIjuUeGydyqwwAuZzaMP0Do5v1zRJxmPITFdy4EHTY5r6A==  
</code></pre>

<p>Any alternatives or solutions would be appreciated!</p>
","<p>If you match what you do in PHP with <code>base64_decode</code>, you get the correct value:</p>

<pre><code>const crypto = require('crypto');
const API_SECRET_KEY = Buffer.from('abc', 'base64');

let hmac = crypto.createHmac('sha512', API_SECRET_KEY);
hmac.update('0');
const s = hmac.digest('base64');
console.log(s);
</code></pre>

<p><code>7W2U/3uEKIMD0s39jmZLlJItwTcSSDQdW7WTYdslvIjuUeGydyqwwAuZzaMP0Do5v1zRJxmPITFdy4EHTY5r6A==</code></p>

<p><a href=""https://repl.it/repls/BouncyBogusGigabyte"" rel=""nofollow noreferrer"">https://repl.it/repls/BouncyBogusGigabyte</a></p>

<p>Check that you really have the correct constant API_SECRET_KEY value, the correct data input value ('0' in this case), and you are looking at the correct requests in the PHP code. If you provide the same inputs, both libraries will give you the same output value.</p>
","161","<javascript><php><node.js><hmac><cryptojs>","2","0","1","2018-07-11 16:28:37","","4","","7350995","","2018-07-11 15:27:59","2018-07-11 15:12:20",""
"25560244","MD5 string not displaying correctly with html()","<p>I have two spans with the IDs <code>salt</code> and <code>password</code></p>

<pre><code>&lt;div&gt;
    $salt = '&lt;span id=""salt""&gt;&lt;/span&gt;';&lt;br /&gt;
    $password = '&lt;span id=""password""&gt;&lt;/span&gt;';
&lt;/div&gt;
</code></pre>

<p>I then use the following jQuery code which takes the salt, adds it to the password entered by the user, and returns both a salt and hashed password (to copy into a config file)</p>

<pre><code>salt = (Math.random() +1).toString(36).substr(2, 16);
$('#salt').html(salt);
hashed = CryptoJS.MD5(salt + $(this).val());
$('#password').html(hashed);
</code></pre>

<p>This code adds the salt to the span with the <code>salt</code> ID, but it doesn't add anything to the <code>password</code> ID.</p>

<p>If I enter the code <code>alert(hashed)</code> it will open an alert with an md5 value.</p>

<p>If I change <code>.html()</code> to <code>.text()</code> it works.</p>
","<p>the <code>CryptoJS.MD5()</code> method returns an object. to convert this object to a string use it's <code>toString()</code> method.</p>

<pre><code>hashed = CryptoJS.MD5(value);
var hashedString = hashed.toString();
</code></pre>

<p>than to insert the text into an element use jQuerys <code>text()</code> method. the jQuery <code>html()</code> method is for setting an elements <code>innerHTML</code> value. but you want to insert unescaped text.</p>

<pre><code>$('#password').text(hashedString);
</code></pre>

<p><em>if an object is passed to <code>text()</code> it will automatically call <code>toString()</code> on it, although this is not documented in the reference</em></p>

<h1>reference</h1>

<h2>.text( text )</h2>

<blockquote>
  <p>The text to set as the content of each matched element. When Number or Boolean is supplied, it will be converted to a String representation. <strong>[] be aware that this method escapes the string provided as necessary so that it will render correctly in HTML.</strong></p>
</blockquote>

<p><em>from <a href=""http://api.jquery.com/text/"" rel=""nofollow"">jQuery API Documentation: <code>text()</code></a></em></p>

<h2>.html( htmlString )</h2>

<blockquote>
  <p>A string of HTML to set as the content of each matched element</p>
</blockquote>

<p><em>from <a href=""http://api.jquery.com/html/"" rel=""nofollow"">jQuery API Documentation: <code>html()</code></a></em></p>
","160","<javascript><jquery><cryptojs>","4","1","1","2014-08-29 17:04:45","25560765","8","","1952895","","2014-08-29 01:14:48","2014-08-29 01:08:31",""
"54641474","Equivalent CryptoJS SHA512 hash of content Hex encoded for python?","<p>I am trying to make an authenticated API call. Documentation example in JS states that contentHash header has to be populated with:</p>

<pre><code>content = {currencySymbol:symbol};
var contentHash = CryptoJS.SHA512(JSON.stringify(content)).toString(CryptoJS.enc.Hex); 
</code></pre>

<p>I am writing my request in Python and I keep getting INVALID_CONTENT_HASH. This is what I have so far:</p>

<pre><code>content = {""currencySymbol"":""BTC""}
contentHash = hashlib.sha512(json.dumps(content, separators=(',',':')).encode('latin1')).hexdigest()
</code></pre>

<p>Hash: 18aa13a42b5efe3c45b37050626f23fcc4f3b4acf5e479f2f50212722cdcd80baa0ba6ddf8dcbd0f1b88008aaf9ec33874e4be9ab6ec2dece611c2dbdca87560</p>

<p>Expected Hash: e6e0b5e9941269e61fb41bd4f6a0dc5be0da1c011087a057ff88fe3de98f41c6681983dd14662c88b6293663d942c93511c3fd7f9cc5250e686b16de53a18f57</p>

<p>I don't know what is wrong with my request. Please advice. </p>
","<p>Your problem is that <code>json.dumps</code> applies some minor pretty-printing by default but <code>JSON.stringify</code> does not.  </p>

<p>Try this:</p>

<pre><code>content = {'currencySymbol':'BTC'}
contentHash = hashlib.sha512(json.dumps(content, separators=(',',':')).encode('latin1')).hexdigest()
</code></pre>

<p>By adding the <code>separators=(',',':')</code> to <code>json.dumps</code>, it will remove the extra whitespace that is added by default</p>

<p><a href=""https://docs.python.org/2/library/json.html"" rel=""nofollow noreferrer"">documentation</a> for <code>json.dumps</code></p>
","159","<javascript><python><cryptojs><hashlib>","1","0","1","2019-02-15 23:33:24","","1","","5456035","","2019-02-15 23:33:24","2019-02-12 01:14:57",""
"52827665","Decrypt external AES256/CBC/PKCS7 data with CryptoJS, provided 64-char Hex key from SiteMinder","<p>I'm attempting to using CryptoJS to decrypt a string, provided a 64 character string from SiteMinder.</p>

<p>The decrypted string looks like:
<code>8yi6XwyLPZq%2FNjV9fmoyHYtC2UUS48KlpPLMl063gPwDDLJYkLeUFAwC8hTcXrPJkShbjJTShlLUoh2y17kwOA%3D%3D</code></p>

<p>And the key provided to me is a 64-character Hex string, like so: <code>B55E3CE5E4E335D61E3224B2EAAA79E68AFF43FFAAA85A9D4F2BA07618DF2D67</code></p>

<p>After the information is decrypted, it should present a string that shows something like:
<code>term1;term2</code></p>

<p>The JavaScript code I am using to decrypt with CryptoJS looks like:
<code>CryptoJS.AES.decrypt(
    encryptedValue,
    64CharacterKeyProvidedAbove
).toString();</code></p>

<p>However, the decrypted value isn't coming back as expected. I've read some information about providing an IV to use a pre-defined key, but I don't have any information, only the key used when SiteMinder encrypts information from the database it is connected to.</p>

<p>Do I need to change the way I'm using CryptoJS?</p>
","<p>Assuming you mean <em>encrypted</em> string looks like <code>8yi6XwyLPZq%2FNjV9fmoyHYtC2UUS48KlpPLMl063gPwDDLJYkLeUFAwC8hTcXrPJkShbjJTShlLUoh2y17kwOA%3D%3D</code>.</p>

<p>And given that encryption is AES256/CBC/PKCS7.</p>

<p>We can make these observations:</p>

<ul>
<li>The string looks URL-encoded and Base64-encoded (%3D is <code>=</code>, and Base64 often ends with <code>=</code>)</li>
<li>There is no IV which is required for CBC, so it is probably in the first 16 bytes of the encoded string. The remainder of the string is probably the ciphertext</li>
</ul>

<p>So we can decrypt it with CryptoJS like this:</p>

<pre><code>var encrypted = CryptoJS.enc.Base64.parse(decodeURIComponent(encryptedStr));
var key = CryptoJS.enc.Hex.parse(hexKey);
var iv = CryptoJS.enc.Hex.parse(CryptoJS.enc.Hex.stringify(encrypted).substr(0, 32));
var ciphertext = CryptoJS.enc.Hex.parse(CryptoJS.enc.Hex.stringify(encrypted).substr(32));
var plaintext = CryptoJS.AES.decrypt({ciphertext: ciphertext}, key, {iv: iv});    
</code></pre>

<p>Here's a working <a href=""https://jsfiddle.net/1yrdmxbL/"" rel=""nofollow noreferrer"">DEMO</a> on jsFiddle.</p>

<p>Result:</p>

<pre class=""lang-none prettyprint-override""><code>SERLOGINNAME=T6ATD1F;password=QWERTY!8;
</code></pre>
","159","<javascript><encryption><aes><cryptojs><siteminder>","0","0","1","2018-10-16 10:55:47","52833854","1","","","","","2018-10-16 03:42:19",""
"49478575","Encrypt with CryptoJS to Decypt with openssl_decrypt on PHP 7 returns always false","<p>I need in my front (ionic) encrypt a UUID to send it to the backend.</p>

<p>I use CryptoJS, this is my code to encrypt the UUID.</p>

<pre><code>const UUID = 'ABCD1234';
const privateKey = 'f38d09938ead31a57eca34d2a0df1c44';   
const salt = CryptoJS.lib.WordArray.random(16);
const iv = CryptoJS.lib.WordArray.random(16);
const key = CryptoJS.PBKDF2(privateKey, salt, {
  hasher: CryptoJS.algo.SHA512,
  keySize: 4,
  iterations: 1
});
const encripted = CryptoJS.AES.encrypt(UUID, key, {
  iv
});
const cp = {};
cp.mid = CryptoJS.enc.Base64.stringify(encripted.ciphertext);
cp.iv = CryptoJS.enc.Hex.stringify(iv);
cp.s = CryptoJS.enc.Hex.stringify(salt);
</code></pre>

<p>So I send the CP in headers to the server (Slim Framework 3).</p>

<p>I receive like this:</p>

<pre><code>$mid = $request-&gt;getHeader('HEADER-MID')[0];
$iv = $request-&gt;getHeader('HEADER-IV')[0];
$salt = $request-&gt;getHeader('HEADER-S')[0];

//Example Data Received
//mid: losv78Amn1zpgRe5/4hYFA==
//iv: 2d198339d178c053c37e36b7d03e8a3b
//salt: fb07dd1f61d72148bc1423af8cd1f295

$ct = base64_decode($mid);
$salt = hex2bin($salt);
$iv = hex2bin($iv);

$key = hash_pbkdf2(""sha512"", $privateKey, $salt, 1, 32);

$decrypted = openssl_decrypt($ct, 'AES-256-CBC', hex2bin($key), OPENSSL_RAW_DATA, $iv);
</code></pre>

<p>The key is generated correctly in back and front.</p>

<p>But the openssl_decrypt function return false and with openssl_error_string() get this:</p>

<pre><code>error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
</code></pre>

<p>I do not know what I'm doing wrong.</p>

<p>Thanks in advance.</p>
","","159","<php><encryption><openssl><aes><cryptojs>","0","","0","2018-03-25 17:13:41","","5","","","","","2018-03-25 17:13:41",""
"46535172","Jquery validate - replace field values before serializing","<p>Using the Jquery validate plugin I want to be able to use CryptoJS to obfuscate the fields <code>password</code> and <code>confirm_password</code> before I send the post data to the server.</p>

<p>The following methodology works fine, as in, the values for the two fields get replaced by the CryptoJS hash(?) and then get sent to the server. However, at the same time the password fields (the ones the users can see on the page) get populated with the hash as a bunch of additional asterisks. So if the users password was 123, then the visible fields change to the hash equivalent of that. This is not reflected in Chromes dev tools when viewing the input values (weird). How can I avoid this?</p>

<pre><code>$('#register-form').validate({
    rules: {
        code: {
            //required: true
        },
        email: {
            //required: true,
            email: true
        },
        username: {
            //required: true,
            minlength: 5
        },
        password: {
            //required: true,
            minlength: 6
        },
        confirm_password: {
            //required: true,
            minlength: 6
        },
        bot_sum: {
            //required: true
        }
    },
    errorElement: 'span',
    errorPlacement: function (error, element) {
        //element.closest('.control-group').addClass('has-error');
        error.addClass('text-danger validation-error');
        error.insertAfter(element);
    },
    submitHandler: function (form) {
        asengine.removeErrorMessages();
        form.elements['password'].value = CryptoJS.SHA512(form.elements['password'].value).toString();
        form.elements['confirm_password'].value = CryptoJS.SHA512(form.elements['confirm_password'].value).toString();
        var data = $(form).serialize();
        register.register_user(data);
    }
});
</code></pre>
","","157","<jquery><forms><serialization><jquery-validate><cryptojs>","0","","0","2017-10-03 15:05:58","","8","","594235","","2017-10-03 15:05:58","2017-10-02 23:40:26",""
"36368955","how crypto-js hide the class method?","<p>Start With This</p>

<pre><code>import crypto from 'crypto-js'
global.crypto = crypto
</code></pre>

<p>When I Access crypto from the browser Console I got the following error</p>

<pre><code>crypto['AES'].encrypt('MyString', 'pass').toString() // Uncaught TypeError: Cannot read property 'encrypt' of undefined()
</code></pre>

<p>but when I access it from Node it works -_-</p>

<pre><code>crypto['AES'].encrypt('MyString','pass').toString() // Encrypted String
</code></pre>

<p>How Crypto JS do this? can't directly access from the browser, but accessible in node?</p>
","<p>I believe your issue is that 'crypto' is reserved internally by the window object. Try importing under another name.</p>
","155","<javascript><node.js><encryption><methods><cryptojs>","2","1","1","2016-04-02 05:59:39","36369776","6","","1905944","","2016-04-02 04:27:18","2016-04-02 03:48:46",""
"39936524","Can't print CryptoJS-encrypted ciphertext to page","<p>I can't access the <code>encryptedData</code> variable with jQuery but in <code>alert</code> it works!!!</p>

<pre><code>&lt;script src=""js/jquery-1.6.4.min.js"" type=""text/javascript""&gt;&lt;/script&gt;
&lt;script src=""js/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
  $( document ).ready(function() {
    var textToEncrypt = ""textToEncrypt"";
    var secretPhrase  = ""secretPhrase"";
    var encryptedData = CryptoJS.AES.encrypt(textToEncrypt, secretPhrase);
    $('#data').text(encryptedData);  
    alert(encryptedData);
  });
&lt;/script&gt;

&lt;div id=""data""&gt;&lt;/div&gt;
</code></pre>
","<p><code>encryptedData</code> is a CipherParams object containing various properties such as <code>ciphertext</code>, <code>salt</code> and <code>iv</code>. jQuery's <code>text</code> function takes this object and tries to assign it directly to the element. <code>alert</code> on the other hand first stringifies it. You probably want:</p>

<pre><code>$('#data').text(encryptedData.toString());
</code></pre>
","154","<javascript><jquery><encryption><cryptojs>","0","1","1","2016-10-08 19:38:46","39936581","0","","1816580","","2016-10-08 19:38:46","2016-10-08 19:31:51",""
"50874329","How to Encode nodejs ecdh public key as pem","<p><a href=""https://stackoverflow.com/questions/39696888/unable-to-sign-a-file-with-nodejs-crypto/50873668#50873668"">Unable to sign a file with nodejs crypto</a></p>

<p>I am trying to verify a signed document created like in this thread using the method verify.verify() with the ECDH public key. Therefore, i guess, i have to format the raw public key into valid PEM.</p>

<p>How would i do that using the ans1.js and bn.js module?</p>
","","153","<node.js><sign><cryptojs><verify><diffie-hellman>","2","","0","2018-06-15 11:06:57","","0","","","","","2018-06-15 11:06:57",""
"41411889","Html textarea changing the value of a encoded javascript string","<p>I'm working on this <a href=""http://toastext.com/cipher.html"" rel=""nofollow noreferrer"">Encryption Cipher</a> using <a href=""https://code.google.com/archive/p/crypto-js/wikis/QuickStartGuide_v3beta.wiki"" rel=""nofollow noreferrer"">CryptoJS</a> for people who want to encrypt their messages. Unfortunately, I've run into a problem decrypting any messages that is encrypted using ""NoPadding"" padding. After hours and hours of testing the program for bugs, I finally found out what the problem was. I turns out that, when I append the encrypted javascript string into the HTML textarea, it changed the value of the string. Therefore, when I tried to decrypt the value from the textarea, it didn't work.</p>

<pre><code>    &lt;textarea id=""textarea""&gt;&lt;/textarea&gt;
    &lt;button onclick=""encrypting_without_textarea()""&gt;encrypting without textarea&lt;/button&gt;
    &lt;button onclick=""encrypting_with_textarea()""&gt;encrypting with textarea&lt;/button&gt;
</code></pre>

<p>HTML</p>

<pre><code>    function encrypting_without_textarea(){
        var textarea_element = document.getElementById(""textarea"");

        var encryptionKey = ""fkjasdlfkdsanfknlasknflsjkanflnasjkfnjknskjnfnlsnf"";
        var key  = CryptoJS.enc.Hex.stringify(encryptionKey);
        var value = ""Multi-stability is the tendency of ambiguous perceptual experiences to move unstably back and forth between alternative interpretations. Some objects can be perceived in more than one way. An example from below in the section of figure/ground."";
        var paddingObject = CryptoJS.pad.NoPadding;
        var encrypted = CryptoJS.AES.encrypt(value, key, {mode:CryptoJS.mode.ECB, padding:paddingObject});

        var decrypted = CryptoJS.AES.decrypt(encrypted, key, {mode:CryptoJS.mode.ECB, padding:paddingObject});
        var msg = decrypted.toString(CryptoJS.enc.Utf8);
        alert(msg); 
    } 
</code></pre>

<p>The one above is decrypted straight from the encrypted message and it works, and the one below is decrypted with the value from from the textarea but it returns an error.  </p>

<pre><code>             function encrypting_with_textarea(){
                var textarea_element = document.getElementById(""textarea"");

                var encryptionKey = ""fkjasdlfkdsanfknlasknflsjkanflnasjkfnjknskjnfnlsnf"";
                var key  = CryptoJS.enc.Hex.stringify(encryptionKey);
                var value = ""Multi-stability is the tendency of ambiguous perceptual experiences to move unstably back and forth between alternative interpretations. Some objects can be perceived in more than one way. An example from below in the section of figure/ground."";
                var paddingObject = CryptoJS.pad.NoPadding;
                var encrypted = CryptoJS.AES.encrypt(value, key, {mode:CryptoJS.mode.ECB, padding:paddingObject});
                textarea_element.value = encrypted;

                var decrypted = CryptoJS.AES.decrypt(textarea_element.value, key, {mode:CryptoJS.mode.ECB, padding:paddingObject});
                var msg = decrypted.toString(CryptoJS.enc.Utf8);
                alert(msg); 
                //Error: Malformed UTF-8 data
            } 
</code></pre>

<p>Here is the plnkr <a href=""http://plnkr.co/1Hu6F19yFq3LxPBNDOrN"" rel=""nofollow noreferrer"">link</a>. I understand that the value append to the textarea has change, but how? And, how do I change/encode the string so that the code can be display in the textarea and copy so that the message can be paste/decode with out it being corrupted. I'm open to any solutions, simpler the better?</p>
","","152","<javascript><html><cryptojs>","2","","0","2016-12-31 22:49:37","","12","","4592767","","2016-12-31 22:49:37","2016-12-31 21:42:05",""
"22901195","crypto-js throws compile error in Unity","<p>I am working on an app that currently stores user passwords in plain-text.  After a bit of research, I decided to opt for SHA3 from the crypto-js library to accomplish this task.  I downloaded the SHA3 rollup and placed it (unmodified) in the same folder as the scripts I intended to use it in.  Unity, however, immediately throws a compile error:</p>

<pre><code>Assets/Scripts/StartMenu/sha3.js(7,46): BCE0043: Unexpected token: ,.
</code></pre>

<p>Googling the error yields various issues with syntacticly incorrect code.  My research led me to believe that crypto-js was the go-to implementation for js, so I doubt there's an issue with the library.  Does Unity differ greater in it's JS implementation?  What am I missing?</p>
","<p>Unity is not really using JavaScript, but UnityScript. Unityscript and Javascript are essentially different languages; it's mostly a marketing move to call it ""Javascript"" in Unity. Some of the differences can be found <a href=""http://wiki.unity3d.com/index.php?title=Head_First_into_Unity_with_UnityScript"" rel=""nofollow"">here</a> and <a href=""http://wiki.unity3d.com/index.php?title=UnityScript_versus_JavaScript"" rel=""nofollow"">here</a>. If anything I would advice you to switch over to C#.</p>
","149","<javascript><unity3d><unityscript><cryptojs>","1","3","1","2014-04-07 06:04:53","","0","","264697","","2014-04-07 06:04:53","2014-04-06 23:14:39",""
"20836198","Should I store passphrase in jsp","<p>I need to generate a key with a passphrase in jsp using PBKDF2WithHmacSHA1 algorithms, CryptoJs library, then I use this key to encrypt the user login password and pass to server, and in the server, generate the key again and decrypt the user login password.</p>

<p>I know I should not pass the passphrase or key from client to server through http during login, but can I save the passphrase in login jsp page? if not, how can I use the passphrase to generate key in jsp?</p>

<p>even use a javascript variable to store the passphrase, the user can still use javascript debug mode to watch the passphrase variable value, so I think  no method to hidden the passphrase value in jsp, any method?  </p>

<p>Or is the design of encrypt login password in client side using javascript has problem?</p>
","<p>No.Generate a one-way hash on the server for the user's input (using best practice, including a safe hashing algorithm and salting). Compare any future user input against that hash by generating a new hash with the user's input using the same algorithm, then compare the two hashes</p>
","148","<javascript><cryptojs><passphrase>","0","0","1","2013-12-31 04:59:54","","0","","1169587","","2013-12-31 04:59:54","2013-12-30 08:50:42",""
"46291394","How to Validate Json objects in a file from asp.net core application C#","<p><strong>Problem:</strong> A nodejs application creates a json file which is a license,and an asp.net core application will need to validate the info with public key. The node application uses RSA sha256 to sign it with private key, and .net core app will use public key to validate. THANK YOU. The json file includes the following information: </p>

<pre><code>    {
    ""info"":{
    ""validto"":1514678400000,""validfrom"":1498608000000,""nodes"":10,""email"":""person@example.com"",""name"":""TAC Account"",""phone"":""3333333333333"",""address"":""something""
    },

""signature"":
    {
    ""data"":[159,1,86,24,244,199,39,40,251,195,175,80,18,33,232,63,178,213,205,129,150,58,243,154,138,168,61,197,222,50,222,80,33,82,135,243,121,250,176,33,9,25,167,177,235,193,246,236,235,19,187,118,57,64,38,143,42,35,12,207,133,33,166,201,34,76,40,87,242,163,141,14,218,198,247,91,191,132,86,162,194,143,177,147,65,171,160,41,2,244,130,53,82,178,72,39,247,45,242,139,243,59,79,196,12,70,14,202,246,48,231,66,38,94,235,237,204,77,40,252,216,63,41,204,210,228,93,16,201,4,123,104,119,251,56,160,9,105,180,217,129,113,19,166,89,199,203,129,47,218,20,131,94,87,251,193,177,111,151,72,187,79,0,63,0,168,36,147,155,47,5,123,176,203,189,111,199,165,90,12,122,2,148,62,107,115,132,183,76,147,7,238,154,174,198,226,170,204,193,18,197,30,191,189,133,134,33,33,159,14,90,153,219,226,184,149,19,179,210,171,136,39,144,178,229,236,126,11,252,80,65,83,181,117,26,37,231,92,151,110,33,93,239,243,129,58,201,214,231,248,151,23,19,170,0,19],
    ""type"":""Buffer""
    }

    }
</code></pre>

<p>We have tried many things at asp.net core side but no success, the public key given has some unusual characters like \n which not seen typically. Following is one of different things we tried:</p>

<pre><code>using System ;
using System.IO ;
using System.Text ;
using Org.BouncyCastle.Crypto ;
using Org.BouncyCastle.Crypto.Parameters ;
using Org.BouncyCastle.OpenSsl ;
using Org.BouncyCastle.Security ;

namespace ValidateRsa
{
    internal class Program
    {
        private static readonly string info =
                @""{""""validto"""":1514678400000,""""validfrom"""":1498608000000,""""nodes"""":10,""""email"""":""""person@example.com"""",""""name"""":""""TAC Account"""",""""phone"""":""""3333333333333"""",""""address"""":""""something""""}""
            ;
        private static readonly byte[] signature =
        {
            159, 1, 86, 24, 244, 199, 39, 40, 251, 195, 175, 80, 18, 33, 232, 63, 178, 213, 205, 129, 150, 58, 243, 154, 138, 168,
            61, 197, 222, 50, 222, 80, 33, 82, 135, 243, 121, 250, 176, 33, 9, 25, 167, 177, 235, 193, 246, 236, 235, 19, 187, 118,
            57, 64, 38, 143, 42, 35, 12, 207, 133, 33, 166, 201, 34, 76, 40, 87, 242, 163, 141, 14, 218, 198, 247, 91, 191, 132, 86,
            162, 194, 143, 177, 147, 65, 171, 160, 41, 2, 244, 130, 53, 82, 178, 72, 39, 247, 45, 242, 139, 243, 59, 79, 196, 12,
            70, 14, 202, 246, 48, 231, 66, 38, 94, 235, 237, 204, 77, 40, 252, 216, 63, 41, 204, 210, 228, 93, 16, 201, 4, 123, 104,
            119, 251, 56, 160, 9, 105, 180, 217, 129, 113, 19, 166, 89, 199, 203, 129, 47, 218, 20, 131, 94, 87, 251, 193, 177, 111,
            151, 72, 187, 79, 0, 63, 0, 168, 36, 147, 155, 47, 5, 123, 176, 203, 189, 111, 199, 165, 90, 12, 122, 2, 148, 62, 107,
            115, 132, 183, 76, 147, 7, 238, 154, 174, 198, 226, 170, 204, 193, 18, 197, 30, 191, 189, 133, 134, 33, 33, 159, 14, 90,
            153, 219, 226, 184, 149, 19, 179, 210, 171, 136, 39, 144, 178, 229, 236, 126, 11, 252, 80, 65, 83, 181, 117, 26, 37,
            231, 92, 151, 110, 33, 93, 239, 243, 129, 58, 201, 214, 231, 248, 151, 23, 19, 170, 0, 19
        } ;
        private static void Main (string[] args)
        {
            Console.WriteLine (""Setting up validator..."") ;
            TextReader text = File.OpenText (@""X:\Scratch\pubkey.asc"") ;
            var pemr = new PemReader (text) ;
            object pem = pemr.ReadObject () ;
            text.Close () ;
            var keyParams = (RsaKeyParameters) (AsymmetricKeyParameter) pem ;
            ISigner sig = SignerUtilities.GetSigner (""SHA-256withRSA"") ;
            sig.Init (false, keyParams) ;
            byte[] infoBytes = Encoding.ASCII.GetBytes (Program.info) ;
            sig.BlockUpdate (infoBytes, 0, infoBytes.Length) ;
            if (sig.VerifySignature (Program.signature))
                Console.WriteLine (""Verified!"") ;
            else
                Console.WriteLine (""Failed!"") ;
            Console.ReadLine () ;
        }
    }
}
</code></pre>

<p>Public key is in the following format: </p>

<pre><code> -----BEGIN RSA PUBLIC KEY
-----\nMIIBCgKCAQEAqao1ZkAYKDybHSeoy79ySQDcXODByDRaZKT2nYwT8GrYohBle8phB5LgSoQu\nVD7ErRFGHxutcqPrfL3AuTHg874Kmw6/G+25/FdC9uNJzLtCP+Z5mOrF5HlU8dGOOpTeq4y5\n0EPcj//YuO4kScj0wOOp1HMRwxsdVo\nAZUQwMz5w1QIoGL5CoW7RKiL/oQw0Mh0Ju+9ofVbovSzBTo0r7onqw6M0hOJScV86iQ21Ukl\nup/6CmXCMwcYK1Fr5J6YNbeZoQhkII7VazPMgZetJBCfm+iyBPSPARlf13RLM0cHzwIDAQAB\n-----END RSA PUBLIC KEY-----\n
</code></pre>

<p>The code where nodejs app is signing the data:</p>

<pre><code> const licenseSchema = new Schema({
  info: {
    name: String,
    address: String,
    phone: String,
    email: String,
    nodes: Number,
    validfrom: Schema.Types.Mixed,  // validfrom and validto must be either
    validto: Schema.Types.Mixed,    // valid Date strings or ms since epoch
  },

  signature: {
    type: { type: String, required: true },
    data: { type: Schema.Types.Mixed, required: true },
  },
});

// updates license.signature
licenseSchema.statics.createAndSignLicense = function createAndSignLicense(object, privateKey, cb) {
  let arrayInfo = [];
  arrayInfo = [
    object.name,
    object.address,
    object.phone.toString(),
    object.email,
    object.nodes.toString(),
    object.validfrom,
    object.validto,
  ];
  const sign = crypto.createSign('RSA-SHA256');
  sign.update(JSON.stringify(arrayInfo));
  const sig = sign.sign(privateKey);

  const LicenseModel = this;

  const licenseDoc = new LicenseModel({
    info: object,
    signature: {
      type: 'Buffer',
      data: Array.prototype.slice.call(sig, 0),
    },
  });

  licenseDoc.save((err) =&gt; {
    if (err) { return cb(err); }

    return cb(null, licenseDoc);
  });
};
</code></pre>

<p>There is another nodejs app which is validating the data successfully, example is below, just in .net things are not coming together: </p>

<pre><code>    const Schema = mongoose.Schema;

export const Errors = {LicenseValidationError: 'LicenseValidationError'};

const LicenseDescription = {
    key: { type: String, unique: true },
    info: {
        name: String,
        address: String,
        phone: String,
        email: String,
        nodes: Number,
        validfrom: Schema.Types.Mixed,  // validfrom and validto must be either
        validto: Schema.Types.Mixed,    // valid Date strings or ms since epoch
    },
    signature: {
        type: { type: String, required: true },
        data: Schema.Types.Mixed
    }
};

// Application state variable representing license validity.
let isLicenseValid = false;

/*
 * uses the utils function with a validator to set the system-wide document
 * license is a file (buffer) or JSON license.
 * This method attempts to validate the input.
 *
 * See: License.statics.ValidateLicense()
 *
 * cb: function (err, license) { ... }
 */
const License = utils.createSchema(LicenseDescription, {
    validator: function (license, cb) {
        validateLicense(license, (err, valid) =&gt; {
            if (err) {
                return cb(err);
            }
            isLicenseValid = isLicenseWithinDateRange(license);
            return cb(null, true);
        });
    }
});


// license public key, hardcoded.
// Uses RSA-SHA256
    const pair = () =&gt; ({
    public: `-----BEGIN RSA PUBLIC KEY-----\nMIIBCgKCAQEAqao1ZkAYKDybHSeoy79ySQDcXODByDRaZKT2nYwT8GrYohBle8phB5LgSoQu\nVD7ErRFGHxutcqPrfL3AuTHg874Kmw6/G+25/FdC9uNJzLtCP+Z5mOrF5HlU8dGOOpTeq4y5\n0EPcj//YuO4kScj0wOOp1HMRwxsdVo+G00Q\nAZUQwMz5w1QIoGL5CoW7RKiL/oQw0Mh0Ju+9oV86iQ21Ukl\nup/6CmXCMwcYK17VazPMgZetJBCfm+iyBPSPARlf13RLM0cHzwIDAQAB\n-----END RSA PUBLIC KEY-----\n`
});

/*
 * Verifies the supplied license (must be a valid JSON object) against the
 * public key (hardcoded).
 *
 * Returns true if valid, false otherwise.
 */
const verifySignature = license =&gt; {
    winston.info('Verifying license signature:');

    // crypto.verify relies on specific key ordering (undefined behavior, unfortunately).
    // To try to force key order, we construct this object (with explicit toString calls
    // where applicable).
    const infoString = [
        license.info.name,
        license.info.address,
        license.info.phone,
        license.info.email,
        license.info.nodes.toString(),
        new Date(license.info.validfrom).toString(),
        new Date(license.info.validto).toString(),
    ];

    const infoMS = [
        license.info.name,
        license.info.address,
        license.info.phone,
        license.info.email,
        license.info.nodes.toString(),
        license.info.validfrom,
        license.info.validto,
    ];

    const verifyString = crypto.createVerify('RSA-SHA256'), verifyMS = crypto.createVerify('RSA-SHA256'), 
    licenseInfoString = JSON.stringify(infoString), licenseInfoMS = JSON.stringify(infoMS);

    // Currently the signature must be a buffer and the type field is ignored.
    let buf;
    try {
        buf = new Buffer(license.signature.data);
    } catch (parseError) {
        return false;
    }

    verifyString.update(licenseInfoString);
    verifyMS.update(licenseInfoMS);

    const isLicenseValid = verifyString.verify(pair().public, buf) || verifyMS.verify(pair().public, buf);
    winston.info(`The license signature is ${(isLicenseValid) ? 'valid.' : 'invalid.'}`);
    return isLicenseValid;
};
</code></pre>
","<p>There's something wrong with your key file I guess?</p>

<p>Your code works fine.</p>

<p>Here's an example of generating the signature in node:</p>

<pre><code>var crypto = require('crypto');
var fs = require('fs');

var privateKey = fs.readFileSync('./junk').toString('utf8');
var publicKey = fs.readFileSync('./junk.pem').toString('utf8');

var sign = crypto.createSign('RSA-SHA256');
sign.update(""Test123"");
var sig = sign.sign(privateKey);
var bytes = Array.prototype.slice.call(sig, 0);
console.log(JSON.stringify(bytes));

var verify = crypto.createVerify('RSA-SHA256');
verify.update(""Test123"");
var success = verify.verify(publicKey, new Buffer(sig));

console.log(""Did sign? "" + success);
</code></pre>

<p>and here's an example of verifying it using bouncy castle in C# .net core (I've simplified, but its basically exactly what you're doing):</p>

<pre><code>using System;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.OpenSsl;
using Org.BouncyCastle.Security;

namespace RsaTest
{
  class Program
  {
    static void Main(string[] args)
    {
      var signature = new byte[]
      {
        193, 185, 118, 187, 54, 28, 71, 173, 185, 255, 213, 61, 254, 51, 86, 168, 224, 11, 113, 23, 81, 123, 89,
        31, 89, 183, 142, 194, 7, 250, 194, 165, 230, 254, 74, 61, 15, 12, 137, 246, 151, 61, 83, 107, 112, 178,
        98, 183, 234, 247, 56, 11, 246, 179, 183, 74, 27, 190, 17, 99, 161, 31, 209, 178, 81, 41, 56, 214, 184, 165,
        232, 20, 125, 155, 25, 102, 104, 193, 1, 101, 143, 209, 192, 145, 47, 215, 190, 95, 196, 164, 69, 203, 206, 69,
        142, 18, 196, 155, 221, 8, 31, 179, 5, 165, 143, 29, 34, 148, 218, 177, 94, 31, 174, 218, 153, 52, 85, 156, 67,
        2, 157, 29, 111, 95, 231, 249, 212, 39, 123, 229, 75, 2, 18, 238, 44, 94, 181, 181, 98, 156, 150, 44, 219, 208,
        161, 18, 250, 117, 91, 146, 133, 233, 210, 161, 133, 233, 228, 111, 124, 107, 96, 134, 123, 148, 88, 238, 193,
        50, 216, 187, 42, 131, 51, 28, 52, 55, 150, 31, 49, 95, 63, 245, 58, 212, 205, 26, 223, 32, 124, 233, 20, 148,
        107, 33, 162, 47, 107, 221, 238, 221, 200, 89, 199, 52, 164, 114, 177, 254, 146, 60, 118, 1, 78, 73, 231, 138,
        136, 201, 242, 26, 100, 57, 237, 135, 181, 44, 193, 143, 191, 155, 93, 66, 142, 69, 203, 57, 22, 147, 120, 161,
        117, 167, 54, 16, 200, 6, 27, 160, 187, 15, 197, 138, 201, 114, 52, 202
      };

      var inlinePem = @""
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1I++ulXUpZUopjSe7M74
PJpj0D9JbbpV3MChYvqnu1m9+Rnd5fr1FUg7xQu+EI0XN+YIi9CbZl4tGtxjela0
0MidM2dd1BI/5W2Zl4DHnPPmvfZoybBquK6dwkkTe5AhCCZegYD4TsNhKWGqea8D
fSiCAvTeG0uiXbQGPD6lWei3IoVcOQ0cuz3LheCl440Bbmg2BVMUrZO81r6yH1Nz
0ypYnBfx26Mo7379ngHc3yjxi8vjDF/is4wqOgWj34R3gbbf9EZ5OWS+DpItPpFZ
Ykh82DrNHNCPSyvD0XvmcPhJ6O7yrloAPSiTUP9+u7w1zBpg50Srcp+afUcGODYm
KQIDAQAB
-----END PUBLIC KEY-----
      "";

      var pemr = new PemReader(new StringReader(inlinePem.Trim()));
      var pem = pemr.ReadObject();

      var keyParams = (RsaKeyParameters) (AsymmetricKeyParameter) pem;
      var sig = SignerUtilities.GetSigner(""SHA-256withRSA"");
      sig.Init(false, keyParams);
      var infoBytes = Encoding.ASCII.GetBytes(""Test123"");
      sig.BlockUpdate(infoBytes, 0, infoBytes.Length);

      Console.WriteLine($""{sig.VerifySignature(signature)}"");
    }
  }
}
</code></pre>

<p>With these two key files I just randomly generated:</p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA1I++ulXUpZUopjSe7M74PJpj0D9JbbpV3MChYvqnu1m9+Rnd
5fr1FUg7xQu+EI0XN+YIi9CbZl4tGtxjela00MidM2dd1BI/5W2Zl4DHnPPmvfZo
ybBquK6dwkkTe5AhCCZegYD4TsNhKWGqea8DfSiCAvTeG0uiXbQGPD6lWei3IoVc
OQ0cuz3LheCl440Bbmg2BVMUrZO81r6yH1Nz0ypYnBfx26Mo7379ngHc3yjxi8vj
DF/is4wqOgWj34R3gbbf9EZ5OWS+DpItPpFZYkh82DrNHNCPSyvD0XvmcPhJ6O7y
rloAPSiTUP9+u7w1zBpg50Srcp+afUcGODYmKQIDAQABAoIBAChRh7zycN5jl41H
J+oFLCLaqhojFvuAP68avsH2h4BK+nTYijWIT5qU0/mBS7D6AjBxKqfSjtdw/587
tIbNEYkUtHS+o5aJS6NqEZsiKzrDLL5VkfTHyMZ1IKlskQx7/zf7hyuLWg4ekzx1
MQ/ZuZCw8VA8QDDvPMIHVrNwso6F8/vc/K3tqygeFBh+rfAbkzp2zvK4Tr+reJTT
hmsg68wBzTNAzmeHK8FsMB2NZvwW/zq5ZgEIkZVkJZl7XbYGj+ggVSn2h0J8KleK
H+60nx39wk/KnscsHo9lPpv/7RoYb7OGEVR8W0fY5+QvALTZ8U9HZftm9TfhUd/0
Is5CIT0CgYEA/kaqLKK2hYlEdP2f9N6w/qiF2Gmxu6N1Tk+gvbz1ChukPHW42xUz
iG45So6iGDWNzjVf9IxAP2n0Zltar4tMlyC767jk5Xs7kONZMwqge5a52NYLRRvt
xoklLgXCjurriq+hw6tNAuvVjs/ScOHOQyC4emVDqJ5Z9766zqrpkCsCgYEA1gCt
pGAwt5KoDOXlk3311BDS6XLev536GW25CmKrs9sJH2cOWSRFA0fWcPr0gVotM9F5
+2ymmJmlYLLDRYWTYCX+vL8aysTTDqezpOhJ9VIzgeTh3FwD17LFE5j4W0AqE5jR
2eMItfobMYqHF4iHp+OmfhocLpLQcTC4BlMvZPsCgYBLXOZTFGbEbUq84e7mxJnw
4EHLQohK9Mdvzmn10mtN86NZyAph5IbBiOmyD1Q7mKPO2kL2WBsysFSfgbP/E2o/
4JPR6Zrt6PhemQN2/U9TUfkDK21rrjtq/HroiQyBD1+AW022kK7ijsNc8HuOuV5I
xwnmPN0wvL4tj3oOhtlywQKBgAsXq+h6R+wsAOPyQq0beVONr7EEEEG0aZNJ2a6N
IMNI1jc3e0nplF4wKhBfIa9WwkMOV5lNr3D3fdf+TBrdap8wOP0FltjtzNbUoH4q
wDKkGSFhgMeQSW6zyH1Uj4MDV2r+n9oAZ6IvHZu6x3fTztxH84hTyCQt3foQAWnq
g+ljAoGBAMza/hD+Hsz7uNtVvvqki6a6FMk7cSZTEtZvBvqrywIEEZEnbsuHk5tD
towaZbQQirZp45xsEJZDO/8O5Q0+WEs/0ZG1CPBgIwNEBUt/deid6s1HFFoESp0/
DfekILO1scieEpccfz8aIlgq/CoRFfXQ5m0VetfP6H6Wau1Hfx5A
-----END RSA PRIVATE KEY-----
</code></pre>

<p>and:</p>

<pre><code>-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA1I++ulXUpZUopjSe7M74
PJpj0D9JbbpV3MChYvqnu1m9+Rnd5fr1FUg7xQu+EI0XN+YIi9CbZl4tGtxjela0
0MidM2dd1BI/5W2Zl4DHnPPmvfZoybBquK6dwkkTe5AhCCZegYD4TsNhKWGqea8D
fSiCAvTeG0uiXbQGPD6lWei3IoVcOQ0cuz3LheCl440Bbmg2BVMUrZO81r6yH1Nz
0ypYnBfx26Mo7379ngHc3yjxi8vjDF/is4wqOgWj34R3gbbf9EZ5OWS+DpItPpFZ
Ykh82DrNHNCPSyvD0XvmcPhJ6O7yrloAPSiTUP9+u7w1zBpg50Srcp+afUcGODYm
KQIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>...and it works fine:</p>

<pre><code>$ node test
[193,185,118,187,54,28,71,173,185,255,213,61,254,51,86,168,224,11,113,23,81,123,89,31,89,183,142,194,7,250,194,165,230,254,74,61,15,12,137,246,151,61,83,107,112,178,98,183,234,247,56,11,246,179,183,74,27,190,17,99,161,31,209,178,81,41,56,214,184,165,232,20,125,155,25,102,104,193,1,101,143,209,192,145,47,215,190,95,196,164,69,203,206,69,142,18,196,155,221,8,31,179,5,165,143,29,34,148,218,177,94,31,174,218,153,52,85,156,67,2,157,29,111,95,231,249,212,39,123,229,75,2,18,238,44,94,181,181,98,156,150,44,219,208,161,18,250,117,91,146,133,233,210,161,133,233,228,111,124,107,96,134,123,148,88,238,193,50,216,187,42,131,51,28,52,55,150,31,49,95,63,245,58,212,205,26,223,32,124,233,20,148,107,33,162,47,107,221,238,221,200,89,199,52,164,114,177,254,146,60,118,1,78,73,231,138,136,201,242,26,100,57,237,135,181,44,193,143,191,155,93,66,142,69,203,57,22,147,120,161,117,167,54,16,200,6,27,160,187,15,197,138,201,114,52,202]
Did sign? true
$ dotnet run
True
</code></pre>

<p>So my guess? </p>

<p>Either something is wrong with your public key, or the json input you're passing in to the function on both sides isn't quite the same for some reason.</p>

<p>There's nothing wrong with your signing code as far as I can tell.</p>
","148","<c#><node.js><asp.net-core><cryptojs><node-crypto>","-1","0","1","2017-09-19 09:00:55","46292294","0","","","","","2017-09-19 03:38:57",""
"45756561","Match PHPs openssl_encrypt with blank IV in JavaScript","<p>How can I match the output of <code>openssl_encrypt</code> in JavaScript, when no IV is declared in PHP and a non-compliant key length is used?</p>

<p><strong>PHP</strong></p>

<pre><code>php -r '$value = openssl_encrypt(""test"", ""AES-128-CBC"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaa""); echo $value;'

/u+5lB/VwbMX9U1YY4cnCQ==
</code></pre>

<p><strong>JavaScript</strong></p>

<pre><code>iv  = CryptoJS.enc.Utf8.parse("""");
var encrypted = CryptoJS.AES.encrypt(""test"", ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"", {iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7});
console.log(encrypted.toString());

U2FsdGVkX19Cn1f6x8C/rJdfwzsZk5m5WWCUrR4z3U4=

console.log(CryptoJS.enc.Base64.stringify(encrypted.ciphertext));

l1/DOxmTmblZYJStHjPdTg==
</code></pre>

<p>I can only modify the Javascript code and I need a way to encrypt a string so that it can be decrypted by PHP's <code>openssl_decrypt</code>. It works fine obviously if the string it's encrypted from PHP.</p>

<p>I understand that by not declaring a IV renders the code less secure, but in my particular case it's not a big issue.</p>

<p>I've read in other topics that PHP defaults the padding to Pkcs7, which is why I added it to the JS method.</p>

<p>My current theory is that either the default IV of PHP is the issue or the output of the JS function needs to be further processed. As you can see I tried the <code>Base64.stringify</code> method, but the results are still different.</p>

<p>The sample key I'm using here is of the same length of the actual key.</p>

<p>I'm using <a href=""https://github.com/sytelus/CryptoJS/blob/master/rollups/aes.js"" rel=""nofollow noreferrer"">https://github.com/sytelus/CryptoJS/blob/master/rollups/aes.js</a> (whatever I use in JS, it needs to be easily distributed like a standalone file, with a relatively small footprint)</p>
","<p>There are some issues with your code:</p>

<ul>
<li>If you want to use an existing key, then you need to provide a <code>WordArray</code> object to <code>CryptoJS.&lt;cipher&gt;.encrypt</code>. That means it has to be parsed in some way. If you simply provide a string as a ""key"", then CryptoJS will assume that it is a password, generate a random salt and use EVP_BytesToKey to derive the key and IV from password and salt.</li>
<li>Your ""key"" is 29 characters long. AES only supports three key sizes: 16, 24 and 32 bytes. Since you've used AES-128 in PHP, you need to provide a 16 byte key in CryptoJS so that AES-128 is automatically selected. Remember: a key is supposed to be randomly chosen and be indistinguishable from random noise so that it has some kind of security. If you must print the key in some way, use Hex or Base64 encoding.</li>
</ul>

<p>Full example:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var iv  = CryptoJS.enc.Utf8.parse("""");
var key = CryptoJS.enc.Utf8.parse(""aaaaaaaaaaaaaaaa"");
var encrypted = CryptoJS.AES.encrypt(""test"", key, {
    iv: iv, 
    mode: CryptoJS.mode.CBC, 
    padding: CryptoJS.pad.Pkcs7
});

console.log(CryptoJS.enc.Base64.stringify(encrypted.ciphertext));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","146","<javascript><php><cryptojs><php-openssl>","0","1","1","2017-08-18 19:58:18","45764221","0","","608639","","2017-08-18 12:50:56","2017-08-18 12:23:21",""
"51583713","node sha256 convert to java","<p>I am trying to convert a library to java. I am stuck at one place.</p>

<p>This method in node js</p>

<pre><code>import { SHA256, enc } from 'crypto-js'
export const sha256 = (hex) =&gt; {
  let hexEncoded = enc.Hex.parse(hex)
  return SHA256(hexEncoded).toString()
}
</code></pre>

<p>Can you please help it converting in java?
This is not directly sha256 encryption. 
for example : </p>

<pre><code>Direct conversion : 
String : 68656c6c6f
Sha256 string : 4ef79bf561cdeacd465e135a3b9c8b51a42ded0605f15ab8e501162d2693bd00
</code></pre>

<p>Source : <a href=""http://md5decrypt.net/en/Sha256/#answer"" rel=""nofollow noreferrer"">http://md5decrypt.net/en/Sha256/#answer</a>    </p>

<p>Above method conversion</p>

<pre><code>String : 68656c6c6f
Sha256 String : 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
</code></pre>

<p>I am not sure what part i am missing. The first step is to convert it decimal array.But couldn't figure out the logic in second step.This is taken from crypto-js library.(<a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a>)</p>
","<pre><code>String : 68656c6c6f
</code></pre>

<p>is basically the hex of String <code>hello</code> and </p>

<pre><code>Sha256 String : 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
</code></pre>

<p>is the sha256 hash of <code>hello</code></p>

<p>So first you need to parse String from Hex i.e -></p>

<pre><code>68656c6c6f -&gt; hello
</code></pre>

<p>and then calculate the sha256 hash :-></p>

<pre><code>hello -&gt; 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
</code></pre>

<p>The Java Implementation for the same :-></p>

<pre><code>import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

import java.nio.charset.StandardCharsets;

public class libraryTransfer {
    public static void main(String[] args) throws DecoderException {
        String input = ""hello"";
        System.out.println(""Hex from String :-&gt; "" + toHex(input));
        System.out.println(""String from hex : -&gt; "" + getStringFromHex(toHex(input.trim())).trim());
        String sha256hex = org.apache.commons.codec.digest.DigestUtils.sha256Hex(getStringFromHex(toHex(input)));
        System.out.println(sha256hex);
    }

    public static String toHex(String arg) {
        return Hex.encodeHexString(arg.getBytes(/* charset */));
    }

    public static String getStringFromHex(String inputHex) throws DecoderException {
        byte[] bytes = Hex.decodeHex(inputHex.toCharArray());
        return new String(bytes, StandardCharsets.UTF_8);
    }

}
</code></pre>
","145","<java><node.js><node-modules><cryptojs>","2","0","1","2018-07-30 04:40:12","","0","1","","","","2018-07-29 19:15:37",""
"53238848","how use function pbkdf2 of cryptoJS without nodeJS","<p>according to <a href=""https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#from-mnemonic-to-seed"" rel=""nofollow noreferrer"">this link</a>, I want to convert mnemonic words to its corresponding seed. I want to do this by <strong>javascript</strong> and use it in <strong>webclients</strong> without <strong>nodeJS</strong>.</p>

<p>the library that I have in mind is <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">cryptoJS</a>.</p>

<p>I am planning to use function <strong>pbkdf2</strong>, but I don't know which <strong>js</strong> file I need to add to html page.</p>
","<p>I have one old answer here how to use cryptoJS:
<a href=""https://stackoverflow.com/a/43438494/2951051"">https://stackoverflow.com/a/43438494/2951051</a></p>

<p>About your last question "" which js file I need to add to html page."":</p>

<p>I use this scripts from gitHub: <a href=""https://github.com/sytelus/CryptoJS"" rel=""nofollow noreferrer"">https://github.com/sytelus/CryptoJS</a></p>

<p>After that I use this files from <code>rollups/</code> folder:</p>

<p><code>aes.js</code> , <code>pbkdf2.js</code>, <code>hmac-sha512.js</code></p>

<p>For more random entropy i have changed <code>random.js</code> (inside aes.js)  with another random function you can download from : <a href=""https://github.com/wwwtyro/cryptico/blob/master/random.js"" rel=""nofollow noreferrer"">https://github.com/wwwtyro/cryptico/blob/master/random.js</a> </p>
","144","<javascript><cryptojs>","0","1","1","2018-11-10 13:25:45","53239397","0","","","","","2018-11-10 12:15:06",""
"36215070","How to get the same result with JAVA and CryptoJS using SHA256?","<p>I am trying to make same result with Java in the javascript using CryptoJs. But I am failed many times. I found the CryptoJs to generate Hash value in the javascript recently .  But It was defficult to make same result between javascript and java. I want to get hash value (checksum) from zip or xls ,doc . And the Java application have to check if it has same hash value or not.  Does anyone know  whats going wrong on my javascript? </p>

<p>====== java source ==========</p>

<pre><code>public static String getFileHashSHA256(String fileName) throws Exception {

    int buff = 16384;

    RandomAccessFile file = new RandomAccessFile(fileName, ""r"");
    MessageDigest hashSum = MessageDigest.getInstance(""SHA-256"");

    byte[] buffer = new byte[buff];
    byte[] partialHash = null;

    long read = 0;

    long offset = file.length();
    int unitsize;

    while (read &lt; offset) {

        unitsize = (int) (((offset - read) &gt;= buff) ? buff : (offset - read));
        file.read(buffer, 0, unitsize);

        hashSum.update(buffer, 0, unitsize);

        read += unitsize;
    }
    file.close();

    partialHash = new byte[hashSum.getDigestLength()];
    partialHash = hashSum.digest();

    StringBuffer sb = new StringBuffer();
    for (int i = 0; i &lt; partialHash.length; i++) {
        sb.append(Integer.toString((partialHash[i] &amp; 0xff) + 0x100, 16).substring(1));
    }

    return sb.toString();

}
</code></pre>

<p>result hash value :  2f3512d3caad7b43f0036bafa7c80e78e9fca6a253857d24b1c38dc5cdab1399</p>

<p>========= javascript source ==============</p>

<pre><code>var fileToLoad = document.getElementById(""fileToLoad"").files[0];

var fileReader = new FileReader();
fileReader.readAsBinaryString(fileToLoad);
fileReader.onload = function(fileLoadedEvent) 
{

    var hash = CryptoJS.SHA256(fileLoadedEvent.target.result).toString();
    console.log(hash);

};
</code></pre>

<p>result hash value : cc7cf3ed59fb26a43d2596e54c48bced09ad22bff68e2cb5a1ea7cc80b48387d</p>

<p>The both hash value is diffrent even though it bring from a same zip file.</p>
","","143","<javascript><java><hash><sha256><cryptojs>","0","","0","2016-03-25 08:06:43","","5","3","6112693","","2016-03-25 08:06:43","2016-03-25 06:22:28","2016-03-26 13:03:48"
"22857155","simple mail/password registration with crypto.js","<p>I'm trying to save passwords in my database, and I want to hash them with either MD5 or SHA2. </p>

<p>I googled it and found a lot of very different topics with long lines of code all the time, I don't know why.</p>

<p>Isn't it possible to store a password with one line of code with crypto.js ?</p>

<p>e.g. </p>

<pre><code>var crypto = require('crypto-js')  
collection.insert(user: ""my user"", password: crypto.sha2(""my-password"")
</code></pre>

<p>So later, I can do the simplest auth ever and process the result of this db request: </p>

<pre><code>db.findOne({use:""my user"", password: crypto.sha2(""my-password"") etc...
</code></pre>
","<p>You shouldn't use general-purpose hash algorithms such as SHA-2 for storing passwords. See: <a href=""http://codahale.com/how-to-safely-store-a-password/"" rel=""nofollow"">http://codahale.com/how-to-safely-store-a-password/</a></p>
","143","<node.js><mongodb><authentication><cryptojs>","0","2","1","2017-12-13 17:34:12","22857536","0","","641914","","2017-12-13 17:34:12","2014-04-04 08:13:19",""
"36980835","Matching Signed Headers Encrypted in Ruby on Rails and JavaScript","<p>I am using ApiAuth gem (as found <a href=""https://github.com/mgomes/api_auth"" rel=""nofollow"">here</a>) to sign my request. I am also writing my own JavaScript code using CryptoJS (as found <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow"">here</a>) to provide authentication by checking the encrypted header generated by ApiAuth against the one generated by my code.</p>

<p>Given below is a code snippet from ApiAuth Gem:</p>

<pre><code>def hmac_signature(headers, secret_key, options)
  if options[:with_http_method]
    canonical_string = headers.canonical_string_with_http_method(options[:override_http_method])
  else
    canonical_string = headers.canonical_string
  end
  digest = OpenSSL::Digest.new('sha1')
  b64_encode(OpenSSL::HMAC.digest(digest, secret_key, canonical_string))
end
</code></pre>

<p>Here is the code I have written as an equivalent in JavaScript:</p>

<pre><code>function hmacSignature(request, appSecret) {
 return CryptoJS.HmacSHA1(canonicalString(request), appSecret).toString(CryptoJS.enc.Base64);}
</code></pre>

<p>These two don't generate the same encrypted header. I tried using jsSHA to do the same thing and while the encrypted header generated by jsSHA and CryptoJS is the same, they don't match the one generated by ApiAuth.</p>

<p>Kindly help me figure out how to make this work.</p>

<p><strong>EDIT:</strong></p>

<p>Taking Canonical String as ""message"" and appSecret as ""secret"" I get the same values from ApiAuth and CryptoJS which is:</p>

<p>DK9kn+7klT2Hv5A6wRdsReAo3xY=</p>

<p>I've figured out that the problem in my original code is coming because the timestamp set in my JS code and the one set in the ApiAuth don't match.</p>
","<p>I fixed my problem and am writing this answer in  hopes that it helps someone else looking for a solution to this problem.</p>

<ol>
<li>Let me start off by saying that the two encryptions should be the same whether they are encrypted in Ruby or JS or any other language.</li>
<li>It is important to check that every portion of the input sent to both places is exactly the same and completely identical.</li>
</ol>

<p>When I checked my inputs to the JS file and the gem, I realised that for some reason the time-stamp (which I was setting in the JS file) wasn't getting sent correctly to the gem.</p>

<p>I debugged my code step by step and figured out where the mistake was. I am outlining some of the possible issues below:</p>

<ol>
<li><p>I was setting the timestamp in my JS as follow</p>

<p>request.headers[""DATE""]</p></li>
</ol>

<p>I realised that this wasn't getting set correctly so I had to change ""DATE"" to ""DATE1"" and accordingly change the rest of my code. This worked.</p>

<ol start=""2"">
<li>Second, the timestamp I was sending wasn't compatible with the HTTP GST type timestamp that was expected by the gem. This is another thing that you must keep in mind when sending the timestamp.</li>
</ol>
","142","<javascript><ruby-on-rails><encryption><cryptojs><api-auth>","1","0","1","2016-05-10 03:34:36","","2","","5345672","","2016-05-03 03:50:27","2016-05-02 10:59:58",""
"34321972","how replicate in mysql Crypto JS formula?","<p>I have the duty of decrypt some data in our database that was encrypted using Crypto js a year ago, I would like to know how I can replicate the formula in pure mysql scripting.</p>

<p>Our actual js formula is:</p>

<pre><code>// Use Cipher Mode
var crypto = CryptoJS.lib.BlockCipherMode.extend();
crypto.Encryptor = crypto.extend({processBlock:function(a,b){this._cipher.encryptBlock(a,b)}});
crypto.Decryptor = crypto.extend({processBlock:function(a,b){this._cipher.decryptBlock(a,b)}});

// Passphrase + iv
var passphrase = CryptoJS.enc.Hex.parse(""46536b6e32674441484c7a5374554975"");
var iv  = CryptoJS.enc.Hex.parse(""2a4b04f4fa87f913b98c30bce9d7fe69"");
var value = 'st5AC+HL09fKYRJ7TxdMhQ==';

var decryptedValue = CryptoJS.AES.decrypt(value, passphrase, { iv: iv, mode: crypto, padding: CryptoJS.pad.Pkcs7 }).toString(CryptoJS.enc.Utf8);
</code></pre>

<h1>UPDATE</h1>

<p>I really want to understand the formula more than translate it, because what I understand is that I have to do next in mysql</p>

<pre><code>SET @@session.block_encryption_mode = 'aes-128-ecb';
select AES_DECRYPT('st5AC+HL09fKYRJ7TxdMhQ==',hex('46536b6e32674441484c7a5374554975'),hex('2a4b04f4fa87f913b98c30bce9d7fe69'))
</code></pre>

<p>The expected word is ""Christos"", but I just get null result.</p>
","","141","<javascript><mysql><cryptojs>","0","","0","2015-12-16 23:23:38","","4","","1649627","","2015-12-16 23:23:38","2015-12-16 20:57:40",""
"43605113","cryptoJS aes encode data NOT match with java code","<pre><code>var get = function(a) {
    var b = CryptoJS.MD5('contentWindowHig');
    var c = CryptoJS.enc.Utf8.parse(b);
    var d = CryptoJS.enc.Utf8.parse('contentDocuments');
    var e = CryptoJS.AES.encrypt(a, c, {
        iv: d,
        mode: CryptoJS.mode.CBC
        pad: CryptoJS.pad.ZeroPadding
    });
    return e.toString()
}
}
</code></pre>

<h1>java output is not the same</h1>

<p>input plain text: 8d3fj5T7lPMjMfMTyzdbl6Aq95zSUrmuChBFf/ex3lF23jHweq9ABJmEbd7+4z5DmjmhvTVyXWoeoFWCv6xCPFw7CAx7n9RZ9x9fOVrY3Cy+Nm1TAThsjgOjjK+M1S3XIim39NiRp55ai/dm2+E+NzRGPN0wW1bc9Q</p>

<p>js output data:</p>

<p>a: 8d3fj5T7lPMjMfMTyzdbl6Aq95zSUrmuChBFf/ex3lF23jHweq9ABJmEbd7+4z5DmjmhvTVyXWoeoFWCv6xCPFw7CAx7n9RZ9x9fOVrY3Cy+Nm1TAThsjgOjjK+M1S3XIim39NiRp55ai/dm2+E+NzRGPN0wW1bc9Q</p>

<p>b: a165f267f74aba5ded7563ebae2c5ac0</p>

<p>c: 6131363566323637663734616261356465643735363365626165326335616330</p>

<p>d: 636f6e74656e74446f63756d656e7473</p>

<p>e(output): YzYv1oDPuHMyvtt8dgHUOdKaTev3rDtDXu9O%2BBlnCt4X118BroqK7nDjc%2Bo6cb6aoik6KAvIhZwENjkmrMvF26xhhWATh0TrlK0ZWPotNWI9mXWW1FgZtRrFkQGn6%2F4BWY8D%2BAfLxePup4rAw%2BekHjpkFsSZcY6rlL37uUKU%2F6OTdN4rrjG3FOEmN8yDZ9sMNAXu%2FdmAqgFRJ77gvWjgKZEXvhqYqaH1Ukb9eZYMRAE%3D</p>

<h1>base64 utf-8 aes iv key confused me...</h1>

<p>java output data:</p>

<p>b: a165f267f74aba5ded7563ebae2c5ac0</p>

<p>c: 6131363566323637663734616261356465643735363365626165326335616330</p>

<p>d: 636F6E74656E74446F63756D656E7473</p>

<p>enc_data: fPkNBugoCDHtBLO4tv9VcfGNCWxbqdWryrOWPXrsqN2I0IzNfTN+Smh5PQX5fKsGuHtGWFv7Lryh
jEgOSUJNskH/JD1agfWfzDClSWA7eF4bpKmTg3ch8mrHHI7nwDm4t6jQEeCfDGcQ3Sa8s0UPipOR
wcOTdGVl7RmgJ5gIERQ45m34fm8tveMYrXyTgvDKbvqO7toqshcg6IOxNgB5OCr/DH4xQibnYPnk
0Z4EBy8=</p>

<p>encoded_str: fPkNBugoCDHtBLO4tv9VcfGNCWxbqdWryrOWPXrsqN2I0IzNfTN%2BSmh5PQX5fKsGuHtGWFv7Lryh%0D%0AjEgOSUJNskH%2FJD1agfWfzDClSWA7eF4bpKmTg3ch8mrHHI7nwDm4t6jQEeCfDGcQ3Sa8s0UPipOR%0D%0AwcOTdGVl7RmgJ5gIERQ45m34fm8tveMYrXyTgvDKbvqO7toqshcg6IOxNgB5OCr%2FDH4xQibnYPnk%0D%0A0Z4EBy8%3D</p>

<pre><code>import com.pplive.common.util.LogUtil;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

import sun.misc.BASE64Encoder;
    public static void main(String[] args) {
            // key: 8d3fj5T7lPMjMfMTyzdbl6Aq95zSUrmuChBFf/ex3lF23jHweq9ABJmEbd7+4z5DmjmhvTVyXWoeoFWCv6xCPFw7CAx7n9RZ9x9fOVrY3Cy+Nm1TAThsjgOjjK+M1S3XIim39NiRp55ai/dm2+E+NzRGPN0wW1bc9Q
            // b: a165f267f74aba5ded7563ebae2c5ac0
            // c: 6131363566323637663734616261356465643735363365626165326335616330
            // d: 636f6e74656e74446f63756d656e7473
            //ss: YzYv1oDPuHMyvtt8dgHUOdKaTev3rDtDXu9O%2BBlnCt4X118BroqK7nDjc%2Bo6cb6aoik6KAvIhZwENjkmrMvF26xhhWATh0TrlK0ZWPotNWI9mXWW1FgZtRrFkQGn6%2F4BWY8D%2BAfLxePup4rAw%2BekHjpkFsSZcY6rlL37uUKU%2F6OTdN4rrjG3FOEmN8yDZ9sMNAXu%2FdmAqgFRJ77gvWjgKZEXvhqYqaH1Ukb9eZYMRAE%3D

            //int end = html.indexOf(""\"")"", start);
            //String plaintext = html.substring(start + ""encodeURIComponent(get(\"""".length(), end);
            String plaintext = ""8d3fj5T7lPMjMfMTyzdbl6Aq95zSUrmuChBFf/ex3lF23jHweq9ABJmEbd7+4z5DmjmhvTVyXWoeoFWCv6xCPFw7CAx7n9RZ9x9fOVrY3Cy+Nm1TAThsjgOjjK+M1S3XIim39NiRp55ai/dm2+E+NzRGPN0wW1bc9Q"";
            System.out.println(""plaintext: "" + plaintext);

            try {
                String b = EncoderByMd5(""contentWindowHig"");
                System.out.println(""b: "" + b);

                String c = byteToHexString(b.getBytes(""utf-8""));
                System.out.println(""c: "" + c);

                String d = byteToHexString(""contentDocuments"".getBytes(""utf-8""));
                System.out.println(""d: "" + d);

                String enc_data = AES_CBC_Encrypt_nopadding(
                        plaintext.getBytes(""utf-8""),
                        b.getBytes(),
                        ""contentDocuments"".getBytes());
                System.out.println(""enc_data: "" + enc_data);

                String encoded_str = URLEncoder.encode(enc_data, ""utf-8"");
                System.out.println(""encoded_str: "" + encoded_str);
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }
}
        public static String AES_CBC_Encrypt_nopadding(byte[] content, byte[] keyBytes, byte[] iv){

                try{
                    KeyGenerator keyGenerator = KeyGenerator.getInstance(""AES"");
                    keyGenerator.init(128, new SecureRandom(keyBytes));
                    SecretKey key = keyGenerator.generateKey();
                    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
                    int blockSize = cipher.getBlockSize();
                    // process plain text
                    int plaintextLength = content.length;
                    if (plaintextLength % blockSize != 0) {
                        plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));
                    }
                    byte[] plaintext = new byte[plaintextLength];
                    System.arraycopy(content, 0, plaintext, 0, content.length);
                    for (int i=content.length;i&lt;plaintextLength;i++) {
                        plaintext[i] = (byte)0;
                    }
                    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
                    byte[] encrypted = cipher.doFinal(plaintext);
                    BASE64Encoder base64en = new BASE64Encoder();
                    return base64en.encode(encrypted);
                }catch (Exception e) {
                    // TODO Auto-generated catch block
                    System.out.println(""exception:""+e.toString());
                }
                return null;
            }
    public static String EncoderByMd5(String str) throws NoSuchAlgorithmException, UnsupportedEncodingException {
            MessageDigest md5=MessageDigest.getInstance(""MD5"");
            md5.update(str.getBytes());
            return new BigInteger(1, md5.digest()).toString(16);
        }

    public static String AES_CBC_Decrypt(byte[] content, byte[] keyBytes, byte[] iv){

            try{
                KeyGenerator keyGenerator=KeyGenerator.getInstance(""AES"");
                keyGenerator.init(128, new SecureRandom(keyBytes));//key128192256128
                SecretKey key=keyGenerator.generateKey();
                Cipher cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
                byte[] result = cipher.doFinal(content);
                BASE64Encoder base64en = new BASE64Encoder();
                return base64en.encode(result);
            }catch (Exception e) {
                // TODO Auto-generated catch block
                System.out.println(""exception:""+e.toString());
            }
            return null;
        }

    //Converting a string of hex character to bytes
        public static byte[] hexStringToByteArray(String s) {
            int len = s.length();
            byte[] data = new byte[len / 2];
            for (int i = 0; i &lt; len; i += 2){
                data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                        + Character.digit(s.charAt(i+1), 16));
            }
            return data;
        }

        public static String byteToHexString(byte[] bytes) {
            StringBuffer sb = new StringBuffer(bytes.length);
            String sTemp;
            for (int i = 0; i &lt; bytes.length; i++) {
                sTemp = Integer.toHexString(0xFF &amp; bytes[i]);
                if (sTemp.length() &lt; 2)
                    sb.append(0);
                sb.append(sTemp.toUpperCase());
            }
            return sb.toString();
        }
</code></pre>
","","139","<java><cryptojs>","0","","0","2017-04-26 06:08:54","","9","2","7918048","","2017-04-26 06:08:54","2017-04-25 08:12:50",""
"55595308","How can use crypto js publicEncrypt and privateDecrypt in client side javascript?","<p>I'm using <code>nodejs</code> api <code>Crypto</code> for generate public and private key. And encrypt and decrypt messages using those key. Everything is fine in server side. But how can I use <code>crypto.publicEncrypt()</code> in client side?</p>
","<p>You can download the javascript file from <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer""><strong>HERE</strong></a> and then add it in the client side like this:</p>

<pre><code>&lt;script type=""text/javascript"" src=""path-to/bower_components/crypto-js/crypto-js.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
    var encrypted = CryptoJS.AES(...);
    var encrypted = CryptoJS.SHA256(...);
&lt;/script&gt;
</code></pre>
","137","<javascript><node.js><express><cryptojs>","0","-1","1","2019-04-09 14:35:09","","0","","","","","2019-04-09 14:33:42",""
"50505823","Angular 5 material button give invalid array length error once clicked to send an id and generate a token","<p>I am trying to use JWT with angular 5 and PHP to generate a token. For testing reasons, I encrypted the <code>userid</code> variable using <code>CryptoAESJs</code> library and send it via <code>post</code> method to php script:</p>

<pre><code>getToken()
{
    let userid = 123;
    let key = ""coded"";
    let encUserID = crypto.AES.encrypt(userid, key);
    const headerOptions = new HttpHeaders().set
        ('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    const params = new HttpParams().set('userID', encUserID);

    this.http.post('http://aff.local/jwtTest.php', params, {
      headers: headerOptions,
      responseType: 'json'
    }).subscribe(
      res=&gt;{
        console.log(res);
      },
      error=&gt;{
        console.log(error);
      }
    )
}
</code></pre>

<p>I send it to the PHP script:</p>

<pre><code>&lt;?php
header('Access-Control-Allow-Origin: *');
header('Content-Type: application\JSON');
header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS');
header('Access-Control-Allow-Headers: *');
error_reporting(E_ALL);

require_once ""CryptoJSAES.php"";
require_once('JWT.php');

ini_set('log_errors', 0);
ini_set('display_errors', 1);

$key = ""coded"";
$id = $_POST['userID'];
$token = CryptoJSAES::decrypt($id,$key);

$jwt = JWT::encode($token, $key);


$jwtDecode = JWT::decode($jwt, $key, array('HS256'));

echo json_encode($jwtDecode);
?&gt;
</code></pre>

<p>Inside my <code>app.component.html</code>, I added a button:</p>

<pre><code>&lt;button mat-raised-button  (click)='getToken()'&gt;Click Me&lt;/button&gt;
</code></pre>

<p>So run the <code>getToken()</code> method when click event is fired.</p>

<p>Once clicked, I got the following error at the console:</p>

<blockquote>
  <p>ERROR RangeError: Invalid array length</p>
  
  <p>at WordArray.init.clamp (core.js:272)</p>
  
  <p>at WordArray.init.concat (core.js:237)</p>
  
  <p>at Object.pad (cipher-core.js:415)</p>
  
  <p>at Object._doFinalize (cipher-core.js:492)</p>
  
  <p>at Object.finalize (cipher-core.js:163)</p>
  
  <p>at Object.encrypt (cipher-core.js:675)</p>
  
  <p>at Object.encrypt (cipher-core.js:833)</p>
  
  <p>at Object.encrypt (cipher-core.js:201)</p>
  
  <p>at AppComponent.push../src/app/app.component.ts.AppComponent.getToken
  (app.component.ts:20)</p>
  
  <p>at Object.eval [as handleEvent] (AppComponent.html:1)</p>
</blockquote>

<p>Is it a problem with material ? Or with the browser ? Or it is a problem with the value sent from Angular to PHP ?</p>

<p><strong>EDIT</strong></p>

<pre><code>//Imports
import { Component, OnInit } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import * as crypto from 'crypto-js';
</code></pre>
","","137","<php><angular-material><jwt><angular5><cryptojs>","0","","0","2018-05-24 09:47:23","","2","","3922727","","2018-05-24 09:47:23","2018-05-24 09:32:58",""
"19895493","Three-pass Protocol in CryptoJS and OpenSSL","<p>I am looking to do a three-pass exchange with CryptoJS (client) and OpenSSL (server). I can not find any examples on how to do this, could any one pint me in the right directions. I am looking to do the following:</p>

<ol>
<li>Server sends client a string encrypted with a randomly generated key.</li>
<li>Client encrypts the string with another key, and sends it back to the server</li>
<li>Server decrypts the string using server's key from step 1 and sends it back to the client</li>
<li>Client decrypts the string with client's key from step 2. Client now has original string from the server.</li>
</ol>

<p>This is for a small app I am making. I have used CryptoJS before, but I never had to do the three-pass before, and an example to work from would be very helpful. Thank you for any help.</p>
","","137","<javascript><encryption><openssl><cryptojs>","0","","0","2013-11-10 21:36:01","","5","","","","","2013-11-10 21:36:01",""
"46892451","CryptoJSAES inserts a space during the encryption. Can't decrypt afterward","<p>I am using the CryptoJS v3.1.2 from code.google.com/p/crypto-js to encrypt a string and store it i a cookie to be decrypted afterward using the corresponding PHP helper <a href=""https://github.com/brainfoolong/cryptojs-aes-php"" rel=""nofollow noreferrer"">https://github.com/brainfoolong/cryptojs-aes-php</a>.</p>

<p>For some reason I don't know, time to time, the result of the encryption cause the CT to have spaces in the string. When there's space, the PHP helper cannot decrypt it. If I removed the spaces it doesn't decrypt either.</p>

<p>Here the JS snippet:</p>

<pre><code>var my_encrypted = CryptoJS.AES.encrypt(JSON.stringify(phrase), 'MYSALT', {format: CryptoJSAesJson}).toString();
return my_encrypted;
</code></pre>

<p>Here the PHP snippet:</p>

<pre><code>$decrypted              = cryptoJsAesDecrypt('MYSALT', $password);
</code></pre>

<p>The $password is taken from the cookie without any other modifications</p>
","","136","<php><aes><cryptojs>","0","","0","2017-10-23 14:55:27","","2","","","","","2017-10-23 14:55:27",""
"40841541","Promise.method() function not working the way I expect it to work","<p>I am writing some code that encrypts a communication channel between two users.
The steps are as follows</p>

<ul>
<li>Check if a cipher for the channel exists in <code>mongoDb</code></li>
<li>If yes, fetch the <code>cipher</code> and encrypt the incoming data</li>
<li>If no, create a new cipher, save it to <code>mongoDb</code> and encrypt the incoming data</li>
</ul>

<p>The code uses <code>crypto</code> module which is one of the few synchronous libs in core nodejs</p>

<p>Create a cipher and return it as a promise</p>

<pre><code>cipher.createCipher = Promise.method((pw) =&gt; {
  if (!pw) {
    throw new Error('Passphrase must be provided');
  }
  return crypto.createCipher('aes192', pw);
});
</code></pre>

<p>Encrypt data using Promise.method()</p>

<pre><code>cipher.encryptTextAsPromise = Promise.method((cipher, plainText) =&gt; {
  if (!( typeof plainText === 'string')) {
    throw new Error(""2nd param must be plain text"");
    let cipherText = '';
    cipher.on('readable', () =&gt; {
      var data = cipher.read();
      if (data)
        cipherText += data.toString('hex');
    });
    cipher.on('end', () =&gt; {
      return cipherText;
    });
    cipher.write(plainText);
    cipher.end();
  }
});
</code></pre>

<p>Encrypt data via callback functions.</p>

<pre><code>cipher.encryptText = (cipher, plainText, callback) =&gt; {
  if (!( typeof plainText === 'string')) {
    throw new Error(""2nd param must be plain text"");
  }
  try {
    let cipherText = '';
    cipher.on('readable', () =&gt; {
      var data = cipher.read();
      if (data)
        cipherText += data.toString('hex');
    });
    cipher.on('end', () =&gt; {
      callback(null, cipherText);
    });
    cipher.write(plainText);
    cipher.end();
  } catch (e) {
    callback(e, null);
  }
}
</code></pre>

<p>I am unable to chain these two together. What I have is a <strong>horrible anti-pattern</strong> that is worse than getting stuck in callback hell</p>

<pre><code>cipher.createCipher('secretWord')
  .then((data) =&gt; {
    cipher.encryptTextasPromise(data, 'hello world')
    .then((data) =&gt; {
      console.log(data);
    })
    .catch((err) =&gt; {
      console.log(err);
    })
  })
  .catch((err) =&gt; {
    console.log(err);
  })

mongoDbSearch(username)
  .then((data) =&gt; {
    if (data) {
      // Cipher exists, retrieve and encrypt
    }else {
      // Create new cipher and save
      someMongoSave()
        .then((data) =&gt; {
          // Cipher exists now, retrieve and encrypt
        })
    }
  })
  .catch((mongoErr) =&gt; {
    console.log(mongoErr);
  })
</code></pre>

<p>The code is a bit incomplete as I am still trying to grasp this concept. Furthermore the my attempt to chain <code>createCipher</code> and <code>encryptTextAsPromise</code> is returning <code>undefined</code> in the data. I have tried writing these as normal callback and then using <code>Promise.promisfyAll()</code> as well, which just feels like another anti-pattern.</p>
","<p><code>Promise.method</code> would appear to make sense for <code>createCipher</code>, but probably not for <code>encryptTextAsPromise</code>.</p>

<p>Here's a version that should point you the right direction, distilling various of <a href=""https://stackoverflow.com/users/157247/t-j-crowder"">T.J. Crowder</a>'s, <a href=""https://stackoverflow.com/users/5053002/jaromanda-x"">Jaromanda X</a>'s, and <a href=""https://stackoverflow.com/users/848164/undefined"">undefined</a>'s comments on the question; see code comments for more:</p>

<pre><code>// For this one, `Promise.method` still makes sense (although doing it with
// your own promise is also perfectly reasonable)
cipher.createCipher = Promise.method(pw =&gt; {
  if (!pw) {
    throw new Error('Passphrase must be provided');
  }
  return crypto.createCipher('aes192', pw);
});

// For this one, your own promise makes sense
cipher.encryptTextAsPromise = (cipher, plainText) =&gt; {
  return new Promise(resolve =&gt; {
    if (!( typeof plainText === 'string')) {
      // It's fine to throw here (it will get converted into a rejection),
      // or add `reject` to the arguments list above and call
      // that and return instead:
      // reject(new Error(""2nd param must be plain text""));
      // return;
      throw new Error(""2nd param must be plain text"");
    }
    let cipherText = '';
    cipher.on('readable', () =&gt; {
      var data = cipher.read();
      if (data)
        cipherText += data.toString('hex');
    });
    cipher.on('end', () =&gt; {
      resolve(cipherText);
    });
    cipher.write(plainText);
    cipher.end();
  });
};

// Usage:
cipher.createCipher('secretWord')
.then(data =&gt; cipher.encryptTextAsPromise(data, 'hello world'))
.then(data =&gt; console.log(data)) // See 1 below
.catch(err =&gt; console.log(err));

mongoDbSearch(username)
.then(data =&gt; data || someMongoSave(data)) // You pass `data` to `someMongoSave`, presumably?
.then(data =&gt; {
    // Cipher exists, retrieve and encrypt
})
.catch(mongoErr =&gt; {
    console.log(mongoErr);
});
</code></pre>

<p>Separately, re</p>

<pre><code>if (!( typeof plainText === 'string')) {
</code></pre>

<p>there's a <code>!==</code> operator in JavaScript. Jus' sayin'. ;-D</p>
","136","<javascript><node.js><promise><bluebird><cryptojs>","2","3","1","2016-11-28 10:51:24","40842070","16","","848164","","2016-11-28 10:09:13","2016-11-28 10:03:17",""
"52977277","CryptoJS decrypting from PHP","<p>Here's my PHP code: </p>

<pre><code>$cipher = 'aes-256-cbc';
// 128-bit key
$key = md5('super secret', true);
// 128-bit IV
$iv = openssl_random_pseudo_bytes(16);
$ciphertext = openssl_encrypt($message, $cipher, $key, OPENSSL_RAW_DATA, $iv);

error_log(__FILE__ . __LINE__ . ' key: ' . bin2hex($key));
error_log(__FILE__ . __LINE__ . ' iv: ' . bin2hex($iv));
error_log(__FILE__ . __LINE__ . ' ciphertext: ' . bin2hex($ciphertext));

file_put_contents($courseOutlineFile, bin2hex($iv) . bin2hex($ciphertext));
</code></pre>

<p>And my Javascript code, where res is the text from the ajax response to read the file generated by PHP: </p>

<pre><code>var k = CryptoJS.MD5('super secret');
var iv = CryptoJS.enc.Hex.parse(res.substring(0, 32));
var data = CryptoJS.enc.Hex.parse(res.substring(32));

console.log(""key: "", CryptoJS.enc.Hex.stringify(k))
console.log(""iv: "", CryptoJS.enc.Hex.stringify(iv))
console.log(""ciphertext: "", CryptoJS.enc.Hex.stringify(data))

var cipher = CryptoJS.lib.CipherParams.create({
    ciphertext: data
});

var dec = CryptoJS.AES.decrypt(cipher, k, {
    iv: iv,
    mode: CryptoJS.mode.CBC
});
console.log(""decrypted:"", dec.toString(CryptoJS.enc.Hex));

var json = dec.toString(CryptoJS.enc.Utf8);
console.log(""json:"", json)
</code></pre>

<p>I've verified with a compare tool that the hex values of the key, IV, and data are the same in PHP and what gets printed to the browser's console.  It does successfully decrypt (something), but that last console.log statement generates an error: Error: ""Malformed UTF-8 data"".  If I try Latin1 it results in a bunch of non-printable characters.</p>

<p>The $message variable that I'm encrypting is the output from json_encode on an array.</p>

<p>Does anyone know what I'm missing?</p>

<p>These are the first 80 hex digits of the decrypted result, the entire thing is a little under 28k hex digits.</p>

<blockquote>
  <p>20a290156abf2855f2c3344a2d9cf7dc84c5c02b1a48a03f18aa8a5054f650dd5517b25b6582c72d </p>
</blockquote>

<p>Here's a complete example:</p>

<pre><code>&lt;?php
ini_set('display_errors', 1);

$jsonObj = [
  'el1' =&gt; 'val1',
  'ar1' =&gt; [
    'el2' =&gt; 'val2',
    'el3' =&gt; 'val3',
  ],
];
$message = json_encode($jsonObj);
echo $message . '&lt;br&gt;';
$cipher = 'aes-256-cbc';
// 128-bit key
$key = md5('super secret', true);
// 128-bit IV
$iv = openssl_random_pseudo_bytes(16);
$ciphertext = openssl_encrypt($message, $cipher, $key, OPENSSL_RAW_DATA, $iv);

echo ' key: ' . bin2hex($key) . '&lt;br&gt;';
echo ' iv: ' . bin2hex($iv) . '&lt;br&gt;';
echo ' ciphertext: ' . bin2hex($ciphertext) . '&lt;br&gt;';

echo bin2hex($iv) . bin2hex($ciphertext);
</code></pre>

<p>The output:</p>

<pre><code>{""el1"":""val1"",""ar1"":{""el2"":""val2"",""el3"":""val3""}}
key: 5f1903f5f2cb32acb4c1dcae9e30d374
iv: bfdb765d1ca4734c5748ffb9883dd15c
ciphertext: 
02717027440040375f7e0dbea69e77783949d3c160529eef0b9d59a751a2a312fa137a5034f6f4c9f89a348ef3f96fce40c8afe0c8a20a2f7a2535417cca2dd2
bfdb765d1ca4734c5748ffb9883dd15c02717027440040375f7e0dbea69e77783949d3c160529eef0b9d59a751a2a312fa137a5034f6f4c9f89a348ef3f96fce40c8afe0c8a20a2f7a2535417cca2dd2
</code></pre>

<p>And the Javascript:</p>

<pre><code>res = 'bfdb765d1ca4734c5748ffb9883dd15c02717027440040375f7e0dbea69e77783949d3c160529eef0b9d59a751a2a312fa137a5034f6f4c9f89a348ef3f96fce40c8afe0c8a20a2f7a2535417cca2dd2';
var k = CryptoJS.MD5('super secret');
var iv = CryptoJS.enc.Hex.parse(res.substring(0, 32));
var data = CryptoJS.enc.Hex.parse(res.substring(32));

console.log(""key: "", CryptoJS.enc.Hex.stringify(k))
console.log(""iv: "", CryptoJS.enc.Hex.stringify(iv))
console.log(""ciphertext: "", CryptoJS.enc.Hex.stringify(data))

var cipher = CryptoJS.lib.CipherParams.create({
    ciphertext: data
});

var dec = CryptoJS.AES.decrypt(cipher, k, {
    iv: iv,
    mode: CryptoJS.mode.CBC
});
console.log(""dec:"", dec.toString());
console.log(""decrypted:"", dec.toString(CryptoJS.enc.Hex));
var json = dec.toString(CryptoJS.enc.Utf8);
console.log(""json:"", json)
// parse the JSON string to get the object
var obj = JSON.parse(json);
</code></pre>

<p>And the console output:</p>

<pre><code>key:  5f1903f5f2cb32acb4c1dcae9e30d374 
iv:  bfdb765d1ca4734c5748ffb9883dd15c 
ciphertext:  02717027440040375f7e0dbea69e77783949d3c160529eef0b9d59a751a2a312fa137a5034f6f4c9f89a348ef3f96fce40c8afe0c8a20a2f7a2535417cca2dd2 
dec: 50d411522f2d08b34d68f847fb78e0cfabf1144f933d83839431732a473079d9b3ed843e120d9ad6a239 
decrypted: 50d411522f2d08b34d68f847fb78e0cfabf1144f933d83839431732a473079d9b3ed843e120d9ad6a239 

Error during decryption:  Error: ""Malformed UTF-8 data""
</code></pre>
","","136","<javascript><php><aes><cryptojs>","0","","0","2018-10-24 21:29:22","","5","1","151283","","2018-10-24 21:29:22","2018-10-24 20:13:13",""
"39884266","Javascript: shasum of SHELL and crypto of JS library are giving different results","<p>Here's what Unix gives me and it is correct:</p>

<pre><code>shasum -a 256 test.jpg
df94ac3fd72415827f345b5fa22761f57d87e99c25d5345d2e8e9f6c91ef34a3  test.jpg
</code></pre>

<p>In Javascript, I am not able to get this using <code>crypto-browserify</code>. Please see my results:</p>

<pre><code>img.onload = function(e) {
    console.log(crypto.createHash('sha256').update(e.path[0]).digest('hex'));
    console.log(crypto.createHash('sha256').update(e.path).digest('hex'));
    console.log(crypto.createHash('sha256').update(e.path[0].src).digest('hex'));
    console.log(crypto.createHash('sha256').update(e).digest('hex'));
}
</code></pre>

<p>The results are:</p>

<pre><code>da5698be17b9b46962335799779fbeca8ce5d491c0e26243bafef9ea1837a9d8
6e340b9cffb37a989ca54ee6bb780a2c78901d3fb33738768511a30617afa01d
7ce85f64d69c7a8865413deaff3d65ca0272dfbe74ad9bc07s5e28679243cb69
da5698be17b9b46962335799779fbeca8ce5d491csd26243bafef9ea1837a9d8
</code></pre>

<p>Not able to get <code>df94ac3fd72415827f345b5fa22761f57d87e99c25d5345d2e8e9f6c91ef34a3</code> like in <code>shasum</code> command line. Could you please tell what should I do get the <code>sha</code>?</p>
","<p>This is how I finally implemented:</p>

<pre><code>    var oReq = new XMLHttpRequest();
    oReq.open(""GET"", ""../test.jpg"", true);
    oReq.responseType = ""arraybuffer"";
    oReq.onload = function (oEvent) {
        var arrayBuffer = oReq.response;
        if (arrayBuffer) {
            var byteArray = new Uint8Array(arrayBuffer);
            console.log(crypto.createHash('sha256').update(byteArray).digest('hex'));
        }
    };
    oReq.send(null);
</code></pre>

<p>Thanks,
Keith.</p>
","135","<javascript><hash><browserify><sha256><cryptojs>","-1","0","1","2016-10-12 05:08:33","","3","","1816580","","2016-10-06 05:15:16","2016-10-05 21:49:38",""
"56414023","How to rewrite NodeJS CryptoJS functions so they work in ReactJS web?","<p>I have some code that was created for me by a past contractor that provided a working implementation of CryptoJS between a Unity3D client and NodeJS server app (as in encryption of client-server messages).</p>

<p>I am working on an implementation that needs to call the same server endpoints from a React web app. Basically, I need to be able to ensure that the React app provides the same results when encrypting and decrypting messages as the server (and hence the Unity3D implementation) does.</p>

<p>The existing encrypt/decrypt functions in the NodeJS app are shown below. They are somewhat more advanced than the standard CryptoJS examples and when I attempt to use them as-is in React, I get this error:</p>

<p><code>TypeError: cryptoJS.createHash is not a function. (In 'cryptoJS.createHash('md5')', 'cryptoJS.createHash' is undefined)</code></p>

<p>After some researching, I understand that potentially the 'use as-is' approach will fail because it's using a server side library on the client side, but I have been able to find anything that would explain how I would recreate the same code to work client-side.</p>

<pre><code>encrypt(text, key, iv) {
    const keyBuffer = Buffer.from(cryptoJS.createHash('md5').update(key).digest('hex'), ""hex"")
    const ivBuffer = Buffer.from(cryptoJS.createHash('md5').update(iv).digest('hex'), ""hex"")
    const textBuffer = Buffer.from(text, 'utf8')
    let cipher = cryptoJS.createCipheriv(algorithm, keyBuffer, ivBuffer)
    let encryptedText = Buffer.concat([cipher.update(textBuffer), cipher.final()])
    return encryptedText.toString(""base64"")
}

decrypt(text, key, iv) {
    const keyBuffer = Buffer.from(cryptoJS.createHash('md5').update(key).digest('hex'), ""hex"")
    const ivBuffer = Buffer.from(cryptoJS.createHash('md5').update(iv).digest('hex'), ""hex"")
    let decipher = cryptoJS.createDecipheriv(algorithm, keyBuffer, ivBuffer)
    const textBuffer = Buffer.from(text, 'base64')
    var decipheredContent = Buffer.concat([decipher.update(textBuffer), decipher.final()])
    return decipheredContent.toString(""utf8"")
}
</code></pre>

<p>So, I need to figure out how to replace these encrypt/decrypt functions with ones that compile and function in client side in React web. Any help in steering me in the right direction or assisting with the code would be greatly appreciated. Thanks for taking the time to read my question.</p>
","","135","<node.js><reactjs><cryptojs>","1","","0","2019-06-02 10:03:33","","5","1","","","","2019-06-02 10:03:33",""
"47905866","How can we implement JWE with just nodejs Crypto library?","<p>This is what I am doing to generate JWT tokens for now. How can I generate JWE tokens with just crypto library without using any other npde packages?</p>

<pre><code>var Header = {""alg"": ""HS256"",""typ"": ""JWT""},
    Payload = {""content"": ""valuable data""},
    secret_key = ""xxxxx123xxxxxxxx123xxxxxxxx"";

function create_jwt(Header, Payload) {

  var encodedString = btoa(JSON.stringify(Header)) + ""."" + btoa(JSON.stringify(Payload));

  var hmac_hash = z.hmac('sha256', secret_key, encodedString, ""base64"");
  return console.log(encodedString + ""."" + hmac_hash);
}
</code></pre>
","","133","<javascript><node.js><jwt><cryptojs><jwe>","0","","0","2017-12-20 12:15:17","","4","","","","","2017-12-20 12:15:17",""
"44934900","Angular 2 - moving embedded plugin to service","<p>I am new to Angular 2, and am just learning how to include plugins. I am getting this error:</p>

<p><em>Uncaught Error: Can't resolve all parameters for SwitchClientComponent: ([object Object], [object Object], [object Object], [object Object], [object Object], [object Object], ?, ?)</em></p>

<p>when implementing <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a>.</p>

<p>I'm sure it's because I haven't properly installed and referenced it.</p>

<p>I have an app.module.ts file (snipped for brevity):</p>

<pre><code>import { BrowserModule } from '@angular/platform-browser';
import { NgModule, APP_INITIALIZER  } from '@angular/core';
import { FormsModule } from '@angular/forms';
...
import { MomentModule } from 'angular2-moment';
import { CryptoJS } from ""crypto-js"";

@NgModule({
    declarations: [
        AppComponent,
        ...
        SwitchClientComponent
    ],
    imports: [
        BrowserModule,
        ...
        StoreModule.provideStore({ appState: appStateReducer }),
    ],providers: [
    { provide: AppConfig, useFactory: serviceConfigFactory },
    SiteService,
    AppContext,
    { provide: APP_INITIALIZER, useFactory: AppContextLoader, deps: [AppContext], multi: true },
    EmployeeService,
    EncryptionService
],
    ...

})
export class AppModule { }
</code></pre>

<p>(I see an import line but no corresponding reference in the @NgModule...)</p>

<p>Here is where I'm trying to use it:</p>

<pre><code>import { Injectable } from '@angular/core';
import { CryptoJS } from ""crypto-js"";

@Injectable()
export class EncryptionService {

    secretKey: string = ""123"";

    constructor() {
    }

    public setLocalStorage(storagePrefix : string, jsonObj) {
        localStorage.setItem(storagePrefix, this.encrypt(jsonObj));
    }

    encrypt(jsonObj) {
        return CryptoJS.AES.encrypt(JSON.stringify(jsonObj), this.secretKey);
    }
}
</code></pre>

<p>Here is the actual switch-client-component that is trying to utilize the service:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { SiteService } from '../../services/site.service';
import { CompanyRoutes } from '../../features/company/company.routes';
import { AppContext } from '../../services/app.context';
import { SiteConfig } from '../../models/site/site.config';
import { AuthService } from '../../services/auth/auth.service';
import { EncryptionService } from '../../services/encryption.service';

@Component({
  selector: 'app-switch-client',
  templateUrl: './switch-client.component.html',
  styleUrls: ['./switch-client.component.scss']

})
export class SwitchClientComponent implements OnInit {
    availableClients : any[] = [];
    filterString: string = '';
    frequentClients: any[] = [];
    maxFrequentClients: number = 6;
    storagePrefix = 'AbilitiConnect-FrequentClients';

    constructor(public auth: AuthService,
        private route: ActivatedRoute,
        private router: Router,
        private appContext: AppContext,
        private siteService: SiteService,
        private companyRoutes: CompanyRoutes,
        private encryptionService, EncryptionService
    ) {}


    ngOnInit() {
        this.availableClients = this.siteService.getAvailableClientCodes();
        //redirect the user to main page if there is onlu one client.
        if (this.availableClients == null || this.availableClients.length &lt;= 1) {
            this.router.navigate(['/']);
        }
        this.purgeFrequentClients();
        this.frequentClients = this.getFrequentClients();
    }

    switchClient(client) {
        this.updateFrequentClient(client);
        this.appContext.switchClient(client.ClientCode)
            .subscribe((siteConfig: SiteConfig) =&gt; {
                this.companyRoutes.resetCompanyRoutes(siteConfig.clientCode, ""/"");
                this.router.navigate(['/']);
            });
    };

    updateFrequentClient(client) {
        var tempClientArr = [];
        tempClientArr = this.getFrequentClients();
        tempClientArr = tempClientArr.filter(item =&gt; item.Name !== client.Name);
        tempClientArr.unshift(client);
        tempClientArr = tempClientArr.slice(0, this.maxFrequentClients);
        this.encryptionService.setLocalStorage(this.storagePrefix, tempClientArr);
    };

    getFrequentClients() {
        return this.encryptionService.getLocalStorage(this.storagePrefix);
    };
    purgeFrequentClients() {
        this.encryptionService.setLocalStorage(this.storagePrefix, []);
    };
}
</code></pre>

<p>I don't know how to interpret that error.</p>
","<p>Seems you have a typo</p>

<pre><code>constructor(public auth: AuthService,
        private route: ActivatedRoute,
        private router: Router,
        private appContext: AppContext,
        private siteService: SiteService,
        private companyRoutes: CompanyRoutes,
        private encryptionService, EncryptionService 
                               ^^^^^
                          you should change it to :
   ) {}
</code></pre>

<p>Correct code should look like</p>

<pre><code>constructor(public auth: AuthService,
        private route: ActivatedRoute,
        private router: Router,
        private appContext: AppContext,
        private siteService: SiteService,
        private companyRoutes: CompanyRoutes,
        private encryptionService: EncryptionService
   ) {}
</code></pre>
","132","<angular><cryptojs>","0","1","2","2017-07-06 07:43:14","44935551","0","","581837","","2017-07-05 20:27:59","2017-07-05 19:54:58",""
"44934900","Angular 2 - moving embedded plugin to service","<p>I am new to Angular 2, and am just learning how to include plugins. I am getting this error:</p>

<p><em>Uncaught Error: Can't resolve all parameters for SwitchClientComponent: ([object Object], [object Object], [object Object], [object Object], [object Object], [object Object], ?, ?)</em></p>

<p>when implementing <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a>.</p>

<p>I'm sure it's because I haven't properly installed and referenced it.</p>

<p>I have an app.module.ts file (snipped for brevity):</p>

<pre><code>import { BrowserModule } from '@angular/platform-browser';
import { NgModule, APP_INITIALIZER  } from '@angular/core';
import { FormsModule } from '@angular/forms';
...
import { MomentModule } from 'angular2-moment';
import { CryptoJS } from ""crypto-js"";

@NgModule({
    declarations: [
        AppComponent,
        ...
        SwitchClientComponent
    ],
    imports: [
        BrowserModule,
        ...
        StoreModule.provideStore({ appState: appStateReducer }),
    ],providers: [
    { provide: AppConfig, useFactory: serviceConfigFactory },
    SiteService,
    AppContext,
    { provide: APP_INITIALIZER, useFactory: AppContextLoader, deps: [AppContext], multi: true },
    EmployeeService,
    EncryptionService
],
    ...

})
export class AppModule { }
</code></pre>

<p>(I see an import line but no corresponding reference in the @NgModule...)</p>

<p>Here is where I'm trying to use it:</p>

<pre><code>import { Injectable } from '@angular/core';
import { CryptoJS } from ""crypto-js"";

@Injectable()
export class EncryptionService {

    secretKey: string = ""123"";

    constructor() {
    }

    public setLocalStorage(storagePrefix : string, jsonObj) {
        localStorage.setItem(storagePrefix, this.encrypt(jsonObj));
    }

    encrypt(jsonObj) {
        return CryptoJS.AES.encrypt(JSON.stringify(jsonObj), this.secretKey);
    }
}
</code></pre>

<p>Here is the actual switch-client-component that is trying to utilize the service:</p>

<pre><code>import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { SiteService } from '../../services/site.service';
import { CompanyRoutes } from '../../features/company/company.routes';
import { AppContext } from '../../services/app.context';
import { SiteConfig } from '../../models/site/site.config';
import { AuthService } from '../../services/auth/auth.service';
import { EncryptionService } from '../../services/encryption.service';

@Component({
  selector: 'app-switch-client',
  templateUrl: './switch-client.component.html',
  styleUrls: ['./switch-client.component.scss']

})
export class SwitchClientComponent implements OnInit {
    availableClients : any[] = [];
    filterString: string = '';
    frequentClients: any[] = [];
    maxFrequentClients: number = 6;
    storagePrefix = 'AbilitiConnect-FrequentClients';

    constructor(public auth: AuthService,
        private route: ActivatedRoute,
        private router: Router,
        private appContext: AppContext,
        private siteService: SiteService,
        private companyRoutes: CompanyRoutes,
        private encryptionService, EncryptionService
    ) {}


    ngOnInit() {
        this.availableClients = this.siteService.getAvailableClientCodes();
        //redirect the user to main page if there is onlu one client.
        if (this.availableClients == null || this.availableClients.length &lt;= 1) {
            this.router.navigate(['/']);
        }
        this.purgeFrequentClients();
        this.frequentClients = this.getFrequentClients();
    }

    switchClient(client) {
        this.updateFrequentClient(client);
        this.appContext.switchClient(client.ClientCode)
            .subscribe((siteConfig: SiteConfig) =&gt; {
                this.companyRoutes.resetCompanyRoutes(siteConfig.clientCode, ""/"");
                this.router.navigate(['/']);
            });
    };

    updateFrequentClient(client) {
        var tempClientArr = [];
        tempClientArr = this.getFrequentClients();
        tempClientArr = tempClientArr.filter(item =&gt; item.Name !== client.Name);
        tempClientArr.unshift(client);
        tempClientArr = tempClientArr.slice(0, this.maxFrequentClients);
        this.encryptionService.setLocalStorage(this.storagePrefix, tempClientArr);
    };

    getFrequentClients() {
        return this.encryptionService.getLocalStorage(this.storagePrefix);
    };
    purgeFrequentClients() {
        this.encryptionService.setLocalStorage(this.storagePrefix, []);
    };
}
</code></pre>

<p>I don't know how to interpret that error.</p>
","<p>Install Cryto js usning npm</p>

<pre><code>npm install crypto-js 

typings install dt~crypto-js --global --save
</code></pre>

<p>You can refer crypto js in below ways </p>

<pre><code>import * as CryptoJS from 'crypto-js';
</code></pre>
","132","<angular><cryptojs>","0","0","2","2017-07-06 07:43:14","44935551","0","","581837","","2017-07-05 20:27:59","2017-07-05 19:54:58",""
"50031174","CryptoJS weird encrypt/decrypt failure","<p>I just want to encrypt a 128 bit code using AES-128 but it results in weird decrypt result.</p>

<p>It is set up this way so it can represent my real implementation:</p>

<pre><code>var plain = CryptoJS.lib.WordArray.random(128/8);
console.log(""plain: "" + plain.toString(CryptoJS.enc.Base64));

var iv_wordArr = CryptoJS.lib.WordArray.random(128/8);
var salt = CryptoJS.lib.WordArray.random(128/8);

var key128Bits = CryptoJS.PBKDF2(""12345678"", salt, { keySize: 128/32, iterations: 1000 });

var encrypted = CryptoJS.AES.encrypt(plain.toString(CryptoJS.enc.Base64), key128Bits, { iv: iv_wordArr });

var dbKeyEnc = iv_wordArr.toString(CryptoJS.enc.Base64) + "":"" + encrypted.toString();

salt = salt.toString(CryptoJS.enc.Base64);

var splitted = dbKeyEnc.split("":"");

key128Bits = CryptoJS.PBKDF2(""12345678"", CryptoJS.enc.Base64.parse(salt), { keySize: 128/32, iterations: 1000 });

iv_wordArr = CryptoJS.enc.Base64.parse(splitted[0]);

var decrypt = CryptoJS.AES.decrypt(splitted[1], key128Bits, { iv: iv_wordArr });

console.log(""decrypt: "" + decrypt.toString(CryptoJS.enc.Base64));
//console error: Invalid array length (because of decrypt wrong result)
</code></pre>

<p>I have checked step by step and iv, salt, key are alright. Problem comes when decrypting.</p>
","<p>After extense testing I found out that the problem was with the salt.</p>

<p>I assumed that this functions did the same thing:</p>

<pre><code>var salt = CryptoJS.lib.WordArray.random(128/8);

salt = salt.toString(CryptoJS.enc.Base64);

salt = CryptoJS.enc.Base64.stringify(salt); //correct one
</code></pre>

<p>But they are different. The second one is the one that keeps the same value.</p>
","129","<cryptojs>","1","0","1","2018-04-26 02:04:36","","0","","3834722","","2018-04-26 01:30:27","2018-04-25 20:52:21",""
"57297239","How to Encrypt Data in Javascript with RSA public key?","<p>Server generates RSA public and private keys and store them in the session. Over a server call the client html page recieves the public key. Now I want to encrypt data using it. I have tried using jsencrypt but it doesn't recognize the public key my server generates. Gives false when I call encrypt after setting the public key. I think the key is 2048 bits. Not sure about the encoding though. How to encrypt data using this key? Any help is appreciated.</p>

<pre><code>Sample public key generated by server: 9995362445e0a98f4da3019f6f3eb960f938056972408675c0b3f642ad5943709f8e8031f00bba6ed24bad1e8e2b099cd154b5eb5b64b310d179b39abb4392442cdb8ad3fe8bc6e3088bd63089d405fb134c633de62b741e4c5bd615b90e096ec3bb16f71ef54825febc5662a96c093db986225825a1cc63d4dc19e2abbbfb1cb9d3a5e41f757ce3f82481a5caf92207ffe4c37e8acc43835dce49cf61a6b113384d333050b6ac59ef78a182bae114b08729e84cbad659eb8bace0481aa51a370daac09f97d779be245ce95af85a285d0ea170da732f9eef2e43a21f5586014ea00259ef09498356eaf2d4e492f0f8978ca167c3f690b35045a8dd1c7ccf4347
</code></pre>

<p>Edit: As suggested by many, I tried using crypto:</p>

<pre><code>let crypto;
try {
  crypto = require('crypto');
} catch (err) {
  console.log('crypto support is disabled!');
}
var encryptStringWithRsaPublicKey = function(toEncrypt, publicKey) {
  var buffer = Buffer.from(toEncrypt,'utf8');
  var encrypted = crypto.publicEncrypt(publicKey, buffer);
  return encrypted.toString(""base64"");
};
console.log(encryptStringWithRsaPublicKey('MyText','9995362445e0a98f4da3019f6f3eb960f938056972408675c0b3f642ad5943709f8e8031f00bba6ed24bad1e8e2b099cd154b5eb5b64b310d179b39abb4392442cdb8ad3fe8bc6e3088bd63089d405fb134c633de62b741e4c5bd615b90e096ec3bb16f71ef54825febc5662a96c093db986225825a1cc63d4dc19e2abbbfb1cb9d3a5e41f757ce3f82481a5caf92207ffe4c37e8acc43835dce49cf61a6b113384d333050b6ac59ef78a182bae114b08729e84cbad659eb8bace0481aa51a370daac09f97d779be245ce95af85a285d0ea170da732f9eef2e43a21f5586014ea00259ef09498356eaf2d4e492f0f8978ca167c3f690b35045a8dd1c7ccf4347'));
</code></pre>

<p>It is throwing the below error:</p>

<pre><code>Uncaught TypeError: Cannot read property '2' of null
    at push../node_modules/parse-asn1/fixProc.js.module.exports (fixProc.js:19)
    at parseKeys (index.js:27)
    at Object.publicEncrypt (publicEncrypt.js:30)
    at encryptStringWithRsaPublicKey (App.js:20)
    at Module.&lt;anonymous&gt; (App.js:23)
    at Module../src/App.js (App.js:727)
    at __webpack_require__ (bootstrap:781)
    at fn (bootstrap:149)
    at Module../src/index.js (index.css?f3f6:45)
    at __webpack_require__ (bootstrap:781)
    at fn (bootstrap:149)
    at Object.0 (test.css?2a93:45)
    at __webpack_require__ (bootstrap:781)
    at checkDeferredModules (bootstrap:45)
    at Array.webpackJsonpCallback [as push] (bootstrap:32)
    at main.chunk.js:1
</code></pre>
","<p>You can use 'crypto' in node:
<a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">https://nodejs.org/api/crypto.html</a>
In their official documentation there is news that it encrypt 2048 bits.</p>
","129","<javascript><encryption><rsa><public-key-encryption><cryptojs>","0","1","1","2019-08-01 03:22:04","","3","","10418519","","2019-08-01 03:22:04","2019-07-31 18:52:50",""
"49396548","Can't add option object to the SHA3 function with typescript","<p>the <code>SHA3</code> function provides an option to control the output length as shown in this example:</p>

<pre><code>var hash = CryptoJS.SHA3(""Message"", { outputLength: 512 });
var hash = CryptoJS.SHA3(""Message"", { outputLength: 384 });
var hash = CryptoJS.SHA3(""Message"", { outputLength: 256 });
var hash = CryptoJS.SHA3(""Message"", { outputLength: 224 });
</code></pre>

<p>however when used in typescript with <a href=""https://www.npmjs.com/package/@types/crypto-js"" rel=""nofollow noreferrer"">@types/crypto-js</a> i am getting the following type error when trying to specify the the <code>outputLength</code>:</p>

<blockquote>
  <p>Argument of type '{ outputLength: number; }' is not assignable to
  parameter of type 'string | WordArray | undefined'.
        Object literal may only specify known properties, and 'outputLength' does not exist in type 'string | WordArray |
  undefined'.</p>
</blockquote>
","<p>That's because that function is defined, in <code>@types/crypto-js</code>, as:</p>

<pre><code>(message: string | LibWordArray, key?: string | WordArray, ...options: any[]) =&gt; WordArray;
</code></pre>

<p>As you see, it expects three parameters, the second being the key (which is nullable). Just do this:</p>

<pre><code>CryptoJS.SHA3(""Message"", undefined, { outputLength: 512});
</code></pre>

<p>An it should work.</p>

<p>By the way, there's another @types for this library, <code>@types\cryptojs</code>, it might suit you better.</p>
","129","<typescript><typescript-typings><cryptojs>","2","0","1","2018-03-21 08:48:15","49401723","1","1","","","","2018-03-21 01:01:36",""
"56058546","Is it secure to pass static value for CryptoJS AES encryption key?","<p>I want to encrypt all my form data with crypto js AES encryption. Is it good to keep the encrypt key value in client side like below.Kindly suggest.</p>

<pre><code>
var key = CryptoJS.enc.Utf8.parse(""234234234DFDFDF343434DFDFDF"")
      , iv = CryptoJS.enc.Utf8.parse(""234234324234324"")
      , data = CryptoJS.enc.Utf8.parse(str)
      , encryptedData = CryptoJS.AES.encrypt(data, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });

</code></pre>
","<p>No, this is generally not secure.</p>

<p>First of all, you wrongly state your goal. AES encryption is not a goal, it is a means to an end. What you want to do is to keep your form data confidential. The form data is called ""the message"" in crypto terminology.</p>

<p>If you need to send your message to a server, and then let the server have the decrypted form, then you need <em>transport security</em>. It's best to use TLS for that. Commonly JavaScript doesn't have any means to create a trust relationship with the server (your browser uses it's certificate store with trusted certificates for that). So in that case you cannot rely on JavaScript security.</p>

<p>Sometimes you want to keep your front end from decrypting the messages. In that case you could send a <em>public key</em> such as an RSA public key over the secure channel. Then you could encrypt the form data using RSA and AES (hybrid cryptography). Your backend would then be able to decrypt the messages. This scheme still fails if your front end sends the wrong key though, as the message would be encrypted with a public key from another party. So this assumes that the front end software cannot be easily hacked (or replaced altogether by a different server, subverting the traffic).</p>

<p>Even if you could use a trusted AES key then using CBC for transport mode security will definitely enable plaintext or padding oracle attacks. You're lacking <em>way</em> too much experience with crypto to pull this off. Use TLS, that's hard enough (to secure, using it is relatively easy).</p>
","128","<encryption><base64><aes><cryptojs>","0","0","1","2019-05-10 12:59:33","56078239","1","","","","","2019-05-09 11:36:38",""
"42162894","Cannot decrypt ciphertext from php encryption","<p>I can't  decrypt this cipher using crypto-js.</p>

<p>plain text key: 'abcdabcdabcdabcd'</p>

<p>iv: <code>'0000000000000000'</code></p>

<p>secret message: <code>'5555555555555555'</code></p>

<p>ciphertext: <code>'jIwKE2X1N/1aiZfWoaY+USXRnslF1tsXKVtUON8ucn0='</code></p>

<p>My crypto-js code looks like this:</p>

<pre><code>var iv  = '0000000000000000';
var aesKey = 'abcdabcdabcdabcd';
var ciphertext = 'jIwKE2X1N/1aiZfWoaY+USXRnslF1tsXKVtUON8ucn0=';
var decryption = CryptoJS.AES.decrypt(ciphertext, aesKey, {iv: iv});
console.log( decryption.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>After runing this code the console.log is empty, what i'm doing wrong?</p>
","<p>Not an answer, needed for formatting</p>

<p>Given:  </p>

<pre><code>keyString:           ""abcdabcdabcdabcd""
ivString:            ""0000000000000000""
secretMessageString: ""5555555555555555""
ciphertextBase64:    ""jIwKE2X1N/1aiZfWoaY+USXRnslF1tsXKVtUON8ucn0=""
</code></pre>

<p>Displayed as hex:  </p>

<pre><code>keyHex:                  61626364616263646162636461626364
ivHex:                   30303030303030303030303030303030
secretMessageHex:        35353535353535353535353535353535
secretMessageHexPadded:  3535353535353535353535353535353510101010101010101010101010101010
ciphertextHex:           8c8c0a1365f537fd5a8997d6a1a63e5125d19ec945d6db17295b5438df2e727d
</code></pre>

<p>Putting these values into an online <a href=""http://extranet.cryptomathic.com/aescalc?key=61626364616263646162636461626364&amp;iv=30303030303030303030303030303030&amp;input=3535353535353535353535353535353510101010101010101010101010101010&amp;mode=cbc&amp;action=Encrypt&amp;output=9494DA8CD4DD92415C694BBC41EA45F8962F8D02505127FC2657461011085028"" rel=""nofollow noreferrer"">AES Calculator <kbd>Encrypt</kbd></a>: </p>

<pre><code>ciphertextHexCalculated: 319C920C815076E0DD863FCB5AE8DDBD6D8065E9B4D285E06B0F58DD1F0EA3B7
</code></pre>

<p>Note that this is not the same as the question provided ciphertext.</p>

<p>There is something that is not correct with parameters, options or data.</p>

<p><strong>However</strong> the decryption does work with an IV of 0x00 bytes:</p>

<pre><code>keyString:           ""abcdabcdabcdabcd""
ivHex: 00000000000000000000000000000000
secretMessageString: ""5555555555555555""
</code></pre>

<p><a href=""http://extranet.cryptomathic.com/aescalc?key=61626364616263646162636461626364&amp;iv=00000000000000000000000000000000&amp;input=3535353535353535353535353535353510101010101010101010101010101010&amp;mode=cbc&amp;action=Decrypt&amp;output=319C920C815076E0DD863FCB5AE8DDBD6D8065E9B4D285E06B0F58DD1F0EA3B7"" rel=""nofollow noreferrer"">Online AES Calculator <kbd>Decrypt</kbd></a></p>

<p>Which is incorrect because the clear text is being used as the encrypted text.</p>
","128","<javascript><encryption><cryptojs>","-1","1","1","2017-02-10 19:20:25","","4","","451475","","2017-02-10 17:46:35","2017-02-10 15:22:32",""
"55700676","Decrypt text in Node.js encrypted in C#","<p>I have some text encrypted in C#/.NET which I want to decrypt in Node.js. I have the decryption code that works perfectly fine in C#, but I am not able to find code that decrypts the same encrypted text in Node.js. Below mentioned is the code in .NET for decryption</p>

<pre><code>public static string Decrypt(string encodedText, string key)
{
    TripleDESCryptoServiceProvider desCryptoProvider = new TripleDESCryptoServiceProvider();
    byte[] byteBuff;
    try
    {
        byteBuff = Convert.FromBase64String(encodedText);
        desCryptoProvider.Key = UTF8Encoding.UTF8.GetBytes(key);
        desCryptoProvider.Mode = CipherMode.ECB;
        desCryptoProvider.Padding = PaddingMode.PKCS7;
        string plaintext = Encoding.UTF8.GetString(desCryptoProvider.CreateDecryptor().TransformFinalBlock(byteBuff, 0, byteBuff.Length));
        return plaintext;
    }
    catch (Exception except)
    {
        Console.WriteLine(except + ""\n\n"" + except.StackTrace);
        return null;
    }
}
</code></pre>

<p>The Node.js built-in library crypto did not help me a great deal as it errored out with the encrypted text. When I used 'Crypto-JS' package from npm, it did not error out, however, it did not give any output either. Below is the Node.js equivalent</p>

<pre><code>function decrypt(input, key) {
   var key = CryptoJS.enc.Utf8.parse(key);
   var iv = CryptoJS.enc.Base64.parse('QUJDREVGR0g=');
   var options = {
       mode: CryptoJS.mode.ECB,
       padding: CryptoJS.pad.Pkcs7
   };
   var bytes = CryptoJS.TripleDES.decrypt(input, key, options);
   console.log('key:' + key);
   var decryptedText = bytes.toString(CryptoJS.enc.Utf8);
   console.log('DecryptedText:' + decryptedText);
   return decryptedText;
}
</code></pre>

<p>How do I find out the Node.js equivalent of the above code?</p>
","","125","<c#><node.js><cryptojs><node-crypto>","0","","0","2019-04-16 11:49:47","","2","","63550","","2019-04-16 11:49:47","2019-04-16 04:41:31",""
"47567736","Java decode AES encoded message issue","<p>This is my java program:</p>

<pre><code>package com.util;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class Coder1 {

    public static int AES_KEY_SIZE = 256 ;
    public static int IV_SIZE = 16 ;
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException 
    {
        String message = ""abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"";
        message =message +message;
        message =message +message;
        KeyGenerator keygen = KeyGenerator.getInstance(""AES"") ; // Specifying algorithm key will be used for 
        keygen.init(AES_KEY_SIZE) ; // Specifying Key size to be used, Note: This would need JCE Unlimited Strength to be installed explicitly 
        SecretKey aesKey = keygen.generateKey();

        // Generating IV
        byte iv[] = new byte[IV_SIZE];

        SecureRandom secRandom = new SecureRandom() ;
        secRandom.nextBytes(iv);
        Cipher cipher = Cipher.getInstance(""AES/CTR/PKCS5PADDING"");
        Cipher decipher = Cipher.getInstance(""AES/CTR/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, aesKey,new IvParameterSpec(iv));
        decipher.init(Cipher.DECRYPT_MODE, aesKey,new IvParameterSpec(iv));
        byte[] cipherTextInByteArr = cipher.doFinal(message.getBytes());
        byte[] plainTextInByteArr = decipher.doFinal(cipherTextInByteArr);
        System.out.println(""Key=""+Base64.getEncoder().encodeToString(aesKey.getEncoded())+""|"");
        System.out.println(""IV=""+Base64.getEncoder().encodeToString(iv)+""|"");
        System.out.println(""Encrypted Text="" + Base64.getEncoder().encodeToString(cipherTextInByteArr)+""|"") ;
        System.out.println(""Decrypted text="" + new String(plainTextInByteArr));
    }

}
</code></pre>

<p>In order to decode the output of the above java program, which javascript library should I use? I want to setup a secure websocket channel. 
I have tried using RSA algorithm. Unfortunately, it does not support the message size larger than 128 byte.</p>

<p>I follow the example in <a href=""https://stackoverflow.com/questions/13500368/encrypt-and-decrypt-large-string-in-java-using-rsa"">here</a>.  It work fine in java side, however, I don't know how to send SealedObject to javascript side, therefore, dead end again. </p>

<p>The java program output as follow:</p>

<pre><code>Key=hlnUjh4GM1PegSzl13YFQgI5+I1qcbsmqlBV8vDsVy0=|
IV=ZkqiRuDS7YUrjZMLRr/gfQ==|
Encrypted Text=HFROj40Qh9YagJAS+7saN2/ugqszCPpmjT9Qwy2yt9dCntSbpbYqTt/tW0ju5QO614+S9zQyOdBXFKtNdDew9Ouo9YkmRgRkjY7NNGyVbt+Z5CYCgcwpRmNUuH7Fqyat5H3hFSUi05UyLLA6lIa47wyP7jKsq0rtj1yHth8qN06aisB18s4Cf9YBPbUM72qXS+IcpKLMWEVVw7Q0qA91WRCt9y93SptNUme75D/qCKyym20UJ5f0ZCgijOnnsbWJKci1R179qZ8UthFBjqcZm88VmV1UuA7OsAvzxsyA7iVtwsf9u6UnrlOtoMTl41Q5nLod4unkdbomrXb6hDKhV9ThtCy1ZWPFHhKbEAPMdzUnmmBSwcuGSTKvdPJeHAWH|
Decrypted text=abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890
</code></pre>

<p>According to the post <a href=""https://stackoverflow.com/questions/20323765/aes-encryption-in-javascript-and-decrypting-in-java"">here</a>, the Crypto-JS can decode the Java output successfully.</p>

<p>However, the java program cannot decode the javascript output sucessfully.
Here is my javascript progarm</p>

<pre><code>    &lt;script src=""js/cryptojs/rollups/aes.js""&gt;&lt;/script&gt;
    &lt;script src=""js/cryptojs/components/mode-ctr-min.js""&gt;&lt;/script&gt;
    &lt;script language=javascript&gt;
          ..................
      var result;
      var encoded=CryptoJS.AES.encrypt(""hello"",
                                       keyArray,
                                       {
                                         iv: ivArray,
                                         mode: CryptoJS.mode.CTR,
                                         padding: CryptoJS.pad.Pkcs7
                                        });

      result=encoded.ciphertext.toString(CryptoJS.enc.Base64);
   &lt;/script&gt;
</code></pre>

<p>My java program:</p>

<pre><code>   byte iv[] = new byte[16];
   SecureRandom secRandom = new SecureRandom() ;
   secRandom.nextBytes(iv);       
   Cipher decipher = Cipher.getInstance(""AES/CTR/PKCS5PADDING"");
   decipher.init(Cipher.DECRYPT_MODE, aesKey,new IvParameterSpec(iv)); 
   byte[] cipherTextInByteArr =Base64.getDecoder().decode(encodedText);
   byte[] plainTextInByteArr = decipher.doFinal(cipherTextInByteArr);     
   String result=new String(plainTextInByteArr,""UTF-8"");
</code></pre>

<p>However,the output is ""hello???????"". 
   Is there something wrong?</p>
","<p>Finally, I get it works.
According to <a href=""https://stackoverflow.com/questions/7615743/java-aes-without-padding"">this post</a>, CTR mode does not require padding.
Therefore the javascript program look like:</p>

<pre><code>&lt;script src=""js/cryptojs/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script src=""js/cryptojs/components/mode-ctr-min.js""&gt;&lt;/script&gt;
&lt;script language=javascript&gt;
      ..................
  var result;
  var encoded=CryptoJS.AES.encrypt(""hello"",
                                   keyArray,
                                   {
                                     iv: ivArray,
                                     mode: CryptoJS.mode.CTR,
                                     padding: CryptoJS.pad.NoPadding
                                    });

  result=encoded.ciphertext.toString(CryptoJS.enc.Base64);
&lt;/script&gt;
</code></pre>

<p>And the java program look like:</p>

<pre><code>byte iv[] = new byte[16];
SecureRandom secRandom = new SecureRandom() ;
secRandom.nextBytes(iv);       
Cipher decipher = Cipher.getInstance(""AES/CTR/NoPadding"");
decipher.init(Cipher.DECRYPT_MODE, aesKey,new IvParameterSpec(iv)); 
byte[] cipherTextInByteArr =Base64.getDecoder().decode(encodedText);
byte[] plainTextInByteArr = decipher.doFinal(cipherTextInByteArr);     
String result=new String(plainTextInByteArr,""UTF-8"");
</code></pre>
","125","<javascript><java><aes><cryptojs>","-1","0","1","2017-12-01 06:46:43","47588000","3","3","2018278","","2017-12-01 06:23:20","2017-11-30 07:07:44",""
"56624032","How to decrypt image use crypto.js","<p>I had a difficult about decrypting image with crypto.js AES. </p>

<p>I need to read an encrypted image downloaded locally from the service, then I need to decrypt it. Now I failed to decrypt the picture. But if I just decrypt the base64 of the encrypted image,I will be able to decrypt it successfully.</p>

<p>So here's a demo that I'm doing in electron-vue</p>

<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;el-button @click=""encrypt""&gt;&lt;/el-button&gt;
        &lt;el-button @click=""decrypt""&gt;&lt;/el-button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import fs from 'fs';
import CryptoJS from 'crypto-js';

export default {
    data() {
        return {
            file: {},
            fileName: '',
            mydata: '',
            beforeBase64: '',
            afterBase64: ''
        };
    },
    methods: {
        async encrypt() {
            const eKey = '123';
            const filedir = '/Users/haoxiaoli/Documents/data/old.jpg';
            const c = fs.readFileSync(filedir);
            const data = new Buffer(c).toString('base64');
            let encrypted = CryptoJS.AES.encrypt(data, eKey).toString();
            this.mydata = encrypted;
            fs.writeFile('haoxl.jpg', encrypted, function (err) {
                if (err) {
                    console.log(err);
                }
                else {
                    console.log('save success');
                }
            });
        },
        decrypt() {
            const eKey = '123';
            const filedir = '/Users/haoxiaoli/Documents/data/haoxl.jpg';
            const c = fs.readFileSync(filedir);
            const data = new Buffer(c).toString('base64');

            // It was successful, but I need to decrypt a picture
            // let base64 = CryptoJS.AES.decrypt(this.mydata, eKey).toString(CryptoJS.enc.Utf8);

            let decrypted = CryptoJS.AES.decrypt(data, eKey);
            let base64 = new Buffer(decrypted.words).toString('base64');

            let img = new Image();
            img.src = 'data:image/jpeg;base64,' + base64;
            img.style.height = '600px';
            img.style.width = '600px';
            document.body.append(img);
        }
    }

};
&lt;/script&gt;
</code></pre>

<p>I expect to be able to successfully decrypt the encrypted image, please help me, thank you!</p>
","","125","<javascript><node.js><electron><cryptojs>","0","","0","2019-06-17 02:18:49","","0","","","","","2019-06-17 02:18:49",""
"39612652","Encrypting in a web worker make Safari crash with error 0x00000006","<p>I'm trying to encrypt a password in a Web Worker using CryptoJS, but this makes (ONLY) Safari to crash with this error:</p>

<pre><code>Error code:      0x00000006
</code></pre>

<p>The encryption works fine without the worker but this will make the app to freeze until the encryption is done (2-6 seconds).</p>

<p>Any ideas how I can solve this problem?</p>
","","124","<javascript><encryption><safari><web-worker><cryptojs>","0","","0","2016-09-21 13:23:20","","2","","607407","","2016-09-21 13:23:20","2016-09-21 09:30:18",""
"54091653","Decrypt with PHP, Encrypt with Javascript (cryptoJS)","<p>In my case, <strong>encrypted data is encrypted by cryptoJS</strong>, also I want to Decrypt using PHP.  </p>

<p>So <a href=""https://stackoverflow.com/questions/54091653/decrypt-with-php-encrypt-with-javascript-cryptojs"">I wrote a question about this problem</a>. However, I haven't found any solution.<br>
I tried several times to find the answer, but the decryption failed.</p>

<p>The data encrypted by CryptoJS provided by the server is encrypted as follows.</p>

<pre><code>var encryptedParam = CryptoJS.AES.encrypt(JSON.stringify({""user_pw"":""test""}), ""1234"");
</code></pre>

<p>The encrypted data in the code is a JSON object, and the key is <code>1234</code>.</p>

<p>Also, my PHP code as follows.  </p>

<pre><code>mcrypt_decrypt(
  MCRYPT_RIJNDAEL_128, 
  '1234', 
  '-------encrypted data---------', 
  MCRYPT_MODE_CBC, 
  mcrypt_create_iv(mcrypt_get_iv_size(
     MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC), MCRYPT_RAND)
);
</code></pre>

<p>But it does not work the way I want. No matter what, I can't make this to work. Please help me.</p>
","","122","<javascript><php><encryption><cryptojs>","1","","0","2019-01-10 06:46:24","","8","","1386680","","2019-01-10 06:46:24","2019-01-08 12:16:53",""
"41502332","getScript() and data uri base64 giving net::ERR_INVALID_URL","<p>I have some code that is encrypted, so I use <code>AES</code> and Base64</p>

<pre><code>var encrypted = ""(some aes encrypted base 64 encrypted data uri)""
var decrypted = CryptoJS.AES.decrypt(encrypted, ""(key)"");
var decstring = decrypted.toString(CryptoJS.enc.Utf8);
$.getScript( decstring, function() {
    console.log( ""Script was succesfully decrypted."" );
    call();
});
</code></pre>

<p>When i try this in a browser it says    </p>

<blockquote>
  <p>net::ERR_INVALID_URL</p>
</blockquote>

<p>I go and see the url given and it contains an extra <code>?_=1483692592022</code> which ruins the data URI. I go in the console and the value of my <code>decstring</code> variable is without the extra bit at the end, and every time I refresh the number changes.
This is very annoying, somebody please help me.</p>
","","122","<javascript><jquery><cryptojs>","0","","0","2017-01-06 09:12:21","","6","","519413","","2017-01-06 09:12:21","2017-01-06 09:11:29",""
"26298223","Encryption Algorithm returning different value in php and javascript","<p>In PHP</p>

<pre><code>&lt;?php
  $token = 'uid=pratik@gmail.com|ts=1412917909|hash=r1xWbgfHUxDLlppGYuOKQJdIM1MTrkryEArkMQx9ERw=|url=http://myintranet.com';
  $key = 'a1cbbb6eb5cb2c1c27a9f02a4434d3af';
  $token =  mb_convert_encoding( $token ,'UTF-16LE' );
  $blockSize = 16;
  $pad = $blockSize - (strlen($token) % $blockSize);
  $token .= str_repeat(chr($pad), $pad);
  $token = mcrypt_encrypt(MCRYPT_RIJNDAEL_128,$key, $token, MCRYPT_MODE_CBC, $iv);

  $token = base64_encode($token);
  echo ""\n This is the token $token \n"";
?&gt;
</code></pre>

<p>Output -: </p>

<pre><code> This is the token TXz3UEgAdjGhyriNGcMJBUk4QcW3dA7rttzjbKztw19X8bSIMDZt8s6uSQy2OP5QcSpJuReKv73wFXzPyCXt05CNY6XWlx9Lfrv6Nosj0+4mHdD7/Wvx0QWqxuuv5qv4sgtgSif59Wy/ZAoYhfH8yzN/3hWnx6zzOrV6jxyDttmffk1zcBwtJ3X41mMVbPLOd1/2K3ZYxCcJ1VxESFDNB4N1okvGMRkCM0tL77oZiKv+n6CP9FEgKivCfvytFB8JWc9K++8vbLdV/iGgkEa7h0pfAZtYpryQQjFzqLx8NSQ= 
</code></pre>

<p>In Javascript </p>

<pre><code>'use strict';

var CryptoJS = require(""crypto-js"");

String.prototype.repeat = function( num )
{
    return new Array( num + 1 ).join( this );
}

function encodeUTF16LE(str) {
    var out, i, len, c;
    var char2, char3;

    out = """";
    len = str.length;
    i = 0;
    while(i &lt; len) {
        c = str.charCodeAt(i++);
        switch(c &gt;&gt; 4)
        {
          case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
            // 0xxxxxxx
            out += str.charAt(i-1);
            break;
          case 12: case 13:
            // 110x xxxx   10xx xxxx
            char2 = str.charCodeAt(i++);
            out += String.fromCharCode(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F));
            out += str.charAt(i-1);
            break;
          case 14:
            // 1110 xxxx  10xx xxxx  10xx xxxx
            char2 = str.charCodeAt(i++);
            char3 = str.charCodeAt(i++);
            out += String.fromCharCode(((c &amp; 0x0F) &lt;&lt; 12) | ((char2 &amp; 0x3F) &lt;&lt; 6) | ((char3 &amp; 0x3F) &lt;&lt; 0));
            break;
        }
    }

    var byteArray = new Uint8Array(out.length * 2);
    for (var i = 0; i &lt; out.length; i++) {
        byteArray[i*2] = out.charCodeAt(i); // &amp; 0xff;
        byteArray[i*2+1] = out.charCodeAt(i) &gt;&gt; 8; // &amp; 0xff;
    }

    return String.fromCharCode.apply( String, byteArray );
}

var token = 'uid=pratik@gmail.com|ts=1412917909|hash=r1xWbgfHUxDLlppGYuOKQJdIM1MTrkryEArkMQx9ERw=|url=http://myintranet.com';
var key = 'a1cbbb6eb5cb2c1c27a9f02a4434d3af';
var blockSize = 16;
token =  encodeUTF16LE(token);
var pad = blockSize - (token.length % blockSize);

token = token + (String.fromCharCode(pad)).repeat(pad);

token = CryptoJS.AES.encrypt(token, key,
    {   iv: iv,
        mode: CryptoJS.mode.CBC
    });

console.log(""\n This is the token "" + token + ""\n"");

token = token.ciphertext.toString(CryptoJS.enc.Base64);
console.log(""\n This is the token "" + token + ""\n"");
</code></pre>

<p>Output</p>

<pre><code>This is the token U2FsdGVkX19iQjVHkx/vmhljCsRyTBUA0QFJ8I+pPvxAa2dK6iO4r9FUw2Um2j0H+iyXZ/G0UO0fhJTFzfJEfS1cMfAaq0Z7UBUpVhtrH5IArr2F3BI6yWC8Kpo4ZimyW+xnWp0BYUpLUNQTLsFooiIqPHv3s9HHMe3k0altm6ou1pAKaIr8IAY1OzIDTbaRO55mPf0rU6Z2XTLGR6kYoAx9Lk4dZ3RA66cynXWFMuHznL0fik3phZ8cUiKd/Twquil97YHT+CB/1ulxEBD17VQvnsCJI1lYNn9dyWAUG96KMgGk3jFxiW9eRzV5Poywnt0QNaRpmZiG41KNFmtMtw==


This is the token GWMKxHJMFQDRAUnwj6k+/EBrZ0rqI7iv0VTDZSbaPQf6LJdn8bRQ7R+ElMXN8kR9LVwx8BqrRntQFSlWG2sfkgCuvYXcEjrJYLwqmjhmKbJb7GdanQFhSktQ1BMuwWiiIio8e/ez0ccx7eTRqW2bqi7WkApoivwgBjU7MgNNtpE7nmY9/StTpnZdMsZHqRigDH0uTh1ndEDrpzKddYUy4fOcvR+KTemFnxxSIp39PCq6KX3tgdP4IH/W6XEQEPXtVC+ewIkjWVg2f13JYBQb3ooyAaTeMXGJb15HNXk+jLCe3RA1pGmZmIbjUo0Wa0y3
</code></pre>

<p>I think the problem is CryptoJS.AES.encrypt where I am not passing it the correct configuration?</p>

<p>Really stuck on this, so if you have any suggestions, I'd like to know.</p>
","<p>In both cases the key is not treated in the way you expect. <code>'a1cbbb6eb5cb2c1c27a9f02a4434d3af'</code> is the hex representation of a 16 byte (= 128 bit) key, that can be used for AES128. </p>

<p><code>mcrypt</code> does not know its getting a hex representation and treats it as 32 byte string and - IIRC - throws away everything except its first 16 bytes ('a1cbbb6eb5cb2c1c'). You need to unhexlify the key to get the raw bytes: <a href=""https://stackoverflow.com/a/13066269/371137""><code>$key=pack('H*', 'a1cbbb6eb5cb2c1c27a9f02a4434d3af')</code></a>.</p>

<p>CryptoJS also does not know it's presented a hex representation of the key and <a href=""https://code.google.com/p/crypto-js/#The_Cipher_Input"" rel=""nofollow noreferrer"">treats it as password instead, which is used as input to PBKDF2</a>. The library has its <a href=""https://code.google.com/p/crypto-js/#Encoders"" rel=""nofollow noreferrer"">own unhexlify routines</a>: <code>var key = CryptoJS.enc.Hex.parse('a1cbbb6eb5cb2c1c27a9f02a4434d3af');</code> The resulting <code>WordArray</code> will be treated by CryptoJS as binary key input.</p>
","122","<encryption><aes><mcrypt><cryptojs>","0","2","1","2014-10-10 22:21:05","","2","","1970079","","2014-10-10 17:26:25","2014-10-10 11:20:29",""
"52148156","How to use hash_hmac function in node js","<p>Recently I have used same code on PHP and it's working fine but when I tried Node Js, it's not working for me. Please check once: </p>

<p>PHP </p>

<pre><code>$signature = $ACCID . ""POST"" . strtolower(urlencode($url)).$requestContentBase64String; 
$hmacsignature = base64_encode(hash_hmac(""sha256"", $signature, base64_decode($APIKey), true)); 
</code></pre>

<p>NODE CODE : </p>

<pre><code>var signature = ACCID+""POST""+encodeURI(url).toLowerCase()+requestContentBase64String; 
var hmacsignature = base64.encode(crypto.createHmac('sha256', APIKey).update(signature).digest('base64'))
</code></pre>

<p>Please check what's wrong in this code. </p>
","<p>Your second line has two mistakes:</p>

<ol>
<li>PHP APIKey is <code>BASE64_DECODE(APIKey)</code> while in Node.js code it is just <code>APIKey</code></li>
<li>PHP hmacsignature is <code>BASE64(HEX(HMAC))</code> while in Node.js code it is <code>BASE64(BASE64(HMAC))</code></li>
</ol>

<p>Try this:</p>

<pre><code>var hmacsignature = crypto.createHmac('sha256', Buffer.from(APIKey, 'base64')).update(signature).digest('base64')
</code></pre>
","121","<php><node.js><md5><cryptojs>","0","0","1","2018-09-03 13:50:52","","0","","2664350","","2018-09-03 13:50:52","2018-09-03 10:45:24",""
"54102651","how to decrypt in nodejs which is encrypted using JAVA","<p>im trying to convert java lambda into javascript lamda. want to convert these encrypt and decrypt method which is written in java to node js or javascript.
I have tried to implement using crpto in node </p>

<p>keys are like this </p>

<pre><code>private static String CIPHER_NAME = ""AES/CBC/PKCS5PADDING"";
private static int CIPHER_KEY_LEN = 16; //128 bits
</code></pre>

<p><strong>encrypt method</strong></p>

<pre><code> private String encrypt(String key, String iv, String data) {
        try {
            if (key.length() &lt;CIPHER_KEY_LEN) {
                int numPad = CIPHER_KEY_LEN - key.length();

                for(int i = 0; i &lt; numPad; i++){
                    key += ""0""; //0 pad to len 16 bytes
                }

            } else if (key.length() &gt;CIPHER_KEY_LEN) {
                key = key.substring(0, CIPHER_KEY_LEN); //truncate to 16 bytes
            }


            IvParameterSpec initVector = new IvParameterSpec(iv.getBytes(""ISO-8859-1""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""ISO-8859-1""), ""AES"");

            Cipher cipher = Cipher.getInstance(CIPHER_NAME);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, initVector);

            byte[] encryptedData = cipher.doFinal((data.getBytes()));

            String base64_EncryptedData = Base64.getEncoder().encodeToString(encryptedData);
            String base64_IV = Base64.getEncoder().encodeToString(iv.getBytes(""ISO-8859-1""));

            return base64_EncryptedData + "":"" + base64_IV;

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }
</code></pre>

<p><strong>decrypt method</strong></p>

<pre><code>private String decrypt(String key, String data) {
    try {
        if (key.length() &lt; CIPHER_KEY_LEN) {
            int numPad = CIPHER_KEY_LEN - key.length();

            for(int i = 0; i &lt; numPad; i++){
                key += ""0""; //0 pad to len 16 bytes
            }

        } else if (key.length() &gt; CIPHER_KEY_LEN) {
            key = key.substring(0, CIPHER_KEY_LEN); //truncate to 16 bytes
        }

        String[] parts = data.split("":"");

        IvParameterSpec iv = new IvParameterSpec(Base64.getDecoder().decode(parts[1]));
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""ISO-8859-1""), ""AES"");

        Cipher cipher = Cipher.getInstance(CIPHER_NAME);
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

        byte[] decodedEncryptedData = Base64.getDecoder().decode(parts[0]);

        byte[] original = cipher.doFinal(decodedEncryptedData);

        return new String(original);
    } catch (Exception ex) {
        ex.printStackTrace();
    }

    return null;
}
</code></pre>

<p>I have used 
this is the solution i made but seems it not working cause i encrypted this using a java code and using node's javascript code to decrypt it.</p>

<pre><code>function decrypt (messagebase64, keyBase64, ivBase64) {

    var key = Buffer.from(keyBase64, 'base64');
    var iv = Buffer.from(ivBase64, 'base64');

    var decipher = crypto.createDecipheriv(getAlgorithm(keyBase64), key, iv);
    decipher.setAutoPadding(false);
    decipher.update(messagebase64, 'base64');
    return decipher.final();
}
</code></pre>

<p>find the alogorithm i use this and adding padding if the key is not long enough but this give error that saying length is not enough. </p>

<pre><code>function getAlgorithm(keyBase64) {

    if(keyBase64.length&lt;CIPHER_KEY_LEN){
        var padding = CIPHER_KEY_LEN-keyBase64.length;
        for(var i=0;i&lt;padding;i++){
            keyBase64+=""0"";
        }
    }else if(keyBase64.length&gt;CIPHER_KEY_LEN){
        keyBase64 =keyBase64.substring(0, CIPHER_KEY_LEN)
    }

    var key = Buffer.from(keyBase64, 'base64');

    switch (key.length) {
        case 16:
            return 'aes-128-cbc';
        case 32:
            return 'aes-256-cbc';

    }

    throw new Error('Invalid key length: ' + key.length);
}
</code></pre>
","<p>after struggling for a while i have implemented encrypted method and decrypt method which will be identical to java.</p>

<p><strong>decrypt method</strong></p>

<pre><code>function decrypt (messagebase64, keyBase64, ivBase64) {

    if(keyBase64.length&lt;CIPHER_KEY_LEN){
        var padding = CIPHER_KEY_LEN-keyBase64.length;
        for(var i=0;i&lt;padding;i++){
            keyBase64+=""0"";
        }
    }else if(keyBase64.length&gt;CIPHER_KEY_LEN){
        keyBase64 =keyBase64.substring(0, CIPHER_KEY_LEN)
    }


    var key = Buffer.from(keyBase64, 'latin1');
    var iv = Buffer.from(ivBase64, 'base64');

    var encryptdata = new Buffer(messagebase64, 'base64');

    var decipher = crypto.createDecipheriv('aes-128-cbc', key, iv),
        decoded = decipher.update(encryptdata, 'base64', 'utf8');

    decoded += decipher.final('utf8');


    return decoded

}
</code></pre>

<p><strong>encrypt method</strong></p>

<pre><code>function encrypt(plainText, keyBase64, ivBase64) {

    if(keyBase64.length&lt;CIPHER_KEY_LEN){
        var padding = CIPHER_KEY_LEN-keyBase64.length;
        for(var i=0;i&lt;padding;i++){
            keyBase64+=""0"";
        }
    }else if(keyBase64.length&gt;CIPHER_KEY_LEN){
        keyBase64 =keyBase64.substring(0, CIPHER_KEY_LEN)
    }

    var key = Buffer.from(keyBase64, 'latin1');
    var iv = Buffer.from(ivBase64,'latin1');
    var encoded_base64_iv= iv.toString('base64');

    var cipher2 = crypto.createCipheriv('aes-128-cbc', key, iv);
    cipher2.write(plainText);
    cipher2.end();

    var cipher_text = cipher2.read();
    var encodedString = cipher_text.toString('base64');

    var final_encrypted_data = encodedString+"":""+encoded_base64_iv;

    return final_encrypted_data.toString();
};
</code></pre>
","119","<javascript><java><node.js><cryptojs>","1","0","1","2019-01-16 06:46:38","54211713","2","","6790065","","2019-01-10 06:28:19","2019-01-09 02:55:29",""
"55767799","TypeError: Data must be a buffer","<p>I have an http request in which I want to pass some sensitive data so I tried to encrypted these data.
In my React Native app I generated a pair of keys with react-native-rsa-native and I crypte my string with the public key via the function RSA.encrypt(my string, my public key). </p>

<p>After this I send the generated crypt data in my http request and I try to decrypt it in my node.js environment (Google Cloud Functions). For this I use the Crypto module.</p>

<p>I import it with:</p>

<pre><code>const crypto = require('crypto');
</code></pre>

<p>And I try to decrypt my data with the RSA private key generated in my react-native module :</p>

<pre><code>crypto.privateDecrypt(rsaPrivateKey, myCryptedString)
</code></pre>

<p>But I obtain the error:</p>

<blockquote>
  <p>TypeError: Data must be a buffer
      at TypeError (native)
      at Object.privateDecrypt (crypto.js:375:12)
      at exports.createPaymentMethod.functions.https.onRequest (/user_code/index.js:928:10)
      at cloudFunction (/user_code/node_modules/firebase-functions/lib/providers/https.js:37:41)
      at /var/tmp/worker/worker.js:783:7
      at /var/tmp/worker/worker.js:766:11
      at _combinedTickCallback (internal/process/next_tick.js:73:7)
      at process._tickDomainCallback 
  (internal/process/next_tick.js:128:9)</p>
</blockquote>

<p>Does someone have a solution to my issue ?</p>
","<p>According to the <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_privatedecrypt_privatekey_buffer"" rel=""nofollow noreferrer"">documentation</a>, the ciphertext should be an instance of <code>Buffer</code> rather than a <code>String</code>, therefore you can try to wrap the ciphertext into a buffer:</p>

<p><code>crypto.privateDecrypt(rsaPrivateKey, Buffer.from(myCryptedString))</code></p>
","118","<node.js><google-cloud-functions><aes><cryptojs>","0","1","1","2019-04-19 21:07:34","55767875","0","","","","","2019-04-19 20:59:15",""
"50466859","Encrypt video with CryptoJS, store it in Firebase and watch it decrypted in HTML5 video","<p>I'm trying to encrypt a video using the CryptoJS library. The goal is to encrypt it and store it in Firebase Storage. Later, when you want to visualize, it is decrypted and added as an url to the HTML video tag. I can't get the video displayed after decrypting it, any idea of what the problem is?  I have the feeling that the problem is with treating the output of the cipher as a string. I don't know in what way I should treat it so that it continues to maintain the properties of a video file. Thanks in advance.</p>

<p>The current code is:</p>

<pre><code>    //Encrypt and upload function
    function almacenarFicheroGrabacionVideo(file) {
        let storageRef = firebase.storage().ref('videos/' + file.name);
        let reader = new FileReader();
        reader.onload = function () {
          let read = reader.result;
          let task = storageRef.putString(CryptoJS.AES.encrypt(read, getCookie('key')).toString());
          task.on('state_changed', function progress(snapshot) {
          }, function error(err) {
            console.log(err);
          }, function complete() {
            console.log(""fichero subido"");
          });
        };
        reader.readAsText(file);
      }

//Decrypt and visualize video
  $scope.verVideo = function() {
    firebase.storage().ref('videos/').child('Blurred Bokeh Video 2.mp4').getDownloadURL().then(function (url) {
      fetch(url)
        .then(res =&gt; res.blob()) // Gets the response and returns it as a blob
        .then(blob =&gt; {
          let reader = new FileReader();
          reader.onload = function () {
            let fileDown = CryptoJS.AES.decrypt(reader.result, getCookie('clave')).toString(CryptoJS.enc.Utf8);
            var videoNode = document.getElementsByTagName('video')[0];
            let blob = new Blob([fileDown], {type: ""video/mp4""});
            let url  = URL.createObjectURL(blob);
            let element = document.createElement('a');
            element.setAttribute('href', url);
            element.setAttribute('download', 'Blurred Bokeh Video 2.mp4');
            element.style.display = 'none';
            document.body.appendChild(element);
            element.click();
            document.body.removeChild(element);
          };
          reader.readAsText(blob);
        });
    }).catch(function (error) {
      // Handle any errors
      console.log(error);
    });
  };
</code></pre>
","","117","<angularjs><firebase><html5-video><firebase-storage><cryptojs>","1","","0","2018-05-23 13:36:33","","0","","6304714","","2018-05-23 13:36:33","2018-05-22 11:44:47",""
"40688305","Javascript AES Encryption returning too many characters","<p>I am trying to implement a PHP encryption script into JavaScript. My PHP script returns a 128 character string, while my Javascript based one returns 160 characters. The first 128 characters of the JavaScript based version match the PHP based version.</p>

<pre><code>function pkcs5_pad ($text, $blocksize){
  $pad = $blocksize - (strlen($text) % $blocksize);
  return $text . str_repeat(chr($pad), $pad);
}
$skey = ""somekey"";
$ivKey = ""someIVKey"";
$input = ""empid=xxxxxx;timestamp=Sat, 19 Nov 2016 00:33:03 UTC"";

try {
  $size = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128,'cbc');
  echo strlen($input) . ""\n"";
  $input = pkcs5_pad($input, $size);
  echo strlen($input) . ""\n"";
  $cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');

  $key = pack('H*', $skey);
  $iv = pack('H*', $ivKey);
  # The key size used is 16, 24 or 32 bytes - for AES-128, 192 and 256 respectively

  if (mcrypt_generic_init($cipher, $key, $iv) != -1){
    $encrypted = mcrypt_generic($cipher, $input);
    mcrypt_generic_deinit($cipher);
    $encryptedString = bin2hex($encrypted);
  }
  echo $encryptedString . ""\n"";
  echo strlen($encryptedString) . ""\n"";
} catch (Exception $ex) {
  echo $ex-&gt;getMessage();
}
</code></pre>

<p>The length <code>strlen($encryptedString)</code> here gives me 128 characters.</p>

<p>My JavaScript based version uses CryptoJS to create looks like this</p>

<pre><code>var aesKey = ""somekey"";
var ivKey = ""someIVKey"";

function pkcs5_pad (text, blocksize){
  console.log(text.length);
  var pad = blocksize - (text.length % blocksize);
  console.log(""pad:"" + pad);
  return text + str_repeat(chr(pad), pad);
}

input = ""empid=xxxxxx;timestamp=Sat, 19 Nov 2016 00:33:03 UTC"";

var size = 16;
console.log(input.length);
var input = pkcs5_pad(input, size);
console.log('""' + input + '""');
console.log(input.length);

var key = CryptoJS.enc.Hex.parse(aesKey);
var iv = CryptoJS.enc.Hex.parse(aesIV);

var encryptedString = CryptoJS.AES.encrypt(input,key,{iv: iv});
console.log(encryptedString.ciphertext.toString().length);
encryptedString = encryptedString.ciphertext.toString();
</code></pre>

<p>Everything matches, including the string lenght before and after pkcs5_pad.  I'm using some additional JavaScript code from locutus.io to call str_repeat, and chr.  Here <code>encryptedString.ciphertext.toString().length</code> returns 160 characters and the first 128 match that of my PHP script.</p>

<p>My understanding is that version 3 of CryptoJS uses CBC mode, but I've also set the mode explicitly to CBC to no avail.  I've also returned the encrypted string as hex</p>

<pre><code>encryptedString = encryptedString.ciphertext.toString(CryptoJS.enc.Hex);
</code></pre>

<p>Where am I going wrong? </p>

<p><strong>EDIT</strong>
The output of the PHP version is</p>

<p>86b1c9874069129d0852eade01eb753a176a1c6155c4af3ac447ae0a5350b92c3447f95be9c4f8cdbf14503696bcaa16e6307c1605a2cac503239db9d1ac6fb3</p>

<p>The output of the JavaScript version is</p>

<p>86b1c9874069129d0852eade01eb753a176a1c6155c4af3ac447ae0a5350b92c3447f95be9c4f8cdbf14503696bcaa16e6307c1605a2cac503239db9d1ac6fb33051208849788f8a90db1cbe2494cac7</p>
","<p>The extra 32 characters are hex encoding of 16 bytes and that is the padding. The Java is adding padding, the PHP is not.</p>

<p>Note that mcrypt does not use standard PKCS#7 (ne PKCS#5) padding.</p>

<p>Good encryption libraries will have a padding option and add the padding on encryption and remove it on decryption. You should not have to do your own padding.</p>
","116","<javascript><php><encryption><mcrypt><cryptojs>","1","1","1","2016-11-19 04:15:00","40689121","4","","1072830","","2016-11-19 02:21:32","2016-11-19 01:29:04",""
"20491061","UTF-8 encoding in Java giving contrasting result","<p>I have the following encoding in the javascript file:</p>

<pre><code>var words = CryptoJS.enc.Utf8.parse(""cy03ISBnqOMGQZoAvpAszw==""); 
</code></pre>

<p>and it gives me out put as - (I have checked it on <a href=""http://jsfiddle.net/9Hyfd/"" rel=""nofollow"">http://jsfiddle.net/9Hyfd/</a>)</p>

<pre><code>result: 637930334953426e714f4d47515a6f41767041737a773d3d 
</code></pre>

<p>If I try to write the same thing in JAVA it gives me output as:</p>

<pre><code>[99, 121, 48, 51, 73, 83, 66, 110, 113, 79, 77, 71, 81, 90, 111, 65, 118, 112, 65, 115, 122, 119, 61, 61]
</code></pre>

<p>Here is the code:</p>

<pre><code>import java.util.*;
import java.lang.*;
import java.io.*;

class convertsample
{
    public static void main (String[] args)
    {

    String a = ""cy03ISBnqOMGQZoAvpAszw=="";
    byte[] u = a.getBytes(""UTF-8"");   
        //System.out.println(u); 
        System.out.println(Arrays.toString(u));
       // String s = new String(u, ""US-ASCII"");
        //System.out.println(s); 
    }
}
</code></pre>

<p>What is wrong with the java code? </p>
","","115","<java><javascript><encoding><utf-8><cryptojs>","0","","0","2013-12-10 10:15:05","","2","","1737813","","2013-12-10 09:57:03","2013-12-10 09:50:43",""
"55929028","subtleCrypto.encrypt() fails in MS Edge but work in Chome","<p>I am trying to setup a client-side script that will encrypt files &lt;2MB in size to be uploaded to a SharePoint document library. The encryption is necessary for files that contain personnally idenfiable information (PII) such as social security numbers and the like. The code below works perfectly in Google Chrome but fails the .encrypt(...) portion in MS Edge. </p>

<p>Edge will create all the needed results/buffers for the .encrypt(...) function; however, it returns a ""Could not complete the operation due to error 8070000b."" result. I've seen some other boards talk about Edge and needing to include a ""hash"" parameter in both the .generateKey(...) and .encrypt(...) scripts; however, that hasn't had any effect on my problem.</p>

<p>What am I missing?</p>

<pre><code>file = document.getElementsByName('aFile')[0].files[0]
function encrypt() {
  window.crypto.subtle.generateKey(
    {
      name: ""AES-GCM"",
      length:256,
    },
    true,
    [""encrypt"", ""decrypt""]
  )
  .then(function(key) {
    pks = key
    crypto.subtle.exportKey( ""raw"", key)
    .then(function(buf) { 
      newKey = new Int8Array(buf)
      exportedAsBase64 = _arrayBufferToBase64(buf);
    })
    .then(function() {
      reader = new FileReader()
      reader.readAsDataURL(file)
      reader.onload = function() {
        fileString = reader.result,
          n=fileString.indexOf("";base64,"") + 8;
        X = _base64ToArrayBuffer(fileString.substring(n))
        crypto.subtle.encrypt({name: 'AES-GCM', iv: newKey}, pks, X)
        .then( function(buf) {
           newFile = new Int8Array(buf) 
           encrypted = _arrayBufferToBase64(buf);
        })
        .catch(function (err) {
          console.error(err);
        }); 
      }
    })
  })
}

function _base64ToArrayBuffer(base64) {
    var binary_string =  window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array( len );
    for (var i = 0; i &lt; len; i++)        {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}
</code></pre>
","","113","<javascript><google-chrome><microsoft-edge><cryptojs>","2","","0","2019-04-30 21:42:46","","2","1","","","","2019-04-30 21:42:46",""
"54036722","Facing problem within salt in CryptoJs with Laravel and Angular 6","<p>In Laravel5, I have encrypted message through the following salt and passed the salt value in API with base64 encoded:</p>

<pre><code>    $data = [];
    $cipher = env('APP_CIPHER'); // AES-256-CBC
    $iv = random_bytes(openssl_cipher_iv_length($cipher));
    $key = env('APP_KEY'); // XXXXXZNUK5nhIMBbBEwKISqQ9ioXXXXX
    $value = \openssl_encrypt(
        json_encode($response),
        $cipher, $key, 0, $iv
    );
    $data['data'] = $value;
    $data['salt'] = base64_encode($iv);

    return $data;
</code></pre>

<p>In Angular 6, I want to decrypt the message. I did the following code but its showing me <code>malformed utf-8 data</code>:</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse('XXXXXZNUK5nhIMBbBEwKISqQ9ioXXXXX');
var salt = atob(this.countryList.response.salt);
var iv = CryptoJS.enc.Utf8.parse(salt);
var decrypted = CryptoJS.AES.decrypt(this.countryList.response.data, key, {
keySize: 128 / 8,
iv: iv,
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7
});
console.log('utf8 = ' + decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>The message/ values are stored into <code>this.countryList.response.data</code></p>

<p>The base64 encoded salt value I received in <code>this.countryList.response.salt</code>.</p>

<p>Any mistake in my code?</p>

<p>Please note, If I do <code>$iv = '1212121212121212';</code> in Laravel and do <code>var salt = '1212121212121212';</code> in Angular, it returns the expected result.</p>
","<p>I made a mistake as above. I did the following :</p>

<pre><code>var salt = (this.countryList.response.salt);
var iv = CryptoJS.enc.Base64.parse(salt);
</code></pre>

<p>Note, I removed the atob function too.</p>

<p>So instead of <code>Utf8</code>, it should be <code>Base64</code>. So, the Angular code will be:</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse('XXXXXZNUK5nhIMBbBEwKISqQ9ioXXXXX');
var salt = (this.countryList.response.salt);
var iv = CryptoJS.enc.Base64.parse(salt);
var decrypted = CryptoJS.AES.decrypt(this.countryList.response.data, key, {
keySize: 128 / 8,
iv: iv,
mode: CryptoJS.mode.CBC,
padding: CryptoJS.pad.Pkcs7
});
console.log('utf8 = ' + decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","110","<angular><laravel><cryptojs>","1","1","1","2019-01-04 10:56:39","","0","","","","","2019-01-04 10:03:39",""
"57059289","JSON JWT Token Object - Malformed UTF-8 data - Crypto JS","<p>I have encrypt my token and data json object like this and that's redirect to a subdomain web app with a guard angular :</p>

<pre><code>// access website Wordpress/jQuery/Crypto-js 3.1.9-1
let encrypted = CryptoJS.AES.encrypt(JSON.stringify(response), SECRET_PASSPHRASE);
window.location.href = APP_HOME + ""?access="" + encrypted;
</code></pre>

<p>The redirection work's as well but I have this error when my guard try to deycrpt the ""access"" param.</p>

<pre><code>Error: Malformed UTF-8 data
at Object.stringify (core.js:478)
at WordArray.init.toString (core.js:215)
at AuthGuard.push../src/app/_guards/auth/auth.guard.ts.AuthGuard.decryptData (auth.guard.ts:62)
at AuthGuard.push../src/app/_guards/auth/auth.guard.ts.AuthGuard.canActivate
</code></pre>

<p>My function to decrypt - Angular WebApp - I try a lot of variations because I find a lot of persons to have the same bug with this error ""Malformed UTF-8 data'.</p>

<pre><code>/* Angular - Crypto-js 3.1.9-1 */
import * as CryptoJS from 'crypto-js'; 
...
decryptData(data) {
  try {
    const bytes = CryptoJS.AES.decrypt(data.toString(), this.encryptSecretKey);
    let decryptedData = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
    //let aa = CryptoJS.enc.Utf8.stringify(bytes)
    // let aa = bytes.toString(CryptoJS.enc.Utf8);
    console.log('decryptedData ==&gt;', decryptedData);
    return JSON.stringify(decryptedData);
  } catch (e) {
    console.log(e);
  }
}
</code></pre>
","","106","<javascript><json><encryption><utf-8><cryptojs>","0","","0","2019-07-16 15:09:53","","4","","9269043","","2019-07-16 15:09:53","2019-07-16 14:11:39",""
"26875588","Different AES implementations don't agree","<p>I have to encrypt a piece of data using both C#, and Javascript. I'm using Bouncy Castle in C# and Crypto-JS in Javascript.</p>

<p>The problem I am facing is that even though all the parameters are equal (OFB with no padding, and the IV is always 0), I don't get the same output with both libraries. The consequence of that is also that I can't decrypt with one what was encrypted with the other.</p>

<p>Here is my C# code for encrypting:</p>

<pre><code>byte[] iv = new byte[16];

BufferedBlockCipher aes = new BufferedBlockCipher(new OfbBlockCipher(new AesEngine(), 16));
ParametersWithIV ivAndKey = new ParametersWithIV(new KeyParameter(stretchedKey), iv);
aes.Init(true, ivAndKey);

int minSize = aes.GetOutputSize(privateKey.Length);
byte[] outBuf = new byte[minSize];
int length1 = aes.ProcessBytes(privateKey, 0, privateKey.Length, outBuf, 0);
int length2 = aes.DoFinal(outBuf, length1);

byte[] encryptedKey = iv.Concat(outBuf.Take(length1 + length2)).ToArray();
</code></pre>

<p>My Javascript code is the following for encrypting (try it on JSFiddle here: <a href=""http://jsfiddle.net/gCHAG/424/"" rel=""nofollow"">http://jsfiddle.net/gCHAG/424/</a>):</p>

<pre><code>var key = Crypto.util.hexToBytes('59b50e345cab8b6d421b161918ea3fbd7e5921eea7d43d1ac54fa92cca452bb5');
var iv  = Crypto.util.hexToBytes('00000000000000000000000000000000');
var message = Crypto.util.hexToBytes('3b16601d0a7e283c1f24d30ec214676885096cb0bbf3998012a2be87c5a58d89');

var encrypted = Crypto.AES.encrypt(message, key, { iv: iv, asBytes: true, mode: new Crypto.mode.OFB(Crypto.pad.NoPadding) });
</code></pre>

<p>I get the following from the bouncy castle implementation: <code>578934dbb576dc986a531f09e8d5abd5b01dc1bfd3ededd222ff8aa6e4bfdbf2</code></p>

<p>And the following from Crypto-JS: <code>578946591ce2d787cbe41bec77a58dac66e6007fb722b1af847ecc3bf4212cea</code></p>

<p>Note how the first two bytes are the same, but then everything else is different.</p>

<p>To top it all up, when trying on an online tool, I get a third output (see <a href=""http://aes.online-domain-tools.com/link/bd243g1VXbD7LUAS/"" rel=""nofollow"">http://aes.online-domain-tools.com/link/bd243g1VXbD7LUAS/</a>): <code>57804D64A8...</code></p>

<p>I went through everything several times, but I don't see why I get different outputs.</p>
","<p>CryptoJS seems to use an output of 128 bits per block for the key stream. You specify 16 <em>bits</em> per block for Bouncy. As 8 or 128 bits per block are common for OFB, and since 128 is the recommended output size, I guess you are just confusing bits and bytes in the Bouncy code.</p>

<p>If you specify <code>new OfbBlockCipher(new AesEngine(), 128)</code> you should be OK.</p>
","105","<javascript><c#><aes><bouncycastle><cryptojs>","1","1","1","2014-11-11 23:36:10","26876638","1","","","","","2014-11-11 22:13:49",""
"53587930","Encrypt with crypto-js and decrypt with PHP sodium","<p>I'm trying to encrypt a string client-side with typescript using the crypto-js library and then decode it server side with PHP and libsodium.  I'm encrypting like so:</p>

<pre class=""lang-js prettyprint-override""><code>/// &lt;reference types=""crypto-js"" /&gt;
import * as CryptoJS from 'crypto-js';

const key = CryptoJS.enc.Utf8.parse('length 32 hex string here');
const iv = CryptoJS.enc.Utf8.parse('length 32 hex string here');
const encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(""...""), key, {
    keySize: 32,
    iv: iv
});

const base64 = btoa(encrypted.ciphertext);
</code></pre>

<p>Many of the examples I've seen instead convert to base 64 via <code>encrypted.ciphertext.toString(CryptoJS.enc.Base64)</code> but I get compiler errors with that because <code>toString</code> doesn't take a parameter.</p>

<p>I then try to decode it in PHP like so:</p>

<pre class=""lang-php prettyprint-override""><code>$key = pack(""H*"", ""same length 32 hex string here"");

$decoded = base64_decode(""base 64 string here"");

if (mb_strlen($decoded, '8bit') &lt; (SODIUM_CRYPTO_SECRETBOX_NONCEBYTES + SODIUM_CRYPTO_SECRETBOX_MACBYTES)) {
    throw new Exception('truncated');
}

$nonce = mb_substr($decoded, 0, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, '8bit');
$ciphertext = mb_substr($decoded, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, null, '8bit');

$plain = sodium_crypto_secretbox_open($ciphertext, $nonce, $key);

if ($plain === false) {
    throw new Exception('the message was tampered with in transit');
}

sodium_memzero($ciphertext);
sodium_memzero($key);
</code></pre>

<p>When I run that I get this exception as soon as it hits the call to <code>sodium_crypto_secretbox_open</code>:</p>

<blockquote>
  <p>Uncaught SodiumException: key size should be SODIUM_CRYPTO_SECRETBOX_KEYBYTES</p>
</blockquote>
","","103","<cryptojs><libsodium>","0","","0","2018-12-03 05:35:19","","0","","1455351","","2018-12-03 05:35:19","2018-12-03 05:26:22",""
"53881717","PHP hash_hmac() binary output with crypto-js","<p>I'm developing a project with an app (expo react native) and a server Laravel 5.1, using <code>oauth2-server</code>.<br>
Now I need to send Authorization header with format</p>

<pre><code>Mac id=""access_token"" ts=""timestamp"" nonce=""random_string"" mac=""signature""
</code></pre>

<p>My problem is the <code>signature</code> is not match with calculated signature from oauth-server. I also compared all necessary parts of signarure (request URI, Host and Port). They are matched<br></p>

<p>I'm trying to generate encoded base64 with <code>crypto-js</code>. Result string must be equal with result of <code>hash_hmac()</code> in PHP. Below is example<br></p>

<pre><code>$phpString = base64_encode(
    hash_hmac(
        'sha256', 'ANY STRING', 'HMAC HASH KEY', true
    )
);
// Result: cOeqRLpcqCUyluyY/Y4yROM+5upAr0dFzrSLU/m8qhY=
</code></pre>

<p>In my JS script with <code>crypto-js</code></p>

<pre><code>import CryptoJS from 'crypto-js';
import Base64   from 'crypto-js/enc-base64';

const jsString = Base64.stringify(
    CryptoJS.HmacSHA256('ANY STRING', 'HMAC HASH KEY').toString(CryptoJS.enc.Hex)
);
// 70e7aa44ba5ca8253296ec98fd8e3244e33ee6ea40af4745ceb48b53f9bcaa16
// It is seems not a valid base64 string
</code></pre>

<p>I also tried with some other scripts, and It was not working</p>

<pre><code>const jsString = CryptoJS.HmacSHA256('ANY STRING', 'HMAC HASH KEY').toString(CryptoJS.enc.Base64);
// cOeqRLpcqCUyluyY/Y4yROM+5upAr0dFzrSLU/m8qhY=
</code></pre>

<p>Two results are totally different. What is my wrong in JS script?</p>
","","103","<javascript><cryptojs>","1","","0","2018-12-22 03:00:40","","5","","4906552","","2018-12-22 03:00:40","2018-12-21 08:53:07",""
"33507460","PHP All Options Found to Read a Web Page Result in an Error in my case","<p>I have been searching and trying a lot to find the answer to this problem, including trying out many answers to very similar questions asked here on StackOverflow that, as I read, worked really well for many users, however not for me, for reasons I don't know yet but hope to find the answer here.</p>

<p>My problem is that for some reason it turns out to be impossible for me to read the contents of any Crypto-JS from the GoogleCode pages in PHP (like <a href=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha512.js"" rel=""nofollow noreferrer"">http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha512.js</a>). I started with the basic <code>file_get_contents</code> and when that failed searched for other options on the web, which resulted in the following basic class:</p>

<pre><code>&lt;?php
include 'snoopy.class.php';

class StreamReader {

    public static $agent = ""Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"";
    static $proxy = ""http://proxy.whoisaaronbrown.com/proxy/"";

    public static function curlcontents($path) {
        if(!function_exists('curl_version')) { return false; }
        $handle = curl_init();
        if(!$handle) { return false; }
        $timeout = 30;

        curl_setopt($handle, CURLOPT_URL, $path);
        curl_setopt($handle, CURLOPT_CONNECTTIMEOUT, $timeout);
        curl_setopt($handle, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($handle, CURLOPT_VERBOSE, true);
        curl_setopt($handle, CURLOPT_RETURNTRANSFER, 1);
        curl_setopt($handle, CURLOPT_USERAGENT, StreamReader::$agent);

        $lines_string = curl_exec($handle);
        curl_close($handle);
        return $lines_string;
    }

    public static function sockcontents($path, $port = 80) {
        $handle = fsockopen($path, $port, $errno, $errstr, 30);
        if (!$handle) {
            echo "" /* &lt;b&gt;$errstr ($errno)&lt;/b&gt; */ ""; return false;
        } else {
            $lines_string = """";
            $out = ""GET / HTTP/1.1\r\n"";
            $out .= ""Host: $path\r\n"";
            $out .= ""Connection: Close\r\n\r\n"";
            fwrite($handle, $out);
            $data = false;
            while (!feof($handle)) {
                $data = fgets($handle, 128);
                if($data === false) { break; }
                $lines_string .= $data;
            }
            fclose($handle);
            if($lines_string == """" &amp;&amp; $data === false) { return false; }
            return $lines_string;
        }
    }

    public static function readcontents($path) {
        if(!ini_get('allow_url_fopen')) { return false; }

        // fopen opens webpage in Binary
        // $handle = fopen($path,""rb"");
        $handle = fopen($path,""r"");
        if(!$handle) { return false; }

        $lines_string = """";
        $data = fread($handle,1024);
        do {
            if($data === false || strlen($data) == 0) {
                break;
            }
            $lines_string .= $data;
            $data = fread($handle,1024);
        } while(true);

        fclose($handle);
        if($lines_string == """" &amp;&amp; $data === false) { return false; }
        return $lines_string;
    }

    public static function browsecontents($path) {
        $snoopy = new Snoopy();
        if($snoopy-&gt;fetch($path)) { return $snoopy-&gt;results; }
        else { echo "" /* &lt;b&gt;error fetching document: "" . $snoopy-&gt;error . ""&lt;/b&gt; */ ""; return false; }
    }
}
?&gt;
</code></pre>

<p>As you can see I copied the answers to <a href=""https://stackoverflow.com/questions/2259892/how-to-read-a-web-page-in-php"">""website - How to read a web page in PHP""</a>, <a href=""https://stackoverflow.com/questions/3535799/file-get-contents-failed-to-open-stream"">""php - file_get_contents() failed to open stream""</a> &amp; <a href=""https://stackoverflow.com/questions/697472/why-file-get-contents-returns-failed-to-open-stream-http-request-failed"">""php - Why file_get_contents() returns ""failed to open stream: HTTP request failed!""?""</a>, <a href=""https://stackoverflow.com/questions/8004140/php-connect-to-external-ip-with-port"">""fsockopen - PHP connect to external ip with port""</a> and other optional solutions found here on StackOverflow as well as from SuperUser, PHP Freaks and others I found on the web.</p>

<p>(<em>On a side note, since I don't have enough credits or something yet, SO don't allow me to post more than 2 links and so thanks to user</em> bmla <em>for de-uglifying this post</em>)</p>

<p>My code is on an external host that I have no control over, but <code>function_exists('curl_version')</code> returns true, as well as <code>ini_get('allow_url_fopen')</code> does, however <code>http_get</code> gives an undefined function error. </p>

<p>I have tried all functions on itself, as well as in combination with each other and with other techniques I found or could think of, among which is the redirection through Aaron Brown's proxy (<code>$trythispathforachange = $proxy . $path;</code>). Sadly, all functions and combinations I have tried result in either a ""connection failed"", or a ""connection timed out"" error and in the case of Snoopy it tells me that the <code>tcp://</code>-connection went sour. Also, for <a href=""https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"" rel=""nofollow noreferrer"">https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js</a> everything works flawlessly, so I think the code must be correct so far.</p>

<p>But apparently for googlecode.com there still is something that prevents it from yielding a response to me in contrast to any human-interface-based browser.</p>

<p>Thanks in advance for any help or information provided!</p>

<p>Klaas</p>
","","101","<php><curl><connection><cryptojs><snoopy>","0","","0","2015-11-03 19:46:26","","5","","-1","","2017-05-23 11:44:31","2015-11-03 19:29:49",""
"56571009","React native in production: Cryptojs AES Error: Malformed UTF-8 data","<p>I used same code for aes encrypt (in <a href=""https://github.com/imchintan/react-native-crypto-js#readme"" rel=""nofollow noreferrer"">https://github.com/imchintan/react-native-crypto-js#readme</a>) for my react-native android app and nodejs server,</p>

<pre><code>let data = [{id: 1}, {id: 2}]
// Encrypt in react-native android app
let ciphertext = CryptoJS.AES.encrypt(JSON.stringify(data), 'secret key 123').toString();

// Decrypt in the nodejs server
let bytes = CryptoJS.AES.decrypt(ciphertext, 'secret key 123');
let decryptedData = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>when my react-native app is in ""JS Dev Mode"" activated and ""JS Minify"" desactivated the decryption in the server works fine, but when i configure my app as ""JS Dev Mode"" desactivated and ""JS Minify"" activated i cant decrypt the data in the server,</p>

<p>Error: Malformed UTF-8 data
at Object.stringify</p>

<p>the error throw in the server only when the app is in production mode, the error happend exactly when execute: bytes.toString(CryptoJS.enc.Utf8)</p>

<p>Can someone explain to me what I am doing wrong or how to solve the problem?</p>
","","101","<javascript><react-native><cryptojs>","0","","0","2019-06-12 22:42:09","","1","","9662601","","2019-06-12 22:42:09","2019-06-12 22:10:59",""
"38750419","CryptoJS and Google's Closure Compiler","<p>I'm writing a library and was trying to use Closure Compiler's advanced optimization features to minify my code further.</p>

<p>The library's built with TypeScript and I'm using Google's CryptoJS and am compiling with <code>--allowJS</code>. I've written externs for the methods I'm wanting to expose; but when I am getting errors that are coming from CryptoJS's <a href=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core.js"" rel=""nofollow"">core library</a>. From what it looks like; it seems annotated for Closure Compiler so I'm confused why it's breaking.
I'm taking advantage of the source maps provided by closure compiler so I can inspect the minified code.</p>

<p>Specifically on line 495; <code>this._data.concat(data);</code>. Claims <code>this._data</code> is undefined when minifed. </p>
","<p>It appears that while CryptoJS has JSDoc annotations, it wasn't written for compatibility with Closure-Compiler advanced optimizations. I can tell because it's JSDoc annotations for optional parameters are not correct.</p>

<p>You would most likely want to use CryptoJS as an external library.</p>
","100","<javascript><google-closure-compiler><cryptojs>","0","1","1","2016-08-04 13:01:24","38768094","0","","","","","2016-08-03 17:45:04",""
"55190887","AES decryption with wrong key. how to hide the fact the key was wrong?","<p>I'm using <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a>. when i use AES.decrypt with the wrong key, i noticed it usually has a negative ""sigBytes"", which tells me i used the wrong key. why is this possible? does it have something to do with invalid padding? I've tried different modes of AES, same issue. is it even possible for AES to not acknowledge failure?</p>

<p>is there a standard encryption algo that will decrypt to random bytes with no indication of success or failure?</p>
","<p>Yes,  stream based ciphers do generally never report failure. Basically, if you know that the ciphertext size is the same as the plaintext size then failure cannot be reported. This is because general purpose ciphers generally accept <em>any</em> message, meaning that there is exactly one ciphertext for each plaintext for a certain bit length and vice versa, independent on what key is used. Such a 1:1 mapping is called a <em>pseudo random permutation</em> or PRP. As each ciphertext leads back to a valid plaintext message, there is no error to return.</p>

<p>All stream ciphers (such as ChaCha) and block cipher streaming modes will therefore have this property. Streaming modes are modes that do not require padding and should therefore not expand the ciphertext size compared with the plaintext size. Of course, if you <em>actively</em> indicate that padding is required you may destroy this particular property. Currently the most common counter mode is probably CTR mode, also because it is used for almost all <em>authenticated</em> modes. CFB/OFB are generally considered for legacy purposes only.</p>

<p>Beware that an adversary may still get information depending on the information in the plaintext. Generally a key can be found even if very little plaintext is known (a JPEG header would for instance easily be sufficient knowledge). Other operations on wrong plaintext may also easily indicate failure (turning the receiving side into a so called <em>plaintext oracle</em>).</p>
","98","<javascript><encryption><aes><cryptojs>","-1","0","1","2019-03-16 14:30:53","","12","","","","","2019-03-15 21:27:18",""
"55226696","encrypt using ase256 gives different output in python and nodejs","<p>I am trying to encrypt a string ""1"" using key = ""secret_key"" and text ""11869021012"". Earlier I had written this in nodejs. now I want to port this to python. but here surprisingly both are giving different outputs.</p>

<pre><code>var crypto = require('crypto');

function getBytes (str) {
  let bytes = [], char;
  str = encodeURI(str);
  while (str.length) {
    char = str.slice(0, 1);
    str = str.slice(1);

    if ('%' !== char) {
      bytes.push(char.charCodeAt(0));
    } else {
      char = str.slice(0, 2);
      str = str.slice(2);

      bytes.push(parseInt(char, 16));
    }
  }
  return bytes;
};


function getIV (str, bytes){
    iv = getBytes(str);
    if(!bytes) bytes = 16;
    for(let i=iv.length;i&lt;bytes;i++) {
      iv.push(0);
    }
    return Buffer.from(iv);
};

function getKey (pwd){
    pwd = Buffer.from(getBytes(pwd), 'utf-8');
    let hash = crypto.createHash('sha256');
    pwd = hash.update(pwd).digest();
    return pwd;
};

function createCipherIV (algorithm, input_key, iv_input, text){
    let iv = getIV(iv_input);
    let key = getKey(input_key);
    let cipher = crypto.createCipheriv(algorithm, key, iv);
    let encrypted = cipher.update(text)
    encrypted += cipher.final('base64');
    return encrypted;
}

output = createCipherIV('aes256', 'secret_key', '11869021012', '1') 
console.log(output)
</code></pre>

<p>This produces the output:
<code>s6LMaE/YRT6y8vr2SehLKw==</code></p>

<p>python code:</p>

<pre><code># AES 256 encryption/decryption using pycrypto library
import base64
import hashlib

from Crypto.Cipher import AES
from Crypto import Random

BLOCK_SIZE = 16
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)
unpad = lambda s: s[:-ord(s[len(s) - 1:])]

password = ""secret_key""

def encrypt(raw, password):
    private_key = hashlib.sha256(bytearray(password, ""utf-8"")).digest()
    raw = pad(raw)
    iv = b'11869021012\x00\x00\x00\x00\x00'
    cleartext = bytearray(raw, 'utf-8')
    cipher = AES.new(private_key, AES.MODE_CBC, iv)

    return base64.b64encode(iv + cipher.encrypt(cleartext))

# First let us encrypt secret message
encrypted = encrypt(""1"", password)
print(encrypted)
</code></pre>

<p>This produces the output:
<code>MTE4NjkwMjEwMTIAAAAAALOizGhP2EU+svL69knoSys=</code></p>

<p>I have used aes256 algorithm here for encrypting message.
Clearly they are very close, but node seems to be padding the output with some extra bytes. Any ideas how I can get the two to interoperate?</p>
","<p>First, in a secure crypto system, you should <em>expect</em> the output to be different every time you encrypt, even using the same code. That fact that yours doesn't indicates it's an insecure cipher. Typically this is done by adding a random IV.</p>

<p>Your IV is ""11869021012"", which is horrible (because it's not random, and not even 16 bytes), but it does seem you're using it the same way in both, so that's fine.</p>

<p>Your password is the SHA-256 of a string, which is a horrible way to create a key, but still, you seem to be doing it the same way in both cases, so that's fine.</p>

<p>Your problem is that the Python code emits the IV followed by the cipher text. Your JS code does not emit the IV; it only emits the cipher text. So you probably meant this in the Python:</p>

<pre><code>return base64.b64encode(cipher.encrypt(cleartext))
</code></pre>

<p>Or you need to rework the JavaScript to glue together the IV and the cipher text before Base64 encoding.</p>
","95","<encryption><aes><cryptojs><pycrypto>","1","1","1","2019-03-18 17:37:40","55227093","6","","","","","2019-03-18 17:13:27",""
"52867263","crypto.js what does ""ciphertext"" mean","<p>I am reading this article about crypto.js.</p>

<p><a href=""https://hibara.org/blog/2016/02/15/cryptojs/"" rel=""nofollow noreferrer"">https://hibara.org/blog/2016/02/15/cryptojs/</a></p>

<pre><code>text = ""ABCDE""
password = ""pass""

var secret_passphrase = crypto.enc.Utf8.parse(this.password);
    var salt = crypto.lib.WordArray.random(128 / 8);
    var key128Bits500Iterations = crypto.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });
    var iv = crypto.lib.WordArray.random(128 / 8);
    var options = {iv: iv, mode: crypto.mode.CBC, padding: crypto.pad.Pkcs7};
    var message_text = crypto.enc.Utf8.parse(this.text);
    var encrypted = crypto.AES.encrypt(message_text, key128Bits500Iterations, options);
    var binary_data = crypto.enc.Hex.stringify(salt);
    binary_data += (',' + crypto.enc.Hex.stringify(iv));
    binary_data += (',' + encrypted);

    console.log(binary_data)

    var array_rawData = binary_data.split(',');
    var salt = crypto.enc.Hex.parse(array_rawData[0]);
    var iv = crypto.enc.Hex.parse(array_rawData[1]);
    var encrypted_data = crypto.enc.Base64.parse(array_rawData[2]);
    var secret_passphrase = crypto.enc.Utf8.parse(this.password);
    var key128Bits500Iterations = crypto.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });
    var options = {iv: iv, mode: crypto.mode.CBC, padding: crypto.pad.Pkcs7};
    var decrypted = crypto.AES.decrypt({&amp;quot;ciphertext&amp;quot;:encrypted_data}, key128Bits500Iterations, options);

    console.log(decrypted)
</code></pre>

<p>But I am getting an error.</p>

<blockquote>
  <p>Cannot find name 'ciphertext'.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>TS1005: ';' expected.</p>
</blockquote>

<p>What is ciphertext ? 
Does anyone know the way to solve this problem?</p>

<hr>

<p>Thank you so much for answering.</p>

<p>But it doesn't work properly. </p>

<p>I think console.log(decrypted) should be ""ABCDE"" , but I got WordArray object.</p>

<p>Do you know why?</p>

<hr>

<pre><code>text = ""ABCDE""
  password = ""pass""

var secret_passphrase = CryptoJS.enc.Utf8.parse(this.password);
      //alert(secret_passphrase.toString(CryptoJS.enc.Utf8));
      var salt = CryptoJS.lib.WordArray.random(128 / 8);
      var key128Bits500Iterations =
          CryptoJS.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });
      //
      var iv = CryptoJS.lib.WordArray.random(128 / 8);
      //IV:, CBC, PKCS7
      var options = {iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7};
      //UTF-8
      var message_text = CryptoJS.enc.Utf8.parse(this.text);

      //----------------------------------------------------------------------
      //
      var encrypted = CryptoJS.AES.encrypt(message_text, key128Bits500Iterations, options);
      //----------------------------------------------------------------------

      //"",""
      //salt + iv + ciphertext)
      var binary_data = CryptoJS.enc.Hex.stringify(salt);
      binary_data += (',' + CryptoJS.enc.Hex.stringify(iv));
      binary_data += (',' + encrypted);

      var array_rawData = binary_data.split(',');

      var salt = CryptoJS.enc.Hex.parse(array_rawData[0]);  // Salt
      var iv = CryptoJS.enc.Hex.parse(array_rawData[1]);    // IV
      var encrypted_data = CryptoJS.enc.Base64.parse(array_rawData[2]); //

      //
      var secret_passphrase = CryptoJS.enc.Utf8.parse(this.password);
      var key128Bits500Iterations =
          CryptoJS.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });

      //
      var options = {iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7};

      //
      var decrypted = CryptoJS.AES.decrypt({""ciphertext"":encrypted_data}, key128Bits500Iterations, options);
      // UTF-8
      console.log(decrypted)
</code></pre>

<p>I changed my code.</p>

<p>I thought inside of the decrypted would be ""ABCDE"" but inside of it there was WordArray object.</p>

<p>I want ABCDE back again do you know how to do that?</p>
","<p>Ciphertext refers to the encrypted text.</p>

<p>As for the error you're getting: there's an encoding error in your code (and in the article you've copied it from).</p>

<p>This line:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt({&amp;quot;ciphertext&amp;quot;:encrypted_data}, key128Bits500Iterations, options);
</code></pre>

<p>Should be:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt({""ciphertext"":encrypted_data}, key128Bits500Iterations, options);
</code></pre>

<p>Or even just:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt({ciphertext:encrypted_data}, key128Bits500Iterations, options);
</code></pre>

<p>The <a href=""https://jsfiddle.net/hibara/qzono8jb/"" rel=""nofollow noreferrer"">JSFiddle</a> that the article links to has the correct code.</p>

<hr>

<p>Complete snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const crypto = CryptoJS;
const text = ""ABCDE""
const password = ""pass""

var secret_passphrase = crypto.enc.Utf8.parse(password);
var salt = crypto.lib.WordArray.random(128 / 8);
var key128Bits500Iterations = crypto.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });
var iv = crypto.lib.WordArray.random(128 / 8);
var options = {iv: iv, mode: crypto.mode.CBC, padding: crypto.pad.Pkcs7};
var message_text = crypto.enc.Utf8.parse(text);
var encrypted = crypto.AES.encrypt(message_text, key128Bits500Iterations, options);
var binary_data = crypto.enc.Hex.stringify(salt);
binary_data += (',' + crypto.enc.Hex.stringify(iv));
binary_data += (',' + encrypted);

console.log(binary_data);

var array_rawData = binary_data.split(',');
var salt = crypto.enc.Hex.parse(array_rawData[0]);
var iv = crypto.enc.Hex.parse(array_rawData[1]);
var encrypted_data = crypto.enc.Base64.parse(array_rawData[2]);
var secret_passphrase = crypto.enc.Utf8.parse(password);
var key128Bits500Iterations = crypto.PBKDF2(secret_passphrase, salt, {keySize: 128 / 8, iterations: 500 });
var options = {iv: iv, mode: crypto.mode.CBC, padding: crypto.pad.Pkcs7};
var decrypted = crypto.AES.decrypt({ciphertext:encrypted_data}, key128Bits500Iterations, options);

console.log(decrypted.toString(CryptoJS.enc.Utf8));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
  &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/pbkdf2.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","92","<javascript><cryptojs>","2","1","1","2018-10-18 06:54:54","52867296","2","","10257395","","2018-10-18 06:39:49","2018-10-18 04:57:52",""
"56555318","crypto.privateDecrypt works on windows but not in ubuntu","<p>I have a code that reads a privateKey ( which is in PEM format ) and an encrypted text that I want to decrypt it. When I run the code in windows everything is working and it decrypt the text by</p>

<pre><code>let buffer = Buffer.from(encryptedData,'base64');
crypto.privateDecrypt(privatekey, buffer);
</code></pre>

<p>However when I run the same code in Ubuntu I receive the following error :</p>

<pre><code>""'Passphrase required for encrypted key.TypeError: Passphrase ' +
  'required for encrypted key    at Object.privateDecrypt ' +
  '(internal/crypto/cipher.js:53:12)    at e1c2 ' +...
</code></pre>

<p>""</p>

<p>I used console.log(encryptedData,privatekey,buffer) in both windows and Ubuntu system and they are identical. Also in privatekey I did not use passphrase. 
anyone has idea why in Ubuntu I get such error and in windows it is working fine? Could it be related to privatekey format that is actually .pam format and due to whitespaces linux could not handle it? </p>

<p>EDIT:</p>

<p>My private key has this format </p>

<pre><code>-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIJrTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQIdq79fP1MZogCAggA
MAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBDMX/L46fPKcSQkgXrwpLtqBIIJ
..
</code></pre>

<p>I basically generated it via </p>

<pre><code>crypto.generateKeyPairSync('rsa', {
    modulusLength: 4096,
    publicKeyEncoding: {
      type: 'spki',
      format: 'pem'
    },
    privateKeyEncoding: {
      type: 'pkcs8',
      format: 'pem',
      cipher: 'aes-256-cbc',
      passphrase: ''
    }
  });
</code></pre>

<p>When I check more in internet I saw an example at <a href=""https://github.com/nodejs/node/issues/22792"" rel=""nofollow noreferrer"">enter link description here</a>
that the header of the private key is ""-----BEGIN RSA PRIVATE KEY-----"" and actually I could run that code in Ubuntu and no error happens. So  it looks the problem is related to the header that change due to 'pkcs8' type inside privateKeyEncoding. 
Also I noticed that my node version on windows is 10.15.3 and on ubuntu is 12.4
Could it be also related to the node version change?</p>
","<p>I've tried something very similar on both Windows 10 and Ubuntu 18.04. In my case I generate public / private key files, encrypt then decrypt using these. It's working well on both platforms. It's worth giving this a go to see if it works for you. Node versions are: Windows: 10.15 Ubuntu 10.16.</p>

<pre><code>const crypto = require('crypto');
const fs = require(""fs"");

function generateKeyFiles() {

    const keyPair = crypto.generateKeyPairSync('rsa', {
        modulusLength: 4096,
        publicKeyEncoding: {
            type: 'spki',
            format: 'pem'
        },
        privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem',
        cipher: 'aes-256-cbc',
        passphrase: ''
        }
    });

    fs.writeFileSync(""public_key"", keyPair.publicKey);
    fs.writeFileSync(""private_key"", keyPair.privateKey);
}

// Encrypt a string given a public key file. Encode the result in base64.
function encryptString (plaintext, publicKeyFile) {
    const publicKey = fs.readFileSync(publicKeyFile, ""utf8"");
    const encrypted = crypto.publicEncrypt(publicKey, Buffer.from(plaintext));
    return encrypted.toString(""base64"");
}

// Encrypt a string given a cipherText (in base64) and a private key file.
function decryptString (ciphertext, privateKeyFile) {
    const privateKey = fs.readFileSync(privateKeyFile, ""utf8"");
    const decrypted = crypto.privateDecrypt(privateKey, Buffer.from(ciphertext, ""base64""));
    return decrypted.toString(""utf8"");
}

generateKeyFiles();

const plainText = ""I have spread my dreams under your feet. Tread softly because you tread on my dreams."";

const cipherText = encryptString(plainText, ""./public_key"");

console.log();
console.log(""Plaintext:"", plainText);
console.log();
console.log(""Ciphertext: "", cipherText);
console.log();
console.log(""Decrypted Text: "", decryptString(cipherText, ""private_key""));
console.log();
</code></pre>

<p>You could also try copying the key files from Windows to Ubuntu (skipping the generate key files step). This is working for me too.</p>
","92","<node.js><windows><ubuntu-16.04><cryptojs>","2","0","1","2019-06-12 08:45:27","","0","","11634761","","2019-06-12 07:23:09","2019-06-12 05:41:02",""
"57954629","How to convert crypto from java to nodejs","<p>I have following code in Java.</p>

<pre><code>KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom secureRandom = SecureRandom.getInstance(""SHA1PRNG"");
secureRandom.setSeed(password.getBytes());
kgen.init(INIT_LENGTH, secureRandom);
SecretKey secretKey = kgen.generateKey();
byte[] enCodeFormat = secretKey.getEncoded();
SecretKeySpec key = new SecretKeySpec(enCodeFormat, ""AES"");
Cipher cipher = Cipher.getInstance(""AES""); 
byte[] byteContent = content.getBytes(""utf-8"");
cipher.init(Cipher.ENCRYPT_MODE, key);  
byte[] result = cipher.doFinal(byteContent);
return result; 
</code></pre>

<p>I need to implement it in <em>JavaScript/Node.js</em>
I don't know how to implement it in JavaScript from <code>secretString</code> to key generated by KeyGenerator</p>

<p><strong>from the comment section:</strong></p>

<p>This is my code:</p>

<pre><code>function encodeDesCBC( textToEncode, keyString, ivString ) {
    const key = Buffer.from(keyString.substring(0, 8), 'utf8') 
    const iv = Buffer.from(ivString.substring(0, 8), 'utf8') 
    const cipher = crypto.createCipheriv('aes-128-cbc', key, iv) 
    let c = cipher.update(textToEncode, 'utf8', 'base64') 
    c += cipher.final('base64') 
    return base64url.escape(c) 
}
</code></pre>

<p>My problem is <code>secureRandom</code> and <code>KeyGenerator</code>. I do not know how to implement it in nodejs</p>
","<p>I don't know Java, but your usage looks somewhat weak, there are algorithms like PBKDF2 (which is old and discouraged now) and scrypt which do a much better job at turning human passwords into keying material.  I'm also not sure where your IV is coming from in your Java code.  Exactly replicating the Java code would be somewhat difficult as you'd need to know how your version of Java was implemented, and hence how the bytes passed to <code>setSeed</code> actually get turned into a key.</p>

<p>Node's <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer""><code>Crypto</code></a> module, as far as I can tell, assumes you know how long the keys are supposed to be.  In the case of AES 128 in CBC mode, this would be 128 bits (i.e. 16 bytes) for both the key and IV.</p>

<p>Assuming you wanted to use things built into the Crypto module (<a href=""https://www.npmjs.com/package/argon2"" rel=""nofollow noreferrer"">argon2</a> would be recommended if you could relax this restriction) then you'd do something like:</p>

<pre><code>const crypto = require('crypto');

const password = 'passw0rd';

const scrypt_salt = crypto.randomBytes(16);
const key = crypto.scryptSync(password, scrypt_salt, 16);
</code></pre>

<p>which would leave you with a suitable value in <code>key</code>, then you'd encrypt with:</p>

<pre><code>const plaintext = 'the plain text to encode';

const iv = crypto.randomBytes(16);
const cipher = crypto.createCipheriv('aes-128-cbc', key, iv);

const ciphertext = Buffer.concat([
    cipher.update(plaintext),
    cipher.final(),
]);
</code></pre>

<p>and you could encode to Base64 with <code>ciphertext.toString('base64')</code>.</p>

<p>Note that to be able to decrypt this, you'd need the <code>scrypt_salt</code>, <code>iv</code>, and <code>ciphertext</code>.</p>
","91","<java><node.js><encryption><aes><cryptojs>","1","1","2","2019-09-16 17:18:12","","3","","1235935","","2019-09-16 16:20:38","2019-09-16 10:10:45",""
"57954629","How to convert crypto from java to nodejs","<p>I have following code in Java.</p>

<pre><code>KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom secureRandom = SecureRandom.getInstance(""SHA1PRNG"");
secureRandom.setSeed(password.getBytes());
kgen.init(INIT_LENGTH, secureRandom);
SecretKey secretKey = kgen.generateKey();
byte[] enCodeFormat = secretKey.getEncoded();
SecretKeySpec key = new SecretKeySpec(enCodeFormat, ""AES"");
Cipher cipher = Cipher.getInstance(""AES""); 
byte[] byteContent = content.getBytes(""utf-8"");
cipher.init(Cipher.ENCRYPT_MODE, key);  
byte[] result = cipher.doFinal(byteContent);
return result; 
</code></pre>

<p>I need to implement it in <em>JavaScript/Node.js</em>
I don't know how to implement it in JavaScript from <code>secretString</code> to key generated by KeyGenerator</p>

<p><strong>from the comment section:</strong></p>

<p>This is my code:</p>

<pre><code>function encodeDesCBC( textToEncode, keyString, ivString ) {
    const key = Buffer.from(keyString.substring(0, 8), 'utf8') 
    const iv = Buffer.from(ivString.substring(0, 8), 'utf8') 
    const cipher = crypto.createCipheriv('aes-128-cbc', key, iv) 
    let c = cipher.update(textToEncode, 'utf8', 'base64') 
    c += cipher.final('base64') 
    return base64url.escape(c) 
}
</code></pre>

<p>My problem is <code>secureRandom</code> and <code>KeyGenerator</code>. I do not know how to implement it in nodejs</p>
","<p>When you encrypt something using AES, there is always a ""mode"" in play. In your Java code you don't specify a mode explicitly - <code>Cipher.getInstance(""AES"")</code>. When you do not specify a mode, the default mode in Java is ""ECB"" which is the most insecured mode anyway.</p>

<p>In your NodeJs code, you're using ""CBC"" mode which is a altogether different mode.</p>

<p>Neither ""ECB"", nor ""CBC"" are considered secured enough. As of today, usually, the recommended mode is the GCM mode.</p>

<p>To generate a key from a password, ideally a ""key derivation function"" should be used. The 4 key derivation functions recommended by OWASP are: PBKDF2, Scrypt, Bcrypt and Argon2.</p>

<p>In your Java code, the password is used as a seed for the pseudo random number generator class <code>SecureRandom</code>. That's a little bit bizarre because even if you give the same password to your function, it will produce different key in different run. Yes, <code>SecureRandom</code> is also used to generate key. But if the requirement is to generate a key from a password, a key derivation function, as mentioned above, shoul be used. Both the approaches are shown in the following StackOverflow answer with detailed explanation. However, it uses ""GCM"" mode. But as long as you understand the concepts, you can use any mode of your choice.</p>

<p><a href=""https://stackoverflow.com/a/53015144/1235935"">https://stackoverflow.com/a/53015144/1235935</a></p>

<p>Similarly, you'll find the same implementation in NodeJs in the following StackOverflow answer:</p>

<p><a href=""https://stackoverflow.com/a/53573115/1235935"">https://stackoverflow.com/a/53573115/1235935</a></p>

<p>To further understand AES in general, you may want to go through the following StackOverflow answer:</p>

<p><a href=""https://stackoverflow.com/a/43779197/1235935"">https://stackoverflow.com/a/43779197/1235935</a></p>
","91","<java><node.js><encryption><aes><cryptojs>","1","0","2","2019-09-16 17:18:12","","3","","1235935","","2019-09-16 16:20:38","2019-09-16 10:10:45",""
"56544178","Decrypt the encrypted pdf file having text and image content, using CryptoJS AES encryption javascript","<p>Trying to encrypt a pdf file having text and image content using cryptojs AES algo. after decryption the decrypted content is not same in a way the image content within pdf is different but text part is same as expected.</p>

<p>This is project requirement to first encrypt pdf file containing text and image and send to server(JAVA). on retrieval get the encrypted file and decrypt it. </p>

<p>On decryption expecting to have same file content as before encryption.</p>

<pre><code>encryptFile(file): Promise&lt;string&gt; {
return new Promise((resolve, reject) =&gt; {
const reader = new FileReader();

const key = CryptoJS.enc.Base64.parse('u/Gu5posvwDsXUnV5Zaq4g==');
const iv = CryptoJS.enc.Base64.parse('5D9r9ZVzEYYgha93/aUK2w==');

reader.onloadend = function (e) {
    const utf8Stringified = CryptoJS.enc.Utf8.parse(reader.result)
    const encrypted = CryptoJS.AES.encrypt(utf8Stringified, key, { iv: 
    iv,
    padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC })
    resolve(CryptoJS.enc.Base64.stringify(encrypted.ciphertext))
};
reader.readAsText(file);
})
}

decryptFile(file): Promise&lt;string&gt; {
return new Promise((resolve, reject) =&gt; {
    const reader = new FileReader()

    const key = CryptoJS.enc.Base64.parse('u/Gu5posvwDsXUnV5Zaq4g==');
    const iv = CryptoJS.enc.Base64.parse('5D9r9ZVzEYYgha93/aUK2w==');

    reader.onloadend = function (e) {
    const decrypted = CryptoJS.AES.decrypt(reader.result, key, { iv: iv, 
    padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC })
    resolve(decrypted.toString(CryptoJS.enc.Utf8))
};
reader.readAsText(file);
})
}
</code></pre>
","","89","<javascript><pdf><cryptojs>","0","","0","2019-06-12 04:16:17","","2","","1503016","","2019-06-12 04:16:17","2019-06-11 12:50:27",""
"54854350","Result are not equals from CryptoJS and Kotlin/Java encryption","<p>I need to replicate the same cryptography of CryptoJS on my Kotlin android application, I already set the same algorithm and transformation for both.</p>

<p>Kotlin code
Extension to encrypt/decrypt: (I not tested decrypt)</p>

<pre><code>private val ALGORITHM = ""AES""
private val TRANSFORMATION = ""AES/CBC/PKCS7Padding""

fun ByteArray.toEncryptedHash(key: String): String {

    var outputBytes = ByteArray(0)
    try {
        val secretKey = SecretKeySpec(key.toByteArray(), ALGORITHM)
        val cipher = Cipher.getInstance(TRANSFORMATION)
        val ivParameterSpec = IvParameterSpec(""1234567891234567"".toByteArray())
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)

        outputBytes = cipher.doFinal(this)

    } catch (ex: IOException) {
        //throw CryptoException(""Error encrypting/decrypting file"", ex)
    }


    return Base64.encodeToString(outputBytes, 0)
}

fun String.toDecryptedByteArray(key: String): ByteArray {

    var outputBytes = ByteArray(0)

    try {
        val secretKey = SecretKeySpec(key.toByteArray(), ALGORITHM)
        val cipher = Cipher.getInstance(TRANSFORMATION)
        cipher.init(Cipher.DECRYPT_MODE, secretKey)

        val inputByte = Base64.decode(this.toByteArray(), 0)

        outputBytes = cipher.doFinal(inputByte)

    } catch (ex: IOException) {
        //throw CryptoException(""Error encrypting/decrypting file"", ex)
    }

    return outputBytes
}
</code></pre>

<p>MainActivity:</p>

<pre><code>class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        Log.d(""ENCRYPT TEST"", ""DSDASSADAS DAS ADSD"".toByteArray().toEncryptedHash(""ZGFzZGFzZGZhZ2Y=""))

    }
}
</code></pre>

<p>CryptoJS code (on postman:)</p>

<pre><code>const payload = ""DSDASSADAS DAS ADSD"";

const encrypted = CryptoJS.AES.encrypt(
      CryptoJS.enc.Utf8.parse(payload),
      ""ZGFzZGFzZGZhZ2Y="",
         {
          keySize: 128,
          iv: CryptoJS.enc.Utf8.parse('1234567891234567'),
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
        }
);
console.log(encrypted.toString())
pm.globals.set(""userEncrypted"", encrypted.toString());
</code></pre>

<p>Result from Kotlin Android app:
bsOVFANvitVwybiPCcjLe189KuQV5Jb70iLoLQOog8Q=</p>

<p>Result from CryptoJS (postman console):
U2FsdGVkX19tqC2bt+P4KddWhhxQrHyIsRpggPDQX79gI24fg64Cl14rDtuosN44</p>

<p>It's not the same hash, I think CryptoJS do many things, not only cripto with AES.
How to get the same hash on Kotlin? (I don't have permission to change the js application, I need to replicate on Kotlin).</p>

<p>The answer can be on Java, no problem.</p>
","","88","<javascript><java><android><kotlin><cryptojs>","0","","0","2019-02-24 17:05:48","","2","","","","","2019-02-24 17:05:48",""
"56909626","How to make a Base64 HmacSHA256 signature of bytes payload in JavaScript equivalent to Java?","<p>In Java to make a signature of some data we are using <code>Mac</code> instance which allows to sign any byte array. How to make a function in JavaScript which produces the same signature for the same byte array?</p>

<p>An example of Java implementation (method <code>sign</code> signs <code>message</code> with <code>HmacSHA256</code> and than converts <code>signature</code> into url-safe base64 string):</p>

<pre><code>public static void main(String[] args) throws InvalidKeyException, NoSuchAlgorithmException {

    byte[] secret = new byte[5];
    secret[0] = 0x1e;
    secret[1] = 0x03;
    secret[2] = 0x01;
    secret[3] = 0x02;
    secret[4] = 0x03;

    byte[] message = new byte[5];
    message[0] = 0x01;
    message[1] = 0x03;
    message[2] = 0x02;
    message[3] = 0x1e;
    message[4] = 0x03;

    System.out.println(sign(secret, message));
}

private static String sign(byte[] secret, byte[] message) throws NoSuchAlgorithmException, InvalidKeyException {

    Mac sha256Hmac = Mac.getInstance(""HmacSHA256"");
    SecretKeySpec secretKey = new SecretKeySpec(secret, ""HmacSHA256"");
    sha256Hmac.init(secretKey);

    byte[] signature = sha256Hmac.doFinal(message);
    return Base64.getUrlEncoder().withoutPadding().encodeToString(signature);
}
</code></pre>

<p>The example above produces <code>q-l6FioFNkAqMIIxX5rs3AF-VnGIzpApCSSDHmnmjF8</code> signature string. I am trying to create the equivalent of <code>sign</code> method in JavaScript to get the same signature.</p>

<pre><code>function main(){
    var secret = [5];
    secret[0] = 0x1e;
    secret[1] = 0x03;
    secret[2] = 0x01;
    secret[3] = 0x02;
    secret[4] = 0x03;

    var message = [5];
    message[0] = 0x01;
    message[1] = 0x03;
    message[2] = 0x02;
    message[3] = 0x1e;
    message[4] = 0x03;

    console.log(sign(secret, message));
}

function sign(secret, message){

    // ?

}
</code></pre>

<p>I couldn't find a way to sign bytes with <code>CryptoJS</code>.</p>
","<p>Base64 and HmacSHA256 should be included in CryptoJS after install. Try this approach: </p>

<pre><code>function sign(secret, message){
const hash = CryptoJS.HmacSHA256(message.join(''), secret.join('')); 
const hashInBase64 = CryptoJS.enc.Base64.stringify(hash);
return hashInBase64}
</code></pre>
","88","<javascript><java><digital-signature><hmac><cryptojs>","0","0","2","2019-07-06 11:32:46","56913709","0","","","","","2019-07-05 21:58:41",""
"56909626","How to make a Base64 HmacSHA256 signature of bytes payload in JavaScript equivalent to Java?","<p>In Java to make a signature of some data we are using <code>Mac</code> instance which allows to sign any byte array. How to make a function in JavaScript which produces the same signature for the same byte array?</p>

<p>An example of Java implementation (method <code>sign</code> signs <code>message</code> with <code>HmacSHA256</code> and than converts <code>signature</code> into url-safe base64 string):</p>

<pre><code>public static void main(String[] args) throws InvalidKeyException, NoSuchAlgorithmException {

    byte[] secret = new byte[5];
    secret[0] = 0x1e;
    secret[1] = 0x03;
    secret[2] = 0x01;
    secret[3] = 0x02;
    secret[4] = 0x03;

    byte[] message = new byte[5];
    message[0] = 0x01;
    message[1] = 0x03;
    message[2] = 0x02;
    message[3] = 0x1e;
    message[4] = 0x03;

    System.out.println(sign(secret, message));
}

private static String sign(byte[] secret, byte[] message) throws NoSuchAlgorithmException, InvalidKeyException {

    Mac sha256Hmac = Mac.getInstance(""HmacSHA256"");
    SecretKeySpec secretKey = new SecretKeySpec(secret, ""HmacSHA256"");
    sha256Hmac.init(secretKey);

    byte[] signature = sha256Hmac.doFinal(message);
    return Base64.getUrlEncoder().withoutPadding().encodeToString(signature);
}
</code></pre>

<p>The example above produces <code>q-l6FioFNkAqMIIxX5rs3AF-VnGIzpApCSSDHmnmjF8</code> signature string. I am trying to create the equivalent of <code>sign</code> method in JavaScript to get the same signature.</p>

<pre><code>function main(){
    var secret = [5];
    secret[0] = 0x1e;
    secret[1] = 0x03;
    secret[2] = 0x01;
    secret[3] = 0x02;
    secret[4] = 0x03;

    var message = [5];
    message[0] = 0x01;
    message[1] = 0x03;
    message[2] = 0x02;
    message[3] = 0x1e;
    message[4] = 0x03;

    console.log(sign(secret, message));
}

function sign(secret, message){

    // ?

}
</code></pre>

<p>I couldn't find a way to sign bytes with <code>CryptoJS</code>.</p>
","<p>The solution appeared to be not complicated. Before using <code>CryptoJS</code> we have to correctly convert bytes array into a String. After returning <code>base64</code> string we should escape it to url friendly string.</p>

<pre><code>function sign(secret, message){

    var secretString = String.fromCharCode.apply(String, secret);
    var messageString = String.fromCharCode.apply(String, message);

    var hash = CryptoJS.HmacSHA256(messageString, secretString);
    return CryptoJS.enc.Base64.stringify(hash).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}
</code></pre>
","88","<javascript><java><digital-signature><hmac><cryptojs>","0","0","2","2019-07-06 11:32:46","56913709","0","","","","","2019-07-05 21:58:41",""
"37333100","Why does base64 code changes when inserted into mongodb?","<p>I am working on generating unique email links for my users, trying to generate a code bye concatenating the user email and the Date timestamp.</p>

<p>The code generated looks like this</p>

<pre><code>bUBzLnBvazE0NjM2ODc3MDg0MTA=3D
</code></pre>

<p>while in the mongodb it doesn't have 3D in it,   <code>bUBzLnBvazE0NjM2ODc3MDg0MTA=</code>, and that's why URLs don't work.</p>

<p>I am using cryptoJS to encode string into base64.</p>

<pre><code>const BASE_SERVER_URL = ""http://localhost:3000/"";
const INVITE_URL = BASE_SERVER_URL+""login/"";

let uniqueCode = CryptoJS.enc.Base64.stringify(CryptoJS.enc.Utf8.parse(pmGroupUser.email+Date.now()));
    let emailText = ""Hello "" + pmGroupUser.first_name +  "" click the following url to register your self "";
    emailText += INVITE_URL;
    emailText += uniqueCode;


        Meteor.call('sendEmail',""to"", ""from"",""Subject"", emailText, (err, res) =&gt; {
            if(!err) {
                Invites.insert({
                    code: uniqueCode
                });
            }
        });
</code></pre>
","","88","<javascript><mongodb><meteor><base64><cryptojs>","0","","0","2016-05-19 21:00:30","","4","","975183","","2016-05-19 21:00:30","2016-05-19 20:09:38",""
"46522618","Node 6 upgrade caused SignatureDoesNotMatch errors from aws-sdk because of crypto.DEFAULT_ENCODING='binary'","<p>I have moved from node 4 to node 6 and this caused anything using the aws-sdk to return the following error message:</p>

<blockquote>
  <p>SignatureDoesNotMatch: The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.</p>
</blockquote>

<p>Looking into the code this seems to be caused by my code calling crypto to create and validate hashes and sets</p>

<pre><code> crypto.DEFAULT_ENCODING = 'binary' 
</code></pre>

<p>If I change this from 'binary' to 'buffer' (which is the default) the aws-sdk works but my code cannot validate old hashes.</p>

<p>This is the code used to create and check the hashes:</p>

<pre><code>  crypto.pbkdf2(password, salt, iterations, keysize, function (err, derivedKey) {
      callback(null, [salt.toString('base64'), new Buffer(derivedKey).toString('base64')])
  });
</code></pre>

<p>Looking at the crypto documentation for <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_default_encoding"" rel=""nofollow noreferrer"">crypto.DEFAULT_ENCODING</a> I am not sure what the difference is between using buffer and binary.</p>

<p>Is there a way to use the binary encoding only for this crypto method and not affect the aws-sdk ?</p>

<p>If not is there a way of transforming a hash produced by pbkdf2 using 'buffer' encoding to what it would have produced if it was using the 'binary' encoding? </p>
","<p>Looking at the crypto.pbkdf2 source code found <a href=""https://github.com/nodejs/node/blob/master/lib/internal/crypto/pbkdf2.js"" rel=""nofollow noreferrer"">here</a>. The DEFAULT_ENCODING variable is only used if it is not set to ""buffer"" (which is the default). If it is set to some other encoding this piece of code gets executed to change the result to the desired encoding:</p>

<pre><code> // at this point, we need to handle encodings.
if (callback) {
  function next(er, ret) {
    if (ret)
      ret = ret.toString(encoding);
    callback(er, ret);
  }
  PBKDF2(password, salt, iterations, keylen, digest, next);
} else {
  var ret = PBKDF2(password, salt, iterations, keylen, digest);
  return ret.toString(encoding);
}
</code></pre>

<p>So if you remove the <code>DEFAULT_ENCODING</code> or set it to ""buffer"" and then use <code>result.toString(""binary"")</code> on the result of the <code>pbkdf2</code> function you should get the exact same result as if you were using <code>DEFAULT_ENCODING=""binary""</code> as demonstrated by the following example:</p>

<pre><code>var crypto = require(""crypto"");

function defaultBuffer(){
    crypto.DEFAULT_ENCODING = ""buffer"";
    crypto.pbkdf2(password, salt, 5, 12, function (err, derivedKey) {
        console.log(""Key (Buffer + toString('binary')): ""+ derivedKey.toString('binary'))
      });

}
function defaultBinary(){
    crypto.DEFAULT_ENCODING = ""binary"";
    crypto.pbkdf2(password, salt, 5, 12, function (err, derivedKey) {
        console.log(""Key (binary): ""+ derivedKey)
      });
}
var password = 'password';
var salt = 'salt';
defaultBuffer();
defaultBinary();
</code></pre>

<p>This produces the following result:</p>

<blockquote>
  <p>Key (Buffer + toString('binary')): ?p~ </p>
  
  <p>Key (binary): ?p~</p>
</blockquote>
","87","<node.js><hash><aws-sdk><cryptojs>","2","0","1","2017-10-05 16:26:57","46590541","0","","","","","2017-10-02 09:10:19",""
"57080348","How to pass number to crypto-js hmac sha1 method?","<p>I have  different results in java and js code when using <code>HmacSha1</code> method. after spend time to searching, I found that maybe my message should passed as a number to <code>HmacSha1</code> method. so how to do this?
this is my code :</p>

<pre><code>import Crypto from ""crypto-js"";

 Crypto.HmacSHA1(
   ""26056085"",
   Crypto.enc.Hex.parse(""0899917B8146FFE4"")
 );
</code></pre>

<p>so, how to send <code>""26056085""</code> as a number message? Also i know that this method parameters accepts string type.
maybe this <a href=""https://www.jokecamp.com/blog/examples-of-creating-base64-hashes-using-hmac-sha256-in-different-languages"" rel=""nofollow noreferrer"">link</a>
can help you for help me.</p>
","<p>After more trying, we have to generate <code>HmacSha1</code> in native code (swift).
so we used react native bridge communication between <code>react native</code> and <code>swift</code>.
this <a href=""https://facebook.github.io/react-native/docs/native-components-ios.html#properties"" rel=""nofollow noreferrer"">link</a> can help you.</p>
","86","<javascript><react-native><cryptojs><hmacsha1>","2","1","1","2019-07-21 05:41:51","57130630","4","","6498792","","2019-07-17 18:19:23","2019-07-17 16:19:14",""
"55173662","Passport fails authentication with ""Wrong password"" before actually calling my passwordMatch function","<p>This is a weird one.</p>

<p><strong>What im trying to do</strong></p>

<p>Create an authentication server in node.js using Passportjs local strategy, and JWT. Allowing for account registration with email &amp; password, with passwords hashed with 'crypto'</p>

<p><strong>What's happening</strong></p>

<p>So when I login with the right password, to a pre existing model, authentication fails in the APi for having a wrong password. Though theres some weird stuff going on.</p>

<p><strong>What I've tried</strong></p>

<p>Essentially when I make the post request:</p>

<ul>
<li>OPTIONS /api/login calls</li>
<li>It goes through my passport config, and in the typical function where you check if the password is correct</li>
<li><em>side note: POST api/login is logged to the console</em></li>
</ul>

<p>The function in my passport config:</p>

<pre><code>if (!profileController.passMatch(username, password)) {
            console.log('pass was wrong');
            return done(null, false, {
                message: 'Password is wrong'
            });
        }
</code></pre>

<ul>
<li>The 'pass was wrong' thing calls, failing the authentication with done(). Though in passMatch, as you'll see below, it does show the correct password</li>
</ul>

<p>passMatch function in profile controller:</p>

<pre><code>module.exports.passMatch = (email, password) =&gt; {
    User.findOne({email: email}, (err, user) =&gt; {
        if (err) { console.log (""error at passMatch: "" + err); }
        var hash = crypto.pbkdf2Sync(password, user.salt, 1000, 64, 'sha512').toString('hex');
        console.log(user.hash == hash);
        return (user.hash == hash);
    });
    return false;
};
</code></pre>

<ul>
<li>Though if you notice the console log where I check if the hash comparison is correct. That log statement <strong>is printed to the console <em>after</em> 'pass was wrong' is logged</strong>. It's also printed after the passport.authenticate call in my login function concludes a failed authentication at the console.log(info)</li>
</ul>

<p>Login function:</p>

<pre><code>module.exports.login = (req, res) =&gt; {

    console.log('beginning to authenticate');

    passport.authenticate('local', (err, user, info) =&gt; {

        console.log (""authenticating"");
        var token;

        // If passport throws an error
        if (err) {
            res.status(404).json(err);
            console.log(""error logging in"");
            return;
        }

        // If a user is found
        if (user) {

            // Respond with JWT
            token = createJwt(user)
            res.status(200);
            res.json({
                ""token"": token
            })
            console.log(""user logged in"");

        // If a user wasn't found
        } else {

            res.status(401).json(info);
            console.log(info);
        }

    })(req, res);

};
</code></pre>

<ul>
<li>Error logging in isn't called, but the console.log(info) is called with the error message from the done() message in the config.</li>
</ul>

<p><strong>What's going wrong here?</strong></p>
","<p>In the ""passMatch"" function, I query for the user again (which is just inefficient), but since this operation was asynch, it was being skipped to the ""return false"" statement after, and in the passport authentication config process, it recieved that false, causing authentication to fail, but the ""log"" to be returned after cause it took longer.</p>

<p><strong>How I fixed it</strong></p>

<p>I passed in the user object that passport already queried instead of the username into passMatch, then had two operations to check if the hash was the same and returned that, and now it works.</p>

<p><strong>The new code</strong></p>

<pre><code>module.exports.passMatch = (user, password) =&gt; {
    var hash = crypto.pbkdf2Sync(password, user.salt, 1000, 64, 'sha512').toString('hex');
    return user.hash == hash;
};
</code></pre>

<p>Also the necessary change in the passport config to pass in the user instead of the username as the first param to that function.</p>
","80","<node.js><authentication><mongoose><passport.js><cryptojs>","2","1","1","2019-03-15 01:06:16","55174173","0","","","","","2019-03-14 23:51:39",""
"57952839","Crypto js decrypt from base64","<p>I dealing with cryptojs and want to try a simple example with <code>aes</code></p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""TEST_TEXT"", '9021D105A446', {
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.Pkcs7
});

var decrypt = CryptoJS.AES.decrypt(encrypted, '9021D105A446', {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
console.log(decrypt.toString(CryptoJS.enc.Utf8));//Yeah! TEST_TEXT output as expected
</code></pre>

<p>Now I give a try with encrypted in base64, but not output as expected</p>

<pre><code> var encryptedText = encrypted.ciphertext.toString(CryptoJS.enc.Base64)
 var encrypted2 = CryptoJS.enc.Base64.parse(encryptedText);
 var decrypt2 = CryptoJS.AES.decrypt(encrypted2, '9021D105A446', {
     mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
   });
console.log(decrypt2.toString(CryptoJS.enc.Utf8));// Ops! empty output
</code></pre>

<p>Do you know something went wrong with decryption in 2nd example?</p>

<p>Another question, every I run example 1, the <code>encryptedText</code>  was difference from previous running. Is this normal behavior?</p>

<p>Fiddle update : <a href=""https://jsfiddle.net/n6wL9a40/"" rel=""nofollow noreferrer"">https://jsfiddle.net/n6wL9a40/</a></p>
","<p>First, actually <code>CryptoJS.enc.Base64.parse(encryptedText)</code> doesn't give you back a Base64 string, but an object, you should use it with <code>toString</code> like this: <code>CryptoJS.enc.Base64.parse(encryptedText).toString()</code> to get back your original string that was encoded in Base64</p>

<p>But the real problem is that you use the wrong part of the encrypted object (see linked fiddle, trying to decrypt <code>.ciphertext</code> won't work, because ciphertext is just the last part of the encrypted result needed for decryption, first part is missing). And additionally, there is no need to convert your output to Base64 at all, because it's already in Base64!</p>

<p><code>console.log(encrypted.toString()); //will already be Base64</code></p>

<p>See all this in an updated fiddle: <a href=""https://jsfiddle.net/gqkcvjxo/"" rel=""nofollow noreferrer"">https://jsfiddle.net/gqkcvjxo/</a></p>

<p><strong>EDIT:</strong>
For your other question I quote <a href=""https://cryptojs.gitbook.io/docs/#the-cipher-algorithms"" rel=""nofollow noreferrer"">the docs</a>: </p>

<blockquote>
  <p>CryptoJS supports AES-128, AES-192, and AES-256. It will pick the variant by the size of the key you pass in. If you use a passphrase, then it will generate a 256-bit key</p>
</blockquote>

<p>You can generate a key for AES-128 by using a pass of length 16 (128/8), you'll see in the fiddle that it works, the encrypted text length is halved.</p>

<pre><code>var pass = 'abcdefghijklmnop'; //must be length 16 (because 128/8)
var key =  CryptoJS.enc.Utf8.parse(pass);
</code></pre>

<p>Updated fiddle: <a href=""https://jsfiddle.net/o3975jtd/3/"" rel=""nofollow noreferrer"">https://jsfiddle.net/o3975jtd/3/</a></p>

<p>To answer your other question, the encrypted text is not the same each time in first version because of the generated <code>iv</code> (<a href=""https://stackoverflow.com/questions/35472396/how-does-cryptojs-get-an-iv-when-none-is-specified"">see explanation here</a>). By using a key with AES-128 in ECB mode, the <code>iv</code> is not automatically generated and comes undefined (apparently, when trying to specify one, nothing changes, probably because it's not used as told in the explanation link)</p>
","79","<javascript><aes><cryptojs>","0","1","2","2019-09-16 12:26:44","57954357","2","","1434397","","2019-09-16 08:32:09","2019-09-16 08:15:19",""
"57952839","Crypto js decrypt from base64","<p>I dealing with cryptojs and want to try a simple example with <code>aes</code></p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""TEST_TEXT"", '9021D105A446', {
  mode: CryptoJS.mode.ECB,
  padding: CryptoJS.pad.Pkcs7
});

var decrypt = CryptoJS.AES.decrypt(encrypted, '9021D105A446', {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
console.log(decrypt.toString(CryptoJS.enc.Utf8));//Yeah! TEST_TEXT output as expected
</code></pre>

<p>Now I give a try with encrypted in base64, but not output as expected</p>

<pre><code> var encryptedText = encrypted.ciphertext.toString(CryptoJS.enc.Base64)
 var encrypted2 = CryptoJS.enc.Base64.parse(encryptedText);
 var decrypt2 = CryptoJS.AES.decrypt(encrypted2, '9021D105A446', {
     mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
   });
console.log(decrypt2.toString(CryptoJS.enc.Utf8));// Ops! empty output
</code></pre>

<p>Do you know something went wrong with decryption in 2nd example?</p>

<p>Another question, every I run example 1, the <code>encryptedText</code>  was difference from previous running. Is this normal behavior?</p>

<p>Fiddle update : <a href=""https://jsfiddle.net/n6wL9a40/"" rel=""nofollow noreferrer"">https://jsfiddle.net/n6wL9a40/</a></p>
","<p>You don't need to convert encrypted value to <code>base64</code>, <code>encrypted.toString()</code> returns <code>base64</code> value.  </p>

<pre><code>var base64Value = encrypted.toString();
// base64Value is U2FsdGVkX19s42BDpx8A9I265vm+zGKSk8nEbQwNjfw=
var encryptedText = CryptoJS.enc.Base64.parse(base64Value)
var encrypted2 = encryptedText.toString(CryptoJS.enc.Base64);
var decrypt2 = CryptoJS.AES.decrypt(encrypted2, '9021D105A446', {
 mode: CryptoJS.mode.ECB,
 padding: CryptoJS.pad.Pkcs7
});

console.log(decrypt2.toString(CryptoJS.enc.Utf8));// TEST_TEXT
</code></pre>
","79","<javascript><aes><cryptojs>","0","0","2","2019-09-16 12:26:44","57954357","2","","1434397","","2019-09-16 08:32:09","2019-09-16 08:15:19",""
"57416217","CryptoJS encrypt in aes-256-cbc returns an unexpected value","<p>I am encrypting some data using <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> and comparing it to <a href=""https://www.devglan.com/online-tools/aes-encryption-decryption"" rel=""nofollow noreferrer"">an online tool</a> and I am not getting the same result. In fact the result from CryptoJS in not decryptable with the tool.</p>

<p>I am trying to encrypt in AES-256-CBC with the following parameters:</p>

<pre><code>text = '111222333'
iv = 'I8zyA4lVhMCaJ5Kg'
key = '6fa979f20126cb08aa645a8f495f6d85'
</code></pre>

<p>Here's my code:</p>

<pre><code>let text = '111222333';

aesEncrypt(data) {
    let key = '6fa979f20126cb08aa645a8f495f6d85';    //length 32
    let iv = 'I8zyA4lVhMCaJ5Kg';                     //length 16
    let cipher = CryptoJS.AES.encrypt(data, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });
    return cipher.toString();
}

aesEncrypt(text);
</code></pre>

<p>The resulting encrypted string is <code>U2FsdGVkX1+f3UywYmIdtb50bzdxASRCSqB00OijOb0=</code> while the one obtained with the online tool is <code>B6AeMHPHkEe7/KHsZ6TW/Q==</code>. Why are they different, I seem to be using the same parameters?</p>

<p>My plan in using CryptoJS is to encrypt some data client side and then be able to decrypt it server side, if needed. But the differences in both encrypted values is stopping me to do so.</p>
","<p>How 'bout encoding your data as UTF-8. Just like the ""online tool"" is doing.</p>

<p>Use <a href=""https://cryptojs.gitbook.io/docs/#encoders"" rel=""nofollow noreferrer""><code>CryptoJS.enc.Utf8.parse</code></a>  to achieve what I'm saying.</p>

<pre><code>aesEncrypt(data) {
   let key = '6fa979f20126cb08aa645a8f495f6d85';
   let iv = 'I8zyA4lVhMCaJ5Kg';
   let cipher = CryptoJS.AES.encrypt(data, CryptoJS.enc.Utf8.parse(key), {
       iv: CryptoJS.enc.Utf8.parse(iv), // parse the IV 
       padding: CryptoJS.pad.Pkcs7,
       mode: CryptoJS.mode.CBC
   });

   return cipher.toString(); // returns B6AeMHPHkEe7/KHsZ6TW/Q==

}
</code></pre>

<p>Code snippet using CryptoJS.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function aesEncrypt(data) {
   let key = '6fa979f20126cb08aa645a8f495f6d85';
   let iv = 'I8zyA4lVhMCaJ5Kg';
   let cipher = CryptoJS.AES.encrypt(data, CryptoJS.enc.Utf8.parse(key), {
       iv: CryptoJS.enc.Utf8.parse(iv),
       padding: CryptoJS.pad.Pkcs7,
       mode: CryptoJS.mode.CBC
   });

   return cipher.toString();

}
console.log(aesEncrypt('111222333')) // B6AeMHPHkEe7/KHsZ6TW/Q==</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>

<p><a href=""https://stackblitz.com/edit/typescript-srpjrz"" rel=""nofollow noreferrer"">Working Stackblitz example</a></p>
","79","<javascript><cryptojs>","2","2","1","2019-08-13 19:39:41","57416759","1","","9322238","","2019-08-08 15:58:05","2019-08-08 15:36:38",""
"55516937","Fetch with encrypted password","<p>I'm trying to authenticate to an API via fetch. For that, I'm using an encrypted username and password. The problem is that no matter what I do, the response I get from the API is that my password is invalid. I know the password works because it was provided by my admins.</p>

<p>This is the code I'm using:</p>

<pre><code>import CryptoJS from 'crypto-js';
import CryptoJSAesJson from './helpers/helpers';

var username = 'myusername';
var pass = 'mypassword';
var hash = CryptoJS.SHA1(username).toString();
var password = CryptoJS.AES.encrypt(JSON.stringify(pass), 'mypassphrase', {format: CryptoJSAesJson}).toString();
var credentials = {
    user: hash,
    password: password
}

fetch(""https://demo.mediainfo.com/api/user/login"", {
    body: JSON.stringify(credentials),
    headers: {
        ""Content-Type"": ""application/json""
    },
    method: ""POST""
}).then(response =&gt; {
    // do something with the response
});
</code></pre>

<p>On helpers.js I have this code:</p>

<pre><code>var CryptoJSAesJson = {
    stringify: function (cipherParams) {
        var j = {ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)};
    if (cipherParams.iv) j.iv = cipherParams.iv.toString();
    if (cipherParams.salt) j.s = cipherParams.salt.toString();
        return JSON.stringify(j).replace(/\s/g, '');
    },
    parse: function (jsonStr) {
        var j = JSON.parse(jsonStr);
        var cipherParams = CryptoJS.lib.CipherParams.create({ciphertext: CryptoJS.enc.Base64.parse(j.ct)});
        if (j.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(j.iv);
        if (j.s) cipherParams.salt = CryptoJS.enc.Hex.parse(j.s);
        return cipherParams;
    }
}

export default CryptoJSAesJson;
</code></pre>

<p>Unfortunately the API documentation is null so I'm not sure what could be the problem, the only message I get when fetching is: ""Wrong password exchange. Please contact administrator.""</p>

<p>Thanks!</p>
","","78","<javascript><fetch><cryptojs>","0","","0","2019-04-04 13:25:37","","6","","833532","","2019-04-04 13:25:37","2019-04-04 13:15:28",""
"55923521","How to convert Des-ede algorithm encryption written in Java to NodeJS","<p>I am trying to convert code the below java to Nodejs. I have one requirement to encrypt the text with a key using ""DESede"" algorithm. Currently code is written in Java and now I need to migrate to Nodejs</p>

<p>Java code - </p>

<pre><code>public static void main(String args[]) throws Exception {

    String myString = ""the sample text to be encrypted"";

    EncryptData(myString);
}

public static byte[] EncryptData(String text) throws Exception {
    String keyValue = ""kbhgvfbjhgfcf87576hgv656"" ;
    final byte[] keyBytes = keyValue.getBytes(""UTF8"");

    final DESedeKeySpec key = new DESedeKeySpec(keyBytes);
    SecretKeyFactory keyFactory = 
    SecretKeyFactory.getInstance(""DESede"");
    SecretKey key1 = keyFactory.generateSecret(key);
    final Cipher cipher = Cipher.getInstance(""DESede"");
    cipher.init(1, key1);

    final byte[] plainTextBytes = text.getBytes(""UTF8"");
    final byte[] cipherText = cipher.doFinal(plainTextBytes);

    return cipherText;
}
</code></pre>

<p>I have tried using both NodeJS in built module Crypto and as well as CryptoJS. But getting different results than what I am getting in Java. Unable to figure out what I am missing. </p>

<p>Using CryptoJS [Google Code]- </p>

<pre><code>function encrypt(message, key) {

    var keyHex = CryptoJS.enc.Utf8.parse(key);

    var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });

    return encrypted;
}
</code></pre>

<p>Using NodeJS Crypto -</p>

<pre><code>let option = {
        alg: 'des-ede3',
        key: ""kbhgvfbjhgfcf87576hgv656"",
        plaintext: ""the sample text to be encrypted"",
    }

encrypt(option);

function encrypt(param) {
    var key = new Buffer(param.key, 'utf8');
    var plaintext = new Buffer(param.plaintext, 'utf8');
    var alg = param.alg;

    //encrypt  
    var cipher = crypto.createCipheriv(alg, key, '');
    var ciph = cipher.update(plaintext, 'utf8');
    ciph += cipher.final('utf8');
    console.log(alg, ciph);
    return ciph;
}
</code></pre>

<p>I expect the output to be -</p>

<p>[-15, 6, -31, 6, -99, 57, -90, -125, 121, 73, -107, 112, -68, 8, 66, 62, 116, 71, 118, -55, -50, -21, 96, -124, 63, -75, -96, -117, 108, -46, -72]</p>

<p>but the actual output is -
[5a ad e6 65 a1 be b9 68 d5 bd e4 9f 3c ca d6 6c 7e 71 ad 84 c6 39 81 49 14 35 7e 5f de 64 da 40].</p>
","","78","<node.js><encryption><cryptojs><des>","1","","0","2019-04-30 14:49:25","","3","","","","","2019-04-30 14:49:25",""
"50413401","getting different results when encoding with python and when encoding with nodejs","<p>i am trying to encode a particular string with python with pycrypto and encode the same string with nodejs with crypto.
i am getting different results in both the cases for the same input string</p>

<p>python code:</p>

<pre><code>from Crypto.Cipher import AES
from hashlib import md5
import base64


password = 'aquickbrownfoxjumpsoverthelazydog'
input = 'hello+world'

BLOCK_SIZE = 16

def pad (data):
    pad = BLOCK_SIZE - len(data) % BLOCK_SIZE
    return data + pad * chr(pad)

def unpad (padded):
    pad = ord(padded[-1])
    return padded[:-pad]

def text_encrypt(data, nonce, password):
    m = md5()
    m.update(password)
    key = m.hexdigest()
    m = md5()
    m.update(password + key)
    iv = m.hexdigest()

    data = pad(data)

    aes = AES.new(key, AES.MODE_CBC, iv[:16])

    encrypted = aes.encrypt(data)
    return base64.urlsafe_b64encode(encrypted)

output = text_encrypt(input, """", password)
print output
</code></pre>

<p>and the nodejs code is as follows:</p>

<pre><code>var crypto = require('crypto');

var password = 'aquickbrownfoxjumpsoverthelazydog';
var input = 'hello+world';

var encrypt = function (input, password, callback) {
    var m = crypto.createHash('md5');
    m.update(password)
    var key = m.digest('hex');

    m = crypto.createHash('md5');
    m.update(password + key)
    var iv = m.digest('hex');

    var data = new Buffer(input, 'utf8').toString('binary');

    var cipher = crypto.createCipheriv('aes-256-cbc', key, iv.slice(0,16));

    var nodev = process.version.match(/^v(\d+)\.(\d+)/);
    var encrypted;

    if( nodev[1] === '0' &amp;&amp; parseInt(nodev[2]) &lt; 10) {
        encrypted = cipher.update(data, 'binary') + cipher.final('binary');
    } else {
        encrypted = cipher.update(data, 'utf8', 'binary') + cipher.final('binary');
    }

    var encoded = new Buffer(encrypted, 'binary').toString('base64');

    callback(encoded);
};

encrypt(input, password, function (encoded) {
    console.log(encoded);
});
</code></pre>

<p>the results for both the cases is different but after decryption they both tend to give the same correct result.</p>

<p>what might be the issue here?</p>
","<p>You didn't specify what different results are you getting but those two should produce same-ish result. The only difference I see is in the base64 alphabet you're using.</p>

<p>In Python you're calling <a href=""https://docs.python.org/2/library/base64.html#base64.urlsafe_b64encode"" rel=""nofollow noreferrer""><code>base64.urlsafe_b64encode()</code></a> which differs from the <a href=""https://tools.ietf.org/html/rfc3548.html"" rel=""nofollow noreferrer""><strong><em>standard</em> Base64</strong></a> in what characters it uses for values for <code>62</code> and <code>63</code> (<code>-</code> and <code>_</code> instead of <code>+</code> and <code>/</code>). To get the same result, either in Python return:</p>

<pre><code>return base64.b64encode(encrypted)
</code></pre>

<p>Or post-process the base64 encoded string in Node.js:</p>

<pre><code>encoded = encoded.replace(/_/g, '/').replace(/-/g, '+');
</code></pre>

<p>All this being said, as I've mentioned in my comment, never derive an IV from your password/key (or anything else deterministic and unchanging). Use a <a href=""https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator"" rel=""nofollow noreferrer"">cryptographically secure PRNG</a> for it.</p>
","77","<python><node.js><pycrypto><cryptojs>","-1","0","1","2018-05-18 21:15:19","50419370","2","","","","","2018-05-18 14:20:07",""
"53066169","How to decrypt the encrypted data from PHP using NodeJS Crypto Package","<p>I have created an encryption function in PHP using <code>openssl_encrypt()</code> with <code>aes-256-cbc</code> as algorithm. I want the encrypted data to be decrypted in NodeJS when sent in an <code>API</code> call.</p>

<p>This is the encryption in my PHP:</p>

<pre><code>$form_data_str = json_encode($form_data);

  // Encrypt data to submit
  define('AES_256_CBC', 'aes-256-cbc');
  // Encryption Key from Merchant sKey
  $sKey = 'uTEW2U0s90mtzF5nGX2BBKkuYcUsQEEK';
  $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(AES_256_CBC));
  $encrypted_form_data = openssl_encrypt($form_data_str, AES_256_CBC, $encryption_key, 0, $iv);
</code></pre>

<p>then I pass the encrypted data as body in an API call to my NodeJS server.
Now, I want to decrypt the data in my NodeJS. I have this current code in my NodeJS:</p>

<pre><code>var encrypter = require('crypto'),
algorithm = 'aes-256-cbc',
password = 'uTEW2U0s90mtzF5nGX2BBKkuYcUsQEEK';

function decrypt(data){
    let iv = new Buffer.alloc(16);
    var decipher = encrypter.createDecipheriv(algorithm,password,iv)
    var decrypted = decipher.update(data,'hex','utf8')
    decrypted += decipher.final('utf8');
    return decrypted;
}

var decrypted = decrypt('encrypted data from request body');
console.log(decrypted)
</code></pre>

<p>In <code>console</code> I have this error:</p>

<pre><code>crypto.js:183


 var ret = this._handle.final();
                         ^

Error: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length at Decipheriv.final (crypto.js:183:26)
</code></pre>

<p>What should be the correct approach in my <code>decrypt</code> function in NodeJS?</p>
","","75","<php><node.js><encryption><cryptojs>","0","","0","2018-10-30 14:07:39","","4","","","","","2018-10-30 14:07:39",""
"53432263","How to decrypt data with CryptoJS, which is encrypted by Crypto library?","<p>I used Crypto library on client side, and since it's deprecated I'm trying to move to CryptoJS.</p>

<p>I have data that was encrypted (with Crypto) by this code:</p>

<pre><code>export function encrypt(toEncrypt, password) {
    let cipher = crypto.createCipher('aes-256-ctr', password);
    crypted += cipher.final('hex');
    return crypted;
}
</code></pre>

<p>How do I decrypt the output data of this code with CryptoJS?</p>
","","75","<javascript><encryption><aes><cryptojs>","1","","0","2018-11-22 13:39:42","","3","","","","","2018-11-22 13:39:42",""
"52069243","Is there a SHA that's guaranteed to produce a unique hash?","<p>I am looking for a way to hash a user id, obtained from a 3rd party service, such that I can use the hash as a primary key.</p>

<p>My understanding is that the usual <code>SHA-512</code> style algorithms, given an input string that is guaranteed to be unique, are not guaranteed to produce a hash value that is also guaranteed to be unique.</p>

<p>Is there a hashing algorithm that will produce an unique hash?</p>

<p>More specifically is there such an algorithm supported out of the box by NodeJS 10.9 or better</p>
","<p>Most hashing algorithms are doing their best to avoid collisions. SHA 512 ought to be fine for you, if not SHA 256. Note that if you can see collisions in the input data, there will be collisions in the hashes, in which case I recommend appending something else likely unique to two separate accounts - such as the timestamp they were created - before inputting the value into the hash. This will work just fine so long as both inputs are immutable and they never change on the account. </p>

<p>You can use <code>crypto.getHashes()</code> to view available hashes and pick the one you want. You are asking after uniqueness and not security so faster is better.</p>

<p>This answer is also related:
<a href=""https://stackoverflow.com/questions/23639952/when-using-sha-256-hashes-as-a-primary-key-is-it-ok-to-ignore-the-possibility-o?rq=1"">When using SHA-256 hashes as a primary key, is it OK to ignore the possibility of collisions?</a></p>
","75","<node.js><encryption><sha><cryptojs>","1","1","2","2018-08-29 04:31:26","52069433","4","","","","","2018-08-29 03:56:58",""
"52069243","Is there a SHA that's guaranteed to produce a unique hash?","<p>I am looking for a way to hash a user id, obtained from a 3rd party service, such that I can use the hash as a primary key.</p>

<p>My understanding is that the usual <code>SHA-512</code> style algorithms, given an input string that is guaranteed to be unique, are not guaranteed to produce a hash value that is also guaranteed to be unique.</p>

<p>Is there a hashing algorithm that will produce an unique hash?</p>

<p>More specifically is there such an algorithm supported out of the box by NodeJS 10.9 or better</p>
","<p>Length of a SHA-512 hash is 64 bytes(512 bits) long which gives you 10<sup>154</sup> combinations of values. So it has a very less (i mean a very very less ) chance of getting same hash. </p>

<p>How much very less it is, think of the weight of the sun from grams (which is weigh million times like the earch). If any other planet weight 10<sup>154</sup> of grams, not even a millions of millions suns combined can be equals to that amount.</p>

<p>So by very less, it means never. Even the bitcoin addresses are using this method as the wallet address. If you by any chance can find that one combination, you will be a billionaire. I promise</p>

<p><a href=""https://i.stack.imgur.com/boIql.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/boIql.png"" alt=""enter image description here""></a></p>
","75","<node.js><encryption><sha><cryptojs>","1","1","2","2018-08-29 04:31:26","52069433","4","","","","","2018-08-29 03:56:58",""
"53951376","Using crypto to sign and verify strings","<p>I'm playing around with Node's Crypto's <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypairsync_type_options"" rel=""nofollow noreferrer"">generateKeyPairSync</a>, <a href=""https://nodejs.org/api/crypto.html#crypto_class_sign"" rel=""nofollow noreferrer"">Sign</a> and <a href=""https://nodejs.org/api/crypto.html#crypto_class_verify"" rel=""nofollow noreferrer"">Verify</a> but I can't get this ridiculously simple code to work: <code>verify.verify</code> always output false, eventhough it should output true. What am I missing? </p>

<pre><code>const crypto = require('crypto');

const txt = 'Some text to sign';

// generates asymmetric key pair
const keys = crypto.generateKeyPairSync('rsa', {
    modulusLength: 4096,
    publicKeyEncoding: {
        type: 'pkcs1',
        format: 'pem'
    },
    privateKeyEncoding: {
        type: 'pkcs1',
        format: 'pem',
    }
});

// generates a signature object
const sign = crypto.createSign('sha256');
sign.update(txt);

// generates a verify object
const verify = crypto.createVerify('sha256');
verify.update(txt);

// should logs true, but logs false
console.log(
    verify.verify(
        keys.publicKey,
        sign.sign(keys.privateKey, 'base64')
    )
);
</code></pre>
","<p>You can precise <code>signature_format: ""latin1"" | ""hex"" | ""base64""</code> as the third argument of <code>verify.verify</code>. This returns <code>true</code>, as expected:</p>

<pre><code>verify.verify(
    keys.publicKey,
    sign.sign(keys.privateKey, 'base64'),
    'base64'
)
</code></pre>
","75","<node.js><cryptojs>","0","1","1","2018-12-27 22:21:09","","2","","","","","2018-12-27 22:10:53",""
"50477235","How to encrypt value in C# which mimics JavaScript CryptoJS","<p>I am integrating with an API. The author of the API provided me with a Postman pre-request script. That script uses crypto-js - something I have never used before.</p>

<p>In the example, they stringify the JSON payload, parse that as UTF8, in turn parse that as base64, encrypt it using HmacSHA256, parse that back to UTF8, and then stringify that to base 64</p>

<p>I am not sure how I can replicate what the JS is doing to the C# equivalent.</p>

<p>Here is JS code</p>

<pre><code>var crypto = require(""crypto-js"");
pm.globals.set(""SecretKey"", ""key"");
var key    = pm.globals.get(""SecretKey"");

var payload = {
        ""vendor"": {
            ""email"": """",
            ""firstName"": """",
            ""lastName"": """"
        },
        ""purchaseId"": ""12345678""
    };

var payloadString = JSON.stringify(payload);
var payloadUTF8   = crypto.enc.Utf8.parse(payloadString);
var payloadBase64 = crypto.enc.Base64.stringify(payloadUTF8);
pm.environment.set(""Payload"", payloadBase64);
var signature       = crypto.HmacSHA256(payloadUTF8, key);
var signatureUTF8   = crypto.enc.Utf8.parse(signature);
var signatureBase64 = crypto.enc.Base64.stringify(signatureUTF8);
pm.environment.set(""Signature"", signatureBase64);
</code></pre>

<p>In the C# this is as far as I have got:</p>

<pre><code>// payload is JSON object which matches the above.
var payloadString = JsonConvert.SerializeObject(payload);
byte[] bytes = Encoding.Default.GetBytes(payloadString);
var payloadUTF8 = Encoding.UTF8.GetString(bytes);
</code></pre>

<p>I am not sure of the corresponding class in the System.Security.Crypto namespace.</p>
","<p>This is pretty close...  I am not sure about the second UTF8 encoding you do after the hash, because in C# the hash is already in a byte[].</p>

<pre><code>        static void Main(string[] args)
        {
            var secretKey = ""secret"";

            var payload = new
            {
                vendor = new
                {
                    email = """",
                    firstName = """",
                    lastName = """"
                },
                purchaseId = ""12345678""
            };

            string payLoadString = JsonConvert.SerializeObject(payload);
            //NOTE:  C# uses UTF-8 by default, so this is the same as Encoding.Default.GetBytes();
            byte[] payLoadUTF8 = Encoding.UTF8.GetBytes(payLoadString);  
            string payLoadBase64 = Convert.ToBase64String(payLoadUTF8);

            string signatureBase64 = null;
            using (HMACSHA256 hmac = new HMACSHA256(Encoding.Default.GetBytes(secretKey)))
            {
                byte[] hash = hmac.ComputeHash(payLoadUTF8);
                signatureBase64 = Convert.ToBase64String(hash);
            }

            Console.WriteLine($""payLoadBase64:\t{payLoadBase64}"");
            Console.WriteLine($""signatureBase64: \t{signatureBase64}"");
            Console.ReadLine();
        }
</code></pre>

<p><a href=""https://i.stack.imgur.com/eys90.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eys90.png"" alt=""enter image description here""></a></p>
","74","<javascript><c#><cryptojs>","0","1","1","2018-05-23 02:22:59","","1","","","","","2018-05-22 22:21:34",""
"42117632","How to limit key length with Passlib 1.7+","<p>A server protocol requires me to derive a password hash with a limited key size. This is the given JavaScript + CryptoJS implementation:</p>

<pre><code>var params = {keySize: size/32, hasher: CryptoJS.algo.SHA512, iterations: 5000}
var output = CryptoJS.PBKDF2(password, salt, params).toString();
</code></pre>

<p>I want to re-implement this in Python using Passlib, i.e. something like</p>

<pre><code>from passlib.hash import pkbdf2_sha512
output = pbkdf2_sha512.hash(password, salt=salt, rounds=5000)
</code></pre>

<p>The Passlib API does not allow me to specify the key size. How to do it though?</p>
","<p>If the derived key it to long just truncate it to the required length. Each byte is just as valid as every other byte, it makes no difference which bytes you use, there is no ordering.</p>
","74","<python><cryptojs><pbkdf2><passlib>","1","0","1","2017-02-08 17:42:28","42120070","0","1","","","","2017-02-08 15:48:07",""
"56876196","Problem with AES encrypt in javascript and Decrypt in java","<p>I want to encrypt and decrypt ""ABCD1234"" in AES but the output is not the same.
What I have to do to get the same results?</p>

<p>encrypt in crypto-js</p>

<pre><code>function encrypt(string) {
  const key = CryptoJS.enc.Utf8.parse(""g@eNR@2H'9n/ZF8s"");
  const encrypted = CryptoJS.AES.encrypt(string, key, {
    iv: CryptoJS.enc.Utf8.parse(""Fa6Fy$F8.qRvHKU+""),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.NoPadding
  });
  return encrypted.toString()
}

document.getElementById(""encrypted"").innerHTML = encrypt(""ABCD1234"");
</code></pre>

<p>then the output is sRdk5O4U+WA=</p>

<p>when i try to decrypt in java</p>

<pre><code>import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;

class Main {
  public static void main(String[] args) {
        String data = ""sRdk5O4U+WA="";
        String key = ""g@eNR@2H'9n/ZF8s"";
        String iv = ""Fa6Fy$F8.qRvHKU+"";
        try 
        {
            byte[] encrypted1  = Base64.getDecoder().decode(data);
            Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes(""UTF-8""));
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);


            byte[] original = cipher.doFinal(encrypted1);

            String decrypt = new String(original).trim();
            System.out.println(""decrypt ""+decrypt);
        } catch (Exception e)
        {
            System.out.println(""e ""+e.toString());
        }
  }
}
</code></pre>

<p>throws an exception javax.crypto.IllegalBlockSizeException: Input length not multiple of 16 bytes</p>

<p>java code: <a href=""https://repl.it/repls/NoxiousWavyMp3"" rel=""nofollow noreferrer"">https://repl.it/repls/NoxiousWavyMp3</a></p>

<p>javascript code: <a href=""https://codepen.io/anon/pen/ydEpZB"" rel=""nofollow noreferrer"">https://codepen.io/anon/pen/ydEpZB</a></p>
","","74","<javascript><java><encryption><aes><cryptojs>","1","","0","2019-07-09 20:17:11","","5","","6087977","","2019-07-09 20:17:11","2019-07-03 18:39:45",""
"56505793","How to encrypt jpeg on server using C# and decrypt it on browser using Crypt-JS","<p>I'm trying to encrypt jpeg on server and decrypt it on browser like below but failed at step #3.</p>

<ol>
<li>Encrypt jpeg by C# on server</li>
<li>Get encrypted data, vector, and passphrase on client browser </li>
<li>Decrypt on client browser</li>
</ol>

<p>I tried to things below, but nothing helped.</p>

<ol>
<li>use RijndaelManaged instead of AesManaged on server.</li>
<li>use 'CryptoJS.enc.Utf16.parse' instead of 'CryptoJS.enc.Utf8.parse'
on client.</li>
</ol>

<p>Encryption on Server</p>

<pre class=""lang-cs prettyprint-override""><code>public byte[] Encrypt(byte[] bytes, string password, string vector)
{
    AesManaged aes = new AesManaged();
    aes.KeySize = _keySize;
    aes.BlockSize = _blockSize;
    aes.Mode = CipherMode.CBC;
    aes.IV = Encoding.UTF8.GetBytes(vector);
    aes.Key = Encoding.UTF8.GetBytes(password);
    aes.Padding = PaddingMode.PKCS7;

    byte[] encrypted = aes.CreateEncryptor().TransformFinalBlock(bytes, 0, bytes.Length);

    return encrypted;
}
</code></pre>

<p>Decryption on Client</p>

<pre class=""lang-js prettyprint-override""><code>// These values are same as above
var encrypted = ... //  byte[]
var vector = ... // string
var password = ... // string

var cipherParams = CryptoJS.lib.CipherParams.create({
    iv: CryptoJS.enc.Utf8.parse(vector),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
var cipherText = CryptoJS.lib.WordArray.create(encrypted);
var passwordWordArray = CryptoJS.enc.Utf8.parse(password);
var decrypted = CryptoJS.AES.decrypt(cipherText, passwordWordArray, cipherParams);
// decrypted.words is empty here
</code></pre>

<p>Please advise.</p>

<p>I'm using .Net Core MVC 2.1, Crypto-JS 3.1.9-1, and Chrome74.0.3729.169 on Windows 10.</p>

<p><strong>THIS PROBLEM RESOLVED</strong></p>

<p>As Topaco mentioned, there was a flaw in javascript. The corrected code is as below.</p>

<pre><code>var encrypted = ... //  byte[]
var vector = ... // string
var password = ... // string

var cipherParams = CryptoJS.lib.CipherParams.create({
    iv: CryptoJS.enc.Utf8.parse(vector),
    mode: CryptoJS.mode.CBC,
    padding: CryptoJS.pad.Pkcs7
});
var cipherText = CryptoJS.lib.WordArray.create(encrypted);
var cipherTextParam = CryptoJS.lib.CipherParams.create({
            ciphertext: cipherText
        });
var passwordWordArray = CryptoJS.enc.Utf8.parse(password);
var decrypted = CryptoJS.AES.decrypt(cipherTextParam, passwordWordArray, cipherParams);
</code></pre>

<p>Thank you for your help.</p>
","<p>There are two flaws in the JavaScript-code that can be corrected as follows:</p>

<ul>
<li><p>In the JavaScript-code the line: </p>

<pre><code>var cipherText = CryptoJS.lib.WordArray.create(encrypted);
</code></pre>

<p>must be replaced by:</p>

<pre><code>var cipherText = byteArrayToWordArray(encrypted); 
</code></pre>

<p>Here, the function <a href=""https://gist.github.com/artjomb/7ef1ee574a411ba0dd1933c1ef4690d1"" rel=""nofollow noreferrer""><code>byteArrayToWordArray</code></a> is used:</p>

<pre><code>function byteArrayToWordArray(ba) {
    var wa = [], i;
    for (i = 0; i &lt; ba.length; i++) 
        wa[(i / 4) | 0] |= ba[i] &lt;&lt; (24 - 8 * i);
    return CryptoJS.lib.WordArray.create(wa, ba.length);
}
</code></pre>

<p>This function generates a word-array from the byte-array by generating a word (4 bytes) from 4 bytes of the byte-array. In the old code, a word of the same value is generated for each byte, i.e. both arrays have the same number of elements, which is wrong.</p>

<p>Alternatively: </p>

<pre><code>var cipherTextHex = bytesToHex(encrypted);
var cipherText = CryptoJS.enc.Hex.parse(cipherTextHex);
</code></pre>

<p>can also be used. Here, the function <a href=""https://stackoverflow.com/a/34356351/9014097""><code>bytesToHex</code></a> is used:</p>

<pre><code>function bytesToHex(bytes) {
    for (var hex = [], i = 0; i &lt; bytes.length; i++) {
        var current = bytes[i] &lt; 0 ? bytes[i] + 256 : bytes[i];
        hex.push((current &gt;&gt;&gt; 4).toString(16));
        hex.push((current &amp; 0xF).toString(16));
    }
    return hex.join("""");
}
</code></pre>

<p>The function generates a hex-string from the byte-array. From this a word-array is derived using the appropriate <a href=""https://github.com/jakubzapletal/crypto-js#encoders"" rel=""nofollow noreferrer"">encoder</a>.</p></li>
<li><p>In the JavaScript-code, the line: </p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(cipherText, passwordWordArray, cipherParams);
</code></pre>

<p>must be replaced by: </p>

<pre><code>var cipherParamsCipherText = CryptoJS.lib.CipherParams.create({
    ciphertext: cipherText
});
var decrypted = CryptoJS.AES.decrypt(cipherParamsCipherText, passwordWordArray, cipherParams);
</code></pre>

<p>since the <code>decrypted</code>-function expects a <code>CipherParams</code>-object as the first argument instead of a <code>WordArray</code>.</p>

<p>Alternatively, a Base64-encoded string can also be passed:</p>

<pre><code>var cipherTextB64Enc = CryptoJS.enc.Base64.stringify(cipherText);   
var decrypted = CryptoJS.AES.decrypt(cipherTextB64Enc, passwordWordArray, cipherParams);
</code></pre></li>
<li><p>Test: The C#-code provides for the following input:</p>

<pre><code>byte[] bytes = Encoding.UTF8.GetBytes(""The quick brown fox jumps over the lazy dog"");
string password = ""0123456789012345""; // 16 byte -&gt; AES-128
string vector = ""5432109876543210"";   // 16 byte
</code></pre>

<p>the following byte-array as ciphertext:</p>

<pre><code>170, 27, 161, 209, 42, 247, 234, 191, 38, 167, 22, 74, 34, 139, 115, 0, 75, 207, 119, 161, 97, 142, 179, 93, 41, 12, 177, 128, 52, 151, 75, 231, 76, 157, 14, 197, 59, 111, 63, 206, 136, 218, 189, 244, 116, 43, 25, 20
</code></pre>

<p>If the modified JavaScript-code is tested with those data:</p>

<pre><code>var encrypted = [170,27,161,209,42,247,234,191,38,167,22,74,34,139,115,0,75,207,119,161,97,142,179,93,41,12,177,128,52,151,75,231,76,157,14,197,59,111,63,206,136,218,189,244,116,43,25,20]; // byte[]
var vector = ""5432109876543210""    // string
var password = ""0123456789012345""; // string
</code></pre>

<p>it is decrypted correctly.</p>

<p>In the test AES-128 has been used. It can be switched to AES-256 by simply using a 32-byte key instead of a 16-byte key.</p></li>
</ul>
","74","<c#><cryptojs>","1","1","1","2019-06-09 09:37:40","","5","","11617861","","2019-06-09 09:37:40","2019-06-08 11:10:20",""
"22358981","Different hashes with same input values","<p>I'm building a api and I'm having trouble generating a hash with CryptoJs in the client-side interface</p>

<p>My js function does this:</p>

<pre><code>console.log("" username: '"" + $rootScope.username + ""'"");
console.log(""timestamp: '"" + timestamp + ""'"");  
console.log(""  request: '"" + req + ""'"");
console.log(""  entropy: '"" + ""dragonsahead"" + ""'"");
console.log("" password: '"" + $rootScope.password + ""'"");
var message = $rootScope.username+timestamp+req+""dragonsahead"";
console.log(""  message: '"" + message +""'"");
var hash = CryptoJS.HmacSHA1(message, $rootScope.password).toString();
console.log(""     HASH: '"" + hash + ""'"");
return hash;
</code></pre>

<p><code>$rootScope.username</code> and <code>$rootScope.password</code> are user inputs;</p>

<p>JS Log:</p>

<pre><code> username: 'admin' 
timestamp: '1394643128.478' 
  request: '/login' 
  entropy: 'dragonsahead' 
 password: 'e1a47a0407d876c8187b1e984a6813abde8160af' 
  message: 'admin1394643128.478/logindragonsahead' 
     HASH: '5061875265279c7378c95c9536feade1c610492d' 
</code></pre>

<p>I could see in the server-side logs that the hashes did not match.
PHP server Log:</p>

<pre><code>2014-03-12 16:52:08 - INFO --&gt;  username: 'admin' 
2014-03-12 16:52:08 - INFO --&gt; timestamp: '1394643128.478' 
2014-03-12 16:52:08 - INFO --&gt;   request: '/login' 
2014-03-12 16:52:08 - INFO --&gt;   entropy: 'dragonsahead' 
2014-03-12 16:52:08 - INFO --&gt;  password: 'e1a47a0407d876c8187b1e984a6813abde8160af' 
2014-03-12 16:52:08 - INFO --&gt;   message: 'admin1394643128.478/logindragonsahead' 
2014-03-12 16:52:08 - INFO --&gt;      HASH: '4c34a29aa05059d5016bd74796407de3d2e5428c' 
2014-03-12 16:52:08 - INFO --&gt;CLIENTOKEN: '5061875265279c7378c95c9536feade1c610492d'
</code></pre>

<p>After this I checked i <a href=""http://www.freeformatter.com/hmac-generator.htm"" rel=""nofollow"">this site</a> and the hash built by the server was the right one.
So, I decided lo load CryptoJS to a blank page (google, for example) and see what could happen:</p>

<pre><code>&gt; var jq = document.createElement('script');
&gt; jq.src = ""https://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha1.js"";
&gt; document.getElementsByTagName('head')[0].appendChild(jq);
&lt;script src=""https://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/hmac-sha1.js""&gt;&lt;/script&gt;
&gt;var test = CryptoJS.HmacSHA1(""admin1394643128.478/logindragonsahead"",'e1a47a0407d876c8187b1e984a6813abde8160af')
undefined
&gt;test.toString()
""4c34a29aa05059d5016bd74796407de3d2e5428c""
</code></pre>

<p>As CryptoJS returned the right hash, It can only be that I am messing up with my javascript vars. I don't know what could possibly be messing up my variables...</p>
","<p>It happens that I was storing the password in a angularjs's ""$rootScope"".</p>

<p>I need to do <code>$rootScope.password.tostring()</code> instead of <code>$rootScope.password</code>;</p>

<p>Solved.</p>
","74","<javascript><hash><cryptojs>","1","1","1","2014-03-12 17:34:28","22359471","0","","","","","2014-03-12 17:13:39",""
"47447268","Use WebCryptography API to get CryptoJS words","<p>I am migrating function using Google's CryptoJS to browser native WebCryptography API.</p>

<p>With CryptoJS, I use the following code to get the words array of SHA1 hash</p>

<pre><code>CryptoJS.SHA1('1w0g6Ixf2VHvOc+6pGBqDHItFYQ=:9590467').words
</code></pre>

<p>and it returns <code>[888149035, -1762573935, 1178769020, -1914057363, 481296384]</code></p>

<p>With WebCrypto API, I use</p>

<pre><code>const msgBuffer = new TextEncoder().encode('1w0g6Ixf2VHvOc+6pGBqDHItFYQ=:9590467')
const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
const hashArray = Array.from(new Uint8Array(hashBuffer));
</code></pre>

<p>and <code>hashArray</code> is <code>[52, 240, 20, 43, 150, 241, 65, 145, 70, 66, 150, 124, 141, 233, 205, 109, 28, 176, 0, 0]</code></p>

<p>How can I transform this result to the same array as CyptoJS?</p>
","<p>Would've been nice if were as simple as</p>

<pre><code>const msgBuffer = new TextEncoder().encode('1w0g6Ixf2VHvOc+6pGBqDHItFYQ=:9590467')
const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
const hashArray = Array.from(new Int32Array(hashBuffer));
</code></pre>

<p>except for endianness - so, it's just a little more complex</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>async function test() {
    const msgBuffer = new TextEncoder().encode('1w0g6Ixf2VHvOc+6pGBqDHItFYQ=:9590467')
    const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
    const dv = new DataView(hashBuffer);
    const hashArray = [];
    for(let i = 0; i &lt; dv.byteLength; i+=4) {
        hashArray.push(dv.getInt32(i, false));
    }
    return hashArray;
};
test().then(console.log);</code></pre>
</div>
</div>
</p>
","73","<javascript><sha1><cryptojs><webcrypto-api>","0","3","1","2017-11-23 04:38:19","47447651","0","","1412539","","2017-11-23 04:37:16","2017-11-23 03:50:50",""
"54166397","Encrypt with CryptoJs, decrypt with PHP openssl_decrypt","<p>I'm working on encryption from Client Side to Server Side using Javascript library CryptoJS:</p>

<pre><code>function encrypt(msg, pass) {
    var salt = CryptoJS.lib.WordArray.random(128/8);

    var key = CryptoJS.SHA256(pass);
    key = key.toString().substr(0,32);
    var iv = CryptoJS.lib.WordArray.random(128/8);

    var encrypted = CryptoJS.AES.encrypt(msg, key, { 
        iv: iv,
        //padding: CryptoJS.pad.Pkcs7,
        mode: CryptoJS.mode.CBC
    });
    var transitmessage = salt.toString() + iv.toString() + encrypted.toString();
    window.location.href=""test_cbc.php?action=decrypt&amp;msg="" + transitmessage;
}
</code></pre>

<p>On the Server Side:</p>

<pre><code>&lt;?php
if(!empty($_GET[""action""]) &amp;&amp; $_GET[""action""]==""decrypt""){
    $msg=$_GET[""msg""];
    echo ""&lt;pre&gt;"";
    $_salt=substr($msg, 0, 32);
    $_iv = substr($msg, 32, 32);
    $_enc = substr($msg, 64);
    $salt = pack(""H*"", $_salt);
    $iv = pack(""H*"", $_iv);
    $encrypted = substr(base64_decode($_enc),16);
    $key = hash(""SHA256"", ""helloworld"");
    $decrypted = openssl_decrypt($encrypted,""AES-128-CBC"",$key,OPENSSL_RAW_DATA,$iv);
    //$decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, trim($encrypted), MCRYPT_MODE_CBC, $iv);
    echo $decrypted;
    echo ""&lt;/pre&gt;"";
}
</code></pre>

<p>If I use openssl_decrypt, $decrypted is empty. If I use mcrypt I got unreadable chars.</p>

<p>Where I have wrong code?</p>
","","70","<cryptojs><php-openssl>","0","","0","2019-01-14 13:43:18","","1","","6173214","","2019-01-14 13:43:18","2019-01-13 05:45:09",""
"48401693","How to use cryptojs aes decrypt from java code with iv param and SecretKeySpec","<p>From java code I have a code: </p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"", new BouncyCastleProvider());
byte[] keys = Base64.decodeBase64(encryptionKey);
SecretKey speckey = new SecretKeySpec(keys, ""AES"");
byte[] ivParam = new byte[cipher.getBlockSize()];
System.arraycopy(speckey.getEncoded(), 0, ivParam, 0, ivParam.length);
cipher.init(cipherMode, speckey, new IvParameterSpec(ivParam));
return cipher;
</code></pre>

<p>In javascript I have a script to decrypt but it doesn't work:</p>

<pre><code>var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
    iv: iv,
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC
  })
  console.log(""Decrypted: "", decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>I know we need to parse iv(Like this <code>var iv = CryptoJS.enc.Hex.parse(pass);</code> but it doesn't work), key and maybe encrypted first to rub decrypted but I don't know with the Java code above How we can parse iv and key to decrypted. Who has worked in this please help me. Thanks so much &lt;3</p>
","","69","<javascript><java><encryption><aes><cryptojs>","0","","0","2018-01-23 12:24:35","","3","","","","","2018-01-23 12:24:35",""
"53820527","MessageDigest to CryptoJS digest byteBuffer SHA512","<p>i try to digest an array of bytes with SHA512</p>

<p>Java:</p>

<pre><code>MessageDigest sha512 = MessageDigest.getInstance(""SHA-512"");
System.out.println(""sha512: ""+Arrays.toString(sha512.digest(buffer.array())));
</code></pre>

<p>this sample computes with input:</p>

<pre><code>[18, 52, 49, 114, -101, -17, 46, -74, -108, 84, 7, -37, -51, -87, -75, 123, 113, 71, -52, 109, -69, 6, 46, 19, -108, 100, -33, 14, 74, 122, -126, -103, 81, -93]
</code></pre>

<p>this output:</p>

<pre><code>[-6, -75, -91, -50, 3, 5, -78, -74, -63, -33, -103, 24, -18, 39, -45, -22, 30, -10, 58, -7, -2, -28, 77, 43, -78, 58, 123, -101, -12, 22, 63, 16, -56, -17, 58, 13, -26, 61, -45, -22, 100, 121, -118, -86, 53, 115, -42, 90, -70, 67, -61, 100, 54, -46, -113, -119, -95, 27, 23, -95, -76, 51, 52, 99]
</code></pre>

<p>how can i get the same result using CryptoJS on postman?</p>

<p>thanks-</p>
","<p>Here ist the java code, that i want translate to javaScript usung CryptoJS into postman as pre-script to compute a SHA512 hash:</p>

<pre><code>    package hashtest;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import com.google.common.io.BaseEncoding;

public class SpinHash
{
    private static byte[] applyChallenge(byte[] encrypted, byte[] challenge) throws NoSuchAlgorithmException {
        byte[] KEY_CHALLENGE_SEPARATOR = """".getBytes();   
        MessageDigest sha512 = MessageDigest.getInstance(""SHA-512"");

        ByteBuffer buffer = ByteBuffer.allocate(encrypted.length + challenge.length + KEY_CHALLENGE_SEPARATOR.length);
        buffer.put(encrypted);
        buffer.put(KEY_CHALLENGE_SEPARATOR);
        buffer.put(challenge);
        buffer.compact();

        return sha512.digest(buffer.array());
     }

     private static String returnHashPin(String spin, String challenge) throws NoSuchAlgorithmException
     {
         BaseEncoding BASE16 = BaseEncoding.base16();

         byte[] _challenge = BASE16.decode(challenge.toUpperCase());
         byte[] _SPIN = BASE16.decode(spin.toUpperCase());
         byte[] answer; 

         answer = applyChallenge(_SPIN, _challenge); 
         return BASE16.encode(answer).toUpperCase();
     }

    public static void main(String[] args) throws NoSuchAlgorithmException
    {
        System.out.println( ""Hash-Wert:  "" + returnHashPin(""1234"",""089C25A81BA2B17601FB89A47CEE561737AA41055AFE88766883CA9C9E7545F5"") );
    }

}
</code></pre>
","69","<postman><cryptojs><sha512><message-digest>","0","0","1","2018-12-19 10:36:22","","0","","10557144","","2018-12-17 18:14:14","2018-12-17 17:46:35",""
"28768085","Angular directive validation and decryption","<p>I am trying to build a directive that first validates the users input.</p>

<p>After the input is validated I want to hash the string with sha256 and return a new model that only contains the crypted input.</p>

<p>I know its a strange feature but i have a customer that need it this way :)</p>

<p><strong>Here is where im at:</strong> <a href=""http://plnkr.co/edit/gz0zGIgrSSoqgJZhBMcX?p=preview"" rel=""nofollow"">Plunkr</a></p>

<pre><code>var app = angular.module(""myApp"", []);

app.directive('ccInput', function () {

    var types = {
        'socialSecurityNumber': {
            'regex': /^[0-9]{6}-[0-9pPtTfF][0-9]{3}$/,
            'type': 'text',
            'error': 'The value you entered is not a valid social security number.'
        }
    };

    //CryptoJS.SHA256(""hejsan Stefan hur mpr du"");

    var getType = function (type) {
        return types[type];
    };

    return {
        restrict: 'E',
        require: 'ngModel',
        replace: true,
        scope: {
            ccType: ""@"",
            ccId: ""@"",
            ccLabel: ""@"",
            ccModel: ""=ngModel""
        },
        template: '&lt;div class=""cc-group""&gt;&lt;label class=""cc-form-label"" for=""{{ccId}}""&gt;{{ccLabel}}&lt;/label&gt;&lt;input id=""{{ccId}}"" class=""cc-form-input"" data-ng-model=""ccModel"" type=""{{inputType}}"" ng-pattern=""inputRegex"" /&gt;&lt;/div&gt;',
        link: function (scope, elm, attr, ctrl) {


            var options = {},
                textField = angular.element(elm[0].lastChild),
                parser,
                formatter;
            if (!ctrl) {
                return;
            }


            options = getType(attr.ccType);
            scope.inputType = options.type;
            scope.inputRegex = options.regex;
        }
    };
});
</code></pre>
","<p>Solved my issue by making the script easier.</p>

<pre><code>app.directive('valiCrypt', function ($timeout) {

    var validateInput =function(input) {
         // Returns validation logic result here.
    }

    return {
        restrict: 'A',
        require: 'ngModel',
        replace: true,
        scope: {
            vcModel: ""=ngModel"",
            vcDuration: ""@"",
            vcText: ""@""
        },

        link: function (scope) {

            if (!scope.vcDuration) {
                scope.vcDuration = 0;
            }

            if (!scope.vcText) {
                scope.vcText = """";
            }

            scope.$watch('vcModel', function (value) {
                if (value) {
                    if (value.length === 11) {
                        var result = validateInput(value);

                        if (result) {

                            var copy = angular.copy(scope.vcModel);

                            scope.vcModel = scope.vcText;

                            $timeout(function () {
                                // &lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/sha256.js""&gt;&lt;/script&gt;
                                copy = CryptoJS.SHA256(value);
                                scope.vcModel = copy;
                            }, scope.vcDuration, true);
                        }
                    }
                }
            });
        }
    };
});
</code></pre>
","68","<javascript><angularjs><angularjs-directive><cryptojs>","0","0","1","2015-03-02 08:35:55","28805497","1","1","1816580","","2015-02-27 15:18:10","2015-02-27 15:03:24",""
"54059313","How can I convert this java code to javascript","<p>My code should get an encrypted plaintext from the server and decrypts it in react-native with javascript. I have decryption function in java but how can I convert it to javascript?</p>

<p>I tried cryptojs with no success. Because the cipher IV made but a byte array and javascript hasn't the byte data type</p>

<pre><code>public static String decrypt(String plainText, String key) throws Exception {
    byte[] clean = new BASE64Decoder().decodeBuffer(plainText);

    int keySize = 16;
    byte[] keyBytes = new byte[keySize];

    byte[] pwbyte = key.getBytes(""UTF-8"");

    int len = pwbyte.length;

    if (len &gt; keyBytes.length) {
        len = keyBytes.length;
    }

    System.arraycopy(pwbyte, 0, keyBytes, 0, len);
    SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");

    IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
    byte[] encrypted = cipher.doFinal(clean);

    return new String(encrypted, ""UTF-8"");
}
</code></pre>
","<p>I faced the issue of data type mismatch for byte array when rewriting a Python driver to Node.js. In my case I had used the <a href=""https://github.com/dchest/tweetnacl-js"" rel=""nofollow noreferrer"">tweetnacl</a> which is a port of the NACL library in JS.
I solved the problem <a href=""https://stackoverflow.com/questions/51978889/how-to-generate-a-sha256-hash-of-32-bytes-using-nodejs-crypto-in-order-to-avoi"">here</a>. </p>

<p>Hope this helps.</p>
","68","<javascript><java><cryptojs><cbc-mode>","-1","1","1","2019-01-06 07:43:41","","3","","1336469","","2019-01-06 07:07:14","2019-01-06 06:55:01",""
"54942685","AES-256-CTR Encrypting via C# and Decrypting in JS","<p>Using library <strong>Org.BouncyCastle.Crypto</strong> for C# project and <strong>crypto-js</strong> for JS project.</p>

<p>Trying to encrypt data via C# which outputs a string using the function below:</p>

<pre><code>public string EncryptData(string data)
{
    byte[] inputBytes = Encoding.UTF8.GetBytes(data);
    byte[] keyBytes = Encoding.UTF8.GetBytes(ENCRYPTION_KEY);
    IBufferedCipher cipher = CipherUtilities.GetCipher(""AES/CTR/NoPadding"");
        cipher.Init(true, new ParametersWithIV(ParameterUtilities.CreateKeyParameter(""AES"", keyBytes), new byte[16]));

    byte[] encryptedBytes = cipher.DoFinal(inputBytes);
    string base64EncryptedOutputString = Convert.ToBase64String(encryptedBytes);

    return base64EncryptedOutputString;
}
</code></pre>

<p>Then using the function below, in JS, to decrypt: </p>

<pre><code>function decrypt(text) {
    var decipher = crypto.createDecipher(algorithm, password);
    var dec = decipher.update(text, ""hex"", ""utf8"");
    dec += decipher.final(""utf8"");
    return dec;
}
</code></pre>

<p>Function to encrypt via JS is below, in case it helps trying to make the C# code the same as the JS code (not the other way around):</p>

<pre><code>function encrypt(text) {
    var cipher = crypto.createCipher(algorithm, password);
    var crypted = cipher.update(text, ""utf8"", ""hex"");
    crypted += cipher.final(""hex"");
    return crypted;
}
</code></pre>

<p>The decrypt function seems to be returning an empty string, when it should be returning the original data inputted. </p>

<p>Any ideas what may be the issue here? </p>
","","67","<c#><encryption><aes><bouncycastle><cryptojs>","0","","0","2019-03-01 11:24:33","","2","","6483395","","2019-03-01 11:24:33","2019-03-01 10:28:51",""
"58124358","Crypto-JS always return new hash","<p>I want to use <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a> on my angular 8 application .<br>
this is my example code :    </p>

<pre><code>import {Injectable} from '@angular/core';
import * as CryptoJS from 'crypto-js';

@Injectable()
export class HprotoService {

  public enc(msg: string): string {
    return CryptoJS.AES.encrypt(msg, '1234').toString();
  }

  public dec(encMsg: string): string {
    return CryptoJS.AES.decrypt(encMsg, '1234').toString(CryptoJS.enc.Utf8);
  }
}
</code></pre>

<p>and my component :    </p>

<pre><code>import {Component} from '@angular/core';
import {HprotoService} from './hproto.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent {

  private hproto: HprotoService;

  constructor(hproto: HprotoService) {
    this.hproto = hproto;
  }

  public encrypt() {
    console.log(this.hproto.enc('Hello dear !!!'));
  }
}
</code></pre>

<p>My problem is Crypto-JS always return different hash on this example ! </p>

<blockquote>
  <p>U2FsdGVkX19E9JKokPiRUZlrWsykZqAIEVw7ftbBbiA=<br>
  U2FsdGVkX1+8qW19xOpLCy1Zt5lcyxE3LIKrhs5VmjI=<br>
  U2FsdGVkX1/I2AuJM3jBgHuASmWQvkgmaL0RMsR2LXA=<br>
  U2FsdGVkX1+tR17ftLYsWGoEcRA0+zmSjkLHJE3zul0=     </p>
</blockquote>

<p>I think this library add random salt on my password .<br>
How to disable this feature ?     </p>
","<p><code>AES</code> is designed to generated random output that are symmetrical (That can be decrypted)</p>

<p><code>CryptoJS</code> <code>AES</code> uses <code>Math.random()</code> calls to generate a matrix/salt during cyphering and this randomness is included in the encrypted result, that's how decrypt can ""uncypher"" the encrypted data.</p>

<p>You can either <strong><em>fork the CryptoJS Library and replaces <code>Math.random</code> usage by your own seed</em></strong> or you can <strong><em>change the outcome of <code>Math.random</code> at runtime for the duration of the encryption</em></strong>. </p>

<p>Thanks to Javascript, you can assign custom code to <code>native function</code>.</p>

<p>Here is Option #2. It will always return the same output, it uses the function <code>fakeMathRandom</code>. This will temporarily change the outcome of <code>Math.random</code> for the duration of the callBack function</p>

<p><strong>fakeMathRandom function</strong></p>

<pre><code>function fakeMathRandom(callBack) {
     if(!callBack) throw new Error(""Must provide callBack function"");
     //fake predefined output setup
     let seed=0;
     const randomOutputs = [0.04,0.08,0.15,0.16,0.23,0.42,0.52,0.65,0.79,0.89];
     //save nativeFunction
     const Math_random = Math.random;
     //change nativeFunction
     Math.random = function() {return randomOutputs[seed++ % 10];}
     //runs the callback
     const callbackOutput = callBack();
     //restore nativeFunction
     Math.random = Math_random; 
     return callbackOutput;
}
</code></pre>

<p><strong>Usage</strong></p>

<pre><code>var encrypted = fakeMathRandom(() =&gt; CryptoJS.AES.encrypt(text, key));
</code></pre>

<p><strong>Complete Demo Code:</strong>
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>function fakeMathRandom(callBack) {
  if(!callBack) throw new Error(""Must provide callBack function"");
	let seed=0;
  const randomOutputs = [0.04,0.08,0.15,0.16,0.23,0.42,0.52,0.65,0.79,0.89];
  const Math_random = Math.random;
  Math.random = function() {return randomOutputs[seed++ % 10];}
  const callbackOutput = callBack();
  Math.random = Math_random;
  return callbackOutput;
}

var text = ""Text to crypt!!!."";
var key  = 'secret';

var encrypted = fakeMathRandom(() =&gt; CryptoJS.AES.encrypt(text, key)); //This will always return U2FsdGVkX18KPXCjFHrhR4Q5zBbjCf+I/m/w9jbS3EuvE59kzUxK45FrGHDpqalt
var encrypted2 = fakeMathRandom(() =&gt; CryptoJS.AES.encrypt(text, key));
var encrypted3 = fakeMathRandom(() =&gt; CryptoJS.AES.encrypt(text, key));

var decrypted = CryptoJS.AES.decrypt(encrypted, key).toString(CryptoJS.enc.Utf8);


document.getElementById('encrypted').innerHTML = encrypted
document.getElementById('encrypted2').innerHTML = encrypted2
document.getElementById('encrypted3').innerHTML = encrypted3
document.getElementById('decrypted').innerHTML = decrypted</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
&lt;div id=""encrypted""&gt;&lt;/div&gt;
&lt;div id=""encrypted2""&gt;&lt;/div&gt;
&lt;div id=""encrypted3""&gt;&lt;/div&gt;
&lt;div id=""decrypted""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>

<p>I hope that solve you problem!</p>
","67","<javascript><angular><cryptojs>","4","3","1","2019-09-27 11:51:08","58133706","3","1","1842294","","2019-09-26 20:38:57","2019-09-26 20:31:21",""
"50996861","Uncaught Error: Reference.push failed:","<p>So I am using cryptojs and firebase to send an encrypted message and then display that encrypted message in the chat box. I am able to send a regular message without any encryption just fine but when I encrypt the message. I end up getting this error:</p>

<p><strong><em>Uncaught Error: Reference.push failed: first argument contains a function in property 'messages.text.init' with contents = function () {
                            subtype.$super.init.apply(this, arguments);</em></strong></p>

<p>I think because I am pushing an encryption of the message it is a function.
Not sure though.</p>

<pre><code>    messageForm.addEventListener(""submit"", function (e) {
    e.preventDefault();

    var user = auth.currentUser;
    var userId = user.uid;
    if (user.emailVerified) {
        // Get the ref for your messages list
        var messages = database.ref('messages');

        // Get the message the user entered
        var message = messageInput.value;

        var myPassword = ""11111"";
        var myString = CryptoJS.AES.encrypt(message, myPassword);

        // Decrypt the after, user enters the key
        var decrypt = document.getElementById('decrypt')

        // Event listener takes input
        // Allows user to plug in the key
        // function will decrypt the message
        decrypt.addEventListener('click', function (e) {
            e.preventDefault();
            // Allows user to input there encryption password 
            var pass = document.getElementById('password').value;

            if (pass === myPassword) {
                var decrypted = CryptoJS.AES.decrypt(myString, myPassword);

                document.getElementById(""demo0"").innerHTML = myString;
                // document.getElementById(""demo1"").innerHTML = encrypted;
                document.getElementById(""demo2"").innerHTML = decrypted;
                document.getElementById(""demo3"").innerHTML = decrypted.toString(CryptoJS.enc.Utf8);
            }
        });

        // Create a new message and add it to the list.
        messages.push({
                displayName: user.displayName,
                userId: userId,
                pic: userPic,
                text: myString,
                timestamp: new Date().getTime() // unix timestamp in milliseconds

            })
            .then(function () {
                messageStuff.value = """";

            })
            .catch(function (error) {
                windows.alert(""Your message was not sent!"");
                messageStuff;
            });
</code></pre>
","<p>Look at this line of code:</p>

<pre><code>var myString = CryptoJS.AES.encrypt(message, myPassword);
</code></pre>

<p><code>myString</code> isn't a string.  I believe it's a CipherParams object.  (<a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">Reading from the documentation here</a>.)  You're then trying to make that object a field in the database:</p>

<pre><code>messages.push({
        displayName: user.displayName,
        userId: userId,
        pic: userPic,
        text: myString,
        timestamp: new Date().getTime() // unix timestamp in milliseconds
})
</code></pre>

<p>This isn't going to work.  You need to store a string instead of an object there.  Try calling toString() the return value of encrypt() to store a string that you can later convert back to whatever you need:</p>

<pre><code>messages.push({
        displayName: user.displayName,
        userId: userId,
        pic: userPic,
        text: myString.toString(),
        timestamp: new Date().getTime() // unix timestamp in milliseconds
})
</code></pre>
","66","<javascript><firebase><cryptojs>","0","1","1","2018-06-23 03:10:46","50997622","0","0","","","","2018-06-23 00:08:29",""
"53412539","Triple DES Encrytion in GWT and Decryption in Javascript","<p>I need to do triple DES encryption in GWT client file and need to do decryption of encrypted string in javascript. I have used TripleDesCipher in GWT but while doing decryption in javascript using crypto-js, I am getting blank string. Following is my GWT code.</p>

<pre><code>    TripleDesCipher cipher = new TripleDesCipher();
    String enc ="""";
    String key = ""579D2D852F2F3BABABBD71B7"";

    cipher.setKey(key.getBytes());
    try {
      enc = cipher.encrypt(String.valueOf(value));


    } catch (DataLengthException e1) {
      e1.printStackTrace();
    } catch (IllegalStateException e1) {
      e1.printStackTrace();
    } catch (InvalidCipherTextException e1) {
      e1.printStackTrace();
    }
</code></pre>

<p>Following is my javascript code for decryption.</p>

<pre><code>var encrypted = urlParams.get('id');

var base64String = encrypted.toString();
alert(base64String);
var key = ""579D2D852F2F3BABABBD71B"";        

var decrypted = 
CryptoJS.TripleDES.decrypt(base64String,key);
console.log(""DES3 decrypted text:""+ decrypted.toString(CryptoJS.enc.Utf8));
</code></pre>
","","66","<java><encryption><gwt><cryptojs><tripledes>","2","","0","2018-11-22 03:20:39","","0","","6250308","","2018-11-22 03:20:39","2018-11-21 12:56:52",""
"54701686","Matching CryptoJS.SHA256() with hashlib.sha256() for a JSON","<p>As a part of IEFT standard, I need to hash the body of a JSON request.</p>

<p>I have a reference code in JS that is known to produce the right hash, but now I'm stuck with matching the result in Python.</p>

<p>The JSON body:</p>

<pre><code>body = {""description"":""Test ticket""}
</code></pre>

<p>The JS code:</p>

<pre><code>bodyHash = CryptoJS.SHA256(body).toString(CryptoJS.enc.Base64)
</code></pre>

<p>Please note it's not <code>JSON.stringify(body)</code>! The ""correct"" hash (the one I'm looking to match):</p>

<pre><code>TqXFCKZWbnYkBUP4/rBv1Fd3e+OVScQBZDav2mXSMw4=
</code></pre>

<p>The Python solution should be along the lines of:</p>

<pre><code>body_hash = base64.b64encode(hashlib.sha256(repr(body).encode('utf-8')).digest()).decode('ascii')
</code></pre>

<p>Which produces something different:</p>

<pre><code>z0RpYmKAIfVibpSLJx/iRDZaNHJkJ2+rcenc1KEEAUw=
</code></pre>

<p>Is there even a way to match those hashes? How the JS object is hashed in CryptoJS?</p>
","","65","<javascript><python><json><sha256><cryptojs>","2","","0","2019-02-15 01:54:31","","3","","","","","2019-02-15 01:54:31",""
"48018093","How Can I Create SHA512 Hash In Node Js ... How Can i convert this java code into NodeJs","<p>How can i convert this java into NodeJS    </p>

<pre><code>byte[] decodedKey = Hex.decodeHesecretKey.toCharArray());    
SecretKeySpec keySpec = new SecretKeySpec(decodedKey, algorithm);    
Mac mac = Mac.getInstance(algorithm);    
mac.init(keySpec);    
byte[] dataBytes = data.getBytes(""UTF-8"");    
byte[] signatureBytes = mac.doFinal(dataBytes);    
String signature = new String(Base64.encodeBase64(signatureBytes),""UTF-8""); 
return signature;
</code></pre>
","","65","<javascript><java><node.js><hash><cryptojs>","0","","0","2017-12-29 05:56:14","","2","","","","","2017-12-29 05:56:14",""
"42899982","jquery plugin appending external librarys are not reconized (crypto-js,criptico)","<p>I am building a jquery plugin im using this code to include external files:</p>

<pre><code>if(!$(""script[src*='https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js']"").length){

        var myScript =  ""&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js'&gt;&lt;/script&gt;"";

        $(myScript).appendTo(""head"");

    }
</code></pre>

<p>It works great with promise js , but when i try this with crypto-js and cryptico scripts it  does append the files to the html but for some reason i can't access the imported scripts.  this is the error i get :</p>

<p>Uncaught TypeError: Cannot read property 'lib' of undefined</p>
","<p>Try this way:</p>

<pre><code>if($(""script[src*='https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js']"").length &lt; 1){
    $.getScript('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js');
}
</code></pre>
","65","<javascript><jquery><cryptojs>","0","0","1","2017-03-20 10:11:24","42900838","2","","","","","2017-03-20 09:31:30",""
"57462250","AES encryption in python and decryption in java not working","<p>I have Java based Web API which receives AES encrypt user credentials and let the user get the session token. This is working fine with AES encryption on client side with CryptoJS. But the same throws bad padding exception while trying to access this API from Python. </p>

<p>In Java I've used PKCS5Padding padding. I have tried this with NoPadding as well, but in that case the de-crypted text is simply empty. Also, when trying with NoPadding, CryptoJS code is not working properly. As, this API should work for any client side program (Later I'm planning to expand this to PHP, .Net and R as well), I want to have a common, working mechnism for encryption of passwords thru AES. I'm pretty new to python and I have tried various programs provided in stack overflow as well as in other blogs on this subject. </p>

<p>Here is the java part</p>

<pre><code>public String decrypto(String cipherText, String secret) {
        byte[] cipherData = java.util.Base64.getDecoder().decode(cipherText);
        byte[] saltData = Arrays.copyOfRange(cipherData, 8, 16);
        String decryptedText = null;
        try {
            MessageDigest md5 = MessageDigest.getInstance(""MD5"");

            final byte[][] keyAndIV = GenerateKeyAndIV(32, 16, 1, saltData, secret.getBytes(StandardCharsets.UTF_8),
                    md5);
            SecretKeySpec key = new SecretKeySpec(keyAndIV[0], ""AES"");
            IvParameterSpec iv = new IvParameterSpec(keyAndIV[1]);

            byte[] encrypted = Arrays.copyOfRange(cipherData, 16, cipherData.length);
            Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
            byte[] decryptedData = aesCBC.doFinal(encrypted);
            decryptedText = new String(decryptedData, StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
</code></pre>

<p>And this line send the encrypted password from CrptoJS without any issues which gets de-crypted properly in Java</p>

<pre><code>encKey = CryptoJS.AES.encrypt(this.logingrp.value['loginpass'], this.localPublicKey).toString();
      this.localLogin(encKey);
</code></pre>

<p>LocalLogin is an AJAX function to call the API</p>

<p>Python code is below. I'm using Pycryptodome</p>

<pre><code>import requests, json
import base64

from Crypto.Cipher import AES
from Crypto.Util import Padding
from Crypto import Random
from urllib.parse import urlencode
from urllib.request import Request, urlopen
from hashlib import sha256



BS = 16
pad = lambda s: bytes(s + (BS - len(s) % BS) * chr(BS - len(s) % BS), 'utf-8')
unpad = lambda s : s[0:-ord(s[-1:])]

class AESCipher:

    def __init__( self, key ):
        self.key = bytes(key, 'utf-8')

    def encrypt( self, raw ):
        raw = pad(raw)
        iv = Random.new().read( AES.block_size )
        cipher = AES.new(self.key, AES.MODE_CBC )
        return base64.b64encode( iv + cipher.encrypt( raw ) )

    def decrypt( self, enc ):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key, AES.MODE_CBC, iv )
        return unpad(cipher.decrypt( enc[16:] )).decode('utf8')

header = {""Content-type"": ""application/json"",
          ""Authorization"": ""Bearer CT9797""
          } 

password = 'stone@123'
keyphrase = '9DA538D0HMQXQRGI';

cipher = AESCipher(keyphrase)
encrypted = cipher.encrypt(password).decode('utf8')


payload={'userId':'CT9797','userData':encrypted,'encKey':''}
response_decoded_json = requests.post(url=_base_URL+'eLogin', data=json.dumps(payload), headers=header)
print(response_decoded_json.status_code)
</code></pre>

<p>The below exception occurs while trying the above program on java side</p>

<pre><code>javax.crypto.BadPaddingException: Given final block not properly padded. Such issues can arise if a bad key is used during decryption.
    at com.sun.crypto.provider.CipherCore.unpad(CipherCore.java:975)
    at com.sun.crypto.provider.CipherCore.fillOutputBuffer(CipherCore.java:10
</code></pre>

<p>Appreciate your time in reading and helping me out.</p>
","","64","<java><python-3.x><encryption><aes><cryptojs>","0","","0","2019-08-12 13:35:01","","6","","","","","2019-08-12 13:35:01",""
"54402923","Cloudflare worker generate smime signature","<p>Generating smime (CMS) signature with node-forge working good on Cloudflare Worker Editor, but When I deploy the code, I'm getting CPU Timeout (Error 1102).
So, I assume, when I call <code>signature.sign({ detached: true });</code>, it just taking time to generate signature.
I'm using <code>Business: 50ms</code>.</p>

<p>So,</p>

<ol>
<li>Is it possible to increase node-forge process by setting any properties?</li>
<li>Is there any other alternative other then node-forge which I can use (expecting some example, I studies pkijs)</li>
</ol>

<p>Looking for guide line.</p>
","<p>Unfortunately, cryptographic algorithms implemented in pure JavaScript are likely to run very slowly and exceed the current CPU time limits imposed by Workers.</p>

<p>Instead, try using the WebCrypto API. Workers supports some of WebCrypto, and in particular it supports generating signatures in <code>RSASSA-PKCS1-v1_5</code> format. Based on a quick Google search it looks like this may be what you need for S/MIME.</p>
","64","<node.js><cryptojs><webcrypto-api><cloudflare-workers>","0","2","2","2019-02-11 00:00:26","","0","","3296928","","2019-01-28 13:46:21","2019-01-28 13:19:54",""
"54402923","Cloudflare worker generate smime signature","<p>Generating smime (CMS) signature with node-forge working good on Cloudflare Worker Editor, but When I deploy the code, I'm getting CPU Timeout (Error 1102).
So, I assume, when I call <code>signature.sign({ detached: true });</code>, it just taking time to generate signature.
I'm using <code>Business: 50ms</code>.</p>

<p>So,</p>

<ol>
<li>Is it possible to increase node-forge process by setting any properties?</li>
<li>Is there any other alternative other then node-forge which I can use (expecting some example, I studies pkijs)</li>
</ol>

<p>Looking for guide line.</p>
","<p>CloudFlare has added <a href=""https://github.com/cloudflare/worker-examples"" rel=""nofollow noreferrer"">WebCrypto</a> to the workers recently. You really dont want to use JS crypto, Forge is full of it, see <a href=""https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2011/august/javascript-cryptography-considered-harmful/"" rel=""nofollow noreferrer"">Javascript Cryptography Considered Harmful</a> for why.</p>

<p>If what you want is a pure crypto signature you don't even need PKIjs, just use it <a href=""https://github.com/diafygi/webcrypto-examples"" rel=""nofollow noreferrer"">directly</a></p>

<p>If you really want S/MIME a look at <a href=""http://pkijs.org"" rel=""nofollow noreferrer"">PKIjs</a> and use WebCrypto. the <a href=""https://pkijs.org/examples/SMIMEexample.html"" rel=""nofollow noreferrer"">S/MIME examples</a>. </p>
","64","<node.js><cryptojs><webcrypto-api><cloudflare-workers>","0","0","2","2019-02-11 00:00:26","","0","","3296928","","2019-01-28 13:46:21","2019-01-28 13:19:54",""
"48535783","Decryption on java side","<p>I found core library and Now I can encrypt and decrypt on Jsp</p>

<pre><code>var encryptedpassword=CryptoJS.AES.encrypt(password,'abcd');
var ciphertext = encryptedpassword.ciphertext.toString(CryptoJS.enc.Base64);
console.log(ciphertext);
</code></pre>

<p>and decrypted using following</p>

<pre><code>var decryptedpassword=CryptoJS.AES.decrypt(encryptedpassword,'abcd');
var plaintext = decryptedpassword.toString(CryptoJS.enc.Utf8);
console.log(plaintext);
</code></pre>

<p>My problem now is I want to decrypt the encrypted password on java side can some one tell me how can I do it?</p>
","","64","<javascript><java><cryptojs>","1","","0","2018-01-31 07:07:09","","2","","4443323","","2018-01-31 07:07:09","2018-01-31 06:27:03",""
"57285959","How is AES implemented in CryptoJS?","<p>I want to verify that CryptoJS's AES is actually implementing AES. However, I am not able to verify it by encrypting a plain using CryptoJS and decrypting the cipher with a python script using PyCrypto.</p>

<p>Source for CryptoJS:</p>

<p><a href=""http://ramblings.mcpher.com/Home/excelquirks/gassnips/cryptogs"" rel=""nofollow noreferrer"">http://ramblings.mcpher.com/Home/excelquirks/gassnips/cryptogs</a>
<a href=""https://script.google.com/d/1IEkpeS8hsMSVLRdCMprij996zG6ek9UvGwcCJao_hlDMlgbWWvJpONrs/edit?usp=sharing"" rel=""nofollow noreferrer"">https://script.google.com/d/1IEkpeS8hsMSVLRdCMprij996zG6ek9UvGwcCJao_hlDMlgbWWvJpONrs/edit?usp=sharing</a></p>

<p>I gathered that in CryptoJS-AES, </p>

<ol>
<li>it does 1 iteration of MD5 on the passphrase to generate the symmetric key.</li>
<li>In the cipher, the first 16bytes is the salt in the form of ""Salted__[8byte random]"".</li>
<li>The salt is used as the iv for the encryption/decryption.</li>
<li>done in CBC-Mode</li>
</ol>

<p>The cipher is created with the below code in Google App Script.</p>

<pre><code>var encryptedMessage = CryptoJS.AES.encrypt ('this is my message to be encrypted', '0123456789abcdef').toString();
//var decryptedMessage = CryptoJS.AES.decrypt (encryptedMessage, '0123456789abcdef').toString(CryptoJS.enc.Utf8);
</code></pre>

<p>I then tried to decrypt the cipher with the below python code. (adapted from some stackoverflow thread)</p>

<pre><code>import base64
import hashlib
from Crypto import Random
from Crypto.Cipher import AES

class AESCipher(object):
    def __init__(self, key): 
        self.bs = 16
        self.key = hashlib.md5(key.encode()).digest()
        self.key = key

    def decrypt(self, enc):
        enc = base64.b64decode(enc)
        iv = enc[:16]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return self._unpad(cipher.decrypt(enc[16:])).decode(""utf-8"")

    def _pad(self, s):
        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)

    @staticmethod
    def _unpad(s):
        print s
        return s[:-ord(s[len(s)-1:])]

key = ""0123456789abcdef""
aes = AESCipher(key)
cipher = ""U2FsdGVkX1/CuZIB2c+sxY7rA0jw19EOKrL87cU1bzwU9BlIDP6VZvsSzXAQ+6v8S2GQOzf4VpEw7AK0LSFfKw==""
bbb = aes.decrypt(cipher)
print bbb #prints out gibberish
</code></pre>

<p>How can i verify that the AES is correct? Or what have i done wrong here?</p>
","<p>CryptoGS is a direct port of CryptoJS and you can find the CryptoJS AES implementation at the following link:
<a href=""https://github.com/brix/crypto-js/blob/develop/src/aes.js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js/blob/develop/src/aes.js</a></p>

<p>CryptoGS' code is minified but the following gist breaks up some of the encryption algos into separate sections:
<a href=""https://gist.github.com/DimuDesigns/5666e9c6df531b8d11099dfd291ed0e4"" rel=""nofollow noreferrer"">https://gist.github.com/DimuDesigns/5666e9c6df531b8d11099dfd291ed0e4</a></p>

<p>You can try running the AES algo in the gist through a code beautfier and comparing the two.</p>
","63","<python><aes><cryptojs>","1","0","1","2019-07-31 13:17:37","","0","","3486675","","2019-07-31 11:32:49","2019-07-31 08:02:37",""
"58710783","Decrypt file while streaming in nodejs","<p>I have a file that I have encrypted that by crypto.createCipher, and Now I want to stream that file and decrypted that while streaming.</p>

<p>I write the following code but when I set ""Content-Range"" and ""Accept-Ranges"" header, streaming not working.</p>

<p>How can I streaming and decrypt that with content-range?</p>

<pre><code>
  const path = ""file path"";
  const stat = fs.statSync(path);
  const fileSize = stat.size;
  const range = req.headers.range;

  const algorithm = 'aes-256-ctr';
  const password = '123456';
  const encrypt = crypto.createCipher(algorithm, password);
  const decrypt = crypto.createDecipher(algorithm, password);

  if (range) {
    const parts = range.replace(/bytes=/, """").split(""-"");
    const start = parseInt(parts[0], 10);
    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;

    const chunksize = end - start + 1;
    const file = fs.createReadStream(path, { start, end });
    const head = {
      ""Content-Range"": `bytes ${start}-${end}/${fileSize}`,
      ""Accept-Ranges"": ""bytes"",
      ""Content-Length"": chunksize,
      ""Content-Type"": ""video/mp4""
    };

    res.writeHead(200, head);
    file
        .pipe(decrypt)
        .pipe(res);
  } else {
    const head = {
      ""Content-Length"": fileSize,
      ""Content-Type"": ""video/mp4""
    };
    res.writeHead(200, head);
    fs.createReadStream(path).pipe(decrypt).pipe(res);
  }
</code></pre>
","","63","<javascript><node.js><encryption><streaming><cryptojs>","1","","0","2019-11-05 11:50:25","","0","","","","","2019-11-05 11:50:25",""
"57447707","How to convert Java AES ECB Encryption Code to Nodejs","<p>I have code in java for encryption </p>

<pre><code>public String encrypt() throws Exception {
    String data = ""Hello World"";
    String secretKey = ""j3u8ue8xmrhsth59"";
    byte[] keyValue = secretKey.getBytes();
    Key key = new SecretKeySpec(keyValue, ""AES"");
    Cipher c = Cipher.getInstance(""AES"");
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encVal = c.doFinal(StringUtils.getBytesUtf8(data));
    String encryptedValue = Base64.encodeBase64String(encVal);
    return encryptedValue;
}
</code></pre>

<p>It returns same value ( eg5pK6F867tyDhBdfRkJuA== ) as the <a href=""https://www.devglan.com/online-tools/aes-encryption-decryption"" rel=""nofollow noreferrer"">tool here</a>
<a href=""https://i.stack.imgur.com/Pe0Ca.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Pe0Ca.png"" alt=""enter image description here""></a></p>

<p>I converted the code to Nodejs (crypto)</p>

<pre><code>var crypto = require('crypto')

encrypt(){
      var data = ""Hello World""
      var cipher = crypto.createCipher('aes-128-ecb','j3u8ue8xmrhsth59')
      var crypted = cipher.update(data,'utf-8','base64')
      crypted += cipher.final('base64')
      return crypted;
}
</code></pre>

<p>But this is giving a different value ( POixVcNnBs3c8mwM0lcasQ== )</p>

<p>How to get same value from both?
What am I missing?</p>
","<p>Thanks to dave now I am getting same result both for Java and Nodejs/JavaScript</p>

<pre><code>var crypto = require('crypto')

encrypt(){
      var data = ""Hello World""
      var iv = new Buffer(0);
       const key = 'j3u8ue8xmrhsth59'
      var cipher = crypto.createCipheriv('aes-128-ecb',new Buffer(key),new Buffer(iv))
      var crypted = cipher.update(data,'utf-8','base64')
      crypted += cipher.final('base64')
      return crypted;
}
</code></pre>
","62","<java><node.js><aes><cryptojs><ecb>","0","0","1","2019-08-11 10:14:34","57448395","1","1","1446379","","2019-08-11 08:14:20","2019-08-11 06:05:21",""
"52233969","encryption with tripleDes in meteor","<p>I have a code in Asp.net that encrypts a string with TripleDES algorithm in EBC mode and other settings. and uses a key which is encrypted using Base64. I have to write this code in meteor (javascript). Therefore I used the CryptoJs library but the results are not the same. Here is the Asp.net code:</p>

<pre><code>var str;
var key;

var dataBytes = Encoding.UTF8.GetBytes(str);
var symmetric = SymmetricAlgorithm.Create(TripleDes);
symmetric.Mode = CipherMode.ECB;
symmetric.Padding = PaddingMode.PKCS7;

var encryptor = symmetric.CreateEncryptor(Convert.FromBase64String(key), new byte[8]);

enc = Convert.ToBase64String(encryptor.TransformFinalBlock(dataBytes, 0, dataBytes.Length));
</code></pre>

<p>and its my code:</p>

<pre><code>var key = ""helloooooooooooooooooooooooooooo"";
var str = ""24000615;251985;1000"" ;
var dataBytes = CryptoJS.enc.Utf8.parse(str);

var key = CryptoJS.enc.Base64.parse(key);

var encrypted = CryptoJS.DES.encrypt(dataBytes, key , {
 mode: CryptoJS.mode.ECB,
 padding: CryptoJS.pad.Pkcs7,
});
var enc = encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>

<p>in the first code if I set the variables as bellow:</p>

<p>key = ""helloooooooooooooooooooooooooooo"" and str = ""24000615;251985;1000"".</p>

<p>the encrypted text value will be:
enc = ORwbhqYfUAngc0KZf63XXO3NLToIHXXk</p>

<p>but in my code the encrypted value will be:
enc= ""inalvFtdhxelvdwnUxILMZhQwZahVsO4""
which are not the same. I do not know why this happens.</p>
","","62","<meteor><encryption><base64><cryptojs><tripledes>","2","","0","2018-09-11 05:56:17","","4","","10272519","","2018-09-11 05:56:17","2018-09-08 09:38:21",""
"56490535","Crypto-Js library's hmac-256 script returning function structure instead of value within Google Apps Script, working fine outside?","<p>I am setting up a google spreadsheet project to connect to my CryptoExchange
API.
But when it comes to this simple CryptoJs Hmac-sha256 script, it's not working: it is returning the function structure instead of the value, while outside it's working fine (<a href=""https://jsfiddle.net/John_Galassi/9n5oLwxv/54/"" rel=""nofollow noreferrer"">see my jsfiddle</a>).</p>

<p>Now, I understand <a href=""https://stackoverflow.com/questions/26731438/inject-external-javascript-file-in-google-app-scriptgoogle-docs#answer-26734725"">from this Stack answer</a> by Cameron Roberts that Apps Script behaves differently under certain POVs, but I can't understand how this relates.</p>

<p>Besides, <strong>if I just switch script</strong> and use the Stanford Javascript Crypto 
Library, <strong>the code executes perfectly</strong> with no issue at all, both within Google 
Apps Script AND outside of it of course.</p>

<p>Here is my code:</p>

<pre class=""lang-js prettyprint-override""><code>eval(UrlFetchApp.fetch('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/hmac-sha256.js').getContentText());


function write() {
var hash = CryptoJS.HmacSHA256(""message"", ""secret"");
return hash;
}
Logger.log(write());
</code></pre>

<p>and the console log from Google Apps Script</p>

<pre class=""lang-js prettyprint-override""><code>[19-06-07 00:53:32:859 PDT] {mixIn=
function (a) {
    for (var c in a) {
        a.hasOwnProperty(c) &amp;&amp; (this[c] = a[c]);
    }
    a.hasOwnProperty(""toString"") &amp;&amp; (this.toString = a.toString);
}
, extend=
function (a) {
    q.prototype = this;
    var c = new q();
    a &amp;&amp; c.mixIn(a);
    c.hasOwnProperty(""init"") || (c.init = function () {
        c.$super.init.apply(this, arguments);
    });
    c.init.prototype = c;
    c.$super = this;
    return c;
}
, init=
function (a, c) {
    a = this.words = a || [];
    this.sigBytes = c != s ? c : 4 * a.length;
}
, random=
function (a) {
    for (var c = [], d = 0; d &lt; a; d += 4) {
        c.push(4294967296 * h.random() | 0);
    }
    return new r.init(c, a);
}
, words=[-1.956689808E9, 6.97680217E8, -1.940439631E9, -5.01717335E8, -

1.205480281E9, -1.798215209E9, 1.0131952E8, 1.469462027E9], clone=
function () {
    var a = m.clone.call(this);
    a.words = this.words.slice(0);
    return a;
}
, sigBytes=32.0, create=
function () {
    var a = this.extend();
    a.init.apply(a, arguments);
    return a;
}
, toString=
function (a) {
    return (a || k).stringify(this);
}
, concat=
function (a) {
    var c = this.words, d = a.words, b = this.sigBytes;
    a = a.sigBytes;
    this.clamp();
    if (b % 4) {
        for (var e = 0; e &lt; a; e++) {
            c[b + e &gt;&gt;&gt; 2] |= (d[e &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - 8 * (e % 4) &amp; 255) &lt;&lt; 24 - 

8 * ((b + e) % 4);
        }
    } else {
        if (65535 &lt; d.length) {
            for (e = 0; e &lt; a; e += 4) {
                c[b + e &gt;&gt;&gt; 2] = d[e &gt;&gt;&gt; 2];
            }
        } else {
            c.push.apply(c, d);
        }
    }
    this.sigBytes += a;
    return this;
}
, clamp=
function () {
    var a = this.words, c = this.sigBytes;
    a[c &gt;&gt;&gt; 2] &amp;= 4294967295 &lt;&lt; 32 - 8 * (c % 4);
    a.length = h.ceil(c / 4);
}
, $super={extend=
function (a) {
    q.prototype = this;
    var c = new q();
    a &amp;&amp; c.mixIn(a);
    c.hasOwnProperty(""init"") || (c.init = function () {
        c.$super.init.apply(this, arguments);
    });
    c.init.prototype = c;
    c.$super = this;
    return c;
}
, mixIn=
function (a) {
    for (var c in a) {
        a.hasOwnProperty(c) &amp;&amp; (this[c] = a[c]);
    }
    a.hasOwnProperty(""toString"") &amp;&amp; (this.toString = a.toString);
}
, init=
function () {
}
, clone=
function () {
    return this.init.prototype.extend(this);
}
, create=
function () {
    var a = this.extend();
    a.init.apply(a, arguments);
    return a;
}
}}
</code></pre>

<p>While the same code <a href=""https://jsfiddle.net/John_Galassi/9n5oLwxv/54/"" rel=""nofollow noreferrer"">within jsfiddle</a> works fine</p>

<p>EDIT:
While my question is still a source of curiosity for me, I have just found a whole branch of replies here on stack which involve a specific method <strong>within Google Apps Script</strong> I didn't know about: <strong>a built in Class Utility</strong> for creating HMAC Sha256 signature.</p>

<p>This may not be the very answer to my question in terms of theoretical knowledge, but will probably solve my problem from a practical point of view; so I will look into that now.
Thanks</p>

<p><a href=""https://stackoverflow.com/questions/22889270/generate-a-keyed-hash-value-using-the-hmac-method-with-google-apps-script?rq=1"">Generate a keyed hash value using the HMAC method with Google Apps Script</a></p>

<p><a href=""https://stackoverflow.com/questions/41232615/how-to-get-hex-value-from-computehmacsha256signature-method-of-google-apps-scrip"">How to get Hex value from computeHmacSha256Signature method of Google Apps Script?</a></p>

<p><a href=""https://stackoverflow.com/questions/16216868/get-back-a-string-representation-from-computedigestalgorithm-value-byte"">get back a string representation from computeDigest(algorithm, value) byte[]</a></p>
","<ul>
<li>You want to retrieve the value of <code>8b5f48702995c1598c573db1e21866a9b825d4a794d169d7060a03605796360b</code> from <code>CryptoJS.HmacSHA256(""message"", ""secret"")</code> using Google Apps Script.</li>
</ul>

<p>If my understanding is correct, how about directly calculating the value using the methods of Google Apps Script? In this case, CryptoJS is not used. Please think of this as just one of several answers.</p>

<h3>Sample script:</h3>

<pre><code>var res = Utilities.computeHmacSha256Signature(""message"", ""secret"")
  .map(function(e) {return (""0"" + (e &lt; 0 ? e + 256 : e).toString(16)).slice(-2)}).join("""");
Logger.log(res)
</code></pre>

<h3>Result:</h3>

<pre><code>8b5f48702995c1598c573db1e21866a9b825d4a794d169d7060a03605796360b
</code></pre>

<h3>Note:</h3>

<p>The important point for above script is as follows.</p>

<ul>
<li>At Google Apps Script, the data which was encrypted by <code>Utilities.computeHmacSha256Signature()</code> is the bytes array of the signed hexadecimal.</li>
<li>In your case, the bytes array is converted to the unsigned hexadecimal.</li>
</ul>

<h3>References:</h3>

<ul>
<li><a href=""https://developers.google.com/apps-script/reference/utilities/utilities#computehmacsha256signaturevalue-key_4"" rel=""nofollow noreferrer"">computeHmacSha256Signature(value, key)</a></li>
<li><a href=""https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"" rel=""nofollow noreferrer"">map()</a></li>
</ul>

<p>If I misunderstood your question and this was not the direction you want, I apologize.</p>
","62","<javascript><google-apps-script><google-sheets><cryptojs><hmacsha1>","2","1","1","2019-06-07 09:31:12","56491697","0","1","6589922","","2019-06-07 09:29:00","2019-06-07 08:18:39",""
"56546394","Anyone gotten CryptoJS to work with Cybersource REST API v3 reporting for the Signature?","<p>Unable to generate correct HMAC 256 hash for Cybersource Signature headers</p>

<p>I have been working on this for a couple of days, and I can easily get it to work within .Net using the supplied sample code to generate the correct HMAC Signature.  However I cannot get CryptoJS to work, I beleive it stems from the fact that CryptoJS is interpreting the ""\n"" as a LRCF internally and thus throws the encryption off.  Please be aware that I am limited to ECMA5 and have brought the CryptoJS in as a minified function.</p>

<p>var data = ""host: api.cybersource.com\ndate: Mon, 10 Jun 2019 20:41:05 GMT\n(request-target): get /reporting/v3/report-downloads?organizationId={OrgId}&amp;reportDate=2019-06-06&amp;reportName=PaymentBatchDetailReport\nv-c-merchant-id: {MerchId}"";</p>

<p>var hash   = CryptoJS.HmacSHA256(data, ""{SecretKey}"");</p>

<p>var base64 = CryptoJS.enc.Base64.stringify(hash);</p>

<p>document.write(base64);</p>

<p>Any help would be greatly appreciated!</p>
","<p>Make sure to Base64 decode your secret key before passing it to CryptoJS.HmacSHA256.</p>

<p>For example 
<code>
var words = CryptoJS.enc.Base64.parse({SecretKey});
var hash = CryptoJS.HmacSHA256(data, words);
</code></p>
","61","<javascript><cryptojs><cybersource>","0","0","1","2019-06-11 21:59:02","56552204","2","","4588821","","2019-06-11 15:20:44","2019-06-11 14:50:13",""
"56706086","Difference in encypt result bettween C# and javascript","<p>I want to encypt data to request api parameter. I converted my c# code to javascript but i got diff result:</p>

<p>C# code:</p>

<pre><code>private byte[] GetPasswordInBytes(string password)
{
   SHA1Managed mSha1 = new SHA1Managed();
   var hashBytes = mSha1.ComputeHash(Encoding.UTF8.GetBytes(password));
   return hashByte;
}   
</code></pre>

<p>Javascipt Code:</p>

<pre><code>getPasswordInBytes(password) {
  let bytes = CryptoJS.enc.Utf8.parse(password);
  let hashPass = CryptoJS.SHA1(bytes);
  return this.getBytes(hashPass);
}

getBytes(hash) {
  var byteArray = [];
  hash.words.forEach(function(i) {
    var k;
    for (var j = 3; j &gt;= 0; j--) {
      k = (i &gt;&gt; (j * 8)) &amp; 0xFF;
      k = k &lt; 128 ? k : -(256 - k);
      byteArray.push(k);
    }
  });

  return byteArray;
}
</code></pre>

<p>input: password=""123456""</p>

<p>output:    </p>

<p>C#: </p>

<pre><code>[124, 74, 141, 9, 202, 55, 98, 175, 97, 229, 149, 32, 148, 61, 194, 100, 148, 248, 148, 27]
</code></pre>

<p>Javascript: </p>

<pre><code>[124, 74, -115, 9, -54, 55, 98, -81, 97, -27, -107, 32, -108, 61, -62, 100, -108, -8, -108, 27]
</code></pre>

<p>I just implemet new from above code:</p>

<p>C# code</p>

<pre><code>  private byte[] GetPasswordInBytes(string password)
    {
      SHA1Managed mSha1 = new SHA1Managed();
      var hashBytes = mSha1.ComputeHash(Encoding.UTF8.GetBytes(password));           

      var keyBytes = new byte[16];
      Array.Copy(hashBytes, keyBytes, 16);//Copy first 128-bit.

      return keyBytes;
    }

    private string Encrypt(string plainText, string password)
    {
      byte[] plainBytes = Encoding.UTF8.GetBytes(plainText);
      byte[] keyBytes = GetPasswordInBytes(password);
      RijndaelManaged rijndaelManaged = new RijndaelManaged
      {
        Mode = CipherMode.CBC,
        Padding = PaddingMode.PKCS7,
        KeySize = 128,
        BlockSize = 128,
        Key = keyBytes,
        IV = keyBytes
      };

      byte[] cryptedBytes = rijndaelManaged.CreateEncryptor()
          .TransformFinalBlock(plainBytes, 0, plainBytes.Length);

      return Convert.ToBase64String(cryptedBytes);
    }
</code></pre>

<p>Javascript code </p>

<pre><code>getPasswordInBytes(password) {
    let bytes = CryptoJS.enc.Utf8.parse(password);
    let hashPass =  CryptoJS.SHA1(bytes);    
    let byteArray = this.getBytes(hashPass);

    return byteArray.slice(0, 16);//Copy first 128-bit.
  } 



 getBytes(hash)
  {    
    var byteArray = [];
    hash.words.forEach(function (i) {
      var k;
      for (var j = 3; j &gt;= 0; j--) {
        k = (i &gt;&gt; (j * 8)) &amp; 0xFF;        
        byteArray.push(k);
      }
    });

    return byteArray;
  }    



  encrypt(clearText, password)
  {
    let key = this.getPasswordInBytes(password).toString();
    let iv = key;    
    let data = CryptoJS.enc.Latin1.parse(clearText);
    var encrypted = CryptoJS.AES.encrypt(
      data,
      key,
      { 
        keySize: 128,
        iv: iv,       
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
      });     

    let result =  CryptoJS.enc.Base64.stringify( encrypted.ciphertext);   

    return result;
  }
</code></pre>

<p>call method:
encrypt('cleart text','123456')</p>

<p>Out put:   </p>

<pre><code>C#: m8BOnfX+n9Fc90dZdV2vQQ==     
Javascript: 6qYSO7ZkTcesmZKvkFJz+g==  
</code></pre>

<p>In javascript the result was changed for each run</p>

<pre><code>lV2NO3NpsERUQmXMOOzcvQ==    
H1Sla9/wrQXvKuTELPATDQ==    
WsMHHJLskuJxmEJe7PnAAg==  
</code></pre>

<p><strong>UPDATE</strong></p>

<pre><code> getPasswordInBytes(password) {
    let bytes = CryptoJS.enc.Utf8.parse(password);   
    let hashPass =  CryptoJS.SHA1(bytes);    
    let byteArray = this.getBytes(hashPass);
    return byteArray;
  }          

  encrypt(clearText, password)
  {
    let keyBytes = this.getPasswordInBytes(password);     
    let key = CryptoJS.lib.WordArray.create(keyBytes, 16);//128bit
    let iv = CryptoJS.lib.WordArray.create(keyBytes, 16);    
    let data = CryptoJS.enc.Utf8.parse(clearText);      
    var encrypted = CryptoJS.AES.encrypt(
      data,
      key,
      {        
        keySize:128,
        blockSize: 128,   
        iv: iv,        
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
      });                    

    return encrypted.toString();            
  }

  getBytes(hash)
  {    
    var byteArray = [];
    hash.words.forEach(function (i) {
      var k;
      for (var j = 3; j &gt;= 0; j--) {
        k = (i &gt;&gt; (j * 8)) &amp; 0xFF;        
        byteArray.push(k);
      }
    });

    return byteArray;
  }
</code></pre>

<p>call method: encrypt('cleart text','123456')</p>

<p>Out put: still diffrence</p>

<pre><code>C#: m8BOnfX+n9Fc90dZdV2vQQ==
Javascript: gVSE5CdyGxJJRbWaJiuyhg==
</code></pre>
","<p>If you would remove the line <code>k = k &lt; 128 ? k : -(256 - k);</code> from the code, the results would be the same.</p>
","61","<javascript><c#><encryption><cryptojs>","1","1","1","2019-06-23 15:39:30","","4","","11677228","","2019-06-23 15:39:30","2019-06-21 15:11:33",""
"58111929","Why I get Malformed UTF-8 data error on crypto-js?","<p>I try to encrypt and decrypt this string using <code>crypto-js</code>:</p>

<pre><code>const str = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiI1ZDg5MjMxMjc5OTkxYjJhNGMwMjdjMGIiLCJoc2giOiIkMmEkMTMkWk53Y0cubjdRZFIybDA3S1RHd2RoLlN0QksudW5GSFVGLkZnZ0tQTGlUV2pOVEFqVy9SMm0iLCJncmFudCI6ImFjY2VzcyIsImlhdCI6MTU2OTI2ODUwMiwiZXhwIjoxNjAwODI2MTAyfQ.PQcCoF9d25bBqr1U4IhJbylpnKTYiad3NjCh_LvMfLE~3~null~undefined~434ce0149ce42606d8746bd9`;
</code></pre>

<p>But I got an error:</p>

<pre><code>Error: Malformed UTF-8 data
</code></pre>

<p>What I doing wrong? How do I fix that?</p>

<p>The full code <a href=""https://stackblitz.com/edit/rxjs-amo7i4?devtoolsheight=60"" rel=""nofollow noreferrer"">also on stackbliz</a>:</p>

<pre><code>import crypto from 'crypto-js';

const str = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiI1ZDg5MjMxMjc5OTkxYjJhNGMwMjdjMGIiLCJoc2giOiIkMmEkMTMkWk53Y0cubjdRZFIybDA3S1RHd2RoLlN0QksudW5GSFVGLkZnZ0tQTGlUV2pOVEFqVy9SMm0iLCJncmFudCI6ImFjY2VzcyIsImlhdCI6MTU2OTI2ODUwMiwiZXhwIjoxNjAwODI2MTAyfQ.PQcCoF9d25bBqr1U4IhJbylpnKTYiad3NjCh_LvMfLE~9~null~undefined~434ce0149ce42606d8746bd9`;

const cryptoInfo = crypto.AES.encrypt(str, 'secret').toString();

console.log({ cryptoInfo });
const info2 = crypto.AES.decrypt(str, 'secret').toString(crypto.enc.Utf8);

console.log({ info2 });
</code></pre>
","<p>Not sure why, but you have to <strong>wrap your string with an object</strong> and use <code>JSON.stringify</code> in order to make it works.</p>

<p>Here:</p>

<pre><code>    import crypto from 'crypto-js';

    const str = `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiI1ZDg5MjMxMjc5OTkxYjJhNGMwMjdjMGIiLCJoc2giOiIkMmEkMTMkWk53Y0cubjdRZFIybDA3S1RHd2RoLlN0QksudW5GSFVGLkZnZ0tQTGlUV2pOVEFqVy9SMm0iLCJncmFudCI6ImFjY2VzcyIsImlhdCI6MTU2OTI2ODUwMiwiZXhwIjoxNjAwODI2MTAyfQ.PQcCoF9d25bBqr1U4IhJbylpnKTYiad3NjCh_LvMfLE~9~null~undefined~434ce0149ce42606d8746bd9`;

    const cryptoInfo = crypto.AES.encrypt(JSON.stringify({ str }), 'secret').toString();

    console.log({ cryptoInfo });
    const info2 = crypto.AES.decrypt(cryptoInfo, 'secret').toString(crypto.enc.Utf8);

    console.log({ info2 });

    const info3 = JSON.parse(info2);

    console.log({ str: info3.str });
</code></pre>
","61","<javascript><node.js><cryptojs>","1","2","1","2019-09-26 08:28:11","58112589","4","","","","","2019-09-26 07:46:30",""
"56931059","Why does API Key authentication not work on Coinbase Pro using Crypto-JS?","<p>I am really battling to get API Key authentication working with Coinbase Pro using the Crypto-JS library in React Native.</p>

<p>I have followed the instructions here:
<a href=""https://docs.pro.coinbase.com/#authentication"" rel=""nofollow noreferrer"">https://docs.pro.coinbase.com/#authentication</a></p>

<pre><code>import axios from 'axios';
import { Buffer } from 'buffer';
import CryptoJS from 'crypto-js';

export const baseURL = 'https://api.pro.coinbase.com';
export const axiosTimeout = 10 * 1000; // 10 sec

export const addHeaders = (additional) =&gt; {
  const headers = {};
  return Object.assign(
    headers,
    {
      Accept: 'application/json',
      'User-Agent': 'rn-coinbasepro-app',
      'Content-Type': 'application/json'
    },
   additional
  );
};
</code></pre>

<hr>

<pre><code>componentDidMount() {
  const auth = {
    key: '',
    secret: '',
    passphrase: ''
  };

  const method = 'GET';
  const url = `${baseURL}/orders?status=all`;
  const timestamp = Date.now() / 1000;
  const requestPath = '/orders?status=all'
  const what = timestamp + method + requestPath;
  const key = Buffer.from(auth.secret, 'base64').toString('ascii');
  const hmac = CryptoJS.HmacSHA256(what, key);
  const signature = CryptoJS.enc.Base64.stringify(hmac);

  axios.interceptors.request.use((request) =&gt; {
    console.log('Starting Request', request);
    return request;
  });

  axios.interceptors.response.use((response) =&gt; {
    console.log('Response:', response);
    return response;
  });

  axios
    .get(url, {
      timeout: axiosTimeout,
      headers: addHeaders({
        method,
        timeout: axiosTimeout,
        'CB-ACCESS-KEY': auth.key,
        'CB-ACCESS-SIGN': signature,
        'CB-ACCESS-TIMESTAMP': timestamp,
        'CB-ACCESS-PASSPHRASE': auth.passphrase
      }),
      debug: true
    })
    .then((response) =&gt; {
      console.log(response);
      if (response.status === 200) {
        console.log(response.data);
      } else {
        console.log(response);
      }
    })
    .catch((error) =&gt; {
      console.log(error);
    });
}
</code></pre>

<p>It keeps returning 401 (Unauthorized  Invalid API Key)</p>

<p>I have followed the instructions and I think I've done it all correctly. I just don't see what is wrong and the Coinbase Pro API returns very little to explain why.</p>
","","60","<react-native><cryptojs><api-key><coinbase-api><gdax-api>","1","","0","2019-07-08 08:30:26","","0","","","","","2019-07-08 08:30:26",""
"46806220","CryptoJS incorrect AES encoding","<p>Why is the output from CryptoJS different than in PHP' openssl_encrypt if I'm using the same key and ivector?</p>

<pre><code>openssl_encrypt('test' , 'aes-256-cbc', '17cc0ffd728f34c171e06c47df4227a32ee6ef5d6c60398eeab30cf34306c644', 0 , base64_decode('aROnq5DocMLgrlpAF6yjgw=='));
</code></pre>

<p>Output:</p>

<pre><code>oIcizpTDCTgtTGu3lO1cJg==
</code></pre>

<p>Each time the same output.</p>

<p>CryptoJS:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""test"", CryptoJS.enc.Hex.parse('UDOuDk5uxceoFWxtrabuEhamMC1T4Abr'), {
iv: CryptoJS.enc.Hex.parse('HLcM0VZYfsgPo2ye')}).toString();
</code></pre>

<p>Output:</p>

<pre><code>VTJGc2RHVmtYMTlrVHh4N0F3V2VySWlFcjBGeWlRRkcyMmNabEtjWmpmYz0=
</code></pre>

<p>Why is the output from CryptoJS different each time?</p>

<h1>Edit:</h1>

<p>After your hints:</p>

<pre><code>var encrypted = CryptoJS.AES.encrypt(""test"", CryptoJS.enc.Hex.parse('UDOuDk5uxceoFWxtrabuEhamMC1T4Abr'), {
iv: CryptoJS.enc.Hex.parse('HLcM0VZYfsgPo2ye')}).toString();
</code></pre>

<p>Output:</p>

<pre><code>CoFpbmd4YzOiVEFzVkeaDQ==
</code></pre>

<p>Now each time is the same</p>

<p>But is different than in PHP:</p>

<pre><code>openssl_encrypt(""test"" , ""aes-256-cbc"", ""UDOuDk5uxceoFWxtrabuEhamMC1T4Abr"", 0 , ""HLcM0VZYfsgPo2ye"");
</code></pre>

<p>Output:</p>

<pre><code>oV9OZVYM80p8mlHH5wnzEg==
</code></pre>
","<p>CryptoJS.AES.encrypt will try to automatically use AES-128, AES-192 or AES-256 depending on the key you pass it. In your case, you pass a secret passphrase ('17cc0f...') instead of a key  which will cause it to generate its own AES-256 key.</p>

<p><a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">The documentation states</a>:</p>

<blockquote>
  <p>CryptoJS supports AES-128, AES-192, and AES-256. It will pick the
  variant by the size of the key you pass in. If you use a passphrase,
  then it will generate a 256-bit key.</p>
</blockquote>

<p>In order to use a key, you must parse a Hex key first and pass that.</p>

<pre><code>var key = CryptoJS.enc.Hex.parse('000102030405060708090a0b0c0d0e0f');
var encrypted = CryptoJS.AES.encrypt(""test"", key, { iv: iv });
</code></pre>
","60","<javascript><php><aes><cryptojs>","0","1","1","2017-10-18 09:33:53","46806494","0","","7663518","","2017-10-18 09:33:53","2017-10-18 08:51:32",""
"54035583","NodeJs/Javascript AES 128 EBC encryption doesn't match iOS AES 128 EBC encryption","<p>In our Angular project, we need to Decrypt the Text/File which is encrypted by iOS.</p>

<p>iOS team is using AES 128 bit encryption with ECB Mode Algorithm.</p>

<p>I have tried using CryptoJS, aes-js and directly using Crypto class from NodeJs.</p>

<p>The result of encrypted text or decrypted UTF8 string from iOS doesn't match. We are getting different values.</p>

<p>iOS team is using aes-commoncrypto library</p>

<p>Before calling common crypto library, we are converting the string to iOS Data (Dataatype) ie., Bytes buffer and encoding with UTF8</p>

<p>Encryption - </p>

<pre><code>let fileUrl = URL(fileURLWithPath: folderPath)
                    try? Utils.aes128Encryption(forData: 
textAnnotationText.data(using: .utf8))?.write(to: fileUrl)
</code></pre>

<p>Decryption -</p>

<pre><code> let _fileURL = documentsDirectory.appendingPathComponent( path)

do {
        if let decryptedData = Utils.aes128Decryption(forData: try Data(contentsOf: _fileURL)) {
                                            message = String(decoding: decryptedData, as: UTF8.self)
                                   }
}

CCCrypt(operation,
                  kCCAlgorithmAES128,
                  kCCOptionPKCS7Padding | kCCOptionECBMode,
                  keyPtr,
                  kCCBlockSizeAES128,
                  ivPtr,
                  [self bytes],
                  dataLength,
                  buffer,
                  bufferSize,
                  &amp;numBytesEncrypted)
</code></pre>

<p>As per understanding from the above code, iOS team is using ECB mode algorithm.
Output: UTF8 string and we will write it to document directory file.</p>

<p>Solution 1:
With CryptoJS:</p>

<pre><code>let key = CryptoJS.enc.Utf8.parse(TESTKEY);
let iv = CryptoJS.lib.WordArray.create([0, 0]);
const encrypted = CryptoJS.AES.encrypt(message, key, {
        keysize: 256 / 8,
        iv: iv.toString(),
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    });
</code></pre>

<p>const encrypted64 = encrypted.ciphertext.toString();</p>

<p>Output: Base64 encoded string. (Doesn't match with iOS encrypted text)</p>

<p>Solution 2: With AES Js:</p>

<pre><code>let aesEcb = new aesjs.ModeOfOperation.ecb(Buffer.from(key, 'utf8'));
let textBytes = aesjs.utils.utf8.toBytes(str);
let encryptedBytes = aesEcb.encrypt(textBytes);
</code></pre>

<p>Output: We are getting error ""invalid plaintext size (must be multiple of 16 bytes)""</p>

<p>Solution 3: Using Crypto Decipher</p>

<pre><code>fs.readFile('./sample_text.html', 'utf-8', function (err, data) {
    if (err) throw err;
    console.log(data);
    const d = crypto.createDecipheriv('aes-128-ecb', convertCryptKey(key), '')
    let ret = ''
    d.setAutoPadding(false);
    console.log(Buffer.from(data, 'utf8'));
    ret = d.update(data, 'binary', 'utf8')

    console.log(ret);
    decoded = Buffer.concat([ ret, d.final() ]);
    console.log(decoded);
});

function convertCryptKey(strKey) {
   const newKey = new Buffer([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
   strKey = new Buffer(strKey)
   for (let i = 0; i &lt; strKey.length; i++) newKey[i % 16] ^= strKey[i]
   return newKey
}
</code></pre>

<p>Output: Doesn't match with iOS encrypted string or file</p>
","","60","<javascript><ios><node.js><angular><cryptojs>","0","","0","2019-01-04 08:45:15","","0","","","","","2019-01-04 08:45:15",""
"51955580","CryptoJS decode return value","<p>I am trying to encode data to Base64 using CryptoJS. My code is as below:</p>

<pre><code>let key = ""test"";
let iv = myCrypto.lib.WordArray.random(16);
let newKey = myCrypto.PBKDF2(key, iv, {keySize: 128/32});
let encrypted = myCrypto.AES.encrypt(""hello"", newKey, {iv: iv});
let ivString = myCrypto.enc.Base64.stringify(iv);
let decoded = myCrypto.enc.Base64.parse(ivString);
</code></pre>

<p>When I print decoded, I ma getting the following output:</p>

<pre><code>{ init: [Function],
  '$super':
   { init: [Function],
     toString: [Function: toString],
     concat: [Function: concat],
     clamp: [Function: clamp],
     clone: [Function: clone],
     random: [Function: random],
     '$super':
      { extend: [Function: extend],
        create: [Function: create],
        init: [Function: init],
        mixIn: [Function: mixIn],
        clone: [Function: clone] } },
  words: [ -1828772172, 1815131715, 749929333, 1399144403 ],
  sigBytes: 16 }
</code></pre>

<p>If I try encoding using HEX, I am getting the expected output.</p>

<p>Is this a problem with the CryptoJS library? If not, how do I fix this?</p>
","<p>Decoded consists of random bytes, which seem to be lazily generated (i.e. when they are required). Just printing the bytes will - by definition - not result in anything useful because the bytes have random values. JavaScript support is a bit tricky because JavaScript doesn't use the byte as primitive type (hence the word array).</p>

<p>To view the bytes first encode them to hexadecimals, and <em>then</em> print them.</p>
","60","<javascript><cryptojs>","0","0","1","2018-08-23 14:34:09","","1","","","","","2018-08-21 19:37:27",""
"54238569","C# Rijndael Decryption code in Node.js getting error bad decrypt","<p>Trying to convert C# Rijndael decryption code to Node.js but getting the error <strong>bad decrypt</strong></p>

<p>C# code for Decryption:</p>

<pre><code>RijndaelManaged RMCrypto = new RijndaelManaged();
byte[] data = Convert.FromBase64String(strCript.Replace("" "", ""+""));
byte[] initVectorBytes;
initVectorBytes = Encoding.ASCII.GetBytes(""@1***********H8"");
byte[] saltValueBytes;
saltValueBytes = Encoding.ASCII.GetBytes(""i**************ng"");
PasswordDeriveBytes password;
password = new PasswordDeriveBytes(""KEY**************KEY"", saltValueBytes, ""SHA1"", 1); 
byte[] keyBytes;
keyBytes = password.GetBytes(256 / 8);
byte[] Key = keyBytes;
byte[] IV = initVectorBytes;
MemoryStream msDncrypt = new MemoryStream(data);
CryptoStream CryptStream = new CryptoStream(msDncrypt, RMCrypto.CreateDecryptor(Key, IV), CryptoStreamMode.Read);
byte[] fromEncrypt = new byte[data.Length];
int len = CryptStream.Read(fromEncrypt, 0, fromEncrypt.Length);
byte[] decrypted = new byte[len];
Array.Copy(fromEncrypt, decrypted, len);
return Encoding.UTF8.GetString(decrypted); //(decrypted,0,decrypted.Length);
</code></pre>

<p>Node.js code for Decryption:</p>

<pre><code>const crypto = require(""crypto"");

let passkey= ""KEY*********KEY"";
let salt = ""i****************ng""
let d = ""u***************="";
d = Buffer.from(d,""base64"");
salt = Buffer.from(salt);

const derivedKey = crypto.pbkdf2Sync(passkey,salt, 1000, 32, ""sha1"");

let iv = Buffer.from(""@1B2c3D4e5F6g7H8"");

const decipher = crypto.createDecipheriv(""aes-256-cbc"", derivedKey, iv);
let buf = Buffer.concat([decipher.update(d), decipher.final()]);
let decrypted = buf.toString(""utf8"");
console.log(decrypted);
</code></pre>
","","60","<c#><node.js><encryption><cryptojs><rijndaelmanaged>","0","","0","2019-01-17 14:56:45","","4","","","","","2019-01-17 14:56:45",""
"58260989","cryptojs and golang give different sha3 hash values","<p>I'm trying to generate a sha3-512 hash in JS and check it in a golang server. However, cryptoJS is producing different hashes than golang.</p>

<p>CryptoJS:</p>

<pre class=""lang-js prettyprint-override""><code>CryptoJS.algo.SHA3.create().update(""foo"").finalize().toString(CryptoJS.enc.Hex)
</code></pre>

<p>Output: </p>

<p><code>1597842aac52bc9d13fe249d808afbf44da13524759477404c3592ee331173e89fe1cbf21a7e4360990d565fad4643cdb209d80fa41a91dea97e665022c92135</code></p>

<hr>

<p>Golang:</p>

<pre class=""lang-golang prettyprint-override""><code>hex.EncodeToString(crypto.SHA3_512.New().Sum([]byte(""foo"")))
</code></pre>

<p>Output:</p>

<p><code>666f6fa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26</code></p>

<p>I expect these hashes to be equal, but they aren't</p>
","<p>I don't know whose sha3 package you're using.  Here's what I get with <a href=""https://play.golang.org/p/fEI1gUwLycu"" rel=""nofollow noreferrer"">this code</a>:</p>

<pre><code>package main

import (
    ""fmt""
    ""golang.org/x/crypto/sha3""
)

func main() {
    h := sha3.New512()
    h.Write([]byte(""foo""))
    sum := h.Sum(nil)
    fmt.Printf(""hash = %x\n"", sum)
}
</code></pre>

<p><code>hash = 4bca2b137edc580fe50a88983ef860ebaca36c857b1f492839d6d7392452a63c82cbebc68e3b70a2a1480b4bb5d437a7cba6ecf9d89f9ff3ccd14cd6146ea7e7</code></p>

<p>Compare with Python3:</p>

<pre><code>&gt;&gt;&gt; import hashlib
&gt;&gt;&gt; print(hashlib.sha3_512(b""foo"").hexdigest())
</code></pre>

<p>which prints:</p>

<p><code>4bca2b137edc580fe50a88983ef860ebaca36c857b1f492839d6d7392452a63c82cbebc68e3b70a2a1480b4bb5d437a7cba6ecf9d89f9ff3ccd14cd6146ea7e7</code></p>
","59","<javascript><go><cryptojs><sha-3>","0","2","2","2019-10-07 17:56:08","58262073","2","1","8507883","","2019-10-07 17:56:08","2019-10-06 20:30:37",""
"58260989","cryptojs and golang give different sha3 hash values","<p>I'm trying to generate a sha3-512 hash in JS and check it in a golang server. However, cryptoJS is producing different hashes than golang.</p>

<p>CryptoJS:</p>

<pre class=""lang-js prettyprint-override""><code>CryptoJS.algo.SHA3.create().update(""foo"").finalize().toString(CryptoJS.enc.Hex)
</code></pre>

<p>Output: </p>

<p><code>1597842aac52bc9d13fe249d808afbf44da13524759477404c3592ee331173e89fe1cbf21a7e4360990d565fad4643cdb209d80fa41a91dea97e665022c92135</code></p>

<hr>

<p>Golang:</p>

<pre class=""lang-golang prettyprint-override""><code>hex.EncodeToString(crypto.SHA3_512.New().Sum([]byte(""foo"")))
</code></pre>

<p>Output:</p>

<p><code>666f6fa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26</code></p>

<p>I expect these hashes to be equal, but they aren't</p>
","<p>Obviously, your output is 134-width which should be 128-width.</p>

<p>Let us decode your output:</p>

<pre><code>bytes, _ := hex.DecodeString(""666f6fa69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26"")
fmt.Printf(""%s\n"", bytes)
</code></pre>

<p>We found the output is <code>foos:gZunOXYG\:L@,:Xu(&amp;</code>.</p>

<p>That means what you did actually is to output:</p>

<p>""foo"" + sha3("""")</p>

<p>where sha3_512("""") is ""a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26"" from <a href=""https://en.wikipedia.org/wiki/SHA-3"" rel=""nofollow noreferrer"">Examples of SHA-3 variants</a>.</p>
","59","<javascript><go><cryptojs><sha-3>","0","2","2","2019-10-07 17:56:08","58262073","2","1","8507883","","2019-10-07 17:56:08","2019-10-06 20:30:37",""
"53722857","need AES Decryption in javascript","<p>I have the following code for decryption in java, I want that to be implemented in angular4.</p>

<pre><code>public synchronized InputStream getInputStream(String src) {
    KeyEntry entry = keysMap.get(src);
    try {
        String destPath = rootFolder + ""/"" + entry.destination;
        FileInputStream is = new FileInputStream(destPath);
        if (entry.key.isEmpty()) return is;
        byte[] encKey = Base64.decode(entry.key, Base64.DEFAULT);
        SecretKeySpec secretKeySpec = new SecretKeySpec(encKey, AES_ALGORITHM);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(encKey);
        Cipher cipher = Cipher.getInstance(AES_TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
        return new CipherInputStream(is, cipher);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>currently doing it, something like below, not working</p>

<pre><code>decryptContent(ciphertext, base64Key) {
    const key = CryptoJS.enc.Base64.parse(base64Key);

    const decryptedData = CryptoJS.AES.decrypt( ciphertext, key, {
        iv: CryptoJS.lib.WordArray.random(128 / 8),
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.NoPadding
    });

    const decryptedText = decryptedData.toString( CryptoJS.enc.Utf8 );    
}
</code></pre>
","<blockquote>
  <p>AES_TRANSFORMATION = ""AES/CFB8/NoPadding""; </p>
</blockquote>

<p>Then you need to use CFB mode as well for decryption</p>

<pre><code> mode: CryptoJS.mode.CFB
</code></pre>

<blockquote>
  <p>I don't understand how to get the IV in javascript as in java, that is where I am majorly struck</p>
</blockquote>

<pre><code>IvParameterSpec ivParameterSpec = new IvParameterSpec(encKey);
</code></pre>

<p>In Java the encryption key is used as IV as well. To decrypt the data you should use the key as IV too. </p>

<p>Please note using key as IV is bad practice and it may create security weakness. IV allows reusing the same key for multiple encryptions without creating an opening for the ""two-time  pad attack"". If the key is reused for multiple encryptions, IV needs to be unique for each encryption for the same key. </p>
","59","<javascript><java><angular><encryption><cryptojs>","-1","1","1","2018-12-13 09:15:07","","2","","4386321","","2018-12-11 14:42:53","2018-12-11 11:09:43",""
"56033746","TripleDES .Net to TripleDES (crypto-js) Javascript","<p>I've spent some time looking at all solutions but something still seems off.. The encrypted string I see in .Net does not match the output I see in Cryto-JS. What could be wrong?</p>

<pre><code>    public static void Encrypt()
    {
        string toEncrypt = ""123456"";
        string key = ""hello"";

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
        byte[] keyArray = hashmd5.ComputeHash(UnicodeEncoding.Unicode.GetBytes(key));
        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;

        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] toEncryptArray = UnicodeEncoding.Unicode.GetBytes(toEncrypt);
        byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        string finalString = Convert.ToBase64String(resultArray);

        Console.WriteLine(""Output encrypted .Net: "" + finalString);
    }
</code></pre>

<p>and the equivalent Javascript using crypto-js is</p>

<pre><code>    Encrypt = () =&gt; {
        var CryptoJS = require('crypto-js');
        var text = '123456'
        var key = ""hello"";

        key = CryptoJS.enc.Utf16LE.parse(key);
        key = CryptoJS.MD5(key)

        var options = {
           mode: CryptoJS.mode.ECB, 
        };

        var textWordArray = CryptoJS.enc.Utf16LE.parse(text); 
        var encrypted = CryptoJS.TripleDES.encrypt(textWordArray, key, options);   
        var base64String = encrypted.toString();    
        console.log('Output JS Encrypted: ' + base64String);   
     }  
</code></pre>

<p>I get <strong>yGOnLhoVpIHQOCbAn51FTA==</strong> in .Net and <strong>d5Lg8k8cz68T6akDI0KQrA==</strong> in crypto-js. </p>
","<p>I have fixed this issue. A console log inside tripledes.js (CryptoJS package) revealed that I was missing 64 more bits in the key after MD5 Hash. </p>

<pre><code>this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
</code></pre>

<p>key.words length was 4 instead of 6. So, des3 had an empty wordarray. Solution was to push value of index 0 and 1 into the key word array. With length now being 6, des3 gets the value of des1. i.e keyWords.slice(0, 2) = keyWords.slice(4, 6). </p>

<pre><code>Encrypt = () =&gt; {
    var CryptoJS = require('crypto-js');
    var text = '123456'
    var key = ""hello"";

    key = CryptoJS.enc.Utf16LE.parse(key);
    key = CryptoJS.MD5(key)
    key.words.push(key.words[0], key.words[1]) // FIX FIX FIX

    var options = {
       mode: CryptoJS.mode.ECB, 
    };

    var textWordArray = CryptoJS.enc.Utf16LE.parse(text); 
    var encrypted = CryptoJS.TripleDES.encrypt(textWordArray, key, options);   
    var base64String = encrypted.toString();    
    console.log('Output JS Encrypted: ' + base64String);   
 }  
</code></pre>
","58","<cryptojs><tripledes>","0","0","1","2019-05-09 18:12:49","56065313","0","","8890014","","2019-05-08 10:45:56","2019-05-08 04:53:08",""
"58116672","Padding is invalid and cannot be removed while encryption decryption using AES","<p>I'm working on AES encryption/decryption. I want to encrypt request from my angular app and send it to .net api and decrypt at api then encrypt the response from api side and send it to angular app and decrypt using AES.
But sometimes it gives me 'padding is invalid and cannot be removed' exception at api side.</p>

<p>Here is my angular typescript crypto service code:</p>

<pre><code>aesEncrypt(keys: string, value: string) { // encrypt api request parameter with aes secretkey

    var key = CryptoJS.enc.Utf8.parse(keys);
    var iv = CryptoJS.enc.Utf8.parse(keys);
    var encrypted = CryptoJS.AES.encrypt(JSON.stringify(value), key,
        {
            keySize: 128 / 8,
            //keySize: 128,
            iv: iv,
            mode: CryptoJS.mode.CBC,
            padding: CryptoJS.pad.Pkcs7,

        });

    return encrypted.toString();
}

aesDecrypt(keys: string, value: any) { // decrypt api response parameter with aes secretkey
    var key = CryptoJS.enc.Utf8.parse(keys);
    var iv = CryptoJS.enc.Utf8.parse(keys);
    var decrypted = CryptoJS.AES.decrypt(value, key, {
        keySize: 128 / 8,
        //keySize: 128,
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7
    });

    return JSON.parse(decrypted.toString(CryptoJS.enc.Utf8));
}
</code></pre>

<p>Here is my api crypto filter code:</p>

<p>Way 1:</p>

<pre><code>public static string Encrypt(string key, string data)
{
    byte[] encryptedBytes = new UTF8Encoding().GetBytes(data);
    AesCryptoServiceProvider aes = AesCryptoServiceProvider(key);
    ICryptoTransform crypto = aes.CreateEncryptor(aes.Key, aes.IV);
    byte[] secret = crypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
    crypto.Dispose();
    return Convert.ToBase64String(secret);
}

public static string Decrypt(string key, string encrypted)
{
    byte[] encryptedBytes = Convert.FromBase64String(encrypted);
    AesCryptoServiceProvider aes = AesCryptoServiceProvider(key);
    ICryptoTransform crypto = aes.CreateDecryptor(aes.Key, aes.IV);
    byte[] secret = crypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
    crypto.Dispose();
    return Encoding.UTF8.GetString(secret);
}

private static AesCryptoServiceProvider AesCryptoServiceProvider(string key)
{
    AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
    //aes.BlockSize = 128; //Not Required
    //aes.KeySize = 256; //Not Required
    //aes.KeySize = 128;
    aes.Mode = CipherMode.CBC;
    aes.Padding = PaddingMode.PKCS7;
    aes.Key = Encoding.UTF8.GetBytes(key); //PSVJQRk9QTEpNVU1DWUZCRVFGV1VVT0 =
    aes.IV = Encoding.UTF8.GetBytes(key); //2314345645678765
    return aes;
}
</code></pre>

<p>Way 2:</p>

<pre><code>public static string Encrypt(string key, string data)
{
    AesCryptoServiceProvider aes = AesCryptoServiceProvider(key);
    ICryptoTransform encryptor = aes.CreateEncryptor();
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, encryptor, CryptoStreamMode.Write);
    StreamWriter streamWriter = new StreamWriter(cs);
    streamWriter.Write(data);
    streamWriter.Flush();
    cs.FlushFinalBlock();
    byte[] cypherTextBytes = ms.ToArray();
    ms.Close();
    return Convert.ToBase64String(cypherTextBytes);
}

public static string Decrypt(string key, string encrypted)
{
    AesCryptoServiceProvider aes = AesCryptoServiceProvider(key);
    byte[] encryptedBytes = Convert.FromBase64String(encrypted);
    ICryptoTransform decryptor = aes.CreateDecryptor();
    byte[] plainText = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
    return Encoding.UTF8.GetString(plainText);
}

private static AesCryptoServiceProvider AesCryptoServiceProvider(string key)
{
    AesCryptoServiceProvider aes = new AesCryptoServiceProvider();
    //aes.BlockSize = 128; //Not Required
    //aes.KeySize = 256; //Not Required
    //aes.KeySize = 128;
    aes.Mode = CipherMode.CBC;
    aes.Padding = PaddingMode.PKCS7;
    aes.Key = Encoding.UTF8.GetBytes(key); //PSVJQRk9QTEpNVU1DWUZCRVFGV1VVT0 =
    aes.IV = Encoding.UTF8.GetBytes(key); //2314345645678765
    return aes;
}
</code></pre>

<p>I tried both the ways at api level but still it is giving me padding issue (sometimes, not always)</p>
","","58","<c#><angular6><aes><cryptojs>","0","","0","2019-09-26 12:18:58","","8","","","","","2019-09-26 12:18:58",""
"57125927","Encrypt on JS, decrypt in PHP?","<p>I'm currently stuck here right now, this is from client side:</p>

<pre><code>$scope.encryptFormData = function() {
    // Get payment data
    var paymentData = JSON.stringify($scope.payment);

    // Generate AES secret key
    var secret_key = $scope.generateKey(paymentData);
    var iv  = CryptoJS.lib.WordArray.random(16);

    // Encrypt form data using AES secret key
    var cipherPaymentData = CryptoJS.AES.encrypt(paymentData, secret_key, {iv: iv});

    // Encrypt AES secret key with RSA public key from server
    var secret_key_rsa = null;
    var encrypt = new JSEncrypt();
    encrypt.setPublicKey($scope.public_key);
    secret_key_rsa = encrypt.encrypt(secret_key);

    // Assign values to form object
    var iv_hex = CryptoJS.enc.Hex.stringify(iv);
    var payment_data_hex = CryptoJS.enc.Hex.stringify(cipherPaymentData.ciphertext);

    $scope.payment_data.secret_key = secret_key_rsa;
    $scope.payment_data.iv = iv_hex;
    $scope.payment_data.payment = payment_data_hex;

    // Send form data to server
};

$scope.generateKey = function(p) {
    var salt = CryptoJS.lib.WordArray.random(128/8);

    return CryptoJS.PBKDF2(p, salt, { keySize: 512/32, iterations: 1000 });     
}
</code></pre>

<p>Now, I send this payload to the server for decryption:</p>

<pre><code>{
    iv: ""ae3bafa370bdc0c8a6b47ab1b792ec58""
    payment: ""e12f9db635984ec2f146bd34e433ef912580c4b3c7c1efe0a8e3fa6981abefa860630752539a9af88a9db0c198a63b804855d4b56357f75456785d7313908c6e""
    secret_key: ""emMKQ2QOWtzQAHhur4FLQCyBSK9zzPzomjWyDbeOM3VpjIKb1aNs9SL4P1nhuizEwuM2os/FXsN6MJz/cwxQWakK3tnVFvmt...""
}
</code></pre>

<p>This is my controller function in the server:</p>

<pre><code>public function storePayment(Request $request) {
    $postData = $request-&gt;data;

    // Decrypt AES secret key, using private key
    $iv = $postData['iv'];
    $secretKey = $this-&gt;EncryptionService-&gt;decryptData($postData['secret_key']);

    // Decrypt AES client form data with secret key
    $paymentData = $this-&gt;EncryptionService-&gt;decryptSecretData($postData['payment'], $secretKey, $iv);

    // Print decrypted data
}
</code></pre>

<p>From my <code>EncryptionService</code>:</p>

<p>For RSA decryption:</p>

<pre><code>public function decryptData($data) 
{
    $privateKey = $this-&gt;getPrivateKey();

    if (empty($privateKey)) {
        $this-&gt;regenerateKeypair();
    }

    $privateKey = $this-&gt;getPrivateKey();
    $binaryData = hex2bin($data);
    openssl_private_decrypt($binaryData, $decrypted, $privateKey);

    return $decrypted;
}
</code></pre>

<p>For AES decryption:</p>

<pre><code>public function decryptSecretData($data, $secretKey, $iv) 
{
    $cipher = ""aes-256-cbc"";
    if (in_array($cipher, openssl_get_cipher_methods()))
    {
        $iv = hex2bin($iv);
        $originalData = openssl_decrypt($data, $cipher, $secretKey, $options=0, $iv);

        return $originalData;
    }
}
</code></pre>

<p>But right now I'm just getting this error:</p>

<pre><code>file: ""...\Services\EncryptionService.php""
line: 101
message: ""hex2bin(): Input string must be hexadecimal string""
</code></pre>

<p>It points to this line inside <code>decryptData()</code>:</p>

<pre><code>$binaryData = hex2bin($data);
</code></pre>

<p>How do I properly send the data from the client so the server can properly decrypt it?</p>

<p><strong>EDIT:</strong></p>

<p>I'm using these libraries:</p>

<p><a href=""https://github.com/travist/jsencrypt"" rel=""nofollow noreferrer"">https://github.com/travist/jsencrypt</a></p>

<p><a href=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js"" rel=""nofollow noreferrer"">https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.js</a></p>
","<p>It looks like the data you're getting from JavaScript for <code>$secretKey</code> is base64 encoded, rather than hex. Perhaps this change on the PHP side will work (but only for <code>$secretKey</code>):</p>

<p><code>$binaryData = base64_decode($data);</code></p>
","58","<javascript><php><angularjs><encryption><cryptojs>","1","0","1","2019-07-20 15:39:43","","4","","4497356","","2019-07-20 15:39:43","2019-07-20 15:06:09",""
"58278679","How to successfully decrypt AES-256 encrypted content generated with OpenSSL in Node.js using CryptoJS","<h1>Context</h1>

<p>I have a Node.js AWS Lambda function, which is acting as a custom authorizer and being triggered by AWS API Gateway, that is supposed to take a token from the Authorization header, which is an AES-256 encrypted JSON, and decrypt it using CryptoJS and a secret passphrase. Just FYI, the token is not a JWT.
I've followed <a href=""https://cryptojs.gitbook.io/docs/#interoperability"" rel=""nofollow noreferrer"">CryptoJS</a> docs but it's just not working. I've read dozens of posts and articles and it's really surprising to me that I haven't been able to find anyone trying a simple approach like mine.</p>

<h1>Steps and Code</h1>

<p>1) I have a file called <em>token.json</em> containing a stringified JSON object:</p>

<pre><code>""{""user_id"":1,""name"":""user"",""time"":""2019-09-27 13:58:22"",""env"":""dev""}""
</code></pre>

<p>2) Following CryptoJS examples, in the terminal I'm executing:
<code>openssl enc -aes-256-cbc -in token.json -out encrypted-json-token -pass pass:""password"" -e -A -base64</code></p>

<p>I'm using the <code>-A</code> option to get a one line string.
According to <code>openssl enc --help</code>:</p>

<blockquote>
  <p>-A                  Used with -[base64|a] to specify base64 buffer as a single line</p>
</blockquote>

<p>3) I'm taking that output, the encrypted token, and sending it as the value for the <code>Authorization</code> header in a HTTP request that's  parsed by AWS API Gateway, which takes that header and passes it to my Lambda function.</p>

<p>4) In the Lambda function:</p>

<pre><code>const AES = require('crypto-js/aes');
const Utf8 = require('crypto-js/enc-utf8');

module.exports.authenticate = function authenticate(event, context, callback) {
...
  try {
    const token = event.authorizationToken;
    const decryptedToken = AES.decrypt(token, 'password').toString(Utf8);
    const parsedToken = JSON.parse(decryptedToken);
  }
  catch(error){
  // log error
  }
...
}
</code></pre>

<p>The result of the decryption is an empty string, and hence parsing to JSON fails.</p>

<h1>Final notes</h1>

<p>I'm calling <code>.toString(Utf8)</code> since according to <a href=""https://cryptojs.gitbook.io/docs/#the-hashing-output"" rel=""nofollow noreferrer"">this</a> and <a href=""https://cryptojs.gitbook.io/docs/#the-cipher-output"" rel=""nofollow noreferrer"">this</a>, the output of a decryption operation is a <em>Word Array object</em>, and I need to turn it back to it's original string form, which is supposed to be the stringified JSON token.
Also, I'm testing all this using Serverless offline plugin to emulate API Gateway locally.</p>
","<p><strong>TL; DR</strong>: Pass an actual AES key encoded as hex using the <code>-K</code> flag.</p>

<p>If you read the <a href=""https://www.openssl.org/docs/man1.0.2/man1/enc.html"" rel=""nofollow noreferrer"">documentation for <code>openssl enc</code></a> carefully you'll notice there is a difference between the <code>-pass</code> (<code>-k</code>) and <code>-K</code> flags - the first is literally a password, the second is an actual key.</p>

<p>If you use <code>-pass</code>, you're actually passing in an arbitrary string password that gets fed through an (obsolete and insecure) KDF, <code>EVP_KDF</code>.  If you use <code>-K</code>, you can pass a real AES key as a hex string.</p>

<p>Since <code>EVP_KDF</code> is insecure, I'd recommend the latter.</p>
","57","<node.js><encryption><openssl><aes><cryptojs>","0","1","1","2019-10-08 00:47:50","","0","","","","","2019-10-08 00:23:20",""
"50618917","Javascript Crypto AES decrypt","<p>This is the crypto AES encryption code in server side. How can I <code>decrypt in javascript</code>. I can't find any decryption logic having both iv and key with padding.</p>

<pre><code>public static String encrypt(String key, String initVector, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(""l353b3l3jk3bk3j3"".getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(""2353c3l3jk3bk3j8"".getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string: "" + Base64.encodeBase64String(encrypted));

            return Base64.encodeBase64String(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }
</code></pre>
","<p>You can use <a href=""https://code.google.com/archive/p/crypto-js/"" rel=""nofollow noreferrer"">CryptoJS</a> in the following way:</p>

<pre><code>var decryptedData = CryptoJS.AES.decrypt(cipherText, CryptoJS.enc.Base64.parse(key), 
{
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7 //default
});
console.log('Decrypted Data: ' + decrypted);
</code></pre>

<p>PKCS5 is not supported by this library but you should not be using it as it was designed for DES rather than AES. However if you dont want to change it then you can still use PKCS7 for decryption and it will work because the difference is in the block size both paddings supports. PKCS5 only works with 8-byte blocks whereas PKCS7 works with block sizes betwheen 1 and 255 bytes. DES uses block size of 8 bytes.</p>
","57","<javascript><java><encryption><base64><cryptojs>","-1","0","1","2018-05-31 18:36:07","","1","","","","","2018-05-31 07:27:00",""
"39841368","CryptoJS to Pycrypto AES","<p>Im trying to decrypt with Pycrypto an encrypted text with CryptoJS, <strong><em>and I would like to know how is generated the by default IV value from CryptoJS?An example code solving the decryption would be great.</em></strong></p>

<p>This is the decryption code with JS:</p>

<pre><code>var crypto_test = require('crypto-js'); 
var bytes = crypto_test.AES.decrypt(encrypted_text, 'test_key');
</code></pre>

<p>This is the equivalent Python version that Im trying to create:</p>

<pre><code>BS = 32
key = 'test_key'
dkey = hashlib.sha256(key.encode()).digest()
encodedEncrypted = base64.b64decode(encrypted_text)
#block_size is 16
cipher = AES.new(dkey, AES.MODE_CBC, encodedEncrypted[:AES.block_size])
decrypted = _unpad(cipher.decrypt((encodedEncrypted[AES.block_size:])).decode('utf-8')

def _unpad(s):
    return s[:-ord(s[len(s)-1:])]
</code></pre>

<p>From the documentation of CryptoJS I found:</p>

<ol>
<li>If a passphrase has been used instead of a key then It will use AES
256 by default. </li>
<li>The mode is CBC.</li>
<li>The padding is PKCS7.</li>
</ol>

<p>However Pycrypto by default is forcing me to use a 16 bytes IV not a 32 as the documentation from CryptoJS proposed..so Im a bit confused on the correct way to do the decryption here.. Also I saw in some documentation that CryptoJS applies to sha256 to passphrase..but still not sure about that ..</p>

<p>That code will not crash but will give an empty text..</p>
","","56","<javascript><python><encryption><pycrypto><cryptojs>","0","","0","2016-10-03 22:26:03","","6","","","","","2016-10-03 22:26:03","2016-10-04 04:11:29"
"57620965","Nodejs crypto module does not work with typescript","<p>I am trying to implement encryption into my project using vuejs and typescript. I successfully implemented it in the .vue file, but when I try to write the encryption into a typescript class, the mocha test runs it, but when I try to compile and open it in the browser i get a javascript error in the console: </p>

<pre><code>app.js:128620 Uncaught ReferenceError: require is not defined
at Object.crypto (app.js:128620)
at __webpack_require__ (app.js:20)
at Object../resources/ts/Classes/Model/Crypter.ts (app.js:125233)
at __webpack_require__ (app.js:20)
at Object../resources/ts/Controller/AuthController.ts (app.js:125924)
at __webpack_require__ (app.js:20)
at Object../node_modules/babel-loader/lib/index.js?!./node_modules/babel- 
loader/lib/index.js!./node_modules/vue- 
loader/lib/index.js?!./resources/js/Components/Includes/Login.vue? 
vue&amp;type=script&amp;lang=js&amp; (app.js:3308)
at __webpack_require__ (app.js:20)
at Module../resources/js/Components/Includes/Login.vue? 
vue&amp;type=script&amp;lang=js&amp; (app.js:124322)
at __webpack_require__ (app.js:20)
</code></pre>

<p>The marked line in the app.js is:</p>

<pre><code>module.exports = require(""crypto"");
</code></pre>

<p>I already tried different importing 'strategies' in the typescript file like: </p>

<pre><code>import * as crypto from ""crypto"";
import crypto from ""crypto"";
var crypto = require(""crypto"");
</code></pre>

<p>And also adding this in the webpack.mix.js</p>

<pre><code>""node"": {
        fs: ""empty"",
        crypto: true,
        http: true,
        https: true,
        os: true,
        vm: true,
        stream: true,
        path: true
    },
</code></pre>

<p>but it didn't work.</p>

<p>The Crypter.ts</p>

<pre><code>import crypto from ""crypto"";

export default class Crypter {

    public constructor() {
    }

    public static publicEncrypt(data: JSON, publicKey: string): string{
        let dataStr = JSON.stringify(data);
        let dataB64 = Buffer.from(dataStr).toString(""base64"");
        var buffer = Buffer.from(dataB64);
        return crypto.publicEncrypt(publicKey, buffer).toString(""base64""); 
    }
}
</code></pre>

<p>The tsconfig.json</p>

<pre><code>    ""compilerOptions"": {
        ""allowUnreachableCode"": false,
        ""allowUnusedLabels"": true,
        ""alwaysStrict"": true,
        ""charset"": ""utf8"",
        ""declaration"": true,
        ""declarationDir"": ""resources/ts/lib/types"",
        ""declarationMap"": true,
        ""esModuleInterop"": true,
        ""experimentalDecorators"": true,
        ""importHelpers"": true,
        ""lib"": [""ES5"", ""ES6"", ""DOM"", ""DOM.Iterable"", ""ScriptHost""],
        ""locale"": ""en"",
        ""module"": ""commonjs"",
        ""moduleResolution"": ""node"",
        ""noFallthroughCasesInSwitch"": true,
        ""noImplicitAny"": true,
        ""noImplicitReturns"": true,
        ""noImplicitThis"": true,
        ""noImplicitUseStrict"": false,
        ""noUnusedParameters"": true,
        ""outDir"": ""public/js"",
        ""baseUrl"": ""resources/"",
        ""paths"": {
            ""Base/*"":           [ ""ts/*"" ],
            ""@js/*"":            [ ""js/*"" ],
            ""@ts/*"":            [ ""ts/*"" ],
            ""Component/*"":      [ ""ts/Components/*"" ],
            ""Interface/*"":      [ ""ts/Interfaces/*"" ],
            ""Model/*"":          [ ""ts/Model/*"" ],
            ""Controller/*"":     [ ""ts/Controller/*"" ],
            ""Helper/*"":         [ ""ts/Helper/*"" ]
        },
        ""pretty"": true,
        ""sourceMap"": true,
        ""target"": ""ES5"",
        ""typeRoots"": [
            ""node_modules/@types""
        ],
        ""downlevelIteration"": true
    },
    ""include"": [
        ""resources/ts/**/*""
    ],
    ""exclude"": [
        ""node_modules"",
        ""**/*.spec.ts""
    ],
    ""files"": [
        ""./node_modules/@types/node/index.d.ts""
      ]
}
</code></pre>

<p>I expect the error to be resulting from wrong compiling or other misconfigurations.</p>
","<p>You can't access nodejs crypto module in a web application. <code>Node.js</code> uses the same javascript syntax, but is not running in the browser.</p>

<p>You may need to install another crypto library such as <code>crypto-js</code>, that you can install using <code>npm install crypto-js</code>. There are probably plenty of other libraries that you can choose from (<a href=""https://gist.github.com/jo/8619441"" rel=""nofollow noreferrer"">some ideas</a>)</p>
","56","<node.js><typescript><vue.js><cryptojs>","0","1","1","2019-08-23 06:38:57","57621026","0","","","","","2019-08-23 06:33:07",""
"46384742","How to decrypt a cryptojs text in PHP","<p>I use following code in JS to encrypt my data:</p>

<pre><code>const crypto = require('crypto');

const IV_LENGTH = 16; // For AES, this is always 16

export function encrypt(text, key) {
 let iv = crypto.randomBytes(IV_LENGTH);
 let cipher = crypto.createCipheriv('aes-256-cbc', new Buffer(key), iv);
 let encrypted = cipher.update(text);
 encrypted = Buffer.concat([encrypted, cipher.final()]);
 return iv.toString('hex') + ':' + encrypted.toString('hex');
}
</code></pre>

<p>I have tried to decrypt it in PHP (with pack('H*',.) etc but I can't find a solution to decode it in PHP. All the time I get the error that the IV is to long because I am not able to transform it back in PHP.</p>

<p>Do you have an idea how I can decrypt it in PHP?</p>

<p>Thank you very much and I wish a nice weekend!</p>
","","56","<javascript><php><encryption><cryptojs>","0","","0","2017-09-23 22:32:49","","6","","7005798","","2017-09-23 22:32:49","2017-09-23 22:15:45",""
"57388662","How to do encryption/decyption using crypto js in ionic4?","<p>I am trouble, how to do encryption/decyption using crypto js in ionic4?</p>

<p>I have written code for encryption decryption in java</p>

<pre><code>public static String encrypt(String str) 
{
    String encryptedString = str;

    try {
        byte[] utf8 = str.getBytes(""UTF8"");
        byte[] enc = encryptor.doFinal(utf8);
        encryptedString = Base64.encodeBase64URLSafeString(enc);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return encryptedString;
}
</code></pre>

<p>For <strong>decryption</strong></p>

<pre><code>public static String decrypt(String str) 
{
    String decryptedString = """";        
    try {
        byte[] dec = Base64.decodeBase64(str);
        byte[] utf8 = decryptor.doFinal(dec);
        decryptedString = new String(utf8, ""UTF8"");
    } catch (Exception e) {
        e.printStackTrace();
    } 
    return decryptedString;
}
</code></pre>

<p><strong>Secrete key generation</strong></p>

<pre><code>public static void genKeyPair(int i)    {
    try {
        // generates DES key from string //
        key = new SecretKeySpec(Skey.getBytes(), ""DES"");

        // initialize the cipher with key //
        encryptor = Cipher.getInstance(""DES"");
        decryptor = Cipher.getInstance(""DES"");
        encryptor.init(Cipher.ENCRYPT_MODE, key);
        decryptor.init(Cipher.DECRYPT_MODE, key);

        System.err.println(java.util.Base64.getEncoder().encodeToString(key.getEncoded()));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>I want to write same thing in ionic4, how to do plz help me. I am new in ionic4(Hybrid application) </p>
","<p>Your code looks like custom encryption/decryption,You can use one of the many encryption methods like from crypto-js like: </p>

<p>Its pretty simple, here is <strong>sample code to go-ahead</strong> :</p>

<pre><code>import * as utf8 from 'crypto-js/enc-utf8';
import * as AES from 'crypto-js/aes';

// Encryption
AES.encrypt(JSON.stringify(data),your_encKey).toString();

// Decryption
AES.decrypt(userdata, your_encKey).toString(utf8);
</code></pre>

<p>For More : <strong><a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">READ HERE</a></strong></p>

<blockquote>
  <p><strong>I think this code snippet is enough reference to go ahead and will
  help you to convert your code with ionic4/angular.</strong></p>
</blockquote>
","55","<angular><ionic-framework><encryption><cryptojs><caesar-cipher>","1","0","2","2019-08-08 08:45:38","","1","","","","","2019-08-07 07:02:44",""
"57388662","How to do encryption/decyption using crypto js in ionic4?","<p>I am trouble, how to do encryption/decyption using crypto js in ionic4?</p>

<p>I have written code for encryption decryption in java</p>

<pre><code>public static String encrypt(String str) 
{
    String encryptedString = str;

    try {
        byte[] utf8 = str.getBytes(""UTF8"");
        byte[] enc = encryptor.doFinal(utf8);
        encryptedString = Base64.encodeBase64URLSafeString(enc);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return encryptedString;
}
</code></pre>

<p>For <strong>decryption</strong></p>

<pre><code>public static String decrypt(String str) 
{
    String decryptedString = """";        
    try {
        byte[] dec = Base64.decodeBase64(str);
        byte[] utf8 = decryptor.doFinal(dec);
        decryptedString = new String(utf8, ""UTF8"");
    } catch (Exception e) {
        e.printStackTrace();
    } 
    return decryptedString;
}
</code></pre>

<p><strong>Secrete key generation</strong></p>

<pre><code>public static void genKeyPair(int i)    {
    try {
        // generates DES key from string //
        key = new SecretKeySpec(Skey.getBytes(), ""DES"");

        // initialize the cipher with key //
        encryptor = Cipher.getInstance(""DES"");
        decryptor = Cipher.getInstance(""DES"");
        encryptor.init(Cipher.ENCRYPT_MODE, key);
        decryptor.init(Cipher.DECRYPT_MODE, key);

        System.err.println(java.util.Base64.getEncoder().encodeToString(key.getEncoded()));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>I want to write same thing in ionic4, how to do plz help me. I am new in ionic4(Hybrid application) </p>
","<p>I found solution in angular (IONIC 4) , but sign characters are differs from java code</p>

<pre><code>let key=""AND$VBOA"";
var keyHex = CryptoJS.enc.Utf8.parse(key);
var message = CryptoJS.enc.Utf8.parse(message);
var encrypted = CryptoJS.DES.encrypt(message, keyHex, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
console.log(""Encrypted:=""+encrypted.toString());
</code></pre>

<p>for decryped</p>

<pre><code>var decrypted = CryptoJS.DES.decrypt({
    ciphertext: CryptoJS.enc.Base64.parse(encrypted)
}, keyHex, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
});
console.log(""Derypted:=""+decrypted .toString());
</code></pre>

<p>In ionic</p>

<pre><code>Ecrypted: 6qPw1YkOopA=
Decrypted: Nitin
</code></pre>

<p>In Java </p>

<pre><code>Ecrypted: 6qPw1YkOopA
Decrypted: Nitin
</code></pre>

<p>In Ionic </p>

<pre><code>Ecrypted: oOmH6uQ4R/Q=
Decrypted: Message
</code></pre>

<p>In Java </p>

<pre><code>Ecrypted: oOmH6uQ4R_Q
Decrypted: Message
</code></pre>

<p>In Ionic </p>

<pre><code>Ecrypted: f+eTKAqlUwXnznPVyjTXWA==
Decrypted: engineer
</code></pre>

<p>In Java </p>

<pre><code>Ecrypted: f-eTKAqlUwXnznPVyjTXWA
Decrypted: engineer
</code></pre>

<p>So many example tested in Java ""-"" &amp; in IONIC ""+""  &amp; in ionic ""/"" &amp; java ""_"", In ionic extra  = or == are  comming. Then whats wrong in this sample code, Plz suggest me.  </p>
","55","<angular><ionic-framework><encryption><cryptojs><caesar-cipher>","1","0","2","2019-08-08 08:45:38","","1","","","","","2019-08-07 07:02:44",""
"56280825","crypto-js module is imported but does not work as expected","<p>I work on a project wich use typescript and es6 syntax. I have installed the module crypto-js <code>npm install crypto-js</code> and his typescript type <code>npm install @types/crypto-js</code>.</p>

<p>I import it then into my file like this :`</p>

<p><code>import * as CryptoJS from 'crypto-js';</code></p>

<p>But when i tried to use it like in the documentation : </p>

<p><code>console.log(CryptoJS.MD5('my message'));</code></p>

<p>It show me an Object structure instead of an unreadable string :</p>

<pre><code>WordArray.init {words: Array(4), sigBytes: 16}
sigBytes: 16
words: Array(4)
    0: -1952005731
    1: -1042352784
    2: 804629695
    3: 720283050
    length: 4
__proto__: Array(0)
__proto__: Object

</code></pre>

<p>What am I forgetting? </p>
","<p>In your code, you reference the output from calling the MD5 function which, when passed to <code>typeof</code> returns its type as 'object'.</p>

<p>Though it seems poorly documented, you can reach the string representation of the MD5 value using:</p>

<pre><code>console.log(CryptoJS.MD5('my message').toString())
</code></pre>

<p>which produces: <code>""8ba6c19dc1def5702ff5acbf2aeea5aa""</code></p>

<p>If you plan to run your code using NodeJS, you might consider its native <code>crypto</code> module rather than <code>crypto-js</code>.</p>

<pre><code>const crypto = require('crypto')
const h = crypto.createHash('md5')
h.update('my message')
console.log(h.digest('hex'))
</code></pre>

<p>which also prints: <code>""8ba6c19dc1def5702ff5acbf2aeea5aa""</code></p>

<p>The benefit of using NodeJS' native <a href=""https://nodejs.org/dist/latest-v10.x/docs/api/crypto.html#crypto_hash_digest_encoding"" rel=""nofollow noreferrer"">crypto module</a> here is that, like all native modules, it is bundled into the NodeJS runtime and so doesn't need to be loaded in from an external module.</p>
","54","<node.js><typescript><import><node-modules><cryptojs>","0","1","1","2019-05-23 18:58:04","56281305","0","","","","","2019-05-23 18:12:03",""
"52101106","Cannot get previous hash of the block when pushing new block","<p>I created an implementation of Blockchain, it worked well. Then I wanted to write a program that creates a new chain when deleting message.</p>

<p>And instead of getting a new chain where the second block has data from the latest block from the previous chain it drops an error, and I really don't understand what that means. Why ""1""? It is even not hash but index of the block in a new chain. Here is error:</p>

<pre><code>Uncaught TypeError: Cannot create property 'prevHash' on number '1'
    at Chain.addBlock (chain.js:24)
    at newChain (test.js:26)
    at HTMLButtonElement.onclick (index.html:1)
</code></pre>

<p>Can somebody explain why? I also attached a code snippet for showing hot it all works</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>// Chain.js
class Block {
  constructor(id, data, prevHash = ''){
    this.id = id;
    this.prevHash = this.prevHash;
    this.hash = this.calcHash();
    this.data = data;
  }
  calcHash() {
    return CryptoJS.SHA512(this.id + JSON.stringify(this.data)).toString();
  }

}
class Chain {
  constructor(){
    this.chain = [this.genesisBlock()];
  }
  genesisBlock(){
    return new Block(0,'Chain started.');
  }
  getLastBlock(){
    return this.chain[this.chain.length - 1];
  }
  addBlock(block){
    block.prevHash = this.getLastBlock().hash;
    block.hash = block.calcHash();
    this.chain.push(block)
  }
  isValid(){
    for(let i = 1; i &lt; this.chain.length; i++){
      let prev = this.chain[i-1], current = this.chain[i];
      if(current.hash !== prev.prevHash || current.hash !== current.calcHash())
       return false;
    }return true;
  }

}

// Msg.js
class Msg {
  constructor(msg, date){
    this.msg = msg;
    const D = new Date();
    this.date = [D.getHours(), D.getMinutes(), D.getSeconds()].join(' : ');
  }
}

// Test.js
FROZENCHAINS = [];
CHAIN = new Chain();
i = 0;

msg = () =&gt; {
  let text = $('input').val();
  i++;
 CHAIN.addBlock(new Block(i, text));

 let msg = JSON.stringify(CHAIN.chain,null, 4);

 $('#log').text(msg);
 let thisMSG = new Msg(text);

 $('section').append('&lt;div class=""notification is-primary""&gt;&lt;span class=""tag""&gt;' + thisMSG.msg + '&lt;/span&gt;'
 + '&lt;span class=""tag""&gt;Created at: ' + thisMSG.date + '&lt;/span&gt;&lt;button onclick=""$(this).parent().hide() &amp;&amp; newChain()"" align=center class=""delete is-large""&gt;&lt;/button&gt;&lt;/div&gt;')


}

newChain = () =&gt; {
  FROZENCHAINS.push(CHAIN);
  delete CHAIN;
  CHAIN = new Chain();
  CHAIN.addBlock(1,'Hi')
}</code></pre>
<pre class=""snippet-code-css lang-css prettyprint-override""><code>.input {
        margin: 10px 0;
      }
      .tag {
        font-size: 23px !important;
        background-color: whitesmoke !important;
        margin: 5px;
      }</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=""utf-8""&gt;
    &lt;link rel=""stylesheet"" href=""https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css"" /&gt;
    &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;
    &lt;script src=""https://code.jquery.com/jquery-3.3.1.min.js"" charset=""utf-8""&gt;&lt;/script&gt;
    &lt;title&gt;Blockchain Chat&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=""tile is-parent""&gt;
         &lt;article class=""tile is-child notification""&gt;
           &lt;p class=""title""&gt;Blockchain Chat Part 1&lt;/p&gt;
           &lt;div class=""content""&gt;
             &lt;pre class=""hero-body"" id=log&gt;&lt;/pre&gt;
             &lt;section class=""hero-body""&gt;&lt;/section&gt;
             &lt;input class=""input"" value=""Hello World""/&gt;
            &lt;button onclick=""msg()"" class=""button""&gt;Send Message&lt;/button&gt;
           &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</p>
","<p>Your addBlock function expects a Block, but you provide 1 in newChain(). Change the line to</p>

<pre><code>CHAIN.addBlock(new Block(1,'Hi'));
</code></pre>
","54","<javascript><oop><frontend><blockchain><cryptojs>","1","1","1","2018-08-30 17:00:58","52102163","0","","9950309","","2018-08-30 16:43:36","2018-08-30 15:53:40",""
"55798824","AES encryption / decryption gives deffenret result for the same input, and same iv, pad & mode","<p>I'm trying to make 2 apps, the first encrypt a data, and save it to a file, then the second will try to read this file and decrypt its content</p>

<p>I'm working with <code>crypto-js</code> library with <code>ionic/angular</code></p>

<p>in the first program (encrypter) i wrote:</p>

<pre><code>encryptTest(input: string) {
    let key = ""secret"";
    return crypto.AES.encrypt(input, key, {
      iv: 'aTestIvValueKey',
      mode: crypto.mode.CBC,
      padding: crypto.pad.Pkcs7
    }).toString();
  }
</code></pre>

<p>then i call it with:</p>

<pre><code>this.encryptTest('hello world !')
</code></pre>

<p>it gives me on output:</p>

<blockquote>
  <p>U2FsdGVkX186H1iRZM4Il+10/TS6gM7DoUaghwAZX3A=</p>
</blockquote>

<p>when i try to decrypt this output in the second program, it dosen't give me the previous input: <code>hello world !</code>  but a worng test wich is :</p>

<blockquote>
  <p>68656c6c6f20776f726c642021</p>
</blockquote>

<p>the second program (decrypter): has:</p>

<pre><code>decryptTest(input: string) {
    let key = ""secret"";
    return crypto.AES.decrypt(input, key, {
      iv: 'aTestIvValueKey',
      mode: crypto.mode.CBC,
      padding: crypto.pad.Pkcs7
    }).toString();
  }
</code></pre>

<p>PS: i use the same iv, pad &amp; mode</p>
","<p>When you decrypt you get bytes, you need to pass those bytes though the correct encoding to get the words in characters.</p>
","54","<javascript><aes><cryptojs>","0","2","2","2019-04-22 18:35:00","","4","","11396035","","2019-04-22 18:01:40","2019-04-22 17:59:22",""
"55798824","AES encryption / decryption gives deffenret result for the same input, and same iv, pad & mode","<p>I'm trying to make 2 apps, the first encrypt a data, and save it to a file, then the second will try to read this file and decrypt its content</p>

<p>I'm working with <code>crypto-js</code> library with <code>ionic/angular</code></p>

<p>in the first program (encrypter) i wrote:</p>

<pre><code>encryptTest(input: string) {
    let key = ""secret"";
    return crypto.AES.encrypt(input, key, {
      iv: 'aTestIvValueKey',
      mode: crypto.mode.CBC,
      padding: crypto.pad.Pkcs7
    }).toString();
  }
</code></pre>

<p>then i call it with:</p>

<pre><code>this.encryptTest('hello world !')
</code></pre>

<p>it gives me on output:</p>

<blockquote>
  <p>U2FsdGVkX186H1iRZM4Il+10/TS6gM7DoUaghwAZX3A=</p>
</blockquote>

<p>when i try to decrypt this output in the second program, it dosen't give me the previous input: <code>hello world !</code>  but a worng test wich is :</p>

<blockquote>
  <p>68656c6c6f20776f726c642021</p>
</blockquote>

<p>the second program (decrypter): has:</p>

<pre><code>decryptTest(input: string) {
    let key = ""secret"";
    return crypto.AES.decrypt(input, key, {
      iv: 'aTestIvValueKey',
      mode: crypto.mode.CBC,
      padding: crypto.pad.Pkcs7
    }).toString();
  }
</code></pre>

<p>PS: i use the same iv, pad &amp; mode</p>
","<p>So, what i did to resolve:</p>

<pre><code>return crypto.AES.decrypt(input, key, {
      iv: 'aTestIvValueKey',
      mode: crypto.mode.CBC,
      padding: crypto.pad.Pkcs7
    }).toString(crypto.enc.Utf8);
</code></pre>
","54","<javascript><aes><cryptojs>","0","0","2","2019-04-22 18:35:00","","4","","11396035","","2019-04-22 18:01:40","2019-04-22 17:59:22",""
"57974571","how to deterministically generate a key from a passphrase with nodejs crypto module","<p>I want to generate a key pair, in NodeJS v10.16.3, using the crypto module, from the hash of a passphrase or seed.</p>

<p>I'm getting a public and private key and I'm able to sign with it.</p>

<p>They look like this;</p>

<pre><code>-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEaScBwOHQRRIDzPb3cnz3TZfHYOG7
pM7M8PkZFq7DjElFUrkavQf9NSopuJcIZ0EOmlQq8jPLbLdHoUO9M9a1Pw==
-----END PUBLIC KEY-----
</code></pre>

<p>The code to create this;
Basically from the doc found here; 
<a href=""https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypair_type_options_callback"" rel=""nofollow noreferrer"">https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypair_type_options_callback</a></p>

<pre><code>var seed = ""a very long and random passphrase or seed"";
let sha256 = require('js-sha256');
seed = sha256(seed);


const { generateKeyPair } = require('crypto');
generateKeyPair('ec', {
  namedCurve: 'P-256',
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem',
    cipher: 'aes-256-cbc',
    passphrase: seed
  }
}, (err, publicKey, privateKey) =&gt; {
  if (err) { throw err; }

  console.log('Node Private : ', privateKey);
  console.log('Node public : ', publicKey);

  const fs = require('fs');
  fs.writeFile(""test.dat"", privateKey, function(err) {
      if(err) {
          return console.log(err);
      }

    console.log(""The file was saved!"");
  }); 

});
</code></pre>

<p>How can I generate  a keypair using a seed so I can reproduce that same key again? The seed I am using is not changing but the key is.</p>

<p>If I want to create addresses by hashing the public key. I wouldn't be able to reproduce the same hash.</p>

<p>I want to do something similar to what is done with crypto wallet right now.</p>
","","53","<node.js><key><bitcoin><cryptojs>","0","","0","2019-09-17 23:13:04","","0","1","144015","","2019-09-17 23:13:04","2019-09-17 12:48:58",""
"56194350","What's the correct/standard practice to authenticate a user after registration?","<p>I'm trying to authenticate a user after registration. What's the correct or standard way to go about it?</p>

<p>Using <a href=""https://stackoverflow.com/a/39093058/4861207"">this method</a> as the way to implement it, in step 3, how can I generate the random hash to send to the users email? I see two different options:</p>

<ol>
<li>crypto</li>
<li>JWT token</li>
</ol>

<p>I'm currently using JWT for login, so would it make sense to use the same token for user verification? Why or why not, and if not, what's the correct way?</p>
","<p>The answer to your question of whether you should use a crypto hash or a token is neither.    </p>

<p>The hash you are generating to use as a verification method does not need to be cryptographically secure, it only needs to be a unique verification hash that is not easy to guess.<br>
In the past I have used a v4 UUID with the <a href=""https://www.npmjs.com/package/uuid"" rel=""nofollow noreferrer"">UUID</a> lib and it works just fine. You could also base64 some known piece of information about the user, like their id or email concatenated with something random, like the time in mircoseconds and a random hex string with substantial length, but honestly the time it takes to build out something like that is wasted when UUID v4 works just fine.    </p>

<p>Your hash also doesn't <em>need</em> to be unique (different for each user, yes, but avoid all potential collisions? No) - hitting an endpoint with only the hash is not a great idea. The endpoint should also take an identifier for your user combined with the verification hash. This way, you don't need to worry about the hash being unique in your datastore. Find user by ID, check that verification hashes match, verify. I would only suggest that you obfuscate the user's know information in a way that you can decode on your end (ex: base64 encode their user ID + email + some const string you use). </p>

<p>[EDIT]    </p>

<p>Verifying or validating a user is really just asking them to prove that the email address (or phone number) they entered does in fact exist and that it belongs to the user. This is an attempt to make sure the user didn't enter the information incorrectly or that the registration is spam. For this we don't need cryptographic authentication, a simple shared secret is more than enough.   </p>

<p>When you store your user's registration data, you generate the shared secret you will use to verify the account. This can be anything that is (relatively) unique and contains enough length and entropy that it is not easy to be guessed. We aren't encoding or encrypting information that will be unpacked later, we are doing a literal string comparison to make sure the secret we provided to the user was echoed back to us intact. This is why a simple one-way hash is OK to use. I suggested a UUID v4 because the components of this hash are generated from random information (other versions of UUID make use of the machine's MAC or the time or other known pieces of information). You can use any method you like as long as it can't be easily decoded or guessed.    </p>

<p>After you generate the verification hash you send it to the user (in a nicely formatted URL that they only need to click) in order for them to complete their account registration. URL guidelines are totally up to you, but here are some suggestions:    </p>

<p><strong>BAD</strong>    </p>

<p><code>/verify/&lt;verification hash&gt;</code><br>
or<br>
<code>/verify?hash=&lt;verification hash&gt;</code>    </p>

<p>With only the verification hash in the URL, you are relying on this value to be globally unique in your datastore. If you can reliably generate unique values that never contain collisions, then it would be OK, but why would you want to worry about that? Don't rely on the verification hash by itself.    </p>

<p><strong>GOOD</strong>    </p>

<p><code>/users/&lt;id&gt;/verify/&lt;verification hash&gt;</code><br>
or<br>
<code>/users/&lt;id&gt;?action=verify&amp;hash=&lt;verification hash&gt;</code>    </p>

<p>Out of these two examples you can see that the point is to provide two pieces of data, 1. is a way to identify the user, and 2. the verification hash you are checking.<br>
In this process you start by finding the user in your datastore by ID, and then literally compare the secret you generated and stored against the value given in the URL. If the user is found and the verification hashes match, set their account to Active and you're good to go. If the user is found but the hashes don't match... either you provided a malformed URL or someone is trying to brute force your verification. What you do here is up to you, but to be safe you might regenerate the hash and send out a new email and try the process again. This leads very quickly into a black hole about how to prevent spam and misuse of your system, which is a different conversation.    </p>

<p>The above URL schemas really only work if your user IDs are safe for public display. As a general rule you should never use your datastore IDs in a URL, especially if they are sequential INTs. There are many options for IDs that you would use in a URL like UUID v1 or <a href=""https://www.npmjs.com/package/hashids"" rel=""nofollow noreferrer"">HashIDs</a> or any implementation of a short ID.    </p>

<p><strong>ALSO</strong>    </p>

<p>A good way to see how this is done in the wild is to look at the emails you have received from other systems asking you to verify your own email address. Many may use the format:<br>
<code>/account/verify/&lt;very long hash&gt;</code>    </p>

<p>In this instance, the ""very long hash"" is usually generated by a library that either creates a datastore table just for the purpose of account verification (and the hash is stored in that table) or is decoded to reveal a user identifier as well as some sort of verification hash. This string is encoded in a way that is not easily reversible so it can not be guessed or brute forced. This is typically done by encoding the components with some sort of unique salt value for each string.    </p>

<p>NOTE - while this method may be the most ""secure"", I only mention this because it is based on the typical methods used by third-party libs which do not make assumptions about your user data model. You can implement this style if you want, but it would be more work. My answer is focused your intent to do basic verification based on data in your user model. </p>

<p><strong>BONUS</strong>    </p>

<p>Many verification systems are also time constricted so that the verification URL expires after some period of time. This is easily able to be set up by also storing a future timestamp with your user data that is checked when the verification endpoint is hit and the user is found. What to do when an expired link is clicked is up to you, but the main benefit is to help you more easily clean up dead registrations that you know cannot be verified. </p>
","53","<node.js><express><jwt><backend><cryptojs>","0","1","1","2019-05-18 00:40:44","56194523","0","","","","","2019-05-17 22:38:07",""
"55768895","Error ""Error:0906D06C:PEM routines:PEM_read_bio:no start line"" when trying to decrypt data with Crypto","<p>I have an http request in which I want to pass some sensitive data so I encrypted these data. In my React Native app I generated a pair of keys with react-native-rsa-native and I crypte my string with the public key via the function RSA.encrypt(my string, my public key).</p>

<p>After this I send the generated crypt data in my http request and I try to decrypt it in my node.js environment (Google Cloud Functions). For this I use the Crypto module.</p>

<p>I import it with:</p>

<pre><code>const crypto = require('crypto');
</code></pre>

<p>And I try to decrypt my data with the RSA private key generated in my react-native module :</p>

<pre><code>crypto.privateDecrypt(rsaPrivateKey, Buffer.from(myCryptedString))
</code></pre>

<p>But I obtain the error:</p>

<blockquote>
  <p>Error: error:0906D06C:PEM routines:PEM_read_bio:no start line
      at Error (native)
      at Object.privateDecrypt (crypto.js:375:12)
      at exports.createPaymentMethod.functions.https.onRequest (/user_code/index.js:943:10)
      at cloudFunction (/user_code/node_modules/firebase-functions/lib/providers/https.js:37:41)
      at /var/tmp/worker/worker.js:783:7
      at /var/tmp/worker/worker.js:766:11
      at _combinedTickCallback (internal/process/next_tick.js:73:7)
      at process._tickDomainCallback 
  (internal/process/next_tick.js:128:9)</p>
</blockquote>
","","53","<node.js><google-cloud-functions><cryptojs>","0","","0","2019-04-19 23:29:26","","0","","","","","2019-04-19 23:29:26",""
"52453877","How do I breakdown the decrypt error when decrypting data to JSON using Node JS?","<p>I'm trying to decrypt an encrypted JSON file in NodeJS</p>

<p>How do I go about breakdown the bad decrypt error?</p>

<p>Some information about the data I'm looking to decrypt. Initialization vector is the first 16 bytes of the received data. The payload itself is is the rest of the received data.</p>

<pre><code>`purchaseRouter.route('/')
  .post((req, res, next) =&gt; {
    var algorithm = encryptionHelper.CIPHERS.AES_128_CBC;
    var originalBase64 = req.body.data.replace(/-/g, ""_"").replace(/\+/g, 
    ""/"");
    const key = process.env.ECWID_CLIENT_SECRET.slice(0, 16);
    var decText = encryptionHelper.decryptText(algorithm, key, 
    originalBase64, ""base64"");
    console.log(""decrypted text = "" + decText);
   });
</code></pre>

<p>Below is the error I'm receiving.</p>

<pre><code>Error: error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt
</code></pre>
","<p>Nevermind. I figured it out. For those who might come across this issue in the future. There was a mistake in my conversion to the original base64. </p>

<pre><code>var originalBase64 = req.body.data.replace(/-/g, ""+"").replace(/_/g, ""/"");
</code></pre>
","53","<node.js><cryptojs>","1","0","1","2018-09-29 11:33:32","","0","","5257403","","2018-09-26 11:47:22","2018-09-22 05:49:08",""
"55029822","Using xml-crypto with PSHA1","<p>Is it possible to use XML Crypto using a PSHA1 (<a href=""http://schemas.xmlsoap.org/ws/2005/02/trust/CK/PSHA1"" rel=""nofollow noreferrer"">http://schemas.xmlsoap.org/ws/2005/02/trust/CK/PSHA1</a>) key?</p>

<p>I have both secrets and generate a PSHA1 key string using them, however this fails with:</p>

<blockquote>
  <p>Error: error:0906D06C:PEM routines:PEM_read_bio:no start line</p>
</blockquote>

<p>I'm not what format this key needs to be in to be accepted, it's not a PEM certificate, just a string based on 2 provided nonce's. One provided by the client during the request and one provided by the server in the response.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const sig = new SignedXml();
sig.addReference(""/*[local-name()='Envelope']/*[local-name()='Header']/*[local-name()='Security']/*[local-name()='Timestamp']"");
sig.signingKey = '&lt;SIGNING_KEY&gt;';
sig.computeSignature(xml);
fs.writeFileSync('signed.xml', sig.getSignedXml());</code></pre>
</div>
</div>
</p>

<p>It fails on the <code>signer.sign</code> line here:</p>

<pre><code>this.getSignature = function(signedInfo, signingKey) {
  var signer = crypto.createSign(""RSA-SHA1"")
  signer.update(signedInfo)
  var res = signer.sign(signingKey, 'base64')
  return res
}
</code></pre>
","<p>The PSHA1 algorithm isn't implemented in the Crypto Library, but there's a <code>PSHA1</code> npm package you can use to generate the secret key. After that you can generate a SHA1 hash using the message and key in the standard way.</p>

<p>I asked a very similar question here, which answers the question:
<a href=""https://stackoverflow.com/a/55053741/5065447"">https://stackoverflow.com/a/55053741/5065447</a></p>
","53","<node.js><xml><cryptojs><wss>","1","1","1","2019-03-07 22:25:31","55053793","0","","","","","2019-03-06 18:22:18",""
"44109300","encrypt like Cryptojs in C#","<p>I have a C# application required to calculate token same as JavaScript below:</p>

<pre><code>key = CryptoJS.enc.Hex.parse(""436574536f667445454d537973576562"");
iv = CryptoJS.enc.Hex.parse(""1934577290ABCDEF1264147890ACAE45"");
text ={userID: 0,tokenTime:'2017-05-06 19:20:22'};
text=JSON.stringify(text);
token=CryptoJS.AES.encrypt(text,key,{iv:iv}).toString();
</code></pre>

<p>token=9L9qY0fmi3Riysac3YbIciIIJFisPZZC3uBxjriVH1OyARL2ZQ/HVO941/Tod2PT</p>

<p>(JavaScript can not be change)</p>

<p>But,I am confuse by what is include in string ""token""?</p>

<p>only ciphertext or whole result of encryption in string?</p>

<p>And,how to convert format of key and iv for CryptoJS to a format which accepted by C#(RijndaelManaged or AesCryptoServiceProvider)?</p>

<p>Most of the question and answer using ""CryptoJS.enc.utf8.parse"",so I try to convert key and iv from hex to utf-8 ,but only key can be converted.</p>
","","52","<c#><encryption><cryptojs>","0","","0","2017-05-22 09:28:52","","2","1","","user8041188","2017-05-22 09:28:52","2017-05-22 09:24:54","2017-05-23 05:49:34"
"56477639","CrytoJS AES: Encrypted string gets decrypted to empty string","<p>I was tinkering with crypto-js and AES.  </p>

<p>I have a seemingly straightforward piece of code which takes a plainText and encrypts it using AES with a key and an initial vector.</p>

<p>When I try to decrypt the encrypted text, it gets decrypted to empty string for some reason.</p>

<p>This is the snippet:</p>

<pre><code>const { enc, AES } = require(""crypto-js"");

const KEY = enc.Utf8.parse(""this is a key"");
const IV = enc.Utf8.parse(""this is initial vector"");

const originalText = ""someone@example.com"";

const hash = AES.encrypt(originalText, KEY, { iv: IV });
const hashText = hash.toString();

console.log(`""${originalText}"" was encrypted to ""${hashText}""`);

const hashTextCopy = `${hashText}`;
const decrypt = AES.decrypt(hashTextCopy, KEY, { iv: IV });
const decryptText = decrypt.toString(enc.Utf8);

console.log(`""${hashTextCopy}"" was decrypted to ""${decryptText}""`);
</code></pre>

<p>The output I get is:</p>

<pre><code>""someone@example.com"" was encrypted to ""IgyDXGNVD8IokknoZqjamG0QecGvBM/dyxx4il8gCHA=""
""IgyDXGNVD8IokknoZqjamG0QecGvBM/dyxx4il8gCHA="" was decrypted to """"
</code></pre>

<p>Can someone explain what is going on? I have seen quite a few examples of it over the Internet and they all seem to working just fine. But here, the text is not getting decrypted.</p>

<p><strong>PS</strong>: The version I am using is <code>""crypto-js"": ""^3.1.9-1"",</code></p>
","<p>Maybe try changing your code ever so slightly, this works for me.</p>

<p>As stated in the comments, I believe the problem with your initial example was the key length.</p>

<pre><code>const { enc, AES } = require(""crypto-js"");

// Keep as a string..
const KEY = ""this is a key"";
const IV = enc.Utf8.parse(""this is initial vector"");

const originalText = ""someone@example.com"";

const hash = AES.encrypt(originalText, KEY, { iv: IV });
const hashText = hash.toString();

console.log(`""${originalText}"" was encrypted to ""${hashText}""`);

const hashTextCopy = `${hashText}`;
const decrypt = AES.decrypt(hashTextCopy, KEY, { iv: IV });
const decryptText = decrypt.toString(enc.Utf8);

console.log(`""${hashTextCopy}"" was decrypted to ""${decryptText}""`);
</code></pre>

<p>This also works:</p>

<pre><code>const { enc, AES } = require(""crypto-js"");

// 128-bit key works nicely
const KEY = enc.Hex.parse(""000102030405060708090a0b0c0d0e0f"");
const IV = enc.Utf8.parse(""this is initial vector"");

const originalText = ""someone@example.com"";

const hash = AES.encrypt(originalText, KEY, { iv: IV });
const hashText = hash.toString();

console.log(`""${originalText}"" was encrypted to ""${hashText}""`);

const hashTextCopy = `${hashText}`;
const decrypt = AES.decrypt(hashTextCopy, KEY, { iv: IV });
const decryptText = decrypt.toString(enc.Utf8);

console.log(`""${hashTextCopy}"" was decrypted to ""${decryptText}""`);
</code></pre>

<p>The key: </p>

<pre><code>const KEY = enc.Utf8.parse(""abcdfghi"");
</code></pre>

<p>Will also work correctly (since it's 128-bits). 256 would work too.</p>

<pre><code>const KEY = enc.Utf8.parse(""abcdfghijklmnopq"");
</code></pre>

<p>If you just use a pass phrase, a 256-bit key will be generated from it.</p>
","52","<node.js><encryption><aes><cryptojs>","0","2","1","2019-06-06 13:05:04","56477823","0","","","","","2019-06-06 12:29:53",""
"56694894","VueJS hash files with CryptoJS","<p>I'm reaching out to you because I'm terribly stuck with a Vue project...</p>

<p>I'm experiencing a little issue when trying to move a jQuery project over to Vue. CryptoJS is working a charm and I can create hashes from strings.</p>

<p>However, I'm still struggling reading the actual file, as the nested functions are throwing errors. Specifically getting errors on the <code>callbackRead</code> function.</p>

<pre><code>App.vue?234e:280 Uncaught TypeError: this.callbackRead is not a function
at FileReader.reader.onload (App.vue?234e:280)
</code></pre>

<p>Can you please give me some guidance on how to successfully translate the script to VUE JS? ( <a href=""https://medium.com/@0xVaccaro/hashing-big-file-with-filereader-js-e0a5c898fc98"" rel=""nofollow noreferrer"">https://medium.com/@0xVaccaro/hashing-big-file-with-filereader-js-e0a5c898fc98</a> )</p>

<p>Thanks a lot in advance!!!</p>

<p>Here is what I got so far: <a href=""https://codesandbox.io/s/vuejs-file-crypter-kjirp"" rel=""nofollow noreferrer"">https://codesandbox.io/s/vuejs-file-crypter-kjirp</a></p>

<p>Best regards,
Mac</p>
","<p>The error is coming from this section:</p>

<pre class=""lang-js prettyprint-override""><code>reader.onload = function(evt) {
    this.callbackRead(this, file, evt, callbackProgress, callbackFinal);
};
</code></pre>

<p>The problem is that <code>this</code> refers to the wrong object. Your <code>onload</code> handler is a different function from the surrounding code and whenever you enter a new function the value of <code>this</code> changes.</p>

<p>There are several possible solutions.</p>

<p>Aliasing <code>this</code>:</p>

<pre class=""lang-js prettyprint-override""><code>const that = this;

reader.onload = function(evt) {
    that.callbackRead(that, file, evt, callbackProgress, callbackFinal);
};
</code></pre>

<p>Binding <code>this</code>:</p>

<pre class=""lang-js prettyprint-override""><code>reader.onload = function(evt) {
    this.callbackRead(this, file, evt, callbackProgress, callbackFinal);
}.bind(this);
</code></pre>

<p>Using an arrow function, which won't alter the value of <code>this</code>:</p>

<pre class=""lang-js prettyprint-override""><code>reader.onload = evt =&gt; {
    this.callbackRead(this, file, evt, callbackProgress, callbackFinal);
};
</code></pre>
","52","<javascript><vue.js><vuejs2><cryptojs>","-1","0","1","2019-06-21 01:37:59","56695820","1","","9225514","","2019-06-21 01:24:03","2019-06-20 23:03:37",""
"53190976","How to use unique attribute along with encryption in a mongoose schema?","<p>I have a MongoDB database which I access through NodeJS using Mongoose. I use encryption to store email addresses using the <code>crypto</code> module. When retrieving an email address, I decrypt the database value. Here is the relevant part of the Mongoose schema using the encryption getter and setter:</p>

<pre><code>...
email: {
  type: Schema.Types.String,
  required: true,
  trim: true,
  unique: true, // &lt;-- this does not work due to encryption
  set: value =&gt; this._encryption.encrypt(value),
  get: value =&gt; this._encryption.decrypt(value)
},
....
</code></pre>

<p>As you can see, the field is using the <code>unique</code> attribute. But due to the encryption, the encrypted value of the same email address is always different. Now I can store two different users using the same email address and no errors are thrown.</p>

<p>How do I use encryption along with a <code>unique</code> field attribute?</p>
","<p>I would suggest perhaps doing the encryption / setting outside of the schema. The get method will still be fine.</p>

<p>This way you can firstly encrypt the new email coming in.</p>

<p><code>const encryptedEmail= _encryption.encrypt(email);</code></p>

<p>Then you can do a search to make sure that this hash does not exist:</p>

<p><code>const email = await emailSchema.findOne({email: encryptedEmail});</code></p>

<pre><code>if (!email.length) {
    emailSchema.create({ email: encryptedEmail});
}
</code></pre>

<p>This is obviously not as clean as doing it within the schema however it would achieve the desired encryption at rest.</p>
","52","<node.js><mongodb><encryption><mongoose><cryptojs>","0","0","1","2018-11-07 15:39:03","","2","1","","","","2018-11-07 14:00:22",""
"57826100","Javascript Decrypt Files without Clients Being Able to Access","<p>I want to use <a href=""https://googlewebcomponents.github.io/model-viewer"" rel=""nofollow noreferrer"">model-viewer</a> or <a href=""https://threejs.org"" rel=""nofollow noreferrer"">three.js</a> to showcase some of my 3d models on a personal website. In order to display 3d models on the web, the <strong>client needs to fetch the files from the server</strong> (the 3d mesh and the texture images)</p>

<p>But I don't want my visitors being able to <strong>access any of these files</strong>. I hope you can point me in the right direction. Here are some ideas I had, but I don't think they'll work:</p>

<p>(1) Using something like <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">crypto-js</a> to encrypt and decrypt files</p>

<ul>
<li>But when decrypting files on the frontend aren't users able to decrypt the files, too?</li>
<li>The key has to be transferred to the frontend code somehow, doesn't it?</li>
</ul>

<p>(2) Splitting the files up into little pieces and recomposing them on the client</p>

<ul>
<li>Same issue as with #1</li>
<li>The code for recomposition needs to sit on the client and can be used to access the files</li>
</ul>

<hr>

<p>When elaborating on those ideas, I am not quite sure if what I am trying to do is even possible </p>

<p>In case it is impossible... is there anything I can do to make it really hard for users to get access to the files?</p>
","<p>The short answer is: If it is on a website, <em>you don't stand a chance</em> to protect it against a determined person with enough time on their hands. The only exception here was made for video-streams, which can use the 'Encrypted Media Extensions' API to get video to the screen without any parts of the browser being able to interact with raw data.</p>

<p>Whatever you do to protect the files, the code to read them needs to be sent to the browser as well. Eventually, the raw data will be somewhere in the memory of the js-runtime where it can be extracted using the built-in debugger. The same goes for any mechanism to somehow encrypt the code. It makes it more difficult, but not impossible. You could use WebAssembly to make that part of the code even harder to reverse-engineer, but I wouldn't need to do that:</p>

<p>In the end, the data needs to get to the webgl-api, so I could just use a browser-extension to intercept the relevant webgl-calls and obtain all the raw data there. You could go on and also encrypt the vertex-data in a way that can be decoded in the vertex-shader, but guess what: I can read the vertex-shader code as well.</p>

<p>And so the list goes on. There just is just no way to do it that cannot be somehow circumvented. But maybe you make it difficult enough for nobody to bother...</p>

<p>For me the most promising options seem to be:</p>

<ul>
<li><p>use LoFi or partial models for rendering in the browser alongside renders of the full-resolution model. I've seen that on several sites for downloading CAD-/3D-models. They used merged models, sometimes reduced vertex-count, low-res textures and so on while providing images of what the final result will look like once I paid for it.</p></li>
<li><p>make up your own file-format or hide the file-format used in the network-view of the developer-tools. Google maps/earth for instance does that with their 3d-data (they are probably using something based on protobuf, but it's incredibly hard to reverse-engineer)</p></li>
<li><p>and yes, I guess you could also use the <a href=""https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API"" rel=""nofollow noreferrer"">WebCrypto-API</a> with a pre-shared secret so it is at least not too obvious which of the files contain the 3d-data.</p></li>
</ul>
","51","<javascript><security><encryption><three.js><cryptojs>","1","4","1","2019-09-07 05:58:43","57826674","1","","8586803","","2019-09-07 05:58:43","2019-09-06 17:05:05",""
"55846674","Implement OAuth 1.0 API of tumblr React-native","<p>I'm trying to implement API of creating a post in Tumblr with OAuth 1.0 Authorization with form data using fetch request in react-native.</p>

<p>I tried <code>npm install oauth-1.0a --production</code> but I'm getting crypto error and application not start after installing this node.</p>

<p>I tried <code>npm install --save tumblr.js</code> using tumblr.js but getting the same error. for resolve error, I add below node but not getting expected result.</p>

<pre><code>npm i --save react-native-crypto

npm i --save react-native-randombytes
react-native link react-native-randombytes

npm i --save-dev mvayngrib/rn-nodeify

./node_modules/.bin/rn-nodeify --hack --install
</code></pre>

<p>if anyone has an idea about how to implement OAuth 1.0 API in React-native please suggest what to do for this.</p>

<p>Thanks in advance.</p>
","","50","<react-native><tumblr><cryptojs>","1","","0","2019-04-26 14:14:44","","0","","4613320","","2019-04-26 14:14:44","2019-04-25 10:02:59",""
"56997283","Problems understanding Bit length and String Bitt things in Javascript/Typescript with Crypto-JS","<p>I am a little lost on this one...</p>

<p>I have a special key i need to send to a device in a specified format, and i know that what i am doing is wrong - obviously, because i lack the basic understanding of bit stuff in Javascript, i think.</p>

<p>The first step is to generate a random 128 bit number.
Since afaik JS characters are 16 bit, the following code should generate a 128 bit string, doesn't it?</p>

<pre><code>private generateSeed()
{
  let result = '';

  for(let i = 0; i &lt; 8; i++)
    result += ((Math.random() * 10) - 1).toString();

  return result;
}
</code></pre>

<p>After that i need to concatenate the seed and the key, calculate the SHA1 of that and padd that SHA1 to 192 bit with zeroes.</p>

<p><a href=""https://i.stack.imgur.com/pNLR0.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/pNLR0.jpg"" alt=""enter image description here""></a></p>

<pre><code>private generateAKey(seed: string)
  {
    const Provided_KEY = '[32 random characters are in here]';
    let concat = seed + Provided_KEY;

    let sha1 = crypto.SHA1(concat).toString();
    console.log(`SHA1: ${sha1} , Length: ${sha1.length}`);

    // Padd to 192 bit/24 bytes
    while(sha1.length &lt; 12)
      sha1 += '0';

    return sha1;
  }
</code></pre>

<p>But i am totally lost here. I am pretty sure i am wrong with that.
Also since the SHA1 i calculate with crypto-js is already 40 characters long this makes no sense for me.</p>

<p>How do i correctly do this?</p>
","","50","<javascript><string><encryption><bit-manipulation><cryptojs>","1","","0","2019-07-11 21:11:44","","5","","11306242","","2019-07-11 21:11:44","2019-07-11 21:04:38",""
"52954032","jsSha HMAC not match with crypto - OTP algorithm","<p>This 2 codes doesn't return the same. Sorry I am no expert of both library.</p>

<pre><code>const jsSHA = require(""jssha"");

const time = ""00000000030f7141""
const key = ""101010""
var shaObj = new jsSHA(""SHA-1"", ""HEX"");
shaObj.setHMACKey(key, ""HEX"");
shaObj.update(time);
const hmac = shaObj.getHMAC(""HEX"");
console.log(hmac) 
// returns '536d6eed86796085f8ec2ead742c52fd73995f27'
---------------
const crypto = require('crypto')

const time = ""00000000030f7141""
const key = ""101010""
crypto.createHmac('sha1', new Buffer(key, 
'HEX')).update(time).digest('HEX')
// returns '8a3df92d2a68b32b2b571a1b71bfea03556e0df4'
</code></pre>

<p>My point is to avoid to use an external lib for using OTP with Google Authenticator.
Best,</p>
","<p>your nodejs update() is no different. you need to use hex there also.</p>

<p>Attached a sample code</p>

<pre><code>const jsSHA = require(""jssha"");

const time = ""00000000030f7141""
const key = ""101010""
var shaObj = new jsSHA(""SHA-1"", ""HEX"");
shaObj.setHMACKey(key, ""HEX"");
shaObj.update(time);
const hmac = shaObj.getHMAC(""HEX"");
console.log(hmac) 
// returns '536d6eed86796085f8ec2ead742c52fd73995f27'
const crypto = require('crypto')

let out = crypto.createHmac('sha1', new Buffer(key, 'hex')).update(new Buffer(time,'hex')).digest('hex')
// returns '536d6eed86796085f8ec2ead742c52fd73995f27'
console.log(out)
</code></pre>
","49","<javascript><node.js><cryptojs>","1","0","1","2018-10-30 07:16:37","53059151","0","1","","","","2018-10-23 16:43:35",""
"58468429","Java encryption to javascript decryption AES, CryptoJS, CTR","<p>I am having encryption and decryption code already in place.
But now i am just going to use java encryption for encrypting the text.
And going to decrypt it in JavaScript using CryptoJS.</p>

<pre><code>@Service
public class EncryptionServiceImpl extends EncryptionService {

    protected static final int BLOCK_SIZE_BYTES = 16;

    protected static final int BLOCK_SIZE_BITS = 128;

    protected SecureRandom secureRandom;

    protected int keySizeByte;

    @Value(""${encryption.key}"")
    private String keyString ;


    public EncryptionServiceImpl() {
        byte[] key = keyString.getBytes();
        //create secret key spec instance
        secretKeySpec = new SecretKeySpec(key, ""AES"");
        try {
            cipher = javax.crypto.Cipher.getInstance(""AES/CTR/NoPadding"");
        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
        }
        //create secure random number generator instance
        secureRandom = new SecureRandom();
    }


    public String encrypt(String data) {
        byte[] dataByte = new byte[0];
        try {
            dataByte = data.getBytes(""UTF-8"");
        } catch (UnsupportedEncodingException e) {

        }
        //create iv
        SecureRandom randomSecureRandom;
        IvParameterSpec ivParams = null;
        byte[] iv = new byte[0];
        try {
            randomSecureRandom = SecureRandom.getInstance(""SHA1PRNG"");
            iv = new byte[cipher.getBlockSize()];
            randomSecureRandom.nextBytes(iv);
            ivParams = new IvParameterSpec(iv);
        } catch (NoSuchAlgorithmException e) {

        }
        try {
            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, secretKeySpec, ivParams);
        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
            throw e;
        }
        //return concatenation of iv + encrypted data
        byte[] encByteArr;
        try {
            encByteArr = ArrayUtils.addAll(iv, cipher.doFinal(dataByte));
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            throw e;
        }
        return  Base64.encodeBase64URLSafeString(encByteArr);
    }

    public String decrypt(String encryptedData) {
         byte[] decodedValue = Base64.decodeBase64(encryptedData);
        byte[] iv = new byte[BLOCK_SIZE_BYTES];
        System.arraycopy(data, 0, iv, 0, BLOCK_SIZE_BYTES);
        try {
            cipher.init(javax.crypto.Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(iv));
        } catch (InvalidKeyException | InvalidAlgorithmParameterException e) {
        }

        //return decrypted value
        byte[] decryptedByteArray;
        try {
            decryptedByteArray = cipher.doFinal(data, BLOCK_SIZE_BYTES, data.length - BLOCK_SIZE_BYTES);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
        }
        try {
            return new String(decryptedByteArray,""UTF-8"");
        } catch (UnsupportedEncodingException e) {
        }
        return new String(decryptedByteArray);
    }
}
</code></pre>

<p>I want to do the exact decryption in JS that what i did in java.
I am new to JS. 
i am trying below things to convert it in js.
I think looking at the code, i need to get rid of IV from encrypted text. but IV generated with SecureRandom. Unable to figure out how to get the rid of IV in JS. </p>

<pre><code>import CryptoJS from 'crypto-js';
/* eslint-disable no-restricted-globals */
function decryption(val) {
    const encrypted = CryptoJS.enc.Base64.parse(val);
    const key = CryptoJS.enc.Base64.parse(""&lt;my encryption key used in java code&gt;"");
    const iv = CryptoJS.enc.Base64.parse(val);
    const valueDec = CryptoJS.enc.Utf8.stringify(CryptoJS.AES.decrypt(
        { ciphertext: encrypted },
        key,
        { mode: CryptoJS.mode.CTR, padding: CryptoJS.pad.NoPadding, iv: iv, }));
    return valueDec;
}
</code></pre>
","","49","<javascript><java><encryption><aes><cryptojs>","0","","0","2019-10-19 22:35:32","","2","","9061551","","2019-10-19 22:35:32","2019-10-19 22:10:13",""
"58723860","Where to store the decryption key in reactjs?","<p>I am working on react app which fetches the API on the user responses. 
API response are encrypted and I get decryption key before making any API (via secure method). </p>

<p>I need to store the decryption key so that I can decrypt the API response every single time.
Currently I store the decryption key in component state. 
which can be seen very easily by anyone using react-dev tool</p>

<p>I don't need to store the decryption locally, it changes very time user login.</p>
","<p>The key needs to be stored inside an httpOnly cookie, a special kind of cookie thats only sent in HTTP requests to the server, and its never accessible (both for reading or writing) from JavaScript running in the browser. </p>

<p>By the way, this is the way JWT token verification works as well. So you can use the same mechanism.</p>

<p>PS: Ignore my previous comment, I was just trying to give you an alternative without giving my thought to it </p>
","48","<reactjs><encryption><aes><cryptojs>","0","-1","2","2019-11-06 07:04:19","","5","","9184555","","2019-11-06 06:05:04","2019-11-06 05:53:48",""
"58723860","Where to store the decryption key in reactjs?","<p>I am working on react app which fetches the API on the user responses. 
API response are encrypted and I get decryption key before making any API (via secure method). </p>

<p>I need to store the decryption key so that I can decrypt the API response every single time.
Currently I store the decryption key in component state. 
which can be seen very easily by anyone using react-dev tool</p>

<p>I don't need to store the decryption locally, it changes very time user login.</p>
","<p>I think you can use Cookies for storing your decryption key, but now that's your choice that you need to persist the cookie or make it available for the session.</p>

<p>You can encyrpt cookies making use of <a href=""https://github.com/hex7c0/cookie-encryption"" rel=""nofollow noreferrer"">cookie-encryption</a></p>

<p>Hope this helps!!</p>
","48","<reactjs><encryption><aes><cryptojs>","0","-1","2","2019-11-06 07:04:19","","5","","9184555","","2019-11-06 06:05:04","2019-11-06 05:53:48",""
"51670168","Encrypt and cannot decrypt back","<p>My problem is that I wrote a program that encrypts and decrypts files but doesn't decrypt it properly. I use AES-256 algorithm.</p>

<p>File system:
There are files in project folder:</p>

<pre><code>main.js
package.json
package-lock.json
files
  text1.txt
</code></pre>

<p>Here is main.js file:</p>

<pre><code>    // Import modules
    fs = require('fs');
    aes = require('aes256');

    // Change directory
    process.chdir('files');

    // Choosing global variables
      path = process.cwd();
      key = 'test';

    // Encrypt and decrypt files
      enc = file =&gt; {
       return aes.encrypt(key,file)
      }
      decr = encr =&gt; {
        return aes.decrypt(key,encr)
      }

    // Encrypt file
    fl = fs.readFileSync('file1.txt').toString();
    fs.writeFileSync('file1.txt',enc(fl));

    // Timeout
    setTimeout(()=&gt; {

    // Read file again and decrypt
    newfl = fs.readFileSync('file1.txt').toString()
    fs.writeFileSync('file1.txt',decr(fl))

    }, 3000);
</code></pre>

<p>If I run <code>node main</code> it firstly encrypts a file, then decrypts:</p>

<p>First step:</p>

<pre><code>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>

<p>Second step:</p>

<pre><code>wuv5VqCy3BEC1TeCikiZeYVNHTCJh5eDLCMgTIaKbMk95rBO6419DSUxjCC2d6Ps4s6UtiNSimFFLjzeDWlUML8W3KXNCGrEzu1aj5w9+uUHj34PSBTOLm6ynWs/SPVKoSl5oc5Fn4lGf4CxhuTLUD0C3UnuYwmQ/RYcYtCB/s1t2HiHUxluU4GUs9ge7j8mJUjj55fklaFJ+D9S1nBGIIQj47itbpY+5znnFv4bBumNeurV31F1Igf60ZSNScXFs5dg6oROhZiY33/DxvuwcewqElQzdXbfinHa7h99vl0hSvqSmHOH3Txt/vMQuGc8UovHZFwNsRN6uME0iQ+U+O71aXN6+gf1sn81fDdUB3t7vlgzjn6fEAQdrXSlUq75IFAYbOPnndyzkLFcGI6fklCMFq0JwwbhdtTlCijmah3hTKf1Lm6oQrOOLHkJG3nIxLengVauH9gWUYbJWdZEH7ygqnQbC/LC278bEsQXEwkCte+3Y6paBrgER/LwWFxgYnol0nVS2+kv1wa7zbf+aJhuLXidLVxX49cv1Uq+h0sbcXTSizTuOv9OzUfG8Ykmg9DMBo7Fu1RWBRh85AHZEYVFW8li/79dEgTRzjT5CHg=&lt;/pre&gt;
</code></pre>

<p>Third step:</p>

<pre><code>e|x&gt;!45$
fsYaA+.-m5p
</code></pre>

<p>Why it doesn't decrypt back?</p>
","<p>you need to pass encrypted file content to decr function, you are passing old file content for decryption</p>

<p>Change</p>

<pre><code>setTimeout(()=&gt; {

// Read file again and decrypt
newfl = fs.readFileSync('file1.txt').toString()
fs.writeFileSync('file1.txt',decr(fl))

}, 3000);
</code></pre>

<p>to </p>

<pre><code>setTimeout(()=&gt; {

// Read file again and decrypt
newfl = fs.readFileSync('file1.txt').toString()
fs.writeFileSync('file1.txt',decr(newfl))

}, 3000);
</code></pre>
","48","<javascript><node.js><encryption><aes><cryptojs>","0","1","1","2018-08-03 10:20:43","51670526","1","","","","","2018-08-03 10:01:47",""
"55789017","Encrypt individual rows within a text file using Node.js","<p>I'm trying to encrypt each row within a text file, not the text file itself. Here is the code I have for encrypting a single row of text. </p>

<pre><code>crypto.pbkdf2(password, salt, iteration, keylen, digest, (error, derivedKey) =&gt; {
    const iv = Buffer.from('myiv', 'hex');

    const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);

    let encryptThis = `Encrypt me`;
    let encrypted = '';

    cipher.on('readable', () =&gt; {
        let chunk;
        while (null !== (chunk = cipher.read())) {
            encrypted += chunk.toString('base64');
        }
    });

    cipher.on('end', () =&gt; {
        console.log(`Example string:   ${encryptThis}`);
    });

    cipher.write(encryptThis);
    cipher.end();
});
</code></pre>

<p>I know I can also encrypt using <code>cipher.update(text)</code> and <code>cipher.final()</code> and have tried this method too with no luck. The issue is how do I read a file line by line and encrypt each row. I've tried both methods, but it always results in only one line being encrypted or errors. I'd like to be able to do this with a stream transform, something like. </p>

<pre><code>readStream
    .pipe(encryptLine)
    .pipe(writeStream)
    .on('finish', err =&gt; {
        if (err) console.log(err);
    });
</code></pre>
","<p>Figured out a solution for this. I moved all the encryption logic to a function including the create and end and I do this for every line in the file. My issue was in trying to reuse the cipher.</p>

<pre><code>const encrypt = (line, thisTransform) =&gt; {
    crypto.pbkdf2(password, salt, iteration, keylen, digest, (error, derivedKey) =&gt; {
        const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);

        let encrypted = '';
        cipher.on('readable', () =&gt; {
            while (null !== (chunk = cipher.read())) {
                encrypted += chunk.toString('base64');
            }
        });

        cipher.on('end', () =&gt; {
            thisTransform.push(`${encrypted}\n`);
        });
        cipher.write(line);
        cipher.end();
    });
};

let encryptLine = new stream.Transform();
encryptLine._transform = function(chunk, encoding, callback) {
    let rows = chunk
        .toString()
        .split('\n')
        .map(line =&gt; line.replace(/[\n\r]/g, ''))
        .forEach(line =&gt; {
            encrypt(line, this);
        });
};

readStream
    .pipe(encryptLine)
    .pipe(writeStream)
    .on('finish', err =&gt; {
        if (err) console.log(err);
    });
</code></pre>
","48","<node.js><encryption><cryptojs>","1","0","2","2019-04-23 00:23:52","55802678","0","","","","","2019-04-22 04:11:36",""
"55789017","Encrypt individual rows within a text file using Node.js","<p>I'm trying to encrypt each row within a text file, not the text file itself. Here is the code I have for encrypting a single row of text. </p>

<pre><code>crypto.pbkdf2(password, salt, iteration, keylen, digest, (error, derivedKey) =&gt; {
    const iv = Buffer.from('myiv', 'hex');

    const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);

    let encryptThis = `Encrypt me`;
    let encrypted = '';

    cipher.on('readable', () =&gt; {
        let chunk;
        while (null !== (chunk = cipher.read())) {
            encrypted += chunk.toString('base64');
        }
    });

    cipher.on('end', () =&gt; {
        console.log(`Example string:   ${encryptThis}`);
    });

    cipher.write(encryptThis);
    cipher.end();
});
</code></pre>

<p>I know I can also encrypt using <code>cipher.update(text)</code> and <code>cipher.final()</code> and have tried this method too with no luck. The issue is how do I read a file line by line and encrypt each row. I've tried both methods, but it always results in only one line being encrypted or errors. I'd like to be able to do this with a stream transform, something like. </p>

<pre><code>readStream
    .pipe(encryptLine)
    .pipe(writeStream)
    .on('finish', err =&gt; {
        if (err) console.log(err);
    });
</code></pre>
","<p>I would start by first implementing a transform stream (or utilize an existing library) to read the file line-by-line.</p>

<pre><code>function toLines() {
    let line = '';
    return new Transform({
        decodeStrings: false,
        readableObjectMode: true,
        transform(chunk, encoding, callback) {
            const lines = chunk.split(/\r?\n/g);

            line += lines.shift();
            while (lines.length) {
                this.push(line);
                line = lines.shift();
            }

            callback();
        },
        flush(callback) {
            if (line) {
                this.push(line);
            }
            callback();
        }
    });
}
</code></pre>

<p>Then I would implement a transform stream for encrypting each line.</p>

<pre><code>function encryptLines(algorithm, derivedKey, iv) {
    return new Transform({
        readableObjectMode: false,
        writableObjectMode: true,
        transform(line, encoding, callback) {
            const cipher = crypto.createCipheriv(algorithm, derivedKey, iv);
            this.push(cipher.update(line, encoding, 'base64'));
            this.push(cipher.final('base64'));
            this.push('\n');
            callback();
        }
    });
}
</code></pre>

<p>Then then you can simply <code>pipe</code> everything to the output stream (as desired).</p>

<pre><code>fs.createReadStream('input.txt', {encoding: 'utf8'})
    .pipe(toLines())
    .pipe(encryptLines(algorithm, derivedKey, iv))
    .pipe(fs.createWriteStream('output.txt'))
    .on('finish', () =&gt; console.log('done'));
</code></pre>
","48","<node.js><encryption><cryptojs>","1","1","2","2019-04-23 00:23:52","55802678","0","","","","","2019-04-22 04:11:36",""
"58521221","Java SHA-1 to javascript using CryptoJS","<p>i have such a code to generate password written in Java</p>

<pre><code>        MessageDigest messageDigestPassword = MessageDigest.getInstance(""SHA1"");
        messageDigestPassword .reset();
        byte[] password = ""password"".getBytes();
        messageDigestPassword .update(password);
        byte[] encryptedPassword = messageDigestPassword .digest();

        String date = ""2019-10-22T11:33:13.393Z"";
        byte[] dateBytes = date.getBytes(StandardCharsets.UTF_8);

        int offset = 0;
        byte[] outputBytes = new byte[dateBytes.length + encryptedPassword .length];
        System.arraycopy(dateBytes, 0, outputBytes, offset, dateBytes.length);
        offset += dateBytes.length;
        System.arraycopy(encryptedPassword , 0, outputBytes, offset, encryptedPassword .length);

        MessageDigest finalMessageDigeset = MessageDigest.getInstance(""SHA-1"");
        finalMessageDigeset.reset();
        finalMessageDigeset.update(outputBytes);
        byte[] finalPasswordBytes= finalMessageDigeset .digest();

        String finalBase64Password = new String(Base64.encode(finalPasswordBytes));
</code></pre>

<p>and im trying to rewrite it to JavaScript to use it in postman with - <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">CryptoJS</a> 
So far i have : </p>

<pre><code>function wordArrayToByteArray(wordArray, length) {
if (wordArray.hasOwnProperty(""sigBytes"") &amp;&amp; 
wordArray.hasOwnProperty(""words"")) {
    length = wordArray.sigBytes;
    wordArray = wordArray.words;
}

var result = [],
    bytes,
    i = 0;
while (length &gt; 0) {
    bytes = wordToByteArray(wordArray[i], Math.min(4, length));
    length -= bytes.length;
    result.push(bytes);
    i++;
}
return [].concat.apply([], result);
}

function stringToBytes ( str ) {
var ch, st, re = [];
for (var i = 0; i &lt; str.length; i++ ) {
ch = str.charCodeAt(i);  // get char 
st = [];                 // set up ""stack""
do {
  st.push( ch &amp; 0xFF );  // push byte to stack
  ch = ch &gt;&gt; 8;          // shift value down by 1 byte
}  
while ( ch );
// add stack contents to result
// done because chars have ""wrong"" endianness
re = re.concat( st.reverse() );
}
// return an array of bytes
return re;
}



var dateFixed = ""2019-10-22T11:33:13.393Z"";
var fixedDateBytes = stringToBytes(dateFixed);
var sha1Password= CryptoJS.SHA1(""password"");
console.log(""sha1Password"",sha1Password.toString(CryptoJS.enc.Hex));

var sha1PasswordBytes= wordArrayToByteArray(sha1Password, 20);

var concatedBytes= fixedDateBytes.concat(sha1PasswordBytes);

var finalShaPassWords= CryptoJS.SHA1(concatedBytes); 
console.log(""finalShaPassWords"",finalShaPassWords.toString(CryptoJS.enc.Hex));

console.log(""finalShaPassWords"",finalShaPassWords.toString(CryptoJS.enc.Base64));
</code></pre>

<p>However unfortunatelly Base64 representations written in those 2 languages doesnt match. </p>

<p>I have checked and bytes from date are equal. Bytes from hashed password are not. So hashing after concat fails in JavaScript. </p>

<p>I have checked first password hashing and generated bytes and both of them are the same. So my guess line <code>var sha1PasswordBytes= wordArrayToByteArray(sha1Password, 20);</code> causes that line  <code>var finalShaPassWords= CryptoJS.SHA1(concatedBytes);</code> returns bad value. </p>

<p>Can someone give me some idea what is wrong? Mayby it should be written diffrent ? </p>
","<p>Since you are using CryptoJS anyway, you can also use the <a href=""https://cryptojs.gitbook.io/docs/#encoders"" rel=""nofollow noreferrer"">CryptoJS encoders</a> and the <a href=""https://github.com/brix/crypto-js/blob/develop/src/core.js"" rel=""nofollow noreferrer""><code>WordArray#concat</code>-method</a>, which considerably simplifies the code:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

// Input
var inPwd = ""password"";
var inDate = ""2019-10-22T11:33:13.393Z"";

// Processing
var pwdHash = CryptoJS.SHA1(inPwd);                                         // hash and convert to WordArray
var date = CryptoJS.enc.Utf8.parse(inDate);                                 // convert to WordArray
var joinedData = date.clone().concat(pwdHash);                              // join date and hashed password
var joinedDataHash = CryptoJS.SHA1(joinedData);                             // hash joined data
var joinedDataHashB64 = CryptoJS.enc.Base64.stringify(joinedDataHash);      // convert to Base64 string

// Output
console.log(""Result: "" + joinedDataHashB64 );                              // Output: D235TBTZMfpSyB/CDl5MHAjH5fI=
</code></pre>

<p>The output of this code is the same as the output of the Java-code: <code>D235TBTZMfpSyB/CDl5MHAjH5fI=</code></p>
","47","<javascript><java><hash><cryptojs>","2","1","1","2019-10-23 13:17:22","58523669","0","","","","","2019-10-23 10:53:08",""
"56749351","How can i use cryptojs in Native JS?","<p>I'm using cryptoJs in NativeJS which is in html. but when i decript the txt with aesDecrypt(decrypted,key) and it won't work. i have tried many other Ciphers, and it still don't work. would you guys view the code below and give me some advice ? </p>

<p>I tried many Ciphers(like aes-192-ecb,aes-256-ecb) in backend and it stil don't work. It report : bad encrypt Error.</p>

<pre><code>Front code: encrypt the txt and send to backend.
function aesEncrypt(data, key) {    
    key = CryptoJS.enc.Utf8.parse(key);    
    let encrypted = CryptoJS.AES.encrypt(data, key, {    
        mode: CryptoJS.mode.ECB,    
        padding: CryptoJS.pad.Pkcs7    
    });    
    return encrypted.toString();    
}   

Backend code: decrypt the txt sent from front.
function aesDecrypt(encrypted, key) {    
    const decipher = crypto.createDecipher('aes192', key);    
    let decrypted = decipher.update(encrypted, 'binary', 'utf8');    
    decrypted += decipher.final('utf8');    
    return decrypted;    
}
</code></pre>
","<p>looks like i used wrong methods both front and backend.</p>

<pre><code>front code:
&lt;script src=""https://cdn.jsdelivr.net/npm/crypto-js@3.1.9-1/crypto-js.js""&gt;&lt;/script&gt;
let encrypted = CryptoJS.AES.encrypt(""txt"", ""Secret Passphrase"").toString();


backend code:
const cryptojs = require(""crypto-js"");
let txt = cryptojs.AES.decrypt(encrypted , ""Secret Passphrase"").toString(cryptojs.enc.Utf8);
</code></pre>
","47","<cryptojs>","0","0","1","2019-06-26 01:12:47","56763879","0","","11194845","","2019-06-26 00:35:38","2019-06-25 07:55:38",""
"57884002","generate SHA1 hash ID for base64 input data (file data in base64)","<p>I'm trying to generate SHA1 hash ID for the input, input is nothing but file content in <code>base64</code> format.</p>

<p>To be clear input will be <code>base64</code> data, output will be SHA1 hash ID</p>

<p>I have been using CryptoJS library as shown in below code. But no luck the generated hash ID is different than the actual hash needed.</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=""utf-8""/&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel=""stylesheet"" media=""all"" href=""""/&gt;
        &lt;meta name=""viewport"" content=""width=device-width, initial-scale=1""/&gt;
    &lt;/head&gt;
    &lt;body lang=""en""&gt;
        &lt;form id=""test""&gt;
            &lt;p&gt;
                &lt;label&gt;Text&lt;/label&gt;&lt;br&gt;
                &lt;textarea id=""text"" style=""width: 500px; height: 200px""&gt;This is the secret message&lt;/textarea&gt;
            &lt;/p&gt;
            &lt;input type=""submit"" id=""submit""&gt;
        &lt;/form&gt;
        &lt;div id=""output""&gt;&lt;/div&gt;
        &lt;script src=""http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"" type=""text/javascript""&gt;&lt;/script&gt;
        &lt;script src=""crypto-js.min.js""&gt;&lt;/script&gt;
        &lt;script src=""sha1.js""&gt;&lt;/script&gt;
        &lt;script&gt;
            $(function() {
                $('#test').on('submit', function() {
                    var b64data= $('#text').val();
                    var hash = CryptoJS.SHA1(b64data);
                    var result = CryptoJS.enc.Hex.stringify(hash);
                    console.log(result);

                    return false;
                });

            });
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Output from my code:</p>

<blockquote>
  <p>6bc205c87e54d2d114a880f25d227b75639a9d74</p>
</blockquote>

<p>Expected output:</p>

<blockquote>
  <p>fca9cdfd98590aa4c417b412c8331dfb2faf2253</p>
</blockquote>

<p>Input <code>base64</code> sample: Unable to attach as length exceed Stack Overflow body limit.</p>
","<p>i have fixed my code converting base64 to words array like below</p>

<pre><code>var words = CryptoJS.enc.Base64.parse(b64data);
var hash = CryptoJS.SHA1(words);
var result = CryptoJS.enc.Hex.stringify(hash);
</code></pre>

<p>it worked for me. hope it will help others as well</p>
","47","<javascript><sha1><cryptojs>","0","0","1","2019-09-11 12:51:47","","2","","5073281","","2019-09-11 07:51:09","2019-09-11 07:18:22",""
"24363028","replace cryptoJS with PHP function","<p>Just to cut it short. Is there an equivalent script for the code below. I tried using mcrypt but the IV output seems different in crypto and in mcrypt.</p>

<pre><code>CryptoJS.enc.Base64.parse
</code></pre>

<p>Thanks.</p>
","<p>Base64 is not an encryption algorithm, but an encoding one. As such, it is not part of MCrypt ... and that wouldn't be necessary anyway. What you need is the <code>base64_decode()</code> function.</p>
","46","<php><mcrypt><cryptojs>","0","0","1","2014-07-11 23:05:22","","1","","","","","2014-06-23 09:54:39",""
"58077819","crypto-js encryption not returning same as C# encryption","<p>I am trying to convert a C# encryption method in angular by using crypto-js library in my angular project.</p>

<p>Here is the implementation of C# method</p>

<pre><code>private const string EncryptionKey = ""SomeSecretKEY"";
private readonly static byte[] Salt = Encoding.ASCII.GetBytes(EncryptionKey.Length.ToString());

public static String EncryptPassword(string password)
{
    var rijndaelCipher = new RijndaelManaged();
    byte[] plainText = Encoding.Unicode.GetBytes(password);
    var secretKey = new PasswordDeriveBytes(EncryptionKey, Salt);


    using (ICryptoTransform encryptor = rijndaelCipher.CreateEncryptor(secretKey.GetBytes(32), secretKey.GetBytes(16)))
    {
        using (var memoryStream = new MemoryStream())
        {
            using (var cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write))
            {
                cryptoStream.Write(plainText, 0, plainText.Length);
                cryptoStream.FlushFinalBlock();
                return Convert.ToBase64String(memoryStream.ToArray());
            }
        }
    }
}
</code></pre>

<p>And this is what i an trying in angular</p>

<pre><code>var enckey = ""SomeSecretKEY"";
var salt = CryptoJS.enc.Hex.parse(enckey.length.toString());
var key32Byte = CryptoJS.PBKDF2(enckey, salt, {
    keySize: 256 / 32
});
var iv = CryptoJS.PBKDF2(enckey, salt, {
    keySize: 128 / 32
});
var secret = CryptoJS.enc.Base64.parse(""messageforencryption"");
var enc = CryptoJS.AES.encrypt(secret, key32Byte.toString(), {""iv"": iv.toString()});
console.log(enc.toString());
</code></pre>

<p>I have not access to change the already written C# method.
Thanks in advance for any help.</p>
","","45","<javascript><c#><angular><cryptojs>","0","","0","2019-09-24 10:38:36","","4","","6310485","","2019-09-24 10:38:36","2019-09-24 10:03:56",""
"54506536","How can I store my salt as a string, while still using it as a buffer later?","<p>I'm trying to salt a password, however I get the following error message:</p>

<blockquote>
  <p>(node:958) MaxListenersExceededWarning: Possible EventEmitter memory
  leak detected. 11 exit listeners added. Use emitter.setMaxListeners()
  to increase limit </p>
  
  <p>TypeError: Salt must be a buffer</p>

<pre><code>at pbkdf2 (crypto.js:644:20)
at Object.exports.pbkdf2 (crypto.js:624:10)
at model.exports.UserCredentialsSchema.methods.setPassword (/Users/friso/Documents/projects/MEANpress/server/src/schemas/user-credentials.schema.ts:35:5)
at App.setupMongoose (/Users/friso/Documents/projects/MEANpress/server/src/App.ts:42:15)
at new App (/Users/friso/Documents/projects/MEANpress/server/src/App.ts:14:14)
at Object.&lt;anonymous&gt; (/Users/friso/Documents/projects/MEANpress/server/src/server.ts:5:13)
at Module._compile (module.js:635:30)
at Module.m._compile (/Users/friso/Documents/projects/MEANpress/server/node_modules/ts-node/src/index.ts:439:23)
at Module._extensions..js (module.js:646:10)
at Object.require.extensions.(anonymous function) [as .ts] (/Users/friso/Documents/projects/MEANpress/server/node_modules/ts-node/src/index.ts:442:12)
at Module.load (module.js:554:32)
at tryModuleLoad (module.js:497:12)
at Function.Module._load (module.js:489:3)
at Function.Module.runMain (module.js:676:10)
at Object.&lt;anonymous&gt; (/Users/friso/Documents/projects/MEANpress/server/node_modules/ts-node/src/bin.ts:157:12)
at Module._compile (module.js:635:30)
</code></pre>
</blockquote>

<p>I'm trying to do it for this schema and method:</p>

<pre><code>export var UserCredentialsSchema: Schema = new Schema({
    username: {
        type: String,
        lowercase: true,
        unique: true
    },
    password: String,
    salt: String
});

UserCredentialsSchema.methods.setPassword = function (password: string): void {
    randomBytes(saltLength, (err, buf) =&gt; {
        console.error(err);
        this.salt = buf.toString();
    });
    pbkdf2(password, this.salt, hashIterations, hashLength, digest, (err, derivedKey) =&gt; {
        console.error(err);
        this.hashedPassword = derivedKey;
    });
};
</code></pre>

<p>From the documentation and tutorials online I understood that crypto will convert the string of my salt to a buffer by itself, but this error makes me think otherwise.</p>

<p>Am I missing any steps in using <code>pbkdf2</code> maybe?</p>

<p>I'm getting the error while trying to create an admin user in the setup :</p>

<pre><code>const admin = new UserCredentials();
admin.username = 'admin';
admin.setPassword('admin');
admin.save();
</code></pre>

<p>Links to source code in Github:</p>

<ul>
<li><a href=""https://github.com/FrisoDenijs/MEANpress/blob/feature/login/server/src/schemas/user-credentials.schema.ts#L20"" rel=""nofollow noreferrer"">Schema</a> </li>
<li><a href=""https://github.com/FrisoDenijs/MEANpress/blob/feature/login/server/src/App.ts#L40"" rel=""nofollow noreferrer"">Set the admin</a></li>
</ul>
","<p>If you call <code>randomBytes</code> (I assume it is <code>crypto.randomBytes</code>) with a callback, then the process is made asynchronously. So when <code>pbkdf2</code> is called, <code>this.salt</code> hasn't been initialized yet.</p>

<p>Either move the call to <code>pbdkf2</code> inside the <code>randomBytes</code>' callback, or use the implicitly synchronous version:</p>

<pre><code>try {
  this.salt = randomBytes(saltLength);
} catch (err) {
  // handle err here
}
</code></pre>
","44","<node.js><mongoose><hash><cryptojs><pbkdf2>","0","2","1","2019-02-03 21:15:47","54507072","0","","","","","2019-02-03 19:12:49",""
"56786440","How to replicate same Android encrypt method in React-native?","<p>I'm creating a react-native application, where I need to encrypt with TripleDES using ECB mode and Pkcs7 padding. 
I have an Android Java piece of code that do the encrypt algorithm i want to replicate.</p>

<p>In react-native I added ""CryptoJS"" from <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">https://github.com/brix/crypto-js</a> and I called CryptoJS.enc.TripleDES.encrypt() method but it returns a different result than expected.</p>

<p>This is Android code i want to reach:</p>

<pre><code>private static byte[] encrypt(String message, String privateKeyMobile) throws Exception {
  final MessageDigest md = MessageDigest.getInstance(""MD5"");
  final byte[] digestOfPassword = md.digest(privateKeyMobile.getBytes(""utf-8""));

  final byte[] keyBytes = new byte[24];
  int q;
  for (q = 0; q &lt; 24 &amp;&amp; q &lt; digestOfPassword.length; q++) {
    keyBytes[q] = digestOfPassword[q];
  }
  if (q &lt; 24) {
    for (int u = q; u &lt; 24; u++)
      keyBytes[u] = 0;
  }
  for (int j = 0, k = 16; j &lt; 8;) {
    keyBytes[k++] = keyBytes[j++];
  }

  final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
  final Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS7Padding"");
  cipher.init(Cipher.ENCRYPT_MODE, key);

  final byte[] plainTextBytes = message.getBytes(""utf-8"");
  return cipher.doFinal(plainTextBytes);
}
</code></pre>

<p>This one is my react-native code:</p>

<pre><code>encrypt(message, key) {
  let md5key = CryptoJS.enc.MD5(key);
  var ciphertext = TripleDES.encrypt(message, md5key, {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7
  });
  return ciphertext;
}
</code></pre>

<p>The two functions returns different outputs.</p>

<p>This php code makes same work as Java code:
<a href=""https://webtools.workontech.com/triple-des-encryption-online"" rel=""nofollow noreferrer"">https://webtools.workontech.com/triple-des-encryption-online</a></p>

<p>Other online TripleDES tools return the same react-native result.</p>
","","44","<javascript><java><react-native><cryptojs><tripledes>","0","","0","2019-06-27 09:26:12","","3","","4540311","","2019-06-27 09:26:12","2019-06-27 07:53:26",""
"55130890","Decrypting AES 128 ECB with node.js returns wrong final block length","<p>I am decripting a large file (450mb).</p>

<p>I am reading the file with fs.createReadStream and decrypting with cryptojs.</p>

<p>The file has been encrypted in UTF8.</p>

<p>The contents of the file is JSON.</p>

<p><strong>MY FUNCTION:</strong></p>

<pre><code>function getData(pathMyfile) {

    var readStream = fs.createReadStream(pathMyfile, {encoding: 'utf8'});

    var aes = crypto.createDecipher('aes-128-ecb', 'xxx');

    readStream.pipe(aes).pipe(process.stdout);

}
</code></pre>

<p><strong>ERROR:</strong></p>

<pre><code>events.js:183 Uncaught Error: error:0606506D:digital envelope routines:EVP_DecryptFinal_ex:wrong final block length
    at Decipher._flush (crypto.js:158)
    at Decipher.prefinish (_stream_transform.js:137)
    at emitNone (events.js:106)
    at Decipher.emit (events.js:208)
    at prefinish (_stream_writable.js:593)
    at finishMaybe (_stream_writable.js:601)
    at endWritable (_stream_writable.js:612)
    at Decipher.Writable.end (_stream_writable.js:563)
    at ReadStream.onend (_stream_readable.js:595)
    at Object.onceWrapper (events.js:313)
    at emitNone (events.js:111)
    at ReadStream.emit (events.js:208)
    at endReadableNT (_stream_readable.js:1056)
    at _combinedTickCallback (internal/process/next_tick.js:138)
    at process._tickCallback (internal/process/next_tick.js:180)
</code></pre>
","","44","<javascript><node.js><cryptojs>","0","","0","2019-03-12 21:27:01","","0","1","","","","2019-03-12 21:27:01",""
"47881609","Encryption using cryptojs AES algorithm in JavaScript","<p>I done encryption in java like below, but the same code I need in javascript because same formate am using to decryption
or else anyother option encryption in javascript and decryption in java using cryptionjs.   </p>

<pre><code>static char[] pass={'p','a','s','s','w','o','r','d'};
static String alg=""PBEWithMD5AndDES"";
private static final byte[] SALT = { (byte) 0xde, (byte) 0x33, (byte) 0x11, (byte) 0x10, (byte) 0xde, (byte) 0x33,(byte) 0x11, (byte) 0x10, };

public static String encrypt(String property) throws GeneralSecurityException, UnsupportedEncodingException {
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(alg);
    SecretKey key = keyFactory.generateSecret(new PBEKeySpec(pass));
    Cipher pbeCipher = Cipher.getInstance(alg);
    pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(SALT, 20));
    return base64Encode(pbeCipher.doFinal(property.getBytes(""UTF-8"")));
}

private static String base64Encode(byte[] bytes) {
    return new BASE64Encoder().encode(bytes);
}
</code></pre>
","","44","<javascript><java><encryption><aes><cryptojs>","0","","0","2017-12-19 07:12:24","","4","","","","","2017-12-19 07:05:31",""
"49585107","How dis you get oauth-1.0a and crypto to work with WP-API","<p>I am using crypto and oauth-1.0a from nmp in ionic2 application. I want to access WP-API which is correctly set to handle authentication, I tested this using Postman.</p>

<p>Http.Get results in the following error:</p>

<pre><code>{
  ""_body"": {
    ""isTrusted"": true
  },
  ""status"": 0,
  ""ok"": false,
  ""statusText"": """",
  ""headers"": {},
  ""type"": 3,
  ""url"": null
}
</code></pre>

<p>The options generated that I pass as argument to Http.Get are as follows:</p>

<pre><code>{method:0,headers:{Authorization:OAuth oauth_consumer_key="",
oauth_nonce=jSZGPwkj4quRGMb0bhBLYKwmc3BGfrQw, oauth_signature=x3zseS3XTFBLMsNDLXC4byn2UDI%3D,
oauth_signature_method=HMAC-SHA1, oauth_timestamp=1522414816,
oauth_token="""",
oauth_version=1.0""},body:null,url:"""",params:{rawParams:"""",queryEncoder:{},paramsMap:{}},withCredentials:null,responseType:null}
</code></pre>

<p>Part of code:</p>

<pre><code>this.oauth = new OAuth({
consumer: {
key: this.apiconstant.consumerkey,
secret: this.apiconstant.consumersecret
},
signature_method: HMAC-SHA1,
hash_function: hash_function_sha1,
realm:
});
let request_data = {
url: ,
method: GET
};

let token={
key: this.apiconstant.token,
secret: this.apiconstant.tokensecret
}
//This part doesnt seem to work
this.authkey = this.oauth.authorize(request_data,token);
this.keyoauth = new URLSearchParams();
for (let param in this.authkey) {
this.keyoauth.set(param, this.authkey[param]);
}

let options = new RequestOptions({
method: GET,//request_data.method
url: ,
headers: this.oauth.toHeader(this.oauth.authorize(request_data,token)),
search: this.keyoauth
});

this.http.get(,options)
.map(res =&gt; res.json()).subscribe(data=&gt;{
console.log(Resulting data + JSON.stringify(data));
},
error=&gt;{
console.log(Got error+JSON.stringify(error));
});
</code></pre>

<p>//Error part executed</p>

<p>What am I missing here? Im testing my app on android device. Without authentication I get desired results from the WP-API (Wordpress), that is if the Oauth is disabled on WP-API.</p>

<p>Please help! This is my second day on this. I should also let you know Im new on these technologies but Im able to research and understand how they work.</p>
","","43","<ionic2><cryptojs><wp-api><oauth-1.0a>","0","","0","2018-03-31 07:02:02","","3","","4826457","","2018-03-31 07:02:02","2018-03-31 06:53:54",""
"55885858","How can I emit an array of objects using socket.io and cryptojs with sql server results?","<p>I'm trying to emit an array using Socket.io, but I'm getting a error. The code and error is below. I'm new to using WebSockets, so what can I do to emit this properly? </p>

<pre><code>var conn = new sql.ConnectionPool(dbConfig);
var req = new sql.Request(conn);
 conn.connect(function(err){
  if(err){
    console.log(""err"");
    return;
  }
  console.log('conectou')
  let vend = 'AUGUSTO'
  req.query(`select * from aca_visitas where cd_vend = '${vend}' and 
     dt_visita &gt;= '2019-03-01'`, 
  function(err, array){

    if(err)
    {
      console.log(""err db"");
    }
    else{
      let resultado = array.recordset
      console.log(resultado)
      var ciphertext = CryptoJS.AES.encrypt(JSON.stringify(resultado), 
          'secret key 123');
      io.emit(""Data-from-server"",ciphertext);
}
</code></pre>

<p>The error:</p>

<pre><code>C:\Trabalho\Projetos\MobSupervisor\TargetMobSupervisor\Prototipo\Retaguarda\node_modules\has-binary2\index.js:30
function hasBinary (obj) {
                   ^

RangeError: Maximum call stack size exceeded
</code></pre>
","<p>To emit and encrypt an Array or Object, you should first do a serialization, you could do that with (<code>JSON.stringify</code>) like you done in your code, and finnaly you need to put a <code>.toString()</code> method to emit a ""plain text"" (is a plain text now, because of serialization).</p>

<p>Your code should be: </p>

<pre><code>var ciphertext = CryptoJS.AES.encrypt(JSON.stringify(resultado), 'secret key 123').toString();
io.emit(""Data-from-server"",ciphertext);
</code></pre>

<p>Crypto-js DOC: <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/crypto-js</a></p>
","42","<node.js><sql-server><socket.io><cryptojs>","1","0","1","2019-04-30 17:01:56","","0","1","1896516","","2019-04-28 01:48:30","2019-04-27 23:53:53",""
"57140623","Node.js crypto create ecdh with the tron public address","<p>I am aiming for wallet address encryption, using the <a href=""https://developers.tron.network/docs/account"" rel=""nofollow noreferrer"">TronWeb.createAccount()</a>, I fetch the public address for wallet in base58 and the private key as hex.</p>

<pre><code>Sample Public Address: TPeGpPdJGQoNobV4SEjXLdrjefN3iCAAAA
Sample Private Key: 6B07B82D50B27171F35BF1DEAB14...
</code></pre>

<p>I am getting the keys using following code.</p>

<pre class=""lang-js prettyprint-override""><code>const TronWeb = require('tronweb');
function createAccount() {
    try {
        const tronWeb = new TronWeb(fullNode, solidityNode, eventServer);
        return tronWeb.createAccount();

    } catch (error) {
        console.log(error);
        throw error;
    }
}
</code></pre>

<p>When I use the getPublicKey() method after setting the private key in bob.createECDH() the code works fine but in actual I will not have the utility of setPrivateKey() method for alice when I am on bob side. So I will have to pass the base58 public address instead of bob.getPublicKey() or alice.getPublicKey() on either side.</p>

<pre class=""lang-js prettyprint-override""><code>const alice_secret = alice.computeSecret('HEX_PUBLIC_KEY','hex');
</code></pre>

<p>Following is the full code for encryption and decryption.</p>

<pre class=""lang-js prettyprint-override""><code>const alice = crypto.createECDH('secp256k1');
const bob = crypto.createECDH('secp256k1');
bob.setPrivateKey(""PRIVATE_KEY_FOR_BOB"", ""hex"");
alice.setPrivateKey(""PRIVATE_KEY_FOR_ALICE"", ""hex"");

const alice_secret = alice.computeSecret(bob.getPublicKey());
console.log(""alice's shared Key: "" + alice_secret.toString('hex') + ""\n"");

var algo = 'aes-256-ecb', plainText = ""Some secret to share bob"";
var cipher = crypto.createCipher(algo, alice_secret)
var encrypted = cipher.update(plainText, 'utf8', 'hex')
encrypted += cipher.final('hex');
console.log(""Encrypted: "" + encrypted);

const bob_secret = bob.computeSecret(alice.getPublicKey());
console.log(""bob's shared Key: "" + bob_secret.toString('hex') + ""\n"");

var decipher = crypto.createDecipher(algo, bob_secret)
var decrypted = decipher.update(encrypted, 'hex', 'utf8')
decrypted += decipher.final('utf8');
console.log(""Decrypted: "" + decrypted);

if (plainText == decrypted) {
    console.log(""ECDH Success"")
}
</code></pre>

<p>The output is expected when I use setPrivateKey() and then use getPublicKey()</p>

<pre><code>alice's shared Key: 238c3eba08585a5cae1006710c79fe2de329545e9ca4c1ef719c53b55eb337b6
app.js:21 Encrypted: 44184052d9e205fd855aaf5f30b5f186c4bab88a5cfdce58d99cd8c696954c8dd5676807e6fe372fbe3ca5b230e54293
app.js:29 bob's shared Key: 238c3eba08585a5cae1006710c79fe2de329545e9ca4c1ef719c53b55eb337b6
app.js:35 Decrypted: QmdUuJDvgZ7EWEpJmEcFCoYwotn9CHyvK4qEhZs82AhZoQ
app.js:40 ECDH Success
</code></pre>

<p>When I convert the public key to hex using bs58 or any other package it says </p>

<pre><code>UnhandledPromiseRejectionWarning: Error: Failed to translate Buffer to a EC_POINT
</code></pre>

<p>Is there a way to convert this public address and use it in this situation?</p>
","<p>I had to study the ECDH supported key format and regenerate the keys according to new format to be able to fix this issue.
There were two formats of the public key that we can use to encrypt data.</p>
","42","<node.js><cryptojs><ecdh>","1","1","1","2019-10-17 15:39:03","58436256","0","","","","","2019-07-22 06:59:02",""
"55419225","How to encrypt and decrypt in android","<p>I am new to android and I am trying to decrypt the data which is encrypted by making use of crypto-js in nodejs.</p>

<p>Nodejs code</p>

<pre><code>const secretKey = ""My secret key here"";    
const cipherText = CryptoJS.AES.encrypt(""Hello world"", secretKey);
const encryptedData = cipherText.toString();
</code></pre>

<p>Android code</p>

<pre><code>public static String encryptData(String data, String key) throws Exception {


    SecretKey secretKey = new SecretKeySpec(Base64.decode(key.getBytes(), Base64.NO_PADDING), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    byte[] bytes = cipher.doFinal(data.getBytes(""UTF-8""));
    String encValue = Base64.encodeToString(bytes, Base64.NO_PADDING);
    return encValue;
}
</code></pre>

<p>But both encrypted data (from nodejs &amp; android) is not same, so please help me what I need to do in android to get same encrypted data as in nodejs code.
Thanks in advance.</p>
","","41","<java><android><node.js><encryption><cryptojs>","0","","0","2019-03-30 07:54:16","","7","","6428677","","2019-03-30 07:54:16","2019-03-29 14:07:15","2019-03-30 21:28:06"
"57836380","NodeJS RSA prehashed sign","<p>I'm running NodeJS 8.12.0 and have to set a signature over a hash, without re-hashing it, performing a raw signature. Or, in other words, encrypt the hashed value with the private key.</p>

<pre><code>const crypto = require('crypto');

// 4096 bits key.
let pk  = ""&lt;BASE64 DER&gt;"";
let pub = ""&lt;BASE64 DER&gt;"";

// Transform them to PEM.
pk  = `-----BEGIN PRIVATE KEY-----\n${pk.replace('\n', '')}\n-----END PRIVATE KEY-----\n`;
pub = `-----BEGIN PUBLIC KEY-----\n${pub.replace('\n', '')}\n-----END PUBLIC KEY-----\n`;

// Load the data to sign and set the signature.
const fingerprint = Buffer.from('2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824','hex');
const signature = crypto.privateEncrypt({
        key: pk,
        padding: crypto.constants.RSA_PKCS1_PADDING
    }, 
    fingerprint
);

// Unfortunately, the server is not able to verify the signature...
console.log(signature.toString('hex'));
</code></pre>

<p>So I took a look at raw encryption of the message hash with my private key and ended up with some sort of <a href=""https://tools.ietf.org/html/rfc3447#section-9.2"" rel=""nofollow noreferrer"">EMSA encoding and followed these steps</a>:</p>

<ol>
<li>Apply the hash function to the message</li>
<li>Encode the algorithm ID for the hash function and the hash into ASN.1 value of DigestInfo (Appendix A.2.4)</li>
<li>Generate an octet string PS consisting of emLen - tLen - 3 octets of 0xff</li>
<li>Concatenate PS, the DER encoded value T, and other padding to form the encoded message EM as <code>EM = 0x00 || 0x01 || PS || 0x00 || T</code></li>
</ol>

<p>So, working that out</p>

<pre><code>// 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
H = 2c f2 4d ba 5f b0 a3 0e 26 e8 3b 2a c5 b9 e2 9e 1b 16 1e 5c 1f a7 42 5e 73 04 33 62 93 8b 98 24
emLen = 512

T = 30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 2c f2 4d ba 5f b0 a3 0e 26 e8 3b 2a c5 b9 e2 9e 1b 16 1e 5c 1f a7 42 5e 73 04 33 62 93 8b 98 24

PS = 04 06 02 00 33 ff ff ff

// 00010406020033ffffff003031300d0609608648016503040201050004202cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
EM = 00 01 04 06 02 00 33 ff ff ff 00 30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00 04 20 2c f2 4d ba 5f b0 a3 0e 26 e8 3b 2a c5 b9 e2 9e 1b 16 1e 5c 1f a7 42 5e 73 04 33 62 93 8b 98 24
</code></pre>

<p>But when I put that into the <code>privateEncrypt</code>, I do not get the correct output either. Can anyone help me here?</p>
","<p>You are trying to do the <code>PKCS1</code>-padding (<code>RSASSA-PKCS1-V1_5</code>) <em>manually</em>. But this isn't necessary. It's enough to concatenate the <a href=""https://tools.ietf.org/html/rfc8017#section-9.2"" rel=""nofollow noreferrer"">Hash-ID</a> (here for <code>SHA-256</code>) and your data (<code>fingerprint</code>), the rest is done by the <code>implicitly</code> selected padding (<code>crypto.constants.RSA_PKCS1_PADDING</code>), i.e.</p>

<pre><code>// Signing
var fingerprint = Buffer.from('2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824','hex');
var id = Buffer.from([0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20]);
var allData = Buffer.concat([id, fingerprint]);
var signature = crypto.privateEncrypt(privateKey, allData); // crypto.constants.RSA_PKCS1_PADDING by default

// Verifying with createVerify
var verify = crypto.createVerify('RSA-SHA256');
verify.update('&lt;the signed data&gt;'); 
var verified = verify.verify(publicKey, signature); // provides true

// Verifying with publicDecrypt
var decryptedFingerprint = crypto.publicDecrypt(publicKey, Buffer.from(signature)).slice(-32); // provides fingerprint
</code></pre>

<p><em>Note:</em> If you want to do the padding manually, you have to set the byte sequence <code>0x00 || 0x01 || PS || 0x00</code> before the <code>allData</code>-buffer. <code>PS</code> consists of as many <code>0xff</code>-bytes as necessary to reach the key length (in bytes). In addition, the flag 
<code>crypto.constants.NO_PADDING</code> must be set explicitly in the <code>privateEncrypt</code>-call. However, this isn't necessary, since the result is the same. The details are described in <a href=""https://tools.ietf.org/html/rfc8017#section-8.2.1"" rel=""nofollow noreferrer"">RFC 8017, Section 8.2.1</a></p>
","41","<node.js><rsa><signature><cryptojs>","1","1","1","2019-09-08 07:31:50","57839860","0","","","","","2019-09-07 18:21:06",""
"48228175","Decrypt php encripted string with javascript","<p>i need to decript my secret string generated from open_ssl php function with javascript.</p>

<p>I'm trying to decrypt string generated from php with cryptoJS</p>

<p>PHP FUNCTION</p>

<pre><code>$encData = openssl_encrypt(utf8_encode($pure_string), 'DES-EDE3',$encryption_key , OPENSSL_RAW_DATA);
$session['chip'] = base64_encode($encData);
</code></pre>

<p>JAVASCRIPT FUNCTION</p>

<pre><code>var keyHex = CryptoJS.enc.Utf8.parse(secretkey);
// direct decrypt ciphertext
var decrypted = CryptoJS.DES.decrypt({
        ciphertext: CryptoJS.enc.Base64.parse(secretText)
    }, keyHex, {
        mode: CryptoJS.mode.ECB
    });
console.info('decrypted :', decrypted);
var plaintext = decrypted.toString(CryptoJS.enc.Utf8);
console.info('plaintext :', plaintext);
</code></pre>

<p>But nothing to do, i'm not able to get right result.
I think that problem happen because php use EDE3 mode, and i haven't found any way to use that mode with cryptoJS.</p>

<p>Any suggestion or any other sample to decrypt DES-EDE3 string?</p>

<p>Thank you!</p>
","","41","<javascript><php><cryptojs>","1","","0","2018-01-12 14:24:04","","0","1","","","","2018-01-12 14:24:04",""
"58756605","CryptoJS encrypt HMACSha256 different than Java","<p>I'm trying to convert this code of CryptoJS to Kotlin:</p>

<pre class=""lang-js prettyprint-override""><code>const hash = CryptoJS.HmacSHA256(message, key); 
const signature = CryptoJS.enc.Hex.stringify(hash);
</code></pre>

<p>That's the kotlin code equivalent to above snippet:</p>

<pre><code>private fun generateSignature(key: String, payload: String): String {
    val algorithm = ""HmacSHA256""

    return Mac.getInstance(algorithm)
        .apply { init(SecretKeySpec(key.toByteArray(), algorithm)) }
        .run { doFinal(payload.toByteArray()) }
        .let { HexUtils.toHexString(it) }
}
</code></pre>

<p>But it is not working at all. They generate different results. CryptoJS generates an array of bytes that has 8 positions, the Java code generates an array of bytes that has 32 positions.</p>

<p>I don't know what Im doing wrong. I need to make my Kotlin code work exactly as the javascript one.</p>

<p>Update: I can't change the Javascript way. I have to do the exactly same thing in Kotlin</p>

<p>Update2: Here is a test where the JS code and the Kotlin code generates different results.</p>

<p>Input:</p>

<pre><code>key = 's21fk4vb-5415-46c7-aade-303dcf432bb4'
message = 'POST,/wallets/3323461f96-bdf3-4e03-bc93-7da1fb27aee7/withdraw/,1573148023809,{""amount"":""1.0"",""bank"":{""bank"":""789"",""agency"":""456"",""account"":""12378"",""accountDigit"":""6"",""name"":""joao"",""taxId"":""33206913098"",""holderType"":""personal""}}'
</code></pre>

<p>Results with JS code:</p>

<pre class=""lang-js prettyprint-override""><code>Result of encrypt in bytes:
{sigBytes: 32, words: [8]}
sigBytes: 32
words: [8]
0: 2102759135
1: -196086391
2: -2099697915
3: -1620551271
4: 2463524
5: 1757965357
6: -1039993965
7: -1798822705

Bytes to Hex:
7d558edff44ff58982d927059f6859990025972468c86c2dc202f39394c824cf
</code></pre>

<p>Results with Kotlin code:</p>

<pre><code>Result of encrypt in bytes:
{byte[32]@1126} 
 0 = 82
 1 = -110
 2 = -100
 3 = -128
 4 = -63
 5 = 22
 6 = -103
 7 = -31
 8 = 83
 9 = -125
 10 = -72
 11 = 109
 12 = -91
 13 = -69
 14 = 54
 15 = -41
 16 = 27
 17 = -107
 18 = -60
 19 = -110
 20 = -57
 21 = -29
 22 = -20
 23 = -32
 24 = -66
 25 = 88
 26 = 87
 27 = -50
 28 = -47
 29 = -18
 30 = -96
 31 = 25

Bytes to Hex:
52929c80c11699e15383b86da5bb36d71b95c492c7e3ece0be5857ced1eea019
</code></pre>
","<p>No SHA-256 hash can have only 8 byte positions. The output, as the name suggests, should be 256 bits or 32 bytes. What I suspect to happen is that the input of <code>stringify</code> is already presumed to be bytes, while CryptoJS functions return a <code>WordArray</code> of 32 bit words. As 8 * 32 = 256 this seems reasonable.</p>

<p>So I presume you can simply fix this by using a function on the <code>WordArray</code> instead, for instance <code>hash.toString('hex')</code>.</p>
","41","<java><kotlin><encryption><hmac><cryptojs>","0","1","1","2019-11-08 18:41:38","","3","","11857568","","2019-11-08 18:41:38","2019-11-07 20:40:10",""
"57971721","php equivalent for mcrypt_decrypt in javascript?","<p>I am using following code in php </p>

<pre><code>mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $secretKey, $str, MCRYPT_MODE_CBC, $vector);
</code></pre>

<p>In javascript it does not return similar output as php
I have used the code:</p>

<pre><code>var key = CryptoJS.enc.Utf8.parse(secretKey);
var iv=    CryptoJS.enc.Utf8.parse(vector);
var decrypted = CryptoJS.AES.decrypt(encryptText,key,{iv:iv,padding:CryptoJS.pad.Pkcs7});
</code></pre>
","","40","<javascript><php><mcrypt><cryptojs>","0","","0","2019-09-17 13:37:14","","3","","569976","","2019-09-17 13:37:14","2019-09-17 09:51:56",""
"57524744","Cannot read property '0' of undefined at Object.xorBlock (crypto-js.js:3620)","<p>I am trying to decode a value which is encrypted using AES 256 bits algorithm, where IV is not used and only a private key is used to encrypt and I have no padding settings mentioned as well. I am using crypto-js v3.1.2. The base64 encrypted string is communicated to the page and the JS code is required to decrypt. For testing purpose I am using ""<a href=""https://www.devglan.com/online-tools/aes-encryption-decryption"" rel=""nofollow noreferrer"">https://www.devglan.com/online-tools/aes-encryption-decryption</a>"" online tool and trying to decrypt the base64 string provided by this tool.</p>

<p>My Decryption Code:</p>

<pre><code>var key = 'some-32-characters-key-in-plaintext';
const dataValue = 'base64-encrypted-value';
console.log('data value to decrypt: '+ dataValue);
var decrypted = CryptoJS.AES.decrypt(
    dataValue, // pass base64
    key,
    {
        // iv: _iv, // IV is not used
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.ZeroPadding //I have no specific padding, hence I am trying to use zero padding
    })
console.log(""decrypted object: ""+decrypted);
var dvalue = decrypted.toString(CryptoJS.enc.Utf8);
console.log('decrypted text: ' + dvalue);
</code></pre>

<p>here is the crypto-js file I am using</p>

<pre><code> &lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
</code></pre>

<p>I am not able to decrypt it and I am getting this error on the console:</p>

<pre><code>angular.js:15567 TypeError: Cannot read property '0' of undefined
at Object.x (aes.js:26)
at Object.processBlock (aes.js:26)
at Object._doProcessBlock (aes.js:28)
at Object._process (aes.js:11)
at Object._doFinalize (aes.js:28)
at Object.finalize (aes.js:25)
at Object.decrypt (aes.js:30)
at Object.decrypt (aes.js:25)
at decryptBrokerToken (FundDiscoveryController.js:364)
at b.$scope.init (FundDiscoveryController.js:9) ""&lt;div ng-controller=""FundDiscoveryController"" data-ng-init=""init()"" class=""ng-scope""&gt;""
</code></pre>
","","40","<javascript><cryptojs>","0","","0","2019-08-16 12:33:54","","2","","","","","2019-08-16 12:33:54",""
"55710514","How to duplicate symfony passwordEncode in javascript","<p>I need to create a javascript hashing algorithm the same as Symfony 3 encodePassword.</p>

<p>This was a similar problem to that in but in symfony3:
<a href=""https://stackoverflow.com/questions/25928509/symfony2-password-encoder-function-in-javascript"">Symfony2 password encoder function in Javascript</a></p>

<p>this is to create a message digest to test a rest endpoint with wsse headers in Symfony with fosbundle in postman.</p>

<p>I've managed to simplify and duplicate the Symfony hashing function in PHP</p>

<pre class=""lang-php prettyprint-override""><code>$pass = ""hello"";
$salt = """";
$iterations=5000;

echo $this-&gt;encoder-&gt;encodePassword($pass,$salt);
//contains: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw== 

//simplyfying and replicating the hashing algo in php with same pass/salt:

$salted = $pass.$salt;
$digest = hash(""sha512"", $salted, true);

for($i=1; $i&lt;$iterations; $i++) {
    $digest = hash(""sha512"", $digest.$salted, true);
}

echo base64_encode($digest);
//contains: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw==
</code></pre>

<p>but trying to replicate it in javascript using CryptoJS is proving troublesome. I suspect its to do with the character encoding too.</p>

<p>according to <a href=""https://code.google.com/archive/p/crypto-js/#The_Hasher_Input"" rel=""nofollow noreferrer"">https://code.google.com/archive/p/crypto-js/#The_Hasher_Input</a></p>

<blockquote>
  <p>The hash algorithms accept either strings or instances of
  CryptoJS.lib.WordArray [...] an array of 32-bit words. When you pass a
  string, it's automatically converted to a WordArray encoded as UTF-8.</p>
</blockquote>

<pre><code>
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>password = 'hello';

//attempt 1 use hex converted pass
hexpass = CryptoJS.enc.Utf8.parse(password);
digest = CryptoJS.SHA512(hexpass);

for (i = 1; i &lt; 5000; ++i) {
    hexvar = CryptoJS.SHA512(digest + hexpass);
}

digest = digest.toString(CryptoJS.enc.Base64);
console.log(digest);

// need hash to contain: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw==</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>


</code></pre>

<p>I've tried many different ways to with converting to word array first etc. but none seem to come up with the same hash </p>

<p><a href=""https://jsfiddle.net/munkiepus/awdoq4kL/34/"" rel=""nofollow noreferrer"">https://jsfiddle.net/munkiepus/awdoq4kL/34/</a></p>

<p>EDIT: i think the problem is that the php uses some form of raw binary </p>

<p>outputting the result of <code>$digest = hash(""sha512"", $salted, true);</code> to the terminal shows:</p>

<p>q$bx]j=s1
%g&lt;##|zn
FcG.:osC</p>

<p>so maybe it's not possible in JS after all. if the digest was encoded to a readable string during each iteration then it may be possible, as in the linked example.</p>
","<p>Why do you need that? The best thing is that you only encrypt it on one side, either from JS or Symfony and only compare the hashes.</p>

<p>The other option is to not use <code>encodePassword()</code> and use <code>md5()</code> for example.</p>

<p>In this <a href=""https://github.com/symfony/symfony/blob/3.2/src/Symfony/Component/Security/Core/Encoder/PlaintextPasswordEncoder.php"" rel=""nofollow noreferrer"">link</a> shows you how it works <code>encodePassword()</code>.</p>

<p>Regards!</p>
","39","<javascript><encoding><cryptojs><sha512>","0","0","2","2019-04-17 12:38:59","55726890","4","","2831388","","2019-04-17 08:33:04","2019-04-16 14:25:37",""
"55710514","How to duplicate symfony passwordEncode in javascript","<p>I need to create a javascript hashing algorithm the same as Symfony 3 encodePassword.</p>

<p>This was a similar problem to that in but in symfony3:
<a href=""https://stackoverflow.com/questions/25928509/symfony2-password-encoder-function-in-javascript"">Symfony2 password encoder function in Javascript</a></p>

<p>this is to create a message digest to test a rest endpoint with wsse headers in Symfony with fosbundle in postman.</p>

<p>I've managed to simplify and duplicate the Symfony hashing function in PHP</p>

<pre class=""lang-php prettyprint-override""><code>$pass = ""hello"";
$salt = """";
$iterations=5000;

echo $this-&gt;encoder-&gt;encodePassword($pass,$salt);
//contains: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw== 

//simplyfying and replicating the hashing algo in php with same pass/salt:

$salted = $pass.$salt;
$digest = hash(""sha512"", $salted, true);

for($i=1; $i&lt;$iterations; $i++) {
    $digest = hash(""sha512"", $digest.$salted, true);
}

echo base64_encode($digest);
//contains: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw==
</code></pre>

<p>but trying to replicate it in javascript using CryptoJS is proving troublesome. I suspect its to do with the character encoding too.</p>

<p>according to <a href=""https://code.google.com/archive/p/crypto-js/#The_Hasher_Input"" rel=""nofollow noreferrer"">https://code.google.com/archive/p/crypto-js/#The_Hasher_Input</a></p>

<blockquote>
  <p>The hash algorithms accept either strings or instances of
  CryptoJS.lib.WordArray [...] an array of 32-bit words. When you pass a
  string, it's automatically converted to a WordArray encoded as UTF-8.</p>
</blockquote>

<pre><code>
<div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>password = 'hello';

//attempt 1 use hex converted pass
hexpass = CryptoJS.enc.Utf8.parse(password);
digest = CryptoJS.SHA512(hexpass);

for (i = 1; i &lt; 5000; ++i) {
    hexvar = CryptoJS.SHA512(digest + hexpass);
}

digest = digest.toString(CryptoJS.enc.Base64);
console.log(digest);

// need hash to contain: U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw==</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>


</code></pre>

<p>I've tried many different ways to with converting to word array first etc. but none seem to come up with the same hash </p>

<p><a href=""https://jsfiddle.net/munkiepus/awdoq4kL/34/"" rel=""nofollow noreferrer"">https://jsfiddle.net/munkiepus/awdoq4kL/34/</a></p>

<p>EDIT: i think the problem is that the php uses some form of raw binary </p>

<p>outputting the result of <code>$digest = hash(""sha512"", $salted, true);</code> to the terminal shows:</p>

<p>q$bx]j=s1
%g&lt;##|zn
FcG.:osC</p>

<p>so maybe it's not possible in JS after all. if the digest was encoded to a readable string during each iteration then it may be possible, as in the linked example.</p>
","<p>Ok so it was the binary data causing the problem, if we convert the word array into a binary string it works.</p>

<p>needed some other functions to do the conversions see the runnable example for the functions. example</p>

<pre><code>
hashWordArray = CryptoJS.SHA512(password);
uint8array    = convertWordArrayToUint8Array(hashWordArray);
binaryString  = convertUint8ArrayToBinaryString(uint8array);

for (var i=1; i&lt;5000; i++) {
    wordArrayFromString = CryptoJS.enc.Latin1.parse(binaryString+password);
    hashWordArray = CryptoJS.SHA512(wordArrayFromString);
    uint8array    = convertWordArrayToUint8Array(hashWordArray);
    binaryString  = convertUint8ArrayToBinaryString(uint8array);
}

b64_encoded = btoa(binaryString);
</code></pre>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>const password = ""hello"";
// set up the container to display output
var div = document.getElementById('message');
div.innerHTML += 'string to hash:&lt;br&gt;';
div.innerHTML += password+'&lt;br&gt;&lt;br&gt;';
div.innerHTML += 'php generated hash:&lt;br&gt;';
correct_hash = 'U5xyFq7KQU1CWeX3UcLB0mwWZZQUq0PL8U+GLWomfGW/WQWxxGLi+0ifhmnlw/gQ5pPjNNZV1/q8kMVpAXsFZw=='
div.innerHTML += correct_hash+'&lt;br&gt;&lt;br&gt;';


//actually do the hashing
hashWordArray = CryptoJS.SHA512(password);
uint8array    = convertWordArrayToUint8Array(hashWordArray);
binaryString  = convertUint8ArrayToBinaryString(uint8array);

for (var i=1; i&lt;5000; i++) {
    wordArrayFromString = CryptoJS.enc.Latin1.parse(binaryString+password);
    hashWordArray = CryptoJS.SHA512(wordArrayFromString);
    uint8array    = convertWordArrayToUint8Array(hashWordArray);
    binaryString  = convertUint8ArrayToBinaryString(uint8array);
}

b64_encoded = btoa(binaryString);


// add the outputr to the display container
div.innerHTML += 'javascript generated hash:&lt;br&gt;';
div.innerHTML += b64_encoded +""&lt;br&gt;&lt;br&gt;""; //b64_encode()




// functions from
// https://gist.github.com/getify/7325764

function convertWordArrayToUint8Array(wordArray) {
	var len = wordArray.words.length,
		u8_array = new Uint8Array(len &lt;&lt; 2),
		offset = 0, word, i
	;
	for (i=0; i&lt;len; i++) {
		word = wordArray.words[i];
		u8_array[offset++] = word &gt;&gt; 24;
		u8_array[offset++] = (word &gt;&gt; 16) &amp; 0xff;
		u8_array[offset++] = (word &gt;&gt; 8) &amp; 0xff;
		u8_array[offset++] = word &amp; 0xff;
	}
	return u8_array;
}

function convertUint8ArrayToBinaryString(u8Array) {
	var i, len = u8Array.length, b_str = """";
	for (i=0; i&lt;len; i++) {
		b_str += String.fromCharCode(u8Array[i]);
	}
	return b_str;
}</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js""&gt;&lt;/script&gt;

&lt;div id=""message""&gt;&lt;/div&gt;</code></pre>
</div>
</div>
</p>
","39","<javascript><encoding><cryptojs><sha512>","0","0","2","2019-04-17 12:38:59","55726890","4","","2831388","","2019-04-17 08:33:04","2019-04-16 14:25:37",""
"58378511","How is RSA/ECB/PKCS1 padding encryption done in Nodejs","<p>I have to encrypt a string using <code>RSA/ECB/PKCS1</code> padding encryption with a public certificate. </p>

<p>I have used this code for this:</p>

<p>I am not able to encrypt it correctly. Whats wrong in this.</p>

<p>Is there any method in crypto.js to do the same??</p>

<p>I have tried code using nodejs but not working so far.</p>

<pre><code>const key = new NodeRSA();
key.importKey({
            n: Buffer.from(parsedKey.publicModulus, 'hex'),
            e: parseInt(parsedKey.publicExponent, 10)
}, 'components-public');
key.setOptions({encryptionScheme: 'pkcs1'});

var encryptedKey = key.encrypt(randomNumber, 'base64');```

I am getting an encrypted key but thats not correct.
</code></pre>
","","39","<node.js><encryption><rsa><cryptojs>","-1","","0","2019-10-14 14:06:50","","3","","","","","2019-10-14 14:06:50",""
"57161520","I get a typeerror when using CryptoJS.AES.encrypt","<p>I found this code online on <a href=""https://gist.github.com/dudepare/99f4d682c3db90ea86a4331e32f0006a"" rel=""nofollow noreferrer"">this</a> website, but it doesn't work for me. when I try to use the encrypt function it gives me this error:</p>

<blockquote>
  <p>Uncaught TypeError: Cannot read property 'encrypt' of undefined
      at encrypt (Index.html:36)
      at s (Index.html:86)
      at HTMLButtonElement.onclick (Index.html:90)</p>
</blockquote>

<p>this is the html I used:</p>

<pre><code>&lt;body&gt;
    &lt;script&gt;
        function s(){
            console.log(encrypt(""Hello"", ""mmm""));
            console.log(decrypt(encrypt(""Hello"", ""mmm""), ""mmm""));
        }
    &lt;/script&gt;
    &lt;button onclick=""s();""&gt;click me&lt;/button&gt; 
&lt;/body&gt;
</code></pre>

<p>this is the code for encryption (in the ""head""):</p>

<pre><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/core-min.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/sha256.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/components/enc-base64.js""&gt;&lt;/script&gt;
&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
    function toWordArray(str){
      return CryptoJS.enc.Utf8.parse(str);
    }

    function toString(words){
      return CryptoJS.enc.Utf8.stringify(words);
    }

    function toBase64String(words){
      return CryptoJS.enc.Base64.stringify(words);
    }

    function encrypt(input, key){

      var PROTOCOL_AES256 = 2;
      var secret_key = CryptoJS.SHA256(key);
      var header = toWordArray(""AMAZON"" + String.fromCharCode(PROTOCOL_AES256));
      var iv = CryptoJS.lib.WordArray.random(16);
      var body = CryptoJS.AES.encrypt(json_payload, secret_key, {iv: iv});//This is where the was.

      // construct the packet
      // HEADER + IV + BODY
      header.concat(iv);
      header.concat(body.ciphertext);

      // encode in base64
      return toBase64String(header);
    }

    function decrypt(input, key){
      // convert payload encoded in base64 to words
      var packet = CryptoJS.enc.Base64.parse(input);

      // helpers to compute for offsets
      var PROTOCOL_AES256 = 2;
      var secret_key = CryptoJS.SHA256(key);
      var header = toWordArray(""AMAZON"" + String.fromCharCode(PROTOCOL_AES256));
      var iv = CryptoJS.lib.WordArray.random(16);

      // compute for offsets
      var packet_size = packet.words.length - (iv.words.length + header.words.length);
      var start = iv.words.length + header.words.length;
      var end = packet.words.length;

      var ciphertext = CryptoJS.lib.WordArray.create(packet.words.slice(start, end));
      var parsed_iv = CryptoJS.lib.WordArray.create(packet.words.slice(header.words.length, iv.words.length+1));
      ciphertext = toBase64String(ciphertext);
      var decrypted = CryptoJS.AES.decrypt(ciphertext, secret_key, {iv: parsed_iv});

      return toString(decrypted);
    }
&lt;/script&gt;
</code></pre>
","","39","<javascript><aes><typeerror><cryptojs>","1","","0","2019-07-23 10:00:16","","0","","","","","2019-07-23 10:00:16",""
"57949643","Hmac.digest returning AN_ERROR_OCCURRED_WHILE_DECRYPT_PASSWORDGUID","<p>I am trying to create a function which generates an OAuth signature using suitescript 2.0. However, I am encountering a ""AN_ERROR_OCCURRED_WHILE_DECRYPT_PASSWORDGUID - An error occurred while decrypting a credential."" error when I use the hmac.digest function. Any ideas where I went wrong?</p>

<pre><code>var generateOAuthSignature = function(params) {
    require(['N/crypto', 'N/encode'], function(crypto, encode) {
        var timestamp = Math.round((new Date()).getTime() / 1000.0);
        var nonce = encode.convert({
            string: timestamp + """",
            inputEncoding: encode.Encoding.UTF_8,
            outputEncoding: encode.Encoding.BASE_64
        });

        var oauth_headers = {
            oauth_version: ""1.0"",
            oauth_nonce: nonce,
            oauth_signature_method: params.signature_method,
            oauth_consumer_key: params.consumer_key,
            oauth_token: params.token,
            oauth_timestamp: timestamp
        };

        log.debug('oauth_headers', oauth_headers)

        var url_params = params.rest_url.split(""?"")[1].split(""&amp;"");
        var signature_params = {};

        for (key in oauth_headers) {
            signature_params[key] = key + ""="" + oauth_headers[key];
        }

        for (key in url_params) {
            var temp = url_params[key].split(""="");
            signature_params[temp[0]] = url_params[key];
        }

        var signature_string = """";
        var sortedkeys = Object.keys(signature_params).sort();

        for (var i = 0; i &lt; sortedkeys.length; i++) {
            signature_string += (i == 0 ? """" : ""&amp;"") + signature_params[sortedkeys[i]];
        }

        var base_string = params.method + ""&amp;"" + encodeURIComponent(params.rest_url.split(""?"")[0]) + ""&amp;"" + encodeURIComponent(signature_string);
        var composite_key_guid = encodeURIComponent(params.consumer_secret) + ""&amp;"" + encodeURIComponent(params.token_secret);

        log.debug('composite_key_guid', composite_key_guid);
        log.debug(""crypto.createSecretKey({guid: composite_key, encoding: encode.Encoding.UTF_8})"", JSON.stringify(crypto.createSecretKey({ guid: composite_key_guid, encoding: encode.Encoding.UTF_8 })));

        var secret_key = crypto.createSecretKey({
            guid: composite_key_guid, encoding: encode.Encoding.UTF_8
        });

        log.debug('secret_key', secret_key);

        var hmac = crypto.createHmac({
            algorithm: crypto.HashAlg.SHA256,
            key: secret_key
        });

        hmac.update({
            input: base_string,
            inputEncoding: encode.Encoding.UTF_8
        });

        // error occuring here 
        oauth_signature = hmac.digest({
            outputEncoding: encode.Encoding.BASE_64
        });

        //more code below...
    });
}
</code></pre>
","","38","<javascript><netsuite><hmac><cryptojs><suitescript>","0","","0","2019-09-16 02:16:37","","2","","","","","2019-09-16 02:16:37",""
"56949907","How to decrypt message with CryptoJS AES? I have a working node crypto example","<p>I am able decrypt AES encrypted message using Node's crypto library as follow</p>

<pre><code>const crypto = require('crypto');
const encryptedData = 'b6ab428efbcb93c2f483178114ac0608530e54428f1378c6d3be108531b730d1888e562044cd3acb8844a04d9d7602d83b96f0a758248ffd07cd9c530b76c91c';

const decryptResponse2 = (data) =&gt; {
  const key = 'F5:A4:F4:AB:BF:68:CF:86:51:B4:AA';
  const iv = Buffer.from(data.substring(0, 32), 'hex');
  const payload = data.substring(32);
  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv).setAutoPadding(false);
  const decipherFinal = decipher.update(payload, 'hex', 'utf8') +   decipher.final('utf8');

  console.log(decipherFinal);
};

decryptResponse2(encryptedData);
</code></pre>

<p>I create a script using <code>crypto-js</code> library as that is available to be used in browser. The code I tried is as follow:</p>

<pre><code>const crypto = require('crypto-js');
const encryptedData = 'b6ab428efbcb93c2f483178114ac0608530e54428f1378c6d3be108531b730d1888e562044cd3acb8844a04d9d7602d83b96f0a758248ffd07cd9c530b76c91c';

const decryptResponse = (data) =&gt; {
  const key = 'F5:A4:F4:AB:BF:68:CF:86:51:B4:AA';
  const iv = Buffer.from(data.substring(0, 32), 'hex');
  const payload = data.substring(32);
  let decryptedData = crypto.AES.decrypt(
    payload,
    key,
    {
      iv: iv,
      mode: crypto.mode.CBC,
      padding: crypto.pad.NoPadding
    });
  console.log(decryptedData.toString());
}

decryptResponse(encryptedData);
</code></pre>

<p>However, not only is it generating wrong decrypted data, the decrypted message is not even consistent. I don't know what I am doing wrong as I do not know much about encryption and decryption.</p>

<p>Any help will be apriciated.</p>
","<p>Thanks to @GrafiCode pointing me to the <a href=""https://github.com/brix/crypto-js/issues/195#issuecomment-470200681"" rel=""nofollow noreferrer"">right place</a>, I was able to solve it using <code>format</code> property of config object.</p>

<p>Following is the code:</p>

<pre><code>const crypto = require('crypto-js');
const encryptedData = 'b6ab428efbcb93c2f483178114ac0608530e54428f1378c6d3be108531b730d1888e562044cd3acb8844a04d9d7602d83b96f0a758248ffd07cd9c530b76c91c';

const decryptResponse = (data) =&gt; {
  const key = crypto.enc.Utf8.parse('F5:A4:F4:AB:BF:68:CF:86:51:B4:AA');
  const iv = crypto.enc.Hex.parse(data.substring(0, 32));
  const payload = data.substring(32);
  let decryptedData = crypto.AES.decrypt(
    payload,
    key,
    {
      iv: iv,
      mode: crypto.mode.CBC,
      // padding: crypto.pad.NoPadding,
      format: crypto.format.Hex
    });
  console.log(crypto.enc.Utf8.stringify(decryptedData));
}

decryptResponse(encryptedData);
</code></pre>

<p>I commented out the <code>padding: crypto.pad.NoPadding</code> as there were non-printable characters at the end of the decryptedData when it was enabled.</p>
","38","<javascript><encryption><cryptojs>","1","2","1","2019-07-09 10:38:06","56950710","3","","","","","2019-07-09 09:52:29",""
"56967445","Invalid IV length","<p>Gettint IV length error when trying to login with social network in my application.</p>

<p>Apache 2.4.39
PHP 7.2.18</p>

<pre class=""lang-js prettyprint-override""><code>this.cipherKey = crypto.createHash('sha256')
    .update(this.authorize.secret)
    .digest();

Authorize.prototype.encrypt = function encrypt(text) {
    let iv = crypto.randomBytes(16);
    let cipher = crypto.createCipheriv(this.authorize.algorithm, new Buffer.from(this.cipherKey), iv);
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + ':' + encrypted.toString('hex');
</code></pre>

<blockquote>
  <p>Error: Invalid IV length</p>
</blockquote>
","","38","<javascript><node.js><jwt><cryptojs>","0","","0","2019-07-10 09:33:43","","1","","9974904","","2019-07-10 09:33:43","2019-07-10 09:19:49",""
"56664705","NodeJS Base-64 encoding of the SHA-512 digest","<p>I am using the Starling Bank web hooks to call my API.  They state the following:</p>

<blockquote>
  <p>The signature is placed in the header of the request using
  X-Hook-Signature and consists of Base-64 encoding of the SHA-512
  digest of the secret + JSON payload.</p>
</blockquote>

<p>My code that I ended up with is below. Having tried different ways, I can not seem to get the same Base-64 of the SHA-512 as what is in the header. Am I understanding/using the crypto and bodyParser library correctly?</p>

<pre><code>// middleware.js
const functions = require('firebase-functions');
import * as crypto from 'crypto';

export const auth = (req, res, next) =&gt; {
    let hash = crypto.createHash('sha512');
    hash.update(config.starling.key + req.rawBody));
    req.hasha = hash.digest('base64');

    // req.hasha is different from req.header('X-Hook-Signature')

    next();
}
</code></pre>

<p>My app has the following code </p>

<pre><code>import * as functions from 'firebase-functions';
import * as express from 'express';
import * as cors from 'cors';
import * as middleware from './middleware';
import bodyParser = require('body-parser');

const app = express();
app.use(cors({ origin: true }));
app.use(bodyParser.json());
app.use(middleware.auth);

// Endpoints removed for brevity

export const hooks = functions.https.onRequest(app);
</code></pre>
","","37","<node.js><cryptojs>","0","","0","2019-06-19 09:43:19","","7","","","","","2019-06-19 09:43:19",""
"58025741","Decrypt AES in mysql that was encrypted with CryptoJS","<p>In my database i have a column that stores cryptojs encrypted values in this type of form:</p>

<p>U2FsdGVkX1/BpEUjr5y+hivlNpUep+HZQG4Tw8bmTvQ=</p>

<p>When i decrypt this with cryptojs it's all good.</p>

<pre class=""lang-js prettyprint-override""><code>let decryptedValue = cryptoJS.AES.decrypt(
    encryptedField,
    secretKey
 );
</code></pre>

<p>But decrypting it with mysql returns null.</p>

<p>I've tried converting to the encrypted string into binary then decrypting  it with mysql's aes_decrypt() but it returns null.</p>

<pre class=""lang-sql prettyprint-override""><code>SELECT convert(AES_DECRYPT(binary(encrypted_field),'secret_key') using utf8) as decrypt
</code></pre>

<p>The encrypted values are numbers and i need to decrypt them in order to do some calculations in mysql with them.</p>

<p>I don't know if there is something wrong with the way i'm decrypting it or do cryptojs and mysql have different ways of encrypting and decrypting using AES.</p>

<p>Thank you in advance.</p>
","<p>It looks like your initial string is <strong>Base64 Encoded</strong>. It's possible that <code>cryptoJS.AES</code> or some other process is taking the encrypted bytes and storing them as <strong>Base64</strong> in the database.</p>

<p>Your databases decrypt routine is probably assuming the raw bytes, so you'll need to turn the <strong>Base64</strong> string (check the net for mysql's base64 routines) into the actual bytes and then pass them to the <code>AES_DECRYPT</code> function.</p>
","36","<mysql><aes><cryptojs>","0","0","1","2019-09-20 10:35:58","","0","","","","","2019-09-20 09:37:24",""
"55952582","why is it all the brcypt or crypto hashes comparison are always returning false even for correct password","<p>I have managed to use   cryptojs and bcrypt to hash /encrypt all my passwords but failed
to compare the hashes(hashed password in database vs hashed input password) always returning false
so i did more digging  to find out the contents of the hashes and these are the results.</p>

<pre><code>const crypto = require('crypto')
function setUserPassword(inputPassword){
    const salt = crypto.randomBytes(16).toString('hex')
  let hashedPassword = crypto.pbkdf2Sync(inputPassword, salt, 1000, 16,'sha512').toString('hex')
   return{ //we shall store them in the database later
     salt: salt,
     hashedPassword: hashedPassword
   }
}
database ====&gt;ac0f74b30c94fedbbd591889c4705607  //works perefectly using the above function

challenge comes when validating the user password.. using this function..
   function validateUserPassword(enteredPassword, dbSalt, dbPassword){

// then checks if this generated hash is equal to user's hash in the database or not 
   let hashInput = crypto.pbkdf2Sync(enteredPassword, dbSalt, 1000,16, 'sha512') //the same as above

   //u must compare the hashed password in the db with hashedInput password
   return hashInput === dbPassword //IF it returns true then they match
}
so i checked the  hashInput and discovered that it was a buffer instead of the string... 
hey hashed input password  &lt;Buffer ac 0f 74 b3 0c 94 fe db bd 59 18 89 c4 70 56 07&gt;

//may nodejs version... v6.11.4 and alo tried using v10.15.0 but all in  the vain.
</code></pre>
","<p>In <code>setUserPassword()</code> you're creating a hex-encoded string from the buffer returned by the hash function, but you're forgetting to do the same in <code>validateUserPassword()</code>. This will fix it:</p>

<pre><code>let hashInput = crypto.pbkdf2Sync(enteredPassword, dbSalt, 1000,16, 'sha512').toString('hex')
</code></pre>
","36","<node.js><bcrypt><cryptojs>","0","0","1","2019-05-02 12:49:37","55952866","2","","","","","2019-05-02 12:34:39",""
"56392241","Why do I still get error code 400 from this API request to Coinbase Pro?","<p>I've followed the instructions on the Coinbase Pro developers page for authentication with API Key and no matter what I try I always get error code 400 using CryptoJS and React / React Native.</p>

<p><a href=""https://docs.pro.coinbase.com/#api-key-permissions"" rel=""nofollow noreferrer"">https://docs.pro.coinbase.com/#api-key-permissions</a></p>

<pre><code>import CryptoJS from 'crypto-js';
import axios from 'axios';
import { Buffer } from 'buffer';

const key = '&lt;removed';
const secret = '&lt;removed&gt;';
const passphrase = '&lt;removed&gt;';
const method = 'GET';
const uri = 'https://api.pro.coinbase.com/accounts';
const requestPath = '/accounts';
const timestamp = Math.floor(Date.now() / 1000);
const message = `${timestamp}${method}${requestPath}`;
const secret64 = Buffer.from(secret, 'base64').toString('ascii');
const hmac = CryptoJS.HmacSHA512(message, secret64);
const signed = CryptoJS.enc.Base64.stringify(hmac).toString();

const headers = {
  'User-Agent': 'reactnative',
  'Content-Type': 'application/json',
  'CB-ACCESS-KEY': key,
  'CB-ACCESS-SIGN': signed,
  'CB-ACCESS-TIMESTAMP': timestamp,
  'CB-ACCESS-PASSPHRASE': passphrase,
  'CB-VERSION': '2019-05-22'
};

axios
  .get(uri, {
    method,
    headers
  })
  .then((response) =&gt; {
    console.log(response);
  })
  .catch((error) =&gt; {
    console.log(error);
  });



Other variations I have tried:

// const secret64 = Buffer.from(secret, 'base64').toString('ascii');
// const secret64 = Buffer.from(secret, 'base64').toString();
// const secret64 = Buffer.from(secret, 'base64');
// const signed = CryptoJS.HmacSHA512(message, secret64).toString();
// const signed64 = Buffer.from(signed).toString('base64');

// const hmac = CryptoJS.HmacSHA512(message, secret64).toString(CryptoJS.enc.Hex);
// const hmac = CryptoJS.HmacSHA512(message, secret64).toString(CryptoJS.enc.Hex);
// const signed = CryptoJS.enc.Base64.stringify(hmac);
// const signed = Buffer.from(hmac.toString()).toString('base64');
// const utf = CryptoJS.enc.Utf8.parse(hmac);
// const signed = CryptoJS.enc.Base64.stringify(utf).toString();
// const hash = CryptoJS.HmacSHA512(message, secret);
// const signed = CryptoJS.enc.Base64.stringify(hmac);
</code></pre>

<p>Error: Request failed with status code 400</p>

<p>What am I doing wrong?</p>
","","36","<cryptojs><coinbase-api><gdax-api>","0","","0","2019-05-31 09:22:47","","0","","","","","2019-05-31 09:22:47",""
"58706808","How to encrypt in javascript and decrypt in python?","<p>I am trying to encrypt in javascript using cryptoJS and decrypt in python but some how I am unable to get this working.Here is my code :</p>

<pre class=""lang-js prettyprint-override""><code>//encrypting in javascript using cryptojs
var message = ""praveen"";
var key = 'This is a key123';
var iv = 'This is an IV456';

var encrypted = CryptoJS.AES.encrypt(message, key, {
  iv: CryptoJS.enc.Utf8.parse(iv),
  mode: CryptoJS.mode.CFB,
  padding: CryptoJS.pad.ZeroPadding
});

console.log(encrypted.ciphertext.toString()); // sending this over wire
</code></pre>



<pre class=""lang-python prettyprint-override""><code>#decrypting in python

BLOCK_SIZE = 16
SEGMENT_SIZE = 128

def aes_decrypt(plaintext):
    key = 'This is a key123'
    iv = 'This is an IV456' 
    aes_mode = AES.MODE_CFB
    obj = AES.new(key, aes_mode, iv)
    ciphertext = obj.decrypt(plaintext)
    ciphertext = _unpad_string(ciphertext)
    return ciphertext
</code></pre>


","","36","<javascript><python><cryptojs><pycrypto>","0","","0","2019-11-05 08:06:13","","3","","3082296","","2019-11-05 08:06:13","2019-11-05 07:55:13",""
"58222971","openssh return ""bad key type"" with a crypto generated key pair","<p>I need to generate a rsa key pair on <code>node js</code> code in order to use it with an <code>openssh</code> client on an <code>docker</code> container.</p>

<p>I'm using the <a href=""https://nodejs.org/api/crypto.html#crypto_crypto_generatekeypair_type_options_callback"" rel=""nofollow noreferrer"">generateKeyPair</a> function of <code>crypto</code> to generate keys and <code>parse[Private]Key</code> of <a href=""https://github.com/joyent/node-sshpk#readme"" rel=""nofollow noreferrer"">sshpk</a> to translate keys from <code>pem</code> to <code>openssh</code> format.</p>

<h3>my function is :</h3>

<pre class=""lang-js prettyprint-override""><code>import { generateKeyPair } from 'crypto';
import sshpk from 'sshpk';

const createSShKeys = () =&gt; {
  return new Promise((resolve, reject) =&gt; {
    generateKeyPair('rsa', {
      modulusLength: 4096,
      publicKeyEncoding: {
        type: 'pkcs1',
        format: 'pem',
      },
      privateKeyEncoding: {
        type: 'pkcs1',
        format: 'pem',
      },
    }, (error, publicKey, privateKey) =&gt; {
      if (error) {
        reject(error);
      } else {
        const publicKeySShEncoded = sshpk
          .parseKey(publicKey, 'pem')
          .toString('ssh');

        const privateKeySShEncoded = sshpk
          .parsePrivateKey(privateKey, 'pem')
          .toBuffer('ssh', {}) // toString('ssh') is documented, but I not find it in code.
          .toString();

        resolve({
          publicKey:  publicKeySShEncoded,
          privateKey: privateKeySShEncoded,
        });
      } 
    });
  });
};
</code></pre>

<p>I create a <code>docker secret</code> with the private key, and use it inside the container, but then I get :</p>

<pre><code>Host key verification failed.
</code></pre>

<h3>hint #1 : gitlab.com is not a known host</h3>

<p>After search, I have found <a href=""https://stackoverflow.com/a/29380672/12094975"">this answer</a>, and I have added the host fingerprint inside the <code>.ssh/known_hosts</code> file :</p>

<pre><code>ssh-keyscan -H gitlab.com &gt;&gt; ~/.ssh/known_hosts
</code></pre>

<p>But nothing has changed</p>

<h3>hint #2 : the keys are wrong</h3>

<p>To test the key pair, I have logged this :</p>

<pre class=""lang-js prettyprint-override""><code>const {
  publicKey,
  privateKey,
} = await createSShKeys();

console.log('#PUBLIC KEY');
console.log(publicKey);

console.log('#PRIVATE KEY');
console.log(privateKey);

</code></pre>

<p>And I have stored the private key in a file. I try to verify it with :</p>

<pre><code>$ ssh-keygen -y -t private_key
bad key type
</code></pre>

<h3>the generated private key is as follow</h3>

<p><a href=""https://pastebin.com/2JC7kz9r"" rel=""nofollow noreferrer"">https://pastebin.com/2JC7kz9r</a></p>

<p>Has anyone already generated keys with <code>crypto</code> and <code>sshpk</code> with success ?
Or encoutered similar problem ?</p>

<p>Thank you for your help ! :)</p>
","<p>The problem was really the key of the host, not the generated keys.</p>

<p>But the ""clean"" method doesn't work :</p>

<pre class=""lang-sh prettyprint-override""><code>ssh-keyscan -H gitlab.com &gt;&gt; ~/.ssh/known_hosts
</code></pre>

<p>The only working method is append these lines on <code>/etc/ssh/ssh_config</code>:</p>

<pre class=""lang-sh prettyprint-override""><code>Host *
   StrictHostKeyChecking no
   UserKnownHostsFile=/dev/null
</code></pre>

<p>I don't know why. (if anyone have idea ?)</p>

<p>But finaly, the keys are okay, it's probably a mistake on copy/paste (Lol)</p>

<p>Thank you all !</p>
","35","<node.js><docker><openssh><cryptojs>","1","1","1","2019-10-07 18:03:54","58274901","2","1","12094975","","2019-10-04 08:39:17","2019-10-03 16:04:33",""
"58479079","Invalid Array Length in using Cryptojs","<p>I am trying to transpose a c# code to a javascript using cryptojs and in the c# code it uses TripleDESCryptoServiceProvider. I can get everything exactly the values of C# in my javascript code except for the encrypting part. I get an error of ""Invalid array length"" This is the whole error message:</p>

<pre><code>""RangeError: Invalid array length
    at WordArray.init.clamp (http://localhost:8100/auth-login-login-module.js:1392:27)
    at WordArray.init.concat (http://localhost:8100/auth-login-login-module.js:1357:19)
    at Object.pad (http://localhost:8100/auth-login-login-module.js:652:19)
    at Object._doFinalize (http://localhost:8100/auth-login-login-module.js:729:26)
    at Object.finalize (http://localhost:8100/auth-login-login-module.js:400:44)
    at Object.encrypt (http://localhost:8100/auth-login-login-module.js:912:41)
    at Object.encrypt (http://localhost:8100/auth-login-login-module.js:438:59)
    at AuthService.encryptText (http://localhost:8100/auth-login-login-module.js:6745:83)
    at LoginPage.ngOnInit (http://localhost:8100/auth-login-login-module.js:6939:26)
    at checkAndUpdateDirectiveInline (http://localhost:8100/vendor.js:65455:19)""
</code></pre>

<p>Please see my code on c# and javascript.</p>

<p>C#</p>

<pre><code>public static string EncryptTxt(string key, string msg, CipherMode mode, Int16 KeyOffSet)
{
    SHA512CryptoServiceProvider sha = new SHA512CryptoServiceProvider();
    byte[] newKey = new byte[23];

    using (var tdes = new TripleDESCryptoServiceProvider())
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(key));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

        byte[] keybyte = sha.ComputeHash(Encoding.UTF8.GetBytes(key));
        byte[] newKeyx = new byte[24];

        Array.Copy(keybyte, KeyOffSet, newKeyx, 0, newKeyx.Length);

        TDESAlgorithm.Key = newKeyx;
        TDESAlgorithm.Mode = mode;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        byte[] DataToEncrypt = UTF8.GetBytes(msg);
        try
        {
            ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
            Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
        }
    finally
    {
        TDESAlgorithm.Clear();
        HashProvider.Clear();
    }
    return Convert.ToBase64String(Results);
}
</code></pre>

<p>javascript</p>

<pre><code>encryptText = () =&gt; {
    debugger;
    const msg = 'xxx:juan:201910181809:12345678';
    let key = crypto.enc.Utf8.parse('xxx');
    key = crypto.MD5(key);
    key.words.push(key.words[0], key.words[1]);
    const iv = crypto.enc.Utf8.parse('xxx');

    // MD5CryptoServiceProvider
    const hashProvider = crypto.MD5(iv);
    const TDESKey = this.wordArrayToByteArray(hashProvider, 8);

    const keybyte = this.wordArrayToByteArray(crypto.SHA512(iv), 16);
    const newKeyx = new Uint8Array(24);

    const newkeybyte = keybyte.slice(10, 34);
    Object.assign(newKeyx, newkeybyte);

    const TDESAlgorithmKey = newkeybyte;

    const DataToEncrypt = this.wordArrayToByteArray(crypto.enc.Utf8.parse(msg), 40);
    const dteLength = DataToEncrypt.length;

    const encrypted = crypto.TripleDES.encrypt(DataToEncrypt, key, {
      keySize: dteLength,
      mode: crypto.mode.ECB,
      padding: crypto.pad.Pkcs7,
      algo: TDESAlgorithmKey
    });
    const result = this.wordArrayToByteArray(encrypted.ciphertext, dteLength);
    console.log(encrypted);
    return encrypted;
}

wordToByteArray(word: any, length: any) {
    const ba = [], xFF = 0xFF;
    if (length &gt; 0) {
      // tslint:disable-next-line:no-bitwise
      ba.push(word &gt;&gt;&gt; 24);
    }
    if (length &gt; 1) {
      // tslint:disable-next-line:no-bitwise
      ba.push((word &gt;&gt;&gt; 16) &amp; xFF);
    }
    if (length &gt; 2) {
      // tslint:disable-next-line:no-bitwise
      ba.push((word &gt;&gt;&gt; 8) &amp; xFF);
    }
    if (length &gt; 3) {
      // tslint:disable-next-line:no-bitwise
      ba.push(word &amp; xFF);
    }
    return ba;
}
</code></pre>

<p>Can you please show me how to do this right. I really appreciate it!</p>
","","35","<javascript><c#><cryptojs>","0","","0","2019-10-21 07:06:41","","0","","3825246","","2019-10-21 07:06:41","2019-10-21 02:26:12",""
"55973720","Javascript generate AES using cap and small cap letters","<p>I'm setting up the code to generate the AES hash using with 3 random numbers to generate the hash, but I don't want to generate the hash that come with the keys such as like <code>?</code>, <code>/</code>, <code>+</code>, <code>=</code>...etc. </p>

<p>Here is the output for the hash that I use to generate it:</p>

<pre><code>U2FsdGVkX1+nF+bhzvA/sFnQKgOKwrRNJbqr+XzJ/2k=
</code></pre>

<p>I want to generate the AES hash that start with <code>FM</code> cap letters with the long random cap and small cap letters to make it to show like this:</p>

<pre><code>FMfcgxwCgCRTpGWxctmfLpRBZxVcrkdM
</code></pre>

<p>Here is what I use to encrypt and decrypt the hash:</p>

<pre><code>//encrypt the hash
var hash = '234';
var encryptedAES = CryptoJS.AES.encrypt(hash, ""My Secret Passphrase"");


//decrypt the hash
var decryptbytes = CryptoJS.AES.decrypt(hash.toString(), ""My Secret Passphrase"");
var email_number = decryptbytes.toString(CryptoJS.enc.Utf8);
</code></pre>

<p>What I'm expecting to do is to encrypt the hash using with the long random cap and small cap letters like <code>FMfcgxwCgCRTpGWxctmfLpRBZxVcrkdM</code> without the keys <code>?</code>, <code>-</code>, <code>=</code> or whatever it is and I want to decrypt the hash to go back to numbers that I enter when I encrypted it.</p>

<p>Can you please show me an example how I could use <code>CryptoJS.AES.encrypt</code> to encrypt the numbers to turn into 32 letters that start with <code>FM</code> with the cap and small cap letters?</p>

<p>Thank you</p>
","","35","<javascript><jquery><cryptojs>","0","","0","2019-05-03 16:27:52","","4","","1113766","","2019-05-03 16:27:52","2019-05-03 16:18:40","2019-05-12 22:34:42"
"58291202","Signature management in postman with CryptoJS","<p>I am trying to integrate some activities that I run with bash in Postman tests for API Rest calls.</p>

<p>I need to turn these 2 calls made </p>

<pre><code>$(echo -n $3 | openssl dgst -binary -sha256 | openssl base64)

==&gt; 91154Zn0Qu8FdLBMZGMbqeubI4TtUZvesHxaaMcWa+Y=

$(printf %s ""$sign"" | openssl dgst -sha256 -binary -sign ""privateKey.key"" | openssl base64 -A)
</code></pre>

<p>To do this I'm trying the CryptoJS library but I'm not getting the same result and I don't know where I'm wrong.</p>

<pre><code>function textToBin(text) {
  return (
    Array
      .from(text)
      .reduce((acc, char) =&gt; acc.concat(char.charCodeAt().toString(2)), [])
      .map(bin =&gt; '0'.repeat(8 - bin.length) + bin )
      .join(' ')
  );
}  

var bodySHA= CryptoJS.SHA256(textToBin('body body')).toString();
var bodyParse=CryptoJS.enc.Base64.parse(bodySHA);
var bodyBase64=CryptoJS.enc.Base64.stringify(bodyParse);
console.log(bodyBase64);

===&gt; e6382c53fc78cf2db0e10f103ed4859446bf917b1e1730633974a8df2092cfeb
</code></pre>

<p>With CryptoJS I haven't found a command for the binary, so I'm trying to transform the string into binary with a function that I found.</p>

<p>Can you help me?</p>

<p>Thanks</p>
","<p>For the part of the Digest calculation I solved this way:</p>

<pre><code>function calculateDigest() {
    const requestData = request.data.toString();

    const sha256digest = CryptoJS.SHA256(requestData);
    const base64sha256 = CryptoJS.enc.Base64.stringify(sha256digest);
    const calculatedDigest = 'SHA-256=' + base64sha256;

    pm.environment.set(""Digest"", calculatedDigest);
    return calculatedDigest;
}
</code></pre>

<p>unfortunately for the signature it seems that the sequence of the commands I expose fails to reproduce the correct sequence made with openssl</p>

<pre><code>$(printf %s ""$sign"" | openssl dgst -sha256 -binary -sign ""privateKey.key"" | openssl base64 -A)
</code></pre>

<pre><code>function encryptSignature(normalizedSignatureString) {

    const messageDigest = forge.md.sha256.create();
    const privateKey = forge.pki.privateKeyFromPem(pm.globals.get(""private_key""));

    console.log(""privateKey"" +privateKey);

    messageDigest.update(normalizedSignatureString, ""utf8"");
    console.log(""messageDigest "" +messageDigest);
    const signature = privateKey.sign(messageDigest);
    let buff = new Buffer(signature);
    const signatureBase = buff.toString('base64');

    console.log(""signatureHex--&gt; ""+signatureBase);

  return signatureBase;
}
</code></pre>

<p>Can anyone help me figure out where I'm wrong?</p>
","34","<postman><cryptojs><postman-pre-request-script>","0","0","1","2019-10-15 14:42:43","","0","","2742614","","2019-10-08 23:11:43","2019-10-08 17:22:46",""
"58109626","How to match Key & IV generated by C# and JS CryptoJS","<p>I need help to find a way how to match IV and KEY from C# and JS,</p>

<p>with a simple C# code:</p>

<pre><code>Rijndael rijndael = Rijndael.Create();
byte[] saltArray = Encoding.ASCII.GetBytes(""20190925"");
Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(""password"", saltArray, 1000);
rijndael.Key = pdb.GetBytes(32);
rijndael.IV = pdb.GetBytes(16);
Console.WriteLine(BitConverter.ToString(rijndael.Key).Replace(""-"","""").ToLower());
//Output rijndael.Key = c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f
Console.WriteLine(BitConverter.ToString(rijndael.IV).Replace(""-"","""").ToLower());
//Output rijndael.IV = 063ead20a9d5f35ab83e1156ebe7c099
</code></pre>

<p>with a CryptoJS i can get a same KEY as C# but with the IV i don't get it why the value is not match</p>

<p>CryptoJS code:</p>

<pre><code>let key = CryptoJS.PBKDF2('password', '20190925', {keySize:256/32, iterations:1000})
console.log('key', key.toString(CryptoJS.enc.Hex))
//Output key =  'key', 'c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f'
let iv = CryptoJS.PBKDF2('password', '20190925', {keySize:128/32, iterations:1000})
console.log('iv', iv.toString(CryptoJS.enc.Hex))
//Output iv =  'iv', 'c1b34ea814586db4a22dad37e11c7256'
</code></pre>

<p>I just think if <code>rijndael.IV = pdb.GetBytes(16);</code> will just get half of <code>rijndael.Key = pdb.GetBytes(32);</code> hex, but the value totally different</p>

<p>is there a way to match IV of C# using CryptoJS?</p>
","<p>PBKDF2 must be executed for a length equal to the sum of key length and IV length. The result is divided into two parts. The first part corresponds to the key, the second part to the IV:</p>

<pre><code>let keyLen = 256/32
let ivLen = 128/32
let keyiv = CryptoJS.PBKDF2('password', '20190925', {keySize:keyLen + ivLen, iterations:1000})
let key = CryptoJS.lib.WordArray.create(keyiv.words.slice(0, keyLen));
let iv = CryptoJS.lib.WordArray.create(keyiv.words.slice(keyLen, keyLen + ivLen));
console.log('keyiv:', keyiv.toString())
console.log('key  :', key.toString())
console.log('iv   :', iv.toString())
</code></pre>

<p>This results in:</p>

<pre><code>keyiv: c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f063ead20a9d5f35ab83e1156ebe7c099
key  : c1b34ea814586db4a22dad37e11c7256322ab0eee3a14ed1898f93d7a264242f
iv   : 063ead20a9d5f35ab83e1156ebe7c099
</code></pre>

<p>which matches the result of the C# code. </p>
","34","<javascript><c#><aes><cryptojs><rijndael>","1","1","1","2019-09-26 08:49:46","58112975","0","","8943429","","2019-09-26 05:56:18","2019-09-26 04:35:00",""
"57129362","CryptoJS in Adobe Extendscript (ES3): Decrypting String Does Not Work","<p>I'm working on a Photoshop CES extension and attempting to encrypt data using CryptoJS. This all works, except when I convert the encrypted data to a string and then try to decrypt it. </p>

<p><strong>Here's a link to a JS Fiddle that works:</strong></p>

<p><a href=""https://jsfiddle.net/davevsdave/atwpbmr5/3/"" rel=""nofollow noreferrer"">https://jsfiddle.net/davevsdave/atwpbmr5/3/</a></p>

<p>This same code in ExtendScript Toolkit or running in Photoshop does not return the correct finalResult var. Here's the code I'm running in extendscript, identical to what is in the above JSFiddle (except $.println instead of console.log and an extra line showing that decrypting the obj works):</p>

<pre><code>//JSON from Panel
jsonStr = '{""date"":""1563662582633"",""email"":""email@email.com"",""password"":""1234324"",""uniqueID1"":""12345"",""uniqueID2"":""asfdsa-asdfsa-adsfas-sadfsdf-asfsaf\n""}';

//JSON from Panel
jsonStr = '{""date"":""1563662582633"",""email"":""email@email.com"",""password"":""1234324"",""uniqueID1"":""12345"",""uniqueID2"":""asfdsa-asdfsa-adsfas-sadfsdf-asfsaf\n""}';

//Encrypt Data
var encrypted = CryptoJS.AES.encrypt(jsonStr, 'secret_passcode');

//Convert OBJ to String so I can save it
var encryptedString  = encrypted.toString();
$.writeln('encryptedString is ' + encryptedString);

//Decrypt string - DOES NOT WORK IN EXTENDSCRIPT
var decryptedValue1= CryptoJS.AES.decrypt(encryptedString, 'secret_passcode');
$.writeln('decryptedValue1 is ' +  decryptedValue1);

//Decrypt OBJ - WORKS IN EXTENDSCRIPT
var decryptedValue2= CryptoJS.AES.decrypt(encrypted, 'secret_passcode');
$.writeln('decryptedValue2 is ' +  decryptedValue2);

//Final Decrypt output from string
$.writeln('finalOutput from  decryptedValue1 is ' + decryptedValue1.toString(CryptoJS.enc.Utf8));

//Final Decrypt output from obj
$.writeln('finalOutput from  decryptedValue2 is ' + decryptedValue2.toString(CryptoJS.enc.Utf8));
</code></pre>

<p>I'm guessing the issue is Extendscript using ES3. Any suggestions on how I can convert the encrypted data to a string (so I can store it as JSON) and then still be able to decrypt it? Obviously being able to store data I can't decrypt does me no good.</p>

<p>Thanks!</p>
","","34","<json><cryptojs><extendscript>","0","","0","2019-07-22 16:48:31","","3","","3809939","","2019-07-22 16:48:31","2019-07-20 23:36:03",""
"54825548","CryptoJS Unable to Decrypt Data","<p>I have the following encryption method which uses CryptoJS to encrypt a password.</p>

<pre><code>function encrypt() {
            var val = document.getElementById('password').value;
            var key = CryptoJS.enc.Base64.parse('u/Gu5posvwDsXUnV5Zaq4g==');
            var ivec = CryptoJS.enc.Base64.parse('5D9r9ZVzEYYgha93/aUK2w==');
            var dataString = CryptoJS.enc.Utf8.parse(val);
            var encrypted = CryptoJS.AES.encrypt(dataString.toString(), key,
                { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: ivec });

            document.dform.plaintext.value = encrypted.toString();
            form.submit();
        }
</code></pre>

<p>The following decrypt method doesn't give me the desired result:</p>

<pre><code>function decrypt() {
            var val = document.getElementById('password').value;
            var key = CryptoJS.enc.Base64.parse('u/Gu5posvwDsXUnV5Zaq4g==');
            var ivec = CryptoJS.enc.Base64.parse('5D9r9ZVzEYYgha93/aUK2w==');
            //var dataString = CryptoJS.enc.Utf8.parse(val);
            var decrypted = CryptoJS.AES.decrypt(val, key,
                { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: ivec });

            document.dform.plaintext.value = decrypted.toString();
            //form.submit();
        }
</code></pre>

<p>Sample Ciphertext: y5uoJYFk1+QS2I4Wx7QnsBq8dGe30ucBNaXsTnNhTOE=</p>

<p>Plaintext: helloworld</p>
","","34","<javascript><encryption><cryptojs>","0","","0","2019-02-22 10:54:36","","4","","","","","2019-02-22 10:54:36",""
"55591559","How to make heavy json light?","<p>i want responsd a json file to web client from server. it is very heavy. and, user can post a json file. it is heavy too. (about, 50~150mb)</p>

<p>so, i have to find the way it make light.</p>

<p>then, i think that use encoding function.</p>

<p>i try use variety encode function, but it have to possible decode. but encode result is heavy too. it was differ to hash function.</p>

<pre><code>obj_encoder: json =&gt; {
        const cipher = crypto.createCipher('aes-256-ctr', 'key');
        let result = cipher.update(json, 'utf8', 'hex');
        result += cipher.final('hex');
        return result;
    }
</code></pre>

<p>therefore, i want know the encoding way able to decoding &amp; encoded value's length is fixed.</p>

<p>or, if it is other good way, let me know please.</p>

<p>This problem has lasted more than a week. 
But I could not find a suitable way.</p>

<p>help me thank you.</p>
","","34","<node.js><json><encode><cryptojs>","0","","0","2019-04-09 11:14:41","","2","","","","","2019-04-09 11:14:41",""
"56097183","node_modules/_crypto-js@3.1.9-1@crypto-js/SHA256.web.js doesn't exist","<p>I installed crypto.js, but when I build my project copied from others to learn, it gave me an error:</p>

<blockquote>
  <p>""node_modules/_crypto-js@3.1.9-1@crypto-js/SHA256.web.js doesn't exist""</p>
</blockquote>

<p>I've try the commands including:</p>

<ol>
<li>""npm install crypto-js"" ,</li>
<li>""cnpm install crypto-js"" ,</li>
<li>""sudo npm install crypto-js"" </li>
<li>""sudo cnpm install crypto-js""</li>
</ol>

<p>but nothing is fixed.</p>
","","33","<javascript><node.js><cryptojs>","0","","0","2019-05-12 07:54:38","","2","","10632369","","2019-05-12 07:54:38","2019-05-12 07:48:09",""
"57366174","Crypto JS not encrypting properly in production mode","<p>I've the following code to send a message:</p>

<pre><code>function sendMessage(data) {
        data.version = clientVersion;
        var message = { data: CryptoJS.AES.encrypt(JSON.stringify(data), system.Authentication.SendAuth, { mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7, iv: system.Authentication.Sendiv }).toString() };
        return JSON.stringify(message);
    }
</code></pre>

<p>This works just fine on dev mode. Expo app sends the encrypted message and gets decrypted properly. However, in production mode, the encrypted code gets sent and received no problem, but when decrypted by the server we get a negative sigBytes number. So the decryption failed.</p>

<p>This happened when updation from SDK 27 to SDK 31 of expo.</p>
","","33","<react-native><encryption><expo><cryptojs>","1","","0","2019-08-17 11:19:41","","1","","","","","2019-08-05 21:14:36",""
"56036769","How can i sign the particular text for .cer certificate in node.js? (crypto)","<p>I want to sign a particular string with somefile.cer certificate with RSA-SHA256 cipher.</p>

<p>I have a code.</p>

<pre><code>var crypto = require('crypto');
        var fs = require('fs');

        var pem = fs.readFileSync('./mycercodeproject.cer');
        fs.writeFileSync('./mycer.cer',pem)
        var key = pem.toString('ascii');

        var sign = crypto.createSign('RSA-SHA256');
        var dataString= this.c4c_info['c4c-tenant']+':'+this.c4c_info['c4c-nonce']
        +':'+this.c4c_info['c4c-timestamp']+':'+this.c4c_info['c4c-filename'];
        let buff = new Buffer(dataString);  
        let base64data = buff.toString('base64');
        sign.update(base64data);  // data from your file would go here
        console.log(key);
        var sig = sign.sign(key, 'hex');
</code></pre>

<p>this is giving error</p>

<p>internal/crypto/sig.js:80
  var ret = this._handle.sign(key, passphrase, rsaPadding, pssSaltLength);
                         ^</p>

<p>Error: error:0906D06C:PEM routines:PEM_read_bio:no start line
    at Sign.sign (internal/crypto/sig.js:80:26)
    at EncodeCertificate.sign </p>

<p>Can you tell me what i am doing wrong?</p>
","","33","<node.js><cryptojs>","0","","0","2019-05-08 08:42:24","","0","","","","","2019-05-08 08:42:24",""
"55892208","Encrypted File Transfer Could Not Be Recreated on Android","<p>I am encrypting a file in Node.js client side and saving it on server as file, when I try to decrypt file it is not in the right format.</p>

<pre><code>Encryptor.encryptFile = function (inputPath, outputPath, key, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    options = Encryptor.combineOptions(options);

    var keyBuf = new Buffer(key);
    console.log(key)
    var inputStream = fs.createReadStream(inputPath);
    var outputStream = fs.createWriteStream(outputPath);
    var cipher = crypto.createCipher(options.algorithm, keyBuf);

    inputStream.on('data', function (data) {
        console.log(data.length)
        var buf = new Buffer(cipher.update(data));
        outputStream.write(buf);
    });

    inputStream.on('end', function () {
        try {
            var buf = new Buffer(cipher.final('binary'), 'binary');
            outputStream.write(buf);
            outputStream.end();
            outputStream.on('close', function () {
                return callback();
            });
        } catch (e) {
            fs.unlink(outputPath);
            return callback(e);
        }
    });
};
</code></pre>

<p>Above is the encryption code, and on Android side I use the following code.
FIle Downloading:</p>

<pre><code>Ion.with(this).load(documentModel.filePath)
                .progress { downloaded, total -&gt; println(""$downloaded / $total"") }
                .write(file)
                .setCallback { e, result -&gt;
                    if (result != null) {
                        // val keys = MedpayDatabaseHelper.getInstance(this@ViewMedicalRecordActivity)?.keyDao()?.getKeys()
                        val handler = EncryptionHandler()
                        val decrepted = handler.decryptFile(handler.getSymmetricKey(), result)
                        val outfile = File(dir, ""output.pdf"")
                        pdfView.fromBytes(decrepted).load()
                    } else {
                        Toast.makeText(this@ViewMedicalRecordActivity, ""Failed to load file"", Toast.LENGTH_LONG).show()
                    }
                }
</code></pre>

<p>Following is the decryption code.</p>

<pre><code>fun decryptFile(symmetricKey: String, file: File): ByteArray {
        encryptionAlgorithm = ""AES""
        encryptionMode = ""/ECB""
        paddingMode = ""/NoPadding""
        return decrypt(symmetricKey, file)
    }
private fun decrypt(decryptionKey: String, file: File): ByteArray {
        val inputStream = BufferedReader(InputStreamReader(FileInputStream(file), Charsets.UTF_16BE))
        var x: String? = """"
        var builder = StringBuilder()
        while (x != null) {
            x = inputStream.readLine()
            if (x != null)
                builder.append(x).append('\n')
        }
        val text = builder.toString()
        val read = text.toByteArray().decrypt(decryptionKey)
        val path = Environment.getExternalStorageDirectory().absolutePath + ""/folder""
        val dir = File(path)
        if (!dir.exists())
            dir.mkdirs()
        val outfile = File(dir, ""output.pdf"")
        val dos = OutputStreamWriter(FileOutputStream(outfile))
        dos.write(read.toString(Charsets.UTF_16LE))
        dos.flush()
        dos.close()
        return read
    }
//extension function for decrypting the byte array
private fun ByteArray.decrypt(decryptionKey: String): ByteArray {
        val secretKeySpec = SecretKeySpec(decryptionKey.toByteArray(), encryptionAlgorithm)
        val cipher = Cipher.getInstance(encryptionAlgorithm + encryptionMode + paddingMode)
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec)
        return cipher.doFinal(this)
    }
</code></pre>

<p>As I am new in cryptography I am not really sure where i am going wrong but i think it has something to do with file formats and encoding.
The files get decrypted without any errors but still the following exception is thrown when i try to open file in code or from the file explorer.</p>

<pre><code>E/PDFView: load pdf error
    java.io.IOException: cannot create document: File not in PDF format or corrupted.
        at com.shockwave.pdfium.PdfiumCore.nativeOpenMemDocument(Native Method)
</code></pre>
","","33","<android><node.js><aes><cryptojs>","1","","0","2019-04-28 16:21:02","","1","","","","","2019-04-28 16:21:02",""
"55001647","Convert HEX to 4 digit integer","<p>I am trying to convert a HEX string to 4 digit integer. I can change by the following command but I do not want to generate random integer value every time if same HEX string is passing. The integer number must be same. This is not happening in my case:</p>

<pre><code>const reqq = crypto.createHash('md5').update(admin.companyName).digest('hex');
let valueNum = parseInt(reqq, 16);
let resultValue =  Math.floor(Math.random(valueNum) * 9000);
admin.companyID = resultValue;
console.log(resultValue);
</code></pre>

<p>How can I make this work ?</p>
","","32","<javascript><node.js><cryptojs>","0","","0","2019-03-05 11:20:55","","2","","","","","2019-03-05 11:20:55",""
"58499157","Why do I have different result in C# TripleDESCryptoServiceProvider and Cryptojs in javascript","<p>It's been 2 days now and I still can't resolve this issue. Can you PLEASE help me with this? I have both the message and the key the same in both c# and javascript</p>

<blockquote>
  <p>c# message = QXV0b3N3ZWVwMkdvMTpKdWFuOjIwMTkxMDIyMTE1MToxMjM0NTY3OA== </p>
  
  <p>js message = QXV0b3N3ZWVwMkdvMTpKdWFuOjIwMTkxMDIyMTE1MToxMjM0NTY3OA==</p>
  
  <p>c# key = YUbK78VWzJslL7xW36VnbQcQUmssFQzB   </p>
  
  <p>js key = YUbK78VWzJslL7xW36VnbQcQUmssFQzB</p>
  
  <p>c# iv = WJ+7BWTXe2Y=   </p>
  
  <p>js iv = WJ+7BWTXe2Y=</p>
</blockquote>

<p>But the results are:</p>

<blockquote>
  <p>c# = Tv8vp+eFWSuhBUCadSYg6XdKz5m11UDJjpfOaPQwQDxpHwSOQa8OSwIQXpKcUhUH</p>
  
  <p>js = 
  U2FsdGVkX19pqfWg0oBW3WyPU7zl7IqKmLX86x346oEbMGCv1y0JJSHTmwI/945TFlBIq8EhbtbQK3XZIpjyc0HhFZi6ijELodx0e64+Ua0=</p>
</blockquote>

<p>This is the implementation in c#</p>

<pre><code>public static string EncryptTxt(string key, string msg, CipherMode mode, Int16 KeyOffSet)
{
    SHA512CryptoServiceProvider sha = new SHA512CryptoServiceProvider();
    byte[] newKey = new byte[23];

    using (var tdes = new TripleDESCryptoServiceProvider())
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(key));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

        byte[] keybyte = sha.ComputeHash(Encoding.UTF8.GetBytes(key));
        byte[] newKeyx = new byte[24];

        Array.Copy(keybyte, KeyOffSet, newKeyx, 0, newKeyx.Length);

        byte[] xx = new byte[] {88, 159, 187, 5, 100, 215, 123, 102};

        TDESAlgorithm.Key = newKeyx;
        TDESAlgorithm.Mode = mode;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        TDESAlgorithm.IV = xx;
        byte[] DataToEncrypt = UTF8.GetBytes(msg);
        try
        {
            ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
            Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
            var y = Convert.ToBase64String(DataToEncrypt);
            var z = Convert.ToBase64String(newKeyx);
            var a = Convert.ToBase64String(xx);
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }

        var x = Convert.ToBase64String(Results);
        return Convert.ToBase64String(Results);
    }
}
</code></pre>

<p>This is my implementation in javascript</p>

<pre><code>encryptText = () =&gt; {
    const msg = 'Autosweep2Go1:Juan:201910221332:12345678';
    const iv = crypto.enc.Utf8.parse('fAutosweep2Go1');

    const keybyte = this.wordArrayToByteArray(crypto.SHA512(iv), 16);
    const newKeyx = new Uint8Array(24);

    // creating the iv if needed
    const newKeyx1 = new Uint8Array(8);
    newKeyx1[0] = 88;
    newKeyx1[1] = 159;
    newKeyx1[2] = 187;
    newKeyx1[3] = 5;
    newKeyx1[4] = 100;
    newKeyx1[5] = 215;
    newKeyx1[6] = 123;
    newKeyx1[7] = 102;


    const newkeybyte = keybyte.slice(10, 34);
    let m: any = this._arrayBufferToBase64(newkeybyte); // the key
    m = crypto.MD5(m);
    m.words.push(key.words[0], key.words[1]);

    const DataToEncrypt = this.wordArrayToByteArray(crypto.enc.Utf8.parse(msg), 40);
    const l = this._arrayBufferToBase64(DataToEncrypt); // the message 
    const o = this._arrayBufferToBase64(newKeyx1); // the iv

    const options = {
      mode: crypto.mode.ECB,
      padding: crypto.pad.Pkcs7,
    };
    const dteLength = DataToEncrypt.length;
    const encrypted = crypto.TripleDES.encrypt(
    l,
    m,
    options);

    // view results
    const u = encrypted.toString();
    const x = crypto.enc.Utf8.parse(encrypted.toString());
    const b = crypto.enc.Utf8.stringify(x);
    const a = this.wordToByteArray(encrypted.toString(), 48);
    const result = this.wordArrayToByteArray(encrypted.ciphertext, dteLength);

    console.log(crypto.enc.Base64.stringify(result));
    return encrypted;
  }
</code></pre>

<p>I see the result on the variable ""u"" in the browser console but, why do I have different results?
  I really appreciate your help!</p>
","","32","<javascript><c#><cryptojs>","0","","0","2019-10-23 01:17:13","","0","1","3825246","","2019-10-23 01:17:13","2019-10-22 07:31:38",""
"57744295","CryptoJS -- `toString` method crash","<p>I use CryptoJS to do some AES encryption. And the code is</p>

<pre><code>const cipher = CryptoJS.AES.encrypt(plaintext, key)
</code></pre>

<p>If I use <code>cipher.toString(CryptoJS.enc.Base64)</code>, then the web crushes, and says ""TypeError: wordArray.clamp is not a function"". It seems that only <code>toString()</code> without any parameters can work for me, so I want to know the default encoder for <code>toString()</code> method for decrypting in backend.</p>
","<p>You appear to be confusing an encrypted data object and a decrypted data object. The <code>toString</code> method on each of these work differently and have different argument requirements.</p>

<pre><code>var CryptoJS = require(""crypto-js"");

// Encrypt
var ciphertext = CryptoJS.AES.encrypt('my message', 'secret key 123');

// Decrypt
var bytes  = CryptoJS.AES.decrypt(ciphertext.toString(), 'secret key 123');
var plaintext = bytes.toString(CryptoJS.enc.Utf8);

console.log(plaintext);
</code></pre>

<p>In the above example code, <code>ciphertext</code> is set to an object containing the encrypted data. The <code>toString</code> method on that object does not accept <code>CryptoJS.enc</code> objects as an argument. The encrypted data in the object only takes one form so there's no reason to need to specify an encoding.</p>

<p>Also in the above example code, <code>bytes</code> is set to an object containing the decrypted data. The <code>toString</code> method on that object requires an <code>CryptoJS.enc</code> object as an argument in order to know how to interpret what is otherwise just binary data.</p>
","32","<javascript><cryptojs>","1","0","1","2019-09-01 08:31:09","","0","","","","","2019-09-01 08:13:47",""
"58263305","Encrypt text in Node.js and Decrypt from iOS app","<p>I'm using the solution here current to encrypt text from Node.js and decrypt from an iOS app.
<a href=""https://stackoverflow.com/a/27893935/2977578"">https://stackoverflow.com/a/27893935/2977578</a></p>

<p>The encryption from Node.js works but CryptoJS is very slow. I'm trying to port this code to use the built-in <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">crypto module</a> in Node.js for speed but I'm not an expert in these functions. Is it possible to get this code to work just using the built-in crypto module? </p>

<pre><code>var password = ""..."";
var salt = ""..."";
var iv64 = ""..."";
var hash = CryptoJS.SHA256(salt);
var key = CryptoJS.PBKDF2(password, hash, { keySize: 256/32, iterations: 1000 });
var iv  = CryptoJS.enc.Base64.parse(iv64);
var encrypted = CryptoJS.AES.encrypt(message, key, { iv: iv });
return encrypted.ciphertext.toString(CryptoJS.enc.Base64);
</code></pre>
","<p>I've implemented this encryption logic using the built-in Node.js crypto module, I've encrypted the same plaintext using both the crypto-js function as well and decoded both to ensure the results are consistent: </p>

<pre><code>const CryptoJS = require('crypto-js');
const crypto = require(""crypto"");

function encrypt_cryptojs(message, password, iv64, salt) {
    var hash = CryptoJS.SHA256(salt);
    var key = CryptoJS.PBKDF2(password, hash, { keySize: 256/32, iterations: 1000 });
    var iv  = CryptoJS.enc.Base64.parse(iv64);
    var encrypted = CryptoJS.AES.encrypt(message, key, { iv: iv });
    return encrypted.ciphertext.toString(CryptoJS.enc.Base64);
}

// Use built-in crypto module.
function encrypt(message, password, iv64, salt) {
    const iv = Buffer.from(iv64, 'base64');
    const hash = crypto.createHash('sha256').update(salt, 'utf8').digest()
    const key = crypto.pbkdf2Sync(password, hash, 1000, 32, null);

    const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);
    let encrypted = cipher.update(message, 'utf8', 'base64')
    encrypted += cipher.final('base64');
    return encrypted;
}

function decrypt(messagebase64, password, iv64) {

    const iv = Buffer.from(iv64, 'base64');
    const hash = crypto.createHash('sha256').update(salt, 'utf8').digest()
    const key = crypto.pbkdf2Sync(password, hash, 1000, 32, null);

    const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
    let decrypted = decipher.update(messagebase64, 'base64');
    decrypted += decipher.final();
    return decrypted;
}

const plaintext = ""If you prick us do we not bleed? If you tickle us do we not laugh"";
const salt = ""some salt"";
const password = crypto.scryptSync(""some password"", salt, 16).toString(""base64"");
const iv64 = ""XxbSho8OZacvQwXC6S5RQw=="";

console.log(""Ciphertext (crypto js):"", encrypt_cryptojs(plaintext, password, iv64, salt));
console.log(""Ciphertext (built-in crypto module):"", encrypt(plaintext, password, iv64, salt));
console.log(""Decrypted (crypto js):"", decrypt(encrypt_cryptojs(plaintext, password, iv64, salt), password, iv64));
console.log(""Decrypted (built-in crypto module):"", decrypt(encrypt(plaintext, password, iv64, salt), password, iv64));
</code></pre>
","32","<javascript><node.js><cryptojs>","0","1","1","2019-10-07 08:42:20","58266091","0","","","","","2019-10-07 03:48:14",""
"48483292","encrypted data in Javascript is not being decrypted with php properly","<p>I am encrypting with Cryptojs in javascript with this function.</p>

<pre><code>  function encode(text, skey) {
    var base64Iv = ""0123456789abcdef"";
    var key = CryptoJS.enc.Base64.parse(skey);
    var iv = CryptoJS.enc.Base64.parse(base64Iv);
    var encrypted = CryptoJS.AES.encrypt(CryptoJS.enc.Utf8.parse(text), key, {iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7});
    var encryptedData = encrypted.toString();
    return encryptedData;   
}
</code></pre>

<p>and trying to decrypt it with php_mcrypt with this function</p>

<pre><code>    function decrypt($crypt, $key, $type){
      $enc = MCRYPT_RIJNDAEL_128;
      $mode = MCRYPT_MODE_CBC;
      $iv = ""0123456789abcdef"";
      $crypt = base64_decode($crypt);
      $padtext = mcrypt_decrypt($enc, base64_decode($key) , $crypt, $mode, $iv);
      echo (""PADTEXT""+$padtext);
      $pad = ord($padtext
        {
        strlen($padtext) - 1});
        if ($pad &gt; strlen($padtext)) return false;
        if (strspn($padtext, $padtext{ strlen($padtext) - 1}, strlen($padtext) - $pad) != $pad)
                {
                $text = ""Error"";
                }

            $text = substr($padtext, 0, -1 * $pad);
            echo (""TEXT ""+$text);
            return $text;
}
</code></pre>

<p>I am using the same key and iv however it is not decrypting the beginning of string properly. </p>

<p><strong>Expected Result:</strong>
00paygate|201710270001|12345|16|USD|INR|SALE|<a href=""http://localhost/Response.php|http://localhost/Response.php|WEB"" rel=""nofollow noreferrer"">http://localhost/Response.php|http://localhost/Response.php|WEB</a> </p>

<p><strong>Actual Result:</strong>
00-xRTWQ0001|12345|16|USD|INR|SALE|<a href=""http://localhost/Response.php|http://localhost/Response.php|WEB"" rel=""nofollow noreferrer"">http://localhost/Response.php|http://localhost/Response.php|WEB</a></p>
","","31","<javascript><php><encryption><mcrypt><cryptojs>","2","","0","2018-01-28 04:58:06","","2","","","","","2018-01-28 04:58:06",""
"57424433","padding remain after decryption","<p>I want to encrypt and decrypt string using AES CBC but the problem is the padding remain after decryption ;</p>

<pre><code>key=""wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww""; 
iv=""1111111111111111"";
var encrypted = CryptoJS.AES.encrypt(""60000"", key, { iv: iv , padding: CryptoJS.pad.Pkcs7, mode: CryptoJS.mode.CBC});
var decrypted = CryptoJS.AES.decrypt(encrypted, key, { 
    iv: iv, 
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC

  });
console.log(""mmh-dec"",decrypted.toString());
</code></pre>

<p>I got ""3630303030"" instead of 60000</p>
","<p>Encoding is missing when converting the bytes to string.</p>

<pre><code>decrypted.toString()
</code></pre>

<p>should be:</p>

<pre><code>decrypted.toString(CryptoJS.enc.Utf8)
</code></pre>

<p>Example snippet:</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""true"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code snippet-currently-hidden"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>key=""wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww""; 
iv=""1111111111111111"";

var encrypted = CryptoJS.AES.encrypt(""60000"", key, {
    iv: iv,
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC
});

var decrypted = CryptoJS.AES.decrypt(encrypted, key, { 
    iv: iv, 
    padding: CryptoJS.pad.Pkcs7,
    mode: CryptoJS.mode.CBC
});

console.log(""mmh-dec"",decrypted.toString(CryptoJS.enc.Utf8));</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.2/rollups/aes.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","31","<javascript><cryptojs>","1","1","1","2019-08-09 09:34:15","57427257","0","0","","","","2019-08-09 06:22:34",""
"39028609","How to differentiate AJAX calls made from my application (client) vs elsewhere?","<p>I have a back end running node. I have a front end application that will make AJAX requests to the back end, such as a post request to submit a contact form (not an actual form, but a series of inputs that the post request aggregates user input from to send a payload). Is there a way to differentiate between the various AJAX calls that my application is making vs say a developer in the console who would try and make those calls manually?</p>

<p>My thought was that my application would send some sort of payload with each type of request so that the server could check for said payload and know it was the app making the call. Problem is, I'm not sure how the app itself can both generate that payload on the fly (i.e. not me sending a string of data that's hard-coded in the JS) while keeping it secret. I looked into crypto-js, but it seems that I would have to store the key in my code somewhere which would just defeat the purpose. I hope I just said all that correctly.</p>
","","31","<javascript><ajax><node.js><encryption><cryptojs>","0","","0","2016-09-03 17:19:09","","4","","2525633","","2016-09-03 17:19:09","2016-08-18 22:46:04",""
"58420019","How to convert php hash_hmac to NodeJS","<p>I need to convert a php hash_hmac to node.js. I have found similar questions and answers which I have tried, but I am still receiving 
{ data: '', error: 'HMAC not sent', success: false }</p>

<pre><code>const params = {
method : ""get_issues"",
ts : time.toString(),
field_1_name : ""id"",
field_1_value : 123456,
sort : ""status ASC, created DESC""
}
</code></pre>

<p>php: </p>

<pre><code> $mac = hash_hmac(""sha512"", mac_build_query($params), $PRIVATE_KEY); 
</code></pre>

<p>node.js: </p>

<pre><code>let mac = crypto.createHmac(""sha512"", mac_build_query(params)).update(PRIVATE_KEY).digest().toString('base64') //('base64') //hex
</code></pre>
","<p>IN PHP : </p>

<p><code>hash_hmac ( string $algo , string $data , string $key [, bool $raw_output = FALSE ] ) : string</code> </p>

<p>Example: </p>

<pre><code>hash_hmac($algo,$data,$key) // return hex string 
</code></pre>

<p>In Node : <code>createHmac(algo, key).update(data).digest(encoding)</code></p>

<p>example :</p>

<pre><code> crypto.createHmac('sha512', key).update(data).digest('hex')
</code></pre>

<p><strong>NOTE: Key and data should be a string.</strong></p>

<p>if data is object then convert to string:</p>

<pre><code>let data_json_string = JSON.stringify(data);
</code></pre>

<p>Output: <a href=""https://i.stack.imgur.com/tNYTT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tNYTT.png"" alt=""enter image description here""></a></p>
","30","<php><node.js><hmac><cryptojs>","0","0","1","2019-10-16 20:18:02","","1","","","","","2019-10-16 18:58:18",""
"56953740","CryptoJS giving other results than Java's Cipher.doFinal()","<p>I am trying to write a function in JavaScript that I already have in Java. The function simply encodes a string with AES.</p>

<p>I tried different types like WordArray, ByteArray, String, HexString.</p>

<pre><code>byte[] IV = new byte[] { 57, 118, 97, 110, 32, 77, 101, 100, 118, 101, 100, 101, 118, 100, 101, 118 };

byte[] md5 = { 52, -123, -23, -71, -89, 6, -59, -33, -48, 56, -69, -77, -100, 107, -68, 127 };

byte[] text= { 112, 101, 116, 101, 114, 46, 109, 111, 101, 108, 108, 101, 114, 64, 119, 101, 98, 46, 100, 101 };

String TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
Cipher _cipher;
SecretKey _password;
IvParameterSpec _IVParamSpec;

_password = new SecretKeySpec(md5, ALGORITHM);
_IVParamSpec = new IvParameterSpec(IV);
_cipher = Cipher.getInstance(TRANSFORMATION);
_cipher.init(Cipher.ENCRYPT_MODE, _password, _IVParamSpec);
encryptedData = _cipher.doFinal(text);

Base64.Encoder enc = Base64.getEncoder();
String encData=enc.encodeToString(encryptedData);
</code></pre>

<pre><code>var pass = CryptoJS.enc.Hex.parse(this.toWordArray([52, -123, -23, -71, -89, 6, -59, -33, -48, 56, -69, -77, -100, 107, -68, 127]));

var iv = CryptoJS.enc.Hex.parse(this.toWordArray([57, 118, 97, 110, 32, 77, 101, 100, 118, 101, 100, 101, 118, 100, 101, 118]));

var text = this.toWordArray([112, 101, 116, 101, 114, 46, 109, 111, 101, 108, 108, 101, 114, 64, 119, 101, 98, 46, 100, 101]);

var encrypted = CryptoJS.AES.encrypt(text, pass, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
var utf8 = CryptoJS.enc.Utf8.parse(encrypted);
var base64 = CryptoJS.enc.Base64.stringify(utf8);
</code></pre>

<p>In Java the result is: VmivVhaBFNdJQMY5JHczcs4VQXvzH3qEswsT4PufAqg=</p>

<p>In JavaScript I expect the same output, but I get: VVRGUVRVQlE5VTFOQ1pLb1FFMDhUY05LQzRNcGF3UTBnNE1ZZ3luQW1Vaz0=</p>
","","30","<javascript><java><encryption><cryptojs>","0","","0","2019-07-09 13:29:11","","4","","","","","2019-07-09 13:29:11",""
"56141818","Different when encrypting using AES-128 bit on javascript","<p>I encrypt using AES-128 bits using the CBC method in PHP but when I try it in javascript they produce different outputs</p>

<p>I tried crypto-js on javascript by adapting my code on php</p>

<p>the php code what i made :</p>

<pre><code>$secretKey = ""someivtextforaes"";
$ivKey = 'somesecretkeytxt';
$token = 'BD';
$cipher = ""AES-128-CBC"";
$ciphertext_raw = openssl_encrypt($token, $cipher, $secretKey, false, $ivKey);
return $ciphertext_raw;
</code></pre>

<p>this output is :
rtFKwdZt4wzgRsgYG/LbiQ==</p>

<p>i try this method on javascript using crypto-js, this is the code :</p>

<pre><code>let secretKey = ""someivtextforaes"";
let ivKey = 'somesecretkeytxt';
let token = 'BD';
let cipherData = CryptoJS.AES.encrypt(token, secretKey, { iv: ivKey });
console.log(cipherData.toString())
</code></pre>

<p>but they have a different output :
U2FsdGVkX1+QsOS9lM2F2Emq</p>

<p>i expect the same output for encryption, someone can figure out this?</p>
","<p>For the PHP-code, code and output are inconsistent. The current code returns the output <code>50CqXivvXXTfw276AZ8IjA==</code> (the posted output is only obtained if key and IV are swapped).</p>

<p>In the JavaScript-code key and IV must be passed as <code>WordArray</code>, e.g. </p>

<pre><code>let secretKey = CryptoJS.enc.Latin1.parse(""..."");
</code></pre>

<p>Currently the key is passed as string and therefore interpreted as passphrase, from which key and IV are generated (see <em><a href=""https://cryptojs.gitbook.io/docs/#the-cipher-input"" rel=""nofollow noreferrer"">The Cipher Input</a></em>).</p>
","30","<aes><cryptojs>","0","0","1","2019-05-15 08:46:05","56145096","0","","","","","2019-05-15 04:33:11",""
"40073836","Porting JS (or node.js, i'm now sure) aes to c# aes","<p>i have this JS code:</p>

<pre><code>d = CryptoJS.AES.decrypt((t), CryptoJS.MD5(key), {
    mode: CryptoJS.mode.ECB,
    padding: CryptoJS.pad.Pkcs7,
    keySize: 4
}).toString(CryptoJS.enc.Utf8);
</code></pre>

<p>I don't know how I can set <code>keySize = 4</code> in C#</p>

<p>setting <code>keySize = 4</code> causing exception</p>

<p>I need port JS code to C#</p>
","<p>CryptoJS stores all data in a data structure called <code>WordArray</code>. Each ""word"" stores 32 bit (4 byte). A key size of 4 in CryptoJS means a key size of 128 bit or 16 byte everywhere else.</p>

<p>APIs are generally written differently and most of the time, you don't have the exact same object that represent the same data in the same way across programming languages. </p>

<p>C# works with byte arrays. So, you will need to create a key that has 16 bytes in it. Keep in mind that MD5 always produces 128 bit output (16 bytes), so you probably don't have to do anything special.</p>
","29","<c#><node.js><aes><porting><cryptojs>","0","0","1","2016-10-16 18:33:24","40073955","0","","1816580","","2016-10-16 18:27:48","2016-10-16 18:24:11",""
"56580612","Client-Side calculated MD5 hash using CryptoJS is differnt to terminal calculation","<p>I have integrated a file upload into my web app. The file should not be uploaded but the MD5 hash of the file should be calculated on the client side and then only this hash should be sent to the server.</p>

<p><strong>Javascript part:</strong></p>

<pre><code>if (input.files &amp;&amp; input.files[0]) {
    let reader = new FileReader();
    reader.onload = (e) =&gt; {
       let data = e.target.result;      
       var hashed = CryptoJS.MD5(data);
       console.log('hashed: ' + hashed);
    }
    reader.readAsDataURL(input.files[0]);
}
</code></pre>

<p>However, the code above gives me different hash as terminal does (<em>md5sum </em>).Terminal gives me the same hash as various online converters.</p>

<p>It is the same with SHA1 and SHA256 algorithms I tried.</p>

<p><strong>Example:</strong>
<a href=""https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Lion_waiting_in_Namibia.jpg/800px-Lion_waiting_in_Namibia.jpg"" rel=""nofollow noreferrer"">This image</a> from Wikipedia gives the following hashes.</p>

<p>Terminal: e5d23cb99614778b2acb163b8ee90810</p>

<p>CryptoJS: 468641711626fcfe6d956ddb21ccd4c7</p>
","<p><code>readAsDataURL()</code> is going to return a base64 string (with a data URI preamble) so that's what your hashing however an MD5 terminal tool is just going to read the raw bytes &amp; hash them as-is.  </p>

<p>To fix use:</p>

<pre><code>reader.readAsArrayBuffer(input.files[0]);
</code></pre>

<p>to fetch the raw bytes and:</p>

<pre><code>var hashed = CryptoJS.MD5(CryptoJS.lib.WordArray.create(data));
</code></pre>

<p>to pass them to CryptoJs in a format it can process.</p>
","29","<javascript><hash><cryptojs>","0","1","1","2019-06-13 12:55:35","56581028","0","","","","","2019-06-13 12:33:52",""
"57327265","Key and IV visible in ciphertext object using CryptoJS library","<p>I am trying to encrypt/decrypt some text using the CryptoJS library.</p>

<p>What I've done so far is, I generate a random key and iv and then I call the AES.encrypt function to encrypt the text.</p>

<p>For example</p>

<pre><code>const key = this.generateRandomBytes(32);
const iv = this.generateRandomBytes(16);
let ciphertext = CryptoJS.AES.encrypt(""secretMessage"", key, { iv: iv });
console.log(ciphertext);
</code></pre>

<p>What I noticed is that the ciphertext object contains the key and IV, so if I do <code>ciphertext.iv</code> I can get the iv value.
This means that by sending the ciphertext object, an attacker could get the iv and key values and decrypt the message.</p>

<p>Is it normal behavior?</p>

<p>Example:</p>

<pre><code>key: rGV5ig6haSCITFt3qijtz6upLRwqqTYc 
iv: JYtl1p6QjXEC31l2 
ciphertext: cc7b280b4183a52edf953d67e2780540 

Inside the ciphertext object: 

iv: $super: {init: , toString: , concat: , clamp: , clone: , } init:  () sigBytes: 16 words: (4) [2104546036, 2077723482, 1293309165, -1744950810] __proto__: Object
key: $super: {init: , toString: , concat: , clamp: , clone: , } init:  () sigBytes: 32 words: (12) [811130221, 2012216235, 445216844, 1154159480, 158586942, 1801599139, -1829338835, 1906315595, 2104546036, 2077723482, 1293309165, -1744950810] __proto__: Object
</code></pre>
","","28","<aes><cryptojs>","0","","0","2019-08-02 13:46:47","","10","","9773510","","2019-08-02 13:46:47","2019-08-02 13:14:59",""
"57671764","CryptoJS: How to generate a signed JWT using RSA256 and pair of key?","<p>I'm trying to duplicate the examplet at <a href=""https://jwt.io/#debugger"" rel=""nofollow noreferrer"">JWT.io debugger</a>, using RS256.</p>

<p>This is my code. The private and the public rsa key are from the same page.</p>

<pre><code>const sender_public_key = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnzyis1ZjfNB0bBgKFMSv
vkTtwlvBsaJq7S5wA+kzeVOVpVWwkWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHc
aT92whREFpLv9cj5lTeJSibyr/Mrm/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIy
tvHWTxZYEcXLgAXFuUuaS3uF9gEiNQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0
e+lf4s4OxQawWD79J9/5d3Ry0vbV3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWb
V6L11BWkpzGXSW4Hv43qa+GSYOD2QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9
MwIDAQAB
-----END PUBLIC KEY-----`;

const sender_private_key = `-----BEGIN RSA PRIVATE KEY-----
MIIEogIBAAKCAQEAnzyis1ZjfNB0bBgKFMSvvkTtwlvBsaJq7S5wA+kzeVOVpVWw
kWdVha4s38XM/pa/yr47av7+z3VTmvDRyAHcaT92whREFpLv9cj5lTeJSibyr/Mr
m/YtjCZVWgaOYIhwrXwKLqPr/11inWsAkfIytvHWTxZYEcXLgAXFuUuaS3uF9gEi
NQwzGTU1v0FqkqTBr4B8nW3HCN47XUu0t8Y0e+lf4s4OxQawWD79J9/5d3Ry0vbV
3Am1FtGJiJvOwRsIfVChDpYStTcHTCMqtvWbV6L11BWkpzGXSW4Hv43qa+GSYOD2
QU68Mb59oSk2OB+BtOLpJofmbGEGgvmwyCI9MwIDAQABAoIBACiARq2wkltjtcjs
kFvZ7w1JAORHbEufEO1Eu27zOIlqbgyAcAl7q+/1bip4Z/x1IVES84/yTaM8p0go
amMhvgry/mS8vNi1BN2SAZEnb/7xSxbflb70bX9RHLJqKnp5GZe2jexw+wyXlwaM
+bclUCrh9e1ltH7IvUrRrQnFJfh+is1fRon9Co9Li0GwoN0x0byrrngU8Ak3Y6D9
D8GjQA4Elm94ST3izJv8iCOLSDBmzsPsXfcCUZfmTfZ5DbUDMbMxRnSo3nQeoKGC
0Lj9FkWcfmLcpGlSXTO+Ww1L7EGq+PT3NtRae1FZPwjddQ1/4V905kyQFLamAA5Y
lSpE2wkCgYEAy1OPLQcZt4NQnQzPz2SBJqQN2P5u3vXl+zNVKP8w4eBv0vWuJJF+
hkGNnSxXQrTkvDOIUddSKOzHHgSg4nY6K02ecyT0PPm/UZvtRpWrnBjcEVtHEJNp
bU9pLD5iZ0J9sbzPU/LxPmuAP2Bs8JmTn6aFRspFrP7W0s1Nmk2jsm0CgYEAyH0X
+jpoqxj4efZfkUrg5GbSEhf+dZglf0tTOA5bVg8IYwtmNk/pniLG/zI7c+GlTc9B
BwfMr59EzBq/eFMI7+LgXaVUsM/sS4Ry+yeK6SJx/otIMWtDfqxsLD8CPMCRvecC
2Pip4uSgrl0MOebl9XKp57GoaUWRWRHqwV4Y6h8CgYAZhI4mh4qZtnhKjY4TKDjx
QYufXSdLAi9v3FxmvchDwOgn4L+PRVdMwDNms2bsL0m5uPn104EzM6w1vzz1zwKz
5pTpPI0OjgWN13Tq8+PKvm/4Ga2MjgOgPWQkslulO/oMcXbPwWC3hcRdr9tcQtn9
Imf9n2spL/6EDFId+Hp/7QKBgAqlWdiXsWckdE1Fn91/NGHsc8syKvjjk1onDcw0
NvVi5vcba9oGdElJX3e9mxqUKMrw7msJJv1MX8LWyMQC5L6YNYHDfbPF1q5L4i8j
8mRex97UVokJQRRA452V2vCO6S5ETgpnad36de3MUxHgCOX3qL382Qx9/THVmbma
3YfRAoGAUxL/Eu5yvMK8SAt/dJK6FedngcM3JEFNplmtLYVLWhkIlNRGDwkg3I5K
y18Ae9n7dHVueyslrb6weq7dTkYDi3iOYRW8HRkIQh06wEdbxt0shTzAJvvCQfrB
jg/3747WSsf/zBTcHihTRBdAv6OmdhV4/dD5YBfLAkLrd+mX7iE=
-----END RSA PRIVATE KEY-----`;



var header = {
    ""alg"": ""RS256"",
    ""typ"": ""JWT""
};

var payload = {
    ""sub"": ""1234567890"",
    ""name"": ""John Doe"",
    ""admin"": true,
    ""iat"": 1516239022
}

function base64url(source) {

    // Encode in classical base64
    encodedSource = CryptoJS.enc.Base64.stringify(source);

    // Remove padding equal characters
    encodedSource = encodedSource.replace(/=+$/, '');

    // Replace characters according to base64url specifications
    encodedSource = encodedSource.replace(/\+/g, '-');
    encodedSource = encodedSource.replace(/\//g, '_');

    return encodedSource;
}

var CryptoJS = require('crypto-js');

var stringifiedHeader = CryptoJS.enc.Utf8.parse(JSON.stringify(header));
var encodedHeader = base64url(stringifiedHeader);

var stringifiedPayload = CryptoJS.enc.Utf8.parse(JSON.stringify(payload));
var encodedPayload = base64url(stringifiedPayload);

var signature = CryptoJS.enc.Utf8.parse(CryptoJS.SHA256(encodedHeader + ""."" + encodedPayload, sender_private_key));
var encodedSignature = base64url(signature);


var jwt= encodedHeader + ""."" + encodedPayload + ""."" + encodedSignature
console.log(jwt)
</code></pre>

<h2>The problem</h2>

<p>The final JWT is the following</p>

<pre><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.ODA0MWZiOGNiYTllNGY4Y2MxNDgzNzkwYjA1MjYyODQxZjI3ZmRjYjIxMWJjMDM5ZGRmODg2NDM3NGRiNWY1Mw
</code></pre>

<p>But entering it at jwt.io, using public and private key as in my code, I got</p>

<blockquote>
  <p>Invalid signature</p>
</blockquote>
","","28","<jwt><cryptojs>","0","","0","2019-08-27 09:37:45","","1","1","","","","2019-08-27 09:37:45","2019-09-03 11:40:51"
"58082844","Encrypt in Ruby and Decrypt in Javascript","<p>I am trying to encrypt using Ruby openssl and decrypt using crypto in javascript but I am getting UTF-8 malformed error. Please help.</p>

<pre><code>      # contents is some object with key and value
      contents = contents.to_s;
      cipher = OpenSSL::Cipher::AES128.new :CBC;
      cipher.encrypt;
      # Random Key and IV
      cipher.key = ""AE08BF965F95A75A8AAB8C79CEFF4CB5"";
      cipher.iv = ""7E5ADDF765E56F564FB4E50B3115BAC3"";
      encrypted = cipher.update(contents) + cipher.final;
      # Converting into Base64 for more readable format.
      encrypted =  Base64.strict_encode64(encrypted);
      return {
        config: encrypted
      }.to_json
</code></pre>

<p>Javascript Code</p>

<pre><code>    var data = data.config;
    var decryptedData = data &amp;&amp; CryptoJS &amp;&amp; CryptoJS.AES &amp;&amp; CryptoJS.enc &amp;&amp; CryptoJS.AES.decrypt(data, CryptoJS.enc.Hex.parse(key), {
      iv: CryptoJS.enc.Hex.parse(iv)
    });
    decryptedStr = decryptedData &amp;&amp; decryptedData.toString(CryptoJS.enc.Utf8);
</code></pre>
","","28","<javascript><ruby><encryption><openssl><cryptojs>","0","","0","2019-09-24 14:42:01","","1","","","","","2019-09-24 14:42:01",""
"56196877","How to use AES encryption twice using CryptoJS AES","<p>i try to encrypt twice using cryptojs but its nothing return how i do that this is my code </p>

<pre><code>var defaultKey = ""Part of the journy is the end. Whatever it takes"";
var userKey = 'in this whole universe iron man is the best superhero';
var encryptMsg ='';

encryptMsg = CryptoJS.AES.encrypt(msg, defaultKey);
alert(encryptMsg);
encryptMsg = CryptoJS.AES.encrypt(encryptMsg , userKey );
alert(encryptMsg);
</code></pre>

<p>first alert show encrypted text but seconf alert not display anything</p>
","<p>oooyeh i found a solution i dont know this is right way but this thing work for me</p>

<pre><code>var defaultKey = ""Part of the journy is the end. Whatever it takes"";
var userKey = 'in this whole universe iron man is the best superhero';
var encryptMsg ='';

encryptMsg = CryptoJS.AES.encrypt(msg, defaultKey);
alert(encryptMsg);
encryptMsg = CryptoJS.AES.encrypt(String(encryptMsg) , userKey );
alert(encryptMsg);
</code></pre>

<p>i use String()</p>
","28","<javascript><aes><cryptojs>","0","0","1","2019-05-26 20:40:49","","0","","4845566","","2019-05-26 20:40:49","2019-05-18 07:27:01",""
"58246452","When I try to convert a hex string to an integer in JavaScript, I don't get the same number as I do in python","<p>I've been trying to convert a hex string to an integer in JavaScript but the number I get isn't the same as the number I get in python.</p>

<p>Here's my code in JS:</p>

<pre><code>var x = CryptoJS.MD5('h').toString();
BigInt(parseInt(x, 16));
</code></pre>

<p>Here's what I get:</p>

<pre><code>49268479078006859472353325704298889216n
</code></pre>

<p>And when I run this in python:</p>

<pre><code>int(hashlib.md5('h'.encode()).hexdigest(), 16)
</code></pre>

<p>I get:</p>

<pre><code>49268479078006861543109070154241760913
</code></pre>
","<p><code>parseInt</code> has already lost the precision for you by converting to a number before you convert to <code>BigInt</code>.</p>

<p>You can use a <code>0x</code> prefix? It seems weird, like theres a missing <code>BigInt.parse</code> API, but there you go.</p>

<pre><code>BigInt('0x' + x)
</code></pre>
","28","<javascript><cryptojs>","0","0","1","2019-10-05 08:36:09","","0","","","","","2019-10-05 07:56:04",""
"57982200","How to make Bitfinex api v1 signiture?","<p>I am trying to get response from bitfinex authenticated endpoint but I always get error 401: ""Invalid X-BFX-SIGNATURE."" I am not sure with base64 encoding or with creating hmac. Thank you for help.
bitfinex example:  <a href=""https://docs.bitfinex.com/docs/rest-auth"" rel=""nofollow noreferrer"">https://docs.bitfinex.com/docs/rest-auth</a></p>

<p>Here is my code:
`
request.data = </p>

<pre><code>({
      ...request.data,
      request: request.url,
      nonce: Date.now().toString()
    })
    request.headers = {
      'Content-Type': 'application/json',
      'X-BFX-APIKEY': config.bitfinex.apiKey,
      'X-BFX-PAYLOAD':     Crypto.enc.Base64.stringify(Crypto.enc.Utf8.parse(JSON.stringify(request.data))),
      'X-BFX-SIGNATURE': Crypto.HmacSHA384(config.bitfinex.secretKey,      Crypto.enc.Base64.stringify(Crypto.enc.Utf8.parse(JSON.stringify(request.data)))).toString()      
    }`
</code></pre>
","<p>I found solution which works, I must edit nonce and signature:</p>

<pre><code>request.data = JSON.stringify({
  ...request.data,
  request: request.url,
  nonce: (1000 * new Date().getTime()).toString()
})
request.headers = {
  'Content-Type': 'application/json',
  'X-BFX-APIKEY': config.bitfinex.apiKey,
  'X-BFX-PAYLOAD': Crypto.enc.Base64.stringify(Crypto.enc.Utf8.parse(request.data)),
  'X-BFX-SIGNATURE': Crypto.HmacSHA384(Crypto.enc.Base64.stringify(Crypto.enc.Utf8.parse(request.data)),
    config.bitfinex.secretKey)
}
</code></pre>
","27","<javascript><api><react-native><base64><cryptojs>","0","0","1","2019-09-18 18:40:50","","0","","10182846","","2019-09-18 18:40:50","2019-09-17 21:19:35",""
"57382721","How can I generate HMAC in React-Native?","<p>I need to create HmacSHA256 from a string with a private key...
I use react-native-crypto-js but I cant use it's HmacSHA256 method,
it keeps getting me ""undefined function"" error, here is my code:</p>

<pre><code>const signature = CryptoJS.HmacSHA256('simple', '123456789');
    const signatureBase = signature.toString(CryptoJS.enc.Base64);
</code></pre>

<p>I followed it's document either but still getting same error,
if you know another solution or the correct way to use this package please help me.
thanks.</p>
","","26","<react-native><encryption><cryptojs>","0","","0","2019-08-06 19:22:35","","0","","","","","2019-08-06 19:22:35",""
"55649286","how is the encryption method using CryptoJS using the correct php function","<p>I have javascript code for encryption like this :</p>

<pre><code>var myPassword = '12345*abc';
var encrypted   = CryptoJS.AES.encrypt(myString, myPassword);
document.getElementById(""demo1"").innerHTML = encrypted;
</code></pre>

<p>and I have a decryption function with php like this :</p>

<pre><code>function decrypt($ciphertext, $key) {
   $ciphertext = base64_decode($ciphertext);
   if (substr($ciphertext, 0, 8) != ""Salted__"") {
      return false;
   }
   $salt = substr($ciphertext, 8, 8);
   $keyAndIV = evpKDF($key, $salt);
   $decryptPassword = openssl_decrypt(
        substr($ciphertext, 16), 
        ""aes-256-cbc"",
        $keyAndIV[""key""], 
        OPENSSL_RAW_DATA, // base64 was already decoded
        $keyAndIV[""iv""]);

   return $decryptPassword;
}

function evpKDF($password, $salt, $keySize = 8, $ivSize = 4, $iterations = 1, $hashAlgorithm = ""md5"") {
$targetKeySize = $keySize + $ivSize;
$derivedBytes = """";
$numberOfDerivedWords = 0;
$block = NULL;
$hasher = hash_init($hashAlgorithm);
while ($numberOfDerivedWords &lt; $targetKeySize) {
    if ($block != NULL) {
        hash_update($hasher, $block);
    }
    hash_update($hasher, $password);
    hash_update($hasher, $salt);
    $block = hash_final($hasher, TRUE);
    $hasher = hash_init($hashAlgorithm);

    // Iterations
    for ($i = 1; $i &lt; $iterations; $i++) {
        hash_update($hasher, $block);
        $block = hash_final($hasher, TRUE);
        $hasher = hash_init($hashAlgorithm);
    }

    $derivedBytes .= substr($block, 0, min(strlen($block), ($targetKeySize - $numberOfDerivedWords) * 4));

    $numberOfDerivedWords += strlen($block)/4;
}

return array(
    ""key"" =&gt; substr($derivedBytes, 0, $keySize * 4),
    ""iv""  =&gt; substr($derivedBytes, $keySize * 4, $ivSize * 4)
);
</code></pre>

<p>}</p>

<p>so far it works fine, and now I want to encrypt the string with the php function, I try to use a function like the code below, but it doesn't work,</p>

<pre><code>function encrypt($string, $key) {
   $salt = substr($string, 8, 8);
   $keyAndIV = evpKDF($key, $string);
   $encryptPassword = openssl_encrypt(
        $string,
        ""aes-256-cbc"",
        $keyAndIV[""key""], 
        OPENSSL_RAW_DATA,
        $keyAndIV[""iv""]);

  return $encryptPassword;
</code></pre>

<p>}</p>

<p>can anyone help me please, how can I fix this issue, thanks.</p>
","","25","<php><cryptojs>","0","","0","2019-04-12 13:22:07","","2","","10912722","","2019-04-12 13:22:07","2019-04-12 10:08:55",""
"58478184","Is it possible to output word array in Python similar to CryptoJS.enc.Hex.parse(hash)","<p>Is there a way to convert a hash to a word array in Python as in JS?</p>

<p>In JS with CryptoJS I can use: <code>CryptoJS.enc.Hex.parse(hash)</code> which will output the word array.</p>

<p>I've tried googling it but cannot seem to find how to do that in Python.</p>

<p>Javascript example:</p>

<pre><code>var CryptoJS = require(""crypto-js"");

var hash = ""c8f3ab9777da89748851932d3446b197450bb12fa9b9136ad708734291a6c60c"";

console.log(hash);
</code></pre>

<p>I cannot figure out how to get similar output with hmac and hashlib libraries in Python but I expect the output something like this:</p>

<pre><code>{ words:
   [ -923554921,
     2010810740,
     -2007919827,
     877048215,
     1158394159,
     -1447488662,
     -687312062,
     -1851341300 ],
  sigBytes: 32 }
</code></pre>

<p>Update:
I need to have an output in the exact same format (spacing, indents, new lines) to produce a subsequent hash from the output.</p>
","<p>You can do this in Python but it's not builtin as part of any crypto library that I am aware of.</p>

<p>A simple implementation (requires Python 3):</p>

<pre class=""lang-py prettyprint-override""><code>
hash = ""c8f3ab9777da89748851932d3446b197450bb12fa9b9136ad708734291a6c60c""

# Convert hex-encoded data into a byte array
hash_bytes = bytes.fromhex(hash)

# Split bytes into 4-byte chunks (32-bit integers) and convert
# The integers in your example a big-endian, signed integers
hash_ints = [
    int.from_bytes(hash_bytes[i:i+4], ""big"", signed=True) 
    for i in range(0, len(hash_bytes), 4)
]

# Print result
print({""words"": hash_ints, ""sigBytes"": len(hash_bytes)})
</code></pre>

<p>This will output: <code>{'words': [-923554921, 2010810740, -2007919827, 877048215, 1158394159, -1447488662, -687312062, -1851341300], 'sigBytes': 32}</code></p>

<p>Hope that helps.</p>
","25","<javascript><python><node.js><hmac><cryptojs>","0","0","1","2019-10-21 01:14:57","58478318","0","","12248608","","2019-10-21 01:14:57","2019-10-20 23:39:35",""
"58752326","How to encrypt a image before upload to server side using angular 8?","<p><strong>This is my frontend of file upload component</strong>
<a href=""https://i.stack.imgur.com/hvzyV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hvzyV.png"" alt=""enter image description here""></a></p>

<p><strong>This is the ts file to the above component</strong>
<a href=""https://i.stack.imgur.com/U0QJv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/U0QJv.png"" alt=""enter image description here""></a></p>

<p>what i need to know is that how to encrypt the image before upload to server side?If somone can provide a code that would be really helpfull...</p>
","","25","<angular><encryption><cryptojs>","0","","0","2019-11-07 15:46:45","","4","","","","","2019-11-07 15:46:45",""
"56423371","How to update private key with passphrase, if it was generated without passphrase in Node.js Crypto lib?","<p>I generate RSA keypair with Node.js(10.16.0) native Crypto lib. With my config I create private key without passphrase, because I need to do some actions with it, and after I want to set passphrase on that private key. How shall I do that with exact library version?</p>

<p>That is my config for generating keypair. </p>

<pre><code>generateKeyPair(
      ""rsa"",
      {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: ""spki"",
          format: ""pem""
        },
        privateKeyEncoding: {
          type: ""pkcs8"",
          format: ""pem"",
        }
      })
</code></pre>

<p>I don't see any functions in documentation that do direct thing, but maybe there is a way to combine other crypto functions to get expected result?</p>
","","25","<node.js><cryptojs>","0","","0","2019-06-03 08:07:50","","0","","","","","2019-06-03 08:07:50",""
"56989338","How to decrypt string created by this encryption component","<p>We have a component that's encrypting strings and a Node API that's decrypting them for another purpose. I can't seem to get them decrypting to the correct value. How can I replicate this in Node?</p>

<p>I've included the component's code below, just need to know what options to pass into crypto's functions.</p>

<pre><code>'publics

' Use these members to save min and max salt lengths.
Public minSaltLen As Integer = -1
Public maxSaltLen As Integer = -1

Private encString As String
Private decString As String

Private EncryptionKey As String  'EncryptionKey
Private MasterEncryptionKey As String ' MasterEncryptionKey

Private DecryptUserName As String
Private DecryptPassword As String

Private saltValue As String
Private passwordIterations As Integer = 2

Private keySize As Integer = 256
Private hashAlgorithm As String

Private Shared DEFAULT_HASH_ALGORITHM As String = ""SHA-1""

Private Shared DEFAULT_KEY_SIZE As Integer = 256
Private Shared MAX_ALLOWED_SALT_LEN As Integer = 255

Private Shared MIN_ALLOWED_SALT_LEN As Integer = 4

Private Shared DEFAULT_MIN_SALT_LEN As Integer = MIN_ALLOWED_SALT_LEN
Private Shared DEFAULT_MAX_SALT_LEN As Integer = 8

Private encryptor As ICryptoTransform = Nothing
Private decryptor As ICryptoTransform = Nothing
Private dc As Boolean

Public Sub New()


End Sub

Public Sub setStringToEncrypt(ByVal var As String)
    encString = var
End Sub

Public Sub setEncryptionKey(ByVal var As String)
    EncryptionKey = var
End Sub

Public Function EncryptData()
    EncryptData = Encrypt(encString)
End Function

Public Sub setDecryptUserName(ByVal var As String)
    DecryptUserName = var
End Sub

Public Sub setDecryptPassword(ByVal var As String)
    DecryptPassword = var
End Sub

Public Sub setStringToDecrypt(ByVal var As String)
    decString = var
End Sub

Public Function DecryptData()

    If validateDecryptUser() Then
        DecryptData = Decrypt(decString)
    Else
        DecryptData = """"
        Err.Raise(1000, ""Encryption.AES.DecryptData()"", ""Decryption Username and/or Password incorrect - decryption failed"")
        Exit Function
    End If


End Function

Private Sub initFunction()

    MasterEncryptionKey = ""MASTERKEY"" ' must be 16 chars

    If EncryptionKey.ToString() = """" Then
        Err.Raise(1002, ""Encryption.AES.initFunction()"", ""Encryption key incorrect or empty"")
        Exit Sub
    End If

    If (minSaltLen &lt; MIN_ALLOWED_SALT_LEN) Then
        Me.minSaltLen = DEFAULT_MIN_SALT_LEN
    Else
        Me.minSaltLen = minSaltLen
    End If

    If (maxSaltLen &lt; 0 Or maxSaltLen &gt; MAX_ALLOWED_SALT_LEN) Then
        Me.maxSaltLen = DEFAULT_MAX_SALT_LEN
    Else
        Me.maxSaltLen = maxSaltLen
    End If

    ' Set the size of cryptographic key.
    If (keySize &lt;= 0) Then
        keySize = DEFAULT_KEY_SIZE
    End If

    If (hashAlgorithm Is Nothing) Then
        hashAlgorithm = DEFAULT_HASH_ALGORITHM
    Else
        hashAlgorithm = hashAlgorithm.ToUpper().Replace(""-"", """")
    End If

    Dim initVectorBytes() As Byte = Nothing

    Dim saltValueBytes() As Byte = Nothing

    ' Get bytes of initialization vector.
    If (MasterEncryptionKey Is Nothing) Then
        initVectorBytes = New Byte() {}
    Else
        initVectorBytes = Encoding.ASCII.GetBytes(MasterEncryptionKey)
    End If

    ' Get bytes of salt (used in hashing).
    If (saltValue Is Nothing) Then
        saltValueBytes = New Byte() {}
    Else
        saltValueBytes = Encoding.ASCII.GetBytes(saltValue)
    End If

    ' Generate password, which will be used to derive the key.
    Dim password As PasswordDeriveBytes = New PasswordDeriveBytes( _
                                                EncryptionKey, _
                                                saltValueBytes, _
                                                hashAlgorithm, _
                                                passwordIterations)

    ' Convert key to a byte array adjusting the size from bits to bytes.
    On Error Resume Next
    Dim keyBytes() As Byte = password.GetBytes(keySize / 8)

    ' Initialize Rijndael key object.
    Dim symmetricKey As RijndaelManaged = New RijndaelManaged()

    If (initVectorBytes.Length = 0) Then
        symmetricKey.Mode = CipherMode.ECB
    Else
        symmetricKey.Mode = CipherMode.CBC
    End If

    encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes)
    decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes)

End Sub

Public Function Encrypt(ByVal plainText As String) As String
    dc = False
    initFunction()
    Encrypt = Encrypt(Encoding.UTF8.GetBytes(plainText))
End Function

Public Function Encrypt(ByVal plainTextBytes As Byte()) As String
    dc = False
    initFunction()
    Encrypt = Convert.ToBase64String(EncryptToBytes(plainTextBytes))
End Function

Public Function EncryptToBytes(ByVal plainText As String) As Byte()
    EncryptToBytes = EncryptToBytes(Encoding.UTF8.GetBytes(plainText))
End Function

Public Function EncryptToBytes(ByVal plainTextBytes As Byte()) As Byte()

    Dim plainTextBytesWithSalt() As Byte = AddSalt(plainTextBytes)

    Dim memoryStream As MemoryStream = New MemoryStream()
    Dim cryptoStream As CryptoStream = Nothing

    ' Let's make cryptographic operations thread-safe.
    SyncLock Me
        ' To perform encryption, we must use the Write mode.
        cryptoStream = New CryptoStream(memoryStream, _
                                        encryptor, _
                                        CryptoStreamMode.Write)

        ' Start encrypting data.
        cryptoStream.Write(plainTextBytesWithSalt, _
                            0, _
                            plainTextBytesWithSalt.Length)

        ' Finish the encryption operation.
        cryptoStream.FlushFinalBlock()

        ' Move encrypted data from memory into a byte array.
        Dim cipherTextBytes() As Byte = memoryStream.ToArray()

        ' Close memory streams.
        memoryStream.Close()
        cryptoStream.Close()

        ' Return encrypted data.
        EncryptToBytes = cipherTextBytes
    End SyncLock
End Function

Public Function Decrypt(ByVal cipherText As String) As String
    dc = True
    initFunction()
    Decrypt = Decrypt(Convert.FromBase64String(cipherText))
End Function

Public Function Decrypt(ByVal cipherTextBytes As Byte()) As String
    dc = True
    initFunction()
    Decrypt = Encoding.UTF8.GetString(DecryptToBytes(cipherTextBytes))
End Function

Public Function DecryptToBytes(ByVal cipherText As String) As Byte()
    DecryptToBytes = DecryptToBytes(Convert.FromBase64String(cipherText))
End Function

Public Function DecryptToBytes(ByVal cipherTextBytes As Byte()) As Byte()

    Dim decryptedBytes() As Byte = Nothing
    Dim plainTextBytes() As Byte = Nothing
    Dim decryptedByteCount As Integer = 0
    Dim saltLen As Integer = 0

    Dim memoryStream As MemoryStream = New MemoryStream(cipherTextBytes)

    decryptedBytes = New Byte(cipherTextBytes.Length - 1) {}

    ' Let's make cryptographic operations thread-safe.
    SyncLock Me
        ' To perform decryption, we must use the Read mode.
        Dim cryptoStream As CryptoStream = New CryptoStream( _
                                                    memoryStream, _
                                                    decryptor, _
                                                    CryptoStreamMode.Read)

        ' Decrypting data and get the count of plain text bytes.
        decryptedByteCount = cryptoStream.Read(decryptedBytes, _
                                                0, _
                                                decryptedBytes.Length)
        ' Release memory.
        memoryStream.Close()
        cryptoStream.Close()
    End SyncLock

    ' If we are using salt, get its length from the first 4 bytes of plain
    ' text data.
    If (maxSaltLen &gt; 0 And maxSaltLen &gt;= minSaltLen) Then
        saltLen = (decryptedBytes(0) And &amp;H3) Or _
                    (decryptedBytes(1) And &amp;HC) Or _
                    (decryptedBytes(2) And &amp;H30) Or _
                    (decryptedBytes(3) And &amp;HC0)
    End If

    ' Allocate the byte array to hold the original plain text
    ' (without salt).
    plainTextBytes = New Byte(decryptedByteCount - saltLen - 1) {}

    ' Copy original plain text discarding the salt value if needed.
    Array.Copy(decryptedBytes, saltLen, plainTextBytes, _
                0, decryptedByteCount - saltLen)

    ' Return original plain text value.
    DecryptToBytes = plainTextBytes
End Function

Private Function AddSalt(ByVal plainTextBytes As Byte()) As Byte()

    If (maxSaltLen = 0 Or maxSaltLen &lt; minSaltLen) Then
        AddSalt = plainTextBytes
        Exit Function
    End If

    ' Generate the salt.
    Dim saltBytes() As Byte = GenerateSalt()

    ' Allocate array which will hold salt and plain text bytes.
    Dim plainTextBytesWithSalt() As Byte = New Byte( _
                                            plainTextBytes.Length + _
                                            saltBytes.Length - 1) {}
    ' First, copy salt bytes.
    Array.Copy(saltBytes, plainTextBytesWithSalt, saltBytes.Length)

    ' Append plain text bytes to the salt value.
    Array.Copy(plainTextBytes, 0, _
                plainTextBytesWithSalt, saltBytes.Length, _
                plainTextBytes.Length)

    AddSalt = plainTextBytesWithSalt
End Function
</code></pre>

<p>End Class</p>
","","25","<.net><node.js><aes><cryptojs>","0","","0","2019-07-11 12:34:47","","0","","","","","2019-07-11 12:34:47",""
"50941014","CryptoJS saying Crytpo.js file not found error","<p>So I am trying to use the CryptoJS and I have been trying to use it two ways. One without require and the other with require and I am running into issues with both ways. When I try to use it without require, I get an error saying file not found
<a href=""https://i.stack.imgur.com/bE9q1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bE9q1.png"" alt=""enter image description here""></a></p>

<pre><code>    &lt;script type=""text/javascript"" src=""/public/bower_components/cryptojs/cryptojs.js""&gt;&lt;/script&gt;
&lt;script type=""text/javascript""&gt;
    var encrypted = CryptoJS.AES('Message');
    console.log(encrypted);
&lt;/script&gt;
</code></pre>

<p>When I try to use require, and use require.js I still get an error that says 
Uncaught reference error: Require not defined
<a href=""https://i.stack.imgur.com/1Z0mw.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1Z0mw.png"" alt=""enter image description here""></a>  </p>
","","25","<javascript><cryptojs>","2","","0","2018-06-20 05:42:50","","3","","","","","2018-06-20 05:42:50",""
"58292912","Best way to authenticate node.js file use?","<p>I have a node.js file, which when run firstly authenticates the user by reading two strings from a JSON file. </p>

<p>However, a major problem with this approach:</p>

<p>JSON FILE</p>

<pre><code>{
    ""id"": ""12345"",
    ""apiKey"": ""foo""
}
</code></pre>

<p>JS FILE</p>

<pre><code>if (jsonFile.id === ""123"" &amp;&amp; jsonFile.apiKey === ""foo"") {
    return true;
} else {
    return false;
}
</code></pre>

<p>is that the user can change the values in the JS file to any value they want to put in the JSON file so they can authenticate anything.</p>

<p>One solution, I thought was using hashes with crypto, but the user can create a hash for any id or apiKey they want and change it in the files. The code will be obfuscated but I thought I would ask if there is a better way for this. </p>

<p>I don't want the program that I give the user to be able to run different apiKey's or id's, only the ones I have defined in the program and they should not be able to change it.</p>

<p>Thanks in advance.</p>
","<p>Assuming your node.js file is running on your server and you are authenticating requests from your clients, then you should look at passport.js or another authentication library.  Credentials should never be passed to a server in clear text, but even if your client changes the credentials, it doesn't mean they'll get authenticated on the server, because the server authenticates using a database of registered users.  Your example suggests you are looking for ""bearer token"" authentication (apiKey), so here's a link to the <a href=""http://www.passportjs.org/packages/passport-http-bearer/"" rel=""nofollow noreferrer"">passport-http-bearer</a> docs on the passportjs.org website.</p>
","24","<node.js><cryptojs>","0","0","1","2019-10-08 20:07:58","58293383","1","","","","","2019-10-08 19:31:55",""
"57303734","Why is my function returning unicode replacement characters","<p>I'm trying to add encryption for passwords, and want to store the hashes and have the encryption/decryption being done on signup/login, the encryption goes fine from utf8 to hex, but when I try to decrypt, I get back a bunch of weird letters that look like:</p>

<blockquote>
  <p>""\ufffd'\rF\ufffd\ufffd\\ufffd6>\ufffd\ufffd#B,0\u0005\u0007\ufffd?\ufffd;\ufffd\u0018\u001e\""o""</p>
</blockquote>

<p>I've been trying to figure out how it could be using the wrong encoding data, as I have the hex and utf8 tags in the right places; I've been trying to look at other posts too, but I'm afraid they go over my head over how they're supposed to help me.</p>

<h2>This is in the first file that I export it from</h2>

<pre><code>var crypto = require(""crypto"");

    var secretkey = ""twinkies"";
    var key = {
    encrypt: function(pass){
        var mykey = crypto.createCipher('aes-128-cbc', secretkey);
        var finpass = mykey.update(pass, 'utf8', 'hex');
        finpass += mykey.final('hex');
        return finpass;
    },

    decrypt: function(pass){
        var mykey = crypto.createCipher('aes-128-cbc', secretkey);
        var finpass = mykey.update(pass, 'hex', 'utf8');
        finpass += mykey.final('utf8');
        return finpass;
    }
};
</code></pre>

<h2>this is the second file that uses the methods</h2>

<pre><code>    app.post(""/api/users/create"", function(req, res) {
    console.log(req.body.pword);
    var newpass = key.encrypt(req.body.pword);
    var oldpass = key.decrypt(newpass);
    var enddata = {
        Ciphored_password : newpass,
        Deciphored_password : oldpass
    }
    console.log(res.json(enddata));
</code></pre>

<p>I use postman to test my localhost api, and am putting in 'bigthonks' as the password, when it console logs the enddata the Ciphored_password looks like:</p>

<blockquote>
  <p>982cb6d27f65fbb642c8c7b710e6c349</p>
</blockquote>

<p>and the Deciphored_password:</p>

<blockquote>
  <p>""\ufffd'\rF\ufffd\ufffd\\ufffd6>\ufffd\ufffd#B,0\u0005\u0007\ufffd?\ufffd;\ufffd\u0018\u001e\""o""</p>
</blockquote>
","<p>It turns out I'm an idiot... I missed one of the first steps of bugfixing which is looking at methodnames,</p>

<pre><code>var crypto = require(""crypto"");

var secretkey = ""twinkies"";
var key = {
encrypt: function(pass){
    var mykey = crypto.createCipher('aes-128-cbc', secretkey);
    var finpass = mykey.update(pass, 'utf8', 'hex');
    finpass += mykey.final('hex');
    return finpass;
},

decrypt: function(pass){
    var mykey = crypto.createCipher('aes-128-cbc', secretkey);
    var finpass = mykey.update(pass, 'hex', 'utf8');
    finpass += mykey.final('utf8');
    return finpass;
}
};
</code></pre>

<p>on my decrypt method, when I'm generating the decipher for it i use the createCipher() method instead of the createDecipher() method, really big woops on my part.</p>

<p>I easily fixed it by changing the decrypt method to this: </p>

<pre><code>    decrypt: function(pass){
    var mykey = crypto.createDecipher('aes-128-cbc', secretkey);
    var finpass = mykey.update(pass, 'hex', 'utf8');
    finpass += mykey.final('utf8');
    return finpass;
}
</code></pre>

<p>and now it works.</p>
","23","<javascript><express><cryptojs>","1","0","1","2019-08-01 08:06:01","","0","","","","","2019-08-01 07:21:43",""
"58481462","C# Code on TripleDESCryptoServiceProvider gives a different value from cryptojs","<p>I am trying to transpose a c# code to a javascript using cryptojs and in the c# code it uses TripleDESCryptoServiceProvider. I can get everything exactly the values of C# in my javascript code except for the encrypting part. I get a different result on the encryption.
Please see my code on c# and javascript.</p>

<p>C#
public static string EncryptTxt(string key, string msg, CipherMode mode, Int16 KeyOffSet)
{
    SHA512CryptoServiceProvider sha = new SHA512CryptoServiceProvider();
    byte[] newKey = new byte[23];</p>

<pre><code>using (var tdes = new TripleDESCryptoServiceProvider())
{
    byte[] Results;
    System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
    MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
    byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(key));
    TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

    byte[] keybyte = sha.ComputeHash(Encoding.UTF8.GetBytes(key));
    byte[] newKeyx = new byte[24];

    Array.Copy(keybyte, KeyOffSet, newKeyx, 0, newKeyx.Length);

    TDESAlgorithm.Key = newKeyx;
    TDESAlgorithm.Mode = mode;
    TDESAlgorithm.Padding = PaddingMode.PKCS7;
    byte[] DataToEncrypt = UTF8.GetBytes(msg);
    try
    {
        ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
        Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
    }
finally
{
    TDESAlgorithm.Clear();
    HashProvider.Clear();
}
return Convert.ToBase64String(Results);
</code></pre>

<p>}</p>

<p>javascript</p>

<pre><code>encryptText = () =&gt; {
    debugger;
    const msg = 'Autosweep2Go1:juan:201910181809:12345678';
    let key = crypto.enc.Utf8.parse('xxx');
    key = crypto.MD5(key);
    key.words.push(key.words[0], key.words[1]);
    const iv = crypto.enc.Utf8.parse('xxx');

    // MD5CryptoServiceProvider
    const hashProvider = crypto.MD5(iv);
    const TDESKey = this.wordArrayToByteArray(hashProvider, 8);

    const keybyte = this.wordArrayToByteArray(crypto.SHA512(iv), 16);
    const newKeyx = new Uint8Array(24);

    const newkeybyte = keybyte.slice(10, 34);
    // Object.assign(newKeyx, newkeybyte);

    const TDESAlgorithmKey = newkeybyte;
    const DataToEncrypt = this.wordArrayToByteArray(crypto.enc.Utf8.parse(msg), 40);
    const dteLength = DataToEncrypt.length;
    const encrypted = crypto.TripleDES.encrypt(crypto.enc.Utf8.parse(msg),
    crypto.enc.Utf8.parse(newkeybyte),
    {
      mode: crypto.mode.ECB,
      padding: crypto.pad.Pkcs7,
    });
    const result = this.wordArrayToByteArray(encrypted.ciphertext, dteLength);
    const x = this.wordArrayToByteArray(crypto.enc.Utf8.parse(encrypted.toString()), dteLength);

    console.log(encrypted);
    return encrypted;
     }
</code></pre>

<p>C# Result</p>

<p><a href=""https://i.stack.imgur.com/Ev7l7.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Ev7l7.png"" alt=""enter image description here""></a></p>

<p>Javasctipt Result</p>

<p><a href=""https://i.stack.imgur.com/JgRCy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/JgRCy.png"" alt=""enter image description here""></a></p>

<p>Can you please show me how to do this right. I really appreciate it!</p>
","","23","<javascript><c#><cryptojs>","0","","0","2019-10-21 07:16:11","","3","","","","","2019-10-21 07:16:11",""
"58100913","Is it possible to generate key in CryptoJS same as generated by c# using PasswordDeriveBytes.GetBytes(Int32)","<p>I am trying to encrypt using cryptoJS. How can I implement</p>

<pre><code>var secretKey = new PasswordDeriveBytes(EncryptionKey, Salt);                
using (ICryptoTransform encryptor = rijndaelCipher.CreateEncryptor(secretKey.GetBytes(32), secretKey.GetBytes(16)))
</code></pre>

<p>I am trying to generate ""key"" and ""IV"" as below in cryptoJS</p>

<pre><code>var hasher = CryptoJS.algo.SHA1;
var key32Byte = CryptoJS.PBKDF2(enckey, salt, {
        keySize: 256 / 32,
        iterations: 100,
        hasher: hasher
    });

var iv = CryptoJS.PBKDF2(enckey, salt, {
        keySize: 128 / 32,
        iterations: 100,
        hasher: hasher
    });
</code></pre>

<p>I have matched the hex string of ""secretKey.GetBytes(32)"" by ""key32Byte"" and ""secretKey.GetBytes(16)"" by ""IV"" both are different.</p>

<p>Is there any equivalent method in JS for secretKey.GetBytes(32). As documentation says it randomize(pseudo-random) the bytes.</p>
","","23","<javascript><c#><angular><cryptojs><pbkdf2>","0","","0","2019-09-25 14:36:55","","0","","","","","2019-09-25 14:36:55",""
"57999434","Encryption with CryptoJS, equivalent using openssl command line","<p>I'm trying to reproduce an encryption done with CryptoJS with the openssl command line, but having a hard time doing so...</p>

<p>Here's the call to CryptoJS : <strong>CryptoJS.AES.encrypt(xml, ""Cl cryptage de la btlf"");
console.log(encrypted.toString()</strong></p>

<p>And here's the openssl command line I use : <strong>openssl enc -base64 -A -aes-256-cbc -pass pass:""Cl cryptage de la btlf"" -in Infile.xml -out Outfile.txt</strong></p>

<p>The result are not the same, and I tried to look at the code in JS of CryptoJS to find the default value used, but it seem's that I dont get it...
The result is OK though, a file with only one line in UTF-8.</p>

<p>Thanks for helping me !</p>
","","22","<node.js><encryption><openssl><cryptojs>","0","","0","2019-09-18 19:20:53","","1","","6004710","","2019-09-18 19:20:53","2019-09-18 19:13:39",""
"57605467","How to Decrypt JSON ( CryptoJS.AES Encryptrd ) with C# like CryptoJS.AES.decrypt","<p>I Have a Webservice that return Encrypted string. when i try to decrypt using  javascript CryptoJS
Like this: </p>

<pre><code>CryptoJS.AES.decrypt(""nqihq/xPpu8Fbcj3ws3eXnf+zBCDDCqYv+jZuGutXeKwsML4m1OpdfLCyhVxuZnowL"",'qtu18TIJtuiPYzc4ae5c6WsRTY',{format:CryptoJSAesJson}).tostring(CryptoJS.enc.Utf8)
</code></pre>

<p>It is working.</p>

<p>But Now i want to Decrypt this string Using C#.</p>

<p>How i can Decrypt it using C#</p>
","","22","<c#><encryption><cryptojs>","0","","0","2019-08-22 08:48:58","","0","","","","","2019-08-22 08:48:58",""
"53738684","Verifying a signature signed in javascript inside a Kotlin application","<p>I have a code that signs a payload in Javascript and I want to verify the Signaure on the same inside another application written in Kotlin. I am using the 'secp256k' library .I can sign it on the js side but verification fails on Kotlin side</p>
","<p>I solved the issue using jrassign library . the issue is due to the fact that keys are encoded differently in java and javascript. java follows ASN 1 standard while there appears to be no fixed standard in javascript</p>
","22","<kotlin><cryptojs>","-1","0","1","2019-09-24 06:27:52","","2","","","","","2018-12-12 08:14:30",""
"58185966","how to use crypto.createHmac in plane javascript, without importing require(crypto) library?","<p>I want to use the crypto library in-plane javascript without importing crypto from npm, is there any way to do this.</p>
","","21","<javascript><node.js><cryptojs>","0","","0","2019-10-01 13:35:02","","4","","","","","2019-10-01 13:35:02",""
"50326156","Display notice box when input wrong password to unlock content which is encrypted by Cryptojs","<p>I use Cryptojs to encrypt my text, and I use below code to decrypt:</p>

<pre><code> &lt;div id=""decrypt-box""&gt;
 &lt;div class=""decrypt-form"" id=""decryption"" data-href=""U2FsdGVkX1+Fg5XynZFlZHmhvMhAw9l7jlKt2WEpYYWEkOy7L360rZ7xd19TvoXp""&gt;
&lt;div&gt; password to unlock: asd&lt;/div&gt;
 &lt;form action=""#"" id=""decrypt-form"" method=""post""&gt;
&lt;input autofocus="""" id=""decrypt-password"" name=""password"" placeholder=""Password"" type=""password"" /&gt;

        &lt;input class=""decrypt-button"" type=""submit"" value=""Unlock"" /&gt;
    &lt;/form&gt;
&lt;div id=""decrypt-alert""&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id='decrypt-content'&gt;&lt;/div&gt;
&lt;script src=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/aes.js""&gt;&lt;/script&gt;
&lt;script&gt;
document.getElementById('decrypt-form').addEventListener('submit', function(e) {
    e.preventDefault();
var c=document.getElementById('decryption');
    var encryptedMsg=c.getAttribute('data-href'),
        passphrase = document.getElementById('decrypt-password').value,
        decrypted = CryptoJS.AES.decrypt(encryptedMsg, passphrase);
        decrypted = decrypted.toString(CryptoJS.enc.Utf8);                                    

        document.getElementById('decrypt-content').innerHTML = decrypted;    

});
&lt;/script&gt;
</code></pre>

<p><b> My question is:</b></p>

<p>How do I do to display notice box if I input wrong password.</p>

<p>Thanks.</p>
","","21","<encryption><cryptojs>","0","","0","2018-05-14 08:38:57","","6","","","","","2018-05-14 08:38:57",""
"58703801","How to avoid duplicate files and text in a NodeJs application?","<p><strong>I have the following use case -</strong><br>
1. Avoid duplicate files<br>
2. Avoid duplicate text code<br></p>

<p>I understand I need to calculate both the files and text codes into MD5 and maintain both into columns,<br>
which can be queried, to check if the same file or text code might already be there in the application.<br></p>

<p>I am trying to find the correct way to create MD5 Checksums in NodeJs,<br>
<strong>I found the following to be useful -</strong><br></p>

<pre><code>let crypto = require('crypto');
let md5CheckSum = crypto.createHash('md5').update(dataToConvert).digest(""hex"");
</code></pre>

<p><strong>I have the following queries -</strong><br></p>

<ol>
<li>Is calculating MD5 and MD5 Checksum the same thing?<br></li>
<li>Is the code creating just an MD5, or is it also creating the checksum of the <code>dataToConvert</code> string?<br>
if not how can I further create its checksum?<br></li>
<li>It is straightforward to pass text codes to the md5 function,<br>
In case of files, what conversion do I need to do?<br>
To be passed as an argument to the md5 checksum function?<br></li>
</ol>

<p><strong>Reference -</strong><br>
<a href=""https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm_options"" rel=""nofollow noreferrer"">https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm_options</a></p>
","<ol>
<li>yes</li>
<li>there is no such thing as ""an md5"", md5 checksums are cryptographic hashes <em>of some data</em>, so in this case that data is <code>dataToConvert</code>. No data, no md5.</li>
<li>you're in Node, have a look at <a href=""https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback"" rel=""nofollow noreferrer"">fs.readFile</a></li>
</ol>
","20","<node.js><md5><cryptojs>","0","0","1","2019-11-05 04:44:46","","0","","5433178","","2019-11-05 03:02:33","2019-11-05 02:51:30",""
"57941464","How to use Crypto JS AES component with only core file and not rollup?","<p>I am using two Crypto JS functions: <code>CryptoJS.AES</code> and <code>CryptoJS.enc.utf8</code>. My code works perfectly fine when I use the aes.js rollup, however, the rollups are minified and I can only use unobfuscated files. Only the component file isn't minified (core.js and aes.js). </p>

<p>I have tried to use the solutions detailed in this <a href=""https://stackoverflow.com/questions/42523928/how-to-get-cryptojs-to-work-with-out-rollup-files"">question</a>. I used require, but I got errors in the AES component file and my code said that AES didn't exist. I have also tried using only the aes file, but that didn't work either. If anybody can find the AES rollup in an unobfuscated form, that would also be helpful.</p>

<p><a href=""https://github.com/sytelus/CryptoJS"" rel=""nofollow noreferrer"">Here are the files for my CryptoJS version</a>. Any help is appreciated, and  I will answer your questions. Thanks a lot.</p>
","","20","<javascript><cryptojs>","1","","0","2019-09-15 05:38:20","","3","","","","","2019-09-15 05:38:20",""
"54092855","nodejs crypto sign dont provide the same result using the same input?","<p><br></p>

<p>I am trying to use nodejs crypto module for signing data, but I remarque that the signature changes every time I run the code, why ? </p>

<pre><code>const fs = require(""fs"");

const crypto = require('crypto');
const sign = crypto.createSign('SHA256');

const data = {
  name: ""myName"",
  age: 125,
  description:""This a long Description""
};

sign.write(JSON.stringify(data));
sign.end();

const privateKey = fs.readFileSync(""private.pem"", ""utf8"");
console.log(sign.sign(privateKey, 'base64'));
</code></pre>
","","20","<node.js><cryptojs>","0","","0","2019-01-08 13:27:22","","1","","","","","2019-01-08 13:27:22",""
"39544946","Translate/ReCode CryptoJS.AES code into PHP","<p>This is the code in javascript which for some straing reason I could not recode it in PHP</p>

<pre><code>function encrypt(b, a) {
    var c = CryptoJS.MD5(CryptoJS.enc.Utf8.parse(a));
    return CryptoJS.AES.encrypt(b, c, {
        mode: CryptoJS.mode.ECB,
        padding: CryptoJS.pad.Pkcs7
    }).toString()
}
</code></pre>

<p>UPDATED:
I tried this, But the output is not the same:
PHP</p>

<pre><code>$key = md5('SR0.08963341827756699');

$key_size =  strlen($key);
$plaintext = ""22222222"";

$iv_size = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
$iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);

$ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key,
                             $plaintext, MCRYPT_MODE_ECB, $iv);
echo base64_encode($ciphertext);
</code></pre>

<p><strong>JavaScript</strong></p>

<p>Input : <code>encrypt('22222222', 'SR0.08963341827756699')</code></p>

<p>Output: <code>RnN1WTGkZ9RKPQz3eBtivQ==</code></p>

<p><strong>PHP</strong></p>

<p>Input : string=<code>22222222</code>, key=<code>SR0.08963341827756699</code></p>

<p>Output: <code>ZA2pbDiSx3chj9/ubbUfOA==</code></p>
","","19","<javascript><php><encryption><aes><cryptojs>","0","","0","2016-09-17 10:19:09","","6","","4587492","","2016-09-17 10:19:09","2016-09-17 09:03:55","2016-09-17 10:30:50"
"57707030","Crypto-js configuration to decrypt an encrypted text through the logstash cipher filter","<p>I need to create a kibana custom plugin to decrypt some encrypted text which has been encrypted through the logstash cipher plugin, I am using the cryptor-js as the decipher from the kibana plugin's end (runs on a nodejs instance). However, I have passed in the same parameters at the encryption point and at the decryption point but cipher is not being able to decrypt the given encrypted text. </p>

<p>logstash configuration (Encryption point)</p>

<pre><code>input {
  stdin { }
}
filter{
  cipher {
        algorithm =&gt; ""aes-256-cbc""
        # cipher_padding =&gt; 1
        iv_random_length =&gt; 16

        key =&gt; ""35345353445342342344567890128731""
        key_size =&gt; 32
        mode =&gt; ""encrypt""
        source =&gt; ""host""
        target =&gt; ""host""
        base64 =&gt; true

        max_cipher_reuse =&gt; 100000
    }
}
output {
  stdout {
    codec =&gt; rubydebug
  }
}
</code></pre>

<p>CryptoJS configuration (Decryption point)</p>

<pre><code>const decrypt = (input) =&gt; {

    export const PRIVATE_KEY = ""35345353445342342344567890128731"";

    var iv = CryptoJS.lib.WordArray.random(16);
    var base64Key = CryptoJS.enc.Base64.parse(PRIVATE_KEY);
    var decrypted = CryptoJS.AES.decrypt(input, base64Key, {iv:iv,mode: CryptoJS.mode.CBC});

    return toString(decrypted);
};

export default decrypt;
</code></pre>

<p>Whenever, I input the encrypted text into the decrypt method, it returns an unidentified value. Do I have to encrypted text string into base64 as well ?</p>
","","19","<javascript><node.js><logstash><aes><cryptojs>","0","","0","2019-08-29 09:22:54","","0","","","","","2019-08-29 09:22:54",""
"56414744","Adding headers to fetch, solving cors, running cryptojs client side","<p>I'm working on a project where I need first to get a authentication token from a server. </p>

<p>For this I need to send a GET request to the authorisation server with two key-value pairs included in the header: 1/ the client id (const) and 2/ a HMAC SHA1 calculated value based on client ID timestamp and so on. </p>

<p>This is working fine with Postman. (I calculate the sha1 on an online calculator)</p>

<p>Problem 1: (cryptojs client side)
As a node app I included the cryptojs library and the calculation works. But even with RequireJS I can not get cryptojs to run in the browser.</p>

<pre><code>Error: Module name ""crypto-js"" has not been loaded yet for context: _. Use require([])
</code></pre>

<p>Problem 2: (cors)</p>

<p>Apparently chrome refuses the connection as the server does not accept all incoming connections.
Adding mode: 'no-cors' to the fetch request does not solve the problem. </p>

<p>Problem 3: (headers)</p>

<p>I need to add two key - value pairs to the get request headers. In postman this is no problem but I'm not sure this works with append or just adding them to my headers: { } </p>

<p>I constantly get a server error as if no headers where added. </p>

<p>I have already tried REquireJS for the cryptojs problem.</p>

<p>I have added the headers to a myHeaders object</p>

<pre><code>const myHeaders = new Headers();
myHeaders.append('ClientID', CLIENTID);
myHeaders.append('Clientsecret', hashedToken);
</code></pre>

<p>and also just added the values to: </p>

<pre><code>headers: {
...
'ClientID': CLIENTID,
'Clientsecret': hashedToken,
}
</code></pre>

<p>Both don't seem to help.</p>

<p>My code:</p>

<pre><code>function getToken(){

hashedToken = getHashedSecret();  //this won't work client side as    cryptojs can not be loaded
const CLIENTID = ""CLIENTID"";
const AUTHURL =  ""https://authorization.server.com/api/CLIENTID/authorization/"";
var TIMESTAMP = getTimeStamp();


const myHeaders = new Headers();
//  myHeaders.append('Content-Type', 'application/json');
myHeaders.append('ClientID', CLIENTID);
myHeaders.append('Clientsecret', hashedToken);
 console.log(myHeaders);
let response = fetch(AUTHURL+TIMESTAMP, {
  method: 'GET',
  headers: {
    myHeaders,
    'Accept': 'application/json',
    'Content-Type': 'application/json',
    'Origin': '',
    'Host': 'authorization.server.com',
    include: 'ClientID', CLIENTID

  },
  mode: 'no-cors',
 })
  .then(response =&gt; response.json())
  .then(data =&gt; {
    console.log(data);
    document.getElementById('output').innerHTML = data;
  })
  .catch(error =&gt; console.error(error))
console.log('data');
return data;
}
</code></pre>

<p>I should get a token from the server</p>
","<p>It sounds like <code>https://authorization.server.com</code> doesn't allow access from your page's origin. Remember that in browsers, the <a href=""http://en.wikipedia.org/wiki/Same_origin_policy"" rel=""nofollow noreferrer"">Same Origin Policy</a> prevents scripts from one origin from requesting information from other origins by default. (<code>postman</code>, not being a browser, is not subject to this restriction). This is so that scripts on Site A (a malicious actor) can't steal your personal information from Site B (perhaps your online banking) by making requests (from your browser, thus with your authentication information) to Site B.</p>

<p>For this to work, <strong>server</strong> code at <code>https://authorization.server.com</code> will need to respond to requests from the browser using the <a href=""http://www.w3.org/TR/access-control/"" rel=""nofollow noreferrer"">Cross-Origin Resource Sharing</a> to allow access from your origin. You <strong>cannot</strong> do it from your client-side code (for obvious reasons).</p>

<p>Alternately, you can run a server on your origin, make the requests to that server, and it can make the requests to <code>https://authorization.server.com</code> and pass back the responses to you. Your server, not being a browser, is not subject to the SOP.</p>
","19","<javascript><fetch><node-modules><cryptojs>","0","1","1","2019-06-02 11:58:04","","1","","","","","2019-06-02 11:52:56",""
"55843855","CryptoJs PBKDF2 Hashing causing browser freez","<p>I came across an issue when I have included a Hashing mechanism using PBKDF2 module in <a href=""https://www.npmjs.com/package/crypto-js"" rel=""nofollow noreferrer"">CryptoJs Library</a> and it caused the browser to get frozen (Both in Chrome and Firefox).<br>
This is the code sample of the implementation.</p>

<pre><code>const key = CryptoLib.PBKDF2(password, 'SALT', {
            keySize: 512 / 32,
            iterations: 100,
            hasher: CryptoLib.algo.SHA512,
        });
</code></pre>

<p>Previously I have using 10000 iterations for hashing but now I have reduced it to the 100 iterations but results are almost same.There for I wanted to know that,</p>

<ol>
<li>Why is my broswer getting frozen when the hashing starts and after hashing is finished browser operated normally.</li>
<li>As I know the broswers are single threaded is there a possible asynchronous approach to this.</li>
<li>What's the best approach in Angular 7 to handle this kind of costly processes.</li>
<li>Or is this is an issue with the library.</li>
</ol>

<p>I would be glad to know the reasons for this and to know if any one have faced the simmilar scenario.<br>
Thank you.</p>
","","19","<google-chrome><firefox><browser><cryptojs><pbkdf2>","0","","0","2019-04-25 07:19:54","","0","","","","","2019-04-25 07:19:54",""
"56066263","Java and JavaScript PBKDF2 length inconsistency","<p>I am trying to port some Java code to JavaScript. However, for some reason, I am getting inconsistent lengths. Something tells me the NodeJS library <code>crypto</code> doesn't work as expected.</p>

<p><strong>hash Java file</strong></p>

<pre><code>public class hash {
    public static void main(String[] args){
        try {
            String password = ""password1"";

            //random bytes (should be random)
            byte[] bArr = {0, 1, 2, 3, 4, 5, 6, 7};

            char[] salt = password.toCharArray();

            PBEKeySpec spec = new PBEKeySpec(salt, bArr, 100, 384);

            byte[] encoded = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"").generateSecret(spec).getEncoded();

            System.out.println(encoded.length);
        } catch(Exception e) {}
    }
}
</code></pre>

<p>The printed output is <code>48</code>, which makes sense because of <code>SHA-384</code>. However, my JavaScript code outputs an array with <code>384</code> elements.</p>

<p><strong>JavaScript file</strong></p>

<pre><code>const crypto = require(""crypto"");

const key = ""password1"";

let bArr = [0, 1, 2, 3, 4, 5, 6, 7];

//create the salt (.toCharArray() in Java)
const salt = key.split("""").join("","");

let encoded = crypto.pbkdf2Sync(key, Buffer.from(salt, ""hex""), 100, 384, ""sha1"");

console.log(encoded.length);
</code></pre>

<p>I'm not sure what I'm doing wrong here. I found a couple of places, where people were discussing how to create the PBKDF2 key, and it looks like this is how I'm supposed to. Also, <code>bArr</code> in my JavaScript example was not used.</p>

<p>I have tried converting both <code>encoded</code> variables into HEX to compare them, but the JavaScript one is much longer. Even if I shorten the key length to 48 (<code>384 -&gt; 48</code> in the <code>pbkdf2Sync()</code> method), it's still wrong.</p>
","","19","<javascript><java><cryptojs><pbkdf2>","0","","0","2019-05-09 19:21:52","","1","","","","","2019-05-09 19:21:52",""
"53104031","Need Help to fix this code to work with CrptoJs or OpenSSL commands","<p>Hi Esteemed member of StackOverflow,
I have a closed environment where I cannot use node js or any other language apart from OpenSSL or CrptoJs version of this crypto-Js Module.</p>

<p>My code is working in Node Js and I have attached the working version here.
Can anyone of you help me in getting a working version in OpenSSL or in CrptoJs?</p>

<pre><code>'use strict';
const crypto = require('crypto');

// The two keys gotten from Trustpilot
let encryptionKeyBase64 = 'JB+FsIQEMWjdhB/xLus/SpbaZje9wQQ785tECAsHzF4=';
let authenticationKeyBase64 = 'HFLYS943++xwKuj3qTypmB9F+pFzmNavccKJO+Mm2nY=';

// Our info to encrypt
let info = {
    ""email"":""xyz@domain.com"",
    ""name"":""John Smith"",
    ""ref"":""1234"",
    ""skus"":[""sku1"",""sku2"",""sku3""],
    ""tags"":[""tag1"",""tag2"",""tag3""]
};
let jsonSerializedOrder = JSON.stringify(info);

// When you get the keys from Trustpilot, they are base64 encoded, so first we need to decode them
let encryptionKey = Buffer.from(encryptionKeyBase64, 'base64');
console.log('encryptionKey'+encryptionKey);
let authenticationKey = Buffer.from(authenticationKeyBase64, 'base64');
console.log('authenticationKey'+authenticationKey);
// Generate a random initialization vector
let iv = crypto.randomBytes(16);
console.log('iv'+iv);
// Encrypt our order
let cipher = crypto.createCipheriv('aes-256-cbc', encryptionKey, iv);
console.log('cipher'+cipher);
let cipherText = Buffer.concat([cipher.update(jsonSerializedOrder, 'utf8'), cipher.final()]);
console.log('cipherText'+cipherText);
// Compute the HMAC
let hmac = crypto.createHmac('sha256', authenticationKey).update(Buffer.concat([iv, cipherText])).digest();
console.log('hmac'+hmac);
// Base64 encode the IV + cipherText + HMAC
let base64Payload = Buffer.concat([iv, cipherText, hmac]).toString(""base64"");
console.log('base64Payload'+base64Payload);
// URL encode to get the final payload
let payload = encodeURIComponent(base64Payload);


console.log(payload);
</code></pre>
","","18","<node.js><openssl><cryptojs>","0","","0","2018-11-01 15:09:51","","3","","","","","2018-11-01 15:09:51",""
"58002745","How to decrypt the key,iv and password encrypted by CryptoJS with Python","<h3>The encrypt code</h3>

<pre><code>var password = $(""#password_input"").val()
var key = CryptoJS.MD5(Math.random() + """").toString();

for (
    t = CryptoJS.AES.encrypt(password, key, 
        { mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.ZeroPadding}
    ),
        password_encode = t.ciphertext.toString(CryptoJS.enc.Base64); 

$(""#password_input"").val() != password_encode; )
$(""#password_input"").val(password_encode);
$(""#encrypt_iv"").val(t.iv.toString(CryptoJS.enc.Base64)),
$(""#encrypt_key"").val(t.key.toString(CryptoJS.enc.Base64))
</code></pre>

<h3>The encrypted data</h3>

<pre><code># the original password is 123456
'password':'YJukIxdk6KglzHVPfT3C8A==',
'encrypt_key':'LEbiyNapP8dIbaJ1VA7Iz3zBtk93ex8oB56+ei6yhGE=',
'encrypt_iv':'M79vpevBUppA5EtNy2mYBw=='
</code></pre>

<h3>What I need</h3>

<ol>
<li>If I got the above encrypted data in my Python Server, How I can know whether the password  is Right or not?</li>
<li>If I want to simulate the login action ,How I can get the same encrypted password?</li>
</ol>
","","17","<python><cryptojs>","0","","0","2019-09-19 02:15:38","","0","","6720040","","2019-09-19 02:15:38","2019-09-19 02:04:11",""
"57863230","Crypt-JS Encode possibly using createCipheriv?","<p>I'd be happy to send a few bucks to someone if they could help with a task I've been given.  I'm hoping I can use the Javascript library Crypto-JS and not the NodeJS version since I'll be using a client browser.</p>

<p>I need to include the correct scripts and perform the following:</p>

<p>The token will be constructed as a set of key=value pairs separated by a semicolon (;), the resultant string will be
encrypted with AES and a pre-shared secret key, the resultant output will then be converted into a string with HEX
character encoding.</p>

<p>The following AES cipher attributes should be used to construct the token:
- Rijndael cipher
- Electronic Code Book mode (ECB)
- No built in padding (such as PKCS)
- Resultant encrypted buffer should be manually padded with spaces to achieve the total length a multiple
of 32. That is: length(encrypted padded string) mod 32 = 0
For example, instantiate the cipher and initialize it using Java standard SunJCE cryptological library the code would
contain: Cipher cipher = Cipher.getInstance(""Rijndael/ECB/NoPadding"", ""SunJCE"");</p>

<p>I've found some code that I thought was getting me close, but I can't figure out which script to include so that createCipheriv is available.</p>

<pre><code>function encrypt(data,key) {
    var cipher = crypto.createCipheriv('aes-128-ecb', key,''); //create aes-128 cipher 
    var encrypted = cipher.update(data,'utf8', 'hex'); //output as hex
    return encrypted;
}

function padRightTo32(str) { // ensure block size of 32

    len=str.length;
    for(i=len; i%32&gt;0; i++) {
        str=str +"" "";
    }
    return str;
}
</code></pre>
","","16","<cryptojs>","0","","0","2019-09-10 02:22:34","","0","","","","","2019-09-10 02:22:34",""
"56190222","How to convert Node.js crypto's MD5 method to crypto-js?","<p>I need to convert the following <a href=""https://nodejs.org/api/crypto.html"" rel=""nofollow noreferrer"">Node.js crypto</a> call to web-browser using the <a href=""https://github.com/brix/crypto-js"" rel=""nofollow noreferrer"">crypto-js library</a> and TypeScript:</p>

<pre><code>let final = crypto.createHash('md5').update(password + salt, 'ascii').digest('binary');
</code></pre>

<p>Here is what I got so far:</p>

<pre><code>import { MD5, enc } from 'crypto-js';
let final = MD5(password + salt).toString(enc.Latin1);
</code></pre>

<p>I do not know how I can convert the ""ASCII"" part of <code>password + salt</code>. Am I missing something ?</p>
","","16","<javascript><node.js><cryptojs>","0","","0","2019-05-17 16:21:37","","0","","","","","2019-05-17 16:21:37",""
"57802131","Can we generate public key from ethereum public address?","<p>I know how to generate ethereum public address from public key or from private key.
But i was wondering if we can generate the public key from ethereum public address?</p>
","","14","<ethereum><cryptojs><pki>","0","","0","2019-09-05 09:11:53","","1","","","","","2019-09-05 09:11:53",""
"57154756","Digital signing and verifying using prime256v1 in Node","<p>I want to generate digital signatures in Node using ECDSA (prime256v1 curve) 
The private key is generated with this OpenSSL command:</p>

<pre><code>$ openssl ecparam -name prime256v1 -genkey -out private_key.pem
</code></pre>

<p>Would the following be the correct Node code to sign a message:</p>

<pre><code>import crypto from 'crypto'

const sign = (privateKey, messageString) =&gt; {
  const buffer = Buffer.from(messageString, 'utf8')
  const signature = crypto.sign('sha256', buffer, privateKey)
  return signature.toString('base64')
}
</code></pre>
","","13","<node.js><openssl><cryptojs><ecdsa>","0","","0","2019-07-22 23:04:35","","0","","","","","2019-07-22 23:04:35",""
"58455569","CryptoJS and AWS signing key version 4 generation not working","<p>According to <a href=""https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html"" rel=""nofollow noreferrer"">AWS docs</a> running the following the command should provide the expected results below, but it actually returns a completely different string.</p>

<pre><code>crypto.HmacSHA256('AWS4-HMAC-SHA256\n20150830T123600Z\n20150830/us-east-1/iam/aws4_request\nf536975d06c0309214f805bb90ccff089219ecd68b2577efef23edd43b7e1a59', 'c4afb1cc5771d871763a393e44b703571b55cc28424d1a5e86da6ed3c154a4b9');
</code></pre>

<p><br></p>

<h1>Expected Result according to docs</h1>

<p><code>5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7</code></p>

<h1>Actual Results</h1>

<p><code>fe52b221b5173b501c9863cec59554224072ca34c1c827ec5fb8a257f97637b1</code></p>
","","10","<javascript><node.js><amazon-web-services><cryptojs><aws4c>","0","","0","2019-10-18 17:25:05","","0","","","","","2019-10-18 17:25:05",""
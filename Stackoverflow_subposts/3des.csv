post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"20227","How do I use 3DES encryption/decryption in Java?","<p>Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?</p>

<p>I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:</p>

<p>** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.</p>

<pre><code>public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}
</code></pre>
","<p>Your code was fine except for the Base 64 encoding bit (which you mentioned was a test), the reason the output may not have made sense is that you were displaying a raw byte array (doing toString() on a byte array returns its internal Java reference, not the String representation of the <strong>contents</strong>). Here's a version that's just a teeny bit cleaned up and which prints ""kyle boon"" as the decoded string:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDESTest {

    public static void main(String[] args) throws Exception {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""kyle boon""
    }

    public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>
","161701","<java><encryption><3des>","69","64","5","2017-07-01 01:10:44","20670","0","43","608639","Kyle Boon","2017-07-01 01:10:44","2008-08-21 15:25:22",""
"20227","How do I use 3DES encryption/decryption in Java?","<p>Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?</p>

<p>I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:</p>

<p>** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.</p>

<pre><code>public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}
</code></pre>
","<p>I had hard times figuring it out myself and this post helped me to find the right answer for my case. When working with financial messaging as ISO-8583 the 3DES requirements are quite specific, so for my especial case the ""DESede/CBC/PKCS5Padding"" combinations wasn't solving the problem. After some comparative testing of my results against some 3DES calculators designed for the financial world I found the the value ""DESede/ECB/Nopadding"" is more suited for the the specific task.</p>

<p>Here is a demo implementation of my TripleDes class (using the Bouncy Castle provider)</p>

<pre><code>

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.NoSuchProviderException;
    import java.security.Security;
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;
    import org.bouncycastle.jce.provider.BouncyCastleProvider;


    /**
     *
     * @author Jose Luis Montes de Oca
     */
    public class TripleDesCipher {
       private static String TRIPLE_DES_TRANSFORMATION = ""DESede/ECB/Nopadding"";
       private static String ALGORITHM = ""DESede"";
       private static String BOUNCY_CASTLE_PROVIDER = ""BC"";
       private Cipher encrypter;
       private Cipher decrypter;

       public TripleDesCipher(byte[] key) throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException,
             InvalidKeyException {
          Security.addProvider(new BouncyCastleProvider());
          SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
          encrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION, BOUNCY_CASTLE_PROVIDER);
          encrypter.init(Cipher.ENCRYPT_MODE, keySpec);
          decrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION, BOUNCY_CASTLE_PROVIDER);
          decrypter.init(Cipher.DECRYPT_MODE, keySpec);
       }

       public byte[] encode(byte[] input) throws IllegalBlockSizeException, BadPaddingException {
          return encrypter.doFinal(input);
       }

       public byte[] decode(byte[] input) throws IllegalBlockSizeException, BadPaddingException {
          return decrypter.doFinal(input);
       }
    }

</code></pre>
","161701","<java><encryption><3des>","69","11","5","2017-07-01 01:10:44","20670","0","43","608639","Kyle Boon","2017-07-01 01:10:44","2008-08-21 15:25:22",""
"20227","How do I use 3DES encryption/decryption in Java?","<p>Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?</p>

<p>I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:</p>

<p>** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.</p>

<pre><code>public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}
</code></pre>
","<p>Here's a very simply static encrypt/decrypt class biased on the Bouncy Castle no padding example by Jose Luis Montes de Oca.  This one is using ""DESede/ECB/PKCS7Padding"" so I don't have to bother manually padding.</p>

<pre><code>
    package com.zenimax.encryption;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.NoSuchProviderException;
    import java.security.Security;
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;
    import org.bouncycastle.jce.provider.BouncyCastleProvider;

    /**
     * 
     * @author Matthew H. Wagner
     */
    public class TripleDesBouncyCastle {
        private static String TRIPLE_DES_TRANSFORMATION = ""DESede/ECB/PKCS7Padding"";
        private static String ALGORITHM = ""DESede"";
        private static String BOUNCY_CASTLE_PROVIDER = ""BC"";

        private static void init()
        {
            Security.addProvider(new BouncyCastleProvider());
        }

        public static byte[] encode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher encrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            encrypter.init(Cipher.ENCRYPT_MODE, keySpec);
            return encrypter.doFinal(input);
        }

        public static byte[] decode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher decrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            decrypter.init(Cipher.DECRYPT_MODE, keySpec);
            return decrypter.doFinal(input);
        }
    }
</code>
</pre>
","161701","<java><encryption><3des>","69","3","5","2017-07-01 01:10:44","20670","0","43","608639","Kyle Boon","2017-07-01 01:10:44","2008-08-21 15:25:22",""
"20227","How do I use 3DES encryption/decryption in Java?","<p>Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?</p>

<p>I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:</p>

<p>** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.</p>

<pre><code>public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}
</code></pre>
","<p>Here is a solution using the <strong>javax.crypto</strong> library and the apache commons codec library for encoding and decoding in Base64: </p>

<pre><code>import java.security.spec.KeySpec;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import org.apache.commons.codec.binary.Base64;

public class TrippleDes {

    private static final String UNICODE_FORMAT = ""UTF8"";
    public static final String DESEDE_ENCRYPTION_SCHEME = ""DESede"";
    private KeySpec ks;
    private SecretKeyFactory skf;
    private Cipher cipher;
    byte[] arrayBytes;
    private String myEncryptionKey;
    private String myEncryptionScheme;
    SecretKey key;

    public TrippleDes() throws Exception {
        myEncryptionKey = ""ThisIsSpartaThisIsSparta"";
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        arrayBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        ks = new DESedeKeySpec(arrayBytes);
        skf = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = skf.generateSecret(ks);
    }


    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }


    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] encryptedText = Base64.decodeBase64(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= new String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }


    public static void main(String args []) throws Exception
    {
        TrippleDes td= new TrippleDes();

        String target=""imparator"";
        String encrypted=td.encrypt(target);
        String decrypted=td.decrypt(encrypted);

        System.out.println(""String To Encrypt: ""+ target);
        System.out.println(""Encrypted String:"" + encrypted);
        System.out.println(""Decrypted String:"" + decrypted);

    }

}
</code></pre>

<p>Running the above program results with the following output: </p>

<pre><code>String To Encrypt: imparator
Encrypted String:FdBNaYWfjpWN9eYghMpbRA==
Decrypted String:imparator
</code></pre>
","161701","<java><encryption><3des>","69","17","5","2017-07-01 01:10:44","20670","0","43","608639","Kyle Boon","2017-07-01 01:10:44","2008-08-21 15:25:22",""
"20227","How do I use 3DES encryption/decryption in Java?","<p>Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?</p>

<p>I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:</p>

<p>** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.</p>

<pre><code>public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j &lt; 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}
</code></pre>
","<pre><code>import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.util.Base64;
import java.util.Base64.Encoder;


/**
 * 
 * @author shivshankar pal
 * 
 *         this code is working properly. doing proper encription and decription
           note:- it will work only with jdk8

 * 

 * 
 */

public class TDes {
    private static byte[] key = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
            0x02, 0x02, 0x02, 0x02, 0x02, 0x02 };

    private static byte[] keyiv = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00 };



     public static String encode(String args) {


        System.out.println(""plain data==&gt;  "" + args);

        byte[] encoding;
        try {
            encoding = Base64.getEncoder().encode(args.getBytes(""UTF-8""));

        System.out.println(""Base64.encodeBase64==&gt;"" + new String(encoding));
        byte[] str5 = des3EncodeCBC(key, keyiv, encoding);

        System.out.println(""des3EncodeCBC==&gt;  "" + new String(str5));

        byte[] encoding1 = Base64.getEncoder().encode(str5);
        System.out.println(""Base64.encodeBase64==&gt; "" + new String(encoding1));
        return new String(encoding1);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return null;
    }


    public static String decode(String args) {
        try {
            System.out.println(""encrypted data==&gt;"" + new String(args.getBytes(""UTF-8"")));


        byte[] decode = Base64.getDecoder().decode(args.getBytes(""UTF-8""));
        System.out.println(""Base64.decodeBase64(main encription)==&gt;"" + new String(decode));

        byte[] str6 = des3DecodeCBC(key, keyiv, decode);
        System.out.println(""des3DecodeCBC==&gt;"" + new String(str6));
        String data=new String(str6);
        byte[] decode1 = Base64.getDecoder().decode(data.trim().getBytes(""UTF-8""));
        System.out.println(""plaintext==&gt;  "" + new String(decode1));
        return new String(decode1);
        } catch (UnsupportedEncodingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return ""u mistaken in try block"";

        }



    private static byte[] des3EncodeCBC(byte[] key, byte[] keyiv, byte[] data) {
        try {
            Key deskey = null;
            DESedeKeySpec spec = new DESedeKeySpec(key);
            SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""desede"");
            deskey = keyfactory.generateSecret(spec);

            Cipher cipher = Cipher.getInstance(""desede/ CBC/PKCS5Padding"");
            IvParameterSpec ips = new IvParameterSpec(keyiv);
            cipher.init(Cipher.ENCRYPT_MODE, deskey, ips);
            byte[] bout = cipher.doFinal(data);
            return bout;

        } catch (Exception e) {
            System.out.println(""methods qualified name"" + e);
        }
        return null;

    }

    private static byte[] des3DecodeCBC(byte[] key, byte[] keyiv, byte[] data) {
        try {
            Key deskey = null;
            DESedeKeySpec spec = new DESedeKeySpec(key);
            SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""desede"");
            deskey = keyfactory.generateSecret(spec);

            Cipher cipher = Cipher.getInstance(""desede/ CBC/NoPadding"");//PKCS5Padding NoPadding
            IvParameterSpec ips = new IvParameterSpec(keyiv);
            cipher.init(Cipher.DECRYPT_MODE, deskey, ips);

            byte[] bout = cipher.doFinal(data);


            return bout;

        } catch (Exception e) {
            System.out.println(""methods qualified name"" + e);
        }

        return null;

    }

}
</code></pre>
","161701","<java><encryption><3des>","69","1","5","2017-07-01 01:10:44","20670","0","43","608639","Kyle Boon","2017-07-01 01:10:44","2008-08-21 15:25:22",""
"5632211","3DES Key Size Matter in C#.Net","<p><p>Below Code is Working Fine in c#.NET</P></p>

<pre><code>byte[] key = Encoding.ASCII.GetByte(""012345678901234567890123""); //24characters        
byte[] plainText = Encoding.ASCII.GetBytes(""lasaa""); 
TripleDES des = TripleDES.Create();
des.Key = key;
des.Mode = CipherMode.CBC;
ICryptoTransform ic = des.CreateEncryptor();
byte[] enc = ic.TransformFinalBlock(plainText, 0, plainText.Length);
MessageBox.Show(UTF8Encoding.UTF8.GetString(enc));
</code></pre>

<p>My questions regarding above are...</p>

<ol>
<li>How can I specify KeySize? if i use <code>des.KeySize=</code> <code>128</code> or <code>192</code> or <code>256</code> it gives</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<ol>
<li>If I change character length in key by adding more (ex:40 chars). It gives error</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<p>I want to know why is this happen?</p>
","<p>The key size for <a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">TripleDES</a> is 168 bits. So you'll need 21 bytes. If you want to use a string for the key you really should hash it first. In which case you can use any length of characters (the more the better) and then trim the hashed output to your key size. E.g. if you use <a href=""http://en.wikipedia.org/wiki/SHA-2"" rel=""nofollow"">SHA-256</a> from which you'll get 32 bytes, use 21 of them.</p>
","46508","<c#><encryption><3des>","19","4","4","2015-05-07 22:56:12","5634691","1","4","542251","","2014-05-02 13:35:03","2011-04-12 08:11:47",""
"5632211","3DES Key Size Matter in C#.Net","<p><p>Below Code is Working Fine in c#.NET</P></p>

<pre><code>byte[] key = Encoding.ASCII.GetByte(""012345678901234567890123""); //24characters        
byte[] plainText = Encoding.ASCII.GetBytes(""lasaa""); 
TripleDES des = TripleDES.Create();
des.Key = key;
des.Mode = CipherMode.CBC;
ICryptoTransform ic = des.CreateEncryptor();
byte[] enc = ic.TransformFinalBlock(plainText, 0, plainText.Length);
MessageBox.Show(UTF8Encoding.UTF8.GetString(enc));
</code></pre>

<p>My questions regarding above are...</p>

<ol>
<li>How can I specify KeySize? if i use <code>des.KeySize=</code> <code>128</code> or <code>192</code> or <code>256</code> it gives</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<ol>
<li>If I change character length in key by adding more (ex:40 chars). It gives error</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<p>I want to know why is this happen?</p>
","<p>I think the problem here is that 192bits is the maximum key size supported for 3DES in C# (and elsewhere I assume)</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.legalkeysizes.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgori...</a></p>

<p>Have you tryed setting the key to a 16 byte/char value?</p>

<p>The only other supported size seems to be 128bits. If you want somthing stronger you'll have to use a different algorithm, Aes/Rijndael.</p>

<p>If you look TDES up on <a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">Wikipedia</a>, it seems the maximum key size is 168bits so I'm not sure how Microsoft have implemented it.</p>

<p>I suspect it was omitted from your example for brevity but you should probably hash your key from a good dose of salt. There are several RNG/HSH algorithms for this in the crypto namespace. </p>
","46508","<c#><encryption><3des>","19","0","4","2015-05-07 22:56:12","5634691","1","4","542251","","2014-05-02 13:35:03","2011-04-12 08:11:47",""
"5632211","3DES Key Size Matter in C#.Net","<p><p>Below Code is Working Fine in c#.NET</P></p>

<pre><code>byte[] key = Encoding.ASCII.GetByte(""012345678901234567890123""); //24characters        
byte[] plainText = Encoding.ASCII.GetBytes(""lasaa""); 
TripleDES des = TripleDES.Create();
des.Key = key;
des.Mode = CipherMode.CBC;
ICryptoTransform ic = des.CreateEncryptor();
byte[] enc = ic.TransformFinalBlock(plainText, 0, plainText.Length);
MessageBox.Show(UTF8Encoding.UTF8.GetString(enc));
</code></pre>

<p>My questions regarding above are...</p>

<ol>
<li>How can I specify KeySize? if i use <code>des.KeySize=</code> <code>128</code> or <code>192</code> or <code>256</code> it gives</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<ol>
<li>If I change character length in key by adding more (ex:40 chars). It gives error</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<p>I want to know why is this happen?</p>
","<p>A 3DES key has length 128 or 192 bits. Note that, <em>internally</em>, the algorithm will use only 112 (respectively 168) bits out of those 128 (respectively 192) bits; however, the key itself, as encoded into bytes, stored and exchanged, must have length 16 or 24 bytes. Trying to set a key which does not have one of those two lengths triggers an error, which you observe when you try to use a 40-byte key.</p>

<p>You should not try to set the ""key size"": you already decide that when you set the key. When you set the <code>TripleDES.Key</code> property, the <code>TripleDES</code> class sees that you give it a 24-byte key, and thus will set itself the <code>KeySize</code> property to 192.</p>

<p>(The output of 3DES encryption is binary, not UTF-8 encoding of a string. Chances are that your final <code>UTF8Encoding.UTF8.GetString(enc)</code> will protest.)</p>
","46508","<c#><encryption><3des>","19","26","4","2015-05-07 22:56:12","5634691","1","4","542251","","2014-05-02 13:35:03","2011-04-12 08:11:47",""
"5632211","3DES Key Size Matter in C#.Net","<p><p>Below Code is Working Fine in c#.NET</P></p>

<pre><code>byte[] key = Encoding.ASCII.GetByte(""012345678901234567890123""); //24characters        
byte[] plainText = Encoding.ASCII.GetBytes(""lasaa""); 
TripleDES des = TripleDES.Create();
des.Key = key;
des.Mode = CipherMode.CBC;
ICryptoTransform ic = des.CreateEncryptor();
byte[] enc = ic.TransformFinalBlock(plainText, 0, plainText.Length);
MessageBox.Show(UTF8Encoding.UTF8.GetString(enc));
</code></pre>

<p>My questions regarding above are...</p>

<ol>
<li>How can I specify KeySize? if i use <code>des.KeySize=</code> <code>128</code> or <code>192</code> or <code>256</code> it gives</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<ol>
<li>If I change character length in key by adding more (ex:40 chars). It gives error</li>
</ol>

<blockquote>
  <p>Specified key is not a valid size for this algorithm</p>
</blockquote>

<p>I want to know why is this happen?</p>
","<p>Here is some code that I used to accomplish this ""trim""</p>

<pre><code>byte[] keyArray;
SHA512CryptoServiceProvider hash = new SHA512CryptoServiceProvider();
keyArray = hash.ComputeHash(UTF8Encoding.UTF8.GetBytes(""someProperlySaltedKey""));
byte[] trimmedBytes = new byte[24];
Buffer.BlockCopy(keyArray, 0, trimmedBytes, 0, 24);
keyArray = trimmedBytes;
TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
tdes.Key = keyArray;
</code></pre>
","46508","<c#><encryption><3des>","19","1","4","2015-05-07 22:56:12","5634691","1","4","542251","","2014-05-02 13:35:03","2011-04-12 08:11:47",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>The <a href=""http://www.openssl.org/"" rel=""nofollow noreferrer"">OpenSSL</a> library provides reliable source code for 3DES and many other cryptographic algorithms. The <a href=""http://www.openssl.org/docs/crypto/des.html#"" rel=""nofollow noreferrer"">libcrypto documentaton on the DES_*</a> functions describes what is available.</p>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>I'll bet some banking cards in fact use triple des. It is remarkable how running a business ( in the real world ) diverges from what one would think just from studying the problem. Just interested or is there an actual challenge at hand? ( be it study assignment or otherwise )</p>
","18952","<des><3des>","9","0","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>Triple-DES is still in use today but is widely considered a legacy encryption algorithm. DES is inherently insecure, while Triple-DES has much better security characteristics but is still considered problematic.</p>

<p>NIST is the government organization that standardizes on cryptographic algorithms. The most current symmetric-key encryption algorithm NIST standard is AES, the Advanced Encryption Standard. In fact, there were a number of good nominations to be NIST's AES, including the Rijndael algorithm which became AES, as well as Bruce Schneier's Blowfish, the Twofish algorithm, and the Serpent algorithm.</p>
","18952","<des><3des>","9","12","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>EDIT: @David Koontz replied to this post, and I had a chance to look 5 years into the past. I'm leaving my post intact below, but for anyone reading this now, avoid 3DES if you have the opportunity, and if not, get an expert to look at your specific system. There's no guarantee that a general answer will apply to your situation, in computer security especially.</p>

<p>Yes.</p>

<p>3DES is broken, but when a cryptographer says ""broken,"" that means something very specific: that an attacker can break the key in better-than-brute-force time. 3DES has a key length of 168 bits, which is reduced to 112 bits by some meet-in-the-middle attack cleverness. And, to quote Wikipedia, ""it is designated by NIST to have only 80 bits of security.""</p>

<p>It's pretty badly broken, but even so, 80 bits makes for a very big number; 3DES is plenty good for beating people with fewer resources than the NSA, for example, and it will be for maybe 10 or 15 years, with some luck. The incentive to replace 3DES it isn't high enough for a lot of people who aren't using it to protect expensive things.</p>
","18952","<des><3des>","9","10","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>You are right about banking. But everything happens in hardware level. One popular technology is <a href=""http://iss.thalesgroup.com/Products/Hardware%20Security%20Modules/HSM%208000.aspx#fragment-3"" rel=""nofollow noreferrer"">HSM</a>.</p>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>To answer your question of where 3DES is being used, I would like to add that Microsoft OneNote, Microsoft Outlook 2007 and Microsoft System Center Configuration Manager 2012 use Triple DES to password protect user content and system data.</p>

<p>See also:<br></p>

<ol>
<li>1.<a href=""http://blogs.msdn.com/descapa/archive/2006/11/09/encryption-for-password-protected-sections.aspx"" rel=""nofollow"">Daniel Escapa's OneNote Blog - Encryption for Password Protected Sections, November 2006</a></li>
<li><a href=""http://technet.microsoft.com/en-us/library/hh427327.aspx"" rel=""nofollow"">Microsoft TechNet product documentation - Technical Reference for Cryptographic Controls Used in Configuration Manager, October 2012</a></li>
</ol>
","18952","<des><3des>","9","1","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1619212","Is DES or 3DES still being used today?","<p>I've written a DES implementation as an exercice and am now wondering if and where (triple-)DES is used today.</p>

<p>I've read about banking cards using it, but I can't find any reliable source for it.</p>
","<p>3DES has a Problem described already in two CVE Issues
which is called the SWEET32 Issue. Its base Cipher Dephth is 64Bit (though used along three Rounds) so it belongs to a Family of originally weak Ciphers as well
From today's Standpoint of Security in 2017 and its probability to be broken
more often and more easily, is should no longer be used.</p>
","18952","<des><3des>","9","0","7","2017-07-24 15:20:43","1619237","3","4","17651","","2009-10-24 21:42:09","2009-10-24 21:35:38",""
"1645747","How do I encrypt/decrypt a string of text using 3DES in java?","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a>  </p>
</blockquote>



<p>How do I encrypt/decrypt a string of text using 3DES in java?</p>

<hr>

<p>I found my answer. Duplicate question that didn't show up when I asked this one.</p>

<p><a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>
","<p>From an old code:</p>

<pre><code>    public void testSymCypher(SecretKey k, String str)
        throws BadPaddingException, IllegalBlockSizeException,
        InvalidAlgorithmParameterException, InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException
{
    Cipher cip = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cip.init(Cipher.ENCRYPT_MODE,k);
    byte[] ciphered = cip.doFinal(str.getBytes());
    byte iv[] = cip.getIV();

    // printing the ciphered string
    printHexadecimal(ciphered);

    IvParameterSpec dps = new IvParameterSpec(iv);
    cip.init(Cipher.DECRYPT_MODE,k,dps);
    byte[] deciphered = cip.doFinal(ciphered);

    // printing the deciphered string
    printHexadecimal(deciphered);
}
</code></pre>

<p>Notice than other usage of DESede are available in Java JDK 6:</p>

<ul>
<li>DESede/CBC/NoPadding (168)</li>
<li>DESede/CBC/PKCS5Padding (168)</li>
</ul>

<p>There is also ECB mode available (but be carreful to not use it twice !!), you don't need to use iv part in this case:</p>

<ul>
<li>DESede/ECB/NoPadding (168)</li>
<li>DESede/ECB/PKCS5Padding (168) </li>
</ul>

<p>To generate key for DESede:</p>

<pre><code>    KeyGenerator generatorDes = KeyGenerator.getInstance(""DESede"");
    SecretKey skaes = generatorDes.generateKey();
</code></pre>

<p>Finally I recommand reading <a href=""http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html"" rel=""nofollow noreferrer"" title=""Java ™ Cryptography Architecture (JCA) Reference Guide"">this document</a> from SUN if you need to work on Java and Cryptography</p>
","16082","<java><encryption><3des>","0","2","4","2011-08-30 01:14:03","","0","3","-1","","2017-05-23 12:34:48","2009-10-29 18:41:40","2011-08-30 01:15:27"
"1645747","How do I encrypt/decrypt a string of text using 3DES in java?","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a>  </p>
</blockquote>



<p>How do I encrypt/decrypt a string of text using 3DES in java?</p>

<hr>

<p>I found my answer. Duplicate question that didn't show up when I asked this one.</p>

<p><a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>
","<p>We use this little helper class for password-based DES encryption from String to Hex String and back - not sure how to get this working with 3DES though:</p>

<pre><code>import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

public class DesHelper {
    private static org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(DesHelper.class);

    static final byte[] SALT = { (byte) 0x09, /* snip - randomly chosen but static salt*/ };
    static final int ITERATIONS = 11;

    private Cipher _ecipher;
    private Cipher _dcipher;

    public DesHelper(final String passphrase) {
        try {
            final PBEParameterSpec params = new PBEParameterSpec(SALT, ITERATIONS);

            final KeySpec keySpec = new PBEKeySpec(passphrase.toCharArray());
            final SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"")
                    .generateSecret(keySpec);

            _ecipher = Cipher.getInstance(key.getAlgorithm());
            _dcipher = Cipher.getInstance(key.getAlgorithm());
            _ecipher.init(Cipher.ENCRYPT_MODE, key, params);
            _dcipher.init(Cipher.DECRYPT_MODE, key, params);

        } catch (final Exception e) {
            throw new RuntimeException(e);
        }
    }

    public String encrypt(final String string) {
        try {
            // Encode the string into bytes using utf-8
            final byte[] bytes = string.getBytes(""UTF-8"");

            // Encrypt
            final byte[] enc = _ecipher.doFinal(bytes);

            // Encode bytes to base64 to get a string
            return bytesToHex(enc);
        } catch (final Exception e) {
            throw new RuntimeException(e);
        }
    }

    public String decrypt(final String str) {
        try {
            // Decode base64 to get bytes
            final byte[] dec = hexToBytes(str);

            // Decrypt
            final byte[] utf8 = _dcipher.doFinal(dec);

            // Decode using utf-8
            return new String(utf8, ""UTF8"");
        } catch (final Exception e) {
            log.info(""decrypting string failed: "" + str + "" ("" + e.getMessage() + "")"");
            return null;
        }
    }

    private static String bytesToHex(final byte[] bytes) {
        final StringBuilder buf = new StringBuilder(bytes.length * 2);
        for (final byte b : bytes) {
            final String hex = Integer.toHexString(0xff &amp; b);
            if (hex.length() == 1) {
                buf.append(""0"");
            }
            buf.append(hex);
        }
        return buf.toString();
    }

    private static byte[] hexToBytes(final String hex) {
        final byte[] bytes = new byte[hex.length() / 2];
        for (int i = 0; i &lt; bytes.length; i++) {
            bytes[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2), 16);
        }
        return bytes;
    }
}
</code></pre>

<p>You would use this class like this:</p>

<pre><code>public static void main(final String[] args) {
    final DesHelper h = new DesHelper(""blabla"");
    System.out.println(h.decrypt(h.encrypt(""foobar"")));
}
</code></pre>
","16082","<java><encryption><3des>","0","1","4","2011-08-30 01:14:03","","0","3","-1","","2017-05-23 12:34:48","2009-10-29 18:41:40","2011-08-30 01:15:27"
"1645747","How do I encrypt/decrypt a string of text using 3DES in java?","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a>  </p>
</blockquote>



<p>How do I encrypt/decrypt a string of text using 3DES in java?</p>

<hr>

<p>I found my answer. Duplicate question that didn't show up when I asked this one.</p>

<p><a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>
","<p>I wrote an article on this sometimes back. Please visit the following link in my blog that has a working, completed code with explanations and diagram.</p>

<p><a href=""http://sanjaal.com/java/2009/06/19/tutorial-encryption-and-decryption-using-desede-triple-des-in-java/"" rel=""nofollow noreferrer"">View My Triple DES Encryption Article, Code Here</a></p>

<p>Hopefully you will find it helpful.</p>
","16082","<java><encryption><3des>","0","0","4","2011-08-30 01:14:03","","0","3","-1","","2017-05-23 12:34:48","2009-10-29 18:41:40","2011-08-30 01:15:27"
"1645747","How do I encrypt/decrypt a string of text using 3DES in java?","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a>  </p>
</blockquote>



<p>How do I encrypt/decrypt a string of text using 3DES in java?</p>

<hr>

<p>I found my answer. Duplicate question that didn't show up when I asked this one.</p>

<p><a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">How do I use 3des encryption/decryption in Java?</a></p>
","<p>You may also consider using a stream cipher (e.g., OFB or CTR mode on top of a 3DES block encryption), so that you don't have to deal with padding the string to a multiple of the cipher blocksize.</p>
","16082","<java><encryption><3des>","0","0","4","2011-08-30 01:14:03","","0","3","-1","","2017-05-23 12:34:48","2009-10-29 18:41:40","2011-08-30 01:15:27"
"1400830",".NET TripleDESCryptoServiceProvider equivalent in Java","<p>Please, just don't ask me why. I just have this code in .NET that encrypt/decrypt strings of data. I need now to make 'exactly' the same funcionality in java. I have tried several examples for DESede crypt, but none of them gives the same results as this class in .net.</p>

<p>I even though on making a .net webserbvice behind ssl to serve this two methods writen in .net but it is just too stupid to do without exhausting all the posibilities.</p>

<p>Maybe some of you java people which are more related in the area will have on top of your heads how to make it.</p>

<p>Thanks !!!</p>

<pre><code>public class Encryption
{
  private static byte[] sharedkey = {...};
  private static byte[] sharedvector = {...};

  public static String Decrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toDecrypt = Convert.FromBase64String(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateDecryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);

    cs.Write(toDecrypt, 0, toDecrypt.Length);
    cs.FlushFinalBlock();
    return Encoding.UTF8.GetString(ms.ToArray());
  }

  public static String Encrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toEncrypt = Encoding.UTF8.GetBytes(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);
    cs.Write(toEncrypt, 0, toEncrypt.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
  }
}
</code></pre>

<hr>

<h2>Samle input/output</h2>

<pre><code>String plain = ""userNameHere:passwordHere"";
Console.WriteLine(""plain: "" + plain);


String encrypted = Encrypt(plain);
Console.WriteLine(""encrypted: "" + encrypted);
// ""zQPZgQHpjxR+41Bc6+2Bvqo7+pQAxBBVN+0V1tRXcOc=""

String decripted = Decrypt(encrypted);
Console.WriteLine(""decripted: "" + decripted); 
// ""userNameHere:passwordHere""
</code></pre>
","<p>Have you made sure the .NET code uses the same padding as the Java code? I see no padding specified in the .NET code, that's why I ask.</p>

<p>Do you happen to have the source for the Java code, it will help find mistakes.</p>
","12975","<c#><java><.net><encryption><3des>","3","0","4","2009-09-09 22:54:58","1401193","2","9","39998","","2009-09-09 22:54:58","2009-09-09 16:54:36",""
"1400830",".NET TripleDESCryptoServiceProvider equivalent in Java","<p>Please, just don't ask me why. I just have this code in .NET that encrypt/decrypt strings of data. I need now to make 'exactly' the same funcionality in java. I have tried several examples for DESede crypt, but none of them gives the same results as this class in .net.</p>

<p>I even though on making a .net webserbvice behind ssl to serve this two methods writen in .net but it is just too stupid to do without exhausting all the posibilities.</p>

<p>Maybe some of you java people which are more related in the area will have on top of your heads how to make it.</p>

<p>Thanks !!!</p>

<pre><code>public class Encryption
{
  private static byte[] sharedkey = {...};
  private static byte[] sharedvector = {...};

  public static String Decrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toDecrypt = Convert.FromBase64String(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateDecryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);

    cs.Write(toDecrypt, 0, toDecrypt.Length);
    cs.FlushFinalBlock();
    return Encoding.UTF8.GetString(ms.ToArray());
  }

  public static String Encrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toEncrypt = Encoding.UTF8.GetBytes(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);
    cs.Write(toEncrypt, 0, toEncrypt.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
  }
}
</code></pre>

<hr>

<h2>Samle input/output</h2>

<pre><code>String plain = ""userNameHere:passwordHere"";
Console.WriteLine(""plain: "" + plain);


String encrypted = Encrypt(plain);
Console.WriteLine(""encrypted: "" + encrypted);
// ""zQPZgQHpjxR+41Bc6+2Bvqo7+pQAxBBVN+0V1tRXcOc=""

String decripted = Decrypt(encrypted);
Console.WriteLine(""decripted: "" + decripted); 
// ""userNameHere:passwordHere""
</code></pre>
","<p>Try the following.  For actual usage, I would get a base64 library like commons codec or use the codec that comes with BouncyCastle</p>

<pre><code>import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;

public class Encryption {

    private static SecretKey sharedkey;
    private static byte [] sharedvector;

    static {
        int keySize = 168;
        int ivSize = 8;
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(""DESede"");
            keyGenerator.init(keySize);
            sharedkey = keyGenerator.generateKey();

            sharedvector = new byte [ivSize];
            byte [] data = sharedkey.getEncoded();

            int half = ivSize / 2;
            System.arraycopy(data, data.length-half, sharedvector, 0, half);
            System.arraycopy(sharedvector, 0, sharedvector, half, half);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }

    public static void main(String [] args) throws Exception {
        System.out.println(Decrypt(Encrypt(""Hello World"")));

    }

    public static String Encrypt(String val) throws GeneralSecurityException {
        Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, sharedkey, new IvParameterSpec(sharedvector));

        return new sun.misc.BASE64Encoder().encode(cipher.doFinal(val.getBytes()));
    }

    public static String Decrypt(String val) throws GeneralSecurityException, IOException {
        Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, sharedkey, new IvParameterSpec(sharedvector));

        return new String(cipher.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(val)));
    }

}
</code></pre>
","12975","<c#><java><.net><encryption><3des>","3","0","4","2009-09-09 22:54:58","1401193","2","9","39998","","2009-09-09 22:54:58","2009-09-09 16:54:36",""
"1400830",".NET TripleDESCryptoServiceProvider equivalent in Java","<p>Please, just don't ask me why. I just have this code in .NET that encrypt/decrypt strings of data. I need now to make 'exactly' the same funcionality in java. I have tried several examples for DESede crypt, but none of them gives the same results as this class in .net.</p>

<p>I even though on making a .net webserbvice behind ssl to serve this two methods writen in .net but it is just too stupid to do without exhausting all the posibilities.</p>

<p>Maybe some of you java people which are more related in the area will have on top of your heads how to make it.</p>

<p>Thanks !!!</p>

<pre><code>public class Encryption
{
  private static byte[] sharedkey = {...};
  private static byte[] sharedvector = {...};

  public static String Decrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toDecrypt = Convert.FromBase64String(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateDecryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);

    cs.Write(toDecrypt, 0, toDecrypt.Length);
    cs.FlushFinalBlock();
    return Encoding.UTF8.GetString(ms.ToArray());
  }

  public static String Encrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toEncrypt = Encoding.UTF8.GetBytes(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);
    cs.Write(toEncrypt, 0, toEncrypt.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
  }
}
</code></pre>

<hr>

<h2>Samle input/output</h2>

<pre><code>String plain = ""userNameHere:passwordHere"";
Console.WriteLine(""plain: "" + plain);


String encrypted = Encrypt(plain);
Console.WriteLine(""encrypted: "" + encrypted);
// ""zQPZgQHpjxR+41Bc6+2Bvqo7+pQAxBBVN+0V1tRXcOc=""

String decripted = Decrypt(encrypted);
Console.WriteLine(""decripted: "" + decripted); 
// ""userNameHere:passwordHere""
</code></pre>
","<p>You got a few problems,</p>

<ol>
<li>Your key must be 24 bytes if you want generate the same key materials on both .NET and Java. </li>
<li>The IV must be block size, which is 8 bytes for Triple DES.</li>
<li>In Java, you need to specify the default mode and padding, which is ""DESede/CBC/NoPadding"".</li>
</ol>

<p>Once you make these changes, you should be able to decrypt it on Java side.</p>
","12975","<c#><java><.net><encryption><3des>","3","2","4","2009-09-09 22:54:58","1401193","2","9","39998","","2009-09-09 22:54:58","2009-09-09 16:54:36",""
"1400830",".NET TripleDESCryptoServiceProvider equivalent in Java","<p>Please, just don't ask me why. I just have this code in .NET that encrypt/decrypt strings of data. I need now to make 'exactly' the same funcionality in java. I have tried several examples for DESede crypt, but none of them gives the same results as this class in .net.</p>

<p>I even though on making a .net webserbvice behind ssl to serve this two methods writen in .net but it is just too stupid to do without exhausting all the posibilities.</p>

<p>Maybe some of you java people which are more related in the area will have on top of your heads how to make it.</p>

<p>Thanks !!!</p>

<pre><code>public class Encryption
{
  private static byte[] sharedkey = {...};
  private static byte[] sharedvector = {...};

  public static String Decrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toDecrypt = Convert.FromBase64String(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateDecryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);

    cs.Write(toDecrypt, 0, toDecrypt.Length);
    cs.FlushFinalBlock();
    return Encoding.UTF8.GetString(ms.ToArray());
  }

  public static String Encrypt(String val)
  {
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    byte[] toEncrypt = Encoding.UTF8.GetBytes(val);
    MemoryStream ms = new MemoryStream();
    CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor( sharedkey, sharedvector ), CryptoStreamMode.Write);
    cs.Write(toEncrypt, 0, toEncrypt.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(ms.ToArray());
  }
}
</code></pre>

<hr>

<h2>Samle input/output</h2>

<pre><code>String plain = ""userNameHere:passwordHere"";
Console.WriteLine(""plain: "" + plain);


String encrypted = Encrypt(plain);
Console.WriteLine(""encrypted: "" + encrypted);
// ""zQPZgQHpjxR+41Bc6+2Bvqo7+pQAxBBVN+0V1tRXcOc=""

String decripted = Decrypt(encrypted);
Console.WriteLine(""decripted: "" + decripted); 
// ""userNameHere:passwordHere""
</code></pre>
","<p>Code follows, but first a few notes.</p>

<ol>
<li>A different initialization vector must be chosen for every message. Hard-coding the initialization vector does not make sense. The IV should be sent along with the cipher text to the message recipient (it's not secret). </li>
<li>I used my own utility class for base-64 encoding. You can use <code>sun.misc.BASE64Encoder</code> and <code>sun.misc.BASE64Decoder</code> instead, use a third-party library like BouncyCastle, or write your own.</li>
<li>You are using 2-key triple DES, where the first key and the third key is the same. I modified <code>sharedkey</code> to reflect this, since the Java DESede cipher always requires a 192-bit key; it's up to the key generator to handle the keying option.</li>
<li>A CBC IV is only 64 bits. I've used only the first 64 bits of <code>sharedvector</code>.</li>
</ol>

<p>This class should inter-operate with the C# version.</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encryption
{

  private static byte[] sharedkey = {
    0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11, 
    0x12, 0x11, 0x0D, 0x0B, 0x07, 0x02, 0x04, 0x08, 
    0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11
  };

  private static byte[] sharedvector = {
    0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11
  };

  public static void main(String... argv)
    throws Exception
  {
    String plaintext = ""userNameHere:passwordHere"";
    String ciphertext = encrypt(plaintext);
    System.out.println(ciphertext);
    System.out.println(decrypt(ciphertext));
  }

  public static String encrypt(String plaintext)
    throws Exception
  {
    Cipher c = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sharedkey, ""DESede""), new IvParameterSpec(sharedvector));
    byte[] encrypted = c.doFinal(plaintext.getBytes(""UTF-8""));
    return Base64.encode(encrypted);
  }

  public static String decrypt(String ciphertext)
    throws Exception
  {
    Cipher c = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    c.init(Cipher.DECRYPT_MODE, new SecretKeySpec(sharedkey, ""DESede""), new IvParameterSpec(sharedvector));
    byte[] decrypted = c.doFinal(Base64.decode(ciphertext));
    return new String(decrypted, ""UTF-8"");
  }

}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>zQPZgQHpjxR+41Bc6+2Bvqo7+pQAxBBVN+0V1tRXcOc=</p>
  
  <p>userNameHere:passwordHere</p>
</blockquote>
","12975","<c#><java><.net><encryption><3des>","3","7","4","2009-09-09 22:54:58","1401193","2","9","39998","","2009-09-09 22:54:58","2009-09-09 16:54:36",""
"16336017","How to use 3DES algorithm on Android?","<p>On the server side, the encyption/decryption of the password field is done in C#.</p>

<p>Now, i need to implement same functionality in my android application. So, i followed this tutorial: <a href=""http://ttux.net/post/3des-java-encrypter-des-java-encryption/"" rel=""nofollow"">http://ttux.net/post/3des-java-encrypter-des-java-encryption/</a> as below:</p>

<pre><code>    import java.security.MessageDigest; 
import java.security.spec.KeySpec; 
import java.util.Arrays; 

import javax.crypto.Cipher; 
import javax.crypto.SecretKey; 
import javax.crypto.SecretKeyFactory; 
import javax.crypto.spec.DESedeKeySpec; 
import javax.crypto.spec.IvParameterSpec; 

import org.apache.commons.codec.binary.Base64; 

public class Encrypter { 
  private KeySpec keySpec; 
  private SecretKey key; 
  private IvParameterSpec iv; 

  public Encrypter(String keyString, String ivString) { 
    try { 
      final MessageDigest md = MessageDigest.getInstance(""md5""); 
      final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(""utf-8""))); 
      final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
      for (int j = 0, k = 16; j &lt; 8;) { 
    keyBytes[k++] = keyBytes[j++]; 
      } 

      keySpec = new DESedeKeySpec(keyBytes); 

      key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec); 

      iv = new IvParameterSpec(ivString.getBytes()); 
    } catch(Exception e) { 
      e.printStackTrace(); 
    } 
  } 

  public String encrypt(String value) { 
    try { 
      Cipher ecipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      ecipher.init(Cipher.ENCRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Encode the string into bytes using utf-8 
      byte[] utf8 = value.getBytes(""UTF8""); 

      // Encrypt 
      byte[] enc = ecipher.doFinal(utf8); 

      // Encode bytes to base64 to get a string 
      return new String(Base64.encodeBase64(enc),""UTF-8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 

  public String decrypt(String value) { 
    try { 
      Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      dcipher.init(Cipher.DECRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Decode base64 to get bytes 
      byte[] dec = Base64.decodeBase64(value.getBytes()); 

      // Decrypt 
      byte[] utf8 = dcipher.doFinal(dec); 

      // Decode using utf-8 
      return new String(utf8, ""UTF8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 
} 
</code></pre>

<p>but i dont know what values i need to provide for KeyValue and ivValue for the above code. Please help me...</p>
","<p>Use this code to encrypt your string</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
//string encryption
public class EncryptionHelper {



    // Encrypts string and encode in Base64
    public static String encryptText(String plainText) throws Exception {
        // ---- Use specified 3DES key and IV from other source --------------
        byte[] plaintext = plainText.getBytes();//input
        byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key

        byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector

        Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);

        c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
        byte[] cipherText = c3des.doFinal(plaintext);
        String encryptedString = Base64.encodeToString(cipherText,
                Base64.DEFAULT);
        // return Base64Coder.encodeString(new String(cipherText));
        return encryptedString;
    }

}
</code></pre>

<p>This is how you can encrypt the string</p>

<pre><code>String encryptedPassword = EncryptionHelper.encryptText(edtText.getText().toString());
</code></pre>

<p><strong>EDIT</strong>
Code for <code>Constants.java</code></p>

<pre><code>     Class Constants {
         private final String initializationVector = ""INITALIZATION_VECTOR"";
         private final String ecnryptionKey = ""ENCRYPTION_KEY"";
         public static String getInitializationVector() {
             return initializationVector;
         }
         public static String getKey() {
             return ecnryptionKey;
         }
     }
</code></pre>
","11217","<java><android><3des>","4","5","2","2019-01-02 04:55:25","","2","6","608639","","2017-07-01 01:08:49","2013-05-02 10:43:10",""
"16336017","How to use 3DES algorithm on Android?","<p>On the server side, the encyption/decryption of the password field is done in C#.</p>

<p>Now, i need to implement same functionality in my android application. So, i followed this tutorial: <a href=""http://ttux.net/post/3des-java-encrypter-des-java-encryption/"" rel=""nofollow"">http://ttux.net/post/3des-java-encrypter-des-java-encryption/</a> as below:</p>

<pre><code>    import java.security.MessageDigest; 
import java.security.spec.KeySpec; 
import java.util.Arrays; 

import javax.crypto.Cipher; 
import javax.crypto.SecretKey; 
import javax.crypto.SecretKeyFactory; 
import javax.crypto.spec.DESedeKeySpec; 
import javax.crypto.spec.IvParameterSpec; 

import org.apache.commons.codec.binary.Base64; 

public class Encrypter { 
  private KeySpec keySpec; 
  private SecretKey key; 
  private IvParameterSpec iv; 

  public Encrypter(String keyString, String ivString) { 
    try { 
      final MessageDigest md = MessageDigest.getInstance(""md5""); 
      final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(""utf-8""))); 
      final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
      for (int j = 0, k = 16; j &lt; 8;) { 
    keyBytes[k++] = keyBytes[j++]; 
      } 

      keySpec = new DESedeKeySpec(keyBytes); 

      key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec); 

      iv = new IvParameterSpec(ivString.getBytes()); 
    } catch(Exception e) { 
      e.printStackTrace(); 
    } 
  } 

  public String encrypt(String value) { 
    try { 
      Cipher ecipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      ecipher.init(Cipher.ENCRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Encode the string into bytes using utf-8 
      byte[] utf8 = value.getBytes(""UTF8""); 

      // Encrypt 
      byte[] enc = ecipher.doFinal(utf8); 

      // Encode bytes to base64 to get a string 
      return new String(Base64.encodeBase64(enc),""UTF-8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 

  public String decrypt(String value) { 
    try { 
      Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE""); 
      dcipher.init(Cipher.DECRYPT_MODE, key, iv); 

      if(value==null) 
    return null; 

      // Decode base64 to get bytes 
      byte[] dec = Base64.decodeBase64(value.getBytes()); 

      // Decrypt 
      byte[] utf8 = dcipher.doFinal(dec); 

      // Decode using utf-8 
      return new String(utf8, ""UTF8""); 
    } catch (Exception e) { 
      e.printStackTrace(); 
    } 
    return null; 
  } 
} 
</code></pre>

<p>but i dont know what values i need to provide for KeyValue and ivValue for the above code. Please help me...</p>
","<p>Triple DES is called <code>""DESede""</code> (DES using single DES Encrypt, Decrypt, Encrypt for encryption) in both Java and Android runtimes. So it is build in functionality which can be access through the <a href=""https://developer.android.com/reference/javax/crypto/Cipher.html"" rel=""nofollow noreferrer""><code>Cipher</code></a> class. It also lists the available algorithms. For triple DES you could use ""DESede/CBC/PKCS5Padding""`. Don't forget to supply it a random IV of 8 bytes. </p>

<p>Triple DES should only be used for backwards compatibility. If you decide to use it at least supply it 24 bytes of key material, otherwise there is a chance that your ciphertext can be cracked. For a more modern approach use AES, preferably in an authenticated mode such as GCM (<code>""AES/GCM/NoPadding""</code>). Note that GCM requires a unique nonce of 12 bytes.</p>
","11217","<java><android><3des>","4","1","2","2019-01-02 04:55:25","","2","6","608639","","2017-07-01 01:08:49","2013-05-02 10:43:10",""
"8644867","3Des Encryption/Decryption in java","<p>I am new to Security in java.</p>

<p>I have two clear double length keys which was used for generating ZPK (under LMK) in Futurex HSM.</p>

<p>Below mentioned pin blocks were encrypted using ZPK.
Is there a way to decrypt the block using clear keys in java.</p>

<pre><code>clear_1 = ""801CB5C89DC416C149FB645BB36897AD""

clear_2 = ""45B98FC7D33149E0512F0ED9135E5826""

encrypted_pin_block = ""6288FA9534BF2AA3""

encrypted_pin_block = ""B8D876F238348EB0""
</code></pre>

<p>Decrypted value for one of these encrypted blocks is <code>2222</code>.</p>
","<p>See Sample Example for 3dec encryption and decryption</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;



class ZiggyTest2{


        public static void main(String[] args) throws Exception{  
            String text = ""I am sunil"";

            byte[] codedtext = new ZiggyTest2().encrypt(text);
            String decodedtext = new ZiggyTest2().decrypt(codedtext);

            System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
            System.out.println(decodedtext); // This correctly shows ""kyle boon""
        }

        public byte[] encrypt(String message) throws Exception {
            MessageDigest md = MessageDigest.getInstance(""md5"");
            byte[] digestOfPassword = md.digest(""ABCDEABCDE""
                            .getBytes(""utf-8""));
            byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
            }

            SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            byte[] plainTextBytes = message.getBytes(""utf-8"");
            byte[] cipherText = cipher.doFinal(plainTextBytes);
            // String encodedCipherText = new sun.misc.BASE64Encoder()
            // .encode(cipherText);

            return cipherText;
        }

        public String decrypt(byte[] message) throws Exception {
            MessageDigest md = MessageDigest.getInstance(""md5"");
            byte[] digestOfPassword = md.digest(""ABCDEABCDE""
                            .getBytes(""utf-8""));
            byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
            }

            SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            byte[] plainText = decipher.doFinal(message);

            return new String(plainText, ""UTF-8"");
        }
    }
</code></pre>
","10858","<java><encryption><3des>","-1","0","1","2014-12-05 23:19:22","","1","2","855532","","2011-12-27 12:57:05","2011-12-27 12:52:55",""
"41181905","php: mcrypt_encrypt to openssl_encrypt, and OPENSSL_ZERO_PADDING problems","<p>I have this <code>mcrypt_encrypt</code> call, for a given <code>$key</code>, <code>$message</code> and <code>$iv</code>:</p>

<pre><code>$string = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>I'd like to change the <code>mcrypt_encrypt</code> call to an <code>openssl_encrypt</code> one, to future-proof this. </p>

<p>By having <code>$mode = 'des-ede3-cbc'</code> or <code>$mode = '3DES';</code> and <code>$options = true</code> I get the more similar response, but not identical. Is there other way to call it to get a perfect match?</p>

<p>I'm getting this (base64_encoded) for a lorem-ipsum <code>$message</code>+<code>$key</code> combinations, so I'm starting to believe one function or the other are padding somewhat the message before encrypting... </p>

<p>for mcrypt</p>

<blockquote>
  <p>""Y+JgMBdfI7ZYY3M9lJXCtb5Vgu+rWvLBfjug2GLX7uo="" </p>
</blockquote>

<p>for for openssl</p>

<blockquote>
  <p>""Y+JgMBdfI7ZYY3M9lJXCtb5Vgu+rWvLBvte4swdttHY=""</p>
</blockquote>

<p>Tried using $options to pass <em>OPENSSL_ZERO_PADDING</em>, but passing anything but <strong>1</strong> (<em>OPENSSL_RAW_DATA</em>, or <em>true</em>)  results in an empty string...</p>

<p>Neither using <code>OPENSSL_ZERO_PADDING</code> nor <code>OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING</code> work... :(
I'm using ""OpenSSL 1.0.2g  1 Mar 2016"".</p>

<p>Already read <a href=""https://stackoverflow.com/questions/18102056/php-openssl-equivilent-of-mcrypt-mcrypt-3des"">this</a> q&amp;a, but it doesn't help me. Not the <a href=""https://stackoverflow.com/questions/9993909/php-replace-mcrypt-with-openssl?rq=1"">only</a> <a href=""https://stackoverflow.com/questions/9186541/why-does-something-encrypted-in-php-not-match-the-same-string-encrypted-in-ruby?rq=1"">one</a> with padding troubles, but no solution in sight so far. (Second answer talks about <strong>adding</strong> padding to mcrypt call, I would really want to <strong>remove</strong> padding from openssl encryption call...</p>
","<p><code>mcrypt_encrypt</code> uses zeroes to pad message to the block size. So you can add zeroes to the tail of your raw data, and then encrypt the block.</p>

<p>Using <code>OPENSSL_RAW_DATA|OPENSSL_ZERO_PADDING</code> should work. If it doesn't, then you can remove padding from the decrypted data by yourself.</p>
","9843","<php><openssl><mcrypt><3des><php-openssl>","13","-3","2","2019-09-04 18:07:43","41677002","11","3","1426539","","2019-09-04 18:07:43","2016-12-16 10:09:08",""
"41181905","php: mcrypt_encrypt to openssl_encrypt, and OPENSSL_ZERO_PADDING problems","<p>I have this <code>mcrypt_encrypt</code> call, for a given <code>$key</code>, <code>$message</code> and <code>$iv</code>:</p>

<pre><code>$string = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv);
</code></pre>

<p>I'd like to change the <code>mcrypt_encrypt</code> call to an <code>openssl_encrypt</code> one, to future-proof this. </p>

<p>By having <code>$mode = 'des-ede3-cbc'</code> or <code>$mode = '3DES';</code> and <code>$options = true</code> I get the more similar response, but not identical. Is there other way to call it to get a perfect match?</p>

<p>I'm getting this (base64_encoded) for a lorem-ipsum <code>$message</code>+<code>$key</code> combinations, so I'm starting to believe one function or the other are padding somewhat the message before encrypting... </p>

<p>for mcrypt</p>

<blockquote>
  <p>""Y+JgMBdfI7ZYY3M9lJXCtb5Vgu+rWvLBfjug2GLX7uo="" </p>
</blockquote>

<p>for for openssl</p>

<blockquote>
  <p>""Y+JgMBdfI7ZYY3M9lJXCtb5Vgu+rWvLBvte4swdttHY=""</p>
</blockquote>

<p>Tried using $options to pass <em>OPENSSL_ZERO_PADDING</em>, but passing anything but <strong>1</strong> (<em>OPENSSL_RAW_DATA</em>, or <em>true</em>)  results in an empty string...</p>

<p>Neither using <code>OPENSSL_ZERO_PADDING</code> nor <code>OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING</code> work... :(
I'm using ""OpenSSL 1.0.2g  1 Mar 2016"".</p>

<p>Already read <a href=""https://stackoverflow.com/questions/18102056/php-openssl-equivilent-of-mcrypt-mcrypt-3des"">this</a> q&amp;a, but it doesn't help me. Not the <a href=""https://stackoverflow.com/questions/9993909/php-replace-mcrypt-with-openssl?rq=1"">only</a> <a href=""https://stackoverflow.com/questions/9186541/why-does-something-encrypted-in-php-not-match-the-same-string-encrypted-in-ruby?rq=1"">one</a> with padding troubles, but no solution in sight so far. (Second answer talks about <strong>adding</strong> padding to mcrypt call, I would really want to <strong>remove</strong> padding from openssl encryption call...</p>
","<p><a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""noreferrer"">mcrypt_encrypt</a> zero-pads input data if it's not a multiple of the blocksize. This leads to ambiguous results if the data itself has trailing zeroes. Apparently OpenSSL doesn't allow you to use zero padding in this case, which explains the false return value.</p>

<p>You can circumvent this by adding the padding manually.
</p>

<pre><code>$message = ""Lorem ipsum"";
$key = ""123456789012345678901234"";
$iv = ""12345678"";

$message_padded = $message;
if (strlen($message_padded) % 8) {
    $message_padded = str_pad($message_padded,
        strlen($message_padded) + 8 - strlen($message_padded) % 8, ""\0"");
}
$encrypted_mcrypt = mcrypt_encrypt(MCRYPT_3DES, $key,
    $message, MCRYPT_MODE_CBC, $iv);
$encrypted_openssl = openssl_encrypt($message_padded, ""DES-EDE3-CBC"", 
    $key, OPENSSL_RAW_DATA | OPENSSL_NO_PADDING, $iv);

printf(""%s =&gt; %s\n"", bin2hex($message), bin2hex($encrypted_mcrypt));
printf(""%s =&gt; %s\n"", bin2hex($message_padded), bin2hex($encrypted_openssl));
</code></pre>

<p>This prints both as equal.
</p>

<pre><code>4c6f72656d20697073756d =&gt; c6fed0af15d494e485af3597ad628cec
4c6f72656d20697073756d0000000000 =&gt; c6fed0af15d494e485af3597ad628cec
</code></pre>
","9843","<php><openssl><mcrypt><3des><php-openssl>","13","29","2","2019-09-04 18:07:43","41677002","11","3","1426539","","2019-09-04 18:07:43","2016-12-16 10:09:08",""
"8530312","PHP Equivalent for Java Triple DES encryption/decryption","<p>Am trying to decrypt a key encrypted by Java Triple DES function using PHP mcrypt function but with no luck. Find below the java code</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class Encrypt3DES {

     private byte[] key;
     private byte[] initializationVector;

    public Encrypt3DES(){

    }

    public String encryptText(String plainText, String key) throws Exception{

         //----  Use specified 3DES key and IV from other source --------------
        byte[] plaintext = plainText.getBytes();
        byte[] myIV = key.getBytes();
        byte[] tdesKeyData = {(byte)0xA2, (byte)0x15, (byte)0x37, (byte)0x08, (byte)0xCA, (byte)0x62,
        (byte)0xC1, (byte)0xD2, (byte)0xF7, (byte)0xF1, (byte)0x93, (byte)0xDF,
        (byte)0xD2, (byte)0x15, (byte)0x4F, (byte)0x79, (byte)0x06, (byte)0x67,
        (byte)0x7A, (byte)0x82, (byte)0x94, (byte)0x16, (byte)0x32, (byte)0x95};

        Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        SecretKeySpec    myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);
           c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
        byte[] cipherText = c3des.doFinal(plaintext);
        sun.misc.BASE64Encoder obj64=new sun.misc.BASE64Encoder();
        return obj64.encode(cipherText);

    }

    public String decryptText(String encryptText, String key) throws Exception{


        byte[] initializationVector = key.getBytes();
        byte[] tdesKeyData = {(byte)0xA2, (byte)0x15, (byte)0x37, (byte)0x08, (byte)0xCA, (byte)0x62,
        (byte)0xC1, (byte)0xD2, (byte)0xF7, (byte)0xF1, (byte)0x93, (byte)0xDF,
        (byte)0xD2, (byte)0x15, (byte)0x4F, (byte)0x79, (byte)0x06, (byte)0x67,
        (byte)0x7A, (byte)0x82, (byte)0x94, (byte)0x16, (byte)0x32, (byte)0x95};


          byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(encryptText);
          Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
          SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
          IvParameterSpec ivspec = new IvParameterSpec(initializationVector);
          decipher.init(Cipher.DECRYPT_MODE, myKey, ivspec);
          byte[] plainText = decipher.doFinal(encData);
          return new String(plainText);

    }
}
</code></pre>

<p>I want to write a PHP function equivalent to the decryptText Java function above. am finding difficulty in generating the exact IV value generated by the Java code for encryption, which is required for the decryption.</p>
","<p>This is the PHP equivalent of your Java code (I have copied the PKCS#5-padding from the comment <code>20-Sep-2006 07:56</code> of <a href=""http://php.net/manual/en/ref.mcrypt.php"" rel=""noreferrer"">The <code>mcrypt</code> reference</a>)</p>

<pre><code>function encryptText($plainText, $key) {
    $keyData = ""\xA2\x15\x37\x08\xCA\x62\xC1\xD2""
        . ""\xF7\xF1\x93\xDF\xD2\x15\x4F\x79\x06""
        . ""\x67\x7A\x82\x94\x16\x32\x95"";

    $padded = pkcs5_pad($plainText,
        mcrypt_get_block_size(""tripledes"", ""cbc""));

    $encText = mcrypt_encrypt(""tripledes"", $keyData, $padded, ""cbc"", $key);

    return base64_encode($encText);
}

function decryptText($encryptText, $key) {
    $keyData = ""\xA2\x15\x37\x08\xCA\x62\xC1\xD2""
        . ""\xF7\xF1\x93\xDF\xD2\x15\x4F\x79\x06""
        . ""\x67\x7A\x82\x94\x16\x32\x95"";

    $cipherText = base64_decode($encryptText);

    $res = mcrypt_decrypt(""tripledes"", $keyData, $cipherText, ""cbc"", $key);

    $resUnpadded = pkcs5_unpad($res);

    return $resUnpadded;
}


function pkcs5_pad ($text, $blocksize)
{
    $pad = $blocksize - (strlen($text) % $blocksize);
    return $text . str_repeat(chr($pad), $pad);
}

function pkcs5_unpad($text)
{
    $pad = ord($text{strlen($text)-1});
    if ($pad &gt; strlen($text)) return false;
    if (strspn($text, chr($pad), strlen($text) - $pad) != $pad) return false;
    return substr($text, 0, -1 * $pad);
}
</code></pre>

<p>But there are some problems you should be aware of:</p>

<ul>
<li>In your Java code you call <code>String.getBytes()</code> without indicating an encoding. This makes your code non portable if your clear text contains non ASCII-characters such as umlauts, because Java uses the system-default character set. If you can change that I certainly would do so. I recommend you to use utf-8 on both sides (Java and PHP).</li>
<li>You have hard coded the cipher-key and use the IV as ""key"". I'm by no means a crypto-expert but to me it just feels wrong and may open a huge security leak.</li>
<li>Create a random IV and just concatenate it at the start or at the end of your message. Since the size of the IV is AFAIK equal to the block-size of your cipher you just remove that much bytes from the start or end and have easily separated the IV from the message.</li>
<li>As for the key, it's best to use some kind of <a href=""http://en.wikipedia.org/wiki/Key_derivation_function"" rel=""noreferrer"">key derivation</a> method to generate a key with the right size from a ""human generated"" password.</li>
</ul>

<p>Of course, if you have to fulfil some given requirements you can't change your method. </p>
","9645","<java><php><3des><tripledes>","6","9","2","2017-03-07 08:18:10","8530986","1","4","633239","","2012-01-05 08:26:41","2011-12-16 05:48:25",""
"8530312","PHP Equivalent for Java Triple DES encryption/decryption","<p>Am trying to decrypt a key encrypted by Java Triple DES function using PHP mcrypt function but with no luck. Find below the java code</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class Encrypt3DES {

     private byte[] key;
     private byte[] initializationVector;

    public Encrypt3DES(){

    }

    public String encryptText(String plainText, String key) throws Exception{

         //----  Use specified 3DES key and IV from other source --------------
        byte[] plaintext = plainText.getBytes();
        byte[] myIV = key.getBytes();
        byte[] tdesKeyData = {(byte)0xA2, (byte)0x15, (byte)0x37, (byte)0x08, (byte)0xCA, (byte)0x62,
        (byte)0xC1, (byte)0xD2, (byte)0xF7, (byte)0xF1, (byte)0x93, (byte)0xDF,
        (byte)0xD2, (byte)0x15, (byte)0x4F, (byte)0x79, (byte)0x06, (byte)0x67,
        (byte)0x7A, (byte)0x82, (byte)0x94, (byte)0x16, (byte)0x32, (byte)0x95};

        Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        SecretKeySpec    myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
        IvParameterSpec ivspec = new IvParameterSpec(myIV);
           c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
        byte[] cipherText = c3des.doFinal(plaintext);
        sun.misc.BASE64Encoder obj64=new sun.misc.BASE64Encoder();
        return obj64.encode(cipherText);

    }

    public String decryptText(String encryptText, String key) throws Exception{


        byte[] initializationVector = key.getBytes();
        byte[] tdesKeyData = {(byte)0xA2, (byte)0x15, (byte)0x37, (byte)0x08, (byte)0xCA, (byte)0x62,
        (byte)0xC1, (byte)0xD2, (byte)0xF7, (byte)0xF1, (byte)0x93, (byte)0xDF,
        (byte)0xD2, (byte)0x15, (byte)0x4F, (byte)0x79, (byte)0x06, (byte)0x67,
        (byte)0x7A, (byte)0x82, (byte)0x94, (byte)0x16, (byte)0x32, (byte)0x95};


          byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(encryptText);
          Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
          SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
          IvParameterSpec ivspec = new IvParameterSpec(initializationVector);
          decipher.init(Cipher.DECRYPT_MODE, myKey, ivspec);
          byte[] plainText = decipher.doFinal(encData);
          return new String(plainText);

    }
}
</code></pre>

<p>I want to write a PHP function equivalent to the decryptText Java function above. am finding difficulty in generating the exact IV value generated by the Java code for encryption, which is required for the decryption.</p>
","<p>The answer is almost good! Just reverse <code>$keyData</code> and <code>$key</code> in </p>

<pre><code>$encText = mcrypt_encrypt(""tripledes"", $keyData, $padded, ""cbc"", $key);
</code></pre>

<p>and</p>

<pre><code>$res = mcrypt_decrypt(""tripledes"", $keyData, $cipherText, ""cbc"", $key);
</code></pre>

<p>otherwise you will always use the same 3DES key. And it's better to rename <code>$keyData</code> to <code>$iv</code>.</p>

<p>Anyway, thanks a lot for the Java sample and the Php-Java translation.</p>
","9645","<java><php><3des><tripledes>","6","0","2","2017-03-07 08:18:10","8530986","1","4","633239","","2012-01-05 08:26:41","2011-12-16 05:48:25",""
"19610358","Java Triple DES encryption with 2 different keys","<p>I'm trying to encrypt data using triple DES with two different keys, so given the two keys k1 and k2 the cryptotext would be Ek1(Dk2(Ek1(plaintext))) where E is Encryption and D Decryption. I'm trying to simulate this using DES algorithm from java. Here is the code:</p>

<pre><code>public static void main(String[] args) {

    SecretKey k1 = generateDESkey();
    SecretKey k2 = generateDESkey();

    String firstEncryption = desEncryption(""plaintext"", k1);
    String decryption = desDecryption(firstEncryption, k2);
    String secondEncryption = desEncryption(decryption, k1);

}

public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DES"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(56); // key length 56
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}

public static String desEncryption(String strToEncrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, desKey);
        String encryptedString = Base64.encode(cipher.doFinal(strToEncrypt.getBytes()));
        return encryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public static String desDecryption(String strToDecrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
        return decryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (Base64DecodingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}
</code></pre>

<p>I have this error: javax.crypto.BadPaddingException: Given final block not properly padded when trying to decrypt at this line of code:</p>

<pre><code>String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
</code></pre>

<p>Can you help me to resolve this problem or do you know a direct method to encrypt data using triple DES with two different keys with total key length of 128 bits? I didn't find any algorithm so I tried to simulate it using simple DES. </p>
","<p>You are converting arbitrary bytes to Strings, which is corrupting them.  work entirely with bytes.  if you need to convert the encrypted data to a String, then use Base64 encoding.</p>
","9077","<java><encryption><des><3des>","0","3","2","2013-10-30 16:54:29","19610476","0","2","","","","2013-10-26 18:31:34",""
"19610358","Java Triple DES encryption with 2 different keys","<p>I'm trying to encrypt data using triple DES with two different keys, so given the two keys k1 and k2 the cryptotext would be Ek1(Dk2(Ek1(plaintext))) where E is Encryption and D Decryption. I'm trying to simulate this using DES algorithm from java. Here is the code:</p>

<pre><code>public static void main(String[] args) {

    SecretKey k1 = generateDESkey();
    SecretKey k2 = generateDESkey();

    String firstEncryption = desEncryption(""plaintext"", k1);
    String decryption = desDecryption(firstEncryption, k2);
    String secondEncryption = desEncryption(decryption, k1);

}

public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DES"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(56); // key length 56
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}

public static String desEncryption(String strToEncrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, desKey);
        String encryptedString = Base64.encode(cipher.doFinal(strToEncrypt.getBytes()));
        return encryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}

public static String desDecryption(String strToDecrypt, SecretKey desKey) {
    try {
        Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, desKey);
        String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
        return decryptedString;


    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (NoSuchPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (InvalidKeyException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (IllegalBlockSizeException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (BadPaddingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    } catch (Base64DecodingException ex) {
        Logger.getLogger(Test.class
                .getName()).log(Level.SEVERE, null, ex);
    }
    return null;
}
</code></pre>

<p>I have this error: javax.crypto.BadPaddingException: Given final block not properly padded when trying to decrypt at this line of code:</p>

<pre><code>String decryptedString = new String(cipher.doFinal(Base64.decode(strToDecrypt)));
</code></pre>

<p>Can you help me to resolve this problem or do you know a direct method to encrypt data using triple DES with two different keys with total key length of 128 bits? I didn't find any algorithm so I tried to simulate it using simple DES. </p>
","<p>Why not just use the included DESede algorithm?</p>

<p>Change all your DES code instances to DESede and change your Key Generation method to as such:</p>

<pre><code>public static SecretKey generateDESkey() {
    KeyGenerator keyGen = null;
    try {
        keyGen = KeyGenerator.getInstance(""DESede"");
    } catch (NoSuchAlgorithmException ex) {
        Logger.getLogger(Test.class.getName()).log(Level.SEVERE, null, ex);
    }
    keyGen.init(112); // key length 112 for two keys, 168 for three keys
    SecretKey secretKey = keyGen.generateKey();
    return secretKey;
}
</code></pre>

<p>Note how the getInstance() method is now supplied with DESede and the key size has been increased to 112 (168 for three keys).</p>

<p>Change your Cipher instances from:</p>

<pre><code>Cipher.getInstance(""DES/ECB/PKCS5Padding"");
</code></pre>

<p>to</p>

<pre><code>Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
</code></pre>

<p>And you are set.</p>
","9077","<java><encryption><des><3des>","0","2","2","2013-10-30 16:54:29","19610476","0","2","","","","2013-10-26 18:31:34",""
"17465732","How to use three keys with triple des(3des) in Java","<p>I found a link in stackoverflow here <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">use-3des-encryption-decryption-in-java</a>,but in fact the method uses only two parameter:HG58YZ3CR9"" and the ""<code>IvParameterSpec iv = new IvParameterSpec(new byte[8]);</code>"" 
<br>But the most strong option of triple des could use three different key to encrypt the message.So how to do that? I find a mehond in Cipher, which use ""SecureRandom"" as another parameter.So is this the right way?
<br>
The first method code is below:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDESTest {

    public static void main(String[] args) throws Exception {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""kyle boon""
    }

    public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>
","<p>As per <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html"" rel=""nofollow"">this document</a>, simply pass the cipher a key that is 168 bits long.</p>

<blockquote>
  <p>Keysize must be equal to 112 or 168. </p>
  
  <p>A keysize of 112 will generate a Triple DES key with 2 intermediate keys, and a keysize of 168 will generate a Triple DES key with 3 intermediate keys.</p>
</blockquote>

<p>Your code seems to do something questionable to make up for the fact that the output of MD5 is only 128 bits long.</p>

<p>Copy-pasting cryptographic code off the internet will not produce secure applications. Using a static IV compromises several reasons why CBC mode is better than ECB. If you are using a static key, you should probably consider generating random bytes using a secure random number generator instead of deriving the key from a short ASCII string. Also, there is absolutely no reason to use Triple DES instead of AES in new applications.</p>
","7836","<java><encryption><des><3des>","3","2","2","2013-07-06 11:33:00","","2","3","-1","","2017-05-23 10:27:54","2013-07-04 08:43:01",""
"17465732","How to use three keys with triple des(3des) in Java","<p>I found a link in stackoverflow here <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">use-3des-encryption-decryption-in-java</a>,but in fact the method uses only two parameter:HG58YZ3CR9"" and the ""<code>IvParameterSpec iv = new IvParameterSpec(new byte[8]);</code>"" 
<br>But the most strong option of triple des could use three different key to encrypt the message.So how to do that? I find a mehond in Cipher, which use ""SecureRandom"" as another parameter.So is this the right way?
<br>
The first method code is below:</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDESTest {

    public static void main(String[] args) throws Exception {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""kyle boon""
    }

    public byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return cipherText;
    }

    public String decrypt(byte[] message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(""HG58YZ3CR9""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>
","<p>In principle, the for-next loop to generate the DES ABA key does seem correct. <em>Note that you can provide DESede with a 16 byte key from Java 7 onwards, which amounts to the same thing</em>.</p>

<p>That said, the code you've shown leaves a lot to be desired:</p>

<p>I is not secure:</p>

<ul>
<li>the key is not generated by a Password Based Key Derivation Function (PBKDF) using the (password?) string</li>
<li>the key is composed of two keys instead of three (using a triple DES or TDEA with an ABA key)</li>
<li>the IV is set to all zero's instead of being randomized</li>
<li>the ""password"" string is too short</li>
</ul>

<p>Furthermore the following code mistakes can be seen:</p>

<ul>
<li>using <code>new sun.misc.BASE64Encoder()</code> which is in the Sun proprietary packages (which can be removed or changed during any upgrade of the runtime)</li>
<li>throwing <code>Exception</code> for platform exceptions and runtime exceptions (not being able to decrypt is handled the same way as not being able to instantiate the <code>Cipher</code>)</li>
<li>requesting 24 bytes instead of 16 within the <code>Arrays.copyOf()</code> call (which seems to return 24 SHA-1 output while there are only 20 bytes)</li>
</ul>

<p>To generate a 3DES 24 byte (168 bits used) DES ABC key from a password (like) String you should use PBKDF-2. Adding an authentication tag is also very important if man-in-the-middle attacks or padding oracle  apply. It would be much secure and much more practical to upgrade to AES if you can control the algorithms being used as well.</p>
","7836","<java><encryption><des><3des>","3","0","2","2013-07-06 11:33:00","","2","3","-1","","2017-05-23 10:27:54","2013-07-04 08:43:01",""
"1142477","Using MCrypt to Decrypt a Ciphertext (3DES CBC Mode)","<p>I have a ciphertext, encrypted in 3DES CBC mode, and I'm having some trouble decrypting it. I have the following information (not actual values):</p>

<pre><code>&lt;?php
// Three 16 character long keys
$key1 = '1234567890123456';
$key2 = '6543210987654321';
$key3 = '6549873210456123';

// The initialisation vector
$ivec = '0102030405060708';

// A token which looks something like this
$token = '2ad82e09e3b4e7c491e4bb9fb7c606e1';
?&gt;
</code></pre>

<p>I based my decryption function off the PHP Class that is found in <a href=""http://www.t4vn.net/tutorials/showtutorials/An-Introduction-to-Mcrypt-and-PHP.html"" rel=""nofollow noreferrer"">this blog post</a>. It looks like this:</p>

<pre><code>&lt;?php
function decrypt($key,$iv,$token) {
    $td = mcrypt_module_open('tripledes', '', 'cbc', ''); 
    $iv = substr($iv, 0, mcrypt_enc_get_iv_size($td)); 
    $expected_key_size = mcrypt_enc_get_key_size($td); 

    $key = substr(md5($key), 0, $expected_key_size); 
    mcrypt_generic_init($td, $key, $iv);

    $decrypted_string = trim(mdecrypt_generic($td, base64_decode($token)));

    mcrypt_generic_deinit($td); 
    mcrypt_module_close($td); 

    return $decrypted_string;
}
?&gt;
</code></pre>

<p>However, I'm not sure how to feed the three keys into the algorithm. I have tried chaining them together like so: $key1.$key2.$key3, and in reverse order, but to no avail.</p>

<p>Any help would be appreciated.</p>
","<p><blockquote>// Three 16 character long keys</blockquote>$expected_key_size is 24, 3*8. The keys are most likely in hex format.</p>

<pre><code>function foo($hex) {
    $rv = '';
    foreach(str_split($hex, 2) as $b) {
        $rv .= chr(hexdec($b));
    }
    return $rv;
}

// Three 16 character long keys
$key1 = '1234567890123456';
$key2 = '6543210987654321';
$key3 = '6549873210456123';

$key = foo($key1.$key2.$key3);
</code></pre>
","7011","<php><mcrypt><3des>","0","2","2","2010-11-25 09:04:55","1143060","4","2","","","","2009-07-17 10:21:18",""
"1142477","Using MCrypt to Decrypt a Ciphertext (3DES CBC Mode)","<p>I have a ciphertext, encrypted in 3DES CBC mode, and I'm having some trouble decrypting it. I have the following information (not actual values):</p>

<pre><code>&lt;?php
// Three 16 character long keys
$key1 = '1234567890123456';
$key2 = '6543210987654321';
$key3 = '6549873210456123';

// The initialisation vector
$ivec = '0102030405060708';

// A token which looks something like this
$token = '2ad82e09e3b4e7c491e4bb9fb7c606e1';
?&gt;
</code></pre>

<p>I based my decryption function off the PHP Class that is found in <a href=""http://www.t4vn.net/tutorials/showtutorials/An-Introduction-to-Mcrypt-and-PHP.html"" rel=""nofollow noreferrer"">this blog post</a>. It looks like this:</p>

<pre><code>&lt;?php
function decrypt($key,$iv,$token) {
    $td = mcrypt_module_open('tripledes', '', 'cbc', ''); 
    $iv = substr($iv, 0, mcrypt_enc_get_iv_size($td)); 
    $expected_key_size = mcrypt_enc_get_key_size($td); 

    $key = substr(md5($key), 0, $expected_key_size); 
    mcrypt_generic_init($td, $key, $iv);

    $decrypted_string = trim(mdecrypt_generic($td, base64_decode($token)));

    mcrypt_generic_deinit($td); 
    mcrypt_module_close($td); 

    return $decrypted_string;
}
?&gt;
</code></pre>

<p>However, I'm not sure how to feed the three keys into the algorithm. I have tried chaining them together like so: $key1.$key2.$key3, and in reverse order, but to no avail.</p>

<p>Any help would be appreciated.</p>
","<p>I found the problem with the function in the end. It was a combination of converting the key, IVEC and token from Hex, removing the MD5 hash of the decryption key and removing the Base64 decoding of the resulting plain text. </p>

<p>The padding character that resulted in the plain text was a bit odd, but that's stripped away with rtrim(). It may also be worth noting that the encryption was initially done in JSP using some standard Java libraries, so this might be useful for anyone else going from Java Encryption → PHP Decryption.</p>

<p>Thanks for your help VolkerK, here's the function I ended up using (including your hex function which I haven't added below):</p>

<pre><code>$algorithm = 'tripledes';
$key   = 'F123ACA...'; // Some hex key
$ivec  = 'FE12FA1...'; // Some hex ivec
$token = 'F2ACE12...'; // Some hex token
$mode  = 'cbc';

$key    = foo($key);
$ivec   = foo($ivec);
$token  = foo($token);

function decrypt($key,$iv,$algorithm,$mode,$token) {
    $td = mcrypt_module_open($algorithm, '', $mode, '') ; 
    $iv = substr($iv, 0, mcrypt_enc_get_iv_size($td));

    $expected_key_size = mcrypt_enc_get_key_size($td); 
    $key = substr($key, 0, $expected_key_size); 

    mcrypt_generic_init($td, $key, $iv);

    $response = rtrim(mdecrypt_generic($td, $token), '');

    mcrypt_generic_deinit($td); 
    mcrypt_module_close($td); 

    return $response;
}

$plaintext = decrypt($key,$ivec,$algorithm,$mode,$token);
</code></pre>
","7011","<php><mcrypt><3des>","0","2","2","2010-11-25 09:04:55","1143060","4","2","","","","2009-07-17 10:21:18",""
"27921915","3DES Key Components","<p>I need to encrypt/decrypt data using 3DES. the Keys shared with me are in the form of;</p>

<p>Component 1 = 11111111111111111111111111111111</p>

<p>Component 2 = 22222222222222222222222222222222</p>

<p>KVC = ABCD1234</p>

<p>I need to create 3DES Key from the above components, or K1,k2,k3 sub keys, </p>

<p>I understand sub keys are 16 bytes long, however these are 32 bytes long.</p>

<p>Please share the procedure to create 3DES key.</p>
","<p>Just use EFT calculator, which can be downloaded by following link:
<a href=""https://eftcalculator.codeplex.com/"" rel=""nofollow"">https://eftcalculator.codeplex.com/</a>
Just XOR all the components you have and you will have your 3DES key. To verify the result just encrypt '0000000000000000' using the same calculator with the resulting XORed key. You will have the key check value (KCV) as result. </p>

<p>You have 32 bytes long 3DES key in HEX string representation. Compressing this string to bytes will give you 16 byes (1 byte == 2 hex chars of string).</p>
","6629","<encryption><3des><tripledes>","3","-1","4","2018-03-12 15:03:13","","2","3","","","","2015-01-13 12:12:08",""
"27921915","3DES Key Components","<p>I need to encrypt/decrypt data using 3DES. the Keys shared with me are in the form of;</p>

<p>Component 1 = 11111111111111111111111111111111</p>

<p>Component 2 = 22222222222222222222222222222222</p>

<p>KVC = ABCD1234</p>

<p>I need to create 3DES Key from the above components, or K1,k2,k3 sub keys, </p>

<p>I understand sub keys are 16 bytes long, however these are 32 bytes long.</p>

<p>Please share the procedure to create 3DES key.</p>
","<ol>
<li>Transform the hex strings to byte arrays. 32 chars will give you 16 bytes</li>
<li>3des requires 3 8-byte keys, so it needs 24 bytes. However first and third keys can be the same. So you need to expand your array to 24 bytes by copying first 8 bytes to the end. This 24 byte array is the resulting key you can use for encryption and decryption.</li>
<li>No to check you key - encrypt the string '0000000000000000' (8 zero bytes or 16 zero hex chars) using your key. The beginning of the encoded result must be equal to your KCV.</li>
</ol>
","6629","<encryption><3des><tripledes>","3","1","4","2018-03-12 15:03:13","","2","3","","","","2015-01-13 12:12:08",""
"27921915","3DES Key Components","<p>I need to encrypt/decrypt data using 3DES. the Keys shared with me are in the form of;</p>

<p>Component 1 = 11111111111111111111111111111111</p>

<p>Component 2 = 22222222222222222222222222222222</p>

<p>KVC = ABCD1234</p>

<p>I need to create 3DES Key from the above components, or K1,k2,k3 sub keys, </p>

<p>I understand sub keys are 16 bytes long, however these are 32 bytes long.</p>

<p>Please share the procedure to create 3DES key.</p>
","<p>Transform the clear components in to byte arrays using HexStringToByte standard method. Pass the 3 byte arrays to the method below. You can verify your results at <a href=""http://www.emvlab.org/keyshares/"" rel=""nofollow"">http://www.emvlab.org/keyshares/</a>. Here are sample data:</p>

<ul>
<li>cc1: 447FC2AA6EFFFEE5405A559E88DC958C </li>
<li>cc2: 1086F0493DB0EFE42EDF1BC99541E96F </li>
<li>cc3: D1C603D64D1EDC9D3CA78CD95D168E40</li>
<li>result key: 853F31351E51CD9C5222C28E408BF2A3</li>
<li>result key kvc: 1E49C1</li>
</ul>

<pre class=""lang-java prettyprint-override""><code>public static byte[] buildKey(byte[] cc1, byte[] cc2, byte[] cc3) {
  byte[] result = new byte[cc1.length];
  int i = 0;
  for (byte b1: cc1) {
    byte b2 = cc2[i];
    byte b3 = cc3[i];
    result[i] = (byte)(b1 ^ b2 ^ b3);
    i++;
  }
  return result;
}
</code></pre>
","6629","<encryption><3des><tripledes>","3","4","4","2018-03-12 15:03:13","","2","3","","","","2015-01-13 12:12:08",""
"27921915","3DES Key Components","<p>I need to encrypt/decrypt data using 3DES. the Keys shared with me are in the form of;</p>

<p>Component 1 = 11111111111111111111111111111111</p>

<p>Component 2 = 22222222222222222222222222222222</p>

<p>KVC = ABCD1234</p>

<p>I need to create 3DES Key from the above components, or K1,k2,k3 sub keys, </p>

<p>I understand sub keys are 16 bytes long, however these are 32 bytes long.</p>

<p>Please share the procedure to create 3DES key.</p>
","<p>I was having the same issue. 
Continuing with the example above you have two key components: </p>

<blockquote>
  <p>Component 1 = 11111111111111111111111111111111</p>
  
  <p>Component 2 = 22222222222222222222222222222222</p>
</blockquote>

<p>You have to add a third component, as you don't have it, it will be zeros</p>

<blockquote>
  <p>Component 3 = 00000000000000000000000000000000</p>
</blockquote>

<p>Now use the method provided by @Slav, this will give you the real master key. </p>

<pre><code>byte[] masterKey = buildKey (component1, component2, component3) ; remember those values has to be in hexa. 
</code></pre>

<p>Now let's suppose you have a Encrypted Value you will decrypt it as follows: </p>

<pre><code>byte[] plainValue = tripleDESDecrypt (encryptedValue, masterKey); 
</code></pre>

<p>If you need more detail information, please contact me to send java files. </p>
","6629","<encryption><3des><tripledes>","3","0","4","2018-03-12 15:03:13","","2","3","","","","2015-01-13 12:12:08",""
"11668531","Switching to CBC mode in Triple DES encryption","<p>I’m working on a mvc application over .Net, to secure my sensitive information such as info in web.config I’ve got two functions that encrypts and decrypts information using Triple DES, however I’m new to this and succeeded to reach till here by the help of a friend and asking few question over here.</p>

<p>The point where I’m currently stuck is how can I add TDES IV (Initialization Vector) at the end of the encrypted string and how also retrieve it again while decrypting? I mean how would you identify in an encrypted info that from here the IV (Initialization Vector) stars?</p>

<p>From <a href=""https://stackoverflow.com/questions/11417816/how-to-add-and-retrieve-tdes-iv-initialization-vector-in-encrypted-string"">How to add and retrieve TDES IV (Initialization Vector) in encrypted string</a> i was advised to switch to CBC mode instead of ECB as ECB doesn't support IVs.</p>

<p><strong>But I am confused how can I switch to CBC?</strong></p>

<p>I really need help regarding this, it’s been long that ma struck with this problem and unable to fnid a solution to it. Please help.</p>

<pre><code>public static string Encrypt(string Message)
{
    byte[] iv;
    byte[] Results;
    System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
    MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
    byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String()));
    TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
    TDESAlgorithm.Key = TDESKey;
    TDESAlgorithm.Mode = CipherMode.ECB;
    TDESAlgorithm.Padding = PaddingMode.PKCS7;
    // Capture the randomly generated IV
    iv = TDESAlgorithm.IV;
    byte[] DataToEncrypt = UTF8.GetBytes(Message);
    try
    {
        ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
        Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
        //var lnght=Results.GetLength(0);
        //System.Buffer.BlockCopy(iv, 0, Results, lnght + 1, iv.Length()); //HOW?
    }
    finally
    {
        TDESAlgorithm.Clear();
        HashProvider.Clear();
    }
    return Convert.ToBase64String(Results);
    //return Encoding.UTF8.GetString(Results);
}

public static string Decrypt(string Message)
{
    byte[] Results;
    System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
    MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
    byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String()));
    TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
    TDESAlgorithm.Key = TDESKey;
    // Apply the same IV used during encryption
    //TDESAlgorithm.IV = iv;  // HOW?
    TDESAlgorithm.Mode = CipherMode.ECB;
    TDESAlgorithm.Padding = PaddingMode.PKCS7;
    try
    {
        byte[] DataToDecrypt = Convert.FromBase64String(Message);
        //byte[] DataToDecrypt = UTF8.GetBytes(Message);
        //byte[] DataToDecrypt = Encoding.UTF8.GetBytes(Message);
        ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
        Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length); // &lt;&lt; ERROR is here.
    }
    finally
    {
        TDESAlgorithm.Clear();
        HashProvider.Clear();
    }
    return UTF8.GetString(Results);
}

…
…
</code></pre>

<p>Any guideline, link or a <code>piece of code</code> would be appreciated.
Thankyou.</p>
","<p>To change to CBC, amend your code to read, <code>TDESAlgorithm.Mode = CipherMode.CBC;</code> for both encryption and decryption.</p>

<p>DES is a 64 bit block cypher, so you will need 64 bits of IV, 8 bytes.  Use a cryptographically secure RNG, C# has <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider.aspx"" rel=""nofollow""><code>RNGCryptoServiceProvider</code></a> to generate your IV, and pass it as as a parameter to the encryption method.  The C# documentation will help you here.</p>

<p>When you have encrypted the plain text, prepend the IV to the message and send the whole thing.</p>

<p>When you decrypt, extract the first eight bytes of the incoming message to use as the IV.  The rest of the message will form the cyphertext.</p>
","5799","<c#><.net><encryption><3des>","0","4","1","2012-07-26 13:47:11","11670737","3","","-1","","2017-05-23 12:08:03","2012-07-26 11:43:30",""
"1474801","TripleDES Encryption - .NET and ColdFusion not playing nice","<p>I'm trying to exchange encrypted data between my ASP.NET application and another developer's CF app using TripleDES. </p>

<p>Here's his CF code (fictitious key and IV of course):</p>

<pre><code>&lt;cfset variables.theKey = ""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5""&gt;
&lt;cfset variables.theIV = BinaryDecode(""password"",""Base64"")&gt;
&lt;cfset variables.theAlgorithm = ""DESEDE""&gt;
&lt;cfset variables.theEncoding = ""Base64""&gt;

&lt;cfif IsDefined(""form.string"") and IsDefined(""form.method"")&gt;
   &lt;cfif form.method is ""encrypt""&gt;
      &lt;cfset variables.theString = encrypt(form.string, variables.theKey, variables.theAlgorithm, variables.theEncoding, variables.theIV)&gt;
   &lt;/cfif&gt;
   &lt;cfif form.method is ""decrypt""&gt;
      &lt;cfset variables.theString = decrypt(form.string, variables.theKey, variables.theAlgorithm, variables.theEncoding, variables.theIV)&gt;
   &lt;/cfif&gt;
   &lt;cfoutput&gt;&lt;p&gt;Output: #variables.theString#&lt;/cfoutput&gt;
&lt;/cfif&gt;
</code></pre>

<p>Here's my VB.NET (I've left out exception handling, etc.):</p>

<pre><code>    Private IV() As Byte = ASCIIEncoding.ASCII.GetBytes(""password"")
    Private EncryptionKey() As Byte = Convert.FromBase64String(""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5"")

    Public Function EncryptString(ByVal Input As String) As String
        Dim buffer() As Byte = Encoding.UTF8.GetBytes(Input)
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Key = EncryptionKey
        des.IV = IV
        Return Convert.ToBase64String(des.CreateEncryptor().TransformFinalBlock(buffer, 0, buffer.Length()))
    End Function

    Public Function DecryptString(ByVal Input As String) As String
        Dim buffer() As Byte = Convert.FromBase64String(Input)
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Key = EncryptionKey
        des.IV = IV
        Return Encoding.UTF8.GetString(des.CreateDecryptor().TransformFinalBlock(buffer, 0, buffer.Length()))
    End Function
</code></pre>

<p>We're getting different results. </p>

<p>The obvious thing that comes to mind is that he's using Base64 to create the IV from the password, whereas I'm using ASCII - but if I do this</p>

<pre><code>    Private IV() As Byte = Convert.FromBase64String(""password"")
</code></pre>

<p>then .NET is not happy because it's getting a 6-byte array for the IV and it wants 8 bytes. </p>

<p>Any ideas what we're doing wrong - preferably changes I could make to my (VB.NET) code to make this work? Or failing that, a different approach that would work better between the two environments?</p>
","<p>Try to use UTF8 encoding for password.</p>

<pre><code>Private IV() As Byte = Encoding.UTF8.GetBytes(""password"")
</code></pre>
","5662","<vb.net><encryption><coldfusion><3des>","1","0","2","2009-12-01 11:08:54","","2","","","","","2009-09-25 00:12:36",""
"1474801","TripleDES Encryption - .NET and ColdFusion not playing nice","<p>I'm trying to exchange encrypted data between my ASP.NET application and another developer's CF app using TripleDES. </p>

<p>Here's his CF code (fictitious key and IV of course):</p>

<pre><code>&lt;cfset variables.theKey = ""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5""&gt;
&lt;cfset variables.theIV = BinaryDecode(""password"",""Base64"")&gt;
&lt;cfset variables.theAlgorithm = ""DESEDE""&gt;
&lt;cfset variables.theEncoding = ""Base64""&gt;

&lt;cfif IsDefined(""form.string"") and IsDefined(""form.method"")&gt;
   &lt;cfif form.method is ""encrypt""&gt;
      &lt;cfset variables.theString = encrypt(form.string, variables.theKey, variables.theAlgorithm, variables.theEncoding, variables.theIV)&gt;
   &lt;/cfif&gt;
   &lt;cfif form.method is ""decrypt""&gt;
      &lt;cfset variables.theString = decrypt(form.string, variables.theKey, variables.theAlgorithm, variables.theEncoding, variables.theIV)&gt;
   &lt;/cfif&gt;
   &lt;cfoutput&gt;&lt;p&gt;Output: #variables.theString#&lt;/cfoutput&gt;
&lt;/cfif&gt;
</code></pre>

<p>Here's my VB.NET (I've left out exception handling, etc.):</p>

<pre><code>    Private IV() As Byte = ASCIIEncoding.ASCII.GetBytes(""password"")
    Private EncryptionKey() As Byte = Convert.FromBase64String(""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5"")

    Public Function EncryptString(ByVal Input As String) As String
        Dim buffer() As Byte = Encoding.UTF8.GetBytes(Input)
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Key = EncryptionKey
        des.IV = IV
        Return Convert.ToBase64String(des.CreateEncryptor().TransformFinalBlock(buffer, 0, buffer.Length()))
    End Function

    Public Function DecryptString(ByVal Input As String) As String
        Dim buffer() As Byte = Convert.FromBase64String(Input)
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Key = EncryptionKey
        des.IV = IV
        Return Encoding.UTF8.GetString(des.CreateDecryptor().TransformFinalBlock(buffer, 0, buffer.Length()))
    End Function
</code></pre>

<p>We're getting different results. </p>

<p>The obvious thing that comes to mind is that he's using Base64 to create the IV from the password, whereas I'm using ASCII - but if I do this</p>

<pre><code>    Private IV() As Byte = Convert.FromBase64String(""password"")
</code></pre>

<p>then .NET is not happy because it's getting a 6-byte array for the IV and it wants 8 bytes. </p>

<p>Any ideas what we're doing wrong - preferably changes I could make to my (VB.NET) code to make this work? Or failing that, a different approach that would work better between the two environments?</p>
","<p>The default for CF seems to be ""<em>DESede/ECB/PKCS5Padding</em>"" but in VB.NET they are ""<em>DESede/CBC/PKCS7</em>"".  I am not sure why, but the two paddings (PKCS5 and PKCS7) seem to be compatible. </p>

<p>To get it to work, you either need to change the mode to ""ECB"" on VB.NET side </p>

<pre><code>Public Function EncryptString(ByVal Input As String) As String
        Dim buffer() As Byte = Encoding.UTF8.GetBytes(Input)
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Mode = CipherMode.ECB
        des.Key = EncryptionKey
        des.IV = IV
        Return Convert.ToBase64String(des.CreateEncryptor().TransformFinalBlock(buffer, 0, buffer.Length()))
End Function
</code></pre>

<p>..<strong>OR</strong> change the CF mode and IV to match the VB.NET defaults</p>

<pre><code>  &lt;cfset variables.theKey = ""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5"" /&gt;
  &lt;cfset variables.theIV = javacast(""string"", ""password"").getBytes() /&gt;
  &lt;cfset variables.theAlgorithm = ""DESede/CBC/PKCS5Padding""&gt;
  &lt;cfset variables.theEncoding = ""Base64""&gt;
</code></pre>
","5662","<vb.net><encryption><coldfusion><3des>","1","1","2","2009-12-01 11:08:54","","2","","","","","2009-09-25 00:12:36",""
"1389670","iPhone --- 3DES Encryption returns ""wrong"" results?","<p>I have some serious trouble with a CommonCrypto function. There are two existing applications for BlackBerry and Windows Mobile, both use Triple-DES encryption with ECB mode for data exchange. On either the encrypted results are the same.</p>

<p>Now I want to implent the 3DES encryption into our iPhone application, so I went straight for CommonCrypto:
<a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer""><a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer"">http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h</a></a></p>

<p>I get some results if I use CBC mode, but they do not correspond with the results of Java or C#. Anyway, I want to use ECB mode, but I don't get this working at all - there is a parameter error showing up...</p>

<p>This is my call for the ECB mode... I stripped it a little bit:</p>

<pre><code>const void *vplainText;

plainTextBufferSize = [@""Hello World!"" length];
bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

plainText = (const void *) [@""Hello World!"" UTF8String];
NSString *key = @""abcdeabcdeabcdeabcdeabcd"";

ccStatus = CCCrypt(kCCEncrypt,
     kCCAlgorithm3DES,
     kCCOptionECBMode,
     key,
     kCCKeySize3DES,
     nil, // iv, not used with ECB
     plainText,
     plainTextBufferSize,
     (void *)bufferPtr, // output
     bufferPtrSize,
     &amp;movedBytes);
</code></pre>

<p>t is more or less the code from here: <a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer""><a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer"">http://discussions.apple.com/thread.jspa?messageID=9017515</a></a>
But as already mentioned, I get a parameter error each time...</p>

<p>When I use kCCOptionPKCS7Padding instead of kCCOptionECBMode and set the same initialization vector in C# and my iPhone code, the iPhone gives me different results. Is there a mistake by getting my output from the bufferPtr? Currently I get the encrypted stuff this way:</p>

<pre><code>NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [[NSString alloc] initWithData:myData encoding:NSISOLatin1StringEncoding];
</code></pre>

<p>It seems I almost tried every setting twice, different encodings and so on... where is my error?</p>
","<p>Can you post the error message? </p>

<p>One of the best ways to troubleshoot this stuff, I've found, is to take known input, known key and known output (""<a href=""http://www.google.com/search?q=triple+des+test+vectors"" rel=""nofollow noreferrer"">test vectors</a>"") and compare the bytes of the expected output with the observed output. </p>

<p>What you're doing here is probably not a good way to test the output:</p>

<pre><code>NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [[NSString alloc] initWithData:myData encoding:NSISOLatin1StringEncoding];
</code></pre>

<p>How do you know the encrypted binary data can be interpreted with the <code>NSISOLatin1StringEncoding</code> encoding? </p>

<p>Instead, compare the bytes directly (via <code>[myData description]</code> or the like) or translate the output with hexadecimal or <a href=""https://stackoverflow.com/questions/1395968/cocoa-base-64-implementation-for-rest-auth/1396039#1396039"">base64</a> encoding.</p>
","5246","<iphone><objective-c><encryption><3des>","2","1","3","2012-05-28 13:43:19","","0","1","","","","2009-09-07 14:29:27",""
"1389670","iPhone --- 3DES Encryption returns ""wrong"" results?","<p>I have some serious trouble with a CommonCrypto function. There are two existing applications for BlackBerry and Windows Mobile, both use Triple-DES encryption with ECB mode for data exchange. On either the encrypted results are the same.</p>

<p>Now I want to implent the 3DES encryption into our iPhone application, so I went straight for CommonCrypto:
<a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer""><a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer"">http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h</a></a></p>

<p>I get some results if I use CBC mode, but they do not correspond with the results of Java or C#. Anyway, I want to use ECB mode, but I don't get this working at all - there is a parameter error showing up...</p>

<p>This is my call for the ECB mode... I stripped it a little bit:</p>

<pre><code>const void *vplainText;

plainTextBufferSize = [@""Hello World!"" length];
bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

plainText = (const void *) [@""Hello World!"" UTF8String];
NSString *key = @""abcdeabcdeabcdeabcdeabcd"";

ccStatus = CCCrypt(kCCEncrypt,
     kCCAlgorithm3DES,
     kCCOptionECBMode,
     key,
     kCCKeySize3DES,
     nil, // iv, not used with ECB
     plainText,
     plainTextBufferSize,
     (void *)bufferPtr, // output
     bufferPtrSize,
     &amp;movedBytes);
</code></pre>

<p>t is more or less the code from here: <a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer""><a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer"">http://discussions.apple.com/thread.jspa?messageID=9017515</a></a>
But as already mentioned, I get a parameter error each time...</p>

<p>When I use kCCOptionPKCS7Padding instead of kCCOptionECBMode and set the same initialization vector in C# and my iPhone code, the iPhone gives me different results. Is there a mistake by getting my output from the bufferPtr? Currently I get the encrypted stuff this way:</p>

<pre><code>NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [[NSString alloc] initWithData:myData encoding:NSISOLatin1StringEncoding];
</code></pre>

<p>It seems I almost tried every setting twice, different encodings and so on... where is my error?</p>
","<p>I believe the problem is that kCCOptionECBMode alone is not enough.  You also need padding (since it is a block cypher).  If you pass both (i.e. kCCOptionPKCS7Padding | kCCOptionECBMode ) it will work.</p>
","5246","<iphone><objective-c><encryption><3des>","2","1","3","2012-05-28 13:43:19","","0","1","","","","2009-09-07 14:29:27",""
"1389670","iPhone --- 3DES Encryption returns ""wrong"" results?","<p>I have some serious trouble with a CommonCrypto function. There are two existing applications for BlackBerry and Windows Mobile, both use Triple-DES encryption with ECB mode for data exchange. On either the encrypted results are the same.</p>

<p>Now I want to implent the 3DES encryption into our iPhone application, so I went straight for CommonCrypto:
<a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer""><a href=""http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h"" rel=""nofollow noreferrer"">http://www.opensource.apple.com/source/CommonCrypto/CommonCrypto-32207/CommonCrypto/CommonCryptor.h</a></a></p>

<p>I get some results if I use CBC mode, but they do not correspond with the results of Java or C#. Anyway, I want to use ECB mode, but I don't get this working at all - there is a parameter error showing up...</p>

<p>This is my call for the ECB mode... I stripped it a little bit:</p>

<pre><code>const void *vplainText;

plainTextBufferSize = [@""Hello World!"" length];
bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

plainText = (const void *) [@""Hello World!"" UTF8String];
NSString *key = @""abcdeabcdeabcdeabcdeabcd"";

ccStatus = CCCrypt(kCCEncrypt,
     kCCAlgorithm3DES,
     kCCOptionECBMode,
     key,
     kCCKeySize3DES,
     nil, // iv, not used with ECB
     plainText,
     plainTextBufferSize,
     (void *)bufferPtr, // output
     bufferPtrSize,
     &amp;movedBytes);
</code></pre>

<p>t is more or less the code from here: <a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer""><a href=""http://discussions.apple.com/thread.jspa?messageID=9017515"" rel=""nofollow noreferrer"">http://discussions.apple.com/thread.jspa?messageID=9017515</a></a>
But as already mentioned, I get a parameter error each time...</p>

<p>When I use kCCOptionPKCS7Padding instead of kCCOptionECBMode and set the same initialization vector in C# and my iPhone code, the iPhone gives me different results. Is there a mistake by getting my output from the bufferPtr? Currently I get the encrypted stuff this way:</p>

<pre><code>NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [[NSString alloc] initWithData:myData encoding:NSISOLatin1StringEncoding];
</code></pre>

<p>It seems I almost tried every setting twice, different encodings and so on... where is my error?</p>
","<p>I realise this is an old question, but for reference, I think that your key should not be passed in as an NSString. The key should instead be converted from hexadecimal to a byte array. This <a href=""https://stackoverflow.com/questions/2501033/nsstring-hex-to-bytes"">hexToBytes NSString extension</a> should provide what you need by doing the following:</p>

<pre><code>[[key hexToBytes] bytes]
</code></pre>

<p>The key should also be twice as long as the one given (48 characters of hex, i.e. 24 bytes).</p>
","5246","<iphone><objective-c><encryption><3des>","2","0","3","2012-05-28 13:43:19","","0","1","","","","2009-09-07 14:29:27",""
"23388756","ImportError: No module named pyDes","<p>I am trying to use DES and 3DES in python but when I tried to import pyDes I got this Error </p>

<p>ImportError: No module named pyDes</p>

<p>Why?</p>

<p><strong>UPDATE</strong></p>

<p>thank you </p>

<pre><code> from pyDes import *
    Message=(input(""Enter message""))
    key=(input(""Enter Key""))
    k = des(key, CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
    d = k.encrypt(message)
    print (""Encrypted: %r"" % d)
    print (""Decrypted: %r"" % k.decrypt(d))
</code></pre>

<p>when I run my code with this key 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
I got this error even though I'm sure it's 64 bit</p>

<pre><code>  k = des(key, CBC, ""\0\0\0\0\0\0\0\0"", pad=None, padmode=PAD_PKCS5)
   File ""C:\Python32\lib\site-packages\pyDes.py"", line 400, in __init__
   raise ValueError(""Invalid DES key size. Key must be exactly 8 bytes long."")
   ValueError: Invalid DES key size. Key must be exactly 8 bytes long.
</code></pre>
","<p>Here is all you need: <a href=""http://twhiteman.netfirms.com/des.html"" rel=""nofollow"">http://twhiteman.netfirms.com/des.html</a>
If you need any more help you should state more information fe: what you tried to do so far?</p>
","5017","<python><python-3.x><des><3des>","0","1","1","2014-04-30 16:58:26","","2","","3464643","","2014-04-30 16:58:26","2014-04-30 12:58:32",""
"4427477","Encrypting/decrypting 3DES in Ruby","<p>I have a key.bin file which content is something along the lines of:</p>

<pre><code>-12, 110, 93, 14, -48, ...
</code></pre>

<p>This is being used by a service to decrypt 3DES content, but I need to encrypt it via Ruby.</p>

<p>I've tried loads of scenarios with how to set the key and what to do with it, but to no avail as of yet:</p>

<ul>
<li>Tried splitting the key by , and converting each number to hex, concatenating the hex values to make the key</li>
<li>Tried converting the number string to binary</li>
<li>Tried converting the resulting hex to binary</li>
</ul>

<p>I assume what I need to do is something simple like:</p>

<pre><code>des = OpenSSL::Cipher::Cipher.new('des3')
des.decrypt
des.key = mistery # this step is where i'm having problems at
final = des.update(encrypted) + des.final
</code></pre>

<p>Any ideas on what I should do with this key?</p>

<p>Key sample:</p>

<pre><code>-62,-53,124,-110,37,-88,-48,31,-57,93,70,-101,44,69,-88,-57,-123,-99,118,-119,110,55,11,14
</code></pre>

<p>Data sample:</p>

<pre><code>NEb2b9sYXgod6mTvaRv+MRsTJvIiTTI9VjnDGcxjxcN5qBH7FXvxYI6Oj16FeKKsoQvjAmdju2SQ
ifJqPJTl97xeEbjdwm+W8XJnWs99ku85EznVBhzQxI1H2jPiZIcrqIVCWdd/OQun7AjK4w2+5yb7
DPN2OiCIEOz2zK6skJrBw3oTEHpXrSEhydOYxqI+c5hC4z3k5nktN6WSVLIo8EAjwenHPMDxboWF
ET8R+QM5EznVBhzQxI1H2jPiZIcrqIVCWdd/OQun7AjK4w2+5yb7DPN2OiCIFqk4LRwEVq16jvKE
vjz6T4/G34kx6CEx/JdZ1LdvxC3xYQIcwS0wVnmtxorFm4q5QQFHzNKQ5chrGZzDkFzAogsZ2l2B
vcvlwgajNGHmxuVU83Ldn1e5rin7QqpjASqeDGFQHkiSbp4x6axVce2OGgfFpZdzCM7y6jLPpOlX
LOC/Bs1vTwMzcBNRB/Fo4nsX9i4It8Spm228XQNUpQe4i9QGe/4AyKIhHoM8DkXwPZ6rWp0W0UMe
keXjg41cED1JwjAAQSP3RYITB78bu+CEZKPOt2tQ2BvSw55mnFcvjIAYVQxCHliQ4PwgceHrnsZz
5aagC0QJ3oOKw9O0dlkVE3IM6KTBMcuZOZF19nCqxMFacQoDxjJY8tOJoN0Fe4Boz2FPyuggfLz9
yhljVJhxqOlTd8eA34Ex8SdC+5NDByAMumjzcPcXL8YVpSN85gytfd+skXhz3npmJ0dmZZOouu0Z
vMmlaCqw96Sy0L1mHLKbjqmZ/W57OBNRB/Fo4nsX9i4It8Spm228XQNUpQe4i9QGe/4AyKIhHoM8
DkXwPZ5tXdq1dRG6IaS51oNzFFlOoP3wTJuOTpj+zQOBMMOi4ENFyyEwYbG/qE+uY8rVwBOUHv9b
Yd9byvOZbnHDuf4oaWRZ+4K3s2NkEblDF9wU6Mb0ZqnLEJsypjrorH1cNIodIDu8nME1nD5bIDF6
XNrWC6pk6AV6eYQvNJw2QDz0RBD15fz/fAXCvbaCLDnhBKpLXrRbQdV+jxx2ipeC2ceMLLRFRPuR
B+ycYht65lWh4jNjoEsBXGFKiT0bSX6Lx/ZQD3twJWbML8ifRhw7SW0jOkUF+dAfXYNaD6nqA6Xq
TkcsDGaJsVq8wwCIWNh6tDRSw7ba4c391147kmnqEgXdKmmnEzUfHtpRw88C0/u0qj809hB4qB0B
lxj/87aDo4VOz9S4jjtk849CxtA/a9+532A4YlXjsPt/f0KZ2drAGEr1VSWzaLh/sMwP5tznmPaK
uozS6C74gMNdhtNMFz0HONcYecS0hg4lrdRyljROgzC33QoBIHbQXJrG0OXE3+81uhJwusEnFaD9
8Eybjk6YeNk3oxL3C5fx/xXgFmhcLLGdxRe/am0jqA1gV6MyQFUKtzdnNOUYpHkYXT9Ea7YYln4Q
D96Z9AI5EznVBhzQxI1H2jPiZIcrqIVCWdd/OQun7AjK4w2+5yb7DPN2OiCIFqk4LRwEVq16jvKE
vjz6T4/G34kx6CEx/JdZ1LdvxC3iEcYTrEH9kKhPrmPK1cATlB7/W2HfW8rzmW5xw7n+KGlkWfuC
t7NjZBG5QxfcFOjG9GapyxCbMqY66Kx9XDSKHSA7vJzBNZw+WyAxelza1guqZOgFenmElSgtUOo7
TEunuphaMIEQgo0udojG6dm2FtRmA4yntNCnCDzGTY72nrFBz3EZmVXGEm6X3Xd5Ito=
</code></pre>
","<p>Got it working!</p>

<p>Here's how:</p>

<p><strong>Decryption</strong></p>

<pre><code>def read_key(key_file)
  File.read(key_file).split(',').map { |x| x.to_i }.pack('c*')
end
des = OpenSSL::Cipher::Cipher.new('des-ede3')
des.decrypt
des.key = read_key('key.bin')

result = des.update(decoded) + des.final
</code></pre>

<p><strong>Encryption</strong></p>

<pre><code>def read_key(key_file)
  File.read(key_file).split(',').map { |x| x.to_i }.pack('c*')
end
des2 = OpenSSL::Cipher::Cipher.new('des-ede3')
des2.encrypt
des2.key = read_key('key.bin')

result = des2.update(result) + des2.final
puts Base64.encode64(result)
</code></pre>
","4909","<ruby><encryption><3des>","5","5","1","2010-12-23 17:10:47","4520925","2","1","5646","","2010-12-23 14:15:38","2010-12-13 09:38:51",""
"11105718","TripleDES algorithm: from .NET to Java","<p>I have this vb.net code ( but I think meaning code is equivalent for c# too) that I have to replicate in Java and <strong>I can't modify</strong> it in anyway (just replicate):</p>

<pre><code>Public Shared Function Encrypt(ByVal plainText As String, Optional key As String = """") As String

    If String.IsNullOrEmpty(key) Then key = ""sfdjf48mdfdf3054""

    Dim encrypted As String = Nothing
    Try

        Dim inputBytes As Byte() = ASCIIEncoding.ASCII.GetBytes(plainText)
        Dim pwdhash As Byte() = Nothing

        'generate an MD5 hash from the password.
        'a hash is a one way encryption meaning once you generate
        'the hash, you cant derive the password back from it.
        Dim hashmd5 As New MD5CryptoServiceProvider()
        pwdhash = hashmd5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key))
        hashmd5 = Nothing

        ' Create a new TripleDES service provider
        Dim tdesProvider As New TripleDESCryptoServiceProvider()
        tdesProvider.Key = pwdhash
        tdesProvider.Mode = CipherMode.ECB

        encrypted = Convert.ToBase64String(tdesProvider.CreateEncryptor().TransformFinalBlock(inputBytes, 0, inputBytes.Length))

    Catch e As Exception
        Dim str As String = e.Message
        Throw
    End Try
    Return encrypted
End Function
</code></pre>

<p>Exactly, this is a .NET Utility Class function.</p>

<p>Now,</p>

<p>I don't know how to replicate</p>

<pre><code>TripleDESCryptoServiceProvider()
</code></pre>

<p>In java code I began to write some code, but I don't know how to continue:</p>

<pre><code>public static String encrypt(String plaintext, String enctoken){

    if(enctoken == null)
        enctoken = ""sfdjf48mdfdf3054"";

    String encrypted = null;

    byte[] plaintextByte = EncodingUtils.getAsciiBytes(plaintext);

    //nel caso non funzionasse provare getBytes semplicemente
    byte[] pwd = EncodingUtils.getAsciiBytes(Connessione.md5(enctoken));        

    try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/NoPadding"");
        SecretKeySpec myKey = new SecretKeySpec(pwd,""DESede"");

        cipher.init( Cipher.ENCRYPT_MODE, myKey);

        try {
            byte[] encryptedPlainText= cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0); 
            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       

    return """";
}
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>I've just updated code. Now should be good. Enctoken String will be a string data rappresentation (just known). In this way, only if second parameter is NULL then fixed key is setted</p>

<p><strong>UPDATE 2</strong></p>

<p>Unfortunally c# hash is always different from Java hash!!
How to replicate this in java ??</p>

<pre><code> Dim hashmd5 As New MD5CryptoServiceProvider()
    pwdhash = hashmd5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key))
    hashmd5 = Nothing

    ' Create a new TripleDES service provider
    Dim tdesProvider As New TripleDESCryptoServiceProvider()
    tdesProvider.Key = pwdhash
    tdesProvider.Mode = CipherMode.ECB

    encrypted = Convert.ToBase64String(tdesProvider.CreateEncryptor().TransformFinalBlock(inputBytes, 0, inputBytes.Length))
</code></pre>

<p>I tried in this way but it doesn't work:</p>

<p><strong>HASH</strong></p>

<pre><code>public static final String md5(byte[] s) { 
    try { 

        MessageDigest m = MessageDigest.getInstance(""MD5"");
        byte[] digest = m.digest(s);
        String hash = EncodingUtils.getAsciiString(digest, 0, 16);
        Log.i(""MD5"", ""Hash: ""+hash);

        return hash;

    } catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
    }
    return """";
}   
</code></pre>
","<p>There is no such thing as an IV for ECB mode (which is one of the things that is unsafe in your application, you should at least use CBC mode).</p>

<p>As for the key, you just calculated one, why are you stuck here? What exception do you get? And again, using ASCII characters instead of full bytes is unsafe; it makes you vulnerable to (at least) brute force attacks.</p>
","4745","<java><android><.net><encryption><3des>","-5","0","2","2014-03-05 00:44:04","11143705","0","3","1947286","","2014-03-05 00:44:04","2012-06-19 16:56:37",""
"11105718","TripleDES algorithm: from .NET to Java","<p>I have this vb.net code ( but I think meaning code is equivalent for c# too) that I have to replicate in Java and <strong>I can't modify</strong> it in anyway (just replicate):</p>

<pre><code>Public Shared Function Encrypt(ByVal plainText As String, Optional key As String = """") As String

    If String.IsNullOrEmpty(key) Then key = ""sfdjf48mdfdf3054""

    Dim encrypted As String = Nothing
    Try

        Dim inputBytes As Byte() = ASCIIEncoding.ASCII.GetBytes(plainText)
        Dim pwdhash As Byte() = Nothing

        'generate an MD5 hash from the password.
        'a hash is a one way encryption meaning once you generate
        'the hash, you cant derive the password back from it.
        Dim hashmd5 As New MD5CryptoServiceProvider()
        pwdhash = hashmd5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key))
        hashmd5 = Nothing

        ' Create a new TripleDES service provider
        Dim tdesProvider As New TripleDESCryptoServiceProvider()
        tdesProvider.Key = pwdhash
        tdesProvider.Mode = CipherMode.ECB

        encrypted = Convert.ToBase64String(tdesProvider.CreateEncryptor().TransformFinalBlock(inputBytes, 0, inputBytes.Length))

    Catch e As Exception
        Dim str As String = e.Message
        Throw
    End Try
    Return encrypted
End Function
</code></pre>

<p>Exactly, this is a .NET Utility Class function.</p>

<p>Now,</p>

<p>I don't know how to replicate</p>

<pre><code>TripleDESCryptoServiceProvider()
</code></pre>

<p>In java code I began to write some code, but I don't know how to continue:</p>

<pre><code>public static String encrypt(String plaintext, String enctoken){

    if(enctoken == null)
        enctoken = ""sfdjf48mdfdf3054"";

    String encrypted = null;

    byte[] plaintextByte = EncodingUtils.getAsciiBytes(plaintext);

    //nel caso non funzionasse provare getBytes semplicemente
    byte[] pwd = EncodingUtils.getAsciiBytes(Connessione.md5(enctoken));        

    try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/NoPadding"");
        SecretKeySpec myKey = new SecretKeySpec(pwd,""DESede"");

        cipher.init( Cipher.ENCRYPT_MODE, myKey);

        try {
            byte[] encryptedPlainText= cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0); 
            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       

    return """";
}
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>I've just updated code. Now should be good. Enctoken String will be a string data rappresentation (just known). In this way, only if second parameter is NULL then fixed key is setted</p>

<p><strong>UPDATE 2</strong></p>

<p>Unfortunally c# hash is always different from Java hash!!
How to replicate this in java ??</p>

<pre><code> Dim hashmd5 As New MD5CryptoServiceProvider()
    pwdhash = hashmd5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key))
    hashmd5 = Nothing

    ' Create a new TripleDES service provider
    Dim tdesProvider As New TripleDESCryptoServiceProvider()
    tdesProvider.Key = pwdhash
    tdesProvider.Mode = CipherMode.ECB

    encrypted = Convert.ToBase64String(tdesProvider.CreateEncryptor().TransformFinalBlock(inputBytes, 0, inputBytes.Length))
</code></pre>

<p>I tried in this way but it doesn't work:</p>

<p><strong>HASH</strong></p>

<pre><code>public static final String md5(byte[] s) { 
    try { 

        MessageDigest m = MessageDigest.getInstance(""MD5"");
        byte[] digest = m.digest(s);
        String hash = EncodingUtils.getAsciiString(digest, 0, 16);
        Log.i(""MD5"", ""Hash: ""+hash);

        return hash;

    } catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
    }
    return """";
}   
</code></pre>
","<p>Fixed by myself! Following function gives same MD5 HASH result:</p>

<p>JAVA HASH MD5</p>

<pre><code>public static final byte[] md5(String s) { 
    try { 

        MessageDigest md = MessageDigest.getInstance(""MD5"");
        byte[] messageDigest = md.digest(s.getBytes(""UTF-8""));

        String md5 = EncodingUtils.getString(messageDigest, ""UTF-8"");

        Log.i(""Function MD5"", md5);
        Log.i(""Function MD5 Length"",""Length: ""+ md5.length());

        return messageDigest;

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } 
    return null;
}   
</code></pre>

<p>VB.NET HASH MD5</p>

<pre><code>Dim hashmd5 As New MD5CryptoServiceProvider()
pwdhash = hashmd5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key))
</code></pre>

<p>And, TRIPLE-DES ECB JAVA is</p>

<pre><code>try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(hash,""DESede"");

        cipher.init(Cipher.ENCRYPT_MODE, myKey);

        try {
            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0); 
            Log.i(""ENCRYPT"", ""Pwd encrypted: ""+encrypted);
            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       
</code></pre>

<p>TRIPLE-DES VB.NET is</p>

<pre><code>' Create a new TripleDES service provider
    Dim tdesProvider As New TripleDESCryptoServiceProvider()
    tdesProvider.Key = pwdhash
    tdesProvider.Mode = CipherMode.ECB

    encrypted = Convert.ToBase64String(tdesProvider.CreateEncryptor().TransformFinalBlock(inputBytes, 0, inputBytes.Length))
</code></pre>
","4745","<java><android><.net><encryption><3des>","-5","4","2","2014-03-05 00:44:04","11143705","0","3","1947286","","2014-03-05 00:44:04","2012-06-19 16:56:37",""
"2454715","iPhone 3DES encryption key length issue","<p>I have been banging my head on a wall with this one. I need to code my iPhone application to encrypt a 4 digit ""pin"" using 3DES in ECB mode for transmission to a webservice which I believe is written in .NET.</p>

<pre><code>+ (NSData *)TripleDESEncryptWithKey:(NSString *)key dataToEncrypt:(NSData*)encryptData {
NSLog(@""kCCKeySize3DES=%d"", kCCKeySize3DES);
char keyBuffer[kCCKeySize3DES+1]; // room for terminator (unused)
bzero( keyBuffer, sizeof(keyBuffer) ); // fill with zeroes (for padding)

[key getCString: keyBuffer maxLength: sizeof(keyBuffer) encoding: NSUTF8StringEncoding];

// encrypts in-place, since this is a mutable data object
size_t numBytesEncrypted = 0;

size_t returnLength = ([encryptData length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

// NSMutableData* returnBuffer = [NSMutableData dataWithLength:returnLength];
char* returnBuffer = malloc(returnLength * sizeof(uint8_t) );

CCCryptorStatus ccStatus = CCCrypt(kCCEncrypt, kCCAlgorithm3DES , kCCOptionECBMode,
                                 keyBuffer, kCCKeySize3DES, nil,
                                 [encryptData bytes], [encryptData length], 
                                 returnBuffer, returnLength,
                                 &amp;numBytesEncrypted);

if (ccStatus == kCCParamError) NSLog(@""PARAM ERROR"");
else if (ccStatus == kCCBufferTooSmall) NSLog(@""BUFFER TOO SMALL"");
else if (ccStatus == kCCMemoryFailure) NSLog(@""MEMORY FAILURE"");
else if (ccStatus == kCCAlignmentError) NSLog(@""ALIGNMENT"");
else if (ccStatus == kCCDecodeError) NSLog(@""DECODE ERROR"");
else if (ccStatus == kCCUnimplemented) NSLog(@""UNIMPLEMENTED"");

if(ccStatus == kCCSuccess) {
    NSLog(@""TripleDESEncryptWithKey encrypted: %@"", [NSData dataWithBytes:returnBuffer length:numBytesEncrypted]);
    return [NSData dataWithBytes:returnBuffer length:numBytesEncrypted];
}
else 
    return nil;
} }
</code></pre>

<p>I do get a value encrypted using the above code, however it does not match the value from the .NET web service. </p>

<p>I believe the issue is that the encryption key I have been supplied by the web service developers is 48 characters long.</p>

<p>I see that the iPhone SDK constant ""kCCKeySize3DES"" is 24. So I SUSPECT, but don't know, that the commoncrypto API call is only using the first 24 characters of the supplied key.</p>

<p>Is this correct?</p>

<p>Is there ANY way I can get this to generate the correct encrypted pin? I have output the data bytes from the encryption PRIOR to base64 encoding it and have attempted to match this against those generated from the .NET code (with the help of a .NET developer who sent the byte array output to me). Neither the non-base64 encoded byte array nor the final base64 encoded strings match.</p>
","<p>Maybe you need to use padding? Try setting the options to:</p>

<pre><code>(kCCOptionPKCS7Padding | kCCOptionECBMode)
</code></pre>
","4716","<iphone><encryption><3des>","6","1","3","2011-05-19 18:45:23","2455758","0","3","","","","2010-03-16 13:37:59",""
"2454715","iPhone 3DES encryption key length issue","<p>I have been banging my head on a wall with this one. I need to code my iPhone application to encrypt a 4 digit ""pin"" using 3DES in ECB mode for transmission to a webservice which I believe is written in .NET.</p>

<pre><code>+ (NSData *)TripleDESEncryptWithKey:(NSString *)key dataToEncrypt:(NSData*)encryptData {
NSLog(@""kCCKeySize3DES=%d"", kCCKeySize3DES);
char keyBuffer[kCCKeySize3DES+1]; // room for terminator (unused)
bzero( keyBuffer, sizeof(keyBuffer) ); // fill with zeroes (for padding)

[key getCString: keyBuffer maxLength: sizeof(keyBuffer) encoding: NSUTF8StringEncoding];

// encrypts in-place, since this is a mutable data object
size_t numBytesEncrypted = 0;

size_t returnLength = ([encryptData length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

// NSMutableData* returnBuffer = [NSMutableData dataWithLength:returnLength];
char* returnBuffer = malloc(returnLength * sizeof(uint8_t) );

CCCryptorStatus ccStatus = CCCrypt(kCCEncrypt, kCCAlgorithm3DES , kCCOptionECBMode,
                                 keyBuffer, kCCKeySize3DES, nil,
                                 [encryptData bytes], [encryptData length], 
                                 returnBuffer, returnLength,
                                 &amp;numBytesEncrypted);

if (ccStatus == kCCParamError) NSLog(@""PARAM ERROR"");
else if (ccStatus == kCCBufferTooSmall) NSLog(@""BUFFER TOO SMALL"");
else if (ccStatus == kCCMemoryFailure) NSLog(@""MEMORY FAILURE"");
else if (ccStatus == kCCAlignmentError) NSLog(@""ALIGNMENT"");
else if (ccStatus == kCCDecodeError) NSLog(@""DECODE ERROR"");
else if (ccStatus == kCCUnimplemented) NSLog(@""UNIMPLEMENTED"");

if(ccStatus == kCCSuccess) {
    NSLog(@""TripleDESEncryptWithKey encrypted: %@"", [NSData dataWithBytes:returnBuffer length:numBytesEncrypted]);
    return [NSData dataWithBytes:returnBuffer length:numBytesEncrypted];
}
else 
    return nil;
} }
</code></pre>

<p>I do get a value encrypted using the above code, however it does not match the value from the .NET web service. </p>

<p>I believe the issue is that the encryption key I have been supplied by the web service developers is 48 characters long.</p>

<p>I see that the iPhone SDK constant ""kCCKeySize3DES"" is 24. So I SUSPECT, but don't know, that the commoncrypto API call is only using the first 24 characters of the supplied key.</p>

<p>Is this correct?</p>

<p>Is there ANY way I can get this to generate the correct encrypted pin? I have output the data bytes from the encryption PRIOR to base64 encoding it and have attempted to match this against those generated from the .NET code (with the help of a .NET developer who sent the byte array output to me). Neither the non-base64 encoded byte array nor the final base64 encoded strings match.</p>
","<p>3DES is a symmetric block cipher. Using a 24-byte key, 3DES encrypts an 8-byte block into another 8-byte block. With the same 24-byte key, the encryption is reversible (i.e. you can decrypt).</p>

<p>The key is an arbitrary sequence of bytes. That's not the same as ""characters"". In particular, having one of those bytes with value zero is perfectly legal. Similarly, input and output may be arbitrary bytes.</p>

<p>If the key you were given consists in ""characters"" then it must be transformed into an appropriate sequence of bytes in some way. Since you got a 48-character ""key string"" and 48 is exactly 24*2, a plausible guess is that the key is given in hexadecimal notation: see if it contains only digits, and letters from 'a' to 'f'.</p>

<p>As for padding: 3DES encrypts only 8-byte blocks. When a ""message"" is to be encrypted and has some length distinct from 8 bytes, then it is customary to format and split and process the message so that it can be encrypted in a number of invocations to 3DES. The two keywords are <em>padding</em> and <em>chaining</em>. Padding is about adding some extra bytes at the end (in such a way that those byte can be unambiguously removed) so that the length is appropriate (e.g. multiple of 8). Chaining is about deciding what exactly goes into each 3DES invocation (simply splitting the padded message into independently encrypted blocks is known as ""ECB"" and has weaknesses).</p>

<p>If your PIN code contains 4 digits, then there must be some convention on how these four
digits become at least 8 bytes, to be fed to 3DES. If the iPhone behaves similarly to what this <a href=""http://developer.apple.com/mac/library/documentation/Darwin/Reference/ManPages/man3/CCCrypt.3cc.html"" rel=""nofollow noreferrer"">man page for MacOS X</a> describes, then your code should not run successfully unless the length of <code>encryptData</code> is a multiple of eight. Which means that the code you do not show, which converts a 4-digit PIN into an 8-byte buffer, already does some non-trivial transformations. For instance, that code might put the four digits into four bytes (using ASCII encoding) and set the four other bytes to zero. Or maybe it fails to do so. Either way, each of the 64 input bits to 3DES is important, and you have to get it exactly in the same way than the server. You should inspect that code as well.</p>
","4716","<iphone><encryption><3des>","6","4","3","2011-05-19 18:45:23","2455758","0","3","","","","2010-03-16 13:37:59",""
"2454715","iPhone 3DES encryption key length issue","<p>I have been banging my head on a wall with this one. I need to code my iPhone application to encrypt a 4 digit ""pin"" using 3DES in ECB mode for transmission to a webservice which I believe is written in .NET.</p>

<pre><code>+ (NSData *)TripleDESEncryptWithKey:(NSString *)key dataToEncrypt:(NSData*)encryptData {
NSLog(@""kCCKeySize3DES=%d"", kCCKeySize3DES);
char keyBuffer[kCCKeySize3DES+1]; // room for terminator (unused)
bzero( keyBuffer, sizeof(keyBuffer) ); // fill with zeroes (for padding)

[key getCString: keyBuffer maxLength: sizeof(keyBuffer) encoding: NSUTF8StringEncoding];

// encrypts in-place, since this is a mutable data object
size_t numBytesEncrypted = 0;

size_t returnLength = ([encryptData length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

// NSMutableData* returnBuffer = [NSMutableData dataWithLength:returnLength];
char* returnBuffer = malloc(returnLength * sizeof(uint8_t) );

CCCryptorStatus ccStatus = CCCrypt(kCCEncrypt, kCCAlgorithm3DES , kCCOptionECBMode,
                                 keyBuffer, kCCKeySize3DES, nil,
                                 [encryptData bytes], [encryptData length], 
                                 returnBuffer, returnLength,
                                 &amp;numBytesEncrypted);

if (ccStatus == kCCParamError) NSLog(@""PARAM ERROR"");
else if (ccStatus == kCCBufferTooSmall) NSLog(@""BUFFER TOO SMALL"");
else if (ccStatus == kCCMemoryFailure) NSLog(@""MEMORY FAILURE"");
else if (ccStatus == kCCAlignmentError) NSLog(@""ALIGNMENT"");
else if (ccStatus == kCCDecodeError) NSLog(@""DECODE ERROR"");
else if (ccStatus == kCCUnimplemented) NSLog(@""UNIMPLEMENTED"");

if(ccStatus == kCCSuccess) {
    NSLog(@""TripleDESEncryptWithKey encrypted: %@"", [NSData dataWithBytes:returnBuffer length:numBytesEncrypted]);
    return [NSData dataWithBytes:returnBuffer length:numBytesEncrypted];
}
else 
    return nil;
} }
</code></pre>

<p>I do get a value encrypted using the above code, however it does not match the value from the .NET web service. </p>

<p>I believe the issue is that the encryption key I have been supplied by the web service developers is 48 characters long.</p>

<p>I see that the iPhone SDK constant ""kCCKeySize3DES"" is 24. So I SUSPECT, but don't know, that the commoncrypto API call is only using the first 24 characters of the supplied key.</p>

<p>Is this correct?</p>

<p>Is there ANY way I can get this to generate the correct encrypted pin? I have output the data bytes from the encryption PRIOR to base64 encoding it and have attempted to match this against those generated from the .NET code (with the help of a .NET developer who sent the byte array output to me). Neither the non-base64 encoded byte array nor the final base64 encoded strings match.</p>
","<p>well, I managed to resolve this with a lot of reading and the comments here on stackoverflow. There where several issues. The key I had been given by the .NET developers was 48 characters. This of course needed to be read as a hex string and converted down to 24 characters instead.</p>

<p>I added code to do this, and the complete routine is as follows. I am not sure it will be of any use as it's quite specific to our implementation.</p>

<pre><code>+ (NSString *)doCipher3DES:(NSString *)sTextIn key:(NSString *)sKey {
NSMutableData * dTextIn;
CCCryptorStatus ccStatus = kCCSuccess;

// need to add 4 zeros as sTextIn will be a 4 digit PIN
sTextIn = [sTextIn stringByAppendingString:@""0000""];

// convert to data
dTextIn = [[sTextIn dataUsingEncoding: NSASCIIStringEncoding] mutableCopy];           

// key will be a 48 char hex stream, so process it down to 24 chars
const char * bytes = [sKey cStringUsingEncoding: NSUTF8StringEncoding];
NSUInteger length = strlen(bytes);
unsigned char * r = (unsigned char *) malloc(length / 2 + 1);
unsigned char * index = r;

while ((*bytes) &amp;&amp; (*(bytes +1))) {
    *index = strToChar(*bytes, *(bytes +1));
    index++;
    bytes+=2;
}
*index = '\0';

NSData *dKey = [NSData dataWithBytes: r length: length / 2];
free(r);

NSLog(@""doCipher3DES - key: %@"", dKey);

uint8_t *bufferPtr1 = NULL;    
size_t bufferPtrSize1 = 0;    
size_t movedBytes1 = 0;    
uint8_t iv[kCCBlockSize3DES];    
memset((void *) iv, 0x0, (size_t) sizeof(iv));    
bufferPtrSize1 = ([sTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES -1);    
bufferPtr1 = malloc(bufferPtrSize1 * sizeof(uint8_t));    
memset((void *)bufferPtr1, 0x00, bufferPtrSize1);    

ccStatus = CCCrypt(kCCEncrypt, // CCOperation op    
                   kCCAlgorithm3DES, // CCAlgorithm alg    
                   kCCOptionECBMode, // CCOptions options    
                   (const void *)[dKey bytes], // const void *key    
                   kCCKeySize3DES, // size_t keyLength    
                   nil, // const void *iv    
                   (const void *)[dTextIn bytes], // const void *dataIn
                   [dTextIn length],  // size_t dataInLength    
                   (void *)bufferPtr1, // void *dataOut    
                   bufferPtrSize1,     // size_t dataOutAvailable 
                   &amp;movedBytes1);      // size_t *dataOutMoved     

if (ccStatus == kCCParamError) NSLog(@""PARAM ERROR"");
else if (ccStatus == kCCBufferTooSmall) NSLog(@""BUFFER TOO SMALL"");
else if (ccStatus == kCCMemoryFailure) NSLog(@""MEMORY FAILURE"");
else if (ccStatus == kCCAlignmentError) NSLog(@""ALIGNMENT"");
else if (ccStatus == kCCDecodeError) NSLog(@""DECODE ERROR"");
else if (ccStatus == kCCUnimplemented) NSLog(@""UNIMPLEMENTED"");

NSString * sResult;    
NSData *dResult = [NSData dataWithBytes:bufferPtr1 length:movedBytes1];    

NSLog(@""doCipher3DES encrypted: %@"", dResult);

sResult = [Base64 encode:dResult];    

return sResult; }
</code></pre>

<p>The code for strToChar is as follows:</p>

<pre><code>unsigned char strToChar (char a, char b) {
char encoder[3] = {'\0','\0','\0'};
encoder[0] = a;
encoder[1] = b;
return (char) strtol(encoder,NULL,16); }
</code></pre>

<p>I hope this helps someone...</p>
","4716","<iphone><encryption><3des>","6","2","3","2011-05-19 18:45:23","2455758","0","3","","","","2010-03-16 13:37:59",""
"24384394","3des encryption in Node.JS returning invalid IV length","<p>I'm quite new to Node and have run into an issue with the encryption object:</p>

<pre><code>var des3_key = new Buffer(""redacted"", ""base64""); // copied from key in chilk
var des3_iv = new Buffer(""alsoredacted"", ""base64""); // copied from iv in chilk
var des3_encryption = crypto.createCipheriv(""des3"", des3_key, des3_iv);
// encode a string
var string_to_encode = ""thisisatest"";
var ciphered_string = des3_encryption.update(string_to_encode, ""utf8"", ""base64"");
console.log(string_to_encode+"" ""+ciphered_string);
</code></pre>

<p>Both in the Node console and when running on the server, line 6 causes an error <code>node-crypto: Invalid IV length 32</code> instead of returning an encryption object, as expected.</p>

<p>The key and IV I've removed and their encryption types are copied from another file but for the sake of testing I have tried various strings and encryption types but still get the same error, though with different lengths in the error.</p>

<p>My knowledge of encryption is limited to what I've used previously and not much else unfortunately, and I'm having trouble finding troubleshooting resources for Node in this regard. Any help would be appreciated.</p>

<p>Edit: Experimenting with des and des3 yields the same result.</p>
","<p>From OP's edit:</p>

<p>SOLVED:</p>

<p>Working code:</p>

<pre><code>var string_to_decode = ""encrypted string"";
var des_key = new Buffer(""key string"", ""base64"");
var des_iv = new Buffer(0);
var des_decryption = Crypto.createDecipheriv(""DES-EDE3"", des_key, des_iv);
var deciphered_string = des_decryption.update(string_to_decode, ""base64"", ""utf8"");
    console.log(""[""+string_to_decode+""] =&gt; [""+deciphered_string+""]"");
</code></pre>

<p>I found this by making a script to guess combinations of key and IV lengths, and encryption types and methods, and encoding types until it resulted in the correct string. It was a last resort but it worked.</p>
","4701","<javascript><node.js><encryption><3des><tripledes>","3","2","1","2015-12-01 16:22:45","34025051","3","","2180785","","2015-12-01 16:22:22","2014-06-24 10:34:35",""
"27196375","Where is the IV in Triple DES?","<p>I'm encrypt data using triple DES. It works fine, but I have a question. </p>

<p>Where can I see the initialization vector (IV)?</p>

<p>It's 3des encyption with BASE64Decoder.</p>

<pre><code>import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class Crypter {

    Cipher ecipher;
    Cipher dcipher;

    Crypter(String as_Phrase)
            throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException {
        this.ecipher = Cipher.getInstance(""DESede"");
        this.dcipher = Cipher.getInstance(""DESede"");
        this.ecipher.init(1, getSecretKey(as_Phrase));
        this.dcipher.init(2, getSecretKey(as_Phrase));

    }

    public String encrypt(String as_valueToEncrypt)
            throws BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException, IOException {
        byte[] lbarr_utf8 = as_valueToEncrypt.getBytes(""UTF8"");
        byte[] lbarr_enc = this.ecipher.doFinal(lbarr_utf8);

        return new BASE64Encoder().encode(lbarr_enc);
    }

    public String decrypt(String as_valueToDecrypt)
            throws BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException, IOException {
        byte[] lbarr_enc = new BASE64Decoder().decodeBuffer(as_valueToDecrypt);

        byte[] lbarr_utf8 = this.dcipher.doFinal(lbarr_enc);

        return new String(lbarr_utf8, ""UTF8"");
    }

    private SecretKey getSecretKey(String as_Phrase)
            throws UnsupportedEncodingException {
        return new SecretKeySpec(as_Phrase.getBytes(""UTF8""), ""DESede"");
    }
}
</code></pre>
","<p><code>Cipher</code> has <code>getIV()</code> method, which returns initialization vector.</p>
","4469","<java><encryption><3des><tripledes>","2","1","2","2014-11-29 09:22:51","27196696","2","3","1816580","","2014-11-28 22:36:12","2014-11-28 21:54:32",""
"27196375","Where is the IV in Triple DES?","<p>I'm encrypt data using triple DES. It works fine, but I have a question. </p>

<p>Where can I see the initialization vector (IV)?</p>

<p>It's 3des encyption with BASE64Decoder.</p>

<pre><code>import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

public class Crypter {

    Cipher ecipher;
    Cipher dcipher;

    Crypter(String as_Phrase)
            throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException {
        this.ecipher = Cipher.getInstance(""DESede"");
        this.dcipher = Cipher.getInstance(""DESede"");
        this.ecipher.init(1, getSecretKey(as_Phrase));
        this.dcipher.init(2, getSecretKey(as_Phrase));

    }

    public String encrypt(String as_valueToEncrypt)
            throws BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException, IOException {
        byte[] lbarr_utf8 = as_valueToEncrypt.getBytes(""UTF8"");
        byte[] lbarr_enc = this.ecipher.doFinal(lbarr_utf8);

        return new BASE64Encoder().encode(lbarr_enc);
    }

    public String decrypt(String as_valueToDecrypt)
            throws BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException, IOException {
        byte[] lbarr_enc = new BASE64Decoder().decodeBuffer(as_valueToDecrypt);

        byte[] lbarr_utf8 = this.dcipher.doFinal(lbarr_enc);

        return new String(lbarr_utf8, ""UTF8"");
    }

    private SecretKey getSecretKey(String as_Phrase)
            throws UnsupportedEncodingException {
        return new SecretKeySpec(as_Phrase.getBytes(""UTF8""), ""DESede"");
    }
}
</code></pre>
","<p>You can get the IV from the cipher:</p>

<pre><code>ecipher.getIV();
</code></pre>

<p>The problem is that the IV is generated during <code>init</code>. Since you <code>init</code> in the constructor you would run into the problem of using the same IV for every encryption of different ciphertexts. It's always best to generate a new <code>Cipher</code> and init it for every encryption and decryption operation separately.</p>

<p>You use the <code>DESede</code> cipher which is actually <code>DESede/ECB/PKCS5Padding</code>. Note that the mode is ECB which doesn't use an IV. So the above call returns <code>null</code>. Although this is the default mode, it is not recommended. It's safer to use <code>DESede/CBC/PKCS5Padding</code> which actually uses an IV.</p>

<p>So when you decrypt in CBC mode you need to pass that IV in:</p>

<pre><code>dcipher.init(2, new SecretKeySpec(key, ""DESede""), new IvParameterSpec(ecipher.getIV()));
</code></pre>

<p>To reduce the burden of passing the IV around you could then append the IV to the front of the ciphertext before encoding it and slice it off before decrypting the ciphertext. DES is a 64-bit cipher so your IV will be 8 bytes long.</p>
","4469","<java><encryption><3des><tripledes>","2","6","2","2014-11-29 09:22:51","27196696","2","3","1816580","","2014-11-28 22:36:12","2014-11-28 21:54:32",""
"13617807","Replicate T-SQL DecryptByPassPhrase in C#","<p>I wnat to create a C# class to decrypt a byte array encrypted using T-SQL's EncryptByPassPhrase.  (Yes, I know I could decrypt within SQL Server, but what I need is to be able to encrypt/decrypt within both the database tier and in the middle tier equivalently.)</p>

<p>I understand that SQL Server's EncryptByPassPhrase and DecryptByPassPhrase use the TripleDES symmetric key algorithm.  It's not clear to me, though, what the IV should to simulate SQL Server's cryptology.  I can encrypt/decrypt using the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"">TripleDESCryptoServiceProvider</a> class, but I can't find the correct implementation of key and IV to replicate what SQL Server is doing.</p>

<p>Has anyone done something similar?  Thanks!</p>
","<p>(1) Use C# to generate a key/iv pair:
                TripleDESCryptoServiceProvider cp = new TripleDESCryptoServiceProvider();</p>

<pre><code>            MemoryStream m = new MemoryStream(Convert.FromBase64String(Convert.ToBase64String(ASCIIEncoding.ASCII.GetBytes(plainText))));

            CryptoStream cs = new CryptoStream(m, cp.CreateEncryptor(cp.Key, cp.IV), CryptoStreamMode.Read);

            cp.Key = Convert.FromBase64String(""BeaYzNeHfDb27OFYgaYHUd5HUJE2aZyI"");
            cp.IV = Convert.FromBase64String(""T/ENF5G4sCA="");

            string key = Convert.ToBase64String(cp.Key);
            string iv = Convert.ToBase64String(cp.IV);
            // write key/iv to a file here 
</code></pre>

<p>(2) Once we have that, use code like this to encode</p>

<pre><code>            TripleDESCryptoServiceProvider cp = new TripleDESCryptoServiceProvider();
            MemoryStream m = new MemoryStream(Convert.FromBase64String(Convert.ToBase64String(ASCIIEncoding.ASCII.GetBytes(plainText))));

            CryptoStream cs = new CryptoStream(m, cp.CreateEncryptor(cp.Key, cp.IV), CryptoStreamMode.Read);

            cp.Key = Convert.FromBase64String(""the key value from above"");
            cp.IV = Convert.FromBase64String(""the iv value from above"");

            string key = Convert.ToBase64String(cp.Key);
            string iv = Convert.ToBase64String(cp.IV);

            List&lt;byte&gt; r = new List&lt;byte&gt;();
            int x = 0;
            for (; x &gt; -1; )
            {
                x = cs.ReadByte();
                if (x &gt; -1)
                    r.Add((byte)x);
            }
            byte[] y = r.ToArray();
            string cypherText = Convert.ToBase64String(y);
</code></pre>

<p>(3) Then to decode:</p>

<pre><code>            TripleDESCryptoServiceProvider cp = new TripleDESCryptoServiceProvider();
            MemoryStream m = new MemoryStream(Convert.FromBase64String(cypherText));
            cp.Key = Convert.FromBase64String(""the key value from above"");
            cp.IV = Convert.FromBase64String(""the iv value from above"");

            CryptoStream cs = new CryptoStream(m, cp.CreateDecryptor(cp.Key, cp.IV), CryptoStreamMode.Read);

            StreamReader reader = new StreamReader(cs);
            string plainText = reader.ReadToEnd();
</code></pre>
","4367","<c#><sql><encryption><3des>","9","-2","1","2013-05-21 22:00:42","16680226","0","2","","","","2012-11-29 02:18:21",""
"13402856","Triple DES encryption on C# and PHP yields different results","<p>I'm writing a simple encryption system for logging in but I've got small issue. 
C# encrypt function:</p>

<pre><code>public static string EncryptString(string Message, string Passphrase)
{
    byte[] Results;
    System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();

    // Step 1. We hash the passphrase using MD5
    // We use the MD5 hash generator as the result is a 128 bit byte array
    // which is a valid length for the TripleDES encoder we use below

    MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
    byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));

    // Step 2. Create a new TripleDESCryptoServiceProvider object
    TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

    // Step 3. Setup the encoder
    TDESAlgorithm.Key = TDESKey;
    TDESAlgorithm.Mode = CipherMode.ECB;
    TDESAlgorithm.Padding = PaddingMode.PKCS7;

    // Step 4. Convert the input string to a byte[]
    byte[] DataToEncrypt = UTF8.GetBytes(Message);

    // Step 5. Attempt to encrypt the string
    try
    {
        ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
        Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
    }
    finally
    {
        // Clear the TripleDes and Hashprovider services of any sensitive information
        TDESAlgorithm.Clear();
        HashProvider.Clear();
    }

    // Step 6. Return the encrypted string as a base64 encoded string
    return Convert.ToBase64String(Results);
}
</code></pre>

<p><code>EncryptString(""test"", ""123456"")</code> returns <code>""Yjaqhc7RFds=""</code>.</p>

<p>The same code in php:</p>

<pre><code>  &lt;?php
    $key = ""123456"";
    function pkcs7_pad($text, $blocksize)
    {
        $pad = $blocksize - (strlen($text) % $blocksize);
        return $text . str_repeat(chr($pad), $pad);
    }

    $input = pkcs7_pad(""test"", 16);
    $key = md5(utf8_encode($key), true);
    $td = mcrypt_module_open('tripledes', '', 'ecb', '');
    $iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $key, $iv);
    $encrypted_data = mcrypt_generic($td, $input);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);

    echo base64_encode($encrypted_data);
?&gt;
</code></pre>

<p>returns <code>""dybhiZYdKG8pNCgCFkbV6g==""</code>? What am I doing wrong?</p>
","<p>You're running into this problem because Triple DES's key size is 168 bits (21 bytes), but MD5 generates hashes that are only 16 bytes (128 bits) long.</p>

<p>This means the key will have to extended to 168 bits so Triple DES can work. It turns out that this derivation from 128 bits to 168 bits works differently in C# than it does in PHP, so the key that's effectively used is different, resulting in different encrypted data.</p>

<p>Now you have two options:</p>

<hr>

<h3>Option 1: Pick a cipher that supports 128-bit keys outright</h3>

<p>You can avoid all the problems related to key size differences if you use a cipher that supports 128-bit keys. This would require minimal changes to your code. You can use Rijndael (AES), for example. </p>

<p><strong>C#</strong>: Change <code>TripleDESCryptoServiceProvider</code> to <code>RijndaelManaged</code>.<br>
Everything else can stay pretty much the same. <a href=""http://ideone.com/huPErj"" rel=""nofollow""><strong>(Demo)</strong></a></p>

<p><strong>PHP</strong>: Use <code>MCRYPT_RIJNDAEL_128</code> instead of tripledes <a href=""http://ideone.com/TEU3zr"" rel=""nofollow""><strong>(Demo)</strong></a>:</p>

<pre><code>function encrypt_pkcs7($str, $key)
{
    $key = md5(utf8_encode($key), true);
    $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
    $pad = $block - (strlen($str) % $block);
    $str .= str_repeat(chr($pad), $pad);

    $ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $str, MCRYPT_MODE_ECB);
    return base64_encode($ciphertext);
}

echo encrypt_pkcs7('test', '123456');
</code></pre>

<p>Note that the effective key size of AES is larger than Triple DES. Although Triple DES' key is 168-bit long, it only offers 112 bits of security. I would pick this option if I were you.</p>

<hr>

<h3>Option 2: Use a 192-bit key instead of a 128-bit key</h3>

<p>If you use a larger key than Triple DES actually uses, C# and PHP seem to agree on how to reduce it to 168 bits. You can do this by using a hash function like SHA-256, which generates a 256-bit hash and trim it to 192 bits (24 bytes):</p>

<p><strong>C#</strong>: Use <code>SHA256CryptoServiceProvider</code> and <code>Array.Copy</code> to get a 192-bit key, and use that with the rest of your program: <a href=""http://ideone.com/emTLD9"" rel=""nofollow""><strong>(Demo)</strong></a></p>

<pre><code>SHA256CryptoServiceProvider HashProvider = new SHA256CryptoServiceProvider();
byte[] temp = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));
byte[] key = new byte[24];
Array.Copy(temp, key, 24);
</code></pre>

<p><strong>PHP</strong>: Use <code>hash()</code> with SHA-256 and <code>substr()</code> to get the 192-bit key</p>

<pre><code>function encrypt_pkcs7($str, $key)
{
    // derive 192-bit key using SHA-256
    $key = substr(hash('sha256', $key, true), 0, 24);
    $block = mcrypt_get_block_size(MCRYPT_3DES, MCRYPT_MODE_ECB);
    $pad = $block - (strlen($str) % $block);
    $str .= str_repeat(chr($pad), $pad);

    $ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $str, MCRYPT_MODE_ECB);
    return base64_encode($ciphertext);
}

echo encrypt_pkcs7('test', '123456');
</code></pre>

<p>It doesn't look like I can supply a 168-bit key to <code>TripleDESCryptoServiceProvider</code>, I don't know why.</p>

<hr>

<h3>Other considerations:</h3>

<ul>
<li><p>Consider using SSL; even if it's a self-signed cert. It beats re-inventing the wheel, a particularly dangerous task when cryptography is involved.</p></li>
<li><p>Consider using a mode of operation other than ECB (eg: CBC). Using ECB increases security risks. Read the <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""nofollow"">Wikipedia article on block cipher modes of operation</a>.</p></li>
<li><p>Unless you <strong>absolutely</strong> need to have a plaintext password (rarely the case), you should hash your passwords. Read <a href=""http://crackstation.net/hashing-security.htm"" rel=""nofollow"">this article on securing passwords.</a></p></li>
<li><p>Consider using a proper password-based key derivation function, like <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">PBKDF2</a> instead of a general purpose hash function like MD5 or the SHA family. This will make cracking the key harder. For more information, read the article in the previous bullet point.</p></li>
</ul>
","4237","<c#><php><encryption><3des>","3","7","1","2014-03-07 15:54:01","13404970","14","2","396458","","2012-11-15 19:52:54","2012-11-15 17:21:33",""
"9101314","Objective-C Encryption libraries on iPhone?","<p>Are there any ready-to-use encryption libraries for the iPhone? 3DES, AES/Rijndael, whatever. I need to encrypt and decrypt strings. My understanding of Objective-C is that you can use C code inside of Objective-C methods/functions/whatever they're called.</p>
","<p>That is correct, you can use any C code you want in Objective - C, since it is a proper superset of C.</p>
","4199","<iphone><objective-c><encryption><aes><3des>","1","1","4","2012-02-01 18:47:14","","0","","","","","2012-02-01 18:38:00",""
"9101314","Objective-C Encryption libraries on iPhone?","<p>Are there any ready-to-use encryption libraries for the iPhone? 3DES, AES/Rijndael, whatever. I need to encrypt and decrypt strings. My understanding of Objective-C is that you can use C code inside of Objective-C methods/functions/whatever they're called.</p>
","<p>don't forget you could always use c++ source code in your obj-c project and there are many c++ encryption libraries like : <a href=""http://libtomcrypt.com/"" rel=""nofollow"">LibTomCrypt</a></p>

<p>add c++ code to your project and simply call functions;</p>
","4199","<iphone><objective-c><encryption><aes><3des>","1","0","4","2012-02-01 18:47:14","","0","","","","","2012-02-01 18:38:00",""
"9101314","Objective-C Encryption libraries on iPhone?","<p>Are there any ready-to-use encryption libraries for the iPhone? 3DES, AES/Rijndael, whatever. I need to encrypt and decrypt strings. My understanding of Objective-C is that you can use C code inside of Objective-C methods/functions/whatever they're called.</p>
","<p>Take a look at <a href=""http://www.example-code.com/objc/crypt2_3des.asp"" rel=""nofollow"">http://www.example-code.com/objc/crypt2_3des.asp</a></p>
","4199","<iphone><objective-c><encryption><aes><3des>","1","0","4","2012-02-01 18:47:14","","0","","","","","2012-02-01 18:38:00",""
"9101314","Objective-C Encryption libraries on iPhone?","<p>Are there any ready-to-use encryption libraries for the iPhone? 3DES, AES/Rijndael, whatever. I need to encrypt and decrypt strings. My understanding of Objective-C is that you can use C code inside of Objective-C methods/functions/whatever they're called.</p>
","<p>iPhone comes out of the box with the CommonCrypto library. It has various support for encryption. See the <a href=""http://developer.apple.com/library/#codinghowtos/Security/_index.html"" rel=""nofollow"">Security Coding How-to</a> from Apple.</p>
","4199","<iphone><objective-c><encryption><aes><3des>","1","4","4","2012-02-01 18:47:14","","0","","","","","2012-02-01 18:38:00",""
"6966419","ISO 9797 padding method 2 and MAC generation in java","<p>I'm hoping that some of you may be able to help me on this issue.</p>

<p>I've used the SmartCardShell program to run a javascript code that extracts the data off a British e-Passport.</p>

<p>I'm trying to replicate the code in java for my dissertation. However I am stumped on the MAC generation. </p>

<p>The javascript code for the data encryption and MAC generation is:</p>

<pre><code>var cryptogram = crypto.encrypt(kenc, Crypto.DES_CBC, plain, new ByteString(""0000000000000000"", HEX));
print(""Cryptogram   : "" + cryptogram);'

var mac = crypto.sign(kmac, Crypto.DES_MAC_EMV, cryptogram.pad(Crypto.ISO9797_METHOD_2));
print(""MAC          : "" + mac);
</code></pre>

<p>I've managed to correctly verify that my encryption key (Kenc) is generated correctly.</p>

<p>Going off the script code, the MAC key (Kmac) is also a triple DES key which is done via:</p>

<pre><code>byte[] kmackey = new byte[24];
System.arraycopy(kmac, 0, kmackey, 0, kmac.length);
System.arraycopy(kmac, 0, kmackey, kmac.length, 8);
System.out.println(""kmackey = "" + ConvertToHex.convertToHex(kmackey));

DESedeKeySpec desedekey = new DESedeKeySpec(kmackey);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DESede"");
Key KMac = keyFactory.generateSecret(desedekey);
</code></pre>

<p>As seen above, the javascript code ""signs"" the data with the Kmac key, the DES_MAC_EMV mechanism and pads the cryptogram data with the ISO 9797 padding method 2 - which I believe is called ""bit padding"".</p>

<p>Can anyone assist me in creating/explaining to me a Java equivalent of the DES_MAC_EMV mechanism and the ISO 9797 padding method 2?</p>

<p>Appreciate the help</p>

<p>Just to add as I forgot to mention it, I am creating a system to connect to the e-Passport and extract data. At the minute I am verifying the data I obtained from the SmartCardShell program/javascript code. This is not a javacard applet/application, it is solely a Java ""host"" application</p>

<p>HSK</p>
","<h3>Padding</h3>

<p>Padding is actually very simple. Some places refer to the padding method 2 of ISO 9797-1 as <em>Bit Padding</em>. You basically add a single 0x80 byte at the end and then append sufficient number of 0x00 so that the total length of the message is a multiple of 8.</p>

<h3>Encryption</h3>

<p>DES_MAC_EMV in the above code is more formally named <strong>ISO 9797-1 Algorithm 3</strong>. Some articles/ websites also refer to it as <em>Retail MAC algorithm</em>.</p>

<p>You need two 8 byte keys for this algorithm and perform 3DES as defined below. Please note that this is my understanding of the algorithm (off-my-head); please read the formal specs for a ""correct"" understanding:</p>

<ol>
<li>First do the required padding</li>
<li>Use an initialisation vector of 0 (all zeroes)</li>
<li>Chain and encrypt 8 bit blocks using the first key (as in
single DES)</li>
<li>The final block needs a 3DES application; hence decrypt using the second key and encrypt it with the first key again</li>
</ol>
","4141","<java><macos><des><3des>","0","1","1","2011-08-11 11:00:29","","0","","","","","2011-08-06 11:12:18",""
"8943873","Decrypting in PHP a string encoded 3DES with C#","<p>I have to decrypt in PHP a string encoded with this C# class (it's <a href=""http://www.deltasblog.co.uk/code-snippets/basic-encryptiondecryption-c/"" rel=""nofollow"">here</a>)</p>

<pre>
using System;
using System.Security.Cryptography;
using System.Text;

public static class Encryption
{
   public static string Encrypt(string input, string key)
   {
      byte[] inputArray = UTF8Encoding.UTF8.GetBytes(input);
      TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
      tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
      tripleDES.Mode = CipherMode.ECB;
      tripleDES.Padding = PaddingMode.PKCS7;
      ICryptoTransform cTransform = tripleDES.CreateEncryptor();
      byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
      tripleDES.Clear();
      return Convert.ToBase64String(resultArray, 0, resultArray.Length);
   }

   public static string Decrypt(string input, string key)
   {
      byte[] inputArray = Convert.FromBase64String(input);
      TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
      tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
      tripleDES.Mode = CipherMode.ECB;
      tripleDES.Padding = PaddingMode.PKCS7;
      ICryptoTransform cTransform = tripleDES.CreateDecryptor();
      byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
      tripleDES.Clear();
      return UTF8Encoding.UTF8.GetString(resultArray);
   }
}

</pre>

<p>I've tried different examples found around on the web, but nothing seems to work. I think that the first problems comes with the $iv parameter in php mcrypt_generic_init and then another problem comes with padding that is missing in php functions.
Can you please help me to convert the c# Decrypt function above in PHP?
Thank you.</p>
","<p>Because the IV does not matter in ECB mode, we can ignore it.  However, mcrypt isn't very lenient.  We still need to provide <em>an</em> IV, even if it's fake.  </p>

<pre><code>// We'll be encrypting this data
    $key = 'password';
    $data = 'The quick brown fox jumped over the lazy dogs.';
    $encrypted = null;

// 3des in ECB mode
    $m = mcrypt_module_open(MCRYPT_3DES, null, MCRYPT_MODE_ECB, null);
// Our IV will be enough NUL bytes to satisfy mcrypt.
    $fake_iv = str_repeat(chr(0), mcrypt_enc_get_iv_size($m));
    mcrypt_generic_init($m, $key, $fake_iv);
    $encrypted = mcrypt_generic($m, $data);
// ""s/6HOXpVyMyFdSPYUgIgneMRY0o3Kubkwc++hSg9kC4Sw0TWsNTqzrhXY3z4PH9w""
    echo base64_encode($encrypted), ""\n"";
    unset($m);

// And now, in reverse!
    $n = mcrypt_module_open(MCRYPT_3DES, null, MCRYPT_MODE_ECB, null);
// Another fake IV
    $fake_iv = str_repeat(chr(0), mcrypt_enc_get_iv_size($n));
    mcrypt_generic_init($n, $key, $fake_iv);
    $original = mdecrypt_generic($n, $encrypted);
// string(48) ""The quick brown fox jumped over the lazy dogs.""
    var_dump($original);
</code></pre>

<p>Again, you'll only want to do this if you stick with ECB mode.  ECB mode can be pretty awful.  You might want to review <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""nofollow"">the Wikipedia article on block cipher modes</a> for more information.</p>

<p>The only thing not handled here is the padding.  mcrypt doesn't let you pick the padding method, and does something different depending on the cipher.  Generally, it does not add any padding at all.  </p>

<p>If your padding method of choice uses NUL bytes, you'll need to pre-pad the data yourself to ensure interoperability.  You can use <a href=""http://us2.php.net/manual/en/function.mcrypt-get-block-size.php"" rel=""nofollow""><code>mcrypt_get_block_size</code></a> and <a href=""http://us2.php.net/manual/en/function.str-pad.php"" rel=""nofollow""><code>str_pad</code></a> with the <code>STR_PAD_RIGHT</code> option to do this.</p>

<p>Likewise, you might need to trim NUL bytes off of the right after you decrypt.  The second parameter to <a href=""http://us2.php.net/manual/en/function.trim.php"" rel=""nofollow""><code>trim</code></a> will help.</p>
","4135","<php><encryption><3des><tripledes>","0","2","2","2015-03-14 04:36:10","","5","","","","","2012-01-20 15:37:11",""
"8943873","Decrypting in PHP a string encoded 3DES with C#","<p>I have to decrypt in PHP a string encoded with this C# class (it's <a href=""http://www.deltasblog.co.uk/code-snippets/basic-encryptiondecryption-c/"" rel=""nofollow"">here</a>)</p>

<pre>
using System;
using System.Security.Cryptography;
using System.Text;

public static class Encryption
{
   public static string Encrypt(string input, string key)
   {
      byte[] inputArray = UTF8Encoding.UTF8.GetBytes(input);
      TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
      tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
      tripleDES.Mode = CipherMode.ECB;
      tripleDES.Padding = PaddingMode.PKCS7;
      ICryptoTransform cTransform = tripleDES.CreateEncryptor();
      byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
      tripleDES.Clear();
      return Convert.ToBase64String(resultArray, 0, resultArray.Length);
   }

   public static string Decrypt(string input, string key)
   {
      byte[] inputArray = Convert.FromBase64String(input);
      TripleDESCryptoServiceProvider tripleDES = new TripleDESCryptoServiceProvider();
      tripleDES.Key = UTF8Encoding.UTF8.GetBytes(key);
      tripleDES.Mode = CipherMode.ECB;
      tripleDES.Padding = PaddingMode.PKCS7;
      ICryptoTransform cTransform = tripleDES.CreateDecryptor();
      byte[] resultArray = cTransform.TransformFinalBlock(inputArray, 0, inputArray.Length);
      tripleDES.Clear();
      return UTF8Encoding.UTF8.GetString(resultArray);
   }
}

</pre>

<p>I've tried different examples found around on the web, but nothing seems to work. I think that the first problems comes with the $iv parameter in php mcrypt_generic_init and then another problem comes with padding that is missing in php functions.
Can you please help me to convert the c# Decrypt function above in PHP?
Thank you.</p>
","<p>Even I tried today code for both PHP and C#</p>

<pre><code>&lt;?php
$key64 = ""YOUR_KEY"";
$iv64 = ""YOUR_IV"";


$keybytes = base64_decode($key64);
$ivbytes = base64_decode($iv64);

$text = (""4111111111111111"");

// Padding the text
$padding = strlen($text)%8;
for($i=$padding; $i&lt;8; $i++){
   $text .= chr(8-$padding);
}

$decryptRaw = mcrypt_encrypt(MCRYPT_3DES, $keybytes, $text, MCRYPT_MODE_CBC, $ivbytes);
$encoded = base64_encode($decryptRaw);

print ""$encoded&lt;br/&gt;"";
$encryptedString64 = $encoded;
$decryptbytes = base64_decode($encryptedString64);

$decryptRaw = mcrypt_decrypt(MCRYPT_3DES, $keybytes, $decryptbytes, MCRYPT_MODE_CBC, $ivbytes);
$decryptString=trim($decryptRaw,""\x00..\x1F"");
print ""$decryptString&lt;br/&gt;"";

?&gt;
</code></pre>

<p>C#</p>

<pre><code>private string Decrypt(string encryptedValue)
{
    SymmetricAlgorithm tripleDESKey = SymmetricAlgorithm.Create(""TripleDES"") ;
    tripleDESKey.Key = Convert.FromBase64String(""YOUR_KEY"");
    tripleDESKey.IV = Convert.FromBase64String(""YOUR_IV"") ;

    MemoryStream encryptedStream = new MemoryStream();
    encryptedStream.Write(Convert.FromBase64String(encryptedValue), 0,
    Convert.FromBase64String(encryptedValue).Length);
    encryptedStream.Position = 0;
    CryptoStream cs = new CryptoStream(encryptedStream,
    tripleDESKey.CreateDecryptor(), CryptoStreamMode.Read);
    MemoryStream decryptedStream = new MemoryStream();

    byte[] buf = new byte[2049];
    int bytesRead = 0;
    bytesRead = cs.Read(buf, 0, buf.Length);
    while ((bytesRead &gt; 0))
    {
        decryptedStream.Write(buf, 0, bytesRead);
        bytesRead = cs.Read(buf, 0, buf.Length);
    }
    return Encoding.ASCII.GetString(decryptedStream.ToArray());
}
private string Encrypt(string encrypt)
{
    SymmetricAlgorithm sa = SymmetricAlgorithm.Create(""TripleDES"") ;
    sa.Key = Convert.FromBase64String(""YOUR_KEY"");
    sa.IV = Convert.FromBase64String(""YOUR_IV"") ;
    byte[] inputByteArray = Encoding.ASCII.GetBytes(encrypt);
    MemoryStream mS = new MemoryStream();
    ICryptoTransform trans = sa.CreateEncryptor();
    byte[] buf = new byte[2049];
    CryptoStream cs = new CryptoStream(mS, trans, CryptoStreamMode.Write);
    cs.Write(inputByteArray, 0, inputByteArray.Length);
    cs.FlushFinalBlock();
    return Convert.ToBase64String(mS.ToArray());
}
</code></pre>
","4135","<php><encryption><3des><tripledes>","0","2","2","2015-03-14 04:36:10","","5","","","","","2012-01-20 15:37:11",""
"31433162","MD5 3DES encryption Swift","<p>I have an app that must send login credentials that have been encrypted first by MD5 and then by 3DES.</p>

<p>I have managed to use CryptoSwift to encrypt the string by MD5.
However I cannot find anything to encrypt by 3DES on Swift.</p>

<p>I have tried CommonCrypto. As far as I can tell this is in C but could be imported into Objective C with a bridging header.</p>

<p>I have found a few articles and tutorials that tell me how to import CommonCrypto into Swift, either by a bridging header(with the warning it will not work with frameworks) or by Model.map. However neither are working. Im not sure if this is a limitation in the latest versions of iOS or Xcode.</p>

<p>Could someone please advise an alternative?</p>

<p>Thanks</p>

<p>EDITED</p>

<p>Hi, please see the below steps I have taken </p>

<ol>
<li>Ok so I created a new project called newEncrypt.</li>
<li>I chose not to use the header option as the instructions say this is limited to non Framework apps/</li>
<li>I created a folder inside newEncrypt called CommonCrypto, with a module.map file inside. the contents of which are: module CommonCrypto [system] {
header ""/usr/include/CommonCrypto/CommonCrypto.h""
export *
}</li>
<li>added ${SRCROOT}/CommonCrypto to swift compiler-search paths-import paths. Debug and release.</li>
<li>This is where the instructions sort of stop. I assume I need to import CommonCrypto into my class. This error with “could not build objective C module ‘CommonCrypto’.
Im also assuming I should have the CommonCrypto library files (from the CommonCryto ‘include’ folder) in ""/usr/include/CommonCrypto/CommonCrypto.h"" or “/newEncrypt/CommonCrypto/CommonCrypto.h""?
I have tried this, but I just get the same errors.</li>
<li>I have then tried to ad a header file with #import   and added -lfoo to other linker flags debug and release (although this may not be the correct one) ust in case this could still be required. But I still get the same could not build objective c error.
Im sure I am doing something wrong thats obvious</li>
</ol>
","<p>So it turns out I was completely overcomplicating this. </p>

<p>There is a really useful article already
<a href=""http://www.stackoverflow.dluat.com/questions/31004609/how-to-convert-common-crypto-code-from-objective-c-to-swift"" rel=""noreferrer"">http://www.stackoverflow.dluat.com/questions/31004609/how-to-convert-common-crypto-code-from-objective-c-to-swift</a></p>

<p>I didn't need to import any external libraries or SDKs, all I needed was a bridging header and to <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code></p>

<pre><code>override func viewDidLoad() {
    super.viewDidLoad()
    myEncrypt(""my string to encrypt"") 
}

func myEncrypt(encryptData:String) -&gt; NSData?{

        var myKeyData : NSData = (""myEncryptionKey"" as NSString).dataUsingEncoding(NSUTF8StringEncoding)!
        var myRawData : NSData = encryptData.dataUsingEncoding(NSUTF8StringEncoding)!
        var iv : [UInt8] = [56, 101, 63, 23, 96, 182, 209, 205]  // I didn't use
        var buffer_size : size_t = myRawData.length + kCCBlockSize3DES
        var buffer = UnsafeMutablePointer&lt;NSData&gt;.alloc(buffer_size)
        var num_bytes_encrypted : size_t = 0

        let operation: CCOperation = UInt32(kCCEncrypt)
        let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
        let options:   CCOptions   = UInt32(kCCOptionECBMode + kCCOptionPKCS7Padding)
        let keyLength        = size_t(kCCKeySize3DES)

        var Crypto_status: CCCryptorStatus = CCCrypt(operation, algoritm, options, myKeyData.bytes, keyLength, nil, myRawData.bytes, myRawData.length, buffer, buffer_size, &amp;num_bytes_encrypted)

        if UInt32(Crypto_status) == UInt32(kCCSuccess){

            var myResult: NSData = NSData(bytes: buffer, length: num_bytes_encrypted)

            free(buffer)
            println(""my result \(myResult)"") //This just prints the data

            let keyData: NSData = myResult
            let hexString = keyData.toHexString()
            println(""hex result \(hexString)"") // I needed a hex string output


            myDecrypt(myResult) // sent straight to the decryption function to test the data output is the same
            return myResult
        }else{
            free(buffer)
            return nil
        }   
    }


func myDecrypt(decryptData : NSData) -&gt; NSData?{

    var mydata_len : Int = decryptData.length
    var keyData : NSData = (""myEncryptionKey"" as NSString).dataUsingEncoding(NSUTF8StringEncoding)!

    var buffer_size : size_t = mydata_len+kCCBlockSizeAES128
    var buffer = UnsafeMutablePointer&lt;NSData&gt;.alloc(buffer_size)
    var num_bytes_encrypted : size_t = 0

    var iv : [UInt8] = [56, 101, 63, 23, 96, 182, 209, 205]  // I didn't use

    let operation: CCOperation = UInt32(kCCDecrypt)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
    let options:   CCOptions   = UInt32(kCCOptionECBMode + kCCOptionPKCS7Padding)
    let keyLength        = size_t(kCCKeySize3DES)

    var decrypt_status : CCCryptorStatus = CCCrypt(operation, algoritm, options, keyData.bytes, keyLength, nil, decryptData.bytes, mydata_len, buffer, buffer_size, &amp;num_bytes_encrypted)

    if UInt32(decrypt_status) == UInt32(kCCSuccess){

        var myResult : NSData = NSData(bytes: buffer, length: num_bytes_encrypted)
        free(buffer)
        println(""decrypt \(myResult)"")

        var stringResult = NSString(data: myResult, encoding:NSUTF8StringEncoding)
        println(""my decrypt string \(stringResult!)"")
        return myResult
    }else{
        free(buffer)
        return nil

    }
}
</code></pre>

<p>I hope this helps someone. </p>
","4120","<swift><encryption><md5><3des><commoncrypto>","2","9","1","2015-11-05 11:10:32","31964639","7","1","5119823","","2015-07-16 09:04:32","2015-07-15 14:25:18",""
"40028702","Encrypt a string in Delphi 7 using DCPCrypt (3DES)","<p>I need to encrypt a string in Delphi 7. The only encryption library I managed to get running is DCPCrypt.</p>

<p>I studied an example that encrypted files, and tried to adapt it for strings, but I'm afraid I failed miserably...</p>

<p>This is my function:</p>

<pre><code>function Encrypt3DES(psString, psKey: string): string;
var
    lCipher:TDCP_3des;
    CipherIV: array of byte;     // the initialisation vector (for chaining modes)
    lHash:TDCP_sha256;
    lHashDigest: array of byte;   // the result of hashing the passphrase with the salt
    Salt: array[0..7] of byte;   // a random salt to help prevent precomputated attacks
    i:integer;
begin
    lHash:=TDCP_sha256.Create(nil);
    SetLength(lHashDigest,lHash.HashSize div 8);
    for i := 0 to 7 do
      Salt[i] := Random(256);  // just fill the salt with random values (crypto secure PRNG would be better but not _really_ necessary)

    //strmOutput.WriteBuffer(Salt,Sizeof(Salt));  // write out the salt so we can decrypt! ***I don't know what to do with this***

    lHash.Init;
    lHash.Update(Salt[0],Sizeof(Salt));   // hash the salt
    lHash.UpdateStr(psKey);  // and the passphrase
    lHash.Final(lHashDigest[0]);           // store the output in HashDigest

    lCipher:=TDCP_3des.Create(nil);
    //3DES is a block cipher, we need an initialisation vector

    SetLength(CipherIV,TDCP_blockcipher(lCipher).BlockSize div 8);
    for i := 0 to (Length(CipherIV) - 1) do
      CipherIV[i] := Random(256);           // again just random values for the IV

    //strmOutput.WriteBuffer(CipherIV[0],Length(CipherIV));  // write out the IV so we can decrypt! ***I don't know what to do with this***

    lCipher.Init(lHashDigest[0],TNeo.Min(lCipher.MaxKeySize,lHash.HashSize),CipherIV);  // initialise the cipher with the hash as key
    TDCP_blockcipher(lCipher).CipherMode := cmCBC;   // use CBC chaining when encrypting

    //lCipher.EncryptStream(strmInput,strmOutput,strmInput.Size); // encrypt the entire file
    result:=lCipher.EncryptString(psString);
    lCipher.Burn;   // important! get rid of keying information
    //strmInput.Free;
    //strmOutput.Free;
end;
</code></pre>

<p>Please, bear in mind that I am completely ignorant on how encryption works. I know you don't encrypt string, but binaries, but I don't know how to translate that to code.
Every time I run it, I get a different result (I guess it's normal if you use random values), but I don't know if it should be like that, since I have to send this to another server so they can check the integrity there.</p>

<p>Thay gave me a Java function in the API, but obviously I can't use it:</p>

<pre><code>public byte [] encrypt_3DES(final String claveHex, final String datos) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
    byte [] ciphertext = null;
    // Crea la clave
    DESedeKeySpec desKeySpec = new DESedeKeySpec(toByteArray(claveHex));
    SecretKey desKey = new SecretKeySpec(desKeySpec.getKey(), ""DESede"");
    // Crea un cifrador
    Cipher desCipher = Cipher.getInstance(""DESede/CBC/NoPadding"");

    // Inicializa el cifrador para encriptar
    desCipher.init(Cipher.ENCRYPT_MODE, desKey, new IvParameterSpec(IV));

    // Se añaden los 0 en bytes necesarios para que sea un múltiplo de 8
    int numeroCerosNecesarios = 8 - (datos.length() % 8);
    if (numeroCerosNecesarios == 8) {
        numeroCerosNecesarios = 0;
    }
    ByteArrayOutputStream array = new ByteArrayOutputStream();
    array.write(datos.getBytes(""UTF-8""), 0, datos.length());
    for (int i = 0; i &lt; numeroCerosNecesarios; i++) {
        array.write(0);
    }
    byte [] cleartext = array.toByteArray();
    // Encripta el texto
    ciphertext = desCipher.doFinal(cleartext);
    return ciphertext;
}
</code></pre>

<p>I any kind soul could give me a hand with this, I'd be really grateful. I've been banging my head against this for several days.</p>

<p>Thanks in advance.</p>
","<p>This example uses the Open Source TLockBox library to encrypt/decrypt a string using 3DES <a href=""https://sourceforge.net/p/tplockbox/wiki/Home/"" rel=""nofollow"">https://sourceforge.net/p/tplockbox/wiki/Home/</a>    </p>

<pre><code>unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls,
  //lockbox units 
  LbCipher, LbClass, LbAsym, LbRSA, LbString;

type
  TForm1 = class(TForm)
    edPlainText: TEdit;
    edCipherText: TEdit;
    btnEncryptString: TButton;
    btnDescryptString: TButton;
    procedure btnEncryptStringClick(Sender: TObject);
    procedure btnDescryptStringClick(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

Function TripleDesEncrypt(const APlaintext, APassphrase: String): String;
Var
  Key128: TKey128;
begin
  GenerateLMDKey(Key128, SizeOf(Key128), APassphrase);
  result  := TripleDESEncryptStringEx(APlainText, Key128, True);
End;

Function TripleDesDecrypt(const ACipherText, APassphrase: String): String;
Var
  Key128: TKey128;
begin
  GenerateLMDKey(Key128, SizeOf(Key128), APassphrase);
  Try
    result := TripleDESEncryptStringEx(ACipherText, Key128, False);
  Except
    Result := '';
  End;
End;

procedure TForm1.btnEncryptStringClick(Sender: TObject);
begin
  edCipherText.text := TripleDesEncrypt(edPlainText.Text, 'SecretPassphrase');
end;

procedure TForm1.btnDescryptStringClick(Sender: TObject);
begin
  edPlainText.text := TripleDesDecrypt(edCipherText.text, 'SecretPassphrase');
end;

end.
</code></pre>
","4043","<delphi><encryption><delphi-7><3des>","-2","1","2","2016-10-17 17:52:41","40047580","9","3","","","","2016-10-13 18:47:35",""
"40028702","Encrypt a string in Delphi 7 using DCPCrypt (3DES)","<p>I need to encrypt a string in Delphi 7. The only encryption library I managed to get running is DCPCrypt.</p>

<p>I studied an example that encrypted files, and tried to adapt it for strings, but I'm afraid I failed miserably...</p>

<p>This is my function:</p>

<pre><code>function Encrypt3DES(psString, psKey: string): string;
var
    lCipher:TDCP_3des;
    CipherIV: array of byte;     // the initialisation vector (for chaining modes)
    lHash:TDCP_sha256;
    lHashDigest: array of byte;   // the result of hashing the passphrase with the salt
    Salt: array[0..7] of byte;   // a random salt to help prevent precomputated attacks
    i:integer;
begin
    lHash:=TDCP_sha256.Create(nil);
    SetLength(lHashDigest,lHash.HashSize div 8);
    for i := 0 to 7 do
      Salt[i] := Random(256);  // just fill the salt with random values (crypto secure PRNG would be better but not _really_ necessary)

    //strmOutput.WriteBuffer(Salt,Sizeof(Salt));  // write out the salt so we can decrypt! ***I don't know what to do with this***

    lHash.Init;
    lHash.Update(Salt[0],Sizeof(Salt));   // hash the salt
    lHash.UpdateStr(psKey);  // and the passphrase
    lHash.Final(lHashDigest[0]);           // store the output in HashDigest

    lCipher:=TDCP_3des.Create(nil);
    //3DES is a block cipher, we need an initialisation vector

    SetLength(CipherIV,TDCP_blockcipher(lCipher).BlockSize div 8);
    for i := 0 to (Length(CipherIV) - 1) do
      CipherIV[i] := Random(256);           // again just random values for the IV

    //strmOutput.WriteBuffer(CipherIV[0],Length(CipherIV));  // write out the IV so we can decrypt! ***I don't know what to do with this***

    lCipher.Init(lHashDigest[0],TNeo.Min(lCipher.MaxKeySize,lHash.HashSize),CipherIV);  // initialise the cipher with the hash as key
    TDCP_blockcipher(lCipher).CipherMode := cmCBC;   // use CBC chaining when encrypting

    //lCipher.EncryptStream(strmInput,strmOutput,strmInput.Size); // encrypt the entire file
    result:=lCipher.EncryptString(psString);
    lCipher.Burn;   // important! get rid of keying information
    //strmInput.Free;
    //strmOutput.Free;
end;
</code></pre>

<p>Please, bear in mind that I am completely ignorant on how encryption works. I know you don't encrypt string, but binaries, but I don't know how to translate that to code.
Every time I run it, I get a different result (I guess it's normal if you use random values), but I don't know if it should be like that, since I have to send this to another server so they can check the integrity there.</p>

<p>Thay gave me a Java function in the API, but obviously I can't use it:</p>

<pre><code>public byte [] encrypt_3DES(final String claveHex, final String datos) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {
    byte [] ciphertext = null;
    // Crea la clave
    DESedeKeySpec desKeySpec = new DESedeKeySpec(toByteArray(claveHex));
    SecretKey desKey = new SecretKeySpec(desKeySpec.getKey(), ""DESede"");
    // Crea un cifrador
    Cipher desCipher = Cipher.getInstance(""DESede/CBC/NoPadding"");

    // Inicializa el cifrador para encriptar
    desCipher.init(Cipher.ENCRYPT_MODE, desKey, new IvParameterSpec(IV));

    // Se añaden los 0 en bytes necesarios para que sea un múltiplo de 8
    int numeroCerosNecesarios = 8 - (datos.length() % 8);
    if (numeroCerosNecesarios == 8) {
        numeroCerosNecesarios = 0;
    }
    ByteArrayOutputStream array = new ByteArrayOutputStream();
    array.write(datos.getBytes(""UTF-8""), 0, datos.length());
    for (int i = 0; i &lt; numeroCerosNecesarios; i++) {
        array.write(0);
    }
    byte [] cleartext = array.toByteArray();
    // Encripta el texto
    ciphertext = desCipher.doFinal(cleartext);
    return ciphertext;
}
</code></pre>

<p>I any kind soul could give me a hand with this, I'd be really grateful. I've been banging my head against this for several days.</p>

<p>Thanks in advance.</p>
","<p>I found out later that I was using the wrong DCPCrypt function as a guide.
I'll post the other one I found, in case someone needs to use DCPCrypt:</p>

<pre><code>function Encrypt3DES(psData, psKey: string): string;
var
    Cipher: TDCP_3des;
begin
    Cipher:= TDCP_3des.Create(nil);
    Cipher.InitStr(psKey,TDCP_sha256);         // initialize the cipher with a hash of the passphrase
    result:=Cipher.EncryptString(psData);
    Cipher.Burn;
    Cipher.Free;
end;
</code></pre>
","4043","<delphi><encryption><delphi-7><3des>","-2","0","2","2016-10-17 17:52:41","40047580","9","3","","","","2016-10-13 18:47:35",""
"4090098","What would be ""openssl enc -a -e -salt -des3 -pass pass:abc123"" equivalent in .NET?","<p>My .Net application need to communicate with Linux based system which is using following command line to encrypt their messages:</p>

<pre><code>openssl enc -a -e -salt -des3 -pass pass:abc123
</code></pre>

<p>How would be equivalent code to encrypt/decrypt messages in c# look like?</p>

<p>I understand that I should use <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"" rel=""nofollow"">TripleDES</a> in <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.ciphermode.aspx"" rel=""nofollow"">CBC mode</a> with <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.paddingmode.aspx"" rel=""nofollow"">PKCS7 padding</a>. What I don't know is what <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.blocksize.aspx"" rel=""nofollow"">block size</a> and <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.symmetricalgorithm.iv.aspx"" rel=""nofollow"">initialization vector (IV)</a> should I use.</p>

<p>Also I am confused how should I derive key from password. Should I use <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.passwordderivebytes.aspx"" rel=""nofollow"">PBKDF1</a> or <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx"" rel=""nofollow"">PBKDF2</a> and what salt should I use?</p>

<p>So what seems to be a quite standard job ends for me with all night puzzle. Can anybody help me?</p>
","<p>So here is the trick:</p>

<pre><code>&gt; openssl enc -a -e -salt -des3 -P -pass pass:abc123
salt=17685C0658F85BA4
key=1CB6E5A0AA4953EC2323CBA021EF008C9193F5F29990DE87
iv =9148EB5B2BF2E9B2
</code></pre>

<p>If I feed <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes.aspx"" rel=""noreferrer"">TripleDES</a> algorithm the output is almost same as openssl output. Only difference is extra 16 bytes at the beginning of the openssl output. The first eight of these bytes is ""Salted__"" text and the second eight is the salt.</p>

<p>Salt is random. So how should I derive key and iv from password and salt? <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.passwordderivebytes.aspx"" rel=""noreferrer"">PBKDF1</a> nor <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rfc2898derivebytes.aspx"" rel=""noreferrer"">PBKDF2</a> doesn't qualify.</p>

<p>So here is the second trick:</p>

<pre><code>A = MD5(pwd + SALT)
B = MD5(A + PWD + SALT)
KEY + IV = A + B
</code></pre>

<p>Plus sign stands for concatenation, Key is 24 bytes long and IV is 8 bytes long.</p>

<p>I learned these trick from <a href=""http://deusty.blogspot.com/2009/04/decrypting-openssl-aes-files-in-c.html"" rel=""noreferrer"">Deusty blog</a> where he do similar stuff with AES.</p>
","3974","<.net><openssl><3des><pkcs#5>","4","6","1","2010-11-05 10:42:34","4105131","0","3","","","","2010-11-03 18:01:55",""
"3149288","How to perform Triple DES calculations in Ruby in hexadecimal?","<p>I'm trying to do some triple DES encryption in Ruby.  I'm trying to replicate the results from this page: <a href=""http://da.nmilne.com/des.html"" rel=""nofollow noreferrer"">http://da.nmilne.com/des.html</a></p>

<p>I'm trying to replicate those result in Ruby.  I suspect the problem is the key is supposed to be a string, but I need to pass in a Hexadecimal key. Either that or the string being encrypted is in the wrong format. Or maybe both. :-)</p>

<pre><code>require 'openssl'
des = OpenSSL::Cipher::Cipher.new(""des-ede-cbc"")
des.encrypt
des.key=""23232323232323234545454545454545""
des.update(""0000000000000000"")
res=des.final
res.unpack('H*')  
=&gt; [""5045c5d37ca4d13b""]
</code></pre>

<p>But it should be:</p>

<pre><code>=&gt; [""3a42d7a1d1c60c40""]
</code></pre>

<p>Any pointers on where I'm going wrong? </p>

<ul>
<li>Different 3DES algorithms are documented here: <a href=""http://www.openssl.org/docs/apps/enc.html"" rel=""nofollow noreferrer"">http://www.openssl.org/docs/apps/enc.html</a> </li>
<li>Edited for clarity</li>
</ul>
","<p>The key is in hex - if you look at the Java page you pasted you can see that easily by decoding the binary values for the key in the detailed output.</p>

<pre><code>&gt;&gt; des_cbc=OpenSSL::Cipher::Cipher.new(""des-ede-cbc"")
=&gt; #&lt;OpenSSL::Cipher::Cipher:0x10116ce28&gt;
&gt;&gt; des_cbc.encrypt
=&gt; #&lt;OpenSSL::Cipher::Cipher:0x10116ce28&gt;
&gt;&gt; des_cbc.key=""\x23""*8 &lt;&lt; ""\x45""*8
=&gt; ""########EEEEEEEE""
&gt;&gt; des_cbc.update(""\x00""*8).unpack('H*')
=&gt; [""3a42d7a1d1c60c40""]
</code></pre>
","3912","<ruby><encryption><openssl><3des>","1","4","1","2010-10-23 03:47:43","4002381","3","3","49443","","2010-10-22 11:27:15","2010-06-30 12:39:20",""
"11311247","Matching Java Triple DES result to C# one","<p>I have the following C# implementation of triple DES</p>

<pre><code>byte[] bKey = HexToBytes(""C67DDB0CE47D27FAF6F32ECA5C99E8AF"");
byte[] bMsg = HexToBytes(""ff00"");
byte[] iv = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
DESCryptoServiceProvider des = new DESCryptoServiceProvider();
des.Padding = PaddingMode.Zeros;
des.Mode = CipherMode.CBC;
byte[] bK1 = new byte[8];
for (int i = 0; i &lt; 8; i++) bK1[i] = bKey[i];
byte[] bK2 = new byte[8];
for (int i = 0; i &lt; 8; i++) bK2[i] = bKey[i + 8];
ICryptoTransform ict1 = des.CreateEncryptor(bK1, iv);
byte[] bFt = ict1.TransformFinalBlock(bMsg, 0, bMsg.Length);
byte[] bLCb = new byte[8];
for (int i = 0; i &lt; 8; i++) bLCb[i] = bFt[i + bFt.Length - 8];
des.Mode = CipherMode.ECB;
ICryptoTransform ict1_5 = des.CreateDecryptor(bK2, iv);
bLCb = ict1_5.TransformFinalBlock(bLCb, 0, bLCb.Length);
ICryptoTransform ict2 = des.CreateEncryptor(bK1, iv);
byte[] bMac = ict2.TransformFinalBlock(bLCb, 0, bLCb.Length);

ToHex(bMac); // outputs: 4BC0479D7889CF8E
</code></pre>

<p>I need to produce same result in Java/Groovy, in which I'm apparently stuck.
The code I have for now is as follows:</p>

<pre><code>byte[] bKey = Hex.decode(""C67DDB0CE47D27FAF6F32ECA5C99E8AF"")
byte[] bMsg = Hex.decode(""ff00"")

byte[] keyBytes = Arrays.copyOf(sKey.bytes, 24)
int j = 0, k = 16
while (j &lt; 8) {
    keyBytes[k++] = keyBytes[j++]
}

SecretKey key3 = new SecretKeySpec(keyBytes, ""DESede"")
IvParameterSpec iv3 = new IvParameterSpec(new byte[8])
Cipher cipher3 = Cipher.getInstance(""DESede/CBC/PKCS5Padding"")
cipher3.init(Cipher.ENCRYPT_MODE, key3, iv3)

byte[] bMac = cipher3.doFinal(bMsg)
println new String(Hex.encode(bMac))
</code></pre>

<p>This one outpus: <code>ef2c57c3fa18d0a5</code></p>

<p><code>Hex.decode()</code> here is of bouncy castle</p>

<p>I have also tried to reproduce same C# code in java by using DES/CBC twice and EBC in final round, which gave me even different result: <code>48f63c809c38e1eb</code></p>

<p>It'd be great if someone could give me a hint of what I may be doing wrong</p>

<p><strong>Update:</strong></p>

<p>Thanks everyone for your help! Final code that works as needed without much tweaking:</p>

<pre><code>Security.addProvider(new BouncyCastleProvider())
byte[] bKey = Hex.decode(""C67DDB0CE47D27FAF6F32ECA5C99E8AF"")
byte[] bMsg = Hex.decode(""ff00"")

byte[] keyBytes = Arrays.copyOf(sKey.bytes, 24)
int j = 0, k = 16
while (j &lt; 8) {
    keyBytes[k++] = keyBytes[j++]
}

SecretKey key3 = new SecretKeySpec(keyBytes, ""DESede"")
IvParameterSpec iv3 = new IvParameterSpec(new byte[8])
Cipher cipher3 = Cipher.getInstance(""DESede/CBC/ZeroBytePadding"")
cipher3.init(Cipher.ENCRYPT_MODE, key3, iv3)

byte[] bMac = cipher3.doFinal(bMsg)
println new String(Hex.encode(bMac))
</code></pre>
","<p>You're using some non-standard padding and block chaining.  You won't be able to use <code>DESede</code>.  Try <code>DES</code> instead:</p>

<pre><code>import javax.crypto.*
import javax.crypto.spec.*

def key1 = new SecretKeySpec(""C67DDB0CE47D27FA"".decodeHex(), ""DES"")
def key2 = new SecretKeySpec(""F6F32ECA5C99E8AF"".decodeHex(), ""DES"")
def plaintext = (""ff00"" + ""000000000000"").decodeHex() // manually zero pad

def c1 = Cipher.getInstance(""DES/CBC/NoPadding"")
c1.init(Cipher.ENCRYPT_MODE, key1, new IvParameterSpec(new byte[8]))
def cipherText1 = c1.doFinal(plaintext) 

def c2 = Cipher.getInstance(""DES/CBC/NoPadding"")
c2.init(Cipher.DECRYPT_MODE, key2, new IvParameterSpec(new byte[8]))
def cipherText2 = c2.doFinal(cipherText1)

def c3 = Cipher.getInstance(""DES/ECB/NoPadding"")
c3.init(Cipher.ENCRYPT_MODE, key1)
def cipherText3 = c3.doFinal(cipherText2)

assert cipherText3.encodeHex().toString() == ""4bc0479d7889cf8e""
</code></pre>
","3794","<c#><java><encryption><groovy><3des>","2","4","1","2013-10-24 20:46:50","11315100","11","2","1043380","","2013-10-24 20:46:50","2012-07-03 12:47:22",""
"42182101","Disable TLS_RSA_WITH_3DES_EDE_CBC_SHA for Jetty server","<p>To be PCI compliance, I use nmap to scan for SSL vulnerability:</p>

<blockquote>
  <p>nmap -p 8443 --script ssl-enum-ciphers myJettyServer.com</p>
  
  <p>>
  8443/tcp open  https-alt<br>
  | ssl-enum-ciphers:<br>
  |   TLSv1.0:<br>
  |     <strong><em>ciphers:</em></strong><br>
  |       TLS_DHE_RSA_WITH_AES_128_CBC_SHA (dh 768) - C<br>
  |       TLS_DHE_RSA_WITH_AES_256_CBC_SHA (dh 768) - B<br>
  |       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (secp160k1) - A<br>
  |       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (secp160k1) - A<br>
  |       <strong>TLS_RSA_WITH_3DES_EDE_CBC_SHA (rsa 2048) - C</strong><br>
  |       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A<br>
  |       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A<br>
  |     compressors:<br>
  |       NULL<br>
  |     cipher preference: client<br>
  |     <strong><em>warnings:</em></strong><br>
  |       <strong>64-bit block cipher 3DES vulnerable to SWEET32 attack</strong><br>
  |       Key exchange (dh 768) of lower strength than certificate key<br>
  |       Key exchange (secp160k1) of lower strength than certificate key<br>
  |   TLSv1.1:<br>
  |     <strong><em>ciphers:</em></strong><br>
  |       TLS_DHE_RSA_WITH_AES_128_CBC_SHA (dh 768) - C<br>
  |       TLS_DHE_RSA_WITH_AES_256_CBC_SHA (dh 768) - B<br>
  |       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (secp160k1) - A<br>
  |       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (secp160k1) - A<br>
  |       <strong>TLS_RSA_WITH_3DES_EDE_CBC_SHA (rsa 2048) - C</strong><br>
  |       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A<br>
  |       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A<br>
  |     compressors:<br>
  |       NULL<br>
  |     cipher preference: client<br>
  |     <strong><em>warnings:</em></strong><br>
  |       <strong>64-bit block cipher 3DES vulnerable to SWEET32 attack</strong><br>
  |       Key exchange (dh 768) of lower strength than certificate key<br>
  |       Key exchange (secp160k1) of lower strength than certificate key<br>
  |   TLSv1.2:<br>
  |     <strong><em>ciphers:</em></strong><br>
  |       TLS_DHE_RSA_WITH_AES_128_CBC_SHA (dh 768) - C<br>
  |       TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (dh 768) - C<br>
  |       TLS_DHE_RSA_WITH_AES_256_CBC_SHA (dh 768) - B<br>
  |       TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 (dh 768) - B<br>
  |       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (secp160k1) - A<br>
  |       TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (secp160k1) - A<br>
  |       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (secp160k1) - A<br>
  |       TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (secp160k1) - A<br>
  |       <strong>TLS_RSA_WITH_3DES_EDE_CBC_SHA (rsa 2048) - C</strong><br>
  |       TLS_RSA_WITH_AES_128_CBC_SHA (rsa 2048) - A<br>
  |       TLS_RSA_WITH_AES_128_CBC_SHA256 (rsa 2048) - A<br>
  |       TLS_RSA_WITH_AES_256_CBC_SHA (rsa 2048) - A
  |       TLS_RSA_WITH_AES_256_CBC_SHA256 (rsa 2048) - A<br>
  |     compressors:<br>
  |       NULL<br>
  |     cipher preference: client<br>
  |     <strong><em>warnings:</em></strong><br>
  |       <strong>64-bit block cipher 3DES vulnerable to SWEET32 attack</strong><br>
  |       Key exchange (dh 768) of lower strength than certificate key<br>
  |       Key exchange (secp160k1) of lower strength than certificate key<br>
  |_  least strength: C  </p>
</blockquote>

<p>I discover that an SWEET32 exists on my embedded Jetty 9.1.5 server. To resolve this, I add these lines to jetty.xml:</p>

<pre><code>  &lt;Set name=""ExcludeProtocols""&gt;
     &lt;Array type=""java.lang.String""&gt;
        &lt;Item&gt;SSLv3&lt;/Item&gt;
     &lt;/Array&gt;
  &lt;/Set&gt;
  &lt;Set name=""ExcludeCipherSuites""&gt;
     &lt;Array type=""java.lang.String""&gt;
        &lt;!-- default --&gt;
        &lt;Item&gt;SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_DSS_WITH_AES_128_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_DSS_WITH_AES_256_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_DSS_WITH_DES_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_DSS_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_RSA_WITH_AES_128_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_RSA_WITH_AES_256_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_DHE_RSA_WITH_DES_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_EXPORT_WITH_DES40_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_FIPS_WITH_DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_WITH_DES_CBC_SHA&lt;/Item&gt;

        &lt;!--3DES--&gt;
        &lt;Item&gt;TLS_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;         
        &lt;Item&gt;TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;            
        &lt;Item&gt;TLS_DH_anon_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA&lt;/Item&gt;

        &lt;!-- RC4 --&gt;
        &lt;Item&gt;PCT_SSL_CIPHER_TYPE_1ST_HALF&lt;/Item&gt;
        &lt;Item&gt;SSL_DH_anon_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL_DH_anon_WITH_RC4_128_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_WITH_RC4_128_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL_RSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;SSL2_RC4_128_EXPORT40_WITH_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL2_RC4_128_WITH_MD5&lt;/Item&gt;
        &lt;Item&gt;SSL2_RC4_64_WITH_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_DH_Anon_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_DH_Anon_WITH_RC4_128_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_DSS_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_DSS_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_PSK_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_DHE_PSK_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_Anon_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_Anon_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_ECDSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_ECDSA_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_RSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDH_RSA_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_ECDSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_ECDSA_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_PSK_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_PSK_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_RSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_ECDHE_RSA_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_EXPORT_WITH_RC4_40_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_EXPORT_WITH_RC4_40_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_WITH_RC4_128_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_KRB5_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_PSK_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_PSK_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_EXPORT_WITH_RC4_40_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_EXPORT1024_WITH_RC4_56_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_EXPORT1024_WITH_RC4_56_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_EXPORT1024_WITH_RC4_56_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_PSK_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_PSK_WITH_RC4_128_SHA256&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_WITH_RC4_128_MD5&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_WITH_RC4_128_SHA&lt;/Item&gt;
        &lt;Item&gt;TLS_RSA_WITH_RC4_128_SHA256&lt;/Item&gt;
     &lt;/Array&gt;
  &lt;/Set&gt;
</code></pre>

<p>All other 3DES ciphers gone, except this one TLS_RSA_WITH_3DES_EDE_CBC_SHA. It's so weird!  </p>

<p>How can I get rid of this cipher?
Thanks in advance.</p>
","<p>Using a recent stable version of Jetty, you can ask for a server dump and see the list of enabled / disabled ciphers, along with (most importantly!) <em>where</em> they are disabled.</p>

<p>Example:</p>

<pre class=""lang-none prettyprint-override""><code> $ cd /path/to/my/jettybase
 $ java -jar /path/to/jetty-dist/start.jar jetty.server.dumpAfterStart=true

 |   += SslConnectionFactory@cc285f4{SSL-&gt;http/1.1} - STARTED
 |   |   += SslContextFactory@77659b30(file:///path/to/my/jettybase/etc/keystore,file:///path/to/my/jettybase/etc/keystore) trustAll=false
 |   |       +- Protocol Selections
 |   |       |   +- Enabled (size=3)
 |   |       |   |   +- TLSv1
 |   |       |   |   +- TLSv1.1
 |   |       |   |   +- TLSv1.2
 |   |       |   +- Disabled (size=2)
 |   |       |       +- SSLv2Hello - ConfigExcluded:'SSLv2Hello'
 |   |       |       +- SSLv3 - JreDisabled:java.security, ConfigExcluded:'SSLv3'
 |   |       +- Cipher Suite Selections
 |   |           +- Enabled (size=29)
 |   |           |   +- TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
 |   |           |   +- TLS_DHE_DSS_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
 |   |           |   +- TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
 |   |           |   +- TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
 |   |           |   +- TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
 |   |           |   +- TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
 |   |           |   +- TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
 |   |           |   +- TLS_EMPTY_RENEGOTIATION_INFO_SCSV
 |   |           |   +- TLS_RSA_WITH_AES_128_CBC_SHA256
 |   |           |   +- TLS_RSA_WITH_AES_128_GCM_SHA256
 |   |           |   +- TLS_RSA_WITH_AES_256_CBC_SHA256
 |   |           |   +- TLS_RSA_WITH_AES_256_GCM_SHA384
 |   |           +- Disabled (size=53)
 |   |               +- SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DHE_DSS_WITH_DES_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DHE_RSA_WITH_DES_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DH_anon_WITH_3DES_EDE_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_DH_anon_WITH_DES_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_RSA_EXPORT_WITH_DES40_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_RSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_RSA_WITH_DES_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_RSA_WITH_NULL_MD5 - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- SSL_RSA_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DHE_DSS_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DHE_DSS_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DHE_RSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DHE_RSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DH_anon_WITH_AES_128_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DH_anon_WITH_AES_128_CBC_SHA256 - JreDisabled:java.security
 |   |               +- TLS_DH_anon_WITH_AES_128_GCM_SHA256 - JreDisabled:java.security
 |   |               +- TLS_DH_anon_WITH_AES_256_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_DH_anon_WITH_AES_256_CBC_SHA256 - JreDisabled:java.security
 |   |               +- TLS_DH_anon_WITH_AES_256_GCM_SHA384 - JreDisabled:java.security
 |   |               +- TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_ECDSA_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDHE_RSA_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_ECDSA_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_RSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_RSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_RSA_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_anon_WITH_AES_128_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_anon_WITH_AES_256_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_ECDH_anon_WITH_NULL_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_WITH_3DES_EDE_CBC_MD5 - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_WITH_3DES_EDE_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_WITH_DES_CBC_MD5 - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_KRB5_WITH_DES_CBC_SHA - JreDisabled:java.security, ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_RSA_WITH_AES_128_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_RSA_WITH_AES_256_CBC_SHA - ConfigExcluded:'^.*_(MD5|SHA|SHA1)$'
 |   |               +- TLS_RSA_WITH_NULL_SHA256 - JreDisabled:java.security
</code></pre>

<p>You'll quickly see that the ciphers you specifically are calling out are already disabled by default in the Jetty configuration, with others being disabled by the running JRE.</p>

<p>As for configuring the list of Ciphers, you would configure the SslContextFactory to have the excludes you need.  There are many ways to configure it, it would be best if you choose a technique that best fits your needs from the official documentation at ...</p>

<p><a href=""https://www.eclipse.org/jetty/documentation/current/configuring-ssl.html#configuring-sslcontextfactory-cipherSuites"" rel=""nofollow noreferrer"">https://www.eclipse.org/jetty/documentation/current/configuring-ssl.html#configuring-sslcontextfactory-cipherSuites</a></p>
","3429","<ssl><jetty><3des><pci-compliance>","0","1","1","2017-02-15 00:40:16","","1","1","2612644","","2017-02-11 22:50:39","2017-02-11 22:44:25",""
"14445460","PKCS11 deriveKey() and encrypt() returning different results for 3DES","<p>I am working on a key derivation problem using an HSM and PKCS11 and currently I can't understand why I see completely different results depending on whether I use the deriveKey() method as opposed to using the encrypt() method.  In both cases I'm attempting to use DESede/ECB/NoPadding algorithm for the result and yet depending on which method (deriveKey vs. encrypt) I use to generate the result, I see different outcomes.</p>

<p>Stepping back for a moment to give a high level overview... I am using a specific key derivation methodology used by Global Platform to diversify the master key for use on a smart card.  The method starts with a master key and 8 bytes of data (diversification data) that are used to derive the new key.  The div data bytes are literally just encrypted with the master key using DESede/ECB/NoPadding and the result is used as part of the new derived 3DES key.  (In actuality, there are multiple encryptions performed and the results are concatenated together to form the new key, but that is not the issue here.)</p>

<p>I've verified the master key in both cases, verified that the diversification data is the same in both cases, verified that I'm using the same algorithm with the same padding.  I've also tried changing the derived key template to DES, 2DES, 3DES.  All yield similar results that only differ in length.</p>

<p>Currently I've implemented my test case using IAIK wrapper (a pkcs11 wrapper written in Java), which I will post here.  The key is just a test key and the div data is sample div data, so there is no sensitive information here.  I'm first creating a base key in the HSM, then attempt to derive a new key by calling session.deriveKey() using the diversification data.  The derived key bytes are printed in hex (the key value is incorrect, based on my currently working implementation that derives the key in memory instead of within the HSM).  Next, I simply initialize the session to perform an encryption using the master key and then encrypt the diversification data.  This yields the expected value (again, checked against a working implementation).</p>

<p>What I'm looking for is any insight into why these operations are yielding different results, when I'm using the same base key, the same div data and the same encryption algorithm.  I don't understand what deriveKey() is doing under the surface and I'm unable to find any documentation or source code to shed any light on this.  I must be able to use the deriveKey() method since the derived key will not be available outside the HSM.</p>

<p>Any insight appreciated.</p>

<pre><code>Mechanism keyGenerationMechanism = Mechanism.get(PKCS11Constants.CKM_DES3_KEY_GEN);

List supportedMechanisms = Arrays.asList(token.getMechanismList());
if (!supportedMechanisms.contains(Mechanism.get(PKCS11Constants.CKM_DES3_KEY_GEN))) {
    output_.println(""Mechanism not supported: DES3_KEY_GEN"");
    return;
}

// This is the master key that I want to diversify
DES3SecretKey baseKeyTemplate = new DES3SecretKey();
baseKeyTemplate.getValue().setByteArrayValue(new byte[] {0x3d, 0x20, 0x5b, 0x29, (byte) 0xfd, 0x04, (byte) 0xd9, (byte) 0x89, (byte) 0xd0, (byte) 0xfd, (byte) 0x85, (byte) 0xd5, (byte) 0xf7, (byte) 0xb3, 0x31, (byte) 0xd3,
        0x3d, 0x20, 0x5b, 0x29, (byte) 0xfd, 0x04, (byte) 0xd9, (byte) 0x89});
baseKeyTemplate.getDerive().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getToken().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getPrivate().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getSensitive().setBooleanValue(Boolean.FALSE);
baseKeyTemplate.getExtractable().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getLabel().setCharArrayValue(""GP-3des-aba"".toCharArray());
baseKeyTemplate.getObjectClass().setLongValue(PKCS11Constants.CKO_SECRET_KEY);
baseKeyTemplate.getKeyType().setLongValue(PKCS11Constants.CKK_DES3);
baseKeyTemplate.getEncrypt().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getDecrypt().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getWrap().setBooleanValue(Boolean.TRUE);
baseKeyTemplate.getUnwrap().setBooleanValue(Boolean.TRUE);


output_.println(""baseKeyTemplate: "" + baseKeyTemplate.toString());

SecretKey baseKey = (SecretKey) session.createObject(baseKeyTemplate);

System.out.println(""Base key: "");
System.out.println(baseKey.toString());

output_
        .println(""################################################################################"");
output_.println(""derive key"");

//DES3 Key Template
DESSecretKey derived3DESKeyTemplate = new DESSecretKey();
SecretKey derivedKeyTemplate = derived3DESKeyTemplate;

derivedKeyTemplate.getSensitive().setBooleanValue(Boolean.FALSE);
derivedKeyTemplate.getToken().setBooleanValue(Boolean.TRUE);
derivedKeyTemplate.getExtractable().setBooleanValue(Boolean.TRUE);
derivedKeyTemplate.getPrivate().setBooleanValue(Boolean.FALSE);
derivedKeyTemplate.getKeyType().setLongValue(PKCS11Constants.CKK_DES);

// This represents the diversification data (.ie div bytes from some smart card)
byte[] data = new byte[] {0x00, (byte) 0x84, 0x30, (byte) 0x95, 0x35, 0x05,(byte)  0xf0, 0x01};

KeyDerivationStringDataParameters param = new KeyDerivationStringDataParameters(data);
Mechanism mechanism = Mechanism.get(PKCS11Constants.CKM_DES3_ECB);

if (!supportedMechanisms.contains(Mechanism
        .get(PKCS11Constants.CKM_DES3_ECB))) {
    output_.println(""Mechanism not supported: CKM_DES3_ECB"");
    return;
}

mechanism.setParameters(param);

System.out.println(""Derivation Mechanism: "");
output_.println(mechanism.toString());
output_
        .println(""--------------------------------------------------------------------------------"");

Key derivedKey = session.deriveKey(mechanism, baseKey, derivedKeyTemplate);

if (derivedKey == null) {
    output_.println(""Found NO key that can be used for encryption."");
    output_.flush();
    System.exit(0);
}
System.out.println(""Derived key: "");
output_.println(derivedKey.toString());

output_
        .println(""################################################################################"");
output_.println(""finished"");

// initialize for encryption
Mechanism encryptionMechanism = Mechanism.get(PKCS11Constants.CKM_DES3_ECB);
session.encryptInit(encryptionMechanism, baseKey);
byte[] encryptedData = session.encrypt(data);

System.out.println(""Encrypted data: "" + new String(Hex.encodeHex(encryptedData)));

// This is the second part of the derived key, let's not worry about this yet since the first part isn't
// working.
//        data = new byte[] {0x00, (byte) 0x84, 0x30, (byte) 0x95, 0x35, 0x05,(byte)  0x0f, 0x01,
//                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
//
//        session.encryptInit(encryptionMechanism, baseKey);
//        encryptedData = session.encrypt(data);
//        System.out.println(""Encrypted data: "" + new String(Hex.encodeHex(encryptedData)));

session.closeSession();
pkcs11Module.finalize(null);
</code></pre>

<p>Here's the relevant output when I run the above code:</p>

<pre><code>Base key:  
  Object Class: Secret Key  
  Token: true  
  Private: true  
  Modifiable: true  
  Label: GP-3des-aba  
  Key Type: DES3  
  ID: &lt;NULL_PTR&gt;  
  Start Date: 00.00.0000 (DD.MM.YYYY)  
  End Date: 00.00.0000 (DD.MM.YYYY)  
  Derive: true  
  Local: false  
  Key Generation Mechanism: &lt;Information unavailable&gt;  
  Allowed Mechanisms: &lt;NULL_PTR&gt;  
  Sensitive: false  
  Encrypt: true  
  Decrypt: true  
  Sign: false  
  Verify: false  
  Wrap: true  
  Unwrap: true  
  Extractable: true  
  Always Sensitive: false  
  Never Extractable: false  
  Check Value: &lt;Attribute not present&gt;  
  Wrap With Trusted: &lt;Attribute not present&gt;  
  Trusted: &lt;Attribute not present&gt;  
  Wrap Template: &lt;Attribute not present&gt;  
  Unwrap Template: &lt;Attribute not present&gt;  
  Value (hex): 3d205b29fd04d989d0fd85d5f7b331d33d205b29fd04d989  
################################################################################
derive key  
Derivation Mechanism:   
  Mechanism: CKM_DES3_ECB  
  Parameters:   
  String data (hex): 008430953505f001  
--------------------------------------------------------------------------------  
01/18/13 14:12:10   CALL: entering (in Java_iaik_pkcs_pkcs11_wrapper_PKCS11Implementation_C_1DeriveKey)  

[snip]  

Derived key:   
  Object Class: Secret Key  
  Token: true  
  Private: false  
  Modifiable: true  
  Label: &lt;NULL_PTR&gt;  
  Key Type: DES  
  ID: &lt;NULL_PTR&gt;  
  Start Date: 00.00.0000 (DD.MM.YYYY)  
  End Date: 00.00.0000 (DD.MM.YYYY)  
  Derive: false  
  Local: false  
  Key Generation Mechanism: CKM_DES3_ECB  
  Allowed Mechanisms: &lt;NULL_PTR&gt;  
  Sensitive: false  
  Encrypt: false  
  Decrypt: false  
  Sign: false  
  Verify: false  
  Wrap: false  
  Unwrap: false  
  Extractable: true  
  Always Sensitive: false  
  Never Extractable: false  
  Check Value: &lt;Attribute not present&gt;  
  Wrap With Trusted: &lt;Attribute not present&gt;  
  Trusted: &lt;Attribute not present&gt;  
  Wrap Template: &lt;Attribute not present&gt;  
  Unwrap Template: &lt;Attribute not present&gt;  
  Value (hex): 3efe0eab6d3db397      &lt;--- call to deriveKey() value incorrect  
################################################################################  
finished  
01/18/13 14:12:12   CALL: entering (in Java_iaik_pkcs_pkcs11_wrapper_PKCS11Implementation_C_1EncryptInit)  
01/18/13 14:12:12   CALL: exiting  (in Java_iaik_pkcs_pkcs11_wrapper_PKCS11Implementation_C_1EncryptInit)  
01/18/13 14:12:12   CALL: entering (in Java_iaik_pkcs_pkcs11_wrapper_PKCS11Implementation_C_1Encrypt)  
01/18/13 14:12:12   CALL: exiting  (in Java_iaik_pkcs_pkcs11_wrapper_PKCS11Implementation_C_1Encrypt)  
Encrypted data: 3fff0faa6c3cb297    &lt;--- call to encrypt() returns the expected value 
</code></pre>
","<p>Turns out that the key generated in the HSM using DeriveKey and the key bytes I generated using session.encrypt() are essentially the same if one considers how DES parity works.</p>

<p>The least significant bit of each byte in a DES key is the parity bit, which is ignored in many implementations and is not used as part of the key, thus if I properly set the parity bits on my encrypt result then both results match.</p>

<p>0x3efe0eab6d3db397  &lt;--- HSM generated value with correct odd parity<br>
00111110 11111110 00001110 10101011 01101101 00111101 10110011 10010111</p>

<p>0x3fff0faa6c3cb297  &lt;--- encryption result without parity bits set properly<br>
00111111 11111111 00001111 10101010 01101100 00111100 10110010 10010111</p>
","3361","<java><3des><pkcs#11><hsm>","4","8","1","2015-06-29 21:45:08","14469943","0","6","3102264","","2015-06-29 21:45:08","2013-01-21 19:04:47",""
"6087155","Use Zero Padding in OpenSSL?","<p>System.Security.Cryptography.TripleDES allow me use zero padding like this : </p>

<pre><code>static TripleDES CreateTripleDES(byte[] key, byte[] iv)
{
    TripleDES des = new TripleDESCryptoServiceProvider();
    des.Key = key;
    des.IV = iv;
    des.Mode = CipherMode.CBC;
    des.Padding = PaddingMode.Zeros;
    return des;
}
</code></pre>

<p>Now change to use OpenSSL</p>

<pre><code>CipherContext cc = new CipherContext(Cipher.DES_EDE3_CBC);
byte[] des3 = cc.Encrypt(msg2, tripleKey, tripleIv, 0);
//public byte[] Encrypt(byte[] input, byte[] key, byte[] iv, int padding);
</code></pre>

<p>The problem is that when i encrypt a string by two methods, i receive two diffences result :</p>

<pre><code>first method (OK): 90dd67c475dc3a8ce3d0c8927ce43758715888c16688c9828ac92aa86019126297b7ccb80a4729224acd07285b85a847e48fb01b3da4639c
second method (NOT OK): 90dd67c475dc3a8ce3d0c8927ce43758715888c16688c9828ac92aa86019126297b7ccb80a4729224acd07285b85a847b77485eb0a1f214e
</code></pre>

<p>I guess that is because of the padding zero. But i don't know how to use padding zero in openssl.</p>

<p>Any help is appreciated.</p>
","<p>Openssl doesn't allow for ""zero padding"", probably because the result is not consistent (what if the last byte of plaintext is a 0...)  </p>

<p>Openssl will let you use either PKCS padding or no padding (which requires the input to be a multiple of the block size in length).</p>

<p>If you want to emulate this ""zero padding"", you would need to append an appropriate amount of 0's yourself, and then choose the no padding option.</p>
","3274","<openssl><3des>","2","2","1","2011-05-22 12:38:04","","0","","","","","2011-05-22 09:46:44",""
"9699496","javascript library to decrypt a 3des file","<p>I have a base64 encoded string that contains a <strong>3DES</strong> encrypted png file. I need to show this image on the client side provided the right password is given by the client.
I have been searching for some <em>crypto library</em> with this functionality but could not find any (or at least none with some documentation or examples).
I know of many nice libraries that support AES encryption, but ATM my input is 3des encrypted and I can't change that.
Could someone point me to a library with built in 3des decryption ? Also an example would be great.</p>
","<p>So I did the Google search for ""javascript 3des"" for you. Here's the first result.</p>

<p><a href=""http://etherhack.co.uk/symmetric/des_3des/"" rel=""nofollow"">http://etherhack.co.uk/symmetric/des_3des/</a></p>

<p>(JS: <a href=""http://etherhack.co.uk/symmetric/des_3des/js/dessrc.js"" rel=""nofollow"">http://etherhack.co.uk/symmetric/des_3des/js/dessrc.js</a>)</p>

<p>How this works on binary data is another question - how do you store the binary data in your JS right now anyway?</p>
","3173","<javascript><encryption><3des>","1","0","2","2012-06-28 10:28:37","","0","","","","","2012-03-14 09:51:02",""
"9699496","javascript library to decrypt a 3des file","<p>I have a base64 encoded string that contains a <strong>3DES</strong> encrypted png file. I need to show this image on the client side provided the right password is given by the client.
I have been searching for some <em>crypto library</em> with this functionality but could not find any (or at least none with some documentation or examples).
I know of many nice libraries that support AES encryption, but ATM my input is 3des encrypted and I can't change that.
Could someone point me to a library with built in 3des decryption ? Also an example would be great.</p>
","<p>Have you checked <a href=""http://code.google.com/p/jscryptolib/"" rel=""nofollow"">jscryptolib</a>? They provide:</p>

<ul>
<li>Symmetric encryption: AES, DES, 3DES</li>
<li>Encryption mode: ECB, CBC, CTR</li>
<li>Digest algorithm: SHA-1, SHA256</li>
<li>Message Authentication Code (MAC): HMAC, CBCMAC, CMAC</li>
<li>Random number generator (RNG): FIPS186, X9.17</li>
<li>Public key cryptography: RSA, DSA, ECC, CPK, IBE</li>
</ul>

<p>It's LGPL licensed, so you should not have problems using it on your project.</p>
","3173","<javascript><encryption><3des>","1","0","2","2012-06-28 10:28:37","","0","","","","","2012-03-14 09:51:02",""
"42406950","NodeJS 3DES ECB encryption does not equal C# encryption","<p>I'm trying to convert the C# code to encrypt text using 3DES ECB
(You can copy and paste it on <a href=""https://dotnetfiddle.net/"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/</a> to run it)</p>

<pre><code>using System;
using System.Configuration;
using System.Security.Cryptography;
using System.Text;

public class Program
{
    public static void Main()
    {
        string toEncrypt = ""testtext"";
        string key = ""testkey"";
        bool useHashing = true;
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

        System.Configuration.AppSettingsReader settingsReader =
                                                new AppSettingsReader();

        key = string.IsNullOrEmpty(key) ? (string)settingsReader.GetValue(""SecurityKey"", typeof(String)) : key;

        if (useHashing)
        {
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));

            hashmd5.Clear();
        }
        else 
        {
            keyArray = UTF8Encoding.UTF8.GetBytes(key);
        }

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        key = Convert.ToBase64String(keyArray, 0, keyArray.Length);
        Console.WriteLine(key);
        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;

        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

        tdes.Clear();

        Console.Write(Convert.ToBase64String(resultArray, 0, resultArray.Length));
    }
}
</code></pre>

<p>OUTPUT: </p>

<pre><code>Ihs2jX9fWXhn9SWXHyj/dQ== &lt;- md5 secret key
wHL9J7vhm9LZI2W5DQJGKw== &lt;- encrypt result
</code></pre>

<p>So I rewrite the above code in NodeJS to use crypto</p>

<pre><code>const crypto = require('crypto');
const md5 = text =&gt; {
  return crypto
    .createHash('md5')
    .update(text)
    .digest('base64');
}

const encrypt = (text, secretKey) =&gt; {
  secretKey = md5(secretKey);
  console.log(secretKey);

  const cipher = crypto.createCipher('des-ede3', secretKey);
  const encrypted = cipher.update(text, 'utf8', 'base64');

  return encrypted + cipher.final('base64');
};
const encrypted = encrypt('testtext', 'testkey');

console.log(encrypted);
</code></pre>

<p>OUTPUT:</p>

<pre><code>Ihs2jX9fWXhn9SWXHyj/dQ== &lt;- md5 secret key
VNa9fDYgPus5IMhUZRI+jQ== &lt;- encrypt result
</code></pre>

<p>I think the problem lies in C# and NodeJS Crypto approach in using 3DES ECB. Any idea how to replicate the C# code <strong>behaviour</strong> in NodeJS? </p>
","<p>Ok, just use <a href=""https://www.npmjs.com/package/nod3des"" rel=""nofollow noreferrer"">https://www.npmjs.com/package/nod3des</a> to replicate the same behavior as C#. In case you're wondering how it works</p>

<p><a href=""https://github.com/4y0/nod3des/blob/master/index.js#L30"" rel=""nofollow noreferrer"">https://github.com/4y0/nod3des/blob/master/index.js#L30</a></p>

<pre><code>var CryptoJS = require('crypto-js');
var forge    = require('node-forge');
var utf8     = require('utf8');

...

_3DES.encrypt = function (key, text){

    key          = CryptoJS.MD5(utf8.encode(key)).toString(CryptoJS.enc.Latin1);
    key          = key + key.substring(0, 8); 
    var cipher   = forge.cipher.createCipher('3DES-ECB', forge.util.createBuffer(key));
    cipher.start({iv:''});
    cipher.update(forge.util.createBuffer(text, 'utf-8'));
    cipher.finish();
    var encrypted = cipher.output; 
    return ( forge.util.encode64(encrypted.getBytes()) );

}
</code></pre>
","3055","<c#><node.js><encryption><3des><ecb>","2","2","2","2017-02-23 19:34:23","42408961","0","2","4130039","","2017-02-23 13:08:05","2017-02-23 04:18:31",""
"42406950","NodeJS 3DES ECB encryption does not equal C# encryption","<p>I'm trying to convert the C# code to encrypt text using 3DES ECB
(You can copy and paste it on <a href=""https://dotnetfiddle.net/"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/</a> to run it)</p>

<pre><code>using System;
using System.Configuration;
using System.Security.Cryptography;
using System.Text;

public class Program
{
    public static void Main()
    {
        string toEncrypt = ""testtext"";
        string key = ""testkey"";
        bool useHashing = true;
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

        System.Configuration.AppSettingsReader settingsReader =
                                                new AppSettingsReader();

        key = string.IsNullOrEmpty(key) ? (string)settingsReader.GetValue(""SecurityKey"", typeof(String)) : key;

        if (useHashing)
        {
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));

            hashmd5.Clear();
        }
        else 
        {
            keyArray = UTF8Encoding.UTF8.GetBytes(key);
        }

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        key = Convert.ToBase64String(keyArray, 0, keyArray.Length);
        Console.WriteLine(key);
        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;

        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

        tdes.Clear();

        Console.Write(Convert.ToBase64String(resultArray, 0, resultArray.Length));
    }
}
</code></pre>

<p>OUTPUT: </p>

<pre><code>Ihs2jX9fWXhn9SWXHyj/dQ== &lt;- md5 secret key
wHL9J7vhm9LZI2W5DQJGKw== &lt;- encrypt result
</code></pre>

<p>So I rewrite the above code in NodeJS to use crypto</p>

<pre><code>const crypto = require('crypto');
const md5 = text =&gt; {
  return crypto
    .createHash('md5')
    .update(text)
    .digest('base64');
}

const encrypt = (text, secretKey) =&gt; {
  secretKey = md5(secretKey);
  console.log(secretKey);

  const cipher = crypto.createCipher('des-ede3', secretKey);
  const encrypted = cipher.update(text, 'utf8', 'base64');

  return encrypted + cipher.final('base64');
};
const encrypted = encrypt('testtext', 'testkey');

console.log(encrypted);
</code></pre>

<p>OUTPUT:</p>

<pre><code>Ihs2jX9fWXhn9SWXHyj/dQ== &lt;- md5 secret key
VNa9fDYgPus5IMhUZRI+jQ== &lt;- encrypt result
</code></pre>

<p>I think the problem lies in C# and NodeJS Crypto approach in using 3DES ECB. Any idea how to replicate the C# code <strong>behaviour</strong> in NodeJS? </p>
","<p>Triple DES is only defined for 192 bit keys. An MD5 hash only provides 128 bit. There are multiple ways of expanding a potential 128 bit key into a 192 bit key. If we assume that the 128 bit key is made up of two 64 bit sub keys <em>k1</em> and <em>k2</em>, then C# will create a 192 bit key consisting of <em>k1</em>, <em>k2</em> and <em>k1</em> again.</p>

<p>Here is the code that works:</p>

<pre><code>const crypto = require('crypto');
const md5 = text =&gt; {
  return crypto
    .createHash('md5')
    .update(text)
    .digest();
}

const encrypt = (text, secretKey) =&gt; {
  secretKey = md5(secretKey);
  console.log(secretKey.toString('base64'));
  secretKey = Buffer.concat([secretKey, secretKey.slice(0, 8)]); // properly expand 3DES key from 128 bit to 192 bit

  const cipher = crypto.createCipheriv('des-ede3', secretKey, '');
  const encrypted = cipher.update(text, 'utf8', 'base64');

  return encrypted + cipher.final('base64');
};
const encrypted = encrypt('testtext', 'testkey');

console.log(encrypted);
</code></pre>

<p>The other issue that you had was using <code>crypto#createCipher</code> instead of <code>crypto#createCipheriv</code>. The former has an additional hashing of the ""key"" which you don't want in this case.</p>

<hr>

<p>Other potential problems:</p>

<ul>
<li><p><strong>Never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a></strong>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p></li>
<li><p><strong>Don't use Triple DES nowadays.</strong> It only provides at best 112 bit of security even if you use the largest key size of 192 bit. If a shorter key size is used, then it only provides 56 or 57 bits of security. AES would be faster (processors have a special AES-NI instruction set) and even more secure with the lowest key size of 128 bit. There is also a practical limit on the maximum ciphertext size with 3DES. See <a href=""https://security.stackexchange.com/q/26179/45523"">Security comparison of 3DES and AES</a>.</p></li>
<li><p>You should never use a simple hash function to protect your user's passwords. You need to use a strong hashing scheme like PBKDF2, bcrypt, scrypt and Argon2. Be sure to use a high cost factor/iteration count. It is common to choose the cost so that a single iteration takes at least 100ms. See more: <a href=""https://security.stackexchange.com/q/211/45523"">How to securely hash passwords?</a></p></li>
</ul>
","3055","<c#><node.js><encryption><3des><ecb>","2","2","2","2017-02-23 19:34:23","42408961","0","2","4130039","","2017-02-23 13:08:05","2017-02-23 04:18:31",""
"9826289","php + ios encrypt and decrypt 3des + base64","<p>i need encrypt and decrypt with php a string code generated by that ios method explained here <a href=""https://stackoverflow.com/a/9479657/721253"">https://stackoverflow.com/a/9479657/721253</a></p>

<p>for encrypt with php i use that script</p>

<pre><code>$key = 'f968f8e82961489a8b14b345';
$data = 'odio quando sto studiando e un velociraptor mi lancia addosso banane';
$encrypted = null;
$m = mcrypt_module_open(MCRYPT_3DES, null, MCRYPT_MODE_ECB, null);
$fake_iv = str_repeat(chr(0), mcrypt_enc_get_iv_size($m));
mcrypt_generic_init($m, $key, $fake_iv);
$encrypted = mcrypt_generic($m, $data);
die(base64_encode($encrypted));
</code></pre>

<p>and on IOs for decript i use that</p>

<pre><code>NSURL *url = [NSURL URLWithString:@""http://oscurodrago.it/tools/crypto.php""];
NSData *data = [NSData dataWithContentsOfURL:url];
NSData *outData = [self TripleDES:data encryptOrDecrypt:kCCDecrypt key:@""f968f8e82961489a8b14b345""];
</code></pre>

<p>ccStatus return decode error   ->  if (ccStatus == kCCDecodeError) NSLog( @""DECODE ERROR"");</p>

<p><strong>update</strong>
that is viewcontroller.m where i'm testing that script</p>

<pre><code>#import &lt;CommonCrypto/CommonCryptor.h&gt;
#import ""GTMBase64.h""

#import ""ViewController.h""

@interface ViewController ()

@end

@implementation ViewController

- (NSData*)TripleDES:(NSData*)plainData encryptOrDecrypt:(CCOperation)encryptOrDecrypt key:(NSString*)key {

    const void *vplainText;
    size_t plainTextBufferSize;

    if (encryptOrDecrypt == kCCDecrypt)
    {
        NSData *EncryptData = [GTMBase64 decodeData:plainData];
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
    }
    else
    {
        plainTextBufferSize = [plainData length];
        vplainText = (const void *)[plainData bytes];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    // uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));

    //    NSString *key = @""123456789012345678901234"";
    NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding,
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);
    if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    else if (ccStatus == kCCParamError) NSLog( @""PARAM ERROR"");
     else if (ccStatus == kCCBufferTooSmall) NSLog( @""BUFFER TOO SMALL"");
     else if (ccStatus == kCCMemoryFailure) NSLog( @""MEMORY FAILURE"");
     else if (ccStatus == kCCAlignmentError) NSLog( @""ALIGNMENT"");
     else if (ccStatus == kCCDecodeError) NSLog( @""DECODE ERROR"");
     else if (ccStatus == kCCUnimplemented) NSLog( @""UNIMPLEMENTED"");

    NSData *result;

    if (encryptOrDecrypt == kCCDecrypt)
    {
        result = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        result = [GTMBase64 encodeData:myData];
    }

    return result;
}


- (void)viewDidLoad
{
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    NSURL *url = [NSURL URLWithString:@""http://www.oscurodrago.it/tools/crypto.php""];
    NSData *data = [NSData dataWithContentsOfURL:url];

    NSData *outData = [[NSData alloc] initWithData:[self TripleDES:data encryptOrDecrypt:kCCDecrypt key:@""f968f8e82961489a8b14b345""]];

    NSLog(@""%@"", data );

    // NSData *encriptdata = [self TripleDES:data encryptOrDecrypt:kCCEncrypt key:@""f968f8e82961489a8b14b345""];

    NSLog(@""%@"", [outData length] );
}

- (void)viewDidUnload
{
    [super viewDidUnload];
    // Release any retained subviews of the main view.
}

- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation
{
    if ([[UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPhone) {
        return (interfaceOrientation != UIInterfaceOrientationPortraitUpsideDown);
    } else {
        return YES;
    }
}

@end
</code></pre>
","<p>You have to make the 'outData' to base64 encoded string. Then only you can print the NSData. Try before that, data is not empty by printing the 'outData' length by</p>

<pre><code>NSLog(@""%d"",[outData length]);
</code></pre>

<p>See <a href=""http://sourceforge.net/projects/sag333ar/files/NSStringAdditions/NSStrinAdditions.h.zip/download"" rel=""nofollow"">this</a> link for converting NSData to base64 string.</p>
","3000","<php><ios><base64><encryption><3des>","0","1","1","2012-03-22 17:59:38","","0","2","-1","","2017-05-23 12:27:48","2012-03-22 16:14:56",""
"16203619","Decrypting data in Python that was encrypted in 3DES by Java","<p>I'm trying to decrypt data using PyCrypto. The data was encoded in Java with the javax.crypto package. The encryption is Triple DES (referred to as ""<a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/StandardNames.html#Cipher"" rel=""nofollow"">DESede</a>"" in Java). As far as I can tell, default settings are used for everything. However, when I go to decrypt the data in Python there is always a problem with the data.</p>

<p>Here's the Java code that does encrypting/decrypting:</p>

<pre><code>import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import java.security.spec.KeySpec;

public final class Encrypter
{
    public static final String DESEDE_ENCRYPTION = ""DESede"";

    private KeySpec keySpec;
    private SecretKeyFactory keyFactory;
    private Cipher cipher;

    private static final String UNICODE_FORMAT = ""UTF8"";

    public Encrypter(String encryptionKey)
        throws Exception
    {
        byte[] keyAsBytes = encryptionKey.getBytes(UNICODE_FORMAT);
        keySpec = new DESedeKeySpec(keyAsBytes);
        keyFactory = SecretKeyFactory.getInstance(DESEDE_ENCRYPTION);
        cipher = Cipher.getInstance(DESEDE_ENCRYPTION);
    }

    public String encryptString(String unencryptedString)
    {
        SecretKey key = keyFactory.generateSecret(keySpec);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] cleartext = unencryptedString.getBytes(UNICODE_FORMAT);
        byte[] ciphertext = cipher.doFinal(cleartext);

        BASE64Encoder base64encoder = new BASE64Encoder();
        return base64encoder.encode(ciphertext);
    }

    public String decryptString(String encryptedString)
    {
        SecretKey key = keyFactory.generateSecret(keySpec);
        cipher.init(Cipher.DECRYPT_MODE, key);
        BASE64Decoder base64decoder = new BASE64Decoder();
        byte[] ciphertext = base64decoder.decodeBuffer(encryptedString);
        byte[] cleartext = cipher.doFinal(ciphertext);

        return bytesToString(cleartext);
    }

    private static String bytesToString(byte[] bytes)
    {
        StringBuilder sb = new StringBuilder();
        for (byte aByte : bytes)
        {
            sb.append((char) aByte);
        }
        return sb.toString();
    }
}
</code></pre>

<p>But when I take one of the base64-encoded strings that was produced by this code, I can't decode it. Here's an example of some of the python code I've tried:</p>

<pre><code>from Crypto.Cipher import DES3
import array

key = &lt;value of the key, as a hex string&gt;
encryptedvalue = &lt;the value that's encrypted, as a string&gt;
keyarray = array.array('B', key.decode(""hex""))
des = DES3.new(keyarray)
value = des.decrypt(encryptedvalue.decode('base64'))

value.decode('utf-8') # Gives me an error
</code></pre>

<p>The errors I've gotten have looked along the lines of</p>

<pre><code>UnicodeDecodeError: 'utf8' codec can't decode byte 0xa7 in position 6: invalid start byte
</code></pre>

<p>Which means that somewhere along the way, I haven't gotten something set up correctly. I've been working on this for a few hours, even going so far as trying to look into the <a href=""http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/crypto/provider/SunJCE.java"" rel=""nofollow"">SunJCE source code</a>, which <a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunJCEProvider"" rel=""nofollow"">implements DESede</a>, to see what defaults they use, but to no avail. I'm going to be using this as part of a script that runs automatically, so I'd really rather not have to use Java to do my decryption. Does anyone know what I need to do to decrypt my data correctly?</p>
","<p>All I had to do to make it work was to change this line</p>

<pre><code>keyarray = array.array('B', key.decode(""hex""))
</code></pre>

<p>to this:</p>

<pre><code>keyarray = array.array('B', key.encode(""utf-8""))
</code></pre>

<p>This matches the way that java was encoding the key, allowing me to have the correct encryption key.</p>

<hr>

<p>If you've come here hoping to learn something from this question, here's some general advice:</p>

<ol>
<li>Double-check your assumptions: The key string was a hex string, so I assumed it was being used as such.</li>
<li>Make sure you know what your assumptions are: I didn't consciously think about how I was making an assumption about how the key was used. This tends to be a very frequent problem in both programming and life in general.</li>
<li>Check <em>all</em> the values along the way (<em>especially</em> when you have an <a href=""http://en.wikipedia.org/wiki/Oracle_%28software_testing%29"" rel=""nofollow"">Oracle</a>): Looking at the values in the byte arrays was what led me to realizing my problem.</li>
</ol>
","2987","<java><python><encryption><pycrypto><3des>","1","3","1","2013-04-25 17:12:57","16220825","11","2","2216621","","2013-04-24 23:07:13","2013-04-24 22:56:39",""
"21454774","3des encryption and decryption in iOS","<p>I am working on 3DES encryption and decryption. I have done encryption successfully. For decryption, I am using this code but not getting exact result. My encryption string is ""<strong>CHc3TsfJgYs=</strong>"" and key is ""<strong>meristem</strong>"". Please tell me what I am doing wrong?</p>

<pre><code> NSString *token = @""CHc3TsfJgYs="";
    NSString *key = @""meristem"";

    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [token length];
    vplainText = (const void *) [token UTF8String];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes ;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));


    NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySizeDES,
                       NULL,// vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    NSString *result;
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    result = [myData base64Encoding];
    // result = [myDat];
    NSLog(@""dis is data %@"",result);
</code></pre>
","<pre><code>ccStatus = CCCrypt(kCCDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding | kCCOptionECBMode,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySize3DES,
                   NULL,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);
</code></pre>

<p>you need change <code>kCCKeySizeDES</code> -> <code>kCCKeySize3DES</code></p>
","2983","<ios><objective-c><encryption><3des>","2","1","1","2014-07-02 10:08:04","","3","1","","","","2014-01-30 11:09:31",""
"23143938","PHP code to encrypt using 3DES algorithm using CBC mode and a secretkey and IV spec key","<p>i am try to encrypt following data using the 3des(CBC) using a secretkey and IV spec key in php but i am not getting the same output which i get on this online tool (<a href=""http://symmetric-ciphers.online-domain-tools.com/"" rel=""nofollow"">http://symmetric-ciphers.online-domain-tools.com/</a>)</p>

<pre><code>//input
$data = ""Id=120278;timestamp=2009-02-05 08:28:39.195"";
$key = ""80127ECD5E40BB25DB14354A3795880DF2B459BB08E1EE6D"";
$iv = ""331BA9C5A7446C98"";

//output from online tool. I should get the same result in my php code
$result = ""1C80CBCE1713128176499C7A3DFB8779156B31B8DEF2F667A7100F1C3AEFABACB24283CFDF 5D312D A0074897138684BC"";
</code></pre>

<p>following the PHP code i tried</p>

<pre><code>$string = ""Id=120278;timestamp=2009-02-05 08:28:39.195"";
$iv = ""331BA9C5A7446C98"";
$passphrase = ""80127ECD5E40BB25DB14354A3795880DF2B459BB08E1EE6D""; 
$encryptedString = encryptString($string, $passphrase, $iv);

function encryptString($unencryptedText, $passphrase, $iv) { 
  $enc = mcrypt_encrypt(MCRYPT_3DES, $passphrase, $unencryptedText, MCRYPT_MODE_CBC, $iv); 
  return base64_encode($enc);
}
</code></pre>
","<p>Try this:</p>

<pre><code> function encrypt3DES($key,$iv,$text_enc){
       $block = mcrypt_get_block_size('tripledes', 'cbc');
       $pad = $block - (strlen($text_enc) % $block);
       $text_enc .= str_repeat(chr($pad), $pad);
       $text_enc = mcrypt_encrypt(MCRYPT_3DES, $key, $text_enc, MCRYPT_MODE_CBC, $iv);
       $text_enc = base64_encode ($text_enc);
       return $text_enc;
   }
</code></pre>
","2982","<php><encryption><3des><tripledes><cbc-mode>","2","1","1","2015-04-07 13:46:09","","0","1","43959","","2014-04-17 21:57:37","2014-04-17 21:40:30",""
"6478901","3DES Encryption in Objective-C","<p>I am in the process of building an application for the iMac and iPhone. The goal of the application is to encrypt plain text messages, e-mails, passwords, dates, etc. I have done some research and found that 3DES would work great and is very secure. Does anyone know how to implement 3DES in Objective-C for the iPhone or Mac? Any help would be appreciated! Thanks!</p>
","<p>It probably doesn't make a lot of sense to try to re-implement DES or any other encryption algorithm in Objective-C when there are well-known versions implemented in C and/or C++. You can simply call any of those from your Objective-C program.</p>
","2892","<iphone><objective-c><macos><encryption><3des>","2","1","3","2011-06-25 20:15:54","6479118","0","1","814730","","2011-06-25 16:16:37","2011-06-25 16:05:31",""
"6478901","3DES Encryption in Objective-C","<p>I am in the process of building an application for the iMac and iPhone. The goal of the application is to encrypt plain text messages, e-mails, passwords, dates, etc. I have done some research and found that 3DES would work great and is very secure. Does anyone know how to implement 3DES in Objective-C for the iPhone or Mac? Any help would be appreciated! Thanks!</p>
","<p>DES is an old standard that is not secure anymore because of its short key length; 3DES is one way to get it safer (uses three times more key bits). But the new standard is AES, which you could try if you don't find (or don't like) any DES libraries out there that suits your needs.
You could, for example, use <a href=""http://www.openssl.org/"" rel=""noreferrer"">OpenSSL</a> or <a href=""http://directory.fsf.org/project/libgcrypt/"" rel=""noreferrer"">libgcrypt</a>.</p>

<p>But I wouldn't implement any of these from scratch. Implementing cryptographic algorithms is kind of tricky. You need to be careful with padding, random number generators and you should be aware that the textbook descriptions of these algorithms are usually simplified (and not safe for real-world use). One book that might help if you really want to implement crypto is Wenbo Mao's <a href=""http://openlibrary.org/works/OL7947479W/Modern_Cryptography"" rel=""noreferrer""><em>""Modern Cryptography""</em></a>. If you are math-oriented you could also use Katz and Lindell's <a href=""http://www.cs.umd.edu/~jkatz/imc.html"" rel=""noreferrer""><em>""Introduction to Modern Cryptography""</em></a>.</p>
","2892","<iphone><objective-c><macos><encryption><3des>","2","6","3","2011-06-25 20:15:54","6479118","0","1","814730","","2011-06-25 16:16:37","2011-06-25 16:05:31",""
"6478901","3DES Encryption in Objective-C","<p>I am in the process of building an application for the iMac and iPhone. The goal of the application is to encrypt plain text messages, e-mails, passwords, dates, etc. I have done some research and found that 3DES would work great and is very secure. Does anyone know how to implement 3DES in Objective-C for the iPhone or Mac? Any help would be appreciated! Thanks!</p>
","<p>Both iOS and OS X have the <a href=""http://developer.apple.com/library/mac/#DOCUMENTATION/Darwin/Reference/ManPages/man3/CCCrypt.3cc.html""><code>CommonCrypto</code></a> library, which provides implementations of AES, 3DES, and DES, among others. Writing your own crypto library is difficult, error prone, and likely to cause bugs. Besides which, if you write your own encryption library, then you have to declare it and go through a U.S. government approval process if you ever plan to put it in the App Store.</p>
","2892","<iphone><objective-c><macos><encryption><3des>","2","11","3","2011-06-25 20:15:54","6479118","0","1","814730","","2011-06-25 16:16:37","2011-06-25 16:05:31",""
"12607937","3DES result in Java produces different result from 3DES iOS version","<p>I really really.... really need help...........</p>

<p><strong>-UPDATED-</strong></p>

<p>I need help because my java function gives me a different result compared with the iOS 3DES function. I posted the code from both ios and java; and results when specified plaintext is ""tutor.1"" and MD5 key is ""spO13+QLZCRAe93pIXMXLg=="" (MD5, clearly, is the same for both).</p>

<p><strong>JAVA 3DES</strong> (short and simple)</p>

<pre><code>public static String encrypt(String plaintext, String enctoken){

    if(enctoken == null)
        enctoken = ""sfdjf48mdfdf3054"";

    String encrypted = null; 

    byte[] plaintextByte = EncodingUtils.getBytes(plaintext,""UTF-8"");

    byte[] hash = Connessione.md5(enctoken);

    Log.i(""ENCRYPT"", ""MD5: ""+Base64.encodeToString(hash, 0));

    try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(hash,""DESede"");

        cipher.init(Cipher.ENCRYPT_MODE, myKey); 

        try {
            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0);

            Log.i(""ENCRYPT"", ""Pwd encrypted: ""+encrypted);

            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       

    return """";
}
</code></pre>

<p>result: <em>R4mXAaHcFxM=</em></p>

<p><strong>IOS 3DES - UPDATED AGAIN</strong></p>

<pre><code>// key value in parameters is MD5 value! It is the same for both version

+ (NSString *) encrypt:(NSString *) dataToEncrypt withKey:(NSString*) key{    


NSData *data = [dataToEncrypt dataUsingEncoding:NSUTF8StringEncoding];
NSData *mData = [key dataUsingEncoding:NSUTF8StringEncoding];

CCCryptorStatus ccStatus = kCCSuccess;


// Begin to calculate bytesNeeded....
size_t bytesNeeded = 0;

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   NULL,
                   0,
                   &amp;bytesNeeded);

if(kCCBufferTooSmall != ccStatus){

    NSLog(@""Here it must return BUFFER TOO SMALL !!"");
    return nil;
}

// .....End
// Now i do the real Crypting

char* cypherBytes = malloc(bytesNeeded);
size_t bufferLength = bytesNeeded;

if(NULL == cypherBytes)
    NSLog(@""cypherBytes NULL"");

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   cypherBytes,
                   bufferLength,
                   &amp;bytesNeeded);

if(kCCSuccess != ccStatus){
    NSLog(@""kCCSuccess NO!"");
    return nil;
}

return [Base64 encode:[NSData dataWithBytes:cypherBytes length:bufferLength]]; 
</code></pre>

<p>}</p>

<p>result: <em>YBAva5J2khY=</em></p>

<p>I need iOS version returns same result as the Java version.</p>

<p>I found the Base64 class here: <a href=""http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php"" rel=""nofollow"">http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php</a></p>

<p>What i'm doing wrong ?</p>

<p>Thx for your help and time</p>
","<p>Ok, I started off easier, using DES encryption. Also, I'm skipping the Base64 and the hashing on the key - all of these are easily added once you're sure that the encryption is working properly, and they can be added one at a time.</p>

<p>Here's the iOS code:</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &lt;CommonCrypto/CommonCrypto.h&gt;
#import &lt;CommonCrypto/CommonCryptor.h&gt;

int main(int argc, char *argv[])
{
    @autoreleasepool {


            BOOL encryptOrDecrypt = kCCEncrypt;
            NSString *plainText = @""abcdefghijklmnop"";
            NSString *key = @""01234567"";

            const void *vplainText;
            size_t plainTextBufferSize;

            NSData *tempData = [plainText dataUsingEncoding:NSASCIIStringEncoding];
            plainTextBufferSize = [tempData length];
            vplainText =  [tempData bytes];

            CCCryptorStatus ccStatus;
            uint8_t *bufferPtr = NULL;
            size_t bufferPtrSize = 0;
            size_t movedBytes = 0;

            bufferPtrSize = [plainText length];
            if (bufferPtrSize % 8) {
                bufferPtrSize += 8 - (bufferPtrSize % 8);
            }

//            bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
            bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t) + 1);   // To null-terminate a string if req'd
            memset((void *)bufferPtr, 0x0, bufferPtrSize+1);

            NSData *_keyData = [key dataUsingEncoding:NSASCIIStringEncoding];

            NSLog(@""key byte is %s"", [_keyData bytes]);

            // Initialization vector; dummy in this case 0's.
            // uint8_t iv[kCCBlockSize3DES];
            // memset((void *) iv, 0x0, (size_t) sizeof(iv));

            ccStatus = CCCrypt(encryptOrDecrypt,
                                   kCCAlgorithmDES,
                                   kCCOptionECBMode, //kCCOptionPKCS7Padding | kCCOptionECBMode,
                                   (const void *)[_keyData bytes], //key
                                   kCCKeySizeDES,
                                   nil,  //iv,
                                   vplainText,  //plainText,
                                   plainTextBufferSize,
                                   (void *)bufferPtr,
                                   bufferPtrSize,
                                   &amp;movedBytes);

            //if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
            /*else*/
            switch (ccStatus) {
                case kCCParamError:
                    NSLog(@""PARAM ERROR"");
                    break;
                case kCCBufferTooSmall:
                    NSLog(@""BUFFER TOO SMALL"");
                    break;
                case kCCMemoryFailure:
                    NSLog(@""MEMORY FAILURE"");
                    break;
                case kCCAlignmentError:
                    NSLog(@""ALIGNMENT ERROR"");
                    break;
                case kCCDecodeError:
                    NSLog(@""DECODE ERROR"");
                    break;
                case kCCUnimplemented:
                    NSLog(@""UNIMPLEMENTED"");
                    break;
                default:
                    NSLog(@""encrypt seems to have worked"");
                    break;
            }

            for (size_t i=0; i&lt;movedBytes; i++) {
                printf(""%02x "", (int) bufferPtr[i]);
            }
            printf(""\n"");

        return UIApplicationMain(argc, argv, nil, NSStringFromClass([FAAppDelegate class]));
    }
}
</code></pre>

<p>And here's the Java code:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;


public class DesRun {
    /**
     * @param args
     */
    public static void main(String[] args) {
        String theKey = ""01234567"";
        String message = ""abcdefghijklmnop"";
        Cipher ecipher, dcipher;
         try {
            // generate secret key using DES algorithm
             SecretKeySpec key = new SecretKeySpec(theKey.getBytes(""UTF-8""), ""DES"");

                 ecipher = Cipher.getInstance(""DES"");
                 dcipher = Cipher.getInstance(""DES"");

                 // initialize the ciphers with the given key
                 ecipher.init(Cipher.ENCRYPT_MODE, key);
                 dcipher.init(Cipher.DECRYPT_MODE, key);

                 byte[] encrypted = ecipher.doFinal(message.getBytes(""UTF-8""));
                 System.out.println(DatatypeConverter.printHexBinary(encrypted));
                 String decrypted = new String(dcipher.doFinal(encrypted), ""UTF-8"");

                 System.out.println(""Decrypted: "" + decrypted);

             }
             catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

    }
}
</code></pre>

<p>Both print out the hex bytes of the encrypted data, and they agree.</p>

<p>Now it should be (relatively) easy to move to 3DES.</p>

<p>Only once you've got 3DES agreeing on both iOS and Java would I start to add hashing on the keys.</p>
","2747","<java><ios><algorithm><encryption><3des>","0","0","2","2013-01-29 21:36:30","13458949","15","2","736196","","2012-10-16 16:49:18","2012-09-26 18:15:54",""
"12607937","3DES result in Java produces different result from 3DES iOS version","<p>I really really.... really need help...........</p>

<p><strong>-UPDATED-</strong></p>

<p>I need help because my java function gives me a different result compared with the iOS 3DES function. I posted the code from both ios and java; and results when specified plaintext is ""tutor.1"" and MD5 key is ""spO13+QLZCRAe93pIXMXLg=="" (MD5, clearly, is the same for both).</p>

<p><strong>JAVA 3DES</strong> (short and simple)</p>

<pre><code>public static String encrypt(String plaintext, String enctoken){

    if(enctoken == null)
        enctoken = ""sfdjf48mdfdf3054"";

    String encrypted = null; 

    byte[] plaintextByte = EncodingUtils.getBytes(plaintext,""UTF-8"");

    byte[] hash = Connessione.md5(enctoken);

    Log.i(""ENCRYPT"", ""MD5: ""+Base64.encodeToString(hash, 0));

    try {
        Cipher cipher = Cipher.getInstance(""DESEDE/ECB/PKCS5Padding"");
        SecretKeySpec myKey = new SecretKeySpec(hash,""DESede"");

        cipher.init(Cipher.ENCRYPT_MODE, myKey); 

        try {
            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);

            encrypted = Base64.encodeToString(encryptedPlainText, 0);

            Log.i(""ENCRYPT"", ""Pwd encrypted: ""+encrypted);

            return encrypted;

        } catch (IllegalBlockSizeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (BadPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }       

    return """";
}
</code></pre>

<p>result: <em>R4mXAaHcFxM=</em></p>

<p><strong>IOS 3DES - UPDATED AGAIN</strong></p>

<pre><code>// key value in parameters is MD5 value! It is the same for both version

+ (NSString *) encrypt:(NSString *) dataToEncrypt withKey:(NSString*) key{    


NSData *data = [dataToEncrypt dataUsingEncoding:NSUTF8StringEncoding];
NSData *mData = [key dataUsingEncoding:NSUTF8StringEncoding];

CCCryptorStatus ccStatus = kCCSuccess;


// Begin to calculate bytesNeeded....
size_t bytesNeeded = 0;

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   NULL,
                   0,
                   &amp;bytesNeeded);

if(kCCBufferTooSmall != ccStatus){

    NSLog(@""Here it must return BUFFER TOO SMALL !!"");
    return nil;
}

// .....End
// Now i do the real Crypting

char* cypherBytes = malloc(bytesNeeded);
size_t bufferLength = bytesNeeded;

if(NULL == cypherBytes)
    NSLog(@""cypherBytes NULL"");

ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding,
                   [mData bytes],
                   [mData length],
                   nil,
                   [data bytes],
                   [data length],
                   cypherBytes,
                   bufferLength,
                   &amp;bytesNeeded);

if(kCCSuccess != ccStatus){
    NSLog(@""kCCSuccess NO!"");
    return nil;
}

return [Base64 encode:[NSData dataWithBytes:cypherBytes length:bufferLength]]; 
</code></pre>

<p>}</p>

<p>result: <em>YBAva5J2khY=</em></p>

<p>I need iOS version returns same result as the Java version.</p>

<p>I found the Base64 class here: <a href=""http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php"" rel=""nofollow"">http://www.imthi.com/blog/programming/iphone-sdk-base64-encode-decode.php</a></p>

<p>What i'm doing wrong ?</p>

<p>Thx for your help and time</p>
","<p>Error found. keydata encoding was different</p>
","2747","<java><ios><algorithm><encryption><3des>","0","0","2","2013-01-29 21:36:30","13458949","15","2","736196","","2012-10-16 16:49:18","2012-09-26 18:15:54",""
"4949373","3DES - Decrypt encrypted text (by JAVA) in C#","<p>Here is the situation:</p>

<ol>
<li>The encrypted text is done in JAVA (which we have no JAVA background at all)</li>
<li>The method is 3DES</li>
<li>The padded is PKCS#5</li>
<li>Base 64</li>
</ol>

<p>The decryption will be in C#, and here is the code:</p>

<pre><code>    public static string DecryptString(string Message, string Passphrase)
    {
        byte[] Results;
        UTF8Encoding UTF8 = new UTF8Encoding();

        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));

        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

        TDESAlgorithm.Key = TDESKey;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;

        byte[] DataToDecrypt = Convert.FromBase64String(Message);

        try
        {
            ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
            Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length);
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }

        return UTF8.GetString(Results);
    }
</code></pre>

<p>However, when tried to decrypt, got the error message: BAD DATA</p>

<p>Where am I missing here?</p>

<p>Thanks in advance.</p>

<p>Added, and here's how the encryption works:</p>

<pre><code>&lt;cffunction name=""getToken"" returntype=""String"" output=""false""&gt;
    &lt;cfscript&gt;
        plainText = getPlainText();
        rawSecretKey = CreateObject(""java"",""sun.misc.BASE64Decoder"").decodeBuffer(variables.encryptionKey);

        secretKeySpec = CreateObject(""java"",""javax.crypto.spec.SecretKeySpec"").init(rawSecretKey,""DESEDE"");

        cipher = CreateObject(""java"",""javax.crypto.Cipher"").getInstance(""DESEDE"");
        cipher.init(Cipher.ENCRYPT_MODE, secretkeySpec);

        encrypted = cipher.doFinal(plainText.getBytes()); // a byte array (a binary in CF)

        return URLEncodedFormat(ToString(ToBase64(encrypted)));
    &lt;/cfscript&gt;
&lt;/cffunction&gt;
</code></pre>

<p><strong>Update:</strong>
This issue has been resolved. The problem was that the key needed to be converted from Base64.</p>
","<p>The answer:</p>

<p>Instead of:</p>

<pre><code>byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));
</code></pre>

<p>Do this:</p>

<pre><code>byte[] TDESKey = Convert.FromBase64String(Passphrase);
</code></pre>

<p>That solves this issue.</p>
","2746","<java><c#-2.0><3des>","0","0","1","2011-02-22 16:24:48","","4","","610271","","2011-02-09 20:07:22","2011-02-09 19:14:10",""
"13097592","Decrypting data from MagTek iDynamo encrypted card reader","<p>Does anyone have reference code (even if pseudo-code) for decrypting data from a MagTek iDynamo encrypted card reader?  The ANSI X9.24 standard is... lacking... in the pseudo-code and readability department.  I have the master key, KSN, and cipher text and need to derive the session key and get to the clear text.  I've implemented an algorithm similar to the one found <a href=""http://www.andyorrock.com/2006/11/creating_an_ipe.html"" rel=""nofollow"">here</a> and added a loop based on the counter portion of the KSN but it still doesn't produce actual card track data.</p>
","<p>here is the DUKPT class i wrote to do what you need:</p>

<p><a href=""https://github.com/mburshteyn1/DUKPT"" rel=""nofollow"">https://github.com/mburshteyn1/DUKPT</a></p>
","2735","<encryption><3des>","2","4","1","2018-05-02 17:48:49","14655120","4","2","","","","2012-10-27 05:40:57",""
"43642667","Using Triple DES(3DES) with PHP 7.1","<p>I need a way to encrypt and decrypt with 3des. I'm currently using php 7.1</p>

<p>I found <a href=""https://stackoverflow.com/questions/22592919/triple-des-encryption-decryption-using-php"">this</a> question, but mcrypt is <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">deprecated</a> as of php 7.1 and I can't find any other resource for this. </p>
","<p>Continue to the Comments section of the function's manual and you'll see the following:</p>

<blockquote>
  <p>If you're writing code to encrypt/encrypt data in 2015, you should use
  openssl_encrypt() and openssl_decrypt(). The underlying library
  (libmcrypt) has been abandoned since 2007, and performs far worse than
  OpenSSL (which leverages AES-NI on modern processors and is
  cache-timing safe).
  [<a href=""http://php.net/manual/en/function.mcrypt-encrypt.php#117667"" rel=""nofollow noreferrer"">Link to the full comment]</a></p>
</blockquote>

<p>So, Consider using <a href=""http://php.net/manual/en/function.openssl-encrypt.php"" rel=""nofollow noreferrer""><code>openssl_encrypt()</code></a> &amp; openssl_decrypt() instead.
They are still being supported and better performing.</p>
","2698","<php><des><3des><tripledes><php-7.1>","0","1","1","2017-07-09 23:55:20","","2","","-1","","2017-05-23 12:02:34","2017-04-26 19:11:58","2019-03-07 07:42:48"
"17037172","machinekey validation using 3DES","<p>I am getting the error on the following machinekey when using validationkey &amp; decryption key using 3DES validation. it works when i removed both. what's the best approach when using 3DES?</p>

<pre><code>&lt;machineKey       validationKey=""AD34B95FCD4C35848217F74E18AAC1DB029CB2265C46ECCA6E1A2F558B6A2EDFF3AF81FE84F39935F44152B3B6978F843659B1D9370C9D1F7ABAF3B687C726A2""
        decryptionKey=""0932BBEB28DFA274EFBE9D9A2BBDF7DDBDA08B56BFD186F2512DD06AC7DBD16E""
        validation=""3DES"" decryption=""AES""
/&gt;
</code></pre>
","<p>You need to change your validation key to a valid 3DES key, they have specific length requirements.
Looks like your key is for SHA1.</p>

<p>Take a look at this <a href=""http://msdn.microsoft.com/en-us/library/ms998288.aspx"" rel=""nofollow"">MSDN Article</a></p>

<blockquote>
  <p>""For SHA1, set the validationKey to 64 bytes (128 hexadecimal
  characters).  For AES, set the decryptionKey to 32 bytes (64
  hexadecimal characters).  For 3DES, set the decryptionKey to 24 bytes
  (48 hexadecimal characters).""</p>
</blockquote>

<p>You may want to use <a href=""http://www.a2zmenu.com/utility/Machine-Key-Generator.aspx"" rel=""nofollow"">this tool</a> to generate your key specifying the algorithm</p>
","2676","<encryption><viewstate><3des><machinekey>","0","1","1","2013-09-20 21:17:18","","0","","474189","","2013-06-11 08:21:00","2013-06-11 05:38:45",""
"7194185","3DES encryption different on iPhone and server","<p>I have the following code for encrypting the request i am sending to my server. The decoding on the server is done by .NET and on the iPhone, I am using the security framework with the following code.  </p>

<pre><code>- (NSString*) doCipher:(NSString*)plainText:(CCOperation)encryptOrDecrypt {

const void *vplainText;
size_t plainTextBufferSize;

if (encryptOrDecrypt == kCCDecrypt)
{
    NSData *EncryptData = [[NSData alloc] initWithBase64EncodedString:plainText];
    plainTextBufferSize = [EncryptData length];
    vplainText = [EncryptData bytes];
}
else
{
    plainTextBufferSize = [plainText length];
    vplainText = (const void *) [plainText UTF8String];
}

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
// uint8_t iv[kCCBlockSize3DES];

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x0, (size_t) sizeof(iv));

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);
// memset((void *) iv, 0x0, (size_t) sizeof(iv));

NSString *key = @""D3v3lop_4pp13_f0r_M4z4Y4"";
const void *vkey = (const void *) [key UTF8String];

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySize3DES,
                   iv, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);
if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
else if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{
    result = [[ [NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    result = [myData base64Encoding];   
}    
return result;
}    
</code></pre>

<p>The encryption on the server and the iPhone give the same result when the encrypted string is less than 8 characters! after that, it gives different results.
I am a total beginner with this, is there any hint on where to look?</p>
","<p>Yes, your cipher modes and/or padding are different.  Make sure you are using the same mode on both the server and client. For instance, in most cases CBC mode with PKCS#7 padding is a good choice.</p>

<p>Is there any particular reason you are using 3DES? It is significantly slower than AES (with slightly worse properties). </p>
","2658","<iphone><ios><encryption><3des>","4","0","1","2014-10-20 05:30:29","","1","0","","","","2011-08-25 16:47:59",""
"9196207","Decrypting a string in ColdFusion encrypted with 3DES in C#","<p>We are having difficulty decrypting a string in ColdFusion that was previously encrypted with 3DES and C#. Here is the code we used to encrypt the string initially:</p>

<pre><code>    public static string EncryptTripleDES(string plaintext, string key)
    {
    TripleDESCryptoServiceProvider DES = new TripleDESCryptoServiceProvider();
    MD5CryptoServiceProvider hashMD5 = new MD5CryptoServiceProvider();
    DES.Key = hashMD5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(key));
    DES.Mode = CipherMode.ECB;
    ICryptoTransform DESEncrypt = DES.CreateEncryptor();
    byte[] Buffer = ASCIIEncoding.ASCII.GetBytes(plaintext);

    string EncString = Convert.ToBase64String(DESEncrypt.TransformFinalBlock(Buffer, 0, Buffer.Length));
    EncString = EncString.Replace(""+"", ""@@12"");

    return EncString;
    }
</code></pre>

<p>We have tried using the suggestions here:</p>

<p><a href=""https://stackoverflow.com/questions/1474801/tripledes-encryption-net-and-coldfusion-not-playing-nice"">TripleDES Encryption - .NET and ColdFusion not playing nice</a></p>

<p>..with no luck. Here is our CF code and the error:</p>

<pre><code>  &lt;cfset variables.theKey = ""blahblah"" /&gt;
  &lt;cfset variables.theAlgorithm = ""DESede/CBC/PKCS5Padding""&gt;
  &lt;cfset variables.theEncoding = ""Base64""&gt;
  &lt;cfset strTest = decrypt(#DB.PASSWORD#, variables.theKey, variables.theAlgorithm, variables.theEncoding)&gt;
</code></pre>

<p>Error returned: An error occurred while trying to encrypt or decrypt your input string: '' Can not decode string ""blahblah""</p>

<p>So, it looks like it's trying to decrypt the key and not the string, but that's not how the decrypt function is outlined in ColdFusion. Any ideas?</p>

<p><strong>UPDATE:</strong> Attempted to use the following CF code, but the error returned is still ""An error occurred while trying to encrypt or decrypt your input string: Given final block not properly padded.""</p>

<pre><code>&lt;cfset dbPassword  = ""Hx41SYUrmnFPa31QCH1ArCHN1YOF8IAL""&gt;
&lt;cfset finalText   = replace(dbPassword, ""@@12"", ""+"", ""all"")&gt;
&lt;cfset theKey      = ""abcdefgh""&gt;
&lt;cfset theKeyInBase64 = toBase64(theKey)&gt;
&lt;cfset hashedKey   = hash( theKeyInBase64, ""md5"" )&gt;
&lt;cfset padBytes    = left( hashedKey, 16 )&gt;
&lt;cfset keyBytes    = binaryDecode( hashedKey &amp; padBytes , ""hex"" )&gt;
&lt;cfset finalKey    = binaryEncode( keyBytes, ""base64"" )&gt;
&lt;cfset decrypted = decrypt( finalText, finalKey, ""DESede/ECB/PKCS5Padding"", ""base64"" )&gt;
Decrypted String: &lt;cfdump var=""#decrypted#""&gt;
</code></pre>

<p><strong>UPDATE:</strong></p>

<p>The solution if you follow the comments was to change:</p>

<pre><code>&lt;cfset hashedKey   = hash( theKeyInBase64, ""md5"" )&gt;
</code></pre>

<p>To:</p>

<pre><code>&lt;cfset hashedKey   = hash( theKey, ""md5"" )&gt;
</code></pre>

<p>The final code is this:</p>

<pre><code>&lt;cfset dbPassword  = ""Hx41SYUrmnFPa31QCH1ArCHN1YOF8IAL""&gt;
&lt;cfset finalText   = replace(dbPassword, ""@@12"", ""+"", ""all"")&gt;
&lt;cfset theKey      = ""abcdefgh""&gt;
&lt;cfset hashedKey   = hash( theKey, ""md5"" )&gt;
&lt;cfset padBytes    = left( hashedKey, 16 )&gt;
&lt;cfset keyBytes    = binaryDecode( hashedKey &amp; padBytes , ""hex"" )&gt;
&lt;cfset finalKey    = binaryEncode( keyBytes, ""base64"" )&gt;
&lt;cfset decrypted = decrypt( finalText, finalKey, ""DESede/ECB/PKCS5Padding"", ""base64"" )&gt;
Decrypted String: &lt;cfdump var=""#decrypted#""&gt;
</code></pre>
","<p>Looks like there a few extra twists in your c# function you need to handle to achieve compatibility:</p>

<ol>
<li><p>The .NET function modifies the encrypted string. You need to
reverse those changes so decrypt will recognize it as valid base64:</p>

<pre><code>&lt;!--- reverse replacements in encrypted text ie #DB.Password# ---&gt;
&lt;cfset dbPassword = ""uAugP@@12aP4GGBOLCLRqxlNPL1PSHfTNEZ""&gt;
&lt;cfset finalText = replace(dbPassword, ""@@12"", ""+"", ""all"")&gt;
</code></pre></li>
<li><p>The function also uses a hash which creates a 16 byte key. CF/java require a <a href=""https://web.archive.org/web/20150105220023/http://helpx.adobe.com/coldfusion/kb/strong-encryption-coldfusion-mx-7.html"" rel=""nofollow noreferrer"">24 byte key</a> for that algorithm. So you must first hash the key and <a href=""http://tripoverit.blogspot.com/2009/06/tripledes-encryption-compatibility.html"" rel=""nofollow noreferrer"">pad it to the proper length</a>. Otherwise, decrypt() will complain the key is too small. </p>

<p>Note: CF also expects the final key to be base64 encoded. The error <em>Can not decode string ""blahblah""</em> suggests your input key is not in base64.</p>

<pre><code>&lt;!--- hash and pad the key (ie ""blahblah""), then convert to base64 for CF ---&gt;
&lt;cfset theKeyInBase64 = ""rpaSPvIvVLlrcmtzPU9/c67Gkj7yL1S5""&gt;
&lt;cfset hashedKey   = hash( theKeyInBase64, ""md5"" )&gt;
&lt;cfset padBytes    = left( hashedKey, 16 )&gt;
&lt;cfset keyBytes    = binaryDecode( hashedKey &amp; padBytes , ""hex"" )&gt;
&lt;cfset finalKey    = binaryEncode( keyBytes, ""base64"" )&gt;
</code></pre></li>
<li><p>Finally, the feedback modes must match. Since the .NET code uses the less secure <code>ECB</code> mode, the CF code must use that mode as well.</p>

<pre><code>&lt;!--- .net code uses the less secure ECB mode ---&gt;
&lt;cfset decrypted = decrypt( finalText, finalKey, ""DESede/ECB/PKCS5Padding"", ""base64"" )&gt;
Decrypted String: &lt;cfdump var=""#decrypted#""&gt;
</code></pre></li>
<li><p>One other issue to watch out for is encoding. In CF, encrypt/decrypt always interpret the input string as UTF8, whereas the .NET function uses <a href=""http://msdn.microsoft.com/en-US/library/system.text.asciiencoding%28v=vs.80%29.aspx"" rel=""nofollow noreferrer"">ASCII</a>. For full compatibility, both sides should use the same encoding, in this case UTF8. </p></li>
</ol>

<hr>

<p><strong>Update:</strong> </p>

<p>I tested the above with an arbitrary 8 character key (instead of a base64 string) and CF9 still decrypted the string properly. </p>

<pre><code>// .NET Code
String text = ""some text to encrypt"";
String key = ""abcdefgh"";
String encrypted = EncryptTripleDES(text, key);
// result: encrypted=Hx41SYUrmnFPa31QCH1ArCHN1YOF8IAL
Console.WriteLine(""encrypted={0}"", encrypted);

&lt;!--- same code, only the encrypted text and key changed ---&gt; 
&lt;cfset dbPassword  = ""Hx41SYUrmnFPa31QCH1ArCHN1YOF8IAL""&gt;
&lt;cfset finalText   = replace(dbPassword, ""@@12"", ""+"", ""all"")&gt;
&lt;cfset theKey      = ""abcdefgh""&gt;
&lt;cfset hashedKey   = hash( theKey, ""md5"" )&gt;
.... 
</code></pre>
","2616","<c#><asp.net><coldfusion><3des>","4","5","1","2019-07-09 20:52:22","9205089","4","0","-1","","2017-05-23 10:34:17","2012-02-08 15:22:59",""
"8566700","Unable to Decrypt using TripleDES in .NET encrypted in Java","<p>We have a Java client that sending us some encrypted data 
1. A random string is encrypted using RSA and public key we provided them offline.
2. using the key generated in step1 they encrypt the data using alg_tripleDES_CBC = <a href=""http://www.w3.org/2001/04/xmlenc#tripledes-cbc"" rel=""nofollow"">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</a></p>

<p>I was able to decrypt the key from 1st step like this ... which is working.</p>

<pre><code>public static string DecryptKey(string encryptedKey)
    {
        X509Certificate2 cert = new X509Certificate2(""c:\\test.pfx"", ""test"");
        RSACryptoServiceProvider privateKeyProvider = (RSACryptoServiceProvider)cert.PrivateKey;

        string decryptedKey = System.Text.Encoding.UTF8.GetString(privateKeyProvider.Decrypt(Convert.FromBase64String(encryptedKey), false));

        return decryptedKey;

    }
</code></pre>

<p>And I have this code to decrypt the data using the key generated from 1st step.</p>

<pre><code> public static string DecryptString(string Message, string Passphrase)
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();

        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));

        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

        TDESAlgorithm.Key = TDESKey;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;

        byte[] DataToDecrypt = Convert.FromBase64String(Message);

        try
        {
            ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
            Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length);
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }

        return UTF8.GetString(Results);
    }
</code></pre>

<p>And the second step fails with this exception.</p>

<pre><code>   System.Security.Cryptography.CryptographicException: Bad Data.

   at System.Security.Cryptography.CryptographicException.ThrowCryptographicException(Int32 hr)
   at System.Security.Cryptography.Utils._DecryptData(SafeKeyHandle hKey, Byte[] data, Int32 ib, Int32 cb, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode PaddingMode, Boolean fDone)
   at System.Security.Cryptography.CryptoAPITransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at ConsoleApplication3.Program.DecryptString(String Message, String Passphrase) in C:\Documents and Settings\rjaladi\Desktop\ConsoleApplication3\ConsoleApplication3\Program.cs:line 66
   at ConsoleApplication3.Program.Main(String[] args) in C:\Documents and Settings\rjaladi\Desktop\ConsoleApplication3\ConsoleApplication3\Program.cs:line 22 
</code></pre>

<p>What is that I need to check with our client? I know that there is something wrong with the parameters we are passing to TDES. Any help?</p>

<p>EDIT: Corresponding Java code that encrypts the message.</p>

<pre><code>public String encryptText(String plainText) throws Exception{

  byte[] plaintext = plainText.getBytes();
  byte[] tdesKeyData = key;
  byte[] myIV = initializationVector;

  Cipher c3des = Cipher.getInstance(""""DESede/CBC/NoPadding"""");
  SecretKeySpec    myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
  IvParameterSpec ivspec = new IvParameterSpec(myIV);
     c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
  byte[] cipherText = c3des.doFinal(plaintext);
  sun.misc.BASE64Encoder obj64=new sun.misc.BASE64Encoder();
  return obj64.encode(cipherText);
 }
</code></pre>
","<p>Probably this fails: </p>

<pre><code>TDESAlgorithm.Mode = CipherMode.ECB;
</code></pre>

<p>You should use CBC ciphermode if you used CBC to encrypt the Java. And its not recommended to use ECB anyways, because it has some security flaws.</p>
","2569","<c#><java><3des>","-2","2","2","2011-12-19 21:37:19","8567258","3","3","132985","","2011-12-19 21:37:19","2011-12-19 19:51:48",""
"8566700","Unable to Decrypt using TripleDES in .NET encrypted in Java","<p>We have a Java client that sending us some encrypted data 
1. A random string is encrypted using RSA and public key we provided them offline.
2. using the key generated in step1 they encrypt the data using alg_tripleDES_CBC = <a href=""http://www.w3.org/2001/04/xmlenc#tripledes-cbc"" rel=""nofollow"">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</a></p>

<p>I was able to decrypt the key from 1st step like this ... which is working.</p>

<pre><code>public static string DecryptKey(string encryptedKey)
    {
        X509Certificate2 cert = new X509Certificate2(""c:\\test.pfx"", ""test"");
        RSACryptoServiceProvider privateKeyProvider = (RSACryptoServiceProvider)cert.PrivateKey;

        string decryptedKey = System.Text.Encoding.UTF8.GetString(privateKeyProvider.Decrypt(Convert.FromBase64String(encryptedKey), false));

        return decryptedKey;

    }
</code></pre>

<p>And I have this code to decrypt the data using the key generated from 1st step.</p>

<pre><code> public static string DecryptString(string Message, string Passphrase)
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();

        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(Passphrase));

        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();

        TDESAlgorithm.Key = TDESKey;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;

        byte[] DataToDecrypt = Convert.FromBase64String(Message);

        try
        {
            ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
            Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length);
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }

        return UTF8.GetString(Results);
    }
</code></pre>

<p>And the second step fails with this exception.</p>

<pre><code>   System.Security.Cryptography.CryptographicException: Bad Data.

   at System.Security.Cryptography.CryptographicException.ThrowCryptographicException(Int32 hr)
   at System.Security.Cryptography.Utils._DecryptData(SafeKeyHandle hKey, Byte[] data, Int32 ib, Int32 cb, Byte[]&amp; outputBuffer, Int32 outputOffset, PaddingMode PaddingMode, Boolean fDone)
   at System.Security.Cryptography.CryptoAPITransform.TransformFinalBlock(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at ConsoleApplication3.Program.DecryptString(String Message, String Passphrase) in C:\Documents and Settings\rjaladi\Desktop\ConsoleApplication3\ConsoleApplication3\Program.cs:line 66
   at ConsoleApplication3.Program.Main(String[] args) in C:\Documents and Settings\rjaladi\Desktop\ConsoleApplication3\ConsoleApplication3\Program.cs:line 22 
</code></pre>

<p>What is that I need to check with our client? I know that there is something wrong with the parameters we are passing to TDES. Any help?</p>

<p>EDIT: Corresponding Java code that encrypts the message.</p>

<pre><code>public String encryptText(String plainText) throws Exception{

  byte[] plaintext = plainText.getBytes();
  byte[] tdesKeyData = key;
  byte[] myIV = initializationVector;

  Cipher c3des = Cipher.getInstance(""""DESede/CBC/NoPadding"""");
  SecretKeySpec    myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
  IvParameterSpec ivspec = new IvParameterSpec(myIV);
     c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
  byte[] cipherText = c3des.doFinal(plaintext);
  sun.misc.BASE64Encoder obj64=new sun.misc.BASE64Encoder();
  return obj64.encode(cipherText);
 }
</code></pre>
","<p>Your exception is being thrown in <code>_DecryptData(...)</code> which I notice includes a <code>PaddingMode</code> parameter.  Padding at the end of that last block will be checked and an error thrown if incorrect padding is found.  I suggest that you check with whoever is sending the data to see what padding mode they are using.  You will need to use the same padding mode when decrypting.</p>

<p>As @klartrex says, you should not use ECB mode, it leaks information; see <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes#Electronic_codebook_.28ECB.29"" rel=""nofollow"">here</a> for a (literal) illustration.  Use either CBC or CTR mode instead if you can persuade the other end to do so.</p>
","2569","<c#><java><3des>","-2","1","2","2011-12-19 21:37:19","8567258","3","3","132985","","2011-12-19 21:37:19","2011-12-19 19:51:48",""
"22503898","encrypt nsstring with 3des ios7","<p>I am  new with iOS7 development and objective c, and i need to develop an application which will send encrypted data with 3DES  to a server,I have searched in stack overflow and Net but still unable to get it work, finally i tried this code but i got null as result, </p>

<pre><code>+ (NSString*)encrypt:(NSString*)plainText withKey:(NSString*)key{
    uint8_t keyByte[kSecrectKeyLength];

    NSMutableData *keyData = [[NSMutableData alloc] init];
    int i;
    for (i=0; i &lt; [key length] / 2; i++) {
        NSString *tempNumber = [key substringWithRange: NSMakeRange(i * 2, 2)];
        NSScanner *scanner=[NSScanner scannerWithString:tempNumber];
        unsigned int temp;
        [scanner scanHexInt:&amp;temp];
        Byte B = (Byte)(0xFF &amp; temp);
        keyByte[i] = B;
    }

    NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding];
    size_t plainTextBufferSize = [data length];
    const void *vplainText = (const void *)[data bytes];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    const void *vkey = (const void *) keyByte;
    const void *vinitVec = (const void *) [gIv UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding,
                       vkey,
                       kCCKeySize3DES,
                       vinitVec,
                       vplainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    //NSString *result = [GTMBase64 stringByEncodingData:myData];
    NSString *result = [[NSString alloc] initWithData:myData encoding:NSUTF8StringEncoding];

    NSLog(@""result=%@"",result);

    return result;
}
</code></pre>

<p>Please have u any idea about the solution???</p>
","<p>lol i just struggled with this myself the other day, i have a working solution now using this code</p>

<pre><code>+ (NSData *)tripleDesEncryptString:(NSString *)input
                               key:(NSString *)key
                             error:(NSError **)error
{
NSParameterAssert(input);
NSParameterAssert(key);

NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];
NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

size_t outLength;

NSAssert(keyData.length == kCCKeySize3DES, @""the keyData is an invalid size"");

NSMutableData *outputData = [NSMutableData dataWithLength:(inputData.length  +  kCCBlockSize3DES)];

CCCryptorStatus
result = CCCrypt(kCCEncrypt, // operation
                 kCCAlgorithm3DES, // Algorithm
                 kCCOptionPKCS7Padding | kCCOptionECBMode, // options
                 keyData.bytes, // key
                 keyData.length, // keylength
                 nil,// iv
                 inputData.bytes, // dataIn
                 inputData.length, // dataInLength,
                 outputData.mutableBytes, // dataOut
                 outputData.length, // dataOutAvailable
                 &amp;outLength); // dataOutMoved

if (result != kCCSuccess) {
    if (error != NULL) {
        *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name.""
                                     code:result
                                 userInfo:nil];
    }
    return nil;
}
[outputData setLength:outLength];
return outputData;
}



+ (NSString *)tripleDesDecryptData:(NSData *)input
                               key:(NSString *)key
                             error:(NSError **)error
{
NSParameterAssert(input);
NSParameterAssert(key);

NSData *inputData = input;
NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

size_t outLength;

NSAssert(keyData.length == kCCKeySize3DES, @""the keyData is an invalid size"");

NSMutableData *outputData = [NSMutableData dataWithLength:(inputData.length  +  kCCBlockSize3DES)];

CCCryptorStatus
result = CCCrypt(kCCDecrypt, // operation
                 kCCAlgorithm3DES, // Algorithm
                 kCCOptionPKCS7Padding | kCCOptionECBMode, // options
                 keyData.bytes, // key
                 keyData.length, // keylength
                 nil,// iv
                 inputData.bytes, // dataIn
                 inputData.length, // dataInLength,
                 outputData.mutableBytes, // dataOut
                 outputData.length, // dataOutAvailable
                 &amp;outLength); // dataOutMoved

if (result != kCCSuccess) {
    if (error != NULL) {
        *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name.""
                                     code:result
                                 userInfo:nil];
    }
    return nil;
}
[outputData setLength:outLength];
return [[NSString alloc] initWithData:outputData encoding:NSUTF8StringEncoding];
}
</code></pre>

<p>you probably want to base64 encode the data the comes out of the encryption method, and then un-base64 anything that you want to decrypt as well, there are built in methods for NSData to do this now, eg:</p>

<pre><code>[data base64EncodedDataWithOptions:(NSDataBase64EncodingOptions)];
</code></pre>

<p>to test if the functions work, i used this test function</p>

<pre><code>+ (void) testEncryptionAndDecryption {

    NSData *encrypted = [self tripleDesEncryptString:@""test"" key:@""123456789123456789123456"" error:nil];
    NSLog(@""encrypted data length: %lu"", (unsigned long)encrypted.length);
    NSString *decrypted = [self tripleDesDecryptData:encrypted key:@""123456789123456789123456"" error:nil];
    NSLog(@""decrypted text: %@"", decrypted);
}
</code></pre>

<p>this gave me the correct output that you would expect</p>
","2387","<objective-c><3des>","1","5","1","2014-03-20 11:35:52","22504038","0","1","299924","","2014-03-19 11:10:33","2014-03-19 11:08:32",""
"9680230","AES vs 3DES for NFC device authentication (Mifare)","<p>I'm in a situation where i have to choose between two types of cards,
Mifare Ultralight C and Mifare Plus. Former offers 3DES and the latter, AES. QUite obviously, security is a must and is important in the given circumstance.</p>

<ol>
<li>On what basis do i select the technology?</li>
<li>If possible, do you know how it can be used through the Android SDK?</li>
<li>Please keep in mind ultimately i would like to move into Payments through the usage of NFC. Does this change the dynamics of the selection criteria?</li>
</ol>

<p>Thanks</p>
","<p>Considering that according to the <a href=""http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf"" rel=""nofollow"">Mifare Ultralight C documentation</a> the DES implementation is a 2-key DES only (and not a 3-key DES) I would prefer the AES capable card.</p>
","2385","<android><security><aes><nfc><3des>","1","1","2","2012-03-13 09:14:25","9681161","1","1","","","","2012-03-13 07:58:46",""
"9680230","AES vs 3DES for NFC device authentication (Mifare)","<p>I'm in a situation where i have to choose between two types of cards,
Mifare Ultralight C and Mifare Plus. Former offers 3DES and the latter, AES. QUite obviously, security is a must and is important in the given circumstance.</p>

<ol>
<li>On what basis do i select the technology?</li>
<li>If possible, do you know how it can be used through the Android SDK?</li>
<li>Please keep in mind ultimately i would like to move into Payments through the usage of NFC. Does this change the dynamics of the selection criteria?</li>
</ol>

<p>Thanks</p>
","<p>Some facts that may help in your decision:</p>

<ul>
<li>MIFARE Plus has 3 possible Security Levels (depending on the exact type of MIFARE Plus IC). Security Level 2 cannot be accessed by the Android NFC API.</li>
<li>MIFARE Plus, although it is Android <code>IsoDep</code> compatible, is not ISO 7816 compatible</li>
<li>Communication between phone and MIFARE Ultralight C (and v.v.) is never encrypted.</li>
<li>MIFARE Ultralight C has very limited storage capability</li>
<li>MIFARE DESFire EV1 offers 3DES and AES authentication and communication encryption, offers ISO 7816 compatibility, is NFC Forum compliant and available in 2K, 4K and 8K variants.</li>
</ul>
","2385","<android><security><aes><nfc><3des>","1","1","2","2012-03-13 09:14:25","9681161","1","1","","","","2012-03-13 07:58:46",""
"11928196","3des encryption in iphone","<p>i am fairly new to iOS development and objective c.
I am developing an application which will send encrypted data to a server.
The server uses 3des with cbc and no padding.
I have read most of the related questions in stackoverflow but still unable to get it work.
Been working on this for few days but still unable to get it to match with the server encryption.</p>

<p>Here is what i have work out:</p>

<pre><code>NSString* plaintexthex = @""536176696E67204163636F756E747C313233343536000000"";
NSData *dTextIn = [self dataFromHexString:plaintexthex]; //my own way of convert hex to data

NSString* keyhex = @""6E7B336FD2051BA165A9362BD9735531"";
NSData *_keyData = [self dataFromHexString:keyhex]; //my own way of convert hex to data

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;

bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x00, bufferPtrSize);

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x00, (size_t) sizeof(iv));

unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

ccStatus = CCCrypt(kCCEncrypt,              // CCoperation op
                   kCCAlgorithm3DES,        // CCAlgorithm alg
                   kCCModeCBC,              // CCOptions
                   [_keyData bytes],        // const void *key
                   kCCKeySize3DES,          // 3DES key size length 24 bit
                   iv,                      // const void *iv,
                   [dTextIn bytes],         // const void *dataIn 
                   [dTextIn length],        // size_t dataInLength
                   bufferPtr,               // void *dataOut
                   bufferPtrSize,           // size_t dataOutAvailable
                   &amp;movedBytes);            // size_t *dataOutMoved

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:            (NSUInteger)movedBytes];
result = [self hexStringFromData:myData];

NSLog(@""Data to encrypt %@"",dTextIn);
NSLog(@""Encryption key %@"",_keyData);
NSLog(@""Bytes of key are %s "", bytePtr);
NSLog(@""Key length %d "",[_keyData length]);
NSLog(@""Encrypted bytes %@"", myData);
NSLog(@""Encrypted string %@"", result);
NSLog(@""Encrypted string length %d"", [result length]);

- (NSData *)dataFromHexString:(NSString *)string 
{   
    NSMutableData *stringData = [[[NSMutableData alloc] init] autorelease];
    unsigned char whole_byte;
    char byte_chars[3] = {'\0','\0','\0'};
    int i;
    for (i=0; i &lt; [string length] / 2; i++) {
        byte_chars[0] = [string characterAtIndex:i*2];
        byte_chars[1] = [string characterAtIndex:i*2+1];
        whole_byte = strtol(byte_chars, NULL, 16);
        [stringData appendBytes:&amp;whole_byte length:1]; 
    }
    return stringData;
}
</code></pre>

<p>I have develop a similar application on the Android platform and it works well with the server.
Heres the encryption of the function i used on the Android platform.</p>

<pre><code>public byte[] encrypt(byte[] key, byte[] message) throws Exception {

       byte [] plainTextBytes = message;
       byte[] encryptKey = key;

       SecretKey theKey = new SecretKeySpec(encryptKey, ""DESede"");
       Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
       IvParameterSpec IvParameters = new IvParameterSpec(new byte[] {(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00});
       cipher.init(Cipher.ENCRYPT_MODE, theKey, IvParameters);
       byte[] encrypted = cipher.doFinal(plainTextBytes);
       return encrypted;
  }
</code></pre>

<p>Basically i want to replicate this similar encryption to be used on the iOS platform.
Any help will be welcome and thank you in advance.</p>
","<p><code>kCCModeCBC</code> is a mode, not an option. The option you want is <code>0</code>. CBC is the default mode for <code>CCCrypt()</code>. The default is also no padding.</p>
","2326","<iphone><ios><encryption><3des>","2","1","2","2013-04-26 19:53:19","","3","2","1594391","","2012-08-16 04:09:01","2012-08-13 04:25:10",""
"11928196","3des encryption in iphone","<p>i am fairly new to iOS development and objective c.
I am developing an application which will send encrypted data to a server.
The server uses 3des with cbc and no padding.
I have read most of the related questions in stackoverflow but still unable to get it work.
Been working on this for few days but still unable to get it to match with the server encryption.</p>

<p>Here is what i have work out:</p>

<pre><code>NSString* plaintexthex = @""536176696E67204163636F756E747C313233343536000000"";
NSData *dTextIn = [self dataFromHexString:plaintexthex]; //my own way of convert hex to data

NSString* keyhex = @""6E7B336FD2051BA165A9362BD9735531"";
NSData *_keyData = [self dataFromHexString:keyhex]; //my own way of convert hex to data

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;

bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x00, bufferPtrSize);

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x00, (size_t) sizeof(iv));

unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

ccStatus = CCCrypt(kCCEncrypt,              // CCoperation op
                   kCCAlgorithm3DES,        // CCAlgorithm alg
                   kCCModeCBC,              // CCOptions
                   [_keyData bytes],        // const void *key
                   kCCKeySize3DES,          // 3DES key size length 24 bit
                   iv,                      // const void *iv,
                   [dTextIn bytes],         // const void *dataIn 
                   [dTextIn length],        // size_t dataInLength
                   bufferPtr,               // void *dataOut
                   bufferPtrSize,           // size_t dataOutAvailable
                   &amp;movedBytes);            // size_t *dataOutMoved

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:            (NSUInteger)movedBytes];
result = [self hexStringFromData:myData];

NSLog(@""Data to encrypt %@"",dTextIn);
NSLog(@""Encryption key %@"",_keyData);
NSLog(@""Bytes of key are %s "", bytePtr);
NSLog(@""Key length %d "",[_keyData length]);
NSLog(@""Encrypted bytes %@"", myData);
NSLog(@""Encrypted string %@"", result);
NSLog(@""Encrypted string length %d"", [result length]);

- (NSData *)dataFromHexString:(NSString *)string 
{   
    NSMutableData *stringData = [[[NSMutableData alloc] init] autorelease];
    unsigned char whole_byte;
    char byte_chars[3] = {'\0','\0','\0'};
    int i;
    for (i=0; i &lt; [string length] / 2; i++) {
        byte_chars[0] = [string characterAtIndex:i*2];
        byte_chars[1] = [string characterAtIndex:i*2+1];
        whole_byte = strtol(byte_chars, NULL, 16);
        [stringData appendBytes:&amp;whole_byte length:1]; 
    }
    return stringData;
}
</code></pre>

<p>I have develop a similar application on the Android platform and it works well with the server.
Heres the encryption of the function i used on the Android platform.</p>

<pre><code>public byte[] encrypt(byte[] key, byte[] message) throws Exception {

       byte [] plainTextBytes = message;
       byte[] encryptKey = key;

       SecretKey theKey = new SecretKeySpec(encryptKey, ""DESede"");
       Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
       IvParameterSpec IvParameters = new IvParameterSpec(new byte[] {(byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00});
       cipher.init(Cipher.ENCRYPT_MODE, theKey, IvParameters);
       byte[] encrypted = cipher.doFinal(plainTextBytes);
       return encrypted;
  }
</code></pre>

<p>Basically i want to replicate this similar encryption to be used on the iOS platform.
Any help will be welcome and thank you in advance.</p>
","<p>I am an iOS user, not a developer, but as far as I know, iOS no longer supports 3DES. I use an iPad for VPN, and iOS 3 worked fine with 3DES encryption, but as of iOS 4, the minimum encryption level required is AES128.</p>

<p>Hope that helps.</p>
","2326","<iphone><ios><encryption><3des>","2","0","2","2013-04-26 19:53:19","","3","2","1594391","","2012-08-16 04:09:01","2012-08-13 04:25:10",""
"17690611","Using triple des(3des) of decrypt in java,get error of""javax.crypto.IllegalBlockSizeException: last block incomplete in decryption""","<p>I use the code like <a href=""https://stackoverflow.com/questions/20227/how-do-i-use-3des-encryption-decryption-in-java"">3des-encryption-decryption-in-java</a>,but when I use decrypt it,it got a error like this </p>

<pre><code>javax.crypto.IllegalBlockSizeException: last block incomplete in decryption
07-17 11:27:27.580: WARN/System.err(22432): at com.android.org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(BaseBlockCipher.java:705)
07-17 11:27:27.580: WARN/System.err(22432): at javax.crypto.Cipher.doFinal(Cipher.java:1111)
</code></pre>

<p>But if I change <code>final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");</code> to <code>final Cipher decipher = Cipher.getInstance(""DESede/CFB/NoPadding"");</code>,the method can run but got a wrong result (the mode is different from server).
So I want to know the reason about it.  </p>

<p>The decrypt method:</p>

<pre><code>public static String decrypt(byte[] message) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    final byte[] digestOfPassword = md.digest(token.getBytes(""utf-8""));
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    // final Cipher decipher = Cipher.getInstance(""DESede/CFB/NoPadding"");
    decipher.init(Cipher.DECRYPT_MODE, key, iv);
    final byte[] plainText = decipher.doFinal(message);
    return new String(plainText, ""UTF-8"");
}
</code></pre>

<p>The encrypt method:</p>

<pre><code>public static byte[] encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        final byte[] digestOfPassword = md.digest(token
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8; ) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv, new SecureRandom(new byte[5]));
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        return cipherText;
    }
</code></pre>
","<p>There are many possibilities<br>The most common is if you atr encoding the key as a String, especially without specifying the character encoding. If you want to do this, use Base-64, which is designed to encode any <code>binary</code> data, rather than a character encoding<br>Also make sure that source platform and target platform encoding should be same.As you are using <code>UTF-8</code> here and then on the other en , <code>UTF-8</code> must be used<br><br>Now have a look under the facts which you are telling that code is running with <code>final Cipher decipher = Cipher.getInstance(""DESede/CFB/NoPadding"");</code> but not with <code>final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");</code><br>
While Decryption, you must know the <strong>padding size</strong> and <strong>mode</strong> in which you have selected at encryption time.As you are saying that when you use <code>CBC</code> mode than it throws exception but when you changed it to <code>CFB</code> then it got able to run.In this case you need to make sure which mode you are using at encrytpion time.<br><br>
<strong>As a side note:</strong> CBC, OFB and CFB are identical, however OFB/CFB is better because you only need encryption and not decryption, which can save code space.<br>
<strong>CBC(Cipher Block Chaining)</strong> is used where the data goes through the AES function, and feedback is applied to modify the pre-encrypted data, so that repeated plain data does not yield the same encrypted data. Data can only be processed in blocks which match the block-size of the underlying encryption function (so 128-bit blocks on the case of AES), and synchronisation at this block level must be provided between the encrypting and decrypting engines, otherwise data will be indecipherable<br>
<strong>CFB(Cipher FeedBack mode)</strong> is also a common mode, and offers the possibility of making an underlying block cipher work like a stream cipher; ie. so that the data being processed can be a stream of shorter values (for example bytes or even individual bits) rather than being processed only as much larger blocks.In CFB mode, the data itself does not go through the AES engine, but gets XORed with a value which the AES engine generates from previous message history. This means that the latency through the CFB function can be minimised, as the only processing applied to the data is an XOR function. Data widths can be set to any size up to the underlying cipher block size, but note that throughput decreases as the widths get smaller in the ratio of the data width to the block size.(Side note ended :D)<br>
If you encrypt using Cipher-Feedback (CFB) or Output-Feedback (OFB) or counter (CTR) modes then the ciphertext will be the same size as the plaintext and so padding is not required. Be careful, though, when using these modes, because the initialisation vectors (IV) must be unique.<br>
Similarly, encrypting using a stream cipher like RC4 or PC1 does not require padding. 
<br><br>Now if we investigate more critically than you should take care about the block size and padding size(already mentioned above).Now the first thing you need to make sure is that the padding size defined by your encryption algorithm.As I mentioned that in CFB case padding is not required so first try it without giving padding.<br>if issue still resides then check either it is <code>pkcs5</code> or <code>pkcs7</code>.Try your code by setting decrytpion padding size to <code>pkcs7</code>.If it is <code>pkcs7</code> then I guess it should work with CBC too.I recommend you to read <a href=""http://www.di-mgt.com.au/cryptopad.html"" rel=""nofollow"">Using Padding in Encryption</a><br><br> <strong>As a additional information</strong> <br></p>

<ul>
<li><p>PKCS#5 padding is defined in RFC 2898 (PKCS #5: Password-Based Cryptography Specification Version 2.0).</p></li>
<li><p>PKCS5 padding  is a padding scheme for extending arbitrary data to match the block-size of a block cipher in a way that allows the receiving end to reliably remove the padding.</p></li>
<li><p>PKCS#7 (CMS, RFC 3369) defines a padding scheme, but it is an extension of PKCS#5 padding for block ciphers that have more than 8 bytes for block.</p></li>
</ul>
","2220","<java><android><encryption><3des>","1","1","1","2013-07-17 11:24:28","17690898","0","3","-1","","2017-05-23 12:05:29","2013-07-17 03:31:23",""
"9212749","3DES encryption implementation reporting different output from C# implementation","<p>I have been trying rather unsuccessfully to encrypt a plaintext using 3DES in java by using the BouncyCastle suite. This result is supposed to match that produced by an existing C# implementation because I plan to be decrypting it later.</p>

<p>I keep getting different results though I am convinced I have produced the ""equivalent"" of the C# algo in Java. Could someone kindly look through both snippets and advise? I would be most grateful.</p>

<p>C# encryption:</p>

<pre><code>public static byte[] encryptStringToBytes_3DES(string plainText, string passKey)
    {
        // Check arguments.
        if (plainText == null || plainText.Length &lt;= 0)
            throw new ArgumentNullException(""plainText"");

        // Declare the streams used
        // to encrypt to an in memory
        // array of bytes.
        MemoryStream msEncrypt = null;
        CryptoStream csEncrypt = null;
        StreamWriter swEncrypt = null;
        ASCIIEncoding ascii = new System.Text.ASCIIEncoding();


        // used to encrypt the data.
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        string passphrase = passKey;
        byte[] iv = ascii.GetBytes(""AVREWASH"");
        byte[] key = ascii.GetBytes(passphrase);

        try
        {
            // Create a TripleDES object
            // with the specified key and IV.
            //Console.WriteLine(""Key size is "" + tdes.KeySize+"" and IV is ""+tdes.IV+"" and that of key is ""+key.Length);
            tdes.Key = key;
            tdes.IV = iv;
            tdes.Padding = PaddingMode.Zeros;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = tdes.CreateEncryptor(tdes.Key, tdes.IV);

            // Create the streams used for encryption.
            msEncrypt = new MemoryStream();
            csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            swEncrypt = new StreamWriter(csEncrypt);

            //Write all data to the stream.
            swEncrypt.Write(plainText);

        }
        catch (Exception ex)
        {
            Console.WriteLine(""Error is "" + ex.Message);
            while (true)
            {
            }
        }

        finally
        {
            // Clean things up.

            // Close the streams.
            if (swEncrypt != null)
                swEncrypt.Close();
            if (csEncrypt != null)
                csEncrypt.Close();
            if (msEncrypt != null)
                msEncrypt.Close();

            // Clear the TripleDES object.
            if (tdes != null)
                tdes.Clear();
        }

        // Return the encrypted bytes from the memory stream.
        return msEncrypt.ToArray();

}
</code></pre>

<p>There is this helper function I use in converting results to Hex...</p>

<pre><code>public static string ByteArrayToString(byte[] ba)
    {
        string hex = BitConverter.ToString(ba);
        return hex.Replace(""-"", """");
    }
</code></pre>

<p>The Java snippet supposed to be doing the ""equivalent"" encryption follows too:</p>

<pre><code>public void encrypt(String plaintext, String IV, String tripleDesKey){

try{

     SecretKey keySpec = new SecretKeySpec(tripleDesKey.getBytes(""US-ASCII""),""DESede"");

    IvParameterSpec iv = new IvParameterSpec(IV.getBytes(""US-ASCII""));

    Cipher e_cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    e_cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);

    byte [] cipherText = e_cipher.doFinal(plaintext.trim().getBytes(""US-ASCII""));

        System.out.println(""Ciphertext: "" + asHex(cipherText));
}
catch(Exception exc){
 ex.printStackTrace();
}
}
</code></pre>

<p>here is its corresponding Hex.. function</p>

<pre><code>public static String asHex (byte buf[]) {
  StringBuffer strbuf = new StringBuffer(buf.length * 2);
  int i;

  for (i = 0; i &lt; buf.length; i++) {
   if (((int) buf[i] &amp; 0xff) &lt; 0x10)
        strbuf.append(""0"");

   strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
  }

  return strbuf.toString();
 }
</code></pre>

<p>PLEASE HELP.</p>
","<p>You are using different padding modes. In C# you wrote <code>tdes.Padding = PaddingMode.Zeros;</code>
and in Java you used PKCS5Padding in CBC mode. This is not the same things. </p>
","2211","<c#><java><encryption><bouncycastle><3des>","1","3","2","2012-02-09 16:38:37","","1","2","","","","2012-02-09 14:34:07",""
"9212749","3DES encryption implementation reporting different output from C# implementation","<p>I have been trying rather unsuccessfully to encrypt a plaintext using 3DES in java by using the BouncyCastle suite. This result is supposed to match that produced by an existing C# implementation because I plan to be decrypting it later.</p>

<p>I keep getting different results though I am convinced I have produced the ""equivalent"" of the C# algo in Java. Could someone kindly look through both snippets and advise? I would be most grateful.</p>

<p>C# encryption:</p>

<pre><code>public static byte[] encryptStringToBytes_3DES(string plainText, string passKey)
    {
        // Check arguments.
        if (plainText == null || plainText.Length &lt;= 0)
            throw new ArgumentNullException(""plainText"");

        // Declare the streams used
        // to encrypt to an in memory
        // array of bytes.
        MemoryStream msEncrypt = null;
        CryptoStream csEncrypt = null;
        StreamWriter swEncrypt = null;
        ASCIIEncoding ascii = new System.Text.ASCIIEncoding();


        // used to encrypt the data.
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        string passphrase = passKey;
        byte[] iv = ascii.GetBytes(""AVREWASH"");
        byte[] key = ascii.GetBytes(passphrase);

        try
        {
            // Create a TripleDES object
            // with the specified key and IV.
            //Console.WriteLine(""Key size is "" + tdes.KeySize+"" and IV is ""+tdes.IV+"" and that of key is ""+key.Length);
            tdes.Key = key;
            tdes.IV = iv;
            tdes.Padding = PaddingMode.Zeros;

            // Create a decrytor to perform the stream transform.
            ICryptoTransform encryptor = tdes.CreateEncryptor(tdes.Key, tdes.IV);

            // Create the streams used for encryption.
            msEncrypt = new MemoryStream();
            csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
            swEncrypt = new StreamWriter(csEncrypt);

            //Write all data to the stream.
            swEncrypt.Write(plainText);

        }
        catch (Exception ex)
        {
            Console.WriteLine(""Error is "" + ex.Message);
            while (true)
            {
            }
        }

        finally
        {
            // Clean things up.

            // Close the streams.
            if (swEncrypt != null)
                swEncrypt.Close();
            if (csEncrypt != null)
                csEncrypt.Close();
            if (msEncrypt != null)
                msEncrypt.Close();

            // Clear the TripleDES object.
            if (tdes != null)
                tdes.Clear();
        }

        // Return the encrypted bytes from the memory stream.
        return msEncrypt.ToArray();

}
</code></pre>

<p>There is this helper function I use in converting results to Hex...</p>

<pre><code>public static string ByteArrayToString(byte[] ba)
    {
        string hex = BitConverter.ToString(ba);
        return hex.Replace(""-"", """");
    }
</code></pre>

<p>The Java snippet supposed to be doing the ""equivalent"" encryption follows too:</p>

<pre><code>public void encrypt(String plaintext, String IV, String tripleDesKey){

try{

     SecretKey keySpec = new SecretKeySpec(tripleDesKey.getBytes(""US-ASCII""),""DESede"");

    IvParameterSpec iv = new IvParameterSpec(IV.getBytes(""US-ASCII""));

    Cipher e_cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    e_cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);

    byte [] cipherText = e_cipher.doFinal(plaintext.trim().getBytes(""US-ASCII""));

        System.out.println(""Ciphertext: "" + asHex(cipherText));
}
catch(Exception exc){
 ex.printStackTrace();
}
}
</code></pre>

<p>here is its corresponding Hex.. function</p>

<pre><code>public static String asHex (byte buf[]) {
  StringBuffer strbuf = new StringBuffer(buf.length * 2);
  int i;

  for (i = 0; i &lt; buf.length; i++) {
   if (((int) buf[i] &amp; 0xff) &lt; 0x10)
        strbuf.append(""0"");

   strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
  }

  return strbuf.toString();
 }
</code></pre>

<p>PLEASE HELP.</p>
","<p>Some comments:</p>

<ol>
<li><p>The default mode of the .NET TripleDESCryptoServiceProvider is indeed CBC, which is what you specify explicitly in your JAVA code, but it wouldn't hurt if you specify it explicitly in your C# code as well.</p></li>
<li><p>In your original code you use PaddingMode.Zeros in the C# code, but PKCS5Padding in your JAVA code. There is AFAIK no built in cipher provider in Java that provides the equivalent of PaddingMode.Zeros. If you can still change your C# code, you should use PaddingMode.Pkcs7 instead. Otherwise you have to search for a 3rd party cipher provider for Java that will do the job.</p></li>
<li><p>Avoid using the ASCII encoding, unless you are able to guarantee that the input actually contains 7-bit ascii. If you pass in strings with other characters, the output is undefined.</p></li>
<li><p>The key data you pass to the 3DES constructor should be of length 8, 16 or 24 and - generally - have the DES parity bits set. AFAIK both .NET and Java will ignore the parity bits, but they might behave differently if the key length does not belong to either of the right values. Hence, if you want your encryption to work for any possible key input, you should use a key derivation function that is supported by both .NET and Java. Try PBEWithHmacSHA1AndDESede in Java, and in C# add code that transforms the passKey using System.Security.Cryptography.Rfc2898DeriveBytes.</p></li>
</ol>
","2211","<c#><java><encryption><bouncycastle><3des>","1","3","2","2012-02-09 16:38:37","","1","2","","","","2012-02-09 14:34:07",""
"10993335","Cipher / 3DES / CFB / Java and PHP","<p>I have a PHP servor which decrypt data in 3DES with the CFB Mode</p>

<p>I encrypt in PHP : </p>

<pre><code>$montant = ""500"";
$message_crypte = mcrypt_encrypt(MCRYPT_3DES, ""N4y1FRDRJ7wn7eJNnWaahCIS"", $montant, ,CRYPT_MODE_CFB, ""NCNPJDcR"");
$montant = base64_encode($message_crypte);
</code></pre>

<p>This script in PHP is OK with other system.</p>

<p>And I want to encrypt in Java : </p>

<pre><code>public class CryptData {
    private KeySpec keySpec;
    private SecretKey key;
    private IvParameterSpec iv;

    public CryptData(String keyString, String ivString) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");

            final byte[] digestOfPassword = md.digest(Base64
                    .decodeBase64(keyString.getBytes(""ISO-8859-1"")));

            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0, k = 16; j &lt; 8;) {
                keyBytes[k++] = keyBytes[j++];
            }

            //keySpec = new DESedeKeySpec(keyBytes);
            keySpec = new DESedeKeySpec(keyString.getBytes());

            key = SecretKeyFactory.getInstance(""DESede"")
                    .generateSecret(keySpec);

            iv = new IvParameterSpec(ivString.getBytes());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public String encrypt(String value) {
        try {
            Cipher ecipher = Cipher.getInstance(""DESede/CFB/NoPadding"");

                    //""SunJCE"");
            ecipher.init(Cipher.ENCRYPT_MODE, key, iv);

            if (value == null)
                return null;

            // Encode the string into bytes using utf-8
            byte[] valeur = value.getBytes(""ISO-8859-1"");
            //byte[] utf8 = value.getBytes();

            // Encrypt
            byte[] enc = ecipher.doFinal(valeur);

            // Encode bytes to base64 to get a string
            return new String(Base64.encodeBase64(enc), ""ISO-8859-1"");
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<p>I have not the same result in PHP and in Java</p>

<p>How modify Java treatment to obtain the same result as PHP?</p>
","<p>The answer is:</p>

<pre><code>Cipher ecipher = Cipher.getInstance(""DESede/CFB8/NoPadding"");
</code></pre>

<p>I need to use ""CFB8""</p>
","2209","<java><encryption><3des>","6","2","1","2019-04-11 14:37:55","","8","2","6296561","","2019-04-11 14:37:55","2012-06-12 08:55:19",""
"1284412","Why does changing one bit in a Triple DES key or initial value not give different encrypted data?","<p>I'm using pyDes to encrypt some data.  I wanted to demonstrate that if you change even one bit in the key or initial value, the encrypted data would be totally different.  I set up the 16-byte key to change the last character by +/- 1, causing at least one bit to be different.  However, even when I do that, the 3 different instances of encrypted data are not all different.</p>

<pre><code>from pyDes import *

data = 'Hello'

# CBC : Cipher-Block-Chaining
# \0..\1: arbitrary initial value for CBC
# pad=None: let pyDes take care of padding bytes
k1 = triple_des(""16-byte-key-here"", CBC, ""\0\0\0\0\0\0\0\1"", pad=None, padmode=PAD_PKCS5)
k2 = triple_des(""16-byte-key-herf"", CBC, ""\0\0\0\0\0\0\0\1"", pad=None, padmode=PAD_PKCS5)
k3 = triple_des(""16-byte-key-herd"", CBC, ""\0\0\0\0\0\0\0\1"", pad=None, padmode=PAD_PKCS5)

d1 = k1.encrypt(data)
d2 = k2.encrypt(data)
d3 = k3.encrypt(data)

assert d1 != d2
assert d2 != d3
assert d1 != d3
</code></pre>

<p>One of the assertions seems to fail if I only make a small change to either the key or initial value; I have seen both <code>d1 != d2</code> and <code>d1 != d3</code> fail depending on what I change.  I have also tried changing <code>'Hello'</code> to <code>'Hello' * 50</code> to make sure it wasn't just a case of the input data being too short.</p>

<p>If I make totally random keys, the assertions pass.  With the program as seen above, <code>d1 != d3</code> fails (those keys are one bit apart; k1-k2 are 2 bits different).</p>

<p>I am by no means an encryption expert, but if two keys only one bit apart result in the same encrypted data, then that means the effort it takes to brute-force the key just went down by a factor of two, right?</p>

<p>Am I missing something obvious?  Is Triple DES not supposed to give unique results for very similar keys?  Or is this a bug in PyDes?  Maybe someone else could confirm this behavior in another implementation?</p>

<p><hr/>
@Chris Jester-Young had the answer that some of the bits in the key are parity bits.  And as it turns out, according to <a href=""http://www.tropsoft.com/strongenc/des3.htm"" rel=""nofollow noreferrer"">this article</a>:</p>

<blockquote>
  <p>Note that although the input key for DES is 64 bits long, the actual key used by DES is only 56 bits in length. The least significant (right-most) bit in each byte is a parity bit, and should be set so that there are always an odd number of 1s in every byte. These parity bits are ignored, so only the seven most significant bits of each byte are used, resulting in a key length of 56 bits. <strong>This means that the effective key strength for Triple DES is actually 168 bits because each of the three keys contains 8 parity bits that are not used during the encryption process.</strong></p>
</blockquote>

<p>(emphasis was mine)</p>

<p>And those parity bits were exactly the bits I was changing in the example.</p>

<p>Thanks Chris!</p>
","<p>In DES, some bits of the key are parity bits, and don't actually affect the encryption/decryption.</p>
","2141","<encryption><3des><symmetric-key>","3","4","1","2009-08-16 14:48:33","1284425","0","","126042","","2009-08-16 14:48:33","2009-08-16 14:30:25",""
"10586551","Decrypting a string in ColdFusion encrypted with 3DES in .NET","<p>I'm having trouble decrypting a string that was encrypted in .NET. I saw a couple other solutions on here, mainly <a href=""https://stackoverflow.com/questions/9196207/decrypting-a-string-in-coldfusion-encrypted-with-3des-in-c-sharp"">Decrypting a string in ColdFusion encrypted with 3DES in C#</a> but I'm still having issues trying to decrypt the .NET encrypted string that is being passed to me. Here is the error:</p>

<p>""An error occurred while trying to encrypt or decrypt your input string: Given final block not properly padded.""</p>

<p>In further testing, when starting out with the same decrypted text, I am getting a different encrypted string in CF than I am in .NET</p>

<p>Here is the .NET code that is being used to encrypt/decrypt - I replaced the Key and IV data with fill-in info:</p>

<pre><code>Imports System.IO
Imports System.Text
Imports System.Security.Cryptography

Public Class TripleDES

    ' define the triple des provider
    Private Shared m_des As New TripleDESCryptoServiceProvider

    ' define the string handler
    Private m_utf8 As New UTF8Encoding

    ' define the local property arrays
    Private m_key() As Byte
    Private m_iv() As Byte
    Private key As String = ""48-digit hex key""
    Private iv As String = ""16-digit hex iv""

    Public Sub New()
        Me.m_key = convertHexStringToByteArray(key)
        Me.m_iv = convertHexStringToByteArray(iv)
    End Sub
    Public Sub New(ByVal _key As String, ByVal _iv As String)
        key = _key
        iv = _iv
        Me.m_key = convertHexStringToByteArray(key)
        Me.m_iv = convertHexStringToByteArray(iv)
    End Sub
    Public Sub New(ByVal _key() As Byte, ByVal _iv() As Byte)
        Me.m_key = _key
        Me.m_iv = _iv
    End Sub
    Public Function Encryptfrombyte(ByVal input() As Byte) As Byte()
        Return Transform(input, m_des.CreateEncryptor(m_key, m_iv))
    End Function

    Public Function EncryptBytes(ByVal text As String) As Byte()
        Dim input() As Byte = m_utf8.GetBytes(text)
        Dim DesEnc As ICryptoTransform = m_des.CreateEncryptor(m_key, m_iv)
        Dim output() As Byte = Transform(input, DesEnc)
        Return output 'convertByteArrayToHexString(output)
    End Function

    Public Function encrypt(ByVal key As Byte(), ByVal data As Byte()) As Byte()
        Dim des As TripleDESCryptoServiceProvider = New TripleDESCryptoServiceProvider
        des.Key = key
        des.Mode = CipherMode.ECB
        des.Padding = PaddingMode.PKCS7
        Return des.CreateEncryptor.TransformFinalBlock(data, 0, data.Length)
    End Function
    Public Function Decrypt(ByVal input() As Byte) As String
        Dim DesEnc As ICryptoTransform = m_des.CreateDecryptor(m_key, m_iv)
        Dim output() As Byte = Transform(input, DesEnc)

        Return m_utf8.GetString(output)
    End Function
    Public Function Decrypt(ByVal text As String) As String
        Dim input() As Byte = m_utf8.GetBytes(text)
        Dim output() As Byte = Transform(input, _
                         m_des.CreateDecryptor(m_key, m_iv))
        Return m_utf8.GetString(output)
    End Function

    Private Function Transform(ByVal input() As Byte, _
        ByVal CryptoTransform As ICryptoTransform) As Byte()
        ' create the necessary streams
        Dim memStream As MemoryStream = New MemoryStream
        Dim cryptStream As CryptoStream = New _
            CryptoStream(memStream, CryptoTransform, _
            CryptoStreamMode.Write)
        ' transform the bytes as requested
        cryptStream.Write(input, 0, input.Length)
        cryptStream.FlushFinalBlock()
        ' Read the memory stream and convert it back into byte array
        memStream.Position = 0
        Dim result(CType(memStream.Length - 1, System.Int32)) As Byte
        memStream.Read(result, 0, CType(result.Length, System.Int32))
        ' close and release the streams
        memStream.Close()
        cryptStream.Close()
        ' hand back the encrypted buffer
        Return result
    End Function
    Public Function convertHexStringToByteArray(ByVal str As String) As Byte()

        '//String in Hex - 2 chars represet a byte.
        Dim size As Integer = (str.Length() / 2) - 1
        Dim b(size) As Byte
        'ReDim b  str.Length() / 2
        Dim j As Integer = 0

        Try
            For i As Integer = 0 To str.Length() - 1 Step 2
                Dim s As String = str.Substring(i, 2)
                '//parse the substring as an integer, as the 8th bit may be set
                Dim k As Integer = Convert.ToInt32(s, 16)
                '//downcast integer to byte, this down casting does not do any
                ' //harm since memory footprint of first 8 bits remains same.
                b(j) = New Byte
                b(j) = CType(k, Byte)
                j += 1
            Next
        Catch e As Exception
            Dim ti As String = 1
            'TraceLog.trace2(e)
        End Try
        Return b
    End Function
    Public Function convertByteArrayToHexString(ByVal b() As Byte) As String
        Dim buffer As String
        ' Dim hexDigit() As String = Split(""0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f"", ""', '"")

        For i As Integer = 0 To b.Length - 1
            'dim  array as char()= (hexDigit((b(i) &gt;&gt; 4) &amp; chr(0x0f)), hexDigit(b(i) &amp; 0x0f))
            Dim tmp As String = Hex(b(i))
            If tmp.Length = 1 Then
                tmp = ""0"" &amp; tmp
            End If
            buffer += (tmp)
        Next

        Return buffer.ToString()
    End Function
    Public Function bytetoHex(ByVal hextBt() As Byte) As String
        Dim disc As Integer = 0
        bytetoHex = HexEncoding.ToString(hextBt)

    End Function

    Public Function hexToByte(ByVal hex As String) As Byte()
        Dim disc As Integer = 0
        hexToByte = HexEncoding.hexidecimaltoByte(hex)
    End Function

End Class
</code></pre>

<p>Here is the CF code that encrypts/decrypts:</p>

<pre><code>&lt;!--- Get The Key from Hex to base64 ---&gt;
&lt;cfset theKeyHex    = ""48-digit hex key"" /&gt;
&lt;cfset theKeyBin    = BinaryDecode(theKeyHex,""hex"")&gt;
&lt;cfset theKeyB64    = BinaryEncode(theKeyBin,""base64"")&gt;

&lt;!--- Get the IV to Binary ---&gt;
&lt;cfset theIV        = ""16-digit hex iv"" /&gt;
&lt;cfset theIVBin     = BinaryDecode(theIV,""hex"")&gt;

&lt;!--- Define Encoding parameters ---&gt;
&lt;cfset theAlgorithm = ""DESede/ECB/PKCS5Padding""&gt;
&lt;cfset theEncoding  = ""Base64""&gt;

&lt;!--- Define string ---&gt;
&lt;cfset str = ""108644"" &gt;

&lt;cfoutput&gt;
    &lt;cfset enc = Encrypt(str, theKeyB64, theAlgorithm, theEncoding, theIVBin)&gt;
    encrypted = #enc#&lt;br /&gt;

    &lt;cfset dec = Decrypt(enc, theKeyB64, theAlgorithm, theEncoding, theIVBin)&gt;
    decrypted = #dec#&lt;br /&gt;
&lt;/cfoutput&gt;
</code></pre>

<p>Just to be clear - while trying to test this code, I was running into errors decrypting the .NET encrypted string, so I tried encrypting the value in CF to see if I get the same encrypted string. </p>

<p>In CF, 108644 gets encrypted to 63Yp6O+8K+U=</p>

<p>In .NET, 108644 gets encrypted to 7loa00RCdZo=</p>

<p>I'm at an impasse. I have no idea where to go from here. Any help is greatly appreciated!</p>
","<p><code>ECB</code> mode does not use an initialization vector, so it is ignored. You need to change your mode to <code>CBC</code>:</p>

<pre><code>&lt;cfset theAlgorithm = ""DESede/CBC/PKCS5Padding""&gt;
</code></pre>

<p><strong>Edit:</strong> To elaborate, the mode varies depending on which function the .NET code uses. The <code>encrypt(key, data)</code> function uses <code>ECB</code> mode. While <code>EncryptBytes(text)</code> implicitly uses <code>CBC</code> mode, due to the presence of an <code>iv</code>. So you need to alter your CF code accordingly.</p>
","2070","<.net><encryption><coldfusion><3des>","2","2","1","2012-10-20 05:25:33","10587899","0","","-1","","2017-05-23 12:04:51","2012-05-14 15:39:08",""
"13841472","Mifare Ultralight C 3DES key change","<p>I'm trying to change the 3DES key on an Ultralight C card. I can write the the values in to the address 44-47 as I've found in some topics here. But I cannot authenticate when using it. If I write back the default key it works with no problems.</p>

<p>I think there's something I don't understand that's maybe the source of the problem, looking at the freefare library examples and in some posts from this and libnfc forum I've found the default key in ultralight C is:  <code>425245414b4d454946594f5543414e21</code> <em>(hex values for ASCII ""BREAKMEIFYOUCAN!"")</em>, but for decryption it on client the key used <code>49454D4B41455242214E4143554F5946</code>.</p>

<p>I don't know what's the relation between both keys, but I think some predified operation needs to be done in order to generate one from the other, and that's the cause of my failures. Did somebody had luck doing that? Every help is appreciated</p>

<p>For all my code I used <a href=""http://code.google.com/p/nfc-tools/source/browse/trunk/libfreefare/examples/mifare-ultralight-info.c"" rel=""nofollow"">this code as an starting point</a>.</p>
","<p>Did you manage to solve your problem? Would you mind sharing your code with the community?</p>

<p>If you didn't, here are the premises:</p>

<p>If the hex key is: ""00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F"" then you have to write the sequence ""07 06 05 04 03 02 01 00 0F 0E 0D 0C 0B 0A 09 08"" in 4 pages, from page 0x2C (44) to page 0x2F (47).</p>

<p>if you want to change where (which pages) the authentication is required, here is how to do that:</p>

<ul>
<li>0x2A defines the page address from which the authentication is
required. E.g. if 0x2A = 0x30 no authentication is needed all as
memory goes up to 0x2F.</li>
<li>0x2B defines if authentication is required for read/write (0x2B=0) or
only for write access (0x2B=1)</li>
</ul>
","2039","<key><nfc><3des><mifare>","2","0","1","2018-05-30 15:14:24","","1","1","1806944","","2015-12-14 13:05:52","2012-12-12 14:01:47",""
"4880392","How do I use 3DES decryption in C# in OFB mode?","<p>I need to decrypt a message that was encrypted using 3DES in OFB mode.</p>

<p>I have an encrypted message. I have a key. I have an IV.</p>

<p>I'm on a .Net platform</p>

<p>The encrypted message is 24 chars long in base64.
The key is 24 chars long in base64.
and the IV is a 64-bit binary number.</p>

<p>Because of the lack of examples I tried using an ECB mode example, as follows:</p>

<pre><code>   public static string DecryptTextFromMemory(byte[] Data, byte[] Key, byte[] IV)
    {
        try
        {
            // Create a new MemoryStream using the passed 
            // array of encrypted data.
            MemoryStream msDecrypt = new MemoryStream(Data);

            // Create a CryptoStream using the MemoryStream 
            // and the passed key and initialization vector (IV).
            CryptoStream csDecrypt = new CryptoStream(msDecrypt,
                new TripleDESCryptoServiceProvider().CreateDecryptor(Key, IV),
                CryptoStreamMode.Read);

            // Create buffer to hold the decrypted data.
            byte[] fromEncrypt = new byte[Data.Length];

            // Read the decrypted data out of the crypto stream
            // and place it into the temporary buffer.
            csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

            //Convert the buffer into a string and return it.
            return new ASCIIEncoding().GetString(fromEncrypt);
        }
        catch (CryptographicException e)
        {
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
            return null;
        }
    }
</code></pre>

<p>This is the error I get:</p>

<p>A Cryptographic error occurred: Specified key is not a valid size for this algorithm.</p>

<p>I've tried other code examples where I've changed the algorithm to OFB and it says it's not supported.</p>

<p>Can anyone please help me? I'm obviously out of my depth with this stuff so please be patient if I'm messing up somthing obvious.</p>

<p>There are loads of examples of 3DES decryption in ECB mode but little or nothing I can find about OFB mode.</p>
","<p>The third-party CryptoSys API says it specifically supports Triple-DES in OFB mode. Dunno why the .NET implementation wouldn't, though a good reason may be to discourage its use in new development in favor of the much-faster Rijndael and AES ciphers.</p>

<p>EDIT: Just to explain, a ""mode"" of the algorithm is a defined way that the basic Triple-DES ciphering algorithm is leveraged to produce encrypted text. These have become standardized over most symmetric-key algorithms. OFB mode is one of two standard ""stream cipher"" modes, which use the base algorithm to create a ""shift register"" based on text it has already encrypted, allowing text after the first ""block"" to be encrypted one byte at a time instead of in larger ""blocks"".</p>

<p>Anyway, the ""key size"" error points to a specific type of problem. Triple-DES algorithms (ALL of them; this isn't implementation-specific) require a key that is exactly either 128 or 192 bits long. You're getting the key as a byte array, so you need an array that is exactly 16 or 24 elements long. This should be one of your first checks; throw an ArgumentException if the key isn't the right size. Trace the problem down the call stack until you find where the key is generated and fix the problem at its source.</p>

<p>Next, if you set the Mode property of the <code>TripleDesCryptoServiceProvider</code> to OFB, and it gives you a <code>CryptoException</code> either right then or when you start decrypting that the mode isn't supported, then that's a .NET limitation; the .NET developer team didn't bother to implement that mode of that algorithm in the provider. It'll be more trouble than its worth to try to roll your own; you'll have to look for a third-party implementation that can be used by .NET code. Pretty much any library registered for COM interop will do the trick, doesn't have to be written in a .NET language. There are dozens; I'd do a search for CryptoSys as, like I said, the documentation says it supports TripleDES OFB by name.</p>
","1964","<c#><encryption><3des>","3","2","2","2013-05-09 12:36:15","","3","1","600706","","2011-02-02 22:23:04","2011-02-02 22:00:32",""
"4880392","How do I use 3DES decryption in C# in OFB mode?","<p>I need to decrypt a message that was encrypted using 3DES in OFB mode.</p>

<p>I have an encrypted message. I have a key. I have an IV.</p>

<p>I'm on a .Net platform</p>

<p>The encrypted message is 24 chars long in base64.
The key is 24 chars long in base64.
and the IV is a 64-bit binary number.</p>

<p>Because of the lack of examples I tried using an ECB mode example, as follows:</p>

<pre><code>   public static string DecryptTextFromMemory(byte[] Data, byte[] Key, byte[] IV)
    {
        try
        {
            // Create a new MemoryStream using the passed 
            // array of encrypted data.
            MemoryStream msDecrypt = new MemoryStream(Data);

            // Create a CryptoStream using the MemoryStream 
            // and the passed key and initialization vector (IV).
            CryptoStream csDecrypt = new CryptoStream(msDecrypt,
                new TripleDESCryptoServiceProvider().CreateDecryptor(Key, IV),
                CryptoStreamMode.Read);

            // Create buffer to hold the decrypted data.
            byte[] fromEncrypt = new byte[Data.Length];

            // Read the decrypted data out of the crypto stream
            // and place it into the temporary buffer.
            csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

            //Convert the buffer into a string and return it.
            return new ASCIIEncoding().GetString(fromEncrypt);
        }
        catch (CryptographicException e)
        {
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
            return null;
        }
    }
</code></pre>

<p>This is the error I get:</p>

<p>A Cryptographic error occurred: Specified key is not a valid size for this algorithm.</p>

<p>I've tried other code examples where I've changed the algorithm to OFB and it says it's not supported.</p>

<p>Can anyone please help me? I'm obviously out of my depth with this stuff so please be patient if I'm messing up somthing obvious.</p>

<p>There are loads of examples of 3DES decryption in ECB mode but little or nothing I can find about OFB mode.</p>
","<p>The error message tells you precisely what the problem is: ""Specified key is not a valid size for this algorithm.""</p>

<p>You say that ""The key is 24 chars long in base64"". Base64 encodes 6 bits per char, so that's 144 bits in total. But a 3DES key should be 64 bits (==DES), 128 bits, or 196 bits. You have to either use a key of the appropriate length or work out what the library on the other end is doing to convert the key to an appropriate length.</p>
","1964","<c#><encryption><3des>","3","1","2","2013-05-09 12:36:15","","3","1","600706","","2011-02-02 22:23:04","2011-02-02 22:00:32",""
"22513069","Decrypt 3des cfb string in bash","<p>i want to decrypt a string using openssl but it keeps saying :
non-hex digit
invalid hex iv value</p>

<p>I am using this command:</p>

<pre><code>openssl enc -d -in crypt -out file.txt -K mypas -iv iv.txt -p -des-ede3-cfb
</code></pre>

<p>mypas = 1D5sqZr QEG5ZEY54shhGE9</p>

<p>iv.txt = 2cd3e7471d9da0ef</p>

<p>crypt = 25cc14697f9f2106adcf2e48</p>

<p>what am I doing wrong?</p>

<p>the string is encrypted 3DES in CFB mode.</p>

<p>Thanks in advance :)</p>
","<p>from <code>openssl enc --help</code>:</p>

<pre><code>-K/-iv         key/iv in hex is the next argument
</code></pre>

<p>You have to specify the iv and key in hex. Not as filenames. </p>

<p>I can't make sense of your data, but here's an example:</p>

<pre><code>$ od -t x1 file.bin
0000000 43 f7 fd 5b 39 fd 5c 70 66 d2 8f 67 2a 5d fd
0000017

$ openssl enc -d -in file.bin -out file.txt \
    -K 4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F \
    -iv 524f464c524f464c -p -des-ede3-cfb
salt=B8FCBCBF6448EAB7
key=4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F4C4F
iv =524F464C524F464C

$ cat file.txt
this is a test
</code></pre>
","1920","<bash><encryption><openssl><3des>","0","1","1","2014-03-19 18:54:16","","0","","","","","2014-03-19 17:02:34",""
"27353260","3des encrypting/decrypting of file java","<p>I have a problem to read the file (for example *.zip) and encrypt it with 3DES, using secretKey which one generated from name of encrypted file.
Then I need to decrypt this file, and write it on HDD.
I tried to resolve thhis problem, but stuck when was decrypting file.</p>

<p>Here is code of encryptor</p>

<pre><code>public class Encryptor {
    private static String inputFilePath = ""D:/1.txt"";
    public static void main(String[] args) {
        FileOutputStream fos = null;
        File file = new File(inputFilePath);
        String keyString = ""140405PX_0.$88"";
        String algorithm = ""DESede"";
        try {
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] fileByteArray = new byte[fileInputStream.available()];
            fileInputStream.read(fileByteArray);
            for (byte b : fileByteArray) {
            System.out.println(b);
            }
            SecretKey secretKey = getKey(keyString);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            ObjectOutputStream objectOutputStream = new ObjectOutputStream
                    (new CipherOutputStream
                            (new FileOutputStream
                                    (""D:/Secret.file""), cipher));
            objectOutputStream.writeObject(fileByteArray);
            objectOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SecretKey getKey(String message) throws Exception {
        String messageToUpperCase = message.toUpperCase();
        byte[] digestOfPassword = messageToUpperCase.getBytes();
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        return key;
    }
}
</code></pre>

<p>And here is code of decryptor</p>

<pre><code>public class Decryptor {
    public static void main(String[] args) {
        try {
            File inputFileNAme = new File(""d:/Secret.file"");
            FileInputStream fileInputStream = new FileInputStream(inputFileNAme);
            FileOutputStream fileOutputStream = new FileOutputStream(outputFilePath);
            SecretKey secretKey = getKey(keyString);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            ObjectInputStream objectInputStream = new ObjectInputStream
                    (new CipherInputStream(fileInputStream, cipher));
            System.out.println(objectInputStream.available());
            while (objectInputStream.available() != 0) {
                fileOutputStream.write((Integer) objectInputStream.readObject());
                System.out.println(objectInputStream.readObject());
            }
            fileOutputStream.flush();
            fileOutputStream.close();
            fileInputStream.close();
            objectInputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SecretKey getKey(String message) throws Exception {
        String messageToUpperCase = message.toUpperCase();
        byte[] digestOfPassword = messageToUpperCase.getBytes();
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        return key;
    }
}
</code></pre>

<p>When i try to decrypt my file, i dont get anything in output file.<br>
I tryed make debug, and saw, that <code>objectInputStream.available()</code> always contains 0.<br>
Please tell me, how can I resolve this problem, and why it happens.    </p>
","<ol>
<li><p>The usage</p>

<pre><code>byte[] fileByteArray = new byte[fileInputStream.available()];
</code></pre>

<p>is <a href=""https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html#available--"" rel=""nofollow"">specifically warned against in the Javadoc</a>: "" It is never correct to use the return value of this method to allocate a buffer intended to hold all data in this stream.""</p>

<p>Files should be processed a record or a buffer at a time.</p></li>
<li><p>The line:</p>

<pre><code>fileInputStream.read(fileByteArray);
</code></pre>

<p>isn't guaranteed to fill the buffer. You have to check the return value: for -1, meaning end of file, or > 0, meaning the number of bytes that were actually transferred. See the Javadoc.</p></li>
<li><p>Similarly</p>

<pre><code>while (objectInputStream.available() != 0) {
</code></pre>

<p>is not a valid test for end of stream. You should call <code>readObject()</code> until it throws <code>EOFException.</code></p></li>
</ol>
","1815","<java><encryption><3des>","1","2","2","2014-12-08 08:53:00","27354179","0","2","","","","2014-12-08 07:26:29",""
"27353260","3des encrypting/decrypting of file java","<p>I have a problem to read the file (for example *.zip) and encrypt it with 3DES, using secretKey which one generated from name of encrypted file.
Then I need to decrypt this file, and write it on HDD.
I tried to resolve thhis problem, but stuck when was decrypting file.</p>

<p>Here is code of encryptor</p>

<pre><code>public class Encryptor {
    private static String inputFilePath = ""D:/1.txt"";
    public static void main(String[] args) {
        FileOutputStream fos = null;
        File file = new File(inputFilePath);
        String keyString = ""140405PX_0.$88"";
        String algorithm = ""DESede"";
        try {
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] fileByteArray = new byte[fileInputStream.available()];
            fileInputStream.read(fileByteArray);
            for (byte b : fileByteArray) {
            System.out.println(b);
            }
            SecretKey secretKey = getKey(keyString);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            ObjectOutputStream objectOutputStream = new ObjectOutputStream
                    (new CipherOutputStream
                            (new FileOutputStream
                                    (""D:/Secret.file""), cipher));
            objectOutputStream.writeObject(fileByteArray);
            objectOutputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SecretKey getKey(String message) throws Exception {
        String messageToUpperCase = message.toUpperCase();
        byte[] digestOfPassword = messageToUpperCase.getBytes();
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        return key;
    }
}
</code></pre>

<p>And here is code of decryptor</p>

<pre><code>public class Decryptor {
    public static void main(String[] args) {
        try {
            File inputFileNAme = new File(""d:/Secret.file"");
            FileInputStream fileInputStream = new FileInputStream(inputFileNAme);
            FileOutputStream fileOutputStream = new FileOutputStream(outputFilePath);
            SecretKey secretKey = getKey(keyString);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            ObjectInputStream objectInputStream = new ObjectInputStream
                    (new CipherInputStream(fileInputStream, cipher));
            System.out.println(objectInputStream.available());
            while (objectInputStream.available() != 0) {
                fileOutputStream.write((Integer) objectInputStream.readObject());
                System.out.println(objectInputStream.readObject());
            }
            fileOutputStream.flush();
            fileOutputStream.close();
            fileInputStream.close();
            objectInputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static SecretKey getKey(String message) throws Exception {
        String messageToUpperCase = message.toUpperCase();
        byte[] digestOfPassword = messageToUpperCase.getBytes();
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        return key;
    }
}
</code></pre>

<p>When i try to decrypt my file, i dont get anything in output file.<br>
I tryed make debug, and saw, that <code>objectInputStream.available()</code> always contains 0.<br>
Please tell me, how can I resolve this problem, and why it happens.    </p>
","<p>As a quickfix, this works :</p>

<pre><code>    try {
        File inputFileNAme = new File(""d:/Secret.file"");
        FileInputStream fileInputStream = new FileInputStream(inputFileNAme);
        FileOutputStream fileOutputStream = new FileOutputStream(outputFilePath);
        SecretKey secretKey = getKey(keyString);
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        ObjectInputStream objectInputStream = new ObjectInputStream
                (new CipherInputStream(fileInputStream, cipher));
        System.out.println(objectInputStream.available());
        fileOutputStream.write((byte[]) objectInputStream.readObject());
        fileOutputStream.flush();
        fileOutputStream.close();
        fileInputStream.close();
        objectInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>

<p>What I did is remove the ""<code>.available()</code> while loop"" and remove the cast to <code>Integer</code> that was wrong.</p>

<p>I agree with EJP answer, especially regarding the use of <code>.available()</code>.</p>

<p>You may also use <a href=""http://www.jasypt.org/"" rel=""nofollow"">http://www.jasypt.org/</a> that provides a more simple API to crytpo stuff.</p>
","1815","<java><encryption><3des>","1","1","2","2014-12-08 08:53:00","27354179","0","2","","","","2014-12-08 07:26:29",""
"2697667","Creating a Cerificate for Bouncy Castle Encryption","<p>I am trying to create a self-signed certificate to use for encrypting an email using bouncycaste.</p>

<p>What would be the best way to generate a certificate?</p>

<p>I have tried using openssl but I have had problems with certificate.</p>

<p>Here is the code I am using to encrypt, I am using 3des.</p>

<pre><code>SMIMEEnvelopedGenerator gen = new SMIMEEnvelopedGenerator();
gen.addKeyTransRecipient(x509Cert); // adds an X509Certificate

MimeBodyPart encData = 
    gen.generate(mimeBodyPart, SMIMEEnvelopedGenerator.DES_EDE3_CBC, ""BC"");
</code></pre>

<p>EDIT:
Sorry for being vauge but the error message I am getting doesn't seem to be very useful.</p>

<p>The message is as follows:</p>

<pre><code>org.openas2.WrappedException: org.bouncycastle.mail.smime.SMIMEException:
 key invalid in message.
</code></pre>

<p>This is thrown when I call the SMIMEEnvelopedGenerator.generate method.</p>

<p>I am currently attaching the source code in Eclipse to see if I can get a more useful error message by stepping through the code.</p>
","<p>I would use keytool or openssl to generate a self-signed certificate. If you are having problems then post them, don't just say you are having problems. If you want to generate the certificate from your java code use the <a href=""http://www.bouncycastle.org/docs/docs1.6/org/bouncycastle/x509/X509V3CertificateGenerator.html"" rel=""nofollow noreferrer"">org.bouncycastle.x509.X509V3CertificateGenerator</a> class</p>
","1807","<java><encryption><certificate><bouncycastle><3des>","1","2","2","2010-04-23 14:15:27","2699039","2","","198040","","2010-04-23 12:02:11","2010-04-23 10:01:59",""
"2697667","Creating a Cerificate for Bouncy Castle Encryption","<p>I am trying to create a self-signed certificate to use for encrypting an email using bouncycaste.</p>

<p>What would be the best way to generate a certificate?</p>

<p>I have tried using openssl but I have had problems with certificate.</p>

<p>Here is the code I am using to encrypt, I am using 3des.</p>

<pre><code>SMIMEEnvelopedGenerator gen = new SMIMEEnvelopedGenerator();
gen.addKeyTransRecipient(x509Cert); // adds an X509Certificate

MimeBodyPart encData = 
    gen.generate(mimeBodyPart, SMIMEEnvelopedGenerator.DES_EDE3_CBC, ""BC"");
</code></pre>

<p>EDIT:
Sorry for being vauge but the error message I am getting doesn't seem to be very useful.</p>

<p>The message is as follows:</p>

<pre><code>org.openas2.WrappedException: org.bouncycastle.mail.smime.SMIMEException:
 key invalid in message.
</code></pre>

<p>This is thrown when I call the SMIMEEnvelopedGenerator.generate method.</p>

<p>I am currently attaching the source code in Eclipse to see if I can get a more useful error message by stepping through the code.</p>
","<p>You should be okay with openssl; this is the command I would use to generate a self-signed cert:</p>

<p>openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</p>

<p>This will create a file called mycert.pem which contains both the
private key and the self signed cert. Note in this example the
key is unencrypted which is okay for testing purposes. 
Both key and cert are PEM encoded and include the standard header 
and footer lines.</p>
","1807","<java><encryption><certificate><bouncycastle><3des>","1","1","2","2010-04-23 14:15:27","2699039","2","","198040","","2010-04-23 12:02:11","2010-04-23 10:01:59",""
"9350652","3DES encryption in iPhone app always produces different result from 3DES encryption in Java","<p>I have to encrypt a string in my iPhone app. The encryption scheme is 3DES/CBC/PKCS5 padding and I have to convert in objective-c this Java code:</p>

<pre><code>public class MessageEncrypt {

public String encryptString(String message, String seckey) throws Exception{
    byte[] encData = encrypt(message, seckey);

    return this.getHexString(encData, """");
}

public String decryptString(String message, String seckey) throws Exception{
    return decrypt(this.getBArray(message), seckey);
}

private byte[] encrypt(String message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);

    final byte[] plainTextBytes = message.getBytes(""utf-8"");
    final byte[] cipherText = cipher.doFinal(plainTextBytes);
    // final String encodedCipherText = new sun.misc.BASE64Encoder()
    // .encode(cipherText);

    return cipherText;
}

private String decrypt(byte[] message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    decipher.init(Cipher.DECRYPT_MODE, key, iv);

    final byte[] plainText = decipher.doFinal(message);

    return new String(plainText, ""UTF-8"");
}

private String getHexString(byte[] barray, String delim) {
    StringBuffer buffer = new StringBuffer();


    for (int i = 0; i &lt; barray.length; i++) {
        int ii = barray[i] &amp; 0xFF;
        String bInt = Integer.toHexString(ii);
        if (ii &lt; 16) {
            bInt = ""0"" + bInt.toUpperCase();
        }
        buffer.append(bInt);
        if (i &lt; barray.length - 1) {
            buffer.append(delim);
        }
    }

    return buffer.toString().toUpperCase();
}

private byte[] getBArray(String bString) {
    byte[] retBytes;

    if (bString.length() % 2 != 0) {
        return new byte[0];
    }
    retBytes = new byte[bString.length() / 2];

    for (int i = 0; i &lt; bString.length() / 2; i++) {
        retBytes[i] = (byte) ((Character.digit(bString.charAt(2 * i), 16) &lt;&lt; 4) + Character.digit(bString.charAt(2 * i + 1), 16));
    }
    return retBytes;
}

public static byte[] acopyof(byte[] orig, int newlength){
    byte[] copya = new byte[newlength];
    for(int i=0;i&lt; orig.length;i++){
        copya[i]=orig[i];
    }
    for(int i=orig.length;i&lt;newlength;i++){
        copya[i]=0x0;
    }
    return copya;
}
</code></pre>

<p>}</p>

<p>I made this objective-c method to match those specs:</p>

<pre><code>+(NSString*)doCipher:(NSString*)sTextIn:(CCOperation)encryptOrDecrypt {
</code></pre>

<p>// const void *vplainText;
   // size_t plainTextBufferSize;</p>

<pre><code>NSMutableData *dTextIn;

if (encryptOrDecrypt == kCCDecrypt)
{



}
else
{

    dTextIn = [[sTextIn dataUsingEncoding: NSASCIIStringEncoding]mutableCopy];

}

NSLog(@""************** Init encrypting **********************************"");

NSLog(@""This is data to encrypt %@"",dTextIn);

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
//  uint8_t ivkCCBlockSize3DES;

bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x00, bufferPtrSize);



// Initialization vector; in this case 8 bytes.

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x8, (size_t) sizeof(iv));



UserAndPassword *userPass = [[UserAndPassword alloc]init];

NSString *userPassword = userPass.password;

NSLog(@""This is my password %@"",userPassword);

NSString *key = [userPassword MD5String];

NSLog(@""This is MD5 key %@"",key);


NSMutableData *_keyData = [[key dataUsingEncoding:NSASCIIStringEncoding]mutableCopy];

unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

NSLog(@""Bytes of key are %s "", bytePtr);

NSLog(@""******** This is my key length %d *******"",[_keyData length]);

[_keyData setLength:24];

 unsigned char *bytePtr1 = (unsigned char *)[_keyData bytes];

 NSLog(@""******** Bytes of key are %s ************"", bytePtr1);

 NSLog(@""*********  This is key length %d ***********"",[_keyData length]);



ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                   kCCAlgorithm3DES, // CCAlgorithm alg
                   kCCOptionPKCS7Padding, // CCOptions
                   [_keyData bytes], // const void *key
                   kCCKeySize3DES, // 3DES key size length 24 bit
                   iv,  //const void *iv,
                   [dTextIn bytes], // const void *dataIn  
                   [dTextIn length], // size_t dataInLength
                   (void *)bufferPtr, // void *dataOut
                   bufferPtrSize, // size_t dataOutAvailable
                   &amp;movedBytes); // size_t *dataOutMoved

if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";


NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{

    // result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
    result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    NSLog(@""This is my encrypted bytes %@"", myData);

    result = [NSString dataToHex:myData];

    NSLog(@""This is my encrypted string %@"", result);

    NSLog(@""********************** Encryption is finished ************"");

}
return result;
</code></pre>

<p>}</p>

<p>I didn't manage to match the 3DES encryption obtained with Java code and I don't understand which is the problem.</p>

<p>Thank you in advance,
Pier</p>
","<p>I haven't looked through all your code, but the first thing that jumps out is that the character encoding schemes for your input strings are different. In your Java algorithm you are encoding all strings as <code>UTF-8</code>, but in your ObjC algorithm you encoded the strings as <code>ASCII</code>, which is a potential problem for anything but the simplest of input strings.</p>
","1789","<java><iphone><objective-c><encryption><3des>","1","1","3","2012-08-30 03:53:35","9351244","3","2","","","","2012-02-19 15:52:42",""
"9350652","3DES encryption in iPhone app always produces different result from 3DES encryption in Java","<p>I have to encrypt a string in my iPhone app. The encryption scheme is 3DES/CBC/PKCS5 padding and I have to convert in objective-c this Java code:</p>

<pre><code>public class MessageEncrypt {

public String encryptString(String message, String seckey) throws Exception{
    byte[] encData = encrypt(message, seckey);

    return this.getHexString(encData, """");
}

public String decryptString(String message, String seckey) throws Exception{
    return decrypt(this.getBArray(message), seckey);
}

private byte[] encrypt(String message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);

    final byte[] plainTextBytes = message.getBytes(""utf-8"");
    final byte[] cipherText = cipher.doFinal(plainTextBytes);
    // final String encodedCipherText = new sun.misc.BASE64Encoder()
    // .encode(cipherText);

    return cipherText;
}

private String decrypt(byte[] message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    decipher.init(Cipher.DECRYPT_MODE, key, iv);

    final byte[] plainText = decipher.doFinal(message);

    return new String(plainText, ""UTF-8"");
}

private String getHexString(byte[] barray, String delim) {
    StringBuffer buffer = new StringBuffer();


    for (int i = 0; i &lt; barray.length; i++) {
        int ii = barray[i] &amp; 0xFF;
        String bInt = Integer.toHexString(ii);
        if (ii &lt; 16) {
            bInt = ""0"" + bInt.toUpperCase();
        }
        buffer.append(bInt);
        if (i &lt; barray.length - 1) {
            buffer.append(delim);
        }
    }

    return buffer.toString().toUpperCase();
}

private byte[] getBArray(String bString) {
    byte[] retBytes;

    if (bString.length() % 2 != 0) {
        return new byte[0];
    }
    retBytes = new byte[bString.length() / 2];

    for (int i = 0; i &lt; bString.length() / 2; i++) {
        retBytes[i] = (byte) ((Character.digit(bString.charAt(2 * i), 16) &lt;&lt; 4) + Character.digit(bString.charAt(2 * i + 1), 16));
    }
    return retBytes;
}

public static byte[] acopyof(byte[] orig, int newlength){
    byte[] copya = new byte[newlength];
    for(int i=0;i&lt; orig.length;i++){
        copya[i]=orig[i];
    }
    for(int i=orig.length;i&lt;newlength;i++){
        copya[i]=0x0;
    }
    return copya;
}
</code></pre>

<p>}</p>

<p>I made this objective-c method to match those specs:</p>

<pre><code>+(NSString*)doCipher:(NSString*)sTextIn:(CCOperation)encryptOrDecrypt {
</code></pre>

<p>// const void *vplainText;
   // size_t plainTextBufferSize;</p>

<pre><code>NSMutableData *dTextIn;

if (encryptOrDecrypt == kCCDecrypt)
{



}
else
{

    dTextIn = [[sTextIn dataUsingEncoding: NSASCIIStringEncoding]mutableCopy];

}

NSLog(@""************** Init encrypting **********************************"");

NSLog(@""This is data to encrypt %@"",dTextIn);

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
//  uint8_t ivkCCBlockSize3DES;

bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x00, bufferPtrSize);



// Initialization vector; in this case 8 bytes.

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x8, (size_t) sizeof(iv));



UserAndPassword *userPass = [[UserAndPassword alloc]init];

NSString *userPassword = userPass.password;

NSLog(@""This is my password %@"",userPassword);

NSString *key = [userPassword MD5String];

NSLog(@""This is MD5 key %@"",key);


NSMutableData *_keyData = [[key dataUsingEncoding:NSASCIIStringEncoding]mutableCopy];

unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

NSLog(@""Bytes of key are %s "", bytePtr);

NSLog(@""******** This is my key length %d *******"",[_keyData length]);

[_keyData setLength:24];

 unsigned char *bytePtr1 = (unsigned char *)[_keyData bytes];

 NSLog(@""******** Bytes of key are %s ************"", bytePtr1);

 NSLog(@""*********  This is key length %d ***********"",[_keyData length]);



ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                   kCCAlgorithm3DES, // CCAlgorithm alg
                   kCCOptionPKCS7Padding, // CCOptions
                   [_keyData bytes], // const void *key
                   kCCKeySize3DES, // 3DES key size length 24 bit
                   iv,  //const void *iv,
                   [dTextIn bytes], // const void *dataIn  
                   [dTextIn length], // size_t dataInLength
                   (void *)bufferPtr, // void *dataOut
                   bufferPtrSize, // size_t dataOutAvailable
                   &amp;movedBytes); // size_t *dataOutMoved

if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";


NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{

    // result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
    result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    NSLog(@""This is my encrypted bytes %@"", myData);

    result = [NSString dataToHex:myData];

    NSLog(@""This is my encrypted string %@"", result);

    NSLog(@""********************** Encryption is finished ************"");

}
return result;
</code></pre>

<p>}</p>

<p>I didn't manage to match the 3DES encryption obtained with Java code and I don't understand which is the problem.</p>

<p>Thank you in advance,
Pier</p>
","<p>It looks like you have a character encoding problem. Your Objective-C code is based on ASCII (8 bit) characters but you need to switch (16 bit) UNICODE character decoding while parsing Java Strings into bytes. On the other hand, It may be a good idea to consider byte ordering in your arrays depending on the CPU architecture you are working on (Little or Big Endianness).</p>
","1789","<java><iphone><objective-c><encryption><3des>","1","1","3","2012-08-30 03:53:35","9351244","3","2","","","","2012-02-19 15:52:42",""
"9350652","3DES encryption in iPhone app always produces different result from 3DES encryption in Java","<p>I have to encrypt a string in my iPhone app. The encryption scheme is 3DES/CBC/PKCS5 padding and I have to convert in objective-c this Java code:</p>

<pre><code>public class MessageEncrypt {

public String encryptString(String message, String seckey) throws Exception{
    byte[] encData = encrypt(message, seckey);

    return this.getHexString(encData, """");
}

public String decryptString(String message, String seckey) throws Exception{
    return decrypt(this.getBArray(message), seckey);
}

private byte[] encrypt(String message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);

    final byte[] plainTextBytes = message.getBytes(""utf-8"");
    final byte[] cipherText = cipher.doFinal(plainTextBytes);
    // final String encodedCipherText = new sun.misc.BASE64Encoder()
    // .encode(cipherText);

    return cipherText;
}

private String decrypt(byte[] message, String seckey) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
    final byte[] keyBytes = acopyof(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
        keyBytes[k++] = keyBytes[j++];
    }

    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    decipher.init(Cipher.DECRYPT_MODE, key, iv);

    final byte[] plainText = decipher.doFinal(message);

    return new String(plainText, ""UTF-8"");
}

private String getHexString(byte[] barray, String delim) {
    StringBuffer buffer = new StringBuffer();


    for (int i = 0; i &lt; barray.length; i++) {
        int ii = barray[i] &amp; 0xFF;
        String bInt = Integer.toHexString(ii);
        if (ii &lt; 16) {
            bInt = ""0"" + bInt.toUpperCase();
        }
        buffer.append(bInt);
        if (i &lt; barray.length - 1) {
            buffer.append(delim);
        }
    }

    return buffer.toString().toUpperCase();
}

private byte[] getBArray(String bString) {
    byte[] retBytes;

    if (bString.length() % 2 != 0) {
        return new byte[0];
    }
    retBytes = new byte[bString.length() / 2];

    for (int i = 0; i &lt; bString.length() / 2; i++) {
        retBytes[i] = (byte) ((Character.digit(bString.charAt(2 * i), 16) &lt;&lt; 4) + Character.digit(bString.charAt(2 * i + 1), 16));
    }
    return retBytes;
}

public static byte[] acopyof(byte[] orig, int newlength){
    byte[] copya = new byte[newlength];
    for(int i=0;i&lt; orig.length;i++){
        copya[i]=orig[i];
    }
    for(int i=orig.length;i&lt;newlength;i++){
        copya[i]=0x0;
    }
    return copya;
}
</code></pre>

<p>}</p>

<p>I made this objective-c method to match those specs:</p>

<pre><code>+(NSString*)doCipher:(NSString*)sTextIn:(CCOperation)encryptOrDecrypt {
</code></pre>

<p>// const void *vplainText;
   // size_t plainTextBufferSize;</p>

<pre><code>NSMutableData *dTextIn;

if (encryptOrDecrypt == kCCDecrypt)
{



}
else
{

    dTextIn = [[sTextIn dataUsingEncoding: NSASCIIStringEncoding]mutableCopy];

}

NSLog(@""************** Init encrypting **********************************"");

NSLog(@""This is data to encrypt %@"",dTextIn);

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
//  uint8_t ivkCCBlockSize3DES;

bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x00, bufferPtrSize);



// Initialization vector; in this case 8 bytes.

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x8, (size_t) sizeof(iv));



UserAndPassword *userPass = [[UserAndPassword alloc]init];

NSString *userPassword = userPass.password;

NSLog(@""This is my password %@"",userPassword);

NSString *key = [userPassword MD5String];

NSLog(@""This is MD5 key %@"",key);


NSMutableData *_keyData = [[key dataUsingEncoding:NSASCIIStringEncoding]mutableCopy];

unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

NSLog(@""Bytes of key are %s "", bytePtr);

NSLog(@""******** This is my key length %d *******"",[_keyData length]);

[_keyData setLength:24];

 unsigned char *bytePtr1 = (unsigned char *)[_keyData bytes];

 NSLog(@""******** Bytes of key are %s ************"", bytePtr1);

 NSLog(@""*********  This is key length %d ***********"",[_keyData length]);



ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                   kCCAlgorithm3DES, // CCAlgorithm alg
                   kCCOptionPKCS7Padding, // CCOptions
                   [_keyData bytes], // const void *key
                   kCCKeySize3DES, // 3DES key size length 24 bit
                   iv,  //const void *iv,
                   [dTextIn bytes], // const void *dataIn  
                   [dTextIn length], // size_t dataInLength
                   (void *)bufferPtr, // void *dataOut
                   bufferPtrSize, // size_t dataOutAvailable
                   &amp;movedBytes); // size_t *dataOutMoved

if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";


NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{

    // result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
    result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    NSLog(@""This is my encrypted bytes %@"", myData);

    result = [NSString dataToHex:myData];

    NSLog(@""This is my encrypted string %@"", result);

    NSLog(@""********************** Encryption is finished ************"");

}
return result;
</code></pre>

<p>}</p>

<p>I didn't manage to match the 3DES encryption obtained with Java code and I don't understand which is the problem.</p>

<p>Thank you in advance,
Pier</p>
","<p>The Java version is using an IV of 0s, while the Objective-C version uses 8s.</p>

<p>Deriving a key from a password using one round of MD5 and no salt is not secure. Use a key derivation algorithm like PBKDF2.</p>
","1789","<java><iphone><objective-c><encryption><3des>","1","2","3","2012-08-30 03:53:35","9351244","3","2","","","","2012-02-19 15:52:42",""
"16823107","AES256 vs 3DES 256 key detection","<p>How would I be able to determine the encryption of a key (AES256 or 3DES 256)...Since both keys will be 32 characters (8 bits per char * 32 char)=256 bits and Mime encoded.</p>

<p>Example</p>

<p>MQAyAEgAOgA5ADUAMwA3AD8AQgBFAD4A --->AES256 key</p>

<p>g1EOWGFb+JjCZ7BbH2RergtKUtDfXrNb --->3DES key</p>

<p>The AES keys were made in Openssl while the 3DES ones were made using Java with the following Apis.</p>

<pre><code>javax.crypto.Cipher;
 javax.crypto.KeyGenerator;
 javax.crypto.SecretKey;
 javax.crypto.SecretKeyFactory;
 javax.crypto.spec.DESedeKeySpec;
 javax.crypto.spec.IvParameterSpec;
</code></pre>
","<p>First of all, there is no such thing as 3DES 256. 3DES has a key size of 128 or 192 bits, of which 112 and 168 bits are effectively used. Note that the security margin of 3DES is even lower.</p>

<p>AES on the other hand can be used with 128, 192 and 256 bits, all of which are used.</p>

<p>Now base 64 (not SMIME, that's a higher level protocol) has 6 bits per character (not excluding spurious bits at the end). If I check your keys both of them are 192 bit in size, so that won't help you distinguish the keys. You can use the Apache Codec library to decode base 64 strings.</p>

<p>However, your 3DES key - the second one - seems to use odd parity bytes for the 3 single DES keys. That can be used to distinguish the keys from each other. Note that this is not foolproof, a <strong>randomly generated</strong> AES key may have the parity bits set correctly by chance alone. However, the chance of that happening is somewhere around the order of <code>2^24</code>.</p>

<p>It is possible to use the method <code>DESedeKeySpec.isParityAdjusted(byte[] key, int offset)</code> to check if the parity is correctly set. It is required to decode the base 64 string first of course.</p>

<p>Note that sometimes 3DES keys are distributed without having the parity set correctly. In your case, you <em>need</em> to use the <code>KeyFactory</code> to generate the keys otherwise the parity may not be set.</p>

<p>Another way of checking if the key is of the correct type is to decrypt some known plaintext/ciphertext/secretkey pair using both algorithms.</p>
","1786","<java><encryption><openssl><aes><3des>","2","2","1","2013-05-30 17:40:05","16836589","7","","","","","2013-05-29 20:21:17",""
"3669279","CF DESEDE encrypt() Key Length Issue","<p>I am trying to encrypt a string using ColdFusion encrypt() with a 3rd party provided key like this:</p>

<pre><code>encrypteded = encrypt('theString', 'FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF', 'DESEDE/CBC/NoPadding', 'BASE64', ToBase64('0'));
</code></pre>

<p>I get:</p>

<blockquote>
  <p>""The key specified is not a valid key for this encryption: Wrong key algorithm, expected DESede.""</p>
</blockquote>

<p>What do I have to do to this key in terms of encoding/decoding to get it into the right format?</p>
","<p>The only thing that seems off to me is the algorithm value you're using. Maybe try this?</p>

<pre><code>encrypteded = encrypt('theString', 'FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF', 'DESEDE', 'BASE64', ToBase64('0'));
</code></pre>

<p>I don't know if the <code>/CBC/NoPadding</code> settings will be what you want, but I don't think they will be allowed in the algorithm argument.</p>
","1776","<encryption><coldfusion><coldfusion-8><3des>","1","0","2","2010-10-01 21:02:10","3672679","4","","751","","2010-10-01 21:02:10","2010-09-08 15:23:42",""
"3669279","CF DESEDE encrypt() Key Length Issue","<p>I am trying to encrypt a string using ColdFusion encrypt() with a 3rd party provided key like this:</p>

<pre><code>encrypteded = encrypt('theString', 'FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF', 'DESEDE/CBC/NoPadding', 'BASE64', ToBase64('0'));
</code></pre>

<p>I get:</p>

<blockquote>
  <p>""The key specified is not a valid key for this encryption: Wrong key algorithm, expected DESede.""</p>
</blockquote>

<p>What do I have to do to this key in terms of encoding/decoding to get it into the right format?</p>
","<p>Generally, when using provided keys from other languages, you have to do a little gymnastics on it to get it into Base64.</p>

<p>Try this for the key argument:</p>

<pre><code> ToBase64(BinaryDecode('FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF','hex'))
</code></pre>

<p>But, to make this work for me, the input string needed to be a multiple of 8 bytes (because you're specifying NoPadding), and the IV needed to also be a multiple of 8 bytes.</p>

<p>So, this ended up working for me - not sure if you'll be able to decrypt it on the other end, tho, if the IV they're specifying is really what you've got listed there.</p>

<pre><code> encrypteded = encrypt('theStrin', ToBase64(BinaryDecode('FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF','hex')), 'DESEDE/CBC/NoPadding', 'BASE64', ToBase64('0000'));
</code></pre>

<p>No IV also worked as well (with different output, obviously):</p>

<pre><code>encrypteded = encrypt('theStrin', ToBase64(BinaryDecode('FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF','hex')), 'DESEDE/CBC/NoPadding', 'BASE64');
</code></pre>

<p>If you've been given a Hex IV, then you can use it as such:</p>

<pre><code>encrypteded = encrypt('theStrin', ToBase64(BinaryDecode('FD52250E230D1CDFD5C2DF0D57E3E0FEFD52250E230D1CDF','hex')), 'DESEDE/CBC/NoPadding', 'BASE64', BinaryDecode(""7fe8585328e9ac7b"",""hex""));
</code></pre>

<p>Hopefully this is enough info to get you on your way!</p>
","1776","<encryption><coldfusion><coldfusion-8><3des>","1","1","2","2010-10-01 21:02:10","3672679","4","","751","","2010-10-01 21:02:10","2010-09-08 15:23:42",""
"3443457","iPhone 3Des Encrypting matching Java and .NET key issue, SecretKeySpec?","<p>I'm trying do some encrypt something using 3des on the iphone that must match the results from java and .NET.</p>

<p>the code i have is:</p>

<pre><code>+ (NSString*) doCipher:(NSString*)plainText:(CCOperation)encryptOrDecrypt {

const void *vplainText;
size_t plainTextBufferSize;

if (encryptOrDecrypt == kCCDecrypt)
{
    NSData *EncryptData = [NSData dataWithBase64EncodedString:plainText];
    plainTextBufferSize = [EncryptData length];
    vplainText = [EncryptData bytes];
}
else
{
    NSData *tempData = [plainText dataUsingEncoding:NSASCIIStringEncoding];
    plainTextBufferSize = [tempData length];
    vplainText =  [tempData bytes];
}

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;
//  uint8_t ivkCCBlockSize3DES;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

NSString *key = [NSString MD5:@""HSDNIFFU""];

NSData *_keyData = [key dataUsingEncoding:NSASCIIStringEncoding];

NSLog(@""key byte is %s"", [_keyData bytes]);

// Initialization vector; dummy in this case 0's.
uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x0, (size_t) sizeof(iv));

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   (const void *)[_keyData bytes], //""123456789012345678901234"", //key
                   kCCKeySize3DES,
                   iv,  //iv,
                   vplainText,  //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

//if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
/*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

NSString *result;

if (encryptOrDecrypt == kCCDecrypt)
{

//  result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:[(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding]];
    result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding] autorelease];
}
else
{
    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSLog(@""data is: %@"", myData);
    result = [myData base64Encoding];
}
return result;
</code></pre>

<p>} </p>

<p>This code successfully encrypts and decrypts a string. As you can see, it uses md5 on the key. However, it does not match the results from .NET and java.</p>

<p>The java code from the java developer looks like:</p>

<pre><code>public static byte[] encryptTripleDES(String message) throws Exception {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(""--KEY--"".getBytes(""utf-8""));
    final SecretKey key = new SecretKeySpec(digestOfPassword, ""DESede"");
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    return cipher.doFinal(message.getBytes(""utf-8""));
}
</code></pre>

<p>Unfortunately I'm not too familiar with java encryption. I did notice that after using md5 on the KEY it creates a SecretKey with the method SecretKeySpec. My Java developer told me that he needed to create a secretkey using the byte array of the key so that it could match the .NET key. </p>

<p>Can anyone explain this better to me and help me with a solution to match the results of the .NET and java counterparts?</p>
","<p>I figured it out. The key that is generated after i md5 it is 32 bytes. From reading other posts, it seems that kCCKeySize3DES is only 24 bytes. If i put a key that is 24 bytes or less (no md5) this seems to work perfectly. </p>
","1772","<java><.net><iphone><encryption><3des>","2","1","1","2010-08-09 22:35:22","3444713","0","3","","","","2010-08-09 19:26:30",""
"7942085","TripleDES ECB Encryption in Perl that's compatible with PHP mcrypt's implementation","<p>I'm trying to create a package in perl that is equivalent to our pre-existing class in php for handling data encryption.</p>

<p>The encryption type seems to be TripleDES in ECB mode however I cannot replicated the resulting cypher text using Crypt::CBC or Crypt::TripleDES.</p>

<p>I think the issue is to do with either padding or the key format (binary vs hex etc) yet searching though the documentation isn't helping me find an answer.</p>

<p>The current PHP class is as follows (trimmed down but with the same core functionality):</p>

<pre><code>&lt;?php
class Encryption {
    private $encryption_key;
    private $encryption_td;
    private $encryption_iv;

    private function __construct() {
        $this-&gt;encryption_key = 'abc123';
        $this-&gt;encryption_td = mcrypt_module_open( 'tripledes', '', 'ecb', '' );
        $this-&gt;encryption_iv = mcrypt_create_iv ( mcrypt_enc_get_iv_size( $this-&gt;encryption_td ), MCRYPT_RAND );

        mcrypt_generic_init( $this-&gt;encryption_td, $this-&gt;encryption_key, $this-&gt;encryption_iv );
    }

    public function __destruct() {
        mcrypt_generic_deinit( $this-&gt;encryption_td );
        mcrypt_module_close( $this-&gt;encryption_td );
    }   

    public static function instance($key = null, $iv = null, $algorithm = null, $mode = null) {
        static $instance;

        if (! $instance) {
            $instance = new Encryption( $key, $iv, $algorithm, $mode );
        }

        return $instance;
    }

    public function encrypt( $password ) {
        return base64_encode( mcrypt_generic( $this-&gt;encryption_td, $password ) );
    }

    public function decrypt( $password ) {
        return trim(mdecrypt_generic( $this-&gt;encryption_td, base64_decode( $password ) ) );
    }
}

function decrypt_password( $password ) {
    return Encryption::instance()-&gt;decrypt( $password );
}

function encrypt_password( $password ) {
    return Encryption::instance()-&gt;encrypt( $password );
}

print encrypt_password( 'wibblewobble123' ) . ""\n"";
print decrypt_password( encrypt_password( 'wibblewobble123' ) ) . ""\n"";
?&gt;
</code></pre>

<p>My current perl package is as follows:</p>

<pre><code>package Encryption;
use warnings;
use strict;
use MIME::Base64;
use Crypt::TripleDES;

sub new {
    my $class = shift;
    my $self = {};
    $self-&gt;{'encryption_key'} = 'abc123';
    $self-&gt;{'td'} = Crypt::TripleDES-&gt;new();
    bless( $self, $class );
    return $self;
}

sub decrypt {
    my( $self, $encrypted_password ) = @_;
    $encrypted_password = decode_base64( $encrypted_password );
    my $password = $self-&gt;{'td'}-&gt;decrypt3( $encrypted_password, $self-&gt;{'encryption_key'} );
    chomp( $password );
    return $password;
}

sub encrypt {
    my( $self, $password ) = @_;
    my $encrypted_password = $self-&gt;{'td'}-&gt;encrypt3( $password, $self-&gt;{'encryption_key'} );
    $encrypted_password = encode_base64( $encrypted_password );
    chomp( $encrypted_password );
    undef( $password );
    return $encrypted_password;
}

1;
</code></pre>

<p>And the test code:</p>

<pre><code>use warnings;
use strict;

use Encryption;

sub decrypt {
    my $password = shift;
    my $eh = Encryption-&gt;new();
    return $eh-&gt;decrypt( $password );
}

sub encrypt {
    my $password = shift;
    my $eh = Encryption-&gt;new();
    return $eh-&gt;encrypt( $password );
}

print encrypt( 'wibblewobble123' ) . ""\n"";
print decrypt( encrypt( 'wibblewobble123' ) ) . ""\n"";
</code></pre>

<p>The output from each is as follows:</p>

<p>php:</p>

<pre><code>xuRt3xxjPO1GUz+DccTVKw==
wibblewobble123
</code></pre>

<p>perl:</p>

<pre><code>mmWuKkpvveHvnUsQ2NC6DA==
wibblewobble123
</code></pre>

<p>The expected result is perl's encryption subroutine returns the same output as php's encryption function with decrypt doing the same but in reverse.</p>

<p>If Crypt::TripleDES is the wrong way to be attacking this problem then I'm happy to use something else - This code is going to get re-written into something neater anyway.</p>

<p>As a side note this will need to work with multiple key lengths, so if it is a padding issue please explain how to calculate the correct padding based upon key length.</p>
","","1752","<php><perl><encryption><3des><ecb>","1","","0","2011-10-29 22:26:59","","6","","","","","2011-10-29 22:26:59",""
"18754635","3DES encryption in Java and Objective C produces different result","<p>I have to encrypt a string in Objective C. The encryption scheme is 3DES/CBC/PKCS5 padding and I have to convert in Objective C this Java code:</p>

<pre><code>        public class MessageEncrypt {

            public String encryptString(String message, String seckey) throws Exception{
                byte[] encData = encrypt(message, seckey);

                return this.getHexString(encData, """");
            }

            public String decryptString(String message, String seckey) throws Exception{
                return decrypt(this.getBArray(message), seckey);
            }

            private byte[] encrypt(String message, String seckey) throws Exception {
                final MessageDigest md = MessageDigest.getInstance(""md5"");
                final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
                final byte[] keyBytes = acopyof(digestOfPassword, 24);
                for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
                }

                final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
                final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
                final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
                cipher.init(Cipher.ENCRYPT_MODE, key, iv);

                final byte[] plainTextBytes = message.getBytes(""utf-8"");
                final byte[] cipherText = cipher.doFinal(plainTextBytes);
                // final String encodedCipherText = new sun.misc.BASE64Encoder()
                // .encode(cipherText);

                return cipherText;
            }

            private String decrypt(byte[] message, String seckey) throws Exception {
                final MessageDigest md = MessageDigest.getInstance(""md5"");
                final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
                final byte[] keyBytes = acopyof(digestOfPassword, 24);
                for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
                }

                final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
                final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
                final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
                decipher.init(Cipher.DECRYPT_MODE, key, iv);

                final byte[] plainText = decipher.doFinal(message);

                return new String(plainText, ""UTF-8"");
            }

            private String getHexString(byte[] barray, String delim) {
                StringBuffer buffer = new StringBuffer();


                for (int i = 0; i &lt; barray.length; i++) {
                    int ii = barray[i] &amp; 0xFF;
                    String bInt = Integer.toHexString(ii);
                    if (ii &lt; 16) {
                        bInt = ""0"" + bInt.toUpperCase();
                    }
                    buffer.append(bInt);
                    if (i &lt; barray.length - 1) {
                        buffer.append(delim);
                    }
                }

                return buffer.toString().toUpperCase();
            }

            private byte[] getBArray(String bString) {
                byte[] retBytes;

                if (bString.length() % 2 != 0) {
                    return new byte[0];
                }
                retBytes = new byte[bString.length() / 2];

                for (int i = 0; i &lt; bString.length() / 2; i++) {
                    retBytes[i] = (byte) ((Character.digit(bString.charAt(2 * i), 16) &lt;&lt; 4) + Character.digit(bString.charAt(2 * i + 1), 16));
                }
                return retBytes;
            }

            public static byte[] acopyof(byte[] orig, int newlength){
                byte[] copya = new byte[newlength];
                for(int i=0;i&lt; orig.length;i++){
                    copya[i]=orig[i];
                }
                for(int i=orig.length;i&lt;newlength;i++){
                    copya[i]=0x0;
                }
                return copya;
            }
  }
</code></pre>

<p>Objective C code:</p>

<pre><code>+(NSString*)doCipher:(NSString*)sTextIn:(CCOperation)encryptOrDecrypt {

    NSMutableData *dTextIn;

    if (encryptOrDecrypt == kCCDecrypt)
    {
        //TODO
    }
    else
    {
        dTextIn = [[sTextIn dataUsingEncoding: NSUTF8StringEncoding]mutableCopy];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    // Initialization vector; in this case 8 bytes.
    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    NSString *key = [@""MY_KEY_HERE"" MD5];

    NSMutableData *_keyData = [[key dataUsingEncoding:NSUTF8StringEncoding]mutableCopy];

    unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

    [_keyData setLength:24];

    unsigned char *bytePtr1 = (unsigned char *)[_keyData bytes];

    ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                       kCCAlgorithm3DES, // CCAlgorithm alg
                       kCCOptionPKCS7Padding, // CCOptions
                       [_keyData bytes], // const void *key
                       kCCKeySize3DES, // 3DES key size length 24 bit
                       iv,  //const void *iv,
                       [dTextIn bytes], // const void *dataIn  
                       [dTextIn length], // size_t dataInLength
                       (void *)bufferPtr, // void *dataOut
                       bufferPtrSize, // size_t dataOutAvailable
                       &amp;movedBytes); // size_t *dataOutMoved

    if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;
    if (encryptOrDecrypt == kCCDecrypt)
    {
        result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] autorelease];
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        result = [NSString dataToHex:myData];
    }
    return result;
}
</code></pre>

<p>Do not understand why I get a different result. Any idea ?</p>
","<p>I made it. Solution:</p>

<p>Java code:</p>

<pre><code>public class MessageEncrypt {

        public String encryptString(String message, String seckey) throws Exception{
            byte[] encData = encrypt(message, seckey);

            return Base64.encodeToString(encData, Base64.DEFAULT);
        }

        public String decryptString(String message, String seckey) throws Exception{
            byte[] encData= Base64.decode(message, Base64.DEFAULT);

            return decrypt(encData, seckey);
        }

        private byte[] encrypt(String message, String seckey) throws Exception {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
            final byte[] keyBytes = acopyof(digestOfPassword, 24);
            for (int j = 0, k = 16; j &lt; 8;) {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);

            return cipherText;
        }

        private String decrypt(byte[] message, String seckey) throws Exception {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
            final byte[] keyBytes = acopyof(digestOfPassword, 24);
            for (int j = 0, k = 16; j &lt; 8;) {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            final byte[] plainText = decipher.doFinal(message);

            return new String(plainText, ""UTF-8"");
        }

        public byte[] acopyof(byte[] orig, int newlength){
            byte[] copya = new byte[newlength];
            for(int i=0;i&lt; orig.length;i++){
                copya[i]=orig[i];
            }
            for(int i=orig.length;i&lt;newlength;i++){
                copya[i]=0x0;
            }
            return copya;
        }
    }
</code></pre>

<p>Objective C code:</p>

<pre><code>+(NSString*)doCipher:(NSString*)message key:(NSString*)key operation:(CCOperation)encryptOrDecrypt {

    const void *messageData;
    size_t messageBufferSize;

    if (encryptOrDecrypt == kCCDecrypt){
        NSData *messageEncryptData= [NSData dataFromBase64String:message];
        messageBufferSize= [messageEncryptData length];
        messageData= [messageEncryptData bytes];
    }
    else{
        messageBufferSize= message.length;
        messageData = [[[message dataUsingEncoding: NSUTF8StringEncoding]mutableCopy] bytes];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;

    bufferPtrSize = (messageBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    NSMutableData *keyData = [[key dataUsingEncoding:NSUTF8StringEncoding]mutableCopy];
    NSData *keyEncodedMD5 = [NSData MD5Digest:keyData];

    NSMutableData *keyDataAux = [NSMutableData dataWithData:keyEncodedMD5];
    NSRange rangeToModify = NSMakeRange([keyEncodedMD5 length], kCCKeySize3DES - [keyEncodedMD5 length]);
    [keyDataAux setLength: kCCKeySize3DES];
    [keyDataAux replaceBytesInRange:rangeToModify withBytes:[keyEncodedMD5 bytes]];

    ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                       kCCAlgorithm3DES, // CCAlgorithm alg
                       kCCOptionPKCS7Padding, // CCOptions
                       [keyDataAux bytes], // const void *key
                       kCCKeySize3DES, // 3DES key size length 24 bytes
                       iv,  //const void *iv,
                       messageData, // const void *dataIn
                       messageBufferSize, // size_t dataInLength
                       (void *)bufferPtr, // void *dataOut
                       bufferPtrSize, // size_t dataOutAvailable
                       &amp;movedBytes); // size_t *dataOutMoved

    if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;
    if (encryptOrDecrypt == kCCDecrypt){
        result = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] ;
    }
    else{
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        result= [myData base64EncodedString];
    }

    return result;
}
</code></pre>
","1750","<java><objective-c><encryption><3des>","0","0","2","2013-12-13 07:00:29","","0","2","1629490","","2013-09-12 03:22:46","2013-09-12 03:02:44",""
"18754635","3DES encryption in Java and Objective C produces different result","<p>I have to encrypt a string in Objective C. The encryption scheme is 3DES/CBC/PKCS5 padding and I have to convert in Objective C this Java code:</p>

<pre><code>        public class MessageEncrypt {

            public String encryptString(String message, String seckey) throws Exception{
                byte[] encData = encrypt(message, seckey);

                return this.getHexString(encData, """");
            }

            public String decryptString(String message, String seckey) throws Exception{
                return decrypt(this.getBArray(message), seckey);
            }

            private byte[] encrypt(String message, String seckey) throws Exception {
                final MessageDigest md = MessageDigest.getInstance(""md5"");
                final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
                final byte[] keyBytes = acopyof(digestOfPassword, 24);
                for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
                }

                final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
                final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
                final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
                cipher.init(Cipher.ENCRYPT_MODE, key, iv);

                final byte[] plainTextBytes = message.getBytes(""utf-8"");
                final byte[] cipherText = cipher.doFinal(plainTextBytes);
                // final String encodedCipherText = new sun.misc.BASE64Encoder()
                // .encode(cipherText);

                return cipherText;
            }

            private String decrypt(byte[] message, String seckey) throws Exception {
                final MessageDigest md = MessageDigest.getInstance(""md5"");
                final byte[] digestOfPassword = md.digest(seckey.getBytes(""utf-8""));
                final byte[] keyBytes = acopyof(digestOfPassword, 24);
                for (int j = 0, k = 16; j &lt; 8;) {
                    keyBytes[k++] = keyBytes[j++];
                }

                final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
                final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
                final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
                decipher.init(Cipher.DECRYPT_MODE, key, iv);

                final byte[] plainText = decipher.doFinal(message);

                return new String(plainText, ""UTF-8"");
            }

            private String getHexString(byte[] barray, String delim) {
                StringBuffer buffer = new StringBuffer();


                for (int i = 0; i &lt; barray.length; i++) {
                    int ii = barray[i] &amp; 0xFF;
                    String bInt = Integer.toHexString(ii);
                    if (ii &lt; 16) {
                        bInt = ""0"" + bInt.toUpperCase();
                    }
                    buffer.append(bInt);
                    if (i &lt; barray.length - 1) {
                        buffer.append(delim);
                    }
                }

                return buffer.toString().toUpperCase();
            }

            private byte[] getBArray(String bString) {
                byte[] retBytes;

                if (bString.length() % 2 != 0) {
                    return new byte[0];
                }
                retBytes = new byte[bString.length() / 2];

                for (int i = 0; i &lt; bString.length() / 2; i++) {
                    retBytes[i] = (byte) ((Character.digit(bString.charAt(2 * i), 16) &lt;&lt; 4) + Character.digit(bString.charAt(2 * i + 1), 16));
                }
                return retBytes;
            }

            public static byte[] acopyof(byte[] orig, int newlength){
                byte[] copya = new byte[newlength];
                for(int i=0;i&lt; orig.length;i++){
                    copya[i]=orig[i];
                }
                for(int i=orig.length;i&lt;newlength;i++){
                    copya[i]=0x0;
                }
                return copya;
            }
  }
</code></pre>

<p>Objective C code:</p>

<pre><code>+(NSString*)doCipher:(NSString*)sTextIn:(CCOperation)encryptOrDecrypt {

    NSMutableData *dTextIn;

    if (encryptOrDecrypt == kCCDecrypt)
    {
        //TODO
    }
    else
    {
        dTextIn = [[sTextIn dataUsingEncoding: NSUTF8StringEncoding]mutableCopy];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = ([dTextIn length] + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    // Initialization vector; in this case 8 bytes.
    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    NSString *key = [@""MY_KEY_HERE"" MD5];

    NSMutableData *_keyData = [[key dataUsingEncoding:NSUTF8StringEncoding]mutableCopy];

    unsigned char *bytePtr = (unsigned char *)[_keyData bytes];

    [_keyData setLength:24];

    unsigned char *bytePtr1 = (unsigned char *)[_keyData bytes];

    ccStatus = CCCrypt(encryptOrDecrypt, // CCoperation op
                       kCCAlgorithm3DES, // CCAlgorithm alg
                       kCCOptionPKCS7Padding, // CCOptions
                       [_keyData bytes], // const void *key
                       kCCKeySize3DES, // 3DES key size length 24 bit
                       iv,  //const void *iv,
                       [dTextIn bytes], // const void *dataIn  
                       [dTextIn length], // size_t dataInLength
                       (void *)bufferPtr, // void *dataOut
                       bufferPtrSize, // size_t dataOutAvailable
                       &amp;movedBytes); // size_t *dataOutMoved

    if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;
    if (encryptOrDecrypt == kCCDecrypt)
    {
        result = [[[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding] autorelease];
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        result = [NSString dataToHex:myData];
    }
    return result;
}
</code></pre>

<p>Do not understand why I get a different result. Any idea ?</p>
","<p>Objective-C code:</p>

<pre><code> + (NSString*) doCipher:(NSString*)plainText operation:(CCOperation)encryptOrDecrypt
 {

     const void *vplainText;
     size_t plainTextBufferSize;

     if (encryptOrDecrypt == kCCDecrypt)
     {
         NSData *EncryptData = [[NSData alloc] initWithBase64EncodedString:plainText];
         plainTextBufferSize = [EncryptData length];
         vplainText = [EncryptData bytes];
     }
     else
     {
         plainTextBufferSize = [plainText length];
         vplainText = (const void *) [plainText UTF8String];
     }

     CCCryptorStatus ccStatus;
     uint8_t *bufferPtr = NULL;
     size_t bufferPtrSize = 0;
     size_t movedBytes = 0;


     uint8_t iv[kCCBlockSize3DES];
     memset((void *) iv, 0x00, (size_t) sizeof(iv));

     bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
     bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
     memset((void *)bufferPtr, 0x0, bufferPtrSize);


     NSData *testData = [self md5DataFromString:SECRET_KEY];
     const char *constSource = [testData bytes];

     unsigned char source[24];
     memcpy(source, constSource, sizeof (source));

     for (int j = 0, k = 16; j &lt; 8;) {
         source[k++] = source[j++];
     }

     ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   source,
                   kCCKeySize3DES,
                   iv,
                   vplainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);
     if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
     else if (ccStatus == kCCParamError) return @""PARAM ERROR"";
     else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
     else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
     else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
     else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
     else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

     NSString *result;

     if (encryptOrDecrypt == kCCDecrypt)
     {
         result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void     *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSUTF8StringEncoding];
     }
     else
     {
         NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
         result = [myData base64Encoding];
     }
     return result;
 }

 + (NSData *)md5DataFromString:(NSString *)input
 {
     const char *cStr = [input UTF8String];
     unsigned char digest[16];
     CC_MD5( cStr, strlen(cStr), digest ); // This is the md5 call

     return [NSData dataWithBytes:digest length:CC_MD5_DIGEST_LENGTH];
 }
</code></pre>
","1750","<java><objective-c><encryption><3des>","0","0","2","2013-12-13 07:00:29","","0","2","1629490","","2013-09-12 03:22:46","2013-09-12 03:02:44",""
"13917640","Failure to decrypt an AES encrypted SMIME Message with OpenSSL","<p>I have a two mails (SMIME encrypted) for a single recipient. One mail is encrypted using 3DES, the other one is encrypted using AES 256.</p>

<p>The mails where created using C# <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.pkcs.envelopedcms%28v=vs.100%29.aspx"" rel=""nofollow"">EnvelopedCms</a> class.</p>

<p>I can successfully decrypt the 3DES message using</p>

<pre><code>openssl smime -decrypt -in trippledes.eml -inkey keyfile.pem
</code></pre>

<p>However, if I try this with the AES encrypted file, OpenSSL outputs some gibberish and Fails with this comment:</p>

<pre><code>Error decrypting PKCS#7 structure 4128:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:.\crypto\evp\evp_enc.c:539:
</code></pre>

<p>Thunderbird cannot open the mail either. But Outlook 2010 has no problem opening the message.</p>

<p>What is the best way to troubleshoot the issue? Is there any logging I can turn on? </p>

<p>I've already examined the ASN.1 structure of both mails using the ASN.1 Decoder on <a href=""http://lapo.it/asn1js/"" rel=""nofollow"">http://lapo.it/asn1js/</a>. Both messages look OK to me, so I guess the culprit lies in the encrypted Content itself.</p>
","<p>I know this is years late, but it might be helpful to others...</p>

<p>I was using the EnvelopedCms very successfully and happily for a few years, exchanging messages with many other implementations.  When someone this year decided to require the use of AES, I discovered that at least one Java-based system was failing to work with my messages. (Their error was ""Unable to create PKCS #7 MIME content"")</p>

<p>I used an ASN info utility to break down what I was sending, and discovered that EnvelopedCms was forcing the KeyEncryptionAlgorithm to RSA-OAEP when the content encryption was set to AES. (If the content was encrypted with anything else, the KeyEncryptionAlgorithm was just plain RSA.)</p>

<p>I could find no documentation or RFCs explaining this behavior, and there does not appear to be any way to change it. </p>

<p>My solution to the problem was to use the BouncyCastle CmsEnvelopedDataGenerator class.  So far, it appears to work at least as well as EnvelopedCms, and avoids the RSA-OAEP key encryption issue. Almost a drop-in replacement (other than the certificate class used.)</p>

<p>While I could not find any documentation that specifically said that my recipient's Java libraries could not use the RSA-OAEP algorithm, once I eliminated it, their error was gone, and messages were successfully sent.</p>

<p>Example code using BouncyCastle:</p>

<pre><code>private byte[] CmsEncrypt(byte[] message, string contentEncryptionOid, Org.BouncyCastle.X509.X509Certificate recipCertificate)
{
    var cmsGenerator = new CmsEnvelopedDataGenerator();
    var cmsData = new CmsProcessableByteArray(message);

    cmsGenerator.AddKeyTransRecipient(recipCertificate);

    var cmsEnvelope = cmsGenerator.Generate(cmsData, contentEncryptionOid);

    return cmsEnvelope.GetEncoded();
}
</code></pre>
","1710","<outlook><openssl><aes><thunderbird><3des>","0","2","1","2015-12-26 14:21:47","","2","","","","","2012-12-17 16:04:35",""
"31786037","How to encrypt using 3DES in Swift","<p>I am struggling to find something to encrypt 3DES in swift. I have tried CommonCrypto, but I cannot get it working (I raised a separate issue on this). I also have CryotoSwift working for MD5, but it either doesn't do 3DES, or its not got the required code in place in the Objective C library.</p>

<p>Could someone please recommend something or is there an example of some swift code out there to do this? (Im not very good with Objective C)</p>
","","1634","<swift><3des>","0","","0","2017-11-20 18:07:03","","3","","","","","2015-08-03 11:27:29","2017-11-20 19:08:56"
"17084182","Different 3DES encryption result between objective-c and C#","<p>I am developing a ios app, using C# in server side. I need to use 3DES encryption to encrypt the password. </p>

<p>In both code:</p>

<pre><code>key = ""FC13573F412EAA1BA8E34791C06504C1429C5BCEB94DB111"";
plainText = ""123456""; // (or CryptString = ""123456"")
</code></pre>

<p>now C# result is correct, buy i never get the same result in objective-c, please help</p>

<p>following is C# code:</p>

<pre><code>public bool Crypt3DESToBase64(string CryptString, string Key, out string DecryptString)
    {
        DecryptString = """";
        try
        {
            // encode to bytes
            byte[] KEY = HexStringToByteArray(Key);
            byte[] CRYPTSTRING = System.Text.Encoding.UTF8.GetBytes(CryptString);

            //set iv and key
            byte[] tmpiv = { 1, 2, 3, 4, 5, 6, 7, 8 };
            byte[] tmpkey = { 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7 };

            for (int ii = 0; ii &lt; 24; ii++)
            {
                tmpkey[ii] = KEY[ii];
            }
            TripleDESCryptoServiceProvider dsp = new TripleDESCryptoServiceProvider();
            dsp.Mode = System.Security.Cryptography.CipherMode.CBC;
            dsp.Padding = System.Security.Cryptography.PaddingMode.PKCS7;

            ICryptoTransform tridesencrypt = dsp.CreateEncryptor(tmpkey, tmpiv);

            DecryptString = Convert.ToBase64String(tridesencrypt.TransformFinalBlock(CRYPTSTRING, 0, CRYPTSTRING.Length));

            dsp.Clear();

            return true;
        }
        catch (Exception e)
        {
            return false;
        }
    }

    public static byte[] HexStringToByteArray(string s)
    {
        Byte[] buf = new byte[s.Length / 2];
        for (int i = 0; i &lt; buf.Length; i++)
        {
            buf[i] = (byte)(chr2hex(s.Substring(i * 2, 1)) * 0x10 + chr2hex(s.Substring(i * 2 + 1, 1)));
        }
        return buf;
    }

    private static byte chr2hex(string chr)
    {
        switch (chr)
        {
            case ""0"":
                return 0x00;
            case ""1"":
                return 0x01;
            case ""2"":
                return 0x02;
            case ""3"":
                return 0x03;
            case ""4"":
                return 0x04;
            case ""5"":
                return 0x05;
            case ""6"":
                return 0x06;
            case ""7"":
                return 0x07;
            case ""8"":
                return 0x08;
            case ""9"":
                return 0x09;
            case ""A"":
                return 0x0a;
            case ""B"":
                return 0x0b;
            case ""C"":
                return 0x0c;
            case ""D"":
                return 0x0d;
            case ""E"":
                return 0x0e;
            case ""F"":
                return 0x0f;
        }
        return 0x00;
    }
</code></pre>

<p>and following is objective-c code:</p>

<pre><code>#define gIv  @""12345678""
#define kSecrectKeyLength 24
+ (NSString*)encrypt:(NSString*)plainText withKey:(NSString*)key{
    uint8_t keyByte[kSecrectKeyLength];
    NSMutableData *keyData = [[NSMutableData alloc] init];
    int i;
    for (i=0; i &lt; [key length] / 2; i++) {
        NSString *tempNumber = [key substringWithRange: NSMakeRange(i * 2, 2)];
        NSScanner *scanner=[NSScanner scannerWithString:tempNumber];
        unsigned int temp;
        [scanner scanHexInt:&amp;temp];
        Byte B = (Byte)(0xFF &amp; temp);
        keyByte[i] = B;
    }

    NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding];
    size_t plainTextBufferSize = [data length];
    const void *vplainText = (const void *)[data bytes];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    const void *vkey = (const void *) keyByte;
    const void *vinitVec = (const void *) [gIv UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   vkey,
                   kCCKeySize3DES,
                   vinitVec,
                   vplainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    NSString *result = [GTMBase64 stringByEncodingData:myData];

    NSLog(@""result=%@"",result);

    return result;
}
</code></pre>

<p>please help, thanks very much!</p>
","<p>Your IV is different. In your C# code you are using bytes 1,2 etc. but in your objective-C you are using the byte value of characters '1', '2' (which are bytes 49, 50 etc).</p>
","1630","<c#><ios><objective-c><3des>","3","5","1","2013-06-13 10:40:33","17084251","0","3","2369778","","2013-06-13 10:40:33","2013-06-13 09:56:56",""
"9911899","Encryption in iPhone with 3DES","<p>I need encrypt a NSString with 3DES and i cant do it. Its return me a big NSString in result:</p>

<pre><code>ccStatus = CCCrypt(kCCEncrypt,
                   kCCAlgorithm3DES,
                   kCCOptionECBMode | kCCOptionPKCS7Padding ,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySize3DES,
                   vinitVec,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   movedBytes);

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [myData base64Encoding];

NSLog(@""%@"", result);
</code></pre>
","<p>Try this.. It worked for me.</p>

<pre><code>    NSData *data = [NSString dataUsingEnconding:NSASCIIStringEncoding];
    NSData *key = [self create3DesKey]; //This should be 24 characters, or 24 bytes

    const void *vplainText;
    size_t plainTextBufferSize;
    plainTextBufferSize = [data length];
    vplainText = (const void *)[data bytes];

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t movedBytes = 0;

    bufferPtr = (uint8_t *) malloc( [data length] * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, [data length]);

    NSString *initVec = @""init_Vec"";

    const void *vkey = (const void *) [key bytes];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(kCCEncrypt,//encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       plainTextBufferSize % 8 == 0 ? kCCOptionECBMode : KCCOptionPKCS7PAdding , //
                       vkey, //this should 24 bytes from 0x00 to 0xFF
                       kCCKeySize3DES,
                       vinitVec, //""init Vec"", //iv,
                       vplainText, //This should be a multiple of 8 bytes or you will have to use KCCOptionPKCS7PAdding
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       [data length],
                       &amp;movedBytes);

NSString *result;
NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
result = [myData base64Encoding];

NSLog(@""%@"", result);
</code></pre>

<p>This function should be used to create the key the proper way:</p>

<pre><code>-(NSData*)create3DesKey
{
NSMutableData *mData = [[NSMutableData alloc] init];
    NSMutableData *mAuxData = [[NSMutableData alloc] init];

    for(int i = 0; i &lt; 16; ++i)
    {
        u_int32_t aux = arc4random() % 255;

        [mData appendBytes:&amp;aux length:1];

        if(i &lt; 8)
        {
            [mAuxData appendBytes:&amp;aux length:1];
        }
    } 

    [mData appendData:mAuxData];    

    return mData;
}
</code></pre>

<p>I've been working around with it myself. Note that, the createkey function, creates a EDE key, which states that the first 8 bytes of the key is exactly equal to the 8 last bytes. It could also be created in a way that all 3 blocks of 8 bytes are the same, or completely different. You should check which one your server processes.</p>

<p>Hope it helps.</p>
","1591","<iphone><encryption><encoding><character-encoding><3des>","0","2","1","2012-03-28 20:53:24","","1","","589259","","2012-03-28 19:31:33","2012-03-28 16:31:54",""
"6860915","Java SecretKey and replicating it's behaviour in C#","<p>I am trying to replicate the encryption logic found in a Java library in a C# application.</p>

<p>The Java contains two methods which I have managed to replicate in C#.  I get the same results in each program for any set of data.</p>

<pre><code>createKey(byte data1[], MessageDigest md);
createIV(byte data2[], MessageDigest md);
</code></pre>

<p>The logic to generate the key and IV in Java is as follows:</p>

<pre><code>public Cipher getCipher(byte[] password) {

    MessageDigest md = MessageDigest.getInstance(""SHA-1"");

    byte keyData[] = createKey(byte[] password, md);

     SecretKey secretKey = 
        SecretKeyFactory.getInstance(""DESede"").
        generateSecret(new DESedeKeySpec(keyData[]));

    IVSpec ivspec = createIV(secretKey.getEncoded(), md);

    Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
    cipher.init(1, secretKey, ivSpec, md);

    return cipher;
}
</code></pre>

<p>Let's say I have the follow:</p>

<pre><code>Java Key HEX:       9c 3a 79 df ba 49 86 0 ed 58 1 d8 9b a7 94 0 bb 3e 8f 80 4d 67 0 0
</code></pre>

<p>When I build the secretKey and then call secretKey.getEncoded() I get:</p>

<pre><code>Java Encoded Key: : 9d 3b 79 df ba 49 86 1 ec 58 1 d9 9b a7 94 1 ba 3e 8f 80 4c 67 1 1     
</code></pre>

<p>Because I don't know what the SecretKey is doing internally I don't know how to replicate this in C#.</p>

<p>My current C# code looks like this:</p>

<pre><code>    public static ICryptoTransform createCryptoTransform(String password)
    {

        ICryptoTransform ct = null;

        byte[] keyData = createKey(password);
        byte[] ivData = createInitialisationVector(keyData);

        printByteArray(""keyData"", keyData);
        printByteArray(""ivData"", ivData);

        TripleDESCryptoServiceProvider tdcsp = new TripleDESCryptoServiceProvider();

        tdcsp.Key = keyData; / This seems to be ignored by CreateEncryptor method below
        tdcsp.KeySize = 192;            
        tdcsp.IV = ivData; // This seems to be ignored by CreateEncryptor method below
        tdcsp.Mode = CipherMode.CBC;   
        tdcsp.Padding = PaddingMode.PKCS7; // PKCS5 and PKCS7 provide the same padding scheme

        ct = tdcsp.CreateEncryptor(keyData, ivData);

        return ct;

    }
</code></pre>

<p>As you can see, I'm using the ivData[] created from the unencoded key.</p>

<p>Everything works, that is I get the same encrypted result, if I pass the same IV data in when creating the encryptor but unfortunately I cannot modify how it generates it's IVSpec.</p>

<p>What is SecretKey doing internally and how do I replicate this in C#?</p>
","<p>DES (and DESede) both derive 56 bits of key material from 64 bit input. The remaining 8 bits are used as parity check bits here. The <a href=""http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/com/sun/crypto/provider/DESedeKey.java#DESedeKey"" rel=""nofollow"">source code</a> shows you how Java handles this, you can apply the same in C#.</p>

<p>See also the section at the beginning of <a href=""http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf"" rel=""nofollow"">FIPS 46-3</a>.</p>
","1562","<c#><java><encryption><sha1><3des>","1","2","1","2011-07-28 17:00:51","6862774","4","2","","","","2011-07-28 14:45:54",""
"33195755","Decrypt a TripleDES ciphertext with static KEY and IV through the OpenSSL tool","<p>I have the following snippet that decrypts a string encrypted with 3DES:</p>

<pre><code>private static byte[] KEY_192 = new byte[]
{
    37, 19, 88, 164, 71, 3, 227, 30, 19,
    174, 45, 84, 23, 253, 149, 108, 12,
    107, 16, 192, 98, 22, 179, 200
};

private static byte[] IV_192 = new byte[]
{
    47, 108, 239, 71, 33, 98, 177, 13,
    36, 51, 69, 88, 189, 17, 210, 14,
    174, 230, 20, 60, 174, 100, 12, 22
};

public static string DecryptTripleDES(string value)
{
    if (!string.IsNullOrEmpty(value))
    {
        System.Security.Cryptography.TripleDESCryptoServiceProvider cryptoProvider = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
        byte[] buffer = System.Convert.FromBase64String(value);
        System.IO.MemoryStream ms = new System.IO.MemoryStream(buffer);
        System.Security.Cryptography.CryptoStream cs = new System.Security.Cryptography.CryptoStream(ms, cryptoProvider.CreateDecryptor(DataEncryptionEngine.KEY_192, DataEncryptionEngine.IV_192), System.Security.Cryptography.CryptoStreamMode.Read);
        System.IO.StreamReader sr = new System.IO.StreamReader(cs);
        return sr.ReadToEnd();
    }
    return null;
}
</code></pre>

<p>I'm trying to replicate it with Openssl or Ruby but with no luck, an example of encrypted base64 encoded string is:</p>

<pre><code>JDiLOoP3iIY=
</code></pre>

<p>When trying this under Linux I'm getting the following error.</p>

<blockquote>
  <p>$ echo JDiLOoP3iIY= | openssl enc -d -des3 -a -K
  371988164713227301917445842325314910812107161929822179200 -iv
  471082397133981771336516988189172101417423020601741001222; hex string
  is too long invalid hex iv value</p>
</blockquote>

<p>What am I missing? Thanks!</p>

<p>Edit: If it helps, this is the function that encrypts the string:</p>

<pre><code>public static string EncryptTripleDES(string value)
{
    if (!string.IsNullOrEmpty(value))
    {
        System.Security.Cryptography.TripleDESCryptoServiceProvider cryptoProvider = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
        System.IO.MemoryStream ms = new System.IO.MemoryStream();
        System.Security.Cryptography.CryptoStream cs = new System.Security.Cryptography.CryptoStream(ms, cryptoProvider.CreateEncryptor(DataEncryptionEngine.KEY_192, DataEncryptionEngine.IV_192), System.Security.Cryptography.CryptoStreamMode.Write);
        System.IO.StreamWriter sw = new System.IO.StreamWriter(cs);
        sw.Write(value);
        sw.Flush();
        cs.FlushFinalBlock();
        ms.Flush();
        return System.Convert.ToBase64String(ms.GetBuffer(), 0, System.Convert.ToInt32(ms.Length));
    }
    return null;
}
</code></pre>

<p>Tried this on ruby too, same, I get 'bad decrypt'</p>

<pre><code>#!/usr/bin/env ruby

require 'openssl'
require 'base64'

string = 'JDiLOoP3iIY='

def decrypt(cpass)
  cipher = OpenSSL::Cipher::Cipher.new(""des-ede-cbc"")
  cipher.decrypt
  cipher.key = ""251358A44703E31E13AE2D5417FD956C0C6B10C06216B3C8""
  cipher.iv = ""2F6CEF472162B10D24334558BD11D20EAEE6143CAE640C16""
  return cipher.update(Base64.decode64(cpass)) + cipher.final
end

decrypted = decrypt(string)

puts ""decrypted string: #{decrypted}""
</code></pre>
","<ol>
<li><p>The IV size needs to match the block-size, not the key size. So 3DES needs 64 bit IVs, not 192 bit IVs.</p>

<p>I guess that your existing code simply ignores everything beyond the first 64 bits. Try truncating it to 64 bits (16 hex characters) in rubu/OpenSSL.</p></li>
<li><p>You didn't convert these to hex correctly. The values in C# are decimal, you can't simply concatenate them to form a hex string.</p>

<p>Converting to hex I'm getting:</p>

<pre><code>Key = 25-13-58-A4-47-03-E3-1E-13-AE-2D-54-17-FD-95-6C-0C-6B-10-C0-62-16-B3-C8
IV  = 2F-6C-EF-47-21-62-B1-0D-24-33-45-58-BD-11-D2-0E-AE-E6-14-3C-AE-64-0C-16
</code></pre>

<p>So I guess you need to use</p>

<pre><code>Key = 251358A44703E31E13AE2D5417FD956C0C6B10C06216B3C8
IV  = 2F6CEF472162B10D
</code></pre></li>
<li><p>The C# output is Base64 encoded. I don't see anything Base64 related in your ruby code.</p></li>
<li>I don't know what the default padding for ruby is, but for C# it's PKCS#5 / PKCS#7 padding (those are two names for the same thing).</li>
</ol>

<hr>

<p>This is not secure. Using a static IV misses the point of an IV, which should be different for each message. And it lacks a MAC, so it suffers from active attacks, including padding oracles. And finally 64 bit block ciphers shouldn't encrypt more that a few GB using a single key.</p>
","1560","<c#><ruby><encryption><openssl><3des>","0","2","2","2015-10-19 05:04:24","33195783","2","","608639","","2015-10-19 05:04:24","2015-10-18 08:19:24",""
"33195755","Decrypt a TripleDES ciphertext with static KEY and IV through the OpenSSL tool","<p>I have the following snippet that decrypts a string encrypted with 3DES:</p>

<pre><code>private static byte[] KEY_192 = new byte[]
{
    37, 19, 88, 164, 71, 3, 227, 30, 19,
    174, 45, 84, 23, 253, 149, 108, 12,
    107, 16, 192, 98, 22, 179, 200
};

private static byte[] IV_192 = new byte[]
{
    47, 108, 239, 71, 33, 98, 177, 13,
    36, 51, 69, 88, 189, 17, 210, 14,
    174, 230, 20, 60, 174, 100, 12, 22
};

public static string DecryptTripleDES(string value)
{
    if (!string.IsNullOrEmpty(value))
    {
        System.Security.Cryptography.TripleDESCryptoServiceProvider cryptoProvider = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
        byte[] buffer = System.Convert.FromBase64String(value);
        System.IO.MemoryStream ms = new System.IO.MemoryStream(buffer);
        System.Security.Cryptography.CryptoStream cs = new System.Security.Cryptography.CryptoStream(ms, cryptoProvider.CreateDecryptor(DataEncryptionEngine.KEY_192, DataEncryptionEngine.IV_192), System.Security.Cryptography.CryptoStreamMode.Read);
        System.IO.StreamReader sr = new System.IO.StreamReader(cs);
        return sr.ReadToEnd();
    }
    return null;
}
</code></pre>

<p>I'm trying to replicate it with Openssl or Ruby but with no luck, an example of encrypted base64 encoded string is:</p>

<pre><code>JDiLOoP3iIY=
</code></pre>

<p>When trying this under Linux I'm getting the following error.</p>

<blockquote>
  <p>$ echo JDiLOoP3iIY= | openssl enc -d -des3 -a -K
  371988164713227301917445842325314910812107161929822179200 -iv
  471082397133981771336516988189172101417423020601741001222; hex string
  is too long invalid hex iv value</p>
</blockquote>

<p>What am I missing? Thanks!</p>

<p>Edit: If it helps, this is the function that encrypts the string:</p>

<pre><code>public static string EncryptTripleDES(string value)
{
    if (!string.IsNullOrEmpty(value))
    {
        System.Security.Cryptography.TripleDESCryptoServiceProvider cryptoProvider = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
        System.IO.MemoryStream ms = new System.IO.MemoryStream();
        System.Security.Cryptography.CryptoStream cs = new System.Security.Cryptography.CryptoStream(ms, cryptoProvider.CreateEncryptor(DataEncryptionEngine.KEY_192, DataEncryptionEngine.IV_192), System.Security.Cryptography.CryptoStreamMode.Write);
        System.IO.StreamWriter sw = new System.IO.StreamWriter(cs);
        sw.Write(value);
        sw.Flush();
        cs.FlushFinalBlock();
        ms.Flush();
        return System.Convert.ToBase64String(ms.GetBuffer(), 0, System.Convert.ToInt32(ms.Length));
    }
    return null;
}
</code></pre>

<p>Tried this on ruby too, same, I get 'bad decrypt'</p>

<pre><code>#!/usr/bin/env ruby

require 'openssl'
require 'base64'

string = 'JDiLOoP3iIY='

def decrypt(cpass)
  cipher = OpenSSL::Cipher::Cipher.new(""des-ede-cbc"")
  cipher.decrypt
  cipher.key = ""251358A44703E31E13AE2D5417FD956C0C6B10C06216B3C8""
  cipher.iv = ""2F6CEF472162B10D24334558BD11D20EAEE6143CAE640C16""
  return cipher.update(Base64.decode64(cpass)) + cipher.final
end

decrypted = decrypt(string)

puts ""decrypted string: #{decrypted}""
</code></pre>
","<p>Thanks to CodesInChaos, I solved my problem.</p>

<ol>
<li><p>OpenSSL:</p>

<pre><code>echo JDiLOoP3iIY= | openssl enc -d -des3 -a -K 251358A44703E31E13AE2D5417FD956C0C6B10C06216B3C8 -iv 2F6CEF472162B10D;
</code></pre></li>
</ol>

<p>output:</p>

<blockquote>
  <p>792</p>
</blockquote>

<ol start=""2"">
<li><p>Ruby:</p>

<pre><code>require 'openssl'
require 'base64'

string = 'JDiLOoP3iIY='

def decrypt(cpass)
  cipher = OpenSSL::Cipher::Cipher.new(""des3"")
  cipher.decrypt
  cipher.key = ""37,19,88,164,71,3,227,30,19,174,45,84,23,253,149,108,12,107,16,192,98,22,179,200"".split(',').map { |x| x.to_i }.pack('c*')
  cipher.iv = ""47,108,239,71,33,98,177,13"".split(',').map { |x| x.to_i }.pack('c*')
  return cipher.update(Base64.decode64(cpass)) + cipher.final
end

decrypted = decrypt(string)

puts ""decrypted string: #{decrypted}""
</code></pre></li>
</ol>

<p>Output:</p>

<blockquote>
  <p>decrypted string: 792</p>
</blockquote>
","1560","<c#><ruby><encryption><openssl><3des>","0","0","2","2015-10-19 05:04:24","33195783","2","","608639","","2015-10-19 05:04:24","2015-10-18 08:19:24",""
"7914231","Error in converting to hex and then back to normal string","<p>I am using the following code for a my sampled 3DES encryption I am using:</p>

<pre><code>package Algorithms;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class MyDES {
    public static String encrypt(String pass,String plainText) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{
        byte[] key = pass.getBytes(""UTF-8""); //get byte arrays of the given password
        MessageDigest sha = MessageDigest.getInstance(""SHA-1""); //get SHA-1 hashing instance
        key=sha.digest(key); //has the given password
        key=Arrays.copyOf(key,24);//take the first 16 bytes as the key for DES encryption

        SecretKeySpec sks = new SecretKeySpec(key, ""DESede"");//key spec for 3-DES
        Cipher c = Cipher.getInstance(""DESede"");//get an instance of 3DES
        c.init(Cipher.ENCRYPT_MODE,sks); //initialize 3DES to encrypt mode with given parameters
        byte[] cipherTextBytes = c.doFinal(plainText.getBytes()); //encrypt

        System.out.println(""key used: ""+new String(key)+"" cipher generated ""+new String(cipherTextBytes));
        StringBuffer cipherText= new StringBuffer();
        for(int i=0;i&lt;cipherTextBytes.length;i++)
        {
            cipherText.append(Integer.toHexString(cipherTextBytes[i]));
        }

        System.out.println(""Final Cipher returned: ""+cipherText.toString());
        return cipherText.toString();
    }

    public static String decrypt(String pass,String cipherText) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{
        System.out.println(""Initially in decryption-&gt; pass:""+pass+"" cipher: ""+cipherText);
        byte[] byteArray = new byte[cipherText.length() / 2];
        int j=0;
        for(int k=0;k&lt;cipherText.length()-1;k+=2)
        {
            String o= cipherText.substring(k,k+2);
            int dec = Integer.parseInt(o,16);
            byteArray[j++] = (byte)dec;
        }

        String plainText="""";
        byte[] key = pass.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key=sha.digest(key);
        key=Arrays.copyOf(key,24);
        System.out.println(""\nkey obtained: ""+new String(key)+""\n Later cipher text:-&gt; ""+new String(byteArray));

        SecretKeySpec sks = new SecretKeySpec(key, ""DESede"");
        Cipher c = Cipher.getInstance(""DESede"");
        c.init(Cipher.DECRYPT_MODE,sks);
        plainText = new String(c.doFinal(byteArray));
        return plainText;
    }

}
</code></pre>

<p>Here I am trying to take a password, hash it using SHA-1 and then use the generated has as a key to my 3DES. The generated cipher is being converted to hexadecimal representation as I having trouble saving and retrieving the strange characters in the cipher.</p>

<p>In decryption I am converting the cipher from hexadecimal to normal string again and then decrypting it. But I am getting a <code>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher</code> Exception. Any idea where I am wrong?</p>
","<p>Ah i think i got it.
Try to simplify your code a bit, is hard to read.
Avoid using strings and work as much as you can with arrays, when you have to work with binary data is better to use byte arrays.</p>

<p>Isolate the problems! Split your program in smaller functions that does simpler task.</p>

<p>You can use a standard Base64 encoder to do that. See <a href=""http://www.docjar.com/docs/api/sun/misc/BASE64Encoder.html"" rel=""nofollow"">http://www.docjar.com/docs/api/sun/misc/BASE64Encoder.html</a>
Base64 is of course shorter than hex encoding.</p>

<p>If you want to go on with the HEX conversion try to use these functions i found on google: <a href=""http://www.developerfeed.com/javacore/blog/how-convert-hex-string-bytes-and-viceversa-java"" rel=""nofollow"">http://www.developerfeed.com/javacore/blog/how-convert-hex-string-bytes-and-viceversa-java</a></p>

<p>I tried to simplify the code a little.
Instead of new sun.misc.BASE64Encoder().encode() or decode() you can use the new encoding functions you are going to write.</p>

<pre><code>private static byte[] getPassKey(String pass)
{
    byte[] passKey = pass.getBytes(""UTF-8""); //get byte arrays of the given password
    byte[] shaKey = MessageDigest.getInstance(""SHA-1"").digest(passKey); 
    return Arrays.copyOf(shaKey,24);
}

public static String encrypt(String pass, String plainText) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{

    Cipher desCipher = Cipher.getInstance(""DESede"");
    desCipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getPassKey(pass), ""DESede"")); 

    byte[] cipherTextBytes = desCipher.doFinal(plainText.getBytes());
    String encoded = new sun.misc.BASE64Encoder().encode(cipherTextBytes);

    return encoded;
}

public static String decrypt(String pass,String cipherText) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{

    byte[] decoded = new sun.misc.BASE64Encoder().decode(cipherText);

    Cipher desCipher = Cipher.getInstance(""DESede"");
    desCipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(getPassKey(pass), ""DESede""));
    plainText = new String(desCipher.doFinal(decoded));
    return plainText;
}
</code></pre>

<p>Not tested, just written by scratch in notepad.</p>
","1552","<java><hex><3des>","1","2","2","2017-04-11 08:40:03","7914284","0","3","472495","","2017-04-11 08:40:03","2011-10-27 09:48:56",""
"7914231","Error in converting to hex and then back to normal string","<p>I am using the following code for a my sampled 3DES encryption I am using:</p>

<pre><code>package Algorithms;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class MyDES {
    public static String encrypt(String pass,String plainText) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{
        byte[] key = pass.getBytes(""UTF-8""); //get byte arrays of the given password
        MessageDigest sha = MessageDigest.getInstance(""SHA-1""); //get SHA-1 hashing instance
        key=sha.digest(key); //has the given password
        key=Arrays.copyOf(key,24);//take the first 16 bytes as the key for DES encryption

        SecretKeySpec sks = new SecretKeySpec(key, ""DESede"");//key spec for 3-DES
        Cipher c = Cipher.getInstance(""DESede"");//get an instance of 3DES
        c.init(Cipher.ENCRYPT_MODE,sks); //initialize 3DES to encrypt mode with given parameters
        byte[] cipherTextBytes = c.doFinal(plainText.getBytes()); //encrypt

        System.out.println(""key used: ""+new String(key)+"" cipher generated ""+new String(cipherTextBytes));
        StringBuffer cipherText= new StringBuffer();
        for(int i=0;i&lt;cipherTextBytes.length;i++)
        {
            cipherText.append(Integer.toHexString(cipherTextBytes[i]));
        }

        System.out.println(""Final Cipher returned: ""+cipherText.toString());
        return cipherText.toString();
    }

    public static String decrypt(String pass,String cipherText) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{
        System.out.println(""Initially in decryption-&gt; pass:""+pass+"" cipher: ""+cipherText);
        byte[] byteArray = new byte[cipherText.length() / 2];
        int j=0;
        for(int k=0;k&lt;cipherText.length()-1;k+=2)
        {
            String o= cipherText.substring(k,k+2);
            int dec = Integer.parseInt(o,16);
            byteArray[j++] = (byte)dec;
        }

        String plainText="""";
        byte[] key = pass.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key=sha.digest(key);
        key=Arrays.copyOf(key,24);
        System.out.println(""\nkey obtained: ""+new String(key)+""\n Later cipher text:-&gt; ""+new String(byteArray));

        SecretKeySpec sks = new SecretKeySpec(key, ""DESede"");
        Cipher c = Cipher.getInstance(""DESede"");
        c.init(Cipher.DECRYPT_MODE,sks);
        plainText = new String(c.doFinal(byteArray));
        return plainText;
    }

}
</code></pre>

<p>Here I am trying to take a password, hash it using SHA-1 and then use the generated has as a key to my 3DES. The generated cipher is being converted to hexadecimal representation as I having trouble saving and retrieving the strange characters in the cipher.</p>

<p>In decryption I am converting the cipher from hexadecimal to normal string again and then decrypting it. But I am getting a <code>javax.crypto.IllegalBlockSizeException: Input length must be multiple of 8 when decrypting with padded cipher</code> Exception. Any idea where I am wrong?</p>
","<p>The problem is hidden under several layers.</p>

<pre><code>    StringBuilder sb = new StringBuilder();
      ...
        sb.append((char)dec);
</code></pre>

<p>So you try to assemble the raw binary data by calling StringBuilder.Append(char). Well, what does that do?</p>

<p>The docs for <a href=""http://download.oracle.com/javase/1,5.0/docs/api/java/lang/StringBuilder.html#append%28char%29"" rel=""nofollow"">StringBuilder.Append(char)</a> say ""The overall effect is exactly as if the argument were converted to a string by the method String.valueOf(char) and the character in that string were then appended to this character sequence.""</p>

<p>Okay, so what does the documentation for <a href=""http://download.oracle.com/javase/1,5.0/docs/api/java/lang/String.html#valueOf%28char%29"" rel=""nofollow"">String.valueOf(char)</a> say? I'm glad you asked. It says it ""Returns: a String of length 1 containing as its single character the argument c."" (And you can see, the return type is 'String'.)</p>

<p>Ahh, but how does a String value work? Well, let's check the <a href=""http://download.oracle.com/javase/1,5.0/docs/api/java/lang/String.html"" rel=""nofollow"">documentation on that</a>. It says, ""A String represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the Character class for more information). Index values refer to char code units, so a supplementary character uses two positions in a String.""</p>

<p>So that's the problem. You are converting the raw binary ciphertext into UTF-16 characters and surrogate pairs, which is certainly not what you want.</p>
","1552","<java><hex><3des>","1","3","2","2017-04-11 08:40:03","7914284","0","3","472495","","2017-04-11 08:40:03","2011-10-27 09:48:56",""
"11763112","C# TripleDES incorrect Input Length when decrypting","<p>I get no error when I encrypt a string but, 
I get an error when I try to decrypt the string, it says that the Input.Length is invalid. Any ideas?</p>

<pre><code>public class Crypt
    {
        public string Encrypt(string Key, string Input)
        {
            ICryptoTransform crypted = tran(Key).CreateEncryptor();
            UTF8Encoding utf8 = new UTF8Encoding();
            return utf8.GetString(crypted.TransformFinalBlock(utf8.GetBytes(Input), 0, Input.Length));
        }
        public string Decrypt(string Key, string Input)
        {
            ICryptoTransform crypted = tran(Key).CreateDecryptor();
            UTF8Encoding utf8 = new UTF8Encoding();
            return utf8.GetString(crypted.TransformFinalBlock(utf8.GetBytes(Input), 0, Input.Length));
        }
        private TripleDESCryptoServiceProvider tran(string Key)
        {
            MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();
            UTF8Encoding utf8 = new UTF8Encoding();
            TripleDESCryptoServiceProvider tDES = new TripleDESCryptoServiceProvider();
            tDES.Key = md5.ComputeHash(utf8.GetBytes(Key));
            tDES.Mode = CipherMode.ECB;
            tDES.Padding = PaddingMode.PKCS7;
            return tDES;
        }
    }
</code></pre>
","<p>The bytes returned by the encryption process are not UTF8, but you're treating them as such. If you want a textual representation of the encrypted data, you'll need to do a little more than simply converting arbitrary bytes to UTF8.</p>

<p>Skeet's answer <a href=""https://stackoverflow.com/questions/7996955/encoding-to-use-to-convert-bytes-array-to-string-and-vice-versa"">here</a> should set you on your way.</p>
","1541","<c#><encryption><3des><tripledes>","1","3","1","2012-08-02 14:13:54","","1","","396200","","2012-08-02 14:13:54","2012-08-01 15:58:33",""
"11420945","3des java encryption/decryption with salt and iterations","<p>In the decrypt class, I cant get it to correctly decrypt. I've verified in the decrypt class that my salt and my ciphertext still carries the same values before I convert them back to bytes. </p>

<p>The program itself doesn't given an error however when I compile, I'll encrypt, save it to the string encryptPhrase and then decrypt it in the decrypt method and I cant seem to get it to decrypt properly. I've marked in comments where the issue is and gives a badpadding exception, however there is no padding?</p>

<p>The odd thing is... if i take out everything in the decrypt method and return just encryptPhrase, it actually returns the correct plain text.</p>

<p>Any help would be appreciated. Thanks! :) </p>

<pre><code>import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.util.*;

public class PasswordEncryption {

private static int ITERATIONS = 1000;
private static String saltString;
private static String ciphertextString;
private static String encryptPhrase;

private static void usage(){
    System.err.println(""Usage: java PBE -e|-d password text"");
    System.exit(1);
}

public static void main(String[] args) throws Exception{

    scan = new Scanner(System.in);

    System.out.println(""Please enter plain text: "");
    String text = scan.nextLine();
    System.out.println(""Please enter password to encrypt plain text: "");

    char [] pw = scan.nextLine().toCharArray();
    int option=3;

    while (option!=0){
    System.out.println(""Are we encrypting(1) or decrypting(2) or Exit(0)? "" );
    option = scan.nextInt();
    String output=""exiting program"";

    if (option == 1)
        output = encrypt(pw, text);
    else if (option ==2)
        output = decrypt(pw,text);
    System.out.println(""Output: "" +output);
    }

}
private static Scanner scan;

private static String encrypt(char[] password, String plaintext) throws Exception {

    //create random salt
    byte[]  salt = new byte[8];
    SecureRandom random = new SecureRandom();
    random.nextBytes(salt);

    //create key based on password
    int iterationCount = ITERATIONS;
    PBEKeySpec pbeSpec = new PBEKeySpec(password, salt, iterationCount);
    SecretKeyFactory keyFact = SecretKeyFactory.getInstance(""PBEWithSHAAnd3KeyTripleDES"");

    //create a cipher
    Cipher myCipher = Cipher.getInstance(""PBEWithSHAAnd3KeyTripleDES"");

    Key encryptKey = keyFact.generateSecret(pbeSpec);
    myCipher.init(Cipher.ENCRYPT_MODE, encryptKey);

    byte[] cipherText = myCipher.doFinal();
    System.out.println(""Encrypted Text: "" +toString(cipherText));

    //produce salt to string
    saltString = salt.toString();
    System.out.println(""SALT: "" +saltString);

    //produce cipher text to string
    ciphertextString = toString(cipherText);

    //stores salt and cipher string in encryptPhrase
    encryptPhrase = saltString+ciphertextString;

    return saltString+ciphertextString;
}

public static String decrypt(char[] password, String encryptPhrase) throws Exception{
    //split the encryption data into salt and ciphertext
    //System.out.println(""encrypt Phrase: "" +encryptPhrase);


    //convert salt into bytearray
    byte[] bsalt = toByteArray(saltString);
    //convert ciphertext into bytearray
    byte[] bciphert= toByteArray(ciphertextString);

    //produce cipher

    /////////////////////////////////////////////////////////////////////       
    int iterationCount = ITERATIONS;
    PBEKeySpec pbeSpec = new PBEKeySpec(password, bsalt, iterationCount);
    //use SHA and 3DES

    //create the key
    SecretKeyFactory keyFact = SecretKeyFactory.getInstance(""PBEWithSHAAnd3KeyTripleDES"");
    Cipher cDec = Cipher.getInstance(""PBEWithSHAAnd3KeyTripleDES"");
    Key sKey = keyFact.generateSecret(pbeSpec);

    //perform decryption
    cDec.init(cDec.DECRYPT_MODE,sKey);

    byte [] plainTextb = cDec.doFinal(bciphert); //gives me an error here. Says BadPaddingException: pad block corrupted?

    String plainText = toString(plainTextb); 

    return plainText;
    //return encryptPhrase;

}

/**
 * Convert a byte array of 8 bit characters into a String.
 * 
 *@param bytes the array containing the characters
 * @param length the number of bytes to process
 * @return a String representation of bytes
 */
public static String toString(byte[] bytes, int length)
{
    char[]  chars = new char[length];

    for (int i = 0; i != chars.length; i++)
    {
        chars[i] = (char)(bytes[i] &amp; 0xff);
    }

    return new String(chars);
}

/**
 * Convert a byte array of 8 bit characters into a String.
 * 
 * @param bytes the array containing the characters
 * @return a String representation of bytes
 */
public static String toString( byte[]   bytes)
{
    return toString(bytes, bytes.length);
}

/**
 * Convert the passed in String to a byte array by
 * taking the bottom 8 bits of each character it contains.
 * 
 * @param string the string to be converted
 * @return a byte array representation
 */
public static byte[] toByteArray(String string)
{
    byte[]  bytes = new byte[string.length()];
    char[]  chars = string.toCharArray();

    for (int i = 0; i != chars.length; i++)
    {
        bytes[i] = (byte)chars[i];
    }

    return bytes;
}
private static String digits = ""0123456789abcdef"";

public static String toHex(byte[] data, int length)
{
    StringBuffer buf = new StringBuffer();

    for (int i=0; i!= length; i++)
    {
        int v = data[i] &amp; 0xff;

        buf.append(digits.charAt(v &gt;&gt;4));
        buf.append(digits.charAt(v &amp; 0xf));
    }
    return buf.toString();

}

/**
 * Return the passed in byte array as a hex string.
 * 
 * @param data the bytes to be converted.
 * @return a hex representation of data.
 */

public static String toHex(byte[] data)
{
    return toHex(data, data.length);
}
}
</code></pre>
","<p>Yet another confusion between bytes and characters. Could have guessed. Please look up the base 64 encoding and see why it exists. Then note the implementation of <code>Object.toString()</code> and lookup character encoding (don't use <code>new String(byte[])</code> on randomized bytes).</p>
","1519","<java><encryption><3des>","0","2","1","2012-07-10 23:06:58","","0","3","","","","2012-07-10 19:57:45",""
"21426829","3DES Encryption / Decryption using ECB in iOS","<p>i'm making an application , in which i have to encrypt a string using 3DES encryption in ECB mode. i m using ""mykey"" as a key.</p>

<pre><code>+ (NSData *)tripleDesEncryptData:(NSData *)inputData
                             key:(NSData *)keyData
                           error:(NSError **)error
{
NSParameterAssert(inputData);
NSParameterAssert(keyData);

size_t outLength;

NSAssert(keyData.length == kCCKeySize3DES, @""the keyData is an invalid size"");

NSMutableData *outputData = [NSMutableData dataWithLength:(inputData.length  +  kCCBlockSize3DES)];

CCCryptorStatus
    result = CCCrypt(kCCEncrypt, // operation
                     kCCAlgorithm3DES, // Algorithm
                     0, // options
                     keyData.bytes, // key
                     keyData.length, // keylength
                     nil,// iv
                     inputData.bytes, // dataIn
                     inputData.length, // dataInLength,
                     outputData.mutableBytes, // dataOut
                     outputData.length, // dataOutAvailable
                     &amp;outLength); // dataOutMoved

    if (result != kCCSuccess) {
        if (error != NULL) {
            *error = [NSError errorWithDomain:@""com.your_domain.your_project_name.your_class_name.""
                                         code:result
                                     userInfo:nil];
        }
        return nil;
    }
    [outputData setLength:outLength];
    NSLog(@""here is my output %@"",outputData);
    return outputData;
}
</code></pre>

<p>i am getting an exception because of invalid Key size. (i'm using this 'mykey' as my key). I'm not expert in encryption. Any kind of Help will be highly appreciated.</p>
","<p>You're getting ""invalid key size"" because, well, your key is an invalid size. I'm not sure what else you were expecting the system to tell you. The 3DES algorithm expects a key size of 24 bytes and ""mykey"" is too short.</p>

<p>Even apart from the length issue, in general it is a bad idea to directly use strings as cryptographic keys. Instead you should use an accepted password-to-key algorithm such as PBKDF2.</p>
","1512","<ios><encryption><3des>","3","2","1","2014-01-29 16:56:31","","1","","","","","2014-01-29 09:24:27",""
"10242487","Decrypting Java 3DES ECB NoPadding encrypted value in PHP","<p>I have a 3des encrypted hex string which I get from a server. When I decrypt it with Java ECB/NoPadding, I get the expected value, but when I try to decrypt it with PHP I am getting a different value. This is the PHP code:</p>

<pre><code>&lt;?php

$key = ""428982f4658cfeb679bae2bf85ebcde9"";
$input = ""9CB39217A434F6339EF27C503B561342"";
$encrypted_data = bin2hex(
    mcrypt_ecb(MCRYPT_3DES, pack(""H*"", $key), pack(""H*"", $input), MCRYPT_DECRYPT)
);

?&gt;
</code></pre>

<p>and part of the java code starting with main:</p>

<pre><code>String input = ""F414E86894D996F8658F9327C8EC786404192012174729"";
String key = ""05aa58f38a0883d1439750a2495d36ad"";

byte2hex(doCryto(""F414E86894D996F8658F9327C8EC7864"",  ""05aa58f38a0883d1439750a2495d36ad"", Cipher.DECRYPT_MODE));

public static byte[] doCryto(String data, String key, int CipherMode) throws Exception {
    byte result[];
    try {
        byte data1[] = hex2byte(data);
        Key key1 = formDESKey(key);
        transformation = key1.getAlgorithm() + ""/ECB/NoPadding"";

        Cipher c1 = Cipher.getInstance(transformation);
        c1.init(CipherMode, key1);
        result = c1.doFinal(data1);
    } catch (Exception e) {
        throw new Exception(e);
    }
    return result;
}

public static Key formDESKey(String key) throws Exception {
    short len = (short) ((key.length() / 2) * 8);
    return formDESKey(len, hex2byte(key));
}

  public static Key formDESKey(short keyLength, byte clearKeyBytes[]) throws Exception {
    Key key = null;
    switch (keyLength) {
        case 64: // '@'
            key = new SecretKeySpec(clearKeyBytes, ""DES"");
            break;

        case 128:
            clearKeyBytes = concat(clearKeyBytes, 0, 128/8, clearKeyBytes, 0, getBytesLength((short) 64));
        // fall through

        case 192:
            key = new SecretKeySpec(clearKeyBytes, ""DESede"");
            break;
    }
    if (key == null) {
        throw new Exception(""Unsupported DES key length: "" + keyLength + "" bits"");
    } else {
        return key;
    }
}

private static byte[] concat(byte array1[], int beginIndex1, int length1, byte array2[], int beginIndex2, int length2) {
    byte concatArray[] = new byte[length1 + length2];
    System.arraycopy(array1, beginIndex1, concatArray, 0, length1);
    System.arraycopy(array2, beginIndex2, concatArray, length1, length2);
    return concatArray;
}
</code></pre>

<p>Java results in: 31303031464646464646464646464646 <br/>
While PHP results in: 411C689D687F2F118EA05BF234F4E582</p>

<p>I don't know why PHP is getting a different value. Any help would be appreciated.<br/>
Thanks.</p>
","","1480","<java><php><encryption><mcrypt><3des>","2","","0","2012-04-21 11:13:43","","4","","774681","","2012-04-20 11:59:20","2012-04-20 08:07:34",""
"42683230","DESedeKeySpec Wrong key size","<p>I need to use double length 3DES key to encrypt random 8 bytes and then use the encrypted value to derive a new 3DES key. </p>

<p>When I attempt to instantiate the DESedeKeySpec with the encryptedRandomValue, I get an error message ""Wrong key size"". Can you advise me how to fix this issue? </p>

<p>DESedeKeySpec myKeySpec = new DESedeKeySpec(encryptedRandomValue);       </p>

<p>I can avoid getting this error if all my SecretKeys are single DES key. But I need to use double length 3DES key and ECB mode.</p>

<p>Here is my code; </p>

<pre><code>    // Generate double length 3DES Master Key
    KeyGenerator masterEncKeyGenerator = KeyGenerator.getInstance(""DESede"");
    masterEncKeyGenerator.init(112);
    SecretKey masterKey = masterEncKeyGenerator.generateKey();

    //Prepare random bytes
    byte[] randomKeyValue = ""rn4yrbdy"".getBytes();

    // Encrypt random bytes with the 3DES Master key
    final Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, masterKey);
    byte[] encryptedRandomValue = cipher.doFinal(randomKeyValue);

    // Derive new key 3DES Key
    SecretKeyFactory mySecretKeyFactory = SecretKeyFactory.getInstance(""DESede"");
    DESedeKeySpec myKeySpec = new DESedeKeySpec(encryptedRandomValue);
    SecretKey derivedKey = mySecretKeyFactory.generateSecret(myKeySpec);
</code></pre>

<p>I realize why I am getting this error. It is because the DESedeKeySpec needs to take in 24 bytes as key material but I am giving it only 8. But that's the requirement I have: to produce a 3DES key out of encrypted, with master 3DES key, random 8 bytes data...</p>
","<p>Triple DES is just 3 consecutive single DES operation done with different keys. Specifically it's a DES encrypt followed by a DES decrypt followed by a DES encrypt.</p>

<p><strong>DES</strong> <strong>e</strong>ncrypt-<strong>d</strong>ecrypt-<strong>e</strong>ncrypt is what gives it the name <strong>DESede</strong></p>

<p>The difference betwheen double length and tripple length keys is what part of the key you use in each of the three DES operation.</p>

<p>A double length key: <code>k1 || k2</code> would give the following DES operations:</p>

<pre><code>Encrypt(k1) - Decrypt(k2) - Encrypt(k1)
</code></pre>

<p>A tripple length key: <code>k1 || k2 || k3</code> would give the following DES operations:</p>

<pre><code>Encrypt(k1) - Decrypt(k2) - Encrypt(k3)
</code></pre>

<p>The standard implementation in Java don't support double length triple DES keys directly but you can get the same effect by repeating the first part of the key as the third part: <code>k1 || k2 || k1</code></p>

<p>As a curiosity you can support single DES encryption via tripple DES by repeating the single DES key three times like: <code>k1 || k1 || k1</code>. This simplifies backword compatibility in e.g. hardware implementations. </p>
","1440","<java><encryption><3des><secret-key><key-generator>","0","3","1","2017-03-09 00:35:42","","0","2","441893","","2017-03-08 23:20:16","2017-03-08 22:35:46",""
"16335223","NoSuchProviderException when encrypting string with 3DES","<p>I am new to Java. I followed this <a href=""http://ttux.net/post/3des-java-encrypter-des-java-encryption/"" rel=""nofollow"">tutorial</a> about Encryption and Decryption using 3DES algorithm.</p>

<p>I have implemented like this:</p>

<ol>
<li>Created a class and placed the 3DES code provided in the above link.</li>
<li><p>Called the encrypt method in the above link as below:</p>

<pre><code>String encryptedPassword = Encrypter.encrypt(edtText.getText().toString()); 
</code></pre></li>
</ol>

<p>I am getting the exception in logcat as below:</p>

<pre><code> 05-02 15:19:10.804: W/System.err(4445): java.security.NoSuchProviderException: Provider not available: SunJCE
    05-02 15:19:10.820: W/System.err(4445):     at javax.crypto.Cipher.getInstance(Cipher.java:209)
    05-02 15:19:10.820: W/System.err(4445):     at com.example.utilities.Encrypter.encrypt(Encrypter.java:46)
    05-02 15:19:10.820: W/System.err(4445):     at com.example.screens.RegisterScreen.onClick(RegisterScreen.java:152)
    05-02 15:19:10.820: W/System.err(4445):     at android.view.View.performClick(View.java:2485)
    05-02 15:19:10.820: W/System.err(4445):     at android.view.View$PerformClick.run(View.java:9080)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Handler.handleCallback(Handler.java:587)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Handler.dispatchMessage(Handler.java:92)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Looper.loop(Looper.java:130)
    05-02 15:19:10.828: W/System.err(4445):     at android.app.ActivityThread.main(ActivityThread.java:3687)
    05-02 15:19:10.835: W/System.err(4445):     at java.lang.reflect.Method.invokeNative(Native Method)
    05-02 15:19:10.835: W/System.err(4445):     at java.lang.reflect.Method.invoke(Method.java:507)
    05-02 15:19:10.835: W/System.err(4445):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:867)
    05-02 15:19:10.835: W/System.err(4445):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:625)
    05-02 15:19:10.835: W/System.err(4445):     at dalvik.system.NativeStart.main(Native Method)
</code></pre>

<p>Please help me. How to solve this....</p>
","<p>Use this code to encrypt your string</p>

<pre><code>    import javax.crypto.Cipher;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    import android.util.Base64;
    //string encryption
    public class EncryptionHelper {



        // Encrypts string and encode in Base64
        public static String encryptText(String plainText) throws Exception {
            // ---- Use specified 3DES key and IV from other source --------------
            byte[] plaintext = plainText.getBytes();//input
            byte[] tdesKeyData = Constants.getKey().getBytes();// your encryption key

            byte[] myIV = Constants.getInitializationVector().getBytes();// initialization vector

            Cipher c3des = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, ""DESede"");
            IvParameterSpec ivspec = new IvParameterSpec(myIV);

            c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);
            byte[] cipherText = c3des.doFinal(plaintext);
            String encryptedString = Base64.encodeToString(cipherText,
                    Base64.DEFAULT);
            // return Base64Coder.encodeString(new String(cipherText));
            return encryptedString;
        }

    private class Constants 
{
private static final String KEY=""QsdPasd45FaSdnLjf"";
    private static final String INITIALIZATION_VECTOR=""l9yhTaWY"";
public static String getKey() 
    {
        return KEY;
    }


    public static String getInitializationVector() 
    {
        return INITIALIZATION_VECTOR;
    }
 }   
    }
</code></pre>

<p>This is how you can encrypt the string</p>

<pre><code>String encryptedPassword = EncryptionHelper.encryptText(edtText.getText().toString());
</code></pre>
","1429","<java><android><encryption><3des>","0","0","2","2013-05-29 09:38:47","","5","2","928814","","2013-05-29 09:38:47","2013-05-02 10:00:42",""
"16335223","NoSuchProviderException when encrypting string with 3DES","<p>I am new to Java. I followed this <a href=""http://ttux.net/post/3des-java-encrypter-des-java-encryption/"" rel=""nofollow"">tutorial</a> about Encryption and Decryption using 3DES algorithm.</p>

<p>I have implemented like this:</p>

<ol>
<li>Created a class and placed the 3DES code provided in the above link.</li>
<li><p>Called the encrypt method in the above link as below:</p>

<pre><code>String encryptedPassword = Encrypter.encrypt(edtText.getText().toString()); 
</code></pre></li>
</ol>

<p>I am getting the exception in logcat as below:</p>

<pre><code> 05-02 15:19:10.804: W/System.err(4445): java.security.NoSuchProviderException: Provider not available: SunJCE
    05-02 15:19:10.820: W/System.err(4445):     at javax.crypto.Cipher.getInstance(Cipher.java:209)
    05-02 15:19:10.820: W/System.err(4445):     at com.example.utilities.Encrypter.encrypt(Encrypter.java:46)
    05-02 15:19:10.820: W/System.err(4445):     at com.example.screens.RegisterScreen.onClick(RegisterScreen.java:152)
    05-02 15:19:10.820: W/System.err(4445):     at android.view.View.performClick(View.java:2485)
    05-02 15:19:10.820: W/System.err(4445):     at android.view.View$PerformClick.run(View.java:9080)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Handler.handleCallback(Handler.java:587)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Handler.dispatchMessage(Handler.java:92)
    05-02 15:19:10.828: W/System.err(4445):     at android.os.Looper.loop(Looper.java:130)
    05-02 15:19:10.828: W/System.err(4445):     at android.app.ActivityThread.main(ActivityThread.java:3687)
    05-02 15:19:10.835: W/System.err(4445):     at java.lang.reflect.Method.invokeNative(Native Method)
    05-02 15:19:10.835: W/System.err(4445):     at java.lang.reflect.Method.invoke(Method.java:507)
    05-02 15:19:10.835: W/System.err(4445):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:867)
    05-02 15:19:10.835: W/System.err(4445):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:625)
    05-02 15:19:10.835: W/System.err(4445):     at dalvik.system.NativeStart.main(Native Method)
</code></pre>

<p>Please help me. How to solve this....</p>
","<p>Sorry, I was being lazy. The line</p>

<pre><code>Cipher ecipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE"");
</code></pre>

<p>shows that you are specifying a particular provider. Normally you would want a very good reason for doing this, for example you might be required to use a FIPS-compliant provider. The SunJCE provider does not exist on Android. Just use the default provider, which you get simply by leaving out that argument. So try:</p>

<pre><code>Cipher ecipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
</code></pre>

<p>Similarly, change</p>

<pre><code>Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"",""SunJCE"");
</code></pre>

<p>to</p>

<pre><code>Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
</code></pre>
","1429","<java><android><encryption><3des>","0","0","2","2013-05-29 09:38:47","","5","2","928814","","2013-05-29 09:38:47","2013-05-02 10:00:42",""
"18908181","Authentication issues w/ MiFare Ultralight C","<p>I am trying to authenticate w/ an NXP MiFare Ultralight C.  My NFC tag reader is an Android phone (Samsung Galaxy Express) but I'm doing all of the crypto on a Windows 7 machine using C# and the functions in the System.Security.Cryptography namespace.</p>

<p>I <strong>DO</strong> have full datasheets (under NDA) on the Ultralight-C.  Understanding them isn't my issue (I don't think) - I'm just not getting what I expect from my crypto functions.  I will need to be a little circumspect on details about the tag, but I don't think the tag is my issue.</p>

<p>Basically what's happening is I initiate an authentication and I get the expected data from the tag.  I do [the stuff] on my side and send a response to the tag using Nfca.Transceive() on the Android.  That function immediately throws a ""transceive failed"" exception, which I take to mean the tag is telling me to take a flying leap.  Other attempts to use Transceive() are successful (writes, initiating authentication, etc).</p>

<p>That the tag is kicking it back is no surprise because my code isn't producing what I expect when using the only test vectors I could find by Googling.</p>

<p>Because of the NDA probably best to just stick with 3DES side of things since that's no secret...  These are from the test data I found online:</p>

<p>Given ek(Data) is 63FC19906A77D13F
and k is 49454D4B41455242214E4143554F5946 
dk(Data) should be c00c24ed61ea0f3e</p>

<p>This isn't what I'm getting from my code, which looks basically like this:</p>

<pre><code>byte[] key = new byte[16] 
                {                 
                    0x49, 0x45, 0x4D, 0x4B, 
                    0x41, 0x45, 0x52, 0x42, 
                    0x21, 0x4E, 0x41, 0x43, 
                    0x55, 0x4F, 0x59, 0x46
                };

byte[] initVector = new byte[8];

byte[] encrypted =  new byte[8] 
                {
                    0x63, 0xFC, 0x19, 0x90,
                    0x6A, 0x77, 0xD1, 0x3F
                }

byte[] result = DecryptSingleBlock(encrypted, key, ref initVector);
</code></pre>

<p>At this point I expect result to contain the result from the test data:  <code>c00c24ed61ea0f3e</code>  but it doesn't.  Its value is:  <code>5bdd317111226152</code></p>

<p>My decryption function:</p>

<pre><code>public byte[] DecryptSingleBlock(byte[] input, byte[] key, ref byte[] initVector)
{


    using (var des = new TripleDESCryptoServiceProvider  
                         {
                             IV = initVector,   // all zeros this time
                             BlockSize = 64,
                             KeySize = 128,
                             Mode = CipherMode.CBC,
                             Padding = PaddingMode.None,
                             Key = key,
                         })
        {
            byte[] output = des.CreateDecryptor().TransformFinalBlock(input, 0, 8);

            return output;
        }
    }
</code></pre>

<p>I have:  </p>

<ul>
<li>Reversed the order of the bytes in the encrypted data;  </li>
<li>Swapped the first 8 bytes of the key with the second 8 bytes;</li>
<li>Toyed with the FeedbackSize (though I am very unclear on what NXP expects or if this is even applicable to CBC mode (which itself shouldn't apply to this single block decryption);</li>
<li>Used CreateEncryptor instead of CreateDecryptor.</li>
<li>Tried to make sense of the LibFreeFare code, though it covers a lot more - I'm just trying to get past this step.</li>
</ul>

<p>I'm at a loss.  Does anyone have any idea what I need to do to the function above to make it return 'c00c24ed61ea0f3e' for the given input and key?  I don't know if I've overlooked something NXP is doing or if I'm falling victim to some special MS-tastic way 3DES is implemented in .NET.   My gut tells me there is some endian-ness issue somewhere but I don't know where or what to do about it other than what I've tried.</p>

<p>Honestly, I'd be happy to get some known-good test vectors (A, B, K, ek(xx+xx)) so I can get my code working before I even bring a tag into the mix.  I have asked NXP for this but they are 8 hours ahead so no response yet and anyway, I have no idea how long their normal response is and whether they'll be able to help at all - I guess that depends on whether it gets routed to the right people.</p>

<p>In the alternative, if someone knows of a step-by-step authentication application note I can ask for through the DocStore, that would be helpful too.  Once again, I'm under the NDA for both Ultralight-C and DESFire so I'm sure they'll provide it if I know what to ask for.</p>

<p>Thanks! </p>
","<p>Okay, I figured this out with the help of some reading about issues someone had while trying to re-create openSSL.NET functionality with pure managed code.  </p>

<p>When creating the TripleDESCryptoServiceProvider do NOT include the key or IV in the class initializer as I did above.  Setting the key or IV before the mode, block size, key size, etc. have been initialized will cause the key, the IV or both to get mangled or truncated or something, resulting in the wonky behavior I was seeing.  I have not experimented further to see what got mangled and how.  </p>

<p>Glad it's fixed but it cost me about 8 hours...  </p>

<p>Here is the way to do it.  I have omitted the other code for clarity.</p>

<pre><code>var des = new TripleDESCryptoServiceProvider  
{
    BlockSize = 64,
    KeySize = 128,
    Mode = CipherMode.CBC,
    Padding = PaddingMode.None,
};

// the important bit is that these properties are 
// being set last
des.IV = initVector;
des.Key = key;
</code></pre>
","1404","<c#><nfc><rfid><mifare><3des>","1","3","1","2013-09-23 03:16:56","18923919","0","","1991516","","2013-09-23 03:16:56","2013-09-20 03:04:52",""
"38848195","Encrypt String with 3DES usingDelphi 10.1 Berlin","<p>I need to encrypt an 10-byte string in Delphi using 3DES.</p>

<p>It must get the same result than this PHP code:</p>

<pre><code>function encrypt_3DES($message, $key){
$bytes = array(0,0,0,0,0,0,0,0);
$iv = implode(array_map(""chr"", $bytes)); 

$ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv); 
return $ciphertext;
</code></pre>

<p>I have been trying to code it using DCPCrypt and LockBox 3. I have finally discarded DCPCrypt because it hasn't been update lately and I'm not sure if it works correctly with Delphi 10.1 Berlin, so I have focused in LockBox 3, but I haven't been able to get the encryption right.</p>

<p>The encryption key is a 24bytes key (which I have its base64 representation). I can't find how to create such key using the TSymetricKey class of LockBox to pass it to an Codec.Init method. So I put it on an AnsiString and set it on the Password property (although the documentations says that there is a utf8Password but I can't find it).</p>

<p>Then there is a method called EncryptAnsiString, but again it expects strings (utf16 on Delphi 10.1 Berlin) instead of AnsiStrings (although the documentation says the contrary), so I'm not surprised that the result doesn't match what I'm looking for (the same value encrypted on that PHP snippet).</p>

<p>This is my Delphi Code :</p>

<pre><code>  function Encrypt(Data: AnsiString; LocalKey: AnsiString): AnsiString;
  var 
    BinaryLocalKey: TBytes;
    strLocalKey, strTripleDes: AnsiString;
  begin
    BinaryLocalKey := DecodeBase64(LocalKey);
    setString(strLocalKey, PAnsiChar(@BinaryLocalKey[0]), Length(BinaryLocalKey));

    Codec1.Rest;
    Codec1.Password := strLocalKey;
    Codec1.EncryptAnsiString(Data, strTripleDES);
    Codec1.Reset;

    Result := strTripleDes;
  end;
</code></pre>

<p>But this Code not only doesn't get the same result as the PHP code, but at every call it returns a different result for the same input.</p>

<p>NOTE: Codec1 is a component linked to a TCryptographicLibrary component, and with the propertis ChainMode set to CBC* and Cipher set to 3DES (Keying option 1)</p>

<p>Does somebody know how to properly get this 3DES encryption ?.</p>

<p>Thank you.</p>
","<p>A random IV is generated for each message. The low 8 bytes of the IV are a nonce and the high bytes are zero. These low 8 bytes are prepended to the output.</p>

<p>If you want to send the IV via a side channel, then strip the first 8 bytes out of the nominal ciphertext.</p>

<p>If you want to control the IV, then use version 3.7.0 (<a href=""https://github.com/SeanBDurkin/tplockbox"" rel=""nofollow noreferrer"">https://github.com/SeanBDurkin/tplockbox</a>). You will need to set the advanced options and implement the OnGetIV method.</p>

<p>The asterisk (*) rendered in the property editors for cipher selection and chain mode selection, mean that this selection is a recommended one.</p>
","1393","<delphi><3des><delphi-10.1-berlin><lockbox-3>","3","1","1","2016-11-17 12:54:06","","9","","6220377","","2016-09-06 11:34:51","2016-08-09 10:24:53",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Probably a lookup table of an Array with 255 entries would be fastest ""In Ruby"" solution.</p>

<p>In C I would mask and shift. Or if I have SSE4 I would use the POPCNT instruction with inline assembler. If you need this to be high performance write a native extension in C which does either of the above.</p>

<p><a href=""http://en.wikipedia.org/wiki/SSE4"" rel=""nofollow"">http://en.wikipedia.org/wiki/SSE4</a></p>
","1381","<ruby><des><3des><parity>","6","3","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Have you taken a look at the <a href=""http://github.com/robertsosinski/ruby-des"" rel=""nofollow"">RubyDES library</a>? That may remove the need to write your own implementation.</p>

<p>To calculate parity, you can use something like the following:</p>

<pre><code>require 'rubygems'
require 'inline'  # RubyInline (install with `gem install RubyInline`)

class Fixnum
  # native ruby version: simpler but slow
  # algorithm from: 
  #   http://graphics.stanford.edu/~seander/bithacks.html#ParityParallel      
  def parity_native
    (((self * 0x0101010101010101) &amp; 0x8040201008040201) % 0x1FF) &amp; 1
  end

  class &lt;&lt; self
    # inline c version using RubyInline to create c extension
    # 4-5 times faster than native version
    # use as class method: 
    #   Fixnum.parity(0xAB)
    inline :C do |builder|
      builder.c &lt;&lt;-EOC
      int parity_c(int num) {  
        return (
            ((num * 0x0101010101010101ULL) &amp; 0x8040201008040201ULL) % 0x1FF
          ) &amp; 1;
      }
      EOC
    end
  end

  def parity
    self.class.parity_c(self)
  end

  def parity_odd?
    1 == parity
  end
  def parity_even?
    0 == parity
  end
end

0xAB.parity        # =&gt; 1 
0xAB.parity_odd?   # =&gt; true 
0xAB.parity_even?  # =&gt; false
(0xAB + 1).parity  # =&gt; 0
</code></pre>

<p>According to simple benchmarks, the inline c version is 3-4 times faster than the native ruby version</p>

<pre><code>require 'benchmark'
n = 10000
Benchmark.bm do |x|
  x.report(""inline c"") do
    n.times do 
      (0..255).map{|num| num.parity}
    end
  end

  x.report(""native ruby"") do
    n.times do 
      (0..255).map{|num| num.parity_native}
    end
  end
end
# inline c     1.982326s
# native ruby  7.044330s
</code></pre>
","1381","<ruby><des><3des><parity>","6","4","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<pre><code>x = 'AB'.to_i(16)
p = 0
until x == 0
  p += x &amp; 1
  x = x &gt;&gt; 1
end
puts p # =&gt; 5
</code></pre>

<p>which can be shortened to</p>

<pre><code>x = 'AB'.to_i(16)
p = x &amp; 1
p += x &amp; 1 until (x &gt;&gt;= 1) == 0
</code></pre>

<p>if you want something that is unreadable ☺</p>
","1381","<ruby><des><3des><parity>","6","1","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>Unless what you have is not fast enough, keep it.  It's clear and succinct, and its performance is better than you think.</p>

<p>We'll benchmark everything against array lookup, the fastest method I tested:</p>

<pre><code>ODD_PARITY = [
  false,
  true,
  true,
  ...
  true,
  false,
]

def odd_parity?(hex_string)
  ODD_PARITY[hex_string.to_i(16)]
end
</code></pre>

<ul>
<li>Array lookup computes the parity at a rate of 640,000 bytes per second.</li>
<li>Bowsersenior's C code computes parity at a rate of 640,000 bytes per second.</li>
<li>Your code computes parity at a rate of 284,000 bytes per second.</li>
<li>Bowsersenior's native code computes parity at a rate of 171,000 bytes per second.</li>
<li>Theo's shortened code computes parity at a rate of 128,000 bytes per second.</li>
</ul>
","1381","<ruby><des><3des><parity>","6","7","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>How about using your original solution with memoization? This will only calculate once for each integer value.</p>

<pre><code>class Fixnum
  # Using a class variable for simplicity, and because subclasses of
  # Fixnum—while very uncommon—would likely want to share it. 
  @@parity = ::Hash.new{ |h,i| h[i] = i.to_s(2).count('1').odd? }
  def odd_parity?
    @@parity[self]
  end
  def even_parity?
    !@@parity[self]
  end
end

""AB"".to_i(16).odd_parity?
#=&gt; true
</code></pre>
","1381","<ruby><des><3des><parity>","6","2","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"4481887","Calculate the parity of a byte in Ruby","<p>What's the best way to calculate if a byte has odd or even parity in Ruby? I've got a version working: </p>

<pre><code>result = ""AB"".to_i(16).to_s(2).count('1').odd?
=&gt; true
</code></pre>

<p>Converting a number to a string and counting the ""1""s seems a poor way of calculating parity though. Any better methods?</p>

<p>I want to be able to calculate the parity of a 3DES key. Eventually, I'll want to convert even bytes to odd.  </p>

<p>Thanks,
Dan</p>
","<p>I would construct a single table of 16 entries (as a 16 character table), corresponding to each nibble (half) of a bytes. Entries are 0,1,1,2,1,2,....4</p>

<p>To test your byte,</p>

<p>Mask out the left nibble and do a lookup, memorizing the number.
Do. a shift to the right by 4 and do a second lookup, adding the result number to the previous one to provide a sum.</p>

<p>Then test the low order bit from the sum.  If it is 1, the byte is odd, if it is a 0, the byte is even.  If result is even, you flip the high order bit, using the xor instruction.
THis lookup method is much faster than adding up the bits in a byte by single shifts.</p>

<p>email me for a simple function to do the parity for 8 bytes.  3DES uses 3 groups of 8 bytes.</p>
","1381","<ruby><des><3des><parity>","6","1","6","2012-08-18 20:01:37","4483377","1","","49443","","2011-01-03 04:58:10","2010-12-19 06:27:34",""
"28459736","iOS 3DES with ECB return half correct data","<p>Got a problem with crypting password with 3DES + ECB algo. 
Here is the code I using: </p>

<pre><code>class func encryptPassword(pass: String) -&gt; String {

        let keyString        = ""123456789012345678901234""
        let keyData: NSData! = (keyString as NSString).dataUsingEncoding(NSUTF8StringEncoding) as NSData!
        let keyBytes         = UnsafePointer&lt;UInt8&gt;(keyData.bytes)

        let data: NSData! = (pass as NSString).dataUsingEncoding(NSUTF8StringEncoding) as NSData!
        let dataLength    = UInt(data.length)
        let dataBytes     = UnsafePointer&lt;UInt8&gt;(data.bytes)

        var cryptData    = NSMutableData(length: Int(dataLength) + kCCBlockSize3DES)!
        var cryptPointer = UnsafeMutablePointer&lt;UInt8&gt;(cryptData.mutableBytes)
        var cryptLength  = size_t(cryptData.length)

        let keyLength              = size_t(kCCKeySize3DES)
        let operation: CCOperation = UInt32(kCCEncrypt)
        let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
        let options:   CCOptions   = UInt32(kCCOptionECBMode | kCCOptionPKCS7Padding)

        var numBytesEncrypted :UInt = 0

        var cryptStatus = CCCrypt(operation,
            algoritm,
            options,
            keyBytes, keyLength,
            nil,
            dataBytes, dataLength,
            cryptPointer, cryptLength,
            &amp;numBytesEncrypted)

        var base64cryptString = """"
        if UInt32(cryptStatus) == UInt32(kCCSuccess) {
            let x: UInt = numBytesEncrypted
            cryptData.length = Int(numBytesEncrypted)
            println(""cryptLength = \(numBytesEncrypted),\n cryptData = \(cryptData)\n"")

            base64cryptString = cryptData.base64EncodedStringWithOptions(nil)

        } else {
            println(""Error: \(cryptStatus)"")
        }

        return base64cryptString
    }

}
</code></pre>

<p>That works, but failed verifying. I used online-encryptor for that like <a href=""http://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">http://www.tools4noobs.com/online_tools/encrypt/</a> 
Select TripleDES and ECB</p>

<p>For code </p>

<pre><code>let encrypted = Utils.encryptPassword(""123456789"")
</code></pre>

<p>Console shows </p>

<pre><code>cryptData = &lt;1dd50935 b702084b d164ce3e 9427c493&gt;
</code></pre>

<p>Online converter shows </p>

<pre><code>1dd50935b702084bf9fbee67c9643874
</code></pre>

<p>i.e first 8 bytes are correct but the last ones - not. How could be that? What could be wrong with code? </p>

<p>=========== EDIT ============</p>

<p>As @Artjom said - there is should be zeroes values added to complete block. </p>

<p>This code in start adds zero values:</p>

<pre><code>        // Trim password
        var password = pass.stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet())

        // Adding null padding
        let count = 8 - countElements(password) % 8
        for i in 1...count {
            password += ""\0""
        }
</code></pre>

<p>Then use ""password"" var instead incoming ""pass"" to generate ""data""</p>

<p>And also remove Padding for options </p>

<pre><code>let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
</code></pre>

<p>Thanks</p>
","<p>It is probably a different padding being used. DES has a block size of 8 byte. So the first block is <code>12345678</code> and the second block is <code>9</code>. Since DES is a block cipher the plaintext must be padded to the next block size.</p>

<p>The online tool probably uses zero padding or no padding which basically means that the other bytes of the block are set to 0x00. You use in your code on the other hand PKCS#7 padding. Remove the PKCS#7 flag, to see if the output matches.</p>

<p>You will have to do the zero padding yourself if the library doesn't provide it. Fill up the password with <code>\0</code> bytes until a multiple of the block size is reached during  encryption and remove those zero bytes during decryption.</p>

<p>It is not recommended to use encryption without padding.</p>

<p>Also, password are not usually encrypted, but rather <em>hashed</em> with a random salt and multiple iterations. When your user database gets ""lost"", you don't want the one who found it, to be able to easily reverse the passwords and log in as any user (the assumption being that the encryption key is also easily ""loseable""). Using a strong cryptographic hash function on the other hand has the advantage that it is really infeasible to reverse the hash.</p>
","1371","<ios><swift><encryption><3des><tripledes>","3","3","1","2015-02-11 20:34:01","28460019","0","","1531141","","2015-02-11 20:34:01","2015-02-11 16:43:59",""
"17086093","How to encrypt, decrypt data using DUKPT and 3DES algorithm in iphone for a card reader application?","<p>I have reffered this <a href=""https://github.com/mburshteyn1/DUKPT/blob/master/DUKPT.m"" rel=""nofollow"">code</a> and successfuly created IPEK and PEK for differant TKSN and Now how do I encrypt this keys to my card reader device and how do decrypt the card information using those keys. In fact I'm not familiar  with the DUKPT techniques and I was so new to that.Any suggestions will be appreciated</p>

<hr>

<p><strong>Note :</strong>
I have BDK and Final TKSN values how do I encrypt and decrypt these values in my device ?</p>
","<p>Searching on the same thing and I found this example library on github: <a href=""https://github.com/mburshteyn1/DUKPT"" rel=""nofollow"">https://github.com/mburshteyn1/DUKPT</a></p>

<p>I haven't tried it myself yet but it takes BDK and KSN as input which you have.</p>
","1311","<iphone><objective-c><security><3des>","3","1","1","2014-02-13 22:06:25","","3","2","1479798","","2013-06-13 11:42:48","2013-06-13 11:37:03",""
"33999427","Android encrypt 3DES ECB","<p>I need to encrypt some data with a custom key generated from a passphrase.</p>

<p>It MUST be:
3DES
Cipher Mode: ECB
Padding Mode: Zeros</p>

<p>I can't find any code to do that. Can anyone show me an example? </p>

<p>I've tried this and it show me the following error </p>

<pre><code>ERROR: java.security.InvalidAlgorithmParameterException: expected IV length of 0


import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

public static int MAX_KEY_LENGTH = DESedeKeySpec.DES_EDE_KEY_LEN;
private static String ENCRYPTION_KEY_TYPE = ""DESede"";
private static String ENCRYPTION_ALGORITHM = ""DESede/ECB/PKCS5Padding"";
private final SecretKeySpec keySpec;

public Encryption(String passphrase) {
    byte[] key;
    try {
        // get bytes representation of the password
        key = passphrase.getBytes(""UTF8"");
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }

    key = padKeyToLength(key, MAX_KEY_LENGTH);
    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);
}

// !!! - see post below
private byte[] padKeyToLength(byte[] key, int len) {
    byte[] newKey = new byte[len];
    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));
    return newKey;
}

// standard stuff
public byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {
    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);
}

public byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {
    return doCipher(encrypted, Cipher.DECRYPT_MODE);
}

private byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
    // IV = 0 is yet another issue, we'll ignore it here
    IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
    cipher.init(mode, keySpec, iv);
    return cipher.doFinal(original);
}
}
</code></pre>

<p>EDITED:
Now I have this, and I pass as ""passphrase"" parameter my custom key (key size=8)
The php I call is not accepting the encrypted result (it's not correct).</p>

<p>The correct encryption is the one this web does putting Algorith ""tripledes"" and mode: ECB
<a href=""https://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">https://www.tools4noobs.com/online_tools/encrypt/</a></p>

<p>I don't know yet what I am doing wrong...</p>

<pre><code>public class Encryption {

public static int MAX_KEY_LENGTH = DESedeKeySpec.DES_EDE_KEY_LEN;
private static String ENCRYPTION_KEY_TYPE = ""DESede"";
private static String ENCRYPTION_ALGORITHM = ""DESede/ECB/NoPadding"";
private final SecretKeySpec keySpec; 

public Encryption(String passphrase) {
        byte[] key;
    try {
        // get bytes representation of the password
        key = passphrase.getBytes(""UTF8"");
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }

    key = padKeyToLength(key, MAX_KEY_LENGTH);
    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);
}


private byte[] padKeyToLength(byte[] key, int len) {
    byte[] newKey = new byte[len];
    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));
    return newKey;
}

// standard stuff
public byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {
    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);
}

public byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {
    return doCipher(encrypted, Cipher.DECRYPT_MODE);
}

private byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
    int bs = cipher.getBlockSize();
    byte[] padded = new byte[original.length + bs - original.length % bs];
    System.arraycopy(original, 0, padded, 0, original.length);
    cipher.init(mode, keySpec);
    return cipher.doFinal(padded);
}
</code></pre>
","<p>ECB mode doesn't use an IV which makes it a deterministic cipher mode which means that it is not semantically secure. If you still need to use it, remove the IV as a parameter:</p>

<pre><code>int bs = cipher.getBlockSize();
byte[] padded = new byte[original.length + bs - original.length % bs];
System.arraycopy(original, 0, padded, 0, original.length);
cipher.init(mode, keySpec);
return cipher.doFinal(padded);
</code></pre>

<p>This will give you a zero padded message that can then be encrypted. This works, because a byte array is always initialized with zeros in them. The padding is the same as BouncyCastle's ZeroPadding. If you want to do zero padding as PHP's mcrypt does it, then use</p>

<pre><code>byte[] padded = new byte[original.length + (bs - original.length % bs) % bs];
</code></pre>
","1285","<android><security><encryption><3des>","-1","0","2","2015-12-02 09:44:13","","7","4","3683195","","2015-12-01 10:43:34","2015-11-30 13:09:36",""
"33999427","Android encrypt 3DES ECB","<p>I need to encrypt some data with a custom key generated from a passphrase.</p>

<p>It MUST be:
3DES
Cipher Mode: ECB
Padding Mode: Zeros</p>

<p>I can't find any code to do that. Can anyone show me an example? </p>

<p>I've tried this and it show me the following error </p>

<pre><code>ERROR: java.security.InvalidAlgorithmParameterException: expected IV length of 0


import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;

import javax.crypto.Cipher;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

public static int MAX_KEY_LENGTH = DESedeKeySpec.DES_EDE_KEY_LEN;
private static String ENCRYPTION_KEY_TYPE = ""DESede"";
private static String ENCRYPTION_ALGORITHM = ""DESede/ECB/PKCS5Padding"";
private final SecretKeySpec keySpec;

public Encryption(String passphrase) {
    byte[] key;
    try {
        // get bytes representation of the password
        key = passphrase.getBytes(""UTF8"");
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }

    key = padKeyToLength(key, MAX_KEY_LENGTH);
    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);
}

// !!! - see post below
private byte[] padKeyToLength(byte[] key, int len) {
    byte[] newKey = new byte[len];
    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));
    return newKey;
}

// standard stuff
public byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {
    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);
}

public byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {
    return doCipher(encrypted, Cipher.DECRYPT_MODE);
}

private byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
    // IV = 0 is yet another issue, we'll ignore it here
    IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
    cipher.init(mode, keySpec, iv);
    return cipher.doFinal(original);
}
}
</code></pre>

<p>EDITED:
Now I have this, and I pass as ""passphrase"" parameter my custom key (key size=8)
The php I call is not accepting the encrypted result (it's not correct).</p>

<p>The correct encryption is the one this web does putting Algorith ""tripledes"" and mode: ECB
<a href=""https://www.tools4noobs.com/online_tools/encrypt/"" rel=""nofollow"">https://www.tools4noobs.com/online_tools/encrypt/</a></p>

<p>I don't know yet what I am doing wrong...</p>

<pre><code>public class Encryption {

public static int MAX_KEY_LENGTH = DESedeKeySpec.DES_EDE_KEY_LEN;
private static String ENCRYPTION_KEY_TYPE = ""DESede"";
private static String ENCRYPTION_ALGORITHM = ""DESede/ECB/NoPadding"";
private final SecretKeySpec keySpec; 

public Encryption(String passphrase) {
        byte[] key;
    try {
        // get bytes representation of the password
        key = passphrase.getBytes(""UTF8"");
    } catch (UnsupportedEncodingException e) {
        throw new IllegalArgumentException(e);
    }

    key = padKeyToLength(key, MAX_KEY_LENGTH);
    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);
}


private byte[] padKeyToLength(byte[] key, int len) {
    byte[] newKey = new byte[len];
    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));
    return newKey;
}

// standard stuff
public byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {
    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);
}

public byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {
    return doCipher(encrypted, Cipher.DECRYPT_MODE);
}

private byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {
    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);
    int bs = cipher.getBlockSize();
    byte[] padded = new byte[original.length + bs - original.length % bs];
    System.arraycopy(original, 0, padded, 0, original.length);
    cipher.init(mode, keySpec);
    return cipher.doFinal(padded);
}
</code></pre>
","<p>Here's example of code I use to encrypt something with 3DES. I also use Base64 for my secretKey, but I think you'll figure this out.</p>

<pre><code>public class KeywordsCipher {

private static final String PADDING = ""DESede/ECB/NoPadding"";
private static final String UTF_F8 = ""UTF-8"";
private static final String DE_SEDE = ""DESede"";
private String secretKey;

{...}

public String encrypt(String message, String secretKey) {

    byte[] cipherText = null;

    try {
        final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
        final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
        final Cipher cipher = Cipher.getInstance(PADDING);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        final byte[] plainTextBytes = message.getBytes();
        cipherText = cipher.doFinal(plainTextBytes);
    } catch (NoSuchAlgorithmException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | NoSuchPaddingException e) {
        throw new CipherException(""Problem with encryption occured"");
    }

    return Hex.encodeHexString(cipherText);
}

public CipherKeywordModel decrypt(String keyToDecrypt, String secretKey) {

    try {
        byte[] message = DatatypeConverter.parseHexBinary(keyToDecrypt);
        final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
        final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
        final Cipher decipher = Cipher.getInstance(PADDING);
        decipher.init(Cipher.DECRYPT_MODE, key);
        final byte[] plainText = decipher.doFinal(message);
        String decryptedText = new String(plainText, UTF_F8);
    } catch (UnsupportedEncodingException | NoSuchAlgorithmException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | NoSuchPaddingException e) {
        throw new CipherException(""Problem with encryption occured"");
    }
    return decryptedText;
}
</code></pre>
","1285","<android><security><encryption><3des>","-1","0","2","2015-12-02 09:44:13","","7","4","3683195","","2015-12-01 10:43:34","2015-11-30 13:09:36",""
"10566360","DESede (3DES) Encryption in RAILO CFML","<p>I've been trying for many days to try and solve this issue.</p>

<p>A 3rd Party webservice requires me to send encrypted data using 3DES with ECB
and PKCS7padding - They're using .NET</p>

<p>The encrypt function within railo CFML is limited to DESede without any further options (i.e. defaults are used for cipher mode and padding). </p>

<p>Has anyone had this issue in Railo and come up with a solution (java based perhaps)? - I'm seriously pulling my hair out here!</p>

<p>Based on Leigh's suggestions below I made some changes:</p>

<p>I've made a bit of progress, I think this key has some kind of MD5 hashing on it.</p>

<p>I fished around the web and modified your solution a bit - I don't think the padding is necessary but the resultant encrypted string at first appears to be what I should expect but then closer on inspection it's incorrect:</p>

<pre><code>IvParameterSpec = createObject(""java"", ""javax.crypto.spec.IvParameterSpec"");
Cipher = createObject(""java"", ""javax.crypto.Cipher"");
SecretKeySpec = createObject(""java"", ""javax.crypto.spec.SecretKeySpec"");
BASE64Decoder = createObject(""java"", ""sun.misc.BASE64Decoder"");
Str = createObject(""java"", ""java.lang.String"");
MessageDigest = createObject(""java"", ""java.security.MessageDigest"");

input  = ""&lt;xml&gt;&lt;PanNumber&gt;6280390027626871&lt;/PanNumber&gt;&lt;Req_Currency_Code&gt;826&lt;/Req_Currency_Code&gt;&lt;Card_Pin&gt;1234&lt;/Card_Pin&gt;&lt;Till_Amount&gt;&lt;/Till_Amount&gt;&lt;Auth_Code&gt;&lt;/Auth_Code&gt;&lt;/xml&gt;"";
key = ""06098140901984F95E139F29B479D952CB6545C177D21456"";

md = MessageDigest.getInstance(""MD5"");
md.update(key.getBytes(""UTF-8""), 0, key.length());
keyBytes = md.digest();
newKey = tobase64(keyBytes);
keyBytes2  = binaryDecode(newKey, ""base64"");
keyBytes2  = arrayMerge(keyBytes, arraySlice(keyBytes, 1, 8));
allnewKey = binaryEncode(javacast(""byte[]"", keyBytes2), ""base64"");

encrypted = encrypt(input, allnewKey, ""desede"", ""base64"");
WriteDump(""encrypted (CF): ""&amp; encrypted);`
</code></pre>

<p>The result is: <strong>26sfwv2DHDj7EHYd5Qao8veDtPbKIcv8rDVhbLPDEaWHO27EUGRF6KrdbXe7NBUVADYMdGuagfO4Tev584dUcgKGJ2h6kWPZxooNUGMgL2xB7e00YOkLosA8wFD569sZUd1MGKuF9yCjY1zCsAE4SgohkcuK9YZ7BizQma99/W9yOsIjAfHtAqGiep4tMTQ+eFASYtPybccsgi8H4brIB/HAu0kaDSAw</strong></p>

<p>The expected result is:
<strong>26sfwv2DHDj7EHYd5Qao8veDtPbKIcv8rDVhbLPDEaWHO27EUGRF6MxaAzUpJDqQBq8NGgdqmtn6q/wVQNHGWrOE8+aetKVC78nszS3ZO8AHjwoT1igv4lGl78n8jCHHU+KwnBT7KfXIYMTCuwO/MohIiFbGyhMXPsvv3/G4OY1C2nEkN0LweLh4mTgtU8syT1M9XdmvwhaltsmPoFtoE9FujvQpJCY3</strong></p>
","<blockquote>
  <p>The encrypt function within railo CFML is limited to DESede without
  any further options (i.e. defaults are used for cipher mode and
  padding).</p>
</blockquote>

<p>Yes, I believe it uses java's defaults ie <code>DESede/ECB/PKCS5Padding</code> which are compatible with <code>TripleDES/ECB/PKCS7padding</code> in .NET. So it should work right out of the box as long as you are using a 24 byte key.  </p>

<p>Without knowing more, I am guessing it might be a problem with your key size. .NET supports both 16 and 24 byte keys, but java only supports 24 byte keys. So if your key is only 16 bytes, you need to pad it with the first eight (8) bytes to make it acceptable to Java/Railo.</p>

<p><strong>CF/Railo Code</strong></p>

<pre><code>&lt;cfscript&gt;
    input  = ""DESede (3DES) Encryption in RAILO CFML"";
    key    = ""ru8femXhTm9jwdGdhb/4Sw=="";

    // pad the key with the first eight bytes. then convert back to base64
    keyBytes  = binaryDecode(key, ""base64"");
    keyBytes  = arrayMerge(keyBytes, arraySlice(keyBytes, 1, 8));
    newKey = binaryEncode(javacast(""byte[]"", keyBytes), ""base64"");

    encrypted = encrypt(input, newKey, ""desede"", ""base64"");
    WriteDump(""encrypted (CF): ""&amp; encrypted);
&lt;/cfscript&gt;
</code></pre>

<p><strong>C# Code</strong></p>

<pre><code>byte[] input = Encoding.UTF8.GetBytes(""DESede (3DES) Encryption in RAILO CFML"");
byte[] key = Convert.FromBase64String(""ru8femXhTm9jwdGdhb/4Sw=="");

TripleDESCryptoServiceProvider algorithm = new TripleDESCryptoServiceProvider();
algorithm.Mode = CipherMode.ECB;
algorithm.BlockSize = 64;
algorithm.KeySize = 128; // 16 byte key
algorithm.Key = key;
ICryptoTransform cipher = algorithm.CreateEncryptor();
byte[] encrypted = cipher.TransformFinalBlock(input, 0, input.Length);
Console.WriteLine(""encrypted (.NET): {0}"", Convert.ToBase64String(encrypted));
</code></pre>

<p><strong>Results:</strong></p>

<pre><code>encrypted (CF):   fMPlk0ZqHDwp2zzZs/Cng7Y6r8Acr55UPJYWJTruEesxkBApsEFo6w==
encrypted (.NET): fMPlk0ZqHDwp2zzZs/Cng7Y6r8Acr55UPJYWJTruEesxkBApsEFo6w==
</code></pre>

<hr>

<p><strong>Update:</strong>  Weird. When I MD5 hash the key in .NET I get your first result rather than the ""expected result""</p>

<pre><code>    String rawInput = ""&lt;xml&gt;&lt;PanNumber&gt;6280390027626871&lt;/PanNumber&gt;&lt;Req_Currency_Code&gt;826&lt;/Req_Currency_Code&gt;&lt;Card_Pin&gt;1234&lt;/Card_Pin&gt;&lt;Till_Amount&gt;&lt;/Till_Amount&gt;&lt;Auth_Code&gt;&lt;/Auth_Code&gt;&lt;/xml&gt;"";
    String rawKey = ""06098140901984F95E139F29B479D952CB6545C177D21456"";
    byte[] input = Encoding.UTF8.GetBytes(rawInput);
    byte[] key = MD5.Create().ComputeHash(Encoding.UTF8.GetBytes(rawKey));
    // ... rest of code 
</code></pre>

<p><strong>Result:</strong>    </p>

<pre><code>encrypted (.NET): 26sfwv2DHDj7EHYd5Qao8veDtPbKIcv8rDVhbLPDEaWHO27EUGRF6KrdbXe7NB
UVADYMdGuagfO4Tev584dUcgKGJ2h6kWPZxooNUGMgL2xB7e00YOkLosA8wFD569sZUd1MGKuF9yCjY1
zCsAE4SgohkcuK9YZ7BizQma99/W9yOsIjAfHtAqGiep4tMTQ+eFASYtPybccsgi8H4brIB/HAu0kaDS
Aw          
</code></pre>
","1243","<.net><encryption><coldfusion><railo><3des>","1","4","1","2016-10-19 17:35:14","10569638","1","","414857","","2012-05-13 10:31:31","2012-05-12 18:30:36",""
"31115861","C# and PHP encryption compatibility - 3DES ECB with PKCS7","<p>I have a common problem but none of the various solutions in the web seems working for me.</p>

<p>I have C# code which make an encrypt 3DES-ECB with PKCS7. I have to do the same in PHP, but I'm getting different results.</p>

<p>This is my C# code:</p>

<pre><code>        public string Encrypt(string toEncrypt, string key)
    {
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);
        System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
            //Always release the resources and flush data
            // of the Cryptographic service provide. Best Practice
            hashmd5.Clear();            
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;
        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray =
          cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        tdes.Clear();
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
</code></pre>

<p>I've made a lot of tries in php... this is only one of them:</p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}
</code></pre>

<p>I'm using a random key, you can find it in the php sample code.</p>

<p>When the input is ""<strong>00010</strong>"", the C# code returns ""<strong>FcXBCikZU64=</strong>"" while the php gives to me ""<strong>FIg+xqod9iY=</strong>"".</p>

<p>Why? I think I'm doing all the stuff I've found in the blogs/tutorials/etc... so, what's the problem in my case?</p>

<p>UPDATE:</p>

<p>I have add, but still bad news...</p>

<p><strong>$key .= substr($key,0,8);</strong></p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key .= substr($key,0,8); // append the first 8 bytes onto the end

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb'); //, $iv);
  return base64_encode($encData);
}
</code></pre>

<p>now the output is <strong>hbJpiCNmXz8=</strong>... still not what I need..</p>

<p><strong>UPDATE2</strong>: the problem is that, on c# side, I make an hash and I don't know how to do it in php.. look the code ""tabbed"", is where I do the hash in c# side.. how can I do it in php one?</p>

<p><strong>SOLUTION</strong>: </p>

<pre><code>function apiEncode($data)
{    
  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key = ""6702BC24DD0527E7"";
  $key = md5($key,TRUE);
  $key .= substr($key,0,8);
  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}

 $crypt = apiEncode(""00010"");     
    echo ""CRYPT: $crypt"";
</code></pre>
","<p>PHP code:</p>

<pre><code>$key = ""6702BC24DD0527E7"";
$key = md5($key,TRUE);
$key .= substr($key,0,8);
</code></pre>

<p>The C# code is ""ok"" as it is.</p>

<p>""ok"" is a big word here. I would probably use SHA256 and trim it to 24 bytes:</p>

<p>C#:</p>

<pre><code>SHA256Managed sha256 = new SHA256Managed();
keyArray = sha256.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
Array.Resize(ref keyArray, 24);
//Always release the resources and flush data
// of the Cryptographic service provide. Best Practice
sha256.Clear(); 
</code></pre>

<p>and PHP:</p>

<pre><code>$key = ""6702BC24DD0527E7"";
$key = hash(""sha256"",$key,TRUE);
$key = substr($key,0,24);
</code></pre>

<p>and still would be ""lower case OK""... Normally you should use AES and one of the various block chaining modes, like CBC (that requires a IV), and the password should be ""strenghtened"" with an algorithm, like PBKDF2 (requires PHP >= 5.5)</p>
","1232","<c#><php><encryption><pkcs#7><3des>","2","2","2","2015-07-08 10:24:13","31117920","13","1","819161","","2015-06-29 14:21:24","2015-06-29 12:34:45",""
"31115861","C# and PHP encryption compatibility - 3DES ECB with PKCS7","<p>I have a common problem but none of the various solutions in the web seems working for me.</p>

<p>I have C# code which make an encrypt 3DES-ECB with PKCS7. I have to do the same in PHP, but I'm getting different results.</p>

<p>This is my C# code:</p>

<pre><code>        public string Encrypt(string toEncrypt, string key)
    {
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);
        System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
            //Always release the resources and flush data
            // of the Cryptographic service provide. Best Practice
            hashmd5.Clear();            
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;
        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray =
          cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        tdes.Clear();
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
</code></pre>

<p>I've made a lot of tries in php... this is only one of them:</p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}
</code></pre>

<p>I'm using a random key, you can find it in the php sample code.</p>

<p>When the input is ""<strong>00010</strong>"", the C# code returns ""<strong>FcXBCikZU64=</strong>"" while the php gives to me ""<strong>FIg+xqod9iY=</strong>"".</p>

<p>Why? I think I'm doing all the stuff I've found in the blogs/tutorials/etc... so, what's the problem in my case?</p>

<p>UPDATE:</p>

<p>I have add, but still bad news...</p>

<p><strong>$key .= substr($key,0,8);</strong></p>

<pre><code>function apiEncode($data)
{    
  $key = ""6702BC24DD0527E7"";

  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key .= substr($key,0,8); // append the first 8 bytes onto the end

  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb'); //, $iv);
  return base64_encode($encData);
}
</code></pre>

<p>now the output is <strong>hbJpiCNmXz8=</strong>... still not what I need..</p>

<p><strong>UPDATE2</strong>: the problem is that, on c# side, I make an hash and I don't know how to do it in php.. look the code ""tabbed"", is where I do the hash in c# side.. how can I do it in php one?</p>

<p><strong>SOLUTION</strong>: </p>

<pre><code>function apiEncode($data)
{    
  //Pad for PKCS7
  $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
  $len = strlen($data);
  $pad = $blockSize - ($len % $blockSize);
  $data .= str_repeat(chr($pad), $pad);

  $key = ""6702BC24DD0527E7"";
  $key = md5($key,TRUE);
  $key .= substr($key,0,8);
  //Encrypt data
  $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
  return base64_encode($encData);
}

 $crypt = apiEncode(""00010"");     
    echo ""CRYPT: $crypt"";
</code></pre>
","<p>Ok, solved the issue. Look <a href=""https://programmingistheway.wordpress.com/2015/07/08/triple-des-with-pcsk7-and-ecb-between-php-and-net/"" rel=""nofollow"">this link</a>, I wrote all there.</p>
","1232","<c#><php><encryption><pkcs#7><3des>","2","0","2","2015-07-08 10:24:13","31117920","13","1","819161","","2015-06-29 14:21:24","2015-06-29 12:34:45",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<p><a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">3DES</a> is just DES used three times on the plaintext:</p>

<pre><code>ciphertext = E_K3(D_K2(E_K1(plaintext)))
plaintext = D_K1(E_K2(D_K3(ciphertext)))

E_Kn = Encryption with Key number n.
D_Kn = Decryption with Key number n.
</code></pre>

<p>So you can easily ""emulate"" 3DES with just DES.</p>

<p>In CBC mode you'll need an IV to start with and then XOR the next plaintext block with the previous ciphertext block. If your device doesn't support CBC then this too is easily ""emulated"".</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","0","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<p>You start by picking three independent DES keys which are not related to each other in any way.</p>

<p>You will want to put DES into ECB mode, <strong>not CBC mode</strong>. You also need to ensure that each encryption and decryption operation is done only on 64-bit blocks and nothing more or less. Padding schemes and the likes will cause a vulnerability in the implementation and will lead to the discovery of the block content via brute force faster than a brute force against each key.</p>

<p>Using the first key, encrypt your plaintext. Using the second key, decrypt that value. Using the third key, encrypt the value for your full block. It looks like this:</p>

<p><code>Encrypt(k3, Decrypt(k2, Encrypt(k1, plaintext)))</code></p>

<p>Decryption is the other way around and looks like this:</p>

<p><code>Decrypt(k1, Encrypt(k2, Decrypt(k3, ciphertext)))</code></p>

<p>When you encrypt your blocks with 3DES you then need to apply your mode of operation like CBC or CTR and apply padding if needed.</p>

<p>Be careful.</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","4","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"10246083","Emulate 3DES EDE using only DES","<p>My device doesn't support full 3DES (EDE). How can I emulate one using standard DES? Encryption mode is CBC.</p>
","<h1>Block mode encryption</h1>

<p>What you do is that you split the key of size 128 bit (16 byte) or 168 bit (24 byte) in two or three pieces respectively. So for a 16 byte key K you would have two keys Ka and Kb, and for a 24 byte key you would have Ka, Kb and Kc. DES ABC keys have an <em>effective</em> strength of about 112 bits, DES ABA keys have an <em>effective</em> strength of about 80 bits.</p>

<p>To encrypt a single block of 8 bytes (the block size of both DES and 3DES) you would perform the following cryptographic operation: Cn = E(Ka, D(Kb, E(Kc, Mn))) where Mn is the n'th block of the plain text message and Cn the n'th block of the cipher text. If you don't have a Kc then you may use Ka (DES ABC key vs DES ABA key).</p>

<p>For this you need a single block DES encrypt, which is identical to a single block encrypt in ECB mode, or a single block encrypt with CBC and an IV consisting of 8 bytes valued 00h.</p>

<h1>CBC</h1>

<p>So that's the block encryption sorted, now you need some kind of encryption mode and padding mode. I'll explain CBC mode encryption here, ECB should not be used for encryption non-random data.</p>

<p>With CBC mode encryption you XOR a vector to the plain text. The vector is normally just the output of the last DESede encrypted block. As you don't have any preceding cipher text, you need to create the first vector yourself using random data. This vector is called the initialization vector or IV. See <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block%20chaining%20%28CBC%29"" rel=""nofollow"">wikipedia</a> for a clear picture.</p>

<h1>Padding</h1>

<p>Block cipher modes only allow full blocks of plain text to be encrypted. So you would need some kind of padding scheme. Although there are many padding modes, PKCS#5 padding is used most of the time. You should pad the plain text like this: pad with bytes valued 0Xh, where X is the number of padding bytes required to create a full block. X should be between 1 and 8: in other words, PKCS#5 padding is always used; this makes it possible to distinquish the padding bytes from the plain text.</p>

<p>If you use padding in an online protocol then you need to protect against padding oracle attacks. In this case it is highly recommended to use some form of integrity checks, e.g. by adding a HMAC over the cipher text using a separate key.</p>
","1207","<encryption><encryption-symmetric><des><3des>","1","1","3","2012-05-03 21:12:28","10246219","0","","468904","","2012-05-03 21:12:28","2012-04-20 12:17:05",""
"34031404","3DES CBC Encryption in PHP with a 16 byte key","<p>I've been trying to make a 3DES algorithm in PHP. I made it in Java and it works well, but the PHP version gives me a different result; here is my code:</p>

<pre><code>function String2Hex($string){
    $hex='';
    for ($i=0; $i &lt; strlen($string); $i++){
        $hex .= dechex(ord($string[$i]));
    }
    return $hex;
}

function hexToAscii($inputHex) {
    $inputHex = str_replace(' ', '', $inputHex);
    $inputHex = str_replace('\x', '', $inputHex);
    $ascii = pack('H*', $inputHex);
    return $ascii;
}

$cipher = mcrypt_module_open(MCRYPT_3DES, '', MCRYPT_MODE_CBC, '');

$iv =  '0000000000000000';

$key = '75ABFD405D018A9BD0E66D23DA3B6DC8';
printf(""KEY: %s\n"", String2Hex($key));

$cleartext = '0436A6BFFFFFFFA8';
printf(""&lt;br&gt;TEXT: %s\n\n"", $cleartext);

if (mcrypt_generic_init($cipher, hexToAscii($key), $iv) != -1)
{
    $cipherText = mcrypt_generic($cipher, hexToAscii($cleartext));
    mcrypt_generic_deinit($cipher);

    printf(""&lt;br&gt;&lt;br&gt;3DES encrypted:\n%s\n\n"", strtoupper(bin2hex($cipherText)));
}
</code></pre>

<p><strong>It must give me: 76FB62FB3AFD6677<br>
But it gives me: E01BD1085F0126A2</strong></p>

<p>What can I do?</p>
","<p>Triple DES is defined for key sizes of 192 bit (168 bit without parity). This assumes three independent subkeys. Since you only have one 128 bit, you need to stretch the two keys into three subkeys. Since 3DES is usually executed as a Encrypt-Decrypt-Encrypt (EDE) scheme, the first and the last subkey can be the same.</p>

<p>If your current key is <code>K1 || K2</code>, then you can try <code>K1 || K2 || K1</code> or <code>K2 || K1 || K2</code> as the final key. I've tried it for you and the first suggestion works. </p>

<p>Also, you forgot to decode the IV from Hex. Here is the full code:</p>

<pre><code>function String2Hex($string){
$hex='';
for ($i=0; $i &lt; strlen($string); $i++){
    $hex .= dechex(ord($string[$i]));
}
return $hex;
}

function hexToAscii($inputHex) {
    $inputHex = str_replace(' ', '', $inputHex);
    $inputHex = str_replace('\x', '', $inputHex);
    $ascii = pack('H*', $inputHex);
    return $ascii;
}

$cipher = mcrypt_module_open(MCRYPT_3DES, '', MCRYPT_MODE_CBC, '');

$iv =  '0000000000000000';

//$key = '75ABFD405D018A9BD0E66D23DA3B6DC8';
$key = '75ABFD405D018A9BD0E66D23DA3B6DC875ABFD405D018A9B';
printf(""KEY: %s\n"", $key);

$cleartext = '0436A6BFFFFFFFA8';
printf(""&lt;br&gt;TEXT: %s\n\n"", $cleartext);

if (mcrypt_generic_init($cipher, hexToAscii($key), hexToAscii($iv)) != -1)
{
    $cipherText = mcrypt_generic($cipher, hexToAscii($cleartext));
    mcrypt_generic_deinit($cipher);

    printf(""&lt;br&gt;3DES encrypted:\n%s\n\n"", strtoupper(bin2hex($cipherText)));
}
</code></pre>

<p>Output:</p>

<pre>
KEY: 75ABFD405D018A9BD0E66D23DA3B6DC875ABFD405D018A9B
TEXT: 0436A6BFFFFFFFA8
3DES encrypted: 76FB62FB3AFD6677 
</pre>
","1181","<php><encryption><3des><cbc-mode>","1","1","1","2017-03-28 09:03:29","34032336","1","","1816580","","2015-12-01 23:44:42","2015-12-01 22:25:25",""
"45352262","Encrypt with Double Length 3DES Key in Java and produce 16 bytes array cipher","<p>I need to create a double length 3DES key in Java using a 16 bytes array key material, encrypt with it a message and get back 16 bytes length array. I am able to get it working with 24 bytes but not 16 bytes... </p>

<p>Because DESede expects 24 byte[], the only way to produce a double length 3DES Key with a 16 bytes long key material, I was able to by using a DESede instance and then increasing its length by appending first 8 bytes at the end to get 24 bytes. Like so: </p>

<pre><code>    byte[] keyMaterial = // Assume this one is 16 bytes. 

    byte[] newKeyBytes = ByteBuffer.wrap( new byte[ 24 ] )
            .put( Arrays.copyOfRange( keyMaterial, 0, 16 ) )
            .put( Arrays.copyOfRange( keyMaterial, 0, 8 ) )
            .array();

    SecretKeyFactory mySecretKeyFactory = SecretKeyFactory.getInstance( ""DESede"" );
    KeySpec myKeySpec = new DESedeKeySpec( newKeyBytes );
    SecretKey encryptionKey = mySecretKeyFactory.generateSecret( myKeySpec );
</code></pre>

<p>Now when I have my DESede key I can use it to encrypt the message the following way. Also, I need to use ""ECB"" mode: </p>

<pre><code>    Cipher cipher = Cipher.getInstance( ""DESede/ECB/PKCS5Padding"" );
    cipher.init( Cipher.ENCRYPT_MODE, encryptionKey );
    byte[] returnValue = cipher.doFinal( dataToEncrypt )
</code></pre>

<p>But as a result I get back 24 byte array rather than 16 byte array and I guess this is because I am encrypting with 24 byte array. </p>

<p>Is there a way to create a 3DES SecretKey 16 bytes long rather than 24 bytes, OR when encrypting with 24 byte long SecretKey, get back a 16 bytes long ciphered message as I need rather than 24 bytes long?</p>

<p>Thank you!</p>
","<p>I think I have just found an answer to my question. </p>

<p><a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html</a></p>

<p>I used DESede/ECB/NoPadding and when used with NoPadding, then encrypting a 16 bytes array message with 24 bytes SecretKey produces a 16 bytes long cipher message which is exactly what I need.</p>

<p>I hope this finding is correct. Please correct me if I am mistaken. </p>
","1181","<java><encryption><3des>","0","1","1","2017-07-27 13:48:40","","0","2","","","","2017-07-27 13:29:15",""
"9899140","JSON + 3des encrypt dosen't work","<p>i'm trying to pass some JSON data encrypted to my app but seem when i decrypt it my script add some 00 to hexe code making it impossible to be serialized</p>

<p>i've tried to pass data uncrypted and crypted and the only difference i found is 00 at the end</p>

<p>that is how i read JSON if isn't Encrypted </p>

<pre><code>NSLog(@""A) %@"",  response );
NSMutableArray *json = [NSJSONSerialization JSONObjectWithData:response options:kNilOptions error:&amp;error];
NSLog(@""B) %@"",  error);
</code></pre>

<p>that is NSLog Output</p>

<pre><code>2012-03-28 00:43:58.399 VGCollect[5583:f803] A) &lt;5b7b2274 69746c65 223a2252 696c6173 63696174 61206c61 20707269 6d612045 7370616e 73696f6e 65206469 20526167 6e61726f 6b204f64 79737365 79222c22 63617465 676f7279 223a225b 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3536345f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 68616e74 61737920 53746172 204f6e6c 696e6520 3220616e 63686520 73752069 4f532065 20416e64 726f6964 20222c22 63617465 676f7279 223a225b 20495048 4f4e452c 2050432c 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437355f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 72696d69 20536372 65656e73 686f7420 696e2061 6c747261 20726973 6f6c757a 696f6e65 20706572 202e6861 636b5c2f 5c2f7665 72737573 222c2263 61746567 6f727922 3a225b20 50533320 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2269 6c206e75 6f766f20 444c4320 64692046 696e616c 2046616e 74617379 20584949 492d3220 636f6e66 65726d61 746f2061 6e636865 20696e20 416d6572 69636122 2c226361 7465676f 7279223a 225b2050 53332c20 58333630 205d222c 22696d67 55726c22 3a22494d 41474553 5c2f3230 31325c2f 30335c2f 30303030 38343439 5f313530 7838302e 6a706722 7d2c7b22 7469746c 65223a22 52656769 73747261 746f2069 6c206d61 72636869 6f205461 6c657320 6f662058 696c6c69 6120696e 20457572 6f706122 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 34385f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225376 656c6174 69202e68 61636b5c 2f5c2f56 65727375 732e2065 202e6861 636b5c2f 5c2f5365 6b616920 6e6f204d 756b6f75 206e6922 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 33345f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a22476f 6e205061 6b752050 616b7520 50616b75 2050616b 75204164 76656e74 75726520 756e206e 756f766f 2067696f 636f2064 69204e61 6d636f20 42616e64 6169222c 22636174 65676f72 79223a22 5b203344 53205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383432 385f3135 30783830 2e6a7067 227d2c7b 22746974 6c65223a 224e756f 76652069 6d6d6167 696e6920 6520696e 666f2064 69204669 72652045 6d626c65 6d204177 616b656e 696e6722 2c226361 7465676f 7279223a 225b2033 4453205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 31365f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225072 696d6520 696d6d61 67696e69 20646569 206e756f 76692044 4c432064 69204669 6e616c20 46616e74 61737920 58494949 2d32222c 22636174 65676f72 79223a22 5b205053 332c2058 33363020 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3431325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2249 6e206172 7269766f 20717565 73746f20 41757475 6e6e6f20 45706963 204d6963 6b657920 323a2054 68652050 6f776572 206f6620 54776f22 2c226361 7465676f 7279223a 225b2050 53332c20 5769692c 20583336 30205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383430 385f3135 30783830 2e6a7067 227d5d&gt;
2012-03-28 00:43:58.410 VGCollect[5583:f803] B) (null)
</code></pre>

<p>instead that is how i serialize my crypted JSON</p>

<pre><code>NSData *decryptBase64   = [GTMBase64 decodeData:response];
NSData *decrypt3DES     = [Crypt TripleDES:decryptBase64 encryptOrDecrypt:kCCDecrypt key:@""2b9534b45611cbb2436e625d""];
NSLog(@""A) %@"",  decrypt3DES );
NSMutableArray *json = [NSJSONSerialization JSONObjectWithData:decrypt3DES options:kNilOptions error:&amp;error];
NSLog(@""B) %@"",  error);
</code></pre>

<p>and that is the NSLog output</p>

<pre><code>2012-03-28 00:41:51.525 VGCollect[5529:f803] A) &lt;5b7b2274 69746c65 223a2252 696c6173 63696174 61206c61 20707269 6d612045 7370616e 73696f6e 65206469 20526167 6e61726f 6b204f64 79737365 79222c22 63617465 676f7279 223a225b 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3536345f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 68616e74 61737920 53746172 204f6e6c 696e6520 3220616e 63686520 73752069 4f532065 20416e64 726f6964 20222c22 63617465 676f7279 223a225b 20495048 4f4e452c 2050432c 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437355f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 72696d69 20536372 65656e73 686f7420 696e2061 6c747261 20726973 6f6c757a 696f6e65 20706572 202e6861 636b5c2f 5c2f7665 72737573 222c2263 61746567 6f727922 3a225b20 50533320 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2269 6c206e75 6f766f20 444c4320 64692046 696e616c 2046616e 74617379 20584949 492d3220 636f6e66 65726d61 746f2061 6e636865 20696e20 416d6572 69636122 2c226361 7465676f 7279223a 225b2050 53332c20 58333630 205d222c 22696d67 55726c22 3a22494d 41474553 5c2f3230 31325c2f 30335c2f 30303030 38343439 5f313530 7838302e 6a706722 7d2c7b22 7469746c 65223a22 52656769 73747261 746f2069 6c206d61 72636869 6f205461 6c657320 6f662058 696c6c69 6120696e 20457572 6f706122 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 34385f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225376 656c6174 69202e68 61636b5c 2f5c2f56 65727375 732e2065 202e6861 636b5c2f 5c2f5365 6b616920 6e6f204d 756b6f75 206e6922 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 33345f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a22476f 6e205061 6b752050 616b7520 50616b75 2050616b 75204164 76656e74 75726520 756e206e 756f766f 2067696f 636f2064 69204e61 6d636f20 42616e64 6169222c 22636174 65676f72 79223a22 5b203344 53205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383432 385f3135 30783830 2e6a7067 227d2c7b 22746974 6c65223a 224e756f 76652069 6d6d6167 696e6920 6520696e 666f2064 69204669 72652045 6d626c65 6d204177 616b656e 696e6722 2c226361 7465676f 7279223a 225b2033 4453205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 31365f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225072 696d6520 696d6d61 67696e69 20646569 206e756f 76692044 4c432064 69204669 6e616c20 46616e74 61737920 58494949 2d32222c 22636174 65676f72 79223a22 5b205053 332c2058 33363020 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3431325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2249 6e206172 7269766f 20717565 73746f20 41757475 6e6e6f20 45706963 204d6963 6b657920 323a2054 68652050 6f776572 206f6620 54776f22 2c226361 7465676f 7279223a 225b2050 53332c20 5769692c 20583336 30205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383430 385f3135 30783830 2e6a7067 227d5d00&gt;
2012-03-28 00:41:51.530 VGCollect[5529:f803] B) Error Domain=NSCocoaErrorDomain Code=3840 ""The operation couldn’t be completed. (Cocoa error 3840.)"" (Garbage at end.) UserInfo=0x6ccdd40 {NSDebugDescription=Garbage at end.}
</code></pre>

<p>as u can see the only difference between 2 NSlogs is 00 at the end of second hexcode and the error on serialization of it</p>

<p>do u know how fix that ?</p>

<p>idk if is needed, that is my script for encrypt data</p>

<pre><code>+(NSData*)TripleDES:(NSData*)plainData encryptOrDecrypt:(CCOperation)encryptOrDecrypt key:(NSString*)key {

    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [plainData length];
    vplainText = (const void *)[plainData bytes];


    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    // uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));

    //    NSString *key = @""123456789012345678901234"";
    NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       (kCCOptionPKCS7Padding | kCCOptionECBMode) ,
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    NSData *result = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    return result;
}
</code></pre>
","<p>I think you're asking too much of a generic encryption/decryption function.</p>

<p>It would probably be better to provide two functions:</p>

<ul>
<li>the first function performs padding and then encrypts</li>
<li>the second function decrypts and then strips the padding.</li>
</ul>

<p>Trying to make one function do the work of four separate pieces is obviously complicating the code significantly. (I can't tell, for instance, if the padded-size calculation properly reverses itself.)</p>
","1177","<ios><json><encryption><3des>","1","0","2","2012-04-15 22:50:39","10166867","2","","","","","2012-03-27 23:26:44",""
"9899140","JSON + 3des encrypt dosen't work","<p>i'm trying to pass some JSON data encrypted to my app but seem when i decrypt it my script add some 00 to hexe code making it impossible to be serialized</p>

<p>i've tried to pass data uncrypted and crypted and the only difference i found is 00 at the end</p>

<p>that is how i read JSON if isn't Encrypted </p>

<pre><code>NSLog(@""A) %@"",  response );
NSMutableArray *json = [NSJSONSerialization JSONObjectWithData:response options:kNilOptions error:&amp;error];
NSLog(@""B) %@"",  error);
</code></pre>

<p>that is NSLog Output</p>

<pre><code>2012-03-28 00:43:58.399 VGCollect[5583:f803] A) &lt;5b7b2274 69746c65 223a2252 696c6173 63696174 61206c61 20707269 6d612045 7370616e 73696f6e 65206469 20526167 6e61726f 6b204f64 79737365 79222c22 63617465 676f7279 223a225b 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3536345f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 68616e74 61737920 53746172 204f6e6c 696e6520 3220616e 63686520 73752069 4f532065 20416e64 726f6964 20222c22 63617465 676f7279 223a225b 20495048 4f4e452c 2050432c 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437355f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 72696d69 20536372 65656e73 686f7420 696e2061 6c747261 20726973 6f6c757a 696f6e65 20706572 202e6861 636b5c2f 5c2f7665 72737573 222c2263 61746567 6f727922 3a225b20 50533320 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2269 6c206e75 6f766f20 444c4320 64692046 696e616c 2046616e 74617379 20584949 492d3220 636f6e66 65726d61 746f2061 6e636865 20696e20 416d6572 69636122 2c226361 7465676f 7279223a 225b2050 53332c20 58333630 205d222c 22696d67 55726c22 3a22494d 41474553 5c2f3230 31325c2f 30335c2f 30303030 38343439 5f313530 7838302e 6a706722 7d2c7b22 7469746c 65223a22 52656769 73747261 746f2069 6c206d61 72636869 6f205461 6c657320 6f662058 696c6c69 6120696e 20457572 6f706122 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 34385f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225376 656c6174 69202e68 61636b5c 2f5c2f56 65727375 732e2065 202e6861 636b5c2f 5c2f5365 6b616920 6e6f204d 756b6f75 206e6922 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 33345f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a22476f 6e205061 6b752050 616b7520 50616b75 2050616b 75204164 76656e74 75726520 756e206e 756f766f 2067696f 636f2064 69204e61 6d636f20 42616e64 6169222c 22636174 65676f72 79223a22 5b203344 53205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383432 385f3135 30783830 2e6a7067 227d2c7b 22746974 6c65223a 224e756f 76652069 6d6d6167 696e6920 6520696e 666f2064 69204669 72652045 6d626c65 6d204177 616b656e 696e6722 2c226361 7465676f 7279223a 225b2033 4453205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 31365f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225072 696d6520 696d6d61 67696e69 20646569 206e756f 76692044 4c432064 69204669 6e616c20 46616e74 61737920 58494949 2d32222c 22636174 65676f72 79223a22 5b205053 332c2058 33363020 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3431325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2249 6e206172 7269766f 20717565 73746f20 41757475 6e6e6f20 45706963 204d6963 6b657920 323a2054 68652050 6f776572 206f6620 54776f22 2c226361 7465676f 7279223a 225b2050 53332c20 5769692c 20583336 30205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383430 385f3135 30783830 2e6a7067 227d5d&gt;
2012-03-28 00:43:58.410 VGCollect[5583:f803] B) (null)
</code></pre>

<p>instead that is how i serialize my crypted JSON</p>

<pre><code>NSData *decryptBase64   = [GTMBase64 decodeData:response];
NSData *decrypt3DES     = [Crypt TripleDES:decryptBase64 encryptOrDecrypt:kCCDecrypt key:@""2b9534b45611cbb2436e625d""];
NSLog(@""A) %@"",  decrypt3DES );
NSMutableArray *json = [NSJSONSerialization JSONObjectWithData:decrypt3DES options:kNilOptions error:&amp;error];
NSLog(@""B) %@"",  error);
</code></pre>

<p>and that is the NSLog output</p>

<pre><code>2012-03-28 00:41:51.525 VGCollect[5529:f803] A) &lt;5b7b2274 69746c65 223a2252 696c6173 63696174 61206c61 20707269 6d612045 7370616e 73696f6e 65206469 20526167 6e61726f 6b204f64 79737365 79222c22 63617465 676f7279 223a225b 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3536345f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 68616e74 61737920 53746172 204f6e6c 696e6520 3220616e 63686520 73752069 4f532065 20416e64 726f6964 20222c22 63617465 676f7279 223a225b 20495048 4f4e452c 2050432c 20505356 69746120 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437355f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2250 72696d69 20536372 65656e73 686f7420 696e2061 6c747261 20726973 6f6c757a 696f6e65 20706572 202e6861 636b5c2f 5c2f7665 72737573 222c2263 61746567 6f727922 3a225b20 50533320 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3437325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2269 6c206e75 6f766f20 444c4320 64692046 696e616c 2046616e 74617379 20584949 492d3220 636f6e66 65726d61 746f2061 6e636865 20696e20 416d6572 69636122 2c226361 7465676f 7279223a 225b2050 53332c20 58333630 205d222c 22696d67 55726c22 3a22494d 41474553 5c2f3230 31325c2f 30335c2f 30303030 38343439 5f313530 7838302e 6a706722 7d2c7b22 7469746c 65223a22 52656769 73747261 746f2069 6c206d61 72636869 6f205461 6c657320 6f662058 696c6c69 6120696e 20457572 6f706122 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 34385f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225376 656c6174 69202e68 61636b5c 2f5c2f56 65727375 732e2065 202e6861 636b5c2f 5c2f5365 6b616920 6e6f204d 756b6f75 206e6922 2c226361 7465676f 7279223a 225b2050 5333205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 33345f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a22476f 6e205061 6b752050 616b7520 50616b75 2050616b 75204164 76656e74 75726520 756e206e 756f766f 2067696f 636f2064 69204e61 6d636f20 42616e64 6169222c 22636174 65676f72 79223a22 5b203344 53205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383432 385f3135 30783830 2e6a7067 227d2c7b 22746974 6c65223a 224e756f 76652069 6d6d6167 696e6920 6520696e 666f2064 69204669 72652045 6d626c65 6d204177 616b656e 696e6722 2c226361 7465676f 7279223a 225b2033 4453205d 222c2269 6d675572 6c223a22 494d4147 45535c2f 32303132 5c2f3033 5c2f3030 30303834 31365f31 35307838 302e6a70 67227d2c 7b227469 746c6522 3a225072 696d6520 696d6d61 67696e69 20646569 206e756f 76692044 4c432064 69204669 6e616c20 46616e74 61737920 58494949 2d32222c 22636174 65676f72 79223a22 5b205053 332c2058 33363020 5d222c22 696d6755 726c223a 22494d41 4745535c 2f323031 325c2f30 335c2f30 30303038 3431325f 31353078 38302e6a 7067227d 2c7b2274 69746c65 223a2249 6e206172 7269766f 20717565 73746f20 41757475 6e6e6f20 45706963 204d6963 6b657920 323a2054 68652050 6f776572 206f6620 54776f22 2c226361 7465676f 7279223a 225b2050 53332c20 5769692c 20583336 30205d22 2c22696d 6755726c 223a2249 4d414745 535c2f32 3031325c 2f30335c 2f303030 30383430 385f3135 30783830 2e6a7067 227d5d00&gt;
2012-03-28 00:41:51.530 VGCollect[5529:f803] B) Error Domain=NSCocoaErrorDomain Code=3840 ""The operation couldn’t be completed. (Cocoa error 3840.)"" (Garbage at end.) UserInfo=0x6ccdd40 {NSDebugDescription=Garbage at end.}
</code></pre>

<p>as u can see the only difference between 2 NSlogs is 00 at the end of second hexcode and the error on serialization of it</p>

<p>do u know how fix that ?</p>

<p>idk if is needed, that is my script for encrypt data</p>

<pre><code>+(NSData*)TripleDES:(NSData*)plainData encryptOrDecrypt:(CCOperation)encryptOrDecrypt key:(NSString*)key {

    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [plainData length];
    vplainText = (const void *)[plainData bytes];


    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    // uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));

    //    NSString *key = @""123456789012345678901234"";
    NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       (kCCOptionPKCS7Padding | kCCOptionECBMode) ,
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    NSData *result = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    return result;
}
</code></pre>
","<p>I had same situation and had fix the problem with this code below.</p>

<pre><code>NSString* decoded=[request.responseString stringByDecodeFromServer];
decoded=[decoded stringByTrimmingCharactersInSet:[NSCharacterSet controlCharacterSet]];
LOG_S(decoded);
id response =[NSJSONSerialization JSONObjectWithData:[decoded dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingAllowFragments|NSJSONReadingMutableContainers|NSJSONReadingMutableLeaves error:&amp;error];
</code></pre>

<p>With stringByTrimmingCharactersInSet method, that cut bad data off.</p>
","1177","<ios><json><encryption><3des>","1","3","2","2012-04-15 22:50:39","10166867","2","","","","","2012-03-27 23:26:44",""
"19718060","DES3 encryption: ruby openssl::cipher vs. oracle dbms_obfuscation_toolkit","<p>I have a legacy application written in PL/SQL that encrypts and decrypts data using 3DES. Now I need to perform similar encryption from a ruby app. Eventually the resulting hash will need to be decrypted by the same PL/SQL application using its existing algorithm.</p>

<p>The problem is that I'm obtaining different encrypted results in PL/SQL and Ruby and I don't know why.</p>

<p><strong>First here is exactly how the PL/SQL encryption works:</strong></p>

<p>From Oracle's docs about DBMS_OBFUSCATION_TOOLKIT  <a href=""http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_obtool.htm"" rel=""nofollow"">http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_obtool.htm</a></p>

<p>""Oracle's implementation of 3DES supports either a 2-key or 3-key implementation, in outer cipher-block-chaining (CBC) mode.""</p>

<p>Function signature:</p>

<pre><code>DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
input_string      IN     VARCHAR2,
key_string        IN     VARCHAR2,
encrypted_string  OUT    VARCHAR2,
which             IN     PLS_INTEGER  DEFAULT TwoKeyMode
iv_string         IN     VARCHAR2     DEFAULT NULL);
</code></pre>

<p>Note about the parameter which:
""If = 0, (default), then TwoKeyMode is used. If = 1, then ThreeKeyMode is used.""
This helped me choose the cipher in the ruby version.</p>

<p>Here is how the application makes that call:</p>

<pre><code>set serveroutput on;
declare 
        v_encrypted varchar2(100);
begin  
  dbms_obfuscation_toolkit.des3encrypt(
    input_string =&gt; 'abcdefgh',       -- data to encrypt
    key_string =&gt; '16_byte_string_k', -- 16 byte = 128 bit key needed by DES3Encrypt
    encrypted_string =&gt; v_encrypted,
    iv_string =&gt; 'xxxxxxxx');         -- initialization vector
    dbms_output.put_line( lower(utl_raw.cast_to_raw(v_encrypted)) );
    -- prints 23ff779e88e2dbe1
end;
</code></pre>

<p><strong>Second here is what I'm trying in Ruby:</strong></p>

<p>OpenSSL::Cipher docs:
<a href=""http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html"" rel=""nofollow"">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html</a></p>

<p>OpenSSL docs to give me the cipher name:
From <a href=""http://www.openssl.org/docs/apps/enc.html"" rel=""nofollow"">http://www.openssl.org/docs/apps/enc.html</a>
""des-ede-cbc        Two key triple DES EDE in CBC mode""</p>

<pre><code>require 'openssl'

cipher = OpenSSL::Cipher.new('des-ede-cbc')
cipher.encrypt
input = 'abcdefgh'
cipher.key = '16_byte_string_k'
cipher.iv = 'xxxxxxxx'

# i noticed that cipher.update returns same length hash as PL/SQL
# if called without cipher.final, but you are not supposed to do that
#encrypted = cipher.update(input)
encrypted = cipher.update(input) + cipher.final

hex_representation = encrypted.unpack(""H*"")

puts hex_representation
# prints a5cfc96485d7203eb929c28ceb9fcd53
</code></pre>

<p>As shown in the code the ruby version computes a different hash value. Why? What needs to change to make them consistent?</p>

<p>Points I'm unsure about:</p>

<ul>
<li>Whether des-ede-cbc is in fact the same as what Oracle does.</li>
<li>Whether utl_raw.cast_to_raw and unpack(""H*"") will do the same thing
to the    encrypted binary  data.</li>
<li>What exactly cipher.final appends and if there's any equivalent
way to append that data in PL/SQL.</li>
</ul>

<p><em>Note</em>: I am aware that DES is insecure and that AES has superseded it. My use case does not require these hashes to be unbreakable. The important requirement is to make the hashes consistent so that the PL/SQL app can decrypt hashes generated by the ruby app.</p>
","<p>Let's go digging!</p>

<pre><code>['des-cbc', 'des', 'des-cfb', 'des-ofb', 'des-ecb',
 'des-ede-cbc', 'des-ede', 'des-ede-cfb', 'des-ede-ofb', 
 'des-ede3-cbc', 'des-ede3', 'des3', 'des-ede3-cfb', 
 'des-ede3-ofb', 'desx'].each do |flavour|
  begin
    c = OpenSSL::Cipher.new flavour
    c.encrypt
    c.key = '16_byte_string_k'
    c.iv = 'xxxxxxxx'
    str = 'abcdefgh'
    enc = c.update(str) + c.final
    puts ""#{flavour} gives us #{enc.unpack('H*')}""
  rescue =&gt; e
    puts ""#{flavour} didn't work because #{e.message}""
  end
end
</code></pre>

<p>The results:</p>

<pre><code>des-cbc gives us [""a5cfc96485d7203eb929c28ceb9fcd53""]
des gives us [""a5cfc96485d7203eb929c28ceb9fcd53""]
des-cfb gives us [""d898369e91589ae8""]
des-ofb gives us [""d898369e91589ae8""]
des-ecb gives us [""de8579b342a528b6143594946045d91a""]
des-ede-cbc gives us [""23ff779e88e2dbe1c009dc3105d8ff88""]
des-ede gives us [""0e589e3d85ac83efbb271a2e4a77cf4e""]
des-ede-cfb gives us [""1618988004b6a948""]
des-ede-ofb gives us [""1618988004b6a948""]
des-ede3-cbc didn't work because key length too short
des-ede3 didn't work because key length too short
des3 didn't work because key length too short
des-ede3-cfb didn't work because key length too short
des-ede3-ofb didn't work because key length too short
desx didn't work because key length too short
</code></pre>

<p><code>des-ede-cbc</code> gives you a match--at least the first part matches. The question is, why is the encrypted body longer? I'm going to bet this is the correct content and the PL/SQL version is truncated somehow--I'll see if I can figure it out.</p>

<p><strong>Edit: <em>nope, it's the padding</em></strong>. When you set the padding to 0 on the cipher, you get the same results as the PL/SQL version, e.g.</p>

<pre><code>['des-cbc', 'des', 'des-cfb', 'des-ofb', 'des-ecb',
 'des-ede-cbc', 'des-ede', 'des-ede-cfb', 'des-ede-ofb', 
 'des-ede3-cbc', 'des-ede3', 'des3', 'des-ede3-cfb', 
 'des-ede3-ofb', 'desx'].each do |flavour|
  begin
    c = OpenSSL::Cipher.new flavour
    c.encrypt
    c.key = '16_byte_string_k'
    c.iv = 'xxxxxxxx'
    c.padding = 0 # This is the important part!
    str = 'abcdefgh'
    enc = c.update(str) + c.final
    puts ""#{flavour} gives us #{enc.unpack('H*')}""
  rescue =&gt; e
    puts ""#{flavour} didn't work because #{e.message}""
  end
end

...
des-ede-cbc gives us [""23ff779e88e2dbe1""]
...
</code></pre>

<p>You will need to compare the two algorithms with different lengths of input string now. Take a look at the documentation for the padding method here: <a href=""http://www.ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html"" rel=""nofollow"">http://www.ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html</a></p>
","1156","<ruby><oracle><encryption><openssl><3des>","2","2","2","2016-04-26 08:32:44","19718499","0","","","","","2013-10-31 23:00:19",""
"19718060","DES3 encryption: ruby openssl::cipher vs. oracle dbms_obfuscation_toolkit","<p>I have a legacy application written in PL/SQL that encrypts and decrypts data using 3DES. Now I need to perform similar encryption from a ruby app. Eventually the resulting hash will need to be decrypted by the same PL/SQL application using its existing algorithm.</p>

<p>The problem is that I'm obtaining different encrypted results in PL/SQL and Ruby and I don't know why.</p>

<p><strong>First here is exactly how the PL/SQL encryption works:</strong></p>

<p>From Oracle's docs about DBMS_OBFUSCATION_TOOLKIT  <a href=""http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_obtool.htm"" rel=""nofollow"">http://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_obtool.htm</a></p>

<p>""Oracle's implementation of 3DES supports either a 2-key or 3-key implementation, in outer cipher-block-chaining (CBC) mode.""</p>

<p>Function signature:</p>

<pre><code>DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(
input_string      IN     VARCHAR2,
key_string        IN     VARCHAR2,
encrypted_string  OUT    VARCHAR2,
which             IN     PLS_INTEGER  DEFAULT TwoKeyMode
iv_string         IN     VARCHAR2     DEFAULT NULL);
</code></pre>

<p>Note about the parameter which:
""If = 0, (default), then TwoKeyMode is used. If = 1, then ThreeKeyMode is used.""
This helped me choose the cipher in the ruby version.</p>

<p>Here is how the application makes that call:</p>

<pre><code>set serveroutput on;
declare 
        v_encrypted varchar2(100);
begin  
  dbms_obfuscation_toolkit.des3encrypt(
    input_string =&gt; 'abcdefgh',       -- data to encrypt
    key_string =&gt; '16_byte_string_k', -- 16 byte = 128 bit key needed by DES3Encrypt
    encrypted_string =&gt; v_encrypted,
    iv_string =&gt; 'xxxxxxxx');         -- initialization vector
    dbms_output.put_line( lower(utl_raw.cast_to_raw(v_encrypted)) );
    -- prints 23ff779e88e2dbe1
end;
</code></pre>

<p><strong>Second here is what I'm trying in Ruby:</strong></p>

<p>OpenSSL::Cipher docs:
<a href=""http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html"" rel=""nofollow"">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/openssl/rdoc/OpenSSL/Cipher.html</a></p>

<p>OpenSSL docs to give me the cipher name:
From <a href=""http://www.openssl.org/docs/apps/enc.html"" rel=""nofollow"">http://www.openssl.org/docs/apps/enc.html</a>
""des-ede-cbc        Two key triple DES EDE in CBC mode""</p>

<pre><code>require 'openssl'

cipher = OpenSSL::Cipher.new('des-ede-cbc')
cipher.encrypt
input = 'abcdefgh'
cipher.key = '16_byte_string_k'
cipher.iv = 'xxxxxxxx'

# i noticed that cipher.update returns same length hash as PL/SQL
# if called without cipher.final, but you are not supposed to do that
#encrypted = cipher.update(input)
encrypted = cipher.update(input) + cipher.final

hex_representation = encrypted.unpack(""H*"")

puts hex_representation
# prints a5cfc96485d7203eb929c28ceb9fcd53
</code></pre>

<p>As shown in the code the ruby version computes a different hash value. Why? What needs to change to make them consistent?</p>

<p>Points I'm unsure about:</p>

<ul>
<li>Whether des-ede-cbc is in fact the same as what Oracle does.</li>
<li>Whether utl_raw.cast_to_raw and unpack(""H*"") will do the same thing
to the    encrypted binary  data.</li>
<li>What exactly cipher.final appends and if there's any equivalent
way to append that data in PL/SQL.</li>
</ul>

<p><em>Note</em>: I am aware that DES is insecure and that AES has superseded it. My use case does not require these hashes to be unbreakable. The important requirement is to make the hashes consistent so that the PL/SQL app can decrypt hashes generated by the ruby app.</p>
","<p>We had the same problem with one important difference: Our database procedure did not specify an initialization vector (IV) when encrypting the passwords. Omitting the IV in ruby did not lead to the same result as omitting it in the Oracle procedure call, so both seemed to use different ""default"" IVs.</p>

<p>The default Oracle IV is ""0123456789abcdef"" hex decoded as some guys figured out here: <a href=""https://community.oracle.com/thread/1528090"" rel=""nofollow"">https://community.oracle.com/thread/1528090</a></p>

<p>In Ruby you can set it like this:</p>

<pre><code>['des-cbc', 'des', 'des-cfb', 'des-ofb', 'des-ecb',
 'des-ede-cbc', 'des-ede', 'des-ede-cfb', 'des-ede-ofb', 
 'des-ede3-cbc', 'des-ede3', 'des3', 'des-ede3-cfb', 
 'des-ede3-ofb', 'desx'].each do |flavour|
  begin
    c = OpenSSL::Cipher.new flavour
    c.encrypt
    c.key = '16_byte_string_k'
    c.iv = ['0123456789abcdef'].pack('H*') # Required if no IV is set in Oracle!
    c.padding = 0
    str = 'abcdefgh'
    enc = c.update(str) + c.final
    puts ""#{flavour} gives us #{enc.unpack('H*')}""
  rescue =&gt; e
    puts ""#{flavour} didn't work because #{e.message}""
  end
end
</code></pre>
","1156","<ruby><oracle><encryption><openssl><3des>","2","0","2","2016-04-26 08:32:44","19718499","0","","","","","2013-10-31 23:00:19",""
"20121076","3DES Decrypt in java a token encrypted in C#","<p>I've searched a lot before asking, but none of the ideas I found work in my problem so here's my problem :</p>

<ol>
<li>In C# the code (which I cannot change because it is from another application) for encryption is detailed after.</li>
<li>I have to decrypt the encrypted token in Java but nothing works so far, can anyone help ?</li>
</ol>

<p>For 1. C# code :</p>

<pre><code>    static public string Encrypt3DES(string toEncrypt, string SecKey, string IV){
    byte[] keyArray;
    try
    {
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

    MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
        keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(SecKey));
        hashmd5.Clear();      

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

        tdes.Key = keyArray;      
        tdes.Mode = CipherMode.CBC;
    tdes.Padding = PaddingMode.PKCS7;
        tdes.IV = UTF8Encoding.UTF8.GetBytes(IV);

        ICryptoTransform cTransform = tdes.CreateEncryptor();

        //transform the specified region of bytes array to resultArray
        byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
    tdes.Clear();

    //Return the encrypted data into unreadable string format
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
    catch (Exception e) { return string.Empty; }
    }
</code></pre>

<p>For 2 Java code that does not work :</p>

<pre><code>    public class TripleDesTest {

private KeySpec keySpec;
private SecretKey key;
private IvParameterSpec iv;

public TripleDesTest() {
    String keyString = ""THE_KEY"";
    String ivString = ""THE_IV"";

    try {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(""UTF-8"")));            
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        keySpec = new DESedeKeySpec(keyBytes);

        key = SecretKeyFactory.getInstance(""DESede"").generateSecret(keySpec);

        iv = new IvParameterSpec(ivString.getBytes(""UTF-8""));
    } catch (Exception e) {
        e.printStackTrace();
    }

}


public String decrypt(String value) {

    try {
        Cipher dcipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"", ""SunJCE"");
        dcipher.init(Cipher.DECRYPT_MODE, key, iv);

        if (value == null)
            return null;

        // Decode base64 to get bytes
        byte[] dec = Base64.decodeBase64(value.getBytes(""UTF-8""));

        // Decrypt
        byte[] utf8 = dcipher.doFinal(dec);

        // Decode using UTF-8
        return new String(utf8, ""UTF-8"");
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;

}
    }
</code></pre>
","<p>Here is the solution to the problem (I finally was able to solve this myself) :</p>

<p>In Java, replace        </p>

<pre><code>final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(""UTF-8"")));`
</code></pre>

<p>with :</p>

<pre><code>final byte[] digestOfPassword = md.digest(keyString.getBytes(""UTF-8""));
</code></pre>

<p>Because on the C# side, no Base64 is used for the key :</p>

<pre><code>keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(SecKey));
</code></pre>
","1154","<c#><java><encryption><base64><3des>","0","0","1","2013-11-25 09:42:53","20188791","2","2","","","","2013-11-21 12:30:50",""
"11417816","How to add and retrieve TDES IV (Initialization Vector) in encrypted string","<p>I’m working on a mvc application over .Net, to secure my sensitive information such as info in web.config I’ve got two functions that encrypts and decrypts information using Triple DES, however I’m new to this and succeeded to reach till here by the help of a friend and asking few question over here.</p>

<p>The point where I’m currently stuck is how can I add TDES <code>IV (Initialization Vector)</code> at the end of the encrypted string and how also retrieve it again while decrypting? I mean how would you identify in an encrypted info that from here the <code>IV (Initialization Vector)</code> stars?</p>

<p>Kindly help.</p>

<pre><code>public static string Encrypt(string Message)
    {
        byte[] iv;
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String()));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
        TDESAlgorithm.Key = TDESKey;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        // Capture the randomly generated IV
        iv = TDESAlgorithm.IV;
        byte[] DataToEncrypt = UTF8.GetBytes(Message);
        try
        {
            ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
            Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
            //var lnght=Results.GetLength(0);
            //System.Buffer.BlockCopy(iv, 0, Results, lnght + 1, iv.Length()); //HOW?
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }
        return Convert.ToBase64String(Results);
        //return Encoding.UTF8.GetString(Results);
    }

    public static string Decrypt(string Message)
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String()));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
        TDESAlgorithm.Key = TDESKey;
        // Apply the same IV used during encryption
        //TDESAlgorithm.IV = iv;  // HOW?
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        try
        {
            byte[] DataToDecrypt = Convert.FromBase64String(Message);
            //byte[] DataToDecrypt = UTF8.GetBytes(Message);
            //byte[] DataToDecrypt = Encoding.UTF8.GetBytes(Message);
            ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
            Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length); // &lt;&lt; ERROR is here.
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }
        return UTF8.GetString(Results);
    }

…
…
…
</code></pre>
","<p>Your problem is that you're using ECB mode. ECB doesn't support IVs, and has a number of undesirable properties. You could switch to CBC instead.</p>

<p>Typically you put the IV before and not after the encrypted data. GameScripting's answer shows one way to do that.</p>

<p>Finally your key derivation looks dubious, but since it's incomplete I can't tell you what you should do there.</p>
","1146","<.net><encryption><3des><tripledes>","1","2","1","2012-07-10 19:11:26","11420248","1","","","","","2012-07-10 16:33:09",""
"33869814","Using mcrypt_encrypt() give me warning ""Size of key is too long""","<p>I'm trying to use mcrypt_encrypt() in PHP but I've a problem when I use the function to encrypt:</p>

<p>My code is:</p>

<p>Vars:</p>

<pre><code>$key = ""1e1r1r1t1y1y1g1g1g1g1g1345678910""; // That is a example, the real key have 32 long too.
$ref=""12013515""; // example value

// Tamanio Encripyt ....
$iv_size = mcrypt_get_iv_size(MCRYPT_3DES,MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size,MCRYPT_RAND);
// Lunch
$stringEncrypted = mcrypt_encrypt(MCRYPT_3DES,$key,$ref,MCRYPT_MODE_CBC,$iv);
</code></pre>

<p>If I do that, PHP show me the error:</p>

<pre><code>Warning: mcrypt_encrypt(): Size of key is too large for this algorithm
</code></pre>

<p>I need to use the encrypt 3DES...what can be the problem?</p>
","<p>Your key is to long. Maximum key length for 3DES in CBC mode is 24 chars.</p>

<p>3DES has a key length of 168 bit. 168 bit / 24 chars = 7 bit per char.</p>

<p>To get the max key length for a given algorith use:</p>

<pre><code>mcrypt_get_key_size(MCRYPT_3DES,MCRYPT_MODE_CBC)
</code></pre>

<p>@see <a href=""http://php.net/manual/en/function.mcrypt-get-key-size.php"" rel=""nofollow"">http://php.net/manual/en/function.mcrypt-get-key-size.php</a></p>
","1124","<php><3des>","0","0","3","2015-11-25 11:36:08","33870056","0","","","","","2015-11-23 11:19:40",""
"33869814","Using mcrypt_encrypt() give me warning ""Size of key is too long""","<p>I'm trying to use mcrypt_encrypt() in PHP but I've a problem when I use the function to encrypt:</p>

<p>My code is:</p>

<p>Vars:</p>

<pre><code>$key = ""1e1r1r1t1y1y1g1g1g1g1g1345678910""; // That is a example, the real key have 32 long too.
$ref=""12013515""; // example value

// Tamanio Encripyt ....
$iv_size = mcrypt_get_iv_size(MCRYPT_3DES,MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size,MCRYPT_RAND);
// Lunch
$stringEncrypted = mcrypt_encrypt(MCRYPT_3DES,$key,$ref,MCRYPT_MODE_CBC,$iv);
</code></pre>

<p>If I do that, PHP show me the error:</p>

<pre><code>Warning: mcrypt_encrypt(): Size of key is too large for this algorithm
</code></pre>

<p>I need to use the encrypt 3DES...what can be the problem?</p>
","<p>Key of size 32 not supported by this algorithm. Only keys of size 24 supported.</p>
","1124","<php><3des>","0","0","3","2015-11-25 11:36:08","33870056","0","","","","","2015-11-23 11:19:40",""
"33869814","Using mcrypt_encrypt() give me warning ""Size of key is too long""","<p>I'm trying to use mcrypt_encrypt() in PHP but I've a problem when I use the function to encrypt:</p>

<p>My code is:</p>

<p>Vars:</p>

<pre><code>$key = ""1e1r1r1t1y1y1g1g1g1g1g1345678910""; // That is a example, the real key have 32 long too.
$ref=""12013515""; // example value

// Tamanio Encripyt ....
$iv_size = mcrypt_get_iv_size(MCRYPT_3DES,MCRYPT_MODE_CBC);
$iv = mcrypt_create_iv($iv_size,MCRYPT_RAND);
// Lunch
$stringEncrypted = mcrypt_encrypt(MCRYPT_3DES,$key,$ref,MCRYPT_MODE_CBC,$iv);
</code></pre>

<p>If I do that, PHP show me the error:</p>

<pre><code>Warning: mcrypt_encrypt(): Size of key is too large for this algorithm
</code></pre>

<p>I need to use the encrypt 3DES...what can be the problem?</p>
","<p>For that case, I need to ignore the size value for this type of encription (I can't change the key and type of encription).</p>

<p>I read some post with the same problem and that solution. </p>

<p>Thanks everybody for the help.</p>
","1124","<php><3des>","0","0","3","2015-11-25 11:36:08","33870056","0","","","","","2015-11-23 11:19:40",""
"6049810","TripleDESCryptoServiceProvider using hex key","<p>I am using TripleDESCryptoServiceProvider to encrypt a series of bytes in C#. The key which is passed to  me is in like this <code>FFC7B905AD6ACB57D662115FD65FA338</code> which i believe is a hex. How can i get this value into <code>TripleDESCryptoServiceProvider.Key</code> property which accepts a byte array or how do i copy this value to a byte array so that i can pass to key property.</p>

<p>Thanks in advance,</p>

<p>John</p>
","<p>Just parse the hex to a byte array - nothing to do with encryption, really.</p>

<p>There are lots of bits of sample code to do that here on Stack Overflow, including <a href=""https://stackoverflow.com/questions/854012/how-to-convert-hex-to-a-byte-array"">my answer here</a>.</p>

<p>(Not closing this question as a duplicate, as it's not <em>quite</em> a duplicate - it's really about understanding that it's a matter of parsing to a byte array first.)</p>
","1119","<c#><.net><encryption><3des>","2","3","1","2011-05-18 19:11:50","6049840","0","","","","","2011-05-18 19:08:48",""
"4885797","How do I use 3DES decryption in C# in OFB mode?","<p>I posted this same question last night but I gave a very poor example of code. Hopefully this will make it easier to understand my situation.</p>

<p>I need to decrypt messages that have been encrypted using 3DES in OFB mode with null padding.</p>

<p>Here's my attempt to do the decryption using code I grabbed from the web. </p>

<p>The encrypted message, key and IV are all verified as correct.</p>

<p>It produces the following error:</p>

<p><strong>A Cryptographic error occurred: Specified key is not a valid size for this algorithm.</strong></p>

<p>Assuming all else is well with the code, how do I change the cipher mode so it's OFB with null padding?</p>

<p>using System;
using System.Collections.Generic;
using System.Text;</p>

<p>namespace _DESapp
{
    using System;
    using System.Security.Cryptography;
    using System.Text;
    using System.IO;</p>

<pre><code>class TrippleDESCSPSample
{

    static void Main()
    {
        try
        {
            int discarded;
            byte[] encrypteddata = Convert.FromBase64String( ""zbv67qbzN6pD2Uaog62u8WgZOcOz"");
            byte[] key = Convert.FromBase64String( ""wSQ90YI+lAauwVVSySAi8u0P"");
            byte[] IV = HexEncoding.GetBytes(""ac3834bfbda8eb07"", out discarded);

            string decrypteddata = DecryptTextFromMemory( encrypteddata, key, IV);

            Console.ReadLine();

        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }

    }

    public static string DecryptTextFromMemory(byte[] Data, byte[] Key, byte[] IV)
    {
        try
        {
            // Create a new MemoryStream using the passed 
            // array of encrypted data.
            MemoryStream msDecrypt = new MemoryStream(Data);

            // Create a CryptoStream using the MemoryStream 
            // and the passed key and initialization vector (IV).

            ICryptoTransform des = new TripleDESCryptoServiceProvider().CreateDecryptor(Key, IV);

            CryptoStream csDecrypt = new CryptoStream(msDecrypt, des, CryptoStreamMode.Read);
            //CryptoStream csDecrypt = new CryptoStream(msDecrypt,
            //    new TripleDESCryptoServiceProvider().CreateDecryptor(Key, IV),
            //    CryptoStreamMode.Read);

            // Create buffer to hold the decrypted data.
            byte[] fromEncrypt = new byte[Data.Length];

            // Read the decrypted data out of the crypto stream
            // and place it into the temporary buffer.
            csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length);

            //Convert the buffer into a string and return it.
            return new ASCIIEncoding().GetString(fromEncrypt);
        }
        catch (CryptographicException e)
        {
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message);
            return null;
        }
    }


    public class HexEncoding
    {
        public HexEncoding()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        public static byte[] GetBytes(string hexString, out int discarded)
        {
            discarded = 0;
            string newString = """";
            char c;
            // remove all none A-F, 0-9, characters
            for (int i = 0; i &lt; hexString.Length; i++)
            {
                c = hexString[i];
                if (IsHexDigit(c))
                    newString += c;
                else
                    discarded++;
            }
            // if odd number of characters, discard last character
            if (newString.Length % 2 != 0)
            {
                discarded++;
                newString = newString.Substring(0, newString.Length - 1);
            }

            int byteLength = newString.Length / 2;
            byte[] bytes = new byte[byteLength];
            string hex;
            int j = 0;
            for (int i = 0; i &lt; bytes.Length; i++)
            {
                hex = new String(new Char[] { newString[j], newString[j + 1] });
                bytes[i] = HexToByte(hex);
                j = j + 2;
            }
            return bytes;
        }

        public static bool IsHexDigit(Char c)
        {
            int numChar;
            int numA = Convert.ToInt32('A');
            int num1 = Convert.ToInt32('0');
            c = Char.ToUpper(c);
            numChar = Convert.ToInt32(c);
            if (numChar &gt;= numA &amp;&amp; numChar &lt; (numA + 6))
                return true;
            if (numChar &gt;= num1 &amp;&amp; numChar &lt; (num1 + 10))
                return true;
            return false;
        }

        private static byte HexToByte(string hex)
        {
            if (hex.Length &gt; 2 || hex.Length &lt;= 0)
                throw new ArgumentException(""hex must be 1 or 2 characters in length"");
            byte newByte = byte.Parse(hex, System.Globalization.NumberStyles.HexNumber);
            return newByte;
        }

    }

}
</code></pre>

<p>}</p>
","","1117","<c#><encryption><3des>","0","","0","2011-02-03 11:54:04","","0","0","","","","2011-02-03 11:54:04",""
"18102056","PHP : OpenSSL equivilent of mcrypt : MCRYPT_3DES?","<p>We would like to convert our use of mcrypt to openssl.</p>

<p>Here is our encryption function:</p>

<pre><code>mcrypt_ecb(MCRYPT_3DES,$key,$payload,MCRYPT_ENCRYPT)
</code></pre>

<p>Here is our decryption function:</p>

<pre><code>mcrypt_ecb(MCRYPT_3DES,$key,$payload,MCRYPT_DECRYPT)
</code></pre>

<p>What are the openssl_* equivalents of the above?</p>

<p>Thanks.</p>
","<p>I think you're looking for the <code>EVP_Encrypt...</code> functions with <code>EVP_des_ede3</code> as the cipher (although you should really be using CBC mode rather than ECB).</p>

<p><a href=""https://www.openssl.org/docs/crypto/EVP_EncryptInit.html#"" rel=""nofollow"">https://www.openssl.org/docs/crypto/EVP_EncryptInit.html#</a></p>

<p>If it helps, I have a short example for AES written in C++ at <a href=""https://github.com/shanet/Crypto-Example"" rel=""nofollow"">https://github.com/shanet/Crypto-Example</a>. Converting it to use triple DES should be trivial.</p>
","1043","<php><openssl><mcrypt><3des>","1","0","1","2013-08-07 22:55:59","","0","","","","","2013-08-07 11:20:59",""
"14599066","iOS 3DES encryption with md5 key","<p>Can you help me please. </p>

<p>I have developed an iOS application. I tried to encrypt a string with the 3DES algorithm, but I found a different result from Java code. Key should be md5 and size 24 byte. My friend encrypted the plaintext with Java and he got an encrypted base64 string. but I get different results. :(</p>

<p>Where am I going wrong?</p>
","<p>md5 outputs a 128 bit (16 byte) hash, while 3DES takes a 168 bit (21 byte) key.  I would suspect that passing an md5 hash into your encryption and/or decryption algorithm is causing some padding to take place along the way.</p>

<p>It would be better to either use SHA256 (which outputs a 256 bit hash) and truncate the output to 168 bits, or use AES-256 instead of 3DES with the full 256 bit hash as the key.  Even better than that would be to use a proper key derivation function like <a href=""http://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">PBKDF2</a> to create a key from a string password.</p>
","1043","<ios><objective-c><encryption><md5><3des>","1","2","1","2013-01-31 21:20:16","14607902","0","2","1904979","","2013-01-31 21:20:16","2013-01-30 07:55:41",""
"11662052","3DES in PHP is not same as Java","<p>I have a 3DES encrypted string from a service on java as - </p>

<pre><code>30BA1A87B3B08F8A6F69BF0E2EC7539B
</code></pre>

<p>when i am applying 3DES encryption in PHP to check the result, i am getting a very different string which is as - </p>

<pre><code>ªã;Îù1ù@yq—ÿÃÓ""Õó[ûñüM“ƒº5fá$!Ø5JºÝ7
</code></pre>

<p>i am using an open source PHP lib for encryption, which is Crypt_TripleDES from <a href=""http://sourceforge.net/projects/phpseclib/"" rel=""nofollow"">http://sourceforge.net/projects/phpseclib/</a>.</p>

<p>Can someone help me, to understand what is wrong and where?</p>

<p>Please ask if I am missing anything.</p>

<p>Thanks</p>

<p>PHP Code - </p>

<pre><code>require_once 'Crypt/TripleDES.php';
$tdes = new Crypt_TripleDES();
$tdes-&gt;setKey($key);
$enc_text = $tdes-&gt;encrypt($text);
echo 'Encrypted text - '.($enc_text).'&lt;br /&gt;';
</code></pre>
","<p>It is most like just how you are displaying the information. </p>

<p>In your first line, it appears you are outputting the string as hex. That is, each byte of the data is converted into two hexadecimal characters.</p>

<p>In your second line, it looks like you may just be trying to dump the raw binary to the output. That is, each byte is interpreted as an ASCII character, which makes sense why it looks like hell.</p>

<p>Can we get more information about your Java output? How did you get it exactly?</p>

<hr>

<p>After looking at the library, it seems that yes, it is returning the raw binary string.  To convert this to hex, you simply need to call the built-in <a href=""http://php.net/manual/en/function.bin2hex.php"" rel=""nofollow""><code>bin2hex()</code></a> function:</p>

<pre><code>require_once 'Crypt/TripleDES.php';
$tdes = new Crypt_TripleDES();
$tdes-&gt;setKey($key);
$enc_text = $tdes-&gt;encrypt($text);
echo 'Encrypted text - ' . bin2hex($enc_text) . '&lt;br /&gt;';
</code></pre>
","1040","<java><php><encryption><3des>","0","1","1","2012-07-27 00:08:41","11662099","1","","892840","","2012-07-26 07:36:38","2012-07-26 03:45:21",""
"22565679","3DES PHP Encryption Not Decrypting Properly","<p>I'm using the following code to encrypt information that will be passed to an external site on the end of the link URL. Right now it's able to do the encrypting and decrypting itself, but when I go to online Decryptors (<a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">online-domain-tools.com</a>, <a href=""http://www.tools4noobs.com/online_tools/decrypt/"" rel=""nofollow noreferrer"">tools4noobs.com</a>)  I'm seeing extra symbols added or it's not showing the right content whatsoever. Of course I'm new to this. What I have, I have pieced together from other questions (<a href=""https://stackoverflow.com/questions/8530312/php-equivalent-for-java-triple-des-encryption-decryption"">php-equivalent-for-java-triple-des-encryption-decryption</a>, <a href=""https://stackoverflow.com/questions/22181357/php-equivalent-encryption-decryption-for-java-tripledes-i-dont-get-the-same-en"">php-equivalent-encryption-decryption-tripledes</a>, <a href=""https://stackoverflow.com/questions/13347528/php-encrypt-decrypt-with-tripledes-pkcs7-and-ecb"">php-encrypt-decrypt-with-tripledes-pkcs7-and-ecb</a>). Thanks for any help or direction! </p>

<p>I can only use 3DES with CBC.</p>

<p>PHP Code:</p>

<pre><code>$key = ""12AB12AB12AB12AB12AB12AB"";
$iv = ""12AB12AB"";
$cipher = mcrypt_module_open(MCRYPT_3DES, '', 'cbc', '');

// MESSAGE
$message = ""email=billysmith@afakeemail.com&amp;account=987654321&amp;role=2"";
echo 'Message:::  ' .$message .'&lt;br /&gt;';

// ENCRYPTED
$encrypted = Encryptor($message);
echo 'Encrypted:::  ' .$encrypted .'&lt;br /&gt;';

// DECRYPTED
$decrypted = Decryptor($encrypted);
echo 'Decrypted:::  ' .$decrypted .'&lt;br /&gt;';

function Encryptor($buffer) {
  global $key, $iv, $cipher;

  // get the amount of bytes to pad
  $extra = 8 - (strlen($buffer) % 8);

  // add the zero padding
  if($extra &gt; 0) {
    for($i = 0; $i &lt; $extra; $i++) {
      $buffer .= ""\0"";
    }
  }
  mcrypt_generic_init($cipher, $key, $iv);
  $result = bin2hex(mcrypt_generic($cipher, $buffer));
  mcrypt_generic_deinit($cipher);
  return $result;
}

function Decryptor($buffer) {
  global $key, $iv, $cipher;

  mcrypt_generic_init($cipher, $key, $iv);
  $result = rtrim(mdecrypt_generic($cipher, hex2bin($buffer)), ""\0"");
  mcrypt_generic_deinit($cipher);
  return $result;
}

function hex2bin($data)
{
  $len = strlen($data);
  return pack(""H"" . $len, $data);
} 
</code></pre>
","<p>To be short: Your code is correct. You can't test your encryption with provided tools.</p>

<p>Both tools do not allow to enter your IV.</p>

<p>The IV should be unique and can be transferred publicly.</p>

<p>Using wrong IV by decoding gives you wrong part at the beginning of decrypted data.</p>

<p>Here is OO version. It uses zero padding (built in PHP), like your code. It also makes no padding **, if the original message is already aligned.</p>

<pre><code>&lt;?php

$key = ""12AB12AB12AB12AB12AB12AB"";
$iv = ""12AB12AB"";

// MESSAGE
$message = ""email=billysmith@afakeemail.com&amp;account=987654321&amp;role=22"";
echo 'Message:::   ' . $message . PHP_EOL;


$cryptor = new Crypt3Des();

$encryptedMessage = $cryptor-&gt;encrypt($message, $key, $iv);
echo 'Encrypted:::  ' . bin2hex($encryptedMessage) . PHP_EOL;

$decryptedMessage = $cryptor-&gt;decrypt($encryptedMessage, $key, $iv);
echo 'Decrypted:::  ' . $decryptedMessage . PHP_EOL;

class Crypt3Des
{
    private $cipher;

    public function __construct()
    {
        $this-&gt;cipher = mcrypt_module_open(MCRYPT_3DES, '', 'cbc', '');
    }

    public function encrypt($data, $key, $iv)
    {
        mcrypt_generic_init($this-&gt;cipher, $key, $iv);
        $result = mcrypt_generic($this-&gt;cipher, $data);
        mcrypt_generic_deinit($this-&gt;cipher);
        return $result;
    }

    public function decrypt($encryptedData, $key, $iv)
    {
        mcrypt_generic_init($this-&gt;cipher, $key, $iv);
        $result = mdecrypt_generic($this-&gt;cipher, $encryptedData);
        mcrypt_generic_deinit($this-&gt;cipher);
        $result = rtrim($result, ""\0"");
        return $result;
    }
}


// Before 5.4.0
if (!function_exists('hex2bin')) {
    function hex2bin($data)
    {
        $len = strlen($data);
        return pack(""H"" . $len, $data);
    }
}
</code></pre>
","1029","<php><security><encryption><3des><tripledes>","3","1","1","2014-03-28 08:28:23","22614892","0","1","-1","","2017-05-23 12:31:01","2014-03-21 17:33:42",""
"23529733","php encrypt string using huawei md5 + 3des","<p>hey
thanks for reading in advance.</p>

<p>I am facing some issue in encrypting something in 3des, it is working but doesn't seem to out the proper values</p>

<p>purpose:
i need to authenticate to a rest API from php to be able to retrieve info,
their documentation states this :</p>

<ol>
<li>step 1 call the login function to receive a token (i have this)</li>
<li>step 2, call the authorize function using a string generated from the token</li>
</ol>

<p>I have implemented the below code, but not sure if am doing something wrong,
here's some info from the docs</p>

<p>The process to generate key is as follows:<br>
1.  The internal value 99991231 defined by Huawei is added in the plain text to be encrypted. Result A is generated.<br>
2.  The standard MD5 algorithm is executed on result A. Result B is generated.<br>
3.  Result B is converted into a hexadecimal number. Result C is generated.<br>
If the first character is 0 in the hexadecimal string, ignore it. If another character is 0, retain it. For example, 0x0100101F3B is converted into 100101F3B.<br>
4.  The first eight characters in result C are obtained. Result D is generated.<br>
5.  The characters in result D are converted into lowercase characters. The encrypted text is generated.   </p>

<p>this is the example code they have provided to generate md5 huawei (i think it's java? need it's php equivalent)</p>

<pre><code>byte[] id = plainPwd.getBytes();

MessageDigest md = MessageDigest.getInstance(""MD5"");
md.update(id);
md.update(""99991231"".getBytes());           // “99991231” mentioned in XML-API DOC

byte[] buffer = md.digest();
StringBuffer sb = new StringBuffer();
for (int i = 0; i &lt;buffer.length; i++) {
    sb.append(Integer.toHexString((int) buffer[i] &amp; 0xff));
}
String md5Pwd = sb.substring(0, 8);         // only use first 8 characters
</code></pre>

<p>this is what is required:</p>

<p>The 3DES encryption algorithm is used to generate an authenticator. The format of a plain text to be encrypted is as follows:
Random+""$""+EncryToken+""$""+userid+""$""+terminalid+""$""+terminalip+""$""+mac+""$""+Reserved+""$""+""CTC""</p>

<p>they key is generated based on this:</p>

<blockquote>
  <p>The 3DES encryption result is converted into a hexadecimal string in<br>
  ASCII mode, in which letters A to F are in uppercase. For example, if<br>
  the 3DES encryption result is 0x0123456789ABCDEF, the value of<br>
  Authenticator is 0123456789ABCDEF. The process of generating an<br>
  authenticator is as follows:<br>
  1.    A client sends a subscriber authentication request to the EPG server.   Request URL: http.../XML/Authenticate<br>
   UserID: 10086  Mac address: ABCDEFGH<br>
  2.    The EPG server returns enctytoken (for example, AD75B1697FB5EB6345B2D412124030D2) and encryptiontype (for example,
  MD5) to the client.<br>
  3.    The client encrypts the subscriber's password (for example, 0 in plain text) using  the MD5 algorithm to generate a key, for example,
  db90e7eb.<br>
  4.    The client generates a string randomly, for example, 20926330.<br>
  5.    The client generates a string of plain text to be encrypted based on each parameter.    The following is an example:<br>
  20926330$AD75B1697FB5EB6345B2D412124030D2$10086$10086$10.164.111$ABCDEFGH$Reserved$CTC<br>
  6.    The client uses the 3DES algorithm to encrypt the string to generate an authenticator. The following is a code example:<br>
  567A7A72AE33C8867936AB0190EC9F2405B20D4A4808D2A8E8CBC0D7D5482E4F53454EA4F37A29B81A63ECB0BF717E96505EE59476799D932F16AEBFECE097171159095DC57DA84D91930AF92EF96E75486DEA0DEA781D51</p>
</blockquote>

<p>they also have this code(I think java) example which also i need its equivalent in php:</p>

<pre><code>public class DESUtil
{
    private static final String Algorithm = ""DESede/ECB/PKCS5Padding"";// DESede/ECB/PKCS5Padding;DESede

    private static final String DESede = ""DESede"";

    public static byte[] encrypt(byte[] keybyte, byte[] src)
    throws NoSuchAlgorithmException, NoSuchPaddingException, Exception
    {
        SecretKey deskey = new SecretKeySpec(keybyte, DESede);
        Cipher c1 = Cipher.getInstance(Algorithm);
        c1.init(Cipher.ENCRYPT_MODE, deskey);
        return c1.doFinal(src);
    }

    public static byte[] decrypt(byte[] keybyte, byte[] src)
        throws NoSuchAlgorithmException, NoSuchPaddingException, Exception
    {
        SecretKey deskey = new SecretKeySpec(keybyte, DESede);
        Cipher c1 = Cipher.getInstance(Algorithm);
        c1.init(Cipher.DECRYPT_MODE, deskey);
        return c1.doFinal(src);
    }

    public static String byte2hex(byte[] b)
    {
        StringBuffer hs = new StringBuffer();
        String stmp = """";
        for (int n = 0; n &lt;b.length; n++)
        {
            stmp = (java.lang.Integer.toHexString(b[n] &amp; 0XFF));
            if (stmp.length() == 1)
                hs.append(""0"").append(stmp);
            else
                hs.append(stmp);
        }
        return hs.toString().toUpperCase(Locale.getDefault());
    }

    public static byte[] hex2byte(String hexStr)
    {
        if (hexStr.length() % 2 != 0)
        {
            AppLogger.error(""hex2bytes's hexStr length is not even."");
            return null;
        }

        byte[] toBytes = new byte[hexStr.length() / 2];
        for (int i = 0, j = 0; i &lt;hexStr.length(); j++, i = i + 2)
        {
            int tmpa = Integer.decode(
                ""0X"" + hexStr.charAt(i) + hexStr.charAt(i + 1)).intValue();
            toBytes[j] = (byte) (tmpa &amp; 0XFF);
        }
        return toBytes;
    }


    public static void main(String[] args)
    {
        Security.addProvider(new com.sun.crypto.provider.SunJCE());
        final byte[] rawKey = ""db90e7eb"".getBytes();
        final byte[] keyBytes = new byte[24];

        for (int i = 0; i &lt;rawKey.length; i++)
        {
            keyBytes[i] = rawKey[i];
        }

        for (int i = rawKey.length; i &lt;keyBytes.length; i++)
        {
            keyBytes[i] = (byte)0;
        }

        String szSrc = ""20926330$AD75B1697FB5EB6345B2D412124030D2$10086$10086$10.164.111$ABCDEFGH$Reserved$CTC"";
        System.out.println(""string before encrypt:"" + szSrc);
        byte[] encoded = null;

        try
        {
            encoded = encrypt(keyBytes, szSrc.getBytes());
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(""string after encrypt::"" + byte2hex(encoded));

        byte[] srcBytes = null;

        try
        {
            srcBytes = decrypt(keyBytes, encoded);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        System.out.println(""string before decode: :"" + (new String(srcBytes)));
    }
}
</code></pre>

<p>the php code i did based on some online references is below, but api doesnt seem to like it and the encrypted code length seems too long, this is the result of my code + the api's response:</p>

<blockquote>
  <p>encrypted: 
  y8V17%2BEImP88UyoQRfGbjldYjfGzsR4r%2B04sE1kPOwPdQNeH1jEhZMYTAgdgeinT6A%2BUfXCFI5KN9QDCTq2oz7AZqTlFEfztQRdgW2ij6YvwQVbRsblJwA%3D%3D</p>
  
  <p>Decrypt
  15173232$BCE723AE4BC97FAD6293D73B2266361D$20140409$20140409$$ABCDEFGH$Reserved$CTC</p>
  
  <p>encrypted hex: 
  793856313725324245496D50383855796F51526647626A6C64596A66477A7352347225324230347345316B504F775064514E6548316A45685A4D59544167646765696E543641253242556658434649354B4E395144435471326F7A37415A71546C4645667A74515264675732696A365976775156625273626C4A7741253344253344</p>
  
  <p>3des authenticator: 
  y8V17%2BEImP88UyoQRfGbjldYjfGzsR4r%2B04sE1kPOwPdQNeH1jEhZMYTAgdgeinT6A%2BUfXCFI5KN9QDCTq2oz7AZqTlFEfztQRdgW2ij6YvwQVbRsblJwA%3D%3D</p>
  
  <p>SimpleXMLElement Object (</p>

<pre><code>[retmsg] =&gt; 3DES decrypt error second time(0x30), please check epg's encrytMode and acs's encryMode.
</code></pre>
</blockquote>

<p>my PHP code to be checked for any wrong details:</p>

<pre><code>$userid = '123';
$terminalip = '';
$mac = 'ABCDEFGH';
$terminalid = $userid;
$pin = '123';
$encToken = 'testtest';

$encryption_key = $pin;
$authenticator = rand(0,99999999).'$'.$encToken.'$'.$userid.'$'.$terminalid.'$'.$terminalip.'$'.$mac.'$'.'Reserved'.'$'.'CTC';

$desEncryptedData = encrypt($authenticator, $encryption_key);
echo ""encrypted: &lt;br&gt;"".$desEncryptedData;
echo""&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Decrypt&lt;/b&gt;&lt;br&gt;"";
$d = decrypt($desEncryptedData,$encryption_key);
echo $d;

echo ""&lt;BR&gt;&lt;BR&gt;encrypted hex: &lt;br&gt;"". strToHex($desEncryptedData);

echo ""&lt;br&gt;&lt;br&gt;3des authenticator: &lt;br&gt;"".$desEncryptedData.""&lt;br /&gt;"";


$req = ""&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;AuthenticateReq&gt;
&lt;userid&gt;$userid&lt;/userid&gt;
&lt;authenticator&gt;$desEncryptedData&lt;/authenticator&gt;
&lt;/AuthenticateReq&gt;
"";

// the functions to use to login
$context = stream_context_create(array('http'=&gt;array(
    'method' =&gt; 'POST',
    'header'  =&gt; ""Content-Type: text/xml\r\n"",
    'content' =&gt; $req
)));


function encrypt($input,$ky)
{
    $key = $ky;
    $size = mcrypt_get_block_size(MCRYPT_TRIPLEDES, 'ecb');
    $input = pkcs5_pad($input, $size);
    $td = mcrypt_module_open(MCRYPT_TRIPLEDES, '', 'ecb', '');
    $iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $key, $iv);
    $data = mcrypt_generic($td, $input);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
    $data = base64_encode($data);
    $data = urlencode($data); //push it out so i can check it works
    return $data;
}

function decrypt($crypt,$ky)
{

    $crypt = urldecode($crypt);
    $crypt = base64_decode($crypt);
    $key = $ky;
    $td = mcrypt_module_open (MCRYPT_TRIPLEDES, '', 'ecb', '');
    $iv = mcrypt_create_iv (mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $key, $iv);
    $decrypted_data = mdecrypt_generic ($td, $crypt);
    mcrypt_generic_deinit ($td);
    mcrypt_module_close ($td);
    $decrypted_data = pkcs5_unpad($decrypted_data);
    $decrypted_data = rtrim($decrypted_data);
    return $decrypted_data;
}

function pkcs5_pad($text, $blocksize)
{
    $pad = $blocksize - (strlen($text) % $blocksize);
    return $text . str_repeat(chr($pad), $pad);
}

function pkcs5_unpad($text)
{
    $pad = ord($text{strlen($text)-1});
    if ($pad &gt; strlen($text)) return false;
    return substr($text, 0, -1 * $pad);
}

function strToHex($string){
    $hex = '';
    for ($i=0; $i&lt;strlen($string); $i++){
        $ord = ord($string[$i]);
        $hexCode = dechex($ord);
        $hex .= substr('0'.$hexCode, -2);
    }
    return strToUpper($hex);
}
</code></pre>

<p>thanks alot for your time in advance</p>
","","1014","<java><php><security><encryption><3des>","2","","0","2014-05-08 00:50:05","","5","3","589259","","2014-05-08 00:50:05","2014-05-07 22:41:16",""
"50901017","Mifare Ultralight C Authentication on Android","<p>I have some Mifare Ultralight C tags for testing authentication.</p>

<p>The first time I read it with the app NXP TagInfo, I could see the following info:</p>

<pre>
(...)
Page 04 - Page 27: FULL OF 0s **(empty tag)**
Page 28: 00 00 -- --
Page 29: 00 00 -- --
Page 2A: 30 -- -- --
Page 2B: 00 -- -- --
Page 2C: 42 52 45 41
PAGE 2D: 4B 4D 45 49
PAGE 2E: 46 59 4F 55
PAGE 2F: 43 41 4E 21
</pre>

<p>The page 2C - 2F means that it had the default key ""BREAKMEIFYOUCAN!"" (<code>425245414b4d454946594f5543414e21</code>).</p>

<p>Then I ran my Android app which basically did this:</p>

<ol>
<li><p>Write <code>49454D4B41455242214E4143554F5946</code> starting from page 2C till page 2F (for authenticating).</p></li>
<li><p>Write 0x04 at page 2A (42); meaning all the pages from 2A on need authentication.</p></li>
<li><p>Write 0x00 at page 2B (43); meaning authentication is needed both for reading and writing.</p></li>
</ol>

<p><b></b></p>

<pre><code>//Start authenticating
byte[] result1 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2C,  /* PAGE = 44    */
                (byte)0x49, (byte)0x45, (byte)0x4D, (byte)0x4B  /* 49 45 4D 4B */
        });

byte[] result2 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2D,  /* PAGE = 45    */
                (byte)0x41, (byte)0x45, (byte)0x52, (byte)0x42  /* 41 45 52 42 */
        });

byte[] result3 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2E,  /* PAGE = 46    */
                (byte)0x21, (byte)0x4E, (byte)0X41, (byte)0X43  /* 21 4E 41 43 */
        });

byte[] result4 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2F,  /* PAGE = 47    */
                (byte)0X55, (byte)0X4F, (byte)0X59, (byte)0X46  /* 55 4F 59 46 */
        });
//Finish authenticating

//Say the pages the card needs authentication
byte[] result5 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2A,  /* PAGE = 42    */
                (byte)0x04, (byte)0x00, (byte)0x00, (byte)0x00  /* Message = All pages after 04 needs authentication */
        });

byte[] result6 = mifare.transceive(new byte[] {
                (byte)0xA2,  /* CMD = WRITE */
                (byte)0x2B,  /* PAGE = 43    */
                (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00  /* Message = authentication is required both for reading and writing */
        });
//Finish ""card activition""
</code></pre>

<p>After doing this, I read the tag again using the NXP TagInfo app, and as expected, I couldn't see the tag info anymore. Instead of that, it indicated <strong>.p XX XX XX XX</strong> on all fields (from 04 on), which indicates it needs password for reading the data.</p>

<p>After that (and here is where I can't see my mistake) I tried to authenticate the tag again (by writing to pages 2C - 2F), but I get this error at the beginning of the authentication part:</p>

<blockquote>
<pre>
System.err: java.io.IOException: Transceive failed
System.err:     at android.nfc.TransceiveResult.getResponseOrThrow(TransceiveResult.java:52)
        at android.nfc.tech.BasicTagTechnology.transceive(BasicTagTechnology.java:151)
        at android.nfc.tech.MifareUltralight.transceive(MifareUltralight.java:215)**
</pre>
</blockquote>

<p>I can't see what I'm doing wrong...</p>
","<p>What you are doing wrong is that you did not actually implement the MIFARE Ultralight C authentication. On MIFARE Ultralight C tags, writing to pages 0x2C..0x2F does exactly what the command says: It <em>writes</em> to that pages, but it does <em>not</em> perform any authentication.</p>

<p>Instead, MIFARE Ultralight C implements a three-way mutual challenge-response authentication protocol. This protocol is started by sending an AUTHENTICATE command:</p>

<pre><code>byte[] result1 = mifare.transceive(new byte[] {
            (byte)0xA1,  /* CMD = AUTHENTICATE */
            (byte)0x00
});
</code></pre>

<p>In response to that command, you will get a challenge that you need to decrypt using the authentication key, manipulate, encrypt and send back to the tag to proof that you actually posess the authentication key. You can find some code that implements MIFARE Ultralight C authentication in this Q/A: <a href=""https://stackoverflow.com/q/19438554/2425802"">Android: Authenticating with NXP MiFare Ultralight C</a>.</p>
","960","<android><authentication><nfc><mifare><3des>","2","3","1","2018-06-21 16:15:57","50973223","2","","2425802","","2018-06-21 16:05:59","2018-06-17 22:36:43",""
"1492118","Which library would you consider on linux for DEA (Data Encryption Algorithm)?","<p>I need a 3DES encrypt/decrypt library for my project.
Do you know an implementation working on linux ?</p>

<p>Linux is the target platform, but I essantially compile/debug on Windows. Therefore it could be really appreciated if it could work on Windows, while not mandatory.</p>
","<p>Look for Eric Young's ""libdes"".
This library can be also used on Windows as well as on Linux.</p>
","952","<c++><linux><encryption><3des>","1","2","4","2009-09-29 13:35:41","1492195","4","","","","","2009-09-29 12:01:44",""
"1492118","Which library would you consider on linux for DEA (Data Encryption Algorithm)?","<p>I need a 3DES encrypt/decrypt library for my project.
Do you know an implementation working on linux ?</p>

<p>Linux is the target platform, but I essantially compile/debug on Windows. Therefore it could be really appreciated if it could work on Windows, while not mandatory.</p>
","<p>OpenSSL is a very reputable, well tested open source security library.  It's available for *nix and Windows.  You can find it <a href=""http://openssl.org/"" rel=""nofollow noreferrer"">here</a></p>

<p>Edit, can't find a simple example right now.  The API <a href=""http://www.openssl.org/docs/crypto/des.html#"" rel=""nofollow noreferrer"">documentation</a> is pretty good though.</p>

<p>There's a pre-compiled version for windows available for download from the openssl site.  Most package managers will have a pre-packaged version of OpenSSL for Linux boxes, so you shouldn't have to compile your own version.</p>
","952","<c++><linux><encryption><3des>","1","6","4","2009-09-29 13:35:41","1492195","4","","","","","2009-09-29 12:01:44",""
"1492118","Which library would you consider on linux for DEA (Data Encryption Algorithm)?","<p>I need a 3DES encrypt/decrypt library for my project.
Do you know an implementation working on linux ?</p>

<p>Linux is the target platform, but I essantially compile/debug on Windows. Therefore it could be really appreciated if it could work on Windows, while not mandatory.</p>
","<p>you can compile libcrypto (openssl) for windows but I wouldn't recommend it:
<a href=""http://www.pixelbeat.org/programming/lib_crypto.html"" rel=""nofollow noreferrer"">http://www.pixelbeat.org/programming/lib_crypto.html</a></p>

<p>Maybe NSS used by firefox would be useful?
<a href=""http://www.mozilla.org/projects/security/pki/nss/"" rel=""nofollow noreferrer"">http://www.mozilla.org/projects/security/pki/nss/</a></p>

<p>Though I'd probably try something simple like:
<a href=""http://www.lysator.liu.se/~nisse/nettle/nettle.html"" rel=""nofollow noreferrer"">http://www.lysator.liu.se/~nisse/nettle/nettle.html</a></p>
","952","<c++><linux><encryption><3des>","1","1","4","2009-09-29 13:35:41","1492195","4","","","","","2009-09-29 12:01:44",""
"1492118","Which library would you consider on linux for DEA (Data Encryption Algorithm)?","<p>I need a 3DES encrypt/decrypt library for my project.
Do you know an implementation working on linux ?</p>

<p>Linux is the target platform, but I essantially compile/debug on Windows. Therefore it could be really appreciated if it could work on Windows, while not mandatory.</p>
","<p>I have used <a href=""http://botan.randombit.net/news/"" rel=""nofollow noreferrer"">botan</a> before and I really like it. It has an implementation of not only 3DES but a lot of others algorithm. It is C++ so their API is Object Oriented (I like this feature while other might disagree). It supports a lot of systems (Windows, Linux, FreeBSD, etc), a lot of processors (x86, x86-64, IA-64, PowerPC and so on) and compilers. It seems to have a very good performance. Finally its license allows commercial developments.</p>

<p>At least it's Worth to have a look ;-)</p>
","952","<c++><linux><encryption><3des>","1","2","4","2009-09-29 13:35:41","1492195","4","","","","","2009-09-29 12:01:44",""
"27296851","ios 3DES encryption/decryption CBC","<p>I need some help with this 3DES decryption. I have created some code for decryption but i cant get it to work as it should.This is the first time i am playing around with encryptions and i don't know what exactly am i doing wrong here.</p>

<p>I am receiving the key for the decryption from server (this is example value for the key: 0F7BC98767FF9A01F2B2AD1CD644AD33 - it is hex representation of random generated bytes).</p>

<p>this is the method that I use to decrypt the message:</p>

<pre><code>-(NSString*)doCipher:(NSString*)message key:(NSString*)key operation:(CCOperation)encryptOrDecrypt {

const void *messageData;
size_t messageBufferSize;

if (encryptOrDecrypt == kCCDecrypt){
    NSData *messageEncryptData= [NSData dataWithBase64EncodedString:message];
    messageBufferSize= [messageEncryptData length];
    messageData= [messageEncryptData bytes];
}
else{
    messageBufferSize= message.length;
    messageData = [[[message dataUsingEncoding: NSUTF8StringEncoding]mutableCopy] bytes];
}

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes = 0;

bufferPtrSize = (messageBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

uint8_t iv[kCCBlockSize3DES];
memset((void *) iv, 0x0, (size_t) sizeof(iv));



NSData *keyData = [[key dataUsingEncoding:NSUTF8StringEncoding]mutableCopy];

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding &amp; kCCModeCBC,
                   (const void *)[keyData bytes],
                   kCCKeySize3DES,
                   iv,
                   messageData,
                   messageBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

if (ccStatus == kCCParamError) return @""PARAM ERROR"";
else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

NSLog(@""bufferPtr: %s"", bufferPtr);

NSString *s = [[NSString alloc] initWithFormat:@""%s"", bufferPtr];
return s;
}
</code></pre>

<p>-- EDIT ---
this is output that I receive from the method:</p>

<p>bufferPtr: Ã’ ÕÏÁU</p>

<p>--- EDIT 2 -----
I fixed the key length to be 24 byte long, but now the end result is empty string</p>
","<p>i Found my problem. It was the way i was reading the key.</p>

<p>i created this method for converting hex string into NSData:</p>

<pre><code>+ (NSData *)dataFromHexString: (NSString *) hex {
const char *chars = [hex UTF8String];
int i = 0, len = hex.length;

NSMutableData *data = [NSMutableData dataWithCapacity:len / 2];
char byteChars[3] = {'\0','\0','\0'};
unsigned long wholeByte;

while (i &lt; len) {
    byteChars[0] = chars[i++];
    byteChars[1] = chars[i++];
    wholeByte = strtoul(byteChars, NULL, 16);
    [data appendBytes:&amp;wholeByte length:1];
}

return data;
}
</code></pre>

<p>then this is how i managed to decrypt the damn thing:</p>

<pre><code>NSData *keyData = [Utilities dataFromHexString:key];

ccStatus = CCCrypt(encryptOrDecrypt,
                   kCCAlgorithm3DES,
                   kCCOptionPKCS7Padding,
                   [keyData bytes],
                   [keyData length],
                   iv,
                   messageData,
                   messageBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);
</code></pre>

<p>Sorry for wasting your time :)</p>
","940","<ios><encryption><3des><cbc-mode>","1","2","1","2017-12-14 05:33:38","27312362","4","1","1033581","","2017-12-14 05:33:38","2014-12-04 14:45:36",""
"29175453","Java implementation of 3DES and DUKPT for decryption of credit card reader data through keyboard emulation?","<p>We have an online key-in interface, and are support credit card swipe capability. In the industry today, the card reader should encrypt the information before encoding it to ASCII, and then it is up to server-side to decrypt. (so the local machine never sees the card info)</p>

<p>I am using MagTek card reader in keyboard emulation mode, and have it with the ANSI standard key injected for testing purposes. Once decode &amp; decryption successful, we'll get our own key registered with MagTek and order some production-use readers.</p>

<p>I know this decryption has been implemented before in C# and other languages, but need something in Java, or perhaps some other CLI-accessible program that can be included with a Java webapp. I am about to proceed with porting some C# code to Java, but first need to set up a C# environment. (I've never done this before.)</p>

<p>Once I've ensured the C# version works well, then I know I can eliminate any errors during porting with my usual debugging techniques.</p>

<p>Before I go through all of this, if there is an easier way please let me know. I would think this has already been done in Java, but perhaps not...</p>
","<p>Partial answer, CW for anyone to add to.</p>

<p>First, it's not clear (to me) if you want to run on PCs or similar where the swipe devices are, possibly downloaded (like applet or webstart), or to just get the encrypted swipe data (in a webform?) and send it to your server to decrypt. I suggest the latter makes PCI DSS compliance easier.</p>

<p>Java crypto certainly does <strong>3DES</strong>, under the name DESede (case-insensitive, like all JCA Cipher names). One slightly unobvious point: the implementation in SunJCE only handles full 24-byte keys. DUKPT uses ""2-key 3DES"", so you need to copy ""left"" to bytes 0-7, ""right"" to 8-15, and ""left"" again to 16-23. If you use BouncyCastle (as my shop does) it can take a 16-byte key and do the copy internally, which is slightly more convenient. (A symmetric key in Java is a byte array in a thin wrapper class, usually <code>javax.crypto.spec.SecretKeySpec</code>.)</p>

<p>If you're not familiar with Java crypto in general, the pattern is that you obtain an ""instance"" of a particular algorithm or mode from a ""provider"" (you can specify one or let Java choose automatically; several are builtin and more can be added, like ""bcprov"" from www.BouncyCastle.org) using a generic API class <code>Cipher</code>, <code>Signature</code>, <code>MessageDigest</code>, etc, then initialize that instance with needed parameters (such as key or IV, and direction), then call methods to take input data and return output either in separate (possibly multiple) steps or in a simple combined <code>doFinal</code> (which is fine for your case). The JCA manual <a href=""http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html#Cipher"" rel=""nofollow"">http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html#Cipher</a> and javadoc for the applicable API class <code>javax.crypto.Cipher</code> (at <a href=""http://docs.oracle.com/javase/8/docs/api/index.html"" rel=""nofollow"">http://docs.oracle.com/javase/8/docs/api/index.html</a> and also automatically displayed in leading IDEs) has quite full details on this.</p>

<p>I haven't seen any open/free implementation of <strong>DUKPT</strong> but that doesn't prove there isn't one. It is straightforward, though a bit tedious, to just code the steps from X9.24, if no one offers better.</p>
","919","<java><credit-card><3des><credit-card-track-data><dukpt>","0","1","1","2015-03-21 16:48:37","29179323","1","","463304","","2015-03-21 16:48:37","2015-03-20 20:39:36",""
"33373764","PHP and C# 3DES Encryption","<p>Need to convert the following function from PHP to C# (asp.net)</p>

<pre><code>function encrypt_3DES($message, $key){
    // Se establece un IV por defecto
    $bytes = array(0,0,0,0,0,0,0,0); //byte [] IV = {0, 0, 0, 0, 0, 0, 0, 0}
    $iv = implode(array_map(""chr"", $bytes)); //PHP 4 &gt;= 4.0.2

    // Se cifra
    $ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv); //PHP 4 &gt;= 4.0.2
    return $ciphertext;
}
</code></pre>

<p>Where 
<code>$message</code> is a string to encode and <code>$key</code> is the key</p>

<p>The <code>$key</code> is base 64 encoded and it is decoded before calling the function</p>

<pre><code>$key = $this-&gt;decodeBase64($key);
$ciphertext = $this-&gt;encrypt_3DES($message, $key);
</code></pre>

<p>Following C# code I used:</p>

<pre><code>key = Base64Decode(key);
ciphertext = encrypt_3DES(order, key,true);
</code></pre>

<p>where</p>

<pre><code> private  string Base64Decode(string base64EncodedData)
    {
        byte[] base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);
        return Encoding.GetEncoding(28591).GetString(base64EncodedBytes);
        // 28591 for php compatibility
    }  
</code></pre>

<p>and</p>

<pre><code>  private string encrypt_3DES(string message, string k,bool useHashing)
    {
        byte[] keyArray;
        byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(message);

        //If hashing use get hashcode regards to your key
        if (useHashing)
        {
            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(Encoding.GetEncoding(28591).GetBytes(k));
            //Always release the resources and flush data
            // of the Cryptographic service provide. Best Practice

            hashmd5.Clear();
        }
        else
            keyArray = UTF8Encoding.GetEncoding(28591).GetBytes(k);

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        //set the secret key for the tripleDES algorithm
        tdes.Key = keyArray;
        //mode of operation. there are other 4 modes.
        //We choose ECB(Electronic code Book)
        tdes.Mode = CipherMode.ECB;
        //padding mode(if any extra byte added)

        tdes.Padding = PaddingMode.PKCS7;

        ICryptoTransform cTransform = tdes.CreateEncryptor();
        //transform the specified region of bytes array to resultArray
        byte[] resultArray =
          cTransform.TransformFinalBlock(toEncryptArray, 0,
          toEncryptArray.Length);
        //Release resources held by TripleDes Encryptor
        tdes.Clear();
        //Return the encrypted data into unreadable string format
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);

    }
</code></pre>

<p>The results from PHP and C# are not the same.</p>
","<p>I found a code that works for me in this spanish web.
<a href=""http://www.resuelvetusproblemas.com/convertir-encriptacion-en-php-3des-en-c/"" rel=""nofollow"">http://www.resuelvetusproblemas.com/convertir-encriptacion-en-php-3des-en-c/</a></p>

<p>This is the function in C# would be the same as you've written in PHP</p>

<pre><code>    public static byte[] TripleDESEncrypt(string texto, byte[] key)
    {
        using (TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider())
        {
            byte[] iv_0 = { 0, 0, 0, 0, 0, 0, 0, 0 };

            byte[] toEncryptArray = Encoding.ASCII.GetBytes(texto);               

            tdes.IV = iv_0;

            //assign the secret key
            tdes.Key = key;

            tdes.Mode = CipherMode.CBC;

            tdes.Padding = PaddingMode.Zeros;

            ICryptoTransform cTransform = tdes.CreateEncryptor();
            //transform the specified region of bytes array to resultArray
            byte[] resultArray =
              cTransform.TransformFinalBlock(toEncryptArray, 0,
              toEncryptArray.Length);

            //Clear to Best Practices
            tdes.Clear();

            return resultArray;
        }
    }
</code></pre>
","885","<c#><php><asp.net><encryption><3des>","1","2","1","2015-10-29 07:31:36","33408296","5","1","","","","2015-10-27 16:46:09",""
"9846283","Need Java equvalent for 3DES decryption of PHP code","<p>This is the PHP code I have.<br></p>

<pre><code>function decrypt($s_input, $s_key, $s_iv) { 
   $s_decrypted = pack(""H*"" , $s_input); // Hex to binary
   $s_decrypted = mcrypt_decrypt (MCRYPT_3DES, $s_key, $s_decrypted, MCRYPT_MODE_CBC, $s_iv);  // 3des decryption
  return $s_decrypted; 
}
echo encrypt('c37551bb77f741d0bcdc16497b4f97b1','123456781234567812345678','12345678' );
</code></pre>

<p>what it basically does is to decrypt a 3des encrypted string (first it convert the hex string to binary using pack function and then does the actual decryption).</p>

<p>This perfectly works in PHP-4 and prints the ""Hello World"" message. </p>

<p>However, if I run the equivalent java code (jdk 1.6), it prints garbage output as - ¬ªmjV=7xl_ÓÄ^›*?.</p>

<p>Can someone help to troubleshoot this? Why Java is not properly decrypting the hex string.   </p>

<pre><code>private static String decrypt(String inputStr, String keyStr, String ivStr) throws Exception {

    IvParameterSpec iv = new IvParameterSpec(ivStr.getBytes());
    SecretKeySpec key = new SecretKeySpec(keyStr.getBytes(), ""DESede"");
    inputStr = hexToString(inputStr, 2);

    Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, key, iv);
    byte[] decrypted = cipher.doFinal(inputStr.getBytes());

    return new String(decrypted);
}

private static String hexToString(String input, int groupLength) {
    StringBuilder sb = new StringBuilder(input.length() / groupLength);
    for (int i = 0; i &lt; input.length() - groupLength + 1; i += groupLength) {
        String hex = input.substring(i, i + groupLength);
        sb.append((char) Integer.parseInt(hex, 16));
    }
    return sb.toString();
}

public static void main(String[] args) throws Exception {
    String decryptSignature = decrypt(""c37551bb77f741d0bcdc16497b4f97b1"", ""123456781234567812345678"", ""12345678"");
    System.out.println(decryptSignature);
}
</code></pre>
","<p>There are a few things you should check. You might find <a href=""https://stackoverflow.com/questions/8233553/encryption-using-aes-128-in-java/8233650"">Encryption using AES-128 in Java</a> to be of some assistance. There could be issues with differences between how you are handling keys in the PHP and Java code. Calling <code>getBytes()</code> on a <code>String</code> in Java without an encoding is almost always a bad idea. Plus the padding used could be a problem. From what I've seen PHP pads with <code>null</code> characters by default, which does not correspond to <code>NoPadding</code> in Java. Finally, the <code>hexToString</code> method should return a <code>byte[]</code> instead of a <code>String</code>. Add the result of calling <code>Integer.parseInt(hex, 16)</code> into an array:</p>

<pre><code>byte[] results = new byte[input.length() / groupLength];
...
    //inside the loop
    results[i / groupLength] = (byte) Integer.parseInt(hex, 16);
...
return results;
</code></pre>
","870","<java><php><encryption><3des>","2","0","1","2012-03-23 21:11:08","9846531","0","2","","","","2012-03-23 20:45:36",""
"28877221","Implementing 3DES encryption/decryption in PLSQL to handle values encrypted by VB.net","<p>We are being asked to decrypt a stream of data using PLSQL which is being encrypted by a VB.net process on a different platform. </p>

<p>The VB code is below:</p>

<pre><code>Public Function TruncateHash(ByVal key As String,ByVal length As Integer) As Byte()

            Dim sha1 As New SHA1CryptoServiceProvider

            ' Hash the key.
            Dim keyBytes() As Byte =  System.Text.Encoding.Unicode.GetBytes(key)
            Dim hash() As Byte = sha1.ComputeHash(keyBytes)

            ' Truncate or pad the hash.
            ReDim Preserve hash(length - 1)
            Return hash
        End Function

      Imports System.Security.Cryptography

        Public Function test_encrypt(ByVal plaintext As String, ByVal key As String, ByVal seed As String) As String

            Dim TripleDes As New TripleDESCryptoServiceProvider
            TripleDes.Key = TruncateHash(key, TripleDes.KeySize \ 8)
            TripleDes.IV = TruncateHash(seed, TripleDes.BlockSize \ 8)

            ' Convert the plaintext string to a byte array.
            Dim plaintextBytes() As Byte = System.Text.Encoding.Unicode.GetBytes(plaintext)

            ' Create the stream.
            Dim ms As New System.IO.MemoryStream
            ' Create the encoder to write to the stream.
            Dim encStream As New CryptoStream(ms, TripleDes.CreateEncryptor(), System.Security.Cryptography.CryptoStreamMode.Write)

            ' Use the crypto stream to write the byte array to the stream.
            encStream.Write(plaintextBytes, 0, plaintextBytes.Length)
            encStream.FlushFinalBlock()

            ' Convert the encrypted stream to a printable string.
            Return Convert.ToBase64String(ms.ToArray)

        End Function

        Public Function TEST_decrypt(ByVal encryptedtext As String, ByVal key As String, ByVal seed As String) As String

            Dim TripleDes As New TripleDESCryptoServiceProvider
            TripleDes.Key = TruncateHash(key, TripleDes.KeySize \ 8)
            TripleDes.IV = TruncateHash(seed, TripleDes.BlockSize \ 8)


            ' Convert the encrypted text string to a byte array.
            Dim encryptedBytes() As Byte = Convert.FromBase64String(encryptedtext)

            ' Create the stream.
            Dim ms As New System.IO.MemoryStream
            ' Create the decoder to write to the stream.
            Dim decStream As New CryptoStream(ms, TripleDes.CreateDecryptor(), System.Security.Cryptography.CryptoStreamMode.Write)

            ' Use the crypto stream to write the byte array to the stream.
            decStream.Write(encryptedBytes, 0, encryptedBytes.Length)
            decStream.FlushFinalBlock()

            ' Convert the plaintext stream to a string.
            Return System.Text.Encoding.Unicode.GetString(ms.ToArray)
        End Function
</code></pre>

<p>This appears to have been pulled mostly from an <a href=""https://msdn.microsoft.com/en-us/library/ms172831.aspx"" rel=""nofollow"">MSDN article</a>.</p>

<p>How can this type of encryption/decryption be implemented in PLSQL using Oracle 11g Enterprise Edition? I have had a stab at it using the code below but the values I'm getting are completely different. I don't know how to interpret the padding/truncation element of the TruncateHash function.</p>

<pre><code>DECLARE 

g_value VARCHAR2 (30 BYTE) DEFAULT 'hello world';
g_key   VARCHAR2 (30 BYTE) DEFAULT 'password';
g_seed  VARCHAR2 (30 BYTE) DEFAULT 'seed';

l_enc   VARCHAR2 (2000 BYTE) DEFAULT NULL;

    FUNCTION get_hash (p_in     VARCHAR2)
    RETURN RAW
    AS
    l_hash  RAW(2000);
    BEGIN

    l_hash  :=  dbms_crypto.hash(utl_raw.cast_to_raw(p_in), dbms_crypto.hash_sh1);

    RETURN l_hash;

    END get_hash;  

FUNCTION get_enc_val (
     p_in_val      IN   VARCHAR2,
       p_key         IN   VARCHAR2,
       p_iv          IN   VARCHAR2 := NULL
    )
       RETURN VARCHAR2
    IS
       l_enc_val    RAW (4000);
       l_enc_algo   PLS_INTEGER;
      l_in         RAW (4000);
      l_iv         RAW (4000);
      l_key        RAW (4000);
      l_ret        VARCHAR2 (4000);
   BEGIN
      l_enc_algo := dbms_crypto.encrypt_3des_2key;
      l_in := utl_raw.cast_to_raw(p_in_val);
      l_iv := get_hash (p_iv);
      l_key := get_hash (p_key);
      l_enc_val :=
         dbms_crypto.encrypt (src      =&gt; l_in,
                              KEY      =&gt; l_key,
                              iv       =&gt; l_iv,
                              typ      =&gt;   l_enc_algo
                                          + dbms_crypto.chain_cbc
                                          + dbms_crypto.pad_pkcs5
                             );
      l_ret := RAWTOHEX (l_enc_val);
      RETURN l_ret;
   END;


BEGIN

l_enc := get_enc_val(g_value, g_key, g_seed);

dbms_output.put_line(utl_raw.cast_to_varchar2(l_enc));
END;
</code></pre>

<p>The expected encrypted value of ""hello world"" is ""S3UPpm51c919L+C+PqkuxS7avQt5IjXV"". </p>
","","867","<vb.net><encryption><plsql><oracle11g><3des>","0","","0","2015-03-05 11:50:46","","2","","","","","2015-03-05 11:50:46",""
"30959980","3DES encrypt from C# to JAVA","<p>I have this code in C# and I need to migrate it to Java.
I need to use 3DES encryptation. It's mandatory.</p>

<p><strong>C#</strong>:</p>

<pre><code>public void test() 
{
    string sKSN = ""ffff1234560006800010"";
    string sBDK = ""E08A46B616230152230DB9C8DF94C75E"";
    byte[] dikKSN = new byte[10];
    byte[] KSN8 = new byte[8];
    byte[] BDK = new byte[16];
    byte[] lKey = new byte[8];
    byte[] rKey = new byte[8];
    string retKey = string.Empty;
    string lgTxt = string.Empty;
    dikKSN = this.FromHex(sKSN);  // convert hex to byte array
    BDK = this.FromHex(sBDK); // convert hex to byte array
    KSN8 = this.CopyByte8(dikKSN); //use the first 8 values
    lKey = this.TDESEncrypt(KSN8, BDK);
}
private byte[] TDESEncrypt(byte[] data, byte[] key) 
{
    byte[] retVal = null;
    byte[] IV = new byte[16];
    System.IO.MemoryStream ms = null;
    System.Security.Cryptography.TripleDES tDES = System.Security.Cryptography.TripleDES.Create();
    tDES.BlockSize = 64;
    tDES.KeySize = 128;
    tDES.Padding = System.Security.Cryptography.PaddingMode.None;
    tDES.Mode = System.Security.Cryptography.CipherMode.ECB;
    System.Security.Cryptography.CryptoStream csEncrypt = null;
    try
    {
        ms = new System.IO.MemoryStream(data);
        csEncrypt = new System.Security.Cryptography.CryptoStream(ms, tDES.CreateEncryptor(key, IV), System.Security.Cryptography.CryptoStreamMode.Write);
        retVal = new byte[data.Length];
        csEncrypt.Write(data, 0, data.Length);
        retVal = ms.ToArray();
    }
    catch (Exception ex)
    {
        Console.WriteLine(ex.Message);
    }
    finally
    {
        ms.Close();
    }
    return retVal;
}
</code></pre>

<p><strong>JAVA</strong>:</p>

<pre><code>public void test() {
    String sKSN = ""ffff1234560006800010"";
    String sBDK = ""E08A46B616230152230DB9C8DF94C75E"";
    byte[] dikKSN = new byte[10];
    byte[] KSN8 = new byte[8];
    byte[] BDK = new byte[16];
    byte[] lKey = new byte[8];
    byte[] rKey = new byte[8];
    String retKey = """";
    String lgTxt = """";
    dikKSN = this.fromHex(sKSN);  // convert hex to byte array
    BDK = this.fromHex(sBDK); // convert hex to byte array
    KSN8 = this.copyByte8(dikKSN); //use the first 8 values
    lKey = this.tDESEncrypt(KSN8, BDK);
}
private byte[] tDESEncrypt(byte[] plainTextBytes, byte[] kb) {
  byte[] cipherText = null;
  try {
    final MessageDigest md = MessageDigest.getInstance(""md5"");
    final byte[] digestOfPassword = md.digest(kb);
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
    for (int j = 0, k = 16; j &lt; 8;) {
      keyBytes[k++] = keyBytes[j++];
    }
    final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding""); 
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    cipherText = cipher.doFinal(plainTextBytes);
  } catch (Exception ex) {
    ex.printStackTrace();
  }
  return cipherText;
}
</code></pre>

<p>Test when I execute desEncrypt method:</p>

<p><strong>C#</strong></p>

<pre><code>data = {255, 255, 18, 52, 86, 0, 6, 128};
key = {224, 138, 70, 182, 22, 35, 1, 82, 35, 13, 185, 200, 223, 148, 199, 94};
</code></pre>

<p><strong>JAVA</strong></p>

<pre><code>plainBytes = {-1, -1, 18, 52, 86, 0, 6, -128};
kb = {-32, -118, 70, -74, 22, 35, 1, 82, 35, 13, -71, -56, -33, -108, -57, 94}
</code></pre>

<p>I think that my main problem is in Java that a byte is between -128 and 127 and in C# the byte primitive can contain the 255 number. 
The values of data and key variables were obtained from conversion from the same hexadecimal string to byte.</p>

<p>I need that the Java code returns the same value than C# code.
In this moment, the values below are the returns:</p>

<pre><code>Java = {99, -104, 95, 92, 59, -75, -30, -16};
C# = {171, 58, 144, 248, 46, 146, 227, 224};
</code></pre>

<p>I don't have any value in common between both results.</p>
","<p>The solution is here:</p>

<p><a href=""https://stackoverflow.com/questions/20835808/3des-decryption-error-invalid-key-length"">3DES Decryption Error Invalid Key Length</a></p>

<p>I removed the MessageDigest key generation and I used this code:</p>

<pre><code>private byte[] genTwoKey3DES(byte[] key) {
    byte[] keyAux;
    if (key.length == 16) {
        keyAux = new byte[24];
        System.arraycopy(key, 0, keyAux, 0, 16);
        System.arraycopy(key, 0, keyAux, 16, 8);
    } else {
        keyAux = key;
    }
    return keyAux;
} 
</code></pre>
","863","<java><c#><encryption><3des>","0","1","1","2015-06-22 17:40:03","30986407","3","2","1707311","","2015-06-21 18:02:51","2015-06-20 23:50:16",""
"50761047","Convert Java JCEKS keystore containing 3DES key to PKCS12","<p>I'm trying to convert a Java JCEKS keystore to PKCS12 that contains two symmetric keys, one AES and one 3DES.</p>

<p>The AES key gets imported into the PKCS12 file just fine but not the 3DES key.</p>

<p>The command I'm using is:</p>

<p><code>""c:\Program Files\Java\jdk-10.0.1\bin\keytool.exe"" -importkeystore -srckeystore D:\temp\ssc.jceks -srcstoretype jceks -destkeystore D:\temp\ssc.p12 -deststoretype pkcs12</code></p>

<p>I'm getting the following error message:</p>

<pre><code>java.security.KeyStoreException: Key protection  algorithm not found: java.security.NoSuchAlgorithmException: unrecognized algorithm name: DESede
</code></pre>

<p>This is with Java 10.0.1, I've also tried Java 8u171 and Java 11 EA 17.</p>

<p>Keytool can list the JCEKS keystore just fine with:</p>

<p><code>""c:\Program Files\Java\jdk-10.0.1\bin\keytool.exe"" -list -keystore D:\temp\ssc.jceks -storepass xxxxx -storetype jceks -v</code></p>

<p>Any idea on how to import 3DES key into PKCS12 keystores? </p>

<p>Thanks.</p>
","<p>Looks like the default <code>SunJSSE</code> Provider which implements the <code>PKCS12</code> KeyStore doesn't support the <code>DESede</code> algorithm.</p>

<p>Your best bet is to have them in the <code>JCEKS</code> keystore (it is proprietary to Java, but the PKCS#11 standard is to not store non-private keys. Even if you have to do, DESede may not be supported because AES is considered much more secure than DESede and is the industry standard.)</p>
","861","<java><keytool><pkcs#12><3des><jceks>","0","2","1","2018-06-13 14:31:00","50839811","0","","","","","2018-06-08 12:49:23",""
"48039173","Converting md5 hash to a proper 3DES key in python3","<p>I have a function written in c# that you can pass an ascii string as the key, and the encrypted string from a database and decode the data.</p>

<p>I've verified that the code works by  writing a simple c# program to decode the data.  The code snippet converts the key string to bytes and MD5 hashes it.  </p>

<p>C# Code Snippet, omitting some code that converted the byteHash to an ascii string for output in the compiled program</p>

<pre><code>key = ""joetest""

byte[] byteHash =  cryptoServiceProvider.ComputeHash(Encoding.ASCII.GetBytes(key));
</code></pre>

<p>byteHash = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I run the following commands and Python3 and get the same byteHash</p>

<pre><code>key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()
print(hex_key)
</code></pre>

<p>hex_key = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I've tried encoding 'hex_key' as binary.</p>

<p>My issue is I'm trying to pass hex_key into 2 different python3 crypto programs.  Cryptodome and pyDes.  Both tell me that i'm passing in an invalid key.  </p>

<p>The C# code that uses byteHash is as follows</p>

<pre><code>tripleDesCryptoServiceProvider.Key = byteHash;

tripleDesCryptoServiceProvider.Mode = CipherMode.ECB;

byte[] byteBuff = Convert.FromBase64String(encryptedString);

string strDecrypted = Encoding.UTF8.GetString(tripleDesCryptoServiceProvider.CreateDecryptor().TransformFinalBlock(byteBuff, 0, byteBuff.Length));
</code></pre>

<p>This all works, i was able to decrypt data when i passed in the encrypted string into this function.</p>

<p>Using pyDes i'm using this code</p>

<pre><code>from pyDes import *
import base64
import hashlib


my_data = ""fK/jw6/25y0=""
#my_data is the word 'test' encrypted with the key of 'joetest'

#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")    #Encode the data as binary data
m = hashlib.md5()           
m.update(encoded_key)
hex_key = m.hexdigest()         #Convert the key to an MD5 hash
encoded_hex_key = hex_key.encode()  #Make the MD5 key a binary key  

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out)
exit()
</code></pre>

<p>The error i'm getting is:</p>

<pre><code>(3destest) c:\3des-test\3destest&gt;joe3des_test3.py
Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test3.py"", line 20, in &lt;module&gt;
    k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 710, in __init__
    self.setKey(key)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 719, in setKey
    raise ValueError(""Invalid triple DES key size. Key must be either 16 or 24 bytes long"")
ValueError: Invalid triple DES key size. Key must be either 16 or 24 bytes long
</code></pre>

<p>Using pyCryptodome, i've tried this code</p>

<pre><code>from Cryptodome.Cipher import DES3
import base64
import hashlib

# Converts the key string to an MD5 hash
key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()

#Decodes the string to binary digits
encryptedString = base64.b64decode(""fK/jw6/25y0="")

#Create the cipher to decrypt the data
cipher = DES3.new(hex_key, DES3.MODE_ECB)
decryptedString = cipher.decrypt(encryptedString)
</code></pre>

<p>And i get this error</p>

<pre><code>Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test2.py"", line 16, in &lt;module&gt;
    cipher = DES3.new(hex_key, DES3.MODE_ECB)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 174, in new
    return _create_cipher(sys.modules[__name__], key, mode, *args, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\__init__.py"", line 55, in _create_cipher
    return modes[mode](factory, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\_mode_ecb.py"", line 175, in _create_ecb_cipher
    cipher_state = factory._create_base_cipher(kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 99, in _create_base_cipher
    key = adjust_key_parity(key_in)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 80, in adjust_key_parity
    raise ValueError(""Not a valid TDES key"")
ValueError: Not a valid TDES key
</code></pre>

<p>My python MD5 hash is 32 hex characters long.  Assuming my math is right, 32 * 4 is 128 bits.  And the error is saying it must be 16 or 24 bytes long.  16 * 8 is also 128 bits.  So the byte string value i'm passing it should be correct.  I think I'm missing something, but can't seem to figure it out.</p>

<p><strong>Update 2-Jan-2018</strong>
Based on answer below here's a copy of the code that I used to confirm this will decrypt the data from the DB.</p>

<pre><code>from pyDes import *
import base64
import hashlib

#my_data is the word 'test' encrypted with the key of 'joetest'
my_data = ""fK/jw6/25y0=""


#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
digest_key = m.digest()

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(digest_key, ECB)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out.decode(""ascii""))
</code></pre>
","<p>TripleDES, by definition, is meant to use a 24 byte key, e.g. 192 bits.  Implementations that accept less than that actually reuse key data.</p>

<p>In C#, TripleDES with a 128-bit key reuses the first 64 bits to create a key that is 192 bits in length.</p>

<p>With that in mind, try using the following 192-bit key instead:</p>

<pre><code>f2fc0f481787cc4cbb15f7ded4412fe4f2fc0f481787cc4c
</code></pre>

<p>If this works, which I expect it will, you'll just need to modify the code to copy the first 64 bits to the end.</p>
","846","<python-3.x><encryption><hash><3des>","1","0","3","2018-01-03 01:11:47","48065439","1","","9157327","","2018-01-03 01:11:47","2017-12-31 01:11:31",""
"48039173","Converting md5 hash to a proper 3DES key in python3","<p>I have a function written in c# that you can pass an ascii string as the key, and the encrypted string from a database and decode the data.</p>

<p>I've verified that the code works by  writing a simple c# program to decode the data.  The code snippet converts the key string to bytes and MD5 hashes it.  </p>

<p>C# Code Snippet, omitting some code that converted the byteHash to an ascii string for output in the compiled program</p>

<pre><code>key = ""joetest""

byte[] byteHash =  cryptoServiceProvider.ComputeHash(Encoding.ASCII.GetBytes(key));
</code></pre>

<p>byteHash = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I run the following commands and Python3 and get the same byteHash</p>

<pre><code>key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()
print(hex_key)
</code></pre>

<p>hex_key = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I've tried encoding 'hex_key' as binary.</p>

<p>My issue is I'm trying to pass hex_key into 2 different python3 crypto programs.  Cryptodome and pyDes.  Both tell me that i'm passing in an invalid key.  </p>

<p>The C# code that uses byteHash is as follows</p>

<pre><code>tripleDesCryptoServiceProvider.Key = byteHash;

tripleDesCryptoServiceProvider.Mode = CipherMode.ECB;

byte[] byteBuff = Convert.FromBase64String(encryptedString);

string strDecrypted = Encoding.UTF8.GetString(tripleDesCryptoServiceProvider.CreateDecryptor().TransformFinalBlock(byteBuff, 0, byteBuff.Length));
</code></pre>

<p>This all works, i was able to decrypt data when i passed in the encrypted string into this function.</p>

<p>Using pyDes i'm using this code</p>

<pre><code>from pyDes import *
import base64
import hashlib


my_data = ""fK/jw6/25y0=""
#my_data is the word 'test' encrypted with the key of 'joetest'

#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")    #Encode the data as binary data
m = hashlib.md5()           
m.update(encoded_key)
hex_key = m.hexdigest()         #Convert the key to an MD5 hash
encoded_hex_key = hex_key.encode()  #Make the MD5 key a binary key  

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out)
exit()
</code></pre>

<p>The error i'm getting is:</p>

<pre><code>(3destest) c:\3des-test\3destest&gt;joe3des_test3.py
Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test3.py"", line 20, in &lt;module&gt;
    k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 710, in __init__
    self.setKey(key)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 719, in setKey
    raise ValueError(""Invalid triple DES key size. Key must be either 16 or 24 bytes long"")
ValueError: Invalid triple DES key size. Key must be either 16 or 24 bytes long
</code></pre>

<p>Using pyCryptodome, i've tried this code</p>

<pre><code>from Cryptodome.Cipher import DES3
import base64
import hashlib

# Converts the key string to an MD5 hash
key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()

#Decodes the string to binary digits
encryptedString = base64.b64decode(""fK/jw6/25y0="")

#Create the cipher to decrypt the data
cipher = DES3.new(hex_key, DES3.MODE_ECB)
decryptedString = cipher.decrypt(encryptedString)
</code></pre>

<p>And i get this error</p>

<pre><code>Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test2.py"", line 16, in &lt;module&gt;
    cipher = DES3.new(hex_key, DES3.MODE_ECB)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 174, in new
    return _create_cipher(sys.modules[__name__], key, mode, *args, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\__init__.py"", line 55, in _create_cipher
    return modes[mode](factory, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\_mode_ecb.py"", line 175, in _create_ecb_cipher
    cipher_state = factory._create_base_cipher(kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 99, in _create_base_cipher
    key = adjust_key_parity(key_in)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 80, in adjust_key_parity
    raise ValueError(""Not a valid TDES key"")
ValueError: Not a valid TDES key
</code></pre>

<p>My python MD5 hash is 32 hex characters long.  Assuming my math is right, 32 * 4 is 128 bits.  And the error is saying it must be 16 or 24 bytes long.  16 * 8 is also 128 bits.  So the byte string value i'm passing it should be correct.  I think I'm missing something, but can't seem to figure it out.</p>

<p><strong>Update 2-Jan-2018</strong>
Based on answer below here's a copy of the code that I used to confirm this will decrypt the data from the DB.</p>

<pre><code>from pyDes import *
import base64
import hashlib

#my_data is the word 'test' encrypted with the key of 'joetest'
my_data = ""fK/jw6/25y0=""


#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
digest_key = m.digest()

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(digest_key, ECB)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out.decode(""ascii""))
</code></pre>
","<p>The Error</p>

<blockquote>
  <p>line 80, in adjust_key_parity
          raise ValueError(""Not a valid TDES key"")</p>
</blockquote>

<p>Comes from the following code in pyCryptodome:</p>

<pre><code> 79   if len(key_in) not in key_size:
 80            raise ValueError(""Not a valid TDES key"")
..
186  # Size of a key (in bytes)
187  key_size = (16, 24)
</code></pre>

<p>Your key is 16 bytes long, but in hex form the key you pass have size 32.</p>
","846","<python-3.x><encryption><hash><3des>","1","0","3","2018-01-03 01:11:47","48065439","1","","9157327","","2018-01-03 01:11:47","2017-12-31 01:11:31",""
"48039173","Converting md5 hash to a proper 3DES key in python3","<p>I have a function written in c# that you can pass an ascii string as the key, and the encrypted string from a database and decode the data.</p>

<p>I've verified that the code works by  writing a simple c# program to decode the data.  The code snippet converts the key string to bytes and MD5 hashes it.  </p>

<p>C# Code Snippet, omitting some code that converted the byteHash to an ascii string for output in the compiled program</p>

<pre><code>key = ""joetest""

byte[] byteHash =  cryptoServiceProvider.ComputeHash(Encoding.ASCII.GetBytes(key));
</code></pre>

<p>byteHash = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I run the following commands and Python3 and get the same byteHash</p>

<pre><code>key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()
print(hex_key)
</code></pre>

<p>hex_key = ""f2fc0f481787cc4cbb15f7ded4412fe4""</p>

<p>I've tried encoding 'hex_key' as binary.</p>

<p>My issue is I'm trying to pass hex_key into 2 different python3 crypto programs.  Cryptodome and pyDes.  Both tell me that i'm passing in an invalid key.  </p>

<p>The C# code that uses byteHash is as follows</p>

<pre><code>tripleDesCryptoServiceProvider.Key = byteHash;

tripleDesCryptoServiceProvider.Mode = CipherMode.ECB;

byte[] byteBuff = Convert.FromBase64String(encryptedString);

string strDecrypted = Encoding.UTF8.GetString(tripleDesCryptoServiceProvider.CreateDecryptor().TransformFinalBlock(byteBuff, 0, byteBuff.Length));
</code></pre>

<p>This all works, i was able to decrypt data when i passed in the encrypted string into this function.</p>

<p>Using pyDes i'm using this code</p>

<pre><code>from pyDes import *
import base64
import hashlib


my_data = ""fK/jw6/25y0=""
#my_data is the word 'test' encrypted with the key of 'joetest'

#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")    #Encode the data as binary data
m = hashlib.md5()           
m.update(encoded_key)
hex_key = m.hexdigest()         #Convert the key to an MD5 hash
encoded_hex_key = hex_key.encode()  #Make the MD5 key a binary key  

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out)
exit()
</code></pre>

<p>The error i'm getting is:</p>

<pre><code>(3destest) c:\3des-test\3destest&gt;joe3des_test3.py
Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test3.py"", line 20, in &lt;module&gt;
    k = triple_des(encoded_hex_key, ECB, padmode=PAD_PKCS5)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 710, in __init__
    self.setKey(key)
  File ""c:\3des-test\3destest\lib\site-packages\pyDes.py"", line 719, in setKey
    raise ValueError(""Invalid triple DES key size. Key must be either 16 or 24 bytes long"")
ValueError: Invalid triple DES key size. Key must be either 16 or 24 bytes long
</code></pre>

<p>Using pyCryptodome, i've tried this code</p>

<pre><code>from Cryptodome.Cipher import DES3
import base64
import hashlib

# Converts the key string to an MD5 hash
key = ""joetest"" 
encoded_key = key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
hex_key = m.hexdigest()

#Decodes the string to binary digits
encryptedString = base64.b64decode(""fK/jw6/25y0="")

#Create the cipher to decrypt the data
cipher = DES3.new(hex_key, DES3.MODE_ECB)
decryptedString = cipher.decrypt(encryptedString)
</code></pre>

<p>And i get this error</p>

<pre><code>Traceback (most recent call last):
  File ""C:\3des-test\3destest\joe3des_test2.py"", line 16, in &lt;module&gt;
    cipher = DES3.new(hex_key, DES3.MODE_ECB)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 174, in new
    return _create_cipher(sys.modules[__name__], key, mode, *args, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\__init__.py"", line 55, in _create_cipher
    return modes[mode](factory, **kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\_mode_ecb.py"", line 175, in _create_ecb_cipher
    cipher_state = factory._create_base_cipher(kwargs)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 99, in _create_base_cipher
    key = adjust_key_parity(key_in)
  File ""c:\3des-test\3destest\lib\site-packages\Cryptodome\Cipher\DES3.py"", line 80, in adjust_key_parity
    raise ValueError(""Not a valid TDES key"")
ValueError: Not a valid TDES key
</code></pre>

<p>My python MD5 hash is 32 hex characters long.  Assuming my math is right, 32 * 4 is 128 bits.  And the error is saying it must be 16 or 24 bytes long.  16 * 8 is also 128 bits.  So the byte string value i'm passing it should be correct.  I think I'm missing something, but can't seem to figure it out.</p>

<p><strong>Update 2-Jan-2018</strong>
Based on answer below here's a copy of the code that I used to confirm this will decrypt the data from the DB.</p>

<pre><code>from pyDes import *
import base64
import hashlib

#my_data is the word 'test' encrypted with the key of 'joetest'
my_data = ""fK/jw6/25y0=""


#This code takes the key string and converts it to an MD5 hash
my_key = ""joetest""
encoded_key = my_key.encode(""ascii"")
m = hashlib.md5()
m.update(encoded_key)
digest_key = m.digest()

#Convert the Base64 encoded string to the format that the decoder wants
decoded_data = base64.b64decode(my_data)

k = triple_des(digest_key, ECB)
my_out = k.decrypt(decoded_data)
print(""my_out"")
print(my_out.decode(""ascii""))
</code></pre>
","<p>The disconnect here is that <code>pyDes.triple_des()</code> is looking for a binary key, but what you are giving it is an encoded string with the hex representation of that key.  Since <code>pyDes</code> doesn't expect the hex string, try just giving it the raw digest instead (i.e. <code>m.digest()</code> instead of <code>m.hexdigest()</code>).  No need to <code>.encode()</code> it either.</p>
","846","<python-3.x><encryption><hash><3des>","1","1","3","2018-01-03 01:11:47","48065439","1","","9157327","","2018-01-03 01:11:47","2017-12-31 01:11:31",""
"27929067","Encrypt using 3DES EDE / ECB / NOPadding","<p>I have received a task to encrypt and decrypt an XML string by using a TOKEN and a KEY.
The encryption shall use <code>3DES EDE / ECB / NOPadding</code> and can be made either in <code>PHP</code> or <code>C#</code></p>

<p>I am not so prepared on this so I have read around a bit of theory and came to a very easy implementation which is as follow:</p>

<pre><code>public string Encrypt( string message, string key, string token ) {
    byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes( message );
    byte[] keyArray = CreateHash( key );
    byte[] vectorArray = CreateHash( token );
    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    //set the secret key for the tripleDES algorithm
    tdes.Key = keyArray;
    //mode of operation. there are other 4 modes. We choose ECB(Electronic code Book)
    tdes.Mode = CipherMode.ECB;
    //padding mode(if any extra byte added)
    tdes.Padding = PaddingMode.None;

    ICryptoTransform cTransform = tdes.CreateEncryptor(keyArray, vectorArray);
    //transform the specified region of bytes array to resultArray
    byte[] resultArray = cTransform.TransformFinalBlock( toEncryptArray, 0, toEncryptArray.Length );
    //Release resources held by TripleDes Encryptor
    tdes.Clear();
    //Return the encrypted data into unreadable string format
    return Convert.ToBase64String( resultArray, 0, resultArray.Length );
}

private byte[] CreateHash( string toHash ) {
    //use get hashcode regards to your key
    MD5CryptoServiceProvider hashKey = new MD5CryptoServiceProvider();
    byte[] kArray = hashKey.ComputeHash( UTF8Encoding.UTF8.GetBytes( toHash ) );
    //Always release the resources and flush data
    //of the Cryptographic service provide. Best Practice
    hashKey.Clear();
    return kArray;
}
</code></pre>

<p>However I think this is not completely correct. In fact I am not sure that the TOKEN shall be used this way.
Can somebody provide more informations and point me to the right direction on how to solve this problem?</p>

<p>Thanks</p>
","<p>You could use token as a vector on TripleDESCryptoServiceProvider, together with the key.</p>

<pre><code>ICryptoTransform cTransform = tdes.CreateEncryptor(key, token);
</code></pre>
","819","<c#><php><encryption><3des>","0","2","1","2015-01-14 11:32:32","27929183","2","","431537","","2015-01-14 11:32:32","2015-01-13 18:33:26",""
"49774837","Triple DES with CBC mode : java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 8 bytes long","<p>I am trying to implement a 3DES encryption/decryption with CBC mode in java. <br/><br/>The initialisation vector is 0000000000000000
<br/>Encrypted string is DD446C051A83BFD98144C348935C61D81398CF29CCFE1CCD
<br/>Key for decryption is DCBA4F836E45BAB04FAB2937454075D9<br/><br/>
I am receiving below error. 
Any help will be much appreciated. Thanks.</p>

<pre><code>java.security.InvalidAlgorithmParameterException: Wrong IV length: must be 8 bytes long
</code></pre>

<p>Code:</p>

<pre><code>import java.security.Key; 

import javax.crypto.Cipher; 
import javax.crypto.SecretKeyFactory; 
import javax.crypto.spec.DESedeKeySpec; 
import javax.crypto.spec.IvParameterSpec;

import org.apache.commons.codec.binary.Base64; 

public class DES3 { 

    private static final String IV = ""01234567""; 
    private static final String CHARSET = ""utf-8""; 

    public static String decrypt(String iv, String secretKey, String encryptText) throws Exception { 
        DESedeKeySpec spec = new DESedeKeySpec(secretKey.getBytes()); 
        SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""desede""); 
        Key deskey = keyfactory.generateSecret(spec); 
        Cipher cipher = Cipher.getInstance(""desede/CBC/PKCS5Padding""); 
        IvParameterSpec ips = new IvParameterSpec(iv.getBytes()); 
        cipher.init(Cipher.DECRYPT_MODE, deskey, ips); 
        byte[] decryptData = cipher.doFinal(Base64.decodeBase64(encryptText)); 
        return new String(decryptData, CHARSET); 
    } 

    public static String decrypt(String secretKey, String encryptText) throws Exception { 
        return decrypt(IV, secretKey, encryptText); 
    } 

    public static void main(String[] args) {

        try {
            String iv=""0000000000000000"";
            System.out.println(""iv size""+iv.getBytes(""UTF8"").length);
            decrypt(iv, ""DCBA4F836E45BAB04FAB2937454075D9"", ""DD446C051A83BFD98144C348935C61D81398CF29CCFE1CCD"");
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }


    }

}
</code></pre>
","<p>You problem is here:</p>

<pre><code> String iv=""0000000000000000"";
</code></pre>

<p>which shows your IV is hex string. But in your decrypt function you use:</p>

<pre><code>iv.getBytes()
</code></pre>

<p>for this IV. This is obviously over 16 bytes long. <strong>You need to convert hex string to byte, not only use <code>getBytes()</code> function</strong>. <code>getBytes()</code> convert each chat to corresponding ASCII code, so you will get an array of 16 bytes each <code>0x30</code>, rather than getting an array of 8 bytes each <code>0</code>. </p>

<p>By the way, you have same problem for your secret key and your input too.</p>

<p>You can check <a href=""https://stackoverflow.com/questions/140131/convert-a-string-representation-of-a-hex-dump-to-a-byte-array-using-java"">hexStringToByteArray()</a> here.</p>
","808","<java><encryption><3des><cbc-mode><block-cipher>","-1","2","1","2018-04-11 14:51:16","","1","","","","","2018-04-11 12:13:37",""
"46730271","TripleDES Encryption between C#/.NET and PHP","<p>I have to implement some TripleDES encryption in my PHP application to communicate with a C#/.NET application, but I get different results compared to the server-side C#/.NET application. I already tried to use different encodings and flags, without much success.</p>

<p>I am already able to decrypt the string from C#/.NET and get the desired result in PHP (based on examples on StackOverflow and other sites).</p>

<p>The server-side C#/.NET code can be found and executed here:</p>

<p><a href=""https://dotnetfiddle.net/OrwaOl"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/OrwaOl</a></p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

public class Program
{
    public static void Main()
    {
        Console.WriteLine(Encrypt(""SourceString123"", ""fsgerh"", ""Dataehaeh""));
        Console.WriteLine(Decrypt(""Vql0pOr7ouxfUScI3H8exeFbfmcfE5uM3TBtAZXAq0zwkJmqEe13EA=="", ""fsgerh"", ""Dataehaeh""));
    }

    public static string Encrypt(string value, string password, string salt)
    {
        DeriveBytes rgb = new Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt));
        SymmetricAlgorithm algorithm = new TripleDESCryptoServiceProvider();
        byte[] rgbKey = rgb.GetBytes(algorithm.KeySize &gt;&gt; 3);
        byte[] rgbIV = rgb.GetBytes(algorithm.BlockSize &gt;&gt; 3);
        ICryptoTransform transform = algorithm.CreateEncryptor(rgbKey, rgbIV);
        using (MemoryStream buffer = new MemoryStream())
        {
            using (CryptoStream stream = new CryptoStream(buffer, transform, CryptoStreamMode.Write))
            {
                using (StreamWriter writer = new StreamWriter(stream, Encoding.Unicode))
                {
                    writer.Write(value);
                }
            }
            return Convert.ToBase64String(buffer.ToArray());
        }
    }

    public static string Decrypt(string text, string password, string salt)
    {
        DeriveBytes rgb = new Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt));
        SymmetricAlgorithm algorithm = new TripleDESCryptoServiceProvider();
        byte[] rgbKey = rgb.GetBytes(algorithm.KeySize &gt;&gt; 3);
        byte[] rgbIV = rgb.GetBytes(algorithm.BlockSize &gt;&gt; 3);
        ICryptoTransform transform = algorithm.CreateDecryptor(rgbKey, rgbIV);
        using (MemoryStream buffer = new MemoryStream(Convert.FromBase64String(text)))
        {
            using (CryptoStream stream = new CryptoStream(buffer, transform, CryptoStreamMode.Read))
            {
                using (StreamReader reader = new StreamReader(stream, Encoding.Unicode))
                {
                    return reader.ReadToEnd();
                }
            }
        }
    }

}
</code></pre>

<p>The ""cient""-side PHP code can be found and executed here:</p>

<p><a href=""http://phpfiddle.org/lite/code/hkgu-n1fe"" rel=""nofollow noreferrer"">http://phpfiddle.org/lite/code/hkgu-n1fe</a></p>

<pre><code>&lt;?php

$decrypted = 'SourceString123';
$encrypted = 'Vql0pOr7ouxfUScI3H8exeFbfmcfE5uM3TBtAZXAq0zwkJmqEe13EA==';

$password = 'fsgerh';
$salt = 'Dataehaeh';

$hash = hash_pbkdf2(""sha1"", $password, mb_convert_encoding($salt, 'UTF-16LE'), 1000, 32, true); 

$key = substr($hash, 0, 24);
$iv = substr($hash, 24, 8);

echo base64_encode($key) . ""&lt;br /&gt;"";
echo base64_encode($iv) . ""&lt;br /&gt;&lt;br /&gt;"";

$result = mb_convert_encoding(openssl_decrypt($encrypted, 'des-ede3-cbc', $key, 0, $iv), 'UTF-8', 'UTF-16');
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

$result = openssl_encrypt(mb_convert_encoding($decrypted, 'UTF-8'), 'des-ede3-cbc', $key, 0, $iv);
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

$result = openssl_encrypt(mb_convert_encoding($decrypted, 'UTF-16'), 'des-ede3-cbc', $key, 0, $iv);
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

?&gt;
</code></pre>

<p>I spent hours to figure out the problem, but haven't been able yet.</p>

<p>I would really appreciate if anybody can spot the problem or point me into the right direction.</p>
","<p>The PHP code uses the <code>hash_pbkdf2</code> with the <code>sha1</code> algo.</p>

<p>TripleDES is symmetric encryption, which is very different from sha1 which is a hashing function.</p>

<p>you can refer to <a href=""https://stackoverflow.com/questions/43642667/using-triple-des3des-with-php-7-1"">Using Triple DES(3DES) with PHP 7.1</a> for TripleDES in PHP</p>
","805","<c#><php><.net><3des><tripledes>","-2","2","2","2017-10-18 17:47:40","46816216","1","","7920473","","2017-10-13 13:22:47","2017-10-13 12:45:12",""
"46730271","TripleDES Encryption between C#/.NET and PHP","<p>I have to implement some TripleDES encryption in my PHP application to communicate with a C#/.NET application, but I get different results compared to the server-side C#/.NET application. I already tried to use different encodings and flags, without much success.</p>

<p>I am already able to decrypt the string from C#/.NET and get the desired result in PHP (based on examples on StackOverflow and other sites).</p>

<p>The server-side C#/.NET code can be found and executed here:</p>

<p><a href=""https://dotnetfiddle.net/OrwaOl"" rel=""nofollow noreferrer"">https://dotnetfiddle.net/OrwaOl</a></p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Text;
using System.IO;

public class Program
{
    public static void Main()
    {
        Console.WriteLine(Encrypt(""SourceString123"", ""fsgerh"", ""Dataehaeh""));
        Console.WriteLine(Decrypt(""Vql0pOr7ouxfUScI3H8exeFbfmcfE5uM3TBtAZXAq0zwkJmqEe13EA=="", ""fsgerh"", ""Dataehaeh""));
    }

    public static string Encrypt(string value, string password, string salt)
    {
        DeriveBytes rgb = new Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt));
        SymmetricAlgorithm algorithm = new TripleDESCryptoServiceProvider();
        byte[] rgbKey = rgb.GetBytes(algorithm.KeySize &gt;&gt; 3);
        byte[] rgbIV = rgb.GetBytes(algorithm.BlockSize &gt;&gt; 3);
        ICryptoTransform transform = algorithm.CreateEncryptor(rgbKey, rgbIV);
        using (MemoryStream buffer = new MemoryStream())
        {
            using (CryptoStream stream = new CryptoStream(buffer, transform, CryptoStreamMode.Write))
            {
                using (StreamWriter writer = new StreamWriter(stream, Encoding.Unicode))
                {
                    writer.Write(value);
                }
            }
            return Convert.ToBase64String(buffer.ToArray());
        }
    }

    public static string Decrypt(string text, string password, string salt)
    {
        DeriveBytes rgb = new Rfc2898DeriveBytes(password, Encoding.Unicode.GetBytes(salt));
        SymmetricAlgorithm algorithm = new TripleDESCryptoServiceProvider();
        byte[] rgbKey = rgb.GetBytes(algorithm.KeySize &gt;&gt; 3);
        byte[] rgbIV = rgb.GetBytes(algorithm.BlockSize &gt;&gt; 3);
        ICryptoTransform transform = algorithm.CreateDecryptor(rgbKey, rgbIV);
        using (MemoryStream buffer = new MemoryStream(Convert.FromBase64String(text)))
        {
            using (CryptoStream stream = new CryptoStream(buffer, transform, CryptoStreamMode.Read))
            {
                using (StreamReader reader = new StreamReader(stream, Encoding.Unicode))
                {
                    return reader.ReadToEnd();
                }
            }
        }
    }

}
</code></pre>

<p>The ""cient""-side PHP code can be found and executed here:</p>

<p><a href=""http://phpfiddle.org/lite/code/hkgu-n1fe"" rel=""nofollow noreferrer"">http://phpfiddle.org/lite/code/hkgu-n1fe</a></p>

<pre><code>&lt;?php

$decrypted = 'SourceString123';
$encrypted = 'Vql0pOr7ouxfUScI3H8exeFbfmcfE5uM3TBtAZXAq0zwkJmqEe13EA==';

$password = 'fsgerh';
$salt = 'Dataehaeh';

$hash = hash_pbkdf2(""sha1"", $password, mb_convert_encoding($salt, 'UTF-16LE'), 1000, 32, true); 

$key = substr($hash, 0, 24);
$iv = substr($hash, 24, 8);

echo base64_encode($key) . ""&lt;br /&gt;"";
echo base64_encode($iv) . ""&lt;br /&gt;&lt;br /&gt;"";

$result = mb_convert_encoding(openssl_decrypt($encrypted, 'des-ede3-cbc', $key, 0, $iv), 'UTF-8', 'UTF-16');
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

$result = openssl_encrypt(mb_convert_encoding($decrypted, 'UTF-8'), 'des-ede3-cbc', $key, 0, $iv);
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

$result = openssl_encrypt(mb_convert_encoding($decrypted, 'UTF-16'), 'des-ede3-cbc', $key, 0, $iv);
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

?&gt;
</code></pre>

<p>I spent hours to figure out the problem, but haven't been able yet.</p>

<p>I would really appreciate if anybody can spot the problem or point me into the right direction.</p>
","<p>I solved the problem by using iconv() instead of mb_convert_encoding() and now I get the expected result in PHP as well as in .NET/C#. The following code shows my result for reference.</p>

<pre><code>&lt;?php

$decrypted = 'SourceString123';
$encrypted = 'Vql0pOr7ouxfUScI3H8exeFbfmcfE5uM3TBtAZXAq0zwkJmqEe13EA==';

$password = 'fsgerh';
$salt = 'Dataehaeh';

$hash = hash_pbkdf2(""sha1"", $password, mb_convert_encoding($salt, 'UTF-16LE'), 1000, 32, true); 

$key = substr($hash, 0, 24);
$iv = substr($hash, 24, 8);

echo base64_encode($key) . ""&lt;br /&gt;"";
echo base64_encode($iv) . ""&lt;br /&gt;&lt;br /&gt;"";

$result = iconv('UTF-16', 'UTF-8', openssl_decrypt($encrypted, 'des-ede3-cbc', $key, 0, $iv));
echo $result;
echo ""&lt;br /&gt;&lt;br /&gt;"";

$result = openssl_encrypt(iconv('UTF-8', 'UTF-16', $decrypted), 'des-ede3-cbc', $key, 0, $iv);
echo $result;
echo ""&lt;br /&gt;"";

?&gt;
</code></pre>
","805","<c#><php><.net><3des><tripledes>","-2","0","2","2017-10-18 17:47:40","46816216","1","","7920473","","2017-10-13 13:22:47","2017-10-13 12:45:12",""
"18825602","3DES encryption in C# and decryption in an existing Java application","<p>I am trying to write an encrypt function in C# that generates a string that can be decrypted in a Java application. The existing Java decrypting code I received from my client:</p>

<pre><code>    public static String encryptParameters(byte plainText[], String sKey)
        throws RCPCipherException
    {
      Cipher cipher;
      DESedeKeySpec dks = new DESedeKeySpec(_getKeyBytes(sKey));
      java.security.Key secretKey = SecretKeyFactory.getInstance(""DESede"").generateSecret(dks);
      cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
      cipher.init(1, secretKey);
      return Base64.encodeBase64URLSafeString(cipher.doFinal(plainText));
    }
</code></pre>

<p>So far I only have this in C#:</p>

<pre><code>public string Encrypt(string toEncrypt, string encryptionKey, bool useHashing)
{
    byte[] keyArray;
    byte[] toEncryptArray = Encoding.UTF8.GetBytes(toEncrypt);

    if (useHashing)
    {
        var hashmd5 = new MD5CryptoServiceProvider();
        keyArray = hashmd5.ComputeHash(Encoding.UTF8.GetBytes(encryptionKey));
        hashmd5.Clear();
    }
    else
    {
        keyArray = Encoding.UTF8.GetBytes(encryptionKey);
    }

    var tripleDesCryptoServiceProvider = new TripleDESCryptoServiceProvider();

    //set the secret key for the tripleDES algorithm
    tripleDesCryptoServiceProvider.Key = keyArray;

    //mode of operation. there are other 4 modes.
    //We choose ECB(Electronic code Book)
    tripleDesCryptoServiceProvider.Mode = CipherMode.ECB;

    //padding mode(if any extra byte added)
    tripleDesCryptoServiceProvider.Padding = PaddingMode.PKCS7;

    var cTransform = tripleDesCryptoServiceProvider.CreateEncryptor();

    //transform the specified region of bytes array to resultArray
    var resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

    //Release resources held by TripleDes Encryptor
    tripleDesCryptoServiceProvider.Clear();

    //Return the encrypted data into unreadable string format
    return Convert.ToBase64String(resultArray, 0, resultArray.Length);
}
</code></pre>

<p>What can be done to make them compatible?</p>

<p>The plainText byte array parameter in the Java function is created via a String.getBytes(""UTF-8"").</p>
","","778","<c#><java><compatibility><3des>","1","","0","2013-09-16 12:39:03","","0","2","2783503","","2013-09-16 12:39:03","2013-09-16 10:18:57",""
"21378979","3DES encryption using CFB8 and no padding in iOS?","<p>I am developing an application which will send encrypted data to a server. The server uses 3des with CFB8 and no padding. I have read most of the related questions in stackoverflow but still unable to get it work. Been working on this for few days but still unable to get it to match with the server encryption. here is what i have tried-</p>

<pre><code> + (NSString*) doCipher:(NSString*)plainText operation:(CCOperation)encryptOrDecrypt {

        const void *vplainText;
        NSData* plainTextData;
        size_t plainTextBufferSize;

        if (encryptOrDecrypt == kCCDecrypt)
        {
           NSData *EncryptData =[NSData  dataWithBase64EncodedString:plainText];
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
        }
        else
        {
             plainTextData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
        plainTextBufferSize = [plainTextData length];
        }

        CCCryptorStatus ccStatus;
        uint8_t *bufferPtr = NULL;
        size_t bufferPtrSize = 0;
        size_t movedBytes = 0;
         uint8_t iv[kCCBlockSize3DES];

        bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
        bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
        memset((void *)bufferPtr, 0x0, bufferPtrSize);
         memset((void *) iv, 0x0, (size_t) sizeof(iv));

        const void *vkey = kPrivateKey;
        unsigned char IV[8]={0,0,0,0,0,0,0,0};

        ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       0,
                       [keyData bytes],
                       [key length],
                       IV,
                       [plainTextData bytes],
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

        if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
        else if (ccStatus == kCCParamError) return @""PARAM ERROR"";
        else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
        else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
        else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
        else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
        else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

        NSString *result;

        if (encryptOrDecrypt == kCCDecrypt)
        {
            result = [[NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];
        }
        else
        {
            NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
            result = [myData base64EncodedString];
        }

        return result;
    }
</code></pre>

<p>It seems <code>CCOptions</code> currently supports <code>kCCOptionPKCS7Padding</code> and <code>kCCOptionECBMode</code>.How to achieve 3des with CFB8 and no padding.Any suggestion would be appreciated. </p>
","<p>EDIT: Sorry; I overlooked a key point previously. You're never asking for CFB8 mode. The default is CBC mode.</p>

<p>You can't use <code>CCCrypt()</code> for this. You have to use <code>CCCryptorCreateWithMode()</code> so you can pass the mode. Then call <code>CCCryptorUpdate()</code> with the data and <code>CCCryptorFinal()</code> to finish.</p>

<hr>

<p>If you don't want padding, why are you requesting padding? Remove <code>kCCOptionPKCS7Padding</code>. If you don't want any options (which you appear not to), just pass 0.</p>

<p>CFB-8 takes an initialization vector. You've set it to all 0's. Is this what the server is using? (This is a very poor IV; the IV for CFB should be random, not fixed.)</p>

<p>These lines are dangerous:</p>

<pre><code>    plainTextBufferSize = [plainText length];
    vplainText = (const void *) [plainText UTF8String];
</code></pre>

<p>This will truncate any multi-byte strings. The better solution to this is to create an <code>NSData</code>:</p>

<pre><code>plainTextData = [self.plainText dataUsingEncoding:NSUTF8StringEncoding];
</code></pre>

<p>You can then use <code>bytes</code> and <code>length</code> on <code>plainTextData</code>.</p>
","751","<ios><objective-c><encryption><3des><commoncrypto>","0","2","1","2014-01-29 14:46:12","","1","1","1534593","","2014-01-28 08:37:26","2014-01-27 10:55:06",""
"9863893","problems with 3DES encryption cut or extends the string","<p>i'm using that code for encrypt a string with 3DES in IOS and i want decrypt it with php
but it generate a string longer if i use kCCOptionPKCS7Padding ( or shorter if i don't use it )
when i decrypt it with php it adds more or less chars to de string 
how i can fix that ?</p>

<p>that is how i decrypt with php</p>

<pre><code>$key = ""f968f8e82961489a8b14b345"";
$encrypted = base64_decode($crypt);
$n = mcrypt_module_open(MCRYPT_3DES, null, MCRYPT_MODE_ECB, null);
$fake_iv = str_repeat(chr(0), mcrypt_enc_get_iv_size($n));
mcrypt_generic_init($n, $key, $fake_iv);
$original = mdecrypt_generic($n, $encrypted);
</code></pre>

<p>that is where i call function for encrypt</p>

<pre><code>NSString* str= @""test string with random words"";
NSData* body =[str dataUsingEncoding:NSUTF8StringEncoding];

NSData *encrypt3DES     = [ViewController TripleDES:body encryptOrDecrypt:kCCEncrypt key:@""f968f8e82961489a8b14b345""];

NSData *encryptBase64   = [GTMBase64 encodeData:encrypt3DES];
</code></pre>

<p>that is how i encrypt in ios</p>

<pre><code>+ (NSData*)TripleDES:(NSData*)plainData encryptOrDecrypt:(CCOperation)encryptOrDecrypt key:(NSString*)key {

    const void *vplainText;
    size_t plainTextBufferSize;

    plainTextBufferSize = [plainData length];
    vplainText = (const void *)[plainData bytes];


    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    // uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));

    //    NSString *key = @""123456789012345678901234"";
    NSString *initVec = @""init Vec"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       (kCCOptionPKCS7Padding | kCCOptionECBMode),
                       vkey, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       vinitVec, //""init Vec"", //iv,
                       vplainText, //""Your Name"", //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);
 /*   if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    else if (ccStatus == kCCParamError) NSLog( @""PARAM ERROR"");
     else if (ccStatus == kCCBufferTooSmall) NSLog( @""BUFFER TOO SMALL"");
     else if (ccStatus == kCCMemoryFailure) NSLog( @""MEMORY FAILURE"");
     else if (ccStatus == kCCAlignmentError) NSLog( @""ALIGNMENT"");
     else if (ccStatus == kCCDecodeError) NSLog( @""DECODE ERROR"");
     else if (ccStatus == kCCUnimplemented) NSLog( @""UNIMPLEMENTED"");

  */

    NSData *result = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];

    return result;
}
</code></pre>

<p><strong>more info</strong></p>

<p>that is the output i get decrypting with php (at the end of string it add stange square chars)</p>

<pre><code>test string with random words
</code></pre>

<p>that is what i want obtaine </p>

<pre><code>test string with random words
</code></pre>

<p>that is the Base64 code generated by <code>NSString *base64tring = [[NSString alloc] initWithData:encryptBase64 encoding:NSUTF8StringEncoding];</code></p>

<pre><code>JuelOxhG5rmLZ32/HNQjxqSPGovPv+lupUz/u0/ryXU=
</code></pre>
","<p>Without having this tested i guess the reason for your ""strange bytes"" is the PKCS#5 padding that you add to the string on iOS side. It is not supported by PHPs mcrypt extension, so you would have to remove it yourself. For example, by using a function from <a href=""http://www.php.net/manual/en/ref.mcrypt.php#69782"" rel=""nofollow"">the commentary on mcrypt</a></p>

<pre><code>function pkcs5_unpad($text)
{
    $pad = ord($text{strlen($text)-1});
    if ($pad &gt; strlen($text)) return false;
    if (strspn($text, chr($pad), strlen($text) - $pad) != $pad) return false;
    return substr($text, 0, -1 * $pad);
} 
</code></pre>
","744","<php><ios><encryption><3des>","3","2","1","2012-03-25 21:13:09","9864126","2","","721253","","2012-03-25 21:03:36","2012-03-25 20:46:02",""
"54420126","OpenSSL [des-ede3-cbc] Decryption php","<p>i had to receive some data encrypted with 3DES with shared keys.
I'm using php7 and openssl_decrypt function, but I'm not able to recreate the result of the example of the documentation sent to me.</p>

<p>The OpenSSL command that create the data sent to me is the following:</p>

<pre><code>openssl enc -des-ede3-cbc -base64 -K 17839778773fadde0066e4578710928988398877bb123789 -iv 00000000 -in D:/in.txt

Example:
string_encoded: 123456
data_to_decrypt: Ja79hWTRfBE=
</code></pre>

<p>I tried to decode ""Ja79hWTRfBE="" with an online tool and I successfully obtain ""123456"".
(I used this tool: <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a> with input text  (hex) ""25aefd8564d17c11"", function: 3DES, mode: CBC, key (hex) 17839778773fadde0066e4578710928988398877bb123789, iv: 00000000 )</p>

<p>Below my php code:</p>

<pre><code>$key = ""17839778773fadde0066e4578710928988398877bb123789"";
$decData = openssl_decrypt(base64_decode('Ja79hWTRfBE='), 'DES-EDE3-CBC', $key, 0, ""00000000"");
var_dump($decData);
</code></pre>

<p>var_dump return me bool(false).</p>

<p>What am i doing wrong?</p>
","<p>i can reproduce your goal with the following code:</p>

<pre><code>&lt;?php

$data = ""123456"";
$method = ""DES-EDE3"";
$key = ""17839778773fadde0066e4578710928988398877bb123789"";
$options = 0;

// transform the key from hex to string
$key = pack(""H*"", $key);

// encrypt
$enc = openssl_encrypt($data, $method, $key, $options);
// decrypt
$dec = openssl_decrypt($enc, $method, $key, $options);

echo ""plain: "".$data."" encrypted: "".$enc."" decrypted: "".$dec;
</code></pre>

<ul>
<li>set data without base64</li>
<li>use DES-EDE3 method</li>
<li>transform your key (from hex to string)</li>
</ul>
","740","<php><encryption><3des><php-openssl><tripledes>","1","1","1","2019-01-29 13:35:05","54422313","0","","","","","2019-01-29 11:33:05",""
"29610827","3DES CB Encryption Dynamic Key","<p>A guy told me to encrypt data by using a dynamic key generated according to the following algorithm</p>

<pre><code>timestamp  = '080717032817'    
static_key =  A270AE59FF7782A2EDFE1A781BAB888D0B749D265865C288
k1 = first 5 bytes of the static key
k2 = first 3 bytes of the integer value of the timestamp
k3 = last  5 bytes of the static key
k4 = last  5 bytes of the timestamp
dynamic_key = k1k2k3k4
</code></pre>

<p>He told be that the data should be padded :</p>

<pre><code>pad to reach a multiple of the blocksize (8byte for 3DES CBC),
</code></pre>

<p>or</p>

<pre><code> pad with 8 null bytes if the length of the data is already multiple of 8.
</code></pre>

<p>In his example, with an <code>iv='0123456789ABCDEF'</code> he obtains:</p>

<pre><code>&lt;DATA&gt;       &lt;TIMESTAMP&gt;    &lt;BASE64 CRYPTED DATA&gt;
3408682266,080717032817,hkUIYwssDQCq0GLx/5MiZg==
</code></pre>

<p>To implement the algo, I wrote this class functions</p>

<pre><code>private function __encrypt($data,$parameters,$time,$convert = false)
    {

        $staticKey  =  
        $mode       = MCRYPT_MODE_CBC;
        $ivi        = '0123456789ABCDEF';
        $cipher     = MCRYPT_3DES;
        $this-&gt;log[] = ""Encrypt params: mode =&gt; {$mode}, cipher =&gt; {$cipher}, iv =&gt;{$ivi}"";
        $dynamicKey =  
        $iv         = pack('H*', $ivi);
        $this-&gt;log[] = 'Initial Vector '. var_dump($iv);         
        $data = $this-&gt;__padder($data,mcrypt_get_block_size($cipher, $mode),$convert);

        $this-&gt;log[] = ('Data After padding: ' . $data ."", length (bytes):"" . strlen($data)/2);

        try {
             $output = mcrypt_encrypt($cipher, $dynamicKey, $data, $mode,$iv);

        } catch (Exception $ex) {
             debug($ex-&gt;getMessage());
            throw new Exception($ex-&gt;getMessage());

        }

        return $output;
    }

/**
     * Generate a dynamic key based on a timestamp and a static key
     * @param type $static_key
     */
    private function __generateDynamicKey($static_key = '', $time)
    {

        $dateObj = DateTime::createFromFormat(""ymdHis"", $time);


        $k[1]    = substr($static_key,0,  10);

        $k[2]    = substr($time,0,6);debug($k[2]);

        $k[3]    = substr($static_key,strlen($static_key) - 10,  10);        

        $k[4]    = substr($time,strlen($time)-6,6);debug($k[4]); //last 3 bytes
        $this-&gt;log[] = (""Dynamic key =&gt;"".join("""",$k). ', length in bytes=&gt;'. strlen(pack('H*', join("""",$k))));

        return  pack('H*', join("""",$k));

    }
/**
     * 
     * @param type $data
     * @param type $blockSize
     * @param type $convert
     * @return string
     */
    private function __padder($data,$blockSize = 8,$convert = false)
    {  

        if ($convert)
            $data = Generic::strToHex($data); // hex representation of the data

        $this-&gt;log[] = 'Block size of cipher: ' .$blockSize;
        $this-&gt;log[] = (""Hex value before padding=&gt;"".($data) );
        //Chek if the data is padded to 16 bytes        
        $dataBytes   = strlen($data) / 2 ; //  1 byte = 2 Hex digits
        $this-&gt;log[] = ""Data num. of bytes "" . $dataBytes;
        $rest      = $dataBytes % $blockSize;    // The num of bytes is a multiple of blockSize ?
        $nearest   = ceil($dataBytes/$blockSize ) * $blockSize;
        $output    = $data;
        if ($rest != 0)
        {
            $delta       = ($nearest - $dataBytes); // in bytes
            $deltaValue  = Generic::zeropad($delta, 2);            
            $this-&gt;log[] = ('padding value '.$deltaValue);

        }
        else
        {  
            $this-&gt;log[] = ('Add 8 bytes of padding!');
            $delta       = 8;
            $deltaValue  = '00';

        }

        $output = $data . str_repeat($deltaValue, $delta);
        $this-&gt;log[] = ('Hex  value after padding '. $output . ', length in bytes =&gt;' . strlen($output)/2);

        return $output;
    }

public function test($clearUserCode)
{
 $userCode = $this-&gt;__encrypt($clearUserCode,$provider,$time,true); //UserCode is given as string, mut be converted in hex
        $this-&gt;log[] = ('UserCode Clear : ' . $clearUserCode . ', in hex: ' . Generic::strToHex($clearUserCode));
        $this-&gt;log[] = ('UserCode Crypt : ' . bin2hex($userCode));
        $this-&gt;log[] = ('UserCode Crypt and base64: ' . base64_encode(($userCode)));

        $this-&gt;log[] = ('----------------------End encrypt UserCode part----------------------') ;
 }
</code></pre>

<p>And finally somewhere</p>

<pre><code>$this-&gt;test('3408682266');
</code></pre>

<p>which give to me a different result:</p>

<pre><code>UserCode Clear : 3408682266, in hex: 33343038363832323636
UserCode Crypt : 9d7e195a8d85aa7d051362dfae0042c2
UserCode Crypt and base64: nX4ZWo2Fqn0FE2LfrgBCwg==
</code></pre>

<p>Any hint?</p>
","<p>After googling somewhere, I discovered that 3DES wants a 192 bits key, and in some way <code>php</code>'s <code>mcrypt</code> does not do that magically: You have to pad the key yourself! These are the two functions that work for the examples of the question:</p>

<pre><code> /**
     * Make ciphering (3DES) in pkc7 (padding with 0 or a filling value)
     * key must bey 24 bytes (192 bits)
     * @param type $key
     * @param type $iv
     * @param type $text
     * @return type
     */
    public static function encryptNET3DES($key,$iv,$text)

    {
      $td = mcrypt_module_open(MCRYPT_3DES, '', MCRYPT_MODE_CBC, '');

      // Complete the key

      $key_add = 24-strlen($key);
      $key     .= substr($key,0,$key_add);


      // Padding the text 

      $block   = mcrypt_get_block_size(""tripledes"", ""cbc"");                
      $len     = strlen($text);           
      $padding = $block - ($len % $block);

      $text    .= str_repeat(chr($padding),$padding);           
      mcrypt_generic_init ($td, $key, $iv);
      $encrypt_text = mcrypt_generic ($td, $text);
      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);
      return $encrypt_text;    

}    
    /**
     * Decrypt 3DES encrypted data with 24-bit key 
     * @param type $key
     * @param type $iv
     * @param type $text
     * @return type
     */
    public static function decryptNET3DES($key,$iv,$text)

    {

    $td = mcrypt_module_open (MCRYPT_3DES, """", MCRYPT_MODE_CBC, """");
    // Complete the key
    $key_add  = 24-strlen($key);
    $key      .= substr($key,0,$key_add);
    mcrypt_generic_init ($td, $key, $iv);
    $decrypt_text = mdecrypt_generic ($td, $text);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
    //remove the padding text

    $block   = mcrypt_get_block_size(""tripledes"", ""cbc"");
    $packing = ord($decrypt_text{strlen($decrypt_text) - 1}); 
    if($packing &amp;&amp; ($packing &lt; $block))
    // Get rid of padded data
    {        
          for($P = strlen($decrypt_text) - 1; $P &gt;= strlen($decrypt_text) - $packing; $P--)          {
               if(ord($decrypt_text{$P}) != $packing)
               {
                   $packing = 0;
               }
         }
    }

   $decrypt_text = substr($decrypt_text,0,strlen($decrypt_text) - $packing);

   return $decrypt_text;

}
</code></pre>
","670","<php><mcrypt><3des>","0","0","1","2015-04-14 12:07:35","","0","1","778508","","2015-04-14 07:44:33","2015-04-13 16:54:09",""
"38489874","TripleDES Key - Generate String Key","<p>I received the tripleDES key as follow:</p>

<p>2 components of 16 bytes HEX string each.</p>

<p><strong>Component 1</strong>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>

<p><strong>KCV 1</strong>: 0000000000000000</p>

<p><strong>Component 2</strong>: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p>

<p><strong>KCV 2</strong>: 0000000000000000</p>

<p>I need to store the final key as UTF8 string in web.config (Development Stage), there is an implementation running in production using this approach, key length is 24 characters, where I only retrieve the key in web.config as follow:</p>

<pre><code>Encoding.UTF8.GetBytes(secreteKeyValue);
//Secret key from web.config
</code></pre>

<p>How can i generate the final key from those components as UTF 8 string to store in web.config and use in the method below ?</p>

<pre><code>public static byte[] TripleDes(byte[] inputBuffer, byte[] key)
    {
        using (TripleDESCryptoServiceProvider des = new TripleDESCryptoServiceProvider())
        {
            des.Key = key;
            des.Mode = CipherMode.ECB;
            des.Padding = PaddingMode.None;

            byte[] result;

            using (MemoryStream stream = new MemoryStream())
            using (CryptoStream cryptoStream = new CryptoStream(stream, des.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cryptoStream.Write(inputBuffer, 0, inputBuffer.Length);
                cryptoStream.Flush();
                result = stream.ToArray();
            }

            return result;
        }
    }
</code></pre>
","","669","<c#><security><encryption><3des><tripledes>","1","","0","2016-07-20 20:05:25","","13","","","","","2016-07-20 20:05:25",""
"47750359","TripleDES Length of the data to encrypt is invalid","<p>I have the following code :
</p>

<pre><code>public static string Encrypt3Des(string cipherString)
{
    string result = """";

    byte[] keyArray;
    byte[] ivArray;

    byte[] toEncryptArray = Enc3DesPerChar(cipherString);
    //string toEncryptString = ByteArrayToString(toEncryptArray);

    // Get the key from config file
    System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
    string key = (string)settingsReader.GetValue(""SecurityKey"", typeof(String));
    string iv = (string)settingsReader.GetValue(""InitializationVector"", typeof(String));

    keyArray = StringToByteArray(key);
    ivArray = StringToByteArray(iv);

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    //set the secret key for the tripleDES algorithm

    tdes.Key = keyArray;
    tdes.IV = ivArray;

    //ChiperMode
    tdes.Mode = CipherMode.CBC;

    //PaddingMode(if any extra byte added)
    tdes.Padding = PaddingMode.None;

    ICryptoTransform cTransform = tdes.CreateEncryptor();
    //transform the specified region of bytes array to resultArray
    byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

    //Release resources held by TripleDes Encryptor
    tdes.Clear();

    result = ByteArrayToString(resultArray);

    return result;
}
</code></pre>



<p>And this is my method :</p>

<pre><code>protected static string ByteArrayToString(byte[] ba)
{
    StringBuilder hex = new StringBuilder(ba.Length * 2);
    foreach (byte b in ba)
        hex.AppendFormat(""{0:x2}"", b);
    return hex.ToString();
}

protected static byte[] StringToByteArray(String hex)
{
    int NumberChars = hex.Length;
    byte[] bytes = new byte[NumberChars / 2];
    for (int i = 0; i &lt; NumberChars; i += 2)
        bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
    return bytes;
}

protected static byte[] Enc3DesPerChar(String toEncrypt)
{
    string toAsciiString = ByteArrayToString(Encoding.ASCII.GetBytes(toEncrypt));

    string toRoll = toAsciiString;

    int NumberChars = toRoll.Length;
    byte[] bytes = new byte[NumberChars / 2];
    for (int i = 0; i &lt; NumberChars; i += 2)
    {
        bytes[i / 2] = Convert.ToByte(toRoll.Substring(i, 2), 16);
    }
    return bytes;
}
</code></pre>

<p>
Everything works fine with the above method until I found that the method cannot accept less than 8 character.</p>

<p>The block code that raise an error :</p>

<pre><code>byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
</code></pre>

<p>Error message :</p>

<blockquote>
  <p>Length of the data to encrypt is invalid.</p>
</blockquote>

<p>
Example input :</p>

<pre><code>Encrypt3Des(""14022000""); // return encrypt because 8 character or more

Encrypt3Des(""1402200""); // return error because 7 character
</code></pre>

<p>Does anybody know why this is or how I can fix it? (I don't know if it comes from my encrypting method, but I know a web app which uses the exact same thing to encrypt strings and that one does work.)</p>

<p>EDIT :
The tool that I used for manual encrypt : <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">3des</a></p>

<p>The option must :</p>

<ul>
<li>Text input type</li>
<li>Plaintext input text</li>
<li>3DES function</li>
<li>CBC mode</li>
<li>Fixed Key Hex</li>
<li>Fixed Init Vector</li>
</ul>
","<p>You are using padding as none.  Set the padding mode to <code>PKCS7</code>.</p>
","665","<c#><encryption><3des><tripledes>","0","1","2","2017-12-12 04:24:19","","5","","5761779","","2017-12-12 03:00:27","2017-12-11 10:02:16",""
"47750359","TripleDES Length of the data to encrypt is invalid","<p>I have the following code :
</p>

<pre><code>public static string Encrypt3Des(string cipherString)
{
    string result = """";

    byte[] keyArray;
    byte[] ivArray;

    byte[] toEncryptArray = Enc3DesPerChar(cipherString);
    //string toEncryptString = ByteArrayToString(toEncryptArray);

    // Get the key from config file
    System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();
    string key = (string)settingsReader.GetValue(""SecurityKey"", typeof(String));
    string iv = (string)settingsReader.GetValue(""InitializationVector"", typeof(String));

    keyArray = StringToByteArray(key);
    ivArray = StringToByteArray(iv);

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
    //set the secret key for the tripleDES algorithm

    tdes.Key = keyArray;
    tdes.IV = ivArray;

    //ChiperMode
    tdes.Mode = CipherMode.CBC;

    //PaddingMode(if any extra byte added)
    tdes.Padding = PaddingMode.None;

    ICryptoTransform cTransform = tdes.CreateEncryptor();
    //transform the specified region of bytes array to resultArray
    byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

    //Release resources held by TripleDes Encryptor
    tdes.Clear();

    result = ByteArrayToString(resultArray);

    return result;
}
</code></pre>



<p>And this is my method :</p>

<pre><code>protected static string ByteArrayToString(byte[] ba)
{
    StringBuilder hex = new StringBuilder(ba.Length * 2);
    foreach (byte b in ba)
        hex.AppendFormat(""{0:x2}"", b);
    return hex.ToString();
}

protected static byte[] StringToByteArray(String hex)
{
    int NumberChars = hex.Length;
    byte[] bytes = new byte[NumberChars / 2];
    for (int i = 0; i &lt; NumberChars; i += 2)
        bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
    return bytes;
}

protected static byte[] Enc3DesPerChar(String toEncrypt)
{
    string toAsciiString = ByteArrayToString(Encoding.ASCII.GetBytes(toEncrypt));

    string toRoll = toAsciiString;

    int NumberChars = toRoll.Length;
    byte[] bytes = new byte[NumberChars / 2];
    for (int i = 0; i &lt; NumberChars; i += 2)
    {
        bytes[i / 2] = Convert.ToByte(toRoll.Substring(i, 2), 16);
    }
    return bytes;
}
</code></pre>

<p>
Everything works fine with the above method until I found that the method cannot accept less than 8 character.</p>

<p>The block code that raise an error :</p>

<pre><code>byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
</code></pre>

<p>Error message :</p>

<blockquote>
  <p>Length of the data to encrypt is invalid.</p>
</blockquote>

<p>
Example input :</p>

<pre><code>Encrypt3Des(""14022000""); // return encrypt because 8 character or more

Encrypt3Des(""1402200""); // return error because 7 character
</code></pre>

<p>Does anybody know why this is or how I can fix it? (I don't know if it comes from my encrypting method, but I know a web app which uses the exact same thing to encrypt strings and that one does work.)</p>

<p>EDIT :
The tool that I used for manual encrypt : <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">3des</a></p>

<p>The option must :</p>

<ul>
<li>Text input type</li>
<li>Plaintext input text</li>
<li>3DES function</li>
<li>CBC mode</li>
<li>Fixed Key Hex</li>
<li>Fixed Init Vector</li>
</ul>
","<p>Ok, I think just found the solution (my client told me how), I need to fill up the character with null before the loop. null can be converted to ascii with ""00"". so I decide to PadRight to the ascii result with '0' to 16 character, so one of my method become :</p>

<pre><code>protected static byte[] Enc3DesPerChar(String toEncrypt)
{
    string toAsciiString = ByteArrayToString(Encoding.ASCII.GetBytes(toEncrypt));

    string toRoll = toAsciiString.PadRight(16,'0');

    int NumberChars = toRoll.Length;
    byte[] bytes = new byte[NumberChars / 2];
    for (int i = 0; i &lt; NumberChars; i += 2)
    {
        bytes[i / 2] = Convert.ToByte(toRoll.Substring(i, 2), 16);
    }
    return bytes;
}
</code></pre>
","665","<c#><encryption><3des><tripledes>","0","-1","2","2017-12-12 04:24:19","","5","","5761779","","2017-12-12 03:00:27","2017-12-11 10:02:16",""
"13704069","Want to convert 3DES Encrypted NSData to NSString","<p>In my project, I am encrypting some data (string) using the 3DES encryption algorithm. The string I pass to the encryption function returns me a NSData object. </p>

<p>Now I want to convert NSData to NSString, so that I can send that string to server. </p>

<p>So I used this code to convert NSData to NSString </p>

<p><code>NSString *stringCreated = [[NSString alloc] initWithData:encryptedData encoding:NSASCIIStringEncoding];</code></p>

<p>But when I print this string, It prints very few characters on the console. I think there are few characters which is making a sequence of ""\0"" due to which it prints the string upto that character only. </p>

<p>I tried to encode the data with <code>NSUTF8StringEncoding</code> but it returns me (null).</p>

<p>I want to send the complete string to the server, what to do now? </p>
","<p>This will not work since encrypted string is binary data. Convert it to Base64, if you need to use textual representation.</p>

<p>Here is described convertion of NSData to NSString : <a href=""https://stackoverflow.com/questions/2197362/converting-nsdata-to-base64"">Converting NSData to base64</a></p>
","659","<objective-c><ios><encryption><nsdata><3des>","1","3","1","2012-12-04 13:43:18","13704330","0","1","","","","2012-12-04 13:29:50",""
"44049066","tripleDES encryption in Swift 3","<p>Can anyone please help me with tutorials or sample code for TripleDES decryption in Swift. I receiving a web service response data as 3DES encrypted and I need to decrypt via my app and show the data in app</p>

<p>I am using this code snippet, but it doesn't work for me: </p>

<pre><code>func myDecrypt(decryptData : NSData) -&gt; NSData?{\
    let mydata_len : Int = decryptData.length
    let keyData : NSData = (helperObject.decryptionKey as NSString).data(using: String.Encoding.utf8.rawValue)! as NSData

    let buffer_size : size_t = mydata_len+kCCBlockSizeAES128
    let buffer = UnsafeMutablePointer&lt;NSData&gt;.allocate(capacity: buffer_size)
    var num_bytes_encrypted : size_t = 0

    var _ : [UInt8] = [56, 101, 63, 23, 96, 182, 209, 205]  // I didn't use

    let operation: CCOperation = UInt32(kCCDecrypt)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
    let options:   CCOptions   = UInt32(kCCOptionECBMode + kCCOptionPKCS7Padding)
    let keyLength        = size_t(kCCKeySize3DES)

    let decrypt_status : CCCryptorStatus = CCCrypt(operation, algoritm, options, keyData.bytes, keyLength, nil, decryptData.bytes, mydata_len, buffer, buffer_size, &amp;num_bytes_encrypted)

    if UInt32(decrypt_status) == UInt32(kCCSuccess){\
        let myResult : NSData = NSData(bytes: buffer, length: num_bytes_encrypted)
        free(buffer)
        print(""decrypt \(myResult)"")

        let stringResult = NSString(data: myResult as Data, encoding:String.Encoding.utf8.rawValue)
        print(stringResult ?? ""No string decription"")
        return myResult
    }else{
        free(buffer)
        return nil\
    }
}
</code></pre>
","","653","<swift><3des><tripledes>","0","","0","2017-05-18 14:57:54","","2","","4370109","","2017-05-18 14:57:54","2017-05-18 13:26:08",""
"19803505","Is 3DES = DES do 3 times?","<p>I have done a DES Util class according to <a href=""http://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow"">mkyong's JCE Encryption – Data Encryption Standard (DES) Tutorial</a></p>

<p>Here's my class:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import tw.com.januarytc.android.singularsdk.lib.JsLib;
import android.util.Log;

public class DESUtil
{
  private KeyGenerator keyGen=null;
  private SecretKey sKey=null;
  private Cipher desCip=null;

  /**
   * Init. DES utility class
   * @return boolean
   */
  public boolean init()
  {
    boolean b=false;

    try
    {
      keyGen=KeyGenerator.getInstance(""DES"");
      sKey=keyGen.generateKey();
      desCip=Cipher.getInstance(""DES/ECB/PKCS5Padding"");
      b=true;
    }
    catch(Exception e)
    {
      Log.d(JsLib.TAG, ""Init DESUtil failed: ""+e.toString());
      e.printStackTrace();
      b=false;
    }
    return b;
  }

  /**
   * Encrypt string with DES
   * @param str - Original string
   * @return java.lang.String DES encrypted string
   * @throws IllegalStateException
   */
  public String encryptString(String str) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.ENCRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(str.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }

  /**
   * Decrypt string which encrypted by DES
   * @param str - DES encrypted string
   * @return java.lang.String Original string
   * @throws IllegalStateException
   */
  public String decryptString(String strDes) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.DECRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(strDes.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }
}
</code></pre>

<p>And as WiKi said:</p>

<p>In cryptography, Triple DES is the common name for the Triple Data Encryption Algorithm (TDEA or Triple DEA) block cipher, which <strong>applies the Data Encryption Standard (DES) cipher algorithm three times to each data block</strong>.</p>

<p>I'm just wondering what if I encrypt a string with DES for 3 times...Will it equals 3DES ?</p>

<p>Thanks for suggestions, and sorry for my poor english~</p>
","<p><code>3DES</code> does perform <code>DES</code> 3 times, but with three different keys. This algorithm was designed to get around DES's inherent lack of security associated with the original key size.</p>
","649","<java><android><des><3des>","1","3","2","2013-11-06 03:35:40","19803613","0","3","","","","2013-11-06 03:21:55",""
"19803505","Is 3DES = DES do 3 times?","<p>I have done a DES Util class according to <a href=""http://www.mkyong.com/java/jce-encryption-data-encryption-standard-des-tutorial/"" rel=""nofollow"">mkyong's JCE Encryption – Data Encryption Standard (DES) Tutorial</a></p>

<p>Here's my class:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

import tw.com.januarytc.android.singularsdk.lib.JsLib;
import android.util.Log;

public class DESUtil
{
  private KeyGenerator keyGen=null;
  private SecretKey sKey=null;
  private Cipher desCip=null;

  /**
   * Init. DES utility class
   * @return boolean
   */
  public boolean init()
  {
    boolean b=false;

    try
    {
      keyGen=KeyGenerator.getInstance(""DES"");
      sKey=keyGen.generateKey();
      desCip=Cipher.getInstance(""DES/ECB/PKCS5Padding"");
      b=true;
    }
    catch(Exception e)
    {
      Log.d(JsLib.TAG, ""Init DESUtil failed: ""+e.toString());
      e.printStackTrace();
      b=false;
    }
    return b;
  }

  /**
   * Encrypt string with DES
   * @param str - Original string
   * @return java.lang.String DES encrypted string
   * @throws IllegalStateException
   */
  public String encryptString(String str) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.ENCRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(str.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }

  /**
   * Decrypt string which encrypted by DES
   * @param str - DES encrypted string
   * @return java.lang.String Original string
   * @throws IllegalStateException
   */
  public String decryptString(String strDes) throws IllegalStateException
  {
    if(keyGen==null || sKey==null || desCip==null){throw new IllegalStateException(""DESUtil class has not been initialized."");}
    String ret="""";
    try
    {
      desCip.init(Cipher.DECRYPT_MODE, sKey);
      ret=new String(desCip.doFinal(strDes.getBytes(""UTF-8"")));
    }
    catch(Exception e)
    {
      e.printStackTrace();
      ret="""";
    }
    return ret;
  }
}
</code></pre>

<p>And as WiKi said:</p>

<p>In cryptography, Triple DES is the common name for the Triple Data Encryption Algorithm (TDEA or Triple DEA) block cipher, which <strong>applies the Data Encryption Standard (DES) cipher algorithm three times to each data block</strong>.</p>

<p>I'm just wondering what if I encrypt a string with DES for 3 times...Will it equals 3DES ?</p>

<p>Thanks for suggestions, and sorry for my poor english~</p>
","<p>DES uses a short 56 bit key, which was vulnerable to brute force attacks. 3DES uses 168 bit keys (56x3), and performs the encryption like so:</p>

<ol>
<li>Encrypt clear text using the 1st 56 bits of the key, produce output1</li>
<li><strong>Decrypt</strong> output1 using the 2nd 56 bits of the key, produce output2</li>
<li>Encrypt output2 using the 3rd 56 bits of they, produce encrypted text.</li>
</ol>

<p>Her's a reference:
<a href=""http://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow"">http://en.wikipedia.org/wiki/Triple_DES</a></p>
","649","<java><android><des><3des>","1","4","2","2013-11-06 03:35:40","19803613","0","3","","","","2013-11-06 03:21:55",""
"41001376","Triple des decryption function not working","<p>So i've been working at this function and i'm not sure what's wrong.</p>

<p>I get encrypted data and key:</p>

<pre><code>$key = 'aaaaaaaabbbbbbbbccccccccdddddddd';
$data = 'b5057bbc04b842a96144a0f617f2820e';
</code></pre>

<p>I've gone and converted them into binary:</p>

<pre><code>$key = pack('H*',$key);
$data = pack('H*',$data);
</code></pre>

<p>And ran the decryption function:</p>

<pre><code>echo bin2hex(mcrypt_decrypt(Mcrypt_3des, $key, $data, MCRYPT_MODE_ECB));
</code></pre>

<p>However what I get returned is this : <code>e2119b734b5050e3fa8717ee17f3a548</code></p>

<p>But if I run the same decryption on <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a>
or <a href=""http://www.emvlab.org/descalc/?key=aaaaaaaabbbbbbbbccccccccdddddddd&amp;iv=0000000000000000&amp;input=b5057bbc04b842a96144a0f617f2820e&amp;mode=ecb&amp;action=Decrypt&amp;output=54657374313233313233000000000000"" rel=""nofollow noreferrer"">http://www.emvlab.org/descalc/?key=aaaaaaaabbbbbbbbccccccccdddddddd&amp;iv=0000000000000000&amp;input=b5057bbc04b842a96144a0f617f2820e&amp;mode=ecb&amp;action=Decrypt&amp;output=54657374313233313233000000000000</a></p>

<p>It actually decrpyts to <code>54 65 73 74 31 32 33 31 32 33 00 00 00 00 00 00</code></p>

<p>which is actually <code>Test123123</code></p>

<p>Any suggestions of what could be the problem?</p>

<p><strong>EDIT:</strong></p>

<p>I have tried switching to <code>openssl_decrypt</code></p>

<p>However I keep getting a false returned.</p>

<p>Code:</p>

<pre><code>$result = openssl_decrypt($data,'des-ede3', $key);
result = bool(false)
</code></pre>
","<p>I was able to get it working using open SSLs decryption function:</p>

<pre><code>$key = 'aaaaaaaabbbbbbbbccccccccdddddddd';
$key = pack('H*',$key);

// DATA
$data = 'b5057bbc04b842a96144a0f617f2820e';
$data = pack('H'.strlen($key),$data);

// DECRYPT OPEN SSL
$result = openssl_decrypt($data,'des-ede', $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING);
</code></pre>
","644","<php><encryption><mcrypt><3des><php-openssl>","1","0","1","2019-02-02 15:04:50","42956430","12","0","608639","","2016-12-07 13:39:21","2016-12-06 17:30:27",""
"6479452","ToadStudio passwords in settings file, security concern","<p>I need to share a connections setting file for ToadStudio SQLeditor.</p>

<p>I do have some concerns about the passwords that are stored in the settings file.</p>

<p>The file currently looks like this:</p>

<pre><code>&lt;ToadStudio&gt;
  &lt;FileVersion Encryption=""3Des""&gt;3&lt;/FileVersion&gt;
  &lt;ConnectionHierarchy&gt;
    &lt;DbPlatform name=""MySQL""&gt;
      &lt;Path /&gt;
      &lt;Connections&gt;
        &lt;Connection type=""MySQL"" autoCommit=""True""&gt;
          &lt;Path&gt;MySQL&lt;/Path&gt;
          &lt;AutoConnect&gt;False&lt;/AutoConnect&gt;
          &lt;Database&gt;db&lt;/Database&gt;
          &lt;Host&gt;localhost&lt;/Host&gt;
          &lt;User&gt;dbuser&lt;/User&gt;
          &lt;Password&gt;EF9ED08748C745FC&lt;/Password&gt;
          &lt;WinAuth&gt;False&lt;/WinAuth&gt;
          &lt;LastConnectionDate&gt;0001-01-01T00:00:00.0000000&lt;/LastConnectionDate&gt;
          &lt;Options&gt;
            &lt;Protocol type=""SSH"" /&gt;
            &lt;SSH host=""127.0.0.1"" user=""sshuser"" password=""744F3C66F88E084B"" /&gt;
          &lt;/Options&gt;
        &lt;/Connection&gt;
      &lt;/Connections&gt;
      &lt;Groups /&gt;
    &lt;/DbPlatform&gt;
  &lt;/ConnectionHierarchy&gt;
&lt;/ToadStudio&gt;
</code></pre>

<p>It's meant to connect to a database via SSH tunnel.</p>

<p>So, the concern is the way that passwords are stored in this file.
Looking at the first lines in the file, I assume that the passwords are being encrypted with triple DES.</p>

<p>In the above sample, the passwords are equal to the usernames (dbuser,sshuser)</p>

<p>Since I can share this file, any other instance of TOADStudio can decrypt it to the original plain text, so I can only guess that toadStudio uses a hard coded seed for encrypting stuff.</p>

<p>I'm not running state secrets in my server, but I'd like a bit of reassurance that it will not be trivially easy for someone to obtain the password plaintext based on these setting files.</p>

<p>Any insight would be appreciated.</p>
","<p>That does look like 3DES to me, which is honestly more security than your average app uses - look into how VNC stores its passwords some day, very scary.</p>

<p>In any case, it definitely sounds like you're on the right track. Have you actually tested that sharing this file allows other TOAD users to connect using your stored info? If so then it probably would be fairly easy (though not trivially so) for someone to get at those passwords. That said, 3DES isn't really adequate these days and is fairly breakable, but if someone has sufficient access to your machine to steal that file, they could just as easily keylog you, install backdoors or all kinds of other things. From a security standpoint, if the attacker has sufficient access to get at that file, it's probably game over anyway.</p>
","624","<sql><password-protection><toad><3des>","1","0","1","2011-08-20 18:21:02","7133723","0","","","","","2011-06-25 17:38:17",""
"25058903","3DES decryption in Objective C produces different result comparing to java","<p>I have to decrypt a string in Objective C. The encryption scheme is DES/ECB/NoPadding and I am providing this Java code with correct output with following input
data = 741DCDDF1C216EEF and key = D9C44F6D2589255E and output should be 34160D6EADAD6D86</p>

<pre><code>public static String decrypt3DES(String Key, String data) throws Exception
{
    Cipher cipher = null;
    byte[] text = null;
    byte[] desKey = null;
    Key keySpec = null;
    try {

        if (Key.length() &lt;= 16) {
            cipher = Cipher.getInstance(""DES/ECB/NoPadding"");
            desKey = byteConvertor(Key);
            keySpec = new SecretKeySpec(desKey, ""DES"");
        } else if (Key.length() &gt;= 32) {
            cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
            desKey = byteConvertor(Key);
            keySpec = new SecretKeySpec(desKey, ""DESede"");
        }
        cipher.init(Cipher.DECRYPT_MODE, keySpec);

        text = cipher.doFinal(byteConvertor(data));

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    }

    return alpha2Hex(byteArr2String(text));
}
</code></pre>

<p>Objective C code :</p>

<pre><code>NSString *token = @""741DCDDF1C216EEF"";

NSString *key = @""D9C44F6D2589255E"";

const void *vplainText;

size_t plainTextBufferSize;

NSData *EncryptData = [[NSData alloc] initWithBase64EncodedString:token options:0];
plainTextBufferSize = [EncryptData length]+1;
vplainText = [EncryptData bytes];

//plainTextBufferSize = [token length];
//vplainText = (const void *)[token UTF8String];

CCCryptorStatus ccStatus;
uint8_t *bufferPtr = NULL;
size_t bufferPtrSize = 0;
size_t movedBytes;

bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
memset((void *)bufferPtr, 0x0, bufferPtrSize);

NSString *initVec = @""init Vec"";
const void *vkey = (const void *)[key UTF8String];
const void *vinitVec;
vinitVec = (const void *) [initVec UTF8String];

//uint8_t initVect[8];
//bzero(initVect, 8);

ccStatus = CCCrypt(kCCDecrypt,
                   kCCAlgorithmDES,
                   kCCOptionECBMode|0x0000,
                   vkey, //""123456789012345678901234"", //key
                   kCCKeySizeDES,
                   NULL,// vinitVec, //""init Vec"", //iv,
                   vplainText, //""Your Name"", //plainText,
                   plainTextBufferSize,
                   (void *)bufferPtr,
                   bufferPtrSize,
                   &amp;movedBytes);

NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
NSString *decodedString = [[NSString alloc] initWithData:myData encoding:NSUTF8StringEncoding];
NSLog(@""dis is data %@"",decodedString);
</code></pre>

<p>i am getting correct output in java and not in objective c.please provide solution for objective c code</p>
","","618","<java><ios><objective-c><encryption><3des>","0","","0","2014-10-20 05:23:34","","3","2","","","","2014-07-31 12:30:32",""
"18628940","Image Encryption using 3DES","<p>I am doing encryption and decryption of an image using 3DES. After encrypting an image I am not able to see an encrypted image. Can any one please tell me why is this happening? I am using a jpeg image to encrypt. All this process has been done in Java.</p>
","<p>After performing the Triple DES encryption the image is no longer readable as a JPG file until it has been decrypted. That’s generally the purpose of encryption to allow you to transfer that image and ensure it will be safe until it is read the intended recipient who has the private keys</p>
","611","<encryption><3des>","4","1","1","2013-09-05 08:05:58","","5","2","","user2194175","2013-09-05 08:05:58","2013-09-05 06:10:42",""
"33799494","3DES encrypt result in PHP, JAVA and .NET produces different result from 3DES iOS","<p>I'm trying to upgrade my current app in iOS 8, to adapt to the new encryption SHA256 of Redsys / Sermpa.</p>

<p>But I have problems in data encryption. In PHP, Java and .NET I get a result, completely different from iOS.</p>

<p>I think the problem must be in the 3DES IOS CCCrypt.</p>

<p>The PHP, JAVA and .NET code is a library, I can not alter that library.</p>

<p>I have to make the result of encryption in iOS, is identical to right result encrypt in PHP, JAVA and .NET.</p>

<p><strong>Library Java Code:</strong></p>

<pre><code>    String secretCodeString = ""Mk9m98IfEblmPfrpsawt7BmxObt98Jev"";
    String Ds_Merchant_Order = ""1442772645"";
    String Ds_MerchantParameters = ""eyJEU19NRVJDSEFOVF9BTU9VTlQiOiIxNDUiLCJEU19NRVJDSEFOVF9PUkRFUiI6IjE0NDI3NzI2NDUiLCJEU19NRVJDSEFOVF9NRVJDSEFOVENPREUiOiI5OTkwMDg4ODEiLCJEU19NRVJDSEFOVF9DVVJSRU5DWSI6Ijk3OCIsIkRTX01FUkNIQU5UX1RSQU5TQUNUSU9OVFlQRSI6IjAiLCJEU19NRVJDSEFOVF9URVJNSU5BTCI6Ijg3MSIsIkRTX01FUkNIQU5UX01FUkNIQU5UVVJMIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX05vdGlmLnBocCIsIkRTX01FUkNIQU5UX1VSTE9LIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCIsIkRTX01FUkNIQU5UX1VSTEtPIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCJ9"";

    byte [] secretCode = decodeB64(secretCodeString.getBytes(""UTF-8""));
    String secretKc = toHexadecimal(secretCode, secretCode.length);
    byte [] Ds_Merchant_Order_encrypt3DES = encrypt_3DES(secretKc, Ds_Merchant_Order);
    byte [] hash = mac256(Ds_MerchantParameters, Ds_Merchant_Order_encrypt3DES);
    byte [] res = encodeB64UrlSafe(hash);
    String Ds_Signature = new String(res, ""UTF-8"");
    //Ds_Signature: hueCwD/cbvrCi+9IDY86WteMpXulIl0IDNXNlYgcZHM=


public byte [] encrypt_3DES(final String claveHex, final String datos) {
        byte [] ciphertext = null;
        try {
            DESedeKeySpec desKeySpec = new DESedeKeySpec(toByteArray(claveHex));
            SecretKey desKey = new SecretKeySpec(desKeySpec.getKey(), ""DESede"");
            Cipher desCipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
            byte [] IV = {0, 0, 0, 0, 0, 0, 0, 0};

            desCipher.init(Cipher.ENCRYPT_MODE, desKey, new IvParameterSpec(IV));

            int numeroCerosNecesarios = 8 - (datos.length() % 8);
            if (numeroCerosNecesarios == 8) {
                numeroCerosNecesarios = 0;
            }
            ByteArrayOutputStream array = new ByteArrayOutputStream();
            array.write(datos.getBytes(""UTF-8""), 0, datos.length());
            for (int i = 0; i &lt; numeroCerosNecesarios; i++) {
                array.write(0);
            }
            byte [] cleartext = array.toByteArray();

            ciphertext = desCipher.doFinal(cleartext);
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
        return ciphertext;
    }
</code></pre>

<p><strong>Library PHP Code:</strong></p>

<pre><code>    $Ds_Merchant_Order = ""1442772645"";
    $Ds_MerchantParameters = ""eyJEU19NRVJDSEFOVF9BTU9VTlQiOiIxNDUiLCJEU19NRVJDSEFOVF9PUkRFUiI6IjE0NDI3NzI2NDUiLCJEU19NRVJDSEFOVF9NRVJDSEFOVENPREUiOiI5OTkwMDg4ODEiLCJEU19NRVJDSEFOVF9DVVJSRU5DWSI6Ijk3OCIsIkRTX01FUkNIQU5UX1RSQU5TQUNUSU9OVFlQRSI6IjAiLCJEU19NRVJDSEFOVF9URVJNSU5BTCI6Ijg3MSIsIkRTX01FUkNIQU5UX01FUkNIQU5UVVJMIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX05vdGlmLnBocCIsIkRTX01FUkNIQU5UX1VSTE9LIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCIsIkRTX01FUkNIQU5UX1VSTEtPIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCJ9"";
    $secretCode = ""Mk9m98IfEblmPfrpsawt7BmxObt98Jev"";

    $secretCode = base64_decode($secretCode);
    $bytes = array(0,0,0,0,0,0,0,0);
    $iv = implode(array_map(""chr"", $bytes)); //PHP 4 &gt;= 4.0.2
    $Ds_Merchant_Order_encrypt3DES = mcrypt_encrypt(MCRYPT_3DES, $secretCode, $Ds_Merchant_Order, MCRYPT_MODE_CBC, $iv);
    $hash = hash_hmac('sha256', $Ds_MerchantParameters, $Ds_Merchant_Order_encrypt3DES, true);
    $Ds_Signature = $this-&gt;encodeBase64($hash);
    //Ds_Signature: hueCwD/cbvrCi+9IDY86WteMpXulIl0IDNXNlYgcZHM=
</code></pre>

<p><strong>Library .NET Code:</strong></p>

<pre><code>byte[] secretCode = Base64Decode(""Mk9m98IfEblmPfrpsawt7BmxObt98Jev"");

    string Ds_MerchantParameters = ""eyJEU19NRVJDSEFOVF9BTU9VTlQiOiIxNDUiLCJEU19NRVJDSEFOVF9PUkRFUiI6IjE0NDI3NzI2NDUiLCJEU19NRVJDSEFOVF9NRVJDSEFOVENPREUiOiI5OTkwMDg4ODEiLCJEU19NRVJDSEFOVF9DVVJSRU5DWSI6Ijk3OCIsIkRTX01FUkNIQU5UX1RSQU5TQUNUSU9OVFlQRSI6IjAiLCJEU19NRVJDSEFOVF9URVJNSU5BTCI6Ijg3MSIsIkRTX01FUkNIQU5UX01FUkNIQU5UVVJMIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX05vdGlmLnBocCIsIkRTX01FUkNIQU5UX1VSTE9LIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCIsIkRTX01FUkNIQU5UX1VSTEtPIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCJ9""
    string Ds_Merchant_Order = ""1442772645"";

    // Calculate derivated key by encrypting with 3DES the ""DS_MERCHANT_ORDER"" with decoded key 
    byte[] Ds_Merchant_Order_encrypt3DES = cryp.Encrypt3DES(Ds_Merchant_Order, secretCode);

    // Calculate HMAC SHA256 with Encoded base64 JSON string using derivated key calculated previously
    byte[] hash = cryp.GetHMACSHA256(Ds_MerchantParameters, Ds_Merchant_Order_encrypt3DES);

    // Encode byte[] res to Base64 String
    string Ds_Signature = Base64Encode2(hash);
    //Ds_Signature: hueCwD/cbvrCi+9IDY86WteMpXulIl0IDNXNlYgcZHM=

    public byte[] Encrypt3DES(string plainText, byte[] key)  {
            byte[] toEncryptArray = Encoding.UTF8.GetBytes(plainText);
            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

            try  {
                /// SALT used in 3DES encryptation process.
                byte[] SALT = new byte[8] {0,0,0,0,0,0,0,0};

                // Block size 64 bit (8 bytes)
                tdes.BlockSize = 64;

                // Key Size 192 bit (24 bytes)
                tdes.KeySize = 192;
                tdes.Mode = CipherMode.CBC;
                tdes.Padding = PaddingMode.Zeros;

                tdes.IV = SALT; 
                tdes.Key = key;  

                var cTransform = tdes.CreateEncryptor();

                //transform the specified region of bytes array to resultArray
                byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

                //Release resources held by TripleDes Encryptor
                tdes.Clear();

                return resultArray;

            } // Error in Cryptographic method
            catch (CryptographicException ex) {
                throw new CryptographicException(ex.Message);
            }
        }
</code></pre>

<p>**********************------------**********************------------**********************</p>

<p><strong>My Objective-C Code:</strong></p>

<pre><code>NSString *Ds_Merchant_Order = @""1442772645"";
NSString *Ds_MerchantParameters = @""eyJEU19NRVJDSEFOVF9BTU9VTlQiOiIxNDUiLCJEU19NRVJDSEFOVF9PUkRFUiI6IjE0NDI3NzI2NDUiLCJEU19NRVJDSEFOVF9NRVJDSEFOVENPREUiOiI5OTkwMDg4ODEiLCJEU19NRVJDSEFOVF9DVVJSRU5DWSI6Ijk3OCIsIkRTX01FUkNIQU5UX1RSQU5TQUNUSU9OVFlQRSI6IjAiLCJEU19NRVJDSEFOVF9URVJNSU5BTCI6Ijg3MSIsIkRTX01FUkNIQU5UX01FUkNIQU5UVVJMIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX05vdGlmLnBocCIsIkRTX01FUkNIQU5UX1VSTE9LIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCIsIkRTX01FUkNIQU5UX1VSTEtPIjoiaHR0cHM6XC9cL2VqZW1wbG9cL2VqZW1wbG9fVVJMX09LX0tPLnBocCJ9"";

NSString *clave = @""Mk9m98IfEblmPfrpsawt7BmxObt98Jev"";
NSData *decodedData = [[NSData alloc] initWithBase64EncodedString:clave options:0];
NSString *secretCode = [self hexadecimalString:decodedData];

NSData *Ds_Merchant_Order_encrypt3DES = [self encrypt3DES:Ds_Merchant_Order key:secretCode];

NSData *hash = [self hmac256ForKeyAndData:Ds_MerchantParameters withKey:Ds_Merchant_Order_encrypt3DES];

NSString *Ds_Signature = [hash base64EncodedStringWithOptions:0];
//Ds_Signature:  kUVwanKNIlrvw3t56HUAYXSBmE/u6ruTj1r/FGOIiUg=
</code></pre>

<p><strong>My Functions:</strong></p>

<pre><code>- (NSString *)hexadecimalString:(NSData*)data{
    const unsigned char *dataBuffer = (const unsigned char *)[data bytes];
    if (!dataBuffer){
        return [NSString string];
    }
    NSUInteger          dataLength  = [data length];
    NSMutableString     *hexString  = [NSMutableString stringWithCapacity:(dataLength * 2)];
    for (int i = 0; i &lt; dataLength; ++i){
        [hexString appendFormat:@""%02x"", (unsigned int)dataBuffer[i]];
    }
    return [NSString stringWithString:hexString];
}


- (NSData*)encrypt3DES:(NSString*)data key:(NSString*)key{
    NSData *plainData = [data dataUsingEncoding:NSUTF8StringEncoding];
    const void *vplainText = (const void *)[plainData bytes];
    size_t plainTextBufferSize = [plainData length];
    size_t movedBytes = 0;
    size_t bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    uint8_t * bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    NSString *initVec = @""\0\0\0\0\0\0\0\0"";
    const void *vkey = (const void *) [key UTF8String];
    const void *vinitVec = (const void *) [initVec UTF8String];

    CCCryptorStatus ccStatus = CCCrypt(kCCEncrypt,
                                       kCCAlgorithm3DES,
                                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                                       vkey,
                                       kCCKeySize3DES,
                                       vinitVec,
                                       vplainText,
                                       plainTextBufferSize,
                                       (void *)bufferPtr,
                                       bufferPtrSize,
                                       &amp;movedBytes);
    if (ccStatus == kCCSuccess) NSLog(@""SUCCESS"");
    else if (ccStatus == kCCParamError) NSLog( @""PARAM ERROR"");
    else if (ccStatus == kCCBufferTooSmall) NSLog( @""BUFFER TOO SMALL"");
    else if (ccStatus == kCCMemoryFailure) NSLog( @""MEMORY FAILURE"");
    else if (ccStatus == kCCAlignmentError) NSLog( @""ALIGNMENT"");
    else if (ccStatus == kCCDecodeError) NSLog( @""DECODE ERROR"");
    else if (ccStatus == kCCUnimplemented) NSLog( @""UNIMPLEMENTED"");

    return [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
}


-(NSData *)hmac256ForKeyAndData:(NSString *)data withKey:(NSData *)keyData{
    NSData *dataData=[data dataUsingEncoding:NSUTF8StringEncoding];
    NSMutableData* hash = [NSMutableData dataWithLength:CC_SHA256_DIGEST_LENGTH];
    CCHmac(kCCHmacAlgSHA256, keyData.bytes, keyData.length, dataData.bytes, dataData.length, hash.mutableBytes);
    return hash;
}
</code></pre>

<p>P.S.: Keys and passwords are fake, are just for testing. ;)</p>
","<p>There are a couple of errors:</p>

<p>First: the PHP version uses CBC mode and the iOS version uses ECB mode. The default for <code>CCCrypt</code> is CBC mode, just remove <code>kCCOptionECBMode</code>. Using a null iv will make the first block insecure, generally a random iv is used and prepended to the encrypted data.</p>

<p>Second: mcrypt does not support PKCS#7 padding, it only supports non-standard insecure null padding. Therefore it is necessary to add the padding to the data prior to encryption.</p>

<p>From this <a href=""https://stackoverflow.com/a/32139481/451475"">SO Answer</a>:</p>

<p>Add PKCS#7 padding (php):<br>
where <code>$block</code> is the block size in bytes and <code>$str</code> is the data to be encrypted</p>

<pre><code> $pad = $block - (strlen($str) % $block);
 $str .= str_repeat(chr($pad), $pad);
</code></pre>

<p>Remove PKCS#7 padding (php):<br>
where <code>$str</code> is the decrypted data</p>

<pre><code>$len = strlen($str);
$pad = ord($str[$len-1]);
$str = $strsubstr($str, 0, $len - $pad);
</code></pre>

<p>Note: if the data is exactly a multiple of the block size an entire block of padding will be added, this is necessary.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS#7</a> for more information on padding.</p>

<p>For further debugging provide the hex dumps of all parameters and data in and out of the encryption: secretCode, Ds_Merchant_Order, iv and encrypted output.</p>

<p>Finally: For better security consider using <a href=""https://github.com/RNCryptor/RNCryptor"" rel=""nofollow noreferrer"">RNCryptor</a> which is available for several platforms and languages. It is well vetted, supports the current best practices and is currently supported.</p>
","601","<php><ios><encryption><3des>","-1","0","1","2016-04-05 14:30:09","33805290","0","2","1498035","","2015-11-19 19:29:09","2015-11-19 09:12:14",""
"23809868","Trying to port old encryption algorithm to C#","<p>I'll start by saying that the following link helped me greatly:</p>

<p><a href=""https://stackoverflow.com/questions/6253363/translating-win32-crypto-api-calls-to-c-sharp-with-system-security-cryptography/6255758#6255758"">Translating Win32 Crypto API calls to C# with System.Security.Cryptography</a></p>

<p>I'm having the same problem he's having, except his fix didn't fix my code.</p>

<p>Here's my old (vb6) code:</p>

<pre><code>Private Const ALG_CLASS_DATA_ENCRYPT = 24576&amp;
Private Const ALG_CLASS_HASH = 32768
Private Const ALG_SID_3DES = 3&amp;
Private Const ALG_SID_SHA1 = 4&amp;
Private Const ALG_TYPE_ANY = 0&amp;
Private Const ALG_TYPE_BLOCK = 1536&amp;
Private Const CALG_3DES = (ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_BLOCK Or ALG_SID_3DES)
Private Const CALG_SHA1 = (ALG_CLASS_HASH Or ALG_TYPE_ANY Or ALG_SID_SHA1)
Private Const CRYPT_SILENT = &amp;H40&amp;
Private Const CRYPT_VERIFYCONTEXT = &amp;HF0000000
Private Const MS_ENHANCED_PROV = ""Microsoft Enhanced Cryptographic Provider v1.0""
Private Const PROV_RSA_FULL = 1&amp;

Private Declare Function CryptAcquireContextApi Lib ""advapi32.dll"" Alias ""CryptAcquireContextA"" (ByRef phProv As Long, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptCreateHashApi Lib ""advapi32.dll"" Alias ""CryptCreateHash"" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, ByRef phHash As Long) As Long
Private Declare Function CryptDecryptApi Lib ""advapi32.dll"" Alias ""CryptDecrypt"" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long) As Long
Private Declare Function CryptDeriveKeyApi Lib ""advapi32.dll"" Alias ""CryptDeriveKey"" (ByVal hProv As Long, ByVal Algid As Long, ByVal hBaseData As Long, ByVal dwFlags As Long, ByRef phKey As Long) As Long
Private Declare Function CryptDestroyHashApi Lib ""advapi32.dll"" Alias ""CryptDestroyHash"" (ByVal hHash As Long) As Long
Private Declare Function CryptDestroyKeyApi Lib ""advapi32.dll"" Alias ""CryptDestroyKey"" (ByVal hKey As Long) As Long
Private Declare Function CryptEncryptApi Lib ""advapi32.dll"" Alias ""CryptEncrypt"" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long, ByVal dwBufLen As Long) As Long
Private Declare Function CryptGetHashParamApi Lib ""advapi32.dll"" Alias ""CryptGetHashParam"" (ByVal hHash As Long, ByVal dwParam As Long, pbData As Any, pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptHashDataApi Lib ""advapi32.dll"" Alias ""CryptHashData"" (ByVal hHash As Long, ByRef pbData As Byte, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContextApi Lib ""advapi32.dll"" Alias ""CryptReleaseContext"" (ByVal hProv As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetKeyParamApi Lib ""advapi32.dll"" Alias ""CryptGetKeyParam"" (ByVal hKey As Long, ByVal dwParam As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long, dwFlags As Long) As Long

Private Declare Sub CopyMemoryApi Lib ""kernel32"" Alias ""RtlMoveMemory"" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)

Function Encrypt(message As String, Password As String) As String

   If CryptAcquireContextApi(provider, vbNullString, ProviderName, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) = 0 Then
      Goto Encrypt_Failure
   End-If
   If CryptCreateHashApi(provider, CALG_SHA1, 0&amp;, 0&amp;, hash) = 0 Then
      Goto Encrypt_Failure
   End-If

   buffer = StrConv(Password, vbFromUnicode)
   If CryptHashDataApi(hash, buffer(0), CLng(UBound(buffer) + 1), 0&amp;) = 0 Then
      GoTo Encrypt_Failure
   End If

   If CryptDeriveKeyApi(provider, CALG_3DES, hash, 1&amp;, key) = 0 Then
      key = 0
      GoTo Encrypt_Failure
   End If

   length = Len(message)
   bfrlen = length
   If CryptEncryptApi(key, 0&amp;, 1&amp;, 0&amp;, ByVal 0&amp;, bfrlen, bfrlen) = 0 Then
      GoTo Encrypt_Failure
   End If

   ReDim buffer(bfrlen - 1)

   For i = 0 To length - 1
      buffer(i) = Asc(Mid(message, i + 1, 1))
   Next i

   If CryptEncryptApi(key, 0&amp;, 1&amp;, 0&amp;, buffer(0), length, bfrlen) = 0 Then
      GoTo Encrypt_Failure
   End If

   Call CryptDestroyKeyApi(key)
   Call CryptReleaseContextApi(provider, 0)

   Encrypt = left(StrConv(buffer, vbUnicode), length)

Encrypt_Failure:
   If key Then
      Call CryptDestroyKeyApi(key)
   End If
   If hash Then
      Call CryptDestroyHashApi(hash)
   End If
   If provider Then
      Call CryptReleaseContextApi(provider, 0)
   End If

Exit Function
</code></pre>

<p>Here's the new C# version:</p>

<pre><code>   public byte[] Encrypt(string source, string pass)
    {
        byte[] password = Encoding.UTF8.GetBytes(pass);
        byte[] resultArray = null;
        byte[] streamToEncrypt = Encoding.UTF8.GetBytes(source);

        if(streamToEncrypt.Length % 8 != 0)
        {
            byte[] inputArray = new byte[streamToEncrypt.Length + (8 - (streamToEncrypt.Length % 8))]; //add padding to the end to make the message groups of 8 bytes
            int i = 0;
            foreach (byte element in streamToEncrypt)
            {
                inputArray[i] = element;
                i++;
            }
            streamToEncrypt = inputArray;
        }


        using (TripleDESCryptoServiceProvider prov3des = new TripleDESCryptoServiceProvider())
        {

           prov3des.Mode = CipherMode.CBC;
           prov3des.Padding = PaddingMode.PKCS7;
           prov3des.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }; //8 bytes, zero-ed

            using (PasswordDeriveBytes pdb = new PasswordDeriveBytes(password, null)) //No salt needed here
            {
                prov3des.Key = pdb.CryptDeriveKey(""TripleDES"", ""SHA1"", 168, new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
            }

            ICryptoTransform cTransform = prov3des.CreateEncryptor();
            resultArray = cTransform.TransformFinalBlock(streamToEncrypt,0,streamToEncrypt.Length);

        }

        return resultArray;

    }
</code></pre>

<p>And, like the poster linked above, the hash of the password is the same, and the first 8 bytes of the encrypted byte array are the same.  I've got the initialization vector set to 8 bytes of zero, but I figure if the first 8 bytes of the encrypted data are the same, then the initialization vector must match.  I just can't figure out why the next 8 bytes differ.  Any ideas what I'm doing wrong here?</p>

<p>Thanks!</p>
","<p>If the first 8 bytes are the same and the rest are not, it sounds like you are using a different form of feedback than the original algorithm.  Try using different values of CipherMode and see if one of them gives you a match.</p>
","597","<c#><vb6-migration><encryption-symmetric><3des>","1","1","2","2014-05-22 17:07:34","23813160","2","","-1","","2017-05-23 10:32:23","2014-05-22 14:34:40",""
"23809868","Trying to port old encryption algorithm to C#","<p>I'll start by saying that the following link helped me greatly:</p>

<p><a href=""https://stackoverflow.com/questions/6253363/translating-win32-crypto-api-calls-to-c-sharp-with-system-security-cryptography/6255758#6255758"">Translating Win32 Crypto API calls to C# with System.Security.Cryptography</a></p>

<p>I'm having the same problem he's having, except his fix didn't fix my code.</p>

<p>Here's my old (vb6) code:</p>

<pre><code>Private Const ALG_CLASS_DATA_ENCRYPT = 24576&amp;
Private Const ALG_CLASS_HASH = 32768
Private Const ALG_SID_3DES = 3&amp;
Private Const ALG_SID_SHA1 = 4&amp;
Private Const ALG_TYPE_ANY = 0&amp;
Private Const ALG_TYPE_BLOCK = 1536&amp;
Private Const CALG_3DES = (ALG_CLASS_DATA_ENCRYPT Or ALG_TYPE_BLOCK Or ALG_SID_3DES)
Private Const CALG_SHA1 = (ALG_CLASS_HASH Or ALG_TYPE_ANY Or ALG_SID_SHA1)
Private Const CRYPT_SILENT = &amp;H40&amp;
Private Const CRYPT_VERIFYCONTEXT = &amp;HF0000000
Private Const MS_ENHANCED_PROV = ""Microsoft Enhanced Cryptographic Provider v1.0""
Private Const PROV_RSA_FULL = 1&amp;

Private Declare Function CryptAcquireContextApi Lib ""advapi32.dll"" Alias ""CryptAcquireContextA"" (ByRef phProv As Long, ByVal pszContainer As String, ByVal pszProvider As String, ByVal dwProvType As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptCreateHashApi Lib ""advapi32.dll"" Alias ""CryptCreateHash"" (ByVal hProv As Long, ByVal Algid As Long, ByVal hKey As Long, ByVal dwFlags As Long, ByRef phHash As Long) As Long
Private Declare Function CryptDecryptApi Lib ""advapi32.dll"" Alias ""CryptDecrypt"" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long) As Long
Private Declare Function CryptDeriveKeyApi Lib ""advapi32.dll"" Alias ""CryptDeriveKey"" (ByVal hProv As Long, ByVal Algid As Long, ByVal hBaseData As Long, ByVal dwFlags As Long, ByRef phKey As Long) As Long
Private Declare Function CryptDestroyHashApi Lib ""advapi32.dll"" Alias ""CryptDestroyHash"" (ByVal hHash As Long) As Long
Private Declare Function CryptDestroyKeyApi Lib ""advapi32.dll"" Alias ""CryptDestroyKey"" (ByVal hKey As Long) As Long
Private Declare Function CryptEncryptApi Lib ""advapi32.dll"" Alias ""CryptEncrypt"" (ByVal hKey As Long, ByVal hHash As Long, ByVal Final As Long, ByVal dwFlags As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long, ByVal dwBufLen As Long) As Long
Private Declare Function CryptGetHashParamApi Lib ""advapi32.dll"" Alias ""CryptGetHashParam"" (ByVal hHash As Long, ByVal dwParam As Long, pbData As Any, pdwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptHashDataApi Lib ""advapi32.dll"" Alias ""CryptHashData"" (ByVal hHash As Long, ByRef pbData As Byte, ByVal dwDataLen As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptReleaseContextApi Lib ""advapi32.dll"" Alias ""CryptReleaseContext"" (ByVal hProv As Long, ByVal dwFlags As Long) As Long
Private Declare Function CryptGetKeyParamApi Lib ""advapi32.dll"" Alias ""CryptGetKeyParam"" (ByVal hKey As Long, ByVal dwParam As Long, ByRef pbData As Byte, ByRef pdwDataLen As Long, dwFlags As Long) As Long

Private Declare Sub CopyMemoryApi Lib ""kernel32"" Alias ""RtlMoveMemory"" (pDst As Any, pSrc As Any, ByVal ByteLen As Long)

Function Encrypt(message As String, Password As String) As String

   If CryptAcquireContextApi(provider, vbNullString, ProviderName, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) = 0 Then
      Goto Encrypt_Failure
   End-If
   If CryptCreateHashApi(provider, CALG_SHA1, 0&amp;, 0&amp;, hash) = 0 Then
      Goto Encrypt_Failure
   End-If

   buffer = StrConv(Password, vbFromUnicode)
   If CryptHashDataApi(hash, buffer(0), CLng(UBound(buffer) + 1), 0&amp;) = 0 Then
      GoTo Encrypt_Failure
   End If

   If CryptDeriveKeyApi(provider, CALG_3DES, hash, 1&amp;, key) = 0 Then
      key = 0
      GoTo Encrypt_Failure
   End If

   length = Len(message)
   bfrlen = length
   If CryptEncryptApi(key, 0&amp;, 1&amp;, 0&amp;, ByVal 0&amp;, bfrlen, bfrlen) = 0 Then
      GoTo Encrypt_Failure
   End If

   ReDim buffer(bfrlen - 1)

   For i = 0 To length - 1
      buffer(i) = Asc(Mid(message, i + 1, 1))
   Next i

   If CryptEncryptApi(key, 0&amp;, 1&amp;, 0&amp;, buffer(0), length, bfrlen) = 0 Then
      GoTo Encrypt_Failure
   End If

   Call CryptDestroyKeyApi(key)
   Call CryptReleaseContextApi(provider, 0)

   Encrypt = left(StrConv(buffer, vbUnicode), length)

Encrypt_Failure:
   If key Then
      Call CryptDestroyKeyApi(key)
   End If
   If hash Then
      Call CryptDestroyHashApi(hash)
   End If
   If provider Then
      Call CryptReleaseContextApi(provider, 0)
   End If

Exit Function
</code></pre>

<p>Here's the new C# version:</p>

<pre><code>   public byte[] Encrypt(string source, string pass)
    {
        byte[] password = Encoding.UTF8.GetBytes(pass);
        byte[] resultArray = null;
        byte[] streamToEncrypt = Encoding.UTF8.GetBytes(source);

        if(streamToEncrypt.Length % 8 != 0)
        {
            byte[] inputArray = new byte[streamToEncrypt.Length + (8 - (streamToEncrypt.Length % 8))]; //add padding to the end to make the message groups of 8 bytes
            int i = 0;
            foreach (byte element in streamToEncrypt)
            {
                inputArray[i] = element;
                i++;
            }
            streamToEncrypt = inputArray;
        }


        using (TripleDESCryptoServiceProvider prov3des = new TripleDESCryptoServiceProvider())
        {

           prov3des.Mode = CipherMode.CBC;
           prov3des.Padding = PaddingMode.PKCS7;
           prov3des.IV = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 }; //8 bytes, zero-ed

            using (PasswordDeriveBytes pdb = new PasswordDeriveBytes(password, null)) //No salt needed here
            {
                prov3des.Key = pdb.CryptDeriveKey(""TripleDES"", ""SHA1"", 168, new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
            }

            ICryptoTransform cTransform = prov3des.CreateEncryptor();
            resultArray = cTransform.TransformFinalBlock(streamToEncrypt,0,streamToEncrypt.Length);

        }

        return resultArray;

    }
</code></pre>

<p>And, like the poster linked above, the hash of the password is the same, and the first 8 bytes of the encrypted byte array are the same.  I've got the initialization vector set to 8 bytes of zero, but I figure if the first 8 bytes of the encrypted data are the same, then the initialization vector must match.  I just can't figure out why the next 8 bytes differ.  Any ideas what I'm doing wrong here?</p>

<p>Thanks!</p>
","<p>There's actually a very simple solution, although it's not at all obvious.  You have a block of code which says ""If this data isn't exactly a multiple of 8, pad it.""  However, this is <em>changing</em> the value you're encrypting, so you get a different result.</p>

<p>Simply remove the whole <code>if(streamToEncrypt.Length.Dump(""Length"") % 8 != 0) {}</code> block and you'll get the expected result.</p>
","597","<c#><vb6-migration><encryption-symmetric><3des>","1","1","2","2014-05-22 17:07:34","23813160","2","","-1","","2017-05-23 10:32:23","2014-05-22 14:34:40",""
"34173619","Reverse 3(DES) key for decryption with encryption function","<p>Is it possible to derive reverse key for use as opposite function in 3DES algorithm. Idea is that the key that is used for encryption will be doing decryption and vice versa. </p>

<pre><code>encrypt(3des_key, data) == decrypt(3des_reverse_key,data)
decrypt(3des_key, data) == encrypt(3des_reverse_key,data)
</code></pre>

<p>Of course as 3DES is just 3 time DES function, the question is transparently generalised to DES algorithm so:</p>

<pre><code>encrypt(des_key, data) == decrypt(des_reverse_key,data)
decrypt(des_key, data) == encrypt(des_reverse_key,data)
</code></pre>

<p>If exists such a reverse key function that those two statements are true extending this function for use in 3des is just a simple displacement of key sectors. </p>
","","556","<encryption><3des>","0","","0","2015-12-09 08:03:46","","2","","","","","2015-12-09 08:03:46",""
"40704745","Triple DES encoding-java.security.InvalidKeyException: key size must be 128 or 192 bits","<p>I am using below code to implement Triple DES encoding with ECB and PKSC5 Padding.The secret key which i am using is stored in a file named key in raw folder.I am getting below exception-</p>

<pre><code>java.security.InvalidKeyException: key size must be 128 or 192 bits
</code></pre>

<p>Why am i getting this exception and where am i going wrong?</p>

<pre><code> public byte[] encrypt(String message) throws Exception {

        getResources().getIdentifier(""key"",
                ""raw"", getPackageName());
        byte[] bytes = new byte[1024];
        try {
            BufferedInputStream buf = new BufferedInputStream(getResources().openRawResource(
                    getResources().getIdentifier(""key"",
                            ""raw"", getPackageName())));
            buf.read(bytes, 0, bytes.length);
            buf.close();
        } catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        final SecretKey key = new SecretKeySpec(bytes, ""DESede/ECB/PKCS5Padding"");
        final Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE,key);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);

        return cipherText;
    }
</code></pre>
","<p>You passed an array of length 1024 as your key.  The key must be either length 16 (128 bits) or 24 (192 bits).  1024 is neither of those numbers.</p>

<p>If you're overallocating for your read, trim the array down to the proper size after reading.</p>
","539","<android><encryption><3des><ecb><pkcs#5>","-2","0","1","2016-11-21 19:47:44","","3","2","","","","2016-11-20 13:46:21",""
"13315301","3DES not producing consistent decryption for multiple iterations over same ciphertext","<p>I've implemented a 3DES (TripleDES) decryption routine in my code and have noticed that it never produces the same cleartext when the supplied ciphertext is the same as the previous iteration.  It seems non-deterministic and I'm sure it's something I'm doing wrong.  </p>

<p>I've tried CBC (with a zeroed-out IV), ECB, multiple combinations of disposing and clearing.  I cannot seem to get consistent output.</p>

<p>(for some reason the code formatting on the 'Code' and 'Output' below are not coming out right, sorry)</p>

<p>Code</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Threading;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string key = ""27F66D5244FF621EAA6F6120EDEB427F"";
                string cipher = ""C25C1D1197D31CAA87285D59A892047426D9182EC11353C051ADD6D0F072A6CB3436560B3071FC1FD11D9F7E74886742D9BEE0CFD1EA1064C213BB55278B2F12"";

                Console.WriteLine(""clear: "" + byte_array_to_hex_string(
                    decrypt_3des(
                        hex_string_to_byte_array(cipher),
                        hex_string_to_byte_array(key)
                    ), true, true
                    ));

                Console.WriteLine("""");
                Thread.Sleep(1000);
            }
        }

        static byte[] decrypt_3des(byte[] cipher, byte[] key)
        {
            if (cipher == null) return null;
            if (key == null) return null;
            int num_chunks = (cipher.Length) / 8;

            Console.WriteLine(""Entering decrypt_3des"");
            Console.WriteLine("" - cipher: "" + byte_array_to_hex_string(cipher, true, true));
            Console.WriteLine("" - key: "" + byte_array_to_hex_string(key, true, true));
            Console.WriteLine("" - cipher length: "" + cipher.Length);
            Console.WriteLine("" - key length: "" + key.Length);

            if ((cipher.Length % 8) != 0)
            {
                Console.WriteLine(""cipher length not divisble by eight"");
                return null;
            }

            if ((key.Length % 8) != 0)
            {
                Console.WriteLine(""key length not divisible by eight"");
                return null;
            }

            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            tdes.Key = key;
            tdes.Mode = CipherMode.ECB;
            tdes.IV = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            tdes.Padding = PaddingMode.Zeros;
            tdes.KeySize = (key.Length * 8);
            ICryptoTransform ct = tdes.CreateDecryptor();

            Console.WriteLine("" - IV: "" + byte_array_to_hex_string(tdes.IV, true, true));
            byte[] clear = new byte[(cipher.Length)];
            clear = ct.TransformFinalBlock(cipher, 0, cipher.Length);

            Console.WriteLine("" - clear: "" + byte_array_to_hex_string(clear, true, true));
            tdes.Clear();
            tdes.Dispose();
            ct.Dispose();
            return clear;
        }

        public static byte[] hex_string_to_byte_array(string hex)
        {
            int number_chars = hex.Length;
            byte[] bytes = new byte[number_chars / 2];
            for (int i = 0; i &lt; number_chars; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            }
            return bytes;
        }

        public static string byte_array_to_hex_string(byte[] ba, bool remove_dashes, bool include_spaces)
        {
            string hex = BitConverter.ToString(ba);
            string hex_dashes = """";
            string hex_spaces = """";

            if (remove_dashes)
            {
                hex_dashes = hex.Replace(""-"", """");
            }
            else
            {
                return hex;
            }

            int hex_char_count = 0;
            if (include_spaces)
            {
                for (int i = (hex_dashes.Length - 1); i &gt;= 0; i--)
                {
                    if (hex_char_count == 0)
                    {
                        hex_spaces += hex_dashes[i];
                        hex_char_count++;
                        continue;
                    }

                    if (hex_char_count % 16 == 0)
                    {
                        hex_spaces = (hex_dashes[i] + "" "" + hex_spaces);
                        hex_char_count++;
                        continue;
                    }

                    hex_spaces = hex_dashes[i] + hex_spaces;
                    hex_char_count++;
                }

                return hex_spaces;
            }
            else
            {
                return hex_dashes;
            }
        }
    }
}
</code></pre>

<p>Output</p>

<pre>Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 10F99E2232BEC7F4
 - clear: BF3CBF923E6C0E19 DBBB64E0FCBBFBB9 4CA3D68F117BE51F 0C1294CEC85470B6 6A799CC5D914F427 30D0C47BC9E6340C BD8E4C2E
6E5819ED 23125066DBA83477
clear: BF3CBF923E6C0E19 DBBB64E0FCBBFBB9 4CA3D68F117BE51F 0C1294CEC85470B6 6A799CC5D914F427 30D0C47BC9E6340C BD8E4C2E6E5
819ED 23125066DBA83477

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 32B9C802333CFBB4
 - clear: A878F23C3AF5E724 2ACB3458F8D68E68 9BE4F6C007F24FD2 9AF4CE98239A4F2C 5710633D88266AFD 77EF88A7B09485D9 F07C33D7
08832E90 77382A7A51A532C1
clear: A878F23C3AF5E724 2ACB3458F8D68E68 9BE4F6C007F24FD2 9AF4CE98239A4F2C 5710633D88266AFD 77EF88A7B09485D9 F07C33D7088
32E90 77382A7A51A532C1

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 2FCB1A9F5B502E1B
 - clear: 80B7302520ACA111 223BF99421EFDA2C 60CABCB3C632A61C 3422552A07B582B7 E50E44E38DEDC300 DD9A6EB5CF3C0A63 E512FAC0
C04D3EC5 EEC551C3E845BF80
clear: 80B7302520ACA111 223BF99421EFDA2C 60CABCB3C632A61C 3422552A07B582B7 E50E44E38DEDC300 DD9A6EB5CF3C0A63 E512FAC0C04
D3EC5 EEC551C3E845BF80

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 355096FE3CA1E9A1
 - clear: E4EDCDC436745A51 42FE9D0C71933080 6DFCAACE07FBCC22 0F5C9AF9082C8264 870362982FF90CA4 665E312FC1A8D264 DDBB27B7
3B30840E 6030D791CD849A3D
clear: E4EDCDC436745A51 42FE9D0C71933080 6DFCAACE07FBCC22 0F5C9AF9082C8264 870362982FF90CA4 665E312FC1A8D264 DDBB27B73B3
0840E 6030D791CD849A3D</pre>
","<p>I can't explain why, but replacing it with the code below worked.  I'll dive into it more and if I figure it out I'll comment.</p>

<pre><code>    static byte[] decrypt_3des(byte[] cipher, byte[] key)
    {
        byte[] clear;
        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        tdes.Key = key;
        tdes.Mode = CipherMode.CBC;
        tdes.Padding = PaddingMode.None;
        tdes.IV = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

        try
        {
            ICryptoTransform ic = tdes.CreateDecryptor();
            clear = ic.TransformFinalBlock(cipher, 0, cipher.Length);
        }
        finally
        {
            tdes.Clear();
        }
        return clear;
    }
</code></pre>
","527","<c#><encryption><3des><tripledes>","2","0","2","2012-11-09 22:49:51","","2","","1026363","","2012-11-09 21:09:03","2012-11-09 20:15:06",""
"13315301","3DES not producing consistent decryption for multiple iterations over same ciphertext","<p>I've implemented a 3DES (TripleDES) decryption routine in my code and have noticed that it never produces the same cleartext when the supplied ciphertext is the same as the previous iteration.  It seems non-deterministic and I'm sure it's something I'm doing wrong.  </p>

<p>I've tried CBC (with a zeroed-out IV), ECB, multiple combinations of disposing and clearing.  I cannot seem to get consistent output.</p>

<p>(for some reason the code formatting on the 'Code' and 'Output' below are not coming out right, sorry)</p>

<p>Code</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Threading;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            while (true)
            {
                string key = ""27F66D5244FF621EAA6F6120EDEB427F"";
                string cipher = ""C25C1D1197D31CAA87285D59A892047426D9182EC11353C051ADD6D0F072A6CB3436560B3071FC1FD11D9F7E74886742D9BEE0CFD1EA1064C213BB55278B2F12"";

                Console.WriteLine(""clear: "" + byte_array_to_hex_string(
                    decrypt_3des(
                        hex_string_to_byte_array(cipher),
                        hex_string_to_byte_array(key)
                    ), true, true
                    ));

                Console.WriteLine("""");
                Thread.Sleep(1000);
            }
        }

        static byte[] decrypt_3des(byte[] cipher, byte[] key)
        {
            if (cipher == null) return null;
            if (key == null) return null;
            int num_chunks = (cipher.Length) / 8;

            Console.WriteLine(""Entering decrypt_3des"");
            Console.WriteLine("" - cipher: "" + byte_array_to_hex_string(cipher, true, true));
            Console.WriteLine("" - key: "" + byte_array_to_hex_string(key, true, true));
            Console.WriteLine("" - cipher length: "" + cipher.Length);
            Console.WriteLine("" - key length: "" + key.Length);

            if ((cipher.Length % 8) != 0)
            {
                Console.WriteLine(""cipher length not divisble by eight"");
                return null;
            }

            if ((key.Length % 8) != 0)
            {
                Console.WriteLine(""key length not divisible by eight"");
                return null;
            }

            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            tdes.Key = key;
            tdes.Mode = CipherMode.ECB;
            tdes.IV = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            tdes.Padding = PaddingMode.Zeros;
            tdes.KeySize = (key.Length * 8);
            ICryptoTransform ct = tdes.CreateDecryptor();

            Console.WriteLine("" - IV: "" + byte_array_to_hex_string(tdes.IV, true, true));
            byte[] clear = new byte[(cipher.Length)];
            clear = ct.TransformFinalBlock(cipher, 0, cipher.Length);

            Console.WriteLine("" - clear: "" + byte_array_to_hex_string(clear, true, true));
            tdes.Clear();
            tdes.Dispose();
            ct.Dispose();
            return clear;
        }

        public static byte[] hex_string_to_byte_array(string hex)
        {
            int number_chars = hex.Length;
            byte[] bytes = new byte[number_chars / 2];
            for (int i = 0; i &lt; number_chars; i += 2)
            {
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            }
            return bytes;
        }

        public static string byte_array_to_hex_string(byte[] ba, bool remove_dashes, bool include_spaces)
        {
            string hex = BitConverter.ToString(ba);
            string hex_dashes = """";
            string hex_spaces = """";

            if (remove_dashes)
            {
                hex_dashes = hex.Replace(""-"", """");
            }
            else
            {
                return hex;
            }

            int hex_char_count = 0;
            if (include_spaces)
            {
                for (int i = (hex_dashes.Length - 1); i &gt;= 0; i--)
                {
                    if (hex_char_count == 0)
                    {
                        hex_spaces += hex_dashes[i];
                        hex_char_count++;
                        continue;
                    }

                    if (hex_char_count % 16 == 0)
                    {
                        hex_spaces = (hex_dashes[i] + "" "" + hex_spaces);
                        hex_char_count++;
                        continue;
                    }

                    hex_spaces = hex_dashes[i] + hex_spaces;
                    hex_char_count++;
                }

                return hex_spaces;
            }
            else
            {
                return hex_dashes;
            }
        }
    }
}
</code></pre>

<p>Output</p>

<pre>Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 10F99E2232BEC7F4
 - clear: BF3CBF923E6C0E19 DBBB64E0FCBBFBB9 4CA3D68F117BE51F 0C1294CEC85470B6 6A799CC5D914F427 30D0C47BC9E6340C BD8E4C2E
6E5819ED 23125066DBA83477
clear: BF3CBF923E6C0E19 DBBB64E0FCBBFBB9 4CA3D68F117BE51F 0C1294CEC85470B6 6A799CC5D914F427 30D0C47BC9E6340C BD8E4C2E6E5
819ED 23125066DBA83477

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 32B9C802333CFBB4
 - clear: A878F23C3AF5E724 2ACB3458F8D68E68 9BE4F6C007F24FD2 9AF4CE98239A4F2C 5710633D88266AFD 77EF88A7B09485D9 F07C33D7
08832E90 77382A7A51A532C1
clear: A878F23C3AF5E724 2ACB3458F8D68E68 9BE4F6C007F24FD2 9AF4CE98239A4F2C 5710633D88266AFD 77EF88A7B09485D9 F07C33D7088
32E90 77382A7A51A532C1

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 2FCB1A9F5B502E1B
 - clear: 80B7302520ACA111 223BF99421EFDA2C 60CABCB3C632A61C 3422552A07B582B7 E50E44E38DEDC300 DD9A6EB5CF3C0A63 E512FAC0
C04D3EC5 EEC551C3E845BF80
clear: 80B7302520ACA111 223BF99421EFDA2C 60CABCB3C632A61C 3422552A07B582B7 E50E44E38DEDC300 DD9A6EB5CF3C0A63 E512FAC0C04
D3EC5 EEC551C3E845BF80

Entering decrypt_3des
 - cipher: C25C1D1197D31CAA 87285D59A8920474 26D9182EC11353C0 51ADD6D0F072A6CB 3436560B3071FC1F D11D9F7E74886742 D9BEE0C
FD1EA1064 C213BB55278B2F12
 - key: 27F66D5244FF621E AA6F6120EDEB427F
 - cipher length: 64
 - key length: 16
 - IV: 355096FE3CA1E9A1
 - clear: E4EDCDC436745A51 42FE9D0C71933080 6DFCAACE07FBCC22 0F5C9AF9082C8264 870362982FF90CA4 665E312FC1A8D264 DDBB27B7
3B30840E 6030D791CD849A3D
clear: E4EDCDC436745A51 42FE9D0C71933080 6DFCAACE07FBCC22 0F5C9AF9082C8264 870362982FF90CA4 665E312FC1A8D264 DDBB27B73B3
0840E 6030D791CD849A3D</pre>
","<p>Setting the key size results in a new random key being created. If you do this before you set the key and the IV, you will get consistent results.</p>
","527","<c#><encryption><3des><tripledes>","2","5","2","2012-11-09 22:49:51","","2","","1026363","","2012-11-09 21:09:03","2012-11-09 20:15:06",""
"43829039","Triple DES implementation by DES","<p>I'm trying to implement 3Des by using a DES API as below:</p>

<pre><code>des(input, output, key, mode)
</code></pre>

<p>which input, output and key are 8 bytes each one and mode identifies encryption and decryption type.
I'm wondering if it's possible to have a 3Des algorithm with variable output length?</p>

<p>This is the code I've written in C to create 3des with more than 8 bytes key by using this API.</p>

<p>But I have no idea if it's working OK or if it's possible to change output bytes.</p>

<pre><code>unsigned char TripleDes(uchar *input, uchar *output,uchar *deskey, int mode)
{
    uchar tt[100];
    uchar tmpInput[100];
    uchar tmpOutput[100];
    int i=0, j=0;

    memset(tt, 0, sizeof(tt));
    memset(tmpInput, 0, sizeof(tmpInput));
    memset(tmpOutput, 0, sizeof(tmpOutput));

    j =  strlen(input);
    memcpy(tmpInput, input, j);
    while(j/8!=0){
        j-=8;
        if (mode) { //Encrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey,1);
            des(tmpOutput+i*8, tt, deskey+8, 0);
            des(tt,tmpOutput+i*8, deskey, 1);
        }
        else { //Decrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey, 0);
            des(tmpOutput+i*8, tt, deskey+8, 1);
            des(tt, tmpOutput+i*8, deskey, 0);
        }
        i++;
    }

    strcpy(output, tmpOutput);
    return;
}
</code></pre>

<p>Any idea?</p>
","<pre><code>des(tmpInput+i*8, tmpOutput+i*8, deskey,1); // step1: encrypting 8 bytes of input with first 8 bytes of key
des(tmpOutput+i*8, tt, deskey+8, 0);// step2: decrypting result of step1 with last 8 bytes of key
des(tt,tmpOutput+i*8, deskey, 1);// step3: encrypting result of step2 with first 8 bytes of key
</code></pre>

<p>Assuming you have used 16 bytes key and if des api is doing what I have mentioned in comments, its doing 3DES properly</p>

<p>The length of output data is same as input data, if input data is multiple of 8 bytes.
If length of input data is not multiple of 8, its padded with trailing zeros to make it multiple of 8, and then encrypted
eg
If length of your input data is 10, length of output data will be 16</p>
","521","<c><des><3des><tripledes>","0","-1","2","2017-05-08 04:31:14","","4","1","","","","2017-05-07 07:44:13",""
"43829039","Triple DES implementation by DES","<p>I'm trying to implement 3Des by using a DES API as below:</p>

<pre><code>des(input, output, key, mode)
</code></pre>

<p>which input, output and key are 8 bytes each one and mode identifies encryption and decryption type.
I'm wondering if it's possible to have a 3Des algorithm with variable output length?</p>

<p>This is the code I've written in C to create 3des with more than 8 bytes key by using this API.</p>

<p>But I have no idea if it's working OK or if it's possible to change output bytes.</p>

<pre><code>unsigned char TripleDes(uchar *input, uchar *output,uchar *deskey, int mode)
{
    uchar tt[100];
    uchar tmpInput[100];
    uchar tmpOutput[100];
    int i=0, j=0;

    memset(tt, 0, sizeof(tt));
    memset(tmpInput, 0, sizeof(tmpInput));
    memset(tmpOutput, 0, sizeof(tmpOutput));

    j =  strlen(input);
    memcpy(tmpInput, input, j);
    while(j/8!=0){
        j-=8;
        if (mode) { //Encrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey,1);
            des(tmpOutput+i*8, tt, deskey+8, 0);
            des(tt,tmpOutput+i*8, deskey, 1);
        }
        else { //Decrypt
            des(tmpInput+i*8, tmpOutput+i*8, deskey, 0);
            des(tmpOutput+i*8, tt, deskey+8, 1);
            des(tt, tmpOutput+i*8, deskey, 0);
        }
        i++;
    }

    strcpy(output, tmpOutput);
    return;
}
</code></pre>

<p>Any idea?</p>
","<p>I finally could solve this problem not by using this API but with the methods are mentiond in the class in below link:</p>

<p><a href=""https://github.com/petricek/eternity-service/blob/master/Common/RSARef/source/desc.c"" rel=""nofollow noreferrer"">https://github.com/petricek/eternity-service/blob/master/Common/RSARef/source/desc.c</a></p>

<p>I needed a triple des class in CBC mode with 16 key length. I changed these classes and thos works fine:</p>

<pre><code> DES3_CBCInit
    {
     .....
      deskey(context-&gt;subkeys[0], key, encrypt);
      deskey(context-&gt;subkeys[1], &amp;key[8], !encrypt);
    }

 DES3_CBCUpdate
  {
    .....

    DESFunction (work, context-&gt;subkeys[0]);
    DESFunction (work, context-&gt;subkeys[1]);
    DESFunction (work, context-&gt;subkeys[0]);

    ......
   }
</code></pre>
","521","<c><des><3des><tripledes>","0","0","2","2017-05-08 04:31:14","","4","1","","","","2017-05-07 07:44:13",""
"48106278","How to encrypt text by 3DES, CBC mode using Javascript on APIGEE","<p>Here is my information:</p>

<ul>
<li>Plain Text: --------------------------------------------------- 

<ul>
<li>do not encode</li>
</ul></li>
<li>Key: ------------------------------------

<ul>
<li>do not encode</li>
</ul></li>
<li>Ecryption Algorithm: 3DES, CBC mode with symmetric key</li>
<li>Init Vector : ------------------------------

<ul>
<li>I knew only ""iv must be hexa form""</li>
</ul></li>
</ul>

<p><strong>Desired Output:</strong> </p>

<pre><code>----------------------------------------------------------------------------
</code></pre>

<p>I'm using this library: <a href=""https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/tripledes.js"" rel=""nofollow noreferrer"">https://cdn.rawgit.com/CryptoStore/crypto-js/3.1.2/build/rollups/tripledes.js</a></p>

<p><strong>My function to encrypt:</strong></p>

<pre><code>function encryptByDES(message, key){
  var iv = CryptoJS.lib.WordArray.create(8);
  var encrypted = CryptoJS.TripleDES.encrypt(message, key, {
    iv: key,
    mode: CryptoJS.mode.CBC
  });
  return encrypted.toString();
}
</code></pre>

<p><strong>Actual Output:</strong> </p>

<pre><code>----------------------------------------------------------------------------
</code></pre>

<p><strong>Question:</strong> How do I achieve my desired output?</p>
","<p>There are a number of oddities and issues with your inputs/outputs and code:</p>

<ul>
<li><p>You have a Base64 plaintext which you pass as plain UTF8 (???), UTF8 encoded key and hex encoded IV.  Ideally you should operate under one encoding for all three values.  I recommend base64 if you can't operate using plain binary.</p></li>
<li><p>You're using a fixed IV, which introduces a number of vulnerabilities that can result in plaintext recovery.  Always randomly generate an IV for each encryption operation.</p></li>
<li><p>You're passing the key as the IV during encryption, so the IV that you do generate is not used anyway.  <strong>Never use the key as an IV</strong>.</p></li>
</ul>

<p>I have solved your issue and have produced the desired output but I am not going to post the code, as you won't learn anything.  Instead I'll tell you what you need to do to fix what you have:</p>

<ul>
<li>Modify your existing to code to actually use the IV.</li>
<li>Pass the plaintext and key as binary data to the encrypt function by using <code>CryptoJS.enc.Utf8.parse</code> to get each as binary words.</li>
<li>Output the result as hex and not as base64.</li>
</ul>

<p>EDIT: The code used to produce the desired result.  Note the conversion from base64 to hex for the <code>output</code> variable:</p>

<pre><code>let iv = CryptoJS.enc.Hex.parse(""0000000000000000"");
let pt = CryptoJS.enc.Utf8.parse(""MjAxODAxMDQwOTM5MzgxMjM0NTY3ODkwMTIzNA=="");
let key = CryptoJS.enc.Utf8.parse(""20180104093938xSpUoDU3Z0"");

let result = CryptoJS.TripleDES.encrypt(pt, key, {
    iv: iv,
    mode: CryptoJS.mode.CBC
});

let output = CryptoJS.enc.Hex.stringify(CryptoJS.enc.Base64.parse(result.toString()));
console.log(output);
</code></pre>
","517","<javascript><encryption><apigee><3des><cbc-mode>","1","1","1","2018-01-08 02:52:40","48108101","0","","5645600","","2018-01-08 02:52:40","2018-01-05 02:09:29",""
"27610133","How to perform 3DES encryption in Ruby?","<p>I have a legacy Yii PHP system that is performing 3DES Encryption.</p>

<pre><code>$data = 'id=1,username=admin,email=webmaster@example.com';
$encrypted_key = mhash(MHASH_SHA1,""foo_bar_key"");
$encrypted_value = $StringHelper::encrypt($data, $encrypted_key); 
echo $encrypted_value 
//output =&gt; ""0G8ITzc32wvqpDIjt6O7tZV9VKwU8KK7p0xI%2Fa%2FjiPOR%2FLrpfvsfMg9fyV2vAHgf""
</code></pre>

<p>I'm trying to get this same encrypted value in Ruby using 3DES encryption but I am not able to get it.</p>

<pre><code>require 'openssl'
require 'mhash'
require 'base64'

@data = ""id=1,username=admin,email=webmaster@example.com""
@encrypted_key = Mhash.sha1(""foo_bar_key"")

cipher = OpenSSL::Cipher::Cipher.new('des-ede-cbc')
cipher.encrypt
cipher.key = @encrypted_key
output = cipher.update(@data)

puts output 
# output =&gt; ""\xFC\xCAR\xE2L\xB1\x1A\xCA\x83E\x9C\xEEA\xFD\x9D'I\v\x8E9\xFA4\x14\x1F&amp;\xBFR\x8A\xD3\xBDL\xC64\xABf\xCD\x85\x87\x88^""
#Base64.encode64(output) =&gt; ""/MpS4kyxGsqDRZzuQf2dJ0kLjjn6NBQfJr9SitO9TMY0q2bNhYeIXg==\n""
</code></pre>

<p>Does anyone know what I'm doing wrong?</p>

<p>Thanks.</p>
","<p>I haven't been able to find the <code>$StringHelper::encrypt</code> function, but if it is compatible, you just need to also perform <code>cipher.final</code> in your Ruby code and concatenate the output of <code>update</code> and <code>final</code> as clearly specified in the <a href=""http://ruby-doc.org/stdlib-2.0/libdoc/openssl/rdoc/OpenSSL/Cipher.html"" rel=""nofollow"">instructions</a>.</p>
","508","<php><ruby><encryption><yii><3des>","0","0","2","2015-02-27 20:08:33","","3","","4386456","","2014-12-22 21:02:38","2014-12-22 20:42:22",""
"27610133","How to perform 3DES encryption in Ruby?","<p>I have a legacy Yii PHP system that is performing 3DES Encryption.</p>

<pre><code>$data = 'id=1,username=admin,email=webmaster@example.com';
$encrypted_key = mhash(MHASH_SHA1,""foo_bar_key"");
$encrypted_value = $StringHelper::encrypt($data, $encrypted_key); 
echo $encrypted_value 
//output =&gt; ""0G8ITzc32wvqpDIjt6O7tZV9VKwU8KK7p0xI%2Fa%2FjiPOR%2FLrpfvsfMg9fyV2vAHgf""
</code></pre>

<p>I'm trying to get this same encrypted value in Ruby using 3DES encryption but I am not able to get it.</p>

<pre><code>require 'openssl'
require 'mhash'
require 'base64'

@data = ""id=1,username=admin,email=webmaster@example.com""
@encrypted_key = Mhash.sha1(""foo_bar_key"")

cipher = OpenSSL::Cipher::Cipher.new('des-ede-cbc')
cipher.encrypt
cipher.key = @encrypted_key
output = cipher.update(@data)

puts output 
# output =&gt; ""\xFC\xCAR\xE2L\xB1\x1A\xCA\x83E\x9C\xEEA\xFD\x9D'I\v\x8E9\xFA4\x14\x1F&amp;\xBFR\x8A\xD3\xBDL\xC64\xABf\xCD\x85\x87\x88^""
#Base64.encode64(output) =&gt; ""/MpS4kyxGsqDRZzuQf2dJ0kLjjn6NBQfJr9SitO9TMY0q2bNhYeIXg==\n""
</code></pre>

<p>Does anyone know what I'm doing wrong?</p>

<p>Thanks.</p>
","<p><a href=""https://www.ruby-forum.com/topic/168731"" rel=""nofollow"">https://www.ruby-forum.com/topic/168731</a></p>

<p>'man enc' on my system says:</p>

<pre><code>    des-ede3-cbc       Three key triple DES EDE in CBC mode
    des-ede3           Three key triple DES EDE in ECB mode
</code></pre>

<ul>
<li><p>des3               Alias for des-ede3-cbc</p>

<pre><code>des-ede3-cfb       Three key triple DES EDE CFB mode
des-ede3-ofb       Three key triple DES EDE in OFB mode
</code></pre></li>
</ul>
","508","<php><ruby><encryption><yii><3des>","0","0","2","2015-02-27 20:08:33","","3","","4386456","","2014-12-22 21:02:38","2014-12-22 20:42:22",""
"12846273","I'm implementing 3Des Encryption Algorithm for Long Numbers in Java","<p>I'm implementing 3Des Encryption Algorithm for a project.</p>

<p>I using this code as example:</p>

<p><a href=""http://www.java2s.com/Code/Java/Security/TripleDES.htm"" rel=""nofollow"">http://www.java2s.com/Code/Java/Security/TripleDES.htm</a></p>

<p>It's working ok, but I need to send and receive String, but i'm making this to save Credit Card Number on the Data Base, so I need to work with Long numbers, not Strings.</p>

<p>It is some possibillity to do that?.</p>

<p>I have to use a especial Key or I have to do some cast to the returned value?
I'm loking for the best, and most correct, solution.</p>

<p>I know, maybe my question is a little silly, but I'm lost.</p>

<p>Thanks for your answers and sorry for my poor english</p>
","<p>You need <code>byte[]</code> for encryption and from long you can generate <code>byte[]</code></p>

<pre><code>public static byte[] toByteArray(long value)    
{  
    ByteBuffer bb = ByteBuffer.allocate(8);  
    return bb.putLong(value).array();  
}  

public long toLong(byte[] bytes) {
    ByteBuffer buffer = ByteBuffer.allocate(8);
    buffer.put(bytes);
    return buffer.getLong();
}
</code></pre>

<p>Use this <code>byte[]</code> for encryption and decryption.
Also note that it is really not good to have credit card number as long.</p>
","501","<java><string><3des>","0","2","1","2012-10-11 18:39:10","","4","","","","","2012-10-11 18:34:00",""
"23428128","3DES result in PHP produces different result from 3DES in Python","<p><em>PHP code:</em></p>

<pre><code>$key = '111111111111111111111111'; //length: 24
$iv = ""\0\0\0\0\0\0\0\0""; //8 bytes
$data = mcrypt_encrypt(MCRYPT_TRIPLEDES, $key, ""SECRET"", MCRYPT_MODE_CBC, $iv);  
base64_encode($data); 
// Result: ZGF0YQ==
</code></pre>

<p><em>Python code</em> (using m2crypto):</p>

<pre><code>cipher = Cipher(alg='des_ede3_ecb', key=""111111111111111111111111"", op=encrypt, iv='\0'*8)
ciphertext = cipher.update(""SECRET"")
ciphertext += cipher.final()
base64.b64encode(ciphertext)
# Result: LhBqW6pGRoQ=
</code></pre>

<p><em>Python code</em> (using pyDes):</p>

<pre><code>k = pyDes.triple_des('111111111111111111111111', mode=pyDes.CBC, IV=b'\0'*8, pad=None, padmode=pyDes.PAD_PKCS5)
d = k.encrypt(""SECRET"")
base64.b64encode(d)
# Result: LhBqW6pGRoQ=
</code></pre>

<p>So Python gets the same result for different library, but PHP not ;/ Anybody see here any bug?</p>

<p>Thank you!</p>
","<p>PHP mcrypt doesn't handle PKCS5 padding, instead it uses simple zero padding. This is why you get different results compared to Python libs which use PKCS5 padding.</p>

<p>Here a workaround to get PKCS5 padding in PHP: <a href=""https://chrismckee.co.uk/handling-tripledes-ecb-pkcs5padding-php/"" rel=""nofollow"">https://chrismckee.co.uk/handling-tripledes-ecb-pkcs5padding-php/</a></p>

<p><strong>EDIT</strong></p>

<p>I confirm it works with this guy's lib:</p>

<pre><code>$key = '111111111111111111111111';
$x = ""SECRET"";
print(urldecode(encrypt($x, $key)));
</code></pre>

<p>(for some reason he decided to URL encode the result)</p>

<pre><code>$ php test.php 
LhBqW6pGRoQ=
</code></pre>

<p><strong>EDIT2</strong></p>

<p>Here is how to use classic padding with <code>pyDes</code>:</p>

<pre><code>import pyDes
import base64

k = pyDes.triple_des('111111111111111111111111', mode=pyDes.CBC, IV=b'\0'*8,
                     pad='\0', padmode=pyDes.PAD_NORMAL)
d = k.encrypt(""SECRET"")
print base64.b64encode(d)
</code></pre>

<p>It gives the same result as <code>mcrypt</code>.</p>
","490","<php><python><3des>","0","1","1","2014-05-02 15:49:33","23428454","2","","505722","","2014-05-02 15:49:33","2014-05-02 12:24:06",""
"25710371","PHP 3DES decrypt showed weird(bad) characters","<p>I have a PHP form for which I have implemented 3des encryption/decryption. After submitting and inserting information into database from the front-end, I want to read out the information in the back-end.</p>

<p>After decryption my form's information instead of correct characters it just return some bad charater for me such as : <code>�СU�k�8��t�ó�2(�f�B</code>. How can I solve this issue?</p>

<p>Here is my source code: </p>

<pre><code>   &lt;?php
function encrypt($clear, $key , $base64 = true)
  {
    if (!$clear)
      return '';
    $clear = pack(""a*H2"", $clear, ""80"");

    if (function_exists('mcrypt_module_open') &amp;&amp;
        ($td = mcrypt_module_open(MCRYPT_TripleDES, """", MCRYPT_MODE_CBC, """")))
    {
      $iv = create_iv(mcrypt_enc_get_iv_size($td));
      mcrypt_generic_init($td, $key, $iv);
      $cipher = $iv . mcrypt_generic($td, $clear);
      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);
    }
    else {
      @include_once('des.inc');

      if (function_exists('des')) {
        $des_iv_size = 8;
        $iv = create_iv($des_iv_size);
        $cipher = $iv . des($key, $clear, 1, 1, $iv);
      }
      else {
        raise_error(array(
          'code' =&gt; 500, 'type' =&gt; 'php',
          'file' =&gt; __FILE__, 'line' =&gt; __LINE__,
          'message' =&gt; ""Could not perform encryption; make sure Mcrypt is installed or lib/des.inc is available""
        ), true, true);
      }
    }
    return $base64 ? base64_encode($cipher) : $cipher;

  }


function decrypt($cipher, $key , $base64 = true)
  {
    if (!$cipher)
      return '';

    $cipher = $base64 ? base64_decode($cipher) : $cipher;

    if (function_exists('mcrypt_module_open') &amp;&amp;
        ($td = mcrypt_module_open(MCRYPT_TripleDES, """", MCRYPT_MODE_CBC, """")))
    {
      $iv_size = mcrypt_enc_get_iv_size($td);
      $iv = substr($cipher, 0, $iv_size);

      // session corruption? (#1485970)
      if (strlen($iv) &lt; $iv_size)
        return '';

      $cipher = substr($cipher, $iv_size);
      mcrypt_generic_init($td, $key, $iv);
      $clear = mdecrypt_generic($td, $cipher);
      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);
    }
    else {
      @include_once('lib/des.inc');

      if (function_exists('des')) {
        $des_iv_size = 8;
        $iv = substr($cipher, 0, $des_iv_size);
        $cipher = substr($cipher, $des_iv_size);
        $clear = des($this-&gt;config-&gt;get_crypto_key($key), $cipher, 0, 1, $iv);
      }
      else {
        raise_error(array(
          'code' =&gt; 500, 'type' =&gt; 'php',
          'file' =&gt; __FILE__, 'line' =&gt; __LINE__,
          'message' =&gt; ""Could not perform decryption; make sure Mcrypt is installed or lib/des.inc is available""
        ), true, true);
      }
    }

    /*-
     * Trim PHP's padding and the canary byte; see note in
     * rcmail::encrypt() and http://php.net/mcrypt_generic#68082
     */
    $clear = substr(rtrim($clear, ""\0""), 0, -1);

    return $clear;
  }


function create_iv($size)
  {
    $iv = '';
    for ($i = 0; $i &lt; $size; $i++)
        $iv .= chr(mt_rand(0, 255));
    return $iv;
  }

**echo decrypt('ijvdfvf1==+Ac44tgLHdAL+w7O2MiiIZplC','s&amp;gs1?m5l8PQIOGckvxDT4kR',true);**

?&gt;
</code></pre>

<p>I want to encrypt and decrypt UTF-8 characters in my form. </p>
","<p>I think you have forgotten one <code>$cipher = substr($cipher, $des_iv_size);</code> in the mcrypt part of your <code>decrypt</code> function.</p>

<p>Furthermore you should explicitly convert strings to (and from) UTF-8 encoding if you want to support UTF-8.</p>

<p>Finally it seems you are using single DES if 3DES is not available. Is that on purpose? </p>
","486","<php><encryption><utf-8><3des><roundcube>","0","0","1","2014-09-08 16:24:20","","5","","589259","","2014-09-08 16:17:14","2014-09-07 12:50:59",""
"26029529","PHP mcrypt 3DES 168bytes key: encrypted string can't by decrypt by JAVA","<p>I have a problem with 3DES of PHP. I'm doing a project that will access the internal interface of bank. They had developed an interface by java.
One function of the interface is that bank system will get the public RSA key from my server. The bank side is the client. He accesses my server by HTTP protocol. They required that the RSA public key was encrypted by 3DES. The key for 3DES is ""1000000200YYMMDD"".And they required the result to be sent back by byte stream.</p>

<p>I download several program of 3DES from web. They can get the encryped string. But they all failed at the bank side. The response is ""string index out of range"". I think this message is just the system message, and had few value for debug.
The following is my program.</p>

<p>I had several question about this problem.</p>

<p><strong>1, Many materail said that the length of 3DES key is max to 168 bytes. How can I extend my key to that length. I mean that the key of ""1000000200YYMMDD"" is just 16 chars, how to convert to 168bytes.</strong></p>

<p><strong>2, What is the difference of PHP and JAVA in 3DES encrypt.</strong> </p>

<p><strong>3, Which block mode should I choose? ECB? CBC?</strong> </p>

<p><strong>4, What kind of padding should I use?</strong></p>

<pre><code>//encrypt method 1
public function DESencrypt($str)
{  
    if ($this-&gt;mcrypt == MCRYPT_DES) $str = $this-&gt;_pkcs5Pad($str);  
    $block = mcrypt_get_block_size($this-&gt;mcrypt, $this-&gt;mode);  
    $pad = $block - (strlen($str) % $block);  
    $str .= str_repeat(chr($pad), $pad);  
    $result = mcrypt_encrypt($this-&gt;mcrypt, base64_encode($this-&gt;des_key), $str, $this-&gt;mode);
    return $result;  
}  
//encrypt method 2

public function encrypt_1($input)
{  
    $td = mcrypt_module_open(MCRYPT_TRIPLEDES, '', 'ecb', '');
    $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), MCRYPT_RAND);
    mcrypt_generic_init($td, $this-&gt;des_key, $iv);
    $encrypted_data = mcrypt_generic($td, $input);
    mcrypt_generic_deinit($td);
    mcrypt_module_close($td);
    return $encrypted_data;
}
//encrypt method 3
function encrypt($str)  
{  
       $block = mcrypt_get_block_size(MCRYPT_TRIPLEDES, MCRYPT_MODE_ECB);  
       $pad = $block - (strlen($str) % $block);  
       $str .= str_repeat(chr($pad), $pad);  
       return mcrypt_encrypt(MCRYPT_3DES, $this-&gt;des_key, $str, MCRYPT_MODE_ECB);  
} 
//encrypt method 4
public function  encrypt_2($input)
{
    $key = $this-&gt;des_key.$this-&gt;des_key;
    $tripleKey = substr($key, 0, mcrypt_get_key_size($this-&gt;mcrypt, $this-&gt;mode));
    $blocksize = mcrypt_get_block_size($this-&gt;mcrypt, $this-&gt;mode);
    $paddingSize = $blocksize - (strlen($input) % $blocksize);
    $input .= str_repeat(chr($paddingSize), $paddingSize);
    $encodedText = mcrypt_encrypt($this-&gt;mcrypt, $tripleKey, $input, $this-&gt;mode);
    return $encodedText;
}


///the main function
$des_key=""1000000200YYMMDD"";
///Initialize the encrypt class
$c = new Xcrypt($des_key);
/// Set the encrypt algorithm to 3DES
$c-&gt;setMcrypt(MCRYPT_3DES);
/// Get the RSA public key
$pub = $c-&gt;get_ZGSC_public();
// here I will encrypt the RSA key, I had used all the four method above, but all failed
$encyt_pub = $c-&gt;encrypt_2($pub);
///return to the client in byte stream.
file_put_contents(""php://output"", getBytes(base64_encode($encyt_pub)));
</code></pre>
","","484","<java><php><encryption><3des>","0","","0","2014-09-25 02:27:18","","3","1","","","","2014-09-25 02:27:18",""
"43885843","Can I set key length for OpenSSL 3des?","<p>I want do these</p>

<pre><code>  require ""openssl""
  decipher = OpenSSL::Cipher::Cipher.new('des3')
  decipher.decrypt
  decipher.key = ""11111111""
</code></pre>

<p>But it throws <code>OpenSSL::Cipher::CipherError: key length too short</code></p>

<p>I have tried to set the key length by <code>des.key_len = 8</code>, it throws <code>OpenSSL::Cipher::CipherError: invalid key length</code> error.</p>
","<p>From the OpenSSL ruby documentation:</p>

<blockquote>
  <p>key_length = integer → integer </p>
  
  <p>Sets the key length of the cipher. If
  the cipher is a fixed length cipher then attempting to set the key
  length to any value other than the fixed value is an error.</p>
  
  <p>Under normal circumstances you do not need to call this method (and
  probably shouldn’t).</p>
  
  <p>See EVP_CIPHER_CTX_set_key_length for further information.</p>
</blockquote>

<p>And as <strong>Triple Des</strong> <em>is</em> a fixed length key cipher (168-bit ~ 24-bytes), you get an error.</p>
","480","<ruby><encryption><openssl><3des>","1","2","1","2017-05-10 12:54:26","43886912","2","","","","","2017-05-10 07:16:39",""
"41272754","Decrypting 3des from hex data with a hex key","<p>I am trying to use the mycrypt php library to decrypt the following:</p>

<blockquote>
  <p><strong>Key:</strong> aaaaaaaabbbbbbbbccccccccdddddddd </p>
  
  <p><strong>Data:</strong> b5057bbc04b842a96144a0f617f2820e</p>
  
  <p><strong>Expected Result:</strong> Test123123</p>
</blockquote>

<p>The data is encrypted with 3DES with the mode ECB. The code I'm currently working with decrypts the hex value to ""e2119b734b5050e3"" which translates to ""â›sKPPã"". I have tried using open ssl which is returning ""False"". </p>

<p>The code is as follows:</p>

<p>(PHP Version 5.3.3)</p>

<pre><code>$key = 'aaaaaaaabbbbbbbbccccccccdddddddd';
$key = pack('H*',$key);

// DATA
$data = 'b5057bbc04b842a96144a0f617f2820e';
$data = pack('H'.strlen($key),$data);

// DECRYPT MCRYPT
$data = rtrim(mcrypt_decrypt(MCRYPT_3DES, $key, $data, MCRYPT_MODE_ECB), ""\0"");
$decryptedHex = unpack('H*',$data);

// DECRYPT OPEN SSL (RETURNS FALSE)
$result = openssl_decrypt($data,'des-ede3', $key);

// ECHO
echo $decryptedHex[1];
</code></pre>
","<p>The problem here is that there is too much missing information - the exact variant of 3DES, the padding info. With a little fiddling with encrypting options, rather than decrypting one can try to generate the ciphertext to find the correct options. They turn out to be </p>

<pre><code>openssl_encrypt($ptext,'des-ede', $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING)
</code></pre>

<p>Where <code>$ptext</code> is <code>""Test123123\0\0\0\0\0\0""</code></p>

<p>The ciphertext can similarly be decrypted via </p>

<pre><code>$result = openssl_decrypt($data,'des-ede', $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING);
</code></pre>

<p>You will need to upgrade to a more recent and supported (PHP 5.3 was released in 2009 and is no longer supported as of 2015) version of PHP. </p>
","471","<php><encryption><mcrypt><3des><tripledes>","-1","1","1","2016-12-22 20:21:46","41273852","15","","2977137","","2016-12-22 20:21:46","2016-12-21 22:09:39",""
"13717571","In ios 3des encryption contain lots of null termination.when i convert NSData to NSString , it will endup to first null termination?","<p>i have used this function for 3des encryption.</p>

<pre><code> ccStatus = CCCrypt(kCCEncrypt,              // CCoperation op
                       kCCAlgorithm3DES,        // CCAlgorithm alg
                       kCCOptionPKCS7Padding,  // kCCOptionPKCS7Padding,                    //kCCModeECB,              // CCOptions
                       [_keyData bytes],        // const void *key
                       kCCKeySize3DES,          // 3DES key size length 24 bit
                       vinitVec,              //iv,                      // const void *iv,
                       [dTextIn bytes],         // const void *dataIn 
                       [dTextIn length],        // size_t dataInLength
                       bufferPtr,               // void *dataOut
                       bufferPtrSize,           // size_t dataOutAvailable
                       &amp;movedBytes);            // size_t *dataOutMoved
       NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];'
</code></pre>

<p>Although it is working. but when i convert convert this NSData to NSString , because the  NSString contain lots of null termination,NSString end up on first null termination, the variable is not able to contain the whole data. but i have to send encrypted string on the server. what can i do to convert NSData to NSString. string that contain all data means(if the data contain null termination. the string will not end up in that case)?</p>

<p>Please help
Thanks in advance.</p>

<hr>

<p>thanks for reply ,
look if the encrypted byte contain </p>

<pre><code> char bytes[] = { 'H', 'e', 'l', 'l', 'o', \0, 'W', 'o', 'r', 'l', 'd', \0 };
   NSData *data = [NSData dataWithBytes:bytes length:sizeof(bytes)];
   NSString *str = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
   NSLog(@""%@"", str);

   NSString *sendtoserver=[NSString stringwithformat:@""&lt;request&gt;%@&lt;/request&gt;"",str];
</code></pre>

<p>when we convert these NSData to NSString. it will end on first \0 ( null termination)
because we have to send encrypted NSString.so it is making problem. and i can't send the base64string because server side don't want that.they were asking for encrypting string.</p>

<p>so what i do now , please help
and thanks again for reply sir,</p>
","<p>Converting <code>NSData</code> to <code>NSString</code> does <em>not</em> stop at null bytes. A <code>NSString</code> can contain arbitrary Unicode characters, including embedded ""NULL"" characters.</p>

<p>Example:</p>

<pre><code>char bytes[] = { 'H', 'e', 'l', 'l', 'o', 0, 'W', 'o', 'r', 'l', 'd', 0 };
NSData *data = [NSData dataWithBytes:bytes length:sizeof(bytes)];
NSString *str = [[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding];
NSLog(@""%@"", str);
</code></pre>

<p><em>Output:</em></p>

<pre><code>Hello
</code></pre>

<p>So it <em>looks</em> as if the string contains only 5 characters and the conversion stopped at the first null byte. But that is only the <code>NSLog</code> output, in fact nothing is lost:</p>

<pre><code>for (int i = 0; i &lt; [str length]; i++) {
    unichar c = [str characterAtIndex:i];
    NSLog(@""%2d, %3d, %c"", i, c, c);
}
</code></pre>

<p><em>Output:</em></p>

<pre><code>  0,  72, H
  1, 101, e
  2, 108, l
  3, 108, l
  4, 111, o
  5,   0, 
  6,  87, W
  7, 111, o
  8, 114, r
  9, 108, l
 10, 100, d
 11,   0, 
</code></pre>

<p>So the string contains all data and nothing is lost. Probably the string is truncated later, when you send it to the server.</p>

<hr>

<p><strong>REMARK:</strong> Converting the encrypted data to a string seems problematic to me, because the data is interpreted in some character encoding. I have chosen <code>NSASCIIStringEncoding</code> in this example, but according to the documentation this encoding is only valid for  ASCII values 0…127.</p>

<p>If you add more information on how and in which format the encrypted data is sent to the server, we might be able to make suggestions how so solve this better.</p>
","468","<iphone><encryption><nsstring><3des>","1","0","1","2012-12-06 12:03:37","13732228","1","","1288","","2012-12-06 12:03:37","2012-12-05 06:31:26",""
"45436615","Disable Weak ciphers on a particular port","<p>I recently scanned my system for PCI compliance test using NMAP.
NMAP reported following weak ciphers-</p>

<p><em>TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA (dh 1024) - D</em></p>

<p><em>TLS_RSA_WITH_3DES_EDE_CBC_SHA (rsa 2048) - C</em> </p>

<p><em>TLS_RSA_WITH_RC4_128_MD5 (rsa 2048) - C</em></p>

<p><em>TLS_RSA_WITH_RC4_128_SHA (rsa 2048) - C</em></p>

<p>These all are reported on TLSv1.2 on Port 5061. 
Port 5061 runs my secure SIP connection. </p>

<p>To resolve this, I disabled 3DES (Triple DES 168) from registry, also disabled, RC4 &amp; MD5 ciphers completely from registry.</p>

<p>I also did set an SSL cipher Suite order which does not use DES/3DES/RC4 or MD5 but still, after each scan same vulnerabilities are being reported. </p>

<p>How can I resolve this &amp; completely disable these ciphers?
Also, is there anyway to block cipher suite negotiation on any particular port?</p>

<p>Thanks.</p>

<p>P.S.- This is a Windows Server 2012 machine. </p>
","","468","<nmap><3des><pci-compliance><rc4-cipher>","0","","0","2017-08-29 22:26:04","","3","","1076479","","2017-08-29 22:26:04","2017-08-01 11:31:15",""
"34069934","Encrypt in Sqlserver using 3des and decrypt using java","<p>Is it possible to decrypt a file which is encrypted in sql server using 3DES algorithm?</p>

<p>Using java if I encrypt and save to sqlserver, then I am able to decrypt with out issues..</p>

<p>Is there any difference of encryption methods of sqlserver and java?</p>
","<p>You'd need to be using the same implementations, keys, lengths, chaining mode, initialization vectors etc. If any of the configuration of the algorithms is different, it will not decrypt successfully, this is by design.</p>

<p>If you're using the same for all of the above, in theory you could decrypt using paper and a pencil. Any different and you're looking at several million years of compute capacity to crack it.</p>

<p>ps: Use AES if you want it to be quicker AND more secure. Triple DES uses (as the name suggests) three passes of regular DES encryption, which is considerably slower than a single pass of the more modern AES encryption.</p>
","465","<java><3des>","1","1","2","2015-12-03 16:11:31","","3","1","2180785","","2015-12-03 16:11:31","2015-12-03 15:32:58",""
"34069934","Encrypt in Sqlserver using 3des and decrypt using java","<p>Is it possible to decrypt a file which is encrypted in sql server using 3DES algorithm?</p>

<p>Using java if I encrypt and save to sqlserver, then I am able to decrypt with out issues..</p>

<p>Is there any difference of encryption methods of sqlserver and java?</p>
","<p>You will want to encrypt and decrypt in Java because of ease of use and the security it provides. Also as mentioned before AES is quicker and more secure. Even though triple DES is still in the secure range, it's takes so longer to compute.</p>
","465","<java><3des>","1","0","2","2015-12-03 16:11:31","","3","1","2180785","","2015-12-03 16:11:31","2015-12-03 15:32:58",""
"45815134","In ruby, how to do a DES encryption with PKCS5 padding","<p>I am trying to convert some Python code into Ruby. Here is a snippet of the Python code:</p>

<pre><code># -*- coding: UTF-8 -*-
import pyDes
import base64
des3Key = '1234567887654321'
iv = des3Key[0:8]
data = r'abc'
k = pyDes.triple_des(des3Key,pyDes.CBC,iv,pad=None,padmode=pyDes.PAD_PKCS5)
d = k.encrypt(data)
print base64.b64encode(d)
#q8qN6El3X8A=
</code></pre>

<p>My Ruby code:</p>

<pre><code>require 'digest'
require 'openssl'
require 'base64'

data = 'abc'

key = '1234567887654321'
iv = key[0..7]
# cipher = OpenSSL::Cipher::Cipher.new('DES-EDE3')
cipher = OpenSSL::Cipher::Cipher.new('DES-EDE3-CBC') # or any other algorithm?

cipher.encrypt
cipher.pkcs5_keyivgen(key, iv)
output = cipher.update(data)
output &lt;&lt; cipher.final
p Base64.encode64(output).gsub(/\n/, """")
# y7TPhjBQO78=
</code></pre>

<p><strong>The ruby result not equal python's</strong> .Which algorithm should I choose?</p>
","<p>There are two issues here. First, don’t use <code>pkcs5_keyivgen</code>, this is an old and deprecated function for deriving a key and iv from a password. You need to set these directly on the <code>Cipher</code> object:</p>

<pre><code>cipher.key = key
cipher.iv = iv
</code></pre>

<p>Second, in your Python code the key is 16 bytes, which means you are using <em>two key</em> (or keying option 2) triple DES. The Python code automatically determines which to use depending on the length of the key used. In the Ruby OpenSSL bindings you need to explicitly specify which to use. <code>des-ede3-cbc</code> is <em>three key</em> (or keying option 1). You need to use <code>des-ede-cbc</code> as the cipher name:</p>

<pre><code>cipher = OpenSSL::Cipher.new('des-ede-cbc')
</code></pre>
","456","<python><ruby><openssl><3des>","0","2","1","2017-09-02 00:47:18","45815937","5","2","3886157","","2017-08-22 10:42:29","2017-08-22 10:26:36",""
"52827704","Java - BouncyCastle - 3DES encryption and decryption of files: Files are corrupted after round trip","<p>I am trying to encrypt and decrypt files with BouncyCastle 3DES. But the files are corrupted after encrypting and decrypting. For example a simple text-file or a jpg-image-file. This is my Code:</p>

<pre><code>ZipUnzipBouncyCastle()
{
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
}


public void encrypt3DES(String password, String file)
        throws IOException, DataLengthException, IllegalStateException,
        InvalidCipherTextException, NoSuchAlgorithmException
{
    byte[] data = Files.readAllBytes(new File(file).toPath());

    SecureRandom random = new SecureRandom(data);
    KeyGenerator keyGenerator = KeyGenerator.getInstance(""DESede"");
    keyGenerator.init(168, random);
    SecretKey secreteKey = keyGenerator.generateKey();

    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(
            new CBCBlockCipher(new DESedeEngine()));

    cipher.init(true, new KeyParameter(secreteKey.getEncoded()));

    byte[] result = new byte[cipher.getOutputSize(data.length)];
    int tam = cipher.processBytes(data, 0, data.length, result, 0);
    cipher.doFinal(result, tam);

    byte[] encodedData = Base64.getEncoder().encode(result);

    FileOutputStream fileOutputStream = new FileOutputStream(file);
    fileOutputStream.write(encodedData);
    fileOutputStream.flush();
    fileOutputStream.close();
}

public void decrypt3DES(String password, String file)
        throws NoSuchAlgorithmException, DataLengthException,
        IllegalStateException, InvalidCipherTextException, IOException
{
    byte[] data = Files.readAllBytes(new File(file).toPath());

    byte[] decodedData = Base64.getDecoder().decode(data);

    SecureRandom random = new SecureRandom(decodedData);
    KeyGenerator keyGenerator = KeyGenerator.getInstance(""DESede"");
    keyGenerator.init(168, random);
    SecretKey secreteKey = keyGenerator.generateKey();

    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(
            new CBCBlockCipher(new DESedeEngine()));

    cipher.init(true, new KeyParameter(secreteKey.getEncoded()));
    byte[] result = new byte[cipher.getOutputSize(decodedData.length)];
    int tam = cipher.processBytes(decodedData, 0, decodedData.length, result, 0);
    cipher.doFinal(result, tam);

    FileOutputStream fileOutputStream = new FileOutputStream(file);
    fileOutputStream.write(result);
    fileOutputStream.flush();
    fileOutputStream.close();
}
</code></pre>

<p>I looked all over the Internet but could not find any explanation. What am I doing wrong? </p>
","","455","<java><encryption><bouncycastle><3des>","0","","0","2018-10-16 03:49:19","","5","","","","","2018-10-16 03:49:19",""
"46738664","Decrypting DESede cipher with NoPadding","<p>For a Crypto class we've been given a DESede ciphertext using ECB with no padding => ""6t8Z5bKl5ybJL+MiFerNBmiTDS7wlTEUdWNwJJApWmQ=="" which is in base64 form.
We were given clues about the key and so I constructed all possible keys (where all are in an ASCII format).</p>

<pre><code>            String strToDecrypt=""6t8Z5bKl5ybJL+MiFerNBmiTDS7wlTEUdWNwJJApWmQ=="";
            byte[] input = strToDecrypt.getBytes();

            //Decrypt
            Cipher b = Cipher.getInstance(""DESede/ECB/NoPadding"");
            b.init(Cipher.DECRYPT_MODE, keySpec);
            byte output[] = b.doFinal(input);
            String out = new String(output);
            System.out.println(new String(out));
</code></pre>

<p>When I run this code using my keys, I get an IllegalBlockSizeException as my input isn't a multiple of 8 bytes.
I'm confused as to which ""bases"" to use. As I've said above, the ciphertext is in base64 so When running Cipher.DECRYPT should I be giving keys in a certain ""base"" or the string I want to decrypt in a certain base.</p>
","<p>Don't make the key generation harder than it needs to be. You want to try each possible value for the first byte of the variable section. But what if that value is 0xFB? Subsequent values would be 0xFC, 0xFD, 0xFE, and 0xFF. But what about the last value? You can assume that they wrap around, to 0x00.</p>

<p>If that's the case, something like this should work to find the correct key:</p>

<pre><code>static byte[] search(byte[] ciphertext) throws GeneralSecurityException {
  byte[] key = template(); /* Initialize the fixed bytes of ""key"" */
  Cipher nopadding = ... ; /* Create the correct cipher */
  for (long xy = 0; xy &lt; 256; ++xy) { /* Iterate over possible values */
    for (long wz = 0; wz &lt; 256; ++wz) { /* Is there another range? */
      for (int off = 0; off &lt; 6; ++off) {
        key[8 + off] = (byte) (xy + off); /* Set the first range */
      }
      for (int off = 0; off &lt; 6; ++off) {
        key[16 + off] = (byte) (wz + off); /* Set the second range */
      }
      nopadding.init(/* Initialize the cipher with your key */);
      byte[] plaintext = nopadding.doFinal(ciphertext);
      String str = new String(plaintext, StandardCharsets.US_ASCII);
      /* Return the key if it produced valid text */
      if (str.indexOf('\uFFFD') &lt; 0) return key;
    }
  }
  throw new IllegalArgumentException(); /* No key found */
}
</code></pre>
","439","<java><des><3des>","-1","1","1","2017-10-16 04:02:27","","10","2","","","","2017-10-13 22:10:45",""
"42636347","Derive Secret 3DES Key from a Master 3DES Key in Java?","<p>I have generated a 3DES Key the following way: </p>

<pre><code>KeyGenerator masterKeyGenerator = KeyGenerator.getInstance(""DESede"");
masterKeyGenerator.init(112);
SecretKey masterKey = masterKeyGenerator.generateKey();
</code></pre>

<p>Now I need to derive a new key using the above generated master key but I also need to use a random bytes(diversification data) in this key derivation process. </p>

<p>I can derive another Secret Key using the earlier generated Master Key only(the below code example) but apparently it is not the way, because I cannot find a way how use master key together with additional diversification data to derive a new key. </p>

<pre><code>SecretKeyFactory secondKeyFactory = SecretKeyFactory.getInstance(""DESede"");
KeySpec myKeySpec = new DESedeKeySpec(masterKey.getEncoded());
SecretKey secondKey = mySecretKeyFactory.generateSecret(myKeySpec);
</code></pre>

<p>Someone suggest me a code example in Java on how use master key together with additional random bytes[](diversification data) to derive a new key?</p>
","","434","<java><encryption><3des><secret-key><key-generator>","0","","0","2017-03-08 15:25:46","","5","","1816580","","2017-03-06 22:10:22","2017-03-06 21:55:09",""
"49679035","Python des-ede-cbc equivalent","<p>I currently have an encrypt and decrypt for 3DES (des-ede-cbc) in PHP as follows:</p>

<pre><code>php &gt; $key = '0000000000000000';
php &gt; $iv = '00000000';
php &gt; $plaintext = '1234567812345678';
php &gt; $ciphertext = openssl_encrypt($plaintext, 'des-ede-cbc', $key, 0, $iv);
php &gt; echo $ciphertext;
LEvEJf9CI+5VTVNeIjARNamKH+PNTx2P

php &gt; $plaintext = openssl_decrypt($ciphertext, 'des-ede-cbc', $key, 0, $iv);
php &gt; echo $plaintext;
1234567812345678
</code></pre>

<p>I need to be able to take the ciphertext and decrypt it in python. The closest I've found is pycrypto: <a href=""https://gist.github.com/komuw/83ddf9b4ae8f995f15af"" rel=""nofollow noreferrer"">https://gist.github.com/komuw/83ddf9b4ae8f995f15af</a></p>

<p>My attempt: </p>

<pre><code>&gt;&gt;&gt; key = '0000000000000000'
&gt;&gt;&gt; iv = '00000000'
&gt;&gt;&gt; cipher_decrypt = DES3.new(key, DES3.MODE_CBC, iv)
&gt;&gt;&gt; plaintext = cipher_decrypt.decrypt('LEvEJf9CI+5VTVNeIjARNamKH+PNTx2P')
&gt;&gt;&gt; plaintext
b']v\xdf\xa7\xf7\xc0()\x08\xdf\xcb`4\xa7\x10\x9e\xaf\x8c\xb6\x00+_\xb3?2\x1d\\\x08\x01\xfa\xf2\x99'
</code></pre>

<p>I'm not sure what it's doing differently. It's 3DES with mode CBC. I'm not exactly sure what the ede part means, but I can't seem to find anything to emulate that exact openssl mode. </p>

<p>Version info:<br>
Python 3.6.5<br>
PHP 7.1.3</p>
","<p>The string you get from PHP is base64 encoded.</p>

<pre><code>from Crypto.Cipher import DES3
from base64 import decodebytes

key = b'0000000000000000'
iv = b'00000000'

cipher_decrypt = DES3.new(key, DES3.MODE_CBC, iv)
plaintext = cipher_decrypt.decrypt(decodebytes(b'LEvEJf9CI+5VTVNeIjARNamKH+PNTx2P'))

print(plaintext.decode(""utf-8""))

&gt;&gt;&gt;1234567812345678
</code></pre>
","434","<php><python><3des>","3","2","1","2018-04-05 19:29:42","49680106","3","","","","","2018-04-05 18:22:51",""
"33543222","Converting 3DES code php to ASP","<pre><code>function encrypt_3DES($message, $key){
  // Se establece un IV por defecto
  $bytes = array(0,0,0,0,0,0,0,0); //byte [] IV = {0, 0, 0, 0, 0, 0, 0, 0}
  $iv = implode(array_map(""chr"", $bytes)); //PHP 4 &gt;= 4.0.2

  // Se cifra
  $ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv); //PHP 4 &gt;= 4.0.2
  return $ciphertext;
}
</code></pre>

<p>I have this code in php and I need to translate it to asp classic. It's a code used to the new card payment system and I don't know how to start here.
Anyone can help me?</p>
","<p>I found a solution in javascript using CryptoJS. You can use it for your classic asp code:</p>

<pre><code>&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/tripledes.js""&gt;&lt;/script&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/components/pad-nopadding.js""&gt;&lt;/script&gt;

&lt;script&gt;

function padString(source) {
    var paddingChar = '\0';
    var size = 8;
    var x = source.length % size;
    var padLength = size - x;

    for (var i = 0; i &lt; padLength; i++) source += paddingChar;

    return source;
}

var key = CryptoJS.enc.Base64.parse('Mk9m98IfEblmPfrpsawt7BmxObt98Jev');
var iv  = CryptoJS.enc.Hex.parse('0000000000000000');
var message = ""1447841550"";
var padMsg = padString(message);

var encrypted = CryptoJS.TripleDES.encrypt(padMsg, key, { iv: iv, padding: CryptoJS.pad.NoPadding, mode: CryptoJS.mode.CBC});

alert(encrypted);

&lt;/script&gt;
</code></pre>

<p>encrypted = n6lp0I1w5FxLQHskKMn4sw==</p>

<p>Is the same result that Redsys PHP platform.</p>
","412","<php><asp-classic><3des>","0","0","1","2015-11-25 13:27:53","","3","1","692942","","2015-11-05 12:25:56","2015-11-05 11:18:52",""
"41306800","Decrypting using openssl des-ede from the command-line with zero padding and raw data","<p>I am trying to recreate some openssl php code in the command-line. I have been able to get the following php code to work:</p>

<pre><code>$key = 'aaaaaaaabbbbbbbbccccccccdddddddd';
$key = pack('H*',$key);

$data = 'b5057bbc04b842a96144a0f617f2820e';
$data = pack('H*',$data);

$result = openssl_decrypt($data,'des-ede', $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING);
</code></pre>

<p><strong>The Command I'm Working on (Ubuntu)</strong></p>

<p><code>openssl des-ede -in encrypted-data.txt -out decrypted-data.txt -d -K aaaaaaaabbbbbbbbccccccccdddddddd -nopad</code></p>

<p><strong>The Key</strong></p>

<p>The key that im decrypting with is the hex value: <code>aaaaaaaabbbbbbbbccccccccdddddddd</code>. Can this key be passed as hex?</p>

<p><strong>The Encrypted Data</strong></p>

<p>The encrypted data I am passing in the encrypted-data.txt file is the hex value: <code>b5057bbc04b842a96144a0f617f2820e</code>. The data should decrypt to <code>Test123123</code>. I have tried converting the encrypted data to binary and passing it through a .bin file without success. Should this data be converted to some other format before being passed? </p>

<p><strong>The Parameters</strong></p>

<p>I believe I am having an issue translating the php parameters <code>OPENSSL_RAW_DATA</code> and <code>OPENSSL_ZERO_PADDING</code> to my command-line call. I have discovered the option <code>-nopad</code>, but am unsure if it is equivalent to the options in php</p>
","<p>I'm only including this here since I can't format a comment and this question should probably be closed and deleted. This verifies the process works identically with the command line <code>openssl</code> utility</p>

<pre><code>pvg /tmp ➤  more e.php 
&lt;?php
$data = 'b5057bbc04b842a96144a0f617f2820e';
$data = pack('H*',$data);

echo $data;
pvg /tmp ➤  php e.php &gt; in
pvg /tmp ➤  openssl des-ede -in in -out out -d -K aaaaaaaabbbbbbbbccccccccdddddddd -nopad
pvg /tmp ➤  cat out
Test123123%    
</code></pre>
","408","<php><encryption><3des><tripledes><php-openssl>","0","1","1","2016-12-24 08:54:50","41307838","7","","608639","","2016-12-24 08:54:50","2016-12-23 19:16:23",""
"1552060","Does WCF + net.tcp support 3DES?","<p>I currently have an open WCF service running w/ netTcpBinding; however, I need to encrypt this channel. Does WCF support 3DES, or should I just handle the encryption/decryption on my authorized client/server?</p>

<p>Thanks;</p>
","<p>I believe it does, via message security. Set the algorithmSuite attribue to the algorithm you wish to use. You can view the available algorithms here:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.servicemodel.security.securityalgorithmsuite_members.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/system.servicemodel.security.securityalgorithmsuite_members.aspx</a></p>

<p>There are a variety of TripleDES algorithms supported. I would hope that one of them would suffice. I believe the SecurityAlgorithmSuite class may be extended, so it might be possible to implement your own algorithm. However I am not sure how you would go about using it...I am not sure if the default configuration section supports third-party algorithms.</p>
","405","<c#><wcf><security><3des>","0","1","1","2009-10-11 23:26:18","1552070","0","","","","","2009-10-11 23:16:24",""
"10493948","Is it possible to use CBC mode of 3DES decryption method to decrypt an encrypted message of 14 characters?","<p>I read about the CBC mode of encryption in wikipedia where it said that in 3DES method a message is divided into 16 digit blocks each and then they are encrypted or decrypted. Every block which is encrypted is XORed with the next plaintext and then it is encrypted. I got this information from here well explained in a diagram. <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29</a></p>

<p>My problem is that I have to decrypt a message of length 14, so it will be a single block. So now how am I going to implement CBC for such a small message? There won't be next block to be XORed with.</p>
","<p>CBC and other modes of operation exist to allow, ""the repeated and secure use of a block cipher under a single key,"" as the linked Wikipedia article states.  This is needed to eliminate patterns in data, as you can see in the <a href=""http://en.wikipedia.org/wiki/File%3aTux_ecb.jpg"" rel=""nofollow"">picture of the encrypted Tux</a>.  Since you are only encrypting one block worth of data (2 bytes short of this, no less), then you can use the simplest technique, ECB, which simply passes in your plaintext and generates some ciphertext.</p>

<p>If you were panning on encrypting several of these 14 byte messages, then you would potentially want to consider using CBC to avoid exposing repetition in your encrypted data.</p>
","403","<3des><cbc-mode>","0","2","1","2012-05-08 21:16:37","","0","","","","","2012-05-08 06:49:32",""
"11383850","Cannot resolve symbol GetSHA256String","<p>I’m working on a mvc application over .Net, to secure my sensitive information in web.config I’ve got two functions in my model that encrypts and decrypts information using Triple DES, however I’m new to this and succeeded to reach till here by the help of a friend and asking some on line help here.</p>

<p>But now when I m trying to execute the code in my PC am getting this error:</p>

<p><code>Cannot resolve symbol GetSHA256String</code></p>

<p>in both encrypt and decrypt functions where this method is used.</p>

<p>Am i missing a directory here?  kindly help me out with this.</p>

<pre><code>public static string Encrypt(string Message, string Passphrase, out byte[] iv)
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String(Passphrase)));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
        TDESAlgorithm.Key = TDESKey;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        // Capture the randomly generated IV
        iv = TDESAlgorithm.IV;
        byte[] DataToEncrypt = UTF8.GetBytes(Message);
        try
        {
            ICryptoTransform Encryptor = TDESAlgorithm.CreateEncryptor();
            Results = Encryptor.TransformFinalBlock(DataToEncrypt, 0, DataToEncrypt.Length);
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }
        return Convert.ToBase64String(Results);
        //return Encoding.UTF8.GetString(Results);
    }

    public static string Decrypt(string Message, string Passphrase, byte[] iv)
    {
        byte[] Results;
        System.Text.UTF8Encoding UTF8 = new System.Text.UTF8Encoding();
        MD5CryptoServiceProvider HashProvider = new MD5CryptoServiceProvider();
        byte[] TDESKey = HashProvider.ComputeHash(UTF8.GetBytes(GetSHA256String(Passphrase)));
        TripleDESCryptoServiceProvider TDESAlgorithm = new TripleDESCryptoServiceProvider();
        TDESAlgorithm.Key = TDESKey;
        // Apply the same IV used during encryption
        TDESAlgorithm.IV = iv;
        TDESAlgorithm.Mode = CipherMode.ECB;
        TDESAlgorithm.Padding = PaddingMode.PKCS7;
        try
        {
            byte[] DataToDecrypt = Convert.FromBase64String(Message);
            //byte[] DataToDecrypt = UTF8.GetBytes(Message);
            //byte[] DataToDecrypt = Encoding.UTF8.GetBytes(Message);
            ICryptoTransform Decryptor = TDESAlgorithm.CreateDecryptor();
            Results = Decryptor.TransformFinalBlock(DataToDecrypt, 0, DataToDecrypt.Length); // &lt;&lt; ERROR is here.
        }
        finally
        {
            TDESAlgorithm.Clear();
            HashProvider.Clear();
        }
        return UTF8.GetString(Results);
    }
</code></pre>
","<p>I believe you need something similar to this method added to your class:</p>

<pre><code>private string GetSHA256String(string text)
{
    var UE = new UnicodeEncoding();
    var message = UE.GetBytes(text);

    var hashString = new SHA256Managed();
    var hex = string.Empty;

    var hashValue = hashString.ComputeHash(message);
    foreach (byte b in hashValue)
    {
        hex += String.Format(""{0:x2}"", b);
    }
    return hex;
}
</code></pre>

<p>Let me know if this does the trick.</p>
","402","<.net><asp.net-mvc-3><encryption><3des><tripledes>","0","2","1","2012-07-09 00:54:23","11387949","3","","","","","2012-07-08 14:22:37",""
"28438124","Java's 3DES encryption generates trash at the end of encrypted data","<p>I have a 3des <strong>Cipher</strong> object that is initialized like this:</p>

<pre><code>KeySpec keySpec= new DESedeKeySpec(bytesKey);
SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""DESede"");
SecretKey secretKey= secretKeyFactory.generateSecret(keySpec);
Cipher cipher = Cipher.getInstance(""DESede"");
cipher.init(modo, secretKey);
</code></pre>

<p>When this object is used to encrypt data, no exception is thrown and the algorithm ends succesfully:</p>

<pre><code>String unencryptedText = ""192 character length text in clear....        "";
byte[] bytesUnencryptedText = unencryptedText.getBytes(""UTF8"");
byte[] bytesEncryptedData = cipher.doFinal(bytesUnencryptedText);
</code></pre>

<p>When we took a look at the encrypted data generated by the doFinal, we noticed 200 bytes are being returned, as opposed to 192 as we expected. These additional 8 bytes took the following hexa value: 08.</p>

<p>The first 192 bytes are correct and we already have been able to decrypt them and obtain our original data. But the additional 8 bytes are generating an error at our HSM.</p>

<p>How can we prevent the Cipher to inject these additional bytes?</p>
","<p>The block size of DES is 64-bit or 8 bytes. When the plaintext size is a multiple of the plaintext the padding used will add another block of data to the plaintext filled with 0x08. This is how PKCS#5/PKCS#7 padding works.</p>

<p>It seems that your HSM expects that no padding is used. Also, from the comments it is apparent that <code>""DESede""</code> defaults to ECB mode, so the fully qualified Cipher would be:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
</code></pre>

<p>Note that ECB mode is not semantically secure. If possible, use a different mode like CBC with an HMAC over the ciphertext, or simply an authenticated mode like GCM.</p>

<p>When you use NoPadding, the plaintext is filled up with 0x00 bytes and you will have to trim the decrypted plaintext yourself by removing all 0x00 bytes at the end. To do this, make sure that the plaintext doesn't actually contain 0x00 bytes at the end, otherwise you will remove actual plaintext bytes.</p>
","402","<java><encryption><3des>","0","1","1","2015-02-10 19:43:02","28440214","6","2","","","","2015-02-10 17:33:55",""
"34164395","Oracle PL/SQL 3DES encryption replicated to java","<p>i have a legacy oracle functions which use DES3Encrypt and DES3Decrypt function.</p>

<p>I need to write the java equivalent version in order to replace the oracle ones keeping compatibiliy with legacy encryption system.</p>

<p>These are the oracle functions:</p>

<pre><code>//ENCRYPTION
FUNCTION encr(input_string IN VARCHAR2, key_string IN VARCHAR2)
    RETURN VARCHAR2 IS
    encrypted_string := NULL;
    len              := lengthb(input_string);
    --String must be a multiple of 8-byte length.
    rest := len MOD 8;
    IF rest &gt; 0 THEN
        decrypted_string := rpad(input_string, len + 8 - rest, ' ');
    ELSE
        decrypted_string := input_string;
    END IF;

    dbms_obfuscation_toolkit.DES3Encrypt(input_string     =&gt; decrypted_string,
                                     key_string       =&gt; key_string,
                                     encrypted_string =&gt; encrypted_string);

    /* HEX notation to avoid UNICODE chars */
    SELECT RAWTOHEX(encrypted_string) INTO encrypted_string FROM DUAL;

    RETURN encrypted_string;
END;

//DECRYPTION
FUNCTION decr(input_string IN VARCHAR2, key_string IN VARCHAR2)
   RETURN VARCHAR2 IS
   decrypted_string := NULL;
   encrypted_string := input_string;

   /* HEX to ASCII */
   SELECT utl_raw.cast_to_varchar2(encrypted_string)
   INTO encrypted_string
   FROM DUAL;

   dbms_obfuscation_toolkit.DES3Decrypt(input_string     =&gt; encrypted_string,
                                     key_string       =&gt; key_string,
                                     decrypted_string =&gt; decrypted_string);

  RETURN rtrim(decrypted_string);
END;
</code></pre>

<p>Considering the Decrypt function, for example i wrote this java code:</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class DesHelper { 
    private Cipher _dcipher;
    public DesHelper() {
       try {

           byte[] tdesKey = new byte[24];
           System.arraycopy(""2557133392096270"".getBytes(StandardCharsets.US_ASCII), 0, tdesKey, 0, 16);
           System.arraycopy(""2557133392096270"".getBytes(StandardCharsets.US_ASCII), 0, tdesKey, 16, 8);

           final SecretKey key = new SecretKeySpec(tdesKey, ""DESede"");

           _dcipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
           final IvParameterSpec iv = new IvParameterSpec(new byte[8]);

           _dcipher.init(Cipher.DECRYPT_MODE, key,iv);

      } catch (final Exception e) {
          throw new RuntimeException(e);
      }
  }


  public String decrypt(final String str) {
      try {

          final byte[] dec1 = hexToBytes(str);
          final byte[] decryptedBytes = _dcipher.doFinal(dec1);   
          return new String(decryptedBytes, StandardCharacters.US_ASCII);
      } catch (final Exception e) {
          System.out.println(""decrypting string failed: "" + str + "" ("" + e.getMessage() + "")"");
          return null;
      }
  }

 private static byte[] hexToBytes(final String hex) {
      final byte[] bytes = new byte[hex.length() / 2];
      for (int i = 0; i &lt; bytes.length; i++) {
          bytes[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2), 16);
      }
      return bytes;
 }
</code></pre>

<p>}</p>

<p>This is the main:</p>

<pre><code>Public class MainClass{

      public static void main (final String[] args){

          String txtToBeDecrypted = ""DA67C73756184F20ED92DF1614CB85ED"";

         final DesHelper h = new DesHelper();

         String xc = h.decrypt(txtToBeDecrypted);

         System.out.printls(xc);

     }

}
</code></pre>

<p>But the printed result is still a mess of characters like these:</p>

<p>lZ5 ????rd<br>
where only ""rd"" is correct (being the last part of the decrypted word).</p>

<p>the correct decrypted word should be ""mypassword""</p>

<p>if the password changes into mypasswordmypass ( encrypted: 5543417F4834268A2799D9289D864BFB ) ... i get: lZ5????rdmypass ---> it seems that the first 64 bits are always wrong.</p>

<p>What's wrong in my code? is it just an encoding matter?</p>
","","401","<java><encryption><plsql><obfuscation><3des>","2","","0","2015-12-10 09:48:34","","7","2","1809625","","2015-12-10 09:48:34","2015-12-08 19:29:27",""
"17407909","Java Cipher TripleDES porting in PHP","<p>I've got this Java Code and I need to trasform it in PHP code obtaining the same output.
Do you now how to do it?</p>

<pre><code>final byte[] key = {(byte)0x49, (byte)0x45, (byte)0x4D, (byte)0x4B, (byte)0x41, (byte)0x45, (byte)0x52, (byte)0x42, (byte)0x21, (byte)0x4E, (byte)0x41, (byte)0x43, (byte)0x55, (byte)0x4F, (byte)0x59, (byte)0x46};
final byte[] encRndB = {(byte)0x33, (byte)0xD4, (byte)0x8E, (byte)0xAF, (byte)0x75, (byte)0x70, (byte)0x40, (byte)0x5E};

final SecretKeySpec keySpec = new SecretKeySpec(key, ""DESede"");
final byte[] zeroInitVector = { 0, 0, 0, 0, 0, 0, 0, 0 };

final byte[] rndB      = tripleDes(encRndB, Cipher.DECRYPT_MODE, keySpec, zeroInitVector);
</code></pre>

<p>The function tripleDes is this:</p>

<pre><code>public static byte[] tripleDes(final byte[] original, final int mode, final SecretKeySpec keySpec, final byte[] ivSpec) throws GeneralSecurityException {
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
    final IvParameterSpec iv = new IvParameterSpec(ivSpec);
    cipher.init(mode, keySpec, iv);
    return cipher.doFinal(original);
}
</code></pre>

<p>rndB should be something like:</p>

<pre><code>{(byte)0x7B, (byte)0x8B, (byte)0xD0, (byte)0x72, (byte)0x0D, (byte)0xE8, (byte)0x5A, (byte)0x2B}
</code></pre>

<p>I tried this:</p>

<pre><code>&lt;?php
function encryptText($plainText, $key) {
    $iv = ""\x00\x00\x00\x00\x00\x00\x00\x00"";
    $padded = $plainText;

    $encText = mcrypt_decrypt(""tripledes"", $key, $padded, ""cbc"", $iv);

    return $encText;
}

$key = ""\x49\x45\x4D\x4B\x41\x45\x52\x42\x21\x4E\x41\x43\x55\x4F\x59\x46"";
$plainText = ""\x33\xD4\x8E\xAF\x75\x70\x40\x5E"";
print_r(unpack(""H*"", encryptText($plainText, $key)));
?&gt;
</code></pre>

<p>But it doesn't give me the same output...</p>
","","393","<java><php><3des>","1","","0","2013-07-01 22:11:10","","1","2","2538391","","2013-07-01 22:11:10","2013-07-01 15:15:11",""
"40120318","Decrypt hex strings using 3DES in Ruby from .NET","<p>I'm working on a Ruby project that is interacting with a webservice that I'm exchanging some encrypted data with.</p>

<p>I am having a very hard time decrypting something I get back from the webservice in Ruby, although in the .NET side, it's working fine, and a number of other web-based or desktop-based tools can deal with this. </p>

<p>The encryption method was 3DES with ECB and no padding.</p>

<p>Below is a test script I have been working on.  I've tried everything I can think of to get these strings unpacked correctly, but to no avail.</p>

<pre><code>require 'openssl'
require 'base64'

def cipher(key, encrypted)
  key = key.unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
  encrypted = encrypted.unpack('a2'*32).map{|x| x.hex}.pack('c'*32)
  OpenSSL::Cipher::ciphers.select{|c| c.include? 'des3' }.map do |cipher_name|
    begin
      cipher = OpenSSL::Cipher.new(cipher_name)
      cipher.padding = 0
      cipher.decrypt
      cipher.key=key

      plain = cipher.update(encrypted) + cipher.final

      p ""Cipher #{cipher_name} success: #{plain} #{plain.class} #{plain.length} #{plain.encoding.to_s}""
      plain
    rescue =&gt; e
      p ""Cipher #{cipher_name} failed #{e}""
      nil
    end
  end

end

key = '202FA9B21843D7022B6466DB68327E1F'
encrypted = 'ff6f07e270ebd5c0878c67c999d87ebf'

res1 = cipher key, encrypted

key = '49CE85147B24123718AB3F4539AB1A21'
encrypted = '995604ed8016da8897f1875ebd725529'

res2 = cipher key, encrypted


p res1 == res2 ? ""SUCCESS"" : ""FAIL""

# In both cases, the correct output should be '25588015543912470222703296730936'
</code></pre>

<p><a href=""https://i.stack.imgur.com/JNpby.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/JNpby.png"" alt=""BC-Tools Decryption""></a></p>
","<p>A 3DES key is 24-bytes, use a full length key.</p>

<p>3DES uses triple encryption with essentially a 24-byte key. <code>202FA9B21843D7022B6466DB68327E1F</code> is hex encoded 16-byte key.</p>

<p>Try repeating the first 8-bytes of the key:<br>
<code>202FA9B21843D7022B6466DB68327E1F202FA9B21843D702</code></p>

<p>Some 3DES implementations will repeat 8-bytes of a 16-byte key but relying on such implementation details is not a good idea.</p>

<p>Note: 3DES actually uses a 168-bit key because the LSb of each byte is not used. Further because there are actually three DES calls the security is only 112-bits. Additionally DES has some weak keys. There are two common modes, ede and ded, in an effort to facilitate moving from DES to 3DES thus adding more confusion.</p>

<p>Finally: Move from 3DES to AES in CBC mode with a random IV. Please don't continue poor security practices.</p>
","372","<ruby><encryption><3des>","2","1","1","2016-10-19 13:29:00","40132350","3","","","","","2016-10-19 00:49:26",""
"51299728","java.security.InvalidKeyException: Invalid key length: 8 bytes","<p>I have requirement where I am having a hex key-1122334455667788 and 
hex message-2962A83E5D3D5187 to decode with 3des. But when i am trying to decode it ,I am getting error ""java.security.InvalidKeyException: Invalid key length: 8 bytes"".Please anybody can help?</p>

<p>My code to decrypt</p>

<pre><code>public class TripleDES {

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                                 + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }


public static void main(String[] args) throws Exception {

    byte[] keyBytes=hexStringToByteArray(""1122334455667788"");
    byte[] message=hexStringToByteArray(""2962A83E5D3D5187"");
     final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);    
    }
}
</code></pre>
","<p>A triple-DES key is 24 bytes long; see <a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/DESedeKeySpec.html"" rel=""nofollow noreferrer"">https://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/DESedeKeySpec.html</a>.</p>

<p>(I would try padding the byte array to 24 bytes with zero bytes at the start or end ... and see what works for your cypher text.)</p>

<hr>

<p>Next problem ...</p>

<blockquote>
  <p>I tried to change the key to </p>

<pre><code>  String desKey = ""000000000000000000000000000000001122334455667788"";
</code></pre>
  
  <p>but I am now getting a ""Given final block not properly padded"" exception.</p>
</blockquote>

<p>I think that is saying that the message is not padded correctly.   Try using ""NoPadding"" instead of ""PKCS5Padding"".   </p>

<p>See </p>

<ul>
<li><a href=""https://stackoverflow.com/questions/10634065/encryption-using-provided-key-using-des-with-padding"">encryption using provided key using DES with padding</a></li>
</ul>
","353","<java><3des>","1","0","3","2018-07-13 06:47:24","","0","1","","","","2018-07-12 07:30:32",""
"51299728","java.security.InvalidKeyException: Invalid key length: 8 bytes","<p>I have requirement where I am having a hex key-1122334455667788 and 
hex message-2962A83E5D3D5187 to decode with 3des. But when i am trying to decode it ,I am getting error ""java.security.InvalidKeyException: Invalid key length: 8 bytes"".Please anybody can help?</p>

<p>My code to decrypt</p>

<pre><code>public class TripleDES {

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                                 + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }


public static void main(String[] args) throws Exception {

    byte[] keyBytes=hexStringToByteArray(""1122334455667788"");
    byte[] message=hexStringToByteArray(""2962A83E5D3D5187"");
     final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);    
    }
}
</code></pre>
","<pre><code>import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKeyFactory;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.xml.bind.DatatypeConverter;

public class DESede {

    private static Cipher encryptCipher;
    private static Cipher decryptCipher;

    private static byte[] encryptData(String data) throws IllegalBlockSizeException, BadPaddingException {
        System.out.println(""Data Before Encryption :"" + data);
        byte[] dataToEncrypt = data.getBytes();
        byte[] encryptedData = encryptCipher.doFinal(dataToEncrypt);
        System.out.println(""Encryted Data: "" + encryptedData);
        return encryptedData;
    }

    private static void decryptData(byte[] data) throws IllegalBlockSizeException, BadPaddingException {
        byte[] textDecrypted = decryptCipher.doFinal(data);
        System.out.println(""Decryted Data: "" + new String(textDecrypted));
    }

    public static void main(String[] args) throws InvalidKeySpecException {
        try {

            String desKey = ""0123456789abcdef0123456789abcdef0123456789abcdef""; // Key from user
            byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
            System.out.println((int) keyBytes.length);

            SecretKeyFactory factory = SecretKeyFactory.getInstance(""DESede"");
            SecretKey key = factory.generateSecret(new DESedeKeySpec(keyBytes));

            encryptCipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            encryptCipher.init(Cipher.ENCRYPT_MODE, key); // throwing Exception
            byte[] encryptedData = encryptData(""Confidential Data"");
            decryptCipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            byte iv[] = encryptCipher.getIV(); 
            IvParameterSpec dps = new IvParameterSpec(iv);
            decryptCipher.init(Cipher.DECRYPT_MODE, key, dps);
            decryptData(encryptedData);

        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (InvalidAlgorithmParameterException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }
}
</code></pre>

<p>DESede need 24 bytes key. Try this program.</p>

<p><strong>OUTPUT</strong></p>

<pre><code>Data Before Encryption :Confidential Data
Encryted Data: [B@6fadae5d
Decryted Data: Confidential Data
</code></pre>
","353","<java><3des>","1","0","3","2018-07-13 06:47:24","","0","1","","","","2018-07-12 07:30:32",""
"51299728","java.security.InvalidKeyException: Invalid key length: 8 bytes","<p>I have requirement where I am having a hex key-1122334455667788 and 
hex message-2962A83E5D3D5187 to decode with 3des. But when i am trying to decode it ,I am getting error ""java.security.InvalidKeyException: Invalid key length: 8 bytes"".Please anybody can help?</p>

<p>My code to decrypt</p>

<pre><code>public class TripleDES {

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                                 + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }


public static void main(String[] args) throws Exception {

    byte[] keyBytes=hexStringToByteArray(""1122334455667788"");
    byte[] message=hexStringToByteArray(""2962A83E5D3D5187"");
     final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);    
    }
}
</code></pre>
","<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TripleDES {

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i &lt; len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4) + Character.digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    public static void main(String[] args) throws Exception {
        byte[] keyBytes = hexStringToByteArray(""1122334455667788"");
        byte[] message = hexStringToByteArray(""2962A83E5D3D5187"");
        final SecretKey key = new SecretKeySpec(keyBytes, ""DES"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DES/ECB/NoPadding"");
        decipher.init(Cipher.DECRYPT_MODE, key);
        final byte[] plainText = decipher.doFinal(message);
        System.out.println(""Decrypted Data :: ""+new String(plainText));
    }
}
</code></pre>

<p><strong>OUTPUT</strong></p>

<pre><code>Decrypted Data :: FB
</code></pre>
","353","<java><3des>","1","0","3","2018-07-13 06:47:24","","0","1","","","","2018-07-12 07:30:32",""
"19546063","different result in java 3DES CBC programming","<p>I face some questions when I do some 3DES-CBC programming with JAVA.</p>

<p>I have some functions</p>

<pre><code>private static byte[] xorBytes(byte[] rndA, byte[] rndB) {
    // TODO Auto-generated method stub
    byte[] b = new byte[rndB.length];
    for (int i = 0; i &lt; rndB.length; i++) {
        b[i] = (byte) (rndA[i] ^ rndB[i]);
    }
    return b;
}


public static byte[] decrypt(byte[] key, byte[] enciphered_data) {

    try {
        byte[] iv = new byte[] { 0,0,0,0,0,0,0,0 };
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
        SecretKey s = new SecretKeySpec(key, ""DESede"");
        Cipher cipher;
        cipher = Cipher.getInstance(""DESede/CBC/NoPadding"", ""BC"");
        cipher.init(Cipher.DECRYPT_MODE, s, ivParameterSpec);
        byte[] deciphered_data = cipher.doFinal(enciphered_data);
        return deciphered_data;
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchProviderException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (BadPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return null;
}
</code></pre>

<p>and some variables</p>

<pre><code>byte[] key = new byte[] { (byte) 0x0, (byte) 0x0, (byte) 0x0,
            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,
            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,
            (byte) 0x0, (byte) 0x0, (byte) 0x0 };

byte[] rndB = new byte[] { (byte) 0xe4, (byte) 0xee, (byte) 0x2e,
            (byte) 0x8b, (byte) 0x4b, (byte) 0xf7, (byte) 0xb1, (byte) 0x98  };


byte[] rndA = new byte[] { (byte) 0x00, (byte) 0x11, (byte) 0x22,
            (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77  };
</code></pre>

<p>First I do</p>

<pre><code>rndA = decrypt(key, rndA); 
byte[] rndAB = new byte[16];
System.arraycopy(rndA, 0, rndAB, 0, 8);
rndB = xorBytes(rndA, rndB);
rndB = decrypt(key, rndB);
System.arraycopy(rndB, 0, rndAB, 8, 8);
</code></pre>

<p>And the result is<br>
rndAB = 74 f4 ae 77 7a a4 31 e8 4b 18 ba 8f 74 cf 80 63</p>

<p>Then I do</p>

<pre><code> byte[] rndAB = new byte[16];
 System.arraycopy(rndA, 0, rndAB, 0, 8);
 System.arraycopy(rndB, 0, rndAB, 8, 8);
 rndAB = decrypt(key, rndAB);
</code></pre>

<p>But the result is 
rndAB = 74 f4 ae 77 7a a4 31 e8 a6 54 dc e3 27 01 2b 39</p>

<p>I am confused why the two results are different.
Is DES(A+B) equal to DES(A) + DES(DES(A) xor B) with IV = {0,0,0,0,0,0,0,0} ???</p>
","","344","<java><3des>","1","","0","2013-10-23 15:32:32","","1","2","","","","2013-10-23 15:32:32",""
"41552636","unable to decrypt 3DES with SessionKey","<p>I'm developing a C project to read/write Desfire Contactless Cards.
Right now I achieved to authenticate and I'm able to read data from the card, but it's encrypted with 3DES.</p>

<p>I want to decrypt next message:</p>

<pre><code>EB 54 DF DD 07 6D 7C 0F BD D6 D1 D1 90 C6 C7 80 92 F3 89 4D 6F 16 7C BF AA 3E 7C 48 A8 71 CF A2 BD D0 43 07 1D 65 B8 7F
</code></pre>

<p>My SessionKey (generated in Authentication step) is:</p>

<pre><code>44 E6 30 21 4A 89 57 38 61 7A B8 7C A9 91 B2 C0
</code></pre>

<p>I know the IV={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }</p>

<p>With this information, I can go <a href=""http://tripledes.online-domain-tools.com"" rel=""nofollow noreferrer"">here</a> and choosing 3DES, CBC mode, I can decrypt the message and I have means to know that it's right.
It should be, decrypted:</p>

<pre><code>10 1a 01 31 32 ae 03 de 39 b0 00 97 7f 65 e9 43 93 89 53 5c 9e 04 a9 3f 95 71 24 0f 0a 9b f7 ee d4 5b 1b c6 78 7a f4 36
</code></pre>

<p>Anyhow, I tried to implement the C code using OpenSSL des library and I find the next difficulty:</p>

<blockquote>
  <p>I need 3 Keys of 8 bytes each, but I have 1 SessionKey of 16 bytes
  long.</p>
</blockquote>

<p>I tried to split SessionKey into Key1/Key2/Key1 without success.
I have read so much about it, the only clue i found is that I have to generate those 3 keys from my 16byte SessionKey (taking it as a password) but I feel it is too advanced for me.
If this is the only way, is there any tutorial about ossl key derivation (evp_bytestokey)? Is there any other way?</p>

<h2>Thanks</h2>

<p>Edit:
So, right now I'm in a very weird spot. As noted by many of you, I had already taken first 8 bytes from Session Key as Key 3 (that's what I referred to with Key1/Key2/Key1). Anyway it seemed to not work, but slightly it did, which is what puzzles me.
I get:</p>

<pre><code>Decrypted : 11 1B 00 30 33 AF 02 DF DE 01 00 00 00 01 01 00 14 C1 26 8F 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 B1
</code></pre>

<p>When</p>

<pre><code>Expected : 10 1a 01 31 32 ae 03 de de 01 00 00 00 01 01 00 14 c1 26 8f 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 b1
</code></pre>

<p>So I get the expected result XORing first 8 bytes with 01. Does that make any sense?? As in OSSL docu it says: <em>Note that there is both a DES_cbc_encrypt() and a DES_ncbc_encrypt() in libcrypto. I recommend you only use the ncbc version (n stands for new). See the BUGS section of the OpenSSL DES manpage and the source code for these functions.</em>
But I have access only to older version... Could it be the problem??</p>
","<p>It's possible that you don't need 3 keys of 32bits, but only one of 3*32bits, with the bytes in the good order
Best regards</p>
","342","<encryption><openssl><rfid><mifare><3des>","1","0","3","2019-04-25 07:21:19","41553882","0","1","2425802","","2019-04-25 07:21:19","2017-01-09 16:35:23",""
"41552636","unable to decrypt 3DES with SessionKey","<p>I'm developing a C project to read/write Desfire Contactless Cards.
Right now I achieved to authenticate and I'm able to read data from the card, but it's encrypted with 3DES.</p>

<p>I want to decrypt next message:</p>

<pre><code>EB 54 DF DD 07 6D 7C 0F BD D6 D1 D1 90 C6 C7 80 92 F3 89 4D 6F 16 7C BF AA 3E 7C 48 A8 71 CF A2 BD D0 43 07 1D 65 B8 7F
</code></pre>

<p>My SessionKey (generated in Authentication step) is:</p>

<pre><code>44 E6 30 21 4A 89 57 38 61 7A B8 7C A9 91 B2 C0
</code></pre>

<p>I know the IV={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }</p>

<p>With this information, I can go <a href=""http://tripledes.online-domain-tools.com"" rel=""nofollow noreferrer"">here</a> and choosing 3DES, CBC mode, I can decrypt the message and I have means to know that it's right.
It should be, decrypted:</p>

<pre><code>10 1a 01 31 32 ae 03 de 39 b0 00 97 7f 65 e9 43 93 89 53 5c 9e 04 a9 3f 95 71 24 0f 0a 9b f7 ee d4 5b 1b c6 78 7a f4 36
</code></pre>

<p>Anyhow, I tried to implement the C code using OpenSSL des library and I find the next difficulty:</p>

<blockquote>
  <p>I need 3 Keys of 8 bytes each, but I have 1 SessionKey of 16 bytes
  long.</p>
</blockquote>

<p>I tried to split SessionKey into Key1/Key2/Key1 without success.
I have read so much about it, the only clue i found is that I have to generate those 3 keys from my 16byte SessionKey (taking it as a password) but I feel it is too advanced for me.
If this is the only way, is there any tutorial about ossl key derivation (evp_bytestokey)? Is there any other way?</p>

<h2>Thanks</h2>

<p>Edit:
So, right now I'm in a very weird spot. As noted by many of you, I had already taken first 8 bytes from Session Key as Key 3 (that's what I referred to with Key1/Key2/Key1). Anyway it seemed to not work, but slightly it did, which is what puzzles me.
I get:</p>

<pre><code>Decrypted : 11 1B 00 30 33 AF 02 DF DE 01 00 00 00 01 01 00 14 C1 26 8F 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 B1
</code></pre>

<p>When</p>

<pre><code>Expected : 10 1a 01 31 32 ae 03 de de 01 00 00 00 01 01 00 14 c1 26 8f 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 b1
</code></pre>

<p>So I get the expected result XORing first 8 bytes with 01. Does that make any sense?? As in OSSL docu it says: <em>Note that there is both a DES_cbc_encrypt() and a DES_ncbc_encrypt() in libcrypto. I recommend you only use the ncbc version (n stands for new). See the BUGS section of the OpenSSL DES manpage and the source code for these functions.</em>
But I have access only to older version... Could it be the problem??</p>
","<p>Perhaps the encryption is two-key 3DES, in that case repeat the first 8-bytes , bytes 0-7 as bytes 16-23: <code>44 E6 30 21 4A 89 57 38 61 7A B8 7C A9 91 B2 C0 44 E6 30 21 4A 89 57 38</code>.</p>

<p>Some 3DES implementations will do this automatically, some you must do it yourself.</p>

<p>If this does not work you will need to provide more information in the question.</p>
","342","<encryption><openssl><rfid><mifare><3des>","1","2","3","2019-04-25 07:21:19","41553882","0","1","2425802","","2019-04-25 07:21:19","2017-01-09 16:35:23",""
"41552636","unable to decrypt 3DES with SessionKey","<p>I'm developing a C project to read/write Desfire Contactless Cards.
Right now I achieved to authenticate and I'm able to read data from the card, but it's encrypted with 3DES.</p>

<p>I want to decrypt next message:</p>

<pre><code>EB 54 DF DD 07 6D 7C 0F BD D6 D1 D1 90 C6 C7 80 92 F3 89 4D 6F 16 7C BF AA 3E 7C 48 A8 71 CF A2 BD D0 43 07 1D 65 B8 7F
</code></pre>

<p>My SessionKey (generated in Authentication step) is:</p>

<pre><code>44 E6 30 21 4A 89 57 38 61 7A B8 7C A9 91 B2 C0
</code></pre>

<p>I know the IV={ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }</p>

<p>With this information, I can go <a href=""http://tripledes.online-domain-tools.com"" rel=""nofollow noreferrer"">here</a> and choosing 3DES, CBC mode, I can decrypt the message and I have means to know that it's right.
It should be, decrypted:</p>

<pre><code>10 1a 01 31 32 ae 03 de 39 b0 00 97 7f 65 e9 43 93 89 53 5c 9e 04 a9 3f 95 71 24 0f 0a 9b f7 ee d4 5b 1b c6 78 7a f4 36
</code></pre>

<p>Anyhow, I tried to implement the C code using OpenSSL des library and I find the next difficulty:</p>

<blockquote>
  <p>I need 3 Keys of 8 bytes each, but I have 1 SessionKey of 16 bytes
  long.</p>
</blockquote>

<p>I tried to split SessionKey into Key1/Key2/Key1 without success.
I have read so much about it, the only clue i found is that I have to generate those 3 keys from my 16byte SessionKey (taking it as a password) but I feel it is too advanced for me.
If this is the only way, is there any tutorial about ossl key derivation (evp_bytestokey)? Is there any other way?</p>

<h2>Thanks</h2>

<p>Edit:
So, right now I'm in a very weird spot. As noted by many of you, I had already taken first 8 bytes from Session Key as Key 3 (that's what I referred to with Key1/Key2/Key1). Anyway it seemed to not work, but slightly it did, which is what puzzles me.
I get:</p>

<pre><code>Decrypted : 11 1B 00 30 33 AF 02 DF DE 01 00 00 00 01 01 00 14 C1 26 8F 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 B1
</code></pre>

<p>When</p>

<pre><code>Expected : 10 1a 01 31 32 ae 03 de de 01 00 00 00 01 01 00 14 c1 26 8f 03 20 20 41 00 30 39 01 00 00 00 00 00 00 00 00 00 00 75 b1
</code></pre>

<p>So I get the expected result XORing first 8 bytes with 01. Does that make any sense?? As in OSSL docu it says: <em>Note that there is both a DES_cbc_encrypt() and a DES_ncbc_encrypt() in libcrypto. I recommend you only use the ncbc version (n stands for new). See the BUGS section of the OpenSSL DES manpage and the source code for these functions.</em>
But I have access only to older version... Could it be the problem??</p>
","<h3>Size of session key</h3>

<p>Since you refer to MIFARE DESFire and you are using a 16 byte session key, you probably use 2-key triple DES. This means that the 16 byte session key is actually two keys (8 bytes, or actually 56 bits, each with 8 unused ""parity"" bits).</p>

<p>In order to map this to 3DES with 3 keys, you simply need to append the first 8 bytes to the end of your session key, so that you get</p>

<pre>
                     +-------------------------+-------------------------+
16 byte session key: | 8 bytes                 | 8 bytes                 |
                     | 44 E6 30 21 4A 89 57 38 | 61 7A B8 7C A9 91 B2 C0 |
                     +-------------------------+-------------------------+-------------------------+
24 byte 3DES key:    | 8 bytes                 | 8 bytes                 | 8 bytes                 |
                     | 44 E6 30 21 4A 89 57 38 | 61 7A B8 7C A9 91 B2 C0 | 44 E6 30 21 4A 89 57 38 |
                     +-------------------------+-------------------------+-------------------------+
</pre>

<h3>First block of decrypted plaintext</h3>

<p>If the first 8 bytes of the decrypted plaintext differ from the expected value but the remaining bytes match, this is a clear indication that you are using an incorrect initialization vector for CBC mode.</p>

<p>Have a look at how CBC mode works:
<a href=""https://en.wikipedia.org/wiki/File:CBC_decryption.svg"" rel=""nofollow noreferrer""><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/601px-CBC_decryption.svg.png""></a></p>

<p>So for the first block, the plaintext is calculated as</p>

<pre>P<sub>0</sub> = Dec<sub>K</sub>(C<sub>0</sub>) XOR IV</pre>

<p>For the remaining blocks, the plaintext is calculated as</p>

<pre>P<sub>n</sub> = Dec<sub>K</sub>(C<sub>n</sub>) XOR C<sub>n-1</sub></pre>

<p>This means that only the decryption of the first block depends on the IV. The decryption of the remaining blocks depends on the preceding ciphertext instead.</p>

<p>Since you assumed the IV to be all zeros, the XOR operation does nothing. Hence, in your case, the plaintext of the first block is calculated as</p>

<pre>P<sub>0</sub> = Dec<sub>K</sub>(C<sub>0</sub>) XOR {0} = Dec<sub>K</sub>(C<sub>0</sub>) = '10 1A 01 31 32 AE 03 DE'</pre>

<p>As this expected value deviates from the actual value that you get (<code>'11 1B 00 30 33 AF 02 DF'</code>). This most likely means that you used an incorrect IV for decryption:</p>

<pre>P<sub>0</sub>  = Dec<sub>K</sub>(C<sub>0</sub>)        = '10 1A 01 31 32 AE 03 DE'
P'<sub>0</sub> = Dec<sub>K</sub>(C<sub>0</sub>) XOR IV = '11 1B 00 30 33 AF 02 DF'</pre>

<p>You can calculate the IV that you used by XORing the two values:</p>

<pre>P'<sub>0</sub> = P<sub>0</sub> XOR IV
P'<sub>0</sub> XOR P<sub>0</sub> = IV

IV = '11 1B 00 30 33 AF 02 DF' XOR '10 1A 01 31 32 AE 03 DE'
   = '01 01 01 01 01 01 01 01'
</pre>

<p>As this IV differs in exactly the LSB of each byte being set to one, I wonder if you accidentally used the method <code>DES_set_odd_parity()</code> on the IV. This would explain why the LSB (i.e. the parity bit if the value was a DES key) was changed.</p>
","342","<encryption><openssl><rfid><mifare><3des>","1","1","3","2019-04-25 07:21:19","41553882","0","1","2425802","","2019-04-25 07:21:19","2017-01-09 16:35:23",""
"33693256","Ruby 3DES implementation vs PHP mcrypt, different results","<p>I'm trying to migrate some legacy PHP code to ruby, and I've encountered a problem with some 3DES encryption. This is the PHP implementation using mcrypt:</p>

<pre><code>function encrypt_3DES($message, $key){

    $bytes = array(0,0,0,0,0,0,0,0); //byte [] IV = {0, 0, 0, 0, 0, 0, 0, 0}
    $iv = implode(array_map(""chr"", $bytes)); //PHP 4 &gt;= 4.0.2

    $ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv); 
    return $ciphertext;
}
</code></pre>

<p>and this is my ruby code:</p>

<pre><code>def encrypt_3DES(message, key)
  des=OpenSSL::Cipher.new('des3')
  des.encrypt
  des.key = key
  des.update(message)+des.final
end
</code></pre>

<p>However results are slightly different (base64 encoded):</p>

<pre><code>//PHP
ZpgH7NWpRx+Mi6tDBZ9q2Q==

# Ruby
ZpgH7NWpRx/usGDIsQ+A8A==
</code></pre>

<p>As you can see it's the lowest portion of the string's bytes that differs. Any pointers are much appreciated.</p>
","<p>Could the <code>PHP</code> combination of <code>MCRYPT_3DES</code> and <code>MCRYPT_MODE_CBC</code> not be equivalent to the ruby <code>OpenSSL</code> library's <code>3des</code> (or <code>des-ede3-cbc</code>). <a href=""https://stackoverflow.com/questions/19718060/des3-encryption-ruby-opensslcipher-vs-oracle-dbms-obfuscation-toolkit"">There are examples of other mismatches</a>. </p>

<p>Try one of the other modes, such as <code>des-ede-cbc</code> or <code>des-cbc</code> (See full list <a href=""http://www.openssl.org/docs/manmaster/apps/enc.html"" rel=""nofollow noreferrer"">here</a>)</p>
","338","<php><ruby><3des>","4","0","2","2015-11-16 12:53:00","33735883","0","","","","","2015-11-13 12:56:27",""
"33693256","Ruby 3DES implementation vs PHP mcrypt, different results","<p>I'm trying to migrate some legacy PHP code to ruby, and I've encountered a problem with some 3DES encryption. This is the PHP implementation using mcrypt:</p>

<pre><code>function encrypt_3DES($message, $key){

    $bytes = array(0,0,0,0,0,0,0,0); //byte [] IV = {0, 0, 0, 0, 0, 0, 0, 0}
    $iv = implode(array_map(""chr"", $bytes)); //PHP 4 &gt;= 4.0.2

    $ciphertext = mcrypt_encrypt(MCRYPT_3DES, $key, $message, MCRYPT_MODE_CBC, $iv); 
    return $ciphertext;
}
</code></pre>

<p>and this is my ruby code:</p>

<pre><code>def encrypt_3DES(message, key)
  des=OpenSSL::Cipher.new('des3')
  des.encrypt
  des.key = key
  des.update(message)+des.final
end
</code></pre>

<p>However results are slightly different (base64 encoded):</p>

<pre><code>//PHP
ZpgH7NWpRx+Mi6tDBZ9q2Q==

# Ruby
ZpgH7NWpRx/usGDIsQ+A8A==
</code></pre>

<p>As you can see it's the lowest portion of the string's bytes that differs. Any pointers are much appreciated.</p>
","<p>I answer my own question.</p>

<p>It was an issue about how openssl and mcrypt implementations use padding. My cryptography knowledge isn't too deep, but I found a usable code sample here <a href=""http://opensourcetester.co.uk/2012/11/29/zeros-padding-3des-ruby-openssl/"" rel=""nofollow"">http://opensourcetester.co.uk/2012/11/29/zeros-padding-3des-ruby-openssl/</a></p>

<pre><code>#ENCRYPTION
block_length = 8
des.padding = 0 #Tell Openssl not to pad
des.encrypt
json = '{""somekey"":""somevalue""}'
json += ""\0"" until json.bytesize % block_length == 0 #Pad with zeros
edata = des.update(json) + des.final 
b64data = Base64.encode64(edata).gsub(""\n"",'')
</code></pre>

<p>Basically, ruby openssl will use PKCS padding, while mcrypt uses 0 padding. So in our code I had to tell openssl not to pad the string with <code>des.padding = 0</code> and then do the padding manually: <code>json += ""\0"" until json.bytesize % block_length == 0</code>. </p>

<p>Those are the important bits that were missing in my original implementation.</p>
","338","<php><ruby><3des>","4","3","2","2015-11-16 12:53:00","33735883","0","","","","","2015-11-13 12:56:27",""
"35608521","Using CBC DES encryption in java card","<p>I am trying to encrypt data using Cipher class . I want to specify the initial vector so I use the following functions : </p>

<pre><code>try {
    cipherCBC = Cipher.getInstance(Cipher.ALG_DES_CBC_NOPAD, false);
    cipherCBC.init(k, Cipher.MODE_ENCRYPT,INITVECTOR,(short)0,(short)8);
    cipherCBC.doFinal(data, (short) 0, (short) data.length, result, (short) 0);
} catch (Exception e) {
    ISOException.throwIt(ISO7816.SW_CONDITIONS_NOT_SATISFIED);
}
</code></pre>

<p>with the byte array INITVECTOR initialised by a 8-byte array.</p>

<p>The problem is that I get always an exception caught when I use the init function.</p>

<p><strong>EXTRA INFO:</strong></p>

<p>The key is build here :</p>

<pre><code>octetsLus = (byte) (apdu.setIncomingAndReceive());
if (octetsLus != 16) {
    ISOException.throwIt(ISO7816.SW_WRONG_LENGTH);
}    

// build host crypto 
Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA+4),  message, (short) 0,(short) 4);
Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA+8),  message, (short) 4,(short) 4);
Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA),    message, (short) 8,(short) 4);
Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA+12), message, (short) 12,(short) 4);

// GENERATE SESSION KEYS 
encrypt_DES(ENC_key, message,(byte) 0x01);
Util.arrayCopy(result,(short) 0, ENC_SESS_KEY, (short) 0,(short) 16);

encrypt_DES(MAC_key, message,(byte) 0x01);
Util.arrayCopy(result,(short) 0, MAC_SESS_KEY, (short) 0,(short) 16);

ENC_key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES, KeyBuilder.LENGTH_DES3_2KEY, false);
ENC_key.setKey(ENC_SESS_KEY, (short) 0);

MAC_key = (DESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_DES, KeyBuilder.LENGTH_DES3_2KEY, false);
MAC_key.setKey(MAC_SESS_KEY, (short) 0);


 Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA), message, (short) 0,(short) 8); 
 Util.arrayCopy(buffer, (short)(ISO7816.OFFSET_CDATA+8), message, (short) 8,(short) 8);

   for(i=0;i&lt;8;i++)
     message[(short)(16+i)]=(byte)PADDING[i];
</code></pre>

<p>Concerning the initial vector, even if I use the following initialization, I get the same problem :</p>

<pre><code>INITVECTOR =new byte[]{(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00,(byte)0x00};
</code></pre>

<p>On the other hand, when I use the init function which use default initialization parameters the encrypt function works well:</p>

<pre><code>cipherCBC.init(k, Cipher.MODE_ENCRYPT);
</code></pre>
","","335","<encryption><javacard><3des><cbc-mode>","3","","0","2016-02-25 09:30:27","","7","0","3899583","","2016-02-25 09:30:27","2016-02-24 17:06:11",""
"41396883","Authentication Error: DESfire against SAM with 3DES algorithm","<p>I can't finish the authentication phase.
What I am using:
SAM module by NXP
Mifare Desfire PICC</p>

<p>I am following the next steps:</p>

<ol>
<li><p>Get PICC SerialNumber (or UID) with GetVersion.</p>

<p>GET VERSION:
Tx: 90 60 00 00 00
Rx: 04 01 01 00 02 18 05 91 AF</p>

<p>GET VERSION 2:
Tx: 90 AF 00 00 00 00
Rx: 04 01 01 00 06 18 05 91 AF</p>

<p>GET VERSION 3:
Tx: 90 AF 00 00 00 00
Rx: <strong><em>04 65 41 49 65 1B 80</em></strong> 8E 65 58 51 30 46 07 91 00</p></li>
<li><p>Get encrypted(RndB) from PICC.</p>

<p>Tx: 90 0A 00 00 01 00 00
Rx: 31 15 1A 19 DB ED CD 5A 91 AF</p></li>
<li><p>Send to SAM PICC_SN + ek(RndB).</p>

<p>Tx: 80 41 01 03 0F 80 1B 65 49 41 65 04 31 15 1A 19 DB ED CD 5A
Rx: 61 20</p></li>
<li><p>Get from SAM encrypted(RndA + RndB_rotated) + 1st half Session Key</p>

<p>Tx: 00 C0 00 00 20
Rx: F3 10 55 B1 D3 18 91 5B 92 48 16 1F E1 58 D5 CB E9 F3 51 04 41 8A 4E A5 A2 B5 67 CA FF D8 D2 35 90 00</p></li>
<li><p>Send PICC encrypted(RndA + RndB_rotated).</p>

<p>Tx: 90 AF 00 00 10 F3 10 55 B1 D3 18 91 5B 92 48 16 1F E1 58 D5 CB 00
Rx: 91 AE</p></li>
</ol>

<p>So, this is a guide I have received from my suplier, and i don't have explanations about the apdus used; some i have found them on the internet, some others i guessed.</p>

<p>What I need to know is what does the next command i use:
<strong>to SAM module: 80 41 01 03 Lc Data</strong>
I need to know what encryption it deploys, why it needs PICC's UID (is this the IV), how can i know RndB, and what is expecting the PICC to end the authentication.</p>

<p>Thanks</p>

<p>Pd: Sorry for the text's format, it seems I'm unable to use correctly the tools for posting, everything gets in the same line it's disgusting...</p>
","<p>I solved the problem and finished authentication.
The error was that i was requesting RndB encrypted with keyNo = 0, while corresponding key from SAM's key encryption should be keyNo = 2.
So:</p>

<pre><code>--&gt; 90 0A 00 00 01 02 00
&lt;-- 91 B6 08 CE 9F B5 34 3B 91 AF
</code></pre>

<p>Carrying on, i finnish authentication:</p>

<pre><code>--&gt; 90 AF 00 00 10 0F DC FA B6 37 5F 30 34 D7 93 2D A1 3D D6 11 10 00
&lt;-- E9 C2 F2 69 FE 38 78 28 91 00
</code></pre>

<p>But now I have the next problem. I've authenticated and I can read PICC's data but i'm afraid it's encrypted. I suppose it is encrypted with session key, so I need some apdu command to be sent to SAM, with data and session key, in order to decrypt data retrieved from PICC.
Am I right? if that is... which would be that SAM APDU?</p>
","328","<nfc><mifare><3des>","1","1","1","2017-02-02 18:53:19","41464805","0","2","","","","2016-12-30 13:15:14",""
"32882406","Des and 3Des with ecb in C# (from C)","<p>I've this C code and I have to write it in C#.</p>

<p>How can I write these ecb des and 3des functions in C#?</p>

<pre><code>/**
* Simple Single-Des Encryption procedure.
* Does not modify the input data.
* Encrypted result is returned in a separate buffer.
*
* @param pResult    (out) Result of the encrypted byte
* @param pData      (in)  One byte of input data
* @param pKey       (in)  The DES-key
*/

void DesEncrypt(void *pResult, const void *pData, KEY_1DES *pKey)
{
    memcpy(pResult, pData, 8);
    DES_key_schedule k;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey, &amp;k);
    DES_ecb_encrypt((const_DES_cblock *)pData, (const_DES_cblock *)pResult, &amp;k, DES_ENCRYPT);
}


/**
* Encrypts a byte using double length 3DES
*
* @param pResult    (out) Result of the decryption
* @param pData      (in)  One byte of input data
* @param pKey       (in)  The 3DES-key
*/

void DesEncrypt3Des(void *pResult, const void *pData, KEY_3DES *pKey)
{
    memcpy(pResult, pData, 8);
    //DES_set_key_checked()
    DES_key_schedule left;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey-&gt;left, &amp;left);
    DES_key_schedule right;
    DES_set_key_unchecked((const_DES_cblock *)&amp;pKey-&gt;right, &amp;right);
    DES_ecb3_encrypt((const_DES_cblock *)pData, (const_DES_cblock *)pResult, &amp;left, &amp;right, &amp;left, DES_ENCRYPT);
}
</code></pre>

<p>I'm asking this because there are a lot of way to do this and I have to be sure to use the same encrypt parameters.</p>
","<p>Why don't you just use <code>TripleDESCryptoServiceProvider</code> from <code>System.Security.Cryptography</code>?</p>

<pre><code>public static string Encrypt(string data, string pKey)
{
    TripleDESCryptoServiceProvider cryptor = new TripleDESCryptoServiceProvider();
    byte[] array = null;
    cryptor.Key = pKey;
    cryptor.Mode = CipherMode.ECB;
    ICryptoTransform encrypt = cryptor.CreateEncryptor();
    array = ASCIIEncoding.ASCII.GetBytes(data);
    string retVal = """";
    retVal = Convert.ToBase64String(encrypt.TransformFinalBlock(array, 0, array.Length));
    return retVal;
}
</code></pre>

<p>And for decryption use the same logic but instead call <code>CreateDecryptor()</code></p>
","328","<c#><c><converter><des><3des>","-1","0","1","2015-10-07 14:41:25","32995260","0","","","","","2015-10-01 08:02:49",""
"45536607","How to generate a 3DES ECB PHP compatible encrypted string from c#","<p>I need to pass a 3DES encrypted string to a php web page from c# and i'm having no luck.</p>

<p>In short the PHP code I am trying to convert is :</p>

<pre><code>    $message = $request-&gt;get('searchHash');
    $searchHash = base64_decode(rawurldecode($message));
    $key = $this-&gt;container-&gt;getParameter(""api_encryption_key"");
    $decrypted = mcrypt_decrypt(MCRYPT_3DES, $key, $searchHash, MCRYPT_MODE_ECB);
    //$data = unserialize($decrypted);
    $searchString = str_replace(""\x0"", '', $decrypted);
</code></pre>

<p>which I have re-wriiten as:</p>

<pre><code>        using (TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider())
        {
            byte[] iv0 = { 0, 0, 0, 0, 0, 0, 0, 0 };
            byte[] toEncryptArray = Encoding.ASCII.GetBytes(toEncrypt);

            tdes.IV = iv0;
            tdes.Key = Encoding.ASCII.GetBytes(key);
            tdes.Mode = CipherMode.ECB;
            tdes.Padding = PaddingMode.Zeros;

            ICryptoTransform cTransform = tdes.CreateEncryptor();

            byte[] resultArray =
                cTransform.TransformFinalBlock(toEncryptArray, 0,
                    toEncryptArray.Length);

            tdes.Clear();

            return resultArray.ToString();
        }
</code></pre>

<p>however the results from c# are not consistent with those of php.</p>

<p>Can anyone shed any light as to why?</p>

<p>Thanks.</p>
","<p>You need to return <code>Convert.ToBase64String(resultArray)</code> in the C# code. Returning <code>resultArray.ToString()</code> will give you <code>System.Byte[]</code> and not what you're expecting. The PHP code will then fail.</p>

<p>C#:</p>

<pre><code>string toEncrypt = ""SecretText"";
string key = ""SecretKeySecretKeySecret"";

using (TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider())
{
    byte[] iv0 = { 0, 0, 0, 0, 0, 0, 0, 0 };
    byte[] toEncryptArray = Encoding.ASCII.GetBytes(toEncrypt);

    tdes.IV = iv0;
    tdes.Key = Encoding.ASCII.GetBytes(key);
    tdes.Mode = CipherMode.ECB;
    tdes.Padding = PaddingMode.Zeros;

    ICryptoTransform cTransform = tdes.CreateEncryptor();

    byte[] resultArray =
        cTransform.TransformFinalBlock(toEncryptArray, 0,
            toEncryptArray.Length);

    tdes.Clear();

    string s = Convert.ToBase64String(resultArray);
}
</code></pre>

<p>PHP:</p>

<pre><code>&lt;?php
$message = ""b9ssRELdtRWVlNuJqaYUrg=="";
$searchHash = base64_decode(rawurldecode($message));
$key = ""SecretKeySecretKeySecret"";
$decrypted = mcrypt_decrypt(MCRYPT_3DES, $key, $searchHash, MCRYPT_MODE_ECB);
//$data = unserialize($decrypted);
$searchString = str_replace(""\x0"", '', $decrypted);

echo $searchString;
</code></pre>
","324","<c#><php><3des><mcrypt-ecb>","0","0","1","2017-08-06 22:50:34","","5","","","","","2017-08-06 21:02:23",""
"11957075","PHP TripleDES password encryption for registration form","<p>I need the expertise here, i been through many resources yet could not find the answer.</p>

<p>i am working on simple a login script with user registration, but could not find much help/</p>

<p>i would like to use 3des encryption on the passwords for new user registration, and able to login after registering.</p>
","<p>The commenter is correct, you do not encrypt passwords. You prepend a salt string that is created for the user (or a constant one for your app) to the password. You then hash the password with SHA1 or a better hashing algorithm. You store the hashed value and the salt (if it is per user). When the user authenticates, you take the password they give you, prepend the salt and hash that. Compare that to what was stored and if they match they used the correct password.</p>

<p>Better explanation here:
<a href=""http://phpsec.org/articles/2005/password-hashing.html"" rel=""nofollow"">http://phpsec.org/articles/2005/password-hashing.html</a></p>
","317","<php><phpmyadmin><3des>","0","0","1","2012-08-14 17:04:51","","3","","","","","2012-08-14 16:49:14",""
"47995507","_Crypt_EncryptData() and _Crypt_DecryptData() confusion","<p>I'm running into problems with <code>_Crypt_EncryptData()</code>. I want to encrypt data, store it, then read it back decrypted.</p>

<p>It seems  <a href=""https://www.autoitscript.com/autoit3/docs/libfunctions/_Crypt_EncryptData.htm"" rel=""nofollow noreferrer""><code>_Crypt_EncryptData()</code></a> and <a href=""https://www.autoitscript.com/autoit3/docs/libfunctions/_Crypt_DecryptData.htm"" rel=""nofollow noreferrer""><code>_Crypt_DecryptData()</code></a> are not symmetric; the former does an implicit hexadecimal encoding on the output value. But the latter does an implicit binary conversion on the input (so far so good), but then does an <em>implicit hexadecimal conversion</em> on its output! Hence within a single file:</p>

<pre><code>$ciphertext=_Crypt_EncryptData($cleartext, $g_hKey, $CALG_3DES)
$cleartext=_HexToString(_Crypt_DecryptData($ciphertext, $g_hKey, $CALG_3DES))
</code></pre>

<p>(erk!) will give me back the original cleartext. I was unable to recover the cleartext from a file across invocations. The ciphertext was changing each time, e.g. with the string ""This is a test"", on subsequent executions I got:</p>

<pre><code> 0x0B656F9BCC35B73A6EA9D08701E78713
 0xEBE1E744668C379CE74480C3A56303A2
 0x25F50D6B833B3CEF60FCFAF8AE673CF3
</code></pre>

<p>I would expect this if due to different initialization vectors, however looking at ""Crypt.au3"" I see no way to set or get the IV (I know DES3 is insecure - that's a different battle). Is it me or is it AutoIt?</p>

<p>Here is the full source of a script to reproduce the issue:</p>

<pre><code>#include &lt;StringConstants.au3&gt;
#include &lt;Crypt.au3&gt;
#include &lt;String.au3&gt;

_Crypt_Startup() 
$inifile=""C:\test_au_enc.ini""
$g_hKey = _Crypt_DeriveKey(""s3cr3t.S4uce"", $CALG_3DES)

; test previous invocation
$readback=IniRead($inifile, ""main"", ""pass"", ""Failed"")
if (""Failed""=$readback) Then
   MsgBox(0, ""Enc Dec"", ""Failed to read ini file"")
Else
   $dec=_HexToString(_Crypt_DecryptData($readback, $g_hKey, $CALG_3DES))
   MsgBox(0,""Enc Dec"", ""Read from previous: "" &amp; $dec)
   ; this fails to recover the cleartext
EndIf


$subj=InputBox(""Enc Dec"", ""Please supply a string to encrypt"", ""This is a test"");

; encrypt the string and write it to a file...
$enc=_Crypt_EncryptData($subj, $g_hKey, $CALG_3DES)
IniWrite($inifile, ""main"", ""pass"", $enc)

; now read back the value and decrypt
$readback=IniRead($inifile, ""main"", ""pass"", ""Failed"")
$dec=_HexToString(_Crypt_DecryptData($readback, $g_hKey, $CALG_3DES))
InputBox(""Enc Dec"", ""Encrypted:"" &amp; $enc &amp; @CRLF &amp; ""decrypted:"" &amp; $dec, $enc)
; here the decrypted text matches the cleartext 
</code></pre>
","<p>As per <a href=""https://www.autoitscript.com/autoit3/docs/libfunctions/_Crypt_EncryptData.htm"" rel=""nofollow noreferrer"">help file</a>; use of <code>_Crypt_DeriveKey()</code> is correct, but you are supposed to call <code>_Crypt_EncryptData()</code> and <code>_Crypt_DecryptData()</code> like this when using your own derived key:</p>

<pre><code>$enc = _Crypt_EncryptData($subj, $g_hKey, $CALG_USERKEY)
$dec = _HexToString(_Crypt_DecryptData($readback, $g_hKey, $CALG_USERKEY))
</code></pre>

<p>Difference being <code>$CALG_USERKEY</code> for the <code>$iAlgID</code> parameter, which tells to treat the <code>$vCryptKey</code> parameter as a handle to a key instead of a password. This appears to work as intended.</p>

<p>Here is the full code:</p>

<pre><code>#include &lt;StringConstants.au3&gt;
#include &lt;Crypt.au3&gt;
#include &lt;String.au3&gt;

_Crypt_Startup()
$inifile=""C:\test_au_enc.ini""
$g_hKey = _Crypt_DeriveKey(""s3cr3t.S4uce"", $CALG_3DES)

; test previous invocation
$readback=IniRead($inifile, ""main"", ""pass"", ""Failed"")
if (""Failed""=$readback) Then
   MsgBox(0, ""Enc Dec"", ""Failed to read ini file"")
Else
   $dec=_HexToString(_Crypt_DecryptData($readback, $g_hKey, $CALG_USERKEY))
   MsgBox(0,""Enc Dec"", ""Read from previous: "" &amp; $dec)
   ; this fails to recover the cleartext
EndIf


$subj=InputBox(""Enc Dec"", ""Please supply a string to encrypt"", ""This is a test"");

; encrypt the string and write it to a file...
$enc=_Crypt_EncryptData($subj, $g_hKey, $CALG_USERKEY)
IniWrite($inifile, ""main"", ""pass"", $enc)

; now read back the value and decrypt
$readback=IniRead($inifile, ""main"", ""pass"", ""Failed"")
$dec=_HexToString(_Crypt_DecryptData($readback, $g_hKey, $CALG_USERKEY))
InputBox(""Enc Dec"", ""Encrypted:"" &amp; $enc &amp; @CRLF &amp; ""decrypted:"" &amp; $dec, $enc)
; here the decrypted text matches the cleartext
</code></pre>
","307","<encryption><autoit><3des>","0","1","1","2018-01-17 07:44:56","47996970","0","","4157124","","2018-01-17 02:17:39","2017-12-27 16:28:55",""
"16473097","Porting C# CryptoSys-assisted 3DES encryption to Objective-C CommonCrypto issues","<p>I am currently working on an iPhone app that is a port of a subset of .NET C# functionality. I must log into a server using a 3DES encrypted password (yes, I know that is not an optimal standard, but please bear with me).</p>

<p>So far, however, no joy. I cannot properly replicate the encryption in this C# code. The code in both C# in objective-c shares these common variables:</p>

<ol>
<li><code>strPassword</code> is the unencrypted password, like ""secret""</li>
<li><code>abPlain</code> is a byte array with the hex values of strPassword <code>{73, 65, 63, 72, 65, 74, 02, 02}</code></li>
<li><code>rpmPassword</code> is a string of random characters.</li>
<li><code>rpmPasswordAsData</code> is the objective-C only representation of rpmPassword as NSData using UTF8 encoding</li>
<li><code>abPassword</code> is a byte array with the values of rpmPassword</li>
<li>I've added the code to derive <code>nLen</code> in the objective-C code below</li>
</ol>

<p>Here's the C# code first:</p>

<pre><code>static int ITERATIONCOUNT = 2048;
static int KEYBYTES = 24;
static int BLOCKBYTES = 8;

byte[] abInitV = CryptoSysAPI.Rng.NonceBytes(BLOCKBYTES);
byte[] abKey = CryptoSysAPI.Pbe.Kdf2(KEYBYTES, abPassword, abInitV, ITERATIONCOUNT);

CryptoSysAPI.Tdea cipher = CryptoSysAPI.Tdea.Instance();
cipher.InitEncrypt(abKey, Mode.CBC, abInitV);

byte[] abCipher = cipher.Update(abPlain);

abOutput = new byte[abCipher.Length + BLOCKBYTES];
for (int i = 0; i &lt; BLOCKBYTES; i++) abOutput[i] = abInitV[i];
for (int i = 0; i &lt; nLen + nPad; i++) abOutput[BLOCKBYTES + i] = abCipher[i];

return CryptoSysAPI.Cnv.ToHex(abOutput)
</code></pre>

<p>As you can see, the encrypted value this returns is actually a concatenation of the hex values of <code>abInitV</code> and <code>abCipher</code>.</p>

<p>I have been cribbing from Rob Napier to try and transform this into working objective-c code, but so far, it's not happening. I am producing <code>abInitV</code> and <code>abCipher</code> values of the right length, and I'm also concatenating them properly into <code>abOutput</code>, but I am being rejected by the server when I try to log in.</p>

<p>Here's my objective-c code (the constants are also declared, I promise):</p>

<pre><code>int nLen = [strPassword length];
int nPad = ((nLen / BLOCKBYTES) + 1) * BLOCKBYTES - nLen;

NSData *abInitV = [self randomDataOfLength:BLOCKBYTES]; // This is the salthex for the encryption
const unsigned char *abInitVAsBytes = [abInitV bytes];

NSData *abKey = [self TDEAKeyForPassword:strPassword salt:abInitV];

size_t movedBytes = 0;    
NSMutableData *abCipher = [NSMutableData dataWithLength:BLOCKBYTES];

CCCryptorStatus result = CCCrypt(kCCEncrypt,
                                 kCCAlgorithm3DES,
                                 ccNoPadding &amp; kCCModeCBC,
                                 [abKey bytes],
                                 kCCKeySize3DES,
                                 [abInitV bytes],
                                 abPassword,
                                 [rpmPasswordAsData length],
                                 abCipher.mutableBytes,
                                 KEYBYTES,
                                 &amp;movedBytes);

if (result == kCCSuccess)
{
   NSLog(@""abCipher == %@ \n"", [abCipher description] ); 
}

NSMutableData *abOutput = [NSMutableData dataWithCapacity:[abCipher length] + BLOCKBYTES];
const unsigned char *abCipherAsBytes = [abCipher bytes];

for (int i = 0; i &lt; BLOCKBYTES; i++)
{
    [abOutput replaceBytesInRange:NSMakeRange(i, sizeof(abInitVAsBytes[i])) withBytes:&amp;abInitVAsBytes[i]];
}
for (int i = 0; i &lt; nLen + nPad; i++)
{
    [abOutput replaceBytesInRange:NSMakeRange(BLOCKBYTES + i, sizeof(abCipherAsBytes[i])) withBytes:&amp;abCipherAsBytes[i]];        
}

return [EncryptionUtil NSDataToHex:abOutput];
</code></pre>

<p>And here are the supporting methods called in the code above:</p>

<pre><code>+(NSString*) NSDataToHex:(NSData*)data
{
    const unsigned char *dbytes = [data bytes];
    NSMutableString *hexStr =
    [NSMutableString stringWithCapacity:[data length]*2];
    int i;
    for (i = 0; i &lt; [data length]; i++) {
        [hexStr appendFormat:@""%02x "", dbytes[i]];
    }
    return [NSString stringWithString: hexStr];
}

+(NSData*)HexToNSData:(NSString*)hex
{
    NSMutableData* data = [NSMutableData data];
    int idx;
    for (idx = 0; idx+2 &lt;= [hex length]; idx+=2) {
        NSRange range = NSMakeRange(idx, 2);
        NSString* hexStr = [hex substringWithRange:range];
        NSScanner* scanner = [NSScanner scannerWithString:hexStr];
        unsigned int intValue;
        [scanner scanHexInt:&amp;intValue];
        [data appendBytes:&amp;intValue length:1];
    }
    return data;
}

+(NSData *)randomDataOfLength:(size_t)length
{
    NSMutableData *data = [NSMutableData dataWithLength:length];

    int result = SecRandomCopyBytes(kSecRandomDefault,
                                length,
                                data.mutableBytes);

    NSAssert(result == 0, @""Unable to generate random bytes: %d"",
         errno);

    return data;
}

+(NSData *)TDEAKeyForPassword:(NSString *)password
                     salt:(NSData *)salt
{
    NSMutableData *
    derivedKey = [NSMutableData dataWithLength:kCCKeySize3DES];

    int result = CCKeyDerivationPBKDF(kCCPBKDF2,            // algorithm
                                  password.UTF8String,  // password
                                  password.length,  // passwordLength
                                  salt.bytes,           // salt
                                  salt.length,          // saltLen
                                  kCCPRFHmacAlgSHA1,    // PRF
                                  ITERATIONCOUNT,         // rounds
                                  derivedKey.mutableBytes, // derivedKey
                                  derivedKey.length); // derivedKeyLen

    return derivedKey;
}
</code></pre>

<p>So, if anyone can tell me what I'm doing wrong, I'd sincerely appreciate it. If I had to hazard a guess, I'd assume the problem is in one of 2 places:</p>

<ol>
<li>Generating the key, either in the call to, or code of <code>TDEAKeyForPassword</code></li>
<li>Calling <code>CCCrypt</code>.</li>
</ol>

<p>That said, I've tried every available PRF constant, as well as padding and no padding.</p>

<p>I'm very inexperienced with encryption, so I'd appreciate any help anyone can offer.</p>

<p>Thanks!</p>
","<p>First, your code samples seem very different. The C# code is encrypting <code>abPlain</code>. The ObjC code is encrypting <code>abPassword</code>. You indicate that <code>abPlain</code> is static, while <code>abPassword</code> is random. You have some kind of padding going on in the ObjC that I don't see in the C# (maybe this is 0 padding? That's not a standard way to pad.)</p>

<p>If you remove the randomness, then each implementation should return exactly the same result for the same input. So first, hard-code a random value (I generally like to use 0, which is just as random as any other number), and also choose a common <code>abPassword</code>. Then, at each step of the process, make sure that both implementations generate the same result. Most significantly, is <code>abKey</code> the same, and then is <code>abCipher</code>, and finally is <code>abOutput</code>. At one of these points your implementations clearly diverge. (From my quick reading, they seem to be doing very different things all along.)</p>

<p>One thing that is very confusing is how you switch between <code>abPassword</code> and <code>rpmPassword</code>. In one case you pass <code>abPassword</code>, but the length of <code>rpmPasswordAsData</code>. That feels like a place where it's easy to make a mistake.</p>

<p>The length of <code>abPassword</code> is unclear. I assume it's a multiple of 8, or else your <code>ccNoPadding</code> is going to blow up.</p>

<p><code>NSMutableData</code> has an <code>appendData</code> method. That's much easier than your <code>replaceBytesInRange:…</code></p>
","302","<c#><objective-c><encryption><3des>","3","0","1","2013-05-11 00:40:53","16492649","2","0","2367930","","2013-05-10 12:57:57","2013-05-09 23:59:40",""
"50802241","3DES Encryption result different from example","<p>I have an example for a 3DES encryption that I have to follow in order to authenticate on NFC cards. Here is the example:<a href=""https://i.stack.imgur.com/x4Y3y.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/x4Y3y.png"" alt=""enter image description here""></a></p>

<p>So 51E764602678DF2B becomes 577293FD2F34CA51 with key = 49454D4B41455242214E4143554F5946 and IV = 0000000000000000
I succeed to have the right result on this site:
<a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a></p>

<p>I tried on swift with <a href=""https://github.com/sgl0v/SCrypto"" rel=""nofollow noreferrer"">https://github.com/sgl0v/SCrypto</a> as follow:</p>

<pre><code>func testScrypto() {
    let plaintext = ""51E764602678DF2B"".data(using: String.Encoding.utf8)!
    let sharedSecretKey = ""49454D4B41455242214E4143"".data(using: String.Encoding.utf8)!
    let IV = ""0000000000000000"".data(using: String.Encoding.utf8)!

    let ciphertext = try! plaintext.encrypt(.tripleDES, options: .PKCS7Padding, key: sharedSecretKey, iv: IV)     

    let plaintext2 = try! ciphertext.decrypt(.tripleDES, options: .PKCS7Padding, key: sharedSecretKey, iv: IV)

    print(""cipher = \(ciphertext.hexString())"")
    print(""plaintext2 = \(plaintext2.hexString())"")
}

public extension Data {

func bytesArray&lt;T: ExpressibleByIntegerLiteral&gt;() -&gt; [T] {
    var bytes = Array&lt;T&gt;(repeating: 0, count: self.count)
    (self as NSData).getBytes(&amp;bytes, length:self.count * MemoryLayout&lt;T&gt;.size)
    return bytes
}

func hexString() -&gt; String {
    let hexString = NSMutableString()
    let bytes: [UInt8] = self.bytesArray()
    for byte in bytes {
        hexString.appendFormat(""%02x"", UInt(byte))
    }
    return hexString as String
}
}
</code></pre>

<p>and the result is:</p>

<pre><code>cipher = d4c4a9637bcb4a435982330a42d1357b9e4539886a983535
plaintext2 = 35314537363436303236373844463242
</code></pre>

<p>35314537363436303236373844463242 is 51E764602678DF2B if i convert from hexstring to plaintext but the other string is not 577293FD2F34CA51 at all</p>

<p>I also tried this lib <a href=""https://www.example-code.com/swift/crypt2_3des.asp"" rel=""nofollow noreferrer"">https://www.example-code.com/swift/crypt2_3des.asp</a> 
but the result is still wrong</p>

<p>I don't know if anybody has an idea how to do this on swift or is an expert in encryption ?</p>

<p>thanks !</p>
","<p>The plaintext data and key that have been provided are encoded in hexadecimals. You are however encoding them as UTF-8 text, which is not the same thing.</p>
","300","<swift><encryption><encoding><character-encoding><3des>","0","0","2","2019-10-23 08:00:48","50819968","0","","1252438","","2018-06-12 08:01:52","2018-06-11 16:27:48",""
"50802241","3DES Encryption result different from example","<p>I have an example for a 3DES encryption that I have to follow in order to authenticate on NFC cards. Here is the example:<a href=""https://i.stack.imgur.com/x4Y3y.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/x4Y3y.png"" alt=""enter image description here""></a></p>

<p>So 51E764602678DF2B becomes 577293FD2F34CA51 with key = 49454D4B41455242214E4143554F5946 and IV = 0000000000000000
I succeed to have the right result on this site:
<a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a></p>

<p>I tried on swift with <a href=""https://github.com/sgl0v/SCrypto"" rel=""nofollow noreferrer"">https://github.com/sgl0v/SCrypto</a> as follow:</p>

<pre><code>func testScrypto() {
    let plaintext = ""51E764602678DF2B"".data(using: String.Encoding.utf8)!
    let sharedSecretKey = ""49454D4B41455242214E4143"".data(using: String.Encoding.utf8)!
    let IV = ""0000000000000000"".data(using: String.Encoding.utf8)!

    let ciphertext = try! plaintext.encrypt(.tripleDES, options: .PKCS7Padding, key: sharedSecretKey, iv: IV)     

    let plaintext2 = try! ciphertext.decrypt(.tripleDES, options: .PKCS7Padding, key: sharedSecretKey, iv: IV)

    print(""cipher = \(ciphertext.hexString())"")
    print(""plaintext2 = \(plaintext2.hexString())"")
}

public extension Data {

func bytesArray&lt;T: ExpressibleByIntegerLiteral&gt;() -&gt; [T] {
    var bytes = Array&lt;T&gt;(repeating: 0, count: self.count)
    (self as NSData).getBytes(&amp;bytes, length:self.count * MemoryLayout&lt;T&gt;.size)
    return bytes
}

func hexString() -&gt; String {
    let hexString = NSMutableString()
    let bytes: [UInt8] = self.bytesArray()
    for byte in bytes {
        hexString.appendFormat(""%02x"", UInt(byte))
    }
    return hexString as String
}
}
</code></pre>

<p>and the result is:</p>

<pre><code>cipher = d4c4a9637bcb4a435982330a42d1357b9e4539886a983535
plaintext2 = 35314537363436303236373844463242
</code></pre>

<p>35314537363436303236373844463242 is 51E764602678DF2B if i convert from hexstring to plaintext but the other string is not 577293FD2F34CA51 at all</p>

<p>I also tried this lib <a href=""https://www.example-code.com/swift/crypt2_3des.asp"" rel=""nofollow noreferrer"">https://www.example-code.com/swift/crypt2_3des.asp</a> 
but the result is still wrong</p>

<p>I don't know if anybody has an idea how to do this on swift or is an expert in encryption ?</p>

<p>thanks !</p>
","<p>I succeed to fix the issue
The issue was that the key was only 16 bytes and need to be 24, so I guess it was randomly filled but it was expected to be the first 8 bytes to be put back at the end of the 16 in order to do 24 ?</p>

<p>like this it works:</p>

<pre><code>func fillKey(keyLength: size_t, key: Data) -&gt; Data {
    let missingBytes = keyLength - key.count
    if missingBytes &gt; 0 {
        let keyBytes = (key as NSData).bytes
        var bytes = [UInt8](repeating: UInt8(0), count: keyLength)
        memccpy(&amp;bytes[0], keyBytes.advanced(by: 0), Int32(key.count), key.count)
        memccpy(&amp;bytes[key.count], keyBytes.advanced(by: 0), Int32(missingBytes), missingBytes)
        return Data(bytes: bytes)
    } else {
        return key
    }
}

func my3DESEncrypt(encryptData: String, key: String, iv: String) -&gt; Data? {
    var myKeyData : Data = key.hexadecimal()!
    let myIvData : Data = iv.hexadecimal()!
    var myRawData : Data = encryptData.hexadecimal()!
    let buffer_size : size_t = myRawData.count + kCCBlockSize3DES
    var buffer = [UInt8](repeating: UInt8(0), count: buffer_size)
    var num_bytes_encrypted : size_t = 0

    let operation: CCOperation = UInt32(kCCEncrypt)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
    let options:   CCOptions   = 0
    let keyLength        = size_t(kCCKeySize3DES)

    myKeyData = self.fillKey(keyLength: keyLength, key: myKeyData)
    let Crypto_status: CCCryptorStatus = CCCrypt(operation, algoritm, options, (myKeyData as NSData).bytes, keyLength, (myIvData as NSData).bytes, (myRawData as NSData).bytes, myRawData.count, &amp;buffer, buffer_size, &amp;num_bytes_encrypted)
    if UInt32(Crypto_status) == UInt32(kCCSuccess) {
        let data = Data(bytes: buffer, count: num_bytes_encrypted)
        return data
    } else{
        return nil
    }
}


func my3DESDecrypt(decryptData : Data, key: String, iv: String) -&gt; Data? {
    let mydata_len : Int = decryptData.count
    var myKeyData : Data = key.hexadecimal()!
    let myIvData : Data = iv.hexadecimal()!

    let buffer_size : size_t = mydata_len+kCCBlockSize3DES
    var buffer = [UInt8](repeating: UInt8(0), count: buffer_size)
    var num_bytes_encrypted : size_t = 0

    let operation: CCOperation = UInt32(kCCDecrypt)
    let algoritm:  CCAlgorithm = UInt32(kCCAlgorithm3DES)
    let options:   CCOptions   = UInt32(kCCOptionPKCS7Padding)
    let keyLength        = size_t(kCCKeySize3DES)


    myKeyData = self.fillKey(keyLength: keyLength, key: myKeyData)
    let decrypt_status : CCCryptorStatus = CCCrypt(operation, algoritm, options, (myKeyData as NSData).bytes, keyLength, (myIvData as NSData).bytes, (decryptData as NSData).bytes, mydata_len, &amp;buffer, buffer_size, &amp;num_bytes_encrypted)

    if UInt32(decrypt_status) == UInt32(kCCSuccess){
        let data = Data(bytes: buffer, count: num_bytes_encrypted)
        return data
    } else{
        return nil

    }
}
</code></pre>
","300","<swift><encryption><encoding><character-encoding><3des>","0","1","2","2019-10-23 08:00:48","50819968","0","","1252438","","2018-06-12 08:01:52","2018-06-11 16:27:48",""
"43804556","openssl equivalent for TripleDESCryptoServiceProvider","<p>I have some C# code for encrypting and decrypting using TripleDES. I've reduced it to a minimal example for posting.</p>

<pre><code>using System;
using System.Security;
using System.Security.Cryptography;
using System.IO;
using System.Text;

class TDes
{
    static void Main() {
        string key = ""ABCDEF0123456789"";
        string iv = ""ABCDEF01"";

        TDes tdes = new TDes(key, iv);

        string dataToDecrypt = ""x9iWzVc4FfU="";
        string decrypted = tdes.Decrypt(dataToDecrypt,key);
        Console.WriteLine(decrypted);

        string dataToEncrypt = ""abcdegf"";
        string encrypted = tdes.Encrypt(dataToEncrypt, key);
        Console.WriteLine(encrypted);
    }

    public TripleDESCryptoServiceProvider TdesProvider;

    public TDes(string Key, string IV)
    {
        TdesProvider = new TripleDESCryptoServiceProvider();
        TdesProvider.Key = System.Text.ASCIIEncoding.ASCII.GetBytes(Key);
        TdesProvider.IV = System.Text.ASCIIEncoding.ASCII.GetBytes(IV);
    }

    public string Decrypt(string Source, string Key)
    {
        long lLen;
        int nRead, nReadTotal;
        byte[] buf = new byte[3];
        byte[] decData;
        byte[] encData;
        System.IO.MemoryStream sin;
        System.IO.MemoryStream sout;
        CryptoStream decStream;

        encData = System.Convert.FromBase64String(Source);
        sin = new MemoryStream(encData);
        sout = new MemoryStream();

        decStream = new CryptoStream(sin,
            TdesProvider.CreateDecryptor(),
            CryptoStreamMode.Read);

        lLen = sin.Length;
        nReadTotal = 0;
        while (nReadTotal &lt; lLen)
        {
            nRead = decStream.Read(buf, 0, buf.Length);
            if (0 == nRead) break;

            sout.Write(buf, 0, nRead);
            nReadTotal += nRead;
        }
        decStream.Close();

        decData = sout.ToArray();

        ASCIIEncoding ascEnc = new ASCIIEncoding();
        return ascEnc.GetString(decData);
    }

    public string Encrypt(string Source, string Key)
    {
        long lLen;
        int nRead, nReadTotal;
        byte[] buf = new byte[3];
        byte[] srcData;
        byte[] encData;
        System.IO.MemoryStream sin;
        System.IO.MemoryStream sout;
        CryptoStream encStream;

        srcData = System.Text.ASCIIEncoding.ASCII.GetBytes(Source);
        sin = new MemoryStream();
        sin.Write(srcData,0,srcData.Length);
        sin.Position = 0;
        sout = new MemoryStream();

        encStream = new CryptoStream(sout,
            TdesProvider.CreateEncryptor(),
            CryptoStreamMode.Write);
        lLen = sin.Length;
        nReadTotal = 0;
        while (nReadTotal &lt; lLen)
        {
            nRead = sin.Read(buf, 0, buf.Length);
            encStream.Write(buf, 0, nRead);
            nReadTotal += nRead;
        }
        encStream.Close();

        encData = sout.ToArray();
        return System.Convert.ToBase64String(encData);
    }
}
</code></pre>

<p>This works(in the sense that it can decrypt what it encrypts with the same key and iv). However, I have been failing to come up with the equivalent in openssl. Most recent thing I've tried:</p>

<pre><code>echo abcdefg | openssl enc -e -des-ede3-cbc -a -k ABCDEF0123456789 -iv ABCDEF01
U2FsdGVkX1+o9K0itpYTEqGfyMjN8gARTYIDB2ZHg1U=
</code></pre>

<p>The C# code produced a VERY different result of <code>x9iWzVc4FfU=</code> Likewise if I feed <code>x9iWzVc4FfU=</code> into the inverse openssl command it barfs. </p>

<p>I'm pulling my hair out on this. The c# code is unchangeable. Needs to be openssl as I'm using php. </p>
","<p>There’s a few things:</p>

<ol>
<li><p>A typo. In your C# you are encrypting ""abcdegf"", in your OpenSSL you are using ""abcdefg"" (note the order of <code>f</code> and <code>g</code>).</p></li>
<li><p><code>echo</code> adds a newline to what it outputs. Use <code>echo -n</code> to get the same result as your code (check that your <code>echo</code> actually has the <code>-n</code> option, or use <code>printf</code> when encrypting).</p></li>
<li><p>You want the <a href=""https://wiki.openssl.org/index.php/Enc#Options"" rel=""nofollow noreferrer"">command line option <code>-K</code> rather than <code>-k</code></a>. <code>-k</code> specifies a <em>password</em> which is put through a KDF function, you want to specify the key directly.</p></li>
<li><p>Your C# code uses the ASCII bytes of the key and IV strings. The OpenSSL command line interprets them as hex encoded strings. What you want to use on the command line is <code>41424344454630313233343536373839</code> for the key (the hex encoding of the bytes making up “ABCDEF0123456789”) and <code>4142434445463031</code> for the IV (the hex encoding of “ABCDEF01”).</p></li>
<li><p>Your key is 16 bytes long. This means that the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledes(v=vs.110).aspx#Remarks"" rel=""nofollow noreferrer"">C# code is using “2 key” 3DES</a>. In OpenSSL you need to specify this explicitly with <code>des-ede-cbc</code> (note the lack of <code>3</code>).</p></li>
</ol>

<p>So combining all these, to replicate what your C# code does you need something like this:</p>

<pre><code>$ echo -n abcdegf | openssl enc -e -des-ede-cbc -a -K 41424344454630313233343536373839 -iv 4142434445463031
x9iWzVc4FfU=
</code></pre>
","289","<c#><php><encryption><openssl><3des>","2","3","1","2017-05-05 12:41:45","43805268","9","2","","","","2017-05-05 12:07:52",""
"32010915","Triple-DES DUKPT CBC PIN variant vs Data variant","<p>Does any know the difference between triple des dukpt decryption algorithm with PIN variant and Data variant? </p>

<p>I have done Triple DESK DUKPT PIN variant, which generate session key from <strong>KSN</strong> and <strong>BDK</strong>. And then decrypt message using the session key. </p>

<p>How about Data variant? How is it different from PIn variant? Thank you</p>
","","282","<encryption><3des><cbc-mac><dukpt>","2","","0","2015-08-14 15:35:06","","1","","4746911","","2015-08-14 15:35:06","2015-08-14 13:09:50",""
"31836361","3des and AES256 encryption of hex strings in java","<p>I've never used encryption algorithms before and i don't know how to do so. I have a hex string of length=32 that i want to encrypt and then decrypt with 3des or aes256.I also have the key to use, that is in hex format too, but it's length varies. Is someone familiar with this and/or has code for this implementation? I've found some codes here, but i don't exactly understand the implementation and the difference when hex values are used.</p>
","<p>Firstly AES does not encrypt using a 256 bit keyspace, they downsized it to 128 bit, but rijndahl does.
If you do go with rijndahl, remember to use a 32 byte key (32 characters) and a 32 byte blockcipher.
I would recommend using the GNU implementation which can be found here:
<a href=""http://www.gnu.org/software/gnu-crypto/"" rel=""nofollow"">http://www.gnu.org/software/gnu-crypto/</a></p>

<p>I hope this helps.</p>
","282","<java><encryption><hex><aes><3des>","-2","0","1","2015-08-05 15:33:12","","1","","4243712","","2015-08-05 15:33:12","2015-08-05 15:11:37",""
"50087909","triple des cbc encryption in C","<p>How I can decrypt by <code>DES_ENCRYPT</code> in c using <code>openssl</code> library.
I found the following function to decrypt and it worked fine when the lengh of key is 8 byte! But when I use 16 byte key, it results wrong value!</p>

<pre><code>int CBC_3Des_Decrypt(char *data, char *okey)
{
DES_key_schedule ks;
DES_cblock ivec = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

int i = 0;
int len = 0;
int nlen = 0;

unsigned char ch = '\0';
unsigned char *ptr = NULL;

unsigned char src[16] = {0};
unsigned char dst[16] = {0};

unsigned char block[8] = {0};

ptr = hex2bin(okey, strlen(okey), &amp;nlen);
memcpy(block, ptr, 8);
free(ptr);
DES_set_key_unchecked((const_DES_cblock*)block, &amp;ks);

len = strlen((char *)data);
ptr = hex2bin(data, len, &amp;nlen);
len = (nlen / 8 + (nlen % 8 ? 1: 0)) * 8;
memcpy(src, ptr, len);
free(ptr);

ch = 8 - nlen % 8;
memset(src + nlen, ch, 8 - nlen % 8);

for (i = 0; i &lt; len; i++) {
    TRACE((""%.2X"", *(src + i)));
}

DES_ncbc_encrypt(src, dst, sizeof(src), &amp;ks, &amp;ivec, DES_DECRYPT);

for (i = 0; i &lt; len; i++) {
    TRACE((""%.2X"", *(dst + i)));
}

return 0;
}
</code></pre>

<p>How I can decrypt or encrypt using this library with 16 byte key?</p>
","<p>The call you're making (<code>DES_ncbc_encrypt</code>) is the DES algorithm, not 3DES. I suspect you meant to call <code>DES_ede3_cbc_encrypt</code>.</p>

<p>It's important not to confuse DES and 3DES (""triple DES""). They're related algorithms, but not the same. Inside of OpenSSL, 3DES is generally called EDE3. EDE3 is a specific way of implementing Triple DES (and is the one everyone uses, so in practice they're generally synonymous).</p>
","281","<c><encryption><openssl><3des>","1","3","1","2018-04-29 15:08:15","50087987","0","","","","","2018-04-29 14:55:35",""
"34007597","Encryption using Chilkat 3DES provider and the same result using standard .NET provider","<p>Here is a problem. There is a know library 'Chilkat Crypt'. It contains 3des encryption method. </p>

<pre><code> public static void ChilkatEncryption(String cc, string tdesKey, string tdesIV)
    {
        Crypt2 crypt = new Chilkat.Crypt2();

        bool success = crypt.UnlockComponent(""Anything for 30-day trial"");
        if (success != true)
        {
            Console.WriteLine(crypt.LastErrorText);
            return;
        }

        //  Specify 3DES for the encryption algorithm:
        crypt.CryptAlgorithm = ""3des"";

        //  CipherMode may be ""ecb"" or ""cbc""
        crypt.CipherMode = ""cbc"";

        //  KeyLength must be 192.  3DES is technically 168-bits;
        //  the most-significant bit of each key byte is a parity bit,
        //  so we must indicate a KeyLength of 192, which includes
        //  the parity bits.
        crypt.KeyLength = 192;

        //  The padding scheme determines the contents of the bytes
        //  that are added to pad the result to a multiple of the
        //  encryption algorithm's block size.  3DES has a block
        //  size of 8 bytes, so encrypted output is always
        //  a multiple of 8.
        crypt.PaddingScheme = 0;

        //  EncodingMode specifies the encoding of the output for
        //  encryption, and the input for decryption.
        //  It may be ""hex"", ""url"", ""base64"", or ""quoted-printable"".
        crypt.EncodingMode = ""hex"";

        //  An initialization vector is required if using CBC or CFB modes.
        //  ECB mode does not use an IV.
        //  The length of the IV is equal to the algorithm's block size.
        //  It is NOT equal to the length of the key.
        string ivHex = tdesIV;
        crypt.SetEncodedIV(ivHex, ""hex"");

        //  The secret key must equal the size of the key.  For
        //  3DES, the key must be 24 bytes (i.e. 192-bits).
        string keyHex = tdesKey;
        crypt.SetEncodedKey(keyHex, ""hex"");

        //  Encrypt a string...
        //  The input string is 44 ANSI characters (i.e. 44 bytes), so
        //  the output should be 48 bytes (a multiple of 8).
        //  Because the output is a hex string, it should
        //  be 96 characters long (2 chars per byte).
        string encStr = crypt.EncryptStringENC(cc);
        Console.WriteLine(encStr);

        //  Now decrypt:
        string decStr = crypt.DecryptStringENC(encStr);
        Console.WriteLine(decStr);
    }
</code></pre>

<p>When i am trying to do the same without this third-party library using a standard provider the result is quite different: </p>

<pre><code>    private static string EncryptData(String cc, byte[] tdesKey, byte[] tdesIV)
    {
        //Create the file streams to handle the input and output files.
        MemoryStream fin = new MemoryStream();
        MemoryStream fout = new MemoryStream();
        StreamWriter sw = new StreamWriter(fin);
        sw.Write(cc);
        sw.Flush();
        fin.Position = 0;
        fout.SetLength(0);

        //Create variables to help with read and write.
        byte[] bin = new byte[100]; //This is intermediate storage for the encryption.
        long rdlen = 0;              //This is the total number of bytes written.
        long totlen = fin.Length;    //This is the total length of the input file.
        int len;                     //This is the number of bytes to be written at a time.

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        tdes.Mode=CipherMode.CBC;
        tdes.Padding = PaddingMode.None;
        CryptoStream encStream = new CryptoStream(fout, tdes.CreateEncryptor(tdesKey, tdesIV), CryptoStreamMode.Write);

        Console.WriteLine(""Encrypting..."");

        //Read from the input file, then encrypt and write to the output file.
        while (rdlen &lt; totlen)
        {
            len = fin.Read(bin, 0, 100);
            encStream.Write(bin, 0, len);
            rdlen = rdlen + len;
            Console.WriteLine(""{0} bytes processed"", rdlen);
        }

        byte[] encBytes = fout.ToArray();

        return BitConverter.ToString(encBytes);


    }
</code></pre>

<p>Does anyone know, what should be a parameter set for standard .NET encryption to get the same 3DES result? </p>

<p>Thank you! </p>
","<h2>Incorrect Padding</h2>

<p>According to the Chilkat documentation <a href=""http://www.chilkatsoft.com/refdoc/csCrypt2Ref.html"" rel=""nofollow noreferrer"">here</a>, a <code>PaddingScheme</code> value of 0 means the library will use PKCS#5 padding. PKCS#5 is essentially just a special case of PKCS#7 which is specified only for block ciphers of size 8 bytes, suchs as Triple DES. Using the .NET provider, you should specify <code>PaddingMode.PKCS7</code> instead of <code>PaddingMode.None</code> as above.</p>

<p>Additionally, you need to make sure to explicitly close the <code>CryptoStream</code>, so that it knows that you are done writing to it so that it can encrypt the final (padded) block:</p>

<pre><code>encStream.Close();
byte[] encBytes = fout.ToArray();
</code></pre>

<h2>Incorrect Encoding</h2>

<p>Another problem that may or may not be giving you issues is the fact that the two different examples use different text encodings. The Chilkat library looks like it defaults to using ""ANSI"" encoding. In the second example, however, you don't explicitly specify an encoding in the <code>StreamWriter</code> constructor, so it defaults to UTF-8.</p>

<p>Depending upon the data that you are encrypting, this may or may not give you issues, but basically if you have any characters outside the range of plain old ASCII, you will get inconsistent results between the two functions since you won't actually be encrypting the same thing.</p>

<p>The quick fix is to specify the encoding in the <code>StreamWriter</code> constructor:</p>

<pre><code>StreamWriter sw = new StreamWriter(fin, Encoding.Default);
</code></pre>

<p>This will give you a <code>StreamWriter</code> which will write bytes from strings based on whatever the default ANSI codepage for your system. The big problem with this is that whatever ""ANSI"" means on your system won't necessarily be the same thing as someone else's system (for a detailed explanation, see <a href=""https://stackoverflow.com/questions/701882/what-is-ansi-format"">this question</a>), so this could lead to issues if you need to interoperate.</p>

<p>For this reason, I'd highly suggest that you specify a more specific encoding, such as UTF-8.</p>

<p>For the Chilkat library, you can do this:</p>

<pre><code>crypt.Charset = ""utf-8"";    
</code></pre>

<p>For the .NET provider example, you can specify the encoding explicitly in the <code>StreamWriter</code> constructor:</p>

<pre><code>StreamWriter sw = new StreamWriter(fin, Encoding.UTF8);
</code></pre>

<p>You could also just omit the argument, since UTF-8 is the default encoding used by the <code>StreamWriter</code> class.</p>

<p><hr>
Incidentally, rather than using a <code>StreamWriter</code> to encode/write your input string to the memory stream <code>fin</code> at the beginning and then reading it back to write to the <code>CryptoStream</code> 100 bytes at a time, you could just encode directly to a byte array and write to the <code>CryptoStream</code> all at once:</p>

<pre><code>var buffer = Encoding.UTF8.GetBytes(cc);
encStream.Write(buffer, 0, buffer.Length);
</code></pre>
","274","<c#><.net><encryption><3des><chilkat>","1","1","1","2015-12-01 16:20:43","34015308","2","","","","","2015-11-30 20:40:54",""
"53231890","PHP Decrypt data (encrypted with mcrypt) using openssl","<p>I have a database full of data encrypted in 3DES (ECB) that was encrypted with the php Mcrypt library. Since Mcrypt is depreacated, I need to switch to OpenSSL to decrypt it. All the data will be reencrypted using xchacha20-poly1305-ietf.</p>

<p>So I don't need comments about 3DES not being secure and ECB bad etc, we know, this is why we are trying to decrypt to have a better encryption algorithm.</p>

<p>I am providing below the code that was used to encrypt using mcrypt and the 1 line we are trying to use (openssl) to decrypt it. It always returns false and we are wondering why.</p>

<p>I am starting to suspect the problem is with the mcrypt library using an 8 bytes IV while open SSL saying it has to be 0 bytes.</p>

<p>Any help would be appreciated to find a way to decrypt the values using openssl.</p>

<p>Thanks in advance.</p>

<p>Here is the code:
    

<pre><code>$sEncryptionKey = 'aaaabbbbccccddddeeeeffff';
$sDataToEncrypt = 'Foo bar';

echo ""Data to be Encrypted: $sDataToEncrypt\n"";

$rMcrypt = mcrypt_module_open(MCRYPT_3DES, '', MCRYPT_MODE_ECB, '');
$iIvSize = mcrypt_enc_get_iv_size($rMcrypt); //This gives 8 bytes

$sInitializationVector = mcrypt_create_iv($iIvSize, MCRYPT_RAND);
$iKeySize = mcrypt_enc_get_key_size($rMcrypt);

if ($iKeySize != strlen($sEncryptionKey)) {
    throw new Exception ('Invalid key length: '.$iKeySize);
}

mcrypt_generic_init($rMcrypt, $sEncryptionKey, $sInitializationVector);
$sEncryptedString = base64_encode(mcrypt_generic($rMcrypt, $sDataToEncrypt));

echo ""Data Encrypted: $sEncryptedString\n"";
$sDecryptedString = trim(mdecrypt_generic($rMcrypt, base64_decode($sEncryptedString)));

echo ""Data Decrypted: $sDecryptedString\n"";
mcrypt_generic_deinit($rMcrypt);
mcrypt_module_close($rMcrypt);

$sDecryptedString2 = openssl_decrypt(base64_decode($sEncryptedString), 'des-ede3', $sEncryptionKey, 0, ''); //this returns false.
echo ""Data Decrypted (open SSL): $sDecryptedString2\n"";

$sDecryptedString2 = openssl_decrypt(base64_decode($sEncryptedString), 'des-ede3', $sEncryptionKey, 0, $sInitializationVector); //Warning: openssl_decrypt(): IV passed is 8 bytes long which is longer than the 0 expected by selected cipher, truncating
?&gt;
</code></pre>

<p>The output of the program shows:</p>

<pre><code>Data to be Encrypted: Foo bar
Data Encrypted: 5Mraf9swmaI=
Data Decrypted: Foo bar
Data Decrypted (open SSL): 

Warning: openssl_decrypt(): IV passed is 8 bytes long which is longer than the 0 expected by selected cipher, truncating in /usr/local/www/appcluster01.ezmax.ca/pub/web/test/ian/test.cmd on line 31
</code></pre>
","<p>I just realized I was using openssl_decrypt incorrectly.</p>

<p>Changing to this works fine:</p>

<pre><code>$sDecryptedString2 = openssl_decrypt(base64_decode($sEncryptedString), 'des-ede3', $sEncryptionKey, OPENSSL_ZERO_PADDING | OPENSSL_RAW_DATA, '');
</code></pre>

<p>I hope it will help someone somedays.</p>

<p>Thanks</p>
","273","<php><openssl><mcrypt><3des><ecb>","-2","0","1","2018-11-09 19:55:51","","2","","7516139","","2018-11-09 19:16:32","2018-11-09 19:06:47",""
"49107201","3DES encryption with clear key","<p>I'm trying to write a Cobol program with the following interface:</p>

<h3>Objective</h3>

<p>Receives a clear encryption key and a clear text and returns a cyphered text using the <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow noreferrer"">3DES</a> algorithm.</p>

<h3>Inputs:</h3>

<ul>
<li>CLEAR_KEY: A 32-character string of hexadecimal characters to be used as the encryption key.</li>
<li>CLEAR_TEXT: A 16-character string.</li>
</ul>

<h3>Output:</h3>

<ul>
<li>CYPHERED_TEXT: A 16-character string.</li>
</ul>

<p>I have access to <a href=""https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_61/db2/rbafzscaencrypttdes.htm"" rel=""nofollow noreferrer"">DB2</a> and <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/apenc.htm#apenc"" rel=""nofollow noreferrer"">ICSF callable services</a>.</p>

<p>I tried these three approaches:</p>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/sye.htm#sye"" rel=""nofollow noreferrer"">CSNBSYE</a></h3>

<pre><code>77 CSNBSYE                  PIC X(7) VALUE 'CSNBSYE'.
01 CSNBSYE-PARAMETERS.
   02 RETURN-CODE           PIC 9(8) COMP.
   02 REASON-CODE           PIC 9(8) COMP.
   02 EXIT-DATA-LENGTH      PIC 9(8) COMP.
   02 EXIT-DATA             PIC X(32).
   02 RULE-ARRAY-COUNT      PIC 9(8) COMP.
   02 RULE-ARRAY            PIC X(8).
   02 KEY-IDENTIFIER-LENGTH PIC 9(8) COMP.
   02 KEY-IDENTIFIER        PIC X(32).
   02 KEY-PARMS-LENGTH      PIC 9(8) COMP.
   02 KEY-PARMS             PIC X(32).
   02 BLOCK-SIZE            PIC 9(8) COMP.
   02 INIT-VECTOR-LENGTH    PIC 9(8) COMP.
   02 INIT-VECTOR           PIC X(8).
   02 CHAIN-DATA-LENGTH     PIC 9(8) COMP.
   02 CHAIN-DATA            PIC X(16).
   02 CLEAR-TEXT-LENGTH     PIC 9(8) COMP.
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT-LENGTH  PIC 9(8) COMP.
   02 CYPHERED-TEXT         PIC X(16).
   02 OPTIONAL-DATA-LENGTH  PIC 9(8) COMP.
   02 OPTIONAL-DATA         PIC X(32).

INITIALIZE CSNBSYE-PARAMETERS.

MOVE 1                                  TO RULE-ARRAY-COUNT.
MOVE 'DES     '                         TO RULE-ARRAY.
MOVE 16                                 TO KEY-IDENTIFIER-LENGTH.
MOVE '2DF65FD88EA9E17E3C66950387F91DE2' TO KEY-IDENTIFIER.
MOVE 8                                  TO BLOCK-SIZE
                                           INIT-VECTOR-LENGTH.
MOVE ALL ZEROS                          TO INIT-VECTOR.
MOVE 16                                 TO CHAIN-DATA-LENGTH.
MOVE LOW-VALUES                         TO CHAIN-DATA.
MOVE 16                                 TO CLEAR-TEXT-LENGTH
                                           CYPHERED-TEXT-LENGTH.
MOVE ALL ZEROS                          TO CLEAR-TEXT.

CALL CSNBSYE USING RETURN-CODE,
                   REASON-CODE,           
                   EXIT-DATA-LENGTH,      
                   EXIT-DATA,             
                   RULE-ARRAY-COUNT,      
                   RULE-ARRAY,            
                   KEY-IDENTIFIER-LENGTH, 
                   KEY-IDENTIFIER,        
                   KEY-PARMS-LENGTH,      
                   KEY-PARMS,             
                   BLOCK-SIZE,           
                   INIT-VECTOR-LENGTH,    
                   INIT-VECTOR,           
                   CHAIN-DATA-LENGTH,    
                   CHAIN-DATA,            
                   CLEAR-TEXT-LENGTH,     
                   CLEAR-TEXT,            
                   CYPHERED-TEXT-LENGTH,  
                   CYPHERED-TEXT,         
                   OPTIONAL-DATA-LENGTH,  
                   OPTIONAL-DATA.
</code></pre>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/eco.htm#eco"" rel=""nofollow noreferrer"">CSNBECO</a></h3>

<pre><code>77 CSNBECO                  PIC X(7) VALUE 'CSNBECO'.
01 CSNBECO-PARAMETERS.
   02 RETURN-CODE           PIC 9(8) COMP.
   02 REASON-CODE           PIC 9(8) COMP.
   02 EXIT-DATA-LENGTH      PIC 9(8) COMP.
   02 EXIT-DATA             PIC X(32).
   02 CLEAR-KEY             PIC X(32).
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT         PIC X(16).

INITIALIZE CSNBECO-PARAMETERS.

MOVE '2DF65FD88EA9E17E3C66950387F91DE2' TO CLEAR-KEY.
MOVE ALL ZEROS                          TO CLEAR-TEXT.

CALL CSNBSYE USING RETURN-CODE,
                   REASON-CODE,           
                   EXIT-DATA-LENGTH,      
                   EXIT-DATA,             
                   CLEAR-KEY,          
                   CLEAR-TEXT,            
                   CYPHERED-TEXT.
</code></pre>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_61/db2/rbafzscaencrypttdes.htm"" rel=""nofollow noreferrer"">DB2's ENCRYPT_TDES</a></h3>

<pre><code>01 WS.
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT         PIC X(16).

   MOVE ALL ZEROS TO CLEAR-TEXT.

   EXEC SQL
        SELECT ENCRYPT_TDES(:CLEAR-TEXT, '2DF65FD88EA9E17E3C66950387F91DE2')
        INTO   :CYPHERED-TEXT
        FROM   SYSIBM.SYSDUMMY1
   END-EXEC.
</code></pre>

<p>But none of these approaches returned the result I expected. The result I'm expecting is the same obtained from testing in this website: <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a> , with the following data:</p>

<p>Input type: Text</p>

<p>Input Text: 0000000000000000 (HEX)</p>

<p>Function: 3DES</p>

<p>Mode: CBC</p>

<p>Key: 2DF65FD88EA9E17E3C66950387F91DE2 (HEX)</p>

<p>Init Vector: 00 00 00 00 00 00 00 00</p>

<p>Encrypt!</p>

<p>Encrypted Text (result): 87 30  e1  ef  98  3d  f2  b4 (HEX) | .    0   á   ï      =   ò   ´   (STRING)</p>

<p>My question is: how can I obtain the result above in a Cobol program, using any of the tools provided by IBM? </p>

<p>Thank you!</p>
","<p>Most of your confusion seems to come from the fact that you mistake hex-strings for byte-values. E.g. you think you pass CSNBSYE a 16-byte key of <code>'2DF65FD88EA9E17E3C66950387F91DE2'X</code> while you are passing a 32-byte string starting with <code>'F2C4C6F6F5C6C429F8'X</code> - i.e. the EBCDIC-representation of the characters you passed. To use actual hex-representation of the byte-values you have to append a <code>X</code> after the closing apostrophe of your literals.</p>

<p>Also note that moving <code>ZERO</code> into a <code>PIC X</code> item resulte in <code>'F0'X</code> while using <code>LOW-VALUE</code> results in <code>'00'</code>.</p>

<p>Another point is that you seem to be comparing the 3DES results from the website with the DES results from CSNBECO or CSNBSYE - but they are different ciphers and so should return different results.</p>

<p>Last but not least <code>ENCRYPT_TDES</code>: this function is using 3DES but it does not accept a plain key. Instead the second argument is a password that is hashed to obtain the final encryption key.</p>

<p>So of your investigated alternatives it seems that only CSNBSYE is compatible with your requirements but you have to study its exact parameter-formats and usage.</p>
","273","<encryption><db2><cobol><zos><3des>","2","5","2","2018-03-05 15:45:30","49109249","0","","","","","2018-03-05 09:34:15",""
"49107201","3DES encryption with clear key","<p>I'm trying to write a Cobol program with the following interface:</p>

<h3>Objective</h3>

<p>Receives a clear encryption key and a clear text and returns a cyphered text using the <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow noreferrer"">3DES</a> algorithm.</p>

<h3>Inputs:</h3>

<ul>
<li>CLEAR_KEY: A 32-character string of hexadecimal characters to be used as the encryption key.</li>
<li>CLEAR_TEXT: A 16-character string.</li>
</ul>

<h3>Output:</h3>

<ul>
<li>CYPHERED_TEXT: A 16-character string.</li>
</ul>

<p>I have access to <a href=""https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_61/db2/rbafzscaencrypttdes.htm"" rel=""nofollow noreferrer"">DB2</a> and <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/apenc.htm#apenc"" rel=""nofollow noreferrer"">ICSF callable services</a>.</p>

<p>I tried these three approaches:</p>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/sye.htm#sye"" rel=""nofollow noreferrer"">CSNBSYE</a></h3>

<pre><code>77 CSNBSYE                  PIC X(7) VALUE 'CSNBSYE'.
01 CSNBSYE-PARAMETERS.
   02 RETURN-CODE           PIC 9(8) COMP.
   02 REASON-CODE           PIC 9(8) COMP.
   02 EXIT-DATA-LENGTH      PIC 9(8) COMP.
   02 EXIT-DATA             PIC X(32).
   02 RULE-ARRAY-COUNT      PIC 9(8) COMP.
   02 RULE-ARRAY            PIC X(8).
   02 KEY-IDENTIFIER-LENGTH PIC 9(8) COMP.
   02 KEY-IDENTIFIER        PIC X(32).
   02 KEY-PARMS-LENGTH      PIC 9(8) COMP.
   02 KEY-PARMS             PIC X(32).
   02 BLOCK-SIZE            PIC 9(8) COMP.
   02 INIT-VECTOR-LENGTH    PIC 9(8) COMP.
   02 INIT-VECTOR           PIC X(8).
   02 CHAIN-DATA-LENGTH     PIC 9(8) COMP.
   02 CHAIN-DATA            PIC X(16).
   02 CLEAR-TEXT-LENGTH     PIC 9(8) COMP.
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT-LENGTH  PIC 9(8) COMP.
   02 CYPHERED-TEXT         PIC X(16).
   02 OPTIONAL-DATA-LENGTH  PIC 9(8) COMP.
   02 OPTIONAL-DATA         PIC X(32).

INITIALIZE CSNBSYE-PARAMETERS.

MOVE 1                                  TO RULE-ARRAY-COUNT.
MOVE 'DES     '                         TO RULE-ARRAY.
MOVE 16                                 TO KEY-IDENTIFIER-LENGTH.
MOVE '2DF65FD88EA9E17E3C66950387F91DE2' TO KEY-IDENTIFIER.
MOVE 8                                  TO BLOCK-SIZE
                                           INIT-VECTOR-LENGTH.
MOVE ALL ZEROS                          TO INIT-VECTOR.
MOVE 16                                 TO CHAIN-DATA-LENGTH.
MOVE LOW-VALUES                         TO CHAIN-DATA.
MOVE 16                                 TO CLEAR-TEXT-LENGTH
                                           CYPHERED-TEXT-LENGTH.
MOVE ALL ZEROS                          TO CLEAR-TEXT.

CALL CSNBSYE USING RETURN-CODE,
                   REASON-CODE,           
                   EXIT-DATA-LENGTH,      
                   EXIT-DATA,             
                   RULE-ARRAY-COUNT,      
                   RULE-ARRAY,            
                   KEY-IDENTIFIER-LENGTH, 
                   KEY-IDENTIFIER,        
                   KEY-PARMS-LENGTH,      
                   KEY-PARMS,             
                   BLOCK-SIZE,           
                   INIT-VECTOR-LENGTH,    
                   INIT-VECTOR,           
                   CHAIN-DATA-LENGTH,    
                   CHAIN-DATA,            
                   CLEAR-TEXT-LENGTH,     
                   CLEAR-TEXT,            
                   CYPHERED-TEXT-LENGTH,  
                   CYPHERED-TEXT,         
                   OPTIONAL-DATA-LENGTH,  
                   OPTIONAL-DATA.
</code></pre>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.1.0/com.ibm.zos.v2r1.csfb400/eco.htm#eco"" rel=""nofollow noreferrer"">CSNBECO</a></h3>

<pre><code>77 CSNBECO                  PIC X(7) VALUE 'CSNBECO'.
01 CSNBECO-PARAMETERS.
   02 RETURN-CODE           PIC 9(8) COMP.
   02 REASON-CODE           PIC 9(8) COMP.
   02 EXIT-DATA-LENGTH      PIC 9(8) COMP.
   02 EXIT-DATA             PIC X(32).
   02 CLEAR-KEY             PIC X(32).
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT         PIC X(16).

INITIALIZE CSNBECO-PARAMETERS.

MOVE '2DF65FD88EA9E17E3C66950387F91DE2' TO CLEAR-KEY.
MOVE ALL ZEROS                          TO CLEAR-TEXT.

CALL CSNBSYE USING RETURN-CODE,
                   REASON-CODE,           
                   EXIT-DATA-LENGTH,      
                   EXIT-DATA,             
                   CLEAR-KEY,          
                   CLEAR-TEXT,            
                   CYPHERED-TEXT.
</code></pre>

<h3>Using <a href=""https://www.ibm.com/support/knowledgecenter/ssw_ibm_i_61/db2/rbafzscaencrypttdes.htm"" rel=""nofollow noreferrer"">DB2's ENCRYPT_TDES</a></h3>

<pre><code>01 WS.
   02 CLEAR-TEXT            PIC X(16).
   02 CYPHERED-TEXT         PIC X(16).

   MOVE ALL ZEROS TO CLEAR-TEXT.

   EXEC SQL
        SELECT ENCRYPT_TDES(:CLEAR-TEXT, '2DF65FD88EA9E17E3C66950387F91DE2')
        INTO   :CYPHERED-TEXT
        FROM   SYSIBM.SYSDUMMY1
   END-EXEC.
</code></pre>

<p>But none of these approaches returned the result I expected. The result I'm expecting is the same obtained from testing in this website: <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow noreferrer"">http://tripledes.online-domain-tools.com/</a> , with the following data:</p>

<p>Input type: Text</p>

<p>Input Text: 0000000000000000 (HEX)</p>

<p>Function: 3DES</p>

<p>Mode: CBC</p>

<p>Key: 2DF65FD88EA9E17E3C66950387F91DE2 (HEX)</p>

<p>Init Vector: 00 00 00 00 00 00 00 00</p>

<p>Encrypt!</p>

<p>Encrypted Text (result): 87 30  e1  ef  98  3d  f2  b4 (HEX) | .    0   á   ï      =   ò   ´   (STRING)</p>

<p>My question is: how can I obtain the result above in a Cobol program, using any of the tools provided by IBM? </p>

<p>Thank you!</p>
","<p>I did it! The code was the following:</p>

<pre><code>77 CT-cENC-ROUTINE                  PIC X(7) VALUE 'CSNBSYE'.
05 WS-ENC.                                        
   10 WS-ENC-nRETURN-CODE           PIC 9(8) COMP.
   10 WS-ENC-nREASON-CODE           PIC 9(8) COMP.
   10 WS-ENC-nEXIT-DATA-LENGTH      PIC 9(8) COMP.
   10 WS-ENC-cEXIT-DATA             PIC X(4).     
   10 WS-ENC-nRULE-ARRAY-COUNT      PIC 9(8) COMP.
   10 WS-ENC-RULE-ARRAY.                          
      15 WS-ENC-cRULE-ALGO          PIC X(8).     
   10 WS-ENC-cKEY-IDENT-LENGTH      PIC 9(8) COMP.
   10 WS-ENC-cKEY-IDENT             PIC X(32).    
   10 WS-ENC-nKEY-PARMS-LENGTH      PIC 9(8) COMP.
   10 WS-ENC-nKEY-PARMS             PIC X(64).    
   10 WS-ENC-nBLOCK-SIZE            PIC 9(8) COMP.
   10 WS-ENC-nINIT-VECTOR-LENGTH    PIC 9(8) COMP.
   10 WS-ENC-cINIT-VECTOR           PIC X(16).    
   10 WS-ENC-nCHAIN-DATA-LENGTH     PIC 9(8) COMP.
   10 WS-ENC-cCHAIN-DATA            PIC X(32).    
   10 WS-ENC-nCLEAR-TEXT-LENGTH     PIC 9(8) COMP.
   10 WS-ENC-cCLEAR-TEXT            PIC X(16).    
   10 WS-ENC-nCYPHER-TEXT-LENGTH    PIC 9(8) COMP.
   10 WS-ENC-cCYPHER-TEXT           PIC X(16).    
   10 WS-ENC-nOPTIONAL-DATA-LENGTH  PIC 9(8) COMP.
   10 WS-ENC-cOPTIONAL-DATA         PIC X(32).    

INITIALIZE WS-ENC                                          

MOVE 1                          TO WS-ENC-nRULE-ARRAY-COUNT
MOVE 'DES'                      TO WS-ENC-cRULE-ALGO       

EXEC SQL                                                 
     SELECT VARCHAR_BIT_FORMAT('2DF65FD88EA9E17E3C66950387F91DE2')
     INTO   :WS-ENC-cKEY-IDENT                                
     FROM   SYSIBM.SYSDUMMY1                             
END-EXEC       

MOVE 16                         TO WS-ENC-cKEY-IDENT-LENGTH   
MOVE 8                          TO WS-ENC-nBLOCK-SIZE                                          
                                   WS-ENC-nINIT-VECTOR-LENGTH
MOVE ALL ZEROS                  TO WS-ENC-cINIT-VECTOR       

MOVE LENGTH OF WS-ENC-cCHAIN-DATA                            
                                TO WS-ENC-nCHAIN-DATA-LENGTH 
MOVE LOW-VALUES                 TO WS-ENC-cCHAIN-DATA        

MOVE LENGTH OF WS-ENC-cCLEAR-TEXT                            
                                TO WS-ENC-nCLEAR-TEXT-LENGTH 
                                   WS-ENC-nCYPHER-TEXT-LENGTH
MOVE '0000000000000000'         TO WS-ENC-cCLEAR-TEXT        

CALL CT-cENC-ROUTINE USING WS-ENC-nRETURN-CODE,         
                           WS-ENC-nREASON-CODE,         
                           WS-ENC-nEXIT-DATA-LENGTH,    
                           WS-ENC-cEXIT-DATA,           
                           WS-ENC-nRULE-ARRAY-COUNT,    
                           WS-ENC-RULE-ARRAY,           
                           WS-ENC-cKEY-IDENT-LENGTH,    
                           WS-ENC-cKEY-IDENT,           
                           WS-ENC-nKEY-PARMS-LENGTH,    
                           WS-ENC-nKEY-PARMS,           
                           WS-ENC-nBLOCK-SIZE,          
                           WS-ENC-nINIT-VECTOR-LENGTH,  
                           WS-ENC-cINIT-VECTOR,         
                           WS-ENC-nCHAIN-DATA-LENGTH,   
                           WS-ENC-cCHAIN-DATA,          
                           WS-ENC-nCLEAR-TEXT-LENGTH,   
                           WS-ENC-cCLEAR-TEXT,          
                           WS-ENC-nCYPHER-TEXT-LENGTH,  
                           WS-ENC-cCYPHER-TEXT          
                           WS-ENC-nOPTIONAL-DATA-LENGTH,
                           WS-ENC-cOPTIONAL-DATA    
</code></pre>

<p>So, what was missing was: 1) Convert the 32-byte string of hexadecimal characters to it's 16-byte string representation. 2) The chain data size was made to be 32. </p>
","273","<encryption><db2><cobol><zos><3des>","2","-1","2","2018-03-05 15:45:30","49109249","0","","","","","2018-03-05 09:34:15",""
"52211987","How to sync encryption between delphi and c# using dcpcrypt 3des CFB sha1","<p>I'm using Delphi xe4, c# web service. I am trying to sync encryption (delphi) to encryption(c#) and failing.
Delphi code using sha1 3des same with c#
I tried everything</p>

<p>Delphi Code output: <strong>Nv9eZPY6</strong></p>

<pre><code>DCP_3des1 := TDCP_3Des.Create(self);
    with DCP_3des1 do    
    begin      
      Id := 24;    
      Algorithm := '3DES';    
      MaxKeySize := 192;    
      BlockSize := 64;    
      CipherMode := cmCFB8bit;    
    end;

    DCP_3des1.InitStr('Medisoft', TDCP_sha1);    
    DCP_3des1.SetIV('12345678');    
    DCP_3des1.Reset;    
    s := DCP_3des1.EncryptString('123asd');    
    Label1.Caption := s;
</code></pre>

<p>c# Code output: <strong>FYH+tyCp</strong><br>
I used Chilkat but may other code. </p>

<pre><code>Chilkat.Crypt2 crypt = new Chilkat.Crypt2();
bool success = crypt.UnlockComponent(""Anything for 30-day trial"");
if (success != true)
{
Console.WriteLine(crypt.LastErrorText);
return;
}

//  Specify 3DES for the encryption algorithm:
crypt.CryptAlgorithm = ""3des"";
crypt.HashAlgorithm = ""sha1"";

//  CipherMode may be ""ecb"" or ""cbc""
crypt.CipherMode = ""cfb"";

//  KeyLength must be 192.  3DES is technically 168-bits;
//  the most-significant bit of each key byte is a parity bit,
//  so we must indicate a KeyLength of 192, which includes
//  the parity bits.
crypt.KeyLength = 192;

//  The padding scheme determines the contents of the bytes
//  that are added to pad the result to a multiple of the
//  encryption algorithm's block size.  3DES has a block
//  size of 8 bytes, so encrypted output is always
//  a multiple of 8.
crypt.PaddingScheme = 0;

//  EncodingMode specifies the encoding of the output for
//  encryption, and the input for decryption.
//  It may be ""hex"", ""url"", ""base64"", or ""quoted-printable"".
crypt.EncodingMode = ""base64"";

//  An initialization vector is required if using CBC or CFB modes.
//  ECB mode does not use an IV.
//  The length of the IV is equal to the algorithm's block size.
//  It is NOT equal to the length of the key.
crypt.SetEncodedIV(""12345678"", ""ascii"");

//  The secret key must equal the size of the key.  For
//  3DES, the key must be 24 bytes (i.e. 192-bits).
crypt.SetEncodedKey(""Medisoft"", ""ascii"");

//  Encrypt a string...
//  The input string is 44 ANSI characters (i.e. 44 bytes), so
//  the output should be 48 bytes (a multiple of 8).
//  Because the output is a hex string, it should
//  be 96 characters long (2 chars per byte).
string encStr = crypt.EncryptStringENC(""123asd"");
textBox2.Text = encStr;

//  Now decrypt:
string decStr = crypt.DecryptStringENC(encStr);
textBox4.Text = decStr;
</code></pre>

<p>What can be problem, please help. </p>
","","261","<c#><delphi><sha1><3des>","0","","0","2018-09-06 20:51:05","","5","","","","","2018-09-06 20:51:05",""
"36169122","decode 3Des with 64bit encoded text","<p>if we have a encoded text using 3Des with 64bit encoding, is it enough to have the encryption key? What else info we need.</p>

<p>I tried and im hitting below error.</p>

<p>javax.crypto.BadPaddingException: Given final block not properly padded</p>
","<ol>
<li>DES, 3DES and AES among others are block cyphers meaning that they must have input data that is an exact multiple of the block size (8-bytes in DES). Either ensure data is <strong>always</strong> a multiple of blocksize or use padding, PKCS#5 to add and remove padding bytes to achieve the block multiple requirement.</li>
<li>Do not use 3DES, it has been superseded by AES is is not sufficiently secure for new work.</li>
<li>3DES is a 168-bit key (24-bytes), sometimes for compatibility a 112-bit key (16-bytes) is used. Initially the bytes were parity checked with only 7-bits for data in each byte, the parity check is generally no longer done but still only the lower 7-bits per byte are used.</li>
<li>It is always best to supply a key of exact size.</li>
<li>You should use AES in CBC mode with a random IV.</li>
<li>If you are using a string key, possibly user supplied) you should derive  correct length key by using PBKDF2.</li>
<li>A message authentication MAC is also a good idea.</li>
</ol>
","259","<java><encryption><3des><java-security>","1","1","1","2016-03-23 04:24:27","","4","","","","","2016-03-23 03:10:59",""
"33731010","3DES on iOS 8+ with Objective-C","<p>I have to encrypt a password with 3DES and send it as parameter to login service on backend.</p>

<p>I'm struggling searching an algorithm to achieve 3DES during last week but I can't be able to find it.</p>

<p>I need to crypt the password with a <strong>key</strong> and an <strong>initializer vector</strong> (aka <strong>iv</strong>).</p>

<p>Someone knows a free library or an algorithm appropriate?</p>

<p>Thanks.</p>
","","258","<ios><objective-c><3des>","0","","0","2015-11-16 08:24:53","","4","","","","","2015-11-16 08:24:53","2015-11-18 12:39:16"
"19838444","Android 3Des encrypt Binary Output","<p>decrypt with 3des. I can get Base64 output  correctly but i want to get output binary. How can i do? </p>

<pre><code>        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encryptedText = cipher.doFinal(unencryptedString);
        byte[]  sdd = Base64.encode(encryptedText, Base64.DEFAULT);
</code></pre>
","<p>A simple method that turns a byte array in to a String containing the binary value.</p>

<pre><code>String bytesToBinaryString(byte[] bytes){

    StringBuilder binaryString = new StringBuilder();

    /* Iterate each byte in the byte array */
    for(byte b : bytes){

        /* Initialize mask to 1000000 */           
        int mask = 0x80;

        /* Iterate over current byte, bit by bit.*/
        for(int i = 0; i &lt; 8; i++){

            /* Apply mask to current byte with AND, 
             *  if result is 0 then current bit is 0. Otherwise 1.*/
            binaryString.append((mask &amp; b) == 0 ? ""0"" : ""1"");

            /* bit-wise right shift the mask 1 position. */
            mask &gt;&gt;&gt;= 1;
        }
    }

    /* Return the resulting 'binary' String.*/
    return binaryString.toString();
}
</code></pre>
","256","<java><android><base64><3des>","0","2","1","2013-11-07 16:25:58","","1","","2345913","","2013-11-07 15:42:40","2013-11-07 14:29:09",""
"25763530","Convert 20 byte decimal to 24 byte hexadecimal","<p>How can I convert a 20 byte decimal (74515898855732498125) to a 24 byte hexadecimal.</p>

<p>This 24 byte hexa output will act as an encryption key for doing TripleDES.</p>

<p>Please help with this.</p>
","","245","<php><hex><3des><mathematical-expressions>","0","","0","2014-09-10 10:51:52","","2","","","","","2014-09-10 10:51:52",""
"26130754","3DES Decryption Sometimes Different","<p>I'm having a problem using the CCCrypt function to simply encrypt/decrypt a chunk of data.</p>

<p>My platform is iOS 8 in Xcode 6.</p>

<p>What I'm doing is, I convert a test string to NSData format and pass it into a wrapper function I made.  The return of that function is the encrypted data.  I take that encrypted data and then pass it back into the function specifying that it should be decrypted.</p>

<ul>
<li><strong>Sometimes</strong> the value comes back decrypted properly.</li>
<li>Sometimes it's complete junk.</li>
<li>Sometimes said junk is not the same (but sometimes it is).</li>
<li>Sometimes I'm seeing the correct string but with extra junk at the end of it.</li>
</ul>

<p>I wrapped the use of the encryption/decryption function in a loop so I can see the inconsistent behavior more closely.</p>

<p><strong>The Implementation</strong></p>

<pre><code>NSString* unencryptedString = @""Testtest"";
NSData* unencryptedData = [NSData dataWithBytes:(void*)[unencryptedString UTF8String] length:[unencryptedString length]];
NSData* encryptedData = nil;
NSData* decryptedData = nil;

for(int i=0;i&lt;100;i++)
{
    encryptedData = [NSData tripleDesEncrypt:YES Data:unencryptedData error:&amp;err];
    decryptedData = [NSData tripleDesEncrypt:NO Data:encryptedData error:&amp;err];

    NSLog(@""unencrypted: %@, encrypted: %s\n\ndecrypted: %s"", unencryptedString, encryptedData.bytes, decryptedData.bytes);

    if(err)
        NSLog(@""error: %@"", err);
}
</code></pre>

<p><strong>The Function</strong></p>

<pre><code>+(NSData*)tripleDesEncrypt:(BOOL)encrypt
                  Data:(NSData *)inputData
                 error:(NSError **)error
{
    NSString* tripleDesKeyString = @""ABCd@Efghijklmno"";
    NSData* tripleDesKeyData = [tripleDesKeyString dataUsingEncoding:NSUTF8StringEncoding];
    const void* tripleDesKey = [tripleDesKeyData bytes];

    NSString* ivKeyString =   @""012345678901234567890123"";
    NSData* keyData = [ivKeyString dataUsingEncoding:NSUTF8StringEncoding];
    const void* ivKey = [keyData bytes];
    NSAssert(keyData.length == kCCKeySize3DES, @""tripleDesEncrypt; the keyData is an invalid size"");

    NSNumber* pOptions = [NSNumber numberWithInt:kCCOptionPKCS7Padding];
    int options = [pOptions intValue];
    size_t dataMoved;

    unsigned encryptionBufferLen = inputData.length + kCCBlockSize3DES;
    void* encryptedBuffer = malloc(encryptionBufferLen);
    memset(encryptedBuffer, 0, encryptionBufferLen);

    CCCryptorStatus
    result = CCCrypt(encrypt ? kCCEncrypt : kCCDecrypt, // operation
                     kCCAlgorithm3DES, // Algorithm
                     options, // options
                     tripleDesKey, // key
                     tripleDesKeyData.length, // keylength
                     ivKey,// iv
                     inputData.bytes, // dataIn
                     inputData.length, // dataInLength,
                     encryptedBuffer, // dataOut
                     encryptionBufferLen, // dataOutAvailable
                     &amp;dataMoved); // dataOutMoved

    NSData* outputData = [NSData dataWithBytes:encryptedBuffer length:dataMoved];
    free(encryptedBuffer);

    return outputData;
}
</code></pre>

<p><strong>The Output</strong></p>

<p><em>(I'll only run a few iterations of the output to show the weird differences.)</em></p>

<pre><code>unencrypted: Testtest, encrypted: jgüb  -A7‘œåÅKX
decrypted: ¿Ïh5¥√‚qN;1»Í

unencrypted: Testtest, encrypted: ¥⁄˘qÓırS{ÿœ•
decrypted: Æ˛ {íÒ⁄ñè–%4¢‚g

unencrypted: Testtest, encrypted: jgüb  -A7‘œåÅKX
decrypted: Testtest∞¸yå`j/private/tmp/com.apple.CoreSimulator.SimDevice.47124028-EC86-4CC0-8CA2-7DCDED3994B1.launchd_sim/syslogsock


unencrypted: Testtest, encrypted: /Âò◊9ƒ˘=m]˚†%À
decrypted: u‹z©tÙÁ∑&lt;%ˇπØ•

unencrypted: Testtest, encrypted: jgüb  -A7‘œåÅKX
decrypted: ¿Ïh5¥√‚qN;1»Í

unencrypted: Testtest, encrypted: jgüb  -A7‘œåÅKX
decrypted: Testtest
</code></pre>
","<p>Your key is only 16 bytes long. 3DES keys need to be 24 bytes long. So what is happening is that whatever random 8 bytes happen to be in memory after your <code>tripleDesKey</code> get used as the rest of key. Who knows what those bytes actually belong to, and their value could very well change in between the encryption call to <code>tripleDesEncrypt</code> and the decryption call. Different key = different encryption. That would produce the cases where your decryption didn't give back the original plaintext.</p>

<p>(BTW, I don't know why the <code>NAssert</code> on the key length isn't firing. Might you be compiling in release mode, or similar?)</p>

<p>Solution: increase the length of your key to 24 bytes.</p>

<p>As for the garbage you see at the end of the plaintext after decryption: How are you printing the result? The decrypted plaintext won't have a trailing null char, so if you're using something like <code>printf</code> then you will need to put a null char at the end of the plainext before printing it. Otherwise the system will happily output the characters after the end of your plaintext until it happens reaches a null char.</p>
","242","<ios><encryption><3des>","2","2","1","2014-09-30 22:46:35","26131407","1","","","","","2014-09-30 21:53:17",""
"47336346","nodejs 3des decrypt didn't get expected result","<p>My nodejs 3DES decryption didn't get expected result. Is there anything wrong with my code?</p>

<pre><code>let cryptojs = require('crypto-js')
var key = '551408C3D129EC64DA505CB48CD61D57551408C3D129EC64';
var ciphertext = 'C5F21F0F82038833851BA3092D613F085A60DB1E189E10F6';
var iv = cryptojs.enc.Hex.parse(""0"".repeat(16));

key = cryptojs.enc.Hex.parse(key);
var result = cryptojs.TripleDES.decrypt(ciphertext, key, {iv: iv, mode: cryptojs.mode.CBC, padding: cryptojs.pad.NoPadding});
console.log ('decrypted ' + result.toString(cryptojs.enc.Hex));
</code></pre>

<p>result is '90d49e1085d5251f87dbcd6292570ba30e8a6e0f84d8331c97a579ef0ba6ac867342f2f6'</p>

<p>however expected result should be '466F0198321458864627662057083A457601185220050000'</p>
","<p>You said you were trying to decrypt the data, but you encrypted it:</p>

<pre><code>var result = cryptojs.TripleDES.encrypt(ciphertext, key, {iv: iv, mode: cryptojs.mode.CBC, padding: cryptojs.pad.NoPadding});
</code></pre>
","241","<node.js><encryption><3des>","0","0","2","2017-11-17 06:41:02","47344729","2","","8917741","","2017-11-17 00:23:41","2017-11-16 18:01:46",""
"47336346","nodejs 3des decrypt didn't get expected result","<p>My nodejs 3DES decryption didn't get expected result. Is there anything wrong with my code?</p>

<pre><code>let cryptojs = require('crypto-js')
var key = '551408C3D129EC64DA505CB48CD61D57551408C3D129EC64';
var ciphertext = 'C5F21F0F82038833851BA3092D613F085A60DB1E189E10F6';
var iv = cryptojs.enc.Hex.parse(""0"".repeat(16));

key = cryptojs.enc.Hex.parse(key);
var result = cryptojs.TripleDES.decrypt(ciphertext, key, {iv: iv, mode: cryptojs.mode.CBC, padding: cryptojs.pad.NoPadding});
console.log ('decrypted ' + result.toString(cryptojs.enc.Hex));
</code></pre>

<p>result is '90d49e1085d5251f87dbcd6292570ba30e8a6e0f84d8331c97a579ef0ba6ac867342f2f6'</p>

<p>however expected result should be '466F0198321458864627662057083A457601185220050000'</p>
","<p>after some more testing found out need to add one more line of code before decrypt :</p>

<pre><code>ciphertext = cryptojs.format.Hex.parse(ciphertext);
</code></pre>

<p>complete code as below :</p>

<pre><code>let cryptojs = require('crypto-js')
var key = '551408C3D129EC64DA505CB48CD61D57551408C3D129EC64';
var ciphertext = 'C5F21F0F82038833851BA3092D613F085A60DB1E189E10F6';
var iv = cryptojs.enc.Hex.parse(""0"".repeat(16));

key = cryptojs.enc.Hex.parse(key);
ciphertext = cryptojs.format.Hex.parse(ciphertext);
var result = cryptojs.TripleDES.decrypt(ciphertext, key, {iv: iv, mode: cryptojs.mode.CBC, padding: cryptojs.pad.NoPadding});
console.log ('decrypted ' + result.toString(cryptojs.enc.Hex));
</code></pre>

<p>result is</p>

<pre><code>decrypted 466f0198321458864627662057083a457601185220050000
</code></pre>
","241","<node.js><encryption><3des>","0","0","2","2017-11-17 06:41:02","47344729","2","","8917741","","2017-11-17 00:23:41","2017-11-16 18:01:46",""
"53332164","Go lang 3DES partially decrypted the encrypted string","<p>While performing decryption using 3des  the given encrypted text is not fully decrypted, not sure where it went wrong, help me complete the decryption error</p>

<p>The code is avaialbe at <a href=""https://play.golang.org/p/3xtFHvpiA3V"" rel=""nofollow noreferrer"">Go Playground</a> for Insection and run </p>

<pre><code>package main

import (
    ""crypto/des""
    ""encoding/hex""
    ""fmt""
)

func main() {

    // Mimimum Key Size of Length 24
    key := ""mysecretPasswordkeySiz24""
    plainText := ""https://8gwifi.org""
    ct := EncryptTripleDES([]byte(key),plainText)
    fmt.Printf(""Original Text:  %s\n"",plainText)
    fmt.Printf(""3DES Encrypted Text:  %s\n"", ct)
    DecryptTripleDES([]byte(key),ct)

}

func EncryptTripleDES(key []byte, plaintext string) string {
        c,err := des.NewTripleDESCipher(key)
    if err != nil {
        fmt.Errorf(""NewTripleDESCipher(%d bytes) = %s"", len(key), err)
        panic(err)
    }

    out := make([]byte, len(plaintext))
    c.Encrypt(out, []byte(plaintext))
    return hex.EncodeToString(out)

    }


func DecryptTripleDES(key []byte, ct string) {

        ciphertext, _ := hex.DecodeString(ct)
        c, err := des.NewTripleDESCipher([]byte(key))
        if err != nil {
            fmt.Errorf(""NewTripleDESCipher(%d bytes) = %s"", len(key), err)
            panic(err)
        }
        plain := make([]byte, len(ciphertext))
        c.Decrypt(plain, ciphertext)
        s := string(plain[:])
        fmt.Printf(""3DES Decrypyed Text:  %s\n"", s)
}
</code></pre>

<p>The output </p>

<pre><code>Original Text:  https://8gwifi.org
3DES Encrypted Text:  a6e5215154bf86d000000000000000000000
3DES Decrypyed Text:  https://
</code></pre>
","<blockquote>
  <p>the given encrypted text is not fully decrypted</p>
</blockquote>

<p>The encrypted text you gave is fully decrypted. The problem is not (yet) the decryption but your encryption. As documented <code>des.NewTripleDESCipher</code> returns a <code>cipher.Block</code> and <code>cipher.Block.Encrypt</code> encrypts as documented only the first block of the input data. Given that DES has a block size of 8 byte only the first 8 byte of the input data are encrypted, i.e. <code>https://</code>. </p>

<p>This means in order to encrypt all data you must encrypt all blocks. Similar you need to decrypt all blocks when decrypting - but <code>cipher.Block.Decrypt</code> also decrypts only a single block.</p>

<p>Apart from that DES is broken, so don't use it for something serious.</p>
","233","<go><encryption><des><3des>","0","2","1","2018-11-16 06:02:44","53332282","0","","","","","2018-11-16 05:52:01",""
"28392119","Why my smart card accepts two different keys as its MAC key?","<p>As you see below, I tried to list installed applets on my card using <strong>gp -list</strong>. I specify some different key: </p>

<pre><code>GP: gp -mac 404142434445464748494A4B4C4D4E4F -list
AID: A000000151000000 (|....Q...|)
     ISD OP_READY: Security Domain, Card lock, Card terminate, Default selected,
 CVM (PIN) management

AID: A0000001515350 (|....QSP|)
     ExM LOADED: (none)
     A000000151535041 (|....QSPA|)


GP: gp -mac 404142434445464748494A4B4C4D4E4E -list
AID: A000000151000000 (|....Q...|)
     ISD OP_READY: Security Domain, Card lock, Card terminate, Default selected,
 CVM (PIN) management

AID: A0000001515350 (|....QSP|)
     ExM LOADED: (none)
     A000000151535041 (|....QSPA|)


GP: gp -mac 404142434445464748494A4B4C4D4E4D -list
openkms.gp.GPException: External authenticate failed SW: 6982
        at openkms.gp.GlobalPlatform.check(GlobalPlatform.java:924)
        at openkms.gp.GlobalPlatform.openSecureChannel(GlobalPlatform.java:447)
        at openkms.gp.GPTool.main(GPTool.java:280)
</code></pre>

<p>Why it works fine with two different keys? </p>

<blockquote>
  <p>404142434445464748494A4B4C4D4E4<strong>F</strong></p>
</blockquote>

<p>and </p>

<blockquote>
  <p>404142434445464748494A4B4C4D4E4<strong>E</strong></p>
</blockquote>

<p>Note that I tried some other cards and tools! Same output.</p>

<p>Is this because of that the encryption with both keys has the same output?</p>
","<p>You are only flipping the parity bit which is not used nor checked by the card (or software). Which means the outcome of ciphers is the same, yes.</p>
","229","<smartcard><javacard><3des><parity><globalplatform>","0","4","1","2015-02-09 08:36:21","28394415","0","","1435475","","2015-02-09 08:36:21","2015-02-08 08:42:04",""
"45639971","Store 3DES in String instead of CipherOutputStream","<p>I'm trying to 3DES encrypt a string and store it in a properties file using <a href=""http://www.java2s.com/Code/Java/Security/TripleDES.htm"" rel=""nofollow noreferrer"">this example</a>.  The problem I'm having is I do not want to write the contents of encrypt() and decrypt() to a file directly from the methods.  I want to store it in a string for use later.</p>

<p>Below are the methods I'm using.</p>

<p>As you can see this uses CipherOutputStream and CipherInputStream.  How would I read the result of both encrypt() and decrypt() into a String instead of writing it out to file?</p>

<pre><code>  public static void encrypt(SecretKey key, InputStream in, OutputStream out)
      throws NoSuchAlgorithmException, InvalidKeyException,
      NoSuchPaddingException, IOException {
    // Create and initialize the encryption engine
    Cipher cipher = Cipher.getInstance(""DESede"");
    cipher.init(Cipher.ENCRYPT_MODE, key);

    // Create a special output stream to do the work for us
    CipherOutputStream cos = new CipherOutputStream(out, cipher);

    // Read from the input and write to the encrypting output stream
    byte[] buffer = new byte[2048];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
      cos.write(buffer, 0, bytesRead);
    }
    cos.close();

    // For extra security, don't leave any plaintext hanging around memory.
    java.util.Arrays.fill(buffer, (byte) 0);
  }

  /**
   * Use the specified TripleDES key to decrypt bytes ready from the input
   * stream and write them to the output stream. This method uses uses Cipher
   * directly to show how it can be done without CipherInputStream and
   * CipherOutputStream.
   */
  public static void decrypt(SecretKey key, InputStream in, OutputStream out)
      throws NoSuchAlgorithmException, InvalidKeyException, IOException,
      IllegalBlockSizeException, NoSuchPaddingException,
      BadPaddingException {
    // Create and initialize the decryption engine
    Cipher cipher = Cipher.getInstance(""DESede"");
    cipher.init(Cipher.DECRYPT_MODE, key);

    // Read bytes, decrypt, and write them out.
    byte[] buffer = new byte[2048];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
      out.write(cipher.update(buffer, 0, bytesRead));
    }

    // Write out the final bunch of decrypted bytes
    out.write(cipher.doFinal());
    out.flush();
  }
</code></pre>
","<p>Simple: instead of passing a file output stream to these methods - pass a different kind of stream, for example a ByteArrayOutputStream. </p>

<p>Then you can extract the encrypted data as string from that stream. </p>

<p>And to ensure that the final result is reasonable encoded, you should actually use some kind of <a href=""https://stackoverflow.com/questions/8896237/java-base64-how-to-write-a-base64outputstream-class-using-decorator-pattern"">Base64OutputStream</a> which in turn writes to that <a href=""https://docs.oracle.com/javase/8/docs/api/java/io/ByteArrayOutputStream.html"" rel=""nofollow noreferrer"">ByteArrayOutputStream</a>.</p>
","226","<java><encryption><3des>","1","3","1","2017-08-11 18:16:53","45640004","4","2","","","","2017-08-11 16:40:07",""
"39963900","Crypto++ equivalent to PHP mcrypt_encrypt MCRYPT_3DES/MCRYPT_MODE_CBC","<p>I have the following PHP code to encrypt a text using a key:</p>

<pre class=""lang-php prettyprint-override""><code>function des_ed3_crypt($msg, $key) {
   $bytes = array(0,0,0,0,0,0,0,0);
   $iv=implode(array_map('chr', $bytes));

   return mcrypt_encrypt(MCRYPT_3DES, $key, $msg, MCRYPT_MODE_CBC, $iv);
}
</code></pre>

<p>And my corresponding C++ function, using Crypto++ is:</p>

<pre class=""lang-cxx prettyprint-override""><code>std::string des_ed3_crypt(std::string const&amp; msg, std::string const&amp; key)
{
    unsigned char iv[8] = { 0 }; // 0-filled

    CryptoPP::CBC_Mode&lt;CryptoPP::DES_EDE3&gt;::Encryption e;
    e.SetKeyWithIV(reinterpret_cast&lt;unsigned char const*&gt;(key.c_str()),
                   key.size(), iv);

    std::string ret;

    CryptoPP::StringSource(msg, true,
            new CryptoPP::StreamTransformationFilter
                 (e, new CryptoPP::StringSink(ret)));

    return ret;
}
</code></pre>

<p>But they don't return the same encrypted text. I want the change the C++ code to make equivalent to the PHP code, and not the opposite.</p>

<p>For the following key and message:</p>

<pre class=""lang-php prettyprint-override""><code>$key = ""keykeykeykeykeykeykeykey"";
$msg = $key;
</code></pre>

<p>The PHP code returns a cyphertext of 24 bytes (base64 encoded as):</p>

<pre class=""lang-none prettyprint-override""><code>a78URfI6EV8m3sTaDDDrntI8VbjWHiwm
</code></pre>

<p>But C++ returns a cyphertext of 32 bytes, but with a matching prefix of 24-bytes (base64 encoded as):</p>

<pre class=""lang-none prettyprint-override""><code>a78URfI6EV8m3sTaDDDrntI8VbjWHiwm9M15+pzUnuM=
</code></pre>

<p>So, there's some extra bytes in the C++ version which I don't know where do they come from. I think it can be related with the padding scheme, but I don't know the padding scheme used by PHP.</p>
","<p>Effectively, it was the padding. The PHP <code>mcrypt_crypto</code> function applies a zero-padding, so, I only have to specify to <code>cryptopp</code> that I want to apply a zero-padding to the encryption:</p>

<pre><code>std::string des_ed3_crypt(std::string const&amp; msg, std::string const&amp; key)
{
    unsigned char iv[8] = { 0 }; // 0-filled

    CryptoPP::CBC_Mode&lt;CryptoPP::DES_EDE3&gt;::Encryption e;
    e.SetKeyWithIV(reinterpret_cast&lt;unsigned char const*&gt;(key.c_str()),
                   key.size(), iv);

    std::string ret;

    CryptoPP::StringSource(msg, true,
        new CryptoPP::StreamTransformationFilter
            (e, new CryptoPP::StringSink(ret),
             CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme::ZEROS_PADDING));

    return ret;
}
</code></pre>
","221","<php><c++><crypto++><3des>","1","1","1","2016-10-12 20:50:10","39966278","0","","1794803","","2016-10-12 20:50:10","2016-10-10 17:45:12",""
"23219290","3des authentication no response","<p>I send the command 1A:00 to the Mifare Ultralight C tag by using APDU command <br/>
Here is the log: </p>

<p><code>inList passive target
write:  4A 1 0
read:   4B 1 1 0 44 0 7 4 C2 35 CA 2C 2C 80
write:  40 1 1A 0</code></p>

<p>I don't know why when I send 1A 00, it did not respond with RndA? <br/>
My code is this: <br/>
<code>bool success = nfc.inListPassiveTarget();
    if (success) {
    uint8_t auth_apdu[] = {
        0x1A, 
        0x00
    };
    uint8_t response[255];
    uint8_t responseLength = 255;
    success = nfc.inDataExchange(auth_apdu, sizeof(auth_apdu), response, &amp;responseLength);
    if (success) {
      Serial.println(""\n Successfully sent 1st auth_apdu \n"");
      Serial.println(""\n The response is: \n"");
      nfc.PrintHexChar(response, responseLength);
        }</code> <br/>
When I try to read pages with command 0x30, , it works OK, but not the authentication command: 1A:00 <br/>
I don't know what I am doing wrong here</p>
","<p>The answer is that I should use <code>inCommunicateThru</code> ( 0x42 ) instead of <code>inDataExchange</code>  ( 0x40 ).<br>
Thus the correct command should be : <code>0x42 1A 0</code></p>
","217","<authentication><mifare><3des>","0","1","1","2014-05-02 14:29:19","","1","","","","","2014-04-22 12:16:02",""
"23456852","3des for arduino uno","<p>I am working with Arduino Uno board, and I want to reuse 3DES from one open source, I have known that libnfc and libfreefare having those functions but those cannot be extracted to run on Arduino. Does anyone knows where I can find the library that works for Arduino Uno?</p>
","<p>ArduinoDES should be good choice - you have options for DES and triple DES:
<a href=""http://spaniakos.github.io/ArduinoDES/"" rel=""nofollow"">http://spaniakos.github.io/ArduinoDES/</a></p>
","212","<arduino><3des>","1","0","1","2016-06-19 20:41:51","","0","","","","","2014-05-04 13:31:42",""
"44936947","iOS 3DES encryption for TPV payments","<p>I'm developing an iOS app that makes payments through a TPV Redsys API. I'm following the documents but it's not working (server returns error due to an incorrect signature) and I guess it's because of the 3DES encryption.</p>

<p>I'm using the test data from the documentation so the output should be the same as in the documentation.
This is my code:</p>

<pre><code>- (void) payViaTPVWithAmount:(NSString *)amount andOrderId:(NSString *)orderId
{
    // I don't use my amount and orderId but those provided by the documentation to test
    // We need to obtain 3 fields:  DS_SIGNATURE_VERSION, DS_MERCHANTPARAMETERS and DS_SIGNATURE.

    // 1) Obtaining DS_SIGNATURE_VERSION
    NSString *dsSignatureVersion = @""HMAC_SHA256_V1""; 
    // &gt;&gt;&gt;&gt; This step is easy and of course is correct &lt;&lt;&lt;&lt;

    // 2) Obtaining DS_MERCHANTPARAMETERS
    // 2.1) Build params JSON -using test data-
    NSString *params = [NSString stringWithFormat: @""{\""DS_MERCHANT_AMOUNT\"":\""%@\"",\""DS_MERCHANT_ORDER\"":\""%@\"",\""DS_MERCHANT_MERCHANTCODE\"":\""%@\"",\""DS_MERCHANT_CURRENCY\"":\""978\"",\""DS_MERCHANT_TRANSACTIONTYPE\"":\""0\"",\""DS_MERCHANT_TERMINAL\"":\""%@\"",\""DS_MERCHANT_MERCHANTURL\"":\""%@\"",\""DS_MERCHANT_URLOK\"":\""%@\"",\""DS_MERCHANT_URLKO\"":\""%@\""}"",
                        @""145"",
                        @""1446117555"",
                        @""327234688"",
                        @""1"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlNotificacion.php"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlOK.php"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlKO.php""];

    //2.2) convert JSON params to base64
    NSData *paramsData = [params dataUsingEncoding:NSUTF8StringEncoding];
    NSString *paramsBase64 = [paramsData base64EncodedStringWithOptions:0];

    NSLog(@""apiMacSHA256\n%@"", params);
    NSLog(@""apiMacSHA256Base64\n%@"", paramsBase64); 
    // &gt;&gt;&gt;&gt;&gt; This output is identical to that included in the documents so this step 2 is ok. &lt;&lt;&lt;&lt;&lt;

    // 3) Obtaining DS_SIGNATURE
    // 3.1) start with secret key -the document gives this for test purposes-
    NSString *merchantKey = @""sq7HjrUOBfKmC576ILgskD5srU870gJ7""; //32 bytes

    // 3.2) convert it to base64
    NSData *merchantKeyData = [merchantKey dataUsingEncoding:NSUTF8StringEncoding];
    NSString *merchantKeyBase64 = [merchantKeyData base64EncodedStringWithOptions:0];

    // 3.3) the documentation doesn't say to convert this key to Hex but I have the Android code (which is working) and it has this step. 
    // Anyway I've tested with both options, with this step and without this step.
    NSData *merchantKeyBase64Data = [merchantKeyBase64 dataUsingEncoding:NSUTF8StringEncoding];
    NSString *merchantHex = [merchantKeyBase64Data hexadecimalString];

    // 3.4) get 3DES from orderId and base 64 (or Hex depending on if step 3.3 is done) key just obtained
    NSData *operationKey = [self encrypt_3DSWithKey:merchantHex andOrderId:@""1446117555""];

    // 3.5) get HMAC SHA256 from operationkey and ds_merchantparameters
    NSData *signatureHmac256 = [self mac256WithKey:operationKey andString:paramsBase64];

    // 3.6) convert HMAC SHA256 to base64
    NSString *signatureHmac256Base64 = [signatureHmac256 base64EncodedStringWithOptions:0];

    NSLog(@""signatureHmac256Base64\n%@"", signatureHmac256Base64);
    // This step is not working, the signature is not the correct one and the connection to the TPV Redsys system fails.

    // 4) Build the request
    // Set URL - using URL for development purposes-
    NSURL *url = [NSURL URLWithString:@""https://sis-t.redsys.es:25443/sis/realizarPago""];

    NSString *dsSignatureVersionEncoded = [dsSignatureVersion stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLUserAllowedCharacterSet]];
    NSString *paramsHTTPEncoded = [paramsBase64 stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLUserAllowedCharacterSet]];
    NSString *signatureHmac256HTTPEncoded = [signatureHmac256Base64 stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLUserAllowedCharacterSet]];

    NSString *body = [NSString stringWithFormat:@""DS_SIGNATURE=%@&amp;DS_MERCHANTPARAMETERS=%@&amp;DS_SIGNATUREVERSION=%@"", signatureHmac256HTTPEncoded, paramsHTTPEncoded, dsSignatureVersionEncoded];

    NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL: url];
    [request setHTTPMethod: @""POST""];
    [request setHTTPBody: [body dataUsingEncoding: NSUTF8StringEncoding allowLossyConversion:false]];

    [_webViewer loadRequest:request];
}

- (NSData *)encrypt_3DSWithKey:(NSString *)key andOrderId:(NSString *)str
{
    NSData *plainData = [str dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t bufferSize = plainData.length + kCCKeySize3DES;
    NSMutableData *cypherData = [NSMutableData dataWithLength:bufferSize];
    size_t movedBytes = 0;

    CCCryptorStatus ccStatus;
    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionECBMode,
                       keyData.bytes,
                       kCCKeySize3DES,
                       NULL,
                       plainData.bytes,
                       plainData.length,
                       cypherData.mutableBytes,
                       cypherData.length,
                       &amp;movedBytes);

    cypherData.length = movedBytes;

    if(ccStatus == kCCSuccess)
    {
        NSLog(@""Data: %@"",cypherData);
    }
    else
    {
        NSLog(@""Failed DES decrypt, status: %d"", ccStatus);
    }
    return cypherData;
}

- (NSData *)mac256WithKey:(NSData *)key andString:(NSString *)str
{
    NSData *strData = [str dataUsingEncoding:NSUTF8StringEncoding];
    NSMutableData* hash = [NSMutableData dataWithLength:CC_SHA256_DIGEST_LENGTH ];
    CCHmac(kCCHmacAlgSHA256, key.bytes, key.length, strData.bytes, strData.length, hash.mutableBytes);
    return hash;
}
</code></pre>

<p>This version fails because I get an encryption error due to alignment, so I modified the encryption to this:</p>

<pre><code>    NSString *initVec = @""\0\0\0\0\0\0\0\0"";
    const void *vinitVec = (const void *) [initVec UTF8String];

    CCCryptorStatus ccStatus;
    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       keyData.bytes,
                       kCCKeySize3DES,
                       vinitVec,
                       plainData.bytes,
                       plainData.length,
                       cypherData.mutableBytes,
                       cypherData.length,
                       &amp;movedBytes);
</code></pre>

<p>This time the encryption seems to be success but the output is not the expected one.</p>

<p>I've tried with the code from this <a href=""https://stackoverflow.com/questions/33799494/3des-encrypt-result-in-php-java-and-net-produces-different-result-from-3des-io"">SO Question</a> but it fails too (incorrect signature and the connection fails).</p>

<p>Is there any error with this code?</p>

<p>I know that is difficult but someone that had used TPV Redsys API to make payments successfully could see what's the problem?</p>

<p><strong>EDIT 1:</strong> </p>

<p>This is what the documentation says about how to get DS_SIGNATURE:</p>

<p><strong>Sign the request data</strong></p>

<p>Once you have the string of data to be signed and the terminal specific key, the signature has to be calculated following these steps:</p>

<ol>
<li><p>A specific key is generated per operation. To obtain the
specific key to be used in an operation, it must be performed a
3DES encryption between the merchant key, which must be
previously decoded in BASE 64, and the value of the order Id (Ds_Merchant_Order).</p></li>
<li><p>The HMAC SHA256 has to be calculated from the parameter value
Ds_MerchantParameters and the key obtained in the previous step.</p></li>
<li><p>The result obtained has to be coded in BASE 64, and the result of this
coding will be the value of the Ds_Signature parameter.</p></li>
</ol>

<p>And since I've got the Redsys API SDK for Java (there is no SKD for iOS) this is what it does to generate Ds_Signature parameter:</p>

<pre><code>public  String createMerchantSignature(final String merchantKey) throws Exception {
        String merchantParams = createMerchantParameters();

        byte [] key = decodeB64(merchantKey.getBytes(""UTF-8""));
        String secretKc = toHexadecimal(key, key.length);
        byte [] secretKo = encrypt_3DES(secretKc, getOrder());

        // MAC with the operation key ""Ko"" and then coded in BASE64
        byte [] hash = mac256(merchantParams, secretKo);
        String res = encodeB64String(hash);
        return res;
}
</code></pre>

<p>And what the server expects is something like that:</p>

<p>Expected Ds_SignatureVersion</p>

<p>HMAC_SHA256_V1</p>

<p>Expected Ds_MerchantParameters</p>

<p>eyJEU19NRVJDSEFOVF9BTU9VTlQiOiIxNDUiLCJEU19NRVJDSEFOVF9PUkRFUiI6IjE0NDYwNjg1ODEiLCJEU19NRVJDSEFOVF9NRVJDSEFOVENPREUiOiIzMjcyMzQ2ODgiLCJEU19NRVJDSEFOVF9DVVJSRU5DWSI6Ijk3OCIsIkRTX01FUkNIQU5UX1RSQU5TQUNUSU9OVFlQRSI6IjAiLCJEU19NRVJDSEFOVF9URVJNSU5BTCI6IjEiLCJEU19NRVJDSEFOVF9NRVJDSEFOVFVSTCI6Imh0dHA6XC9cL3d3dy5iYW5jc2FiYWRlbGwuY29tXC91cmxOb3RpZmljYWNpb24ucGhwIiwiRFNfTUVSQ0hBTlRfVVJMT0siOiJodHRwOlwvXC93d3cuYmFuY3NhYmFkZWxsLmNvbVwvdXJsT0sucGhwIiwiRFNfTUVSQ0hBTlRfVVJMS08iOiJodHRwOlwvXC93d3cuYmFuY3NhYmFkZWxsLmNvbVwvdXJsS08ucGhwIiwiRFNfTUVSQ0hBTlRfUEFOIjoiNDU0ODgxMjA0OTQwMDAwNCIsIkRTX01FUkNIQU5UX0VYUElSWURBVEUiOiIxNTEyIiwiRFNfTUVSQ0hBTlRfQ1ZWMiI6IjEyMyJ9</p>

<p>With my code I get this exact base64 string, so the code is ok.</p>

<p>Expected Ds_Signature</p>

<p>QfLVUv4nF2Nw7jBAkw0w8H0eRlwh2E1w/ZlKHdA2Sq0=</p>

<p>With my code my Ds_Signature is longer than the expected one:
ly2hYyjVlXQF%2FvgdEXBOj0obUdC7r5IERdEpLPSPksA=</p>

<p><strong>EDIT 2:</strong></p>

<p>I've made some changes based on zaph comments. I've removed the encoding for URLs and I've recalculated steps 3.2 and 3.3. This is my code now:</p>

<pre><code>- (void) payViaTPVWithAmount:(NSString *)amount andOrderId:(NSString *)orderId
{
    // I don't use my amount and orderId but those provided by the documentation to test
    // We need to obtain 3 fields:  DS_SIGNATURE_VERSION, DS_MERCHANTPARAMETERS and DS_SIGNATURE.

    // 1) Obtaining DS_SIGNATURE_VERSION
    NSString *dsSignatureVersion = @""HMAC_SHA256_V1""; 
    // &gt;&gt;&gt;&gt; This step is easy and of course is correct &lt;&lt;&lt;&lt;

    // 2) Obtaining DS_MERCHANTPARAMETERS
    // 2.1) Build params JSON -using test data-
    NSString *params = [NSString stringWithFormat: @""{\""DS_MERCHANT_AMOUNT\"":\""%@\"",\""DS_MERCHANT_ORDER\"":\""%@\"",\""DS_MERCHANT_MERCHANTCODE\"":\""%@\"",\""DS_MERCHANT_CURRENCY\"":\""978\"",\""DS_MERCHANT_TRANSACTIONTYPE\"":\""0\"",\""DS_MERCHANT_TERMINAL\"":\""%@\"",\""DS_MERCHANT_MERCHANTURL\"":\""%@\"",\""DS_MERCHANT_URLOK\"":\""%@\"",\""DS_MERCHANT_URLKO\"":\""%@\""}"",
                        @""145"",
                        @""1446117555"",
                        @""327234688"",
                        @""1"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlNotificacion.php"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlOK.php"",
                        @""http:\\/\\/www.bancsabadell.com\\/urlKO.php""];

    //2.2) convert JSON params to base64
    NSData *paramsData = [params dataUsingEncoding:NSUTF8StringEncoding];
    NSString *paramsBase64 = [paramsData base64EncodedStringWithOptions:0];

    NSLog(@""apiMacSHA256\n%@"", params);
    NSLog(@""apiMacSHA256Base64\n%@"", paramsBase64); 
    // &gt;&gt;&gt;&gt;&gt; This output is identical to that included in the documents so this step 2 is ok. &lt;&lt;&lt;&lt;&lt;

    // 3) Obtaining DS_SIGNATURE
    // 3.1) start with secret key -the document gives this for test purposes-
    NSString *merchantKey = @""sq7HjrUOBfKmC576ILgskD5srU870gJ7""; //32 bytes

    // 3.2) convert it to base64
    NSData *merchantKeyData = [merchantKey dataUsingEncoding:NSUTF8StringEncoding];
    NSData *merchantKeyBase64Data = [merchantKeyData base64EncodedDataWithOptions:0];

    // 3.3) the documentation doesn't say to convert this key to Hex but I have the Android code (which is working) and it has this step. 
    // Anyway I've tested with both options, with this step and without this step.
    NSString *merchantHex = [merchantKeyBase64Data hexadecimalString];

    // 3.4) get 3DES from orderId and base 64 (or Hex depending on if step 3.3 is done) key just obtained
    NSData *operationKey = [self encrypt_3DSWithKey:merchantHex andOrderId:@""1446117555""];

    // 3.5) get HMAC SHA256 from operationkey and ds_merchantparameters
    NSData *signatureHmac256 = [self mac256WithKey:operationKey andString:paramsBase64];

    // 3.6) convert HMAC SHA256 to base64
    NSString *signatureHmac256Base64 = [signatureHmac256 base64EncodedStringWithOptions:0];

    NSLog(@""signatureHmac256Base64\n%@"", signatureHmac256Base64);
    // This step is not working, the signature is not the correct one and the connection to the TPV Redsys system fails.

    // 4) Build the request
    // Set URL - using URL for development purposes-
    NSURL *url = [NSURL URLWithString:@""https://sis-t.redsys.es:25443/sis/realizarPago""];

    NSString *body = [NSString stringWithFormat:@""DS_SIGNATURE=%@&amp;DS_MERCHANTPARAMETERS=%@&amp;DS_SIGNATUREVERSION=%@"", signatureHmac256HTTPEncoded, paramsHTTPEncoded, dsSignatureVersionEncoded];

    NSMutableURLRequest *request = [[NSMutableURLRequest alloc]initWithURL: url];
    [request setHTTPMethod: @""POST""];
    [request setHTTPBody: [body dataUsingEncoding: NSUTF8StringEncoding allowLossyConversion:false]];

    [_webViewer loadRequest:request];
}

- (NSData *)encrypt_3DSWithKey:(NSString *)key andOrderId:(NSString *)str
{
    NSData *plainData = [str dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];

    size_t bufferSize = plainData.length + kCCKeySize3DES;
    NSMutableData *cypherData = [NSMutableData dataWithLength:bufferSize];
    size_t movedBytes = 0;

    NSString *initVec = @""\0\0\0\0\0\0\0\0"";
    const void *vinitVec = (const void *) [initVec UTF8String];

    CCCryptorStatus ccStatus;
    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       keyData.bytes,
                       kCCKeySize3DES,
                       vinitVec,
                       plainData.bytes,
                       plainData.length,
                       cypherData.mutableBytes,
                       cypherData.length,
                       &amp;movedBytes);

    cypherData.length = movedBytes;

    if(ccStatus == kCCSuccess)
    {
        NSLog(@""Data: %@"",cypherData);
    }
    else
    {
        NSLog(@""Failed DES decrypt, status: %d"", ccStatus);
    }
    return cypherData;
}

- (NSData *)mac256WithKey:(NSData *)key andString:(NSString *)str
{
    NSData *strData = [str dataUsingEncoding:NSUTF8StringEncoding];
    NSMutableData* hash = [NSMutableData dataWithLength:CC_SHA256_DIGEST_LENGTH ];
    CCHmac(kCCHmacAlgSHA256, key.bytes, key.length, strData.bytes, strData.length, hash.mutableBytes);
    return hash;
}
</code></pre>

<p>My Ds_Signature is now R8+4R6diEbm3nJR6KmonYDy53Zi4CZpuxdoMZtucGX4= (different than the expected one) and the connection still fails.</p>
","","210","<ios><encryption><3des>","0","","0","2017-07-06 22:42:42","","4","0","1639825","","2017-07-06 22:42:42","2017-07-05 22:25:27",""
"10238021","How could I can get this encrypt result in java with 3DES(DESede) encrypt method?","<p><BR /><strong>Key:</strong> 31323334353637383837363534333231
<BR /><strong>Expressly:</strong> 21222324252627281122334455667788
<BR /><strong>Ciphertext:</strong> 0b8bbac7d7c5f6c5879170f3a9ad7099</p>

<p>The above result is achieved in the C++ language. 3DES encryption key is allows to be 16 bytes in C++, but it must be 24 bytes in java (if insufficient padded).</p>

<p>Now， how to do in java，then I could get the encrypted result like 0b8bbac7d7c5f6c5879170f3a9ad7099</p>
","","209","<java><c++><incompatibility><3des><password-encryption>","0","","0","2013-04-06 20:47:31","","2","","1697109","","2013-04-06 20:47:31","2012-04-19 22:56:55",""
"40242396","Equal Objective C result for java Cipher.getInstance(""DESede/ECB/NoPadding"")","<p>Java code is done to generate 3DES result, segment code as below:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""DESede/ECB/NoPadding""); 
cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] result = cipher.doFinal(data);
</code></pre>

<p>Now, I need to implement same result in objective-C, below is my try, but the result is not even close.</p>

<pre><code>+(NSString *) try3DES:(NSString *)plainText key:(NSString *)key
{
    NSString *ciphertext = nil;
    NSData *textData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [textData length];
    unsigned char buffer[1024];
    memset(buffer, 0, sizeof(char));
    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                      kCCAlgorithmDES,
                                      kCCOptionPKCS7Padding,
                                      [key UTF8String],
                                      kCCKeySizeDES,
                                      nil,
                                      [textData bytes],
                                      dataLength,
                                      buffer,
                                      1024,
                                      &amp;numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted];

        ciphertext = [self convertDataToHexStr:data];
    }
    return ciphertext;
}
</code></pre>

<p>Could anybody can help?</p>
","","205","<objective-c><3des>","0","","0","2016-11-09 11:22:05","","2","2","","","","2016-10-25 14:14:12",""
"10548073","What is triple DESm (3DESm) encryption method? Is it much different from 3DES?","<p>I have to decrypt an encrypted message in C program which has been encrypted using 3DESm method in CBC mode. It looks quite different from the encrypted message that we get from 3DES method. Generally the ciphertext that we get after encrypting from is a hexadecimal number which is of length 16 and has includes the characters like 0-9 and A-F only. But the ciphertext that I need to decrypt is more than 20 characters in length and includes all characters from A-Z, a-z , 0-9 and also includes few special characters like '+' and '='.
Which library would be helpful to do the needful?</p>
","<p>The ciphertext you get from any normal blockcipher consistst of raw bytes/ binary data, not hex. In the case of DES these are 8 bytes per block.</p>

<p>You can then encode them, if you prefer text over binary data. Looks like your ciphertext was Base64 and not Hex encoded. But that's a choice independent from the choice of cipher.</p>

<p>Base64 uses all ASCII letters and numbers as well as <code>+</code> and <code>/</code> to encode the data, and <code>=</code> as padding if the input isn't a multiple of 6 bits.</p>
","203","<c><encryption><3des>","0","1","1","2012-05-11 08:48:20","10548148","1","","","","","2012-05-11 08:36:09",""
"10481835","From where can I get a library for c which will help me to write a C program to decrypt through 3DES in CBC mode?","<p>I want to write a simple program where I can call the functions from a library and pass them the encrypted data as input and get the output as the decrypted data.
Which C library would be suitable for this.</p>
","<p><a href=""http://www.openssl.org"" rel=""nofollow"">OpenSSL</a> will probably be your best bet. It's available on most systems, and has functions for doing triple-DES (e.g. DES_ede3_cbc_encrypt). See <a href=""http://www.openssl.org/docs/crypto/des.html"" rel=""nofollow"">the des(3) man page</a> for more information.</p>

<p>Most Linux distributions will have a development package for openssl which contains the header files for the library. On Debian-based distros (like Ubuntu), do <code>sudo apt-get install openssl-dev</code>. Alternatively, you can download the <a href=""http://openssl.org/source/"" rel=""nofollow"">library source</a> and compile it yourself.</p>
","186","<3des>","-1","0","1","2012-05-07 16:22:21","","0","","","","","2012-05-07 12:10:55",""
"32887311","Decoding char to UTF8 in C after 3DES decryption","<p>I need some help decoding a char in C to its UTF8 interpretation.</p>

<p>My code so far works this way:</p>

<ul>
<li>A <code>char</code> is initialised with hexadecimal representation of 'password' <code>70617373776F7264</code></li>
<li>It is then encrypted using 3DES <code>DD201F609E49C0609FABA4C8AAFBB1E5</code></li>
<li>Then it is decrypted successfully using 3DES <code>70617373776F72640808080808080808</code></li>
</ul>

<p>In the<code>printf(""decrypted: %s"",dec)</code> statement, all looks fine and it is displayed as <code>decrypted: password</code></p>

<p>However when doing a string compare, it does not match. Looking closely at the char, I can see that it comes out as <code>\001password\010\010\010\010\010\010\010\010</code> (this is due to the padding)</p>

<p>Is there any way to either un-pad or to decode to <em>UTF8</em>? <a href=""http://software.hixie.ch/utilities/cgi/unicode-decoder/utf8-decoder"" rel=""nofollow"">something similar to this</a></p>

<p>Edit with code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/des.h&gt;
#include &lt;openssl/rand.h&gt;
#include &lt;ldap.h&gt;
#include ""k.h""
#include ""hex.h""


#define ULONG unsigned long
#define INT unsigned int


char *encrypt(char *data)
{

  int i = 0;
  int len = 0;
  int nlen = 0;


  char *key1 = ""1313232323231313"";
  char *key2 = ""6789678967896789"";
  char *key3 = ""1313232323231313"";

  /* Padding */
  char ch = '\0';
  unsigned char out[64] = {0};
  unsigned char src[64] = {0};


  unsigned char *ptr  = NULL;
  unsigned char block[8] = {0};
  DES_key_schedule ks1, ks2, ks3;

  /* set password table */
  ptr = hex2bin(key1, strlen(key1), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks1);

  ptr = hex2bin(key2, strlen(key2), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks2);

  ptr = hex2bin(key3, strlen(key3), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks3);

  ptr = hex2bin(data, strlen(data), &amp;nlen);
  memcpy(src, ptr, nlen);
  free(ptr);

  len = (nlen / 8 + (nlen % 8 ? 1: 0)) * 8;

  ch = 8 - nlen % 8;
  memset(src + nlen, ch, (8 - nlen % 8) % 8);

  printf(""Raw data: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(src + i));
  }
  printf(""\n"");

  for (i = 0; i &lt; len; i += 8) {
      DES_ecb3_encrypt((C_Block *)(src + i), (C_Block *)(out + i), &amp;ks1, &amp;ks2, &amp;ks3, DES_ENCRYPT);
  }

  printf(""Encrypted: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"" , *(out + i));
  }
  printf(""\n"");


  return out;

}


char *decrypt(char *data)
{

  int i = 0;
  int len = 0;
  int nlen = 0;


  char *key1 = ""1313232323231313"";
  char *key2 = ""6789678967896789"";
  char *key3 = ""1313232323231313"";

  /* Padding */
  int ch = 0;
  unsigned char out[64] = {0};
  unsigned char src[64] = {0};


  unsigned char *ptr  = NULL;
  unsigned char block[8] = {0};
  DES_key_schedule ks1, ks2, ks3;

  /* set password table */
  ptr = hex2bin(key1, strlen(key1), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks1);

  ptr = hex2bin(key2, strlen(key2), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks2);

  ptr = hex2bin(key3, strlen(key3), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks3);

  ptr = hex2bin(data, strlen(data), &amp;nlen);
  memcpy(src, ptr, nlen);
  free(ptr);

  len = (nlen / 8 + (nlen % 8 ? 1: 0)) * 8;

  ch = 8 - nlen % 8;
  memset(src + nlen, ch, (8 - nlen % 8) % 8);

  printf(""Raw data: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(src + i));
  }
  printf(""\n"");

  for (i = 0; i &lt; len; i += 8) {
      DES_ecb3_encrypt((C_Block *)(src + i), (C_Block *)(out + i), &amp;ks1, &amp;ks2, &amp;ks3, DES_DECRYPT);
  }

  printf(""Decrypted: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(out + i));
  }

  printf(""\n"");
  return out;

}


K DES_ecb3_do(K user, K pass,K fl )
{
  int res = 0;
  int flag = fl-&gt;i;
  char *usn = user-&gt;s;

  char *enc = pass-&gt;s;
  char *decr = """";
  char dec[32];

  if(flag==1)
  {
    decr = encrypt(enc);
    strcat(dec,decr);
  }
  else if(flag==0)
  {
    decr = decrypt(enc);
    strcat(dec,decr);
  }
  int ret;
  ret = strcmp(dec, ""password"");
  if(ret==0)
  {
    printf(""they match"");
  }
  else
  {
    printf(""they don't match\n"");
    return (K) 0;
  }  
 printf(""decrypted pass is:%s\n"",dec);

   return ks(dec);
}
</code></pre>
","<p>Is it because your decrypted string is not NULL terminated?
Also if your ""string comparison"" is 
    if(dec == ""password"")
Then that's not going to work, try 
    if (strcmp(dec, ""password"") == 0)</p>
","184","<c><encryption><padding><3des>","0","0","2","2015-10-01 15:13:26","32890417","9","","888105","","2015-10-01 14:13:44","2015-10-01 12:11:02",""
"32887311","Decoding char to UTF8 in C after 3DES decryption","<p>I need some help decoding a char in C to its UTF8 interpretation.</p>

<p>My code so far works this way:</p>

<ul>
<li>A <code>char</code> is initialised with hexadecimal representation of 'password' <code>70617373776F7264</code></li>
<li>It is then encrypted using 3DES <code>DD201F609E49C0609FABA4C8AAFBB1E5</code></li>
<li>Then it is decrypted successfully using 3DES <code>70617373776F72640808080808080808</code></li>
</ul>

<p>In the<code>printf(""decrypted: %s"",dec)</code> statement, all looks fine and it is displayed as <code>decrypted: password</code></p>

<p>However when doing a string compare, it does not match. Looking closely at the char, I can see that it comes out as <code>\001password\010\010\010\010\010\010\010\010</code> (this is due to the padding)</p>

<p>Is there any way to either un-pad or to decode to <em>UTF8</em>? <a href=""http://software.hixie.ch/utilities/cgi/unicode-decoder/utf8-decoder"" rel=""nofollow"">something similar to this</a></p>

<p>Edit with code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/des.h&gt;
#include &lt;openssl/rand.h&gt;
#include &lt;ldap.h&gt;
#include ""k.h""
#include ""hex.h""


#define ULONG unsigned long
#define INT unsigned int


char *encrypt(char *data)
{

  int i = 0;
  int len = 0;
  int nlen = 0;


  char *key1 = ""1313232323231313"";
  char *key2 = ""6789678967896789"";
  char *key3 = ""1313232323231313"";

  /* Padding */
  char ch = '\0';
  unsigned char out[64] = {0};
  unsigned char src[64] = {0};


  unsigned char *ptr  = NULL;
  unsigned char block[8] = {0};
  DES_key_schedule ks1, ks2, ks3;

  /* set password table */
  ptr = hex2bin(key1, strlen(key1), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks1);

  ptr = hex2bin(key2, strlen(key2), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks2);

  ptr = hex2bin(key3, strlen(key3), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks3);

  ptr = hex2bin(data, strlen(data), &amp;nlen);
  memcpy(src, ptr, nlen);
  free(ptr);

  len = (nlen / 8 + (nlen % 8 ? 1: 0)) * 8;

  ch = 8 - nlen % 8;
  memset(src + nlen, ch, (8 - nlen % 8) % 8);

  printf(""Raw data: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(src + i));
  }
  printf(""\n"");

  for (i = 0; i &lt; len; i += 8) {
      DES_ecb3_encrypt((C_Block *)(src + i), (C_Block *)(out + i), &amp;ks1, &amp;ks2, &amp;ks3, DES_ENCRYPT);
  }

  printf(""Encrypted: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"" , *(out + i));
  }
  printf(""\n"");


  return out;

}


char *decrypt(char *data)
{

  int i = 0;
  int len = 0;
  int nlen = 0;


  char *key1 = ""1313232323231313"";
  char *key2 = ""6789678967896789"";
  char *key3 = ""1313232323231313"";

  /* Padding */
  int ch = 0;
  unsigned char out[64] = {0};
  unsigned char src[64] = {0};


  unsigned char *ptr  = NULL;
  unsigned char block[8] = {0};
  DES_key_schedule ks1, ks2, ks3;

  /* set password table */
  ptr = hex2bin(key1, strlen(key1), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks1);

  ptr = hex2bin(key2, strlen(key2), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks2);

  ptr = hex2bin(key3, strlen(key3), &amp;nlen);
  memcpy(block, ptr, sizeof(block));
  free(ptr);
  DES_set_key_unchecked((C_Block *)block, &amp;ks3);

  ptr = hex2bin(data, strlen(data), &amp;nlen);
  memcpy(src, ptr, nlen);
  free(ptr);

  len = (nlen / 8 + (nlen % 8 ? 1: 0)) * 8;

  ch = 8 - nlen % 8;
  memset(src + nlen, ch, (8 - nlen % 8) % 8);

  printf(""Raw data: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(src + i));
  }
  printf(""\n"");

  for (i = 0; i &lt; len; i += 8) {
      DES_ecb3_encrypt((C_Block *)(src + i), (C_Block *)(out + i), &amp;ks1, &amp;ks2, &amp;ks3, DES_DECRYPT);
  }

  printf(""Decrypted: "");
  for (i = 0; i &lt; len; i++) {
      printf(""%02X"", *(out + i));
  }

  printf(""\n"");
  return out;

}


K DES_ecb3_do(K user, K pass,K fl )
{
  int res = 0;
  int flag = fl-&gt;i;
  char *usn = user-&gt;s;

  char *enc = pass-&gt;s;
  char *decr = """";
  char dec[32];

  if(flag==1)
  {
    decr = encrypt(enc);
    strcat(dec,decr);
  }
  else if(flag==0)
  {
    decr = decrypt(enc);
    strcat(dec,decr);
  }
  int ret;
  ret = strcmp(dec, ""password"");
  if(ret==0)
  {
    printf(""they match"");
  }
  else
  {
    printf(""they don't match\n"");
    return (K) 0;
  }  
 printf(""decrypted pass is:%s\n"",dec);

   return ks(dec);
}
</code></pre>
","<p>In <code>decrypt</code> function you return the result of decryption from a local variable, that is out of scope in the caller.</p>

<p>Change <code>out[64]</code> to <code>static</code> or as global, or <code>malloc</code> it.</p>

<p>Finally your code invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a> because of you are returning an address of stack area.</p>

<p><strong>EDIT after OP comment request</strong></p>

<p>Your code is</p>

<pre><code>char *decrypt(char *data)
{

  int i = 0;
  int len = 0;
  int nlen = 0;


  char *key1 = ""1313232323231313"";
  char *key2 = ""6789678967896789"";
  char *key3 = ""1313232323231313"";

  /* Padding */
  int ch = 0;
  unsigned char out[64] = {0};
  unsigned char src[64] = {0};

  // stuff....
 return out;
}
</code></pre>

<p>This code is declaring out array as local, otherwise stack allocated. That the variable is available only in local scope: inside <code>decrypt</code> function.</p>

<p>This means that when the function return to the caller function <code>DES_ecb3_do</code> a memory address that could be corrupted. You should not access that address.</p>

<p>To solve the problem you must make <code>out</code> variable available out of <code>decrypt</code> function scope using, for example, one of the following:</p>

<p>1) you define the <code>out</code> as <code>global</code>:</p>

<pre><code>unsigned char out[64] = {0};

char *decrypt(char *data)
{
   // STUFF
}
</code></pre>

<p>2) You define <code>out</code> as <code>static</code> inside your function:</p>

<pre><code>char *decrypt(char *data)
{
   static unsigned char out[64] = {0};
   // STUFF
}
</code></pre>

<p>3) You define <code>out</code> as a poiter and <code>malloc</code> it:</p>

<pre><code>char *decrypt(char *data)
{
   unsigned char *out] = malloc(64);
   // STUFF
}
</code></pre>

<p>Hope it is clear enough.</p>
","184","<c><encryption><padding><3des>","0","2","2","2015-10-01 15:13:26","32890417","9","","888105","","2015-10-01 14:13:44","2015-10-01 12:11:02",""
"35555236","Getting wrong Value after I decrypt the String using 3DES in Objective-c","<p>3DES encryption is working fine and getting wrong values for decryption with same logic.</p>

<p>Please find the below logic to call Encryption / Decryption method</p>

<pre><code>NSString *cipherEnString = [self doCipher:@""Test"" enc:kCCEncrypt];
NSString *cipherDecString = [self doCipher:cipherEnString enc:kCCDecrypt];
</code></pre>

<p>And the code for Encryption / Decryption is added below.</p>

<pre><code>- (NSString*) doCipher:(NSString*)plainText enc:(CCOperation)encryptOrDecrypt{
    const void *vplainText;
    size_t plainTextBufferSize;
    if (encryptOrDecrypt == kCCDecrypt)
    {
        NSString *encStr = [self encodeStringTo64:plainText];
        NSData *EncryptData = [encStr dataUsingEncoding:NSUTF8StringEncoding];        
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
    }
    else
    {
        plainTextBufferSize = [plainText length];
        vplainText = (const void *) [plainText UTF8String];
    }

    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    //  uint8_t ivkCCBlockSize3DES;

    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);

    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    unsigned char secretKey[24]=  {0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11,0x12, 0x11, 0x0D, 0x0B, 0x07, 0x02, 0x04,0x08,0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11};
    unsigned char IV3[8]={0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11};

    uint8_t iv[kCCBlockSize3DES];
    memset((void *) iv, 0x0, (size_t) sizeof(iv));

    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionPKCS7Padding ,
                       secretKey, //""123456789012345678901234"", //key
                       kCCKeySize3DES,
                       IV3 ,  //iv,
                       vplainText,  //plainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    /*else*/ if (ccStatus == kCCParamError) return @""PARAM ERROR"";
    else if (ccStatus == kCCBufferTooSmall) return @""BUFFER TOO SMALL"";
    else if (ccStatus == kCCMemoryFailure) return @""MEMORY FAILURE"";
    else if (ccStatus == kCCAlignmentError) return @""ALIGNMENT"";
    else if (ccStatus == kCCDecodeError) return @""DECODE ERROR"";
    else if (ccStatus == kCCUnimplemented) return @""UNIMPLEMENTED"";

    NSString *result;
    if (encryptOrDecrypt == kCCDecrypt)
    {
        result = [ [NSString alloc] initWithData: [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes] encoding:NSASCIIStringEncoding];
        NSString *s = [[NSString alloc] initWithBytes:bufferPtr
                                               length:movedBytes
                                             encoding:NSUTF8StringEncoding];
        NSLog(@""%@"",s);
    }
    else
    {
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        NSString *base64String = [myData base64EncodedStringWithOptions:0];
        return base64String;
    }
    return result;
}

- (NSString*)encodeStringTo64:(NSString*)fromString
{
    NSData *plainData = [fromString dataUsingEncoding:NSUTF8StringEncoding];
    NSString *base64String;
    if ([plainData respondsToSelector:@selector(base64EncodedStringWithOptions:)]) {
        base64String = [plainData base64EncodedStringWithOptions:kNilOptions];  // iOS 7+
    } 
    else {
        NSString *base64String = [plainData base64EncodedStringWithOptions:0];
        NSLog(@""%@"", base64String);// pre iOS7
    }
    return base64String;
}
</code></pre>
","<p>You are trying to hard to convert the base64 encrypted string to encrypted data:</p>

<p>Current:</p>

<pre><code>NSString *encStr = [self encodeStringTo64:plainText];
NSData *encryptData = [encStr dataUsingEncoding:NSUTF8StringEncoding];
</code></pre>

<p>Correct:</p>

<pre><code>NSData *encryptData = [[NSData alloc] initWithBase64EncodedString:plainText options:0];
</code></pre>

<p>Additionally you don't need the method:</p>

<pre><code>- (NSString *)encodeStringTo64:(NSString*)fromString
</code></pre>

<p>Adding a couple of hex dumps of the data to be encrypted/decrypted before and after would show this problem.</p>

<p>It is also better to create a basic encryption method that takes and returns <code>NSData</code> and add methods that perform any encoding/decoding that call the encryption method. Less co-mingling of responsibilities makes the code simpler and easier to understand and debug.</p>

<p>See this <a href=""https://stackoverflow.com/a/30167657/451475"">SO answer</a> to see how to eliminate <code>malloc</code> and instead just use <code>NSMutableData</code> instead.</p>
","173","<ios><objective-c><encryption><3des>","-2","0","1","2016-02-22 15:36:19","","5","","1689609","","2016-02-22 15:20:13","2016-02-22 13:43:24",""
"48464162","How to make Certbot disable a certain cipher","<p>I am using Let'sEncrypt's Certificates. In an attempt to stay compliant w/ PCI DSS standards, I disabled support for the Triple DES (3DES) cipher in the conf file for nginx. But Certbot then noted that if I manually changed a conf file, it won't automate the cert renewal process. Worse, the certbot's docs does not mention another way to go about disabling certain ciphers <strong>and</strong> keeping the automation. </p>

<p>Is there a workaround for this? Maybe I can have an additional nginx line that overrides the certbot's settings? Or am I missing something?</p>

<p>Here's my nginx.conf and other conf files in a gist: <a href=""https://gist.github.com/bluedeck/7a3a8614fe1cc86c1247b8f303ebcdd3"" rel=""nofollow noreferrer"">https://gist.github.com/bluedeck/7a3a8614fe1cc86c1247b8f303ebcdd3</a></p>
","<p>Maybe not the best way to do this but that's how i renew my certificates.</p>

<pre><code>#!/bin/bash
service nginx stop
certbot certonly --standalone --preferred-challenges http -d mysite.com
service nginx start
</code></pre>

<p>and just add it to your crontab. </p>
","171","<ssl><nginx><3des><pci-dss><certbot>","0","1","1","2018-03-21 23:39:39","","0","1","4661324","","2018-01-27 00:40:06","2018-01-26 15:13:13",""
"23012091","After getResponse the page loads but doesn't redirect","<p>C# Asp.Net Triple-Des</p>

<p>I have two aspx pages in a single project. For trial purposes these two pages are in a single project but in the future they will be on seperate servers.</p>

<p>There's a button on the first page (Default.aspx) and this is the code behind:</p>

<pre><code>protected void btnSub_Click(object sender, EventArgs e)
{
    var name = System.Security.Principal.WindowsIdentity.GetCurrent().Name;
    WebRequest req = null;
    WebResponse rsp = null;
    try
    {
        const string uri = ""http://localhost:52958/WebSite1/Default2.aspx"";
        req = WebRequest.Create(uri);
        req.Method = ""POST"";

        req.ContentType = ""text/xml"";
        var writer = new StreamWriter(req.GetRequestStream());
        var post = ""&lt;VbDoc&gt;&lt;Sicil&gt;a&lt;/Sicil&gt;,&lt;AdSoyad&gt;b&lt;/AdSoyad&gt;,&lt;SubeKodu&gt;c&lt;/SubeKodu&gt;,&lt;SubeAdi&gt;d&lt;/SubeAdi&gt;,&lt;Mail&gt;e&lt;/Mail&gt;,&lt;Tel&gt;f&lt;/Tel&gt;&lt;/VbDoc&gt;"";
        post = Encrypt(post);
        writer.Write(post);
        writer.Close();

        rsp = req.GetResponse();
    }
    catch
    {
        throw;
    }
    finally
    {
        if (req != null) req.GetRequestStream().Close();
        if (rsp != null) rsp.GetResponseStream().Close();
    }
}
</code></pre>

<p>On the second page (Default2.aspx) PageLoad gets activated when I debug and I can read the encrypted data but after page_load the page never gets visible, the old one stays. This is the page load of the second page.</p>

<pre><code>protected void Page_Load(object sender, EventArgs e)
{
    if (!Page.Response.IsRequestBeingRedirected)
    {
        Page.Response.ContentType = ""text/xml"";
        var reader = new StreamReader(Page.Request.InputStream);

        var xmlData = reader.ReadToEnd();

        if (xmlData.Length != 0)
        {
            xmlData = Decrypt(xmlData);
            TextBox1.Text = xmlData;
        }
    }

}
</code></pre>

<p>---If I use Response.Redirect on the first page the second page comes visible but I lose the encrypted data.</p>

<p>---My boss doesn't allow me to use query strings</p>

<p>How can I be able to read the response and show the second page.</p>

<p>Thanks in advance.</p>
","<p>I Solved it with html post mechanism. .cs like:</p>

<pre><code>protected void btnSub_Click(object sender, EventArgs e)
{ 
    var post = ""xml data"";
    post = Encrypt(post);
    Label1.Text = post;
}
</code></pre>

<p>.aspx is like</p>

<pre><code>&lt;body&gt;
    &lt;form id=""form1"" runat=""server"" &gt;
        &lt;asp:Label Visible=""False"" ID=""lblEncrypted""  runat=""server""&gt;&lt;/asp:Label&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;body&gt;
    &lt;form  name=""tokenForm"" method=""POST"" action=""http://localhost:52958/WebSite1/Default2.aspx""&gt;
        &lt;input type=""hidden"" name =""token"" value='&lt;%=Label1.Text%&gt;' /&gt;
        &lt;input type=""submit""  id=""btnGonder"" value=""gonder""/&gt;
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
","168","<c#><asp.net><.net><web><3des>","2","1","1","2014-04-15 08:23:27","23078207","5","","","","","2014-04-11 12:06:03",""
"18094078","3des encryption in iPhone padding issue","<p>I have a problem using 3DES encryption in my iPhone app. I have 9 byte message to be encrypted. When I use <code>kCCOptionECBMode</code>, the first 8 byte block is encrypted correctly (I have a sample result produced by server). How can I encrypt the last byte? When I use <code>kCCOptionPKCS7Padding</code> or <code>kCCOptionECBMode| kCCOptionPKCS7Padding</code>, it gives wrong result with status <code>kCCBufferTooSmall</code>. I have gone through some posts related to 3DES encryption on SO but not helped me.</p>

<pre><code> ccStatus = CCCrypt(kCCEncrypt,
                       kCCAlgorithm3DES,
                       kCCOptionECBMode,
                       vkey, 
                       kCCKeySize3DES,
                       vinitVec,
                       vplainText,
                       plainTextBufferSize,
                       (void *)bufferPtr,
                       [data length],
                       &amp;movedBytes);
</code></pre>
","<p>Problem was with data length parameter. I should calculate data length after padding and pass it to function. </p>
","168","<iphone><ios><encryption><3des>","1","0","1","2013-08-07 05:13:06","18094558","0","","463857","","2013-08-07 05:12:48","2013-08-07 03:20:31",""
"22878747","Triple Des SSH2 via phpseclib","<p>My intention is to use phpseclib to create a script that connects to a ssh2 enabled switch.</p>

<p>I have discovered that this switch only allows 3DES encryption and I dont know how to use Crypt_TripleDES() class together with NET_SSH2.</p>

<p>I couldnt find answer on the Internet and I would apreciate your help. </p>

<p>Thanks you!</p>

<p>Here is my code without 3Des and below you can see logs.</p>

<pre><code>set_include_path(get_include_path() . PATH_SEPARATOR . 'phpseclib');

include('./ssl/Crypt/TripleDES.php');
include('./ssl/Net/SSH2.php');

define('NET_SSH2_LOGGING', 3);

//$des = new Crypt_TripleDES();
//$des-&gt;setKey('');
//$des-&gt;encrypt('');

$ssh = new Net_SSH2('172.16.1.1');
if (!$ssh-&gt;login('admin','admin')) {
print_r($ssh-&gt;getLog());

    exit('Login Failed');
}
</code></pre>

<p>Here are the logs:</p>

<pre><code>-&gt;
00000000  53:53:48:2d:32:2e:30:2d:70:68:70:73:65:63:6c:69  SSH-2.0-phpsecli
00000010  62:5f:30:2e:33:20:28:6d:63:72:79:70:74:2c:20:62  b_0.3 (mcrypt, b
00000020  63:6d:61:74:68:29:0d:0a                          cmath)..

&lt;- NET_SSH2_MSG_KEXINIT (since last: 0.0687, network: 0.0124s)
00000000  ea:54:14:67:67:97:ab:2d:34:85:07:67:76:57:51:c1  .T.gg..-4..gvWQ.
00000010  00:00:00:1a:64:69:66:66:69:65:2d:68:65:6c:6c:6d  ....diffie-hellm
00000020  61:6e:2d:67:72:6f:75:70:31:2d:73:68:61:31:00:00  an-group1-sha1..
00000030  00:07:73:73:68:2d:72:73:61:00:00:00:08:33:64:65  ..ssh-rsa....3de
00000040  73:2d:63:62:63:00:00:00:08:33:64:65:73:2d:63:62  s-cbc....3des-cb
00000050  63:00:00:00:09:68:6d:61:63:2d:73:68:61:31:00:00  c....hmac-sha1..
00000060  00:09:68:6d:61:63:2d:73:68:61:31:00:00:00:04:6e  ..hmac-sha1....n
00000070  6f:6e:65:00:00:00:04:6e:6f:6e:65:00:00:00:00:00  one....none.....
00000080  00:00:00:00:00:00:00:00                          ........

-&gt; NET_SSH2_MSG_KEXINIT (since last: 0.0021, network: 0.0001s)
00000000  de:fa:51:fc:c3:63:3f:2e:3c:44:1a:03:7d:07:cb:b3  ..Q..c?..D..}...
00000010  00:00:00:36:64:69:66:66:69:65:2d:68:65:6c:6c:6d  ...6diffie-hellm
00000020  61:6e:2d:67:72:6f:75:70:31:2d:73:68:61:31:2c:64  an-group1-sha1,d
00000030  69:66:66:69:65:2d:68:65:6c:6c:6d:61:6e:2d:67:72  iffie-hellman-gr
00000040  6f:75:70:31:34:2d:73:68:61:31:00:00:00:0f:73:73  oup14-sha1....ss
00000050  68:2d:72:73:61:2c:73:73:68:2d:64:73:73:00:00:00  h-rsa,ssh-dss...
00000060  dc:61:72:63:66:6f:75:72:32:35:36:2c:61:72:63:66  .arcfour256,arcf
00000070  6f:75:72:31:32:38:2c:61:72:63:66:6f:75:72:2c:61  our128,arcfour,a
00000080  65:73:31:32:38:2d:63:74:72:2c:61:65:73:31:39:32  es128-ctr,aes192
00000090  2d:63:74:72:2c:61:65:73:32:35:36:2d:63:74:72:2c  -ctr,aes256-ctr,
000000a0  74:77:6f:66:69:73:68:31:32:38:2d:63:74:72:2c:74  twofish128-ctr,t
000000b0  77:6f:66:69:73:68:31:39:32:2d:63:74:72:2c:74:77  wofish192-ctr,tw
000000c0  6f:66:69:73:68:32:35:36:2d:63:74:72:2c:61:65:73  ofish256-ctr,aes
000000d0  31:32:38:2d:63:62:63:2c:61:65:73:31:39:32:2d:63  128-cbc,aes192-c
000000e0  62:63:2c:61:65:73:32:35:36:2d:63:62:63:2c:74:77  bc,aes256-cbc,tw
000000f0  6f:66:69:73:68:31:32:38:2d:63:62:63:2c:74:77:6f  ofish128-cbc,two
00000100  66:69:73:68:31:39:32:2d:63:62:63:2c:74:77:6f:66  fish192-cbc,twof
00000110  69:73:68:32:35:36:2d:63:62:63:2c:74:77:6f:66:69  ish256-cbc,twofi
00000120  73:68:2d:63:62:63:2c:33:64:65:73:2d:63:74:72:2c  sh-cbc,3des-ctr,
00000130  33:64:65:73:2d:63:62:63:2c:6e:6f:6e:65:00:00:00  3des-cbc,none...
00000140  dc:61:72:63:66:6f:75:72:32:35:36:2c:61:72:63:66  .arcfour256,arcf
00000150  6f:75:72:31:32:38:2c:61:72:63:66:6f:75:72:2c:61  our128,arcfour,a
00000160  65:73:31:32:38:2d:63:74:72:2c:61:65:73:31:39:32  es128-ctr,aes192
00000170  2d:63:74:72:2c:61:65:73:32:35:36:2d:63:74:72:2c  -ctr,aes256-ctr,
00000180  74:77:6f:66:69:73:68:31:32:38:2d:63:74:72:2c:74  twofish128-ctr,t
00000190  77:6f:66:69:73:68:31:39:32:2d:63:74:72:2c:74:77  wofish192-ctr,tw
000001a0  6f:66:69:73:68:32:35:36:2d:63:74:72:2c:61:65:73  ofish256-ctr,aes
000001b0  31:32:38:2d:63:62:63:2c:61:65:73:31:39:32:2d:63  128-cbc,aes192-c
000001c0  62:63:2c:61:65:73:32:35:36:2d:63:62:63:2c:74:77  bc,aes256-cbc,tw
000001d0  6f:66:69:73:68:31:32:38:2d:63:62:63:2c:74:77:6f  ofish128-cbc,two
000001e0  66:69:73:68:31:39:32:2d:63:62:63:2c:74:77:6f:66  fish192-cbc,twof
000001f0  69:73:68:32:35:36:2d:63:62:63:2c:74:77:6f:66:69  ish256-cbc,twofi
00000200  73:68:2d:63:62:63:2c:33:64:65:73:2d:63:74:72:2c  sh-cbc,3des-ctr,
00000210  33:64:65:73:2d:63:62:63:2c:6e:6f:6e:65:00:00:00  3des-cbc,none...
00000220  30:68:6d:61:63:2d:73:68:61:31:2d:39:36:2c:68:6d  0hmac-sha1-96,hm
00000230  61:63:2d:73:68:61:31:2c:68:6d:61:63:2d:6d:64:35  ac-sha1,hmac-md5
00000240  2d:39:36:2c:68:6d:61:63:2d:6d:64:35:2c:6e:6f:6e  -96,hmac-md5,non
00000250  65:00:00:00:30:68:6d:61:63:2d:73:68:61:31:2d:39  e...0hmac-sha1-9
00000260  36:2c:68:6d:61:63:2d:73:68:61:31:2c:68:6d:61:63  6,hmac-sha1,hmac
00000270  2d:6d:64:35:2d:39:36:2c:68:6d:61:63:2d:6d:64:35  -md5-96,hmac-md5
00000280  2c:6e:6f:6e:65:00:00:00:04:6e:6f:6e:65:00:00:00  ,none....none...
00000290  04:6e:6f:6e:65:00:00:00:00:00:00:00:00:00:00:00  .none...........
000002a0  00:00                                            ..

-&gt; NET_SSH2_MSG_KEXDH_INIT (since last: 0.0225, network: 0s)
00000000  00:00:00:81:00:b4:0c:f4:1e:a8:31:3c:35:2a:c0:c1  ..........1.5*..
00000010  ca:51:51:9a:6c:9a:b4:b2:f0:63:80:ee:0f:6a:f8:3b  .QQ.l....c...j.;
00000020  b0:9d:ce:b7:35:50:1c:09:11:88:c7:fc:96:47:1f:21  ....5P.......G.!
00000030  e5:36:da:7d:b7:be:06:11:c6:ac:ee:b1:2e:64:50:d2  .6.}.........dP.
00000040  65:b6:78:64:84:2d:b8:7f:62:87:29:eb:75:ab:ee:71  e.xd.-..b.).u..q
00000050  d5:db:53:31:0c:27:e2:51:b9:e0:55:98:22:1c:c3:38  ..S1.'.Q..U.""..8
00000060  46:36:5d:d1:e9:b6:5d:f6:a3:ce:95:2a:fe:30:27:5a  F6]...]....*.0'Z
00000070  95:9b:e7:f2:34:ce:04:1b:4a:ce:37:5a:80:f8:ac:b3  ....4...J.7Z....
00000080  18:c1:7f:0f:c0                                   .....

&lt;- NET_SSH2_MSG_KEXDH_REPLY (since last: 3.6055, network: 3.6038s)
00000000  00:00:00:55:00:00:00:07:73:73:68:2d:72:73:61:00  ...U....ssh-rsa.
00000010  00:00:01:23:00:00:00:41:00:e5:01:cd:e0:ac:c9:17  ...#...A........
00000020  a8:ed:8b:c8:a8:3c:1c:0b:ae:b5:a2:f4:35:60:51:fe  ............5`Q.
00000030  46:01:1c:45:65:77:7a:df:86:58:a7:60:2b:6f:53:de  F..Eewz..X.`+oS.
00000040  e6:02:1a:06:91:1a:08:50:52:df:ed:b3:42:de:5d:1d  .......PR...B.].
00000050  84:44:cf:95:d5:ac:ea:35:e7:00:00:00:81:00:a2:30  .D.....5.......0
00000060  11:61:c6:c6:c5:ac:77:18:d6:bc:57:30:da:91:df:e1  .a....w...W0....
00000070  14:19:d8:07:1b:6a:ac:dd:b3:23:eb:0a:17:44:b8:43  .....j...#...D.C
00000080  65:b5:cc:8b:24:dd:be:07:c5:48:15:f6:3d:7f:7d:c3  e...$....H..=.}.
00000090  7e:b1:6a:e3:ee:1b:b3:23:f6:b2:64:21:b6:c6:f2:e3  ~.j....#..d!....
000000a0  ce:a6:79:b4:a7:ce:50:6e:a4:a3:2d:15:69:9e:e3:69  ..y...Pn..-.i..i
000000b0  68:45:43:7f:e0:c5:21:e8:b2:cb:83:c0:1e:64:16:58  hEC...!......d.X
000000c0  d9:06:fa:01:64:e3:28:c4:2d:84:86:34:94:25:df:68  ....d.(.-..4.%.h
000000d0  1a:fa:53:7a:31:5c:e4:bd:23:30:45:2b:fb:2c:00:00  ..Sz1\..#0E+.,..
000000e0  00:4f:00:00:00:07:73:73:68:2d:72:73:61:00:00:00  .O....ssh-rsa...
000000f0  40:6a:36:35:0a:1d:a7:30:48:1d:56:ce:4d:1c:af:40  @j65...0H.V.M..@
00000100  96:24:44:f7:83:bd:96:7f:bd:99:3b:a1:df:0c:43:42  .$D.......;...CB
00000110  4b:cc:a9:3a:70:c2:cc:19:e8:7b:0e:fe:b9:f6:55:1d  K..:p....{....U.
00000120  af:df:fc:c4:b4:9b:6e:cd:8f:8c:7f:ac:5e:d8:b6:5d  ......n.....^..]
00000130  65                                               e

-&gt; NET_SSH2_MSG_NEWKEYS (since last: 0.0217, network: 0.0001s)


&lt;- NET_SSH2_MSG_NEWKEYS (since last: 0.0131, network: 0.0125s)


-&gt; NET_SSH2_MSG_SERVICE_REQUEST (since last: 0.0018, network: 0.0001s)
00000000  00:00:00:0c:73:73:68:2d:75:73:65:72:61:75:74:68  ....ssh-userauth

&lt;- NET_SSH2_MSG_SERVICE_ACCEPT (since last: 0.0109, network: 0.0104s)
00000000  00:00:00:0c:73:73:68:2d:75:73:65:72:61:75:74:68  ....ssh-userauth

-&gt; NET_SSH2_MSG_USERAUTH_REQUEST (since last: 0.0012, network: 0.0001s)
00000000  00:00:00:08:75:73:65:72:6e:61:6d:65:00:00:00:0e  ....username....
00000010  73:73:68:2d:63:6f:6e:6e:65:63:74:69:6f:6e:00:00  ssh-connection..
00000020  00:08:70:61:73:73:77:6f:72:64:00:00:00:00:08:70  ..password.....p
00000030  61:73:73:77:6f:72:64                             assword

&lt;- NET_SSH2_MSG_USERAUTH_FAILURE (since last: 0.0164, network: 0.0155s)
00000000  00:00:00:12:70:61:73:73:77:6f:72:64:2c:70:75:62  ....password,pub
00000010  6c:69:63:6b:65:79:00                             lickey.

Login Failed&lt;pre&gt;-&gt; NET_SSH2_MSG_DISCONNECT (since last: 0.0012, network: 0.0001s)
00000000  00:00:00:0b:00:00:00:00:00:00:00:00              ............
</code></pre>
","<p>3des-cbc is being used already. The inbound &lt;- NET_SSH2_MSG_KEXINIT packet is how phpseclib knows that 3des-cbc has to be used and you know it's using it because the inbound &lt;- NET_SSH2_MSG_NEWKEYS is both received and successfully decrypted.</p>

<p>The problem with your code isn't that 3des-cbc isn't being used - it's that the password is bad, per this:</p>

<pre><code>-&gt; NET_SSH2_MSG_USERAUTH_REQUEST (since last: 0.0012, network: 0.0001s)
00000000  00:00:00:08:75:73:65:72:6e:61:6d:65:00:00:00:0e  ....username....
00000010  73:73:68:2d:63:6f:6e:6e:65:63:74:69:6f:6e:00:00  ssh-connection..
00000020  00:08:70:61:73:73:77:6f:72:64:00:00:00:00:08:70  ..password.....p
00000030  61:73:73:77:6f:72:64                             assword

&lt;- NET_SSH2_MSG_USERAUTH_FAILURE (since last: 0.0164, network: 0.0155s)
00000000  00:00:00:12:70:61:73:73:77:6f:72:64:2c:70:75:62  ....password,pub
00000010  6c:69:63:6b:65:79:00                             lickey.
</code></pre>
","163","<ssh><phpseclib><3des><tripledes>","0","0","1","2014-04-05 22:35:30","","0","","2467753","","2014-04-05 09:16:35","2014-04-05 08:57:22",""
"38975415","iOS 3DES ECB Decryption","<p>I'm trying to decrypt using the following function, but I keep getting the same encrypted string. </p>

<p>What would be the reason for this? </p>

<pre><code>    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];

    const void *vEncryptedText = [data bytes];
    size_t encryptedTextBufferSize = [data length];
    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    bufferPtrSize = (encryptedTextBufferSize + kCCBlockSize3DES) &amp; ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);

    const void *vkey = (const void *) [@""123456789012345678901234"" UTF8String];

    ccStatus = CCCrypt(kCCDecrypt,
                       kCCAlgorithm3DES,
                       kCCOptionECBMode | kCCOptionPKCS7Padding,
                       vkey,
                       kCCKeySize3DES,
                       NULL,
                       vEncryptedText,
                       encryptedTextBufferSize,
                       (void *)bufferPtr,
                       bufferPtrSize,
                       &amp;movedBytes);

    NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
    return [myData base64EncodedStringWithOptions:0];
</code></pre>

<p>Update:</p>

<p>I've changed data to:</p>

<pre><code>NSData *data = [[NSData alloc] initWithBase64EncodedString:string options:0];
</code></pre>

<p>Still no luck. I'm getting the same output string as the input encrypted string.</p>

<p>I've solved the issue by returning:</p>

<pre><code>return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
</code></pre>
","<p>It is virtually impossible for encrypted data to be a valid UTF-8 encoded string, encrypted data is an array or 8-bit bytes that will appear to be random.</p>

<p>Thus the first line:<br>
<code>NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];</code><br>
is incorrect. If the encrypted data is indeed a UTF-8 string it has been encoded to probably Base64 or Hexadecimal.</p>
","158","<ios><objective-c><encryption><3des><ecb>","-2","1","1","2016-08-16 15:43:45","","7","","6555839","","2016-08-16 15:43:45","2016-08-16 12:49:36",""
"39967625","Why does TripleDESCryptoServiceProvider automatically generate Key?","<p>When a new instance of TripleDESCryptoServiceProvider is created, a key and IV are generated.</p>

<p>It makes sense that an IV is generated every time.  </p>

<p>But what is the point of the key being generated every time?</p>

<p>Isn't the key supposed to be static, so that it can be shared between the parties that are sending each other encrypted messages?  Wouldn't I always just override the random key with the shared key?</p>

<p>It what situation is it useful for a new key to be generated every time?</p>
","<p>Often keys are generated randomly for each message and then securely transported along with the encrypted message to the recipient using a public-key algorithm.</p>

<p>So, in that case, initializing the cipher with an appropriate key is convenient and probably safer too, if you assume the library developer is less likely to use improper key generation techniques.</p>

<p>However, if you have an existing key that you need to use, and overwrite the cipher's initial key, the only thing you've lost is some bits from the entropy pool.</p>
","157","<c#><encryption><3des><tripledes>","0","1","1","2016-10-10 22:35:24","","0","","","","","2016-10-10 22:20:07",""
"24174246","3DES iOS encrypt different from .Net server","<p>I'm trying to encrypt a request, I made this function but I'm getting a different encrypt value in the .NET server. This is the function I'm using in iOS:</p>

<pre><code>- (NSData *)Encrypt3DESWithInput:(NSString *)input
                         key:(NSString *)key
{
    NSData *inputData = [input dataUsingEncoding:NSUTF8StringEncoding];
    NSData *keyData = [key dataUsingEncoding:NSUTF8StringEncoding];
    NSUInteger dataLength = [inputData length];

    size_t bufferSize = dataLength + kCCBlockSize3DES;
    void *buffer = malloc(bufferSize);

    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
                                          kCCAlgorithm3DES,
                                          kCCOptionPKCS7Padding,
                                          [keyData bytes],
                                          kCCKeySize3DES,
                                          initializationVector,
                                          [inputData bytes],
                                          dataLength,
                                          buffer,
                                          bufferSize,
                                          &amp;numBytesEncrypted);

    if (cryptStatus == kCCSuccess) {
        NSLog(@""Success"");
        //the returned NSData takes ownership of the buffer and will free it on deallocation
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    }

    free(buffer); //free the buffer;
    return nil;
}
</code></pre>

<p>These are the values im using in the private key and the initialization vector:</p>

<pre><code>static NSString *const privateKey = @"""";
static const char initializationVector[8] = {31, 10, 35, 17, 0, 42, 151, 64};
</code></pre>
","<p>Use a key that is the natural length of the encryption/decryption routine. Don't rely on key padding, that is undefined. If you have a password use <code>PBKDF2</code> to create a full length secure key..</p>

<p>The key string is <code>@""""</code> yet the key data is created by <code>[key dataUsingEncoding:NSUTF8StringEncoding]</code></p>

<pre><code>NSString *keyString = @"""";
NSData *keyData = [keyString dataUsingEncoding:NSUTF8StringEncoding];
</code></pre>

<p>NSLog output:</p>

<blockquote>
  <p>keyString: ''<br>
  keyData: &lt;>   </p>
</blockquote>

<p>Note the key length is 0 so the DES method will access random data from memory.</p>
","155","<ios><encryption><3des>","0","0","1","2014-06-12 00:23:27","","2","","","","","2014-06-11 23:28:33",""
"8168905","Crypt and send hidden communication between client and server","<p>I have an application winform client written in C# and a Server application written in php.</p>

<p>I need to validate an operation that the client does at the server.</p>

<p>When the client sends this validation it sends to the server some information like LicenseID , Info Points , and other info that I dont want to be spoofed.  I want to prevent fake calls to the server.</p>

<p>The first solution that I used was 3DES to prevent anyone from seeing the clear data that I send via GET and POST methods to the php webserver.</p>

<p>The problem now is that some information like LicenseID and others are always the same.</p>

<p>So even if I encrypt them in 3DES, for each call those encrypted words are always the same and could be easily spoofed.</p>

<p>I want to know if it's possible to send the data, so that they look different in each GET and POST method and I can decrypt in webserver.</p>

<p>What can I change to make each call different from each other while providing the same data?</p>

<p>Update: I forgot to say that I can't use SSL.</p>
","<p>SSL enable your php server.  This will prevent the information getting out to those who may be listening on the wire.  It sounds like this may solve most of your issues.</p>
","149","<php><winforms><encryption><3des>","1","1","2","2017-07-11 18:01:48","8169124","6","","1033581","","2017-07-11 18:01:48","2011-11-17 14:37:23",""
"8168905","Crypt and send hidden communication between client and server","<p>I have an application winform client written in C# and a Server application written in php.</p>

<p>I need to validate an operation that the client does at the server.</p>

<p>When the client sends this validation it sends to the server some information like LicenseID , Info Points , and other info that I dont want to be spoofed.  I want to prevent fake calls to the server.</p>

<p>The first solution that I used was 3DES to prevent anyone from seeing the clear data that I send via GET and POST methods to the php webserver.</p>

<p>The problem now is that some information like LicenseID and others are always the same.</p>

<p>So even if I encrypt them in 3DES, for each call those encrypted words are always the same and could be easily spoofed.</p>

<p>I want to know if it's possible to send the data, so that they look different in each GET and POST method and I can decrypt in webserver.</p>

<p>What can I change to make each call different from each other while providing the same data?</p>

<p>Update: I forgot to say that I can't use SSL.</p>
","<p>Maybe you could use a random salt on each information based on some key like the current date, or a pseudo-random salt using the same key in the client and the server. Then you could crypt it all with 3des.</p>

<p>You should also use https after crypting the info. Get an SSL certificate for that.</p>
","149","<php><winforms><encryption><3des>","1","2","2","2017-07-11 18:01:48","8169124","6","","1033581","","2017-07-11 18:01:48","2011-11-17 14:37:23",""
"24111030","Having wired outputs while Rfc2898DeriveBytes implementation in TripleDES","<p>This is a simple code but its taking hours to find out why am I getting wrong output. I can't seem to find the problem. Is everything okey specially with <code>Rfc2898DeriveBytes</code> implementation? 
I need help to find out whats causing wrong output, where is it and how to solve it to make this code work.</p>

<pre><code>static void Main(string[] args)
    {
        string data = ""welcome to the jungle"";
        string pass = ""monkey"";
        string salt = ""12345678"";
        byte[] textdata = Encoding.UTF8.GetBytes(data);
        byte[] password = Encoding.UTF8.GetBytes(pass);
        byte[] saltbyte = Encoding.UTF8.GetBytes(salt);
        Rfc2898DeriveBytes keyGenerate = new Rfc2898DeriveBytes(password ,saltbyte ,1000);
        Rfc2898DeriveBytes keyGenerate1 = new Rfc2898DeriveBytes(password, saltbyte, 1000);
        byte[] key1 = keyGenerate.GetBytes(16);
        byte[] key2 = keyGenerate1.GetBytes(16);
        Console.WriteLine(""Plaintext: "" + data);

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        tdes.BlockSize = 64;
        tdes.KeySize = 128;
        tdes.Key = key1;
        tdes.IV = saltbyte;
        tdes.Mode = CipherMode.CBC;
        tdes.Padding = PaddingMode.PKCS7;
        ICryptoTransform tripledes = tdes.CreateEncryptor();
        byte[] een = tripledes.TransformFinalBlock(textdata, 0, textdata.Length);
        string een1 = Convert.ToBase64String(een);
        Console.WriteLine(""Encrypted Data: "" +een1);

        TripleDESCryptoServiceProvider tdes1 = new TripleDESCryptoServiceProvider();
        tdes1.BlockSize = 64;
        tdes1.KeySize = 128;
        tdes1.Key = key2;
        tdes1.IV = saltbyte;
        tdes1.Mode = CipherMode.CBC;
        tdes1.Padding = PaddingMode.PKCS7;
        ICryptoTransform tripledes1 = tdes1.CreateDecryptor();
        byte[] en1 = tripledes.TransformFinalBlock(een, 0, een.Length);
        string en11 = Encoding.UTF8.GetString(en1); ;
        Console.WriteLine(""Decrypted Data: "" +en11);
        Console.ReadLine(); 
    }
</code></pre>

<p>This is what I get in as output: </p>

<p><img src=""https://i.stack.imgur.com/KAQeo.png"" alt=""enter image description here""></p>

<p>And one more thing that I want to know, what is the difference between <code>Rfc2898DeriveBytes(string a, byte[] salt, int iteration)</code>  and <code>Rfc2898DeriveBytes( byte[] a , byte[] salt, int iteration)</code> ? and which one is best for use? Do they give same output? </p>
","<p>You're using the original (encryptor) <code>tripledes</code> instance, rather than the decryptor instance <code>tripledes1</code> to decrypt.</p>
","148","<c#><3des><pbkdf2>","0","0","1","2014-06-08 21:40:35","24111127","0","","2059267","","2014-06-08 21:40:16","2014-06-08 21:28:58",""
"51946119","TRIPLE DES ECB Encryption RUBY","<p>I have a sample code in .NET C# which I need to convert to RUBY.</p>

<pre><code> public static string Encrypt(string pstrText)
        {
            byte[] keyArray;
            byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(pstrText);
                MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
                keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(secKey));
                hashmd5.Clear();
            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            tdes.Key = keyArray;
            tdes.Mode = CipherMode.ECB;
            tdes.Padding = PaddingMode.PKCS7;
            ICryptoTransform cTransform = tdes.CreateEncryptor();
            byte[] resultArray =cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
            tdes.Clear();
            return Convert.ToBase64String(resultArray, 0, resultArray.Length);
        }
</code></pre>

<p>I have tried using OPENSSL:CIPHER and got thus far -</p>

<pre><code>def encrypt data
secret = ""******************""
md5 = Digest::MD5.hexdigest(secret)
des = OpenSSL::Cipher::Cipher.new 'DES-EDE3'
des.encrypt
des.key = md5
update_value = des.update(data)
up_final = update_value + des.final
puts Base64.encode64(up_final).gsub(/\n/, """")
end
</code></pre>

<p>The results in C# and RUBY do not match. Where am I going wrong?</p>
","","141","<c#><ruby><openssl><3des><ecb>","0","","0","2018-08-21 19:39:52","","8","","2279377","","2018-08-21 19:39:52","2018-08-21 09:56:48",""
"31419517","DESKey expanding using JavaScript","<p>I'm implementing a protocol in Node.js.
This protocol uses 3DES encryption in CBC mode, okay.</p>

<p>But to encrypt/decrypt I need to spread/expand the 14 bytes DES Key to 16 bytes just adding the parity bits. But. I'm stuck on it using JavaScript/Node.js.</p>

<p>I have some implementations using C and Python, can anyone help me to do the same using JavaScript/Node.js (my trial is below)?</p>

<pre><code>uint8 *des_key_spread(uint8 *normal){
  static uint8 spread[16];

  spread[ 0] = normal[ 0] &amp; 0xfe;
  spread[ 1] = ((normal[ 0] &lt;&lt; 7) | (normal[ 1] &gt;&gt; 1)) &amp; 0xfe;
  spread[ 2] = ((normal[ 1] &lt;&lt; 6) | (normal[ 2] &gt;&gt; 2)) &amp; 0xfe;
  spread[ 3] = ((normal[ 2] &lt;&lt; 5) | (normal[ 3] &gt;&gt; 3)) &amp; 0xfe;
  spread[ 4] = ((normal[ 3] &lt;&lt; 4) | (normal[ 4] &gt;&gt; 4)) &amp; 0xfe;
  spread[ 5] = ((normal[ 4] &lt;&lt; 3) | (normal[ 5] &gt;&gt; 5)) &amp; 0xfe;
  spread[ 6] = ((normal[ 5] &lt;&lt; 2) | (normal[ 6] &gt;&gt; 6)) &amp; 0xfe;
  spread[ 7] = normal[ 6] &lt;&lt; 1;
  spread[ 8] = normal[ 7] &amp; 0xfe;
  spread[ 9] = ((normal[ 7] &lt;&lt; 7) | (normal[ 8] &gt;&gt; 1)) &amp; 0xfe;
  spread[10] = ((normal[ 8] &lt;&lt; 6) | (normal[ 9] &gt;&gt; 2)) &amp; 0xfe;
  spread[11] = ((normal[ 9] &lt;&lt; 5) | (normal[10] &gt;&gt; 3)) &amp; 0xfe;
  spread[12] = ((normal[10] &lt;&lt; 4) | (normal[11] &gt;&gt; 4)) &amp; 0xfe;
  spread[13] = ((normal[11] &lt;&lt; 3) | (normal[12] &gt;&gt; 5)) &amp; 0xfe;
  spread[14] = ((normal[12] &lt;&lt; 2) | (normal[13] &gt;&gt; 6)) &amp; 0xfe;
  spread[15] = normal[13] &lt;&lt; 1;

  des_key_parity_adjust(spread, 16);
  return spread;
}

void des_key_parity_adjust(uint8 *key, uint8 len){
  uint8 i, j, parity;

    for (i = 0; i &lt; len; i++){
      parity = 1;
      for (j = 1; j &lt; 8; j++) 
        if ((key[i] &gt;&gt; j) &amp; 0x1) parity = ~parity &amp; 0x01;
      key[i] |= parity;
    }
}
</code></pre>

<p>From here <a href=""https://code.google.com/p/passlib/source/browse/passlib/utils/des.py?name=release-1.5#574"" rel=""nofollow"">Python expand/spread</a></p>

<p>My implementation:</p>

<pre><code>function deskey_spread(normal){
  spread = new Buffer(16);
  spread[ 0] = normal[ 0] &amp; 0xfe;
  spread[ 1] = ((normal[ 0] &lt;&lt; 7) | (normal[ 1] &gt;&gt; 1)) &amp; 0xfe;
  spread[ 2] = ((normal[ 1] &lt;&lt; 6) | (normal[ 2] &gt;&gt; 2)) &amp; 0xfe;
  spread[ 3] = ((normal[ 2] &lt;&lt; 5) | (normal[ 3] &gt;&gt; 3)) &amp; 0xfe;
  spread[ 4] = ((normal[ 3] &lt;&lt; 4) | (normal[ 4] &gt;&gt; 4)) &amp; 0xfe;
  spread[ 5] = ((normal[ 4] &lt;&lt; 3) | (normal[ 5] &gt;&gt; 5)) &amp; 0xfe;
  spread[ 6] = ((normal[ 5] &lt;&lt; 2) | (normal[ 6] &gt;&gt; 6)) &amp; 0xfe;
  spread[ 7] = normal[ 6] &lt;&lt; 1;
  spread[ 8] = normal[ 7] &amp; 0xfe;
  spread[ 9] = ((normal[ 7] &lt;&lt; 7) | (normal[ 8] &gt;&gt; 1)) &amp; 0xfe;
  spread[10] = ((normal[ 8] &lt;&lt; 6) | (normal[ 9] &gt;&gt; 2)) &amp; 0xfe;
  spread[11] = ((normal[ 9] &lt;&lt; 5) | (normal[10] &gt;&gt; 3)) &amp; 0xfe;
  spread[12] = ((normal[10] &lt;&lt; 4) | (normal[11] &gt;&gt; 4)) &amp; 0xfe;
  spread[13] = ((normal[11] &lt;&lt; 3) | (normal[12] &gt;&gt; 5)) &amp; 0xfe;
  spread[14] = ((normal[12] &lt;&lt; 2) | (normal[13] &gt;&gt; 6)) &amp; 0xfe;
  spread[15] = normal[13] &lt;&lt; 1;

  des_key_parity_adjust(spread, 16);
  return spread;
}

function des_key_parity_adjust(key, len){
    var i = new Buffer(1);
    var j = new Buffer(1);
    var parity = new Buffer(1);
    for (i = 0; i &lt; len; i++){
      parity = 1;
      for (j = 1; j &lt; 8; j++) 
        if ((key[i] &gt;&gt; j) &amp; 0x1) parity = ~parity &amp; 0x01;
      key[i] |= parity;
    }
}
</code></pre>

<p>My input:</p>

<pre><code>01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e
</code></pre>

<p>Output using C implementation:</p>

<pre><code>01 80 80 61 40 29 19 0E 08 04 45 02 10 91 4C 29
</code></pre>

<p>And my Node.js implementation:</p>

<pre><code>01 80 80 61 40 29 19 0e 08 04 43 40 b0 61 34 1c
</code></pre>

<p>Whats wrong? :/</p>
","<p>The code is correct and is working properly.</p>

<p>The problem is the input, I used a normal array, not a Buffer.</p>

<p>Using Buffer the code works properly.</p>

<p>Input: </p>

<pre><code>01 80 80 61 40 29 19 0E 08 04 45 02 10 91 4C 29
</code></pre>

<p>Using the C code:</p>

<pre><code>01 80 80 61 40 29 19 0E 08 04 45 02 10 91 4C 29
</code></pre>

<p>Using my Node.js implementation</p>

<pre><code>01 80 80 61 40 29 19 0E 08 04 45 02 10 91 4C 29
</code></pre>

<p>Thanks! </p>
","135","<javascript><node.js><encryption><3des><parity>","2","0","1","2015-07-21 14:39:12","31542192","0","","1816580","","2015-07-15 14:41:46","2015-07-15 00:18:50",""
"33578715","Same return value in php and perl 3DES CBC","<p>I would like to know how to return the same values for a 3DES encription in perl and php. The PHP code is the following:</p>

<pre><code>$bytes = array(0,0,0,0,0,0,0,0);
$iv = implode(array_map(""chr"", $bytes)); 
$ciphertext = mcrypt_encrypt(MCRYPT_3DES, base64_decode('Mk9m98IfEblmPfrpsawt7BmxObt98Jev'), '0000001920', MCRYPT_MODE_CBC, $iv);
echo base64_encode($ciphertext);
</code></pre>

<p>The result is: ""A/VCTXA6q/x/emW0zzlSDg==""</p>

<p>The perl code is:</p>

<pre><code>use Crypt::CBC;
$cipher = Crypt::CBC-&gt;new(  -key    =&gt; decode_base64('Mk9m98IfEblmPfrpsawt7BmxObt98Jev'),
                                -cipher =&gt; 'DES_EDE3',
                                -iv     =&gt; pack(""H*"",""0000000000000000""),
                                -literal_key =&gt; 1,
                                -header      =&gt; 'none'
                            );

$ciphertext = $cipher-&gt;encrypt(""0000001920"");
print encode_base64($ciphertext, '');
</code></pre>

<p>The result is: ""A/VCTXA6q/y9g7ypgqlWIg==""</p>

<p>The results are very similar, what I'm doing wrong in my perl code?</p>
","<p>You are not using the same padding mechanism.</p>

<p>If you read the reference page of <a href=""http://php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow"">PHP's mcrypt_encrypt</a> very carefully you'll see the following note next to the data parameter:</p>

<blockquote>
  <p>If the size of the data is not n * blocksize, the data will be padded with '\0'. </p>
</blockquote>

<p>Now, if you also read the reference page of <a href=""http://search.cpan.org/~lds/Crypt-CBC-2.33/CBC.pm#Padding_methods"" rel=""nofollow"">Perls Crypt::CBC</a>, you notice they have several padding methods (defined by the <code>-padding</code> parameter). The default is PKCS#5 which is something different than just padding with <code>0x00</code>.</p>

<p>Now if you change the padding to <code>""null""</code>, Perl prints the same as PHP. So your code should look like this:</p>

<pre><code>use MIME::Base64;
use Crypt::CBC;
$cipher = Crypt::CBC-&gt;new(  -key    =&gt; decode_base64('Mk9m98IfEblmPfrpsawt7BmxObt98Jev'),
                                -cipher =&gt; 'DES_EDE3',
                                -iv     =&gt; pack(""H*"",""0000000000000000""),
                                -padding     =&gt; ""null"",
                                -literal_key =&gt; 1,
                                -header      =&gt; 'none'
                            );

$ciphertext = $cipher-&gt;encrypt(""0000001920"");
print encode_base64($ciphertext, '');
</code></pre>

<p>Alternatively you could implement PKCS#5 in PHP, which you have to do by yourself, since PHP does not include it by default (search for PHP PKCS#5 and you probably find some code-snippets which you can use, theres even a <a href=""http://us3.php.net/manual/en/ref.mcrypt.php#69782"" rel=""nofollow"">simple PKCS#5 function</a> in one of the PHP-doc comments).</p>
","122","<php><perl><encryption><3des>","2","2","1","2015-11-07 10:03:11","33581452","0","","","","","2015-11-07 03:09:12",""
"50167828","Using decrypted DES key obtained from RSA decryption","<p>I am working on a hybrid encryption mechanism in java that involves encrypting message using 3DES encryption algorithm and then encrypt its key using RSA encryption mechanism at the sender side. Once delivered to the receiver side, the encrypted 3DES key is decrypted using RSA decryption mechanism and then is used to decrypt the cipher text.
Once I obtain the decrypted 3DES key its string value is the same but byte [] is not the same instead returns a 2's complement of the original key.</p>

<p>How can I get the decrypted 3DES to be the same as the originally generated 3DES in byte [] form at the receiver side?</p>

<p>Below is the code I am using for my hybrid encryption mechanism:
    package hybrid_implementation;</p>

<pre><code>import java.security.Key;
import java.security.InvalidKeyException;
import java.security.spec.InvalidKeySpecException;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.IllegalBlockSizeException;

public class Hybrid_Implementation {

//RSA_Encryption Algorithm Required Variables
private static final BigInteger one = new BigInteger(""1"");
private static final SecureRandom random = new SecureRandom();
private BigInteger privatekey;
private BigInteger publickey;
private BigInteger modulus;

//3DES_Encryption Algorithm Required Variables
private byte[] DES_Key;
private SecretKeyFactory keyfactory;
private DESedeKeySpec spec;
private Key deskey;
private int DES_Key_Length;
private byte[] data;
private Cipher cipher;
private String CipherText;
private byte [] CIPHERText;

Hybrid_Implementation() throws InvalidKeyException, 
NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException
{
    DES_Key_Generator();
    RSA_Key_Generator(999);
}

//3DES Encryption-Decryption Algorithm with 2 differnt keys
private String DES_Encryption(String plaintext) throws InvalidKeyException, 
IllegalBlockSizeException, BadPaddingException
{
    data = plaintext.getBytes();
    cipher.init(Cipher.ENCRYPT_MODE, deskey);
    CIPHERText = cipher.doFinal(data);
    StringBuilder hexCiphertext = new StringBuilder();
    for(int i=0; i&lt;CIPHERText.length; i++)
    {
        int v = CIPHERText[i] &amp; 0xff;
        v+=0x100;
        String temp = Integer.toString(v,16);
        hexCiphertext.append(temp).substring(1);
    }
    return hexCiphertext.toString();
}

private String DES_Decryption(byte [] key, byte [] encrypted_text) throws 
InvalidKeyException, IllegalBlockSizeException, BadPaddingException, 
InvalidKeySpecException
{
   spec = new DESedeKeySpec(key);
   deskey = keyfactory.generateSecret(spec);
    byte[] plaintext = cipher.doFinal(encrypted_text);
    StringBuilder decrypttext= new StringBuilder();
    for (int i = 0; i &lt; plaintext.length; i++)
        decrypttext.append((char) plaintext[i]);
    String decrypted_plaintext = decrypttext.toString();
    return decrypted_plaintext;
}

private void DES_Key_Generator() throws InvalidKeyException, 
NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException
{
    Random rnd = new Random();
    String key = rnd.toString();

    DES_Key = key.getBytes();
    spec = new DESedeKeySpec(DES_Key);
    keyfactory = SecretKeyFactory.getInstance(""desede"");
    deskey = keyfactory.generateSecret(spec);
    cipher = Cipher.getInstance(""desede"");
}


//RSA Encryption-Decryption Algorithm
private BigInteger RSA_Encryption(BigInteger des_Key )  //RSA Encryption of 
3DES Key
{
     BigInteger encrypted_DES_Key = des_Key.modPow(publickey, modulus);
     return encrypted_DES_Key;
}

private BigInteger RSA_Decryption(BigInteger encrypted_DES_Key) //RSA 
Decryption of 3DES Key
{
    BigInteger des_Key = encrypted_DES_Key.modPow(privatekey, modulus);
    return des_Key;
}

private void RSA_Key_Generator(int number)     //RSA Public - Private Key 
Generation
{
    BigInteger p = BigInteger.probablePrime(number/2,random);
    BigInteger q = BigInteger.probablePrime(number/2, random);
    BigInteger phi = (p.subtract(one)).multiply(q.subtract(one));

    modulus = p.multiply(q);
    publickey = new BigInteger(""65537"");
    privatekey = publickey.modInverse(phi);
}

private String encryption(String plaintext) throws InvalidKeyException, 
IllegalBlockSizeException, BadPaddingException
{
    String cipher_text = DES_Encryption(plaintext);
    BigInteger RSA_DESKey = RSA_Encryption(new BigInteger(DES_Key));
    String temp_key = RSA_DESKey.toString();
    DES_Key_Length = temp_key.length();
    CipherText ="""";
    CipherText = new 
StringBuilder().append(temp_key).append(cipher_text).toString();
    return CipherText;
}

private String decryption(String encrypted_text) throws InvalidKeyException, 
InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException
{
    StringBuilder encryptedkey = new StringBuilder();
    for(int i = 0 ; i &lt; DES_Key_Length; i++)
        encryptedkey.append (encrypted_text.charAt(i));
    StringBuilder cipheredtext = new StringBuilder();
    for(int j = DES_Key_Length ; j&lt; encrypted_text.length() ; j++)
        cipheredtext.append (encrypted_text.charAt(j));
    BigInteger DES_Encrypted_Key = new BigInteger(encryptedkey.toString());
    BigInteger DES_KEY = RSA_Decryption(DES_Encrypted_Key);
    byte[] decrypt_key = DES_KEY.toByteArray();
    String plaintext = 
DES_Decryption(decrypt_key,cipheredtext.toString().getBytes());
       return plaintext;
}

/**
 *
 * @param args
 * @throws InvalidKeyException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 * @throws java.security.NoSuchAlgorithmException
 * @throws java.security.spec.InvalidKeySpecException
 * @throws javax.crypto.NoSuchPaddingException
 */
public static void main(String[] args) throws InvalidKeyException, 
IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, 
InvalidKeySpecException, NoSuchPaddingException {
    String plaintext;
    Hybrid_Implementation hi = new Hybrid_Implementation ();
    Scanner sc = new Scanner(System.in);
    System.out.print(""Enter Text = "");
    plaintext = sc.nextLine();
    String encrypted_text = hi.encryption(plaintext);
    String decrypted_text = hi.decryption(encrypted_text);
    System.out.println(""Plain Text Entered = ""+plaintext);
    System.out.println(""Encrypted Text = ""+encrypted_text);
    System.out.println(""Decrypted Text = ""+decrypted_text);
    }

}
</code></pre>

<p>The output I receive is:
<a href=""https://i.stack.imgur.com/EUINv.jpg"" rel=""nofollow noreferrer"">enter image description here</a>
Whereas the decrypted text is not the same as the entered plain text</p>
","<p>There are multiple (many) issues with your code</p>

<p>The main issue (why you get incorrect decrypted text) is in the ciphertext encoding. <strong>The ciphertext you are decrypting with 3DES is different than the one you got from the encryption (your ""hex encoding"" is simply buggy).</strong> Just debug  you program (and print the values after encryption and before decryption) and you should find it. I'd advice using something standard, such as working hexadecimal or base64 encoding.</p>

<p>Other issues:</p>

<ul>
<li>you are using ""textbook RSA"" which is not really secure, so I hope you are doing that for learning / assignment purposes, not real life encryption application. As already commented, using RSA should be always with padding (e.g. <code>RSA/ECB/PKCS1Padding</code> or OAEP)</li>
<li>Generating random keys - you should use SecureRandom instead of Random (which is not really random) or - much better - a KeyGenerator</li>
<li>DESede without providing any IV is using ECB mode, which has its weaknesses. So using symmetric encryption you should provide random IV and specify the encryption mode explicitly (e.g. <code>DESede/CBC/PKCS5Padding</code>)</li>
<li>for each operation after <code>doFinal()</code> you should use a new Cipher instance with initialized decrpytion mode</li>
</ul>

<p>I have a <a href=""https://gusto77.wordpress.com/2017/10/30/encryption-reference-project/"" rel=""nofollow noreferrer"">blog about encryption</a> with a few examples, you may take inspiration from.</p>
","116","<java><encryption><rsa><3des>","0","1","1","2018-05-04 11:12:53","","3","","9739185","","2018-05-04 08:12:48","2018-05-04 05:35:01",""
"42225119","Wrong cipher text length when using 3DESede with PKS5 padding of javax.crypto","<p>I am using the following code in my android application to encrypt a string in <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow noreferrer"">Triple DES</a> using the <em>Encrypted Code Book</em> (ECB) mode with three independent keys (aka <em>3DESede</em>), which are provided as a 24 byte sized key array. Therefore I use the <a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/package-summary.html"" rel=""nofollow noreferrer"">Java Crypto API</a>. This works pretty well, but if I encrypt an eight character string I get a 16 byte cipher text, which should not happen as 3DES operates on chunks of 64 bit (resp. 8 byte). Same holds for the <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)"" rel=""nofollow noreferrer"">PKCS5 padding</a> as this also operates on chunks of 64 bit. So my question is what causes this problem?</p>

<pre><code>private static byte[] encryptText(String plaintext, byte[] keyBytes) throws Exception {
    // Get plaintext as ASCII byte array
    final byte[] plainBytes;
    if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) {
        plainBytes = plaintext.getBytes(StandardCharsets.US_ASCII);
    } else {
        plainBytes = plaintext.getBytes(""US-ASCII"");
    }

    // Generate triple DES key from byte array
    final DESedeKeySpec keySpec = new DESedeKeySpec(keyBytes);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DESede"");
    SecretKey key = keyFactory.generateSecret(keySpec);

    // Setup the cipher
    final Cipher c3des = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    c3des.init(Cipher.ENCRYPT_MODE, key);

    // Return ciphertext
    return c3des.doFinal(plainBytes);
}
</code></pre>
","<p><strong>PKCS5Padding</strong> adds 1-8 bytes of padding when used with DES. If you encrypt 8 bytes you will get 8 additional bytes of padding to get to an even number of blocks.</p>

<p>If you used <code>Cipher.getInstance(""DES/ECB/NoPadding"")</code> and encrypted 8 bytes, you will get 8 bytes of cipher text.</p>
","116","<java><android><encryption><3des>","1","1","2","2017-02-14 14:13:10","42227491","1","2","1067846","","2017-02-14 14:13:10","2017-02-14 11:35:15",""
"42225119","Wrong cipher text length when using 3DESede with PKS5 padding of javax.crypto","<p>I am using the following code in my android application to encrypt a string in <a href=""https://en.wikipedia.org/wiki/Triple_DES"" rel=""nofollow noreferrer"">Triple DES</a> using the <em>Encrypted Code Book</em> (ECB) mode with three independent keys (aka <em>3DESede</em>), which are provided as a 24 byte sized key array. Therefore I use the <a href=""https://docs.oracle.com/javase/7/docs/api/javax/crypto/package-summary.html"" rel=""nofollow noreferrer"">Java Crypto API</a>. This works pretty well, but if I encrypt an eight character string I get a 16 byte cipher text, which should not happen as 3DES operates on chunks of 64 bit (resp. 8 byte). Same holds for the <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)"" rel=""nofollow noreferrer"">PKCS5 padding</a> as this also operates on chunks of 64 bit. So my question is what causes this problem?</p>

<pre><code>private static byte[] encryptText(String plaintext, byte[] keyBytes) throws Exception {
    // Get plaintext as ASCII byte array
    final byte[] plainBytes;
    if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.KITKAT) {
        plainBytes = plaintext.getBytes(StandardCharsets.US_ASCII);
    } else {
        plainBytes = plaintext.getBytes(""US-ASCII"");
    }

    // Generate triple DES key from byte array
    final DESedeKeySpec keySpec = new DESedeKeySpec(keyBytes);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""DESede"");
    SecretKey key = keyFactory.generateSecret(keySpec);

    // Setup the cipher
    final Cipher c3des = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    c3des.init(Cipher.ENCRYPT_MODE, key);

    // Return ciphertext
    return c3des.doFinal(plainBytes);
}
</code></pre>
","<p>When PKCS#5 padding is used it must always add padding otherwise on decryption there would be no way to determine if padding was added. So, even if the input data is an exact multiple of the block size padding must be added and that will be 8 bytes.</p>

<p>See <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)#PKCS7"" rel=""nofollow noreferrer"">PKCS padding</a>:</p>

<blockquote>
  <p>If the original data is an integer multiple of N bytes, then an extra block of bytes with value N is added. This is necessary so the deciphering algorithm can determine with certainty whether the last byte of the last block is a pad byte indicating the number of padding bytes added or part of the plaintext message. Consider a plaintext message that is an integer multiple of N bytes with the last byte of plaintext being 01. With no additional information, the deciphering algorithm will not be able to determine whether the last byte is a plaintext byte or a pad byte. However, by adding N bytes each of value N after the 01 plaintext byte, the deciphering algorithm can always treat the last byte as a pad byte and strip the appropriate number of pad bytes off the end of the ciphertext; said number of bytes to be stripped based on the value of the last byte.</p>
  
  <p>PKCS#5 padding is identical to PKCS#7 padding, except that it has only been defined for block ciphers that use a 64-bit (8 byte) block size. In practice the two can be used interchangeably.</p>
</blockquote>
","116","<java><android><encryption><3des>","1","1","2","2017-02-14 14:13:10","42227491","1","2","1067846","","2017-02-14 14:13:10","2017-02-14 11:35:15",""
"41162511","File_Decryption - JUNK Character found in decrypted file","<p>I have a encryption tool to encrypt the file, when I study the encrypted file, found it is writing name of .PEM inside the encrypted file.</p>

<pre><code>I found encryption logic is commonly used as below,
it supporting encryption of any file, it means RSA keys can not be use for encryption so here
it is creating a key(K) and encrypt it with RSA public   key and then using key(K) for encrypting the file.
</code></pre>

<p>I write C# Code as below, it is fine but for big file am getting some junk character in middle like,</p>

<pre><code>aaaaaaaaaaaaaaaa
??M'yaaaaaaaaaa?
</code></pre>

<p>my decryption code is like:-</p>

<pre><code> System.Security.Cryptography.TripleDESCryptoServiceProvider tripleDES = new System.Security.Cryptography.TripleDESCryptoServiceProvider();
 tripleDES.Key = result; // 16 byte of key
 tripleDES.Mode = System.Security.Cryptography.CipherMode.CBC;
 byte[] IV = { (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00 };
 tripleDES.IV = IV;
 tripleDES.Padding = System.Security.Cryptography.PaddingMode.Zeros;
 System.Security.Cryptography.ICryptoTransform cTransform = tripleDES.CreateDecryptor();
 byte[] resultArray = cTransform.TransformFinalBlock(enc_data, 0, enc_data.Length);
 //string s = Convert.ToBase64String(resultArray);
 string x = System.Text.Encoding.ASCII.GetString(resultArray);
 System.IO.File.WriteAllText(@""D:\570_f.txt"", x);
 tripleDES.Clear();
</code></pre>

<p>1) -code is working fine almost but somewhere I <strong>found 8 byte of junk character replacing real text.</strong>  [ main problem]</p>

<pre><code>.................okokokookokok8bytejunkokokokokokokookko..............8bytjunkokokokokokokokokokoko............
</code></pre>

<p>2) - don't know what padding scheme is using during encryption process, I tried decryption with zero padding mode.</p>

<pre><code>    ----testing with different length file-----
(A)
     input_file  |encrypted_file with_tool | decrypted_file_with_above_code
     10224 byte  |          x              | 10232 byte        
     ok data + last 8 hex byte 3F 00 00 00 00 00 00 00 
(b)
     input_file  |encrypted_file with_tool | decrypted_file_with_above_code
     10242 byte  |          x              | 10248 byte        
     ok data + last 8 hex byte 0D 3F 3F 3F 3C 56 31 65

(C)
     input_file  |encrypted_file with_tool | decrypted_file_with_above_code
     10258 byte  |          x              | 10264 byte        
     ok data + last 24 hex byte 
     0A 3F 3F 14 4D 27 79 0F 61 61 61 61 61 61 61 61 
     61 61 3F 00 00 00 00 00 
</code></pre>

<p>NOTE - FILE CONTAIN only character a (HEX VALUE = 61)
any advice here would be great to hear</p>
","<p>Finally found this encyption tool is taking input in the form of block of n byte. For n byte block there was no padding while any block less than nbyte is padded by 80 followed by 00 to make it multiple of 8. </p>

<p>I try to decrypt in same way, devide full file in form of n byte block and then decrypt  each block and save output in a buffer,</p>

<p>and at last convert full buffer into string and paste in a file. </p>
","115","<c#><encryption><3des><cbc-mode>","0","0","1","2016-12-20 19:18:45","41249697","0","","608639","","2016-12-16 05:30:14","2016-12-15 11:00:04",""
"20876349","Wraping 3DES key with itself","<p>I have a question that looks weird even to myself.</p>

<p>I am translating a program written about 15 years ago to C#. A part of this program is key generation and storing it in a file medium. </p>

<p>Here is the part that I am concerned. This specific method generates a 3DES derived key from a master 3DES key that we call it <code>Key1</code>.</p>

<p>This method uses <code>Key1</code> to wrap <code>Key1</code> which we call it <code>wrap1</code>.
in next step it uses the <code>Key1</code> to wrap <code>wrap1</code> which we call it <code>wrap2</code>.
<code>wrap2</code> is stored in medium and <code>Key1</code> and <code>wrap1</code> is lost.</p>

<p>From my understanding, a wrapped key should be unwrapped before being used for encryption and decryption; However I'm not sure if we can unwrap a key without having the key that used to wrap it.</p>

<p>Please note I do not have access to the part of program that uses this key to see how it is used.</p>

<p><strong>Question</strong>  is it possible to retrieve the key that is wrapped this way?</p>
","<p>Why?  Wrapping a key with itself is pointless.  It's like buying dehydrated water: just add water to reconstitute.  You need the key <code>key1</code> to decrypt <code>wrap1</code> -- and then what do you get back?  You get back <code>key1</code>, which is what you already had.</p>

<p>Of course, someone who doesn't have the key (and can't guess it) cannot decrypt the wrapped key.  That's how key wrapping works.  So, no, given just <code>wrap1</code> or just <code>wrap2</code>, you cannot deduce the value of <code>key1</code>.</p>
","107","<encryption><3des>","0","1","1","2014-01-02 06:34:08","20877593","0","","1041046","","2014-01-02 06:12:41","2014-01-02 04:28:44",""
"47216470","3des encryption didn't get expected result","<p>My nodejs 3DES encryption didn't get expected result. Is there anything wrong with my code? </p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>let cryptojs = require('crypto-js')
var key = '412B121B61C9782FCA6B983AF29862AA';
var message = '46574669849832145886804657466984';

key = cryptojs.enc.Hex.parse(key);
message = cryptojs.enc.Hex.parse(message);

var result = cryptojs.TripleDES.encrypt(message, key, {mode: cryptojs.mode.ECB, padding: cryptojs.pad.NoPadding});

console.log (result.key.toString());
console.log (result.ciphertext.toString());
console.log (result.toString());</code></pre>
</div>
</div>
</p>

<p>the output is</p>

<pre><code>412b121b61c9782fca6b983af29862aa
511e4f67d9dd0f840c4689348e2e7ce3
UR5PZ9ndD4QMRok0ji584w==
</code></pre>

<p>however expected should be </p>

<pre><code>2B4D7E0FE9672FEA5CDF60735B58D356
</code></pre>
","<p>TripleDES keys are, as you might imagine, three times the length of DES keys.  The key you are using is 128-bits whereas the key size expected is 192-bits.</p>

<p>What this means is that you have 2 of the 3 required keys, e.g. 2 lots of 64-bits, and a third lot of 64-bits is missing.</p>

<p>Some implementations of TripleDES will simply use the first lot of 64-bits as the third lot of 64-bits if you omit them.  CryptoJS doesn't do this for you, it just sets the third lot of 64-bits to be 0.  The result you have comes from an implementation that uses the first key as the third key, so we have to simulate this behavior in CryptoJS.</p>

<p>To solve this problem, change the value of your key to the following: <code>412B121B61C9782FCA6B983AF29862AA412B121B61C9782F</code>.</p>
","105","<node.js><encryption><3des>","0","0","1","2017-11-10 06:15:11","47216692","0","","","","","2017-11-10 05:54:10",""
"54089115","Why did the result of DES Encryption executed in Java different from executed in PHP?","<p>I ran the Trible DES Encryption in Java, with <code>null</code> IV (I have run <code>cipher.getIV()</code> method and indeed it's IV is null) and the same string ran the Triple DES Encryption in PHP with <code>null</code> IV, but I get a different result. Why is that?</p>

<p>Java Code:</p>

<pre><code>private static final String model = ""DESede/ECB/PKCS5Padding"";
public static String desEncrypt(String message, String key) throws Exception {
    byte[] keyBytes = null;
    if(key.length() == 16){
        keyBytes = newInstance8Key(ByteUtil.convertHexString(key));
    } else if(key.length() == 32){
        keyBytes = newInstance16Key(ByteUtil.convertHexString(key));
    } else if(key.length() == 48){
        keyBytes = newInstance24Key(ByteUtil.convertHexString(key));
    }

    SecretKey deskey = new SecretKeySpec(keyBytes, ""DESede"");

    Cipher cipher = Cipher.getInstance(model);
    cipher.init(1, deskey);
    return ByteUtil.toHexString(cipher.doFinal(message.getBytes(""UTF-8"")));
}
</code></pre>

<p>PHP Code:</p>

<pre><code>// composer require phpseclib/phpseclib
use phpseclib\Crypt\TripleDES;

function desEncrypt($str,$key){
    $cipher = new TripleDES();
    $cipher-&gt;setKey(hex2bin($key));

    $cryptText = $cipher-&gt;encrypt($str);

   return unpack(""H*"",$cryptText)[1];
}
</code></pre>

<p>I want to modify my PHP code to fit the Java Encryption Process，how should I do? where is the proplem?</p>

<p>Java Encrypt Result:</p>

<pre><code>before: 622700300000
key: 0123456789ABCDEFFEDCBA98765432100123456789ABCDEF
after: c9aa8ebfcc12ce13e22a33b05d4c18cf
</code></pre>

<p>PHP Encrypt Result:</p>

<pre><code>before: 622700300000
key: 0123456789ABCDEFFEDCBA98765432100123456789ABCDEF
after: a6e7a000d4ce79ac8b3db9f6acf73de3
</code></pre>

<p>Fixed PHP Code:</p>

<pre><code>/**
 * Triple DES (ECB) Encryption Function
 * PKCS5Padding
 * 
 * @param string $message String needed to be encode
 * @param string $key Hex encoded key
 * @return string Hex Encoded
 */
function desEncrypt($message,$key){
    $cipher = new TripleDES(TripleDES::MODE_ECB);
    $cipher-&gt;setKey(hex2bin($key));

    $cryptText = $cipher-&gt;encrypt($message);

   return bin2hex($cryptText);
}
</code></pre>
","<p>You forgot to hex decode the key before using it. You're also using CBC mode instead of ECB mode, but as your IV is all zero's, that amounts to the same thing <em>for the first block</em> of data that is encrypted.</p>
","86","<java><php><encryption><des><3des>","3","1","1","2019-01-08 14:14:40","54091507","1","1","5971805","","2019-01-08 14:14:40","2019-01-08 09:48:12",""
"31577831","Does openssl's low level API automatically add padding?","<p>I know that block cipher mode such as ecb and cbc requires padding. I also know that openssl command line tool can switch between add padding/no padding. But does openssl's low level API automatically add padding? Specifically <code>DES_ecb3_encrypt()</code> / <code>DES_ecb3_encrypt()</code>.</p>

<p>PS: I checked the EVP interface source code, and it seems the padding operation is done at EVP level. When padding is required, after encryping data using <code>DES_ecb3_encrypt()</code>, EVP will also encrypt padding part.</p>
","","84","<openssl><padding><3des><ecb>","1","","0","2015-07-23 03:48:47","","0","","","","","2015-07-23 03:48:47",""
"50226570","Wrong Key Size Exception when decrypt plain text using RSA_Decrypted 3DES KEY","<p>I am trying to implement a hybrid cryptosystem that:</p>

<ol>
<li>encrypts text using 3DES and ecnryptes the 3DES key using RSA encryption algorithm</li>
<li>Decrypted RSA-encrypted 3DES key and then use it to decrypt the cipher text to get retrive the encrypted plaintext</li>
</ol>

<p>It throws an exception of:</p>

<blockquote>
  <p>Invalid Key Size Exception</p>
</blockquote>

<p>How can I fix the code?</p>

<pre><code>import java.security.Key;
import java.security.InvalidKeyException;
import java.security.spec.InvalidKeySpecException;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.IllegalBlockSizeException;

import java.io.UnsupportedEncodingException;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;


import org.apache.commons.codec.binary.Base64;
import java.security.KeyPairGenerator;
import java.security.NoSuchProviderException;
import java.security.spec.InvalidKeySpecException;

public class Hybrid_Implementation_V2 {

//3DES_Encryption Algorithm Required Variables
private byte[] DES_Key;
private SecretKeyFactory keyfactory;
private DESedeKeySpec spec;
private Key deskey;
private int DES_Key_Length;
private byte[] data;
private Cipher cipher;
private String CipherText;
private byte [] CIPHERText;

//RSA
private KeyPairGenerator keyGen;
private KeyPair pair;
private PrivateKey privateKey;
private PublicKey publicKey;
private final Cipher RSA_cipher;

Hybrid_Implementation_V2() throws InvalidKeyException, 
NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException
{
    this.keyGen = KeyPairGenerator.getInstance(""RSA"");
    this.keyGen.initialize(1024);
    this.RSA_cipher = Cipher.getInstance(""RSA"");
    DES_Key_Generator();
    RSA_Key_Generation();
}

                //KEY Generation Mechanism
//3DES Key Generation
private void DES_Key_Generator() throws InvalidKeyException, 
NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException
{
    Random rnd = new Random();
    String key = rnd.toString();

    DES_Key = key.getBytes();
    spec = new DESedeKeySpec(DES_Key);
    keyfactory = SecretKeyFactory.getInstance(""desede"");
    deskey = keyfactory.generateSecret(spec);
    cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
}

//RSA Public - Private Key Generation
private void RSA_create_Key()
{
    this.pair = this.keyGen.generateKeyPair();
    this.privateKey = pair.getPrivate();
this.publicKey = pair.getPublic();
}

public PrivateKey getPrivateKey() 
    {
    return this.privateKey;
}

public PublicKey getPublicKey() 
    {
    return this.publicKey;
}

    public void RSA_Key_Generation(){RSA_create_Key();}



// https://docs.oracle.com/javase/8/docs/api/java/security/spec/PKCS8EncodedKeySpec.html

public PrivateKey getPrivate() throws NoSuchAlgorithmException, 
InvalidKeySpecException
    {
    byte[] keyBytes = getPrivateKey().getEncoded();
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return kf.generatePrivate(spec);
}

// https://docs.oracle.com/javase/8/docs/api/java/security/spec/X509EncodedKeySpec.html
public PublicKey getPublic() throws NoSuchAlgorithmException, 
InvalidKeySpecException
    {
    byte[] keyBytes = getPublicKey().getEncoded();
    X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return kf.generatePublic(spec);
}
    public String RSA_encryptText(String msg) throws 
NoSuchAlgorithmException, NoSuchPaddingException, 
UnsupportedEncodingException, IllegalBlockSizeException, 
BadPaddingException, InvalidKeyException, InvalidKeySpecException {
 PrivateKey key = getPrivate(); 
        this.RSA_cipher.init(Cipher.ENCRYPT_MODE, key);
    return Base64.encodeBase64String(RSA_cipher.doFinal(msg.getBytes(""UTF-8"")));
}

public String RSA_decryptText(String msg)throws InvalidKeyException, 
UnsupportedEncodingException, IllegalBlockSizeException, 
BadPaddingException, NoSuchAlgorithmException, InvalidKeySpecException {
    PublicKey key = getPublic();
        this.RSA_cipher.init(Cipher.DECRYPT_MODE, key);
    return new String(RSA_cipher.doFinal(Base64.decodeBase64(msg)), ""UTF-8"");
}
              //Hybrid Encryption Mechanism
//Encryption Function Caller
private String encryption(String plaintext) throws InvalidKeyException, 
IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, 
NoSuchPaddingException, UnsupportedEncodingException, 
InvalidKeySpecException
{
    String cipher_text = DES_Encryption(plaintext);
    String RSA_DESKey = RSA_encryptText(DES_Key.toString());
    DES_Key_Length = RSA_DESKey.length();
    CipherText ="""";
    CipherText = new 
StringBuilder().append(RSA_DESKey).append(cipher_text).toString();
    return CipherText;
}

//3DES Encryption
 private String DES_Encryption(String plaintext) throws InvalidKeyException, 
IllegalBlockSizeException, BadPaddingException
{
    data = plaintext.getBytes();
    cipher.init(Cipher.ENCRYPT_MODE, deskey);
    CIPHERText = cipher.doFinal(data);
    StringBuilder hexCiphertext = new StringBuilder();
    for(int i=0; i&lt;CIPHERText.length; i++)
    {
        int v = CIPHERText[i] &amp; 0xff;
        v+=0x100;
        String temp = Integer.toString(v,16);
        hexCiphertext.append(temp).substring(1);
    }
    return hexCiphertext.toString();
}

                   //Hybrid Decryption Mechanism
 //Decryption Function Caller
 private String decryption(String encrypted_text) throws 
InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, 
BadPaddingException, UnsupportedEncodingException, NoSuchAlgorithmException, 
NoSuchPaddingException
{
    StringBuilder encryptedkey = new StringBuilder();
    StringBuilder cipheredtext = new StringBuilder();
    for(int i = 0 ; i &lt; DES_Key_Length; i++)    //Extraction of Encrypted 
3DES Key
        encryptedkey.append (encrypted_text.charAt(i));
    for(int j = DES_Key_Length ; j&lt; encrypted_text.length() ; j++)      
//Extraction of Ciphered Text
        cipheredtext.append (encrypted_text.charAt(j));
    String temp = RSA_decryptText(encryptedkey.toString());
    byte [] DES_KEY = temp.getBytes();
    String plaintext = 
DES_Decryption(DES_KEY,cipheredtext.toString().getBytes());
       return plaintext;
}


 //3DES Decryption
private String DES_Decryption(byte [] key, byte [] encrypted_text) throws 
InvalidKeyException, IllegalBlockSizeException, BadPaddingException, 
InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException
{

    Key deskey;
    DESedeKeySpec spec = new DESedeKeySpec(key);
    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(""desede"");
    deskey = keyfactory.generateSecret(spec);
    Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE,deskey);
    byte[] plaintext = cipher.doFinal(encrypted_text);
    StringBuilder decrypttext= new StringBuilder();
    for (int i = 0; i &lt; plaintext.length; i++)
        decrypttext.append((char) plaintext[i]);
    return decrypttext.toString();
}

/**
 * @param args the command line arguments
 * @throws java.security.InvalidKeyException
 * @throws java.security.NoSuchAlgorithmException
 * @throws java.security.spec.InvalidKeySpecException
 * @throws javax.crypto.NoSuchPaddingException
 * @throws javax.crypto.IllegalBlockSizeException
 * @throws javax.crypto.BadPaddingException
 */
public static void main(String[] args) throws InvalidKeyException, 
NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, 
IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException 
{

    String plaintext;
    Hybrid_Implementation_V2 hi = new Hybrid_Implementation_V2 ();
    Scanner sc = new Scanner(System.in);
    System.out.print(""Enter Text = "");
    plaintext = sc.nextLine();
    String encrypted_text = hi.encryption(plaintext);
    String decrypted_text = hi.decryption(encrypted_text);
    System.out.println(""Plain Text Entered = ""+plaintext);
    System.out.println(""Encrypted Text = ""+encrypted_text);
    System.out.println(""Decrypted Text = ""+decrypted_text);

}

}
</code></pre>
","","83","<exception><key><rsa><3des>","1","","0","2018-05-08 14:54:34","","4","","9739185","","2018-05-08 14:54:34","2018-05-08 05:41:00",""
"55917245","JAVA to PHP 7 Encryption","<p>I want to replicate the encryption/decryption from JAVA to PHP. But my problem the result is not match. I have no idea about java so I'm trying to understand each line of codes from java and write in PHP. </p>

<p><strong>JAVA</strong></p>

<pre class=""lang-java prettyprint-override""><code>
    secretkey: thisisasecretkey
    import java.security.MessageDigest;
    import java.util.Arrays;
    import javax.crypto.Cipher;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;

    import org.apache.commons.codec.binary.Base64;

    public class TDESEncrypter {

    public String _encrypt(String message, String secretKey) throws Exception {
    
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] digestOfPassword = md.digest(secretKey.getBytes(""utf-8""));
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        Cipher cipher = Cipher.getInstance(""DESede"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
            
        byte[] plainTextBytes = message.getBytes(""utf-8"");
        byte[] buf = cipher.doFinal(plainTextBytes);
        byte [] base64Bytes = Base64.encodeBase64(buf);
        String base64EncryptedString = new String(base64Bytes);
            
        return base64EncryptedString;
    }

    public String _decrypt(String encryptedText, String secretKey) throws Exception {
    
        byte[] message = Base64.decodeBase64(encryptedText.getBytes(""utf-8""));
            
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] digestOfPassword = md.digest(secretKey.getBytes(""utf-8""));
        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            
        Cipher decipher = Cipher.getInstance(""DESede"");
        decipher.init(Cipher.DECRYPT_MODE, key);
            
        byte[] plainText = decipher.doFinal(message);
            
        return new String(plainText, ""UTF-8"");
    }
   
}

</code></pre>

<p>Here's the steps using java that might be useful to replicate the functions in PHP.</p>

<ol>
<li>create a hash using sha1</li>
<li>convert the secretkey(from credentials) to bytes array with utf-8 encoding</li>
<li>padd step 2 with xeroes, truncating or padding with zeros (if necessary) so the copy has the specified length of 24</li>
<li><p>initialize Secretkey with keybytes from step3 using DESede</p></li>
<li><p>create cipher with DESede instance</p></li>
<li>initialize cipher with mode to encrypt using the key from step4</li>
<li>convert data(username/password) to encrypt to byte array with utf-8 encoding</li>
<li>encrypt step 7 using step 6 cipher</li>
<li>encode step8 in base 64 format</li>
<li>convert step9 to string for final string encrypted message</li>
</ol>

<p>What I have done so far,</p>

<pre class=""lang-php prettyprint-override""><code>function encrypt($data, $secret)  { 



    $key = sha1(utf8_encode($secret), true); &lt;-- Step 1 &amp; 2
    $iv = utf8_encode(""jvz8bUAx""); &lt;-- Do I use initialise vector on it?

    $key .= substr($key, 0, 8); 

    $method = 'des-ede3-cbc'; //&lt;-- Is this cypher method correct from the above?


    if (strlen($data) % 8) {
        $data = str_pad($data, strlen($data) + 8 - strlen($data) % 8, ""\0"");
    }

    $encrypted = openssl_encrypt($data, $method, $key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $iv); //Force zero padding.

    $encrypted = urlencode(base64_encode($encrypted)); // Added the urlencode.....
    return $encrypted;
} 
</code></pre>
","<p>In the Java-code, the encryption-algorithm is specified as <code>DESede</code>. This corresponds to <code>DESede/ECB/PKCS5Padding</code>, i.e. the ECB-mode and PKCS5-padding are used. This means for the PHP-code:</p>

<ul>
<li><code>des-ede3</code> must be applied </li>
<li>all code portions related to an IV must be removed (since the ECB-mode doesn't use an IV)</li>
<li>the custom padding (which is by no means <a href=""https://en.wikipedia.org/wiki/Padding_(cryptography)"" rel=""nofollow noreferrer"">PKCS5-Padding</a>) must be removed (since <code>openssl_encrypt</code> uses PKCS5-padding by default)</li>
</ul>

<p>In the Java-code, the SHA1-hash (with a size of 20 bytes) is extended to 24 bytes by appending 0-values. This extension must also be done in the PHP-code.</p>

<p>A possible PHP-counterpart to the Java <code>_encrypt</code>-method is:</p>

<pre><code>function encrypt($data, $secret)  {
    $key = sha1(mb_convert_encoding($secret, ""UTF-8""), true);                   // Create SHA-1 hash (20 byte) 
    $key = str_pad($key, 24, ""\0"");                                             // Extend to 24 byte by appending 0-values (would also happen automatically on openssl_encrypt-call)
    $encrypted = openssl_encrypt($data, 'DES-EDE3', $key, OPENSSL_RAW_DATA);    // Encryption: DESede (24 byte key), ECB-mode, PKCS5-Padding
    return base64_encode($encrypted);                                           // Base64-encoding
}
</code></pre>

<p>Finally: The Java-code has a number of disadvantages, e.g.</p>

<ul>
<li>Triple-DES is used. A better choice would be AES, see e.g. <a href=""https://stackoverflow.com/questions/5554526/comparison-of-des-triple-des-aes-blowfish-encryption-for-data"">here</a></li>
<li>the ECB-mode is used, which is unsafe per se, see e.g. <a href=""https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption"">here</a>. A better choice would be CBC or GCM (the latter under AES). </li>
<li>SHA-1 is used as KDF (which gives a too short key, 20 bytes instead of the 24 bytes actually needed). A better choice would be <a href=""https://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow noreferrer"">PBKDF2</a>.</li>
</ul>

<p>The latter just for the sake of completeness, as it's probably legacy code that can't be changed for any reason.</p>
","79","<java><php><encryption><encryption-symmetric><3des>","-1","1","1","2019-05-01 00:10:58","55929380","6","","11431445","","2019-05-01 00:10:58","2019-04-30 08:53:36",""
"47375204","BlackBerry 10, 3DES-ECB implementation","<h3>Intro</h3>

<p>My bb10 app sent <code>3DES-ECB</code>-encrypted data to backend (PHP)</p>

<h3>Code</h3>

<p>PHP backend</p>

<pre><code>public static function encrypt3Des($data, $key)
{
    //Generate a key from a hash
    $key = md5(utf8_encode($key), true);
    //Take first 8 bytes of $key and append them to the end of $key.
    $key .= substr($key, 0, 8);
    //Pad for PKCS7
    $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
    $len = strlen($data);
    $pad = $blockSize - ($len % $blockSize);
    $data = $data.str_repeat(chr($pad), $pad);
    //Encrypt data
    $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');
    return base64_encode($encData);
}

public static function decrypt3Des($data, $secret)
{
    //Generate a key from a hash
    $key = md5(utf8_encode($secret), true);
    //Take first 8 bytes of $key and append them to the end of $key.
    $key .= substr($key, 0, 8);
    $data = base64_decode($data);
    $data = mcrypt_decrypt('tripledes', $key, $data, 'ecb');
    $block = mcrypt_get_block_size('tripledes', 'ecb');
    $len = strlen($data);
    $pad = ord($data[$len-1]);
    return substr($data, 0, strlen($data) - $pad);
}
</code></pre>

<p>Blackberry 10 client</p>

<pre><code>/// cipherservice.hpp ///

#pragma once

#include &lt;QObject&gt;

#include &lt;hudes.h&gt;
#include &lt;hugse56.h&gt;

class CipherService : public QObject {
    Q_OBJECT
public:

    virtual ~CipherService();
    CipherService(QString key);

    QString encryptTDES(QString message);
    QString decryptTDES(QString message);

private:
    void initCipher(QString key);
    void destroyCipher();

    sb_GlobalCtx huGlobalContext;
    sb_Context huContext;
    sb_Key huKey;
    sb_Params huParams;
};

/// cipherservice.cpp ///

#include ""cipherservice.hpp""

#include &lt;huctx.h&gt;

#define TO_HEXSTR(code) (""0x"" + QString(""%1"").arg(code, 0, 16).toUpper())

CipherService::CipherService(QString key)
    : QObject() {
    initCipher(key);
}

CipherService::~CipherService() {
    destroyCipher();
}

void CipherService::initCipher(QString key) {
    int rc = hu_GlobalCtxCreateDefault(&amp;huGlobalContext);
    LOGD &lt;&lt; ""hu_GlobalCtxCreateDefault return code = "" &lt;&lt; TO_HEXSTR(rc);

    rc = hu_RegisterSbg56DES(huGlobalContext);
    LOGD &lt;&lt; ""hu_RegisterSbg56DES return code = "" &lt;&lt; TO_HEXSTR(rc);

    rc = hu_InitSbg56(huGlobalContext);
    LOGD &lt;&lt; ""hu_InitSbg56 return code = "" &lt;&lt; TO_HEXSTR(rc) &lt;&lt; "" (0xF00D means already initialized so ignore it)"";

    rc = hu_DESParamsCreate(USED_SB_DES, SB_DES_ECB, SB_DES_PARITY_OFF, SB_DES_WEAK_KEY_OFF,
            NULL, NULL, &amp;huParams, huGlobalContext);
    LOGD &lt;&lt; ""hu_DESParamsCreate return code = "" &lt;&lt; TO_HEXSTR(rc);

    QByteArray resultKey = QCryptographicHash::hash(key.toUtf8().constData(), QCryptographicHash::Md5);
    resultKey.append(resultKey.mid(0, 8));

    LOGD &lt;&lt; ""key="" &lt;&lt; resultKey.toBase64();

    unsigned char* keyBuf = reinterpret_cast&lt;unsigned char*&gt;(resultKey.data());
    size_t keyBufLen = SB_DES_KEY_SIZE;
    rc = hu_DESKeySet(huParams, keyBufLen, keyBuf, keyBufLen, keyBuf, keyBufLen, keyBuf, &amp;huKey, huGlobalContext);
    LOGD &lt;&lt; ""hu_DESKeySet return code = "" &lt;&lt; TO_HEXSTR(rc);

    const unsigned char iv[SB_DES_IV_SIZE] = {0};
    rc = hu_DESBeginV2(huParams, huKey, SB_DES_ECB, SB_DES_IV_SIZE, iv, &amp;huContext, huGlobalContext);
    LOGD &lt;&lt; ""hu_DESBeginV2 return code = "" &lt;&lt; TO_HEXSTR(rc);
}

void CipherService::destroyCipher() {
    if (&amp;huContext != NULL) {
        int rc = hu_DESEnd(&amp;huContext, huGlobalContext);
        LOGD &lt;&lt; ""hu_DESEnd return code = "" &lt;&lt; TO_HEXSTR(rc);
        huContext = NULL;
    }
}

QString CipherService::encryptTDES(QString msg) {
    size_t pad = SB_DES_BLOCK_SIZE - (msg.length() % SB_DES_BLOCK_SIZE);

    for (uint i = 0; i &lt; pad; i += 1) {
        msg.append(static_cast&lt;QChar&gt;(pad));
    }

    QByteArray plainBuf(msg.toUtf8());
    char* cipherBuf = new char[plainBuf.length()];

    LOGD &lt;&lt; ""hu_DESEncryptMsg plainBuf = "" &lt;&lt; plainBuf;

    int rc = hu_DESEncrypt(huContext,
                plainBuf.length(),
                reinterpret_cast&lt;const unsigned char*&gt;(plainBuf.data()),
                reinterpret_cast&lt;unsigned char*&gt;(cipherBuf), huGlobalContext);

    QByteArray byteData((char*)cipherBuf, plainBuf.length());
    QString result(byteData.toBase64());

    LOGD &lt;&lt; ""hu_DESEncryptMsg length = "" &lt;&lt; plainBuf.length() &lt;&lt; "" code = "" &lt;&lt; TO_HEXSTR(rc) &lt;&lt; "" result = "" &lt;&lt; result;

    return result;
}

QString CipherService::decryptTDES(QString msg) {
    QByteArray cipherBuf(QByteArray::fromBase64(msg.toUtf8()));

    if (cipherBuf.size() % SB_DES_BLOCK_SIZE) {
        cipherBuf.resize((cipherBuf.size() / SB_DES_BLOCK_SIZE) * (SB_DES_BLOCK_SIZE));
    }
    LOGD &lt;&lt; ""hu_DESEncryptMsg cipherBuf = "" &lt;&lt; msg &lt;&lt; "" length = "" &lt;&lt; cipherBuf.length();

    unsigned char* plainBuf = new unsigned char[cipherBuf.length() + 1](); // +1 to last \0

    int rc = hu_DESDecrypt(huContext,
            cipherBuf.length(),
            reinterpret_cast&lt;const unsigned char*&gt;(cipherBuf.data()),
            reinterpret_cast&lt;unsigned char*&gt;(plainBuf), huGlobalContext);

    QByteArray byteData((char*)plainBuf, cipherBuf.length());
    QString result(byteData);

    if (result.length() &gt; 0) {
        size_t pad = (size_t) result[result.length() - 1].toAscii();
        result = result.remove(result.length() - pad, pad);
    }

    LOGD &lt;&lt; ""hu_DESDecryptMsg length = "" &lt;&lt; cipherBuf.length() &lt;&lt; "" code = "" &lt;&lt; TO_HEXSTR(rc) &lt;&lt; "" result = "" &lt;&lt; result;

    return result;
}
</code></pre>

<h3>Problem</h3>

<p>This solution doesn't work, during troubleshooting I have found 2 main differences between PHP and BB10 implementations:</p>

<ul>
<li>BB10 use 8-byte keys only, PHP use 24-byte keys

<ul>
<li><a href=""https://developer.blackberry.com/native/reference/core/com.qnx.doc.crypto.lib_ref/topic/hu_DESKeySet.html"" rel=""nofollow noreferrer""><code>SB_DES_KEY_SIZE == 8</code></a></li>
<li><a href=""http://php.net/manual/en/function.mcrypt-get-key-size.php"" rel=""nofollow noreferrer""><code>mcrypt_get_key_size('tripledes', 'ecb') == 24</code></a></li>
</ul></li>
<li>BB10 require <code>IV</code> and I don't know why because <code>ECB</code> mode didn't require it, but I cannot pass <code>NULL</code> because I will get error code</li>
</ul>

<h3>Questions</h3>

<ul>
<li>Is it possible to use different key lengths on BlackBerry10 Cascades?</li>
<li>What is the crypt library used there? Is it from QNX? </li>
<li>I saw that there is <code>openssl</code> presented on BB10, but it's API looks very limited, is it possible to implement <code>3DES-ECB</code> with <code>openssl</code> on BB10?</li>
</ul>

<h3>Links</h3>

<ul>
<li>PHP playground
<a href=""http://sandbox.onlinephpfunctions.com/code/8b33cdf24983af8e1f506a62b69c4504e05176d9"" rel=""nofollow noreferrer"">http://sandbox.onlinephpfunctions.com/code/8b33cdf24983af8e1f506a62b69c4504e05176d9</a></li>
<li>BB10 docs <a href=""https://developer.blackberry.com/native/reference/core/com.qnx.doc.crypto.lib_ref/topic/manual/intro.html"" rel=""nofollow noreferrer"">https://developer.blackberry.com/native/reference/core/com.qnx.doc.crypto.lib_ref/topic/manual/intro.html</a></li>
</ul>
","<p>The issue is the key. BB creates the 24-byte 3DES key like this:</p>

<pre><code>QByteArray resultKey = QCryptographicHash::hash(key.toUtf8().constData(), QCryptographicHash::Md5);
resultKey.append(resultKey.mid(0, 8));
</code></pre>

<p>It is taking the <code>key</code> which is a string , funs it through MD% creating 16-bytes. Then it appends the first 8-bytes of the MD5 output to it. This creates a 24-byte key, what is known as two-key 3DES, this is not secure and should be used.</p>

<p>For PHP you need to create the key in the same way.</p>

<p>Also pay attention to the IV and padding. As noted ECB mode does not use an IV and I have seen time and again pan IV being supplied the ECB mode, =generally because developers did not understand ECB mode.</p>

<p>You are probably better off using OpenSSL in PHP, mcrypt is horrible.</p>

<p>Use some hex prints to verify that the key and IV are the same prior to encryption.</p>
","79","<php><openssl><blackberry-10><blackberry-cascades><3des>","0","0","1","2017-11-19 20:51:05","","1","","","","","2017-11-19 09:01:15",""
"54860225","phpseclib zero byte padding","<p>How to add zero byte padding in phpseclib with encryption method 3des in EBC mode?</p>

<p>Here my current code: </p>

<pre><code>$cipher = new TripleDES(TripleDES::MODE_ECB);
$cipher-&gt;setKey('1234567890ABCDEFGHIJKLMN');
</code></pre>
","<p>Just figure it out:</p>

<ol>
<li><p>Disable padding: 


<pre><code>$cipher-&gt;disablePadding();
</code></pre></li>
<li><p>Manually pad message: 


<pre><code>$message_padded = $urlencoded;
if (strlen($message_padded) % 8) {
    $message_padded = str_pad($message_padded,
        strlen($message_padded) + 8 - strlen($message_padded) % 8, ""\0"");
}
</code></pre></li>
<li><p>encrypt: 


<pre><code>$result = $cipher -&gt; encrypt($message_padded);
</code></pre></li>
</ol>
","79","<php><encryption><phpseclib><3des>","2","2","1","2019-02-26 06:59:47","54860988","2","","","","","2019-02-25 05:51:02",""
"56648883","Encrypt 3DES on oracle, decrypt doesn't work on DB2","<p>I need to encrypt data on oracle and decrypt on DB2.</p>

<p>I can use only DBMS_OBFUSCATION_TOOLKIT on oracle.</p>

<pre><code>set serveroutput on;
DECLARE
    L_TEXT       VARCHAR2(16) := '1234567890123456';
    U_ID         VARCHAR2(16) := 'asdfghjk12345678';
    L_ENCRYPTED  VARCHAR2(512);
BEGIN

DBMS_OBFUSCATION_TOOLKIT.DES3ENCRYPT(INPUT =&gt; UTL_RAW.CAST_TO_RAW(L_TEXT),
                                     KEY =&gt; UTL_RAW.CAST_TO_RAW(U_ID),
                                     ENCRYPTED_DATA =&gt; L_ENCRYPTED);
dbms_output.put_line(L_ENCRYPTED);
END;

OUTPUT: 9E2CC8BFE31C23189D16A6D4E946DF2E
-----------------------------------------------
select decrypt_char(CAST('9E2CC8BFE31C23189D16A6D4E946DF2E' AS VARBINARY(1000)), 'asdfghjk12345678')  from SYSIBM.SYSDUMMY1

OUTPUT: ExampleExceptionFormatter: exception message was: [SQ20146] The decryption function failed.  The data is not encrypted.
</code></pre>

<p>Can you help me?</p>
","<p><code>DES3ENCRYPT</code> sounds like it uses DES3.</p>

<p><code>DECRYPT_CHAR</code> on DB2 (which is Deprecated BTW) can ""can only decrypt values that are encrypted using the ENCRYPT function""</p>

<p>The ENCRYPT encryption algorithm is ""RC2 block cipher with padding""</p>

<p><a href=""https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0004210.html"" rel=""nofollow noreferrer"">https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0004210.html</a></p>
","75","<oracle><encryption><plsql><db2><3des>","0","2","1","2019-06-18 13:05:14","","1","","","","","2019-06-18 12:12:11",""
"54303212","Encrypting payment track details using DUKPT key management in objective C","<p>I finding hard to get the solution to encrypt the payment track details which I got from InfinieaTab device. I am using DUKPT key management with 3DES algorithm. It would be grateful if I find any code snippet on this.</p>
","","71","<ios><objective-c><3des><dukpt>","0","","0","2019-01-22 07:28:51","","5","","","","","2019-01-22 07:28:51",""
"49664619","3des decryption in c# from a string returned by event.message.text","<p>How do I properly convert the input text so that it decrypts properly
I get an error saying </p>

<p>Error   CS1503  Argument 1: cannot convert from 'string' to 'char[]'    </p>

<p>whats the proper way to parse the first parameter of TransfromFinalBlock of the decryption interface? thanks</p>

<pre><code>private static void Bot_OnMessage4(object sender, MessageEventArgs e)
    {
        ICryptoTransform decrypt = des.CreateDecryptor();
        String[] dd = new String[1];
        dd[1]= utf8.GetString(decrypt.TransformFinalBlock(utf8.GetBytes(**e.Message.Text**, 0, utf8.GetBytes(e.Message.Text).Length)));
        Bot.SendTextMessageAsync(e.Message.Chat.Id, ""message to decrypt is  \n"" + e.Message.Text );
        Bot.SendTextMessageAsync(e.Message.Chat.Id, ""decrypted message is  \n"" + dd[1]);
</code></pre>
","<p>You seem to be already trying to fix your issues, correctly blaming your input:</p>

<pre><code>utf8.GetBytes(e.Message.Text, 0, utf8.GetBytes(e.Message.Text).Length)
</code></pre>

<p>The problem is that modern crypto acts on bytes, and returns a ciphertext where each byte can have <em>any value</em>. This means that the ciphertext may also contain bytes that do not represent <em>any character</em>. In other words, the ciphertext is <em>not really text</em>.</p>

<p>So there are two things you can do about it:</p>

<ol>
<li>keep handling the ciphertext as bytes or byte streams;</li>
<li>encode the ciphertext to a binary encoding such as base 64 and decode before you decrypt.</li>
</ol>

<p>Keeping the ciphertext in binary should be preferred, but it is not always possible if the interface with the rest of the system (the <code>Message</code> in this case) requires a textual string.</p>

<hr>

<p>Your error doesn't have anything to do about this, but if you follow above advice you don't need <code>utf8.GetBytes</code> anymore.</p>

<p>You should use the single argument <a href=""https://msdn.microsoft.com/en-us/library/ds4kkd55(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>GetBytes</code></a> method to get rid of the compile error, but your code would still fail during runtime (although it <em>could</em> succeed because the right bytes are generated by chance).</p>
","66","<c#><visual-studio><encryption><3des>","1","2","1","2018-04-05 16:20:37","","5","","","","","2018-04-05 05:17:06",""
"44960603","3DES encryption not matching third party API","<p>My C# 3DES encryption is not matching the third party API I'm using. Is there anything wrong with my code? </p>

<pre><code>static void Main(string[] args)
{
String sharedSec = ""654A7EA2C9914A0B972937F4EA45FED3""; 

byte[] byteArraySharedSec = Convert.FromBase64String(sharedSec);
TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

tdes.KeySize = 192;
tdes.Key = byteArraySharedSec;
tdes.Mode = CipherMode.ECB;
tdes.Padding = PaddingMode.PKCS7;

ICryptoTransform ict = tdes.CreateEncryptor();
ICryptoTransform dct = tdes.CreateDecryptor();

Console.WriteLine(""SharedSec: {0}"", sharedSec);
Console.WriteLine(""byteArraySharedSec: {0}\n"", ToReadableByteArray(byteArraySharedSec));

long unixTimestamp = 1299481200; 

byte[] unixTimestampByte = BitConverter.GetBytes(unixTimestamp);

Console.WriteLine(""Timestamp: {0}, length: {1} "", ToReadableByteArray(unixTimestampByte), unixTimestampByte.Length);

byte[] result = ict.TransformFinalBlock(unixTimestampByte, 0, unixTimestampByte.Length);

Console.WriteLine(""After 3DES encrypting: {0}, length {1}\n\n  "", ToReadableByteArray(result), result.Length); 
}

static public string ToReadableByteArray(byte[] bytes)
{
    return string.Join("","", bytes);
}
</code></pre>

<p>The output (you can see byteArraySharedSec is correct but encrypting is not):</p>

<blockquote>
  <p>SharedSec: 654A7EA2C9914A0B972937F4EA45FED3 </p>
  
  <p>byteArraySharedSec: 235,158,0,236,64,54,11,223,117,224,13,1,247,189,189,223,177,120,16,14,57,20,64,247</p>
  
  <p>Timestamp: 112,130,116,77,0,0,0,0, length: 8  </p>
  
  <p>After 3DES encrypting:
  213,60,183,244,171,116,202,205,233,17,226,8,70,9,111,43, length 16</p>
</blockquote>

<p>API Doc has given this example:</p>

<blockquote>
  <p>The 3DES encryption uses:</p>
  
  <ul>
  <li><p>192 bit key</p></li>
  <li><p>ECB Mode</p></li>
  <li><p>PKCS7 Padding</p></li>
  </ul>
  
  <p>Example SHARED_SECRET: 654A7EA2C9914A0B972937F4EA45FED3</p>
  
  <ul>
  <li><p>Convert SHARED_SECRET to byte array by Base64 decoding. This is the    3DES key: { 235, 158, 0, 236, 64, 54, 11, 223, 117, 224, 13, 1, 247, 189, 189, 223, 177, 120, 16, 14, 57, 20, 64, 247}</p></li>
  <li><p>Example timestamp (7AM 7th March 2011 GMT): 1299481200</p></li>
  <li><p>3DES encrypt (ECB mode, PKCS7 Padding) the timestamp using the 3DES    key : 128 bit (16 byte) result for this example { 82, 191, 213, 179, 179, 73, 1, 218, 247, 68, 254, 199, 19, 159, 1, 138}</p></li>
  </ul>
</blockquote>
","<p>You're encrypting a different value than the example gave you. </p>

<p>Treating the <code>timestamp</code> as string, and using the <code>UTF8</code> encoding to get its bytes representation should gave you the same result:</p>

<pre><code>...
byte[] unixTimestampByte = Encoding.UTF8.GetBytes(unixTimestamp.ToString());
...
</code></pre>
","59","<c#><3des>","0","2","1","2017-07-07 02:08:09","44961483","4","0","515455","","2017-07-07 00:24:59","2017-07-07 00:07:12",""
"57438620","TripleDES Encryption between PHP vs C#/.NET","<p>I have legacy server uses TripleDES encryption in .NET/C#.</p>

<p>Need to decrypt text by using PHP.</p>

<p>I wrote PHP code but it's not able to decrypt message generated form C#.</p>

<p>C# Code</p>

<pre><code>using System;
using System.Data;
using System.IO;
using System.Security.Cryptography;
using System.Text;


namespace testns
{
    class Program
    {
        static void Main(string[] args)
        {
            string key = ""123456789012345678901234"";
            string iv = ""12345678"";

            string text = ""this is just test string"";
            string e = Program.EncryptTripleDES(text, key, iv);
            Console.WriteLine(e);

            string d = Program.DecryptTripleDES(e, key, iv);
            Console.WriteLine(d);

            // Return
            // QDIRAeQ/O1hhjN4XqgcETG7IChnybCqZ
            // this is just test string
        }

        private static string EncryptTripleDES(string neqs, string nafKeyCode, string nafIvCode)
        {

            byte[] rgbKey = Encoding.UTF8.GetBytes(nafKeyCode);
            byte[] rgbIV = Encoding.UTF8.GetBytes(nafIvCode);

            string sEncrypted = string.Empty;

            if (!String.IsNullOrEmpty(neqs))
            {
                TripleDESCryptoServiceProvider cryptoProvider = new TripleDESCryptoServiceProvider();
                cryptoProvider.Mode = CipherMode.CBC;
                cryptoProvider.Padding = PaddingMode.None;

                byte[] buffer = Encoding.UTF8.GetBytes(neqs);
                MemoryStream ms = new MemoryStream();
                CryptoStream cs = new CryptoStream(ms, cryptoProvider.CreateEncryptor(rgbKey, rgbIV), CryptoStreamMode.Write);
                cs.Write(buffer, 0, buffer.Length);
                cs.FlushFinalBlock();

                sEncrypted = Convert.ToBase64String(ms.ToArray());

            }

            return sEncrypted;
        }

        private static string DecryptTripleDES(string neqs, string nafKeyCode, string nafIvCode)
        {

            byte[] rgbKey = Encoding.UTF8.GetBytes(nafKeyCode);
            byte[] rgbIV = Encoding.UTF8.GetBytes(nafIvCode);

            string decryptedText = string.Empty;

            if (!String.IsNullOrEmpty(neqs))
            {
                TripleDESCryptoServiceProvider cryptoProvider = new TripleDESCryptoServiceProvider();
                cryptoProvider.Mode = CipherMode.CBC;
                cryptoProvider.Padding = PaddingMode.None;
                byte[] buffer = Convert.FromBase64String(neqs);
                MemoryStream ms = new MemoryStream(buffer);
                CryptoStream cs = new CryptoStream(ms, cryptoProvider.CreateDecryptor(rgbKey, rgbIV), CryptoStreamMode.Read);
                StreamReader sr = new StreamReader(cs);
                decryptedText = sr.ReadToEnd();

                //(new Logs()).LogException(decryptedText);
            }

            return decryptedText;
        }
    }
}
</code></pre>

<p>PHP Code</p>

<pre><code>$key = '123456789012345678901234';
$iv  = '12345678';
$text = 'this is just test string';

$e = openssl_encrypt($text, 'des-ede3-cbc', $key, 0, $iv);
echo $e . ""&lt;br /&gt;&lt;br /&gt;"";

$d = openssl_decrypt($e, 'des-ede3-cbc', $key, 0, $iv);
echo $d . ""&lt;br /&gt;&lt;br /&gt;"";

// Return
// QDIRAeQ/O1hhjN4XqgcETG7IChnybCqZqN3DpVbYFwk=
// this is just test string
</code></pre>

<p>Got from PHP</p>

<pre><code>QDIRAeQ/O1hhjN4XqgcETG7IChnybCqZqN3DpVbYFwk=
</code></pre>

<p>Got from C#</p>

<pre><code>QDIRAeQ/O1hhjN4XqgcETG7IChnybCqZ
</code></pre>

<p>As you an see it's almost the same for PHP has extra <strong>qN3DpVbYFwk=</strong> characters.</p>

<p>What I am doing wrong? It is something to do with padding?</p>

<p>Thanks</p>
","<p>It looks like the problem is that you have turned padding off (<code>PaddingMode.None</code>) in your C# code and Padding is turned on (by default) in your PHP code.</p>

<p>The OpenSSL library methods <code>openssl_encrypt</code> and <code>openssl_decrypt</code> have padding turned on by default when you pass <code>0</code> as the options parameter. The default padding is <code>PKCS#7</code>.</p>

<p>So to solve your issue you will either need to add <code>PaddingMode.PKCS7</code> to your C# code (which I personally recommend):</p>

<pre><code>cryptoProvider.Padding = PaddingMode.PKCS7;
</code></pre>

<p><strong>Or</strong> you turn off the padding in PHP using <code>OPENSSL_ZERO_PADDING</code>. Remember that in PHP you will need to add the flag <code>OPENSSL_ZERO_PADDING</code> to both <code>openssl_encrypt</code> and <code>openssl_decrypt</code>.</p>

<p>example:</p>

<pre><code>$e = openssl_encrypt($text, 'des-ede3-cbc', $key, OPENSSL_ZERO_PADDING, $iv);
</code></pre>

<p><strong>Important</strong><br>
Remember the padding options must be set on both encrypt and decrypt modes.</p>
","58","<c#><php><.net><3des><tripledes>","1","1","1","2019-08-10 03:20:39","","0","","","","","2019-08-10 01:24:23",""
"23473011","Make TDES working with 16-byte input from existing function worked with 8-byte input","<p>currently I use the DES from this library for Arduino (<a href=""https://github.com/Octoate/ArduinoDES"" rel=""nofollow"">https://github.com/Octoate/ArduinoDES</a>). <br/>
But this library is only working with 8-byte of input. <br/>
So the question is how can I make this library working with my input of 16 bytes? Is there any ways? </p>
","","57","<c++><c><arduino><3des>","0","","0","2014-05-05 12:54:33","","3","","","","","2014-05-05 12:54:33",""
"40369773","C# DESede Symmetric ECB Encryption (I am so close - slightly differing characters)!","<p>My output that I have to match is from Java DESede using a BouncyCastle Jar from 2005 ... I am very close... </p>

<p>Here is my output in Java (which is correct) followed by my output in C# ... if you view in an editor, you will see they ALMOST match, except in C# where it has a forward slash ""/"" in Java it has ""%2F"", ""%2D"" and at the end where C# has is an ""="" , Java has ""%3D"". Any ideas? (I added spaces to show they match up - but you will only see them in an editor.)</p>

<blockquote>
  <p>F3e8sdZ%2F951IRiguIAVqfDLyWptqlbWik5tvFzItcxJCEmupzD9wXp%2BDzIbrf2J2dPpXyEXL2QU%3D      (Java - Correct)</p>
  
  <p>F3e8sdZ/  951IRiguIAVqfDLyWptqlbWik5tvFzItcxJCEmupzD9wXp+  DzIbrf2J2dPpXyEXL2QU=     (C# - Close?)</p>
</blockquote>

<p>Here is my C# Code: </p>

<pre><code>public static string DoubleTrippleDESede(string strToEncode, ref string symKey, ref ICryptoTransform cipher)
    {
        try
        {
            //byte[] input = Encoding.UTF8.GetBytes(""DESede (3DES) Encryption in RAILO CFML"");
            byte[] input = Encoding.UTF8.GetBytes(strToEncode);
            //byte[] key = Convert.FromBase64String(""ru8femXhTm9jwdGdhb/4Sw=="");
            byte[] key = Convert.FromBase64String(symKey);
            TripleDESCryptoServiceProvider algorithm = new TripleDESCryptoServiceProvider();
            algorithm.Mode = CipherMode.ECB;
            algorithm.BlockSize = 64;
            algorithm.KeySize = 192; // 24 byte key
            algorithm.Key = key; //Original
            //algorithm.Key = key.CopyTo(algorithm.Key,)
            cipher = algorithm.CreateEncryptor();
            byte[] encrypted = cipher.TransformFinalBlock(input, 0, input.Length);
            Debug.WriteLine(""encrypted (.NET): {0}"", Convert.ToBase64String(encrypted));
            return Convert.ToBase64String(encrypted);
        }
        catch (Exception ex)
        {
            return ex.Message;
        } 
    }
</code></pre>

<p>Any guidance would be greatly appreciated!!!! I've been at this for 2 weeks and finally can taste victory (I think!?)</p>
","<p>Your Java output appears to have additionally been urlencoded. You should be able to call <a href=""https://msdn.microsoft.com/en-us/library/system.uri.escapedatastring(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>System.Uri.EscapeDataString()</code></a> to match your present output. </p>
","56","<java><c#><bouncycastle><3des>","2","1","1","2016-11-02 01:11:08","40371015","8","","","","","2016-11-01 22:45:05",""
"56153380","How to encrypt and decrypt a file with 3DES (Triple DES) in Java","<p>This is what I have, but I can not decipher the file.
I do not find a logic that allows me to decipher.
I do not know if it is encrypting correctly, because I can not decipher it.</p>

<pre><code> import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.MessageDigest;
 import javax.crypto.Cipher;
 import javax.crypto.SecretKey;
 import javax.crypto.SecretKeyFactory;
 import javax.crypto.spec.DESedeKeySpec;
 import javax.crypto.spec.IvParameterSpec;

 public class TestEncryptor {

     public static void main(String... args) {
         try {
             String KEY_STRING = ""asdasdasd"";
             byte[] key = getEnKey(KEY_STRING);
             String pFilePath = ""D:\\fileTest.png"";
             String pFilePathEncryp = ""D:\\fileTestEncryp.png"";
             byte[] archivoDecrypt = encryptFile(pFilePath, key);

             try (FileOutputStream fos = new FileOutputStream(pFilePathEncryp)) {
                 fos.write(archivoDecrypt);
             }
         } catch (Exception e) {
             e.printStackTrace();
         }

     }

     public static byte[] encryptFile(String pFilePath, byte[] pKey) throws GeneralSecurityException, IOException {
         File file = new File(pFilePath);
         long length = file.length();
         InputStream is = new FileInputStream(file);

         // You cannot create an array using a long type.
         // It needs to be an int type.
         // Before converting to an int type, check
         // to ensure that file is not larger than Integer.MAX_VALUE.
         if (length &gt; Integer.MAX_VALUE) {
             // File is too large
         }

         // Create the byte array to hold the data
         byte[] bytes = new byte[(int) length];

         // Read in the bytes
         int offset = 0;
         int numRead = 0;
         while (offset &lt; bytes.length
                 &amp;&amp; (numRead = is.read(bytes, offset, bytes.length - offset)) &gt;= 0) {
             offset += numRead;
         }

         // Close the input stream and return bytes
         is.close();

         // Ensure all the bytes have been read in
         if (offset &lt; bytes.length) {

             throw new IOException(""Could not completely read file "" + file.getName());
         }

         SecretKeyFactory lDESedeKeyFactory = SecretKeyFactory.getInstance(""DESede"");
         SecretKey kA = lDESedeKeyFactory.generateSecret(new DESedeKeySpec(pKey));

         IvParameterSpec lIVSpec = new IvParameterSpec(new byte[8]);
         Cipher desedeCBCCipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");

         desedeCBCCipher.init(Cipher.ENCRYPT_MODE, kA, lIVSpec);
 //        desedeCBCCipher.init(Cipher.DECRYPT_MODE, kA, lIVSpec);
         byte[] encrypted = desedeCBCCipher.doFinal(bytes);

         return encrypted;
     }

     private static byte[] getEnKey(String spKey) {
         byte[] desKey = null;
         try {
             byte[] desKey1 = md5(spKey);
             desKey = new byte[24];
             int i = 0;
             while (i &lt; desKey1.length &amp;&amp; i &lt; 24) {
                 desKey[i] = desKey1[i];
                 i++;
             }
             if (i &lt; 24) {
                 desKey[i] = 0;
                 i++;
             }
         } catch (Exception e) {
             e.printStackTrace();
         }

         return desKey;
     }

     private static byte[] md5(String strSrc) {
         byte[] returnByte = null;
         try {
             MessageDigest md5 = MessageDigest.getInstance(""MD5"");
             returnByte = md5.digest(strSrc.getBytes(""GBK""));
         } catch (Exception e) {
             e.printStackTrace();
         }
         return returnByte;
     }
 }
</code></pre>
","<p>This is the solution, if someone else needs it.</p>

<pre><code>    try {
        File inputFileNAme = new File(origen);
        FileInputStream fileInputStream = new FileInputStream(inputFileNAme);
        FileOutputStream fileOutputStream = new FileOutputStream(outputFilePath);
        SecretKey secretKey = getKey(keyString);
        Cipher cipher = Cipher.getInstance(algorithm);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        ObjectInputStream objectInputStream = new ObjectInputStream(new CipherInputStream(fileInputStream, cipher));
        System.out.println(objectInputStream.available());
        fileOutputStream.write((byte[]) objectInputStream.readObject());
        fileOutputStream.flush();
        fileOutputStream.close();
        fileInputStream.close();
        objectInputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
</code></pre>
","55","<java><encryption><3des>","0","-1","1","2019-05-15 18:03:01","","4","","770065","","2019-05-15 18:03:01","2019-05-15 15:56:05",""
"57478114","How to set a 24 byte length key to elixir/erlang block_encrypt/4 function using des_ede3 as mode of encryption","<p>Am trying to send data to an external api that expects encrypted data using 3DES encryption but am having issues understanding how to pass my <strong><em>api key</em></strong> as the <em>key</em> field to erlangs <strong><em>des_ede3</em></strong> cipher.</p>

<p>According to erlangs cipher docs <strong><em>des_ede3</em></strong> expects 3 keys that are all 8 bytes in length. How can i pass my 24 byte api key as the key to elixir/erlang :cryptoblock_encrypt/4 function</p>

<pre><code>*** how can i pass key to block_encrypt/4 ***
key = ""123456789012345678901234""
data = ""hello world! The world is yours""
block_size = 8
cipher = :crypto.block_encrypt(:des_ede3, [key, key, key], iv, pad(data, block_size))
</code></pre>

<p>How do i pass my 24 byte api key as the key to erlangs block_encrypt/4 in order for me to pass data to the external api.</p>

<p>Thanks</p>
","<p>Use <a href=""https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#binaries-and-bitstrings"" rel=""nofollow noreferrer"">binary pattern matching</a>:</p>



<pre class=""lang-rb prettyprint-override""><code>&lt;&lt;k1 :: binary-size(8),
  k2 :: binary-size(8),
  k3 :: binary-size(8)&gt;&gt; = ""123456789012345678901234""
#⇒ ""123456789012345678901234""

{k1, k2, k3}
#⇒ {""12345678"", ""90123456"", ""78901234""}
</code></pre>
","55","<erlang><elixir><3des>","0","2","1","2019-08-13 13:05:03","57478340","0","","","","","2019-08-13 12:51:09",""
"40258914","VB Unable to retrieve string after 3DES encryption","<p>Initial conditions:</p>

<pre><code>Private TheKey() As Byte = {1, 2, 3, 4, 5, 6, 7, 8}
Private Vector() As Byte = {&amp;H7C, &amp;H22, &amp;H2F, &amp;HB2, &amp;H92, &amp;H7D, &amp;H82, &amp;H8A}
</code></pre>

<p>I then proceed to encrypt the string: ""asd"" (without quotations) using:</p>

<pre><code>CryptoStream(ms, des.CreateEncryptor(TheKey, Vector), CryptoStreamMode.Write)
</code></pre>

<p><strong>input: asd<br>
output: 82804AD2B295E9E3</strong></p>

<p>When i try to encrypt the same string with the same key/vector on <a href=""http://tripledes.online-domain-tools.com/"" rel=""nofollow"">http://tripledes.online-domain-tools.com/</a> as shown below (can't post image due to reputation):</p>

<p><a href=""https://i.stack.imgur.com/hIB4r.png"" rel=""nofollow"">online 3DES encryption</a></p>

<p>I get a different result.</p>

<p>My ultimate goal is to have this output decrypted in a C application. But two 3DES encryptors giving 2 different results is a show stopper.. Any thoughts about what could be causing this ?</p>

<p>Thanks in advance!</p>
","<p>A good idea to test your crypto against some other ""oracle"". But two issues apparent with your use of the online tool:</p>

<ul>
<li>the key should be given as hex not text (the VB code has a byte array). Presumably 0102030405060708</li>
<li>3DES is the algorithm, but the VB code uses classic DES - there's a separate TripleDESCryptoServiceProvider for 3DES</li>
</ul>

<p>However that site gives me the same encrypted text for both DES and 3DES, so it may not be a reliable oracle anyway? Try another, but may need to use a plain text key (first two I looked at didn't offer hex input in any obvious way)</p>
","54","<c><vb.net><encryption><des><3des>","-1","0","1","2016-10-26 10:40:38","40260085","2","","","","","2016-10-26 09:46:52",""
"45313694","3DES PHP decrypts same result even if a char is added at the end","<p>So i am using this class to encrypt or to decrypt data:</p>

<pre><code>class CryptData
{
    private $hash;
    function __construct($hash) {
        $key = md5($hash, true);
        $key .= substr($key, 0, 8);
        $this-&gt;hash = $key;
    }
    public function Encrypt($data)
    {
        $encData = openssl_encrypt($data, 'DES-EDE3', $this-&gt;hash, OPENSSL_RAW_DATA);
        return base64_encode($encData);
    }
    public function Decrypt($data)
    {
        $data = base64_decode($data);
        return openssl_decrypt($data, 'DES-EDE3', $this-&gt;hash, OPENSSL_RAW_DATA);
    }
}
</code></pre>

<p>and it works fine but for example, if i use:</p>

<pre><code>hash = 12345
text = 1234567891234567
</code></pre>

<p>and encrypt it then it results </p>

<blockquote>
  <p>decData = LQ1zff+UiAAs6GXEgA5x6beMPOubhpcA</p>
</blockquote>

<p>Now if i try to decrypt this data back to plain text, then it gives me correct result but even if i add any char at the end of the decData like</p>

<blockquote>
  <p>decData = LQ1zff+UiAAs6GXEgA5x6beMPOubhpcAa</p>
</blockquote>

<p>Surprisingly it gives correct plain text as well..!!
What i have noticed after few more test, decData with no '=' at the end, if i add a char then it will decrypt to text without error.
for example, if i try</p>

<pre><code>hash = 12345
text = 12345
</code></pre>

<p>then it will result</p>

<blockquote>
  <p>decData = CQm/ZBYSrrs=</p>
</blockquote>

<p>now if i decrypt this adding a char at the end then it will be an error.</p>

<p>so to sum up all, when i try to encrypt a text of length = 16 or more then there's no '=' in decrypted data. I don't have any problem with that but if I try to decrypt the decrypted data adding any char at the end, it gives me correct text back. </p>

<p>Why is this possible and is there any security issue with this problem to my data?</p>
","<p><strong>Base64</strong> is used for encoding binary data into text where each <strong>Base64</strong> character represents 6 bits. Each 3 bytes (24 bits) of input gives 4 <strong>Base64</strong> characters. In the case where the input length is not a multi-plum of 3 the last block of Base64 is padded with one or two '='</p>

<p><strong>Base64</strong> encoded data needs to be in block of 4 <strong>Base64</strong> characters to be valid <strong>Base64</strong>. It seems that php's <code>base64_decoder(..)</code> just ignores your last invalid <strong>Base64</strong> char. You can see this with the following code:</p>

<pre><code>echo strlen(base64_decode(""LQ1zff+UiAAs6GXEgA5x6beMPOubhpcA""));
echo ""\n"";
echo strlen(base64_decode(""LQ1zff+UiAAs6GXEgA5x6beMPOubhpcAa""));
</code></pre>

<p>Giving:</p>

<pre><code>24
24
</code></pre>
","53","<php><encryption><3des>","0","1","1","2017-07-25 22:47:32","45314699","0","","","","","2017-07-25 21:20:53",""
"40180531","C# Encryption of querystring using randomly generated symmetric key","<p>My C# .NET 4.6 Framework Code, ChilKat (64 Bit Nuget package) works and returns an encrypted string, and when I submit it to my ""black box"" it tells me ""Invalid padding string (or incorrect password)"". The box was built in JAVA 11 years ago or so. I have no access to the box. So I guess my real question is, what might have changed over the last decade in the way this type of Encryption is created that I might have to account for when creating code today?</p>

<pre><code>  Crypt2 encryptor = new Crypt2();
  encryptor.CryptAlgorithm = ""3des"";
  encryptor.KeyLength = 192;
  encryptor.CipherMode = ""ecb"";
  encryptor.RandomizeKey();
  passKey = encryptor.GetEncodedKey(""base64"");
  return  encryptor.EncryptStringENC(data2Encrypt);
</code></pre>
","","52","<c#><encryption><bouncycastle><3des><chilkat>","0","","0","2016-10-21 16:20:54","","7","","2440976","","2016-10-21 16:20:54","2016-10-21 15:34:38",""
"53057353","I am writing 3DES (using SHA1 HASH) encryption algorithm using C #. Key size error","<p>I am writing 3DES (using SHA1 HASH) encryption algorithm using C #. 
Size error in tdes.Key = keyArray of the following code. I do not know what went wrong.</p>

<p>public static string Encrypt(string toEncrypt, bool useHashing)</p>

<p>{</p>

<pre><code> byte[] keyArray;
 byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

 System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();


 // Get the key from config file

 string key = (string)settingsReader.GetValue(""SecurityKey"", typeof(String));

 //System.Windows.Forms.MessageBox.Show(key);
 if (useHashing)
  {

   SHA1CryptoServiceProvider objSHA1CryptoService = new SHA1CryptoServiceProvider();
   keyArray = objSHA1CryptoService.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
   objSHA1CryptoService.Clear();

  }
  else
        keyArray = UTF8Encoding.UTF8.GetBytes(key);

        TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
        tdes.Key = keyArray;
        tdes.Mode = CipherMode.ECB;
        tdes.Padding = PaddingMode.PKCS7;

        ICryptoTransform cTransform = tdes.CreateEncryptor();
        byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
        tdes.Clear();
        return Convert.ToBase64String(resultArray, 0, resultArray.Length);
    }
</code></pre>

<p>}</p>
","","50","<sha1><3des>","0","","0","2018-10-30 04:18:34","","2","","","","","2018-10-30 04:18:34",""
"52584910","Different result of after converting 3DES program from C# to Java","<p>I have a c# program as follow:</p>

<pre><code>public static string Encrypt(string sClear, string sKey)
        {
            sClear = ""4140700104596085"";
            sKey = ""222222222222222222222222222222222222222222222222"";

            TripleDESCryptoServiceProvider cryptoProvider = new TripleDESCryptoServiceProvider();
            cryptoProvider.Mode = CipherMode.ECB;

            byte[] bData = new byte[16];
            byte[] bKey = new byte[24];

            // Convert from hex to decimal
            FromHexToDecimal(sClear).CopyTo(bData, 0);
            FromHexToDecimal(sKey).CopyTo(bKey, 0);

            ICryptoTransform cTransform = DESCryptoExtensions.CreateWeakEncryptor(cryptoProvider, bKey, cryptoProvider.IV);
            byte[] result = cTransform.TransformFinalBlock(bData, 0, bData.Length);

            return BitConverter.ToString(result).Replace(""-"", """").Substring(0, 16);
        }
</code></pre>

<p>My clear text is ""4140700104596085"", and my key is ""222222222222222222222222222222222222222222222222"", and this program will return me ""0C90320B7B9EC798"" as result.</p>

<p>Now I am trying to do it in java code, and here is my code:</p>

<pre><code>public static String encryptToString(String message) throws Exception {
      message = ""4140700104596085"";
      final MessageDigest md = MessageDigest.getInstance(""md5"");
      final byte[] digestOfPassword = md.digest(""222222222222222222222222222222222222222222222222""
              .getBytes(""utf-8""));
      final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
      for (int j = 0, k = 16; j &lt; 8;) {
          keyBytes[k++] = keyBytes[j++];
      }

      final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
      final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
      final Cipher cipher = Cipher.getInstance(""DESede/ECB/NoPadding"");
      cipher.init(Cipher.ENCRYPT_MODE, key);
      // cipher.init(Cipher.ENCRYPT_MODE, key, iv);

      final byte[] plainTextBytes = message.getBytes(""utf-8"");
      final byte[] cipherText = cipher.doFinal(plainTextBytes);

      return Hex.encodeHexString(cipherText).substring(0, 16);
  }
</code></pre>

<p>As u can see, I comment the <code>cipher.init(Cipher.ENCRYPT_MODE, key, iv);</code>, because I will hit <code>java.security.InvalidAlgorithmParameterException: ECB mode cannot use IV</code> error. </p>

<p>Even I comment it, the result I get is still different, it is <code>f8f8739fb41259d6</code>. I believe something wrong in my code in Java, any ideas?</p>

<p>I tried google on it, but its not that straight forward to translate.</p>
","<p>I found the solution.</p>

<p>I should follow the code in C#.</p>

<p>Thus, I remove </p>

<pre><code>final MessageDigest md = MessageDigest.getInstance(""md5"");
      final byte[] digestOfPassword = md.digest(""222222222222222222222222222222222222222222222222""
              .getBytes(""utf-8""));
      final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
      for (int j = 0, k = 16; j &lt; 8;) {
          keyBytes[k++] = keyBytes[j++];
      }
</code></pre>

<p>And replace with </p>

<pre><code>final byte[] keyBytes = fromHexToDecimal(""222222222222222222222222222222222222222222222222"");
</code></pre>

<p>And the <code>fromHexToDecimal</code> method will be as follow:</p>

<pre><code>public static byte[] fromHexToDecimal(String hex) {

      int len = hex.length() / 2;
      byte[] result = new byte[len];

      for (int i = 0, j = 0; i &lt; len; i++, j = j + 2) {
        StringBuilder c = new StringBuilder();
        c = c.append(hex.charAt(j)).append(hex.charAt(j+1));
        short s = (short) Integer.parseInt(c.toString(), 16);
        result[i] = (byte)(s &amp; 0xff);
      }


      return result;
    }
</code></pre>
","41","<java><c#><encryption><translate><3des>","1","1","1","2018-10-01 08:44:30","","7","","","","","2018-10-01 05:15:24",""
"56145623","3DES , Java code result produces different result from 3des online tool and oracle database script","<p>when applying 3des encryption using java , java code generate wrong result compared to 3des online tool and oracle DB script</p>

<p>3des encryption , Java</p>

<pre><code>  SET SERVEROUTPUT ON;

    declare
    l_mod_ofb pls_integer;  
     l_mod_ecb pls_integer;
      v_key raw(32);   
      v_iv  raw(16);
      v_test_in raw(16);   v_ciphertext raw(16);

    begin
      l_mod_ecb := dbms_crypto.ENCRYPT_3DES_2KEY + dbms_crypto.CHAIN_CBC  + DBMS_CRYPTO.PAD_NONE ;
      v_key      :=   hextoraw  ('1FB3F48A6D51832CE91C1C734554086D');
      v_iv       :=   hextoraw  ('041234FFFFFFFFFF');                
      v_test_in  :=   hextoraw  ('0000211111111110');                

      v_ciphertext := dbms_crypto.encrypt(src =&gt; v_test_in,
                                          TYP =&gt; l_mod_ecb,
                                          key =&gt; v_key,
                                          iv =&gt; v_iv);

      dbms_output.put_line(' Ciphertext  : '||rawtohex(v_ciphertext));

    end;
</code></pre>

<p>-------------------Java Code</p>

<pre><code>import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESedeKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

public class TripleDes {

private static String SHARED_KEY = ""1FB3F48A6D51832CE91C1C734554086D"";
private static String ivString = ""041234FFFFFFFFFF"";
private static String valueStr = ""0000211111111110"";
static final String HEXES = ""041217DB6AEFF7CF"";

public static void main(String[] args) throws DecoderException, Exception {

    TripleDes tr = new TripleDes();
    byte[] plain = Hex.decodeHex(valueStr.toCharArray());
    byte[] codedtext = tr.encrypt(plain);
    System.out.println(""Encrypted Result = "" + getHex(codedtext));
}



public byte[] encrypt(byte[] plainTextBytes) throws Exception {
    TripleDes tr = new TripleDes();
    byte[] keyValue = getKey(Hex.decodeHex(SHARED_KEY.toCharArray()));
    System.out.println(Hex.encodeHex(keyValue));
    IvParameterSpec iv = new IvParameterSpec(Hex.decodeHex(ivString.toCharArray()));
    //DESede
    final SecretKey key = new SecretKeySpec(keyValue, ""DESede"");
    final Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    final byte[] cipherText = cipher.doFinal(plainTextBytes);
    return cipherText;
}

public static byte[] getKey(byte[] keyBytes) {
    byte[] key;
    if (keyBytes.length == 16) {
        key = new byte[24];
        System.arraycopy(keyBytes, 0, key, 0, 16);
        System.arraycopy(keyBytes, 0, key, 16, 8);
    } else {
        key = keyBytes;
    }

    return key;
}

public static String getHex(byte[] raw) {
    if (raw == null) {
        return null;
    }
    final StringBuilder hex = new StringBuilder(2 * raw.length);
    for (final byte b : raw) {
        hex.append(HEXES.charAt((b &amp; 0xF0) &gt;&gt; 4))
                .append(HEXES.charAt((b &amp; 0x0F)));
    }
    return hex.toString();
}
}
</code></pre>

<p>--------------- online tool
use the following paramters</p>

<pre><code>Input type: Text
Input text:(hex)0000211111111110
Function: 3DES  
Mode: CBS   
Key: (hex)1FB3F48A6D51832CE91C1C734554086D1FB3F48A6D51832C
Init. vector:   041234FFFFFFFFFF
</code></pre>

<ul>
<li>Expected result is 63CA0F38548CC8B5</li>
<li>The result from online tool and oracle script is equal to expected result</li>
<li>Java code result : D2FE0F26716FF6F7</li>
</ul>
","<ul>
<li><p>HEXES variable doesn't have right value so replace it with  0123456789ABCDEF </p></li>
<li><p>byte[] plain = Hex.decodeHex(valueStr.toCharArray()); wrong assignment
replace with DatatypeConverter.parseHexBinary(valueStr);</p></li>
</ul>
","39","<java><oracle><3des>","0","0","1","2019-05-15 10:49:40","","0","0","10989688","","2019-05-15 09:28:20","2019-05-15 09:13:32",""
"56475087","3DES encryption from c# to php","<p>I need php 3DES encryption to generate timestamp to connect to a web service</p>

<p>I want to generate timestamp in php, I have the C# sample code. But my php code generates differently from the source code.</p>

<p>Here is my php code </p>

<pre><code>class trytry{


    public function encrypt2($data, $secret)
    {
        //Generate a key from a hash
        $key = md5(utf8_encode($secret), true);

        //Take first 8 bytes of $key and append them to the end of $key.
        $key .= substr($key, 0, 8);

        //Pad for PKCS7
        $blockSize = mcrypt_get_block_size('tripledes', 'ecb');
        $len = strlen($data);
        $pad = $blockSize - ($len % $blockSize);
        $data .= str_repeat(chr($pad), $pad);

        //Encrypt data
        $encData = mcrypt_encrypt('tripledes', $key, $data, 'ecb');

        return base64_encode($encData);
    }

    public function decrypt2($data, $secret)
    {
        //Generate a key from a hash
        $key = md5(utf8_encode($secret), true);

        //Take first 8 bytes of $key and append them to the end of $key.
        $key .= substr($key, 0, 8);

        $data = base64_decode($data);

        $data = mcrypt_decrypt('tripledes', $key, $data, 'ecb');

        $block = mcrypt_get_block_size('tripledes', 'ecb');
        $len = strlen($data);
        $pad = ord($data[$len-1]);

        return substr($data, 0, strlen($data) - $pad);
    }

    public function return_timestap(){

        date_default_timezone_set('GMT');
        return $date = date('D, d M Y H:i:s')."" GMT"" ;

        //."" GMT"" 
       // this is code to generate 
    }

}
</code></pre>

<p>C# sample code </p>

<pre><code>using System;
using System.Security.Cryptography;
using System.IO;
using System.Text;

namespace MemberSite.OddsDisplay.Helpers
{
    public class DES3
    {
        private byte[] bKey;
        private byte[] bIV;
        private SymmetricAlgorithm mCSP = new AesCryptoServiceProvider();

        public DES3(byte[] key)
        {
            bKey = key;
        }
        public DES3(byte[] key, byte[] iv)
        {
            bKey = key;
            bIV = iv;
        }
    }

    public string EncryptString(string Value)
        {
            ICryptoTransform ct;
            MemoryStream ms;
            CryptoStream cs;
            byte[] byt;
            mCSP.Key = bKey;
            mCSP.IV = bIV;
            mCSP.Mode = System.Security.Cryptography.CipherMode.ECB;
            mCSP.Padding = System.Security.Cryptography.PaddingMode.PKCS7;
            ct = mCSP.CreateEncryptor(mCSP.Key, mCSP.IV);
            byt = Encoding.UTF8.GetBytes(Value);
            ms = new MemoryStream();
            cs = new CryptoStream(ms, ct, CryptoStreamMode.Write);
            cs.Write(byt, 0, byt.Length);
            cs.FlushFinalBlock();
            cs.Close();
            return Convert.ToBase64String(ms.ToArray());
        }

    public string DecryptString(string Value)
        {
            ICryptoTransform ct;
            MemoryStream ms;
            CryptoStream cs;
            byte[] byt;
            mCSP.Key = bKey;
            mCSP.IV = bIV;
            mCSP.Mode = System.Security.Cryptography.CipherMode.ECB;
            mCSP.Padding = System.Security.Cryptography.PaddingMode.PKCS7;
            ct = mCSP.CreateDecryptor(mCSP.Key, mCSP.IV);
            byt = Convert.FromBase64String(Value);
            ms = new MemoryStream();
            cs = new CryptoStream(ms, ct, CryptoStreamMode.Write);
            cs.Write(byt, 0, byt.Length);
            cs.FlushFinalBlock();
            cs.Close();
            return Encoding.UTF8.GetString(ms.ToArray());
        }

    public class Hash
    {
        public static string StringMD5(string data)
        {
            return (
                System.BitConverter.ToString(
                    System.Security.Cryptography.MD5.Create().ComputeHash(
                        System.Text.Encoding.UTF8.GetBytes(data)
                    )
                )
            );
        }
        public static byte[] BytesMD5(string data)
        {
            return (
                System.Security.Cryptography.MD5.Create().ComputeHash(
                    System.Text.Encoding.UTF8.GetBytes(data)
                )
            );
        }
    }
}



public string GetTimeStamp(string accessKey, string ivKey)
    {
        string timeStamp = string.Empty;

        byte[] key = Hash.BytesMD5(accessKey);
        byte[] ivbyte = Hash.BytesMD5(ivKey);
        DES3 des3 = new DES3(key, ivbyte);
        timeStamp = des3.EncryptString(getTimestampString(DateTime.Now));

        return timeStamp;
    }
</code></pre>

<p>Timestamp data: Thu, 06 Jun 2019 09:38:03 GMT</p>

<p>Result PHP</p>

<blockquote>
  <p>QMaMk7ipbL73QLy6tbGBBG6vWJPBqsTEUt2mIpjKhjc= </p>
</blockquote>

<p>Result C#</p>

<blockquote>
  <p>CKdZRaEoT0UgH9KVbc5Oyc1WXspLu/uoIGqCxxnavXc=</p>
</blockquote>

<p>Can anyone explain and point out why my code is not working ? </p>

<p>Any help will be highly appreciated</p>

<p>Thanks in advance</p>
","<p>Firstly, your PHP uses tripledes but C# uses AES</p>

<p>Secondly, key in your C# code and PHP are not equal</p>

<p>In php you have</p>

<pre><code>    //Generate a key from a hash
    $key = md5(utf8_encode($secret), true);

    //Take first 8 bytes of $key and append them to the end of $key.
    $key .= substr($key, 0, 8);
</code></pre>

<p>You append 8 bytes to key to make it becomes 24 bytes key length</p>

<p>But in C#</p>

<pre><code>    byte[] key = Hash.BytesMD5(accessKey);
</code></pre>

<p>This is 16 bytes key length. </p>

<p>Because your requirement is have PHP encrypt and decrypt the same like C#, so I focus to change your php code only</p>

<pre><code>    public function encrypt2($data, $secret)
    {
        //Generate a key from a hash
        $key = md5(utf8_encode($secret), true);

        // Remove this
        //Take first 8 bytes of $key and append them to the end of $key.
        //$key .= substr($key, 0, 8);

        //Pad for PKCS7
        $blockSize = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
        $len = strlen($data);
        $pad = $blockSize - ($len % $blockSize);
        $data .= str_repeat(chr($pad), $pad);

        //Encrypt data MCRYPT_RIJNDAEL_128, ECB equal to C# AES
        $encData = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB);

        return base64_encode($encData);
    }

    function decrypt2($data, $secret)
    {
        //Generate a key from a hash
        $key = md5(utf8_encode($secret), true);

        // Remove this
        //Take first 8 bytes of $key and append them to the end of $key.
        //$key .= substr($key, 0, 8);

        $data = base64_decode($data);

        $data = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB);

        $block = mcrypt_get_block_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_ECB);
        $len = strlen($data);
        $pad = ord($data[$len-1]);

        return substr($data, 0, strlen($data) - $pad);
    }
</code></pre>
","37","<c#><php><3des>","1","1","1","2019-06-06 11:29:53","56476663","1","","5989431","","2019-06-06 10:11:09","2019-06-06 09:52:52",""
"56644621","Cant't triple des encrypt strings that less than 1376 character","<p>I have a problem about 3DES algorithm when i have work on php ( phpseclib ).
If my string length shortest 1376 or 1300 Triple DES on the phpseclib , Triple DES don't work and can't encrypt my string !!!</p>

<p>How many must length my string that this algorithm working?</p>

<p>Use phpseclib package for encryption.</p>

<p>code : </p>

<pre><code>$key = '';
$cipher = new \phpseclib\Crypt\TripleDES(\phpseclib\Crypt\DES::MODE_CBC);

//my key is hex format
$cipher-&gt;setKey(hex2bin($key));
$cipher-&gt;setIV(hex2bin('0000000000000000'));

//my data is hex format

$plaintext = hex2bin($data);

echo $cipher-&gt;encrypt($plaintext);
</code></pre>

<p>tank you.</p>
","<p>I can solve this problem.</p>

<p>in the php you must paded string to 16 character !!!</p>

<p>such as :</p>

<pre><code>str_pad($input, 16, ""your padded char"", STR_PAD_LEFT); // or STR_PAD_RIGHT for padded from right
</code></pre>
","37","<php><phpseclib><3des><tripledes>","0","-1","1","2019-06-20 06:49:09","","3","","5819495","","2019-06-18 08:59:20","2019-06-18 08:14:39",""
"29341563","3Des decryption using different key (from encryption state), can decrypt successfully","<p>I've tried TripleDESCryptoServiceProvider(). 
And I've change Encrypt/Decrypt key a bit, wonder why different key can decrypt encrypted text successfully.</p>

<p>(Also I've tried With or Without specified different IV, same result)</p>

<p>The difference in the keys is at <code>TestKey1(5) = 4, TestKey2(5) = 5</code></p>

<pre><code>Imports System.Net
Imports System.IO
Imports System.Security.Cryptography

Public Class WebForm1
    Inherits System.Web.UI.Page

    Protected Sub Page_Load(ByVal sender As Object, ByVal e As System.EventArgs) Handles Me.Load
        Dim tDESalg As New TripleDESCryptoServiceProvider()

        Dim Testkey1 As Byte() = UTF8Encoding.UTF8.GetBytes(""Z4xC#49S3$3!A470&amp;i0O51@5"")

        ' Create a string to encrypt.
        Dim sData As String = ""Here is some data to encrypt.""

        ' Encrypt the string to an in-memory buffer.
        Dim Data As Byte() = TrippleDESCSPSample.EncryptTextToMemory(sData, Testkey1, tDESalg.IV)

        Dim Testkey2 As Byte() = UTF8Encoding.UTF8.GetBytes(""Z4xC#59S3$3!A470&amp;i0O51@5"")
        Debug.Print(Testkey1.Equals(Testkey2))

        ' Decrypt the buffer back to a string.
        Dim Final As String = TrippleDESCSPSample.DecryptTextFromMemory(Data, Testkey2, tDESalg.IV)

        ' Display the decrypted string to the console.
        Response.Write(Final)
    End Sub



End Class


Class TrippleDESCSPSample


    Public Shared Function EncryptTextToMemory(Data As String, Key As Byte(), IV As Byte()) As Byte()
        Try
            ' Create a MemoryStream.
            Dim mStream As New MemoryStream()

            ' Create a CryptoStream using the MemoryStream 
            ' and the passed key and initialization vector (IV).
            Dim cStream As New CryptoStream(mStream, New TripleDESCryptoServiceProvider().CreateEncryptor(Key, IV), CryptoStreamMode.Write)

            ' Convert the passed string to a byte array.
            Dim toEncrypt As Byte() = New ASCIIEncoding().GetBytes(Data)

            ' Write the byte array to the crypto stream and flush it.
            cStream.Write(toEncrypt, 0, toEncrypt.Length)
            cStream.FlushFinalBlock()

            ' Get an array of bytes from the 
            ' MemoryStream that holds the 
            ' encrypted data.
            Dim ret As Byte() = mStream.ToArray()

            ' Close the streams.
            cStream.Close()
            mStream.Close()

            ' Return the encrypted buffer.
            Return ret
        Catch e As CryptographicException
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message)
            Return Nothing
        End Try

    End Function

    Public Shared Function DecryptTextFromMemory(Data As Byte(), Key As Byte(), IV As Byte()) As String
        Try
            ' Create a new MemoryStream using the passed 
            ' array of encrypted data.
            Dim msDecrypt As New MemoryStream(Data)

            ' Create a CryptoStream using the MemoryStream 
            ' and the passed key and initialization vector (IV).
            Dim csDecrypt As New CryptoStream(msDecrypt, New TripleDESCryptoServiceProvider().CreateDecryptor(Key, IV), CryptoStreamMode.Read)

            ' Create buffer to hold the decrypted data.
            Dim fromEncrypt As Byte() = New Byte(Data.Length - 1) {}

            ' Read the decrypted data out of the crypto stream
            ' and place it into the temporary buffer.
            csDecrypt.Read(fromEncrypt, 0, fromEncrypt.Length)

            'Convert the buffer into a string and return it.
            Return New ASCIIEncoding().GetString(fromEncrypt)
        Catch e As CryptographicException
            Console.WriteLine(""A Cryptographic error occurred: {0}"", e.Message)
            Return Nothing
        End Try
    End Function

End Class
</code></pre>
","","34","<c#><.net><vb.net><encryption-symmetric><3des>","2","","0","2015-03-30 08:32:14","","3","","22656","","2015-03-30 08:32:14","2015-03-30 08:31:04","2015-03-30 08:46:34"
"58547972","Can I use a 3DES key within google KMS HSM?","<p>I have been looking across the different HSM provides alike Azure, AWS, IBM and Google but I haven't find any documentation about google HSM explicitely supporting 3DES keys. </p>

<p>However I can see the type </p>

<pre><code>""CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED""
</code></pre>

<p>in <a href=""https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm"" rel=""nofollow noreferrer"">https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm</a></p>

<p>This type is used to create a key in the KMS.</p>

<p>Does Google KMS HSM support 3DES?</p>
","<p>It does not support 3DES as a key type you can create and use at this time. We'd be interested to know more about why you would want 3DES.</p>
","33","<3des><hsm><tripledes><google-cloud-kms>","0","0","2","2019-10-29 21:26:35","58548712","0","","","","","2019-10-24 19:25:43",""
"58547972","Can I use a 3DES key within google KMS HSM?","<p>I have been looking across the different HSM provides alike Azure, AWS, IBM and Google but I haven't find any documentation about google HSM explicitely supporting 3DES keys. </p>

<p>However I can see the type </p>

<pre><code>""CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED""
</code></pre>

<p>in <a href=""https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm"" rel=""nofollow noreferrer"">https://cloud.google.com/kms/docs/reference/rest/v1/CryptoKeyVersionAlgorithm</a></p>

<p>This type is used to create a key in the KMS.</p>

<p>Does Google KMS HSM support 3DES?</p>
","<p>I recommend that you upvote the existing feature request for 3DES here: <a href=""https://issuetracker.google.com/issues/123697325"" rel=""nofollow noreferrer"">https://issuetracker.google.com/issues/123697325</a> (simply click the star).  </p>

<p>Next, could you explain whether 3DES would be sufficient to satisfy your use case?  I would expect that there may be other requirements beyond 3DES such as DUKPT that you may require for your use case.</p>
","33","<3des><hsm><tripledes><google-cloud-kms>","0","1","2","2019-10-29 21:26:35","58548712","0","","","","","2019-10-24 19:25:43",""
"55528499","encrypt/decrypt DE3 timestamp using PHP","<p>I would like to ask how to encrypt/decrypt using php with DES3 method ,  encrypt timestamp + a secret key.</p>

<p>example ： </p>

<pre><code> GMT_Time=""Sat, 28 Nov 2009 07:53:22 GMT""
 accessKey=""aasdfasdfasdf""
 timeStamp=""Jx9Ozt/Z2oDazSm+K28lUIBEsRrWSwwlliZsuYTy+uE=""
</code></pre>

<p>Any help or advice will be highly appreciated.
This function mcrypt is deprecated, I am not sure what function should I use instead.
Thanks in advance</p>
","","32","<php><encryption><3des>","0","","0","2019-04-05 06:22:20","","1","","11147851","","2019-04-05 06:22:20","2019-04-05 04:59:58",""
"50416673","Ho to decrypt file with additional information?","<p>I need to add a xml header to my encrypted file so it looks as it:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8"" standalone=""yes""?&gt;
 &lt;EncryptedFileHeader&gt;
  &lt;Algorithm&gt;3DES&lt;/Algorithm&gt;
  &lt;KeySize&gt;192&lt;/KeySize&gt;
  &lt;BlockSize&gt;64&lt;/BlockSize&gt;
  &lt;CipherMode&gt;ECB&lt;/CipherMode&gt;
  &lt;IV&gt;some IV&lt;/IV&gt;
  &lt;ApprovedUsers&gt;
    &lt;User&gt;
      &lt;Email&gt;mark&lt;/Email&gt;
      &lt;SessionKey&gt;sss&lt;/SessionKey&gt;
    &lt;/User&gt;
  &lt;/ApprovedUsers&gt;
&lt;/EncryptedFileHeader&gt;encrypted data...
more encrypted data....
</code></pre>

<p>To do this im using this code i found on MSDN:</p>

<pre><code>public void EncryptData(String inName, String outName, byte[] tdesKey, byte[] tdesIV)
        {
            //Create the file streams to handle the input and output files.
            FileStream fin = new FileStream(inName, FileMode.Open, FileAccess.Read);
            FileStream fout = new FileStream(outName, FileMode.OpenOrCreate, FileAccess.Write);
            fout.SetLength(0);

            setHeader(fout , tdesIV);

            //Create variables to help with read and write.
            byte[] bin = new byte[100]; //This is intermediate storage for the encryption.
            long rdlen = 0;              //This is the total number of bytes written.
            long totlen = fin.Length;    //This is the total length of the input file.
            int len;                     //This is the number of bytes to be written at a time.

            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

            tdes.Padding = PaddingMode.ANSIX923;
            CryptoStream encStream = new CryptoStream(fout, tdes.CreateEncryptor(tdesKey, tdesIV), CryptoStreamMode.Write);

            //Read from the input file, then encrypt and write to the output file.
            while (rdlen &lt; totlen)
            {
                len = fin.Read(bin, 0, 100);
                encStream.Write(bin, 0, len);
                rdlen = rdlen + len;
            }

            encStream.Close();
        }
</code></pre>

<p>Adding a xml heading:</p>

<pre><code>private void setHeader(FileStream output, byte[] sal)
        {
            XmlDocument doc = new XmlDocument();
            XmlNode docNode = doc.CreateXmlDeclaration(""1.0"", ""UTF-8"", ""yes"");
            doc.AppendChild(docNode);

            XmlNode header = doc.CreateElement(""EncryptedFileHeader"");
            doc.AppendChild(header);

            XmlNode algorithm = doc.CreateElement(""Algorithm"");
            algorithm.InnerText = ""3DES "" + mw.cmb_algorithm.Text;
            header.AppendChild(algorithm);
            XmlNode keySize = doc.CreateElement(""KeySize"");
            keySize.InnerText = 192.ToString();
            header.AppendChild(keySize);
            XmlNode blockSize = doc.CreateElement(""BlockSize"");
            blockSize.InnerText = 64.ToString();
            header.AppendChild(blockSize);
            XmlNode cipherMode = doc.CreateElement(""CipherMode"");
            cipherMode.InnerText = mw.cmb_encryption_mode.Text;
            header.AppendChild(cipherMode);
            XmlNode salt = doc.CreateElement(""IV"");
            salt.InnerText = System.Text.Encoding.UTF8.GetString(sal);
            header.AppendChild(salt);
            XmlNode approvedUsers = doc.CreateElement(""ApprovedUsers"");
            header.AppendChild(approvedUsers);

            XmlNode user1 = doc.CreateElement(""User"");
            approvedUsers.AppendChild(user1);

            XmlNode mail = doc.CreateElement(""Email"");
            mail.InnerText = ""mark"";
            user1.AppendChild(mail);
            XmlNode sessionKey = doc.CreateElement(""SessionKey"");
            sessionKey.InnerText = ""sss"";
            user1.AppendChild(sessionKey);

            doc.Save(output);            
        }
</code></pre>

<p>It does what i need, but when it comes to decoding, i have a problem. 
For some reason the input FileStream (encoded file) got lenght increased by 3, and because of that i got System.Security.Cryptography.CryptographicException ""length of the data to decrypt is invalid"" while closing Cryptostream.</p>

<p>Decryption code:</p>

<pre><code>public void DecryptData(String inName, String outName, byte[] tdesKey, byte[] tdesIV)
        {
            //Create the file streams to handle the input and output files.
            FileStream fin = new FileStream(inName, FileMode.Open, FileAccess.Read);
            FileStream fout = new FileStream(outName, FileMode.OpenOrCreate, FileAccess.Write);
            fout.SetLength(0);

            int position;
            Header header = new Header();
            readHeader(inName,out position, header);
            fin.Position = position;
            //Create variables to help with read and write.
            byte[] bin = new byte[100]; //This is intermediate storage for the encryption.
            long rdlen = 0;              //This is the total number of bytes written.
            long totlen = fin.Length - position;    //This is the total length of the input file.
            int len;                     //This is the number of bytes to be written at a time.

            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();


            tdes.Padding = PaddingMode.ANSIX923;
            CryptoStream encStream = new CryptoStream(fout, tdes.CreateDecryptor(tdesKey, tdesIV), CryptoStreamMode.Write);


            //Read from the input file, then encrypt and write to the output file.
            while (rdlen &lt; totlen)
            {
                len = fin.Read(bin, 0, 100);
                encStream.Write(bin, 0, len);
                rdlen = rdlen + len;            
            }
            encStream.Close(); //&lt;- exception
        }
</code></pre>

<p>I need to have this xml header and encrypted data in one file, and need to decryppt the data. Dont look at data put into xml, its just some blank info i need to test if encryption works. 
When I dont add the heading encryption and decryption works fine. 
Any idea how to get that work?</p>
","","32","<c#><encryption><3des>","0","","0","2018-05-18 17:39:36","","3","","","","","2018-05-18 17:39:36",""
"55977439","arduino code problem with 3des encypt decrypt","<p>Hello i have problem with my code in 3des enc/dec it work only with 8 byte for me</p>

<p>i got result only this</p>

<p>the problem is result give only for 8 byte first not for all 48 byte</p>

<p>B1 09 DA E1 B7 1B 63 8E 17 02 07 83 1A 0D 1A DF 36 1F E4 6D 41 28 35 25 02 00 00 14 00 00 43 77 3B 38 98 37 15 20 F7 0C 18 56 03 00 00 14 00 00</p>

<p>below i attach my example code </p>

<pre><code>#include &lt;DES.h&gt;

DES des;

void setup() {
  Serial.begin(9600);
  Serial.println(""Hello!"");
}

void loop() {
  tdesTest();
  delay(2000);
}

void tdesTest()
{
  byte out[48];
  byte in[48] = { 0xda, 0x9f, 0xab, 0xbe, 0x85, 0x26, 0x6f, 0x53, 0x9c, 0x8c, 0xbb, 0x03, 0x7f, 0x54, 0x61, 0x27, 0x3d, 0xfa, 0xb9, 0xf5, 0xfe, 0xb0, 0x9a, 0x3b, 0x3b, 0xc6, 0xf8, 0xb5, 0xe0, 0x84, 0x4d, 0xe1, 0x58, 0xe7, 0x88, 0x83, 0xae, 0x0d, 0xae, 0xdf, 0x36, 0x0d, 0xd0, 0x68, 0x45, 0x2b, 0x37, 0x24 };

  byte key[] = { 
                  0x15, 0x2b, 0xd8, 0x96, 0x57, 0xe0, 0x3f, 0xdc, 
                  0x73, 0x75, 0xa0, 0x0e, 0x1f, 0xb1, 0xa3, 0x8b, 
                  0xab, 0x09, 0x7c, 0x10, 0x3b, 0x80, 0x38, 0x46,
                };

  Serial.println();
  Serial.println(""====== Triple-DES test ======"");

  //encrypt
  Serial.print(""Encrypt..."");
  unsigned long time = micros();
  des.tripleEncrypt(out, in, key);
  time = micros() - time;
  Serial.print(""done. ("");
  Serial.print(time);
  Serial.println("" micros)"");
  printArray(out);

  //decrypt
  for (int i = 0; i &lt; 48; i++)
  {
    in[i] = out[i];
  }
  Serial.print(""Decrypt..."");
  time = micros();
  des.tripleDecrypt(out, in, key);
  time = micros() - time;
  Serial.print(""done. ("");
  Serial.print(time);
  Serial.println("" micros)"");
  printArray(out);
}

void printArray(byte output[])
{
  for (int i = 0; i &lt; 48; i++)
  {

   if (output[i] &lt; 0x10)
    {
      Serial.print(""0"");
    }

    Serial.print(output[i], HEX);
    Serial.print("" "");
  }
  Serial.println();
}
</code></pre>
","","30","<encryption><arduino-uno><arduino-ide><3des>","0","","0","2019-05-03 22:00:36","","7","","3982922","","2019-05-03 22:00:36","2019-05-03 21:42:51",""
"56138129","3DES Encryption - java.security.InvalidKeyException: Invalid key length: 16 bytes","<p>I use 3DES algorithm to encrypt String using both java code and oracle database ,The result from oracle database is correct and need java code generate the same oracle database result but java code throw exception(java.security.InvalidKeyException: Invalid key length: 16 bytes)</p>

<pre><code>--------------------- Oracle script-----------------------
SET SERVEROUTPUT ON;

declare
l_mod_ofb pls_integer;  
 l_mod_ecb pls_integer;
  v_key raw(32);   
  v_iv  raw(16);
  v_test_in raw(16);   v_ciphertext raw(16);

begin
  l_mod_ecb := dbms_crypto.ENCRYPT_3DES_2KEY + dbms_crypto.CHAIN_CBC  + DBMS_CRYPTO.PAD_NONE ;
  v_key      :=   hextoraw  ('1FB3F48A6D51832CE91C1C734554086D');
  v_iv       :=   hextoraw  ('041234FFFFFFFFFF');                
  v_test_in  :=   hextoraw  ('0000211111111110');                

  v_ciphertext := dbms_crypto.encrypt(src =&gt; v_test_in,
                                      TYP =&gt; l_mod_ecb,
                                      key =&gt; v_key,
                                      iv =&gt; v_iv);

  dbms_output.put_line(' Ciphertext  : '||rawtohex(v_ciphertext));

end;
</code></pre>

<hr>

<p>script output result : 63CA0F38548CC8B5</p>

<p>the following Java , 3DES Encryption algorithm code :</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

public class TripleDes {

    private static String SHARED_KEY = ""1FB3F48A6D51832CE91C1C734554086D"";
    private static String ivString = ""041234FFFFFFFFFF"";
    private static String valueStr = ""0000211111111110"";
    static final String HEXES = ""041217DB6AEFF7CF"";

    public static void main(String[] args) throws DecoderException, Exception {

        TripleDes tr = new TripleDes();
        byte[] plain = Hex.decodeHex(valueStr.toCharArray());
        byte[] codedtext = tr.encrypt(plain);
        System.out.println(""Encrypted Result = "" + getHex(codedtext));

    }

    public byte[] encrypt(byte[] plainTextBytes) throws Exception {

        byte[] keyValue = Hex.decodeHex(SHARED_KEY.toCharArray());

        IvParameterSpec iv = new IvParameterSpec(ivString.getBytes());
        //DESede
        final SecretKey key = new SecretKeySpec(keyValue, ""DESede"");
        final Cipher cipher = Cipher.getInstance(""DESede/CBC/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        return cipherText;
    }

    public static String getHex(byte[] raw) {
        if (raw == null) {
            return null;
        }
        final StringBuilder hex = new StringBuilder(2 * raw.length);
        for (final byte b : raw) {
            hex.append(HEXES.charAt((b &amp; 0xF0) &gt;&gt; 4))
                    .append(HEXES.charAt((b &amp; 0x0F)));
        }
        return hex.toString();
    }

}
</code></pre>

<ul>
<li>The Java code exception is (java.security.InvalidKeyException: Invalid key length: 16 bytes)</li>
</ul>
","","23","<java><oracle><algorithm><3des>","0","","0","2019-05-14 20:27:21","","0","","","","","2019-05-14 20:27:21","2019-05-15 06:42:18"
"54606414","Csharp tripleDes decryption code convert to Nodejs code - Solved","<p>I have a TripleDes decryption code written in Csharp. I need to convert this code into Nodejs code. The format of the file I'm trying to convert is binary, so I'm not sure if I need to do something different. I'm really confused about how I should do it.</p>

<pre><code>byte[] content = Convert.FromBase64String(UTF8Encoding.UTF8.GetString(TripleDESCDecryptoText (attachSection1, attachDecryptionKey)));

public byte[] TripleDESCDecryptoText(byte[] toEncryptArray, string key)
{
    int ivLen = 8;

    TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();

    tdes.Key = System.Convert.FromBase64String(key); // keyArray;        
    tdes.Mode = CipherMode.CBC; //CipherMode.ECB;         
    tdes.Padding = PaddingMode.None; // PaddingMode.PKCS7;


    if (toEncryptArray.Length &lt; ivLen)
        return null;

    byte[] buffer = new byte[ivLen];

    for (int n = 0; n &lt; ivLen; n++)
        buffer[n] = toEncryptArray[n];

    tdes.IV = buffer;

    ICryptoTransform cTransform = tdes.CreateDecryptor();

    byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0 + ivLen, toEncryptArray.Length - ivLen);

    tdes.Clear();
    int nn2 = resultArray.Length;
    int nn2a = 0;
    while ((resultArray[nn2 - 1] == '\b' || resultArray[nn2 - 1] ==Convert.ToChar(4)) &amp;&amp; nn2a &lt; 15)
    {
        nn2--;
        nn2a++;
    }
    byte[] resultArray2 = new byte[nn2];
    Array.Copy(resultArray, 0, resultArray2, 0, resultArray2.Length);
    return resultArray2;
}
</code></pre>

<p>Do you have suggestions on how to convert? If you have any idea, thank you in advance.</p>

<p>The problem is solved. The solution is as follows.</p>

<p>Nodejs Code:</p>

<pre><code>exports.FilesDecrypt = function (input, keyInfo, callback) {

var chunks = [];

var fileBuffer;

var fileStream = fs.createReadStream(input);


fileStream.once('error', function (err) {
    // Be sure to handle this properly!
    console.error(err);
});

fileStream.once('end', function () {

    fileBuffer = Buffer.concat(chunks);

    var key = new Buffer(keyInfo, 'base64');
    var alg = ""des-ede3-cbc"";
    var autoPad = false;

    var ivLen = 8;

    var keyiv = new Buffer(ivLen); //byte[] keyiv = new byte[ivLen];

    for (var i = 0; i &lt; ivLen; i++) {
        keyiv[i] = fileBuffer[i];
    }

    var dataLen = fileBuffer.length - ivLen; //int dataLen = input.length-ivLen;
    var data = new Buffer(dataLen); //byte[] data = new byte[dataLen];

    for (var i = 0; i &lt; dataLen; i++) {
        data[i] = fileBuffer[i + ivLen];
    }
    //decrypt
    var decipher = crypto.createDecipheriv(alg, key, keyiv);
    decipher.setAutoPadding(autoPad);
    var txt = decipher.update(data);
    txt += decipher.final('base64');

    var utf8encoded = (new Buffer(txt, 'base64')).toString('utf8');

    callback(null, utf8encoded);
});

fileStream.on('data', function (chunk) {
    chunks.push(chunk);
});

 };
</code></pre>

<p>Best Regards,</p>
","","23","<3des><tripledes>","0","","0","2019-04-19 14:34:53","","0","","5665356","","2019-04-19 14:34:53","2019-02-09 12:54:47",""
"29583775","Java TripleDES using DES","<p>I'm trying to implement the <code>TripleDES</code> encryption algorithm using <code>DES</code>,<br>
I want to use 2 keys, and the flavor of the <code>TripleDES</code> is <strong>EDE</strong> using (key1, key2, key1).<br>
I know that there is a TripleDES algorithm, but my project is about implementing it using DES.<br>
Here is my code  </p>

<pre><code>static Cipher cipher;

static final int[] ENC_MODE = {Cipher.ENCRYPT_MODE, Cipher.DECRYPT_MODE, Cipher.ENCRYPT_MODE};

public static void main(String[] args) throws Exception {

    String text = ""this is my text"";
    cipher = Cipher.getInstance(""DES"");
    SecretKey key1 = KeyGenerator.getInstance(""DES"").generateKey();
    SecretKey key2 = KeyGenerator.getInstance(""DES"").generateKey();

    String cipherText = enc(text, key1, key2);



}

private static String enc(String plainText, SecretKey key1, SecretKey key2) throws Exception{
    byte[] textBytes = null;
    String encText = plainText;

    for(int i=0; i&lt;3; i++){ 
        if (ENC_MODE[i] == Cipher.ENCRYPT_MODE){
            cipher.init(ENC_MODE[i], key1);
            textBytes = encText.getBytes(""UTF8"");
            textBytes = cipher.doFinal(textBytes);
            encText = Base64.getEncoder().encodeToString(textBytes);

        }else if(ENC_MODE[i] == Cipher.DECRYPT_MODE){
            cipher.init(ENC_MODE[i], key2);
            textBytes = cipher.doFinal(textBytes);  //Error Line
            encText = new String(textBytes, ""UTF8"");
        }

        System.out.println(""loop= "" + i +"" ""+encText);
    }
    return encText;
}
</code></pre>

<p>my problem is that in the second loop (decryption with key2) I'm always getting this exception
<code>Exception in thread ""main"" javax.crypto.BadPaddingException: Given final block not properly padded</code>
I looked for this problem everywhere, but I didn't find a solution!<br>
Thank you.</p>
","","20","<java><encryption><des><3des><tripledes>","1","","0","2015-04-11 22:26:22","","0","2","","","","2015-04-11 22:26:22","2015-04-11 22:37:35"
"53482628","Minidriver admin login","<p><br/>
I'm trying to perform a login as the administrator (ROLE_ADMIN, 2) on a Gemalto IDPrime MD 830B card with the challenge/response method. </p>

<p>I tried logging in with the default password (24 \0) at first, which worked. I then tried logging in with a 24 bytes random password, which worked as well.
I then tried a typical 9 bytes user password ('Password1') with all kind of padding algorithms, but the card keeps refusing the challenge.</p>

<p>For those who know cryptography but not Minidriver, the Minidriver spec says:</p>

<blockquote>
  <p>The card minidriver interface supports a challenge/response authentication mechanism. The card must generate a challenge of one or more 8 byte blocks. The authenticating entity calculates the response by encrypting the challenge by using Triple DES (3DES) that operates operating in CBC mode with a 168-bit key (and ignoring the parity bits)</p>
</blockquote>

<p>What am I missing here ? Is it a cryptography error (wrong key expansion of a weak password to the 24bytes key needed by 3 DES) or something minidriver related ?</p>

<p>Thanks a lot for your time</p>
","","14","<windows><3des>","0","","0","2018-11-26 13:53:40","","0","","","","","2018-11-26 13:53:40",""
"56240921","Understanding 3Des CreateEnryptor method of TripleDESCryptoServiceProvider","<p>I'm studing 3DES encryption using  TripleDESCryptoServiceProvider  of System.Security.Cryptography library (.net).
The method CreateEncryptor takes in input the Initialization vector and the key.</p>

<p>My question is: how does it generate the keys to perform the encryption? I need at least two keys in order to 
perform EDE encryption,
so why there is only one key and one initialization vector?</p>

<p>I have also a doub about DesCryptoserviceProvider: the method CreateEncryptor takes in input the initialization vector
in order to perform a CBC or ECB encryption, is it correct?</p>

<p>Thanks in advance</p>
","","12","<3des><cbc-mode>","0","","0","2019-05-21 14:48:41","","0","","","","","2019-05-21 14:48:41",""
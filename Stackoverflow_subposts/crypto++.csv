post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"12306956","Example of AES using Crypto++","<p>I have been searching the Internet for <strong><em>good</em></strong> c++ AES code sample/tutorial that teaches the basics of the encryption technology and the use of the Library but so far I have had no luck getting decent material.</p>

<p>good: Easy to understand (Just the basics for on the go study).</p>
","<p>Official document of <a href=""http://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">Crypto++ AES</a> is a good start. And from my archive, a basic implementation of AES is as follows:</p>

<p>Please refer <a href=""http://www.cryptopp.com/fom-serve/cache/79.html"" rel=""noreferrer"">here</a> with more explanation, I recommend you first understand the <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">algorithm</a> and then try to understand each line step by step.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

#include ""modes.h""
#include ""aes.h""
#include ""filters.h""

int main(int argc, char* argv[]) {

    //Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-   
    //bit). This key is secretly exchanged between two parties before communication   
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    CryptoPP::byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    //
    // String and Sink setup
    //
    std::string plaintext = ""Now is the time for all good men to come to the aide..."";
    std::string ciphertext;
    std::string decryptedtext;

    //
    // Dump Plain Text
    //
    std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; plaintext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Create Cipher Text
    //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;CryptoPP::byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Decrypt
    //
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    //
    // Dump Decrypted Text
    //
    std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
    std::cout &lt;&lt; decryptedtext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>For installation details :</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/6619042/how-do-i-install-crypto-in-visual-studio-2010-windows-7"">How do I install Crypto++ in Visual Studio 2010 Windows 7?</a></li>
<li><a href=""http://www.cryptopp.com/wiki/Linux"" rel=""noreferrer"">*nix environment</a></li>
<li>For Ubuntu I did: </li>
</ul>

<p><code>sudo apt-get install libcrypto++-dev libcrypto++-doc libcrypto++-utils</code></p>
","106047","<c++><crypto++>","56","83","1","2019-02-07 11:44:48","12307096","4","26","1198284","","2014-05-13 06:23:41","2012-09-06 19:22:27","2014-05-13 14:50:58"
"14714877","Mismatch Detected for 'RuntimeLibrary'","<p>I downloaded and extracted Crypto++ in C:\cryptopp. I used Visual Studio Express 2012 to build all the projects inside (as instructed in readme), and everything was built successfully. Then I made a test project in some other folder and added cryptolib as a dependency. After that, I added the include path so I can easily include all the headers. When I tried to compile, I got an error about unresolved symbols.</p>

<p>To remedy that, I added <code>C:\cryptopp\Win32\Output\Debug\cryptlib.lib</code> to link additional dependencies. Now I get this error:</p>

<pre><code>Error   1   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cryptlib.obj)    CryptoTest
Error   2   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(iterhash.obj)    CryptoTest
Error   3   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(sha.obj) CryptoTest
Error   4   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(pch.obj) CryptoTest
Error   5   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(misc.obj)    CryptoTest
Error   6   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(queue.obj)   CryptoTest
Error   7   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(algparam.obj)    CryptoTest
Error   8   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(filters.obj) CryptoTest
Error   9   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(fips140.obj) CryptoTest
Error   10  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cpu.obj) CryptoTest
Error   11  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(mqueue.obj)  CryptoTest
</code></pre>

<p>I also get:</p>

<pre><code>Error   12  error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   13  error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   14  error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   15  error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(iterhash.obj) C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Warning 16  warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\LINK  CryptoTest
Error   17  error LNK1169: one or more multiply defined symbols found   C:\Data\Work\C++ VS\CryptoTest\Debug\CryptoTest.exe 1   1   CryptoTest
</code></pre>

<p>The code I tried to compile was simple (I got this from another site):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""sha.h""
#include ""hex.h""
using namespace std;

string SHA256(string data) {
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[32];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}

int main(void) {

    return 0;
}
</code></pre>

<p>Any ideas how to fix this? I really only need SHA-256 right now, nothing else.
I am using Windows 7 64 bit, and I downloaded VS C++ today, so it should be the newest version.</p>
","<p>(This is already answered in comments, but since it lacks an actual <em>answer</em>, I'm writing this.)</p>

<p>This problem arises in newer versions of Visual C++ (the older versions usually just silently linked the program and it would crash and burn at run time.) It means that some of the libraries you are linking with your program (or even some of the source files inside your program itself) are <em>using different versions of the CRT (the C RunTime library.)</em></p>

<p>To correct this error, you need to go into your <code>Project Properties</code> (and/or those of the libraries you are using,) then into <code>C/C++</code>, then <code>Code Generation</code>, and check the value of <code>Runtime Library</code>; this should be exactly the same for <em>all</em> the files and libraries you are linking together. (The rules are a little more relaxed for linking with DLLs, but I'm not going to go into the ""why"" and into more details here.)</p>

<p>There are currently four options for this setting:</p>

<ol>
<li>Multithreaded Debug</li>
<li>Multithreaded Debug DLL</li>
<li>Multithreaded Release</li>
<li>Multithreaded Release DLL</li>
</ol>

<p>Your particular problem seems to stem from you linking a library built with ""Multithreaded Debug"" (i.e. static multithreaded debug CRT) against a program that is being built using the ""Multithreaded Debug <em>DLL</em>"" setting (i.e. dynamic multithreaded debug CRT.) You should change this setting either in the library, or in your program. For now, I suggest changing this in your program.</p>

<p>Note that since Visual Studio projects use different sets of project settings for debug and release builds (and 32/64-bit builds) you should make sure the settings match in all of these project configurations.</p>

<p>For (some) more information, you can see these (linked from a comment above):</p>

<ol>
<li><a href=""http://msdn.microsoft.com/en-us/library/6wtdswk0%28v=vs.110%29.aspx"" rel=""noreferrer"">Linker Tools Warning LNK4098</a> on MSDN</li>
<li><a href=""http://msdn.microsoft.com/en-us/library/2kzt1wy3%28v=vs.110%29.aspx"" rel=""noreferrer"">/MD, /ML, /MT, /LD (Use Run-Time Library)</a> on MSDN</li>
<li><a href=""https://bugzilla.mozilla.org/show_bug.cgi?id=732124"" rel=""noreferrer"">Build errors with VC11 Beta - mixing MTd libs with MDd exes fail to link</a> on Bugzilla@Mozilla</li>
</ol>

<p><strong>UPDATE</strong>: (This is in response to a comment that asks for the reason that this much care must be taken.)</p>

<p>If two pieces of code that we are linking together are themselves linking against and using the standard library, then the standard library must be the same for both of them, unless <em>great</em> care is taken about how our two code pieces interact and pass around data. Generally, I would say that for almost all situations just use the exact same version of the standard library runtime (regarding debug/release, threads, and obviously the version of Visual C++, among other things like iterator debugging, etc.)</p>

<p>The most important part of the problem is this: <em>having the same idea about the size of objects on either side of a function call</em>.</p>

<p>Consider for example that the above two pieces of code are called <code>A</code> and <code>B</code>. A is <em>compiled</em> against one version of the standard library, and B against another. In A's view, some random object that a standard function returns to it (e.g. a block of memory or an iterator or a <code>FILE</code> object or whatever) has some specific size and layout (remember that structure layout is determined and fixed at compile time in C/C++.) For any of several reasons, B's idea of the size/layout of the same objects is different (it can be because of additional debug information, natural evolution of data structures over time, etc.)</p>

<p>Now, if A calls the standard library and gets an object back, then passes that object to B, and B touches that object in any way, chances are that B will mess that object up (e.g. write the wrong field, or past the end of it, etc.)</p>

<p>The above isn't the only kind of problems that can happen. Internal global or static objects in the standard library can cause problems too. And there are more obscure classes of problems as well.</p>

<p>All this gets weirder in some aspects when using DLLs (dynamic runtime library) instead of libs (static runtime library.)</p>

<p>This situation can apply to any library used by two pieces of code that work together, but the standard library gets used by most (if not almost all) programs, and that increases the chances of clash.</p>

<p>What I've described is obviously a watered down and simplified version of the actual mess that awaits you if you mix library versions. I hope that it gives you an idea of why you shouldn't do it!</p>
","102325","<c++><hash><compilation><sha256><crypto++>","104","218","4","2019-06-20 09:30:50","18635749","3","32","608639","","2015-10-24 01:58:21","2013-02-05 19:00:39",""
"14714877","Mismatch Detected for 'RuntimeLibrary'","<p>I downloaded and extracted Crypto++ in C:\cryptopp. I used Visual Studio Express 2012 to build all the projects inside (as instructed in readme), and everything was built successfully. Then I made a test project in some other folder and added cryptolib as a dependency. After that, I added the include path so I can easily include all the headers. When I tried to compile, I got an error about unresolved symbols.</p>

<p>To remedy that, I added <code>C:\cryptopp\Win32\Output\Debug\cryptlib.lib</code> to link additional dependencies. Now I get this error:</p>

<pre><code>Error   1   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cryptlib.obj)    CryptoTest
Error   2   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(iterhash.obj)    CryptoTest
Error   3   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(sha.obj) CryptoTest
Error   4   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(pch.obj) CryptoTest
Error   5   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(misc.obj)    CryptoTest
Error   6   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(queue.obj)   CryptoTest
Error   7   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(algparam.obj)    CryptoTest
Error   8   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(filters.obj) CryptoTest
Error   9   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(fips140.obj) CryptoTest
Error   10  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cpu.obj) CryptoTest
Error   11  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(mqueue.obj)  CryptoTest
</code></pre>

<p>I also get:</p>

<pre><code>Error   12  error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   13  error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   14  error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   15  error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(iterhash.obj) C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Warning 16  warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\LINK  CryptoTest
Error   17  error LNK1169: one or more multiply defined symbols found   C:\Data\Work\C++ VS\CryptoTest\Debug\CryptoTest.exe 1   1   CryptoTest
</code></pre>

<p>The code I tried to compile was simple (I got this from another site):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""sha.h""
#include ""hex.h""
using namespace std;

string SHA256(string data) {
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[32];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}

int main(void) {

    return 0;
}
</code></pre>

<p>Any ideas how to fix this? I really only need SHA-256 right now, nothing else.
I am using Windows 7 64 bit, and I downloaded VS C++ today, so it should be the newest version.</p>
","<blockquote>
  <p>I downloaded and extracted Crypto++ in C:\cryptopp. I used Visual Studio Express 2012 to build all the projects inside (as instructed in readme), and everything was built successfully. Then I made a test project in some other folder and added cryptolib as a dependency.</p>
</blockquote>

<p>The conversion was probably not successful. The only thing that was successful was the running of VCUpgrade. The actual conversion itself failed but you don't know until you experience the errors you are seeing. For some of the details, see <a href=""http://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow"">Visual Studio</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
  <p>Any ideas how to fix this?</p>
</blockquote>

<p>To resolve your issues, you should download <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010.zip</code></a> if you want static C/C++ runtime linking (<code>/MT</code> or <code>/MTd</code>), or <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010-dynamic.zip</code></a> if you want dynamic C/C++ runtime linking (<code>/MT</code> or <code>/MTd</code>). Both fix the latent, silent failures produced by VCUpgrade.</p>

<hr>

<p><a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010.zip</code></a>, <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010-dynamic.zip</code></a> and <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2005-dynamic.zip</code></a> are built from the <a href=""http://github.com/weidai11/cryptopp"" rel=""nofollow"">latest GitHub sources</a>. As of this writing (JUN 1 2016), that's effectively pre-Crypto++ 5.6.4. If you are using the ZIP files with a down level Crypto++, like 5.6.2 or 5.6.3, then you will run into minor problems.</p>

<p>There are two minor problems I am aware. First is a rename of <a href=""http://groups.google.com/d/msg/cryptopp-users/Inz3uhNxd4g/Y6VJPUg4EQAJ"" rel=""nofollow""><code>bench.cpp</code> to <code>bench1.cpp</code></a>. Its error is either:</p>

<ul>
<li><code>C1083: Cannot open source file: 'bench1.cpp': No such file or directory</code></li>
<li><code>LNK2001: unresolved external symbol ""void __cdecl OutputResultOperations(char const *,char const *,bool,unsigned long,double)"" (?OutputResultOperations@@YAXPBD0_NKN@Z)</code></li>
</ul>

<p>The fix is to either (1) open <code>cryptest.vcxproj</code> in notepad, find <code>bench1.cpp</code>, and then rename it to <code>bench.cpp</code>. Or (2) rename <code>bench.cpp</code> to <code>bench1.cpp</code> on the filesystem. Please don't delete this file.</p>

<p>The second problem is a little trickier because its a moving target. Down level releases, like 5.6.2 or 5.6.3, are missing the latest classes available in <a href=""http://github.com/weidai11/cryptopp"" rel=""nofollow"">GitHub</a>. The missing class files include HKDF (5.6.3), RDRAND (5.6.3), RDSEED (5.6.3), ChaCha (5.6.4), BLAKE2 (5.6.4), Poly1305 (5.6.4), etc.</p>

<p>The fix is to remove the missing source files from the Visual Studio project files since they don't exist for the down level releases.</p>

<p>Another option is to add the missing class files from the latest sources, but there could be complications. For example, many of the sources subtly depend upon the latest <code>config.h</code>, <code>cpu.h</code> and <code>cpu.cpp</code>. The ""subtlety"" is you won't realize you are getting an under-performing class.</p>

<p>An example of under-performing class is BLAKE2. <code>config.h</code> adds compile time ARM-32 and ARM-64 detection. <code>cpu.h</code> and <code>cpu.cpp</code> adds runtime ARM instruction detection, which depends upon compile time detection. If you add BLAKE2 without the other files, then none of the detection occurs and you get a straight C/C++ implementation. You probably won't realize you are missing the NEON opportunity, which runs around 9 to 12 cycles-per-byte versus 40 cycles-per-byte or so for vanilla C/C++.</p>
","102325","<c++><hash><compilation><sha256><crypto++>","104","3","4","2019-06-20 09:30:50","18635749","3","32","608639","","2015-10-24 01:58:21","2013-02-05 19:00:39",""
"14714877","Mismatch Detected for 'RuntimeLibrary'","<p>I downloaded and extracted Crypto++ in C:\cryptopp. I used Visual Studio Express 2012 to build all the projects inside (as instructed in readme), and everything was built successfully. Then I made a test project in some other folder and added cryptolib as a dependency. After that, I added the include path so I can easily include all the headers. When I tried to compile, I got an error about unresolved symbols.</p>

<p>To remedy that, I added <code>C:\cryptopp\Win32\Output\Debug\cryptlib.lib</code> to link additional dependencies. Now I get this error:</p>

<pre><code>Error   1   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cryptlib.obj)    CryptoTest
Error   2   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(iterhash.obj)    CryptoTest
Error   3   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(sha.obj) CryptoTest
Error   4   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(pch.obj) CryptoTest
Error   5   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(misc.obj)    CryptoTest
Error   6   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(queue.obj)   CryptoTest
Error   7   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(algparam.obj)    CryptoTest
Error   8   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(filters.obj) CryptoTest
Error   9   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(fips140.obj) CryptoTest
Error   10  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cpu.obj) CryptoTest
Error   11  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(mqueue.obj)  CryptoTest
</code></pre>

<p>I also get:</p>

<pre><code>Error   12  error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   13  error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   14  error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   15  error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(iterhash.obj) C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Warning 16  warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\LINK  CryptoTest
Error   17  error LNK1169: one or more multiply defined symbols found   C:\Data\Work\C++ VS\CryptoTest\Debug\CryptoTest.exe 1   1   CryptoTest
</code></pre>

<p>The code I tried to compile was simple (I got this from another site):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""sha.h""
#include ""hex.h""
using namespace std;

string SHA256(string data) {
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[32];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}

int main(void) {

    return 0;
}
</code></pre>

<p>Any ideas how to fix this? I really only need SHA-256 right now, nothing else.
I am using Windows 7 64 bit, and I downloaded VS C++ today, so it should be the newest version.</p>
","<p>I had this problem along with mismatch in ITERATOR_DEBUG_LEVEL.
As a sunday-evening problem after all seemed ok and good to go, I was put out for some time.
Working in de VS2017 IDE (Solution Explorer) I had recently added/copied a sourcefile reference to my project (ctrl-drag) from another project. Looking into properties->C/C++/Preprocessor - <strong>at source file level, not project level</strong> - I noticed that in a Release configuration _DEBUG was specified instead of NDEBUG for this source file.
Which was all the change needed to get rid of the problem.</p>
","102325","<c++><hash><compilation><sha256><crypto++>","104","3","4","2019-06-20 09:30:50","18635749","3","32","608639","","2015-10-24 01:58:21","2013-02-05 19:00:39",""
"14714877","Mismatch Detected for 'RuntimeLibrary'","<p>I downloaded and extracted Crypto++ in C:\cryptopp. I used Visual Studio Express 2012 to build all the projects inside (as instructed in readme), and everything was built successfully. Then I made a test project in some other folder and added cryptolib as a dependency. After that, I added the include path so I can easily include all the headers. When I tried to compile, I got an error about unresolved symbols.</p>

<p>To remedy that, I added <code>C:\cryptopp\Win32\Output\Debug\cryptlib.lib</code> to link additional dependencies. Now I get this error:</p>

<pre><code>Error   1   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cryptlib.obj)    CryptoTest
Error   2   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(iterhash.obj)    CryptoTest
Error   3   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(sha.obj) CryptoTest
Error   4   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(pch.obj) CryptoTest
Error   5   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(misc.obj)    CryptoTest
Error   6   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(queue.obj)   CryptoTest
Error   7   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(algparam.obj)    CryptoTest
Error   8   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(filters.obj) CryptoTest
Error   9   error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(fips140.obj) CryptoTest
Error   10  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(cpu.obj) CryptoTest
Error   11  error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in program.obj    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\cryptlib.lib(mqueue.obj)  CryptoTest
</code></pre>

<p>I also get:</p>

<pre><code>Error   12  error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)    C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   13  error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   14  error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(cryptlib.obj)   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Error   15  error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(iterhash.obj) C:\Data\Work\C++ VS\CryptoTest\CryptoTest\msvcprtd.lib(MSVCP110D.dll)   CryptoTest
Warning 16  warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library   C:\Data\Work\C++ VS\CryptoTest\CryptoTest\LINK  CryptoTest
Error   17  error LNK1169: one or more multiply defined symbols found   C:\Data\Work\C++ VS\CryptoTest\Debug\CryptoTest.exe 1   1   CryptoTest
</code></pre>

<p>The code I tried to compile was simple (I got this from another site):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""sha.h""
#include ""hex.h""
using namespace std;

string SHA256(string data) {
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[32];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}

int main(void) {

    return 0;
}
</code></pre>

<p>Any ideas how to fix this? I really only need SHA-256 right now, nothing else.
I am using Windows 7 64 bit, and I downloaded VS C++ today, so it should be the newest version.</p>
","<p>Issue can be solved by adding CRT of msvcrtd.lib in the linker library.
Because cryptlib.lib used CRT version of debug.</p>
","102325","<c++><hash><compilation><sha256><crypto++>","104","0","4","2019-06-20 09:30:50","18635749","3","32","608639","","2015-10-24 01:58:21","2013-02-05 19:00:39",""
"6619042","How do I install Crypto++ in Visual Studio 2010?","<p>I downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">http://www.cryptopp.com/#download</a> 5.6.1 and have no clue that to do at this point. I am a total noob and need good instructions. thanks.</p>
","<p>Directly from the readme (Which can be found here <a href=""http://svn.code.sf.net/p/cryptopp/code/trunk/c5/"" rel=""nofollow noreferrer"" title=""Crypto++ SVN Trunk"">Crypto++ Svn Trunk</a>):</p>

<p><strong>* MSVC-Specific Information *</strong></p>

<p>On Windows, Crypto++ can be compiled into 3 forms: a static library including all algorithms, a DLL with only FIPS Approved algorithms, and a static library with only algorithms not in the DLL. (FIPS Approved means Approved according to the FIPS 140-2 standard.) The DLL may be used by itself, or it may be used together with the second form of the static library. MSVC project files are included to build all three forms, and sample applications using each of the three forms are also included.</p>

<p>To compile Crypto++ with MSVC, open the ""cryptest.dsw"" (for MSVC 6 and MSVC .NET 2003) or ""cryptest.sln"" (for MSVC 2005 - 2010) workspace file and build one or more of the following projects:</p>

<ul>
<li>cryptopp - This builds the DLL. Please note that if you wish to use Crypto++ as a FIPS validated module, you must use a pre-built DLL that has undergone the FIPS validation process instead of building your own.</li>
<li>dlltest - This builds a sample application that only uses the DLL.</li>
<li>cryptest Non-DLL-Import Configuration - This builds the full static library along with a full test driver.</li>
<li>cryptest DLL-Import Configuration - This builds a static library containing only algorithms not in the DLL, along with a full test driver that uses both the DLL and the static library.</li>
</ul>

<p>To use the Crypto++ DLL in your application, #include ""dll.h"" before including any other Crypto++ header files, and place the DLL in the same directory as your .exe file. dll.h includes the line #pragma comment(lib, ""cryptopp"") so you don't have to explicitly list the import library in your project settings.</p>

<p>To use a static library form of Crypto++, make the ""cryptlib"" project a dependency of your application project, or specify it as an additional library to link with in your project settings. In either case you should check the compiler options to make sure that the library and your application are using the same C++
run-time libraries and calling conventions.</p>

<p>If you have any questions feel free to ask and i'll update the anwser with my responses.</p>
","23487","<c++><visual-studio-2010><crypto++>","8","18","4","2019-03-01 18:50:04","","0","4","608639","","2015-11-04 09:11:29","2011-07-08 01:33:47",""
"6619042","How do I install Crypto++ in Visual Studio 2010?","<p>I downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">http://www.cryptopp.com/#download</a> 5.6.1 and have no clue that to do at this point. I am a total noob and need good instructions. thanks.</p>
","<p>You'll need to compile the library before using it with anything. You can't just install it. Here is a page from their wiki about compiling the library: <a href=""http://www.cryptopp.com/wiki/Compiling"" rel=""nofollow"">http://www.cryptopp.com/wiki/Compiling</a></p>
","23487","<c++><visual-studio-2010><crypto++>","8","1","4","2019-03-01 18:50:04","","0","4","608639","","2015-11-04 09:11:29","2011-07-08 01:33:47",""
"6619042","How do I install Crypto++ in Visual Studio 2010?","<p>I downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">http://www.cryptopp.com/#download</a> 5.6.1 and have no clue that to do at this point. I am a total noob and need good instructions. thanks.</p>
","<p>If you convert cryptest.sln from VS2005 to VS2010, you will meet a problem. When you compile source code, the compiler will show an error: </p>

<p>c1xx : fatal error C1027: Inconsistent values for /Ym between creation and use of precompiled header</p>

<p>You can resolve this problem by:</p>

<ol>
<li><p>Going to Project Properties --> Configuration Properties --> C/C++ --> Precompiled Headers</p></li>
<li><p>Changing it to ""Not Using Precompiled Headers""</p></li>
</ol>
","23487","<c++><visual-studio-2010><crypto++>","8","1","4","2019-03-01 18:50:04","","0","4","608639","","2015-11-04 09:11:29","2011-07-08 01:33:47",""
"6619042","How do I install Crypto++ in Visual Studio 2010?","<p>I downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">http://www.cryptopp.com/#download</a> 5.6.1 and have no clue that to do at this point. I am a total noob and need good instructions. thanks.</p>
","<blockquote>
  <p>I downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow"">http://www.cryptopp.com/#download</a> 5.6.1 and have no clue what to do at this point...</p>
</blockquote>

<p>This is a very late answer, but the project has released some new files to help folks use Visual Studio 2010 and above.</p>

<p>The project had to release the updated files because VCUpgrade (provided with Visual Studio 2010) does a fairly poor job with this particular project. It has been a source of problems for a few years, and even visually impaired users were commenting about it. The problems were not fixed in VS2012, VS2013 and VS2015, so we don't believe Microsoft has any intentions of fixing the problems.</p>

<p>To use the updated files, download the latest Crypto++ release <a href=""http://www.cryptopp.com/#download"" rel=""nofollow"">from the website</a>. Then, visit the Crypto++ wiki and fetch <a href=""http://www.cryptopp.com/wiki/Visual_Studio"" rel=""nofollow""><code>vs2010.zip</code></a> from the page <a href=""http://www.cryptopp.com/wiki/Visual_Studio"" rel=""nofollow"">Visual Studio</a>. Unzip <code>vs2010.zip</code> over the Crypto++ files. Finally double-click the file called <strong><em><code>cryptest.sln</code></em></strong> to have Visual Studio open the solution file.</p>

<p>The <a href=""https://cryptopp.com/wiki/"" rel=""nofollow"">Crypto++ wiki</a> page also offers project files that provide dynamic runtime linking for both VS2005 and VS2010.</p>
","23487","<c++><visual-studio-2010><crypto++>","8","3","4","2019-03-01 18:50:04","","0","4","608639","","2015-11-04 09:11:29","2011-07-08 01:33:47",""
"5930056","Generating a SHA256 hash with Crypto++, using a string as input and output?","<p>I need an example of how to use Crypto++ to generate a SHA256 hash from a std::string and output a std::string. I can't seem to figure it out. Everything I've tried gives me invalid output.</p>

<p>Here's the new code after interjay's answer:</p>

<pre><code>string SHA256(string data)
{
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[CryptoPP::SHA256::DIGESTSIZE];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}
</code></pre>

<p>The output for SHA256(""A""); is</p>

<p><img src=""https://i.stack.imgur.com/6kRY4.png"" alt=""enter image description here""></p>

<p>How can I turn this into a readable format?</p>

<p>Thanks to interjay's answer I was able to generate the final hash.</p>
","<p>This line will give the wrong results:</p>

<pre><code>unsigned int nDataLen = sizeof(pbData);
</code></pre>

<p>It will always give you the size of a pointer. What you want instead is <code>data.size()</code>.</p>

<p>Also, you don't need this part:</p>

<pre><code>if(!CryptoPP::SHA256().VerifyDigest(abDigest, pbData, nDataLen))
{
    return SHA256(data);
}
</code></pre>

<p>It should always verify correctly, since you just calculated the digest based on the same data. And if it didn't, you'd go into infinite recursion.</p>

<p>To get readable output, you can convert it to hex. Here's an example for MD5 from the <a href=""http://www.cryptopp.com/wiki/Hash_Functions"" rel=""noreferrer"">Crypto++ Wiki</a>, it should work for you if you replace MD5 with SHA256:</p>

<pre><code>CryptoPP::MD5 hash;
byte digest[ CryptoPP::MD5::DIGESTSIZE ];
std::string message = ""abcdefghijklmnopqrstuvwxyz"";

hash.CalculateDigest( digest, (byte*) message.c_str(), message.length() );

CryptoPP::HexEncoder encoder;
std::string output;
encoder.Attach( new CryptoPP::StringSink( output ) );
encoder.Put( digest, sizeof(digest) );
encoder.MessageEnd();

std::cout &lt;&lt; output &lt;&lt; std::endl;  
</code></pre>
","22758","<c++><hash><stdstring><sha256><crypto++>","19","16","3","2018-02-23 06:27:01","5930199","5","8","608639","","2017-05-17 17:48:25","2011-05-08 20:14:47",""
"5930056","Generating a SHA256 hash with Crypto++, using a string as input and output?","<p>I need an example of how to use Crypto++ to generate a SHA256 hash from a std::string and output a std::string. I can't seem to figure it out. Everything I've tried gives me invalid output.</p>

<p>Here's the new code after interjay's answer:</p>

<pre><code>string SHA256(string data)
{
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[CryptoPP::SHA256::DIGESTSIZE];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}
</code></pre>

<p>The output for SHA256(""A""); is</p>

<p><img src=""https://i.stack.imgur.com/6kRY4.png"" alt=""enter image description here""></p>

<p>How can I turn this into a readable format?</p>

<p>Thanks to interjay's answer I was able to generate the final hash.</p>
","<p>This outputs a base64 string using the <code>CryptoPP::Base64Encoder</code>:</p>

<pre><code>#include ""sha.h""
#include ""filters.h""
#include ""base64.h""

std::string SHA256HashString(std::string aString){
    std::string digest;
    CryptoPP::SHA256 hash;

    CryptoPP::StringSource foo(aString, true,
    new CryptoPP::HashFilter(hash,
      new CryptoPP::Base64Encoder (
         new CryptoPP::StringSink(digest))));

    return digest;
}
</code></pre>
","22758","<c++><hash><stdstring><sha256><crypto++>","19","17","3","2018-02-23 06:27:01","5930199","5","8","608639","","2017-05-17 17:48:25","2011-05-08 20:14:47",""
"5930056","Generating a SHA256 hash with Crypto++, using a string as input and output?","<p>I need an example of how to use Crypto++ to generate a SHA256 hash from a std::string and output a std::string. I can't seem to figure it out. Everything I've tried gives me invalid output.</p>

<p>Here's the new code after interjay's answer:</p>

<pre><code>string SHA256(string data)
{
    byte const* pbData = (byte*) data.data();
    unsigned int nDataLen = data.size();
    byte abDigest[CryptoPP::SHA256::DIGESTSIZE];

    CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

    return string((char*)abDigest);
}
</code></pre>

<p>The output for SHA256(""A""); is</p>

<p><img src=""https://i.stack.imgur.com/6kRY4.png"" alt=""enter image description here""></p>

<p>How can I turn this into a readable format?</p>

<p>Thanks to interjay's answer I was able to generate the final hash.</p>
","<p>Your code will expect a null-terminated string from the buffer you supply to the string constructor! Which means the result will almost certainly be wrong.</p>

<p>To enforce the digest size and, use the following instead:</p>

<p><code>return std::string((char*)abDigest, CryptoPP::SHA256::DIGESTSIZE);</code></p>

<p>Also with respect to printing it the following correctly produces the test vector <code>BA7816BF8F01CFEA414140DE5DAE2223B00361A396177A9CB410FF61F20015AD</code> for the string <code>""abc""</code></p>

<pre><code>std::string string_to_hex(const std::string&amp; input)
{
  static const char* const lut = ""0123456789ABCDEF"";
  size_t len = input.length();

  std::string output;
  output.reserve(2 * len);
  for (size_t i = 0; i &lt; len; ++i)
  {
    const unsigned char c = input[i];
    output.push_back(lut[c &gt;&gt; 4]);
    output.push_back(lut[c &amp; 15]);
  }
  return output;
}

std::string SHA256(std::string data)
{
  CryptoPP::byte const* pbData = (CryptoPP::byte*)data.data();
  unsigned int nDataLen = data.length();
  CryptoPP::byte abDigest[CryptoPP::SHA256::DIGESTSIZE];

  CryptoPP::SHA256().CalculateDigest(abDigest, pbData, nDataLen);

  // return string((char*)abDigest);  -- BAD!!!
  return std::string((char*)abDigest, CryptoPP::SHA256::DIGESTSIZE);
}

void test_cryptopp() {
  std::cout &lt;&lt; string_to_hex(SHA256(""abc"")) &lt;&lt; std::endl;
}
</code></pre>
","22758","<c++><hash><stdstring><sha256><crypto++>","19","0","3","2018-02-23 06:27:01","5930199","5","8","608639","","2017-05-17 17:48:25","2011-05-08 20:14:47",""
"4508749","AES with padding pkcs7 c++ code","<p>I need an example of string encryption (in C++ -> I'm working on linux-Ubuntu) with aes-cbc256 and a padding: PKCS7
Please help.</p>

<hr>

<p>For the following code how can I set the IV to 0 and set the key value to a string value? I would also like to add the pkcs7 padding. I'm using the crypto++ lib (in Linux)</p>

<pre><code>// Driver.cpp   
//      

#include ""stdafx.h""    
#include ""cryptopp/dll.h""    
#include ""cryptopp/default.h""    
#include ""crypto++/osrng.h""    
using CryptoPP::AutoSeededRandomPool;    

#include &lt;iostream&gt;    
using std::cout;    
using std::cerr;       

#include &lt;string&gt;    
using std::string;       

#include ""crypto++/cryptlib.h""    
using CryptoPP::Exception;        

#include ""crypto++/hex.h""    
using CryptoPP::HexEncoder;    
using CryptoPP::HexDecoder;        

#include ""crypto++/filters.h""    
using CryptoPP::StringSink;    
using CryptoPP::StringSource;    
using CryptoPP::StreamTransformationFilter;        

#include ""crypto++/aes.h""    
using CryptoPP::AES;       

#include ""crypto++/ccm.h""    
using CryptoPP::CBC_Mode;       

#include ""assert.h""        

int main(int argc, char* argv[])    
{    
    AutoSeededRandomPool prng;        

    byte key[ AES::DEFAULT_KEYLENGTH ];    
    prng.GenerateBlock( key, sizeof(key) );        

    byte iv[ AES::BLOCKSIZE];    
    iv[AES::BLOCKSIZE] = 0;    
    //prng.GenerateBlock(iv,  sizeof(iv) );        

    string plain = ""CBC Mode Test"";    
    string cipher, encoded, recovered;       

    // Pretty print key    
    encoded.clear();    
    StringSource( key, sizeof(key), true,    
                  new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;        

    // Pretty print iv    
    encoded.clear();

    StringSource( iv, sizeof(iv), true,    
        new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;       

    /*********************************\
    \*********************************/

    try    
    {    
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;            
        CBC_Mode&lt; AES &gt;::Encryption e;    
        e.SetKeyWithIV( key, sizeof(key), iv );     

        // The StreamTransformationFilter adds padding    
        //  as required. ECB and CBC Mode must be padded    
        //  to the block size of the cipher.    
        StringSource( plain, true,     
            new StreamTransformationFilter( e,    
                new StringSink( cipher )    
            ) // StreamTransformationFilter          
        ); // StringSource    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    // Pretty print    
    encoded.clear();    
    StringSource( cipher, true,    
        new HexEncoder(    
            new StringSink( encoded )    
        ) // HexEncoder    
    ); // StringSource    
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;    

    /*********************************\    
    \*********************************/    

    try    
    {    
        CBC_Mode&lt; AES &gt;::Decryption d;    
        d.SetKeyWithIV( key, sizeof(key), iv );    

        // The StreamTransformationFilter removes    
        //  padding as required.    
        StringSource s( cipher, true,     
            new StreamTransformationFilter( d,    
                new StringSink( recovered )    
            ) // StreamTransformationFilter    
        ); // StringSource    

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    assert( plain == recovered );    

    return 0;    
}
</code></pre>
","<p>look also at my answer to <a href=""https://stackoverflow.com/questions/4508646/rijndael-alternative-for-linux"">this question</a></p>

<p>I suggest checking out <a href=""http://www.cryptopp.com"" rel=""nofollow noreferrer"">cryptopp</a>. Here's a code sample:</p>

<pre><code>CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor;
byte* key;
size_t keylen;
// ... acquire key

encryptor.SetKey( key, keylen );

std::string input;
std::string result;
// read input ...

StringSource( input, true,
       new StreamTransformationFilter( encryptor, new StringSink( result ),
     StreamTransformationFilter::PKCS_PADDING));
</code></pre>

<p>The values for padding mode in <code>StreamTransformationFilter</code> can be:</p>

<pre><code>BlockPaddingScheme { 
  NO_PADDING, ZEROS_PADDING, PKCS_PADDING, ONE_AND_ZEROS_PADDING, 
  DEFAULT_PADDING 
}
</code></pre>

<p>EDIT: replaced the padding mode in the sample to pkcs</p>
","19279","<c++><crypto++><pkcs#7>","2","1","2","2016-08-12 21:46:19","","4","2","608639","","2016-08-12 21:46:19","2010-12-22 11:34:58",""
"4508749","AES with padding pkcs7 c++ code","<p>I need an example of string encryption (in C++ -> I'm working on linux-Ubuntu) with aes-cbc256 and a padding: PKCS7
Please help.</p>

<hr>

<p>For the following code how can I set the IV to 0 and set the key value to a string value? I would also like to add the pkcs7 padding. I'm using the crypto++ lib (in Linux)</p>

<pre><code>// Driver.cpp   
//      

#include ""stdafx.h""    
#include ""cryptopp/dll.h""    
#include ""cryptopp/default.h""    
#include ""crypto++/osrng.h""    
using CryptoPP::AutoSeededRandomPool;    

#include &lt;iostream&gt;    
using std::cout;    
using std::cerr;       

#include &lt;string&gt;    
using std::string;       

#include ""crypto++/cryptlib.h""    
using CryptoPP::Exception;        

#include ""crypto++/hex.h""    
using CryptoPP::HexEncoder;    
using CryptoPP::HexDecoder;        

#include ""crypto++/filters.h""    
using CryptoPP::StringSink;    
using CryptoPP::StringSource;    
using CryptoPP::StreamTransformationFilter;        

#include ""crypto++/aes.h""    
using CryptoPP::AES;       

#include ""crypto++/ccm.h""    
using CryptoPP::CBC_Mode;       

#include ""assert.h""        

int main(int argc, char* argv[])    
{    
    AutoSeededRandomPool prng;        

    byte key[ AES::DEFAULT_KEYLENGTH ];    
    prng.GenerateBlock( key, sizeof(key) );        

    byte iv[ AES::BLOCKSIZE];    
    iv[AES::BLOCKSIZE] = 0;    
    //prng.GenerateBlock(iv,  sizeof(iv) );        

    string plain = ""CBC Mode Test"";    
    string cipher, encoded, recovered;       

    // Pretty print key    
    encoded.clear();    
    StringSource( key, sizeof(key), true,    
                  new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;        

    // Pretty print iv    
    encoded.clear();

    StringSource( iv, sizeof(iv), true,    
        new HexEncoder(new StringSink( encoded )) // HexEncoder    
    ); // StringSource

    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;       

    /*********************************\
    \*********************************/

    try    
    {    
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;            
        CBC_Mode&lt; AES &gt;::Encryption e;    
        e.SetKeyWithIV( key, sizeof(key), iv );     

        // The StreamTransformationFilter adds padding    
        //  as required. ECB and CBC Mode must be padded    
        //  to the block size of the cipher.    
        StringSource( plain, true,     
            new StreamTransformationFilter( e,    
                new StringSink( cipher )    
            ) // StreamTransformationFilter          
        ); // StringSource    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    // Pretty print    
    encoded.clear();    
    StringSource( cipher, true,    
        new HexEncoder(    
            new StringSink( encoded )    
        ) // HexEncoder    
    ); // StringSource    
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;    

    /*********************************\    
    \*********************************/    

    try    
    {    
        CBC_Mode&lt; AES &gt;::Decryption d;    
        d.SetKeyWithIV( key, sizeof(key), iv );    

        // The StreamTransformationFilter removes    
        //  padding as required.    
        StringSource s( cipher, true,     
            new StreamTransformationFilter( d,    
                new StringSink( recovered )    
            ) // StreamTransformationFilter    
        ); // StringSource    

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;    
    }    
    catch( CryptoPP::Exception&amp; e )    
    {    
        cerr &lt;&lt; ""Caught Exception..."" &lt;&lt; endl;    
        cerr &lt;&lt; e.what() &lt;&lt; endl;    
        cerr &lt;&lt; endl;    
    }    

    /*********************************\    
    \*********************************/    

    assert( plain == recovered );    

    return 0;    
}
</code></pre>
","<p>OpenSSL uses PKCS7 padding by default.  This padding means when your data is not a multiple of the block size, you pad <em>n</em> bytes of the value <em>n</em>, where <em>n</em> is however many bytes you need to get to the block size.  AES's block size is 16.</p>

<p>Here's an example on how to encrypt a string using AES256-cbc with OpenSSL.  The OpenSSL documentation also has <a href=""http://www.openssl.org/docs/crypto/EVP_EncryptInit.html"" rel=""nofollow"">examples</a>, although they use different ciphers.  This example does no error checking.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;

#include &lt;openssl/evp.h&gt;

int main()
{
    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);

    unsigned char key[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                   0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                   0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                   0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) == 16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""encrypt me"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len = plain.length() + 16 - (plain.length() % 16);
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    std::cout &lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);

    return 0;
}
</code></pre>

<p>Name it <code>encrypt.cpp</code> and compile with:</p>

<pre><code>g++ encrypt.cpp -o encrypt -lcrypto -lssl -Wall
</code></pre>

<p>You'll get this output:</p>

<pre><code>338d2a9e28208cad84c457eb9bd91c81
</code></pre>

<p>You can verify correctness by running the OpenSSL command-line utility from the command prompt:</p>

<pre><code>$ echo -n ""encrypt me"" &gt; to_encrypt
$ openssl enc -in to_encrypt -out encrypted -e -aes-256-cbc \
-K 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f \
-iv 00000000000000000000000000000000
$ hexdump -C encrypted
</code></pre>

<p>And the hexdump will show the same bytes as the c++ program.</p>

<pre><code>00000000  33 8d 2a 9e 28 20 8c ad  84 c4 57 eb 9b d9 1c 81  |3.*.( ....W.....|
</code></pre>
","19279","<c++><crypto++><pkcs#7>","2","5","2","2016-08-12 21:46:19","","4","2","608639","","2016-08-12 21:46:19","2010-12-22 11:34:58",""
"9833532","RAW RSA encryption and decryption with Crypto++","<p>I need to establish a secure communication between a PC and a device which supports RSA encryption and signature with SHA1. As I have already used Crypto++ in other part of my application, I would like to utilize Crypto++ for this as well.</p>

<p>The device is very primitive but allows executing a program I write on it. It has raw RSA and SHAa functions built-in; However, it has very little memory to work with, 2K bytes to be precise.</p>

<p>I have to encrypt and sign a message from a PC. Then the device decrypts and verifies the message. The device will then reply an encrypted message and sign on it. The PC will decrypt the message and verify it afterwards. I have implemented the raw RSA encryption, signature and verification with SHA1 inside the device using the built in functions. The messages is short enought to be done in a single round.</p>

<p>However, I don't know how to encrypt a message with raw RSA using Crypto++ without involving OAEP or PKCS#1. Could somebody kind enough to show me some sample code? Thanks a ton!</p>
","<p>Here is a demo function I wrote when I first did RSA encryption and decryption with Crypto++. I wrote it just to understand the basics. I hope it helps:</p>

<pre><code>#include &lt;cryptopp/files.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/sha.h&gt;

void rsa_examples()
{
    // Keys created here may be used by OpenSSL.
    //
    // openssl pkcs8 -in key.der -inform DER -out key.pem -nocrypt 
    // openssl rsa -in key.pem -check

    CryptoPP::AutoSeededRandomPool rng;

    // Create a private RSA key and write it to a file using DER.
    CryptoPP::RSAES_OAEP_SHA_Decryptor priv( rng, 4096 );
    CryptoPP::TransparentFilter privFile( new CryptoPP::FileSink(""rsakey.der"") );
    priv.DEREncode( privFile );
    privFile.MessageEnd();

    // Create a private RSA key and write it to a string using DER (also write to a file to check it with OpenSSL).
    std::string the_key;
    CryptoPP::RSAES_OAEP_SHA_Decryptor pri( rng, 2048 );
    CryptoPP::TransparentFilter privSink( new CryptoPP::StringSink(the_key) );
    pri.DEREncode( privSink );
    privSink.MessageEnd();

    std::ofstream file ( ""key.der"", std::ios::out | std::ios::binary );
    file.write( the_key.data(), the_key.size() );
    file.close();

    // Example Encryption &amp; Decryption
    CryptoPP::InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize( rng, 1536 );

    std::string plain = ""RSA Encryption"", cipher, decrypted_data;

    CryptoPP::RSA::PrivateKey privateKey( params );
    CryptoPP::RSA::PublicKey publicKey( params );

    CryptoPP::RSAES_OAEP_SHA_Encryptor e( publicKey );
    CryptoPP::StringSource( plain, true, new CryptoPP::PK_EncryptorFilter( rng, e, new CryptoPP::StringSink( cipher )));

    CryptoPP::RSAES_OAEP_SHA_Decryptor d( privateKey );
    CryptoPP::StringSource( cipher, true, new CryptoPP::PK_DecryptorFilter( rng, d, new CryptoPP::StringSink( decrypted_keydata )));

    assert( plain == decrypted_data );
}
</code></pre>
","10444","<rsa><crypto++>","4","1","2","2013-10-04 02:35:45","19172129","0","","1074963","","2012-03-26 03:24:30","2012-03-23 02:50:44",""
"9833532","RAW RSA encryption and decryption with Crypto++","<p>I need to establish a secure communication between a PC and a device which supports RSA encryption and signature with SHA1. As I have already used Crypto++ in other part of my application, I would like to utilize Crypto++ for this as well.</p>

<p>The device is very primitive but allows executing a program I write on it. It has raw RSA and SHAa functions built-in; However, it has very little memory to work with, 2K bytes to be precise.</p>

<p>I have to encrypt and sign a message from a PC. Then the device decrypts and verifies the message. The device will then reply an encrypted message and sign on it. The PC will decrypt the message and verify it afterwards. I have implemented the raw RSA encryption, signature and verification with SHA1 inside the device using the built in functions. The messages is short enought to be done in a single round.</p>

<p>However, I don't know how to encrypt a message with raw RSA using Crypto++ without involving OAEP or PKCS#1. Could somebody kind enough to show me some sample code? Thanks a ton!</p>
","<blockquote>
  <p>I don't know how to encrypt a message with raw RSA using Crypto++ without
  involving OAEP or PKCS#1. Could somebody kind enough to show me some sample code?</p>
</blockquote>

<p>That's easy enough when you know where to look: <a href=""http://www.cryptopp.com/wiki/Raw_RSA"" rel=""nofollow"">Raw RSA</a> from the Crypto++ wiki. The code below was taken from the page.</p>

<hr>

<p><strong>Encryption</strong></p>

<pre><code>Integer n(""0xbeaadb3d839f3b5f""), e(""0x11""), d(""0x21a5ae37b9959db9"");

RSA::PublicKey pubKey;
pubKey.Initialize(n, e);

/////////////////////////////////////////////////////////

Integer m, c;
string message = ""secret"";  

cout &lt;&lt; ""message: "" &lt;&lt; message &lt;&lt; endl;

// Treat the message as a big endian byte array
m = Integer((const byte *)message.data(), message.size());
cout &lt;&lt; ""m: "" &lt;&lt; hex &lt;&lt; m &lt;&lt; endl;

// Encrypt
c = pubKey.ApplyFunction(m);
cout &lt;&lt; ""c: "" &lt;&lt; hex &lt;&lt; c &lt;&lt; endl;
</code></pre>

<hr>

<p><strong>Decryption</strong></p>

<pre><code>Integer n(""0xbeaadb3d839f3b5f""), e(""0x11""), d(""0x21a5ae37b9959db9"");
AutoSeededRandomPool prng;

RSA::PrivateKey privKey;
privKey.Initialize(n, e, d);

/////////////////////////////////////////////////////////

Integer c(0x3f47c32e8e17e291), r;
string recovered;

// Decrypt
r = privKey.CalculateInverse(prng, c);
cout &lt;&lt; ""r: "" &lt;&lt; hex &lt;&lt; r &lt;&lt; endl;

// Round trip the message
size_t req = r.MinEncodedSize();
recovered.resize(req);
r.Encode((byte *)recovered.data(), recovered.size());

cout &lt;&lt; ""recovered: "" &lt;&lt; recovered &lt;&lt; endl; 
</code></pre>

<hr>

<p>Here's a sample output:</p>

<pre><code>$ ./cryptopp-raw-rsa.exe
message: secret
m: 736563726574h
c: 3f47c32e8e17e291h
r: 736563726574h
recovered: secret
</code></pre>

<hr>

<p>There is one caveat: <code>c = m ^ e mod n</code>, so there are some limits on plaint text size and cipher text size. Essentially, <code>m</code> and <code>c</code> must be smaller than <code>n</code>. In this example, replacing the string <code>secret</code> with <code>now is the time for all good men to come to the aide of their country</code> would fail because its larger than <code>n</code> when converted to a <code>Integer</code>.</p>

<p>You can get the maximum plain text size with the function <code>MaxPreImage()</code>, and the maximum cipher text size with <code>MaxImage()</code>.</p>

<hr>

<blockquote>
  <p>I have to encrypt and sign a message from a PC. Then the device decrypts
  and verifies the message. The device will then reply an encrypted message
  and sign on it. The PC will decrypt the message and verify it afterwards.</p>
</blockquote>

<p>On the surface, this looks like it will suffer replay attacks. You might need a protocol with the protection.</p>
","10444","<rsa><crypto++>","4","3","2","2013-10-04 02:35:45","19172129","0","","1074963","","2012-03-26 03:24:30","2012-03-23 02:50:44",""
"3967787","How to decrypt a string on OpenSSL that was previously encrypted via Crypto++?","<p><strong>EDIT: I found out that the keys aren't the problem like I said in the comments. I can use them without any issues to encrypt and decrypt data on OpenSSL.</strong></p>

<p><strong>But I need to decrypt a string on OpenSSL that was previously encrypted via Crypto++
and that's not working.</strong></p>

<p><strong>I'll post additional details later.</strong></p>

<p>Hi, I have encrypted a string using an RSA public key generated with Crypto++ and now I'm trying (still unsuccessful) to decrypt it via PHP and OpenSSL.</p>

<p>That is what I'm doing:</p>

<ul>
<li>The private key which is NOT base64 or hex encoded is stored in a file called ""rsa-private.key""</li>
<li>The encrypted message is stored in ""message.txt"" (hex encoded)</li>
</ul>

<p>STEP 1: Load the private key via: <code>$key = file_get_contents(""rsa-private.key"");</code> </p>

<p>STEP 2: Convert the key into PEM format using the following function:</p>

<pre><code>&lt;?php
function pkcs8_to_pem($der) {

    static $BEGIN_MARKER = ""-----BEGIN PRIVATE KEY-----"";
    static $END_MARKER = ""-----END PRIVATE KEY-----"";

    $value = base64_encode($der);

    $pem = $BEGIN_MARKER . ""\n"";
    $pem .= chunk_split($value, 64, ""\n"");
    $pem .= $END_MARKER . ""\n"";

    return $pem;
    }

    $PEMprivatekey = pkcs8_to_pem($key); 
?&gt;
</code></pre>

<p>( stackoverflow.com/questions/1357569/ )</p>

<p>STEP 3: Prepare the key for further use by OpenSSL: (without any problems)</p>

<pre><code>&lt;?php
$privateKey = openssl_get_privatekey($PEMprivatekey);
if (!$privateKey) {
    echo ""Cannot get public key"";
}
?&gt;
</code></pre>

<p>STEP 4: Get the message and decode the message using the following function:</p>

<pre><code>&lt;?php
function hex_to_str($hex){

    for ($i=0; $i &lt; strlen($hex)-1; $i+=2) {
    $string .= chr(hexdec($hex[$i].$hex[$i+1])); }
    return $string;
}

$message = file_get_contents(""message.txt"");` 
$encryptedstring = hex_to_str($message);
?&gt;
</code></pre>

<p>STEP 5: Decrypt the string: (does not work)</p>

<pre><code>&lt;?php
openssl_private_decrypt($encryptedstring, $decrypteddata, $privateKey);
if (!$decrypteddata) {
    echo ""........""; } else { echo $decrypteddata; }
?&gt;
</code></pre>

<p>$decrypteddata is always empty.</p>

<p>I can't figure out why it's not working. Anyone noticed something I'm doing wrong?</p>
","<p>Ok, i dont know if this is the issue, but i guess at this point anything is helpful.</p>

<p>I've created a small openssl/php test script and for testing proposes 2 public-private-key pairs.</p>

<pre><code>openssl genrsa -des3 -out private.pem 1024
openssl rsa -in private.pem -out public.pem -outform PEM -pubout

openssl genrsa -out master.key 1024
openssl rsa -in master.key -pubout -out master.pub
</code></pre>

<p>the first pair uses an phrase ""phrase""</p>

<p>used both pairs with this script to test the output</p>

<pre><code>$source = ""FAIL"";
echo ""&lt;pre&gt;Source: $source"";
$fp=fopen(""./keys/master.pub"",""r"");
$pub_key=fread($fp,8192);
fclose($fp);
openssl_get_publickey($pub_key);
openssl_public_encrypt($source,$crypttext,$pub_key);
echo ""\n\nString crypted: $crypttext"";
flush();
$fp=fopen(""./keys/master.key"",""r"");
$priv_key=fread($fp,8192);
fclose($fp);
// phrase is required if your key is encoded (suggested)
$res = openssl_get_privatekey($priv_key, 'phrase');
openssl_private_decrypt($crypttext,$newsource,$res);
while($error = openssl_error_string()) {
    echo ""\n"" , $error;
}
echo ""\n\nString decrypt : $newsource"";
</code></pre>

<p>beside an <code>error:0906D06C:PEM routines:PEM_read_bio:no start line</code> error-message all went fine</p>

<p>BUT when i mix the keys (just to see what error-message will be created) guess what errors <code>openssl_error_string</code> returns:</p>

<pre><code>error:0906D06C:PEM routines:PEM_read_bio:no start line
error:0407106B:rsa routines:RSA_padding_check_PKCS1_type_2:block type is not 02
error:04065072:rsa routines:RSA_EAY_PRIVATE_DECRYPT:padding check failed
</code></pre>

<p>so you could check if your message is encrypted with the right public key</p>
","9572","<php><openssl><rsa><pem><crypto++>","2","0","2","2010-10-19 20:31:21","","6","1","477755","","2010-10-19 20:31:21","2010-10-19 11:22:09",""
"3967787","How to decrypt a string on OpenSSL that was previously encrypted via Crypto++?","<p><strong>EDIT: I found out that the keys aren't the problem like I said in the comments. I can use them without any issues to encrypt and decrypt data on OpenSSL.</strong></p>

<p><strong>But I need to decrypt a string on OpenSSL that was previously encrypted via Crypto++
and that's not working.</strong></p>

<p><strong>I'll post additional details later.</strong></p>

<p>Hi, I have encrypted a string using an RSA public key generated with Crypto++ and now I'm trying (still unsuccessful) to decrypt it via PHP and OpenSSL.</p>

<p>That is what I'm doing:</p>

<ul>
<li>The private key which is NOT base64 or hex encoded is stored in a file called ""rsa-private.key""</li>
<li>The encrypted message is stored in ""message.txt"" (hex encoded)</li>
</ul>

<p>STEP 1: Load the private key via: <code>$key = file_get_contents(""rsa-private.key"");</code> </p>

<p>STEP 2: Convert the key into PEM format using the following function:</p>

<pre><code>&lt;?php
function pkcs8_to_pem($der) {

    static $BEGIN_MARKER = ""-----BEGIN PRIVATE KEY-----"";
    static $END_MARKER = ""-----END PRIVATE KEY-----"";

    $value = base64_encode($der);

    $pem = $BEGIN_MARKER . ""\n"";
    $pem .= chunk_split($value, 64, ""\n"");
    $pem .= $END_MARKER . ""\n"";

    return $pem;
    }

    $PEMprivatekey = pkcs8_to_pem($key); 
?&gt;
</code></pre>

<p>( stackoverflow.com/questions/1357569/ )</p>

<p>STEP 3: Prepare the key for further use by OpenSSL: (without any problems)</p>

<pre><code>&lt;?php
$privateKey = openssl_get_privatekey($PEMprivatekey);
if (!$privateKey) {
    echo ""Cannot get public key"";
}
?&gt;
</code></pre>

<p>STEP 4: Get the message and decode the message using the following function:</p>

<pre><code>&lt;?php
function hex_to_str($hex){

    for ($i=0; $i &lt; strlen($hex)-1; $i+=2) {
    $string .= chr(hexdec($hex[$i].$hex[$i+1])); }
    return $string;
}

$message = file_get_contents(""message.txt"");` 
$encryptedstring = hex_to_str($message);
?&gt;
</code></pre>

<p>STEP 5: Decrypt the string: (does not work)</p>

<pre><code>&lt;?php
openssl_private_decrypt($encryptedstring, $decrypteddata, $privateKey);
if (!$decrypteddata) {
    echo ""........""; } else { echo $decrypteddata; }
?&gt;
</code></pre>

<p>$decrypteddata is always empty.</p>

<p>I can't figure out why it's not working. Anyone noticed something I'm doing wrong?</p>
","<p>phpseclib is fully interoperable with OpenSSL and is generally regarded as being much easier to use.  The following URL provides several examples of how to inter-operate with OpenSSL:</p>

<p><a href=""https://stackoverflow.com/questions/2608541/rsa-encrypt-in-php-to-decrypt-in-net/2613865#2613865"">RSA Encrypt in PHP to decrypt in .NET</a></p>
","9572","<php><openssl><rsa><pem><crypto++>","2","1","2","2010-10-19 20:31:21","","6","1","477755","","2010-10-19 20:31:21","2010-10-19 11:22:09",""
"19187990","Compiling against Crypto++ provided by Ubuntu","<p>I tried to install Crypto++ using apt-get: <code>sudo apt-get install libcrypto++-dev libcrypto++-doc libcrypto++-utils</code>. And then I tried to compile very simple program like:</p>

<pre><code>#include &lt;iostream&gt;
#include ""aes.h""
#include ""modes.h""

using namespace std;
using namespace CryptoPP;

int main()
{
    cout &lt;&lt; ""Yo, man!"" &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>It resulted in <strong><em><code>fatal error: aes.h: No such file or directory</code></em></strong>.</p>

<p>I'm a new Ubuntu user (Windows before), so I've done some research, but most people say that typing that one command is enough to get repository with Crypto++ library and make it work. Well, it is not in my case.</p>
","<p>If you installed the library as you said (using <code>apt-get</code>), then try this:</p>

<pre><code>#include &lt;crypto++/aes.h&gt;
#include &lt;crypto/modes.h&gt;
</code></pre>

<p>Instead of this:</p>

<pre><code>#include ""aes.h""
#include ""modes.h""
</code></pre>

<p>You should use the <code>#include &lt;crypto++/...&gt;</code> because Ubuntu installs them in its ""system"", which means the preprocessor will look in particular places in a particular order when processing them. Also see <a href=""https://stackoverflow.com/q/21593"">What is the difference between #include  and #include “filename”?</a>.</p>

<p>Also note that on Fedora and Red Hat, you would use <code>#include &lt;cryptopp/...&gt;</code>, not <code>#include &lt;crypto++/...&gt;</code>. If you are targeting multiple operating systems for Crypto++, then see <a href=""https://stackoverflow.com/q/32805772"">How to change the include file path with autotools?</a>.</p>
","8899","<ubuntu><compilation><crypto++>","8","9","1","2015-10-03 07:32:14","19453367","0","2","608639","","2015-10-03 07:17:32","2013-10-04 18:11:13",""
"8107844","How can I work around warning C4505 in third party libraries?","<p>I've got a project that uses Crypto++ for a few hashing functions. Recently, I decided to clean things up a bit and use warning level 4 on MSVC++.</p>

<p>Here's what my source looks like:</p>

<pre><code>#pragma warning(push)
#pragma warning(disable: 4100) //Unreferenced formal parameter
#pragma warning(disable: 4244) //Conversion, possible loss of data
#pragma warning(disable: 4512) //Assignment operator could not be generated
#pragma warning(disable: 4127) //Conditional expression is constant
#pragma warning(disable: 4505) //Unreferenced local function has been removed
#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include &lt;cryptopp/md5.h&gt;
#include &lt;cryptopp/sha.h&gt;
#pragma warning(pop)
</code></pre>

<p>Despite <code>disable: 4505</code>, I still get this warning:</p>

<pre class=""lang-none prettyprint-override""><code>c:\cppdev\cryptopp561\cryptopp\misc.h(548): warning C4505: 'CryptoPP::StringNarrow' : unreferenced local function has been removed
</code></pre>

<p>and my project does not build.</p>

<p>How can I work around this? Basically, I'd just like to disable the warning for third party code; I don't want to be editing cryptopp itself to fix the error if I can avoid doing so.</p>
","<p>The compiler can only determine unreferenced functions after it finished parsing the compiled source file. Move the corresponding <code>#pragma disable</code> out of the push/pop scope so it will still be in effect at the end of the file:</p>

<pre><code>#pragma warning(push)
#pragma warning(disable: 4100) //Unreferenced formal parameter
#pragma warning(disable: 4244) //Conversion, possible loss of data
#pragma warning(disable: 4512) //Assignment operator could not be generated
#pragma warning(disable: 4127) //Conditional expression is constant
#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include &lt;cryptopp/md5.h&gt;
#include &lt;cryptopp/sha.h&gt;
#pragma warning(pop)
#pragma warning(disable: 4505) //Unreferenced local function has been removed
</code></pre>
","8698","<c++><visual-c++><crypto++>","12","20","2","2011-11-13 00:08:54","8108159","3","","","","","2011-11-12 21:55:00",""
"8107844","How can I work around warning C4505 in third party libraries?","<p>I've got a project that uses Crypto++ for a few hashing functions. Recently, I decided to clean things up a bit and use warning level 4 on MSVC++.</p>

<p>Here's what my source looks like:</p>

<pre><code>#pragma warning(push)
#pragma warning(disable: 4100) //Unreferenced formal parameter
#pragma warning(disable: 4244) //Conversion, possible loss of data
#pragma warning(disable: 4512) //Assignment operator could not be generated
#pragma warning(disable: 4127) //Conditional expression is constant
#pragma warning(disable: 4505) //Unreferenced local function has been removed
#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include &lt;cryptopp/md5.h&gt;
#include &lt;cryptopp/sha.h&gt;
#pragma warning(pop)
</code></pre>

<p>Despite <code>disable: 4505</code>, I still get this warning:</p>

<pre class=""lang-none prettyprint-override""><code>c:\cppdev\cryptopp561\cryptopp\misc.h(548): warning C4505: 'CryptoPP::StringNarrow' : unreferenced local function has been removed
</code></pre>

<p>and my project does not build.</p>

<p>How can I work around this? Basically, I'd just like to disable the warning for third party code; I don't want to be editing cryptopp itself to fix the error if I can avoid doing so.</p>
","<p>If you just need a few hashing functions, create a separate source file with 4505 disabled to include the crapto headers and write your own header file to define the function prototypes you use.</p>
","8698","<c++><visual-c++><crypto++>","12","1","2","2011-11-13 00:08:54","8108159","3","","","","","2011-11-12 21:55:00",""
"14789114","Licensing system with expiration date","<p>I want to implement a simple licensing system based on <a href=""http://www.codeproject.com/articles/99499/implementation-of-the-licensing-system-for-a-softw"" rel=""nofollow"">this article</a>.</p>

<p>Everything works fine. But now I want to add a expiration date and I do not know how.</p>

<p>Can someone explain me how to add the expiration date? It is not important to know exactly how to implement, but I need to understand the algorithm behind it :)</p>
","<p>The most useful way is to have a server that checks if the key is still valid. That makes it hard to fake. </p>

<p>But if you don't want to (for some reason) use a ""online"" technique, then you need to store the expiration date somewhere in the data that client uses. It can be encrypted, but your software will have to contain the decryption key. Because at some point or another, your application will have to compare the current date with the date of the expiration date. </p>

<p>As others have said, it's easy to spend a lot of energy on making this hard to break, but sooner or later, it comes down to some simple compare ""Is it in date, or not?"", and that code can always be ""broken"" by replacing the <code>if (!in_date) exit_with_message(""License expired..."");</code> ith <code>if (false) ...</code>. So, unless you do that sort of thing in 100s of different places, and make the code look very different in each place [don't call the same function, don't use the same message, don't use the same calculation, don't use the same result, etc, etc] </p>

<p>I wanted to use a compiler that we used at work on my home machine [to do some work related projects from home!]. It had a ""demo license"" built in, so you could try it out, but it stopped after 10000 lines of source code. So I looked for all occurrences of 10000 in the binary. I think there were three places that contained 10000. I changed one, tried compiling my test-sample of more than 10000 lines, and it still failed - changed it back and changed the next one: wohoo, it worked... Now, the coder could have made it much harder, but had I been interested enough, I'm sure I could have fixed that as well. This was just much easier than getting a second license, installing a license server on my home machine, etc, etc. </p>

<p>Bear in mind also that most people who break things like this are not doing it for money, but for the challenge. And that's just a bigger motivation if it's hard!</p>

<p>Edit:</p>

<p>I would do something like this:</p>

<p>1) Create a license.dat, which contains:</p>

<ul>
<li>A license number of some sort.</li>
<li>An expiration date (somewhat encrypted)</li>
<li>A cryptographic hash of the two above components)</li>
</ul>

<p>2) When loading the software [or at regular intervals in your software], load the license.dat. </p>

<p>3) Verify hash of the license file. </p>

<p>4) Check if the current date is greater than expiration date. </p>

<p>5) If checks all work out, continue, else exit with some relevant message. </p>

<p>Exactly how you store/encrypt the date is something I can't really advice on. One option is a 64-bit integer that has been suitably ""scrambled"", based on a <code>time_t</code> (time in seconds). The encryption is probably more of a case of ""don't make it so darn obvious that it's a timestamp"" - but the hash is really what is protecting your timestamp. </p>
","8640","<c++><encryption><licensing><crypto++>","3","6","1","2014-01-24 00:43:39","","3","1","2642204","","2014-01-24 00:43:39","2013-02-09 14:27:38","2015-06-11 20:14:13"
"6981616","Using Crypto++ to generate random hashes with SHA1","<p>I need to generate a random hash using Crypto++, using SHA1.  At the moment I have:</p>

<pre><code>#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/hex.h&gt;

...

CryptoPP::SHA1 sha1;
string source = ""Hello"";  //This will be randomly generated somehow
string hash = """";
StringSource(source, true, new HashFilter(sha1, new HexEncoder(new StringSink(hash))));
</code></pre>

<p>When I come to compile, I get the following error reported:</p>

<pre><code>error: expected type-specifier before 'HashFilter'
error: expected ')' before 'HashFilter'
error: 'StringSource' was not declared in this scope
</code></pre>

<p>Can anyone help me to get this working?  Is there a much simpler way of performing this using this library?  I am new to using Crypto++ so all help will be much appreciated.</p>

<p>Thanks.</p>
","<p>Just specify your namespaces correctly and carefully:</p>

<pre><code>#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/hex.h&gt;

#include &lt;string&gt;

int main()
{
  CryptoPP::SHA1 sha1;
  std::string source = ""Hello"";  //This will be randomly generated somehow
  std::string hash = """";
  CryptoPP::StringSource(source, true, new CryptoPP::HashFilter(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(hash))));
}
</code></pre>
","7724","<c++><hash><crypto++>","4","8","1","2017-05-17 17:46:13","6981870","0","3","608639","","2017-05-17 17:46:13","2011-08-08 11:46:40",""
"11277324","Decrypting using AES / Crypto++","<p>I'm trying to figure out how to decrypt a block of cipher text using AES. I am using the crypto++ library - or at least TRYING to use that library. But I'm getting absolutely nowhere. I assume that it is only a couple of lines of code to run this decryption algorithm, but I can't figure it out. This is what I have written. Start laughing now:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;rijndael.h&gt;
#include &lt;sha.h&gt;

using namespace std;

int main()
{

    // Decryption
    CTR_Mode&lt; AES &gt;::Decryption decryptor;
    decryptor.SetKeyWithIV( cbcKey, AES::DEFAULT_KEYLENGTH, cbcCipher );
}
</code></pre>

<p>Can anyone give me a brief tutorial on how to ""simply"" decrypt a 16-byte block of cipher text given a decryption key using crypto++? Their documentation is more cryptic than the cipher text you see above (at least for me), and I'm finding little help by searching.  Thank you very much.</p>
","<p>The FAQ at the crypto++ library webpage contains pointers to a ""tutorial"", go read it <a href=""http://www.cryptopp.com/wiki/FAQ"" rel=""nofollow"">over there</a>.</p>
","7558","<c++><aes><crypto++>","4","1","4","2017-01-29 15:15:35","","4","","1024973","","2012-07-16 06:54:33","2012-06-30 20:14:04",""
"11277324","Decrypting using AES / Crypto++","<p>I'm trying to figure out how to decrypt a block of cipher text using AES. I am using the crypto++ library - or at least TRYING to use that library. But I'm getting absolutely nowhere. I assume that it is only a couple of lines of code to run this decryption algorithm, but I can't figure it out. This is what I have written. Start laughing now:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;rijndael.h&gt;
#include &lt;sha.h&gt;

using namespace std;

int main()
{

    // Decryption
    CTR_Mode&lt; AES &gt;::Decryption decryptor;
    decryptor.SetKeyWithIV( cbcKey, AES::DEFAULT_KEYLENGTH, cbcCipher );
}
</code></pre>

<p>Can anyone give me a brief tutorial on how to ""simply"" decrypt a 16-byte block of cipher text given a decryption key using crypto++? Their documentation is more cryptic than the cipher text you see above (at least for me), and I'm finding little help by searching.  Thank you very much.</p>
","<blockquote>
  <p>Can anyone give me a brief tutorial on how to ""simply"" decrypt a 16-byte block of cipher text given a decryption key using crypto++? </p>
</blockquote>

<p>This from the Crypto++ wiki. It provides a <a href=""http://www.cryptopp.com/wiki/CTR_Mode"" rel=""nofollow"">CTR mode example</a>.</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte ctr[ AES::BLOCKSIZE ];
prng.GenerateBlock( ctr, sizeof(ctr) );

string plain = ""CTR Mode Test"";
string cipher, encoded, recovered;

/*********************************\
\*********************************/

try
{
    cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), ctr );

    // The StreamTransformationFilter adds padding
    //  as required. ECB and CBC Mode must be padded
    //  to the block size of the cipher. CTR does not.
    StringSource ss1( plain, true, 
        new StreamTransformationFilter( e,
            new StringSink( cipher )
        ) // StreamTransformationFilter      
    ); // StringSource
}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

// Pretty print cipher text
StringSource ss2( cipher, true,
    new HexEncoder(
        new StringSink( encoded )
    ) // HexEncoder
); // StringSource
cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( key, key.size(), ctr );

    // The StreamTransformationFilter removes
    //  padding as required.
    StringSource ss3( cipher, true, 
        new StreamTransformationFilter( d,
            new StringSink( recovered )
        ) // StreamTransformationFilter
    ); // StringSource

    cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>Here's the result of running the sample program:</p>

<pre><code>$ ./crytpopp-test.exe 
key: F534FC7F0565A8CF1629F01DB31AE3CA
counter: A4D16CBC010DACAA2E54FA676B57A345
plain text: CTR Mode Test
cipher text: 12455EDB41020E6D751F207EE6
recovered text: CTR Mode Test
</code></pre>
","7558","<c++><aes><crypto++>","4","1","4","2017-01-29 15:15:35","","4","","1024973","","2012-07-16 06:54:33","2012-06-30 20:14:04",""
"11277324","Decrypting using AES / Crypto++","<p>I'm trying to figure out how to decrypt a block of cipher text using AES. I am using the crypto++ library - or at least TRYING to use that library. But I'm getting absolutely nowhere. I assume that it is only a couple of lines of code to run this decryption algorithm, but I can't figure it out. This is what I have written. Start laughing now:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;rijndael.h&gt;
#include &lt;sha.h&gt;

using namespace std;

int main()
{

    // Decryption
    CTR_Mode&lt; AES &gt;::Decryption decryptor;
    decryptor.SetKeyWithIV( cbcKey, AES::DEFAULT_KEYLENGTH, cbcCipher );
}
</code></pre>

<p>Can anyone give me a brief tutorial on how to ""simply"" decrypt a 16-byte block of cipher text given a decryption key using crypto++? Their documentation is more cryptic than the cipher text you see above (at least for me), and I'm finding little help by searching.  Thank you very much.</p>
","<p>Indeed, Crypto++ tutorials a quite hard to follow. In general, in order to use Crypto++ API you need to have at least some basic knowledge about Cryptography, I would suggest <a href=""https://class.coursera.org/crypto-012"" rel=""nofollow"">this Cryptography course</a>.</p>

<p>Having said that, let me address your question. Since it is a little bit ambiguous, I would assume that you would like to decrypt an AES cipher, using CTR mode. As input, let's say you have a cipher, the IV and the key (all represented in hex in a <code>std::string</code>). </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

#include ""crypto++/modes.h"" // For CTR_Mode
#include ""crypto++/filters.h"" //For StringSource
#include ""crypto++/aes.h"" // For AES
#include ""crypto++/hex.h"" // For HexDecoder

int main(int argc, char* argv[]) {
    // Our input:
    // Note: the input was previously generated by the same cipher 
    std::string iv_string = ""37C6D22FADE22B2D924598BEE2455EFC"";
    std::string cipher_string = ""221DF9130F0E05E7E87C89EE6A"";
    std::string key_string = ""7D9BB722DA2DC8674E08C3D44AAE976F"";

    std::cout &lt;&lt; ""Cipher text: "" &lt;&lt; cipher_string &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Key: "" &lt;&lt; key_string &lt;&lt; std::endl;
    std::cout &lt;&lt; ""IV: "" &lt;&lt; iv_string &lt;&lt; std::endl;

    // 1. Decode iv: 
    // At the moment our input is encoded in string format...
    // we need it in raw hex: 
    byte iv[CryptoPP::AES::BLOCKSIZE] = {};
    // this decoder would transform our std::string into raw hex:
    CryptoPP::HexDecoder decoder;
    decoder.Put((byte*)iv_string.data(), iv_string.size());
    decoder.MessageEnd();
    decoder.Get(iv, sizeof(iv));

    // 2. Decode cipher:
    // Next, we do a similar trick for cipher, only here we would leave raw hex
    //  in a std::string.data(), since it is convenient for us to pass this
    // std::string to the decryptor mechanism:
    std::string cipher_raw;
    {
        CryptoPP::HexDecoder decoder;
        decoder.Put((byte*)cipher_string.data(), cipher_string.size());
        decoder.MessageEnd();

        long long size = decoder.MaxRetrievable();
        cipher_raw.resize(size);       
        decoder.Get((byte*)cipher_raw.data(), cipher_raw.size());
        // If we print this string it's completely rubbish: 
        // std::cout &lt;&lt; ""Raw cipher: "" &lt;&lt; cipher_raw &lt;&lt; std::endl;
    }

    // 3. Decode the key:
    // And finally the same for the key:
    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    {
        CryptoPP::HexDecoder decoder;
        decoder.Put((byte*)key_string.data(), key_string.size());
        decoder.MessageEnd();
        decoder.Get(key, sizeof(key));
    }

    // 4. Decrypt:
    std::string decrypted_text;
    try {
            CryptoPP::CTR_Mode&lt;CryptoPP::AES&gt;::Decryption d;
            d.SetKeyWithIV(key, sizeof(key), iv);

            CryptoPP::StringSource ss(
                cipher_raw, 
                true, 
                new CryptoPP::StreamTransformationFilter(
                    d,
                    new CryptoPP::StringSink(decrypted_text)
                ) // StreamTransformationFilter
            ); // StringSource

            std::cout &lt;&lt; ""Decrypted text: "" &lt;&lt; decrypted_text &lt;&lt; std::endl;
    }
    catch( CryptoPP::Exception&amp; e ) {
            std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
            exit(1);
    }

    return 0;
}
</code></pre>

<p>I compiled it on Ubutunu 14.04, using Crypto++562:</p>

<p><code>g++ -Wall -std=c++0x -o prog practicalAES.cpp -lcryptopp</code></p>

<p>If I run the program, I get this output: </p>

<p><code>Cipher text: 221DF9130F0E05E7E87C89EE6A
Key: 7D9BB722DA2DC8674E08C3D44AAE976F
IV: 37C6D22FADE22B2D924598BEE2455EFC
Decrypted text: CTR Mode Test</code></p>

<p>It's not really visible here, but both the Key and the IV have the same length - 16 bytes (or 128 bits). This is the block size, so this cipher is AES-128. Since it is the CTR mode, no padding is added, and both the cipher and the plain text have the same number of bytes.</p>

<p>Also note that 60% of the code involves decoding the string into hex, while the decryption itself is only the last step (so if your input data comes as raw hex, no decoding is needed).</p>
","7558","<c++><aes><crypto++>","4","0","4","2017-01-29 15:15:35","","4","","1024973","","2012-07-16 06:54:33","2012-06-30 20:14:04",""
"11277324","Decrypting using AES / Crypto++","<p>I'm trying to figure out how to decrypt a block of cipher text using AES. I am using the crypto++ library - or at least TRYING to use that library. But I'm getting absolutely nowhere. I assume that it is only a couple of lines of code to run this decryption algorithm, but I can't figure it out. This is what I have written. Start laughing now:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;rijndael.h&gt;
#include &lt;sha.h&gt;

using namespace std;

int main()
{

    // Decryption
    CTR_Mode&lt; AES &gt;::Decryption decryptor;
    decryptor.SetKeyWithIV( cbcKey, AES::DEFAULT_KEYLENGTH, cbcCipher );
}
</code></pre>

<p>Can anyone give me a brief tutorial on how to ""simply"" decrypt a 16-byte block of cipher text given a decryption key using crypto++? Their documentation is more cryptic than the cipher text you see above (at least for me), and I'm finding little help by searching.  Thank you very much.</p>
","<p>The tutorial of Crypto++ is focused on the usage of filters and sources and sinks, which are, in my opinion, over complicated. In your case the code is actually very simple:</p>

<pre><code>CTR_Mode&lt; AES &gt;::Decryption decryptor;
decryptor.SetKeyWithIV( cbcKey, AES::DEFAULT_KEYLENGTH, cbcCipher );
decryptor.ProcessData(output, input, size);

// Decrypt another piece of data with the same key
decryptor.Resynchronize(new_iv, new_iv_length);
decryptor.ProcessData(new_output, new_input, size);
</code></pre>
","7558","<c++><aes><crypto++>","4","0","4","2017-01-29 15:15:35","","4","","1024973","","2012-07-16 06:54:33","2012-06-30 20:14:04",""
"11591030","Undefined reference to CryptoPP::AlignedAllocate(unsigned int)","<p>I am using crypto++ in c++ linux.
Here is my simple code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string.h&gt;

#include ""crypto++/cryptlib.h""
#include ""crypto++/modes.h""
#include ""crypto++/filters.h""
#include ""crypto++/aes.h""
#include ""crypto++/osrng.h""
#include ""crypto++/strciphr.h""

using namespace std;
using namespace CryptoPP;

ifstream::pos_type size;
char * memblock;
int length;
char * _iv[AES::BLOCKSIZE];
char * keys[AES::MAX_KEYLENGTH];


void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv);

void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv)
{
    size_t inbyte_len = strlen((const char *)inbyte);
    CTR_Mode&lt;AES&gt;::Encryption ctr_encription(key, strlen((const char*)key), iv);
    ctr_encription.ProcessData(outbyte, inbyte, inbyte_len);
}

int main()
{
    ifstream file;
    file.open(""testaja"", ios::binary);
    if (file.is_open())
    {
        file.seekg (0, ios::end);
        length = file.tellg();
        memblock = new char [length];
        file.seekg (0, ios::beg);
        file.read (memblock, length);


        if (!file)
        {
            int a;
            a = (int)file.gcount();
            file.clear();
        }
        else
        {
            file.close();

            for (int i = 0; i &lt; length; ++i)
            {
                cout &lt;&lt; hex &lt;&lt; (int)memblock[i] &lt;&lt; "" "";
            }

        }
    }
}
</code></pre>

<p>When I run it , some error occured:</p>

<pre><code> undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>Then, I used command</p>

<pre><code>gcc -o test test.cpp -L/usr/lib/crypto++ -lcrypto++
</code></pre>

<p>but this error still there :</p>

<pre><code>undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>How can I fix this error?
Is there something wrong with my code?</p>

<p>I am installing crypto++ using synaptic package manager for this package:</p>

<pre><code>libcrypto++-utils
libcrypto++8
libcrypto++8-dbg
libcrypto++-dev
libcrypto++-doc
</code></pre>

<p>and libcrypto++.a and libcrypto++.so can be found in /usr/lib/</p>

<p>Thanks in advance.</p>
","<p>This command looks wrong:</p>

<pre><code>gcc -o test test.cpp -L/usr/lib/crypto++ -lcrypto++
</code></pre>

<p>If (as you say) the libs are in <code>/usr/lib</code> then you shouldn't be saying <code>-L/usr/lib/crypto++</code></p>

<p>I think the <code>libcrypto++8</code> package installs its libs in the <code>-L/usr/lib/crypto++</code> directory, and presumably they are incompatible and don't provide the undefined symbols your program needs.</p>

<p>You should compile with simply:</p>

<pre><code>gcc -o test test.cpp -lcrypto++
</code></pre>

<p>(There's no need to say <code>-L/usr/lib</code> as it's the default location for libraries anyway)</p>
","6950","<c++><undefined-reference><crypto++>","8","6","3","2016-04-17 10:20:19","11597336","5","","608639","","2015-05-02 22:44:36","2012-07-21 09:28:38",""
"11591030","Undefined reference to CryptoPP::AlignedAllocate(unsigned int)","<p>I am using crypto++ in c++ linux.
Here is my simple code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string.h&gt;

#include ""crypto++/cryptlib.h""
#include ""crypto++/modes.h""
#include ""crypto++/filters.h""
#include ""crypto++/aes.h""
#include ""crypto++/osrng.h""
#include ""crypto++/strciphr.h""

using namespace std;
using namespace CryptoPP;

ifstream::pos_type size;
char * memblock;
int length;
char * _iv[AES::BLOCKSIZE];
char * keys[AES::MAX_KEYLENGTH];


void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv);

void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv)
{
    size_t inbyte_len = strlen((const char *)inbyte);
    CTR_Mode&lt;AES&gt;::Encryption ctr_encription(key, strlen((const char*)key), iv);
    ctr_encription.ProcessData(outbyte, inbyte, inbyte_len);
}

int main()
{
    ifstream file;
    file.open(""testaja"", ios::binary);
    if (file.is_open())
    {
        file.seekg (0, ios::end);
        length = file.tellg();
        memblock = new char [length];
        file.seekg (0, ios::beg);
        file.read (memblock, length);


        if (!file)
        {
            int a;
            a = (int)file.gcount();
            file.clear();
        }
        else
        {
            file.close();

            for (int i = 0; i &lt; length; ++i)
            {
                cout &lt;&lt; hex &lt;&lt; (int)memblock[i] &lt;&lt; "" "";
            }

        }
    }
}
</code></pre>

<p>When I run it , some error occured:</p>

<pre><code> undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>Then, I used command</p>

<pre><code>gcc -o test test.cpp -L/usr/lib/crypto++ -lcrypto++
</code></pre>

<p>but this error still there :</p>

<pre><code>undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>How can I fix this error?
Is there something wrong with my code?</p>

<p>I am installing crypto++ using synaptic package manager for this package:</p>

<pre><code>libcrypto++-utils
libcrypto++8
libcrypto++8-dbg
libcrypto++-dev
libcrypto++-doc
</code></pre>

<p>and libcrypto++.a and libcrypto++.so can be found in /usr/lib/</p>

<p>Thanks in advance.</p>
","<p>it solved!
i change my command from:</p>

<pre><code>g++ -o test test.cpp -L/usr/lib/crypto++ -lcrypto++
</code></pre>

<p>to this command:</p>

<pre><code>g++ -o test test.cpp -L/usr/lib/ -lcryptopp -lpthread
</code></pre>

<p>i add -lpthread because after i used this command:</p>

<pre><code>g++ -o test test.cpp -L/usr/lib/ -lcryptopp
</code></pre>

<p>i get these errors:</p>

<pre><code>./libcryptopp.so: undefined reference to `pthread_getspecific'
./libcryptopp.so: undefined reference to `pthread_key_delete'
./libcryptopp.so: undefined reference to `pthread_key_create'
./libcryptopp.so: undefined reference to `pthread_setspecific'
</code></pre>

<p>i misunderstood about -L/usr/lib/crypto++ arg, i thought compiler will search for crypto++ in /usr/lib/ dir, it turned out the compiler will search for crypto++ in -L/usr/lib/crypto++ dir, whereas the package installed in -L/usr/lib/ dir.</p>

<p>thanks to @jonathan wakely.</p>
","6950","<c++><undefined-reference><crypto++>","8","5","3","2016-04-17 10:20:19","11597336","5","","608639","","2015-05-02 22:44:36","2012-07-21 09:28:38",""
"11591030","Undefined reference to CryptoPP::AlignedAllocate(unsigned int)","<p>I am using crypto++ in c++ linux.
Here is my simple code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string.h&gt;

#include ""crypto++/cryptlib.h""
#include ""crypto++/modes.h""
#include ""crypto++/filters.h""
#include ""crypto++/aes.h""
#include ""crypto++/osrng.h""
#include ""crypto++/strciphr.h""

using namespace std;
using namespace CryptoPP;

ifstream::pos_type size;
char * memblock;
int length;
char * _iv[AES::BLOCKSIZE];
char * keys[AES::MAX_KEYLENGTH];


void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv);

void encriptCTR(byte * outbyte, const byte * inbyte, const byte * key, const byte * iv)
{
    size_t inbyte_len = strlen((const char *)inbyte);
    CTR_Mode&lt;AES&gt;::Encryption ctr_encription(key, strlen((const char*)key), iv);
    ctr_encription.ProcessData(outbyte, inbyte, inbyte_len);
}

int main()
{
    ifstream file;
    file.open(""testaja"", ios::binary);
    if (file.is_open())
    {
        file.seekg (0, ios::end);
        length = file.tellg();
        memblock = new char [length];
        file.seekg (0, ios::beg);
        file.read (memblock, length);


        if (!file)
        {
            int a;
            a = (int)file.gcount();
            file.clear();
        }
        else
        {
            file.close();

            for (int i = 0; i &lt; length; ++i)
            {
                cout &lt;&lt; hex &lt;&lt; (int)memblock[i] &lt;&lt; "" "";
            }

        }
    }
}
</code></pre>

<p>When I run it , some error occured:</p>

<pre><code> undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
 undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
 undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>Then, I used command</p>

<pre><code>gcc -o test test.cpp -L/usr/lib/crypto++ -lcrypto++
</code></pre>

<p>but this error still there :</p>

<pre><code>undefined reference to `CryptoPP::AlignedAllocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedAllocate(unsigned int)'
undefined reference to `CryptoPP::AlignedDeallocate(unsigned int)'
undefined reference to `CryptoPP::UnalignedDeallocate(unsigned int)'
</code></pre>

<p>How can I fix this error?
Is there something wrong with my code?</p>

<p>I am installing crypto++ using synaptic package manager for this package:</p>

<pre><code>libcrypto++-utils
libcrypto++8
libcrypto++8-dbg
libcrypto++-dev
libcrypto++-doc
</code></pre>

<p>and libcrypto++.a and libcrypto++.so can be found in /usr/lib/</p>

<p>Thanks in advance.</p>
","<p>i have this problem too.
your compiler need to bind library files to your program , so because it cannot find any implementation of your decleration!</p>

<p>i still not solve my problem. but you have a way other!!!
you can instead <code>.cpp</code> original files with library files.</p>

<p>you can download <code>Cryptopp</code> originally from below link :</p>

<p><a href=""https://www.cryptopp.com/cryptopp563.zip"" rel=""nofollow"">https://www.cryptopp.com/cryptopp563.zip</a></p>
","6950","<c++><undefined-reference><crypto++>","8","0","3","2016-04-17 10:20:19","11597336","5","","608639","","2015-05-02 22:44:36","2012-07-21 09:28:38",""
"25559057","Android runtime error- dlopen failed: cannot locate symbol ""__cxa_end_cleanup"" referenced by ""libcryptopp.so""","<p>I have been trying to compile/link/run an Android project that uses the NDK, and has 2 stages of NDK compilation. I have been able to compile using GNU-libstdc++ without including CryptoPP, a great alternative to the OpenSSL libraries for encryption. With CryptoPP, I receive the runtime error noted in the Title. </p>

<p>When compiling my Android NDK project, I have no compiler errors, however during runtime, the CryptoPP library is having trouble locating the symbol <strong>""__cxa_end_cleanup""</strong>. I have tried manually recompiling the libcryptopp.so file using STLport as well as GNU-libstdc++, and both result in the same runtime error. I have been following the instructions per <a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a>. I have been properly changing APP_STL when changing compilers.</p>

<p>Looking online, it seems that this error is related to C++ exception handling, and thus I've tried removing the line from Android.mk <strong>""LOCAL_CPP_FEATURES += exceptions""</strong> so that exceptions are not enabled, but again, same error during runtime. </p>

<p>I am also loading the libraries in the correct, reverse, order in the Java side of the JNI. System.loadLibrary(""cryptopp"") comes before my other custom-made library is loaded. </p>

<p>I have also tried including the stlport_shared.so in the armeabi/ folder and loading first, before cryptopp, and same error. </p>

<p>Likewise I have tried including the libsupc++.a library in the armeabi/ folder when compiling with GNU-libstdc++, as this is the C++ library that adds exception handling, and have included references to it in Android.mk <strong>""LOCAL_CFLAGS += -lsupc++""</strong> and <strong>""LOCAL_WHOLE_STATIC_LIBRARIES := libsupc++.a""</strong></p>

<p>Has anyone had similar problems using CryptoPP with Android? And if so, how did you configure your makefiles to properly link the libraries? Finally, any idea why this is not causing an error during compilation, and only during runtime? The full error is pasted below:</p>

<p><strong>E/dalvikvm(15888): dlopen(""/data/app-lib/com.example.test_app/libcryptopp.so"") failed: dlopen failed: cannot locate symbol ""__cxa_end_cleanup"" referenced by ""libcryptopp.so""...</strong></p>
","<p>Hi I met the same issue while using NDK and STL, and I've solved it just now. I found that my native library would depend on STL but Dalvik VM didn't load it from system automatically even I packed it into APK file. Hence I try to load it by myself by adding the line in JAVA file:</p>

<blockquote>
  <p>System.loadLibrary(""stlport_shared"");</p>
</blockquote>

<p>Where my Application.mk looks like:</p>

<pre><code>APP_ABI := armeabi-v7a-hard
APP_STL := stlport_shared
</code></pre>

<p>Perhaps it would help to you</p>
","5578","<android><android-ndk><linker><runtimeexception><crypto++>","1","0","1","2017-06-16 15:30:10","","4","","","","","2014-08-28 22:33:40",""
"19974669","ElGamal encryption example?","<p>I apologise in advance for the n00bishness of asking this question, but I've been stuck for ages and I'm struggling to figure out what to do next. Essentially, I am trying to perform ElGamal encryption on some data. I have been given the public part of an ephemeral key pair and a second static key, as well as some data. If my understanding is correct, this is all I need to perform the encryption, but I'm struggling to figure out how using Crypto++.</p>

<p>I've looked endlessly for examples, but I can find literally zero on Google. Ohloh is less than helpful as I just get back endless pages of the cryptopp ElGamal source files, which I can't seem to be able to figure out (I'm relatively new to using Crypto++ and until about 3 days ago hadn't even heard of ElGamal).</p>

<p>The closest I've been able to find as an example comes from the CryptoPP package itself, which is as follows:</p>

<pre><code>bool ValidateElGamal()
{
    cout &lt;&lt; ""\nElGamal validation suite running...\n\n"";
    bool pass = true;
    {
        FileSource fc(""TestData/elgc1024.dat"", true, new HexDecoder);
        ElGamalDecryptor privC(fc);
        ElGamalEncryptor pubC(privC);
        privC.AccessKey().Precompute();
        ByteQueue queue;
        privC.AccessKey().SavePrecomputation(queue);
        privC.AccessKey().LoadPrecomputation(queue);

        pass = CryptoSystemValidate(privC, pubC) &amp;&amp; pass;
    }
    return pass;
}
</code></pre>

<p>However, this doesn't really seem to help me much as I'm unaware of how to plug in my already computed values. I am not sure if I'm struggling with my understanding of how Elgamal works (entirely possible) or if I'm just being an idiot when it comes to using what I've got with CryptoPP. Can anyone help point me in the right direction?</p>
","<blockquote>
  <p>I have been given the public part of an ephemeral key pair and a second static key, as well as some data.</p>
</blockquote>

<p>We can't really help you here because we know nothing about what is supposed to be done. </p>

<p>The ephemeral key pair is probably for simulating key exchange, and the static key is long term for signing the ephemeral exchange. Other than that, its anybody's guess as to what's going on.</p>

<p>Would you happen to know what the keys are? is the ephemeral key a Diffie-Hellman key and the static key an ElGamal signing key?</p>

<hr>

<blockquote>
  <p>If my understanding is correct, this is all I need to perform the encryption, but I'm struggling to figure out how using Crypto++.</p>
</blockquote>

<p>For the encryption example, I'm going to cheat a bit and use an <a href=""http://www.cryptopp.com/wiki/RSA_Encryption_Schemes"" rel=""nofollow"">RSA encryption example</a> and port it to ElGamal. This is about as difficult as copy and paste because both RSA encryption and <a href=""http://www.cryptopp.com/docs/ref/struct_el_gamal.html"" rel=""nofollow"">ElGamal encryption</a> adhere to the the <code>PK_Encryptor</code> and <code>PK_Decryptor</code> interfaces. See the <a href=""http://www.cryptopp.com/docs/ref/class_p_k___encryptor.html"" rel=""nofollow""><code>PK_Encryptor</code></a> and <a href=""http://www.cryptopp.com/docs/ref/class_p_k___decryptor.html"" rel=""nofollow""><code>PK_Decryptor</code></a> classes for details. (And keep in mind, you might need an ElGamal or Nyberg-Rueppel (NR) signing example).</p>

<p>Crypto++ has a cryptosystem built on ElGamal. The cryptosystem will encrypt a large block of plain text under a symmetric key, and then encrypt the symmetric key under the ElGamal key. I'm not sure what standard it follows, though (likely IEEE's P1363). See <code>SymmetricEncrypt</code> and <code>SymmetricDecrypt</code> in <a href=""http://www.cryptopp.com/docs/ref/elgamal_8h_source.html"" rel=""nofollow"">elgamal.h</a>.</p>

<p>The key size is artificially small so the program runs quickly. ElGamal is a discrete log problem, so its key size should be 2048-bits or higher in practice. 2048-bits is blessed by ECRYPT (Asia), ISO/IEC (Worldwide), NESSIE (Europe), and NIST (US).</p>

<p>If you need to save/persist/load the keys you generate, then see <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow"">Keys and Formats</a> on the Crypto++ wiki. The short answer is to call <code>decryptor.Save()</code> and <code>decryptor.Load()</code>; and stay away from the <code>{BER|DER}</code> encodings.</p>

<p>If you want, you can use a standard <code>string</code> rather than a <code>SecByteBlock</code>. The <code>string</code> will be easier if you are interested in printing stuff to the terminal via <code>cout</code> and friends.</p>

<p>Finally, there's now a page on the Crypto++ Wiki covering the topic with the source code for the program below. See Crypto++'s <a href=""http://www.cryptopp.com/wiki/ElGamal"" rel=""nofollow"">ElGamal Encryption</a>.</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::AutoSeededRandomPool;

#include &lt;cryptopp/secblock.h&gt;
using CryptoPP::SecByteBlock;

#include &lt;cryptopp/elgamal.h&gt;
using CryptoPP::ElGamal;
using CryptoPP::ElGamalKeys;

#include &lt;cryptopp/cryptlib.h&gt;
using CryptoPP::DecodingResult;

int main(int argc, char* argv[])
{
    ////////////////////////////////////////////////
    // Generate keys
    AutoSeededRandomPool rng;

    cout &lt;&lt; ""Generating private key. This may take some time..."" &lt;&lt; endl;

    ElGamal::Decryptor decryptor;
    decryptor.AccessKey().GenerateRandomWithKeySize(rng, 512);
    const ElGamalKeys::PrivateKey&amp; privateKey = decryptor.AccessKey();

    ElGamal::Encryptor encryptor(decryptor);
    const PublicKey&amp; publicKey = encryptor.AccessKey();

    ////////////////////////////////////////////////
    // Secret to protect
    static const int SECRET_SIZE = 16;
    SecByteBlock plaintext( SECRET_SIZE );
    memset( plaintext, 'A', SECRET_SIZE );

    ////////////////////////////////////////////////
    // Encrypt

    // Now that there is a concrete object, we can validate
    assert( 0 != encryptor.FixedMaxPlaintextLength() );
    assert( plaintext.size() &lt;= encryptor.FixedMaxPlaintextLength() );

    // Create cipher text space
    size_t ecl = encryptor.CiphertextLength( plaintext.size() );
    assert( 0 != ecl );
    SecByteBlock ciphertext( ecl );

    encryptor.Encrypt( rng, plaintext, plaintext.size(), ciphertext );

    ////////////////////////////////////////////////
    // Decrypt

    // Now that there is a concrete object, we can check sizes
    assert( 0 != decryptor.FixedCiphertextLength() );
    assert( ciphertext.size() &lt;= decryptor.FixedCiphertextLength() );

    // Create recovered text space
    size_t dpl = decryptor.MaxPlaintextLength( ciphertext.size() );
    assert( 0 != dpl );
    SecByteBlock recovered( dpl );

    DecodingResult result = decryptor.Decrypt( rng, ciphertext, ciphertext.size(), recovered );

    // More sanity checks
    assert( result.isValidCoding );
    assert( result.messageLength &lt;= decryptor.MaxPlaintextLength( ciphertext.size() ) );

    // At this point, we can set the size of the recovered
    //  data. Until decryption occurs (successfully), we
    //  only know its maximum size
    recovered.resize( result.messageLength );

    // SecByteBlock is overloaded for proper results below
    assert( plaintext == recovered );

    // If the assert fires, we won't get this far.
    if(plaintext == recovered)
        cout &lt;&lt; ""Recovered plain text"" &lt;&lt; endl;
    else
        cout &lt;&lt; ""Failed to recover plain text"" &lt;&lt; endl;

    return !(plaintext == recovered);
}
</code></pre>

<p>You can also create the <code>Decryptor</code> from a <code>PrivateKey</code> like so:</p>

<pre><code>ElGamalKeys::PrivateKey k;
k.GenerateRandomWithKeySize(rng, 512);
ElGamal::Decryptor d(k);
...
</code></pre>

<p>And an <code>Encryptor</code> from a <code>PublicKey</code>:</p>

<pre><code>ElGamalKeys::PublicKey pk;
privateKey.MakePublicKey(pk);
ElGamal::Encryptor e(pk);
</code></pre>

<hr>

<p>You can save and load keys to and from disk as follows:</p>

<pre><code>ElGamalKeys::PrivateKey privateKey1;
privateKey1.GenerateRandomWithKeySize(prng, 2048);
privateKey1.Save(FileSink(""elgamal.der"", true /*binary*/).Ref());

ElGamalKeys::PrivateKey privateKey2;
privateKey2.Load(FileSource(""elgamal.der"", true /*pump*/).Ref());
privateKey2.Validate(prng, 3);

ElGamal::Decryptor decryptor(privateKey2);
// ...
</code></pre>

<p>The keys are ASN.1 encoded, so you can dump them with something like Peter Gutmann's <code>dumpasn1</code>:</p>

<pre><code>$ ./cryptopp-elgamal-keys.exe
Generating private key. This may take some time...
$ dumpasn1 elgamal.der 
  0 556: SEQUENCE {
  4 257:   INTEGER
       :     00 C0 8F 5A 29 88 82 8C 88 7D 00 AE 08 F0 37 AC
       :     FA F3 6B FC 4D B2 EF 5D 65 92 FD 39 98 04 C7 6D
       :     6D 74 F5 FA 84 8F 56 0C DD B4 96 B2 51 81 E3 A1
       :     75 F6 BE 82 46 67 92 F2 B3 EC 41 00 70 5C 45 BF
       :     40 A0 2C EC 15 49 AD 92 F1 3E 4D 06 E2 89 C6 5F
       :     0A 5A 88 32 3D BD 66 59 12 A1 CB 15 B1 72 FE F3
       :     2D 19 DD 07 DF A8 D6 4C B8 D0 AB 22 7C F2 79 4B
       :     6D 23 CE 40 EC FB DF B8 68 A4 8E 52 A9 9B 22 F1
       :             [ Another 129 bytes skipped ]
265   1:   INTEGER 3
268 257:   INTEGER
       :     00 BA 4D ED 20 E8 36 AC 01 F6 5C 9C DA 62 11 BB
       :     E9 71 D0 AB B7 E2 D3 61 37 E2 7B 5C B3 77 2C C9
       :     FC DE 43 70 AE AA 5A 3C 80 0A 2E B0 FA C9 18 E5
       :     1C 72 86 46 96 E9 9A 44 08 FF 43 62 95 BE D7 37
       :     F8 99 16 59 7D FA 3A 73 DD 0D C8 CA 19 B8 6D CA
       :     8D 8E 89 52 50 4E 3A 84 B3 17 BD 71 1A 1D 38 9E
       :     4A C4 04 F3 A2 1A F7 1F 34 F0 5A B9 CD B4 E2 7F
       :     8C 40 18 22 58 85 14 40 E0 BF 01 2D 52 B7 69 7B
       :             [ Another 129 bytes skipped ]
529  29:   INTEGER
       :     01 61 40 24 1F 48 00 4C 35 86 0B 9D 02 8C B8 90
       :     B1 56 CF BD A4 75 FE E2 8E 0B B3 66 08
       :   }

0 warnings, 0 errors.
</code></pre>
","5482","<c++><crypto++><elgamal>","3","2","1","2014-01-10 10:58:53","21035735","0","","608639","","2014-01-10 07:12:26","2013-11-14 10:02:10",""
"29467707","How to easily apply Crypto++ hash functions?","<p>Can someone help me how can I easily use hash functions from Crypto++ library?
I tried used these codes for SHA1 and MD5. I have many errors on line where is <code>StringSink</code>. The errors are like:</p>

<pre><code>undefined reference to `CryptoPP::StringSinkTemplate::StringSinkTemplate(std::string&amp;)'
</code></pre>

<p>Thanks for help.</p>

<pre><code> // SHA
CryptoPP::SHA1 sha1;
std::string source = ""Hello"";
std::string hash = """";
CryptoPP::StringSource(source, true, new CryptoPP::HashFilter(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(hash))));
std::cout &lt;&lt; hash;

// MD5
CryptoPP::MD5 hash;
byte digest[ CryptoPP::MD5::DIGESTSIZE ];
std::string message = ""abcdefghijklmnopqrstuvwxyz"";

hash.CalculateDigest( digest, (byte*) message.c_str(), message.length() );

CryptoPP::HexEncoder encoder;
std::string output;
encoder.Attach( new CryptoPP::StringSink( output ) );
encoder.Put( digest, sizeof(digest) );
encoder.MessageEnd();

std::cout &lt;&lt; output &lt;&lt; std::endl;
</code></pre>
","<blockquote>
  <p>I have many errors on line where is StringSink</p>
</blockquote>

<p>This line with the <code>StringSink</code> looks OK to me. You should provide the exact error  that you are encountering.</p>

<hr>

<blockquote>
  <p>Error on line with StringSink is: undefined reference to `CryptoPP::StringSinkTemplate::StringSinkTemplate(std::string&amp;)'</p>
</blockquote>

<p>Based on the additional information you provided, see <a href=""https://stackoverflow.com/questions/13872129/building-and-linking-test-code-for-crypto"">Building and linking test code for Crypto++</a></p>

<hr>

<blockquote>
  <p>How use easily apply Crypto++ hash functions?</p>
</blockquote>

<p>Below is from the Crypto++ wiki on the <a href=""http://www.cryptopp.com/wiki/ChannelSwitch"" rel=""nofollow noreferrer"">ChannelSwitch</a> class. Since you want MD5, you need to <code>#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1</code>, and then <code>#include &lt;cryptopp/md5.h&gt;</code>. After that, you can find MD5 in <code>Weak::MD5</code>.</p>

<pre><code>string message = ""Now is the time for all good men to come to the aide of their country"";
if(argc == 2 &amp;&amp; argv[1] != NULL)
    message = string(argv[1]);

string s1, s2, s3, s4;
SHA1 sha1; SHA224 sha224; SHA256 sha256; SHA512 sha512;

HashFilter f1(sha1, new HexEncoder(new StringSink(s1)));
HashFilter f2(sha224, new HexEncoder(new StringSink(s2)));
HashFilter f3(sha256, new HexEncoder(new StringSink(s3)));
HashFilter f4(sha512, new HexEncoder(new StringSink(s4)));

ChannelSwitch cs;
cs.AddDefaultRoute(f1);
cs.AddDefaultRoute(f2);
cs.AddDefaultRoute(f3);
cs.AddDefaultRoute(f4);

StringSource ss(message, true /*pumpAll*/, new Redirector(cs));

cout &lt;&lt; Message: "" &lt;&lt; message &lt;&lt; endl;
cout &lt;&lt; ""SHA-1: "" &lt;&lt; s1 &lt;&lt; endl;
cout &lt;&lt; ""SHA-224: "" &lt;&lt; s2 &lt;&lt; endl;
cout &lt;&lt; ""SHA-256: "" &lt;&lt; s3 &lt;&lt; endl;
cout &lt;&lt; ""SHA-512: "" &lt;&lt; s4 &lt;&lt; endl;
</code></pre>

<p>A run of the program produces the results shown below:</p>

<pre><code>$ ./cryptopp-test.exe password
Message: password
SHA-1: 5BAA61E4C9B93F3F0682250B6CF8331B7EE68FD8
SHA-224: D63DC919E201D7BC4C825630D2CF25FDC93D4B2F0D46706D29038D01
SHA-256: 5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8
SHA-512: B109F3BBBC244EB82441917ED06D618B9008DD09B3BEFD1B5E07394C706A8BB9
         80B1D7785E5976EC049B46DF5F1326AF5A2EA6D103FD07C95385FFAB0CACBC86
</code></pre>
","5428","<c++><windows><md5><sha1><crypto++>","2","2","1","2015-04-09 18:04:12","29474173","0","1","608639","","2015-04-09 18:04:12","2015-04-06 08:18:28",""
"8015495","Using CryptoPP::Base64Encoder on binary data (ciphertext)","<p>I have an issue using CryptoPP. I'm using AES, and am wanting to represent the binary ciphertext by encoding it to base64.</p>

<p>My problem is that I am randomly getting assertion errors when running the following code:</p>

<pre><code>std::string encoded;
// ciphertext is of type std::string from AES
CryptoPP::StringSource(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>

<p>The specific assertion error is:</p>

<pre><code>Assertion failed: m_allocated, file include\cryptopp\secblock.h, line 197
</code></pre>

<p>Because of this ""random"" behavior, it's leading me to believe that the issue lies within the contents of the ciphertext.</p>

<p>My question is: Am I doing this the correct way? I've been stumped for a while, and have been researching a bit without success. The closest thing I can find is: <a href=""http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html"" rel=""nofollow"">http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html</a></p>

<p>My complete implementation is:</p>

<pre><code>std::string key = ""key"";
std::string in = ""This is a secret message."";

CryptoPP::SHA1 sha;

byte digest[CryptoPP::SHA1::DIGESTSIZE];
sha.CalculateDigest(digest, reinterpret_cast&lt;const byte *&gt;(key.c_str()), key.length());

byte iv[CryptoPP::AES::BLOCKSIZE];
memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);

CryptoPP::AES::Encryption encrypt(reinterpret_cast&lt;const byte *&gt;(digest), CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbc_encrypt(encrypt, iv);

std::string ciphertext;
CryptoPP::StreamTransformationFilter encryptor(cbc_encrypt,
    new CryptoPP::StringSink(ciphertext));
encryptor.Put(reinterpret_cast&lt;const unsigned char *&gt;(in.c_str()), in.length() + 1);
encryptor.MessageEnd();

std::string encoded;
CryptoPP::StringSource(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>
","<p>Your intend is a bit unclear at the moment.
Why would you like to use the SHA digest as the key for the AES encryption?</p>

<p>And about the error in your code,</p>

<p>Your cipher at the end is a string. And if want to communicate it to somebody
you can readily send it.
Why did you use a Base 64 encoder at the end of your code ?
Had your cipher text been in the binary form you could have used Base64 Encoder
to convert it into the ASCII String format.
As long as it is not, you don't need the following part in your code.</p>

<pre><code>std::string encoded;
StringSource(ciphertext, true, new Base64Encoder(new StringSink(encoded)));
</code></pre>
","5280","<c++><base64><crypto++>","3","1","2","2013-10-04 06:38:37","19174866","2","2","608639","","2013-10-04 06:22:08","2011-11-04 20:42:48",""
"8015495","Using CryptoPP::Base64Encoder on binary data (ciphertext)","<p>I have an issue using CryptoPP. I'm using AES, and am wanting to represent the binary ciphertext by encoding it to base64.</p>

<p>My problem is that I am randomly getting assertion errors when running the following code:</p>

<pre><code>std::string encoded;
// ciphertext is of type std::string from AES
CryptoPP::StringSource(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>

<p>The specific assertion error is:</p>

<pre><code>Assertion failed: m_allocated, file include\cryptopp\secblock.h, line 197
</code></pre>

<p>Because of this ""random"" behavior, it's leading me to believe that the issue lies within the contents of the ciphertext.</p>

<p>My question is: Am I doing this the correct way? I've been stumped for a while, and have been researching a bit without success. The closest thing I can find is: <a href=""http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html"" rel=""nofollow"">http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html</a></p>

<p>My complete implementation is:</p>

<pre><code>std::string key = ""key"";
std::string in = ""This is a secret message."";

CryptoPP::SHA1 sha;

byte digest[CryptoPP::SHA1::DIGESTSIZE];
sha.CalculateDigest(digest, reinterpret_cast&lt;const byte *&gt;(key.c_str()), key.length());

byte iv[CryptoPP::AES::BLOCKSIZE];
memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);

CryptoPP::AES::Encryption encrypt(reinterpret_cast&lt;const byte *&gt;(digest), CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbc_encrypt(encrypt, iv);

std::string ciphertext;
CryptoPP::StreamTransformationFilter encryptor(cbc_encrypt,
    new CryptoPP::StringSink(ciphertext));
encryptor.Put(reinterpret_cast&lt;const unsigned char *&gt;(in.c_str()), in.length() + 1);
encryptor.MessageEnd();

std::string encoded;
CryptoPP::StringSource(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>
","<blockquote>
  <p>My question is: Am I doing this the correct way?</p>
</blockquote>

<p>Yes, the code is fine (except for the <code>digest.erase();</code>).</p>

<hr>

<blockquote>
  <p>I've been stumped for a while, and have been researching a bit without success.</p>
</blockquote>

<p>Run it under a memory checker. Valgrind or Clang Asan (address sanitizer).</p>

<hr>

<blockquote>
  <p>The closest thing I can find is: <a href=""http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html"" rel=""nofollow"">http://www.mail-archive.com/cryptopp-users@googlegroups.com/msg06053.html</a></p>
</blockquote>

<p>I've come across that assertion in the past, too. I don't recall if it was iOS or Linux. I think it was Linux with a specific version of GCC (maybe 4.4 or 4.5).</p>

<hr>

<blockquote>
  <p>My problem is that I am randomly getting assertion errors when running the following code:</p>
</blockquote>

<pre><code>CryptoPP::StringSource(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>

<p>Change the above to this:</p>

<pre><code>CryptoPP::StringSource ss(ciphertext, true, 
    new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));
</code></pre>

<p>One version of GCC had problems with anonymous declarations. It would start running object destructors too soon.</p>
","5280","<c++><base64><crypto++>","3","1","2","2013-10-04 06:38:37","19174866","2","2","608639","","2013-10-04 06:22:08","2011-11-04 20:42:48",""
"27244449","Crypto++ pbkdf2 output is different than Rfc2898DeriveBytes (C#) and crypto.pbkdf2 (JavaScript)","<p>So I'm trying to use PBKDF2 to derive a key given a base64 string of 256bits. I am able to use C#'s Rfc2898DeriveBytes and node-crypto's pbkdf2 to derive the same key, however, I can't say the same for C++. I'm not sure if I'm doing wrong conversions or using the functions improperly, but I'll let you guys look at it.</p>

<p>C++</p>

<pre><code>/* 256bit key */
string key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="";
string decodedKey;
StringSource(key, true, new Base64Decoder(new StringSink(decodedKey)));
const byte* keyByte = (const byte*) decodedKey.data();

/* Generate IV */
/*
    AutoSeededRandomPool prng;
    byte iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
*/

/* FOR TESTING PURPOSES, HARDCODE IV */
string iv = ""5iFv54dCRq5icQbD7QHQzg=="";
string decodedIv;
StringSource(iv, true, new Base64Decoder(new StringSink(decodedIv)));
const byte* ivByte = (const byte *) decodedIv.data();

byte derivedKey[32];
PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
pbkdf2.DeriveKey(derivedKey, 32, 0, keyByte, 32, ivByte, 16, 100);

/* 
 * derivedKey: 9tRyXCoQLTbUOLqm3M4OPGT6N25g+o0K090fVp/hflk=
 */
</code></pre>

<p>C#</p>

<pre><code>// string key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""; // need to convert it to byte data
string key = Convert.FromBase64String(""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""); // change above to this
RijndaelManaged symKey = new RijndaelManaged();
symKey.GenerateIV(); /* Assume hardcoded IV same as above */
Rfc2898DeriveBytes derivedKey = new Rfc2898DeriveBytes (key, symKey.IV, 100);

/*
 * derivedKey: dZqBpZKyUPKn8pU4pyyeAw7Rg8uYd6yyj3WI1MIJSyc=
 */
</code></pre>

<p>JS</p>

<pre><code>// var key = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ=""; // need to convert it to byte data
var key = new Buffer(""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="", ""base64""); // changed above to this
var iv = crypto.randomBytes(16);
iv = ""5iFv54dCRq5icQbD7QHQzg==""; /* HARDCODE IV */
crypto.pbkdf2(key, iv, 100, 32, function(err, derivedKey) { }

/*
 * derivedKey: dZqBpZKyUPKn8pU4pyyeAw7Rg8uYd6yyj3WI1MIJSyc=
 */
</code></pre>

<blockquote>
  <p>Well the main questions is, what am I doing wrong on C++'s CryptoPP
  library that it is not deriving the same value.</p>
</blockquote>

<p><strong>SOLUTION: I was being dumb... I realized after review my original implementation on JavaScript and C# I missed a crucial step that for some reason I did not get a complain from the compiler. Basically the problem was that I did not convert the key used into byte data before the algorithm on my C# and JS implementation...</strong></p>

<p><strong>Anyways, proposed solution is: do not code at 4 AM and make sure to be consistent on your data conversion...</strong></p>

<p><strong>I guess the TL;DR of this is that C# and JS was converting my 256bit key to byte data as ASCII instead of base64 conversion.</strong></p>
","<blockquote>
  <p>Well the main questions is, what am I doing wrong on C++'s CryptoPP library that it is not deriving the same value.</p>
</blockquote>

<p>Well, I don't think you are doing anything wrong in C++ with Crypto++ and PBKDF2. I think the other libraries are setting up the parameters differently, or they are a tad-bit non-standard.</p>

<p>I was able to arrive at the IETF's <a href=""http://www.ietf.org/rfc/rfc6070.txt"" rel=""nofollow"">test vectors for PBKDF2</a> using Crypto++:</p>

<pre><code>// From https://www.ietf.org/rfc/rfc6070.txt
//   PKCS #5: Password-Based Key Derivation Function 2 (PBKDF2) Test Vectors
//
//      Input:
//       P = ""password"" (8 octets)
//       S = ""salt"" (4 octets)
//       c = 1
//       dkLen = 20
//
//     Output:
//       DK = 0c 60 c8 0f 96 1f 0e 71
//            f3 a9 b5 24 af 60 12 06
//            2f e0 37 a6    (20 octets)

int main(int argc, char* argv[])
{
    byte password[] =""password"";
    size_t plen = strlen((const char*)password);

    byte salt[] = ""salt"";
    size_t slen = strlen((const char*)salt);

    int c = 1;
    byte derived[20];

    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
    pbkdf2.DeriveKey(derived, sizeof(derived), 0, password, plen, salt, slen, c);

    string result;
    HexEncoder encoder(new StringSink(result));

    encoder.Put(derived, sizeof(derived));
    encoder.MessageEnd();

    cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>And a run of the program:</p>

<pre><code>$ ./cryptopp-test.exe
Derived: 0C60C80F961F0E71F3A9B524AF6012062FE037A6
</code></pre>

<hr>

<p>I think the first thing you should do is verify the C# and Javascript implementations are using the same character encoding as Crypto++ and the IETF.</p>

<p>If that's not it, then check to see if C# and Javascript use the purpose byte. Crypto++ does not, and you can see the implementation at <a href=""http://www.cryptopp.com/docs/ref/pwdbased_8h_source.html"" rel=""nofollow"">pwdbased.h</a>.</p>

<hr>

<p>Unfortunately, I get something a little different when I dial in your parameters:</p>

<pre><code>int main(int argc, char* argv[])
{
    string t1 = ""Y1Mjycd0+O+AendY5pB58JMlmS0EmBWgjdj2r2KW6qQ="";
    string t2 = ""5iFv54dCRq5icQbD7QHQzg=="";

    string pw, iv;

    Base64Decoder b1(new StringSink(pw));
    b1.Put((const byte*)t1.data(), t1.size());
    b1.MessageEnd();

    Base64Decoder b2(new StringSink(iv));
    b2.Put((const byte*)t2.data(), t2.size());
    b2.MessageEnd();

    int c = 100;
    byte derived[32];

    cout &lt;&lt; ""pw size: "" &lt;&lt; pw.size() &lt;&lt; endl;
    cout &lt;&lt; ""iv size: "" &lt;&lt; iv.size() &lt;&lt; endl;

    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
    pbkdf2.DeriveKey(derived, sizeof(derived), 0, (byte*)pw.data(), pw.size(), (byte*)iv.data(), iv.size(), c);

    string result;
    HexEncoder encoder(new StringSink(result));

    encoder.Put(derived, sizeof(derived));
    encoder.MessageEnd();

    cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>A run results in:</p>

<pre><code>$ ./cryptopp-test.exe
pw size: 32
iv size: 16
Derived: F6D4725C2A102D36D438BAA6DCCE0E3C64FA376E60FA8D0AD3DD1F569FE17E59
</code></pre>
","5077","<c++><rijndael><crypto++><pbkdf2><hmacsha1>","6","3","1","2019-07-08 07:41:42","27261798","2","1","4314646","","2014-12-03 09:20:24","2014-12-02 07:58:32",""
"18085474","howto compile cryptopp 5.6.2 with mingw","<p>I am trying to build cryptopp 5.6.1 with mingw 4.8.1 (sjlj). I've changed GNUMakefile from <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">Crypto++ &amp; MinGW</a></p>

<p>But there are several issue:</p>

<ul>
<li>I've compile error if I try to build it as shared library;</li>
<li>On my machine it works (intel i5 (2nd generation) with Windows 7 ) but on Windows Xp on an Intel atom D2500 an error occured (no entry point for memmove_s in msvcrt.dll )</li>
</ul>

<p>When I try to build as shared library I've the following error:</p>

<pre><code>make dll
make: *** No rule to make target 'cryptopp.dll', needed by 'cryptest.import.exe'. Stop.
make libcryptopp.dll
// ...
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hex.cpp -o hex.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hmac.cpp -o hmac.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c integer.cpp -o integer.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c iterhash.cpp -o iterhash.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c misc.cpp -o misc.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c modes.cpp -o modes.export.o
make: *** No rule to make target 'modexppc.export.o', needed by 'libcryptopp.dll'.  Stop.
</code></pre>

<p>Does someone has compiled succeful crypto++ with mingw 4.8.1? This is the snippet of my makefile:</p>

<pre><code>CXXFLAGS = -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3
ARFLAGS = rc
LDLIBS += -lws2_32
LDFLAGS =
MKDIR = mkdir
CP = copy

SRCS = $(wildcard *.cpp)

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

lib: libcryptopp.a

all: cryptest.exe

test: cryptest.exe
    cryptest.exe v

install: lib
    $(CP) *.h include\cryptopp
    $(CP) *.a lib

clean:
    del cryptest.exe libcryptopp.a $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTIMPORTOBJS) $(DLLTESTOBJS)

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)

libcryptopp.so: $(LIBOBJS)
    $(CXX) -shared -o $@ $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) -L. -lcryptopp $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

libcryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>

<p><b> Edit </b></p>

<p>To let it work I've forced the funcion memmove_s defined in misc.h (of cryptopp) to be defined inlined and now works also on windows xp (where memmove_s is not defined in msvcrt.dll).</p>

<p><b>Question:</b> Can I change the mscvrt.dll of windows xp with one defined on Windows 7?</p>
","<p>it's a try</p>

<p>put <code>modexppc.cpp</code> to your  CRYPTOPP folder.</p>

<p>modexppc.cpp</p>

<pre><code>// modexppc.cpp - written and placed in the public domain by Wei Dai

#include ""pch.h""

#ifndef CRYPTOPP_IMPORTS

#include ""modexppc.h""
#include ""asn.h""
NAMESPACE_BEGIN(CryptoPP)


NAMESPACE_END

#endif
</code></pre>
","4904","<c++><windows-xp><mingw><shared-libraries><crypto++>","3","1","3","2014-08-02 10:47:52","18146341","0","","1266688","","2013-08-07 13:02:50","2013-08-06 16:22:14",""
"18085474","howto compile cryptopp 5.6.2 with mingw","<p>I am trying to build cryptopp 5.6.1 with mingw 4.8.1 (sjlj). I've changed GNUMakefile from <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">Crypto++ &amp; MinGW</a></p>

<p>But there are several issue:</p>

<ul>
<li>I've compile error if I try to build it as shared library;</li>
<li>On my machine it works (intel i5 (2nd generation) with Windows 7 ) but on Windows Xp on an Intel atom D2500 an error occured (no entry point for memmove_s in msvcrt.dll )</li>
</ul>

<p>When I try to build as shared library I've the following error:</p>

<pre><code>make dll
make: *** No rule to make target 'cryptopp.dll', needed by 'cryptest.import.exe'. Stop.
make libcryptopp.dll
// ...
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hex.cpp -o hex.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hmac.cpp -o hmac.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c integer.cpp -o integer.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c iterhash.cpp -o iterhash.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c misc.cpp -o misc.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c modes.cpp -o modes.export.o
make: *** No rule to make target 'modexppc.export.o', needed by 'libcryptopp.dll'.  Stop.
</code></pre>

<p>Does someone has compiled succeful crypto++ with mingw 4.8.1? This is the snippet of my makefile:</p>

<pre><code>CXXFLAGS = -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3
ARFLAGS = rc
LDLIBS += -lws2_32
LDFLAGS =
MKDIR = mkdir
CP = copy

SRCS = $(wildcard *.cpp)

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

lib: libcryptopp.a

all: cryptest.exe

test: cryptest.exe
    cryptest.exe v

install: lib
    $(CP) *.h include\cryptopp
    $(CP) *.a lib

clean:
    del cryptest.exe libcryptopp.a $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTIMPORTOBJS) $(DLLTESTOBJS)

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)

libcryptopp.so: $(LIBOBJS)
    $(CXX) -shared -o $@ $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) -L. -lcryptopp $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

libcryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>

<p><b> Edit </b></p>

<p>To let it work I've forced the funcion memmove_s defined in misc.h (of cryptopp) to be defined inlined and now works also on windows xp (where memmove_s is not defined in msvcrt.dll).</p>

<p><b>Question:</b> Can I change the mscvrt.dll of windows xp with one defined on Windows 7?</p>
","<p>A way to build it is using qmake:</p>

<ul>
<li>I removed GNUMakefile,</li>
<li>qmake -project</li>
<li>I open the pro file into QtCreator, changed <code>TEMPLATE</code> to <code>lib</code> and added ws2_32 to lib</li>
</ul>

<p>The pro file now looks something this</p>

<pre><code>TEMPLATE = lib
INCLUDEPATH += .
CONFIG -= qt
HEADERS += ...
SOURCES += ...

win32-g++ {
    QMAKE_CXXFLAGS += -msse -msse2 -msse3 -mssse3
    LIBS += -lws2_32
}
</code></pre>

<p>It seems work.</p>
","4904","<c++><windows-xp><mingw><shared-libraries><crypto++>","3","4","3","2014-08-02 10:47:52","18146341","0","","1266688","","2013-08-07 13:02:50","2013-08-06 16:22:14",""
"18085474","howto compile cryptopp 5.6.2 with mingw","<p>I am trying to build cryptopp 5.6.1 with mingw 4.8.1 (sjlj). I've changed GNUMakefile from <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">Crypto++ &amp; MinGW</a></p>

<p>But there are several issue:</p>

<ul>
<li>I've compile error if I try to build it as shared library;</li>
<li>On my machine it works (intel i5 (2nd generation) with Windows 7 ) but on Windows Xp on an Intel atom D2500 an error occured (no entry point for memmove_s in msvcrt.dll )</li>
</ul>

<p>When I try to build as shared library I've the following error:</p>

<pre><code>make dll
make: *** No rule to make target 'cryptopp.dll', needed by 'cryptest.import.exe'. Stop.
make libcryptopp.dll
// ...
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hex.cpp -o hex.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c hmac.cpp -o hmac.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c integer.cpp -o integer.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c iterhash.cpp -o iterhash.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c misc.cpp -o misc.export.o
g++ -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3 -DCRYPTOPP_EXPORTS -c modes.cpp -o modes.export.o
make: *** No rule to make target 'modexppc.export.o', needed by 'libcryptopp.dll'.  Stop.
</code></pre>

<p>Does someone has compiled succeful crypto++ with mingw 4.8.1? This is the snippet of my makefile:</p>

<pre><code>CXXFLAGS = -std=c++11 -DNDEBUG -O3 -m32 -msse2 -msse3 -mssse3
ARFLAGS = rc
LDLIBS += -lws2_32
LDFLAGS =
MKDIR = mkdir
CP = copy

SRCS = $(wildcard *.cpp)

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

lib: libcryptopp.a

all: cryptest.exe

test: cryptest.exe
    cryptest.exe v

install: lib
    $(CP) *.h include\cryptopp
    $(CP) *.a lib

clean:
    del cryptest.exe libcryptopp.a $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTIMPORTOBJS) $(DLLTESTOBJS)

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)

libcryptopp.so: $(LIBOBJS)
    $(CXX) -shared -o $@ $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) -L. -lcryptopp $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

libcryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>

<p><b> Edit </b></p>

<p>To let it work I've forced the funcion memmove_s defined in misc.h (of cryptopp) to be defined inlined and now works also on windows xp (where memmove_s is not defined in msvcrt.dll).</p>

<p><b>Question:</b> Can I change the mscvrt.dll of windows xp with one defined on Windows 7?</p>
","<p>I sent a <a href=""http://sourceforge.net/p/mingw-w64/mingw-w64/ci/ec1ff7764fbea4eefbb290c9ba888af3386ede8e/"" rel=""nofollow"">patch</a> fixing memmove_s in Windows XP to the MinGW developer team. It's been accepted and it will soon appear in the newer MinGW builds. By now it should be available on the CentOS 7 MinGW distribution and Fedora 21 MinGW.</p>

<p>Crypto++ 5.6.2 now builds fine without modification on MinGW, using make (and setting CC, CXX and PATH environment variables correctly). Tested on CentOS 7, which uses MinGW 4.9 IIRC.</p>
","4904","<c++><windows-xp><mingw><shared-libraries><crypto++>","3","1","3","2014-08-02 10:47:52","18146341","0","","1266688","","2013-08-07 13:02:50","2013-08-06 16:22:14",""
"43864159","'mutex' is not a member of 'std' in MinGW 5.3.0","<p>I am using MinGW 5.3.0 and Crypto++ 5.6.5:</p>

<pre><code>C:\MinGW&gt;g++ -std=c++11 -s -D_WIN32_WINNT=0x0501 LOG.cpp -U__STRICT_ANSI__ Decclass.cpp \
-IC:\\MinGW\\ -IC:\\MinGW\\boost -LC:\\MinGW  -lssl -lcrypto -lcryptopp -lgdi32 -lPCRYPT \
 -lz -ltiny -lwsock32 -lws2_32 -lShlwapi
</code></pre>

<p>Compiling results in the error below.</p>

<pre><code>c:\mingw\cryptopp565\include\cryptopp\misc.h:287:14: error: 'mutex' in namespace 'std'
does not name a typestatic std::mutex s_mutex;

c:\mingw\cryptopp565\include\cryptopp\misc.h:296:18: error: 'mutex' is not a member of
'std'std::lock_guard&lt;std::mutex&gt; lock(s_mutex);
</code></pre>

<p><a href=""https://i.stack.imgur.com/bpaBT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bpaBT.png"" alt=""enter image description here""></a></p>

<p>It showing <strong>'mutex' is not a member of 'std'</strong> </p>

<p>Do i need anther version of MinGW ? 
Or can I fix this build itself?    </p>
","<p>I fix this issue by editing <strong>""misc.h""</strong> in the path ""cryptopp565\include\cryptopp\misc.h""</p>

<p>On the top of <strong>misc.h</strong> I included the <strong>mutex.hpp</strong> from <strong>boost library</strong> </p>

<pre><code>#include ""c:\mingw\include\boost\asio\detail\mutex.hpp""
</code></pre>

<p>and i changed namespace also from <strong>std</strong> to <strong>boost::asio::detail</strong>  </p>

<pre><code>static std::mutex s_mutex; 
static boost::asio::detail::mutex s_mutex;
</code></pre>
","4662","<c++><c++11><mingw><mutex><crypto++>","5","3","2","2018-10-25 14:58:38","43892719","8","","5675325","","2018-10-25 11:03:19","2017-05-09 07:51:25",""
"43864159","'mutex' is not a member of 'std' in MinGW 5.3.0","<p>I am using MinGW 5.3.0 and Crypto++ 5.6.5:</p>

<pre><code>C:\MinGW&gt;g++ -std=c++11 -s -D_WIN32_WINNT=0x0501 LOG.cpp -U__STRICT_ANSI__ Decclass.cpp \
-IC:\\MinGW\\ -IC:\\MinGW\\boost -LC:\\MinGW  -lssl -lcrypto -lcryptopp -lgdi32 -lPCRYPT \
 -lz -ltiny -lwsock32 -lws2_32 -lShlwapi
</code></pre>

<p>Compiling results in the error below.</p>

<pre><code>c:\mingw\cryptopp565\include\cryptopp\misc.h:287:14: error: 'mutex' in namespace 'std'
does not name a typestatic std::mutex s_mutex;

c:\mingw\cryptopp565\include\cryptopp\misc.h:296:18: error: 'mutex' is not a member of
'std'std::lock_guard&lt;std::mutex&gt; lock(s_mutex);
</code></pre>

<p><a href=""https://i.stack.imgur.com/bpaBT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/bpaBT.png"" alt=""enter image description here""></a></p>

<p>It showing <strong>'mutex' is not a member of 'std'</strong> </p>

<p>Do i need anther version of MinGW ? 
Or can I fix this build itself?    </p>
","<p>I think we may have mostly cleared this MinGW/C++11 issue at cryptopp <a href=""https://github.com/weidai11/cryptopp/commit/e4cef84883b2"" rel=""nofollow noreferrer"">Commit e4cef84883b2</a>. You should work from Master or perform a <code>git pull</code>, and then uncomment the define for <code>CRYPTOPP_NO_CXX11</code> in <a href=""https://github.com/weidai11/cryptopp/blob/master/config.h#L57"" rel=""nofollow noreferrer""><code>config.h</code> : 65</a> (or so):</p>

<pre><code>// Define CRYPTOPP_NO_CXX11 to avoid C++11 related features shown at the
// end of this file. Some compilers and standard C++ headers advertise C++11
// but they are really just C++03 with some additional C++11 headers and
// non-conforming classes. You might also consider `-std=c++03` or
// `-std=gnu++03`, but they are required options when building the library
// and all programs. CRYPTOPP_NO_CXX11 is probably easier to manage but it may
// cause -Wterminate warnings under GCC. MSVC++ has a similar warning.
// Also see https://github.com/weidai11/cryptopp/issues/529
// #define CRYPTOPP_NO_CXX11 1
</code></pre>

<p>I think the problems is, you are hitting issues related to Windows and its lack of proper C++11 support, but you are getting them indirectly. They are indirect because MinGW and GCC is layered on top. MinGW and GCC cannot possibly provide C++11 because the underlying platform cannot.</p>

<p>I think your best bet at this point is to define <code>CRYPTOPP_NO_CXX11</code>. I don't believe we can do it for you like we do on Windows because the defines we need access to are hidden behind MinGW and GCC. And we also have some MSVC++ bugs to workaround.</p>

<p>Here's how we do it on Windows, but we don't have access to these defines in MinGW (from <code>config.h</code> : 950):</p>

<pre><code>// Dynamic Initialization and Destruction with Concurrency (""Magic Statics"")
// MS at VS2015 with Vista (19.00); GCC at 4.3; LLVM Clang at 2.9; Apple Clang at 4.0; Intel 11.1; SunCC 5.13.
// Microsoft's implementation only works for Vista and above, so its further
// limited. http://connect.microsoft.com/VisualStudio/feedback/details/1789709
#if (CRYPTOPP_MSC_VERSION &gt;= 1900) &amp;&amp; ((WINVER &gt;= 0x0600) || (_WIN32_WINNT &gt;= 0x0600)) || \
    (CRYPTOPP_LLVM_CLANG_VERSION &gt;= 20900) || (CRYPTOPP_APPLE_CLANG_VERSION &gt;= 40000) || \
    (__INTEL_COMPILER &gt;= 1110) || (CRYPTOPP_GCC_VERSION &gt;= 40300) || (__SUNPRO_CC &gt;= 0x5130)
# define CRYPTOPP_CXX11_DYNAMIC_INIT 1
#endif // Dynamic Initialization compilers
</code></pre>

<p>If you define <code>CRYPTOPP_NO_CXX11</code>, then the following will <em>not</em> be defined and you will avoid the problems: <code>CRYPTOPP_CXX11_DYNAMIC_INIT</code>, <code>CRYPTOPP_CXX11_SYNCHRONIZATION</code>, and <code>CRYPTOPP_CXX11_ATOMICS</code>.</p>
","4662","<c++><c++11><mingw><mutex><crypto++>","5","-1","2","2018-10-25 14:58:38","43892719","8","","5675325","","2018-10-25 11:03:19","2017-05-09 07:51:25",""
"42817362","Encrypt/Decrypt byte array Crypto++","<p>I am trying to encrypt a byte array using AES. I have been able to encrypt strings and files no problem, however byte arrays seem to not be working for me. I pass in a byte array to be encrypted, for ease of testing I just pass in a generated AES key by crypto++ (bArrayToEncrypt). The encryption appears to be working but then the decryption does work at all. I also found it strange that the encryption has a large amount of duplicate characters. What I am doing wrong here??</p>

<p>I saw a similar question <a href=""https://stackoverflow.com/questions/19814236/how-to-encrypt-a-byte-array-with-crypto"">Here</a>, but it was pertaining to RSA
 as well as the example provided encrypts strings which I already have up a running. </p>

<h2>How functions are called:</h2>

<pre class=""lang-cpp prettyprint-override""><code>   size_t ksize = CryptoPP::AES::MAX_KEYLENGTH;
   size_t vsize = CryptoPP::AES::BLOCKSIZE;

   byte key[ksize];
   byte testArray[ksize];
   byte encryptedksize];
   byte decrypted[ksize];
   byte iv[vsize];

   //generate key &amp; iv, then generate a random byte array to encrypt/decrypt
   CryptoPP::AutoSeededRandomPool prng;
   prng.GenerateBlock(key, ksize);
   prng.GenerateBlock(iv, vsize);
   prng.GenerateBlock(testArray, ksize);


   encrypt_barray(key, ksize, iv, vsize, testArray, ksize, encrypted);

   //printed results here

   decrypt_barray(key, ksize, iv, vsize, encrypted, ksize, decrypted);

   //printed results here
</code></pre>

<h2>Encrypt_barray</h2>

<pre class=""lang-cpp prettyprint-override""><code>void encrypt_barray(byte* key, 
                    size_t kSize,
                    byte* iv, 
                    size_t ivSize, 
                    byte* bArrayToEncrypt,
                    size_t bArraySize,
                    byte* encrypted) {

   CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption e;
   e.SetKeyWithIV(key, kSize, iv, ivSize);

   CryptoPP::ArraySource(key, true,
      new CryptoPP::StreamTransformationFilter(e, new CryptoPP::ArraySink(encrypted, bArraySize)));
}
</code></pre>

<h2>Decrypt_barray</h2>

<pre class=""lang-cpp prettyprint-override""><code>void decrypt_barray(byte* key,
                    size_t kSize,
                    byte* iv,
                    size_t ivSize,
                    byte* bArrayToDecrypt,
                    size_t bArraySize,
                    byte* decrypted) {

   CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption d;
   d.SetKeyWithIV(keyFromHash, kfhSize, iv1, iv1Size);

   CryptoPP::ArraySource(keyToDecrypt, true,
      new CryptoPP::StreamTransformationFilter(d, new CryptoPP::ArraySink(decrypted, bArraySize)));
}
</code></pre>

<h2>Output:</h2>

<pre><code> Encrypted: ╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠E1A2AFC5D820ADF7
7DB656DEF3245570╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╨Ñ♫

Decrypted: ╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠E
1A2AFC5D820ADF77DB656DEF3245570╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠
╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╨Ñ♫
Press any key to continue . . .
</code></pre>
","<p>Here's the way to do things using <code>ArraySource</code> and <code>ArraySink</code>. The <code>Redirector</code> ensures the <code>ArraySink</code> survives so you can call <code>TotalPutLength</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""modes.h""
#include ""hex.h""
#include ""aes.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  byte key[AES::MAX_KEYLENGTH];
  byte iv[AES::BLOCKSIZE];
  vector&lt;byte&gt; plain, cipher, recover;
  HexEncoder encoder(new FileSink(cout));

  memset(key, 0x00, sizeof(key));
  memset(iv, 0x00, sizeof(iv));

  string str(""Attack at dawn!"");
  std::copy(str.begin(), str.end(), std::back_inserter(plain));

  cout &lt;&lt; ""Plain text: "";
  encoder.Put(plain.data(), plain.size());
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  /////////////////////////////////////////////////////////////

  CBC_Mode&lt;AES&gt;::Encryption enc;
  enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

  // Make room for padding
  cipher.resize(plain.size()+AES::BLOCKSIZE);
  ArraySink cs(&amp;cipher[0], cipher.size());

  ArraySource(plain.data(), plain.size(), true,
    new StreamTransformationFilter(enc, new Redirector(cs)));

  // Set cipher text length now that its known
  cipher.resize(cs.TotalPutLength());

  cout &lt;&lt; ""Cipher text: "";
  encoder.Put(cipher.data(), cipher.size());
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  /////////////////////////////////////////////////////////////

  CBC_Mode&lt;AES&gt;::Decryption dec;
  dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

  // Recovered text will be less than cipher text
  recover.resize(cipher.size());
  ArraySink rs(&amp;recover[0], recover.size());

  ArraySource(cipher.data(), cipher.size(), true,
    new StreamTransformationFilter(dec, new Redirector(rs)));

  // Set recovered text length now that its known
  recover.resize(rs.TotalPutLength());

  cout &lt;&lt; ""Recovered text: "";
  encoder.Put(recover.data(), recover.size());
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Running the program results in:</p>

<pre><code>$ ./test.exe
Plain text: 41747461636B206174206461776E21
Cipher text: 85928E5511BFE9E6EE235BCACC4894D4
Recovered text: 41747461636B206174206461776E21
</code></pre>

<hr>

<p>Here's the example using <code>ByteQueue</code>. The <code>Redirector</code> helps chain the pipeline together because a <code>ByteQueue</code> is a <code>BufferedTransformation</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;

#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""modes.h""
#include ""queue.h""
#include ""hex.h""
#include ""aes.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  byte key[AES::MAX_KEYLENGTH];
  byte iv[AES::BLOCKSIZE];
  HexEncoder encoder(new FileSink(cout));

  memset(key, 0x00, sizeof(key));
  memset(iv, 0x00, sizeof(iv));

  ByteQueue plain, cipher, recover;
  string str(""Attack at dawn!"");
  plain.Put(reinterpret_cast&lt;const byte*&gt;(str.data()), str.size());

  cout &lt;&lt; ""Plain text: "";
  plain.CopyTo(encoder);
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  /////////////////////////////////////////////////////////////

  CBC_Mode&lt;AES&gt;::Encryption enc;
  enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

  StreamTransformationFilter f1(enc, new Redirector(cipher));
  plain.CopyTo(f1);
  f1.MessageEnd();

  cout &lt;&lt; ""Cipher text: "";
  cipher.CopyTo(encoder);
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  /////////////////////////////////////////////////////////////

  CBC_Mode&lt;AES&gt;::Decryption dec;
  dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

  StreamTransformationFilter f2(dec, new Redirector(recover));
  cipher.CopyTo(f2);
  f2.MessageEnd();

  cout &lt;&lt; ""Recovered text: "";
  recover.CopyTo(encoder);
  encoder.MessageEnd();
  cout &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>It also results in:</p>

<pre><code>skylake:cryptopp$ ./test.exe
Plain text: 41747461636B206174206461776E21
Cipher text: 85928E5511BFE9E6EE235BCACC4894D4
Recovered text: 41747461636B206174206461776E21
</code></pre>
","4565","<c++><encryption><crypto++>","2","3","1","2017-03-15 20:37:28","42820221","6","2","-1","","2017-05-23 12:25:17","2017-03-15 18:01:05",""
"12187689","Crypto++ to PHP mcrypt not working","<p>I have a C++ application that's using Crypto++ to send encrypted data to a PHP site.  However, when the data's getting to the PHP side, it's not decrypting the data properly.</p>

<p>The C++ / Crypto++ code:</p>

<pre><code>char stupidKey[AES::MAX_KEYLENGTH] = ""thisisastupidkeythisisastupidke"";

ECB_Mode&lt;AES&gt;::Encryption aes((byte *)stupidKey, AES::MAX_KEYLENGTH);

std::string cypher;
StringSource(aData, true, new StreamTransformationFilter(aes, new StringSink( cypher ))); 
StringSource(cypher, true, new Base64Encoder( new StringSink(aOutput) ));
</code></pre>

<p>The PHP Code:</p>

<pre><code>define('CRYPT_SECRET', 'thisisastupidkeythisisastupidke');

$postData = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, 
                CRYPT_SECRET, base64_decode($_POST['request']), 
                MCRYPT_MODE_ECB);
</code></pre>

<p>Note: I know ECB is a bad choice of encryption mode, but I'd like to get this working without the added oddities of the IV first, then complicate matters.</p>
","<p>Looking at the PHP manual (http://php.net/manual/en/function.mcrypt-decrypt.php), MCRYPT_RIJNDAEL_256 is different to AES_256. The first comment offers some help: <a href=""http://www.php.net/manual/en/function.mcrypt-decrypt.php#105985"">http://www.php.net/manual/en/function.mcrypt-decrypt.php#105985</a></p>

<blockquote>
  <p>Caution, MCRYPT_RIJNDAEL_256 is not equivalent to AES_256. </p>
  
  <p>The way to make RIJNDAEL be decrypted from AES with openssl is to use MCRYPT_RIJNDAEL_128 and padd the string to encrypt before encrypting with the follwing function: </p>
</blockquote>

<pre><code>&lt;?php 
function pkcs5_pad ($text, $blocksize) { 
    $pad = $blocksize - (strlen($text) % $blocksize); 
    return $text . str_repeat(chr($pad), $pad); 
} 
?&gt; 
</code></pre>

<blockquote>
  <p>On the decryption, the choosing of AES_256 or AES_128, etc. is based on the keysize used in the crypting. In my case it was a 128bit key so I used AES_128.</p>
</blockquote>
","4429","<php><c++><mcrypt><crypto++>","2","5","3","2014-12-17 18:10:25","12187756","0","2","","","","2012-08-29 23:05:04",""
"12187689","Crypto++ to PHP mcrypt not working","<p>I have a C++ application that's using Crypto++ to send encrypted data to a PHP site.  However, when the data's getting to the PHP side, it's not decrypting the data properly.</p>

<p>The C++ / Crypto++ code:</p>

<pre><code>char stupidKey[AES::MAX_KEYLENGTH] = ""thisisastupidkeythisisastupidke"";

ECB_Mode&lt;AES&gt;::Encryption aes((byte *)stupidKey, AES::MAX_KEYLENGTH);

std::string cypher;
StringSource(aData, true, new StreamTransformationFilter(aes, new StringSink( cypher ))); 
StringSource(cypher, true, new Base64Encoder( new StringSink(aOutput) ));
</code></pre>

<p>The PHP Code:</p>

<pre><code>define('CRYPT_SECRET', 'thisisastupidkeythisisastupidke');

$postData = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, 
                CRYPT_SECRET, base64_decode($_POST['request']), 
                MCRYPT_MODE_ECB);
</code></pre>

<p>Note: I know ECB is a bad choice of encryption mode, but I'd like to get this working without the added oddities of the IV first, then complicate matters.</p>
","<pre><code>Client Side using ECB - DES_EDE3
==================================

#include ""cryptlib.h""
#include ""modes.h""
#include ""des.h""
#include ""base64.h"" &lt;-- any base64 encoder/decoder i found the usage of crypto++ base64 class a bit hard to use since you have to know how many byte are taken to encode a byte in base 64...
#include ""hex.h""

// Encode the data using the handy Crypto++ base64 encoder. Base64 uses
// 3 characters to store 2 characters.
const int BUFFER_LENGTH = 255;
byte plaintext[BUFFER_LENGTH];
byte ciphertext[BUFFER_LENGTH];
byte newciphertext[BUFFER_LENGTH];
byte decrypted[BUFFER_LENGTH];

CryptoPP::Base64Encoder base64Encoder;
CBase64Coding base64Coder;
CString MySensitiveDataUncrypted;
CString MySensitiveData;

// Set up the same key and IV
const int KEY_LENGTH = 24;
const int BLOCK_SIZE = CryptoPP::DES::BLOCKSIZE;
byte key[KEY_LENGTH], iv[CryptoPP::DES::BLOCKSIZE];
memset( key, 0, KEY_LENGTH);
memcpy( key, ""012345678901234567890123"", KEY_LENGTH );
memset( iv, 0, CryptoPP::DES::BLOCKSIZE);
memcpy( iv, ""01234567"", CryptoPP::DES::BLOCKSIZE );
memset( plaintext, 0, BUFFER_LENGTH);
memset( ciphertext, 0, BUFFER_LENGTH);
memset( newciphertext, 0, BUFFER_LENGTH);
strcpy((char*)plaintext,MySensitiveDataUncrypted.GetBuffer(0));
// now encrypt
CryptoPP::ECB_Mode::Encryption ecbEncryption(key, sizeof(key));
ecbEncryption.ProcessString(newciphertext, plaintext, BUFFER_LENGTH);
// your own base64 encoder/decoder
base64Coder.Encode((char *)newciphertext,BUFFER_LENGTH,(char *)ciphertext);
MySensitiveData.Format(_T(""%s""),ciphertext);

// MySensitiveData can now be send over http


Server Side in PHP using ECB - DES_EDE3
=========================================

// $MyBase64EncodedSecretString will receive/store the encrypted string which will also be base64Encoded for HTTP protocol convenience

$key = ""012345678901234567890123"";
$iv = ""01234567"";

// Set up an ""encryption"" descriptor. This is basically just an object that
// encapsulates the encryption algorithm. 'tripledes' is the name of the
// algorithm, which is simply the DES algorithm done three times back to
// back. 'ecb' describes how to encrypt different blocks. See, DES
// actually only encrypts 8-byte blocks at a time. To encrypt more than 8
// bytes of data, you break the data up into 8-byte chunks (padding the
// last chunk with NULL, if need be), and then encrypt each block
// individually. Now, ECB (which stands for ""Electronic Code Book"", for
// whatever that's worth) means that each 8-byte block is encrypted
// independently. This has pros and cons that I don't care to discuss.
// The other option is CBC (""Cipher Block Chaining"") which links the blocks,
// such as by XORing each block with the encrypted result of the previous
// block. Security geeks probably really get excited about this, but for my
// needs, I don't really care.
$td = mcrypt_module_open( 'tripledes', '', 'ecb', '' );
mcrypt_generic_init( $td, $key, $iv );

// Grab some interesting data from the descriptor.
// $maxKeySize = 24, meaning 24 bytes
// $maxIVSize = 8, meaning 8 bytes
$maxKeySize = mcrypt_enc_get_key_size( $td );
$maxIVSize = mcrypt_enc_get_iv_size( $td );
//echo ""maxKeySize=$maxKeySize, maxIVSize=$maxIVSize\n"";

// let's decrypt it and verify the result. Because DES pads
// the end of the original block with NULL bytes, let's trim those off to
// create the final result.
$MyEncodedSecretString = base64_decode( $MyBase64EncodedSecretString );
$MyDecodedString = rtrim( mdecrypt_generic( $td, $MyEncodedSecretString ), ""\0"" );

// And finally, clean up the encryption object
mcrypt_generic_deinit($td);
mcrypt_module_close($td);


Client Side Stronger Encryption using RSA
=========================================

First you will need to generate a public/private key pair using crypto++ keygen console application then your client code should be something like

// Client Side Using RSA
#include ""cryptlib.h""
#include ""rsa.h""
#include ""hex.h""
#include ""randpool.h""
#include ""filesource.h""

CString MyNotverySecretStringInMemory;
CString MySensitiveData;
char pubFilename[128];
char seed[1024], message[1024];

// MAX = 19999991
strcpy(seed,""12345"");

CString tmpPath;
TCHAR appPath[MAX_PATH];
::GetModuleFileName(NULL,appPath,MAX_PATH);

tmpPath = appPath;
tmpPath = tmpPath.Left(tmpPath.ReverseFind('\\')+1);
tmpPath += ""public.key""; // 1024 key length for higher security.

strcpy(pubFilename,tmpPath.GetBuffer(0));
strcpy(message,MyNotverySecretStringInMemory.GetBuffer(0));
CryptoPP::FileSource pubFile(pubFilename, true, new CryptoPP::HexDecoder);
CryptoPP::RSAES_OAEP_SHA_Encryptor pub(pubFile);
CryptoPP::RandomPool randPool;
randPool.IncorporateEntropy((byte *)seed, strlen(seed));
std::string result;
CryptoPP::StringSource(message, true, new CryptoPP::PK_EncryptorFilter(randPool, pub, new CryptoPP::HexEncoder(new CryptoPP::StringSink(result))));
MySensitiveData.Format(_T(""%s""),result.c_str());
</code></pre>
","4429","<php><c++><mcrypt><crypto++>","2","0","3","2014-12-17 18:10:25","12187756","0","2","","","","2012-08-29 23:05:04",""
"12187689","Crypto++ to PHP mcrypt not working","<p>I have a C++ application that's using Crypto++ to send encrypted data to a PHP site.  However, when the data's getting to the PHP side, it's not decrypting the data properly.</p>

<p>The C++ / Crypto++ code:</p>

<pre><code>char stupidKey[AES::MAX_KEYLENGTH] = ""thisisastupidkeythisisastupidke"";

ECB_Mode&lt;AES&gt;::Encryption aes((byte *)stupidKey, AES::MAX_KEYLENGTH);

std::string cypher;
StringSource(aData, true, new StreamTransformationFilter(aes, new StringSink( cypher ))); 
StringSource(cypher, true, new Base64Encoder( new StringSink(aOutput) ));
</code></pre>

<p>The PHP Code:</p>

<pre><code>define('CRYPT_SECRET', 'thisisastupidkeythisisastupidke');

$postData = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, 
                CRYPT_SECRET, base64_decode($_POST['request']), 
                MCRYPT_MODE_ECB);
</code></pre>

<p>Note: I know ECB is a bad choice of encryption mode, but I'd like to get this working without the added oddities of the IV first, then complicate matters.</p>
","<p>I didn't have luck with mcrypt, but openssl seem to work with Crypto++ better.</p>

<p>Here is the Crypto++ code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/base64.h&gt;

std::string encrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{
    std::string str_out;
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption encryption((byte*)key.c_str(), key.length(), (byte*)iv.c_str());

    CryptoPP::StringSource encryptor(str_in, true, 
        new CryptoPP::StreamTransformationFilter(encryption, 
            new CryptoPP::Base64Encoder(
                new CryptoPP::StringSink(str_out),
                false // do not append a newline
            )
        )
    );
    return str_out;
}

std::string decrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{
    std::string str_out;

    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Decryption decryption((byte*)key.c_str(), key.length(), (byte*)iv.c_str());

    CryptoPP::StringSource decryptor(str_in, true, 
        new CryptoPP::Base64Decoder(
            new CryptoPP::StreamTransformationFilter(decryption, 
                new CryptoPP::StringSink(str_out)
            )
        )
    );
    return str_out;
}

int main(int argc, char *argv[])
{
    std::string str = ""Hello, world!"";
    std::string key = ""01234567891234560123456789123456""; // 32 bytes
    std::string iv  = ""0123456789123456""; // 16 bytes
    std::string str_encrypted = encrypt(str, key, iv);
    std::string str_decrypted = decrypt(str_encrypted, key, iv);
    std::cout &lt;&lt; ""str_encrypted: "" &lt;&lt; str_encrypted &lt;&lt; std::endl;
    std::cout &lt;&lt; ""str_decrypted: "" &lt;&lt; str_decrypted &lt;&lt; std::endl;
}
</code></pre>

<p>And here is the PHP code:</p>

<pre class=""lang-php prettyprint-override""><code>&lt;?php
    $string = 'Hello, world!';
    $key = '01234567891234560123456789123456'; // 32 bytes
    $iv  = '0123456789123456'; // 16 bytes
    $method = 'aes-256-cfb';
    $encrypted = base64_encode( openssl_encrypt ($string, $method, $key, true, $iv));
    $decrypted = openssl_decrypt( base64_decode($encrypted), $method, $key, true, $iv);
    echo ""encrypted: $encrypted&lt;br/&gt;"";
    echo ""decrypted: $decrypted&lt;br/&gt;"";
?&gt;
</code></pre>

<p>And here is the Crypto++ output:</p>

<pre class=""lang-none prettyprint-override""><code>str_encrypted: pF1gsk+GolfeTSYnEQ==
str_decrypted: Hello, world!
</code></pre>

<p>...and PHP output:</p>

<pre class=""lang-none prettyprint-override""><code>encrypted: pF1gsk+GolfeTSYnEQ==
decrypted: Hello, world!
</code></pre>

<p>Don't forget to change the key and iv to some smarter values :o)</p>
","4429","<php><c++><mcrypt><crypto++>","2","6","3","2014-12-17 18:10:25","12187756","0","2","","","","2012-08-29 23:05:04",""
"4593793","How to decrypt string data in C++ with Crypto++ where the original string encrypted in Python with pyCrypto","<p>I've just encrypted a data string with pyCrypto easily, but don't know how to decrypt it in crypto++. Anybody can help with a sample decryption code in C++ with crypto++?
Here is my python code:</p>

<pre><code>key = '0123456789abcdef' 
data = ""aaaaaaaaaaaaaaaa"" 
iv = ''.join(chr(random.randint(0, 0xFF)) for i in range(16)) 
encryptor = AES.new(key, AES.MODE_CBC, iv) 
enc = encryptor.encrypt(data)
</code></pre>
","<p>This code is from an example from 2005, but it should give you a good starting point:</p>

<pre><code>std::string ciphertext = ""...""; // what Python encryption produces
std::string decryptedtext;

byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];

// populate key and iv with the correct values

CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
stfDecryptor.MessageEnd();

// it's all in decryptedText now
</code></pre>
","4392","<c++><python><crypto++><pycrypto>","3","1","2","2011-01-04 14:08:55","4594060","0","1","","","","2011-01-04 12:54:20",""
"4593793","How to decrypt string data in C++ with Crypto++ where the original string encrypted in Python with pyCrypto","<p>I've just encrypted a data string with pyCrypto easily, but don't know how to decrypt it in crypto++. Anybody can help with a sample decryption code in C++ with crypto++?
Here is my python code:</p>

<pre><code>key = '0123456789abcdef' 
data = ""aaaaaaaaaaaaaaaa"" 
iv = ''.join(chr(random.randint(0, 0xFF)) for i in range(16)) 
encryptor = AES.new(key, AES.MODE_CBC, iv) 
enc = encryptor.encrypt(data)
</code></pre>
","<p>same approach as @Jon, a bit simplified</p>

<pre><code>std::string ciphertext = ""...""; // what Python encryption produces
std::string decryptedtext;

byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];

// populate key and iv with the correct values

CryptoPP::CBC_Mode&lt; CryptoPP::AES &gt;::Decryption decryptor;
decryptor.SetKeyWithIV(key, sizeof(key), iv);


CryptoPP::StringSource(ciphertext, true,
        new CryptoPP::StreamTransformationFilter( decryptor,
            new CryptoPP::StringSink( decryptedtext )
        )
);
</code></pre>

<p>The <code>true</code> parameter to <code>CryptoPP::StringSource</code> means ""consume the whole input""</p>

<p>Note that (obviously) you need your C++ decryptor to know the IV you used for encryption. Since you generate a random IV in python, the popular technique is to prepend the IV to the encrypted text.</p>
","4392","<c++><python><crypto++><pycrypto>","3","2","2","2011-01-04 14:08:55","4594060","0","1","","","","2011-01-04 12:54:20",""
"1357569","Using Crypto++ generated RSA keys on OpenSSL","<p>Is there a way to use the RSA keys I've generated with the Crypto++ API in OpenSSL? What I am looking for is a way to store the keys in a format that both Crypto++ and OpenSSL can easily open them.</p>

<p>I'm writing a licensing scheme and would want to verify signatures and decrypt files using the Crypto++ API, but to generate the license files I would want to use a web interface (probably using PHP, which only supports OpenSSL) to generate and encrypt/sign the licenses. </p>

<p>I would write both applications using Crypto++ and call it from the PHP, but since the private key will be stored in a encrypted form, a password must be passed to the application and passing it on the command line doesn't seems to be a good idea to me.</p>
","<p>Try this link:
<a href=""http://www.cryptopp.com/fom-serve/cache/62.html"" rel=""nofollow noreferrer"">http://www.cryptopp.com/fom-serve/cache/62.html</a></p>

<p>It looks like you'll need to use PKCS#8 and convert from DER to PEM format to be able to use the keys in OpenSSL.  I'm not sure if you'll be able to use a single file for both.</p>

<p>I've only used OpenSSL so I'm not sure what options you have with Crypto++.  I found the link above by searching Google for these terms: Crypto++ RSA OpenSSL.</p>

<p>DER is OpenSSL's binary format for keys and certificates.</p>

<p>PEM is OpenSSL's text format.</p>
","4296","<c++><encryption><openssl><rsa><crypto++>","6","0","3","2015-02-18 00:50:20","1372310","0","1","121961","","2009-08-31 14:09:56","2009-08-31 13:52:34",""
"1357569","Using Crypto++ generated RSA keys on OpenSSL","<p>Is there a way to use the RSA keys I've generated with the Crypto++ API in OpenSSL? What I am looking for is a way to store the keys in a format that both Crypto++ and OpenSSL can easily open them.</p>

<p>I'm writing a licensing scheme and would want to verify signatures and decrypt files using the Crypto++ API, but to generate the license files I would want to use a web interface (probably using PHP, which only supports OpenSSL) to generate and encrypt/sign the licenses. </p>

<p>I would write both applications using Crypto++ and call it from the PHP, but since the private key will be stored in a encrypted form, a password must be passed to the application and passing it on the command line doesn't seems to be a good idea to me.</p>
","<p>Both Crypto++ and OpenSSL can handle PKCS#8 encoded keys. In crypto++, you can generate keys  and convert to PKCS#8 buffer like this,</p>

<pre><code>AutoSeededRandomPool rng;
RSAES_OAEP_SHA_Decryptor priv(rng, 2048);
string der;
StringSink der_sink(der);
priv.DEREncode(der_sink);
der_sink.MessageEnd();

// der.data() is the bytes you need
</code></pre>

<p>Now you just need to pass the bytes to PHP. You can save it in a file, send in a message.</p>

<p>The only gotcha is that PHP's OpenSSL interface only accepts PEM encoded PKCS#8. You can easily convert DER-encoded buffer into PEM like this in PHP,</p>

<pre><code>&lt;?php
function pkcs8_to_pem($der) {

    static $BEGIN_MARKER = ""-----BEGIN PRIVATE KEY-----"";
    static $END_MARKER = ""-----END PRIVATE KEY-----"";

    $value = base64_encode($der);

    $pem = $BEGIN_MARKER . ""\n"";
    $pem .= chunk_split($value, 64, ""\n"");
    $pem .= $END_MARKER . ""\n"";

    return $pem;
}
?&gt;
</code></pre>

<p>You can also convert PKCS#8 to PEM in C++ if you prefer. The algorithm is very simple as you can see from the PHP code.</p>

<p>OpenSSL is so prevalent nowadays. I don't see any reason to use Crypto++ for common crypto applications like this.</p>
","4296","<c++><encryption><openssl><rsa><crypto++>","6","5","3","2015-02-18 00:50:20","1372310","0","1","121961","","2009-08-31 14:09:56","2009-08-31 13:52:34",""
"1357569","Using Crypto++ generated RSA keys on OpenSSL","<p>Is there a way to use the RSA keys I've generated with the Crypto++ API in OpenSSL? What I am looking for is a way to store the keys in a format that both Crypto++ and OpenSSL can easily open them.</p>

<p>I'm writing a licensing scheme and would want to verify signatures and decrypt files using the Crypto++ API, but to generate the license files I would want to use a web interface (probably using PHP, which only supports OpenSSL) to generate and encrypt/sign the licenses. </p>

<p>I would write both applications using Crypto++ and call it from the PHP, but since the private key will be stored in a encrypted form, a password must be passed to the application and passing it on the command line doesn't seems to be a good idea to me.</p>
","<blockquote>
  <p>Is there a way to use the RSA keys I've generated with the Crypto++ API in OpenSSL? What I am looking for is a way to store the keys in a format that both Crypto++ and OpenSSL can easily open them.</p>
</blockquote>

<p>Yes. In addition to X.509 and PKCS #8 encoded keys (ZZ Coder's answer), you can also use PEM encoded keys including encrypted keys. Support for PEM encoded keys was donated to the project in July, 2014 for OpenSSL interop.</p>

<p>To use the PEM encoded keys, you need to fetch the Crypto++ <a href=""http://www.cryptopp.com/wiki/Pem_Pack"" rel=""nofollow"">PEM Pack</a> and recompile the library. The PEM Pack is not part of the Crypto++ library as provided by Wei Dai at the <a href=""http://www.cryptopp.com"" rel=""nofollow"">Crypto++ website</a>.</p>

<p>Once you install and recompile, its as simple as:</p>

<pre><code>// Load a RSA public key
FileSource fs1(""rsa-pub.pem"", true);
RSA::PublicKey k1;
PEM_Load(fs1, k1);

// Load a encrypted RSA private key
FileSource fs2(""rsa-enc-priv.pem"", true);
RSA::PrivateKey k2;
PEM_Load(fs2, k2, ""test"", 4);

// Save an EC public key
DL_PublicKey_EC&lt;ECP&gt; k16 = ...;
FileSink fs16(""ec-pub-xxx.pem"", true);
PEM_Save(fs16, k16);

// Save an encrypted EC private key
DL_PrivateKey_EC&lt;ECP&gt; k18 = ...;
FileSink fs18(""ec-enc-priv-xxx.pem"", true);
PEM_Save(fs18, k18, ""AES-128-CBC"", ""test"", 4);
</code></pre>

<p>The keys look like so on-disk:</p>

<pre><code>$ cat rsa-pub.pem
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCg7ovcljEjZCFOdLWENBKE6FSk
Nke6OP79SMJABJw+JoEBpNddK6/v99IvA1qU76V0V4k8qLvhkVUtk9FArhhRsxeF
1fd8UVqgsT8j0YCVFcJ/ZA372ogpXyvc5aK9mZEiKE5TIF8qnDFFZiMWPrad1buk
hg+eFdo78QRLA5plEQIDAQAB
-----END PUBLIC KEY-----
$  
$ cat rsa-enc-priv.pem
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,E1A759E11CA515CE34B6E8CE5278C919

slMx02TMblahTedEKsfS+qYYo4nZFaqI3PhCRYmE5zUa9clHm7yo36wIk3oo52OB
f4AhOaJwiPQAbLe/kDHeP77iHd/4+hFNq/Haj6ahWRpXilLVOETLtefbzSGO8va3
ORnwQpPThs2V0EetPU3LB3QcA/XRjWDzyNa7+LydOjKwbQdZnF/jND5NCkEkncNM
iQJ1VWubN+Xs3Rx0CfLu5Chl1n7WnmCNMtLL/LtYeaR1SlRJa6BaF7hNHJJJ3+Jc
8curCKlpobs+XnlDfjyqgTXolkiepn95TnT7KSqi3BqVEpq/5LKMnkDJg6nwUR7A
w0jLNr1f8adWyBEj2Dp0D/jy8eDh65eHdJw4s8G5FZfBud1zWbvRQ3Ah70ISUKa3
4q/6z2vervPgoc+rMVYDvRf/mqa4LMXYhuygsyx50OgPldCC2d0cVVFCg/ljdEzO
UV5rSkK1Qczv8Nc1ZdY3fJA+qYIV8JqPPY+dJ2312R+myPi5Av0/69k8lZN5eIJk
SkiiFQmabhc+o6z4RFA52a3lOud3eGM9L5nbFQGc5COzQVZ6y8t06tLIp9Y5zjA4
KTgNncV5eq3Bau+cWXjP6pJRixFVfwIoy95mAur7B2P1iE4FXyZbvCovPL6vilT5
kSqAo7Znu0RpTjE36tWY6tFt+GU7k8EBrjA3Qi+8xxqyYtr57Ns+H/j+hhJTN8L7
IXoevwS81OPiB0Dmg6wLLXATG1+gCNXb8sd5U2eJhy4LOJA3y54CTgRnPXtM38CH
K+JvnDstyUl9IGTsgUz51ZzyJNZGU9Ro3pt/a3Cs5IJumaygZ0LQ44WBw9m/vja9
-----END RSA PRIVATE KEY-----
$  
$ cat ec-pub.pem
-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEVwXjdIb2yy25QbIO0XiIHpySXwSpIAcz
v0Wdyq+fZ6BdJjs2jKvbs9pcRJn8yxlASWoz2R4NoHTZ2YokKsDfEg==
-----END PUBLIC KEY-----
$  
$ cat ec-enc-priv.pem
-----BEGIN EC PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,F1DBC73E26DCD310888932C2762B3512

nikex48SFvtNOIrOEDipwmxaghjn4jtrvwI3d1H/VNq9yp26WqFZxBJCUPFBFLjH
auA+AHeUo3BVkNQPs0VO4FD5xR50mtc2tCJizzhyTTTypLc3lRkxmD1MpeZnWRy2
70foVtNSvLL/QLJqNJGm/G9kl0xPN4zAfOq7Txoscnk=
-----END EC PRIVATE KEY-----
</code></pre>

<hr>

<p>Related: for other useful Crypto++ patches, see the <a href=""http://www.cryptopp.com/wiki/Category:Patch"" rel=""nofollow"">Category:Patch</a> page on the Crypto++ wiki.</p>
","4296","<c++><encryption><openssl><rsa><crypto++>","6","1","3","2015-02-18 00:50:20","1372310","0","1","121961","","2009-08-31 14:09:56","2009-08-31 13:52:34",""
"19814236","How to encrypt a byte array with Crypto++","<p>How can I encrypt a byte array with Crypto++'s RSA implementation? I already found an example for strings. But I can't find a good example how to do the same for a byte array.</p>

<p>This is my first attempt:</p>

<pre><code>//dataSize:     Size of data that is going to be send
//dataToSend    Bytes to send to the user
//seedPool      is an AutoSeededRandomPool

CryptoPP::RSAES_OAEP_SHA_Encryptor encryptor(publicKey);

int size = 64000; 
byte * cipher = new byte(size);

CryptoPP::ArraySink* test = new CryptoPP::ArraySink(cipher, size);
CryptoPP::ArraySource as((byte*)dataToSend, dataSize, true, new CryptoPP::PK_EncryptorFilter(seedPool, encryptor, test));

int newDataSize = test-&gt;TotalPutLength();
unsigned int bytesSend = ::send(socketLink, (char *)(cipher), (int)newDataSize, 0);

delete[] cipher;
</code></pre>

<p>This doesn't work. <code>TotalPutLength</code> will always return 0 but there is data put in cipher.</p>

<p>What is a safe way to implement this? I don't want to be vulnerable for buffer overflows or any other attack.</p>
","<blockquote>
  <p>byte * cipher = new byte(size);</p>
</blockquote>

<p>I believe this should be:</p>

<pre><code>byte * cipher = new byte[size];
</code></pre>

<p>Otherwise, I think you get one byte initialized to 6400 (which is truncated to 0x00).</p>

<hr>

<blockquote>
  <p>CryptoPP::ArraySink * test = new CryptoPP::ArraySink(cipher, size);</p>
</blockquote>

<p>This is kind of different. You can stay out of the memory manager if you'd like:</p>

<pre><code> CryptoPP::ArraySink test(cipher, size);
</code></pre>

<hr>

<blockquote>
  <p>int newDataSize = test->TotalPutLength();</p>
</blockquote>

<p><strike>I've never used <code>TotalPutLength</code>, and I did not see it documented on a <code>BufferedTransformation</code> or <code>Sink</code>. So I don't really have any advice on what its returning.</strike></p>

<p><code>TotalPutLength</code> is OK to use. An <code>ArraySink</code> could return the wrong value <em>if</em> the sink was full. It would happen if the array was fixed and too small for all the data. We cleared that issue at Crypto++ 5.6.3 or 5.6.4.</p>

<p>If you want to count the number of bytes processed (even if the sink cannot store they bytes), then you can also use a <a href=""http://www.cryptopp.com/wiki/MeterFilter"" rel=""nofollow noreferrer""><code>MeterFilter</code></a>:</p>

<pre><code>byte data[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 };

string encoded;
MeterFilter meter( new StringSink( encoded ) );

ArraySource( data, sizeof( data ), true,
    new HexEncoder(
        new Redirector( meter ),
        true /*UCase*/, 2 /*Group*/,
        "" "" /*Separator*/
    )
);

cout &lt;&lt; ""processed "" &lt;&lt; meter.GetTotalBytes() &lt;&lt; "" bytes"" &lt;&lt; endl;
cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>Output:</p>

<pre><code>Processed 23 bytes
00 01 02 03 04 05 06 07
</code></pre>

<hr>

<blockquote>
  <p>How can you encrypt a byte array with Cryptopp RSA implementation</p>
</blockquote>

<p>Now we're talking ;) Try this from the Crypto++ wiki on <a href=""http://www.cryptopp.com/wiki/RSA_Encryption_Schemes"" rel=""nofollow noreferrer"">RSA Encryption</a>.</p>

<pre><code>////////////////////////////////////////////////
// Generate keys
AutoSeededRandomPool rng;

InvertibleRSAFunction params;
params.GenerateRandomWithKeySize( rng, 1536 );

RSA::PrivateKey privateKey( params );
RSA::PublicKey publicKey( params );

string plain=""RSA Encryption"", cipher, recovered;

////////////////////////////////////////////////
// Encryption
RSAES_OAEP_SHA_Encryptor e( publicKey );

StringSource ss1( plain, true,
    new PK_EncryptorFilter( rng, e,
        new StringSink( cipher )
    ) // PK_EncryptorFilter
 ); // StringSource

////////////////////////////////////////////////
// Decryption
RSAES_OAEP_SHA_Decryptor d( privateKey );

StringSource ss2( cipher, true,
    new PK_DecryptorFilter( rng, d,
        new StringSink( recovered )
    ) // PK_DecryptorFilter
 ); // StringSource

assert( plain == recovered );
</code></pre>
","4224","<c++><arrays><encryption><crypto++>","3","2","1","2017-03-16 00:49:42","","0","1","608639","","2016-02-18 04:14:45","2013-11-06 14:08:19",""
"28307339","AES, 128 and 256 Invalid Key Length","<p>I am trying to encrypt a text using Crypto++. It worked well last time when using AES CTR, but now when using CBC or GCM the max key length I can use is 32 bits??</p>

<p>The code that handles the encryption:</p>

<pre><code>string xAESPlain, xAESCipher;
AutoSeededRandomPool xRng;

byte xAESKey[128]; // Doesnt Work has to be 32 or 16
byte xAESIv[128];

xRng.GenerateBlock(xAESKey, sizeof(xAESKey));
xRng.GenerateBlock(xAESIv, sizeof(xAESIv));

CBC_Mode&lt; AES &gt;::Encryption E;
E.SetKeyWithIV(xAESKey, sizeof(xAESKey), xAESIv);

StringSource ss(xAESPlain, true,
    new StreamTransformationFilter(E,
        new StringSink(xAESCipher)
    )
);
</code></pre>

<p>When running this Crypto++ throws an <code>Exception</code>:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidKeyLength'
  what():  AES/CBC: 128 is not a valid key length
</code></pre>

<p>Note that the same thing happens when using the example.zip provided in the Wiki(and changing the key length to 256 or 128)</p>

<p>Any ideas why the <code>Exception</code> is being thrown?</p>
","<p>Bytes are usually octets (8 bits). AES is specified for 128-bit block size or 16 bytes which is also the size of the IV. AES key sizes may be 128-bit, 192-bit or 256-bit or 16 byte, 24 byte or 32 byte respectively. They can't be different from those. So use this for AES-256:</p>

<pre><code>byte xAESKey[32];
byte xAESIv[16];
</code></pre>

<p>This should have nothing to do with the mode of operation.</p>
","4208","<c++><encryption><aes><crypto++><aes-gcm>","1","6","2","2015-09-14 14:36:01","28307668","1","","608639","","2015-02-03 23:15:44","2015-02-03 19:40:42",""
"28307339","AES, 128 and 256 Invalid Key Length","<p>I am trying to encrypt a text using Crypto++. It worked well last time when using AES CTR, but now when using CBC or GCM the max key length I can use is 32 bits??</p>

<p>The code that handles the encryption:</p>

<pre><code>string xAESPlain, xAESCipher;
AutoSeededRandomPool xRng;

byte xAESKey[128]; // Doesnt Work has to be 32 or 16
byte xAESIv[128];

xRng.GenerateBlock(xAESKey, sizeof(xAESKey));
xRng.GenerateBlock(xAESIv, sizeof(xAESIv));

CBC_Mode&lt; AES &gt;::Encryption E;
E.SetKeyWithIV(xAESKey, sizeof(xAESKey), xAESIv);

StringSource ss(xAESPlain, true,
    new StreamTransformationFilter(E,
        new StringSink(xAESCipher)
    )
);
</code></pre>

<p>When running this Crypto++ throws an <code>Exception</code>:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidKeyLength'
  what():  AES/CBC: 128 is not a valid key length
</code></pre>

<p>Note that the same thing happens when using the example.zip provided in the Wiki(and changing the key length to 256 or 128)</p>

<p>Any ideas why the <code>Exception</code> is being thrown?</p>
","<p>It is little bit better and more safely initialize block size and key in this way:</p>

<pre><code>unsigned char iv[ CryptoPP::AES::BLOCKSIZE ];
unsigned char keyq[ CryptoPP::AES::MAX_KEYLENGTH ];
</code></pre>

<p>CryptoPP also have constants like CryptoPP::AES::MIN_KEYLENGTH and etc.</p>
","4208","<c++><encryption><aes><crypto++><aes-gcm>","1","1","2","2015-09-14 14:36:01","28307668","1","","608639","","2015-02-03 23:15:44","2015-02-03 19:40:42",""
"14985664","Code to decrypt the encrypted SHA256 code into string in crypto++","<p>I am using crypto++ to encrypt and decrypt the string .The code is shown below.
The code encrypts the username and password .But I don't know how to I decrypt it one again into string. What is the code to decrypt the encrypted SHA256 code into string.
Can any one help me.</p>

<pre><code>#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  CryptoPP::SHA256 hash;
  byte digest[CryptoPP::SHA256::DIGESTSIZE];
  std::string username, password, salt, output;
  std::cout &lt;&lt; ""Enter username: "";
  std::getline(std::cin,username);
  std::cout &lt;&lt; std::endl &lt;&lt; ""Enter password: "";
  std::getline(std::cin,password);
  salt = username + password;

  hash.CalculateDigest(digest,(const byte *)salt.c_str(),salt.size());

  CryptoPP::HexEncoder encoder;
  CryptoPP::StringSink *SS = new CryptoPP::StringSink(output);
  encoder.Attach(SS);
  encoder.Put(digest,sizeof(digest));
  encoder.MessageEnd();

  std::cout &lt;&lt; ""The username/password salted hash is =&gt; "" &lt;&lt; output &lt;&lt; std::endl;
  return 0;
}
</code></pre>
","<p>This code is not performing <strong>encryption</strong>, as the commentors already pointed out, but <strong>hashing</strong>. The central difference is that hashing, by design, is not reversible cheaply. This is important in password applications because you do explicitly not want to store the user's passwords in any accessible form, but only check against them.</p>

<p>So, in short words: You cannot ""decrypt"" your hash.</p>

<p>When you want to check a supplied password for correctness, you hash it again like in your code and compare the hash against the hash of the original password.</p>
","4063","<c++><crypto++>","0","4","1","2015-11-17 07:07:13","14986122","2","","","","","2013-02-20 17:05:08",""
"14008879","JAVA (AES/CBC/PKCS5PADDING) What is the corresponding C/C++","<p>Cipher.getInstance(""AES/CBC/PKCS5PADDING"") i using the Sun JCE provider：</p>

<pre><code>public static void main(String[] args) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException
{
    System.out.println(""=======================AES/CBC/PKCS5Padding====================="");
    // key
    byte[] key = ""0123456789abcdef"".getBytes(""UTF-8"");
    dump(""key"", key);
    // iv
    byte[] iv = ""fedcba9876543210"".getBytes(""UTF-8"");
    dump(""iv"", iv);

    byte[] indata = ""bsmith is a good guy."".getBytes(""UTF-8"");
    dump(""indata"", indata);

    AES aes = new AES();
    aes.init(key, iv);
    byte[] outdata = aes.encrypt(indata);
    dump(""outdata"", outdata);

    byte[] indata1 = aes.decrypt(outdata);
    dump(""indata1"", indata1);
}

private Cipher enc;
private Cipher dec;
private SecretKeySpec keySpec;
private IvParameterSpec ivSpec;

public AES()
{
}

/**
 * init the AES key.
 * the key must be 128, 192, or 256 bits.
 * @param key the AES key.
 * @param keyoff the AES key offset.
 * @param keylen the AES key length, the key length must be 16 bytes because SunJCE only support 16 bytes key.
 * @param iv the IV for CBC, the length of iv must be 16 bytes.
 * @param ivoff the iv offset.
 */
public void init(byte[] key, int keyoff, int keylen, byte[] iv, int ivoff)
{
    keySpec = new SecretKeySpec(key, keyoff, keylen, ""AES"");
    ivSpec = new IvParameterSpec(iv, ivoff, 16);
}

/**
 * init the AES key.
 * the key must be 16 bytes, because SunJCE only support 16 bytes key..
 * @param key the AES key.
 * @param iv the iv for CBC, iv must be 16 bytes length.
 */
public void init(byte[] key, byte[] iv)
{
    keySpec = new SecretKeySpec(key, ""AES"");
    ivSpec = new IvParameterSpec(iv);
}

/**
* get the maximal cipher data length after encrypted.
* @param len the plain data length.
* @return the cipher data length.
*/
public int getCipherLen(int len)
{
    // for PKCS#1 v1.5 padding
    // max padding BLOCK_SIZE=16.
    int pad = len%16;
    if (0 == pad)
    {
        return len + 16;
    }
    return len - pad + 16;
}

/**
 * encrypt the input data to output data.
 * the input data length must be the times of 16 bytes.
 * and the output data length is equals to the input data.
 * @param indata the input data.
 * @param inoff the input data offset.
 * @param inlen the input data length.
 * @param outdata the output data.
 * @param outoff the output data offset.
 */
public void encrypt(byte[] indata, int inoff, int inlen, byte[] outdata, int outoff) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException
{
    initEncryptor();
    enc.doFinal(indata, inoff, inlen, outdata, outoff);
}

/**
 * encrypt the input data to output data.
 * @param indata the input data.
 * @param inoff the input data offset.
 * @param inlen the input data length.
 * @return the output encrypted data.
 */
public byte[] encrypt(byte[] indata, int inoff, int inlen) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException
{
    initEncryptor();
    return enc.doFinal(indata, inoff, inlen);
}

/**
 * encrypt the input data to output data.
 * @param indata the input data.
 * @return the output data.
 * @throws NoSuchAlgorithmException
 * @throws NoSuchPaddingException
 * @throws InvalidKeyException
 * @throws InvalidAlgorithmParameterException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 */
public byte[] encrypt(byte[] indata) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    initEncryptor();
    return enc.doFinal(indata);
}

/**
* the maximal plain data length after decrypted.
* @param len the cipher data length that will be decrypted.
* @return the maximal plain data length.
*/
public int getPlainLen(int len)
{
    // for PKCS#1 v1.5 padding
    // len always be times of BLOCK_SIZE=16.
    return len;
}

/**
 * decrypt the input data to output data.
 * @param indata the input data.
 * @param inoff the input data offset.
 * @param inlen the input data length.
 * @param outdata the output data.
 * @param outoff the output data offset.
 */
public void decrypt(byte[] indata, int inoff, int inlen, byte[] outdata, int outoff) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException
{
    initDecryptor();
    dec.doFinal(indata, inoff, inlen, outdata, outoff);
}

/**
 * decrypt the input data to output data.
 * @param indata the input data.
 * @param inoff the input data offset.
 * @param inlen the input data length.
 * @return the output decrypted data.
 */
public byte[] decrypt(byte[] indata, int inoff, int inlen) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, ShortBufferException, InvalidAlgorithmParameterException
{
    initDecryptor();
    return dec.doFinal(indata, inoff, inlen);
}

/**
 * decrypt the input data to output data.
 * @param indata the input cipher data.
 * @return the output plain data.
 * @throws NoSuchAlgorithmException
 * @throws NoSuchPaddingException
 * @throws InvalidKeyException
 * @throws InvalidAlgorithmParameterException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 */
public byte[] decrypt(byte[] indata) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    initDecryptor();
    return dec.doFinal(indata);
}

private void initEncryptor() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException
{
    if (null == enc)
    {
        enc = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        enc.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
    }
}

private void initDecryptor() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException
{
    if (null == dec)
    {
        dec = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        dec.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
    }
}
</code></pre>

<p>}</p>

<p>Corresponds to what is C/C++? I found crypto++ Just right，Others are not，But the algorithms inside too much, I just need to have AES。That is too complicated, I will not, I am a novice，Do you familiar with this algorithm, I want to transplant it into Android, packaged as so。</p>
","<p>First of all, PKCS#5 padding is better known as PKCS#7 padding. PKCS#5 padding is actually for 8 byte block ciphers, and PKCS#7 padding is for 16 byte block ciphers. Otherwise they are identical.</p>

<p>The cryptographic library is all right if it supplies AES and CBC. This is more or less a given, as CBC is one of the more common modes. The availability of the right padding mode may differ, although most C++ libraries will support PKCS#5 padding, as it is the de-facto standard.</p>

<p>As there are (NIST) test vectors available, and since the byte order is known, any library that supports the combination of algorithm, mode and padding mode should be inter-operable.</p>
","3995","<c++><c><aes><crypto++>","1","1","1","2012-12-24 13:26:55","14022013","3","5","","","","2012-12-23 05:33:58",""
"3398304","Converting QString/QChar to be accepted with Crypto++","<p>I want to make program that encrypts (later decrypts) user inputted string.
Here is beginning for encryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText(); //Data to process
std::string output; //Result will be Base32 encoded string, so std::string is fine.
</code></pre>

<p>Now, I have to convert <code>QString</code> to <code>char*</code> or <code>std::string</code> so it can be accepted with Crypto++. I thought that <code>QByteArray</code> would be fine, as it has <code>.data()</code> function, which returns <code>char *</code>. (<code>getData</code> always 17 or more bytes long: CryptoPP requires at least 17 bytes for AES encryption).
So, I have used following code:</p>

<pre><code>QByteArray data;
data.append(getData);

//Creating key and iv:

//Creating AES encryptor:

//Encrypting AES and Base32:
CryptoPP::StringSource ss((const byte*)data.data(), data.size() , true,
    new CryptoPP::StreamTransformationFilter( Encryptor,
        new CryptoPP::Base32Encoder(
                new CryptoPP::StringSink(output)
        ) // Base32Encoder
    ) // StreamTransformationFilter
); // StringSource

ui-&gt;text-&gt;clear();
getData = output.c_str();
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>Everything is seems to be fine. But I want it to support non-ASCII characters (I mean russian, lithuanian etc.). After decryption they change to <code>?</code>. How could I fix this? I understand, that <code>std::string</code> doesn`t support them.</p>

<hr>

<p>EDIT: Here is updated code:</p>

<p>Encryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText(); //Data to process
std::string output;

QByteArray data = getData.toUtf8();

//Creating key and iv: &lt;..&gt;

//Creating AES encryptor: &lt;..&gt;

//Encrypting AES and Base32:
CryptoPP::StringSource ss((const byte*) data.data(),getData.size()*2, true,
    new CryptoPP::StreamTransformationFilter( Encryptor,
        new CryptoPP::Base32Encoder(
                new CryptoPP::StringSink(output)
        ) // Base32Encoder
    ) // StreamTransformationFilter
); // StringSource

ui-&gt;text-&gt;clear();
getData = output.c_str();
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>And decryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText();
QByteArray data;
data.append(getData);
std::string output;

//Creating key and iv:
byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ],
      iv[ CryptoPP::AES::BLOCKSIZE ];

//Memsetting them: (randomization needed)
::memset( key, 0x01, CryptoPP::AES::DEFAULT_KEYLENGTH );
::memset(  iv, 0x01, CryptoPP::AES::BLOCKSIZE );

//Creating AES decryptor:
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor( key, sizeof(key), iv );

//Decrypting Base32 and AES
CryptoPP::StringSource ss((const byte*) data.data(), data.size(), true,
    new CryptoPP::Base32Decoder(
        new CryptoPP::StreamTransformationFilter( Decryptor,
            new CryptoPP::StringSink(output)
        ) // StreamTransformationFilter
    ) // Base32Encoder
); // StringSource

ui-&gt;text-&gt;clear();
getData = QString::fromUtf8(output.c_str());
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>Does it have any bugs I have missed?</p>
","<p>Use <code>reinterpret_cast&lt;byte*&gt;(QString::data())</code> instead. Don't try to actually do code page conversion here -- AES does not care. Use an <a href=""http://www.cryptopp.com/docs/ref/class_array_sink.html"" rel=""nofollow noreferrer"">ArraySink</a> instead of a StringSink.</p>

<p>Keep in mind that the size of the actual QString::data() buffer is twice the number of characters contained there, because it uses UTF-16.</p>
","3808","<c++><qt><crypto++>","2","0","2","2016-07-18 21:57:51","3398595","1","","608639","","2016-07-18 21:57:51","2010-08-03 15:54:03",""
"3398304","Converting QString/QChar to be accepted with Crypto++","<p>I want to make program that encrypts (later decrypts) user inputted string.
Here is beginning for encryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText(); //Data to process
std::string output; //Result will be Base32 encoded string, so std::string is fine.
</code></pre>

<p>Now, I have to convert <code>QString</code> to <code>char*</code> or <code>std::string</code> so it can be accepted with Crypto++. I thought that <code>QByteArray</code> would be fine, as it has <code>.data()</code> function, which returns <code>char *</code>. (<code>getData</code> always 17 or more bytes long: CryptoPP requires at least 17 bytes for AES encryption).
So, I have used following code:</p>

<pre><code>QByteArray data;
data.append(getData);

//Creating key and iv:

//Creating AES encryptor:

//Encrypting AES and Base32:
CryptoPP::StringSource ss((const byte*)data.data(), data.size() , true,
    new CryptoPP::StreamTransformationFilter( Encryptor,
        new CryptoPP::Base32Encoder(
                new CryptoPP::StringSink(output)
        ) // Base32Encoder
    ) // StreamTransformationFilter
); // StringSource

ui-&gt;text-&gt;clear();
getData = output.c_str();
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>Everything is seems to be fine. But I want it to support non-ASCII characters (I mean russian, lithuanian etc.). After decryption they change to <code>?</code>. How could I fix this? I understand, that <code>std::string</code> doesn`t support them.</p>

<hr>

<p>EDIT: Here is updated code:</p>

<p>Encryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText(); //Data to process
std::string output;

QByteArray data = getData.toUtf8();

//Creating key and iv: &lt;..&gt;

//Creating AES encryptor: &lt;..&gt;

//Encrypting AES and Base32:
CryptoPP::StringSource ss((const byte*) data.data(),getData.size()*2, true,
    new CryptoPP::StreamTransformationFilter( Encryptor,
        new CryptoPP::Base32Encoder(
                new CryptoPP::StringSink(output)
        ) // Base32Encoder
    ) // StreamTransformationFilter
); // StringSource

ui-&gt;text-&gt;clear();
getData = output.c_str();
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>And decryption:</p>

<pre><code>QString getData = ui-&gt;text-&gt;toPlainText();
QByteArray data;
data.append(getData);
std::string output;

//Creating key and iv:
byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ],
      iv[ CryptoPP::AES::BLOCKSIZE ];

//Memsetting them: (randomization needed)
::memset( key, 0x01, CryptoPP::AES::DEFAULT_KEYLENGTH );
::memset(  iv, 0x01, CryptoPP::AES::BLOCKSIZE );

//Creating AES decryptor:
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor( key, sizeof(key), iv );

//Decrypting Base32 and AES
CryptoPP::StringSource ss((const byte*) data.data(), data.size(), true,
    new CryptoPP::Base32Decoder(
        new CryptoPP::StreamTransformationFilter( Decryptor,
            new CryptoPP::StringSink(output)
        ) // StreamTransformationFilter
    ) // Base32Encoder
); // StringSource

ui-&gt;text-&gt;clear();
getData = QString::fromUtf8(output.c_str());
ui-&gt;text-&gt;setText(getData);
</code></pre>

<p>Does it have any bugs I have missed?</p>
","<p>I think you're losing data when converting from QString to QByteArray.  Try this:</p>

<pre><code>QByteArray data = getData.toUtf8();

...

getData = QString::fromUtf8( output.c_str() );
</code></pre>
","3808","<c++><qt><crypto++>","2","1","2","2016-07-18 21:57:51","3398595","1","","608639","","2016-07-18 21:57:51","2010-08-03 15:54:03",""
"19130498","Problems with CryptoPP C++ AES-256+Base64","<p>could someone please tell me as to why the decryption starts to mess up. It works fine with short strings but it will mess up as you can see as it goes on. I THINK it has something to do with the string conversions.</p>

<pre><code>std::string encrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{

    std::string str_out;
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption encryption((byte*)key.c_str(),    key.length(), (byte*)iv.c_str());
    CryptoPP::StringSource encryptor(str_in, true,
        new CryptoPP::StreamTransformationFilter(encryption,
            new CryptoPP::Base64Encoder(
                new CryptoPP::StringSink(str_out),
                false // do not append a newline
            )
        )
    );
    return str_out;
}


std::string decrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{

    std::string str_out;    
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Decryption decryption((byte*)key.c_str(), key.length(), (byte*)iv.c_str());

    CryptoPP::StringSource decryptor(str_in, true,
        new CryptoPP::Base64Decoder(
            new CryptoPP::StreamTransformationFilter(decryption,
                new CryptoPP::StringSink(str_out)
            )
        )
    );
    return str_out;
}
</code></pre>

<p>This would be my output of the program</p>

<pre><code>key:qwertyuiopasdfghjklzxcvbnmqwerty
IV:0123456789123456

STR:I do not like green eggs and ham I do not like them Sam-I-Am. Try them, try them, and you may! Try them and you may, I say. I will not eat them in a house, i will not eat them with a mouse,i will not eat them in a box i will not eat them with a fox, i will not eat them here of there i will not eat them anywhere, I do not like green eggs and ham i do not like them sam i am

STR_ENCRYPTED: ffyHj0rFQ0fn+jJcuZAznaioo+2oqqq+7ayjqe2lrKBF8s6QLdosGuIXzz/+vL+Bz
c3Nzc3Nzc3Nzc3Nzc3Nzd78yyKlu7P47yMSlKi7AhEyLs55pj9nZcEIPPadhISD4bQSGVWiWGbEMr7Ev
UCA+f9XQnePvQrfDwpegOLwYk8YyjXa9rLprhk7gAOU4LcdSRT6Udgohsolvrick6CSyUB9gJmkK6Ng1
MjSw4zBQkYMmt7oobkObBQY5XJHcTX5fVGXE5MJsVkQqGqAAKwD6jq4yZcG26WfA9LkwVgj0AwpxjKGV
VeYM/HKK9gzDA9u0/x0y/H4be8rpOYXPyrxXB8++iBL6cFz/Hq+y37uznfmqgAFdTkoW9FsHcGfmxZpJ
PYqrPKKwbt0EuMVGT1Z1F8kgvnwGiAg7/t7oa8RFStF3dsBd5LIYujx0nbnebSrkAFR0qMPzMDF4+Pox
n8KaEm6dtRYGEyYBfJWju+kWqug7aTtrKA=


STR_DECRYPTED: I do not like green eggs and ham I do not like t                y
 them, try them π♥┤k≥¬¿♀┼±;PIINry them and you 2ÜÅ║Bp╟↕┬╟ôM/=»éll not eat them ä
┘7£§σKΦsuQ^m_♦ll not eat them ┴W‼%lt├í┘╒(┐è╝°4ill not eat them≈u♦Z╦▬hR╬▼)♀òε↔┴ n
ot eat them wi▲1╣♠&lt;5á""µi+┌≥τ&lt;æ not eat them he+g═╚╕⌠σû∟í╨♀RV█ñll not eat them ÆΘ
..%♂▓╟Ñnot like them sam i amg]╠£▼n┬☺
Press any key to continue . . .
</code></pre>

<h3>EDIT</h3>

<p>This is how I call the code in my program, I use a liscensed version of Visual Studio 2012 on Windows 7.</p>

<pre><code>std::string szEncryptionKey= ""qwertyuiopasdfghjklzxcvbnmqwerty"";;
std::string szEncryptionIV= ""0123456789123456"";
std::string str=""I do not like green eggs and ham I do not like them Sam-I-Am. Try them, try them, and you may! Try them and you may, I say. I will not eat them in a house, i will not eat them with a mouse,i will not eat them in a box i will not eat them with a fox, i will not eat them here of there i will not eat them anywhere, I do not like green eggs and ham i do not like them sam i am"";
std::string str_encrypted = encrypt(str, szEncryptionKey, szEncryptionIV);
std::string str_decrypted = decrypt(str_encrypted, szEncryptionKey, szEncryptionIV);

std::cout&lt;&lt; ""str encrypted: ""&lt;&lt;str_encrypted&lt;&lt;std::endl;
std::cout&lt;&lt; ""str decrypted: ""&lt;&lt;str_decrypted&lt;&lt;std::endl;
</code></pre>
","<p>For your information, this works fine on my end:</p>

<pre><code>int main()
{
    std::string key = ""qwertyuiopasdfghjklzxcvbnmqwerty"";
    std::string IV = ""0123456789123456"";

    std::string input = ""I do not like green eggs and ham I do not like them Sam-I-Am. Try them, try them, and you may! Try them and you may, I say. I will not eat them in a house, i will not eat them with a mouse,i will not eat them in a box i will not eat them with a fox, i will not eat them here of there i will not eat them anywhere, I do not like green eggs and ham i do not like them sam i am"";

    //Your encrypt function
    auto encr = encrypt(input, key, IV);
    std::cout &lt;&lt; encr &lt;&lt; std::endl;  

    //Your decrypt function
    auto decr = decrypt(encr, key, IV);
    std::cout &lt;&lt; decr &lt;&lt; std::endl;
}
</code></pre>

<p>Also, I saw that you are calling <code>new</code> without an associated <code>delete</code> in your encrypt and decrypt functions. I assume this is because the library is taking care of deleting the objects on your behalf?</p>

<p><strong>EDIT</strong></p>

<p>noloader confirmed that Crypto++ does take care of deleting the objects. Thanks, noloader!</p>
","3794","<c++><encryption><base64><aes><crypto++>","-1","1","2","2018-03-23 12:10:33","19146892","1","0","2837329","","2013-10-02 20:23:31","2013-10-02 05:28:24",""
"19130498","Problems with CryptoPP C++ AES-256+Base64","<p>could someone please tell me as to why the decryption starts to mess up. It works fine with short strings but it will mess up as you can see as it goes on. I THINK it has something to do with the string conversions.</p>

<pre><code>std::string encrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{

    std::string str_out;
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption encryption((byte*)key.c_str(),    key.length(), (byte*)iv.c_str());
    CryptoPP::StringSource encryptor(str_in, true,
        new CryptoPP::StreamTransformationFilter(encryption,
            new CryptoPP::Base64Encoder(
                new CryptoPP::StringSink(str_out),
                false // do not append a newline
            )
        )
    );
    return str_out;
}


std::string decrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{

    std::string str_out;    
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Decryption decryption((byte*)key.c_str(), key.length(), (byte*)iv.c_str());

    CryptoPP::StringSource decryptor(str_in, true,
        new CryptoPP::Base64Decoder(
            new CryptoPP::StreamTransformationFilter(decryption,
                new CryptoPP::StringSink(str_out)
            )
        )
    );
    return str_out;
}
</code></pre>

<p>This would be my output of the program</p>

<pre><code>key:qwertyuiopasdfghjklzxcvbnmqwerty
IV:0123456789123456

STR:I do not like green eggs and ham I do not like them Sam-I-Am. Try them, try them, and you may! Try them and you may, I say. I will not eat them in a house, i will not eat them with a mouse,i will not eat them in a box i will not eat them with a fox, i will not eat them here of there i will not eat them anywhere, I do not like green eggs and ham i do not like them sam i am

STR_ENCRYPTED: ffyHj0rFQ0fn+jJcuZAznaioo+2oqqq+7ayjqe2lrKBF8s6QLdosGuIXzz/+vL+Bz
c3Nzc3Nzc3Nzc3Nzc3Nzd78yyKlu7P47yMSlKi7AhEyLs55pj9nZcEIPPadhISD4bQSGVWiWGbEMr7Ev
UCA+f9XQnePvQrfDwpegOLwYk8YyjXa9rLprhk7gAOU4LcdSRT6Udgohsolvrick6CSyUB9gJmkK6Ng1
MjSw4zBQkYMmt7oobkObBQY5XJHcTX5fVGXE5MJsVkQqGqAAKwD6jq4yZcG26WfA9LkwVgj0AwpxjKGV
VeYM/HKK9gzDA9u0/x0y/H4be8rpOYXPyrxXB8++iBL6cFz/Hq+y37uznfmqgAFdTkoW9FsHcGfmxZpJ
PYqrPKKwbt0EuMVGT1Z1F8kgvnwGiAg7/t7oa8RFStF3dsBd5LIYujx0nbnebSrkAFR0qMPzMDF4+Pox
n8KaEm6dtRYGEyYBfJWju+kWqug7aTtrKA=


STR_DECRYPTED: I do not like green eggs and ham I do not like t                y
 them, try them π♥┤k≥¬¿♀┼±;PIINry them and you 2ÜÅ║Bp╟↕┬╟ôM/=»éll not eat them ä
┘7£§σKΦsuQ^m_♦ll not eat them ┴W‼%lt├í┘╒(┐è╝°4ill not eat them≈u♦Z╦▬hR╬▼)♀òε↔┴ n
ot eat them wi▲1╣♠&lt;5á""µi+┌≥τ&lt;æ not eat them he+g═╚╕⌠σû∟í╨♀RV█ñll not eat them ÆΘ
..%♂▓╟Ñnot like them sam i amg]╠£▼n┬☺
Press any key to continue . . .
</code></pre>

<h3>EDIT</h3>

<p>This is how I call the code in my program, I use a liscensed version of Visual Studio 2012 on Windows 7.</p>

<pre><code>std::string szEncryptionKey= ""qwertyuiopasdfghjklzxcvbnmqwerty"";;
std::string szEncryptionIV= ""0123456789123456"";
std::string str=""I do not like green eggs and ham I do not like them Sam-I-Am. Try them, try them, and you may! Try them and you may, I say. I will not eat them in a house, i will not eat them with a mouse,i will not eat them in a box i will not eat them with a fox, i will not eat them here of there i will not eat them anywhere, I do not like green eggs and ham i do not like them sam i am"";
std::string str_encrypted = encrypt(str, szEncryptionKey, szEncryptionIV);
std::string str_decrypted = decrypt(str_encrypted, szEncryptionKey, szEncryptionIV);

std::cout&lt;&lt; ""str encrypted: ""&lt;&lt;str_encrypted&lt;&lt;std::endl;
std::cout&lt;&lt; ""str decrypted: ""&lt;&lt;str_decrypted&lt;&lt;std::endl;
</code></pre>
","<p>I fixed it! I had changed the AES::BLOCKSIZE to 32 in the library because I was playing around with rijndael. I have now found the error thanks to an answer on sci.crypt that pointed out the errors were every 16 bytes (or the block size for AES)</p>
","3794","<c++><encryption><base64><aes><crypto++>","-1","0","2","2018-03-23 12:10:33","19146892","1","0","2837329","","2013-10-02 20:23:31","2013-10-02 05:28:24",""
"15000688","Crypto++ encrypt and decrypt in two different c++ programs","<p>I am writing a code to encrypt and decrypt with crypto++ library .I found a code to encrypt and decrypt which is shown below.The code works OK as one program.but when I divide into two c++ programs (One for encryption and another for decryption) the decryption pargram gives me error </p>

<blockquote>
  <p><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'   what():  StreamTransformationFilter: ciphertext length is not a multiple of block size</code></p>
</blockquote>

<p>The ciphertext I get after encryption is </p>

<pre><code>���z=(f�����P%���2��W3�p�H�����^��@C��#������bp���nx��
</code></pre>

<p>which I transfer into the decryption code. What am I doing wrong?</p>

<p>my first program for encryption is </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""crypto++/modes.h""
#include ""crypto++/aes.h""
#include ""crypto++/filters.h""

int main(int argc, char* argv[]) {

    //
    // Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-
    //bit). This key is secretly exchanged between two parties before communication
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    //
    // String and Sink setup
    //
    std::string plaintext = ""Now is the time for all good men to come to the aide..."";
    std::string ciphertext;
    std::string decryptedtext;

    //
    // Dump Plain Text
    //
    std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; plaintext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Create Cipher Text
    //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    /////////////////////////////////////////////////////////////////////////

    return 0;
}
</code></pre>

<p>I am sending the ciphertext using URL eg. <a href=""https://xxx.xxx.xx.xx/_SERVER_TEST.fcgi"" rel=""nofollow"">https://xxx.xxx.xx.xx/_SERVER_TEST.fcgi</a>?���z=(f�����P%���2��W3�p�H�����^��@C��#������bp���nx��</p>

<p>and on the other side I an trying to decript my ciphertext . but the URL dont understand the cipher.</p>

<p>my second program Decryption is</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""crypto++/modes.h""
#include ""crypto++/aes.h""
#include ""crypto++/filters.h""

int main(int argc, char* argv[]) {

    //
    // Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-
    //bit). This key is secretly exchanged between two parties before communication
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    std::string ciphertext;
    std::string decryptedtext;

    //
    // Decrypt
    //
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    //
    // Dump Decrypted Text
    //
    std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
    std::cout &lt;&lt; decryptedtext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    /////////////////////////////////////////////////////////////////////////

    return 0;
}
</code></pre>
","","3736","<c++><aes><crypto++><cbc-mode>","1","","0","2014-12-15 08:22:21","","4","2","608639","","2014-04-17 06:30:36","2013-02-21 11:08:33",""
"6220453","How to decrypt PKCS8 DER encrypted private key using the password, in crypto++","<p>I'm trying to sign a message using a private key that is encrypted, I of course have the password to it, so I'm trying to decrypt the key so I can the use it to sign.</p>

<p>I'm using C++ library <code>crypto++</code>, this is the code I'm trying to use to read the key from file</p>

<pre><code>string keyString;
FileSource fs(keyFileName.c_str(), true, new DefaultDecryptorWithMAC(passphrase, new StringSink(keyString)));
</code></pre>

<p>When doing this, it rises a <code>CryptoPP::DefaultDecryptor::KeyBadErr</code>, I know that I have the correct password because I managed to decrypt the key using openssl with the following command line:</p>

<pre><code>openssl pkcs8 -inform DER -passin pass:PASSPHRASE &lt; emisor.key
</code></pre>

<p>This is my first post, I'm not sure if I'm following all the rules to ask the question, but any help or tip will be appreciated.</p>

<p>Regards,</p>

<p>heavy</p>
","<p>PKCS #8 uses a specific encryption format that has nothing to do with Crypto++'s <code>DefaultDecryptorWithMAC</code>. You can find the details in the specification here - <a href=""http://www.rsa.com/rsalabs/node.asp?id=2130"" rel=""nofollow"">http://www.rsa.com/rsalabs/node.asp?id=2130</a></p>

<p>Unfortunately Crypto++ does not currently support encrypted PKCS #8 keys natively. With the ASN.1 and crypto support in the library you can certainly implement it yourself, but it may be easier to simply decrypt the key using the openssl command line tool. Or you could use openssl in your program, or another library that supports encrypted PKCS #8 keys.</p>
","3609","<openssl><crypto++>","3","3","1","2011-06-06 16:23:41","6255037","1","","634025","","2011-06-02 21:26:17","2011-06-02 21:11:54",""
"34043538","no archive symbol table (run ranlib) while building libcryptopp.a through ndk-build","<p>Here i am trying to build libcryptopp.a through ndk-build but i getting error as shown below.</p>

<p>Android.mk </p>

<p><a href=""https://i.stack.imgur.com/mHfzx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/mHfzx.png"" alt=""enter image description here""></a></p>

<p>Application.mk</p>

<p><a href=""https://i.stack.imgur.com/J4K0K.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/J4K0K.png"" alt=""enter image description here""></a></p>

<p>setenv-android.sh its while creating libcryptopp.a and .so by using cryptopp 5.6.3</p>

<p><a href=""https://i.stack.imgur.com/iNNsL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iNNsL.png"" alt=""enter image description here""></a></p>

<p>Error produced in terminal as below</p>

<blockquote>
  <p>$ /Users/kasbahapple/Documents/AndroidDocs/AndroidADT/adt-bundle-mac-x86_64-20140702/sdk/ndk-bundle/ndk-build</p>
  
  <p>[armeabi] Gdbserver      : [arm-linux-androideabi-4.8] libs/armeabi/gdbserver</p>
  
  <p>[armeabi] Gdbsetup       : libs/armeabi/gdb.setup</p>
  
  <p>[armeabi-v7a] Gdbserver      : [arm-linux-androideabi-4.8] libs/armeabi-v7a/gdbserver</p>
  
  <p>[armeabi-v7a] Gdbsetup       : libs/armeabi-v7a/gdb.setup</p>
  
  <p>[x86] Gdbserver      : [x86-4.8] libs/x86/gdbserver</p>
  
  <p>[x86] Gdbsetup       : libs/x86/gdb.setup</p>
  
  <p>[armeabi] Executable     : source_file</p>
  
  <p>/Users/kasbahapple/Documents/AndroidDocs/AndroidADT/adt-bundle-mac-x86_64-20140702/sdk/ndk-bundle/toolchains/arm-linux-androideabi-4.8/prebuilt/darwin-x86_64/bin/../lib/gcc/arm-linux-androideabi/4.8/../../../../arm-linux-androideabi/bin/ld: error: jni/nativelib/libcryptopp.a: no archive symbol table (run ranlib)</p>
  
  <p>/Users/kasbahapple/Documents/AndroidDocs/AndroidADT/adt-bundle-mac-x86_64-20140702/sdk/ndk-bundle/platforms/android-8/arch-arm/usr/lib/crtbegin_dynamic.o:crtbrand.c:function _start: error: undefined reference to 'main'</p>
  
  <p>collect2: error: ld returned 1 exit status</p>
</blockquote>

<p>I really struggling to build c++ static library through NDK.</p>

<p>I looking for solution. Give me a complete steps if i doing wrong.</p>
","<blockquote>
  <p>no archive symbol table (run ranlib) while building libcryptopp.a through ndk-build</p>
</blockquote>

<p>After you build the Crypto++ library through <em><code>Android.mk</code></em>, you need to run <code>ranlib</code> on <code>libcryptopp.a</code>. Unfortunately, I don't know <a href=""https://stackoverflow.com/q/36340060"">how to tell <code>Android.mk</code> to run ranlib</a>.</p>

<p>I'm guessing - and its purely a guess - that you have to do this in two steps in Android.mk. You cannot cut to the chase and build the shared object directly from sources.</p>

<ul>
<li>build <code>libcryptopp.a</code>, running <code>ranlib</code></li>
<li>build <code>libcryptopp.so</code> from <code>libcryptopp.a</code></li>
</ul>

<hr>

<blockquote>
  <p><em>setenv-android.sh its while creating libcryptopp.a and .so by using cryptopp 5.6.3</em><br>
  ...<br>
  <em>APP_STL = gnustl_static</em></p>
</blockquote>

<p>The script <code>setenv-android.sh</code> uses STLport because of GNU licensing encumbrances. Your <code>Android.mk</code> uses GNU's STL.</p>

<p>You should probably also use the same C++ runtime libraries. Additionally, all libraries must use the same runtime. That means OpenGL, Crypto++, [Favorite library], must use the same C++ runtime, and there's no mixing and matching. In addition, because multiple libraries are using the C++ runtime, you must use the shared object, and not the static version.</p>

<p>There's a README in the NDK somewhere that discusses it. I think its called CPP-README or similar.</p>

<hr>

<p>Also, when you invoke the <code>setenv-android.sh</code>, you <strong><em>must</em></strong> include a leading dot. Then you run the <code>GNUmakefile-cross</code>:</p>

<pre><code>. ./setenv-android.sh
make -f GNUmakefile-cross static dynamic cryptest.exe
</code></pre>

<hr>

<p>Finally, please don't post pictures. I can barely read them because my eyes are old. Usually, appeasing one user does not matter. In this case, I'm the guy who wrote the scripts and the wiki pages, so you want to make it easy on me, and not hard on me :)</p>
","3609","<android><c++><android-ndk><static-libraries><crypto++>","2","2","1","2016-04-01 22:57:31","","1","","1007302","","2015-12-02 13:14:39","2015-12-02 13:06:09",""
"3024127","Can anyone explain why my crypto++ decrypted file is 16 bytes short?","<p>In order that I might feed AES encrypted text as an <code>std::istream</code> to a parser component I am trying to create a <code>std::streambuf</code> implementation wrapping the vanilla crypto++ encryption/decryption.</p>

<p>The <code>main()</code> function calls the following functions to compare my wrapper with the vanilla implementation:</p>

<ul>
<li><code>EncryptFile()</code> - encrypt file using my streambuf implementation</li>
<li><code>DecryptFile()</code> - decrypt file using my streambuf implementation</li>
<li><code>EncryptFileVanilla()</code> - encrypt file using vanilla crypto++</li>
<li><code>DecryptFileVanilla()</code> - decrypt file using vanilla crypto++</li>
</ul>

<p>The problem is that whilst the encrypted files created by <code>EncryptFile()</code> and <code>EncryptFileVanilla()</code> are identical. The decrypted file created by <code>DecryptFile()</code> is incorrect being 16 bytes short of that created by <code>DecryptFileVanilla()</code>. Probably not coincidentally the block size is also 16.</p>

<p>I think the issue must be in <code>CryptStreamBuffer::GetNextChar()</code>, but I've been staring at it and the crypto++ documentation for hours.</p>

<p>Can anybody help/explain?</p>

<p>Any other comments about how crummy or naive my <code>std::streambuf</code> implementation are also welcome ;-)</p>

<p>Thanks,</p>

<p>Tom</p>

<pre><code>// Runtime Includes
#include &lt;iostream&gt;

// Crypto++ Includes
#include ""aes.h""
#include ""modes.h""      // xxx_Mode&lt; &gt;
#include ""filters.h""    // StringSource and
                        // StreamTransformation
#include ""files.h""

using namespace std;

class CryptStreamBuffer: public std::streambuf {

public:

    CryptStreamBuffer(istream&amp; encryptedInput, CryptoPP::StreamTransformation&amp; c);

    CryptStreamBuffer(ostream&amp; encryptedOutput, CryptoPP::StreamTransformation&amp; c);

    ~CryptStreamBuffer();

protected:
    virtual int_type overflow(int_type ch = traits_type::eof());

    virtual int_type uflow();

    virtual int_type underflow();

    virtual int_type pbackfail(int_type ch);

    virtual int sync();

private:
    int GetNextChar();

    int m_NextChar; // Buffered character

    CryptoPP::StreamTransformationFilter* m_StreamTransformationFilter;

    CryptoPP::FileSource* m_Source;

    CryptoPP::FileSink* m_Sink;

}; // class CryptStreamBuffer

CryptStreamBuffer::CryptStreamBuffer(istream&amp; encryptedInput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, 0, CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING);
    m_Source = new CryptoPP::FileSource(encryptedInput, false, m_StreamTransformationFilter);
}

CryptStreamBuffer::CryptStreamBuffer(ostream&amp; encryptedOutput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_Sink = new CryptoPP::FileSink(encryptedOutput);
    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, m_Sink, CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING);
}

CryptStreamBuffer::~CryptStreamBuffer() {

    if (m_Sink) {
        delete m_StreamTransformationFilter;
        // m_StreamTransformationFilter owns and deletes m_Sink.
    }
    if (m_Source) {
        delete m_Source;
        // m_Source owns and deletes m_StreamTransformationFilter.
    }
}

CryptStreamBuffer::int_type CryptStreamBuffer::overflow(int_type ch) {

    return m_StreamTransformationFilter-&gt;Put((byte)ch);
}

CryptStreamBuffer::int_type CryptStreamBuffer::uflow() {

    int_type result = GetNextChar();

    // Reset the buffered character
    m_NextChar = traits_type::eof();

    return result;
}

CryptStreamBuffer::int_type CryptStreamBuffer::underflow() {

    return GetNextChar();
}

CryptStreamBuffer::int_type CryptStreamBuffer::pbackfail(int_type ch) {

    return traits_type::eof();
}

int CryptStreamBuffer::sync() {

    // TODO: Not sure sync is the correct place to be doing this.
    //       Should it be in the destructor?
    if (m_Sink) {
        m_StreamTransformationFilter-&gt;MessageEnd();
        // m_StreamTransformationFilter-&gt;Flush(true);
    }

    return 0;
}

int CryptStreamBuffer::GetNextChar() {

    // If we have a buffered character do nothing
    if (m_NextChar != traits_type::eof()) {
        return m_NextChar;
    }

    // If there are no more bytes currently available then pump the source
    if (m_StreamTransformationFilter-&gt;MaxRetrievable() == 0) {
        m_Source-&gt;Pump(1024);
    }

    // Retrieve the next byte
    byte nextByte;
    size_t noBytes = m_StreamTransformationFilter-&gt;Get(nextByte);
    if (0 == noBytes) {
        return traits_type::eof();
    }

    // Buffer up the next character
    m_NextChar = nextByte;

    return m_NextChar;
}

void InitKey(byte key[]) {

    key[0] = -62;
    key[1] = 102;
    key[2] = 78;
    key[3] = 75;
    key[4] = -96;
    key[5] = 125;
    key[6] = 66;
    key[7] = 125;
    key[8] = -95;
    key[9] = -66;
    key[10] = 114;
    key[11] = 22;
    key[12] = 48;
    key[13] = 111;
    key[14] = -51;
    key[15] = 112;
}

/** Decrypt using my CryptStreamBuffer */
void DecryptFile(const char* sourceFileName, const char* destFileName) {

    ifstream ifs(sourceFileName, ios::in | ios::binary);
    ofstream ofs(destFileName, ios::out | ios::binary);

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor(key, sizeof(key));

    if (ifs) {
        if (ofs) {
            CryptStreamBuffer cryptBuf(ifs, decryptor);
            std::istream decrypt(&amp;cryptBuf);

            int c;
            while (EOF != (c = decrypt.get())) {
                ofs &lt;&lt; (char)c;
            }
            ofs.flush();
        }
        else {
            std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; destFileName &lt;&lt; ""'."" &lt;&lt; endl;
        }
    }
    else {
        std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; sourceFileName &lt;&lt; ""'."" &lt;&lt; endl;
    }  
}

/** Encrypt using my CryptStreamBuffer */
void EncryptFile(const char* sourceFileName, const char* destFileName) {

    ifstream ifs(sourceFileName, ios::in | ios::binary);
    ofstream ofs(destFileName, ios::out | ios::binary);

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor(key, sizeof(key));

    if (ifs) {
        if (ofs) {
            CryptStreamBuffer cryptBuf(ofs, encryptor);
            std::ostream encrypt(&amp;cryptBuf);

            int c;
            while (EOF != (c = ifs.get())) {
                encrypt &lt;&lt; (char)c;
            }
            encrypt.flush();
        }
        else {
            std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; destFileName &lt;&lt; ""'."" &lt;&lt; endl;
        }
    }
    else {
        std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; sourceFileName &lt;&lt; ""'."" &lt;&lt; endl;
    }  
}

/** Decrypt using vanilla crypto++ */
void DecryptFileVanilla(const char* sourceFileName, const char* destFileName) {

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor(key, sizeof(key));

    CryptoPP::FileSource(sourceFileName, true,
      new CryptoPP::StreamTransformationFilter(decryptor,
        new CryptoPP::FileSink(destFileName), CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
      ) // StreamTransformationFilter
    ); // FileSource
}

/** Encrypt using vanilla crypto++ */
void EncryptFileVanilla(const char* sourceFileName, const char* destFileName) {

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor(key, sizeof(key));

    CryptoPP::FileSource(sourceFileName, true,
      new CryptoPP::StreamTransformationFilter(encryptor,
        new CryptoPP::FileSink(destFileName), CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
      ) // StreamTransformationFilter
    ); // FileSource
}

int main(int argc, char* argv[])
{
    EncryptFile(argv[1], ""encrypted.out"");
    DecryptFile(""encrypted.out"", ""decrypted.out"");
    EncryptFileVanilla(argv[1], ""encrypted_vanilla.out"");
    DecryptFileVanilla(""encrypted_vanilla.out"", ""decrypted_vanilla.out"");
    return 0;
}
</code></pre>
","<p><sup>If your input buffer is not a multiplicity of a 16-byte block, you need to stuff the last block with dummy bytes. If the last block is less than 16 bytes it is dropped by crypto++ and not encrypted. When decrypting, you need to truncate the dummy bytes.
That 'another way' you are referring to, already does the addition and truncation for you.
So what should be the dummy bytes, to know how many of them there is, thus should be truncated? I use the following pattern: fill each byte with the value of dummies count.</sup></p>

<p><sup>Examples: You need to add 8 bytes? set them to 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08. You need to add 3 bytes? set them to 0x03, 0x03, 0x03 etc.</sup></p>

<p><sup>When decrypting, get the value of last byte of the output buffer. Assume it is N. Check, if the values last N bytes are equal to N. Truncate, if true.</sup></p>

<p><strong>UPDATE:</strong></p>

<pre><code>CryptStreamBuffer::CryptStreamBuffer(istream&amp; encryptedInput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, 0, CryptoPP::BlockPaddingSchemeDef::ZEROS_PADDING);
    m_Source = new CryptoPP::FileSource(encryptedInput, false, m_StreamTransformationFilter);
}

CryptStreamBuffer::CryptStreamBuffer(ostream&amp; encryptedOutput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_Sink = new CryptoPP::FileSink(encryptedOutput);
    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, m_Sink, CryptoPP::BlockPaddingSchemeDef::ZEROS_PADDING);
}
</code></pre>

<p>Setting the ZEROS_PADDING made your code working (tested on text files). However why it does not work with DEFAULT_PADDING - I did not find the cause yet.</p>
","3413","<c++><encryption><crypto++>","1","3","2","2010-06-14 13:05:38","3037395","7","","3229","","2010-06-14 11:15:43","2010-06-11 15:36:30",""
"3024127","Can anyone explain why my crypto++ decrypted file is 16 bytes short?","<p>In order that I might feed AES encrypted text as an <code>std::istream</code> to a parser component I am trying to create a <code>std::streambuf</code> implementation wrapping the vanilla crypto++ encryption/decryption.</p>

<p>The <code>main()</code> function calls the following functions to compare my wrapper with the vanilla implementation:</p>

<ul>
<li><code>EncryptFile()</code> - encrypt file using my streambuf implementation</li>
<li><code>DecryptFile()</code> - decrypt file using my streambuf implementation</li>
<li><code>EncryptFileVanilla()</code> - encrypt file using vanilla crypto++</li>
<li><code>DecryptFileVanilla()</code> - decrypt file using vanilla crypto++</li>
</ul>

<p>The problem is that whilst the encrypted files created by <code>EncryptFile()</code> and <code>EncryptFileVanilla()</code> are identical. The decrypted file created by <code>DecryptFile()</code> is incorrect being 16 bytes short of that created by <code>DecryptFileVanilla()</code>. Probably not coincidentally the block size is also 16.</p>

<p>I think the issue must be in <code>CryptStreamBuffer::GetNextChar()</code>, but I've been staring at it and the crypto++ documentation for hours.</p>

<p>Can anybody help/explain?</p>

<p>Any other comments about how crummy or naive my <code>std::streambuf</code> implementation are also welcome ;-)</p>

<p>Thanks,</p>

<p>Tom</p>

<pre><code>// Runtime Includes
#include &lt;iostream&gt;

// Crypto++ Includes
#include ""aes.h""
#include ""modes.h""      // xxx_Mode&lt; &gt;
#include ""filters.h""    // StringSource and
                        // StreamTransformation
#include ""files.h""

using namespace std;

class CryptStreamBuffer: public std::streambuf {

public:

    CryptStreamBuffer(istream&amp; encryptedInput, CryptoPP::StreamTransformation&amp; c);

    CryptStreamBuffer(ostream&amp; encryptedOutput, CryptoPP::StreamTransformation&amp; c);

    ~CryptStreamBuffer();

protected:
    virtual int_type overflow(int_type ch = traits_type::eof());

    virtual int_type uflow();

    virtual int_type underflow();

    virtual int_type pbackfail(int_type ch);

    virtual int sync();

private:
    int GetNextChar();

    int m_NextChar; // Buffered character

    CryptoPP::StreamTransformationFilter* m_StreamTransformationFilter;

    CryptoPP::FileSource* m_Source;

    CryptoPP::FileSink* m_Sink;

}; // class CryptStreamBuffer

CryptStreamBuffer::CryptStreamBuffer(istream&amp; encryptedInput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, 0, CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING);
    m_Source = new CryptoPP::FileSource(encryptedInput, false, m_StreamTransformationFilter);
}

CryptStreamBuffer::CryptStreamBuffer(ostream&amp; encryptedOutput, CryptoPP::StreamTransformation&amp; c) :
    m_NextChar(traits_type::eof()),
    m_StreamTransformationFilter(0),
    m_Source(0),
    m_Sink(0) {

    m_Sink = new CryptoPP::FileSink(encryptedOutput);
    m_StreamTransformationFilter = new CryptoPP::StreamTransformationFilter(c, m_Sink, CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING);
}

CryptStreamBuffer::~CryptStreamBuffer() {

    if (m_Sink) {
        delete m_StreamTransformationFilter;
        // m_StreamTransformationFilter owns and deletes m_Sink.
    }
    if (m_Source) {
        delete m_Source;
        // m_Source owns and deletes m_StreamTransformationFilter.
    }
}

CryptStreamBuffer::int_type CryptStreamBuffer::overflow(int_type ch) {

    return m_StreamTransformationFilter-&gt;Put((byte)ch);
}

CryptStreamBuffer::int_type CryptStreamBuffer::uflow() {

    int_type result = GetNextChar();

    // Reset the buffered character
    m_NextChar = traits_type::eof();

    return result;
}

CryptStreamBuffer::int_type CryptStreamBuffer::underflow() {

    return GetNextChar();
}

CryptStreamBuffer::int_type CryptStreamBuffer::pbackfail(int_type ch) {

    return traits_type::eof();
}

int CryptStreamBuffer::sync() {

    // TODO: Not sure sync is the correct place to be doing this.
    //       Should it be in the destructor?
    if (m_Sink) {
        m_StreamTransformationFilter-&gt;MessageEnd();
        // m_StreamTransformationFilter-&gt;Flush(true);
    }

    return 0;
}

int CryptStreamBuffer::GetNextChar() {

    // If we have a buffered character do nothing
    if (m_NextChar != traits_type::eof()) {
        return m_NextChar;
    }

    // If there are no more bytes currently available then pump the source
    if (m_StreamTransformationFilter-&gt;MaxRetrievable() == 0) {
        m_Source-&gt;Pump(1024);
    }

    // Retrieve the next byte
    byte nextByte;
    size_t noBytes = m_StreamTransformationFilter-&gt;Get(nextByte);
    if (0 == noBytes) {
        return traits_type::eof();
    }

    // Buffer up the next character
    m_NextChar = nextByte;

    return m_NextChar;
}

void InitKey(byte key[]) {

    key[0] = -62;
    key[1] = 102;
    key[2] = 78;
    key[3] = 75;
    key[4] = -96;
    key[5] = 125;
    key[6] = 66;
    key[7] = 125;
    key[8] = -95;
    key[9] = -66;
    key[10] = 114;
    key[11] = 22;
    key[12] = 48;
    key[13] = 111;
    key[14] = -51;
    key[15] = 112;
}

/** Decrypt using my CryptStreamBuffer */
void DecryptFile(const char* sourceFileName, const char* destFileName) {

    ifstream ifs(sourceFileName, ios::in | ios::binary);
    ofstream ofs(destFileName, ios::out | ios::binary);

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor(key, sizeof(key));

    if (ifs) {
        if (ofs) {
            CryptStreamBuffer cryptBuf(ifs, decryptor);
            std::istream decrypt(&amp;cryptBuf);

            int c;
            while (EOF != (c = decrypt.get())) {
                ofs &lt;&lt; (char)c;
            }
            ofs.flush();
        }
        else {
            std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; destFileName &lt;&lt; ""'."" &lt;&lt; endl;
        }
    }
    else {
        std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; sourceFileName &lt;&lt; ""'."" &lt;&lt; endl;
    }  
}

/** Encrypt using my CryptStreamBuffer */
void EncryptFile(const char* sourceFileName, const char* destFileName) {

    ifstream ifs(sourceFileName, ios::in | ios::binary);
    ofstream ofs(destFileName, ios::out | ios::binary);

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor(key, sizeof(key));

    if (ifs) {
        if (ofs) {
            CryptStreamBuffer cryptBuf(ofs, encryptor);
            std::ostream encrypt(&amp;cryptBuf);

            int c;
            while (EOF != (c = ifs.get())) {
                encrypt &lt;&lt; (char)c;
            }
            encrypt.flush();
        }
        else {
            std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; destFileName &lt;&lt; ""'."" &lt;&lt; endl;
        }
    }
    else {
        std::cerr &lt;&lt; ""Failed to open file '"" &lt;&lt; sourceFileName &lt;&lt; ""'."" &lt;&lt; endl;
    }  
}

/** Decrypt using vanilla crypto++ */
void DecryptFileVanilla(const char* sourceFileName, const char* destFileName) {

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor(key, sizeof(key));

    CryptoPP::FileSource(sourceFileName, true,
      new CryptoPP::StreamTransformationFilter(decryptor,
        new CryptoPP::FileSink(destFileName), CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
      ) // StreamTransformationFilter
    ); // FileSource
}

/** Encrypt using vanilla crypto++ */
void EncryptFileVanilla(const char* sourceFileName, const char* destFileName) {

    byte key[CryptoPP::AES::DEFAULT_KEYLENGTH];
    InitKey(key);

    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor(key, sizeof(key));

    CryptoPP::FileSource(sourceFileName, true,
      new CryptoPP::StreamTransformationFilter(encryptor,
        new CryptoPP::FileSink(destFileName), CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
      ) // StreamTransformationFilter
    ); // FileSource
}

int main(int argc, char* argv[])
{
    EncryptFile(argv[1], ""encrypted.out"");
    DecryptFile(""encrypted.out"", ""decrypted.out"");
    EncryptFileVanilla(argv[1], ""encrypted_vanilla.out"");
    DecryptFileVanilla(""encrypted_vanilla.out"", ""decrypted_vanilla.out"");
    return 0;
}
</code></pre>
","<p>After working with a debug build of crypto++ it turns out that what was missing was a call to the StreamTransformationFilter advising it that there would be nothing more coming from the Source and that it should wrap up the processing of the final few bytes, including the padding.</p>

<p>In <code>CryptStreamBuffer::GetNextChar()</code>:</p>

<p>Replace:</p>

<pre><code>// If there are no more bytes currently available then pump the source
if (m_StreamTransformationFilter-&gt;MaxRetrievable() == 0) {
    m_Source-&gt;Pump(1024);
}
</code></pre>

<p>With:</p>

<pre><code>// If there are no more bytes currently available from the filter then
// pump the source.
if (m_StreamTransformationFilter-&gt;MaxRetrievable() == 0) {
    if (0 == m_Source-&gt;Pump(1024)) {
        // This seems to be required to ensure the final bytes are readable
        // from the filter.
        m_StreamTransformationFilter-&gt;ChannelMessageEnd(CryptoPP::DEFAULT_CHANNEL);
    }
}
</code></pre>

<p>I make no claims that this is the best solution, just one I discovered by trial and error that <b>appears</b> to work.</p>
","3413","<c++><encryption><crypto++>","1","5","2","2010-06-14 13:05:38","3037395","7","","3229","","2010-06-14 11:15:43","2010-06-11 15:36:30",""
"9984692","Include Crypto++ Library in Android Project via NDK","<p>I am trying to include Crypto++ (http://www.cryptopp.com/) in an Android NDK project. I want to be able to call Crypto++ member functions from the C++ portion of my code. I thought I could just include the headers and source from Crypto++ in my C++ code but I can't seem to get it to work.</p>

<p>My C++ file looks like this:</p>

<pre><code>#include &lt;jni.h&gt;
#include ""cryptopp/modes.h""
#include ""cryptopp/aes.h""
using namespace CryptoPP;
...
</code></pre>

<p>with all of the Crypto++ headers and source files in the cryptopp subdirectory.</p>

<p>Initially I received many compile errors since the standard C++ libraries were not being found, but I fixed that by adding Application.mk with the following line:</p>

<pre><code>APP_STL := stlport_static
</code></pre>

<p>Compiling with ndk-build (both the standard and crystax versions) gives me the following error:</p>

<pre><code>ABI='armeabi'
ABI='armeabi-v7a'
ABI='x86'
Gdbserver      : [arm-linux-androideabi-4.4.3] libs/armeabi/gdbserver
Gdbsetup       : libs/armeabi/gdb.setup
Compile++ thumb  : ndk-tests-cpp &lt;= ndk-tests.cpp
In file included from jni/cryptopp/modes.h:7,
             from jni/ndk-tests.cpp:2:
jni/cryptopp/cryptlib.h: In static member function 'static void CryptoPP::NameValuePairs::ThrowIfTypeMismatch(const char*, const std::type_info&amp;, const std::type_info&amp;)':
jni/cryptopp/cryptlib.h:291: error: exception handling disabled, use -fexceptions to enable
make: *** [obj/local/armeabi/objs-debug/ndk-tests-cpp/ndk-tests.o] Error 1
</code></pre>

<p>I have never included an external library in an NDK project before - maybe I am just overlooking something basic.</p>
","<p>You have to enable exceptions for your Android project. Try to include these lines into your Applications.mk:</p>

<pre><code>APP_CPPFLAGS += -frtti 
APP_CPPFLAGS += -fexceptions
</code></pre>
","3322","<android><c++><android-ndk><crypto++>","3","6","1","2016-06-05 18:36:17","10366882","1","1","3865653","","2016-06-05 18:36:17","2012-04-02 22:26:51",""
"26145776","std::string to SecByteBlock conversion","<p>I'm currently writing blowfish encryption/decryprion program in C++ (using crypto++).</p>

<p>I really didn't find a satisfied answer at google. I'm trying to send a key of a SecByteBlock as a string and then received in the other part as string then need to be regained to SecByteBlock.</p>

<p>Is it possible to convert string &lt;--> SecByteBlock</p>

<p>Can I do something better to send key from one function to another?</p>

<p>Thank you for help in advance.</p>

<p>The code I use is the following: </p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;
    SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
    prng.GenerateBlock(key, key.size());

    byte iv[Blowfish::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
    BLOCK test = ReadStaticBlocks(""testBin.dat"");

    string plain=test.bl1 ;
    string cipher, encoded, recovered;

    /*********************************\
    \*********************************/

    // Pretty print key
    encoded.clear();
    StringSource ss1(key, key.size(), true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;

    // Pretty print iv
    encoded.clear();
    StringSource ss2(iv, sizeof(iv), true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;

    /*********************************\
    \*********************************/

    try
    {
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        CBC_Mode&lt; Blowfish &gt;::Encryption e;
        e.SetKeyWithIV(key, key.size(), iv);

        // The StreamTransformationFilter adds padding
        //  as required. ECB and CBC Mode must be padded
        //  to the block size of the cipher.
        StringSource ss3(plain, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter      
        ); // StringSource


    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/

    // Pretty print
    encoded.clear();
    StringSource ss4(cipher, true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

    /*********************************\
    \*********************************/

    try
    {
        CBC_Mode&lt; Blowfish &gt;::Decryption d;
        d.SetKeyWithIV(key, key.size(), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource ss5(cipher, true, 
            new StreamTransformationFilter(d,
                new StringSink(recovered)
            ) // StreamTransformationFilter
        ); // StringSource

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/
    system(""pause"");
    return 0;
}
</code></pre>
","<blockquote>
  <p>Is it possible to convert string &lt;--> SecByteBlock</p>
</blockquote>

<p>Yes. Each has a constructor that takes a pointer and a length.</p>

<pre><code>string s1(""hello world"");
SecByteBlock b1((const byte*)s1.data(), s1.size());
</code></pre>

<p>And</p>

<pre><code>byte a[] = {'h','e','l','l','o',' ','w','o','r','l','d'}; 
SecByteBlock b2(a, sizeof(a));
string s2((const char*)b2.data(), b2.size());
</code></pre>

<p>And in your case, the <a href=""http://www.cryptopp.com/docs/ref/class_string_source.html"" rel=""nofollow noreferrer""><code>StringSource</code></a> also has a constructor that takes a pointer and a length. So you could perform:</p>

<pre><code>byte a[] = {'h','e','l','l','o',' ','w','o','r','l','d'}; 
SecByteBlock b3(a, sizeof(a));

StringSource ss1(b3.data(), b3.size(), true ...);
</code></pre>

<p>Or even more directly:</p>

<pre><code>byte a[] = {'h','e','l','l','o',' ','w','o','r','l','d'}; 
StringSource ss1(a, sizeof(a), true ...);
</code></pre>
","3274","<c++><string><crypto++><converters>","1","5","2","2019-03-05 20:11:05","","1","0","608639","","2019-03-05 20:11:05","2014-10-01 16:11:34",""
"26145776","std::string to SecByteBlock conversion","<p>I'm currently writing blowfish encryption/decryprion program in C++ (using crypto++).</p>

<p>I really didn't find a satisfied answer at google. I'm trying to send a key of a SecByteBlock as a string and then received in the other part as string then need to be regained to SecByteBlock.</p>

<p>Is it possible to convert string &lt;--> SecByteBlock</p>

<p>Can I do something better to send key from one function to another?</p>

<p>Thank you for help in advance.</p>

<p>The code I use is the following: </p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;
    SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
    prng.GenerateBlock(key, key.size());

    byte iv[Blowfish::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
    BLOCK test = ReadStaticBlocks(""testBin.dat"");

    string plain=test.bl1 ;
    string cipher, encoded, recovered;

    /*********************************\
    \*********************************/

    // Pretty print key
    encoded.clear();
    StringSource ss1(key, key.size(), true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;

    // Pretty print iv
    encoded.clear();
    StringSource ss2(iv, sizeof(iv), true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;

    /*********************************\
    \*********************************/

    try
    {
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        CBC_Mode&lt; Blowfish &gt;::Encryption e;
        e.SetKeyWithIV(key, key.size(), iv);

        // The StreamTransformationFilter adds padding
        //  as required. ECB and CBC Mode must be padded
        //  to the block size of the cipher.
        StringSource ss3(plain, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter      
        ); // StringSource


    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/

    // Pretty print
    encoded.clear();
    StringSource ss4(cipher, true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

    /*********************************\
    \*********************************/

    try
    {
        CBC_Mode&lt; Blowfish &gt;::Decryption d;
        d.SetKeyWithIV(key, key.size(), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource ss5(cipher, true, 
            new StreamTransformationFilter(d,
                new StringSink(recovered)
            ) // StreamTransformationFilter
        ); // StringSource

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/
    system(""pause"");
    return 0;
}
</code></pre>
","<p>A small correction to the previous answer.</p>

<pre><code>string s1(""hello world"");
SecByteBlock b1((const unsigned char *)(s1.data()), s1.size());
</code></pre>

<p>It works perfectly.</p>

<p>Thank you, it solve my problem too.</p>
","3274","<c++><string><crypto++><converters>","1","0","2","2019-03-05 20:11:05","","1","0","608639","","2019-03-05 20:11:05","2014-10-01 16:11:34",""
"17482230","How to use Crypto++ with Jni or NDK for a Android application","<p>I download from Crypto++ <a href=""http://www.cryptopp.com/"" rel=""noreferrer"">Here</a>.
I find some way to build it with visual studio.
So I don't know how to use it for our Android application with jni or Ndk.</p>
","<p>The Crypto++ wiki has a page with build instructions from the command line at <a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">Android (Command Line)</a>. The steps are:</p>

<ul>
<li>Modify the source files to accommodate Android</li>
<li>Modify the <code>GNUmakefile</code> to accommodate Android</li>
<li>Set a cross compile environment via <code>setenv-android.sh</code></li>
<li>Run make</li>
</ul>

<p>The process will create the various libraries and show you how to build <code>cryptest.exe</code> and verify the library on a device. But you will still need to create you wrapper project using Android's build system.</p>

<p>Piotr Morgwai Kotarbiński has a page on building the Crypto++ library with Android's modified build system. See <a href=""http://morgwai.pl/ndkTutorial/#heading_toc_j_2"" rel=""nofollow"">Building Crypto++ with NDK toolchain</a>. I don't believe Piotr's article verifies the library on a device.</p>
","3123","<android><c++><c><android-ndk><crypto++>","8","1","2","2015-04-30 18:54:07","","1","","1197031","","2013-07-05 06:27:11","2013-07-05 06:14:18",""
"17482230","How to use Crypto++ with Jni or NDK for a Android application","<p>I download from Crypto++ <a href=""http://www.cryptopp.com/"" rel=""noreferrer"">Here</a>.
I find some way to build it with visual studio.
So I don't know how to use it for our Android application with jni or Ndk.</p>
","<p>First of all, and it generally goes without saying - read the manual of crypto++ on the desired subject (Android usage). Previous answers have kindly provided the links to the required documentation.</p>

<p>You should cross-compile the library for your desired linkage type (static/dynamic) - for that purpose you should create and Android.mk, which will describe the compilation process of the lib and then you should add that Android.mk to your main Android.mk as a module. </p>

<p>Alternatively you can search for a prebuilt binary and include this one in you Android.mk.</p>

<p>The process is not specific to crypto++, it's just the way to go with NDK. </p>
","3123","<android><c++><c><android-ndk><crypto++>","8","-1","2","2015-04-30 18:54:07","","1","","1197031","","2013-07-05 06:27:11","2013-07-05 06:14:18",""
"10869706","Using Crypto++ with clang","<p>I'm attempting to get the following Crypto++ (C++ Class Library of Cryptographic Schemes) example to work on a iMac using clang++.</p>

<p>Example</p>

<pre><code>SHA256 hash;

byte digest[ SHA256::DIGESTSIZE ];

hash.CalculateDigest( digest, (byte*) &amp;value[ 0 ], value.size( ) );

HexEncoder encoder;

string result = String::empty;

encoder.Attach( new StringSink( result ) );

encoder.Put( digest, sizeof( digest ) );

encoder.MessageEnd( );
</code></pre>

<p>Build command</p>

<pre><code>Apple clang version 2.1 (tags/Apple/clang-163.7.1) (based on LLVM 3.0svn)
Target: x86_64-apple-darwin11.4.0
Thread model: posix
 ""/usr/bin/clang"" -cc1 -triple x86_64-apple-macosx10.7.4 -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name checksum_impl.cpp -pic-level 2 -mdisable-fp-elim -relaxed-aliasing -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 123.2.1 -v -resource-dir /usr/bin/../lib/clang/2.1 -D framework_EXPORTS -I /Users/Ben/Dropbox/appon/build/../source -nostdinc++ -cxx-isystem /usr/include/c++/v1 -Wall -Wextra -Weffc++ -pedantic -std=c++0x -fdeprecated-macro -ferror-limit 19 -fmessage-length 175 -stack-protector 1 -fblocks -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -o CMakeFiles/framework.dir/Users/Ben/Dropbox/source/example.cpp.o -x c++ /Users/Ben/Dropbox/source/example.cpp
clang -cc1 version 2.1 based upon llvm 3.0svn hosted on x86_64-apple-darwin11.4.0
#include ""..."" search starts here:
#include &lt;...&gt; search starts here:
 /Users/Ben/Dropbox/build/../source
 /usr/include/c++/v1
 /usr/local/include
 /usr/bin/../lib/clang/2.1/include
 /usr/include
 /System/Library/Frameworks (framework directory)
 /Library/Frameworks (framework directory)
End of search list.
</code></pre>

<p>Linker output</p>

<pre><code>clang: warning: argument unused during compilation: '-std=c++0x'
Undefined symbols for architecture x86_64:
  ""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) const"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPut2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelFlush(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 2
</code></pre>

<p>I'm using the latest development version of Crypto++ 5.6.2 as the previous version 5.6.1 fails to build with clang++. However i'm encountering build issues stating that i have missing symbols for x86_64 architecture.</p>

<p>Any hints would be greatly appreciated.</p>
","<p>you need to link to the library that provides those symbols, which should be libcryptopp.so, using<code>-lcryptopp</code> in the compiler command</p>

<p>Looking at your ""build command"" (which is not the command you're running, it's the <em>output</em> of the command you're running, it would be a lot easier to read if you showed the actual command) it seems you are compiling a <code>.cpp</code> file into a <code>.o</code> file, but getting a linker error, which is strange as producing a <code>.o</code> file is usualy the step <em>before</em> linking. What step are you trying to do?  Maybe you also need to add <code>-c</code> so it only compiles and doesn't try to link.  You will still need <code>-lcryptopp</code> when linking.</p>
","3002","<macos><crypto++><undefined-symbol><clang++><missing-symbols>","3","2","4","2015-09-04 17:18:08","11484930","0","1","","","","2012-06-03 10:53:10",""
"10869706","Using Crypto++ with clang","<p>I'm attempting to get the following Crypto++ (C++ Class Library of Cryptographic Schemes) example to work on a iMac using clang++.</p>

<p>Example</p>

<pre><code>SHA256 hash;

byte digest[ SHA256::DIGESTSIZE ];

hash.CalculateDigest( digest, (byte*) &amp;value[ 0 ], value.size( ) );

HexEncoder encoder;

string result = String::empty;

encoder.Attach( new StringSink( result ) );

encoder.Put( digest, sizeof( digest ) );

encoder.MessageEnd( );
</code></pre>

<p>Build command</p>

<pre><code>Apple clang version 2.1 (tags/Apple/clang-163.7.1) (based on LLVM 3.0svn)
Target: x86_64-apple-darwin11.4.0
Thread model: posix
 ""/usr/bin/clang"" -cc1 -triple x86_64-apple-macosx10.7.4 -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name checksum_impl.cpp -pic-level 2 -mdisable-fp-elim -relaxed-aliasing -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 123.2.1 -v -resource-dir /usr/bin/../lib/clang/2.1 -D framework_EXPORTS -I /Users/Ben/Dropbox/appon/build/../source -nostdinc++ -cxx-isystem /usr/include/c++/v1 -Wall -Wextra -Weffc++ -pedantic -std=c++0x -fdeprecated-macro -ferror-limit 19 -fmessage-length 175 -stack-protector 1 -fblocks -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -o CMakeFiles/framework.dir/Users/Ben/Dropbox/source/example.cpp.o -x c++ /Users/Ben/Dropbox/source/example.cpp
clang -cc1 version 2.1 based upon llvm 3.0svn hosted on x86_64-apple-darwin11.4.0
#include ""..."" search starts here:
#include &lt;...&gt; search starts here:
 /Users/Ben/Dropbox/build/../source
 /usr/include/c++/v1
 /usr/local/include
 /usr/bin/../lib/clang/2.1/include
 /usr/include
 /System/Library/Frameworks (framework directory)
 /Library/Frameworks (framework directory)
End of search list.
</code></pre>

<p>Linker output</p>

<pre><code>clang: warning: argument unused during compilation: '-std=c++0x'
Undefined symbols for architecture x86_64:
  ""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) const"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPut2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelFlush(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 2
</code></pre>

<p>I'm using the latest development version of Crypto++ 5.6.2 as the previous version 5.6.1 fails to build with clang++. However i'm encountering build issues stating that i have missing symbols for x86_64 architecture.</p>

<p>Any hints would be greatly appreciated.</p>
","<p>This issue was relating to Crypto++ not having been ported over to llvm-clang++. See <a href=""http://www.cryptopp.com/wiki/Compiling"" rel=""nofollow"">here</a> for supported compilers.</p>

<p>My solution was to use <a href=""http://www.gnu.org/software/libgcrypt/"" rel=""nofollow"">GCrypt</a>.</p>

<p>Sorry I can't supply anymore details on the cause of the failure.</p>
","3002","<macos><crypto++><undefined-symbol><clang++><missing-symbols>","3","0","4","2015-09-04 17:18:08","11484930","0","1","","","","2012-06-03 10:53:10",""
"10869706","Using Crypto++ with clang","<p>I'm attempting to get the following Crypto++ (C++ Class Library of Cryptographic Schemes) example to work on a iMac using clang++.</p>

<p>Example</p>

<pre><code>SHA256 hash;

byte digest[ SHA256::DIGESTSIZE ];

hash.CalculateDigest( digest, (byte*) &amp;value[ 0 ], value.size( ) );

HexEncoder encoder;

string result = String::empty;

encoder.Attach( new StringSink( result ) );

encoder.Put( digest, sizeof( digest ) );

encoder.MessageEnd( );
</code></pre>

<p>Build command</p>

<pre><code>Apple clang version 2.1 (tags/Apple/clang-163.7.1) (based on LLVM 3.0svn)
Target: x86_64-apple-darwin11.4.0
Thread model: posix
 ""/usr/bin/clang"" -cc1 -triple x86_64-apple-macosx10.7.4 -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name checksum_impl.cpp -pic-level 2 -mdisable-fp-elim -relaxed-aliasing -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 123.2.1 -v -resource-dir /usr/bin/../lib/clang/2.1 -D framework_EXPORTS -I /Users/Ben/Dropbox/appon/build/../source -nostdinc++ -cxx-isystem /usr/include/c++/v1 -Wall -Wextra -Weffc++ -pedantic -std=c++0x -fdeprecated-macro -ferror-limit 19 -fmessage-length 175 -stack-protector 1 -fblocks -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -o CMakeFiles/framework.dir/Users/Ben/Dropbox/source/example.cpp.o -x c++ /Users/Ben/Dropbox/source/example.cpp
clang -cc1 version 2.1 based upon llvm 3.0svn hosted on x86_64-apple-darwin11.4.0
#include ""..."" search starts here:
#include &lt;...&gt; search starts here:
 /Users/Ben/Dropbox/build/../source
 /usr/include/c++/v1
 /usr/local/include
 /usr/bin/../lib/clang/2.1/include
 /usr/include
 /System/Library/Frameworks (framework directory)
 /Library/Frameworks (framework directory)
End of search list.
</code></pre>

<p>Linker output</p>

<pre><code>clang: warning: argument unused during compilation: '-std=c++0x'
Undefined symbols for architecture x86_64:
  ""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) const"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPut2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelFlush(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 2
</code></pre>

<p>I'm using the latest development version of Crypto++ 5.6.2 as the previous version 5.6.1 fails to build with clang++. However i'm encountering build issues stating that i have missing symbols for x86_64 architecture.</p>

<p>Any hints would be greatly appreciated.</p>
","<p>In addition to Jonathon's answer because this is a fairly prevalent problem <em>when</em> <code>-lcryptopp</code> is specified...</p>

<blockquote>
  <p>Undefined symbols for architecture x86_64. <code>CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool)""</code>...</p>
</blockquote>

<p>The <code>__1</code> indicates you are using the LLVM C++ runtime (<code>libc++</code>). Somewhere, you are probably mixing and matching with the GNU C++ runtime (<code>libstdc++</code>). The GNU C++ runtime (<code>libstdc++</code>) lacks the <code>__1</code> decoration on its symbols.</p>

<p>You should go through the project <strong><em>and</em></strong> all pre-built libraries, and ensure they are using one or the other. For each, you should use <code>CXXFLAGS</code> of either (1) <code>-stdlib=libc++</code> (LLVM), or (2) <code>-stdlib=libstdc++</code> (GNU).</p>

<p>Be aware that IDEs like Xcode may use a different <code>-stdlib=...</code> setting than Crypto++. In this case, have Xcode match Crypto++, or rebuild the Crypto++ library to match Xcode.</p>

<p>If Xcode is using LLVM's <code>libc++</code> and you have to rebuild Crypto++, then open the <code>GNUmakefile</code> and rework this section (around line 90):</p>

<pre><code>ifeq ($(UNAME),Darwin)
  AR = libtool
  ARFLAGS = -static -o
  CXX = c++
  IS_GCC2 = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c gcc-932)
ifeq ($(IS_GCC2),1)
    CXXFLAGS += -fno-coalesce-templates -fno-coalesce-static-vtables
    LDLIBS += -lstdc++
    LDFLAGS += -flat_namespace -undefined suppress -m
endif
endif
</code></pre>

<p>If you want to use LLVM's <code>libc++</code>, then remove:</p>

<pre><code># GNU C++ Runtime
LDLIBS += -lstdc++
</code></pre>

<p>And add:</p>

<pre><code># LLVM C++ Runtime
CXXFLAGS += -stdlib=libc++
</code></pre>

<p>For completeness, if you want to use GNU's runtime, then remove the <code>LDLIBS += -lstdc++</code> and add <code>CXXFLAGS += -stdlib=libstdc++</code>.</p>

<p>You can also change <code>CXX = c++</code> to <code>CXX ?= c++</code> so the makefile will use <code>c++</code> <em>if</em> its not specified in the environment or command line.</p>

<hr>

<p>If interested, the <code>__1</code> is an inline namespace used for versioning. See <a href=""https://stackoverflow.com/q/11016220"">What are inline namespaces for?</a> and <a href=""https://stackoverflow.com/q/29293394"">Where does the __1 symbol come from when using LLVM's libc++?</a>.</p>
","3002","<macos><crypto++><undefined-symbol><clang++><missing-symbols>","3","1","4","2015-09-04 17:18:08","11484930","0","1","","","","2012-06-03 10:53:10",""
"10869706","Using Crypto++ with clang","<p>I'm attempting to get the following Crypto++ (C++ Class Library of Cryptographic Schemes) example to work on a iMac using clang++.</p>

<p>Example</p>

<pre><code>SHA256 hash;

byte digest[ SHA256::DIGESTSIZE ];

hash.CalculateDigest( digest, (byte*) &amp;value[ 0 ], value.size( ) );

HexEncoder encoder;

string result = String::empty;

encoder.Attach( new StringSink( result ) );

encoder.Put( digest, sizeof( digest ) );

encoder.MessageEnd( );
</code></pre>

<p>Build command</p>

<pre><code>Apple clang version 2.1 (tags/Apple/clang-163.7.1) (based on LLVM 3.0svn)
Target: x86_64-apple-darwin11.4.0
Thread model: posix
 ""/usr/bin/clang"" -cc1 -triple x86_64-apple-macosx10.7.4 -emit-obj -mrelax-all -disable-free -disable-llvm-verifier -main-file-name checksum_impl.cpp -pic-level 2 -mdisable-fp-elim -relaxed-aliasing -masm-verbose -munwind-tables -target-cpu core2 -target-linker-version 123.2.1 -v -resource-dir /usr/bin/../lib/clang/2.1 -D framework_EXPORTS -I /Users/Ben/Dropbox/appon/build/../source -nostdinc++ -cxx-isystem /usr/include/c++/v1 -Wall -Wextra -Weffc++ -pedantic -std=c++0x -fdeprecated-macro -ferror-limit 19 -fmessage-length 175 -stack-protector 1 -fblocks -fcxx-exceptions -fexceptions -fdiagnostics-show-option -fcolor-diagnostics -o CMakeFiles/framework.dir/Users/Ben/Dropbox/source/example.cpp.o -x c++ /Users/Ben/Dropbox/source/example.cpp
clang -cc1 version 2.1 based upon llvm 3.0svn hosted on x86_64-apple-darwin11.4.0
#include ""..."" search starts here:
#include &lt;...&gt; search starts here:
 /Users/Ben/Dropbox/build/../source
 /usr/include/c++/v1
 /usr/local/include
 /usr/bin/../lib/clang/2.1/include
 /usr/include
 /System/Library/Frameworks (framework directory)
 /Library/Frameworks (framework directory)
End of search list.
</code></pre>

<p>Linker output</p>

<pre><code>clang: warning: argument unused during compilation: '-std=c++0x'
Undefined symbols for architecture x86_64:
  ""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) const"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned long&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPut2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelFlush(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, int, bool)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
  ""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)"", referenced from:
      vtable for CryptoPP::SimpleProxyFilter in checksum_impl.cpp.o
      vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
      vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in checksum_impl.cpp.o
ld: symbol(s) not found for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [all] Error 2
</code></pre>

<p>I'm using the latest development version of Crypto++ 5.6.2 as the previous version 5.6.1 fails to build with clang++. However i'm encountering build issues stating that i have missing symbols for x86_64 architecture.</p>

<p>Any hints would be greatly appreciated.</p>
","<p>Crypto++ 5.6.2 successfully build on LLVM version 6.1.0 (clang-602.0.53) with make options:</p>

<pre><code>CXXFLAGS=""-std=c++11 -stdlib=libstdc++ -DCRYPTOPP_DISABLE_ASM -Wno-c++11-narrowing""
</code></pre>

<p>accordingly this script: <a href=""https://github.com/mapnik/mapnik-packaging/blob/master/osx/scripts/build_cryptopp.sh"" rel=""nofollow noreferrer"">https://github.com/mapnik/mapnik-packaging/blob/master/osx/scripts/build_cryptopp.sh</a></p>

<p>-stdlib=libstdc++ need for MacOSX since Mavericks, see: <a href=""https://stackoverflow.com/questions/19774778/when-is-it-necessary-to-use-use-the-flag-stdlib-libstdc"">When is it necessary to use use the flag -stdlib=libstdc++?</a></p>
","3002","<macos><crypto++><undefined-symbol><clang++><missing-symbols>","3","3","4","2015-09-04 17:18:08","11484930","0","1","","","","2012-06-03 10:53:10",""
"4632992","Generated encrypted string does not have same size in PyCrypto and Crypto++","<p>I recently used a Python script to encrypt a string. But could not decrypt it in C++ using Crypto++. I just compared generated encrypted strings and found they are not the same. Anybody can help?</p>

<p>Here is my Python code:</p>

<pre><code>key  = ""0123456789abcdef""
data = ""ccccccccccccccccdddddddddddddddd""
iv = ""aaaaaaaaaaaaaaaa""
encryptor = AES.new(key, AES.MODE_CBC, iv)
enc = encryptor.encrypt(data)
print enc
</code></pre>

<p>Here is my C++ code:</p>

<pre><code>std::string key = ""0123456789abcdef"";
std::string iv  = ""aaaaaaaaaaaaaaaa"";


std::string plaintext = ""ccccccccccccccccdddddddddddddddd"";
std::string ciphertext;
std::string decryptedtext;

std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
std::cout &lt;&lt; plaintext;
std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

CryptoPP::AES::Encryption aesEncryption((byte *)key.c_str(), CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, (byte *)iv.c_str() );

CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
stfEncryptor.MessageEnd();

std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

for( int i = 0; i &lt; ciphertext.size(); i++ ) {

    std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
}

CryptoPP::AES::Decryption aesDecryption((byte *)key.c_str(), CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, (byte *)iv.c_str() );

CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
stfDecryptor.MessageEnd();

std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
std::cout &lt;&lt; decryptedtext;
std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
</code></pre>
","<p>By default, Crypto++ employs PKCS5 padding to the plaintext strings. This <strong>adds padding to the end</strong> of the string to make sure the string is a multiple of the block size which, for AES, is 16 bytes. If the plaintext is already a multiple of 16, Crypto++ adds another 16 bytes of padding to the plaintext and then encrypts the whole thing. PyCrypto doesn't add this extra padding, leaving it up to the user to ensure the correct block size. Note that when you decrypt the Crypto++-encrypted cipher text, the extra padding is automatically removed.</p>
","2957","<c++><python><aes><crypto++><pycrypto>","4","4","1","2011-05-17 08:31:57","","2","1","505893","","2011-05-17 08:31:49","2011-01-08 07:54:10",""
"23223528","How to add Crypto++ library to Qt project","<p>I downloaded the Crypto++ source and compiled the cryptlib project in Visual Studio 2013, and then I added the generated .lib file to my Qt project, which made my .pro file look like this:</p>

<pre><code>QT       += core gui

QT += sql

greaterThan(QT_MAJOR_VERSION, 4):QT += widgets

TARGET = untitled
TEMPLATE = app


SOURCES += main.cpp\
        mainwindow.cpp

HEADERS  += mainwindow.h \
        databasecontrol.h \
    test.h

FORMS    += mainwindow.ui

win32:CONFIG(release, debug|release): LIBS += -L$$PWD/ -lcryptlib
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/ -lcryptlibd
else:unix: LIBS += -L$$PWD/ -lcryptlib

INCLUDEPATH += $$PWD/
DEPENDPATH += $$PWD/

win32-g++:CONFIG(release, debug|release): PRE_TARGETDEPS += $$PWD/libcryptlib.a
else:win32-g++:CONFIG(debug, debug|release): PRE_TARGETDEPS += $$PWD/libcryptlibd.a
else:win32:!win32-g++:CONFIG(release, debug|release): PRE_TARGETDEPS += $$PWD/cryptlib.lib
else:win32:!win32-g++:CONFIG(debug, debug|release): PRE_TARGETDEPS += $$PWD/cryptlibd.lib
else:unix: PRE_TARGETDEPS += $$PWD/libcryptlib.a
</code></pre>

<p>Immediately after adding this library to the project, I build it and get the following error:</p>

<p><code>:-1: error: No rule to make target 'C:/Users/Special Services/WorkOrder/libcryptlibd.a', needed by 'debug\untitled.exe'.  Stop.</code></p>

<p>I believe I understand that the error is telling me that I need an additional line where all of the <code>else:win32</code> lines are under <code>DEPENDPATH</code>... or is it because the lines that were added use <code>$$PWD</code>, isn't that a Unix command? I've looked around at other instances of this error and I'm fairly certain the problem is with something in the .pro file here.</p>

<p><strong>EDIT:</strong></p>

<p>I decided to take a different approach. I got rid of anything that importing a library added to my .pro file, and instead just put this line of code in its place:</p>

<p><code>win32:LIBS += C:\Qt\5.2.1\mingw48_32\include\cryptopp\Win32\Output\Debug\cryptlib.lib</code> (The path to the cryptlib.lib file)</p>

<p>This built just fine. I made sure that all of the cryptopp header files were in my include directory, <code>C:\Qt\5.2.1\mingw48_32\include\cryptopp</code></p>

<p>I then tried to include a file, with <code>#include &lt;cryptopp/aes.h&gt;</code> and it built fine. The first time I built, there were 40+ warnings, but the second time I built, it built without any.</p>
","<blockquote>
<pre><code>win32-g++:CONFIG(release, debug|release): PRE_TARGETDEPS += $$PWD/libcryptlib.a
else:win32-g++:CONFIG(debug, debug|release): PRE_TARGETDEPS += $$PWD/libcryptlibd.a
</code></pre>
</blockquote>

<p>On Windows under Visual Studio, the name of the Crypto++ library is <code>cryptlib.lib</code>, not <code>libcryptlib.a</code>. <em>If</em> you used Cygwin (which I don't believe you did), then the name <em>would</em> be <code>libcryptopp.a</code>.</p>

<p>The <code>libcryptlibd.a</code> (notice the addition of the <code>d</code>) is probably not correct. It stands for 'debug', and its something that was used years ago in the Visual Studio 5.0/6.0 days. It was based on <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment</a>. <em>If</em> you renamed <code>Win32/Debug/cryptlib.lib</code> to <code>Win32/Debug/cryptlibd.lib</code>, then you are probably OK if your paths are OK.</p>

<p>I think the recommended way of doing things now is to use <code>cryptlib.lib</code> as the library (same name everywhere), and change the linker paths based on the configuration. The paths would be:</p>

<ul>
<li>Win32, Debug: <code>&lt;crypto++ dir&gt;/Win32/Debug/</code></li>
<li>Win64, Debug: <code>&lt;crypto++ dir&gt;/x64/Debug/</code></li>
<li>Win32, Release: <code>&lt;crypto++ dir&gt;/Win32/Release/</code></li>
<li>Win64, Release: <code>&lt;crypto++ dir&gt;/x64/Release/</code></li>
</ul>

<p>Here's a screen capture of adding <code>cryptlib.lib</code> under Visual Studio. Notice it applies to all configurations:</p>

<p><img src=""https://i.stack.imgur.com/v1XlN.png"" alt=""enter image description here""></p>

<p>And here's how to change the linker paths so Visual Studio finds the proper <code>cryptlib.lib</code>:</p>

<p><img src=""https://i.stack.imgur.com/seT6e.png"" alt=""enter image description here""></p>

<p>In the above, <code>CRYPTOPP_LIB32</code> would be an environmental variable with a value like <code>C:\Users\Special Services\Crypto++\Win32\</code>. Similarly, <code>CRYPTOPP_LIB64</code> would be <code>C:\Users\Special Services\Crypto++\x64\</code></p>

<p>Unfortunately, I don't know how to do these things under QtCreator.</p>
","2866","<c++><windows><qt><crypto++>","4","1","1","2017-06-17 19:28:58","23230827","1","1","608639","","2017-06-17 19:28:58","2014-04-22 15:15:17",""
"3884823","Error compiling in release mode but not in debug mode","<p>When I compile on VS 2008 in deubg mode everything works fine.
When I compile the same thing in release mode not everything works.  As far as I can tell the include directories are the same and there are no additional preprocessor symbols.</p>

<p>Any help?</p>

<blockquote>
  <p>1>zlib.cpp 1>C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\xutility(419) : error C2664:
  'CryptoPP::AllocatorWithCleanup::AllocatorWithCleanup(const
  CryptoPP::AllocatorWithCleanup &amp;)'
  : cannot convert parameter 1 from
  'CryptoPP::AllocatorWithCleanup' to
  'const
  CryptoPP::AllocatorWithCleanup &amp;'
  1>        with 1>        [ 1><br>
  T=std::_Aux_cont 1>        ] 1><br>
  and 1>        [ 1><br>
  T=CryptoPP::HuffmanDecoder::CodeInfo
  1>        ] 1>        and 1>        [
  1>            T=std::_Aux_cont 1><br>
  ] 1>        Reason: cannot convert
  from
  'CryptoPP::AllocatorWithCleanup' to
  'const
  CryptoPP::AllocatorWithCleanup' 1> 
  with 1>        [ 1><br>
  T=CryptoPP::HuffmanDecoder::CodeInfo
  1>        ] 1>        and 1>        [
  1>            T=std::_Aux_cont 1><br>
  ] 1>        No user-defined-conversion
  operator available that can perform
  this conversion, or the operator
  cannot be called 1>        C:\Program
  Files (x86)\Microsoft Visual Studio
  9.0\VC\include\xutility(417) : while compiling class template member
  function
  'std::_Container_base_aux_alloc_real&lt;_Alloc>::_Container_base_aux_alloc_real(_Alloc)'
  1>        with 1>        [ 1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1>        C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\vector(421) : see reference to class template
  instantiation
  'std::_Container_base_aux_alloc_real&lt;_Alloc>'
  being compiled 1>        with 1><br>
  [ 1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1>        C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\vector(439) : see reference to class template
  instantiation
  'std::_Vector_val&lt;_Ty,_Alloc>' being
  compiled 1>        with 1>        [ 1>
  _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
  1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1><br>
  C:\myproject\sshlib\zinflate.h(79) :
  see reference to class template
  instantiation 'std::vector&lt;_Ty,_Ax>'
  being compiled 1>        with 1><br>
  [ 1><br>
  _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
  1><br>
  _Ax=CryptoPP::AllocatorWithCleanup
  1>        ] 1>zinflate.cpp</p>
</blockquote>

<p>The line of code it eventually points to is:</p>

<pre><code>std::vector&lt;CodeInfo, AllocatorWithCleanup&lt;CodeInfo&gt; &gt; m_codeToValue;
</code></pre>

<p><strong>Edit: More info:</strong></p>

<p>I get this error exactly when my preprocessor contains NDEBUG instead of _DEBUG. If I change my release config to have _DEBUG isntead it compiles.  Why?</p>
","<p>It's a bug in the Visual C++ compiler. See <a href=""http://old.nabble.com/-jira--Created%3a-%28QPID-1458%29-C%2B%2B-common-compile-error-in-VC9-Release-mode-td20469700.html"" rel=""nofollow"">http://old.nabble.com/-jira--Created:-%28QPID-1458%29-C%2B%2B-common-compile-error-in-VC9-Release-mode-td20469700.html</a>.</p>

<p>You can work around it by disabling <a href=""http://msdn.microsoft.com/en-us/library/aa985965%28v=VS.80%29.aspx"" rel=""nofollow"">checked iterators</a>:</p>

<pre><code>#define _SECURE_SCL 0
</code></pre>

<p>But be warned: if you link against a third-party library that was compiled with <code>_SECURE_SCL</code> enabled, like e.g. <a href=""http://www.boost.org/"" rel=""nofollow"">boost</a>, memory corruption can (and will) occur.</p>
","2839","<c++><compiler-errors><crypto++>","0","2","2","2011-11-15 15:40:25","","2","","467169","","2010-10-07 18:58:37","2010-10-07 18:48:29",""
"3884823","Error compiling in release mode but not in debug mode","<p>When I compile on VS 2008 in deubg mode everything works fine.
When I compile the same thing in release mode not everything works.  As far as I can tell the include directories are the same and there are no additional preprocessor symbols.</p>

<p>Any help?</p>

<blockquote>
  <p>1>zlib.cpp 1>C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\xutility(419) : error C2664:
  'CryptoPP::AllocatorWithCleanup::AllocatorWithCleanup(const
  CryptoPP::AllocatorWithCleanup &amp;)'
  : cannot convert parameter 1 from
  'CryptoPP::AllocatorWithCleanup' to
  'const
  CryptoPP::AllocatorWithCleanup &amp;'
  1>        with 1>        [ 1><br>
  T=std::_Aux_cont 1>        ] 1><br>
  and 1>        [ 1><br>
  T=CryptoPP::HuffmanDecoder::CodeInfo
  1>        ] 1>        and 1>        [
  1>            T=std::_Aux_cont 1><br>
  ] 1>        Reason: cannot convert
  from
  'CryptoPP::AllocatorWithCleanup' to
  'const
  CryptoPP::AllocatorWithCleanup' 1> 
  with 1>        [ 1><br>
  T=CryptoPP::HuffmanDecoder::CodeInfo
  1>        ] 1>        and 1>        [
  1>            T=std::_Aux_cont 1><br>
  ] 1>        No user-defined-conversion
  operator available that can perform
  this conversion, or the operator
  cannot be called 1>        C:\Program
  Files (x86)\Microsoft Visual Studio
  9.0\VC\include\xutility(417) : while compiling class template member
  function
  'std::_Container_base_aux_alloc_real&lt;_Alloc>::_Container_base_aux_alloc_real(_Alloc)'
  1>        with 1>        [ 1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1>        C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\vector(421) : see reference to class template
  instantiation
  'std::_Container_base_aux_alloc_real&lt;_Alloc>'
  being compiled 1>        with 1><br>
  [ 1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1>        C:\Program Files
  (x86)\Microsoft Visual Studio
  9.0\VC\include\vector(439) : see reference to class template
  instantiation
  'std::_Vector_val&lt;_Ty,_Alloc>' being
  compiled 1>        with 1>        [ 1>
  _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
  1><br>
  _Alloc=CryptoPP::AllocatorWithCleanup
  1>        ] 1><br>
  C:\myproject\sshlib\zinflate.h(79) :
  see reference to class template
  instantiation 'std::vector&lt;_Ty,_Ax>'
  being compiled 1>        with 1><br>
  [ 1><br>
  _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
  1><br>
  _Ax=CryptoPP::AllocatorWithCleanup
  1>        ] 1>zinflate.cpp</p>
</blockquote>

<p>The line of code it eventually points to is:</p>

<pre><code>std::vector&lt;CodeInfo, AllocatorWithCleanup&lt;CodeInfo&gt; &gt; m_codeToValue;
</code></pre>

<p><strong>Edit: More info:</strong></p>

<p>I get this error exactly when my preprocessor contains NDEBUG instead of _DEBUG. If I change my release config to have _DEBUG isntead it compiles.  Why?</p>
","<p>Coming back to C++ after many years, I encountered a similar error. Turned out it had nothing to do with this bug and everything to do with the fact that I hadn't updated my Release configuration to the same settings as used in the Debug configuration! So for the other noobs out there -- remember to make sure that you have the same Character Sets, CLR Support, Include Directories, Additional Dependencies, and so forth in all your configurations.</p>
","2839","<c++><compiler-errors><crypto++>","0","0","2","2011-11-15 15:40:25","","2","","467169","","2010-10-07 18:58:37","2010-10-07 18:48:29",""
"7014392","Crypto++ Code::blocks Undefined reference problem","<p>I'm trying to create a C++ program using Crypto++ (with Code::Blocks), but keep getting stuck with the same problem. I'm using a cut-down version of this code : <a href=""http://andreyvitdev.blogspot.com/2005/10/crypto-usage-sample.html"" rel=""nofollow"">http://andreyvitdev.blogspot.com/2005/10/crypto-usage-sample.html</a>
, but I can't get it to compile.</p>

<pre><code>#include ""cryptopp/blowfish.h""
#include ""cryptopp/osrng.h""

using namespace CryptoPP;

int main (int argc, char** argv) {

    byte key[Blowfish::DEFAULT_KEYLENGTH],
            iv[Blowfish::BLOCKSIZE];

    AutoSeededRandomPool rng (true);
    rng.GenerateBlock(key, sizeof (key));
    rng.GenerateBlock(iv, sizeof (iv));

}
</code></pre>

<p>I get multiple errors, starting with : ""C:\Users\Utilisateur\Programming\C++\CodeBlocks\Crytp tester\main.cpp|13|undefined reference to `CryptoPP::RandomNumberGenerator::GenerateBlock(unsigned char*, unsigned int)'""</p>

<p>Am I missing something? There are many references on different sites to libraries that must be imported, but I couldn't figure out where they were in the crypto++ folder : <a href=""http://www.cryptopp.com/#download"" rel=""nofollow"">http://www.cryptopp.com/#download</a></p>
","<p>""Undefined reference"" is a linker error -- either you didn't build the Crypto++ library, or didn't tell the linker to link to it.</p>

<p>I'm not positive if it will build using MinGW (the most common compiler with Code Blocks) though. The Microsoft compilers (along with Visual Studio) are free; and are tested explicitly with both Code::Blocks and Crypto++.</p>
","2763","<c++><reference><undefined><codeblocks><crypto++>","2","5","1","2018-11-10 12:02:08","","3","","1033581","","2018-11-10 12:02:08","2011-08-10 16:31:41",""
"25441918","Can't DER encode and BER decode RSA public key","<p>I have problems using Crypto++ to save a RSA public key (that I obtained loading a private key file in PKCS#8 format). When decoding the key, I always get a <code>BERDecodeErr</code> exception.</p>

<p>Here is the code I am using:</p>

<pre class=""lang-cpp prettyprint-override""><code>CryptoPP::RSASSA_PKCS1v15_SHA_Signer   _signer;
CryptoPP::RSASSA_PKCS1v15_SHA_Verifier _verifier;
CryptoPP::ByteQueue                    bytes;

//_signer.AccessPublicKey().Save(bytes); // seem to save private key instead
_signer.AccessKey().DEREncodePublicKey(bytes);

//_verifier.AccessKey().Load(bytes);
//_verifier.AccessKey().BERDecodePublicKey(bytes, 0, 0);
_verifier.AccessPublicKey().Load(bytes);
</code></pre>

<p>I also tried with the instructions commented above, without success.</p>

<p>How do you do to save or open the public key?</p>

<p>The public key looks like this in hex format, is there a tool to check its format / validity (regarding what crypto++ supports) ?</p>

<pre><code>3081890281810097e24f2e95504a397e90fbc56d1b330ab2ab97a0d326007b890e40013f9e1d9bd9
f54b0c0840782ddae19b5b4595d8f8b9ffe0d2120174fcbc39585c5867cd2dfba69f8e540caa2c52
de8f08278a34e9249120500117f0ba756c5bb2be660013160db9f82f75deb7ccf63742a9e945da6c
cf30c2b109b73342daaabd02b872e50203010001
</code></pre>
","<p>I'm not sure I understand your problem completely. But you look like you are on the right track with using either <code>Load</code>/<code>Save</code> or <code>BERDecodePublicKey</code>/<code>DEREncodePublicKey</code>.</p>

<p>Here's how I would approach it given you have a PKCS#8 encoded private key.</p>

<pre class=""lang-cpp prettyprint-override""><code>FileSource privateKey(""&lt;private key&gt;"", true);
RSASSA_PKCS1v15_SHA_Signer signer;    
signer.AccessKey().Load(privateKey);

AutoSeededRandomPool prng;
bool valid = signer.AccessKey().Validate(prng, 3);
...

RSASSA_PKCS1v15_SHA_Verifier verifier(signer);
FileSink publicKey(""&lt;public key&gt;"", true);

verifier.AccessKey().Save(publicKey);
</code></pre>

<p>Then, you can use <a href=""https://www.cs.auckland.ac.nz/~pgut001/"" rel=""nofollow"">Gutmann's <code>dumpasn1</code></a> to print it:</p>

<pre><code>$ dumpasn1 &lt;public key&gt;
...
</code></pre>

<p>I believe you can also convert a private key/signer to a public key/verifier with:</p>

<pre class=""lang-cpp prettyprint-override""><code>RSASSA_PKCS1v15_SHA_Signer signer;
signer.AccessKey().Load(privateKey);

RSASSA_PKCS1v15_SHA_Verifier verifier;
signer.MakePublic(verifier);
</code></pre>

<p>There's also a page on the Crypto++ wiki that talks about it in greater detail: <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow"">Keys and Formats</a>. And there's a page dedicated to PEM encoding, if interested: <a href=""http://www.cryptopp.com/wiki/PEM_Pack"" rel=""nofollow"">PEM Pack</a>. If you want the PEM encoding, you have to compile the library yourself, though.</p>

<hr>

<p>Here's the code I used with the public key you posted. It had no problems.</p>

<pre class=""lang-cpp prettyprint-override""><code>string key = ""3081890281810097e24f2e95504a397e90fbc56d1b330ab2ab97a0d326007b890e40013f9e1d9bd9 \
    f54b0c0840782ddae19b5b4595d8f8b9ffe0d2120174fcbc39585c5867cd2dfba69f8e540caa2c52 \
    de8f08278a34e9249120500117f0ba756c5bb2be660013160db9f82f75deb7ccf63742a9e945da6c \
    cf30c2b109b73342daaabd02b872e50203010001"";

ByteQueue queue;
StringSource ss(key, true, new HexDecoder(new Redirector(queue)));

RSASSA_PKCS1v15_SHA_Verifier verifier;
verifier.AccessKey().BERDecodePublicKey(queue, false, 0);

AutoSeededRandomPool prng;
bool result = verifier.AccessKey().Validate(prng, 3);
if(!result)
    throw Exception(Exception::OTHER_ERROR, ""Failed to validate public key"");
</code></pre>

<hr>

<p>If you install the <a href=""http://www.cryptopp.com/wiki/PEM_Pack"" rel=""nofollow"">PEM Pack</a> then you can add the following:</p>

<pre class=""lang-cpp prettyprint-override""><code>FileSink sink(""public-key.pem"", true);
PEM_Save(sink, verifier.GetKey());
</code></pre>

<p>That will get you:</p>

<pre class=""lang-bash prettyprint-override""><code>$ cat public-key.pem 
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCX4k8ulVBKOX6Q+8VtGzMKsquX
oNMmAHuJDkABP54dm9n1SwwIQHgt2uGbW0WV2Pi5/+DSEgF0/Lw5WFxYZ80t+6af
jlQMqixS3o8IJ4o06SSRIFABF/C6dWxbsr5mABMWDbn4L3Xet8z2N0Kp6UXabM8w
wrEJtzNC2qq9Arhy5QIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>And:</p>

<pre class=""lang-bash prettyprint-override""><code>$ openssl rsa -in public-key.pem -pubin -text -noout
Public-Key: (1024 bit)
Modulus:
    00:97:e2:4f:2e:95:50:4a:39:7e:90:fb:c5:6d:1b:
    33:0a:b2:ab:97:a0:d3:26:00:7b:89:0e:40:01:3f:
    9e:1d:9b:d9:f5:4b:0c:08:40:78:2d:da:e1:9b:5b:
    45:95:d8:f8:b9:ff:e0:d2:12:01:74:fc:bc:39:58:
    5c:58:67:cd:2d:fb:a6:9f:8e:54:0c:aa:2c:52:de:
    8f:08:27:8a:34:e9:24:91:20:50:01:17:f0:ba:75:
    6c:5b:b2:be:66:00:13:16:0d:b9:f8:2f:75:de:b7:
    cc:f6:37:42:a9:e9:45:da:6c:cf:30:c2:b1:09:b7:
    33:42:da:aa:bd:02:b8:72:e5
Exponent: 65537 (0x10001)
</code></pre>

<hr>

<p>Finally, the difference between:</p>

<ul>
<li><code>verifier.AccessKey()</code>: gets the <code>RSA::Public</code> key, the key is non-const</li>
<li><code>verifier.GetKey()</code>: gets the <code>RSA::Public</code> key, the key is const</li>
</ul>
","2708","<public-key><crypto++><der><ber>","1","1","1","2014-08-23 10:54:40","25460803","2","","608639","","2014-08-23 10:53:59","2014-08-22 07:39:52",""
"4946716","verify data signature generated with openssl, using crypto++","<p>I have a server, running under python, signing a message sha256 digest using m2crypto
I use a public and private RSA key generated by openssl CLI. On the server side everythgin is OK<br>
Python code :  </p>

<blockquote>
  <p>privateKey = M2Crypto.RSA.load_key(sys.argv[2])<br>
  signedDigest = privateKey.sign(digest, 'sha256')  </p>
</blockquote>

<p>I double check that signature is good :</p>

<blockquote>
  <p>pubKey = M2Crypto.RSA.load_pub_key(""key.pub.pem"")<br>
  if pubKey.verify(digest, signedDigest, 'sha256') (etc....)</p>
</blockquote>

<p>I store the signed sha256 digest in a file and send it with the original message to the client.<br>
On the client side, running under c++ vc6, I load the signed sha256 digest (as binary), and the message that was signed. The aim is now to verify the message , together with the signed sha256. I have cryptopp as static link, and I know it works fine, because I can compute sha256, and compare with sha256 from python having same result. Here is the code :  </p>

<blockquote>
  <p>RSA::PublicKey pubKey;<br>
  pubKey.Load( FileSource(LicenseControl::pubKeyPath, true));<br>
  RSASS&lt; PKCS1v15, SHA >::Verifier verifier(pubKey);<br>
  //shaDigest is newly computed sha256, signatureByte is the signature of the message received from the server<br>
  result = verifier.VerifyMessage( shaDigest, CryptoPP::SHA256::DIGESTSIZE, signatureByte, 512);  </p>
</blockquote>

<p>This compiles and run, but always return false. To ensure that signature is valid, I have verified it using directly openssl CLI (not through m2crypto python wrapper) :  </p>

<blockquote>
  <p>openssl dgst -sha256 -verify key.pub.pem -signature sign original_file<br>
  Verified OK</p>
</blockquote>

<p>This confirms that signed sha256 digest is ok, and that it can be used  to verify message successfully using the public key. I am aware of DER and PEM format (using PEM for openssl, DER for cryptopp). So I believe the public key is correct.
Now my problem is How to use cryptopp library to verify the signature ???
I have been through the doc, but after days on it, it still looks like chinese to me. I hav tried thing like  </p>

<blockquote>
  <p>RSASS&lt; PSSR, SHA >::Verifier verifier(pubKey);  </p>
</blockquote>

<p>using PSSR to encrypt in python code, but no luck...
I am now considering to only decrypt with public key the signed sha256 digest and compare it myself to the newly sha256 digest computed from the receive file. But even that simple, I hevn't found in the doc...
Any idea how to use verifier properly ?<br>
How to decrypt using public key ? in case previous question can not be solved</p>
","<p>Two issues here I think:</p>

<p>First, SHA in <code>RSASS&lt; PKCS1v15, SHA &gt;</code> means SHA-1, not SHA_256. You'd want <code>SHA256</code> here instead.</p>

<p>Also, <code>VerifyMessage</code> takes the entire message, not just a hash - the hash is computed internally for you. So right now when you're trying to verify the message, you're actually (as far as Crypto++ is concerned) trying to verify SHA-1(SHA-256(msg)), so naturally it fails. Pass the entire actual message instead, skipping your extra SHA-256 computation.</p>
","2695","<openssl><m2crypto><verify><crypto++>","4","1","1","2011-06-30 19:39:52","","0","","","","","2011-02-09 15:11:49",""
"34762869","StreamTransformationFilter: invalid PKCS #7 block padding found in AES decryption","<p>I want to use AES-256 encryption/decryption in my C++ code to do that I use cryptoPP library, I have implement encryption and decryption. but I get <code>Error : StreamTransformationFilter: invalid PKCS #7 block padding found</code> Error. </p>

<p>The senario which I test is :</p>

<p>First I encrypt myplaintext then decrypt it --> there is no error here.</p>

<p>Second I decrypt the cipher created above --> here I got the error.</p>

<p>I know that there are same question here but I couldn't solve my problem :(</p>

<p>Here I set iv:</p>

<pre><code>byte iv[16];
string strIv = ""162169848599E7C792BF58BFA53D88E6"";
memcpy(iv, strIv.data(), strIv.length());
</code></pre>

<p>Encryption:</p>

<pre><code>string CryptoAES::Encrypt(string plain, string strkey) {
    cout &lt;&lt; ""\nplain text :"" &lt;&lt; plain;
    cout &lt;&lt; ""\n key to encrypt: "" &lt;&lt;strkey;
    byte key[AES::MAX_KEYLENGTH];
    memcpy(key, strkey.data(), strkey.length());
    string encodedKey, decodedKey,ciphertextEncode,ciphertext;
    encodedKey.clear();
    decodedKey.clear();
    ciphertextEncode.clear();
    ciphertext.clear();
    StringSource(key, sizeof (key), true, new HexEncoder(new StringSink(encodedKey))); 
    StringSource ssk(encodedKey, true, new HexDecoder(new StringSink(decodedKey)));
    memcpy(key, decodedKey.data(), decodedKey.length());
    CryptoPP::AES::Encryption aesEncryption(key, AES::MAX_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (plain.c_str()), plain.length() + 1);
    stfEncryptor.MessageEnd();
    StringSource ss(ciphertext, true, new HexEncoder(new StringSink(ciphertextEncode)));
    cout &lt;&lt; ""\nencrypted text: "" &lt;&lt;ciphertextEncode;
    return ciphertextEncode;
}
</code></pre>

<p>Decryption:</p>

<pre><code>string CryptoAES::Decrypt(string cipher, string strkey) {
    cout &lt;&lt;""\ncipher text : ""&lt;&lt; cipher;
    cout &lt;&lt; ""\n key to decrypt: "" &lt;&lt;strkey;
    byte key[AES::MAX_KEYLENGTH];
    memcpy(key, strkey.data(), strkey.length());
    string encodedKey, decodedKey,ciphertextDecode,decryptedtext;
    encodedKey.clear();
    decodedKey.clear();
    ciphertextDecode.clear();
    decryptedtext.clear();
    StringSource(key, sizeof (key), true, new HexEncoder(new StringSink(encodedKey))); 
    StringSource ssk(encodedKey, true, new HexDecoder(new StringSink(decodedKey)));
    memcpy(key, decodedKey.data(), decodedKey.length());
    StringSource ss(cipher, true, new HexDecoder(new StringSink(ciphertextDecode)));
    CryptoPP::AES::Decryption aesDecryption(key, AES::MAX_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(decryptedtext));
    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (ciphertextDecode.c_str()), ciphertextDecode.size());
    stfDecryptor.MessageEnd();

    cout &lt;&lt;""\ndecrypted text: ""&lt;&lt;decryptedtext;
    return decryptedtext;
}
</code></pre>

<p>result :</p>

<pre><code>plain text :F7ACA191B43AFAF85277DD196FE0441CB7C0901BEC33CB9F38FFAA54CBF219B9
 key to encrypt: 123456
encrypted text: 6FC1BF3108B0590367E6449B6E615CACFDF4DE16EDD05742C873EE4E8A16BA9EC0B8EFAD800F466EE9A6F75202C8800CF4CBDD2620956020D5B0A6A9A8DCEA9EDB5C470527423ACBEEDD0A9C59916C8B
cipher text : 6FC1BF3108B0590367E6449B6E615CACFDF4DE16EDD05742C873EE4E8A16BA9EC0B8EFAD800F466EE9A6F75202C8800CF4CBDD2620956020D5B0A6A9A8DCEA9EDB5C470527423ACBEEDD0A9C59916C8B
 key to decrypt: 123456
decrypted text: F7ACA191B43AFAF85277DD196FE0441CB7C0901BEC33CB9F38FFAA54CBF219B9
cipher text : 6FC1BF3108B0590367E6449B6E615CACFDF4DE16EDD05742C873EE4E8A16BA9EC0B8EFAD800F466EE9A6F75202C8800CF4CBDD2620956020D5B0A6A9A8DCEA9EDB5C470527423ACBEEDD0A9C59916C8B                                                                                                    
 key to decrypt: 123456
exception in proxy server! :( 
    Error : StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>EDIT #1:
here is the new version of the methods:</p>

<p>IV:</p>

<pre><code>for (int i = 0; i &lt; AES::BLOCKSIZE; i++)
        iv[i] = 0;
</code></pre>

<p>encryption:</p>

<pre><code>string CryptoAES::Encrypt(string plain, string strkey) {

    byte key[AES::MAX_KEYLENGTH];
    byte* k = (byte*) strkey.c_str();

    for (int i = 0; i &lt; AES::MAX_KEYLENGTH; i++)
        if (i&lt;sizeof (k))
            key[i] = k[i];
        else
            key[i] = 0;
    string ciphertextEncode,ciphertext;
    cout &lt;&lt; ""\nplain text :"" &lt;&lt; plain;
    cout &lt;&lt; ""\n key to encrypt: "" &lt;&lt;key;
    ciphertextEncode.clear();
    ciphertext.clear();
    CryptoPP::AES::Encryption aesEncryption(key, AES::MAX_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (plain.c_str()), plain.length() + 1);
    stfEncryptor.MessageEnd();
    cout &lt;&lt; ""\nencrypted text: "" &lt;&lt;ciphertext;
    StringSource ss(ciphertext, true, new HexEncoder(new StringSink(ciphertextEncode)));
    cout &lt;&lt; ""\nencoded encrypted text: "" &lt;&lt;ciphertextEncode;
    return ciphertextEncode;
}
</code></pre>

<p>Decryption:</p>

<pre><code>string CryptoAES::Decrypt(string cipher, string strkey) {

    byte key[AES::MAX_KEYLENGTH];
    byte* k = (byte*) strkey.c_str();

    for (int i = 0; i &lt; AES::MAX_KEYLENGTH; i++)
        if (i&lt;sizeof (k))
            key[i] = k[i];
        else
            key[i] = 0;
    string ciphertextDecode,decryptedtext;
    cout &lt;&lt;""\ncipher text : ""&lt;&lt; cipher;
    cout &lt;&lt; ""\n key to decrypt: "" &lt;&lt;key;
    ciphertextDecode.clear();
    decryptedtext.clear();

    StringSource ss(cipher, true, new HexDecoder(new StringSink(ciphertextDecode)));
    cout &lt;&lt; ""\n cipher decoded: "" &lt;&lt; ciphertextDecode;
    CryptoPP::AES::Decryption aesDecryption(key, AES::MAX_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(decryptedtext));
    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (ciphertextDecode.c_str()), ciphertextDecode.size());
    stfDecryptor.MessageEnd();

    cout &lt;&lt;""\ndecrypted text: ""&lt;&lt;decryptedtext;
    return decryptedtext;
}
</code></pre>

<p>result:</p>

<pre><code>plain text :0C469BEA09DFCAC0A555E74175F1A614F471A5205FEB13A72C2DFFE8C4B52AA4
 key to encrypt: 123456
encrypted text: �����z�����_���d�0�kߨ���^G�o���zL��Z��fc�L��X���,&lt;X*-R_��x��?�  �U$�
encoded encrypted text: D8F68E8E8B7AADB094A5BD5FC117BFBA648130E46BDFA8B6DD0EA35E17478F6FA01AA38E0417B4087A4CAEBB5AB8C466639C4C84F35895C07FB2172C3C582A2D525FFDDC78A9F83FEFA50913E55524C1
cipher text : D8F68E8E8B7AADB094A5BD5FC117BFBA648130E46BDFA8B6DD0EA35E17478F6FA01AA38E0417B4087A4CAEBB5AB8C466639C4C84F35895C07FB2172C3C582A2D525FFDDC78A9F83FEFA50913E55524C1
 key to decrypt: 123456
 cipher decoded: �����z�����_���d�0�kߨ���^G�o���zL��Z��fc�L��X���,&lt;X*-R_��x��?� �U$�
decrypted text: 0C469BEA09DFCAC0A555E74175F1A614F471A5205FEB13A72C2DFFE8C4B52AA4
cipher text : D8F68E8E8B7AADB094A5BD5FC117BFBA648130E46BDFA8B6DD0EA35E17478F6FA01AA38E0417B4087A4CAEBB5AB8C466639C4C84F35895C07FB2172C3C582A2D525FFDDC78A9F83FEFA50913E55524C1                                                                                               
 key to decrypt: 123456
 cipher decoded: �����z�����_���d�0�kߨ���^G�o���zL��Z��fc�L��X���,&lt;X*-R_��x��?� �U$�
exception in proxy server! :( 
    StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>
","<p>Finally I solved the problems.</p>

<p><strong>first:</strong></p>

<p><code>string cipher</code> and <code>string strkey</code> have <code>\0</code> padding.</p>

<p><strong>second:</strong></p>

<p>The <code>iv[16]</code> value which was share between two methods, is changed! so I set it in each methods.</p>
","2642","<c++><aes><crypto++>","1","1","1","2016-01-17 17:33:01","34841367","9","","3806649","","2016-01-13 14:29:21","2016-01-13 09:30:03",""
"31929531","How to convert SecByteBlock to string?","<p>I'm having a problem trying to convert <code>SecByteBlock</code> to string.
Here's my case:</p>

<p>I want to encrypt user access data using AES with static key and dynamic iv.
My code is something like this:</p>

<pre><code>AesKeyIvFactory aesKeyIvFactory;
SecByteBlock key = aesKeyIvFactory.loadKey();
SecByteBlock iv = aesKeyIvFactory.createIv();

encryptionService-&gt;encode(&amp;userAccess, key, iv);
std::string token = std::string(iv.begin(), iv.end()) + userAccess;
</code></pre>

<p>The code above is supposed to:</p>

<ol>
<li><p>Load key from file;</p></li>
<li><p>Create iv;</p></li>
<li><p>Encrypt (AES) user access data;</p></li>
<li><p>Concatenate the iv with the user data access encrypted to create a ""token"";</p></li>
</ol>

<p>Running a test several times, sometimes (1 to 10 times) the <code>std::string(iv.begin(), iv.end())</code> doesn't work correctly. It seems like there is a ""line break"" in the iv that makes the conversion fail.</p>

<p>I tried a lot of things, but nothing works and I don't have experience with c++.</p>

<p>I hope that someone can help me.</p>
","<blockquote>
  <p>I'm having a problem trying to convert SecByteBlock to string</p>
</blockquote>

<p>If the issue is with conversion from <code>SecByteBlock</code> and its <code>byte</code> array to a <code>std::string</code> and its <code>char</code> array, then you should:</p>

<pre><code>SecByteBlock iv;
...

// C-style cast
std::string token = std::string((const char*)iv.data(), iv.size()) + userAccess;
</code></pre>

<p>Or,</p>

<pre><code>SecByteBlock iv;
...

// C++-style cast
std::string token = std::string(reinterpret_cast&lt;const char*&gt;(iv.data()), iv.size()) + userAccess;
</code></pre>

<p>You can also forgo the assignment, and just initialize and later append:</p>

<pre><code>SecByteBlock iv;
...

std::string token(reinterpret_cast&lt;const char*&gt;(iv.data()), iv.size());
...

std::string userAccess;
...

token += userAccess;
</code></pre>

<hr>

<p>The other problem you might have is <code>string</code> to <code>SecByteBlock</code>. You should do this:</p>

<pre><code>std::string str;
...

// C-style cast
SecByteBlock sbb((const byte*)str.data(), str.size());
</code></pre>

<p>Or:</p>

<pre><code>std::string str;
...

// C++-style cast
SecByteBlock sbb(reinterpret_cast&lt;const byte*&gt;(str.data()), str.size());
</code></pre>
","2593","<c++><security><aes><crypto++>","3","4","2","2015-09-10 06:11:44","31981519","3","1","3494633","","2015-09-08 13:59:42","2015-08-10 21:31:16",""
"31929531","How to convert SecByteBlock to string?","<p>I'm having a problem trying to convert <code>SecByteBlock</code> to string.
Here's my case:</p>

<p>I want to encrypt user access data using AES with static key and dynamic iv.
My code is something like this:</p>

<pre><code>AesKeyIvFactory aesKeyIvFactory;
SecByteBlock key = aesKeyIvFactory.loadKey();
SecByteBlock iv = aesKeyIvFactory.createIv();

encryptionService-&gt;encode(&amp;userAccess, key, iv);
std::string token = std::string(iv.begin(), iv.end()) + userAccess;
</code></pre>

<p>The code above is supposed to:</p>

<ol>
<li><p>Load key from file;</p></li>
<li><p>Create iv;</p></li>
<li><p>Encrypt (AES) user access data;</p></li>
<li><p>Concatenate the iv with the user data access encrypted to create a ""token"";</p></li>
</ol>

<p>Running a test several times, sometimes (1 to 10 times) the <code>std::string(iv.begin(), iv.end())</code> doesn't work correctly. It seems like there is a ""line break"" in the iv that makes the conversion fail.</p>

<p>I tried a lot of things, but nothing works and I don't have experience with c++.</p>

<p>I hope that someone can help me.</p>
","<p>I think Eric answered your primary question on how to convert the <code>SecByteBlock</code> to a <code>std::string</code> (including the explicit conversions between <code>char*</code> and <code>byte*</code>). But here's how you might approach <code>std::string token = std::string(iv.begin(), iv.end()) + userAccess;</code> issue.</p>

<pre class=""lang-c++ prettyprint-override""><code>string token;

SecByteBlock iv(16), userAccess(16);
OS_GenerateRandomBlock(false, iv, iv.size());
OS_GenerateRandomBlock(false, userAccess, userAccess.size());

SecByteBlock nil;
nil.CleanNew(HMAC&lt;SHA256&gt;::DEFAULT_KEYLENGTH);

HMAC&lt;SHA256&gt; hmac;
hmac.SetKey(nil.data(), nil.size());

HashFilter filter(hmac, new HexEncoder(new StringSink(token)));
filter.Put(iv.data(), iv.size());
filter.Put(userAccess.data(), userAccess.size());
filter.MessageEnd();

cout &lt;&lt; token &lt;&lt; endl;
</code></pre>

<p>The <code>SecByteBlock nil</code> creates an object with no memory or size. The <code>nil.CleanNew(HMAC&lt;SHA256&gt;::DEFAULT_KEYLENGTH)</code> sizes and initializes the <code>SecByteBlock</code> to 0. Otherwise, you have an uninitialized block of memory.</p>

<p>It is possible to declare it and size it with a 0-inialized array, but you have to be familiar with the sources because its no Doxygen-docimented as of Crypto++ 5.6.2. That way is to use a <code>NULL</code> pointer, but a non-0 size. Here's what it would look like, but its very non-intuitive:</p>

<pre><code>SecByteBlock nil(NULL, HMAC&lt;SHA256&gt;::DEFAULT_KEYLENGTH);
</code></pre>

<p>The trick relies on this <a href=""http://www.cryptopp.com/docs/ref/secblock_8h_source.html"" rel=""nofollow""><code>SecBlock&lt;T&gt;</code></a> constructor:</p>

<pre><code>00250    SecBlock(const T *t, size_type len)
00251        : m_size(len)
00252    {
00253        m_ptr = m_alloc.allocate(len, NULL);
00254        if (t == NULL)
00255            memset_z(m_ptr, 0, len*sizeof(T));
00256        else
00257            memcpy(m_ptr, t, len*sizeof(T));
00258    }
</code></pre>

<hr>

<p>If possible, you should use <code>HKDF</code> instead of the <code>HMAC&lt;SHA&gt;</code> with a <code>nil</code> vector to extract the entropy from the security parameters. You can find the <code>HKDF</code> in the repo at the <a href=""https://github.com/weidai11/cryptopp/blob/master/hkdf.h"" rel=""nofollow""><code>HKDF class</code></a>. Its a stand alone header, so it will ""just work"".</p>

<hr>

<p>A typical run of the program with random values for <code>iv</code> and <code>userAccess</code> is:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
061CF705259058C4E01A2BF22830FC3F2A7E97F12FE605B38405B1E1B19A9E0F
</code></pre>

<hr>

<p>Another way to approach it could be concatenation based on <code>SecByteBlock</code>'s <code>operator +=</code>. The result is a binary string, and not a human readable ASCII string.</p>

<pre class=""lang-c++ prettyprint-override""><code>SecByteBlock result;

result += iv;
result += SecByteBlock(userAccess.data(), userAccess.size());

string token(result.data(), result.size());
</code></pre>

<p>If you need a human readable string, then run it through a <code>HexEncoder</code>:</p>

<pre><code>HexEncoder hex(new StringSink(token));
hex.Put(result.data(), result.size());
hex.MessageEnd();
</code></pre>

<p>But it does not extract the entropy from the parameters, so I personally like it less.</p>

<hr>

<p>When you move from a <code>SecByteBlock</code> to a <code>std::string</code>, you effectively lose your secure allocator. That means the data in the copies will not be zeroized after egressing data to the <code>string</code> object.</p>

<hr>

<p>The <a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow""><code>HexEncoder</code></a> is a convenience item, and it allows you to dump the binary string.</p>

<p>Another useful one might be the <a href=""http://www.cryptopp.com/wiki/Base64URLEncoder"" rel=""nofollow""><code>Base64URLEncoder</code></a>. It uses the web safe alphabet.</p>
","2593","<c++><security><aes><crypto++>","3","2","2","2015-09-10 06:11:44","31981519","3","1","3494633","","2015-09-08 13:59:42","2015-08-10 21:31:16",""
"24190908","Load RSA private key from a PEM encoded private key","<p>I'm trying to load an RSA private key from a <code>std::string</code> that contains the private key in PEM format, like this: </p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBAK8Q+ToR4tWGshaKYRHKJ3ZmMUF6jjwCS/u1A8v1tFbQiVpBlxYB
paNcT2ENEXBGdmWqr8VwSl0NBIKyq4p0rhsCAQMCQHS1+3wL7I5ZzA8G62Exb6RE
INZRtCgBh/0jV91OeDnfQUc07SE6vs31J8m7qw/rxeB3E9h6oGi9IVRebVO+9zsC
IQDWb//KAzrSOo0P0yktnY57UF9Q3Y26rulWI6LqpsxZDwIhAND/cmlg7rUz34Pf
SmM61lJEmMEjKp8RB/xgghzmCeI1AiEAjvVVMVd8jCcItTdwyRO0UjWU4JOz0cnw
5BfB8cSIO18CIQCLVPbw60nOIpUClNxCJzmMLbsrbMcUtgVS6wFomVvsIwIhAK+A
YqT6WwsMW2On5l9di+RPzhDT1QdGyTI5eFNS+GxY
-----END RSA PRIVATE KEY-----
</code></pre>

<p>And I wonder if anyone can help me to use this key instead of generating a random with the following statement. </p>

<pre><code>CryptoPP::RSA::PrivateKey rsaPrivate; 
rsaPrivate.GenerateRandomWithKeySize (rnd, 512);
</code></pre>
","<p>The key is PEM encoded. You need to strip the PEM header and footer, then convert from Base64 back to DER/BER, and finally use Crypto++'s <code>BERDecodePrivateKey</code>.</p>

<p>There's some reading on the subject at the Crypto++ wiki under <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""noreferrer"">Keys and Formats</a>. Below is the code to perform the conversion (I don't believe Stack Overflow has a working example of it in Crypto++).</p>

<pre><code>string RSA_PRIV_KEY =
    ""-----BEGIN RSA PRIVATE KEY-----\n""
    ""MIIBOgIBAAJBAK8Q+ToR4tWGshaKYRHKJ3ZmMUF6jjwCS/u1A8v1tFbQiVpBlxYB\n""
    ""paNcT2ENEXBGdmWqr8VwSl0NBIKyq4p0rhsCAQMCQHS1+3wL7I5ZzA8G62Exb6RE\n""
    ""INZRtCgBh/0jV91OeDnfQUc07SE6vs31J8m7qw/rxeB3E9h6oGi9IVRebVO+9zsC\n""
    ""IQDWb//KAzrSOo0P0yktnY57UF9Q3Y26rulWI6LqpsxZDwIhAND/cmlg7rUz34Pf\n""
    ""SmM61lJEmMEjKp8RB/xgghzmCeI1AiEAjvVVMVd8jCcItTdwyRO0UjWU4JOz0cnw\n""
    ""5BfB8cSIO18CIQCLVPbw60nOIpUClNxCJzmMLbsrbMcUtgVS6wFomVvsIwIhAK+A\n""
    ""YqT6WwsMW2On5l9di+RPzhDT1QdGyTI5eFNS+GxY\n""
    ""-----END RSA PRIVATE KEY-----"";

static string HEADER = ""-----BEGIN RSA PRIVATE KEY-----"";
static string FOOTER = ""-----END RSA PRIVATE KEY-----"";

size_t pos1, pos2;
pos1 = RSA_PRIV_KEY.find(HEADER);
if(pos1 == string::npos)
    throw runtime_error(""PEM header not found"");

pos2 = RSA_PRIV_KEY.find(FOOTER, pos1+1);
if(pos2 == string::npos)
    throw runtime_error(""PEM footer not found"");

// Start position and length
pos1 = pos1 + HEADER.length();
pos2 = pos2 - pos1;
string keystr = RSA_PRIV_KEY.substr(pos1, pos2);

// Base64 decode, place in a ByteQueue  
ByteQueue queue;
Base64Decoder decoder;

decoder.Attach(new Redirector(queue));
decoder.Put((const byte*)keystr.data(), keystr.length());
decoder.MessageEnd();

// Write to file for inspection
FileSink fs(""decoded-key.der"");
queue.CopyTo(fs);
fs.MessageEnd();

try
{
    CryptoPP::RSA::PrivateKey rsaPrivate;
    rsaPrivate.BERDecodePrivateKey(queue, false /*paramsPresent*/, queue.MaxRetrievable());

    // BERDecodePrivateKey is a void function. Here's the only check
    // we have regarding the DER bytes consumed.
    ASSERT(queue.IsEmpty());
}
catch (const Exception&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
    exit (1);
}
</code></pre>

<p>After loading the key, you can validate it with:</p>

<pre><code>AutoSeededRandomPool prng;
bool valid = rsaPrivate.Validate(prng, 3);
if(!valid)
    cerr &lt;&lt; ""RSA private key is not valid"" &lt;&lt; endl;
</code></pre>

<p>And print it with:</p>

<pre><code>cout &lt;&lt; ""N: "" &lt;&lt; rsaPrivate.GetModulus() &lt;&lt; endl &lt;&lt; endl;
cout &lt;&lt; ""E: "" &lt;&lt; rsaPrivate.GetPublicExponent() &lt;&lt; endl &lt;&lt; endl;
cout &lt;&lt; ""D: "" &lt;&lt; rsaPrivate.GetPrivateExponent() &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p><em>If</em> the key is password protected, then Crypto++ cannot decode it. The library lacks the support to perform the decryption. In this case, you can convert it to BER/DER using the following OpenSSL command. Then you can use the key material with Crypto++.</p>

<pre><code>openssl pkcs8 -nocrypt -in rsa-key.pem -inform PEM -topk8 -outform DER -out rsa-key.der
</code></pre>

<hr>

<p>The sample program wrote the key to file with this:</p>

<pre><code>FileSink fs(""decoded-key.der"");
queue.CopyTo(fs);
fs.MessageEnd();
</code></pre>

<p>The <code>CopyTo</code> leaves the bytes in the <code>queue</code> for use later. You can dump the file with an ASN.1 tool, like Gutmann's <code>dumpasn1</code>:</p>

<pre><code>$ dumpasn1 decoded-key.der 
  0 314: SEQUENCE {
  4   1:   INTEGER 0
  7  65:   INTEGER
       :     00 AF 10 F9 3A 11 E2 D5 86 B2 16 8A 61 11 CA 27
       :     76 66 31 41 7A 8E 3C 02 4B FB B5 03 CB F5 B4 56
       :     D0 89 5A 41 97 16 01 A5 A3 5C 4F 61 0D 11 70 46
       :     76 65 AA AF C5 70 4A 5D 0D 04 82 B2 AB 8A 74 AE
       :     1B
 74   1:   INTEGER 3
 77  64:   INTEGER
       :     74 B5 FB 7C 0B EC 8E 59 CC 0F 06 EB 61 31 6F A4
       :     44 20 D6 51 B4 28 01 87 FD 23 57 DD 4E 78 39 DF
       :     41 47 34 ED 21 3A BE CD F5 27 C9 BB AB 0F EB C5
       :     E0 77 13 D8 7A A0 68 BD 21 54 5E 6D 53 BE F7 3B
143  33:   INTEGER
       :     00 D6 6F FF CA 03 3A D2 3A 8D 0F D3 29 2D 9D 8E
       :     7B 50 5F 50 DD 8D BA AE E9 56 23 A2 EA A6 CC 59
       :     0F
178  33:   INTEGER
       :     00 D0 FF 72 69 60 EE B5 33 DF 83 DF 4A 63 3A D6
       :     52 44 98 C1 23 2A 9F 11 07 FC 60 82 1C E6 09 E2
       :     35
213  33:   INTEGER
       :     00 8E F5 55 31 57 7C 8C 27 08 B5 37 70 C9 13 B4
       :     52 35 94 E0 93 B3 D1 C9 F0 E4 17 C1 F1 C4 88 3B
       :     5F
248  33:   INTEGER
       :     00 8B 54 F6 F0 EB 49 CE 22 95 02 94 DC 42 27 39
       :     8C 2D BB 2B 6C C7 14 B6 05 52 EB 01 68 99 5B EC
       :     23
283  33:   INTEGER
       :     00 AF 80 62 A4 FA 5B 0B 0C 5B 63 A7 E6 5F 5D 8B
       :     E4 4F CE 10 D3 D5 07 46 C9 32 39 78 53 52 F8 6C
       :     58
       :   }

0 warnings, 0 errors.
</code></pre>
","2588","<c++><pem><crypto++>","6","9","1","2014-06-16 10:11:31","24194868","6","1","608639","","2014-06-13 06:08:01","2014-06-12 17:55:33",""
"28127356","InvalidCiphertext exception when decrypting ciphertext","<p>I'm working in a new protocol for secure communication and I'm having problems to decrypt the ciphertext. </p>

<p>The data packet is saved in a uint8_t* variable and encrypted. Until this part is all going well. But when I try to decrypt I got the followings problems:</p>

<p>1) If I send the vector and the size (it's really 20 but I just want to decrypt the last 16 bytes):</p>

<pre><code>CBC_Mode&lt; AES &gt;::Decryption decryptor;
decryptor.SetKeyWithIV( key, CryptoPP::AES::DEFAULT_KEYLENGTH, iv );

CryptoPP::StringSource ss( vector+4, 16 , true,
        new CryptoPP::StreamTransformationFilter( decryptor,
             new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>I get this:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>2) If I just send the vector without size:</p>

<pre><code>CryptoPP::StringSource ss( vector+4, true,
       new CryptoPP::StreamTransformationFilter( decryptor,
              new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>The programs runs but I just get all 00:</p>

<pre><code>Text Encrypted (20 bytes)
8c 97 b7 d8 74 80 3d 9f 9f 62 2e 93 38 c7 d1 b de a4 21 80 

Text Decrypted (16 bytes)
0 0 0 0 0 0 0 0 68 0 0 0 0 0 0 0 0 0 0 0 
</code></pre>

<p>I read that it could be that the key is not generated correctly, but I'm working with a size of 16 and here is how I do it:</p>

<pre><code> byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[      CryptoPP::AES::BLOCKSIZE ];
 memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
 memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );
</code></pre>

<p>3) I also tried to cast the vector to char and send it like an string:</p>

<pre><code>CryptoPP::StringSource ss( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16, true,
        new CryptoPP::StreamTransformationFilter( decryptor,
            new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>But again I get the same thing:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>Please help, I have tried for days to figure out what's wrong. This is taking me too long and I can't find the solutions.</p>

<p>Does anyone have any idea on what might be happening?</p>

<p>Let me know if you need further details, code or anything.</p>

<p>Edit:</p>

<p>4) One more thing that I tried was (another way to construct the decrypter):</p>

<pre><code>CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );


CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16 );
stfDecryptor.MessageEnd();
</code></pre>

<p>But I get the same:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>Edit2:</p>

<p>The vector is created with this line (the way the vector is fulled is a quite complicated to put it here because I am using a platform for network encoding) :</p>

<pre><code>uint8_t* vector;
</code></pre>

<p>Edit3:</p>

<p>This is how I encrypt the vector.</p>

<pre><code>CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
        CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

        CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
        stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16 );
        stfEncryptor.MessageEnd();
</code></pre>

<p>And after that I put the ciphertext again in the vector:</p>

<pre><code>std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
for(int i=0;i &lt; 16; i++){
    *(vector+ i + 4) = (ciphertext[i]) ; 
}
</code></pre>
","<pre><code>terminate called after throwing an instance of CryptoPP::InvalidCiphertext'
    what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>This is easy enough to fix. Catch a Crypto++ <code>InvalidCiphertext</code> exception. See the <a href=""http://www.cryptopp.com/docs/ref/class_invalid_ciphertext.html"" rel=""nofollow"">InvalidCiphertext Class Reference</a>.</p>

<h2>-----</h2>

<pre class=""lang-none prettyprint-override""><code>If I just send the vector without size:

CryptoPP::StringSource ss( vector+4, true, ...
</code></pre>

<p>I think this might be matching the following <code>StringSource</code> constructor, which means the length is <code>true</code>, which probable means 1. To add insult to injury the attached <code>StreamTransformationFilter</code> is being coerced into the <code>bool pumpAll</code>:</p>

<pre><code>StringSource (const byte *string, size_t length, bool pumpAll, BufferedTransformation *attachment=NULL)
</code></pre>

<p>You should probably enable warnings to catch these sorts of things. <code>-Wall -Wextra</code> are good choices. (Nothing will help the coercion of the pointer to the <code>bool</code>, though. See, for example, <a href=""http://gcc.gnu.org/ml/gcc/2011-09/msg00293.html"" rel=""nofollow"">No pointer conversion warning for ""bool"" in C/C++</a> on the GCC mailing list).</p>

<h2>-----</h2>

<pre class=""lang-none prettyprint-override""><code>If I send the vector and the size (it's really 20 but I
just want to decrypt the last 16 bytes):

...
CryptoPP::StringSource ss( vector+4, 16 , true, ...
</code></pre>

<p>I don't think this is going to work as expected. CBC mode is not a random access mode (but I may not be parsing things correctly):</p>

<pre><code>CBC_Mode&lt; AES &gt;::Encryption enc;
cout &lt;&lt; ""Random access: "" &lt;&lt; enc.IsRandomAccess() &lt;&lt; endl;
</code></pre>

<p>Results in:</p>

<pre><code>Random access: 0
</code></pre>

<p>I'm fairly certain its not going to work at byte sizes. You might be able to do it by adding a layer above the decryptor, but you will have to manage the initialization vector, then decrypt a block, and finally return the offest into the block.</p>

<h2>-----</h2>

<p>You should probably do something like the following. Its not efficient because it copes a <code>string</code> to a <code>vector</code>, but I wanted to try an use vectors since you seem to be using them.</p>

<p><code>encrypted.CopyTo(f2)</code> is where you put your socket code. Your code will not need <code>encrypted.CopyTo(f2)</code>.</p>

<pre><code>// Creates the memory block and zero's it.
SecByteBlock key(AES::DEFAULT_KEYLENGTH), iv(AES::BLOCKSIZE);

/////////////////////////////////////////////////////////////

string m1;
vector&lt;char&gt; v1;

m1 = ""Now is the time for all good men to come to the aide of their country"";
copy(m1.begin(), m1.end(), back_inserter(v1));

CBC_Mode&lt; AES &gt;::Encryption enc;
enc.SetKeyWithIV(key, key.size(), iv, iv.size());

ByteQueue encrypted;
StreamTransformationFilter f1(enc, new Redirector(encrypted));

f1.PutWord32((uint32_t)v1.size(), BIG_ENDIAN_ORDER);
f1.Put((const unsigned char *) &amp;v1[0], v1.size());
f1.MessageEnd();

/////////////////////////////////////////////////////////////

string m2;
vector&lt;char&gt; v2;

CBC_Mode&lt; AES &gt;::Decryption dec;
dec.SetKeyWithIV(key, key.size(), iv, iv.size());

ByteQueue decrypted;
StreamTransformationFilter f2(dec, new Redirector(decrypted));

encrypted.CopyTo(f2);
f2.MessageEnd();

uint32_t len;
decrypted.GetWord32(len, BIG_ENDIAN_ORDER);

v2.resize(len);
decrypted.Get((unsigned char *) &amp;v2[0], v2.size());

copy(v2.begin(), v2.end(), back_inserter(m2));

/////////////////////////////////////////////////////////////

cout &lt;&lt; ""Message: "" &lt;&lt; m1 &lt;&lt; endl;
cout &lt;&lt; ""Decrypted: "" &lt;&lt; m2 &lt;&lt; endl;
</code></pre>

<p>It produces the expected results:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
Message: Now is the time for all good men to come to the aide of their country
Decrypted: Now is the time for all good men to come to the aide of their country
</code></pre>

<h2>-----</h2>

<p>Regarding your use of <code>vector + 4</code>: once the cipher text is decrypted, you can seek in it, and do things like read a length from it. That's what this does:</p>

<pre><code>// Ciphertext is already decrypted
uint32_t len;
decrypted.GetWord32(len, BIG_ENDIAN_ORDER);
</code></pre>

<p>If you just want to discard the value, then try:</p>

<pre><code>decrypted.Skip(4);
</code></pre>

<p>But then you'll have to figure out how to size your <code>vector</code>.</p>

<h2>-----</h2>

<blockquote>
  <p>I'm working in a new protocol for secure communication </p>
</blockquote>

<p>Secure communications usually provides both confidentiality and authenticity assurances. You seem to be missing the latter since CBC mode only provides confidentiality.</p>

<p>It might be a good idea to use something that already exists, like IPSec (preferred) or TLS (will do in a pinch). Also, key agreement is going to be a pain point. Its another reason to consider using something like IPSec or TLS.</p>

<p>If you can't use something already available, then you should use an <a href=""http://www.cryptopp.com/wiki/Authenticated_encryption"" rel=""nofollow"">Authenticated Encryption</a> mode so you get confidentiality and authenticity combined into a single mode. Try <a href=""http://www.cryptopp.com/wiki/Eax_mode"" rel=""nofollow"">EAX</a>, <a href=""http://www.cryptopp.com/wiki/Gcm_mode"" rel=""nofollow"">GCM</a> or <a href=""http://www.cryptopp.com/wiki/Ccm_mode"" rel=""nofollow"">CCM</a> mode.</p>

<p>If you do, then then change is fairly trivial:</p>

<pre><code>    EAX&lt; AES &gt;::Encryption enc;
    enc.SetKeyWithIV(key, key.size(), iv, iv.size());

    ByteQueue encrypted;
    AuthenticatedEncryptionFilter f1(enc, new Redirector(encrypted));
</code></pre>

<p>And:</p>

<pre><code>    EAX&lt; AES &gt;::Decryption dec;
    dec.SetKeyWithIV(key, key.size(), iv, iv.size());

    ByteQueue decrypted;
    AuthenticatedDecryptionFilter f2(dec, new Redirector(decrypted));
</code></pre>

<h2>-----</h2>

<p>You can print the cipher text by copying it to an encoder. Copying is non-destructive (unlike moving it with <code>TransferTo</code>):</p>

<pre><code>string encoded;
HexEncoder encoder(new StringSink(encoded));
encrypted.CopyTo(encoder);
encoder.MessageEnd();
</code></pre>

<p>Fox CBC mode (less secure):</p>

<pre class=""lang-none prettyprint-override""><code>Encrypted: 7F9FFCAB00704EC79BB5F19C48FE7C668033B16F52E7E00671A38A06F4A7426E7FE31
95CA6A83C7414A76C250B42E63143C93E7A6B97B6304C5782DE3E62BD545706A9F62CD7AD57BC374
19B7510EBED
</code></pre>

<p>For EAX mode (more secure):</p>

<pre class=""lang-none prettyprint-override""><code>Encrypted: B75347EB75DF8E1F0424979E91CEECD455F5727B506A8AA932AF07E1DF6A7B037A245
FEC7A2270BFAB8110226769E1C0A12E95C455E9C714AF28DA330A2B01B3F2D541D4E68276193C018
7BA0246166AD26624E848EC8330D3
</code></pre>

<p>The extra bytes in EAX mode are the authentication tag. Its used to detect accidental and malicious tampering.</p>
","2500","<c++><crypto++>","2","3","2","2015-01-26 02:06:15","28140989","4","","608639","","2015-01-26 02:06:15","2015-01-24 16:06:29",""
"28127356","InvalidCiphertext exception when decrypting ciphertext","<p>I'm working in a new protocol for secure communication and I'm having problems to decrypt the ciphertext. </p>

<p>The data packet is saved in a uint8_t* variable and encrypted. Until this part is all going well. But when I try to decrypt I got the followings problems:</p>

<p>1) If I send the vector and the size (it's really 20 but I just want to decrypt the last 16 bytes):</p>

<pre><code>CBC_Mode&lt; AES &gt;::Decryption decryptor;
decryptor.SetKeyWithIV( key, CryptoPP::AES::DEFAULT_KEYLENGTH, iv );

CryptoPP::StringSource ss( vector+4, 16 , true,
        new CryptoPP::StreamTransformationFilter( decryptor,
             new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>I get this:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>2) If I just send the vector without size:</p>

<pre><code>CryptoPP::StringSource ss( vector+4, true,
       new CryptoPP::StreamTransformationFilter( decryptor,
              new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>The programs runs but I just get all 00:</p>

<pre><code>Text Encrypted (20 bytes)
8c 97 b7 d8 74 80 3d 9f 9f 62 2e 93 38 c7 d1 b de a4 21 80 

Text Decrypted (16 bytes)
0 0 0 0 0 0 0 0 68 0 0 0 0 0 0 0 0 0 0 0 
</code></pre>

<p>I read that it could be that the key is not generated correctly, but I'm working with a size of 16 and here is how I do it:</p>

<pre><code> byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[      CryptoPP::AES::BLOCKSIZE ];
 memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
 memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );
</code></pre>

<p>3) I also tried to cast the vector to char and send it like an string:</p>

<pre><code>CryptoPP::StringSource ss( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16, true,
        new CryptoPP::StreamTransformationFilter( decryptor,
            new CryptoPP::StringSink( decryptedtext ) ) );
</code></pre>

<p>But again I get the same thing:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>Please help, I have tried for days to figure out what's wrong. This is taking me too long and I can't find the solutions.</p>

<p>Does anyone have any idea on what might be happening?</p>

<p>Let me know if you need further details, code or anything.</p>

<p>Edit:</p>

<p>4) One more thing that I tried was (another way to construct the decrypter):</p>

<pre><code>CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );


CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16 );
stfDecryptor.MessageEnd();
</code></pre>

<p>But I get the same:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>

<p>Edit2:</p>

<p>The vector is created with this line (the way the vector is fulled is a quite complicated to put it here because I am using a platform for network encoding) :</p>

<pre><code>uint8_t* vector;
</code></pre>

<p>Edit3:</p>

<p>This is how I encrypt the vector.</p>

<pre><code>CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
        CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

        CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
        stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16 );
        stfEncryptor.MessageEnd();
</code></pre>

<p>And after that I put the ciphertext again in the vector:</p>

<pre><code>std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
for(int i=0;i &lt; 16; i++){
    *(vector+ i + 4) = (ciphertext[i]) ; 
}
</code></pre>
","<p>The problem was that I was encoding with padding and trying to decrypt it without. So I add not only in the encryption but in the descryption that it should work without padding.</p>

<p>Creation of the Key and IV:</p>

<pre><code>CBC_Mode&lt; AES &gt;::Encryption encryptor;
encryptor.SetKeyWithIV( key, CryptoPP::AES::DEFAULT_KEYLENGTH, iv );
</code></pre>

<p>Encryption:  </p>

<pre><code>CryptoPP::StringSource ss( vector + 4 , 16, true, 
     new CryptoPP::StreamTransformationFilter( encryptor,
          new CryptoPP::StringSink( ciphertext ),
              CryptoPP::StreamTransformationFilter::NO_PADDING
     ) // StreamTransformationFilter      
); // StringSource
</code></pre>

<p>Decryption:</p>

<pre><code>CBC_Mode&lt; AES &gt;::Decryption decryptor;
    decryptor.SetKeyWithIV( key, CryptoPP::AES::DEFAULT_KEYLENGTH, iv );

        CryptoPP::StringSource ss( reinterpret_cast&lt;const unsigned char*&gt;( (vector + 4) ), 16, true,
                new CryptoPP::StreamTransformationFilter( decryptor,
                    new CryptoPP::StringSink( decryptedtext ), CryptoPP::StreamTransformationFilter::NO_PADDING) );
</code></pre>

<p>I did this because I don't want to work with padding anymore.</p>
","2500","<c++><crypto++>","2","0","2","2015-01-26 02:06:15","28140989","4","","608639","","2015-01-26 02:06:15","2015-01-24 16:06:29",""
"24174063","Correct way of linking crypto++ library with my application","<p>I am trying to use Crypto++ library in my Qt application.</p>

<p>Qt version is 5.3.0 Compiled with VS2013
running on Windows 8.1</p>

<p>Crypto++ Lib compiled with VS2013</p>

<p>Here is the section of my .pro file which links the lib</p>

<pre><code>win32: LIBS += -L$$PWD/cryptopp562/Win32/DLL_Output/Release/ -lcryptopp

INCLUDEPATH += $$PWD/cryptopp562
DEPENDPATH += $$PWD/cryptopp562
</code></pre>

<p>Everything appears to be fine. However I get two issues.</p>

<ul>
<li><p>I am unable to compile the debug version. I assume that this is because I have release version of .lib file</p></li>
<li><p>When I try to compile my application, I get the following errors</p></li>
</ul>

<p>crypto.obj:-1: error: LNK2019: unresolved external symbol ""class std::basic_string,class std::allocator > const CryptoPP::DEFAULT_CHANNEL"" (?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B) referenced in function ""public: virtual bool __thiscall CryptoPP::Unflushable::Flush(bool,int,bool)"" (?Flush@?$Unflushable@VFilter@CryptoPP@@@CryptoPP@@UAE_N_NH0@Z)</p>

<p>I get two such errors and I assume that this is due to two functions which calls the lib which are not getting compiled.</p>

<h1>Edit</h1>

<p>My observations:</p>

<ul>
<li><p>It seems like I am linking to correct static lib, i.e. libcrypt.lib and I have used dumpbin utility to ensure that the missing symbols specified by the error are there in the lib file.</p></li>
<li><p>It appears that though I am specifying in the .pro file, some how the lib is not being referenced by the project. I have put the following line in my .pro file to reference to static lib</p>

<p>win32: LIBS += -L$$PWD/cryptopp562/Win32/Output/Release/ -lcryptlib</p>

<p>INCLUDEPATH += $$PWD/cryptopp562
DEPENDPATH += $$PWD/cryptopp562</p>

<p>win32:!win32-g++ PRE_TARGETDEPS += $$PWD/cryptopp562/Win32/Output/Release/cryptlib.lib
else:win32-g++: PRE_TARGETDEPS += $$PWD/cryptopp562/Win32/Output/Release/libcryptlib.a</p></li>
</ul>

<p>My question is,</p>

<p>What mistake I am making ?</p>

<p>What is the correct way to link the Crypto++ lib to Qt project.</p>
","<blockquote>
  <p>I am unable to compile the debug version. I assume that this is because I have release version of .lib file</p>
</blockquote>

<p>You can find the versions of the library in their respective folders:</p>

<ul>
<li>Release x64: <code>&lt;cryptopp&gt;\x64\Output\Release</code></li>
<li>Release Win32: <code>&lt;cryptopp&gt;\Win32\Output\Release</code></li>
<li>Debug x64: <code>&lt;cryptopp&gt;\x64\Output\Debug</code></li>
<li>Debug Win32: <code>&lt;cryptopp&gt;\Win32\Output\Debug</code></li>
</ul>

<p>I suppose the first step is to make sure you are building them. In Visual Studio, navigate to <strong><em>Build → Batch Build</em></strong>. Then ensure the four <code>cryptlib</code> configurations are checked. Don't worry about the other 20 or so configuration/platform combinations (except maybe <code>cryptest</code>, which you should run for your native platform vis-à-vis <code>cryptest v</code> to run the self tests).</p>

<p><img src=""https://i.stack.imgur.com/VYmLc.png"" alt=""enter image description here""></p>

<p>After ensuring they are checked, select <strong><em>Build</em></strong> in the upper left corner.</p>

<hr>

<blockquote>
  <p>crypto.obj:-1: error: LNK2019: unresolved external symbol ""class std::basic_string,class std::allocator > const CryptoPP::DEFAULT_CHANNEL""
     (?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B)
     referenced in function ""public: virtual bool __thiscall CryptoPP::Unflushable::Flush(bool,int,bool)"" 
     (?Flush@?$Unflushable@VFilter@CryptoPP@@@CryptoPP@@UAE_N_NH0@Z)</p>
</blockquote>

<p>It sounds like you are linking to the DLL, and not the static LIB. Add <code>CRYPTOPP_IMPORTS</code> to your QT project settings or your precompiled header. Then include the Crypto++ includes. Since you are defining <code>CRYPTOPP_IMPORTS</code>, you do <em>not</em> need to include Crypto++'s <code>dll.h</code>.</p>

<p>With that said, I would recommend abandoning the DLL. The DLL is provided for the FIPS gear, and it might be missing some things you want or need. Instead of the DLL, you should used the static LIB. When using the static LIB, you don't need to worry about defining <code>CRYPTOPP_IMPORTS</code>.</p>

<p>The answer above shows you how to build the Debug and Release versions of the static LIB.</p>
","2499","<compiler-construction><qt5><unresolved-external><crypto++>","2","0","2","2014-06-13 08:58:50","24193459","1","","862175","","2014-06-12 15:13:17","2014-06-11 23:10:52",""
"24174063","Correct way of linking crypto++ library with my application","<p>I am trying to use Crypto++ library in my Qt application.</p>

<p>Qt version is 5.3.0 Compiled with VS2013
running on Windows 8.1</p>

<p>Crypto++ Lib compiled with VS2013</p>

<p>Here is the section of my .pro file which links the lib</p>

<pre><code>win32: LIBS += -L$$PWD/cryptopp562/Win32/DLL_Output/Release/ -lcryptopp

INCLUDEPATH += $$PWD/cryptopp562
DEPENDPATH += $$PWD/cryptopp562
</code></pre>

<p>Everything appears to be fine. However I get two issues.</p>

<ul>
<li><p>I am unable to compile the debug version. I assume that this is because I have release version of .lib file</p></li>
<li><p>When I try to compile my application, I get the following errors</p></li>
</ul>

<p>crypto.obj:-1: error: LNK2019: unresolved external symbol ""class std::basic_string,class std::allocator > const CryptoPP::DEFAULT_CHANNEL"" (?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B) referenced in function ""public: virtual bool __thiscall CryptoPP::Unflushable::Flush(bool,int,bool)"" (?Flush@?$Unflushable@VFilter@CryptoPP@@@CryptoPP@@UAE_N_NH0@Z)</p>

<p>I get two such errors and I assume that this is due to two functions which calls the lib which are not getting compiled.</p>

<h1>Edit</h1>

<p>My observations:</p>

<ul>
<li><p>It seems like I am linking to correct static lib, i.e. libcrypt.lib and I have used dumpbin utility to ensure that the missing symbols specified by the error are there in the lib file.</p></li>
<li><p>It appears that though I am specifying in the .pro file, some how the lib is not being referenced by the project. I have put the following line in my .pro file to reference to static lib</p>

<p>win32: LIBS += -L$$PWD/cryptopp562/Win32/Output/Release/ -lcryptlib</p>

<p>INCLUDEPATH += $$PWD/cryptopp562
DEPENDPATH += $$PWD/cryptopp562</p>

<p>win32:!win32-g++ PRE_TARGETDEPS += $$PWD/cryptopp562/Win32/Output/Release/cryptlib.lib
else:win32-g++: PRE_TARGETDEPS += $$PWD/cryptopp562/Win32/Output/Release/libcryptlib.a</p></li>
</ul>

<p>My question is,</p>

<p>What mistake I am making ?</p>

<p>What is the correct way to link the Crypto++ lib to Qt project.</p>
","<p>I'm going to answer the Edit and Comments in a second block.</p>

<blockquote>
  <p>After many attempts, finally I am getting this error -
  cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for
  'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value
  'MD_DynamicRelease' in main.obj</p>
</blockquote>

<p>Right click on the <code>cryptlib</code> project, and then select <strong><em>Properties</em></strong>.</p>

<p>Notice the <strong><em>Runtime Library</em></strong>. Crypto++ uses the non-DLL runtime libraries by default; and I suspect QT uses the DLL versions of the runtime library by default. Put another way, Crypto++ uses <code>/MT</code> or <code>/MTd</code> by default. And you need <code>/MD</code> or <code>/MDd</code> for Qt integration.</p>

<p><img src=""https://i.stack.imgur.com/YZoDi.png"" alt=""enter image description here""></p>

<p>To fix this, have Crypto++ use the DLL version of the runtime library for each Configuration (Debug and Release) and each Platform (Win32 and x64). So your new settings would look like so (notice the addition of <code>DLL</code>):</p>

<p><img src=""https://i.stack.imgur.com/eQduo.png"" alt=""enter image description here""></p>

<p>After making the changes, do a <strong><em>Build → Batch Build → Clean</em></strong> and then a <strong><em>Build → Batch Build → [four static LIBs]</em></strong> as described in the other answer.</p>

<p>Or, you can tell QT to use the non-DLL versions of the runtime library. But nowadays, its usually easiest to use the DLL version of the runtime library for everything.</p>

<p>In either case (change Crypto++ or change Qt), you will still be using the Crypto++ static LIB. The only difference is the static LIB will be built using the DLL version of the runtime library, and not the non-DLL version of the runtime library.</p>

<p>By the way, this was documented some time ago at <strong><em>Static Versus Dynamic Linking</em></strong> at <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment</a>. But I think the solution is unclear.</p>
","2499","<compiler-construction><qt5><unresolved-external><crypto++>","2","4","2","2014-06-13 08:58:50","24193459","1","","862175","","2014-06-12 15:13:17","2014-06-11 23:10:52",""
"2256233","What is the size of a RSA signature in bytes?","<p>I'm currently using Crypto++ to generate a signature for a block of data. I expected the signature to be 20 bytes ( SHA 1 Hash) , as my understanding was that the signature is just an encrypted hash. But when checking with maxsignaturelength and signature length , it seems that it is 192 bytes. Is it normal?</p>
","<p>The size of the signature is the size of the RSA modulus in bytes.</p>
","2481","<rsa><crypto++>","4","8","1","2010-02-13 02:36:36","2256272","1","","","","","2010-02-13 02:15:24",""
"38893334","Using Crypto++ static library in a QT project","<blockquote>
  <p>I have built cryptopp statically on my system it passes all tests too. These are the warning though I get during tests</p>
</blockquote>

<pre><code>WARNING: CRYPTOPP_NO_UNALIGNED_DATA_ACCESS is not defined in config.h.
WARNING: CRYPTOPP_INIT_PRIORITY is not defined in config.h.
WARNING: CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY_562 is defined in config.h.
WARNING: You should make these changes in config.h, and not CXXFLAGS.
WARNING: You can 'mv config.recommend config.h', but it breaks versioning.
WARNING: See http://cryptopp.com/wiki/config.h for more details.
</code></pre>

<p>I now link this in my QT project file as </p>

<pre><code>TEMPLATE = app

LIBS += -L/usr/lib/libcryptopp.a
#LIBS += -lcryptopp

CONFIG += console c++11
CONFIG += staticlib

SOURCES += main.cpp \
hashdata.cpp

HEADERS += \
hashdata.hpp
</code></pre>

<p>But when I compile this I get all undefined errors.</p>

<pre><code>hashdata.o: In function `hashdata::hashfunction(std::string)':
hashdata.cpp:(.text+0x1fb): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
hashdata.cpp:(.text+0x270): undefined reference to `CryptoPP::SHA512::InitState(unsigned long long*)'
hashdata.cpp:(.text+0x29a): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
hashdata.cpp:(.text+0x2a1): undefined reference to `vtable for CryptoPP::StringSinkTemplate&lt;std::string&gt;'
hashdata.cpp:(.text+0x30b): undefined reference to `CryptoPP::Filter::Filter(CryptoPP::BufferedTransformation*)'
hashdata.cpp:(.text+0x312): undefined reference to `vtable for CryptoPP::Grouper'
hashdata.cpp:(.text+0x35e): undefined reference to `CryptoPP::Filter::Detach(CryptoPP::BufferedTransformation*)'
hashdata.cpp:(.text+0x375): undefined reference to `CryptoPP::Filter::Filter(CryptoPP::BufferedTransformation*)'
hashdata.cpp:(.text+0x37c): undefined reference to `vtable for CryptoPP::BaseN_Encoder'
hashdata.cpp:(.text+0x3d3): undefined reference to `CryptoPP::Filter::Detach(CryptoPP::BufferedTransformation*)'
hashdata.cpp:(.text+0x3e5): undefined reference to `CryptoPP::ProxyFilter::ProxyFilter(CryptoPP::BufferedTransformation*, unsigned long, unsigned long, CryptoPP::BufferedTransformation*)'
hashdata.cpp:(.text+0x3ec): undefined reference to `vtable for CryptoPP::HexEncoder'
hashdata.cpp:(.text+0x452): undefined reference to `vtable for CryptoPP::AlgorithmParametersTemplate&lt;int&gt;'
hashdata.cpp:(.text+0x4af): undefined reference to `vtable for CryptoPP::AlgorithmParametersTemplate&lt;CryptoPP::ConstByteArrayParameter&gt;'
...
</code></pre>

<p>I have seen a similar problem previously when I searched in google, but the solution isn't clear. Could it be because of C++11 flags ? </p>
","<blockquote>
  <p>I have built cryptopp statically on my system it passes all tests too.
  These are the warning though I get during tests</p>
  
  <blockquote>
    <p>WARNING: CRYPTOPP_NO_UNALIGNED_DATA_ACCESS is not defined in config.h.
    WARNING: CRYPTOPP_INIT_PRIORITY is not defined in config.h. WARNING:
    CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY_562 is defined in config.h.
    WARNING: You should make these changes in config.h, and not CXXFLAGS.
    WARNING: You can 'mv config.recommend config.h', but it breaks
    versioning. WARNING: See <a href=""http://cryptopp.com/wiki/config.h"" rel=""nofollow noreferrer"">http://cryptopp.com/wiki/config.h</a> for more
    details.</p>
  </blockquote>
</blockquote>

<p>I can comment on this warning. You should perform the steps it says:</p>

<pre><code>mv config.recommend config.h
</code></pre>

<p><code>config.recommend</code> puts the library is a better configuration by completely avoiding known undefined behavior that <em>could not</em> be removed without breaking versioning. Since you don't appear to have versioning issues (like say, Fedora or Debian), then you can perform the move.</p>

<hr>

<blockquote>
  <p>I now link this in my QT project file as</p>

<pre><code>TEMPLATE = app

LIBS += -L/usr/lib/libcryptopp.a
#LIBS += -lcryptopp

CONFIG += console c++11
...
</code></pre>
</blockquote>

<p>When you build Crypto++, you should use the same compiler and flags for the library and app. I suggest the following.</p>

<p><strong><em>Crypto++</em></strong>:</p>

<pre><code># Be sure to 'mv config.recommend config.h'
export CXXFAGS=""-DNDEBUG -g2 -O3 -std=c++11""
make static dynamic test
</code></pre>

<p><strong><em>Qt App</em></strong></p>

<pre><code># main.pro file
QMAKE_CXXFLAGS += -DNDEBUG -g2 -O3
</code></pre>

<p>Also see <a href=""http://www.cryptopp.com/wiki/GNUmakefile#Building_the_Library"" rel=""nofollow noreferrer"">GNUmakefile | Building the Library</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
<pre><code>hashdata.o: In function `hashdata::hashfunction(std::string)':
hashdata.cpp:(.text+0x1fb): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
hashdata.cpp:(.text+0x270): undefined reference to `CryptoPP::SHA512::InitState(unsigned long long*)'
...
</code></pre>
</blockquote>

<p>These are coming from source (<code>*.cpp</code>) files. I'm guessing (and its purely a guess) one of two problems:</p>

<ul>
<li>C++03 vs C++11 is causing missing symbols</li>
<li>QT Creator is not using <code>libcryptopp.a</code></li>
</ul>

<p>Use <code>nm</code> to inspect the symbols. Something like the following (the ' T "" tells you its defined and in the text section):</p>

<pre><code>$ nm libcryptopp.a 2&gt;/dev/null | c++filt | \
     grep 'Algorithm::Algorithm(bool)' | grep ' T '
0000000000000060 T CryptoPP::Algorithm::Algorithm(bool)
0000000000000070 T CryptoPP::Algorithm::Algorithm(bool)
</code></pre>

<p>If the symbols are present by QT Creator is not finding the Crypto++ library, then see something like <a href=""https://stackoverflow.com/q/718447"">Adding external library into Qt Creator project</a>.</p>

<hr>

<p><strong><em>From Comments</em></strong>:</p>

<blockquote>
  <p><code>-lcryptopp</code> works, but I don't know why <code>-L/usr/lib/libcryptopp.a</code> doesn't. ... Because if a person had both static and dynamic libraries, I still don't know how to force linking static ones. </p>
</blockquote>

<p>An archive, like <code>libcryptopp.a</code>, is a collection of object files. You add it to <code>OBJECTS</code>, not <code>LIBS</code>, so you <a href=""https://stackoverflow.com/questions/20874587/adding-object-o-files-to-qtcreator-project"">want something like</a>:</p>

<pre><code># main.pro file
OBJECTS += /usr/lib/libcryptopp.a
</code></pre>

<p>You use <code>-L</code> to specify a library path to a linker. It does not make much sense to <code>-L/usr/lib/libcryptopp.a</code> since its used for paths.</p>

<hr>

<blockquote>
  <p>Additional note is that when both the static and dynamic libs were present it was automatically linking the dynamic lib. Do you know how to force static linking ? </p>
</blockquote>

<p>On Linux, you can force static linking by either (1) <code>-Bstatic -lcryptopp</code>; or (2) directly specifying <code>/usr/lib/libcryptopp.a</code>. The Crypto++ <a href=""http://www.cryptopp.com/wiki/GNUmakefile#Creating_Programs"" rel=""nofollow noreferrer"">test program uses method (2)</a>:</p>

<pre><code>g++ main.cpp /usr/lib/libcryptopp.a -o main.exe
</code></pre>

<p>On OS X, the linker always links to the dynamic object. It even does so on iOS, where userland is usually not allowed to load dynamic objects. To avoid dynamic linking, either (1) move or rename the <code>*.dylib</code>; or (2) directly specifying <code>/usr/lib/libcryptopp.a</code>. The Crypto++ <a href=""http://www.cryptopp.com/wiki/GNUmakefile#Creating_Programs"" rel=""nofollow noreferrer"">test program uses method (2)</a>:</p>

<pre><code>g++ main.cpp /usr/lib/libcryptopp.a -o main.exe
</code></pre>
","2477","<c++><linux><qt><crypto++>","1","2","1","2017-06-17 19:28:02","38905671","8","2","608639","","2017-06-17 19:28:02","2016-08-11 10:07:59",""
"25887939","How to convert CryptoPP::Integer to char*","<p>I want to convert myVar from <code>CryptoPP:Integer</code> to <code>char*</code> or to String :
The code is below :</p>

<pre><code>CryptoPP::Integer myVar = pubKey.ApplyFunction(m);
std::cout &lt;&lt; ""result: "" &lt;&lt; std::hex &lt;&lt; myVar&lt;&lt; std::endl;
</code></pre>

<p>I have been searching the Internet for converting <code>CryptoPP:Integer</code> to <code>char*</code> but I have had no luck finding. So, either it is really a problem with all to convert <code>CryptoPP:Integer</code> to <code>char*</code>, either I didn't understand very well type <code>CryptoPP:Integer</code> within C++ .</p>

<p>Can someone help me please?</p>
","<p>With Boost:</p>

<pre><code>boost::lexical_cast&lt;std::string&gt;(myVar);
</code></pre>

<p>C++98:</p>

<pre><code>std::ostringstream stream;
stream &lt;&lt; myVar;
stream.str();
</code></pre>
","2374","<c++><visual-c++><crypto++>","3","5","4","2014-09-17 21:38:58","25888061","3","","1629821","","2014-09-17 10:32:46","2014-09-17 10:17:04",""
"25887939","How to convert CryptoPP::Integer to char*","<p>I want to convert myVar from <code>CryptoPP:Integer</code> to <code>char*</code> or to String :
The code is below :</p>

<pre><code>CryptoPP::Integer myVar = pubKey.ApplyFunction(m);
std::cout &lt;&lt; ""result: "" &lt;&lt; std::hex &lt;&lt; myVar&lt;&lt; std::endl;
</code></pre>

<p>I have been searching the Internet for converting <code>CryptoPP:Integer</code> to <code>char*</code> but I have had no luck finding. So, either it is really a problem with all to convert <code>CryptoPP:Integer</code> to <code>char*</code>, either I didn't understand very well type <code>CryptoPP:Integer</code> within C++ .</p>

<p>Can someone help me please?</p>
","<p>One way, without knowing much more about <code>CryptoPP::Integer</code> other than it clearly supports <code>&lt;&lt;</code> as implied by your question, is to use <code>std::stringstream</code>:</p>

<pre><code>std::stringstream ss;
ss &lt;&lt; std::hex /*if required*/ &lt;&lt; myVar;
</code></pre>

<p>Extract the underlying <code>std::string</code> using, say <code>std::string s = ss.str();</code>. You can then use <code>s.c_str()</code> to access the <code>const char*</code> buffer for as long as <code>s</code> is in scope. Don't change <code>s</code> in any way once you've called and relied upon the result of <code>c_str()</code> as the behaviour of doing so and subsequently relying on that result is <em>undefined</em>.</p>

<p>There are neater C++11 solutions but that requires you (and me) to know more about the type.</p>
","2374","<c++><visual-c++><crypto++>","3","5","4","2014-09-17 21:38:58","25888061","3","","1629821","","2014-09-17 10:32:46","2014-09-17 10:17:04",""
"25887939","How to convert CryptoPP::Integer to char*","<p>I want to convert myVar from <code>CryptoPP:Integer</code> to <code>char*</code> or to String :
The code is below :</p>

<pre><code>CryptoPP::Integer myVar = pubKey.ApplyFunction(m);
std::cout &lt;&lt; ""result: "" &lt;&lt; std::hex &lt;&lt; myVar&lt;&lt; std::endl;
</code></pre>

<p>I have been searching the Internet for converting <code>CryptoPP:Integer</code> to <code>char*</code> but I have had no luck finding. So, either it is really a problem with all to convert <code>CryptoPP:Integer</code> to <code>char*</code>, either I didn't understand very well type <code>CryptoPP:Integer</code> within C++ .</p>

<p>Can someone help me please?</p>
","<p>If <code>CryptoPP::Integer</code> can be sent to output streams like <code>std::cout</code> (as your code seems to suggest), then you can use <a href=""http://www.cplusplus.com/reference/sstream/ostringstream/"" rel=""nofollow""><strong><code>std::ostringstream</code></strong></a>:</p>

<pre><code>#include &lt;sstream&gt;  // For std::ostringstream
....

std::string ToString(const CryptoPP::Integer&amp; n)
{
    // Send the CryptoPP::Integer to the output stream string
    std::ostringstream os;
    os &lt;&lt; n;    
    // or, if required:
    //     os &lt;&lt; std::hex &lt;&lt; n;  

    // Convert the stream to std::string
    return os.str();
}
</code></pre>

<p>Then, once you have a <code>std::string</code> instance, you can convert it to <code>const char*</code> using <strong><code>std::string::c_str()</code></strong>.<br>
(But I think in C++ code you should use a <em>safe</em> string class like <code>std::string</code> in general, instead of raw C-style character pointers).</p>

<hr>

<p><strong>PS</strong><br>
I'm assuming <code>CryptoPP::Integer</code> is <em>not</em> a trivial typedef for an <code>int</code>.<br>
If you want to convert an <code>int</code> to a <code>std::string</code>, then you may want to just use C++11's <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow""><strong><code>std::to_string()</code></strong></a>.</p>
","2374","<c++><visual-c++><crypto++>","3","2","4","2014-09-17 21:38:58","25888061","3","","1629821","","2014-09-17 10:32:46","2014-09-17 10:17:04",""
"25887939","How to convert CryptoPP::Integer to char*","<p>I want to convert myVar from <code>CryptoPP:Integer</code> to <code>char*</code> or to String :
The code is below :</p>

<pre><code>CryptoPP::Integer myVar = pubKey.ApplyFunction(m);
std::cout &lt;&lt; ""result: "" &lt;&lt; std::hex &lt;&lt; myVar&lt;&lt; std::endl;
</code></pre>

<p>I have been searching the Internet for converting <code>CryptoPP:Integer</code> to <code>char*</code> but I have had no luck finding. So, either it is really a problem with all to convert <code>CryptoPP:Integer</code> to <code>char*</code>, either I didn't understand very well type <code>CryptoPP:Integer</code> within C++ .</p>

<p>Can someone help me please?</p>
","<p>There's a few different ways you can do this, depending on what you want. <code>char*</code> does not provide enough information in this case.</p>

<p>Here's what you get when using the insertion operator:</p>

<pre><code>byte buff[] = { 'H', 'e', 'l', 'l', 'o' };
CryptoPP::Integer n(buff, sizeof(buff));

cout &lt;&lt; ""Oct: "" &lt;&lt; std::oct &lt;&lt; n &lt;&lt; endl;
cout &lt;&lt; ""Dec: "" &lt;&lt; std::dec &lt;&lt; n &lt;&lt; endl;
cout &lt;&lt; ""Hex: "" &lt;&lt; std::hex &lt;&lt; n &lt;&lt; endl;
</code></pre>

<p>That results in:</p>

<pre><code>$ ./cryptopp-test.exe
Oct: 4414533066157o
Dec: 310939249775.
Hex: 48656c6c6fh
</code></pre>

<hr>

<p>However, if you want to get the original string ""hello"" (re: your Raw RSA project):</p>

<pre><code>byte buff[] = { 'H', 'e', 'l', 'l', 'o' };
CryptoPP::Integer n(buff, sizeof(buff));

size_t len = n.MinEncodedSize();
string str;

str.resize(len);
n.Encode((byte *)str.data(), str.size(), Integer::UNSIGNED);

cout &lt;&lt; ""Str: "" &lt;&lt; str &lt;&lt; endl;
</code></pre>

<p>That results in:</p>

<pre><code>$ ./cryptopp-test.exe
Str: Hello
</code></pre>

<hr>

<p>If, however, you just want the string used in an <code>Integer</code>, then:</p>

<pre><code>Integer i(""11111111111111111111"");    
ostringstream oss;

oss &lt;&lt; i;    
string str = oss.str();

cout &lt;&lt; str &lt;&lt; endl;
</code></pre>

<p>That results in:</p>

<pre><code>$ ./cryptopp-test.exe
1111111111111111111.
</code></pre>
","2374","<c++><visual-c++><crypto++>","3","2","4","2014-09-17 21:38:58","25888061","3","","1629821","","2014-09-17 10:32:46","2014-09-17 10:17:04",""
"27342535","How to use a custom key in Crypto++","<p>I have a question referring to the encryption code in this question:
<a href=""https://stackoverflow.com/questions/15000688/crypto-encrypt-and-decrypt-in-two-different-c-programs/27342248#27342248"">Crypto++ encrypt and decrypt in two different c++ programs</a></p>

<p>If I want to use a custom key/iv, how can I do this?</p>
","<blockquote>
  <p>If I want to use a custom key/iv, how can I do this?</p>
</blockquote>

<p>Just plug it into a cipher with a mode.  There are plenty of modes to choose from, but you should use an authenticated encryption mode like EAX, CCM or GCM. See <a href=""http://www.cryptopp.com/wiki/Category:Mode"" rel=""nofollow"">Category:Mode</a> for discussion of the modes in Crypto++.</p>

<p>The code below takes a password or secret, keys a cipher, and then encrypts and encodes a message. Next, it decodes the encrypted message. Finally it prints some of the parameters.</p>

<hr>

<pre><code>try {

    // KDF parameters
    string password = ""Super secret password"";
    unsigned int iterations = 15000;
    char purpose = 0; // unused by Crypto++

    // 32 bytes of derived material. Used to key the cipher.
    //   16 bytes are for the key, and 16 bytes are for the iv.
    SecByteBlock derived(32);

    // KDF function
    PKCS5_PBKDF2_HMAC&lt;SHA256&gt; kdf;
    kdf.DeriveKey(derived.data(), derived.size(), purpose, (byte*)password.data(), password.size(), NULL, 0, iterations);

    // Encrypt a secret message
    string plaintext = ""Attack at dawn"", ciphertext, recovered;

    // Key the cipher
    EAX&lt;AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(derived.data(), 16, derived.data() + 16, 16);

    AuthenticatedEncryptionFilter ef(encryptor, new StringSink(ciphertext));
    ef.Put((byte*)plaintext.data(), plaintext.size());
    ef.MessageEnd();

    // Key the cipher
    EAX&lt;AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(derived.data(), 16, derived.data() + 16, 16);

    AuthenticatedDecryptionFilter df(decryptor, new StringSink(recovered));
    df.Put((byte*)ciphertext.data(), ciphertext.size());
    df.MessageEnd();

    // Done with encryption and decryption

    // Encode various parameters
    HexEncoder encoder;
    string key, iv, cipher;

    encoder.Detach(new StringSink(key));
    encoder.Put(derived.data(), 16);
    encoder.MessageEnd();

    encoder.Detach(new StringSink(iv));
    encoder.Put(derived.data() + 16, 16);
    encoder.MessageEnd();

    encoder.Detach(new StringSink(cipher));
    encoder.Put((byte*)ciphertext.data(), ciphertext.size());
    encoder.MessageEnd();

    // Print stuff
    cout &lt;&lt; ""plaintext: "" &lt;&lt; plaintext &lt;&lt; endl;
    cout &lt;&lt; ""key: "" &lt;&lt; key &lt;&lt; endl;
    cout &lt;&lt; ""iv: "" &lt;&lt; iv &lt;&lt; endl;
    cout &lt;&lt; ""ciphertext: "" &lt;&lt; cipher &lt;&lt; endl;
    cout &lt;&lt; ""recovered: "" &lt;&lt; recovered &lt;&lt; endl;

}
catch(CryptoPP::Exception&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<p>A run of the program produces the following output.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
plaintext: Attack at dawn
key: 7A8C7732898FB687669CB7DBEFBDD789
iv: 0AA980BABE72797E415C9B8979BF30EF
ciphertext: 197D0BD1A12577393AD1B1696B75D0FC6B8A142CF15B5F887AA965CE75F0
recovered: Attack at dawn
</code></pre>

<hr>

<p>Even better, use an Integrated Encryption Scheme. Crypto++ provides two of them. The first is <a href=""http://cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Elliptic Curve Integrated Encryption Scheme</a> which operates over fields of elliptic curse. The second is <a href=""http://cryptopp.com/wiki/Discrete_Logarithm_Integrated_Encryption_Scheme"" rel=""nofollow"">Discrete Logarithm Integrated Encryption Scheme</a>, which operates over the field of integers.</p>

<p>There's a number of non-obvious reason why its <em>""even better""</em>, but the big one is its <a href=""https://en.wikipedia.org/wiki/Ciphertext_indistinguishability"" rel=""nofollow"">IND-CCA2</a>. Other, more practical ones include: you <strong><em>can't</em></strong> reuse a security context because correct use is built into the system; and padding has been removed which greatly simplifies proofs and avoids potential oracles. The system is also predicated on <a href=""https://en.wikipedia.org/wiki/Discrete_logarithm"" rel=""nofollow"">Discrete Logs</a>, which makes it a Diffie-Hellman based problem and its believed to be hard everywhere.</p>
","2353","<c++><encryption><key><crypto++><passphrase>","0","1","1","2015-09-16 07:59:34","27348134","0","0","-1","","2017-05-23 12:09:24","2014-12-07 12:20:10",""
"13872129","Building and linking test code for Crypto++","<p>I'm trying to write some simple test code for the Crypto++ library for a project. I have yet to manage to get my own code to build though. It compiles fine, the problem comes in linking. I'm still pretty new to Visual Studios, but I'm using VS10. The errors I'm getting are:</p>

<pre><code>1&gt;sec_test.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::DES::Base::ProcessAndXorBlock(unsigned char const *,unsigned char const *,unsigned char *)const "" (?ProcessAndXorBlock@Base@DES@CryptoPP@@UBEXPBE0PAE@Z)
1&gt;sec_test.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::DES::Base::UncheckedSetKey(unsigned char const *,unsigned int,class CryptoPP::NameValuePairs const &amp;)"" (?UncheckedSetKey@Base@DES@CryptoPP@@UAEXPBEIABVNameValuePairs@3@@Z)
</code></pre>

<p>I've tried everything I can find in the documentation in terms of linking. I've never linked against a DLL before, but these are the errors I get when I try to. If I try to do what I think is linking against the static library version, I get even more. </p>

<p>I should note, I'm trying to test pure DES at the moment. In particular, here are the API calls I'm making, just to be safe:</p>

<pre><code>DES::Encryption  DES_encrypt;
DES_encrypt.SetKey(key, 64);
DES_encrypt.ProcessAndXorBlock(plaintext, NULL, ciphertext);

DES::Decryption DES_decrypt;
DES_decrypt.SetKey(key, 64);
DES_decrypt.ProcessAndXorBlock(ciphertext, NULL, decrypted);
</code></pre>

<p>If anyone can help, or point me in the right direction, I'd be much obliged.</p>
","<p>First thing to check is your project properties (right click on project, click <code>Properties</code>).</p>

<p>External libraries need to be specified in the <code>Linker-&gt;Input-&gt;Additional Dependencies</code> field, either by absolute path or in conjunction with the other VS path properties.</p>

<p>You can look in <code>Linker-&gt;Command Line</code> and check that the .lib files you want are actually being passed to the linker.</p>

<p>An alternate method is to turn off the <code>Suppress Startup Banner</code> option in the <code>Linker-&gt;General</code> options, and then check the build output to make sure it has what you want.</p>

<p>If you know that the libraries you want are being linked, another useful trick is to check the output of the <code>strings</code> command (in linux or cygwin) or <code>dumpbin /HEADERS</code> in the VS command prompt. You can look through the output of these commands for the symbol VS claims is missing to verify that it really is defined in the .lib file. Sometimes larger software packages have multiple .lib files, so this can help make sure you are linking the one that has the symbol you want.</p>
","2344","<c++><linker><crypto++>","0","1","1","2012-12-14 12:39:03","13878550","4","","","","","2012-12-14 03:14:00",""
"29679218","Specify Crypto++ library in a CMakeLists file","<p>I am trying to specify the Crypto++ library in my <code>CMakeLists</code> file but I always get an error.</p>

<p>Here is my <code>CMakeLists</code> file:        </p>

<pre><code>cmake_minimum_required(VERSION 2.8)
project( Recognition )
find_package( OpenCV REQUIRED )
find_package ( CURL REQUIRED )
find_package ( CRYPTOPP REQUIRED )
add_executable( Recognition Recognition.cpp )
target_link_libraries( Recognition ${OpenCV_LIBS} ${CURL_LIBRARY} ${CRYPTOPP_LIBRARY})
</code></pre>

<p>And here is the errors I get:        </p>

<pre><code> By not providing ""FindCRYPTOPP.cmake"" in CMAKE_MODULE_PATH this project has
 asked CMake to find a package configuration file provided by ""CRYPTOPP"",
 but CMake did not find one.

 Could not find a package configuration file provided by ""CRYPTOPP"" with any
 of the following names:

 CRYPTOPPConfig.cmake
 cryptopp-config.cmake

 Add the installation prefix of ""CRYPTOPP"" to CMAKE_PREFIX_PATH or set
 ""CRYPTOPP_DIR"" to a directory containing one of the above files.  If
 ""CRYPTOPP"" provides a separate development package or SDK, be sure it has
 been installed.

 -- Configuring incomplete, errors occurred!
</code></pre>

<p>Thank you for your help!</p>
","<p>CMake doesn't have a module for the Crypto++ library in the package so you have to provide your own. You can try the <a href=""https://bitbucket.org/sergiu/cryptopp-cmake"" rel=""nofollow"">following</a>(I've used it once) or google for the ""Find CryptoPP cmake"".</p>

<p>When you are done with the file, place it somewhere and point CMake to search for the file in that location. Suppose you have placed it under your sources directory in <code>contrib/cmake</code> subfolder, then CMake code will be:</p>

<pre><code>set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ""${CMAKE_SOURCE_DIR}/contrib/cmake"")
</code></pre>

<p>So you set the path for the modules search now you need to use <code>find_package</code>, note, however, that you should provide the package name in the same fashion your <code>.cmake</code> file is named. For example, if you have <code>CryptoPP.cmak</code>e, then you should put the following: </p>

<pre><code>find_package ( CryptoPP REQUIRED )
</code></pre>
","2268","<c++><makefile><cmake><crypto++>","6","5","1","2015-04-20 08:41:01","29680497","1","2","608639","","2015-04-20 08:41:01","2015-04-16 15:22:37",""
"2192584","How do I decrypt a file with Crypto++ that was encrypted with C#","<p><br>I would like to decrypt a file that I previously encrypted with C# using the TripleDESCryptoServiceProvider.
<br>Here's my code for encrypting:</p>

<pre><code>private static void EncryptData(MemoryStream streamToEncrypt)
    {
        // initialize the encryption algorithm
        TripleDES algorithm = new TripleDESCryptoServiceProvider();

        byte[] desIV = new byte[8];
        byte[] desKey = new byte[16];

        for (int i = 0; i &lt; 8; ++i)
        {
            desIV[i] = (byte)i;
        }

        for (int j = 0; j &lt; 16; ++j)
        {
            desKey[j] = (byte)j;
        }

        FileStream outputStream = new FileStream(TheCryptedSettingsFilePath, FileMode.OpenOrCreate, FileAccess.Write);
        outputStream.SetLength(0);

        CryptoStream encStream = new CryptoStream(outputStream, algorithm.CreateEncryptor(desKey, desIV),
            CryptoStreamMode.Write);

        // write the encrypted data to the file
        encStream.Write(streamToEncrypt.ToArray(), 0, (int)streamToEncrypt.Length);

        encStream.Close();
        outputStream.Close();
    }
</code></pre>

<p>I already found the Crypto++ library and managed to build and link it. So I tried to decrypt the file that was stored with C# after the encryption with the following (native) C++ code:</p>

<pre><code>FILE *fp;
long len;
char *buf;
if (_wfopen_s(&amp;fp, _T(""MyTest.bin""), _T(""rb"")) != 0)
{
    return false;
}

fseek(fp ,0 ,SEEK_END); //go to end
len = ftell(fp); //get position at end (length)
fseek(fp, 0, SEEK_SET); //go to beg.
buf = (char *)malloc(len); //malloc buffer
fread(buf, len, 1, fp); //read into buffer
fclose(fp);
BYTE pIV[] = {0, 1, 2, 3, 4, 5, 6, 7};
BYTE pKey[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};

const BYTE* lpData = (const BYTE*)(LPCTSTR)buf;
size_t bufferSize = strlen(buf);
BYTE* result = (BYTE *)malloc(bufferSize);

CFB_FIPS_Mode&lt;DES_EDE2&gt;::Decryption decryption_DES_EDE2_CFB;
decryption_DES_EDE2_CFB.SetKeyWithIV(pKey, sizeof(pKey), pIV, sizeof(pIV));
decryption_DES_EDE2_CFB.ProcessString(result, lpData, bufferSize);
</code></pre>

<p>That code won't decrypt properly. The result after the decryption doesn't match the plain text that was encrypted previously. Any idea about my code?</p>
","<p>Can you encrypt and decrypt in c++?
Can you encrypt and decrypt in c#?</p>

<p>Are you sure you are using the same mode, padding and encrypt, decrypt sequence?</p>

<pre><code>tdes.Mode = CipherMode.ECB;
tdes.Padding = PaddingMode.PKCS7;
</code></pre>
","2268","<c#><c++><encryption><crypto++>","2","0","3","2010-08-11 08:43:50","2424273","0","2","","","","2010-02-03 14:27:52",""
"2192584","How do I decrypt a file with Crypto++ that was encrypted with C#","<p><br>I would like to decrypt a file that I previously encrypted with C# using the TripleDESCryptoServiceProvider.
<br>Here's my code for encrypting:</p>

<pre><code>private static void EncryptData(MemoryStream streamToEncrypt)
    {
        // initialize the encryption algorithm
        TripleDES algorithm = new TripleDESCryptoServiceProvider();

        byte[] desIV = new byte[8];
        byte[] desKey = new byte[16];

        for (int i = 0; i &lt; 8; ++i)
        {
            desIV[i] = (byte)i;
        }

        for (int j = 0; j &lt; 16; ++j)
        {
            desKey[j] = (byte)j;
        }

        FileStream outputStream = new FileStream(TheCryptedSettingsFilePath, FileMode.OpenOrCreate, FileAccess.Write);
        outputStream.SetLength(0);

        CryptoStream encStream = new CryptoStream(outputStream, algorithm.CreateEncryptor(desKey, desIV),
            CryptoStreamMode.Write);

        // write the encrypted data to the file
        encStream.Write(streamToEncrypt.ToArray(), 0, (int)streamToEncrypt.Length);

        encStream.Close();
        outputStream.Close();
    }
</code></pre>

<p>I already found the Crypto++ library and managed to build and link it. So I tried to decrypt the file that was stored with C# after the encryption with the following (native) C++ code:</p>

<pre><code>FILE *fp;
long len;
char *buf;
if (_wfopen_s(&amp;fp, _T(""MyTest.bin""), _T(""rb"")) != 0)
{
    return false;
}

fseek(fp ,0 ,SEEK_END); //go to end
len = ftell(fp); //get position at end (length)
fseek(fp, 0, SEEK_SET); //go to beg.
buf = (char *)malloc(len); //malloc buffer
fread(buf, len, 1, fp); //read into buffer
fclose(fp);
BYTE pIV[] = {0, 1, 2, 3, 4, 5, 6, 7};
BYTE pKey[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};

const BYTE* lpData = (const BYTE*)(LPCTSTR)buf;
size_t bufferSize = strlen(buf);
BYTE* result = (BYTE *)malloc(bufferSize);

CFB_FIPS_Mode&lt;DES_EDE2&gt;::Decryption decryption_DES_EDE2_CFB;
decryption_DES_EDE2_CFB.SetKeyWithIV(pKey, sizeof(pKey), pIV, sizeof(pIV));
decryption_DES_EDE2_CFB.ProcessString(result, lpData, bufferSize);
</code></pre>

<p>That code won't decrypt properly. The result after the decryption doesn't match the plain text that was encrypted previously. Any idea about my code?</p>
","<p>I managed to do that task with Windows Crypto API as stated in <a href=""https://stackoverflow.com/questions/2155678/decrypt-file-in-c-with-microsoft-crypt-api-that-was-encrypted-with-tripledes-in"">my other post</a>.</p>
","2268","<c#><c++><encryption><crypto++>","2","0","3","2010-08-11 08:43:50","2424273","0","2","","","","2010-02-03 14:27:52",""
"2192584","How do I decrypt a file with Crypto++ that was encrypted with C#","<p><br>I would like to decrypt a file that I previously encrypted with C# using the TripleDESCryptoServiceProvider.
<br>Here's my code for encrypting:</p>

<pre><code>private static void EncryptData(MemoryStream streamToEncrypt)
    {
        // initialize the encryption algorithm
        TripleDES algorithm = new TripleDESCryptoServiceProvider();

        byte[] desIV = new byte[8];
        byte[] desKey = new byte[16];

        for (int i = 0; i &lt; 8; ++i)
        {
            desIV[i] = (byte)i;
        }

        for (int j = 0; j &lt; 16; ++j)
        {
            desKey[j] = (byte)j;
        }

        FileStream outputStream = new FileStream(TheCryptedSettingsFilePath, FileMode.OpenOrCreate, FileAccess.Write);
        outputStream.SetLength(0);

        CryptoStream encStream = new CryptoStream(outputStream, algorithm.CreateEncryptor(desKey, desIV),
            CryptoStreamMode.Write);

        // write the encrypted data to the file
        encStream.Write(streamToEncrypt.ToArray(), 0, (int)streamToEncrypt.Length);

        encStream.Close();
        outputStream.Close();
    }
</code></pre>

<p>I already found the Crypto++ library and managed to build and link it. So I tried to decrypt the file that was stored with C# after the encryption with the following (native) C++ code:</p>

<pre><code>FILE *fp;
long len;
char *buf;
if (_wfopen_s(&amp;fp, _T(""MyTest.bin""), _T(""rb"")) != 0)
{
    return false;
}

fseek(fp ,0 ,SEEK_END); //go to end
len = ftell(fp); //get position at end (length)
fseek(fp, 0, SEEK_SET); //go to beg.
buf = (char *)malloc(len); //malloc buffer
fread(buf, len, 1, fp); //read into buffer
fclose(fp);
BYTE pIV[] = {0, 1, 2, 3, 4, 5, 6, 7};
BYTE pKey[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};

const BYTE* lpData = (const BYTE*)(LPCTSTR)buf;
size_t bufferSize = strlen(buf);
BYTE* result = (BYTE *)malloc(bufferSize);

CFB_FIPS_Mode&lt;DES_EDE2&gt;::Decryption decryption_DES_EDE2_CFB;
decryption_DES_EDE2_CFB.SetKeyWithIV(pKey, sizeof(pKey), pIV, sizeof(pIV));
decryption_DES_EDE2_CFB.ProcessString(result, lpData, bufferSize);
</code></pre>

<p>That code won't decrypt properly. The result after the decryption doesn't match the plain text that was encrypted previously. Any idea about my code?</p>
","<p>Try CBC mode (the TripleDESCryptoServiceProvider's default mode)</p>
","2268","<c#><c++><encryption><crypto++>","2","0","3","2010-08-11 08:43:50","2424273","0","2","","","","2010-02-03 14:27:52",""
"8388945","Send C# AES encrypted string to CyptoPP C++ program to decrypt","<p>I'm trying to send an encrypted string via a tcp connection from a C# program to a C++ program.  The c++ program crashes in crypto++ when it tries to decrypt the string.  I can see in the debugger the string is mostly decoded but does not terminate properly.  For example if I send ""Hello world"" it gets decrypted as ""Hello world%%@#$@#"" (garbage at the end)</p>

<p>Here's how I encrypt</p>

<pre><code>           //Create byte arrays to hold original, encrypted, and decrypted data.
                byte[] dataToEncrypt = ByteConverter.GetBytes(data);

                byte[] key = new byte[16];
                for (int i = 0; i &lt; 16; ++i)
                {
                    key[i] = 1;
                }

                byte[] iv = new byte[16];
                for (int i = 0; i &lt; 16; ++i)
                {
                    iv[i] = 1;
                }


                RijndaelManaged myRijndael = new RijndaelManaged();

                myRijndael.Key = key;
                myRijndael.IV = iv;
                byte[] encrypted = encryptStringToBytes_AES(data, myRijndael.Key, myRijndael.IV);

         // sends the byte array via active tcp connection
        _transport.SendEncryptedData(encrypted);


 static byte[] encryptStringToBytes_AES(string plainText, byte[] Key, byte[] IV)
 {
   // Check arguments.
            if (plainText == null || plainText.Length &lt;= 0)
                throw new ArgumentNullException(""plainText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""IV"");

            // Declare the stream used to encrypt to an in memory
            // array of bytes.
            MemoryStream msEncrypt = null;

            // Declare the RijndaelManaged object
            // used to encrypt the data.
            RijndaelManaged aesAlg = null;

            try
            {
                // Create a RijndaelManaged object
                // with the specified key and IV.
                aesAlg = new RijndaelManaged();
                aesAlg.Key = Key;
                aesAlg.IV = IV;

                // Create an encrypto to perform the stream transform.
                ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

                // Create the streams used for encryption.
                msEncrypt = new MemoryStream();
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                    {
                        //Write all data to the stream.
                        swEncrypt.Write(plainText);
                    }
                }
            }
            finally
            {
                // Clear the RijndaelManaged object.
                if (aesAlg != null)
                    aesAlg.Clear();
            }

            // Return the encrypted bytes from the memory stream.
            return msEncrypt.ToArray();
        }
</code></pre>

<p>Here's the C++ side decrypting with Crypto++</p>

<pre><code>     byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ];
        byte iv[ CryptoPP::AES::BLOCKSIZE ];
        ::memset( key, 0x01, CryptoPP::AES::DEFAULT_KEYLENGTH );
        ::memset( iv, 0x01, CryptoPP::AES::BLOCKSIZE );

        std::string decryptedtext;


        CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
        CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );


        CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );

            // CRASHES IN .PUT(...)
        stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;(data ), len + 1);
        stfDecryptor.MessageEnd();
</code></pre>
","<p>Your problem is because of 1 of 2 things, perhaps both.</p>

<ol>
<li><p>The C# stream writer isn't writing out a null byte.  When the C++ code reads in the data, the string is not null terminated.  I haven't tested out the code you've given, but this would seem to be expected behavior.</p></li>
<li><p>The assumed methods of padding (or lack thereof) may be different between the C# implementation and the Crypto++ implementation.  AES in CBC mode can only encrypt or decrypt blocks that are multiples of the block size.  In AES, the block size is 128-bits or 16 bytes.</p></li>
</ol>

<p>Wikipedia has a great explanation of the various block cipher modes <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""nofollow"">here</a>.  The typical padding for CBC is PKCS7, which is described <a href=""http://en.wikipedia.org/wiki/Padding_%28cryptography%29"" rel=""nofollow"">here</a>.</p>

<p>I don't know the internals of either implementation well enough to know what the default methods of padding are, or if they leave that up to the user.</p>
","2265","<c#><c++><encryption><crypto++>","1","1","1","2011-12-05 20:27:35","8391421","0","","","","","2011-12-05 17:02:22",""
"37804081","Use Crypto++ RSA::PublicKey to decrypt cipher text","<p>I have the n, d, e for RSA algorithm. However, I want to use private_key to encrypt some string, generate <em>USER_CERTIFICATION</em>, and use public_key for users to decrypt it and get the string. I know if I do so, the string can be easily decrypted by anyone, but security is <strong>not</strong> my concern at all, I just need that <strong>no one except me</strong> can generate the <em>USER_CERTIFICATION</em></p>

<p>I'm using CryptoPP, the code for encoding works fine:</p>

<pre><code>Integer _n(...), _e(...), _d(...);
AutoSeededRandomPool rng;
RSA::PrivateKey k;
k.Initialize(_n, _e, _d);
RSAES_PKCS1v15_Encryptor enc(k);
std::string cipher;
StringSource ss1( plain, true,
    new PK_EncryptorFilter( rng, enc,
        new StringSink( cipher )) // PK_EncryptorFilter
    ); // StringSource
</code></pre>

<p>but the decryption code throws an exception: ""class CryptoPP::InvertibleRSAFunction: Missing required parameter 'Prime1'""</p>

<pre><code>Integer _n(...), _e(...);

AutoSeededRandomPool rng;
RSA::PublicKey k;
k.Initialize(_n, _e);
RSAES_PKCS1v15_Decryptor dec(k);
std::string plain;
StringSource ss1( cipher, true,
    new PK_DecryptorFilter( rng, dec,
        new StringSink( plain ))
    ); // StringSource
</code></pre>

<p>Is it possible to do this with CryptoPP?</p>
","<blockquote>
  <p>I want to use private_key to encrypt some string</p>
</blockquote>

<p>Usually, when you ask for <em>encrypt with the private key</em>, what you want is a <em>Probablistic Signature with Recovery (PSSR)</em> scheme. By the way, <em>encrypt with the private key</em> is <strong><em>not</em></strong> a valid cryptographic transformation :)</p>

<p>The <a href=""http://www.cryptopp.com/docs/ref/cryptlib_8h.html"" rel=""nofollow""><code>cryptlib.h</code> header</a> is described as <em>Abstract base classes that provide a uniform interface to this library</em>. All Crypto++ Signers and Verifiers adhere to the <a href=""http://www.cryptopp.com/docs/ref/class_p_k___signature_scheme.html"" rel=""nofollow""><code>PK_SignatureScheme</code></a> interface. Signers further implement <a href=""http://www.cryptopp.com/docs/ref/class_p_k___signer.html"" rel=""nofollow""><code>PK_Signer</code></a>, while Verifiers further implement <a href=""http://www.cryptopp.com/docs/ref/class_p_k___verifier.html"" rel=""nofollow""><code>PK_Verifier</code></a>.</p>

<p>The Crypto++ RSA objects would look like so:</p>

<pre><code>RSASS&lt;PSSR, SHA256&gt;::Signer signer;
RSASS&lt;PSSR, SHA256&gt;::Verifier verifier;
</code></pre>

<p>The Crypto++ Rabin objects would look like so:</p>

<pre><code>RabinSS&lt;PSSR, SHA256&gt;::Signer signer;
RabinSS&lt;PSSR, SHA256&gt;::Verifier verifier;
</code></pre>

<p>The Crypto++ Rabin-Williams objects would look like so:</p>

<pre><code>RWSS&lt;PSSR, SHA256&gt;::Signer signer;
RWSS&lt;PSSR, SHA256&gt;::Verifier verifier;
</code></pre>

<p>the objects are consistent, and you can swap them in and out.</p>

<p>By the way, you should look into Rabin-Williams to see if it fits your needs. Also see Bernstein's <a href=""http://cr.yp.to/sigs/rwsota-20080131.pdf"" rel=""nofollow"">RSA signatures and Rabin–Williams signatures: the state of the art</a>.</p>

<hr>

<blockquote>
  <p>I'm using CryptoPP, the code for encoding works fine ...</p>
</blockquote>

<p>Scrap it. The exponent you are using is well known, so there's no real security in what you are doing. There are ways to improve the security, but it sounds like you want a PSSR instead.</p>

<p>Here are the two example of using RSA's PSSR from the wiki:</p>

<ul>
<li><p><a href=""http://www.cryptopp.com/wiki/RSA_Signature_Schemes#RSA_Probabilistic_Signature_Scheme_with_Recovery"" rel=""nofollow"">RSA Probabilistic Signature Scheme with Recovery</a></p></li>
<li><p><a href=""http://www.cryptopp.com/wiki/RSA_Signature_Schemes#RSA_Probabilistic_Signature_Scheme_with_Recovery_.28Filter.29"" rel=""nofollow"">RSA Probabilistic Signature Scheme with Recovery (Filter)</a></p></li>
</ul>

<p>And here's the signer code for <a href=""http://www.cryptopp.com/wiki/RSA_Signature_Schemes#RSA_Probabilistic_Signature_Scheme_with_Recovery"" rel=""nofollow"">RSA Probabilistic Signature Scheme with Recovery</a> with some of your stuff dialed in. Note that you need a real <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow""><code>RandomNumberGenerator</code></a> because the signature is randomized.</p>

<pre><code>Integer n(...), e(...), d(...);
RSA::PrivateKey key(n,e,d);
RSASS&lt;PSSR, SHA256&gt;::Signer signer(key);

////////////////////////////////////////////////
// Sign and Encode
SecByteBlock signature(signer.MaxSignatureLength(messageLen));

AutoSeededRandomPool rng;
size_t signatureLen = signer.SignMessageWithRecovery(rng, message, messageLen, NULL, 0, signature);

// Resize now we know the true size of the signature
signature.resize(signatureLen);
</code></pre>

<hr>

<p>And here's the verifier code for <a href=""http://www.cryptopp.com/wiki/RSA_Signature_Schemes#RSA_Probabilistic_Signature_Scheme_with_Recovery"" rel=""nofollow"">RSA Probabilistic Signature Scheme with Recovery</a> with some of your stuff dialed in. Note that you don't need <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow""><code>RandomNumberGenerator</code></a>, so you can use <code>NullRNG()</code> if its needed somewhere.</p>

<pre><code>Integer n(...), e(...);
RSA::PublicKey key(n,e);
RSASS&lt;PSSR, SHA256&gt;::Verifier verifier(key);

////////////////////////////////////////////////
// Verify and Recover
SecByteBlock recovered(
    verifier.MaxRecoverableLengthFromSignatureLength(signatureLen)
);

DecodingResult result = verifier.RecoverMessage(recovered, NULL, 0, signature, signatureLen);

if (!result.isValidCoding) {
    throw Exception(Exception::OTHER_ERROR, ""Invalid Signature"");
}

////////////////////////////////////////////////
// Use recovered message
//  MaxSignatureLength is likely larger than messageLength
recovered.resize(result.messageLength);
</code></pre>

<hr>

<blockquote>
  <p>... but the decryption code throws an exception: ""class CryptoPP::InvertibleRSAFunction: Missing required parameter 'Prime1'""</p>
</blockquote>

<p>Yep, <em>encrypt with the private key</em> is <strong><em>not</em></strong> a valid cryptographic transformation. I'm pretty sure <em>decrypt with the public key</em> is <strong><em>not</em></strong> valid, either :)</p>

<hr>

<p>I'm not going to provide the code for encryption and decryption since I don't believe you need it. But you can find it at <a href=""http://www.cryptopp.com/wiki/Rsa_encryption_schemes"" rel=""nofollow"">RSA Encryption Schemes</a> on the Crypto++ wiki.</p>
","2206","<c++><rsa><private-key><crypto++>","2","2","2","2016-06-15 06:56:37","37804461","1","","2219196","","2016-06-14 07:22:32","2016-06-14 06:04:02",""
"37804081","Use Crypto++ RSA::PublicKey to decrypt cipher text","<p>I have the n, d, e for RSA algorithm. However, I want to use private_key to encrypt some string, generate <em>USER_CERTIFICATION</em>, and use public_key for users to decrypt it and get the string. I know if I do so, the string can be easily decrypted by anyone, but security is <strong>not</strong> my concern at all, I just need that <strong>no one except me</strong> can generate the <em>USER_CERTIFICATION</em></p>

<p>I'm using CryptoPP, the code for encoding works fine:</p>

<pre><code>Integer _n(...), _e(...), _d(...);
AutoSeededRandomPool rng;
RSA::PrivateKey k;
k.Initialize(_n, _e, _d);
RSAES_PKCS1v15_Encryptor enc(k);
std::string cipher;
StringSource ss1( plain, true,
    new PK_EncryptorFilter( rng, enc,
        new StringSink( cipher )) // PK_EncryptorFilter
    ); // StringSource
</code></pre>

<p>but the decryption code throws an exception: ""class CryptoPP::InvertibleRSAFunction: Missing required parameter 'Prime1'""</p>

<pre><code>Integer _n(...), _e(...);

AutoSeededRandomPool rng;
RSA::PublicKey k;
k.Initialize(_n, _e);
RSAES_PKCS1v15_Decryptor dec(k);
std::string plain;
StringSource ss1( cipher, true,
    new PK_DecryptorFilter( rng, dec,
        new StringSink( plain ))
    ); // StringSource
</code></pre>

<p>Is it possible to do this with CryptoPP?</p>
","<p>So, you want to sign a message with your private key? This link has an example, maybe it helps (code and link below). Note also that not all signing is encryption. For example, ECDSA used by Bitcoin uses a signing operation that takes a random number as one input, no encryption is done as part of signing.</p>

<p><a href=""https://www.cryptopp.com/wiki/User_Guide:_rsa.h"" rel=""nofollow"">https://www.cryptopp.com/wiki/User_Guide:_rsa.h</a></p>

<pre><code>void Sign()
{
string strContents = ""A message to be signed"";
//FileSource(""tobesigned.dat"", true, new StringSink(strContents));

AutoSeededRandomPool rng;

//Read private key
CryptoPP::ByteQueue bytes;
FileSource file(""privkey.txt"", true, new Base64Decoder);
file.TransferTo(bytes);
bytes.MessageEnd();
RSA::PrivateKey privateKey;
privateKey.Load(bytes);

//Sign message
RSASSA_PKCS1v15_SHA_Signer privkey(privateKey);
SecByteBlock sbbSignature(privkey.SignatureLength());
privkey.SignMessage(
   rng,
   (byte const*) strContents.data(),
   strContents.size(),
   sbbSignature);

   //Save result
   FileSink sink(""signed.dat"");
   sink.Put((byte const*) strContents.data(), strContents.size());
   FileSink sinksig(""sig.dat"");
   sinksig.Put(sbbSignature, sbbSignature.size());
}
</code></pre>
","2206","<c++><rsa><private-key><crypto++>","2","0","2","2016-06-15 06:56:37","37804461","1","","2219196","","2016-06-14 07:22:32","2016-06-14 06:04:02",""
"19301100","How use custom key in HMAC-SHA1 Crypto++ realisation","<p>I want to implement <code>OAuth 1.0</code> protocol in my C++ project. In order to create OAuth signature I need to implement <code>HMAC-SHA1</code> algorithm where <code>key</code> and <code>text</code> will be some string created according to OAuth specification.</p>

<p>I want to use Crypto++ library for implementing HMAC-SHA1. I found this HMAC-SHA1 example on wiki of project:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(16);
prng.GenerateBlock(key, key.size());

string plain = ""HMAC Test"";
string mac, encoded;

/*********************************\
\*********************************/

// Pretty print key
encoded.clear();
StringSource(key, key.size(), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
    HMAC&lt; SHA256 &gt; hmac(key, key.size());

    StringSource(plain, true, 
        new HashFilter(hmac,
            new StringSink(mac)
        ) // HashFilter      
    ); // StringSource
}
catch(const CryptoPP::Exception&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

// Pretty print
encoded.clear();
StringSource(mac, true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; ""hmac: "" &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>But I can't understand how instead of random generated string use my created <code>key</code>. I tried just create:</p>

<pre><code>string key=...; //string generated by OAuth specification;
</code></pre>

<p>But then appear compiling errors. However when I write:</p>

<pre><code>string plain=...; //string generated by OAuth specification;
</code></pre>

<p>Then there is no errors.</p>

<p>And what key length I need to specify? Because I will have keys of different lengths (with 48 and maybe 96 symbols).</p>
","<p>It appears there are a few things you need to get familiar with. (Sorry I can't help because I've never had to do it).</p>

<p>First is the Security Architecture. You can find some reading at <a href=""http://hueniverse.com/2008/10/beginners-guide-to-oauth-part-iii-security-architecture/"" rel=""nofollow"">Beginner's Guide to OAuth – Part III : Security Architecture</a>.</p>

<p>Second is the HMAC-SHA1 signature and format. You can find the overview at <a href=""http://oauth.net/core/1.0/#anchor16"" rel=""nofollow"">OAuth Core HMAC-SHA1</a>.</p>

<p>Third, you need to understand OAuth's encoding and presentation format. You can find some reading at <a href=""http://oauth.net/core/1.0/#encoding_parameters"" rel=""nofollow"">OAuth Core Parameter Encoding</a>.</p>

<hr>

<p>To answer some of your questions:</p>

<p>You will need to parse and decode the parameters to get the key, signed data, and signature. So you will need to parse and decode three values: <code>oauth_key</code>, <code>oauth_data</code> and <code>oauth_signature</code>.</p>

<p>Then, you will set up your Crypto++ HMAC <code>key</code> as follows.</p>

<pre><code>SecByteBlock key(SHA1::BLOCKSIZE);
memcpy(key.data(), key.size(), oauth_key);
</code></pre>

<p>After that, you would verify with the following:</p>

<pre><code>byte oauth_key[] = ...; // Your parsed and decoded key
string oauth_data = ...; // Your parsed and decoded data
string oauth_signature = ...; // // Your parsed and decoded signature

try
{
    SecByteBlock key(SHA1::BLOCKSIZE);
    memcpy(key.data(), key.size(), oauth_key);

    HMAC&lt; SHA1 &gt; hmac(key, key.size());
    const int flags = HashVerificationFilter::THROW_EXCEPTION | HashVerificationFilter::HASH_AT_END;

    StringSource ss(oauth_data + oauth_signature + mac, true, 
        new HashVerificationFilter(hmac, NULL, flags)
    ); // StringSource

    cout &lt;&lt; ""Verified message"" &lt;&lt; endl;
}
catch(const CryptoPP::Exception&amp; e)
{
    // Handle failure
    cerr &lt;&lt; e.what() &lt;&lt; endl;        
}
</code></pre>

<hr>

<p>Another thing Crypto++ might be able to help with is Base64 decoding. Below is from the <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow"">HexDecoder wiki page</a>, but it applies to <code>Base64Decoder</code> because the encoders and decoders use the same interface.</p>

<pre><code>string encoded = ...;
string decoded;

StringSource ss(encoded,
    new HexDecoder(
        new StringSink(decoded)
    ) // HexDecoder
); // StringSource
</code></pre>

<p>So your code would be:</p>

<pre><code>string encoded = ...;
string decoded;

StringSource ss(encoded,
    new Base64Decoder(
        new StringSink(decoded)
    ) // Base64Decoder
); // StringSource
</code></pre>

<p>The above uses Crypto++'s pipline interface, where data flows from a source to a sink. You can also do it in a more ""C"" like manner using <code>Put</code> and <code>Get</code> on the <code>Base64Decoder</code> object:</p>

<pre><code>string encoded = ...;
string decoded;

Base64Decoder decoder;

decoder.Put( (byte*)encoded.data(), encoded.size() );
decoder.MessageEnd();

word64 size = decoder.MaxRetrievable();
if(size &amp;&amp; size &lt;= SIZE_MAX)
{
    decoded.resize(size);       
    decoder.Get((byte*)decoded.data(), decoded.size());
}
</code></pre>
","2194","<c++><oauth><crypto++><hmacsha1>","4","4","2","2014-08-07 14:42:35","21084728","0","","608639","","2014-01-13 05:53:53","2013-10-10 16:18:01",""
"19301100","How use custom key in HMAC-SHA1 Crypto++ realisation","<p>I want to implement <code>OAuth 1.0</code> protocol in my C++ project. In order to create OAuth signature I need to implement <code>HMAC-SHA1</code> algorithm where <code>key</code> and <code>text</code> will be some string created according to OAuth specification.</p>

<p>I want to use Crypto++ library for implementing HMAC-SHA1. I found this HMAC-SHA1 example on wiki of project:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(16);
prng.GenerateBlock(key, key.size());

string plain = ""HMAC Test"";
string mac, encoded;

/*********************************\
\*********************************/

// Pretty print key
encoded.clear();
StringSource(key, key.size(), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
    HMAC&lt; SHA256 &gt; hmac(key, key.size());

    StringSource(plain, true, 
        new HashFilter(hmac,
            new StringSink(mac)
        ) // HashFilter      
    ); // StringSource
}
catch(const CryptoPP::Exception&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

// Pretty print
encoded.clear();
StringSource(mac, true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; ""hmac: "" &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>But I can't understand how instead of random generated string use my created <code>key</code>. I tried just create:</p>

<pre><code>string key=...; //string generated by OAuth specification;
</code></pre>

<p>But then appear compiling errors. However when I write:</p>

<pre><code>string plain=...; //string generated by OAuth specification;
</code></pre>

<p>Then there is no errors.</p>

<p>And what key length I need to specify? Because I will have keys of different lengths (with 48 and maybe 96 symbols).</p>
","<p>I was tasked with a very similar task. Do two-legged OAuth 1.0a in C++. Two-legged because there is no user involved in the process, only the client and the server. As described in: <a href=""http://oauth.googlecode.com/svn/spec/ext/consumer_request/1.0/drafts/2/spec.html"" rel=""nofollow"">http://oauth.googlecode.com/svn/spec/ext/consumer_request/1.0/drafts/2/spec.html</a></p>

<p>The complete proof of concept including parsing and decoding the parameters can be found at: <a href=""https://gist.github.com/duedal/a197fc9f6dc1ad59f08c"" rel=""nofollow"">https://gist.github.com/duedal/a197fc9f6dc1ad59f08c</a></p>

<p>Should be easy to build on this to complete it. Mainly need to validate the timestamp+nonce, and of course tie into your project.</p>
","2194","<c++><oauth><crypto++><hmacsha1>","4","0","2","2014-08-07 14:42:35","21084728","0","","608639","","2014-01-13 05:53:53","2013-10-10 16:18:01",""
"25728659","Installing Crypto++ 5.6.2 on Mac OS X","<p>I'm trying to installing Crypto++ 5.6.2 on my Mac. 
When I run </p>

<pre><code>make -j4 libcryptopp.a"" 
</code></pre>

<p>I get the following error:</p>

<pre><code>libtool: unrecognized option `-static'
libtool: Try `libtool --help' for more information.
make: *** [libcryptopp.a] Error 1
</code></pre>

<p>Can someone please help me with this?</p>
","<blockquote>
  <p>Can someone please help me with this?</p>
</blockquote>

<p>There's a couple of things you can do to make this easier.</p>

<p>First, open <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/GNUmakefile"" rel=""nofollow""><code>GNUmake</code></a> and add <code>fPIC</code> on line 1:</p>

<pre><code>CXXFLAGS = -DNDEBUG -g -O2 -fPIC
</code></pre>

<p>Second, open <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/GNUmakefile"" rel=""nofollow""><code>GNUmake</code></a> and drop <em>""version""</em> from the Clang detection logic on line 18:</p>

<pre><code>CLANG_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -i -c ""clang"")
</code></pre>

<p>Third, open <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/GNUmakefile"" rel=""nofollow""><code>GNUmake</code></a> and drop <em>GAS check</em> from around the Darwin flags around line 38. You want the Darwin check standing alone, without the <code>ifeq ($(GAS219_OR_LATER),0)</code> check.</p>

<pre><code>ifeq ($(UNAME),Darwin)
  CXXFLAGS += -arch x86_64 -arch i386
else
  CXXFLAGS += -march=native
endif
</code></pre>

<p>Fourth, open <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/GNUmakefile"" rel=""nofollow""><code>GNUmake</code></a> and add the following after the Darwin flags around line 45:</p>

<pre><code>ifneq ($(CLANG_COMPILER),0)
  CXXFLAGS += -Wno-tautological-compare -Wno-unused-value
endif
</code></pre>

<hr>

<p>With the makefile tweaked:</p>

<pre><code># Make the static lib, shared object, and test program
cd cryptopp
make static dynamic cryptest.exe
</code></pre>

<p>After make completes:</p>

<pre><code># Run the test program
cd cryptopp
./cryptest.exe v
</code></pre>

<p>After the validation suit completes successfully:</p>

<pre><code># Install into /usr/local
cd cryptopp
sudo make install PREFIX=/usr/local
</code></pre>

<hr>

<p>OS X can be a real bear. It can be a bear because it silently ignores <code>LD_PRELOAD</code> (it uses <code>DYLD_LIBRARY_PATH</code> instead, see <a href=""http://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dyld.1.html"" rel=""nofollow""><code>dyld(3)</code> man pages</a>); it silently drops <code>-Wl,rpath</code>; it silently drops <code>-Bstatic</code>; and it always links to a shared object if available. It will link to the dynamic lib even on iOS, where its forbidden!</p>

<p>On OS X, It would behoove you you fully specify the static archive, and not use <code>-l</code> and <code>-L</code>. That is, use the following (this is from one of my test programs I use on OS X):</p>

<pre><code>g++ -DDEBUG=1 -g3 -O0 -Wall -Wextra -Wno-unused-parameter \
    -I/usr/local/include/cryptopp \
    cryptopp-test.cpp -o cryptopp-test.exe \
    /usr/local/lib/libcryptopp.a
</code></pre>

<p>Its OK to fully specify <code>libcryptopp.a</code>. An archive is just a collection of object files, and you can specify object files for linking on the command line.</p>

<hr>

<p>Here's a Pastebin of the GNUmakefile I use: <a href=""http://pastebin.com/d7G6PcEX"" rel=""nofollow"">Crypto++ modified makefile for OS X and mobile</a>.</p>

<hr>

<p><strong>EDIT</strong> (June 2015): Crypto++ is migrating away from <a href=""https://sourceforge.net/projects/cryptopp/"" rel=""nofollow"">Sourceforge</a> to <a href=""https://github.com/weidai11/cryptopp"" rel=""nofollow"">GitHub</a>. Most of the changes discussed above have been Incorporated into the makefile.</p>
","2187","<crypto++><failed-installation>","1","2","1","2015-06-21 03:28:44","","2","","","","","2014-09-08 16:18:00",""
"23053763","Crash when trying to encrypt a file with Crypto++ RSA Scheme","<p>I have successfully used this some lines ago in my program:</p>

<pre><code>string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
</code></pre>

<p>So you know that the Crypto++ objects are well created and so.</p>

<p>Now I want to encrypt a whole binary file and save it to an adjacent file:</p>

<pre><code>FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>But this last line crashes with a debug error stating that <em>abort() has been called</em>.</p>

<p>Hunting down the error, I tried to change the second argument to the FileSource call to false, leading to the following code:</p>

<pre><code>FileSource(file.c_str(), false, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>And then the error gone, but the destination file weights 0 bytes, nothing was read/wrote.</p>

<p>I do not know what can can the key to the problem, so, I hope someone can help a little bit.</p>

<p>EDIT: I am using Visual Studio 2013 Pro.</p>

<p>EDIT2: I hunted the error further.</p>

<p>This works and the file binary content is correctly printed on screen:</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new StringSink(s));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>But this don't work and ends with the mentioned crash.</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new PK_EncryptorFilter(*rng, *encryptor, new StringSink (s)));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>This is so strange since the same PK_EncryptorFilter filter is used in another method without trouble, as I stated at the beginning of the post.</p>

<p>Anyway, I post here my entire class, so as to get a clear idea of what is going on:</p>

<pre><code>RSASystem::RSASystem()
{
    std::string pubkey = ""...OMITED..."";

    rng = new AutoSeededRandomPool;

    CryptoPP::HexDecoder decoder;
    decoder.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder.MessageEnd();

    CryptoPP::HexDecoder decoder2;
    decoder2.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder2.MessageEnd();

    verifier = new RSASSA_PKCS1v15_SHA_Verifier;
    encryptor = new RSAES_OAEP_SHA_Encryptor;

    verifier-&gt;AccessKey().Load(decoder);
    encryptor-&gt;AccessKey().Load(decoder2);
}

string RSASystem::encrypt(string msg)
{
    string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
}

void RSASystem::encryptFile(string file)
{
    FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
}
</code></pre>

<p>EDIT 3: After surrounding the code with try..catch() I got this error:</p>

<pre><code>RSA/OAEP-MGF1(SHA-1): message length of 490986 exceeds the maximum of 214 for this public key
</code></pre>

<p>Which now I think can be easily solved.</p>
","<pre><code>FileSource(file.c_str(), false,
    new PK_EncryptorFilter(*rng, *encryptor,
        new FileSink((file+"".xx"").c_str(), true)
    ),
true);
</code></pre>

<p>This does not look right. <strike><code>new FileSink((file+"".xx"").c_str()</code> returns a <code>char*</code>, and you need a pointer to a <code>Sink</code></strike>. Plus, there's an extra false in there I'm not used to seeing. Something like:</p>

<pre><code>FileSource fs1(filename, true,
    new PK_EncryptorFilter(rng, encryptor,
        new FileSink(filename, true)
   ) // PK_EncryptorFilter
); // StringSource
</code></pre>

<p>There's a couple of examples on the Crypto++ wiki. See <a href=""http://www.cryptopp.com/wiki/RSA_Cryptography"" rel=""nofollow"">RSA Cryptography</a> and <a href=""http://www.cryptopp.com/wiki/RSA_Encryption_Schemes"" rel=""nofollow"">RSA Encryption Schemes</a>.</p>

<p>The following is an example from the Crypto++ wiki using RSA. But you can use the code for any cryptosystem that adheres to <code>PK_Encryptor</code> and <code>PK_Decryptor</code> (<code>Sources</code> (like <code>StringSource</code> and <code>FileSource</code>) and <code>Sinks</code> (like <code>StringSink</code> and <code>FileSink</code>) are also interchangeable):</p>

<pre><code>////////////////////////////////////////////////
// Generate keys
AutoSeededRandomPool rng;

InvertibleRSAFunction params;
params.GenerateRandomWithKeySize( rng, 1536 );

RSA::PrivateKey privateKey( params );
RSA::PublicKey publicKey( params );

string plain=""RSA Encryption"", cipher, recovered;

////////////////////////////////////////////////
// Encryption
RSAES_OAEP_SHA_Encryptor e( publicKey );

StringSource ss1( plain, true,
    new PK_EncryptorFilter( rng, e,
        new StringSink( cipher )
    ) // PK_EncryptorFilter
 ); // StringSource

////////////////////////////////////////////////
// Decryption
RSAES_OAEP_SHA_Decryptor d( privateKey );

StringSource ss2( cipher, true,
    new PK_DecryptorFilter( rng, d,
        new StringSink( recovered )
    ) // PK_DecryptorFilter
 ); // StringSource

assert( plain == recovered );
</code></pre>

<hr>

<p>Also, don't use anonymous declarations. Some versions of GCC has problems with them. That is, use:</p>

<pre><code>StringSource ss1( plain, true,
    ...
</code></pre>

<p>rather than:</p>

<pre><code>StringSource( plain, true,
    ...
</code></pre>
","2179","<c++><encryption><crypto++>","3","3","3","2018-03-10 16:03:22","24271218","13","","2812008","","2014-06-17 18:51:59","2014-04-14 06:55:14",""
"23053763","Crash when trying to encrypt a file with Crypto++ RSA Scheme","<p>I have successfully used this some lines ago in my program:</p>

<pre><code>string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
</code></pre>

<p>So you know that the Crypto++ objects are well created and so.</p>

<p>Now I want to encrypt a whole binary file and save it to an adjacent file:</p>

<pre><code>FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>But this last line crashes with a debug error stating that <em>abort() has been called</em>.</p>

<p>Hunting down the error, I tried to change the second argument to the FileSource call to false, leading to the following code:</p>

<pre><code>FileSource(file.c_str(), false, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>And then the error gone, but the destination file weights 0 bytes, nothing was read/wrote.</p>

<p>I do not know what can can the key to the problem, so, I hope someone can help a little bit.</p>

<p>EDIT: I am using Visual Studio 2013 Pro.</p>

<p>EDIT2: I hunted the error further.</p>

<p>This works and the file binary content is correctly printed on screen:</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new StringSink(s));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>But this don't work and ends with the mentioned crash.</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new PK_EncryptorFilter(*rng, *encryptor, new StringSink (s)));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>This is so strange since the same PK_EncryptorFilter filter is used in another method without trouble, as I stated at the beginning of the post.</p>

<p>Anyway, I post here my entire class, so as to get a clear idea of what is going on:</p>

<pre><code>RSASystem::RSASystem()
{
    std::string pubkey = ""...OMITED..."";

    rng = new AutoSeededRandomPool;

    CryptoPP::HexDecoder decoder;
    decoder.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder.MessageEnd();

    CryptoPP::HexDecoder decoder2;
    decoder2.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder2.MessageEnd();

    verifier = new RSASSA_PKCS1v15_SHA_Verifier;
    encryptor = new RSAES_OAEP_SHA_Encryptor;

    verifier-&gt;AccessKey().Load(decoder);
    encryptor-&gt;AccessKey().Load(decoder2);
}

string RSASystem::encrypt(string msg)
{
    string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
}

void RSASystem::encryptFile(string file)
{
    FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
}
</code></pre>

<p>EDIT 3: After surrounding the code with try..catch() I got this error:</p>

<pre><code>RSA/OAEP-MGF1(SHA-1): message length of 490986 exceeds the maximum of 214 for this public key
</code></pre>

<p>Which now I think can be easily solved.</p>
","<p>OK, I think I know where you might be having problems. But I'd need to see <em>all</em> your code and not just the encryption.</p>

<p>I could coax a <code>BER Decode error</code> by <em>omitting</em> <code>encoder1.MessageEnd</code> and <code>encoder2.MessageEnd</code>. Apparently, I was able to read the key before it was fully written. I assume it was fully written after leaving <code>main</code> (and the destructors ran) because the file sizes looked OK with <code>ls</code>.</p>

<p>In the code below, the message was encrypted under <code>publicKey1</code> and then decrypted with <code>privateKey2</code> to ensure the keys were round-tripping.</p>

<pre><code>try {

    ////////////////////////////////////////////////
    // Generate keys
    AutoSeededRandomPool rng;

    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(rng, 1024);

    RSA::PrivateKey privateKey1(params);
    RSA::PublicKey publicKey1(privateKey1);

    ////////////////////////////////////////////////
    // Save/Load keys  
    HexEncoder encoder1(new FileSink(""private-key-der.txt"", true));
    HexEncoder encoder2(new FileSink(""public-key-der.txt"", true));

    privateKey1.Save(encoder1);
    publicKey1.Save(encoder2);

    // Must have these. Otherwise, the full key (hex encoded)
    //   is not written until destructors are run
    encoder1.MessageEnd();
    encoder2.MessageEnd();

    FileSource fs1(""private-key-der.txt"", true, new HexDecoder);
    FileSource fs2(""public-key-der.txt"", true, new HexDecoder);

    RSA::PrivateKey privateKey2;
    RSA::PublicKey publicKey2;

    privateKey2.Load(fs1);
    bool valid = privateKey2.Validate(rng, 3);
    if(!valid)
        throw Exception(Exception::OTHER_ERROR, ""Failed to validate key 1"");

    publicKey2.Load(fs2);
    valid = publicKey2.Validate(rng, 3);
    if(!valid)
        throw Exception(Exception::OTHER_ERROR, ""Failed to validate key 2"");

    ////////////////////////////////////////////////
    // Scratch
    string plain=""RSA Encryption"", cipher, recovered;

    ////////////////////////////////////////////////
    // Encryption
    RSAES_OAEP_SHA_Encryptor encryptor(publicKey1);

    StringSource ss1(plain, true,
                     new PK_EncryptorFilter(rng, encryptor,
                                            new StringSink(cipher)
                                            ) // PK_EncryptorFilter
                     ); // StringSource

    ////////////////////////////////////////////////
    // Decryption
    RSAES_OAEP_SHA_Decryptor decryptor(privateKey2);

    StringSource ss2(cipher, true,
                     new PK_DecryptorFilter(rng, decryptor,
                                            new StringSink(recovered)
                                            ) // PK_DecryptorFilter
                     ); // StringSource

    cout &lt;&lt; ""Recovered plain text: "" &lt;&lt; recovered &lt;&lt; endl;

} catch (const Exception&amp; ex) {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>
","2179","<c++><encryption><crypto++>","3","0","3","2018-03-10 16:03:22","24271218","13","","2812008","","2014-06-17 18:51:59","2014-04-14 06:55:14",""
"23053763","Crash when trying to encrypt a file with Crypto++ RSA Scheme","<p>I have successfully used this some lines ago in my program:</p>

<pre><code>string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
</code></pre>

<p>So you know that the Crypto++ objects are well created and so.</p>

<p>Now I want to encrypt a whole binary file and save it to an adjacent file:</p>

<pre><code>FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>But this last line crashes with a debug error stating that <em>abort() has been called</em>.</p>

<p>Hunting down the error, I tried to change the second argument to the FileSource call to false, leading to the following code:</p>

<pre><code>FileSource(file.c_str(), false, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
</code></pre>

<p>And then the error gone, but the destination file weights 0 bytes, nothing was read/wrote.</p>

<p>I do not know what can can the key to the problem, so, I hope someone can help a little bit.</p>

<p>EDIT: I am using Visual Studio 2013 Pro.</p>

<p>EDIT2: I hunted the error further.</p>

<p>This works and the file binary content is correctly printed on screen:</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new StringSink(s));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>But this don't work and ends with the mentioned crash.</p>

<pre><code>string s;
FileSource file2(""C:\\test.jpg"", true, new PK_EncryptorFilter(*rng, *encryptor, new StringSink (s)));
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>

<p>This is so strange since the same PK_EncryptorFilter filter is used in another method without trouble, as I stated at the beginning of the post.</p>

<p>Anyway, I post here my entire class, so as to get a clear idea of what is going on:</p>

<pre><code>RSASystem::RSASystem()
{
    std::string pubkey = ""...OMITED..."";

    rng = new AutoSeededRandomPool;

    CryptoPP::HexDecoder decoder;
    decoder.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder.MessageEnd();

    CryptoPP::HexDecoder decoder2;
    decoder2.Put((byte*)pubkey.c_str(), pubkey.size());
    decoder2.MessageEnd();

    verifier = new RSASSA_PKCS1v15_SHA_Verifier;
    encryptor = new RSAES_OAEP_SHA_Encryptor;

    verifier-&gt;AccessKey().Load(decoder);
    encryptor-&gt;AccessKey().Load(decoder2);
}

string RSASystem::encrypt(string msg)
{
    string tmp;
    StringSource(msg, true, new PK_EncryptorFilter(*rng, *encryptor, new CryptoPP::HexEncoder(new StringSink(tmp))));
    return tmp;
}

void RSASystem::encryptFile(string file)
{
    FileSource(file.c_str(), true, new PK_EncryptorFilter(*rng, *encryptor, new FileSink((file+"".xx"").c_str(), true)),true);
}
</code></pre>

<p>EDIT 3: After surrounding the code with try..catch() I got this error:</p>

<pre><code>RSA/OAEP-MGF1(SHA-1): message length of 490986 exceeds the maximum of 214 for this public key
</code></pre>

<p>Which now I think can be easily solved.</p>
","<p>I had already pending the encryption and security subject so I wasn't aware of the limitation on the length of the message of the RSA scheme.
<a href=""https://security.stackexchange.com/questions/44702/whats-the-limit-on-the-size-of-the-data-that-public-key-cryptos-can-handle"">https://security.stackexchange.com/questions/44702/whats-the-limit-on-the-size-of-the-data-that-public-key-cryptos-can-handle</a></p>

<p>So the solution passes by implementing an Integrated or Hybrid Encryption Scheme, like ECIES.</p>

<p>I've done this successfully with Crypto++ using: <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">http://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme</a></p>

<p>Thanks to <em>jww</em> to point to the correct decision.</p>
","2179","<c++><encryption><crypto++>","3","0","3","2018-03-10 16:03:22","24271218","13","","2812008","","2014-06-17 18:51:59","2014-04-14 06:55:14",""
"28043785","Undefined symbols for architecture x86_64 when building for ARM64","<p>I built the cryptopp lib to using for an ios application. but isn't working , only told me </p>

<blockquote>
  <p>""Undefined symbols for architecture x86_64:<br>
  ""CryptoPP::ProxyFilter::IsolatedFlush(bool, bool)"", referenced from: ""</p>
</blockquote>

<p>and on and on...</p>

<p>and I follow the Crypopp wiki page's guideline, but it still crashing.</p>

<p>how can I fix that? </p>

<blockquote>
  <p>ld: warning: ignoring file [path]/libcryptopp.a, missing required
  architecture x86_64 in file [path]/libcryptopp.a (4
  slices)CryptoPP::ProxyFilter::IsolatedFlush(bool, bool)"", referenced
  from: ... ... ... (118 things)</p>
</blockquote>

<hr>

<p>I tried to build with <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">github's prebuilt cryptopp</a> but it doesn't work, too. it occur errors like below:</p>

<blockquote>
  <p>Undefined symbols for architecture arm64:
   ""CryptoPP::BufferedTransformation::ChannelFlush(std::string const&amp;, bool, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::string const&amp;, bool) const"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::string const&amp;, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPut2(std::string const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::string const&amp;, unsigned long&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::string const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::string const&amp;, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::string const&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::StringSinkTemplate::StringSinkTemplate(std::string&amp;)"", referenced from:</p>

<pre><code> encryptString(std::string const&amp;) in MYCLASSBBB.o
 decryptString(std::string const&amp;, int) in MYCLASSBBB.o
 MYCLASSAAA::setDeviceId() in MYCLASSAAA.o
 MYCLASSAAA::getSignature() in MYCLASSAAA.o
</code></pre>
  
  <p>ld: symbol(s) not found for architecture arm64
  clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</blockquote>

<p>the MYCLASSAAA and MYCLASSBBB are all of classes what using cryptopp lib.</p>

<p>I'll try to build the lib myself, but I think it maybe same errors happen. what I suppose to do?</p>

<p>and project settings -- I didn't changed ""Compile Sources As"" to Objective-C++ at ""Apple LLVM 6.0 - language"", I just setted that to ""According to File Type"". it must be objective-c++? when I change to that, it occur too many errors in another sources. because it is legacy project of cocos2d-x(0.12.0 / c++ project)...</p>

<p>I hope your help. thanks.</p>
","<blockquote>
  <p>how can I fix that? </p>
</blockquote>

<p>Short answer: run  <code>. ./setenv-ios.sh x86_64</code> after downloading a new copy of the script. By default, <code>setenv-ios.sh</code> uses i386 for the simulator, and it did not support x86_64. The script now responds to x86_64, so fetch a new copy.</p>

<p>Based on @rmaddy's answer at <a href=""https://stackoverflow.com/q/28079224/608639"">Does Xcode 6 Simulator use x86_64?</a>, it appears Xcode 6/iOS 8 SDK uses x86_64 for the simulator under some circumstances.</p>

<p>A new version of <a href=""http://www.cryptopp.com/wiki/File:setenv-ios.sh.zip"" rel=""nofollow noreferrer""><code>setenv-ios.sh</code></a> was uploaded. It will respond to <code>. ./setenv-ios.sh x86_64</code> by selecting the <code>iPhoneSimulator.platform</code> SDK using <code>-arch x86_64</code> as a compiler option.</p>

<p>A new section covering this on the Crpyto++ wiki page for <a href=""http://www.cryptopp.com/wiki/IOS_%28Command_Line%29"" rel=""nofollow noreferrer"">iOS (Command Line)</a> was added. See the section <em>Simulators, ARM64 and x86_64</em>.</p>
","2143","<ios><ios-simulator><crypto++>","1","0","2","2015-02-04 08:31:43","28316780","6","1","3835380","","2015-02-03 03:21:26","2015-01-20 11:06:49",""
"28043785","Undefined symbols for architecture x86_64 when building for ARM64","<p>I built the cryptopp lib to using for an ios application. but isn't working , only told me </p>

<blockquote>
  <p>""Undefined symbols for architecture x86_64:<br>
  ""CryptoPP::ProxyFilter::IsolatedFlush(bool, bool)"", referenced from: ""</p>
</blockquote>

<p>and on and on...</p>

<p>and I follow the Crypopp wiki page's guideline, but it still crashing.</p>

<p>how can I fix that? </p>

<blockquote>
  <p>ld: warning: ignoring file [path]/libcryptopp.a, missing required
  architecture x86_64 in file [path]/libcryptopp.a (4
  slices)CryptoPP::ProxyFilter::IsolatedFlush(bool, bool)"", referenced
  from: ... ... ... (118 things)</p>
</blockquote>

<hr>

<p>I tried to build with <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">github's prebuilt cryptopp</a> but it doesn't work, too. it occur errors like below:</p>

<blockquote>
  <p>Undefined symbols for architecture arm64:
   ""CryptoPP::BufferedTransformation::ChannelFlush(std::string const&amp;, bool, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::string const&amp;, bool) const"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::string const&amp;, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPut2(std::string const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::string const&amp;, unsigned long&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::string const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::string const&amp;, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::string const&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::StringSinkTemplate::StringSinkTemplate(std::string&amp;)"", referenced from:</p>

<pre><code> encryptString(std::string const&amp;) in MYCLASSBBB.o
 decryptString(std::string const&amp;, int) in MYCLASSBBB.o
 MYCLASSAAA::setDeviceId() in MYCLASSAAA.o
 MYCLASSAAA::getSignature() in MYCLASSAAA.o
</code></pre>
  
  <p>ld: symbol(s) not found for architecture arm64
  clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</blockquote>

<p>the MYCLASSAAA and MYCLASSBBB are all of classes what using cryptopp lib.</p>

<p>I'll try to build the lib myself, but I think it maybe same errors happen. what I suppose to do?</p>

<p>and project settings -- I didn't changed ""Compile Sources As"" to Objective-C++ at ""Apple LLVM 6.0 - language"", I just setted that to ""According to File Type"". it must be objective-c++? when I change to that, it occur too many errors in another sources. because it is legacy project of cocos2d-x(0.12.0 / c++ project)...</p>

<p>I hope your help. thanks.</p>
","<p>I solved this--- in short, it have to build with -stdlib=libstdc++ flag(to CXXFLAGS in GNUMAKEFILE) when building libcryptopp.</p>

<p>because my project is legacy cocos2d-x project, that's standard library is setted to libstdc++.</p>

<p>more infomation is <a href=""https://stackoverflow.com/a/28315574/3835380"">here</a>. jeffrey answered me about this in great detail.</p>
","2143","<ios><ios-simulator><crypto++>","1","0","2","2015-02-04 08:31:43","28316780","6","1","3835380","","2015-02-03 03:21:26","2015-01-20 11:06:49",""
"4052594","Incorrect key size when porting Crypto++ AES encryption to PHP's mcrypt","<p>Earlier I managed to port some C++ CryptoPP Rijndael_128 CBC code to MCrypt PHP, but now I'm having problems with CFB mode. The C++ and PHP results do not match (well the first byte matches but this could be coincidence, everything else doesn't). With some diagnostics, it looks like PHP's mcrypt is not setting the key length correctly?</p>

<p>Here's the C++ (diagnostics and sundries removed for simplicity):</p>

<pre class=""lang-cxx prettyprint-override""><code>CFB_Mode&lt;AES&gt;::Encryption encryptor(g_encrypt_key, AES::DEFAULT_KEYLENGTH, g_encrypt_iv);

StringSource ss( sInput.c_str(), true, 
        new StreamTransformationFilter( encryptor, 
            new HexEncoder( new StringSink( sEncryptedOut ) )
        ));
</code></pre>

<p>And here's the PHP:</p>

<pre class=""lang-php prettyprint-override""><code>$cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CFB, '')
mcrypt_generic_init($cipher, $g_encrypt_key, $g_encrypt_iv);

$sEncryptedOutput = mcrypt_generic( $cipher, $sInput);
mcrypt_generic_deinit($cipher);
mcrypt_module_close($cipher);
</code></pre>

<p><code>g_encrypt_key</code> and <code>g_encrypt_iv</code> are both 16 bytes long, and the bytes match for the C++ and PHP versions. For the PHP version it is a binary string constructed from the bytes (yes I have checked these are identical).</p>

<p>I have added calls to the PHP version to check <code>$cipher</code>'s block size, key size, etc.
The block size and iv size are both 16; supported key sizes are reported as 16, 24, and 32 - all as expected.</p>

<p>Where I think the problem is, is that the keysize is being reported as 32 bytes. Looking at the mcrypt docs, the only way of setting the keysize is by supplying a key of the required size. But I'm passing a 16 byte key! So why is it reporting the presence of a 32 byte key? If CFB mode must use a 32 byte key, then why does CryptoPP accept it as okay? What is the solution? Can I force PHP to use the 16 byte key that has been provided? Or is there a parameter that I'm missing which is defaulting to a different setting in CryptoPP than in MCrypt?</p>

<p>I am using the CFB mode because I want to minimize the length of the resulting encrypted data. The few bytes that padding would introduce, do matter in this application.</p>

<p>I need to be able to encrypt/decrypt in C++ but only encrypt in PHP. AES is arguably overkill for my application - the minimum I need is ""a good scrambling of the bytes"" so that the function of individual bytes in the data are not obvious.</p>
","<p>It's been awhile, but I had some similar problems with mcrypt and openSSL using CFB a couple years ago. In the end, I discovered mcrypt used a different default feedback chain size than openssl in CFB mode.  That is to say, I believe an openSSL AES128 in CFB used a block size and feedback size of 128 bits, while mcrypt used a block size of 128bits and a feedback size of 8 bits.  I have no way to confirm this, it was just speculation at the time based on reading some old forum posts.  Regardless of the truth of that theory, I was not the only person or first to have this particular issue.</p>

<p>The solution for me was to use nOFB as yourself.  According to the <a href=""http://www.theserverpages.com/php/manual/en/ref.mcrypt.php"" rel=""nofollow"">PHP mcrypt library reference</a> <code>MCRYPT_MODE_NOFB</code> forces the feedback-chain to equal the algorithm's block size, in this case a 128bit block/feedback for AES128 (Rijndael), which matches with what the <a href=""http://man.cx/mcrypt"" rel=""nofollow"">manpage</a> for the mcrypt module states about nOFB.  This is good as everything I found said nOFB feedback is synchronous to the block size. Thus, both mcrypt and OpenSSL in nOFB were now 128 bit key/iv/block/feedback sizes for AES128 and everything worked fine.</p>

<p>As far as PHP reporting 256bit keysizes (32 bytes), the function that returns the current cipher-algorithm key size actually returns the maximum key size, which isn't clearly stated in the documentation.  I know this because my little class I use all the time now for various projects works perfectly fine with openSSL and any other AES libraries in CBC or nOFB .  This wouldn't be the case if mcrypt was padding my 128bit(16 char) key with an additional 128bits of null string, or whatever, and wouldn't be technically correct anyhow.</p>

<p>Not really a good answer, but the best I got based on a very amateurish foray into cryptography several years ago.</p>
","2137","<php><c++><aes><mcrypt><crypto++>","2","4","3","2016-11-08 04:51:47","4054017","2","","608639","","2016-11-08 04:46:59","2010-10-29 14:06:17",""
"4052594","Incorrect key size when porting Crypto++ AES encryption to PHP's mcrypt","<p>Earlier I managed to port some C++ CryptoPP Rijndael_128 CBC code to MCrypt PHP, but now I'm having problems with CFB mode. The C++ and PHP results do not match (well the first byte matches but this could be coincidence, everything else doesn't). With some diagnostics, it looks like PHP's mcrypt is not setting the key length correctly?</p>

<p>Here's the C++ (diagnostics and sundries removed for simplicity):</p>

<pre class=""lang-cxx prettyprint-override""><code>CFB_Mode&lt;AES&gt;::Encryption encryptor(g_encrypt_key, AES::DEFAULT_KEYLENGTH, g_encrypt_iv);

StringSource ss( sInput.c_str(), true, 
        new StreamTransformationFilter( encryptor, 
            new HexEncoder( new StringSink( sEncryptedOut ) )
        ));
</code></pre>

<p>And here's the PHP:</p>

<pre class=""lang-php prettyprint-override""><code>$cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CFB, '')
mcrypt_generic_init($cipher, $g_encrypt_key, $g_encrypt_iv);

$sEncryptedOutput = mcrypt_generic( $cipher, $sInput);
mcrypt_generic_deinit($cipher);
mcrypt_module_close($cipher);
</code></pre>

<p><code>g_encrypt_key</code> and <code>g_encrypt_iv</code> are both 16 bytes long, and the bytes match for the C++ and PHP versions. For the PHP version it is a binary string constructed from the bytes (yes I have checked these are identical).</p>

<p>I have added calls to the PHP version to check <code>$cipher</code>'s block size, key size, etc.
The block size and iv size are both 16; supported key sizes are reported as 16, 24, and 32 - all as expected.</p>

<p>Where I think the problem is, is that the keysize is being reported as 32 bytes. Looking at the mcrypt docs, the only way of setting the keysize is by supplying a key of the required size. But I'm passing a 16 byte key! So why is it reporting the presence of a 32 byte key? If CFB mode must use a 32 byte key, then why does CryptoPP accept it as okay? What is the solution? Can I force PHP to use the 16 byte key that has been provided? Or is there a parameter that I'm missing which is defaulting to a different setting in CryptoPP than in MCrypt?</p>

<p>I am using the CFB mode because I want to minimize the length of the resulting encrypted data. The few bytes that padding would introduce, do matter in this application.</p>

<p>I need to be able to encrypt/decrypt in C++ but only encrypt in PHP. AES is arguably overkill for my application - the minimum I need is ""a good scrambling of the bytes"" so that the function of individual bytes in the data are not obvious.</p>
","<p>Check out phpseclib:</p>

<p><a href=""http://phpseclib.sourceforge.net/"" rel=""nofollow"">http://phpseclib.sourceforge.net/</a></p>

<p>You can set the key size and block size to whatever you want.</p>

<p>eg. $aes->setKeyLength(128) or $aes->setKeyLength(256);</p>
","2137","<php><c++><aes><mcrypt><crypto++>","2","2","3","2016-11-08 04:51:47","4054017","2","","608639","","2016-11-08 04:46:59","2010-10-29 14:06:17",""
"4052594","Incorrect key size when porting Crypto++ AES encryption to PHP's mcrypt","<p>Earlier I managed to port some C++ CryptoPP Rijndael_128 CBC code to MCrypt PHP, but now I'm having problems with CFB mode. The C++ and PHP results do not match (well the first byte matches but this could be coincidence, everything else doesn't). With some diagnostics, it looks like PHP's mcrypt is not setting the key length correctly?</p>

<p>Here's the C++ (diagnostics and sundries removed for simplicity):</p>

<pre class=""lang-cxx prettyprint-override""><code>CFB_Mode&lt;AES&gt;::Encryption encryptor(g_encrypt_key, AES::DEFAULT_KEYLENGTH, g_encrypt_iv);

StringSource ss( sInput.c_str(), true, 
        new StreamTransformationFilter( encryptor, 
            new HexEncoder( new StringSink( sEncryptedOut ) )
        ));
</code></pre>

<p>And here's the PHP:</p>

<pre class=""lang-php prettyprint-override""><code>$cipher = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CFB, '')
mcrypt_generic_init($cipher, $g_encrypt_key, $g_encrypt_iv);

$sEncryptedOutput = mcrypt_generic( $cipher, $sInput);
mcrypt_generic_deinit($cipher);
mcrypt_module_close($cipher);
</code></pre>

<p><code>g_encrypt_key</code> and <code>g_encrypt_iv</code> are both 16 bytes long, and the bytes match for the C++ and PHP versions. For the PHP version it is a binary string constructed from the bytes (yes I have checked these are identical).</p>

<p>I have added calls to the PHP version to check <code>$cipher</code>'s block size, key size, etc.
The block size and iv size are both 16; supported key sizes are reported as 16, 24, and 32 - all as expected.</p>

<p>Where I think the problem is, is that the keysize is being reported as 32 bytes. Looking at the mcrypt docs, the only way of setting the keysize is by supplying a key of the required size. But I'm passing a 16 byte key! So why is it reporting the presence of a 32 byte key? If CFB mode must use a 32 byte key, then why does CryptoPP accept it as okay? What is the solution? Can I force PHP to use the 16 byte key that has been provided? Or is there a parameter that I'm missing which is defaulting to a different setting in CryptoPP than in MCrypt?</p>

<p>I am using the CFB mode because I want to minimize the length of the resulting encrypted data. The few bytes that padding would introduce, do matter in this application.</p>

<p>I need to be able to encrypt/decrypt in C++ but only encrypt in PHP. AES is arguably overkill for my application - the minimum I need is ""a good scrambling of the bytes"" so that the function of individual bytes in the data are not obvious.</p>
","<p>I had this problem - couple of points. By default the PHP Rijndael mode sets the feedback loop to 8bits - to be AES is needs to be the same length as the IV/Key.</p>

<p>You can do this by using the mode 'ncfb' instead of 'cfb' or MCRYPT_MODE_CFB.</p>

<p>Full details of writing aes_cfb_128 compatible PHP are at this Security Stackexchange question: <a href=""https://security.stackexchange.com/questions/30168/aes-cfb-128-decryption-encryption-problem-between-erlang-and-php/30169#30169"">aes cfb 128 decryption /encryption problem between Erlang and PHP</a>. The short of it is (from Tom Leek):</p>

<blockquote>
  <p>... for both CFB and OFB (which are distinct from each other and cannot be used interchangeably), you have to worry about the ""feedback length"" which is not necessarily documented with high clarity in various crypto libraries. Both encryption and decryption must use the same feedback length to interoperate.</p>
</blockquote>
","2137","<php><c++><aes><mcrypt><crypto++>","2","1","3","2016-11-08 04:51:47","4054017","2","","608639","","2016-11-08 04:46:59","2010-10-29 14:06:17",""
"8914264","Subset of Crypto++ library for mobile usage (iOS, Android)","<p>I need to use some RSA signature scheme for an cross platform library used in an Android and iPhone project. After looking around I've chosen cryptopp, but it is far too big for static linking. Thus I added source and headers to my project in order to only link the relevant parts into my lib. It's still adding a few MB in release build to the final lib.</p>

<ol>
<li><p>Is there an easier or more effective way of brining down the size of a library or cryptopp in particular?</p></li>
<li><p>I'm not in detail familiar with template generation during compiling. But I remember that templates can add quite a lot of code. Is there a way to stop/improve this (compiler options?)?</p></li>
<li><p>If I want to manually remove all source/header files from the project that are not used by my simple usecase, are there any tools to help? Digging through cryptopp with its templates would take quite some time and I'm always in favor of automatic processes ;)</p></li>
</ol>

<p>Any help is greatly appreciated!</p>
","<p>If you want to use crypto++ (and there are many good reasons you'd want to) this is probably a scenario where you're just best off letting the linkers do their job. I was concerned about this some time ago, and I could not do any better by hand than the optimizing linkers could.</p>

<p>I confirmed this by dusting off my old test app that uses crypto++ to generate a new random RSA key, sign a string and verify that string. Here are the numbers I see:</p>

<ul>
<li><p>libcryptopp.a - crypto++ built for release as a static library using clang++ against the iOS SDK 5.0. There was no special attmept to minimize size, just built with -fvisibility=hidden -fvisibility-inlines-hidden and -Os: <strong>22.5MB</strong></p></li>
<li><p>Empty app from the default iOS single view template, built with -Os: <strong>34KB</strong></p></li>
<li><p>The same empty app with ""self test"" code added that generates a keypair, signs (and therefore hashes) a string using RSA/SHA256, hex encodes it, prints the signature, decodes the signature and verifies the signature over the original string, built with -Os against the libcryptopp.a from my first bullet above: <strong>389KB</strong></p></li>
</ul>

<p>The linker seems to be doing a good job here. If you're seeing something drastically different, make sure you're really looking at release binaries.</p>
","2106","<c++><ios><android-ndk><crypto++>","3","4","2","2014-09-20 18:26:01","","0","4","608639","","2014-09-20 17:28:32","2012-01-18 17:10:02",""
"8914264","Subset of Crypto++ library for mobile usage (iOS, Android)","<p>I need to use some RSA signature scheme for an cross platform library used in an Android and iPhone project. After looking around I've chosen cryptopp, but it is far too big for static linking. Thus I added source and headers to my project in order to only link the relevant parts into my lib. It's still adding a few MB in release build to the final lib.</p>

<ol>
<li><p>Is there an easier or more effective way of brining down the size of a library or cryptopp in particular?</p></li>
<li><p>I'm not in detail familiar with template generation during compiling. But I remember that templates can add quite a lot of code. Is there a way to stop/improve this (compiler options?)?</p></li>
<li><p>If I want to manually remove all source/header files from the project that are not used by my simple usecase, are there any tools to help? Digging through cryptopp with its templates would take quite some time and I'm always in favor of automatic processes ;)</p></li>
</ol>

<p>Any help is greatly appreciated!</p>
","<blockquote>
  <p>RSA Signatures ... in an Android and iPhone project. After looking around I've chosen cryptopp...</p>
</blockquote>

<p>Related (from the Crypto++ wiki): <a href=""http://www.cryptopp.com/wiki/Android_%28Command_Line%29"" rel=""nofollow"">Android (Command Line)</a> and <a href=""http://www.cryptopp.com/wiki/iOS_%28Command_Line%29"" rel=""nofollow"">iOS (Command Line)</a>.</p>

<blockquote>
  <p>Is there an easier or more effective way of bringing down the size of a library or cryptopp in particular?</p>
</blockquote>

<p>No. The compiler and libtool on iOS have no way to tell what you may (or may not) need, so you get everything in the archive. Ditto for the GNU tools provided on Android.</p>

<blockquote>
  <p>I'm not in detail familiar with template generation during compiling. But I remember that templates can add quite a lot of code. Is there a way to stop/improve this (compiler options?)?</p>
</blockquote>

<p>No easy way. But you can go though the source code and pull out explicit template instantiations. You want to find objects instantiated with <code>CRYPTOPP_DLL_TEMPLATE_CLASS</code>. You can see how its defined in <a href=""https://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/config.h"" rel=""nofollow"">config.h</a>.</p>

<p>But I would not worry about it since you can get the linker to discard most (or all?) unused code from a static library.</p>

<blockquote>
  <p>If I want to manually remove all source/header files from the project that are not used by my simple use case, are there any tools to help?</p>
</blockquote>

<p>No, I'm not aware of any tools to do it (similar to Boost's <code>bcp</code>). I've tried this in the past, and gave up in frustration.</p>

<p>What you did not ask: how do you reduce the size of the final binary when linking to the static version of Crypto++. Here are the answers:</p>

<ul>
<li><p>Both</p>

<ul>
<li><p>Modify <code>GNUmakefile</code></p></li>
<li><p><code>CXXFLAGS += -Os</code></p></li>
<li><p><code>CXXFLAGS += -ffunction-sections -fdata-sections</code></p></li>
</ul></li>
<li><p>iOS</p>

<ul>
<li><p>Modify <code>GNUmakefile</code></p></li>
<li><p><code>CXXFLAGS += -gfull</code></p></li>
<li><p><code>LDFLAGS += -dead_strip</code></p></li>
</ul></li>
<li><p>Android</p>

<ul>
<li><p><code>CXXFLAGS += -Wl,--exclude-libs,ALL</code></p></li>
<li><p>run <code>arm-linux-androideabi-strip</code> with <code>--strip-debug</code>, <code>--strip-unneeded</code> or <code>--strip-all</code> on your final library or executable</p></li>
</ul></li>
</ul>

<p>Both techniques are covered in the Wiki pages. If you are working on Linux, there's another wiki page to cover size reduction and stripping at <a href=""http://www.cryptopp.com/wiki/Linux"" rel=""nofollow"">Crypto++ Linux</a>.</p>

<p>For more reading, see <a href=""https://developer.apple.com/library/mac/documentation/General/Conceptual/MOSXAppProgrammingGuide/Performance/Performance.html"" rel=""nofollow"">Tuning for Performance and Responsiveness</a> (for iOS), <a href=""https://groups.google.com/forum/#!msg/android-ndk/ZHFLHHXihXI/wHwYFK_6oA0J"" rel=""nofollow"">arm-eabi-strip and binary size</a>, and <a href=""http://gcc.gnu.org/ml/gcc-help/2003-08/msg00128.html"" rel=""nofollow"">Removing unused functions/dead code</a> (for Android and Linux).</p>
","2106","<c++><ios><android-ndk><crypto++>","3","0","2","2014-09-20 18:26:01","","0","4","608639","","2014-09-20 17:28:32","2012-01-18 17:10:02",""
"31002527","Undefined reference to CryptoPP::AlignedAllocate when linking","<p>I am getting the below errors compiling the cryptopp project in Windows.<br></p>

<pre><code>C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv[
__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv]+0x2e): undefined reference to `CryptoPP::AlignedAllocate(unsig
ned int)'
C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPv
j[__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvj]+0x28): undefined reference to `CryptoPP::AlignedDeallocate
(void*)'
collect2.exe: error: ld returned 1 exit status
</code></pre>

<p><br></p>

<p>Below is my compilation command :</p>

<pre><code>mingw32-g++.exe -o .\aestest2.exe .\aescbc.cpp   -I ""C:\cryptopp\Include"" -L ""C:\cryptopp\Lib"" -lcryptopp
</code></pre>

<p><br>
My libcryptopp.a is located at <code>C:\cryptopp\Lib</code><br>
I tried to find out where <code>AlignedDeallocate</code> is declared but I couldn't.</p>

<p>The part of the program that threw this error is below :</p>

<pre><code>try
    {
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        CBC_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeof(key), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter
        ); // StringSource

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }
</code></pre>

<p><br>
Suggestions appreciated !</p>
","<p><code>AlignedAllocate</code> is in <code>misc.h</code>:</p>

<pre class=""lang-none prettyprint-override""><code>$ grep -I AlignedAllocate *
misc.cpp:void * AlignedAllocate(size_t size)
misc.h:CRYPTOPP_DLL void * CRYPTOPP_API AlignedAllocate(size_t size);
secblock.h:                     return (pointer)AlignedAllocate(n*sizeof(T));
</code></pre>

<p>And:</p>

<pre class=""lang-none prettyprint-override""><code>$ grep -R AlignedDeallocate *
misc.cpp:void AlignedDeallocate(void *p)
misc.h:CRYPTOPP_DLL void CRYPTOPP_API AlignedDeallocate(void *p);
secblock.h:                     return AlignedDeallocate(p);
</code></pre>

<p>However, they are guarded with:</p>

<pre><code>#if CRYPTOPP_BOOL_ALIGN16_ENABLED
CRYPTOPP_DLL void * CRYPTOPP_API AlignedAllocate(size_t size);
CRYPTOPP_DLL void CRYPTOPP_API AlignedDeallocate(void *p);
#endif
</code></pre>

<p><code>CRYPTOPP_BOOL_ALIGN16_ENABLED</code> is set in <code>config.h</code>:</p>

<pre><code>#if CRYPTOPP_BOOL_SSE2_INTRINSICS_AVAILABLE || CRYPTOPP_BOOL_SSE2_ASM_AVAILABLE || defined(CRYPTOPP_X64_MASM_AVAILABLE)
    #define CRYPTOPP_BOOL_ALIGN16_ENABLED 1
#else
    #define CRYPTOPP_BOOL_ALIGN16_ENABLED 0
#endif
</code></pre>

<hr>

<p>You might consider adding the following to <code>config.h</code> after Crypto++ makes its choice internally:</p>

<pre><code>#undef CRYPTOPP_BOOL_ALIGN16_ENABLED
#define CRYPTOPP_BOOL_ALIGN16_ENABLED 1
</code></pre>

<p>Then, rebuild the library and your program.</p>

<hr>

<p>Something else that may be happening is: MinGW is building the library on a machine with MMX/SSE/SSE2 disabled. Or perhaps they are using <code>g++ -mno-sse -mno-sse2 ...</code>.</p>

<p>Then, you come a long with a shiny new Intel or AMD, and based on what g++ enables and the defines in <code>config.h</code>, your program expects <code>AlignedAllocate</code> and <code>AlignedDeallocate</code> because your configuration includes MMX/SSE/SSE2...</p>

<p>This situations is discussed at <a href=""https://cryptopp.com/wiki/Config.h#5.6.3_Recommendations"" rel=""nofollow"">config.h | Recommendations</a> on the Crypto++ wiki. Its why we tell distros to enable and disable things in <code>config.h</code>, rather than from the command line. Modifying <code>config.h</code> ensures the distro and user programs mostly use the same settings.</p>

<p>If this is the case, then you might try:</p>

<pre><code>export CXXFLAGS=""-DNDEBUG -g2 -O2 -mno-sse -mno-sse2""
mingw32-g++.exe $CXXFLAGS -o .\aestest2.exe .\aescbc.cpp \
  -I ""C:\cryptopp\Include"" -L ""C:\cryptopp\Lib"" -lcryptopp
</code></pre>

<p>There's a slew of defines that cascade based on MMX/SSE/SSE2; see <a href=""http://cryptopp.com/wiki/Config.h#Assembly_Defines"" rel=""nofollow"">config.h | Assembly Defines</a> on the wiki. Because MMX/SSE/SSE2 is disabled, you will get a software-only implementation of AES. It won't perform as well as it could.</p>
","2072","<c++><mingw><crypto++>","2","5","3","2016-04-17 12:06:15","","1","","608639","","2015-06-23 17:37:48","2015-06-23 12:14:07",""
"31002527","Undefined reference to CryptoPP::AlignedAllocate when linking","<p>I am getting the below errors compiling the cryptopp project in Windows.<br></p>

<pre><code>C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv[
__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv]+0x2e): undefined reference to `CryptoPP::AlignedAllocate(unsig
ned int)'
C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPv
j[__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvj]+0x28): undefined reference to `CryptoPP::AlignedDeallocate
(void*)'
collect2.exe: error: ld returned 1 exit status
</code></pre>

<p><br></p>

<p>Below is my compilation command :</p>

<pre><code>mingw32-g++.exe -o .\aestest2.exe .\aescbc.cpp   -I ""C:\cryptopp\Include"" -L ""C:\cryptopp\Lib"" -lcryptopp
</code></pre>

<p><br>
My libcryptopp.a is located at <code>C:\cryptopp\Lib</code><br>
I tried to find out where <code>AlignedDeallocate</code> is declared but I couldn't.</p>

<p>The part of the program that threw this error is below :</p>

<pre><code>try
    {
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        CBC_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeof(key), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter
        ); // StringSource

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }
</code></pre>

<p><br>
Suggestions appreciated !</p>
","<p><del>I've been experiencing the same thing with MSYS2's version of MinGW64</del></p>

<p><del>The solution was to add <code>-static</code> before <code>-lcryptopp</code>. Hope this works for you!</del></p>

<p><strong>Edit</strong>: nevermind my first answer, actually. MSYS2 might have a corrupted version of a shared lib in their repos, but I guess you compiled it yourself.</p>

<p>I'll instead provide a way how to compile Crypto++ with MinGW. You'll need Qt's qmake to generate a Makefile instead of using the one included.</p>

<p>First, open GNUMakefile and look for <code>TESTOBJS</code>, as of 5.6.2 it's <code>bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o</code>. You need to remove .cpps with the same names, so you don't build a bloated lib.</p>

<p>Then open cmd.exe (with <code>PATH</code> containing MinGW's /bin and a directory where your qmake.exe is), navigate to the directory containing the sources and use these:</p>

<pre><code>erase /f GNUmakefile
qmake -project
</code></pre>

<p>It'll create a file with the name of the current folder and extension "".pro"". Open it with a text editor, change</p>

<pre><code>TEMPLATE = app
TARGET = cryptopp562
INCLUDEPATH += .
</code></pre>

<p>to</p>

<pre><code>TEMPLATE = lib
TARGET = cryptopp
INCLUDEPATH += .
CONFIG -= qt
CONFIG += static
LIBS += -lws2_32
QMAKE_CXXFLAGS_RELEASE += -DNDEBUG
</code></pre>

<p>Replace every <code>OutputDebugString</code> with <code>OutputDebugStringA</code> in <strong>fipstest.cpp</strong>.</p>

<p>Now you can type <code>qmake</code> to generate a new Makefile and use <code>mingw32-make</code>. There'll be a ton of warnings, mostly about unused parameters. Nevertheless, nothing serious enough to cancel compilation. <code>libcryptopp.a</code> will be in <code>./release/</code>.</p>

<p>The example in the question compiles and works perfectly fine with a library compiled this way, tested with MinGW 4.9.2 bundled with Qt and with a standalone MingGW-w64 5.2.0.</p>

<p>The basic idea is taken from <a href=""http://www.babaei.net/blog/2013/02/15/how-to-build-cpp-cryptographic-library-cryptopp/#CryptoMinGW"" rel=""nofollow"">here</a>, I merely improved it.</p>
","2072","<c++><mingw><crypto++>","2","1","3","2016-04-17 12:06:15","","1","","608639","","2015-06-23 17:37:48","2015-06-23 12:14:07",""
"31002527","Undefined reference to CryptoPP::AlignedAllocate when linking","<p>I am getting the below errors compiling the cryptopp project in Windows.<br></p>

<pre><code>C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv[
__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEjPKv]+0x2e): undefined reference to `CryptoPP::AlignedAllocate(unsig
ned int)'
C:\Users\Sajith\AppData\Local\Temp\ccxq8O8x.o:aescbc.cpp:(.text$_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPv
j[__ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvj]+0x28): undefined reference to `CryptoPP::AlignedDeallocate
(void*)'
collect2.exe: error: ld returned 1 exit status
</code></pre>

<p><br></p>

<p>Below is my compilation command :</p>

<pre><code>mingw32-g++.exe -o .\aestest2.exe .\aescbc.cpp   -I ""C:\cryptopp\Include"" -L ""C:\cryptopp\Lib"" -lcryptopp
</code></pre>

<p><br>
My libcryptopp.a is located at <code>C:\cryptopp\Lib</code><br>
I tried to find out where <code>AlignedDeallocate</code> is declared but I couldn't.</p>

<p>The part of the program that threw this error is below :</p>

<pre><code>try
    {
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        CBC_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeof(key), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter
        ); // StringSource

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }
</code></pre>

<p><br>
Suggestions appreciated !</p>
","<p>if you use of <code>Crypto++</code> in your program, so attention :</p>

<p>this solution is for linux and if you doing bellow commands, your problem <strong>100 percentage</strong> will <strong>solved!!!</strong></p>

<p>if you want to linking your <code>.so</code> files and conclusively compiling your program , first you must install all <code>Crypto++</code> libraries from Synaptic tool in ubuntu or another distribution (debian base linux).</p>

<p>after that you most add <code>-lcryptopp</code> or/and <code>-lcrypto++</code> to your <code>.pro</code> file in qt creator like this :</p>

<pre><code>LIBS += -lcryptopp
LIBS += -lcrypto++
</code></pre>

<p>i had this problem , but my problem solved...</p>

<p>and my code haven't any mistakes</p>

<p>if you want, test that in window and add two top statements in your qt creator in windows.</p>
","2072","<c++><mingw><crypto++>","2","0","3","2016-04-17 12:06:15","","1","","608639","","2015-06-23 17:37:48","2015-06-23 12:14:07",""
"4648039","aes256 results differ in C# (Windows) and C++ (Ubuntu) implementation","<p>Here are the codes for aes256 with cbc and pkcs7 padding (and a password) encryption on C (Windows and C++ (Ubuntu using libcrypto++). The encryption result is not the same. Why?</p>

<p>C#:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;


public static class AESEncryption
{
    public static string Encrypt(byte[] PlainTextBytes, byte[] KeyBytes, string InitialVector)
        {
            try
            {
                byte[] InitialVectorBytes = Encoding.UTF8.GetBytes(InitialVector);
                RijndaelManaged SymmetricKey = new RijndaelManaged();
                SymmetricKey.Mode = CipherMode.CBC;
               // SymmetricKey.Padding = PaddingMode.PKCS7;
                ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(KeyBytes, InitialVectorBytes);
                MemoryStream MemStream = new MemoryStream();
                CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write);
                CryptoStream.Write(PlainTextBytes, 0, PlainTextBytes.Length);
                CryptoStream.FlushFinalBlock();
                byte[] CipherTextBytes = MemStream.ToArray();
                MemStream.Close();
                CryptoStream.Close();
                //return ByteToHexConversion(CipherTextBytes);

                return Convert.ToBase64String(CipherTextBytes);
            }
            catch (Exception a)
            {
                throw a;
            }
        }
    }
namespace aes
{ class Program
    {

        static void Main(string[] args)
        {

            string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""0000000000000000"");

            Console.WriteLine(FinalValue);

        }
}

}
</code></pre>

<p>C++:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;sstream&gt;
#include ""base64.h""

int main()
{


std::string result;
std::stringstream out;

    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);


    std::string keyy=""My Password"";// in char key[] My Password is written in bytes
    unsigned char key[] = {0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x4d,0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77,
                   0x6f, 0x72, 0x64};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) ==  16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""My Text"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len  = plain.length() + (plain.length() % 16) + 16;
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
         //std:: cout&lt;&lt; ""val: ""&lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]) &lt;&lt; std::endl;

        out&lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    result = out.str();
    std::cout &lt;&lt;""\n""&lt;&lt; result&lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);


    //
    std::cout&lt;&lt;""decript..\n"";


    return 0;
}
</code></pre>
","<p>your IV in c# is a string containing '0' and not '\0' and your IV in c++ does contain '\0' the ascii value of '0' and '\0' are different.</p>

<p>replace the following line</p>

<pre><code>string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""0000000000000000"");
</code></pre>

<p>with</p>

<pre><code>string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"");
</code></pre>

<p>that should do the trick I think.</p>

<p>20110111</p>

<p>try replacing <code>Encoding.ASCII.GetBytes(""My Password"")</code> with <code>new byte[]{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d,0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77,0x6f, 0x72, 0x64}</code>
in your c# code should yell different result</p>
","2023","<c#><.net><c++><aes><crypto++>","1","8","4","2016-09-01 11:43:00","","0","","89806","","2011-01-10 14:54:26","2011-01-10 14:50:11",""
"4648039","aes256 results differ in C# (Windows) and C++ (Ubuntu) implementation","<p>Here are the codes for aes256 with cbc and pkcs7 padding (and a password) encryption on C (Windows and C++ (Ubuntu using libcrypto++). The encryption result is not the same. Why?</p>

<p>C#:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;


public static class AESEncryption
{
    public static string Encrypt(byte[] PlainTextBytes, byte[] KeyBytes, string InitialVector)
        {
            try
            {
                byte[] InitialVectorBytes = Encoding.UTF8.GetBytes(InitialVector);
                RijndaelManaged SymmetricKey = new RijndaelManaged();
                SymmetricKey.Mode = CipherMode.CBC;
               // SymmetricKey.Padding = PaddingMode.PKCS7;
                ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(KeyBytes, InitialVectorBytes);
                MemoryStream MemStream = new MemoryStream();
                CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write);
                CryptoStream.Write(PlainTextBytes, 0, PlainTextBytes.Length);
                CryptoStream.FlushFinalBlock();
                byte[] CipherTextBytes = MemStream.ToArray();
                MemStream.Close();
                CryptoStream.Close();
                //return ByteToHexConversion(CipherTextBytes);

                return Convert.ToBase64String(CipherTextBytes);
            }
            catch (Exception a)
            {
                throw a;
            }
        }
    }
namespace aes
{ class Program
    {

        static void Main(string[] args)
        {

            string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""0000000000000000"");

            Console.WriteLine(FinalValue);

        }
}

}
</code></pre>

<p>C++:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;sstream&gt;
#include ""base64.h""

int main()
{


std::string result;
std::stringstream out;

    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);


    std::string keyy=""My Password"";// in char key[] My Password is written in bytes
    unsigned char key[] = {0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x4d,0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77,
                   0x6f, 0x72, 0x64};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) ==  16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""My Text"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len  = plain.length() + (plain.length() % 16) + 16;
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
         //std:: cout&lt;&lt; ""val: ""&lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]) &lt;&lt; std::endl;

        out&lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    result = out.str();
    std::cout &lt;&lt;""\n""&lt;&lt; result&lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);


    //
    std::cout&lt;&lt;""decript..\n"";


    return 0;
}
</code></pre>
","<p>Expanding on dvhh's answer:</p>

<p>You probably should not use a zero IV anyhow.  An IV can be useful to avoid identical plaintexts (or plaintexts with identical prefixes) from being recognizably identical to an attacker.  It's OK for the IV itself to be plaintext; so you could just randomly generate the IV and prepend it to the output to permit decryption.</p>

<p>To get a secure random IV in .NET, so something like:</p>

<pre><code>byte[] initialVectorBytes = new byte[16];
using(var rng = new RNGCryptoServiceProvider())
    rng.GetBytes(initialVectorBytes);
//...
using(var memStream = new MemoryStream()) {
    memStream.Write(IV,0,16); //to permit decryption later. 
    //...
}
</code></pre>

<p>BTW, the usual practice in C# is to use a lowercase letter at the start of a variable or parameter name - you'll make your code more readable to others if you follow suit.</p>
","2023","<c#><.net><c++><aes><crypto++>","1","3","4","2016-09-01 11:43:00","","0","","89806","","2011-01-10 14:54:26","2011-01-10 14:50:11",""
"4648039","aes256 results differ in C# (Windows) and C++ (Ubuntu) implementation","<p>Here are the codes for aes256 with cbc and pkcs7 padding (and a password) encryption on C (Windows and C++ (Ubuntu using libcrypto++). The encryption result is not the same. Why?</p>

<p>C#:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;


public static class AESEncryption
{
    public static string Encrypt(byte[] PlainTextBytes, byte[] KeyBytes, string InitialVector)
        {
            try
            {
                byte[] InitialVectorBytes = Encoding.UTF8.GetBytes(InitialVector);
                RijndaelManaged SymmetricKey = new RijndaelManaged();
                SymmetricKey.Mode = CipherMode.CBC;
               // SymmetricKey.Padding = PaddingMode.PKCS7;
                ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(KeyBytes, InitialVectorBytes);
                MemoryStream MemStream = new MemoryStream();
                CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write);
                CryptoStream.Write(PlainTextBytes, 0, PlainTextBytes.Length);
                CryptoStream.FlushFinalBlock();
                byte[] CipherTextBytes = MemStream.ToArray();
                MemStream.Close();
                CryptoStream.Close();
                //return ByteToHexConversion(CipherTextBytes);

                return Convert.ToBase64String(CipherTextBytes);
            }
            catch (Exception a)
            {
                throw a;
            }
        }
    }
namespace aes
{ class Program
    {

        static void Main(string[] args)
        {

            string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""0000000000000000"");

            Console.WriteLine(FinalValue);

        }
}

}
</code></pre>

<p>C++:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;sstream&gt;
#include ""base64.h""

int main()
{


std::string result;
std::stringstream out;

    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);


    std::string keyy=""My Password"";// in char key[] My Password is written in bytes
    unsigned char key[] = {0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x4d,0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77,
                   0x6f, 0x72, 0x64};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) ==  16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""My Text"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len  = plain.length() + (plain.length() % 16) + 16;
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
         //std:: cout&lt;&lt; ""val: ""&lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]) &lt;&lt; std::endl;

        out&lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    result = out.str();
    std::cout &lt;&lt;""\n""&lt;&lt; result&lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);


    //
    std::cout&lt;&lt;""decript..\n"";


    return 0;
}
</code></pre>
","<p>I came across this same issue when I was working on encryption between PHP and a .NET web service.</p>

<p>I created a sample project on github to show a working example of Rijndael encryption between PHP and NET.:
<a href=""https://github.com/dchymko/.NET--PHP-encryption"" rel=""nofollow"">https://github.com/dchymko/.NET--PHP-encryption</a></p>
","2023","<c#><.net><c++><aes><crypto++>","1","1","4","2016-09-01 11:43:00","","0","","89806","","2011-01-10 14:54:26","2011-01-10 14:50:11",""
"4648039","aes256 results differ in C# (Windows) and C++ (Ubuntu) implementation","<p>Here are the codes for aes256 with cbc and pkcs7 padding (and a password) encryption on C (Windows and C++ (Ubuntu using libcrypto++). The encryption result is not the same. Why?</p>

<p>C#:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;


public static class AESEncryption
{
    public static string Encrypt(byte[] PlainTextBytes, byte[] KeyBytes, string InitialVector)
        {
            try
            {
                byte[] InitialVectorBytes = Encoding.UTF8.GetBytes(InitialVector);
                RijndaelManaged SymmetricKey = new RijndaelManaged();
                SymmetricKey.Mode = CipherMode.CBC;
               // SymmetricKey.Padding = PaddingMode.PKCS7;
                ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(KeyBytes, InitialVectorBytes);
                MemoryStream MemStream = new MemoryStream();
                CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write);
                CryptoStream.Write(PlainTextBytes, 0, PlainTextBytes.Length);
                CryptoStream.FlushFinalBlock();
                byte[] CipherTextBytes = MemStream.ToArray();
                MemStream.Close();
                CryptoStream.Close();
                //return ByteToHexConversion(CipherTextBytes);

                return Convert.ToBase64String(CipherTextBytes);
            }
            catch (Exception a)
            {
                throw a;
            }
        }
    }
namespace aes
{ class Program
    {

        static void Main(string[] args)
        {

            string FinalValue = AESEncryption.Encrypt( Encoding.ASCII.GetBytes(""My Text""),  Encoding.ASCII.GetBytes(""My Password""), ""0000000000000000"");

            Console.WriteLine(FinalValue);

        }
}

}
</code></pre>

<p>C++:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;stdlib.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;sstream&gt;
#include ""base64.h""

int main()
{


std::string result;
std::stringstream out;

    // ctx holds the state of the encryption algorithm so that it doesn't
    // reset back to its initial state while encrypting more than 1 block.
    EVP_CIPHER_CTX ctx;
    EVP_CIPHER_CTX_init(&amp;ctx);


    std::string keyy=""My Password"";// in char key[] My Password is written in bytes
    unsigned char key[] = {0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x4d,0x79, 0x20, 0x50, 0x61, 0x73, 0x73, 0x77,
                   0x6f, 0x72, 0x64};
    unsigned char iv[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
   assert(sizeof(key) == 32);  // AES256 key size
    assert(sizeof(iv) ==  16);   // IV is always the AES block size

    // If data isn't a multiple of 16, the default behavior is to pad with
    // n bytes of value n, where n is the number of padding bytes required
    // to make data a multiple of the block size.  This is PKCS7 padding.
    // The output then will be a multiple of the block size.
    std::string plain(""My Text"");
    std::vector&lt;unsigned char&gt; encrypted;
    size_t max_output_len  = plain.length() + (plain.length() % 16) + 16;
    encrypted.resize(max_output_len);

    // Enc is 1 to encrypt, 0 to decrypt, or -1 (see documentation).
    EVP_CipherInit_ex(&amp;ctx, EVP_aes_256_cbc(), NULL, key, iv, 1);

    // EVP_CipherUpdate can encrypt all your data at once, or you can do
    // small chunks at a time.
    int actual_size = 0;
    EVP_CipherUpdate(&amp;ctx,
             &amp;encrypted[0], &amp;actual_size,
             reinterpret_cast&lt;unsigned char *&gt;(&amp;plain[0]), plain.size());

    // EVP_CipherFinal_ex is what applies the padding.  If your data is
    // a multiple of the block size, you'll get an extra AES block filled
    // with nothing but padding.
    int final_size;
    EVP_CipherFinal_ex(&amp;ctx, &amp;encrypted[actual_size], &amp;final_size);
    actual_size += final_size;

    encrypted.resize(actual_size);

    for( size_t index = 0; index &lt; encrypted.size(); ++index )
    {
        std::cout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt;
            static_cast&lt;unsigned int&gt;(encrypted[index]);
         //std:: cout&lt;&lt; ""val: ""&lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]) &lt;&lt; std::endl;

        out&lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; static_cast&lt;unsigned int&gt;(encrypted[index]);
    }
    result = out.str();
    std::cout &lt;&lt;""\n""&lt;&lt; result&lt;&lt; ""\n"";

    EVP_CIPHER_CTX_cleanup(&amp;ctx);


    //
    std::cout&lt;&lt;""decript..\n"";


    return 0;
}
</code></pre>
","<p>If you want to use IV as 16 bytes array of value 0x00, then change the C# code</p>

<pre><code>byte[] InitialVectorBytes = Encoding.UTF8.GetBytes(InitialVector);
</code></pre>

<p>to</p>

<pre><code>byte[] InitialVectorBytes = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
</code></pre>

<p>You can also change the function to ommit the 3rd parameter</p>
","2023","<c#><.net><c++><aes><crypto++>","1","0","4","2016-09-01 11:43:00","","0","","89806","","2011-01-10 14:54:26","2011-01-10 14:50:11",""
"16001214","Inplace AES CBC/ECB mode encrypting/decrypting using Crypto++","<p>Is it explicitly allowed to use the same buffer for plaintext/ciphertext when performing AES encryption/decryption in CBC and ECB modes using Crypto++ (assuming the buffer size is sufficient to accomodate the encrypted data) as in the following code:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cassert&gt;
#include ""cryptopp\rsa.h""
#include ""cryptopp\rijndael.h""
#include ""cryptopp\modes.h""
int main()
{
    using namespace CryptoPP;
    byte key[32], iv[Rijndael::BLOCKSIZE];
    char testdata[] = ""Crypto++ Test""; // any data can be here

    size_t buffer_size = (sizeof(testdata) + Rijndael::BLOCKSIZE) &amp; ~(Rijndael::BLOCKSIZE - 1);
    byte* buffer = new byte[buffer_size];
    memcpy(buffer, testdata, sizeof(testdata));

    // encrypt data inplace
    CBC_Mode&lt;Rijndael&gt;::Encryption enc(key, sizeof(key), iv);
    MeterFilter meter(new ArraySink(buffer, buffer_size));
    ArraySource(buffer, sizeof(testdata), true, new StreamTransformationFilter(enc, new Redirector(meter), BlockPaddingSchemeDef::PKCS_PADDING));
    assert(meter.GetTotalBytes() == buffer_size);

    // decrypt data inplace
    CBC_Mode&lt;Rijndael&gt;::Decryption dec(key, sizeof(key), iv);
    MeterFilter meter2(new ArraySink(buffer, buffer_size));
    ArraySource(buffer, buffer_size, true, new StreamTransformationFilter(dec, new Redirector(meter2), BlockPaddingSchemeDef::PKCS_PADDING));
    assert(meter2.GetTotalBytes() == sizeof(testdata));

    printf(""%s\n"", static_cast&lt;char*&gt;(buffer));
    delete buffer;
}
</code></pre>
","<p>In general, Crypto++ buffers can be the same or they can be distinct. I can't think of a situation where they are not allowed to be the same for in-place or in-situ processing of plain text or cipher text data. The only caveat is the buffer has to be larger enough for cipher text expansion.</p>

<p>You also have to be careful about overlap, but how you can get into trouble depends on the cipher. For example, <code>AES</code> in <code>CBC_Mode</code> operates on 16 byte blocks (the functions of interest are <code>ProcessBlock</code>, <code>ProcessXorBlock</code>, and friends). You can use an overlapped buffer as long as the difference between pointers is 17 bytes (or more). In the RSA case, you would likely need a difference of <code>MaxPreImage</code> size, which is based on the size of the modulus.</p>

<p>Finally, the old Crypto++ FAQ discusses it briefly as ""in-line processing"". See <a href=""http://www.cryptopp.com/fom-serve/cache/42.html"" rel=""nofollow"">How do I use a block cipher in Crypto++ 4.x?</a></p>
","2021","<c++><aes><crypto++>","3","0","1","2013-10-03 06:16:08","19152068","0","0","","","","2013-04-14 16:15:10",""
"30297727","Encryption and export license for an App Store or Google Play app","<p>My iOS app uses crypto++ as a static library for confidentiality.
Since this library is open-sourced, and thus visible to any would-be wrong-doers as it is, common sense implies that there should be no hassle.
However, based on Category 5, Part 2 of the U.S. Export Administration Regulations, my app does NOT seem to be exempt explicitly, but I cannot tell for sure as law tends to be a convoluted mess of exceptions and random hair-splitting, so I wish to ask those of you with actual experience with including an open-source encryption library in your apps (Android advice is OK, too):</p>

<p>Do I need to go through all that hassle of getting an EAR approval?</p>
","<blockquote>
  <p>My iOS app uses crypto++ as a static library for confidentiality...<br>
  However, based on Category 5, Part 2 of the U.S. Export Administration Regulations, my app does NOT seem to be exempt explicitly...</p>
</blockquote>

<p>Correct. Export regulations apply to encryption technologies.</p>

<p>There are some exemptions. For example, you don't need an export license if they key size is 63-bits or less because a <a href=""https://www.bis.doc.gov/index.php/forms-documents/doc_view/986-740"" rel=""noreferrer"">License Exemption is provided</a>. You are also allowed to build test systems and ship the test systems without a license. </p>

<p>If you fall into this category, you still have to self-classify. You just don't need a license. When you fill out paperwork, you write <strong><em>""NLR - No License Required""</em></strong>. But this probably isn't you...</p>

<p><em>If</em> you were using cryptography for authentication only (and not encryption), then you would not need an export license. Or if you are distributing your app to beta tests through <a href=""https://developer.apple.com/testflight/update/"" rel=""noreferrer"">TestFlight</a>, then you don't need an export license. However, Apple still requires the license because they do not take the time to differentiate between encryption and authentication; or beta testing versus release...</p>

<hr>

<blockquote>
  <p>Since this library is open-sourced, and thus visible to any would-be wrong-doers as it is, common sense implies that there should be no hassle...</p>
</blockquote>

<p>Your app has different requirements than the underlying crypto library it uses. What the underlying library is required to do and what you are required to do are two different things.</p>

<p>For example, OpenSSL and Crypto++ fall under EAR 734 and 740, and they only need to send a email to the BIS and Encryption Coordinator with a link to their website and source code. You have to do more...</p>

<hr>

<blockquote>
  <p>Do I need to go through all that hassle of getting an EAR approval?</p>
</blockquote>

<p>Yes. In the end, all you need to do is sign up for a SNAP-R account and self-classify. When you self-classify, you look up some codes, fill out some paperwork, assembly some additional documentation, and then submit it to BIS and the Encryption Coordinator.</p>

<p>After submission, the BIS waits for the Encryption Coordinator to object or reject the application. After 30 days of silence from the Encryption Coordinator, the BIS issues the license.</p>

<p>By the way, the Encryption Coordinator is the NSA. That's their Fort Meade mailing address.</p>

<hr>

<blockquote>
  <p>... I wish to ask those of you with actual experience with including an open-source encryption library in your apps</p>
</blockquote>

<p>I've shepherded 3 libraries and 1 app through the process. Of the libraries, one library was OpenSSL-based and one library was Crypto++-based. None of them were rejected.</p>

<hr>

<blockquote>
  <p>... I cannot tell for sure as law tends to be a convoluted mess of exceptions and random hair-splitting...</p>
</blockquote>

<p>Off-topic, but the ladies at the BIS are very good. You call the number and a real person answers. And they are <em>quite</em> knowledgeable. They are the ones who told me about the testing exemptions.</p>

<p>To speak with those knowledgeable ladies, here's the name of the office you are looking for: <strong><em>Office of Exporter Services, Encryption Division</em></strong>. Their phone number shows up on Google searches (its easy once you know the office name).</p>

<hr>

<p>Related, this is probably the information you seek: how to do it. Zetetic has a good set of instructions to do it at <a href=""https://www.zetetic.net/blog/2009/8/3/mass-market-encryption-ccats-commodity-classification-for-ip.html"" rel=""noreferrer"">Mass Market Encryption CCATS Commodity Classification for iPhone Applications in 8 Easy Steps</a>. Its what I used for my first one years ago.</p>

<hr>

<blockquote>
  <p>(comment) and if I want to publish an Android version of the same app on Google Play, can I reuse the license, or do I need to do it over?</p>
</blockquote>

<p>Yes. The license is issued for the application, not the play store.</p>

<hr>

<blockquote>
  <p>(comment) What about updates that do not touch crypto++, but expose an additional algorithm for the user to choose from in the UI, i.e. first I want to use only RSA for dig. signatures, but in the next version I want to add ECDSA as choice?</p>
</blockquote>

<p>I don't recall. Call the ladies at <strong><em>Office of Exporter Services, Encryption Division</em></strong>. They really are very helpful.</p>

<p>If you are adding or modifying core encryption routines (which is what this stuff covers), then you will likely need to update to the existing application or reclassify.</p>

<p>If you are just changing signing algorithms, then its just entity authentication and it likely will not require an update to the existing application or a reclassification.</p>

<p>I asked a similar question: its was about naming a product and (re)branding with no crpyto changes. In my case, renaming did not require a reclassification.</p>
","1985","<android><ios><appstore-approval><crypto++>","2","6","1","2015-05-20 20:46:31","30300033","2","1","608639","","2015-05-18 10:24:53","2015-05-18 07:48:40",""
"42134433","How to initialize AES-256 key with user defined password","<p>What if I want to encrypt data, using the Crypto++ library and having a user-defined password that is shorter than 32 Byte?</p>

<p>Right now I have the following code:</p>

<pre><code>byte passwordBytes[AES::MAX_KEYLENGTH];
byte ivBytes[AES::BLOCKSIZE];
std::string textToEncrypt(""encryptMe"");
std::string aesKey(""passwordFromUser"");
std::string ivText(""Iv16BytesOfText..."");

memset(passwordBytes, 0, sizeof(passwordBytes)); //fill with zeroes first
memcpy(passwordBytes, aesKey.data(), aesKey.size()); //fill with key data
memcpy(ivBytes, ivText.data(), CryptoPP::AES::BLOCKSIZE); //fill iv bytes

CTR_Mode&lt;AES&gt;::Encryption encryption;
encryption.SetKeyWithIV(passwordBytes, sizeof(passwordBytes), ivBytes);

StringSource encryptor(textToEncrypt, true,
    new StreamTransformationFilter(encryption,
            new StringSink(verschluesselterText)
        ,StreamTransformationFilter::NO_PADDING
    )
);
</code></pre>

<p>As you can see, <code>aesKey</code> is shorter than 32 Bytes.</p>

<p>To apply the full 32 Bytes to the encrypting function, I just fill out the unused space with zeroes, but that doesn't seem to be the best solution to me.</p>

<p>Am I missing something regarding creating an AES Key? With a user-defined password?</p>

<p>My second question, what if the user chooses a password that is longer then 32 Byte? In My case, the password would be truncated, which doesn't sound right to me.  </p>

<p>Thanks for your help! </p>
","<blockquote>
  <p>What if i want to encrypt data, using the Crypto++ library and having a user defined password that is shorter then 32 Byte?</p>
</blockquote>

<p>Use a key derivation function (KDF) to digest the password. The modern one is Krawczyk and Eronen's <a href=""https://www.cryptopp.com/docs/ref/class_h_k_d_f.html"" rel=""nofollow noreferrer"">HKDF</a> using the Extract-then-Expand model. The paper is located at <a href=""http://eprint.iacr.org/2010/264"" rel=""nofollow noreferrer"">Cryptographic Extraction and Key Derivation: The HKDF Scheme</a>.</p>

<p>You should consider using it for the IV, too. Rather than deriving 32 bytes (<code>AES::MAX_KEYLENGTH</code>), derive 48 bytes (<code>AES::MAX_KEYLENGTH+AES::BLOCKSIZE</code>) instead. The IV in your design can then be used for the <code>salt</code> parameter to the KDF.</p>

<p>Maybe something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""aes.h""
#include ""sha.h""
#include ""hkdf.h""
#include ""modes.h""
#include ""filters.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  SecByteBlock key(AES::MAX_KEYLENGTH+AES::BLOCKSIZE);
  string password(""passwordFromUser""), iv(""&lt;random value&gt;""), message(""encryptMe"");
  string encrypted, recovered;

  try
  {
    HKDF&lt;SHA256&gt; hkdf;
    hkdf.DeriveKey(key, key.size(), (const byte*)password.data(), password.size(), (const byte*)iv.data(), iv.size(), NULL, 0);

    ///////////////////////////////////////////////////////////////////////

    CTR_Mode&lt;AES&gt;::Encryption encryption;
    encryption.SetKeyWithIV(key, AES::MAX_KEYLENGTH, key+AES::MAX_KEYLENGTH);

    StringSource encryptor(message, true,
      new StreamTransformationFilter(encryption,
        new StringSink(encrypted))
    );

    ///////////////////////////////////////////////////////////////////////

    CTR_Mode&lt;AES&gt;::Decryption decryption;
    decryption.SetKeyWithIV(key, AES::MAX_KEYLENGTH, key+AES::MAX_KEYLENGTH);

    StringSource decryptor(encrypted, true,
      new StreamTransformationFilter(decryption,
        new StringSink(recovered))
    );

    cout &lt;&lt; ""Message: "" &lt;&lt; message &lt;&lt; endl;
    cout &lt;&lt; ""Recovered: "" &lt;&lt; recovered &lt;&lt; endl;
  }
  catch(const Exception&amp; ex)
  {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
    return 1;
  }

  return 0;
}
</code></pre>

<p>When using the encryption method above, you have to track the <code>{iv,message}</code> pair. The IV is needed to ensure uniqueness per-message since the password effectively fixes the AES key.</p>

<hr>

<blockquote>
  <p>What if the user chooses a password that is longer then 32 Byte? In My case, the password would by truncated, which doesn't sound right to me. </p>
</blockquote>

<p>A KDF handles it for you. It extracts the entropy regardless of how little or how much.</p>

<hr>

<pre><code>StringSource encryptor(textToEncrypt, true,
    new StreamTransformationFilter(encryption,
        new StringSink(verschluesselterText),
        StreamTransformationFilter::NO_PADDING
    )
</code></pre>

<p>There's no need to specify the padding mode. Also see the documentation for <a href=""http://www.cryptopp.com/docs/ref/struct_block_padding_scheme_def.html"" rel=""nofollow noreferrer"">BlockPaddingScheme</a>.</p>

<hr>

<p>You should be very careful with modes like CTR. CTR mode xor's the keystream with the plain text. If someone reuses their password on different messages, then its possible to recover the keystream which leads to plaintext recovery.</p>

<p><em>If</em> <code>ivText</code> is unique for each message, then you should add it to your KDF to ensure a unique keystream for each message. Add the IV as the <code>salt</code> parameter for HKDF. Here, <em>""unique""</em> means if I have a message <em>""Hello World""</em>, then the IV is different each time I encrypt the message.</p>

<p><em>If</em> the IV is truly just ""Iv16BytesOfText..."" (i.e., its fixed), then there's nothing unique about it. Just derive an additional 16 bytes from the user's password. Then, to avoid the keystream xor attack, switch to a mode like CBC.</p>

<p>Finally, you should probably use CCM, EAX or GCM mode. Right now, you only have confidentiality. Usually you want authenticity, too. To gain authenticity, you often select an <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> mode of operation.</p>
","1960","<c++><encryption><aes><crypto++>","2","4","1","2018-03-02 11:10:23","","1","1","4393935","","2018-03-02 11:10:23","2017-02-09 10:39:18",""
"13245385","Invalid block padding trying to decrypt 2-key triple DES","<p>I am trying to implement 2-key triple DES with crypto++ in C++.</p>

<p>My implementation is based upon the code in the crypto++ wiki located <a href=""http://www.cryptopp.com/wiki/TripleDES"" rel=""nofollow"">here</a>.</p>

<p>The code on the wiki builds properly; I can see that it is encrypting and decrypting correctly when I run the sample program.</p>

<p>For my implementation, I am trying to do the following:</p>

<ol>
<li><p>the user can run ""desimp.exe encrypt test.txt"". The program will encrypt test.txt and then output an encrypted file named test.txt.des . This seems to be working properly.</p></li>
<li><p>the user can run ""desimp.exe decrypt test.txt.des"" and the program will decrypt test.txt.des and output the decrypted text to a file ""decrypted.txt"" I can't get this to work. The error that I get is ""<strong>StreamTransformationFilter: invalid PKCS #7 block padding found</strong>""</p></li>
</ol>

<p>I believe I might need to save the data in the iv to a file at the time of encryption as well. Is this correct? I have tried doing this, and I think I'm able to get the iv saved to a file correctly - but I think in order to read in the iv to be used to for decryption, it needs to be read in as an array of 8 bytes. The file size of test.txt.iv when I attempt to save the iv is 21 bytes. If this is the right approach, I'm not sure how to proceed. If this is the wrong approach, I'd like to know what I need to do differently. Here is the code:</p>

<pre><code>#ifndef CRYPTOPP_DLL_ONLY
#define CRYPTOPP_DEFAULT_NO_DLL
#endif

#include ""dll.h""
#include ""rc6.h""
#include &lt;stdio.h&gt;  
#include &lt;string.h&gt;
#include &lt;fstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;streambuf&gt;

USING_NAMESPACE(CryptoPP)
USING_NAMESPACE(std)

#ifdef CRYPTOPP_IMPORTS
static PNew s_pNew = NULL;
static PDelete s_pDelete = NULL;
#endif
#ifdef CRYPTOPP_DLL_ONLY

int __cdecl main(int argc, char *argv[])
{

    AutoSeededRandomPool prng;
    SecByteBlock key(DES_EDE2::DEFAULT_KEYLENGTH);
    prng.GenerateBlock(key, key.size());
    byte iv[DES_EDE2::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
    string plain = ""CBC Mode Test"";
    string cipher, encoded, recovered;


    char *fileName = argv[1];
    char *runMode = argv[2];
    char *ivFile = argv[3];

    cout &lt;&lt; ""ARGUMENT 1: "" &lt;&lt; fileName &lt;&lt; endl;
    cout &lt;&lt; ""ARGUMENT 2: "" &lt;&lt; runMode &lt;&lt; endl;

    string fileNameString(fileName);
    string encryptedFileNameString = fileNameString + "".des"";//add .des to the filename of the encrypted file once it's generated
    string ivString = fileNameString + "".iv"";//iv file
    string runModeString(runMode);

    if (runModeString == ""encrypt"")
    {
        ifstream t(fileName);
        string str((std::istreambuf_iterator&lt;char&gt;(t)),
        istreambuf_iterator&lt;char&gt;());
        try
        {
            cout &lt;&lt; ""plain text: "" &lt;&lt; str &lt;&lt; endl;

            CBC_Mode&lt; DES_EDE2 &gt;::Encryption e;
            e.SetKeyWithIV(key, key.size(), iv);

            // The StreamTransformationFilter adds padding
            //  as required. ECB and CBC Mode must be padded
            //  to the block size of the cipher.
            StringSource ss1(str, true, 
                new StreamTransformationFilter(e,
                    new StringSink(cipher)
                ) // StreamTransformationFilter      
            ); // StringSource
        }
        catch(const CryptoPP::Exception&amp; e)
        {
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            exit(1);
        }
        // Pretty print
        StringSource ss2(cipher, true,
            new HexEncoder(
                new StringSink(encoded)
            ) // HexEncoder
        ); // StringSource

        cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;//""encoded"" is just the pretty print version of the ciphertext.
        ofstream fout(encryptedFileNameString); 
        fout &lt;&lt; cipher; 
        fout.close();//outputs/saves the encrypted file
        cout &lt;&lt; ""Encrypted file was saved to local path as "" &lt;&lt; encryptedFileNameString &lt;&lt; endl;

        ofstream fout2(ivString); 
        fout2 &lt;&lt; iv; 
        fout2.close();
        cout &lt;&lt; ""iv was saved to local path as "" &lt;&lt; ivString &lt;&lt; endl;
    }

    if (runModeString == ""decrypt"")// USER WANTS TO DECRYPT A FILE
        {           
            ifstream t2(fileName);
            string str2((istreambuf_iterator&lt;char&gt;(t2)),istreambuf_iterator&lt;char&gt;());
            cipher = str2;

        try
        {
            CBC_Mode&lt; DES_EDE2 &gt;::Decryption d;
            d.SetKeyWithIV(key, key.size(), iv);
            // The StreamTransformationFilter removes
            //  padding as required.
            StringSource ss3(cipher, true, 
                new StreamTransformationFilter(d,
                    new StringSink(recovered)
                ) // StreamTransformationFilter
            ); // StringSource

            cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
        }
        catch(const CryptoPP::Exception&amp; e)
            {
                cerr &lt;&lt; e.what() &lt;&lt; endl;
                exit(1);
            }
        }
        return 0;
    }//end main

    extern ""C"" __declspec(dllexport) void __cdecl SetNewAndDeleteFromCryptoPP(PNew pNew, PDelete pDelete, PSetNewHandler pSetNewHandler)
    {
        s_pNew = pNew;
        s_pDelete = pDelete;
    }

    void * __cdecl operator new (size_t size)
    {
        return s_pNew(size);
    }

    void __cdecl operator delete (void * p)
    {
        s_pDelete(p);
    }

    #endif
</code></pre>
","<p>I think you need to open your encrypted file with <code>std::ios_base::binary</code> in the mode (both for reading and writing); otherwise, the I/O library will mangle sequences which look like line-ends.</p>
","1947","<c++><encryption><des><crypto++>","1","1","1","2015-05-02 22:43:15","13246047","1","","608639","","2015-05-02 22:43:15","2012-11-06 06:11:18",""
"28756446","Steps to decrypt encrypted data in Crypto++ in libgcrypt","<p>I need to decrypt the encrypted data by Crypto++ in libgcrypt due to C language restriction on target platform. So I've decided to use libgcrypt since it supporting the AES128 and GCM mode.</p>

<p>In Crypto++, the data is encrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string encrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string ciphertext;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedEncryptionFilter(
                                encryptor,
                                new CryptoPP::StringSink(ciphertext)
                                )
                            );

    return ciphertext;
}
</code></pre>

<p>and successfully decrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string decrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string recovered;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedDecryptionFilter(
                                decryptor,
                                new CryptoPP::StringSink( recovered )
                                )
                            );

    return recovered;
}                       
</code></pre>

<p>But the decoded data is wrong when I try to decode <code>ciphertext</code> using libgcrypt by these steps:</p>

<ol>
<li><code>gcry_cipher_open()</code></li>
<li><code>gcry_cipher_setkey()</code></li>
<li><code>gcry_cipher_setiv()</code></li>
<li>Seperate the cipher text and authentication tag</li>
<li><code>gcry_cipher_decrypt(cipher text)</code></li>
<li><code>gcry_cipher_checktag(authentication tag)</code></li>
</ol>

<p>Is there any steps I missed to replicate the Crypto++ decoding process?</p>

<p>Gcrypt decryption code (Expected output <code>Decrypted cipher = password</code>):</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gcrypt.h&gt;

static unsigned char const aesSymKey[] = { 0x38, 0xb4, 0x8f, 0x1f, 0xcd, 0x63, 0xef, 0x32, 0xc5, 0xd1, 0x3f, 0x52, 0xbc, 0x4f, 0x5b, 0x24 };

static unsigned char const aesIV[] = { 0xE4, 0xEF, 0xC8, 0x08, 0xEB, 0xB8, 0x69, 0x95, 0xF3, 0x44, 0x6C, 0xE9, 0x15, 0xE4, 0x99, 0x7E };

static unsigned char const aesPass[] = { 0xda, 0x84, 0x3f, 0x01, 0xa0, 0x14, 0xfd, 0x85 };

static unsigned char const aesTag[] = { 0xdf, 0x5f, 0x9f, 0xe2, 0x9d, 0x7e, 0xc3, 0xdf, 0x7a, 0x1e, 0x59, 0xd8, 0xe6, 0x61, 0xf7, 0x7e };

#define GCRY_CIPHER GCRY_CIPHER_AES128
#define GCRY_MODE GCRY_CIPHER_MODE_GCM

int main(){
    gcry_error_t     gcryError;
    gcry_cipher_hd_t gcryCipherHd;

    if (!gcry_check_version(GCRYPT_VERSION))
     {
       fputs(""libgcrypt version mismatch\n"", stderr);
       exit(2);
     }

    gcry_control(GCRYCTL_DISABLE_SECMEM, 0);

    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

    if(!gcry_control(GCRYCTL_INITIALIZATION_FINISHED_P))
    {
        fputs(""libgcrypt has not been initialized\n"", stderr);
        abort();
    }

    size_t keyLength = gcry_cipher_get_algo_keylen(GCRY_CIPHER);
    size_t blkLength = gcry_cipher_get_algo_blklen(GCRY_CIPHER);

    char * outBuffer = malloc(blkLength);

    gcryError = gcry_cipher_open(
        &amp;gcryCipherHd, // gcry_cipher_hd_t *
        GCRY_CIPHER,   // int
        GCRY_MODE,     // int
        0);            // unsigned int
    if (gcryError)
    {
        printf(""gcry_cipher_open failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setkey(gcryCipherHd, aesSymKey, keyLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setkey failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setiv(gcryCipherHd, aesIV, blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setiv failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_decrypt(
        gcryCipherHd, // gcry_cipher_hd_t
        outBuffer,    // void *
        blkLength,    // size_t
        aesPass,      // const void *
        8);           // size_t
    if (gcryError)
    {
        printf(""gcry_cipher_decrypt failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_checktag(
        gcryCipherHd,
        aesTag,
        blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_checktag failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    printf(""Decrypted cipher = %s\n"", outBuffer);

    // clean up after ourselves
    gcry_cipher_close(gcryCipherHd);
    free(outBuffer);

    return 0;
}
</code></pre>

<p>EDIT: Just to be clear, the steps to decrypt I'm searching for is for the <code>ciphertext</code> output of the Crypto++ encryption function shown above; the <code>encrypt_data()</code>. So I won't accept any answer where it can't be applied to successfully decrypt <code>ciphertext</code>.</p>
","<p>Part 1 of 2 for the answer. This is the Crypto++ encryptor. It also prints the parameters it operates upon.</p>

<p>If you turn knobs on the <code>AE</code> or <code>AAD</code> preprocessor macro, then you will need to generate new parameters for the Gcrypt decryption routine.</p>

<pre class=""lang-c++ prettyprint-override""><code>// g++ -g3 -O1 -Wall -Wextra gcm-cryptopp-encrypt.cpp /usr/local/lib/libcryptopp.a -o gcm-cryptopp-encrypt.exe

#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;cryptopp/cryptlib.h&gt;
using CryptoPP::DEFAULT_CHANNEL;
using CryptoPP::AAD_CHANNEL;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::OS_GenerateRandomBlock;

#include &lt;cryptopp/aes.h&gt;
using CryptoPP::AES;

#include &lt;cryptopp/gcm.h&gt;
using CryptoPP::GCM;

#include &lt;cryptopp/secblock.h&gt;
using CryptoPP::SecByteBlock;

#include &lt;cryptopp/hex.h&gt;
using CryptoPP::HexEncoder;

#include &lt;cryptopp/filters.h&gt;
using CryptoPP::StringSink;
using CryptoPP::AuthenticatedEncryptionFilter;

#define UNUSED(x) ((void)x)

#define AE 1
#define AAD 1

int main(int argc, char* argv[])
{
    UNUSED(argc); UNUSED(argv);

    string hexPre = "" { 0x"", hexPost = "" };"";
    string plain = ""Now is the time for all good men to come to the aide of the country."";
    string aad = ""Attack at dawn!"";

    HexEncoder hex(NULL, true, 2, "",0x"");
    size_t res = 0;

    SecByteBlock key(AES::DEFAULT_KEYLENGTH), iv(AES::BLOCKSIZE);
    static const size_t TAG_SIZE = AES::BLOCKSIZE;

    // Generate random key and iv
    OS_GenerateRandomBlock(false, key, key.size());
    OS_GenerateRandomBlock(false, iv, iv.size());

    string s1(hexPre), s2(hexPre);

    hex.Detach(new StringSink(s1));
    hex.Put(key, key.size());
    hex.MessageEnd();
    s1 += hexPost;

    hex.Detach(new StringSink(s2));
    hex.Put(iv, iv.size());
    hex.MessageEnd();
    s2 += hexPost;

    cout &lt;&lt; ""const byte key[] = "" &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; ""const byte iv[] = "" &lt;&lt; s2 &lt;&lt; endl;

    /////////////////////////////////////////

    string s3(hexPre), s4(hexPre);

#if defined(AE)
    hex.Detach(new StringSink(s3));
    hex.Put(reinterpret_cast&lt;const byte*&gt;(plain.data()), plain.size() + 1 /*NULL*/);
    hex.MessageEnd();
    s3 += hexPost;

    cout &lt;&lt; ""const byte plain[] = "" &lt;&lt; s3 &lt;&lt; endl;
#endif

#if defined(AAD)
    hex.Detach(new StringSink(s4));
    hex.Put(reinterpret_cast&lt;const byte*&gt;(aad.data()), aad.size() + 1 /*NULL*/);
    hex.MessageEnd();
    s4 += hexPost;

    cout &lt;&lt; ""const byte aad[] = "" &lt;&lt; s4 &lt;&lt; endl;
#endif    

    /////////////////////////////////////////

    GCM&lt;AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

    AuthenticatedEncryptionFilter filter(encryptor);

#if defined(AAD)
    filter.ChannelPut(AAD_CHANNEL, reinterpret_cast&lt;const byte*&gt;(aad.data()), aad.size() + 1 /*NULL*/);
#endif

#if defined(AE)
    filter.ChannelPut(DEFAULT_CHANNEL, reinterpret_cast&lt;const byte*&gt;(plain.data()), plain.size() + 1 /*NULL*/);
#endif

    filter.MessageEnd();

    res= filter.MaxRetrievable();
    SecByteBlock cipher(res - TAG_SIZE), tag(TAG_SIZE);

#if defined(AE)
    res = filter.Get(cipher, cipher.size());
    cipher.resize(res);
#endif

    res = filter.Get(tag, tag.size());
    tag.resize(res);

    /////////////////////////////////////////

    string s5(hexPre), s6(hexPre);

    hex.Detach(new StringSink(s5));
    hex.Put(cipher.data(), cipher.size());
    hex.MessageEnd();
    s5 += hexPost;

    hex.Detach(new StringSink(s6));
    hex.Put(tag.data(), tag.size());
    hex.MessageEnd();
    s6 += hexPost;

#if defined(AE)
    cout &lt;&lt; ""const byte cipher[] = "" &lt;&lt; s5 &lt;&lt; endl;
#endif

    cout &lt;&lt; ""const byte tag[] = "" &lt;&lt; s6 &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Its output will be similar to:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./gcm-cryptopp-encrypt.exe
const byte key[] =  { 0xD1,0xB8,0xDC,0xB8,0xF9,0x83,0x8E,0xB8,0xE5,0x0B,0x48,0xB2,0xF5,0x1A,0x71,0x46 };
const byte iv[] =  { 0x05,0x2E,0xAF,0x03,0x23,0xFE,0xFD,0x5C,0xF5,0x90,0x7B,0xDD,0x09,0xBF,0x0A,0x71 };
const byte plain[] =  { 0x4E,0x6F,0x77,0x20,0x69,0x73,0x20,0x74,0x68,0x65,0x20,0x74,0x69,0x6D,0x65,0x20,0x66,0x6F,0x72,0x20,0x61,0x6C,0x6C,0x20,0x67,0x6F,0x6F,0x64,0x20,0x6D,0x65,0x6E,0x20,0x74,0x6F,0x20,0x63,0x6F,0x6D,0x65,0x20,0x74,0x6F,0x20,0x74,0x68,0x65,0x20,0x61,0x69,0x64,0x65,0x20,0x6F,0x66,0x20,0x74,0x68,0x65,0x20,0x63,0x6F,0x75,0x6E,0x74,0x72,0x79,0x2E,0x00 };
const byte aad[] =  { 0x41,0x74,0x74,0x61,0x63,0x6B,0x20,0x61,0x74,0x20,0x64,0x61,0x77,0x6E,0x21,0x00 };
const byte cipher[] =  { 0xD0,0x6D,0x69,0x0F,0x6A,0xDE,0x61,0x81,0x42,0x5A,0xA1,0xF8,0x29,0xFE,0x70,0xCC,0xCC,0x63,0xE4,0xFE,0x8C,0x32,0x58,0xFE,0xB8,0xC1,0x0F,0x38,0xBC,0x3F,0x27,0x2F,0x51,0xC3,0xB4,0x38,0x19,0x8E,0x24,0x97,0x54,0xCA,0xE6,0xA4,0xE6,0x22,0xDA,0x85,0x02,0x17,0xFE,0x76,0x89,0x55,0x85,0xEC,0x94,0x1D,0xD8,0xB4,0x0B,0x79,0x4A,0xE1,0xD6,0x5A,0x6A,0xA4,0x9A };
const byte tag[] =  { 0xA8,0x11,0x3D,0x86,0xE8,0xCA,0x2F,0xAF,0xED,0x09,0x90,0x44,0xCD,0x48,0xC1,0x06 };
</code></pre>
","1895","<c++><crypto++><libgcrypt>","2","0","3","2015-03-09 06:54:14","28936571","5","","1305907","","2015-03-05 01:40:37","2015-02-27 02:19:21",""
"28756446","Steps to decrypt encrypted data in Crypto++ in libgcrypt","<p>I need to decrypt the encrypted data by Crypto++ in libgcrypt due to C language restriction on target platform. So I've decided to use libgcrypt since it supporting the AES128 and GCM mode.</p>

<p>In Crypto++, the data is encrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string encrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string ciphertext;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedEncryptionFilter(
                                encryptor,
                                new CryptoPP::StringSink(ciphertext)
                                )
                            );

    return ciphertext;
}
</code></pre>

<p>and successfully decrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string decrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string recovered;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedDecryptionFilter(
                                decryptor,
                                new CryptoPP::StringSink( recovered )
                                )
                            );

    return recovered;
}                       
</code></pre>

<p>But the decoded data is wrong when I try to decode <code>ciphertext</code> using libgcrypt by these steps:</p>

<ol>
<li><code>gcry_cipher_open()</code></li>
<li><code>gcry_cipher_setkey()</code></li>
<li><code>gcry_cipher_setiv()</code></li>
<li>Seperate the cipher text and authentication tag</li>
<li><code>gcry_cipher_decrypt(cipher text)</code></li>
<li><code>gcry_cipher_checktag(authentication tag)</code></li>
</ol>

<p>Is there any steps I missed to replicate the Crypto++ decoding process?</p>

<p>Gcrypt decryption code (Expected output <code>Decrypted cipher = password</code>):</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gcrypt.h&gt;

static unsigned char const aesSymKey[] = { 0x38, 0xb4, 0x8f, 0x1f, 0xcd, 0x63, 0xef, 0x32, 0xc5, 0xd1, 0x3f, 0x52, 0xbc, 0x4f, 0x5b, 0x24 };

static unsigned char const aesIV[] = { 0xE4, 0xEF, 0xC8, 0x08, 0xEB, 0xB8, 0x69, 0x95, 0xF3, 0x44, 0x6C, 0xE9, 0x15, 0xE4, 0x99, 0x7E };

static unsigned char const aesPass[] = { 0xda, 0x84, 0x3f, 0x01, 0xa0, 0x14, 0xfd, 0x85 };

static unsigned char const aesTag[] = { 0xdf, 0x5f, 0x9f, 0xe2, 0x9d, 0x7e, 0xc3, 0xdf, 0x7a, 0x1e, 0x59, 0xd8, 0xe6, 0x61, 0xf7, 0x7e };

#define GCRY_CIPHER GCRY_CIPHER_AES128
#define GCRY_MODE GCRY_CIPHER_MODE_GCM

int main(){
    gcry_error_t     gcryError;
    gcry_cipher_hd_t gcryCipherHd;

    if (!gcry_check_version(GCRYPT_VERSION))
     {
       fputs(""libgcrypt version mismatch\n"", stderr);
       exit(2);
     }

    gcry_control(GCRYCTL_DISABLE_SECMEM, 0);

    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

    if(!gcry_control(GCRYCTL_INITIALIZATION_FINISHED_P))
    {
        fputs(""libgcrypt has not been initialized\n"", stderr);
        abort();
    }

    size_t keyLength = gcry_cipher_get_algo_keylen(GCRY_CIPHER);
    size_t blkLength = gcry_cipher_get_algo_blklen(GCRY_CIPHER);

    char * outBuffer = malloc(blkLength);

    gcryError = gcry_cipher_open(
        &amp;gcryCipherHd, // gcry_cipher_hd_t *
        GCRY_CIPHER,   // int
        GCRY_MODE,     // int
        0);            // unsigned int
    if (gcryError)
    {
        printf(""gcry_cipher_open failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setkey(gcryCipherHd, aesSymKey, keyLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setkey failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setiv(gcryCipherHd, aesIV, blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setiv failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_decrypt(
        gcryCipherHd, // gcry_cipher_hd_t
        outBuffer,    // void *
        blkLength,    // size_t
        aesPass,      // const void *
        8);           // size_t
    if (gcryError)
    {
        printf(""gcry_cipher_decrypt failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_checktag(
        gcryCipherHd,
        aesTag,
        blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_checktag failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    printf(""Decrypted cipher = %s\n"", outBuffer);

    // clean up after ourselves
    gcry_cipher_close(gcryCipherHd);
    free(outBuffer);

    return 0;
}
</code></pre>

<p>EDIT: Just to be clear, the steps to decrypt I'm searching for is for the <code>ciphertext</code> output of the Crypto++ encryption function shown above; the <code>encrypt_data()</code>. So I won't accept any answer where it can't be applied to successfully decrypt <code>ciphertext</code>.</p>
","<p>Part 2 of 2 for the answer. This is the Gcrpyt decryptor. It consumes the parameters from Part 1.</p>

<p>In the code below, the call to <code>gcry_cipher_decrypt</code> gets the decrypted text. But I don't know how to get the size of the decrypted text from the library. It does not matter for GCM mode, but it will matter for other modes, like CBC. See this Stack Overflow question: <a href=""https://stackoverflow.com/q/28845263"">Determine size of decrypted data from gcry_cipher_decrypt?</a>.</p>

<p>The <code>ROUNDUP</code> is for rounding up to a multiple of the cipher's block size. I read it was a requirement for the decryption buffer at <a href=""https://www.gnupg.org/documentation/manuals/gcrypt/Working-with-cipher-handles.html"" rel=""nofollow noreferrer"">Working with Ciphers</a>, but it may not apply here. I left it in place because ""things worked"", but you should knob turn on it further if it bothers you.</p>

<p>If you turn knobs on the <code>AE</code> or <code>AAD</code> preprocessor macro, then you will need to generate new parameters with the Crypto++ encryption routine.</p>

<pre class=""lang-c prettyprint-override""><code>/* gcc -g3 -O1 -Wall -Wextra -std=c99 gcm-gcrypt-decrypt.c /usr/local/lib/libgcrypt.a /usr/local/lib/libgpg-error.a -o gcm-gcrypt-decrypt.exe */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;gcrypt.h&gt;

typedef unsigned char byte;

/* All of this was generated in Crypto++ */
const byte key[] =  { 0x73,0x12,0xBB,0xDB,0x86,0x73,0x65,0xF7,0x68,0x7D,0xE9,0x2B,0xF8,0xEE,0x66,0xF1 };
const byte iv[] =  { 0x8C,0x70,0x54,0x17,0xD6,0xD9,0x7B,0x18,0x39,0xDC,0x5B,0xBC,0x21,0xDF,0x30,0x74 };
const byte plain[] =  { 0x4E,0x6F,0x77,0x20,0x69,0x73,0x20,0x74,0x68,0x65,0x20,0x74,0x69,0x6D,0x65,0x20,0x66,0x6F,0x72,0x20,0x61,0x6C,0x6C,0x20,0x67,0x6F,0x6F,0x64,0x20,0x6D,0x65,0x6E,0x20,0x74,0x6F,0x20,0x63,0x6F,0x6D,0x65,0x20,0x74,0x6F,0x20,0x74,0x68,0x65,0x20,0x61,0x69,0x64,0x65,0x20,0x6F,0x66,0x20,0x74,0x68,0x65,0x20,0x63,0x6F,0x75,0x6E,0x74,0x72,0x79,0x2E,0x00 };
const byte aad[] =  { 0x41,0x74,0x74,0x61,0x63,0x6B,0x20,0x61,0x74,0x20,0x64,0x61,0x77,0x6E,0x21,0x00 };
const byte cipher[] =  { 0xE8,0x0E,0xEA,0x10,0x32,0x26,0x7D,0xD1,0x75,0xF3,0x33,0x0F,0x30,0xBB,0x36,0xFB,0x3F,0x95,0x24,0x31,0x90,0xD2,0x2C,0xB1,0x34,0x5B,0x69,0x42,0x1E,0x98,0xC4,0x65,0x3B,0x06,0x5D,0x45,0xB6,0xC7,0x7E,0x26,0x7E,0xBC,0xFF,0xB7,0x7F,0xF4,0x11,0xF8,0xF3,0x8B,0x19,0x08,0xE6,0xAE,0x36,0x44,0xEF,0x3F,0xA6,0xC3,0xAE,0x34,0x08,0xB9,0x33,0xD3,0x33,0x63,0x46 };
const byte tag[] =  { 0x00,0xAE,0xDC,0x12,0x55,0xF8,0x87,0xB5,0x10,0x75,0x20,0xB5,0x94,0xCA,0x91,0xDF };

#define COUNTOF(x) ( sizeof(x) / sizeof(x[0]) )
#define ROUNDUP(x, b) ( (x) ? (((x) + (b - 1)) / b) * b : b)
byte recovered[ ROUNDUP(COUNTOF(cipher), 16) ];

#define GCRY_CIPHER GCRY_CIPHER_AES128
#define GCRY_MODE GCRY_CIPHER_MODE_GCM

#define AE 1
#define AAD 1

int main(){
    gcry_error_t     err;
    gcry_cipher_hd_t handle;
    memset(recovered, 0x00, COUNTOF(recovered));

    fprintf(stdout, ""Plaintext size: %d\n"", (int)COUNTOF(plain));
    fprintf(stdout, ""Ciphertext size: %d\n"", (int)COUNTOF(cipher));
    fprintf(stdout, ""Recovered size: %d\n"", (int)COUNTOF(recovered));

    assert(COUNTOF(key) == gcry_cipher_get_algo_keylen(GCRY_CIPHER));
    assert(COUNTOF(iv) == gcry_cipher_get_algo_blklen(GCRY_CIPHER));
    assert(COUNTOF(recovered) % gcry_cipher_get_algo_blklen(GCRY_CIPHER) == 0);

    if (!gcry_check_version(GCRYPT_VERSION))
     {
       fputs(""libgcrypt version mismatch\n"", stderr);
       exit(2);
     }

    gcry_control(GCRYCTL_DISABLE_SECMEM, 0);

    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

    if(!gcry_control(GCRYCTL_INITIALIZATION_FINISHED_P))
    {
        fputs(""libgcrypt has not been initialized\n"", stderr);
        abort();
    }

    err = gcry_cipher_open(
        &amp;handle,           // gcry_cipher_hd_t *
        GCRY_CIPHER,       // int
        GCRY_MODE,         // int
        0);                // unsigned int
    if (err)
    {
        printf(""gcry_cipher_open failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }

    err = gcry_cipher_setkey(handle, key, COUNTOF(key));
    if (err)
    {
        printf(""gcry_cipher_setkey failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }

    err = gcry_cipher_setiv(handle, iv, COUNTOF(iv));
    if (err)
    {
        printf(""gcry_cipher_setiv failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }

#if defined(AAD)
    err = gcry_cipher_authenticate(
        handle,         // gcry_cipher_hd_t
        aad,            // void *
        COUNTOF(aad));  // size_t
    if (err)
    {
        printf(""gcry_cipher_authenticate failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }
#endif

#if defined(AE)
    err = gcry_cipher_decrypt(
        handle,             // gcry_cipher_hd_t
        recovered,          // void *
        COUNTOF(recovered), // size_t
        cipher,             // const void *
        COUNTOF(cipher));   // size_t
    if (err)
    {
        printf(""gcry_cipher_decrypt failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }
#endif

    err = gcry_cipher_checktag(
        handle,
        tag,
        COUNTOF(tag));
    if (err)
    {
        printf(""gcry_cipher_checktag failed:  %s/%s\n"",
               gcry_strsource(err),
               gcry_strerror(err));
        return 1;
    }

#if defined(AE)
    fprintf(stdout, ""Decrypted = %s\n"", recovered);
#endif

#if defined(AAD)
    fprintf(stdout, ""Additional data = %s\n"", (char*)aad);
#endif

    gcry_cipher_close(handle);

    return 0;
}
</code></pre>

<p>It produces output similar to:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./gcm-gcrypt-decrypt.exe
Plaintext size: 69
Ciphertext size: 69
Recovered size: 80
Decrypted = Now is the time for all good men to come to the aide of the country.
Additional data = Attack at dawn!
</code></pre>
","1895","<c++><crypto++><libgcrypt>","2","0","3","2015-03-09 06:54:14","28936571","5","","1305907","","2015-03-05 01:40:37","2015-02-27 02:19:21",""
"28756446","Steps to decrypt encrypted data in Crypto++ in libgcrypt","<p>I need to decrypt the encrypted data by Crypto++ in libgcrypt due to C language restriction on target platform. So I've decided to use libgcrypt since it supporting the AES128 and GCM mode.</p>

<p>In Crypto++, the data is encrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string encrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string ciphertext;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedEncryptionFilter(
                                encryptor,
                                new CryptoPP::StringSink(ciphertext)
                                )
                            );

    return ciphertext;
}
</code></pre>

<p>and successfully decrypted this way:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string decrypt_data(const std::string &amp;data,
                         const std::vector&lt;unsigned char&gt; &amp;iv,
                         const std::vector&lt;unsigned char&gt; &amp;key)
{
    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);

    std::string recovered;
    CryptoPP::StringSource ss( data, true,
                            new CryptoPP::AuthenticatedDecryptionFilter(
                                decryptor,
                                new CryptoPP::StringSink( recovered )
                                )
                            );

    return recovered;
}                       
</code></pre>

<p>But the decoded data is wrong when I try to decode <code>ciphertext</code> using libgcrypt by these steps:</p>

<ol>
<li><code>gcry_cipher_open()</code></li>
<li><code>gcry_cipher_setkey()</code></li>
<li><code>gcry_cipher_setiv()</code></li>
<li>Seperate the cipher text and authentication tag</li>
<li><code>gcry_cipher_decrypt(cipher text)</code></li>
<li><code>gcry_cipher_checktag(authentication tag)</code></li>
</ol>

<p>Is there any steps I missed to replicate the Crypto++ decoding process?</p>

<p>Gcrypt decryption code (Expected output <code>Decrypted cipher = password</code>):</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;gcrypt.h&gt;

static unsigned char const aesSymKey[] = { 0x38, 0xb4, 0x8f, 0x1f, 0xcd, 0x63, 0xef, 0x32, 0xc5, 0xd1, 0x3f, 0x52, 0xbc, 0x4f, 0x5b, 0x24 };

static unsigned char const aesIV[] = { 0xE4, 0xEF, 0xC8, 0x08, 0xEB, 0xB8, 0x69, 0x95, 0xF3, 0x44, 0x6C, 0xE9, 0x15, 0xE4, 0x99, 0x7E };

static unsigned char const aesPass[] = { 0xda, 0x84, 0x3f, 0x01, 0xa0, 0x14, 0xfd, 0x85 };

static unsigned char const aesTag[] = { 0xdf, 0x5f, 0x9f, 0xe2, 0x9d, 0x7e, 0xc3, 0xdf, 0x7a, 0x1e, 0x59, 0xd8, 0xe6, 0x61, 0xf7, 0x7e };

#define GCRY_CIPHER GCRY_CIPHER_AES128
#define GCRY_MODE GCRY_CIPHER_MODE_GCM

int main(){
    gcry_error_t     gcryError;
    gcry_cipher_hd_t gcryCipherHd;

    if (!gcry_check_version(GCRYPT_VERSION))
     {
       fputs(""libgcrypt version mismatch\n"", stderr);
       exit(2);
     }

    gcry_control(GCRYCTL_DISABLE_SECMEM, 0);

    gcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);

    if(!gcry_control(GCRYCTL_INITIALIZATION_FINISHED_P))
    {
        fputs(""libgcrypt has not been initialized\n"", stderr);
        abort();
    }

    size_t keyLength = gcry_cipher_get_algo_keylen(GCRY_CIPHER);
    size_t blkLength = gcry_cipher_get_algo_blklen(GCRY_CIPHER);

    char * outBuffer = malloc(blkLength);

    gcryError = gcry_cipher_open(
        &amp;gcryCipherHd, // gcry_cipher_hd_t *
        GCRY_CIPHER,   // int
        GCRY_MODE,     // int
        0);            // unsigned int
    if (gcryError)
    {
        printf(""gcry_cipher_open failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setkey(gcryCipherHd, aesSymKey, keyLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setkey failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_setiv(gcryCipherHd, aesIV, blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_setiv failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_decrypt(
        gcryCipherHd, // gcry_cipher_hd_t
        outBuffer,    // void *
        blkLength,    // size_t
        aesPass,      // const void *
        8);           // size_t
    if (gcryError)
    {
        printf(""gcry_cipher_decrypt failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    gcryError = gcry_cipher_checktag(
        gcryCipherHd,
        aesTag,
        blkLength);
    if (gcryError)
    {
        printf(""gcry_cipher_checktag failed:  %s/%s\n"",
               gcry_strsource(gcryError),
               gcry_strerror(gcryError));
        return;
    }

    printf(""Decrypted cipher = %s\n"", outBuffer);

    // clean up after ourselves
    gcry_cipher_close(gcryCipherHd);
    free(outBuffer);

    return 0;
}
</code></pre>

<p>EDIT: Just to be clear, the steps to decrypt I'm searching for is for the <code>ciphertext</code> output of the Crypto++ encryption function shown above; the <code>encrypt_data()</code>. So I won't accept any answer where it can't be applied to successfully decrypt <code>ciphertext</code>.</p>
","<p>The Crpto++ encryption implementation executing this code to set the IV:</p>

<p><code>encryptor.SetKeyWithIV(&amp;key[0], key.size(), &amp;iv[0]);</code></p>

<p>Since the IV size is not passed, the default length is used which is 12. This is based on the recommended IV size by the specification which is 96bits.</p>

<p>So in order for my libgrcrypt to decode the cipher correctly, I just need to change this line:</p>

<p><code>gcryError = gcry_cipher_setiv(gcryCipherHd, aesIV, blkLength);</code></p>

<p>into this:</p>

<p><code>gcryError = gcry_cipher_setiv(gcryCipherHd, aesIV, 12);</code></p>

<p>So I'll get the expected output:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./decrypt
Decrypted cipher = password
</code></pre>
","1895","<c++><crypto++><libgcrypt>","2","0","3","2015-03-09 06:54:14","28936571","5","","1305907","","2015-03-05 01:40:37","2015-02-27 02:19:21",""
"41255199","warning: libcryptopp.so: is missing DT_SONAME will use basename as a replacement","<p>I am trying to build <code>libcryptopp.so</code> and include it in my JNI code, follow the guide in <a href=""https://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow noreferrer"">Android Crypto++</a>, I experienced the following problems.</p>

<p><strong>Missing symbol problems in Crypto++ 5.6.3</strong></p>

<p>Originally I used Crypto++ 5.6.3, I came across this problem:</p>

<pre><code> java.lang.UnsatisfiedLinkError: dlopen failed: cannot locate symbol ""_Z9GlobalRNGv"" 

referenced by ""/data/app/com.example.administrator.jnitest-2/lib/arm/libcryptopp.so""...
</code></pre>

<p>I check the <code>libcryptopp.so</code>:</p>

<pre><code>$ readelf -Ws libcryptopp.so | grep _Z9GlobalRNGv
1406: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z9GlobalRNGv
15836: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z9GlobalRNGv
</code></pre>

<p>switching to Crypto++ 5.6.4 fix this problem, but I still do not know the cause and met another problem:</p>

<p><strong>Missing DT_SONAME</strong></p>

<pre><code>12-21 09:50:20.837 21677-21677/com.example.administrator.jnitest   
W/linker: /data/app/com.example.administrator.jnitest- 1/lib/arm/libcryptopp.so: is missing DT_SONAME will use basename as a 
replacement: ""libcryptopp.so""
</code></pre>

<p>Actually this is only a <strong>warning</strong>, app will not crash.</p>

<p>I am using the latest version of android Mashwallow MOB31K.
Somebody have also experienced similar problems using other libraries </p>

<pre><code>https://github.com/bytedeco/javacpp-presets/issues/188
</code></pre>

<p>on Android N-preview.</p>

<p>Why am I getting the warning, and how do I fix it?</p>
","<p>After some attempts, I  find one <strong>imperfect</strong> solution.</p>

<p>It appears that android N turns requires library version now.</p>

<p>turn on <strong>SONAME</strong> flag on build.</p>

<p>Cryptopp turns off the version flag by defaults. In the GNUmakefile-cross,:</p>

<pre><code>HAS_SOLIB_VERSION ?= 0
</code></pre>

<p>set the value to 1:</p>

<pre><code>HAS_SOLIB_VERSION ?= 1
</code></pre>

<p>build, and then use the generated .so file. the warning will go. </p>

<p><strong>the problem is that is library will not work on android 5.0. So we'd better leave alone this warning now.</strong> </p>
","1871","<android><android-ndk><crypto++>","5","2","1","2016-12-22 08:40:43","41278924","6","0","2465534","","2016-12-22 08:35:05","2016-12-21 04:37:15",""
"21261764","Debug assertion fails","<p>I'm new in Crypto++, and I need to make some manipulations with my strings and ints (call a hash function and MAC function)</p>

<p>I saw this 
<a href=""https://stackoverflow.com/questions/6981616/using-cryptopp-to-generate-random-hashes-sha1"">Using Crypto++ to generate random hashes with SHA1</a> and tried to follow it.</p>

<p>I made new project, compiled cryptolibs, linked them (I think, correctly, because there is no linker errors). It built good, but on return from main I have this:</p>

<blockquote>
  <p>DEBUG ASSERTION FAILED! ...blablabla/dbgdel.cpp Line 52</p>
  
  <p>Expression: _Block_Type_Is_Valid(pHead->nBlockUse) ...</p>
</blockquote>

<p>I made it like at those post in comments, so i don't understand, why it happens.</p>

<p>code (includes are like addresses because i was really lazy to make good links at linker):</p>

<pre><code>#include &lt;C:\Users\esselesse\Documents\Visual Studio 2010\Projects\InfoProtect_Biometrics_Auth_Algorithm\InfoProtect_Biometrics_Auth_Algorithm\LIB\sha.h&gt;
#include &lt;C:\Users\esselesse\Documents\Visual Studio 2010\Projects\InfoProtect_Biometrics_Auth_Algorithm\InfoProtect_Biometrics_Auth_Algorithm\LIB\filters.h&gt;
#include &lt;C:\Users\esselesse\Documents\Visual Studio 2010\Projects\InfoProtect_Biometrics_Auth_Algorithm\InfoProtect_Biometrics_Auth_Algorithm\LIB\hex.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace CryptoPP;
using namespace std;

int main()
{
  SHA1 sha1;
  string source = ""Hello"";  //This will be randomly generated somehow
  string hash = """";
  StringSource(source, true, new HashFilter(sha1, new HexEncoder(new StringSink(hash))));
}
</code></pre>
","<pre><code>DEBUG ASSERTION FAILED! ...blablabla/dbgdel.cpp Line 52

Expression: _Block_Type_Is_Valid(pHead-&gt;nBlockUse) ...
</code></pre>

<p>That's coming from Visual Studio, not Crypto++. You have a memory problem.</p>

<hr>

<pre><code>$ cat t.cpp
// g++ -I/usr/local/include t.cpp -o t.exe -lcryptopp -lpthread

#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/hex.h&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace CryptoPP;
using namespace std;

int main()
{
  SHA1 sha1;
  string source = ""Hello"";  //This will be randomly generated somehow
  string hash = """";
  StringSource(source, true, new HashFilter(sha1, new HexEncoder(new StringSink(hash))));

  cout &lt;&lt; hash &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Runs fine for me:</p>

<pre><code>$ ./t.exe
F7FF9E8B7BB2E09B70935A5D785E0CC5D9D0ABF0
$ 
</code></pre>

<p>I suspect there's some information missing - like what you are doing with your strings and ints you mentioned (but did not show us).</p>

<p>You need to show us the code you are trying to run.</p>

<hr>

<blockquote>
  <p>I made new project, compiled cryptolibs, linked them (I think, correctly, because there is no linker errors).</p>
</blockquote>

<p>You might also verify your projects is set up as expected for Visual Studio. For that see <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment</a>.</p>
","1837","<c++><memory><crypto++>","1","1","1","2014-01-25 01:45:52","","0","","-1","","2017-05-23 12:21:00","2014-01-21 15:05:07",""
"33753293","Using std::string for key with AES encryption in Crypto++","<p>I am using <a href=""https://stackoverflow.com/questions/12306956/example-of-aes-using-crypto"">Example of AES using Crypto++</a>. I want to encrypt with this key:</p>

<pre><code>std::string key = ""mykey"";
</code></pre>

<p><strong>Allocate memory for key</strong></p>

<pre><code>byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );
</code></pre>

<p><strong>Do Encrypt:</strong></p>

<pre><code>CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );
</code></pre>

<p>How do I pass a key of <strong>std::string</strong> type to the <strong>aesEncryption</strong> function? </p>
","<p>Here is the solution:</p>

<pre><code>std::string sKey = ""mykey"";

if(CryptoPP::AES::DEFAULT_KEYLENGTH &lt; sKey.size())
    sKey = sKey.substr(0, CryptoPP::AES::DEFAULT_KEYLENGTH); // chop if too long
else if(CryptoPP::AES::DEFAULT_KEYLENGTH &gt; sKey.size())
    sKey += std::string(CryptoPP::AES::DEFAULT_KEYLENGTH - sKey.size(), '*'); // pad

memcpy(key, sKey.c_str(), CryptoPP::AES::DEFAULT_KEYLENGTH);
</code></pre>
","1829","<c++><encryption><aes><crypto++>","1","0","1","2015-11-18 02:37:39","33753913","6","0","-1","","2017-05-23 10:30:28","2015-11-17 09:28:29",""
"26803423","Why does 65537 not base64URL encode to ""AQAB"" using CryptoPP?","<p>I'm using CryptoPP to generate an RSA key pair to allow authentication for a game server. I need to base64URL encode my public exponent and modulus to include in a JWK but am having some problems.
The code shows how I generate the RSA keys, extract the exponent and encode it:</p>

<pre><code>typedef InvertibleRSAFunction RSAPrivateKey;
typedef RSAFunction RSAPublicKey;

RSAPrivateKey privateKey;
privateKey.Initialize( rng, 1024);

RSAPublicKey publicKey( privateKey );

const Integer&amp; e = privateKey.GetPublicExponent();

Base64Encoder exponentSink(new StringSink(exponentString));
e.DEREncode(exponentSink);
exponentSink.MessageEnd();
base64URL(exponentString);

cout &lt;&lt; ""exponentString: "" &lt;&lt; exponentString &lt;&lt; endl;
</code></pre>

<p>The base64URL function just filters the string for the =,+,\n and / characters to make it base64URL.</p>

<p>I know that CryptoPP uses an exponent of 17, and the code above encodes this as ""AgER"".
I've read from numerous sources that 65537 encodes as ""AQAB"" and I tried this as a test by manually setting e to this. When I do this the output is ""AgMBAAE"", not ""AQAB"".</p>

<p>When I use an online converter such as <a href=""https://www.base64encode.org/"" rel=""nofollow"">https://www.base64encode.org/</a> the output is instead ""NjU1Mzc"".</p>

<p>Can someone explain where all these differences come from and what the correct encoding of 17 is? Thanks!</p>
","<p>The output of CryptoPP seems to include the ASN.1 DER encoded representation. In hexadecimals the string <code>AgMBAAE</code> translates to <code>0203010001</code>.</p>

<p>Now in ASN.1 / DER this reads as:</p>

<pre><code>    02 a signed INTEGER
    03 the length of the value
010001 the value, a big endian signed integer (i.e. 65537)
</code></pre>

<hr>

<p>The value of the base64encode.org seems to output the base 64 encoding of the ASCII string <code>""65537""</code> : <code>3635353337</code> in hexadecimals.</p>

<hr>

<p>There is no single correct encoding of the value 17, it depends what you use it for.</p>

<ul>
<li>As single byte value it would be <code>EQ==</code></li>
<li>As ASN.1 / DER encoded integer it would be <code>AgER</code></li>
<li>As string it would be <code>MTc=</code></li>
</ul>

<p>you can of course use the same strings without <code>=</code> padding characters as well (to comply with the base64url encoding instead of the more common base 64 encoding).</p>
","1823","<c++><encoding><base64><rsa><crypto++>","4","6","1","2014-11-07 19:07:21","26808133","0","","1169715","","2014-11-07 15:11:08","2014-11-07 14:26:56",""
"28311795","Undefined symbols in Crypto++/iOS 64-bit project","<p>I tried to build with <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">github's prebuilt cryptopp</a> but it doesn't work, too. it occur errors like below:</p>

<blockquote>
  <p>Undefined symbols for architecture arm64:
   ""CryptoPP::BufferedTransformation::ChannelFlush(std::string const&amp;, bool, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::string const&amp;, bool) const"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::Filter::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::string const&amp;, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPut2(std::string const&amp;, unsigned char const*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelCreatePutSpace(std::string const&amp;, unsigned long&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelPutModifiable2(std::string const&amp;, unsigned char*, unsigned long, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd(std::string const&amp;, int, bool)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::BufferedTransformation::SetRetrievalChannel(std::string const&amp;)"", referenced from:</p>

<pre><code> vtable for CryptoPP::Base64Decoder in MYCLASSBBB.o
 vtable for CryptoPP::Unflushable&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>
  
  <p>""CryptoPP::StringSinkTemplate::StringSinkTemplate(std::string&amp;)"", referenced from:</p>

<pre><code> encryptString(std::string const&amp;) in MYCLASSBBB.o
 decryptString(std::string const&amp;, int) in MYCLASSBBB.o
 MYCLASSAAA::setDeviceId() in MYCLASSAAA.o
 MYCLASSAAA::getSignature() in MYCLASSAAA.o
</code></pre>
  
  <p>ld: symbol(s) not found for architecture arm64
  clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>
</blockquote>

<p>the MYCLASSAAA and MYCLASSBBB are all of classes what using cryptopp lib.
it using cryptlib.h, modes.h, filters.h, aes.h, base64.h, md5.h, hex.h.</p>

<p>I even tried to build the lib myself, but I it same errors happen. what should I do?</p>

<p>I hope your help. thanks.</p>

<hr>

<p>add the xcode cmd</p>

<blockquote>
  <p>Ld /Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Products/Release-iphoneos/PROJECT_NAME.app/PROJECT_NAME normal arm64
      cd /Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root
      export IPHONEOS_DEPLOYMENT_TARGET=5.1.1
      export PATH=""/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin""
      /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS8.1.sdk -L/Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Products/Release-iphoneos -L/Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/libs/cocos2dx/platform/third_party/ios/libraries -L/Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/libs/EEAF-SDK7.0(i386,armv7,armv7s,arm64) -L/Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/libs/boost_1_57/ios -L/Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/Classes/cryptopp/lib -LPROJECT_NAME/cocos2dx/platform/third_party/ios/libraries -LPROJECT_NAME/EEAF-SDK7.0(i386,armv7,armv7s,arm64) -F/Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Products/Release-iphoneos -F/Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/libs -filelist /Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Intermediates/PROJECT_NAME.build/Release-iphoneos/PROJECT_NAME.build/Objects-normal/arm64/PROJECT_NAME.LinkFileList -dead_strip -lxml2 -lz -ObjC -lcryptopp -fobjc-link-runtime -miphoneos-version-min=5.1.1 -lc++ /Users/USERNAME/Desktop/Development/Office_Projects/PROJECTROOT/root/PROJECT_NAME/libs/boost_1_57/ios/boost.a -framework UIKit -framework CoreTelephony -lEEAF -framework FacebookSDK -framework AddressBook -framework AddressBookUI -framework AudioToolbox -framework AVFoundation -framework CFNetwork -framework CoreGraphics -framework CoreLocation -framework CoreMedia -framework CoreText -framework Foundation -framework ImageIO -framework MediaPlayer -framework MobileCoreServices -framework OpenAL -framework OpenGLES -framework QuartzCore -framework Security -framework SystemConfiguration -lsqlite3.0 -framework StoreKit -lcurl -Xlinker -dependency_info -Xlinker /Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Intermediates/PROJECT_NAME.build/Release-iphoneos/PROJECT_NAME.build/Objects-normal/arm64/PROJECT_NAME_dependency_info.dat -o /Users/USERNAME/Library/Developer/Xcode/DerivedData/PROJECT_NAME-aknkujyaqvqjswbhspmawywtyqee/Build/Products/Release-iphoneos/PROJECT_NAME.app/PROJECT_NAME</p>
</blockquote>

<p>and ""vtable for CRYPTOPP::~.o"" always happen. with a notice : </p>

<blockquote>
  <p>NOTE: a missing vtable usually means the first non-inline virtual member function has no definition.</p>
</blockquote>
","<pre><code>Undefined symbols for architecture arm64: ""CryptoPP::BufferedTransformation::ChannelFlush(std::string const&amp;, bool, int, bool)"", referenced from:

 vtable for CryptoPP::SimpleProxyFilter in MYCLASSBBB.o
 vtable for CryptoPP::Bufferless&lt;CryptoPP::Filter&gt; in MYCLASSBBB.o
</code></pre>

<p>I <em>think</em> you are <em>not</em> using <code>libc++</code>, which is LLVM's C++ standard library. I think that because I don't see a <code>-stdlib=libc++</code> (but I don't recall if that's passed to <code>ld</code> directly).</p>

<p>The symbol is defined in the <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow noreferrer"">github's prebuilt cryptopp</a> (that's my github, btw). Here's how to verify.</p>

<p>First, extract the arm64 library from the fat library:</p>

<pre><code>$ xcrun -sdk iphoneos lipo libcryptopp.a -thin arm64 -output libcryptopp-arm64.a
$ ls
libcryptopp-arm64.a libcryptopp.a
</code></pre>

<p>Next, use <code>nm</code> to dump global symbols, and use <code>c++filt</code> to demangle:</p>

<pre><code>$ nm -g libcryptopp-arm64.a | c++filt | grep BufferedTransformation::ChannelFlush | grep "" T ""
0000000000002110 T CryptoPP::BufferedTransformation::ChannelFlush(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool, int, bool)
</code></pre>

<p>The capitol <code>T</code> means you are searching for symbols that are defined and exported. Lower <code>t</code> means its defined <em>but</em> not exported - i.e., private. Capitol <code>U</code> means its undefined.</p>

<p>The <code>__1</code> is what <code>libc++</code> (LLVM) uses to differentiate from <code>libstdc++</code> (GNU). <code>std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;</code> is a <code>string</code>, so that could be rewritten as:</p>

<pre><code>CryptoPP::BufferedTransformation::ChannelFlush(std::__1::string const&amp;, bool, int, bool)
</code></pre>

<p><em>If</em> this library was built against <code>libstdc++</code> (GNU), then the symbol from the library would be:</p>

<pre><code>CryptoPP::BufferedTransformation::ChannelFlush(std:::string const&amp;, bool, int, bool)
</code></pre>

<p>We can repeat for the second problem child, and it follows the same pattern (<code>libc++</code>, and not <code>libstdc++</code>):</p>

<pre><code>$ nm -g libcryptopp-arm64.a | c++filt | grep CryptoPP::Filter::CopyRangeTo2 | grep "" T ""
00000000000001c4 T CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, bool) const
</code></pre>

<p>This can be rewritten as:</p>

<pre><code>CryptoPP::Filter::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__1::string const&amp;, bool) const
</code></pre>

<h2>-----</h2>

<p><em>IF</em> you need GNU's <code>libstdc++</code>, then you can build it yourself. Here are the steps:</p>

<ol>
<li>Download and unpack Crypto++ from the website</li>
<li>Download and unpack <a href=""http://www.cryptopp.com/w/images/a/a0/Cryptopp-mobile.zip"" rel=""nofollow noreferrer""><code>cryptopp-mobile.zip</code></a>. Unpack it right over top the Crypto++ source files</li>
<li>Open the new <code>GNUmakefile</code>, find the iOS rule by searching for the block that begins with <code>IS_IOS</code></li>
<li>Change this line in the <code>IS_IOS</code> block: <code>CXXFLAGS += -stdlib=libc++</code>. Change it to <code>CXXFLAGS += -stdlib=libstdc++</code></li>
<li>Do the cross compile...</li>
</ol>

<h2>-----</h2>

<p>I downloaded Cocos2D-x and tried to look at its configuration (I'm not a Cmake guy, so I could be wrong with what follows). It has the following in <code>CmakeList.txt</code>:</p>

<pre><code>if(MSVC)
  ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS -D_SCL_SECURE_NO_WARNINGS
                  -wd4251 -wd4244 -wd4334 -wd4005 -wd4820 -wd4710
                  -wd4514 -wd4056 -wd4996 -wd4099)
else()
  set(CMAKE_C_FLAGS_DEBUG ""-g -Wall -DCOCOS2D_DEBUG=1"")
  set(CMAKE_CXX_FLAGS_DEBUG ${CMAKE_C_FLAGS_DEBUG})
  set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -fno-exceptions -std=c99"")
  set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fno-exceptions -std=c++11 -Wno-deprecated-declarations -Wno-reorder"")
  if(CLANG)
    set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -stdlib=libc++"")
  endif()
endif(MSVC)
</code></pre>

<p><em>If</em> Cmake is doing what I suspect, then its using LLVM's <code>libc++</code>. But its also using <code>-std=c++11</code>, and the GitHub project is not using it. But I'm not sure <code>-std=c++11</code> makes a difference here.</p>

<p>Just bike shedding, but this is a bad sign: <code>_SCL_SECURE_NO_WARNINGS</code>. If they are blatantly doing that, then they probably have various degrees of of badness and brokenness. (Just my experience with auditing software).</p>

<hr>

<p>If interested, the <code>__1</code> is an inline namespace used for versioning. See <a href=""https://stackoverflow.com/q/11016220"">What are inline namespaces for?</a> and <a href=""https://stackoverflow.com/q/29293394"">Where does the __1 symbol come from when using LLVM's libc++?</a>.</p>
","1812","<c++><ios><xcode><cocos2d-x><crypto++>","1","0","1","2016-03-21 05:36:19","28315574","3","","608639","","2016-03-21 05:36:19","2015-02-04 01:12:18",""
"3201522","C++ writing/reading hex values correctly (CryptoPP)","<p>I am trying to run a program, that encrypts and decrypts using AES.</p>

<p>(from <a href=""http://www.codeproject.com/KB/security/AESProductKey.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/security/AESProductKey.aspx</a> )</p>

<pre><code>// From aestest1.cpp

// Runtime Includes
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include ""stdafx.h""

// Crypto++ Includes
#include ""cryptlib.h""

#include ""aes.h""        // AES

#include ""modes.h""      // CBC_Mode&lt; &gt;

#include ""filters.h""    // StringSource

using namespace std;

int main(int argc, char* argv[]) {

// Key and IV setup
byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], 
      iv[ CryptoPP::AES::BLOCKSIZE ];

::memset( key, 0x01, CryptoPP::AES::DEFAULT_KEYLENGTH );
::memset(  iv, 0x01, CryptoPP::AES::BLOCKSIZE );

// Message M
string PlainText = ""Hello AES World"";

// Debug
cout &lt;&lt; ""Plain Text:"" &lt;&lt; endl;
cout &lt;&lt; ""  '"" &lt;&lt; PlainText &lt;&lt; ""'"" &lt;&lt; endl;
cout &lt;&lt; endl;

// Cipher Text Sink
string CipherText;

// Encryption
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption
    Encryptor( key, sizeof(key), iv );

CryptoPP::StringSource( PlainText, true,
    new CryptoPP::StreamTransformationFilter( Encryptor,
        new CryptoPP::StringSink( CipherText )
    ) // StreamTransformationFilter
); // StringSource


///////////////////////////////////////
//                DMZ                //
///////////////////////////////////////
//Write data
ofstream write (""file.txt"", ios::out | ios::binary);
write.write((char*)key,sizeof(key));
write.write((char*)iv,sizeof(iv));
int at = CipherText.length();
write.write(CipherText.c_str(),at); 
write.close();
CipherText.erase();
//Using new key and iv later;
byte key1[ CryptoPP::AES::DEFAULT_KEYLENGTH ], 
     iv1[ CryptoPP::AES::BLOCKSIZE ];

//Read data
ifstream read (""file.txt"", ios::in | ios::binary);

read.seekg (0, ios::end);
int fsize = read.tellg();
read.seekg (0, ios::beg);

read.read((char*)key1,sizeof(key));
read.read((char*)iv1,sizeof(iv));




int toRead = fsize - sizeof(key) - sizeof(iv);
vector&lt;char&gt; bData(toRead);
read.read(&amp;bData[0],toRead);

read.close();
// Recovered Text Sink
string RecoveredText;

// Decryption
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption
    Decryptor( key1, sizeof(key1), iv1 );

CryptoPP::StringSource( &amp;bData[0], true,
    new CryptoPP::StreamTransformationFilter( Decryptor,
        new CryptoPP::StringSink( RecoveredText )
    ) // StreamTransformationFilter
); // StringSink

// Debug
cout &lt;&lt; ""Recovered Text:"" &lt;&lt; endl;
cout &lt;&lt; ""  '"" &lt;&lt; RecoveredText &lt;&lt; ""'"" &lt;&lt; endl;
cout &lt;&lt; endl;
system(""pause"");
return 0;
</code></pre>

<p>}
So I couldn`t manage to write a code, that will correctly do the stuff, that mentioned in comments (after DMZ, where ofstream begins). Thanks in advance.</p>
","<p>You need to disable text processing, which messes up newline characters.</p>

<p>Try</p>

<pre><code>ofstream write (""text.txt"", ios::out | ios__binary);
</code></pre>

<p>and</p>

<pre><code>ifstream read (""text.txt"", ios::in | ios::binary);
</code></pre>
","1808","<c++><console-application><crypto++>","2","2","1","2010-07-21 11:35:59","3201553","0","1","","user380041","2010-07-21 11:35:59","2010-07-08 07:41:02",""
"25744302","Using CryptoPP::HexDecoder( )","<p>I am playing with Cryptopp for ther first time and I found an example to encode to Hex...All is well.
Now I want to decode std::string produced into original string but all I get is empty string. </p>

<pre><code>#include ""stdafx.h""

#include ""../cryptopp562/sha.h""
#include ""../cryptopp562/filters.h""
#include ""../cryptopp562/hex.h""
#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    CryptoPP::SHA1 sha1;
    std::string source = ""Panawara"";  
    std::string hash = """";
    std::string original= """" ;

    CryptoPP::StringSource(source, true, new CryptoPP::HashFilter(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(hash))));
    std::cout &lt;&lt; hash;
    std::cout &lt;&lt; ""\n"";

    CryptoPP::StringSource (hash, new CryptoPP::HexDecoder(new CryptoPP::StringSink(original)));  // the result is always empty String
    std::cout &lt;&lt; original;
    std::cout &lt;&lt; ""\n"";

    system(""pause"");
}
</code></pre>
","<blockquote>
<pre><code>CryptoPP::StringSource(source, true,
    new CryptoPP::HashFilter(sha1,
        new CryptoPP::HexEncoder(new CryptoPP::StringSink(hash))));
</code></pre>
</blockquote>

<p>Don't use anonymous declarations. Name your variables. Use this instead:</p>

<pre><code>CryptoPP::StringSource ss(source, true,
    new CryptoPP::HashFilter(sha1,
        new CryptoPP::HexEncoder(new CryptoPP::StringSink(hash)
    )));
</code></pre>

<p>Do it for all of them.</p>

<p>Also see <a href=""https://stackoverflow.com/questions/25327066/cryptopp-hexdecoder-output-empty"">CryptoPP HexDecoder output empty</a>.</p>
","1783","<c++><visual-c++><encryption><hex><crypto++>","2","1","1","2014-09-10 08:14:30","25752375","1","","608639","","2014-09-10 08:14:30","2014-09-09 12:11:06",""
"36239273","AES128 in CBC mode implementation using Crypto++ library","<p>In the input file I have: <br>
on the first line a key which is encoded in hex and with length of 16 bytes;<br>
on the second line encrypted message ( AES128 in CBC mode , with a random iv prepended to the encrypted message).<br><br></p>

<p>This is how I tried to decrypt: <br></p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

#include &lt;fstream&gt;
#include &lt;string.h&gt;
#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/filters.h&gt;

using namespace CryptoPP;

int main(void) {
    ifstream in(""input0.txt"");
    ofstream out(""output0.txt"");

    string hex_key = """", hex_ct = """";
    in &gt;&gt; hex_key &gt;&gt; hex_ct;

    byte key[ AES::DEFAULT_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
    string ciphertext = """", recoveredtext = """";

    for(int i = 0; i &lt; hex_key.size(); i+=2) {
        key[i/2] = (char) strtol((hex_key.substr(i, 2)).c_str(), 0, 16);
    }

    //then I divide iv from the text
    for(int i = 0; i &lt; AES::BLOCKSIZE*2; i+=2) {
        iv[i/2] = (char) strtol((hex_ct.substr(i, 2)).c_str(), 0, 16);
    }

    for(int i = AES::BLOCKSIZE*2; i &lt; hex_ct.size(); i++) {
        ciphertext.push_back(hex_ct[i]);
    }

    //decryption
    CBC_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV(key, AES::DEFAULT_KEYLENGTH, iv);

    StringSink sink( recoveredtext );

    StreamTransformationFilter stf (
        d,
        &amp;sink
    );

    StringSource ss (
        ciphertext,
        true,
        &amp;stf
    );

    out &lt;&lt; recoveredtext;

    return 0;
}
</code></pre>

<p>I used this implementation following the <a href=""https://www.cryptopp.com/wiki/CBC_mode"" rel=""nofollow noreferrer""> Wiki</a>.<br>
I also tried with <a href=""https://stackoverflow.com/questions/12306956/example-of-aes-using-crypto""> this </a> and it worked, but not replacing key and ciphertext with my.<br>
Well, using the code above I have this output: <br></p>

<pre><code>AES128CBC: /usr/local/include/cryptopp/misc.h:304: void CryptoPP::memcpy_s(void*, size_t, const void*, size_t): Assertion `dest != __null' failed.
Aborted (core dumped)
</code></pre>

<p>While using this code:</p>

<pre><code>//decryption

 AES::Decryption aesDecryption(key, AES::DEFAULT_KEYLENGTH);
CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

StreamTransformationFilter stfDecryptor(
    cbcDecryption,
    new StringSink( recoveredtext ),
    BlockPaddingSchemeDef::NO_PADDING
);

stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
stfDecryptor.MessageEnd();
</code></pre>

<p>It works but the output isn't a valid sequence of characters.<br></p>

<p>I installed the lib with: <br></p>

<pre><code>sudo apt-get install libcrypto++-dev libcrypto++-doc libcrypto++-utils
</code></pre>

<p>and I compiled it with:</p>

<pre><code>g++ -o AESCBC128 AESCBC128.cpp -lcryptopp
</code></pre>

<p>I can't find what's wrong.<br>
Thanks in advance for the help.<br><br>
Sample of input:<br></p>

<pre><code>140b41b22a29beb4061bda66b6747e14
4ca00ff4c898d61e1edbf1800618fb2828a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
</code></pre>

<p><br>
I don't know a sample of output because this is an exercise and my goal is to discover the secret message.<br>
Test on the inputs and on conversion to byte arrays:</p>

<pre><code>out &lt;&lt; ""KEY:\n"" &lt;&lt; hex_key &lt;&lt; endl;

for(int i = 0; i &lt; AES::DEFAULT_KEYLENGTH; i++) {
    out &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)key[i];
}

out &lt;&lt; endl &lt;&lt; ""Received message:\n"" &lt;&lt; hex_ct &lt;&lt; endl;

out &lt;&lt; ""IV:\n"";
for(int i = 0; i &lt; AES::BLOCKSIZE; i++) {
    out &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)iv[i];
}

out &lt;&lt; endl &lt;&lt; ""CT:\n"" &lt;&lt; ciphertext &lt;&lt; endl;
</code></pre>

<p>Result:</p>

<pre><code>KEY:
140b41b22a29beb4061bda66b6747e14
140b41b22a29beb4061bda66b6747e14
Received message:
4ca00ff4c898d61e1edbf1800618fb2828a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
IV:
4ca00ff4c898d61e1edbf1800618fb28
CT:
28a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
</code></pre>

<p>They are as expected.</p>
","<p>A probable reason you are getting a padding error is not the padding but that the decryption is wrong, the way the parameters are supplied is probably incorrect. </p>

<p>I coded up decryption on the supplied KEY, IV and CT. The result has PKCS#7 padding of 8 bytes of 0x08.</p>

<p>(correct to remove iv)</p>

<p>Decryption with padding removed:  </p>

<blockquote>
  <p>42617369 63204342 43206d6f 64652065 6e637279 7074696f 6e206e65 65647320 70616464 696e672e</p>
</blockquote>

<p>or in text:</p>

<blockquote>
  <p>Basic CBC mode encryption needs padding.</p>
</blockquote>

<p>Decryption with padding intact (note the trailing 8 characters of padding):  </p>

<blockquote>
  <p>42617369 63204342 43206d6f 64652065 6e637279 7074696f 6e206e65 65647320 70616464 696e672e 08080808 08080808</p>
</blockquote>

<p>The output is mostly ASCII with a few exceptions such as the 3rd byte 0xfc.</p>

<p>Because the padding is correct I believe this is the true data that was encrypted.</p>

<p>For the overly curious here is my test code:</p>

<pre><code>NSData *key    = [Utilities dataFromHexString:@""140b41b22a29beb4061bda66b6747e14""];
NSData *iv     = [Utilities dataFromHexString:@""4ca00ff4c898d61e1edbf1800618fb28""];
NSData *dataIn = [Utilities dataFromHexString:@""28a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81""];

size_t         cryptBytes = 0;
NSMutableData *dataOut    = [NSMutableData dataWithLength:dataIn.length + kCCBlockSizeAES128];

CCCrypt(kCCDecrypt,
        kCCAlgorithmAES,
        kCCOptionPKCS7Padding,
        key.bytes, key.length,
        iv.bytes,
        dataIn.bytes, dataIn.length,
        dataOut.mutableBytes, dataOut.length,
        &amp;cryptBytes);
dataOut.length = cryptBytes;

NSLog(@""dataOut: %@"", dataOut);
NSLog(@""dataOut: %@"", [[NSString alloc] initWithData:dataOut encoding:NSUTF8StringEncoding]);
</code></pre>
","1770","<c++><encryption><aes><crypto++>","3","1","2","2016-05-02 01:00:45","36241147","8","","-1","","2017-05-23 10:30:35","2016-03-26 18:39:05",""
"36239273","AES128 in CBC mode implementation using Crypto++ library","<p>In the input file I have: <br>
on the first line a key which is encoded in hex and with length of 16 bytes;<br>
on the second line encrypted message ( AES128 in CBC mode , with a random iv prepended to the encrypted message).<br><br></p>

<p>This is how I tried to decrypt: <br></p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

#include &lt;fstream&gt;
#include &lt;string.h&gt;
#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/filters.h&gt;

using namespace CryptoPP;

int main(void) {
    ifstream in(""input0.txt"");
    ofstream out(""output0.txt"");

    string hex_key = """", hex_ct = """";
    in &gt;&gt; hex_key &gt;&gt; hex_ct;

    byte key[ AES::DEFAULT_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
    string ciphertext = """", recoveredtext = """";

    for(int i = 0; i &lt; hex_key.size(); i+=2) {
        key[i/2] = (char) strtol((hex_key.substr(i, 2)).c_str(), 0, 16);
    }

    //then I divide iv from the text
    for(int i = 0; i &lt; AES::BLOCKSIZE*2; i+=2) {
        iv[i/2] = (char) strtol((hex_ct.substr(i, 2)).c_str(), 0, 16);
    }

    for(int i = AES::BLOCKSIZE*2; i &lt; hex_ct.size(); i++) {
        ciphertext.push_back(hex_ct[i]);
    }

    //decryption
    CBC_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV(key, AES::DEFAULT_KEYLENGTH, iv);

    StringSink sink( recoveredtext );

    StreamTransformationFilter stf (
        d,
        &amp;sink
    );

    StringSource ss (
        ciphertext,
        true,
        &amp;stf
    );

    out &lt;&lt; recoveredtext;

    return 0;
}
</code></pre>

<p>I used this implementation following the <a href=""https://www.cryptopp.com/wiki/CBC_mode"" rel=""nofollow noreferrer""> Wiki</a>.<br>
I also tried with <a href=""https://stackoverflow.com/questions/12306956/example-of-aes-using-crypto""> this </a> and it worked, but not replacing key and ciphertext with my.<br>
Well, using the code above I have this output: <br></p>

<pre><code>AES128CBC: /usr/local/include/cryptopp/misc.h:304: void CryptoPP::memcpy_s(void*, size_t, const void*, size_t): Assertion `dest != __null' failed.
Aborted (core dumped)
</code></pre>

<p>While using this code:</p>

<pre><code>//decryption

 AES::Decryption aesDecryption(key, AES::DEFAULT_KEYLENGTH);
CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

StreamTransformationFilter stfDecryptor(
    cbcDecryption,
    new StringSink( recoveredtext ),
    BlockPaddingSchemeDef::NO_PADDING
);

stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
stfDecryptor.MessageEnd();
</code></pre>

<p>It works but the output isn't a valid sequence of characters.<br></p>

<p>I installed the lib with: <br></p>

<pre><code>sudo apt-get install libcrypto++-dev libcrypto++-doc libcrypto++-utils
</code></pre>

<p>and I compiled it with:</p>

<pre><code>g++ -o AESCBC128 AESCBC128.cpp -lcryptopp
</code></pre>

<p>I can't find what's wrong.<br>
Thanks in advance for the help.<br><br>
Sample of input:<br></p>

<pre><code>140b41b22a29beb4061bda66b6747e14
4ca00ff4c898d61e1edbf1800618fb2828a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
</code></pre>

<p><br>
I don't know a sample of output because this is an exercise and my goal is to discover the secret message.<br>
Test on the inputs and on conversion to byte arrays:</p>

<pre><code>out &lt;&lt; ""KEY:\n"" &lt;&lt; hex_key &lt;&lt; endl;

for(int i = 0; i &lt; AES::DEFAULT_KEYLENGTH; i++) {
    out &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)key[i];
}

out &lt;&lt; endl &lt;&lt; ""Received message:\n"" &lt;&lt; hex_ct &lt;&lt; endl;

out &lt;&lt; ""IV:\n"";
for(int i = 0; i &lt; AES::BLOCKSIZE; i++) {
    out &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; hex &lt;&lt; (int)iv[i];
}

out &lt;&lt; endl &lt;&lt; ""CT:\n"" &lt;&lt; ciphertext &lt;&lt; endl;
</code></pre>

<p>Result:</p>

<pre><code>KEY:
140b41b22a29beb4061bda66b6747e14
140b41b22a29beb4061bda66b6747e14
Received message:
4ca00ff4c898d61e1edbf1800618fb2828a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
IV:
4ca00ff4c898d61e1edbf1800618fb28
CT:
28a226d160dad07883d04e008a7897ee2e4b7465d5290d0c0e6c6822236e1daafb94ffe0c5da05d9476be028ad7c1d81
</code></pre>

<p>They are as expected.</p>
","<p>Yes, the problem was in the input: I didn't convert the ciphertext from hex to ascii.</p>

<p>So the solution is to use this:</p>

<pre><code>for(int i = AES::BLOCKSIZE*2; i &lt; hex_ct.size(); i+=2) {
        ciphertext.push_back((char) strtol((hex_ct.substr(i, 2)).c_str(), 0, 16));
    } 
</code></pre>

<p>Instead of this:</p>

<pre><code>for(int i = AES::BLOCKSIZE*2; i &lt; hex_ct.size(); i++) {
        ciphertext.push_back(hex_ct[i]);
    }
</code></pre>

<p>The IV and the PAD are automatically removed.</p>

<p>So the solution code is:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

#include &lt;fstream&gt;
#include &lt;string.h&gt;
#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/filters.h&gt;

using namespace CryptoPP;

int main(void) {
    ifstream in(""input0.txt"");
    ofstream out(""output0.txt"");

    string hex_key = """", hex_ct = """";
    in &gt;&gt; hex_key &gt;&gt; hex_ct;

    byte key[ AES::DEFAULT_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
    string ciphertext, recoveredtext;

    for(int i = 0; i &lt; hex_key.size(); i+=2) {
        key[i/2] = (char) strtol((hex_key.substr(i, 2)).c_str(), 0, 16);
    }

    for(int i = 0; i &lt; AES::BLOCKSIZE*2; i+=2) {
        iv[i/2] = (char) strtol((hex_ct.substr(i, 2)).c_str(), 0, 16);
    }

    for(int i = AES::BLOCKSIZE*2; i &lt; hex_ct.size(); i+=2) {
        ciphertext.push_back((char) strtol((hex_ct.substr(i, 2)).c_str(), 0, 16));
    }

    //decryption

    AES::Decryption aesDecryption(key, AES::DEFAULT_KEYLENGTH);
    CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    StreamTransformationFilter stfDecryptor(
        cbcDecryption,
        new StringSink( recoveredtext )
    );

    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    out &lt;&lt; recoveredtext;

    return 0;
}
</code></pre>
","1770","<c++><encryption><aes><crypto++>","3","1","2","2016-05-02 01:00:45","36241147","8","","-1","","2017-05-23 10:30:35","2016-03-26 18:39:05",""
"15027321","InvalidCiphertext exception","<p>I am new with cryptopp, I try to encrypt and decrypt text from a file.
I alway receive this error CryptoPP::InvalidCiphertext at memory location 0x0012efe4 just after these lines:</p>

<pre><code>CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.length());
stfDecryptor.MessageEnd();
</code></pre>

<p>The encryption/decryption code:</p>

<pre><code>BOOL Encryption()
{
    // Key and IV setup
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    HW_PROFILE_INFO hwProfileInfo;
    GetCurrentHwProfile(&amp;hwProfileInfo);

    (hwProfileInfo.szHwProfileGuid, strlen(hwProfileInfo.szHwProfileGuid), key);     
    (hwProfileInfo.szHwProfileGuid, strlen(hwProfileInfo.szHwProfileGuid), iv);

    // String and Sink setup
    string STRING;
    ifstream infile;
    infile.open (""test2.txt"");

    getline(infile,STRING, '\0'); // Saves the line in STRING.
    char cFilm[1000];
    strcpy(cFilm,STRING.c_str());
    infile.close();

    std::string plaintext = cFilm;
    std::string ciphertext;
    std::string decryptedtext;

    // Dump Plain Text
    std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; plaintext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    // Create Cipher Text
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );
    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    // Dump Cipher Text
    ofstream write (""test2a.txt"", ios::out | ios::binary);
    int at = ciphertext.length()+ 1;
    write.write(ciphertext.c_str(),at);
    write.close();
    ciphertext.erase();

    remove(""test2.txt"");
    rename(""test2a.txt"",""c:\\test2.txt"");

    return 0;
}

BOOL Decryption()
{
    // Key and IV setup
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    HW_PROFILE_INFO hwProfileInfo;
    GetCurrentHwProfile(&amp;hwProfileInfo);

    // String and Sink setup
    string STRING2;
    ifstream infile2;
    infile2.open (""test2.txt"",ios::binary);

    getline(infile2,STRING2, '\0'); // Saves the line in STRING.
    char cFilm2[1000];
    strcpy(cFilm2,STRING2.c_str());
    infile2.close();

    std::string ciphertext (cFilm2);
    std::string decryptedtext;

    // Decrypt
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.length());
    stfDecryptor.MessageEnd();

    // Dump Decrypted Text
    ofstream write (""test2a.txt"", ios::out | ios::binary);
    write &lt;&lt; decryptedtext;
    write.close();
    decryptedtext.erase();

    remove(""test2.txt"");
    rename(""test2a.txt"",""test2.txt"");

    return 0;
}
</code></pre>
","<p>Your main problem seems to be in the use of <code>getline</code> with the <code>'\0'</code> delimiter in <code>Decryption()</code>.  This may work for the plain text in <code>Encryption()</code> if it doesn't contain null characters, but the cipher text is very likely to be riddled with <code>'\0'</code>s throughout.</p>

<p>It appears as though you've correctly identified that the encrypted file contains binary data, but you need to read it in as such, e.g. using <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/read"" rel=""nofollow""><code>std::ifstream::read</code></a> or <a href=""http://en.cppreference.com/w/cpp/iterator/istreambuf_iterator"" rel=""nofollow""><code>std::istreambuf_iterator</code></a>.</p>

<p>I have updated your example code below:</p>

<pre class=""lang-c prettyprint-override""><code>#include ""windows.h""

#include &lt;algorithm&gt;  // for std::copy
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;  // for std::istreambuf_iterator
#include &lt;string&gt;

#ifdef _MSC_VER
#  pragma warning(push)
#  pragma warning(disable: 4100 4127 4189 4244)
#endif
#include ""cryptopp/aes.h""
#include ""cryptopp/config.h""
#include ""cryptopp/files.h""
#include ""cryptopp/filters.h""
#include ""cryptopp/modes.h""
#ifdef _MSC_VER
#  pragma warning(pop)
#endif

namespace {
const std::string original_file(""original.txt"");
const std::string encrypted_file(""encrypted.txt"");
const std::string decrypted_file(""decrypted.txt"");
const int key_size(CryptoPP::AES::DEFAULT_KEYLENGTH);
const int iv_size(CryptoPP::AES::BLOCKSIZE);
}

void GetKeyAndIv(byte* key, byte* iv) {
  HW_PROFILE_INFOA profile;
  GetCurrentHwProfileA(&amp;profile);
  char* guid(profile.szHwProfileGuid);
  assert(std::char_traits&lt;char&gt;::length(guid) &gt;= key_size + iv_size);
  // Assign first 'key_size' chars of GUID to 'key'
  std::copy(guid, guid + key_size, key);
  // Assign next 'iv_size' chars of GUID to 'iv'
  std::copy(guid + key_size, guid + key_size + iv_size, iv);
};

void Encrypt() {
  // Initialise the key and IV
  byte key[key_size] = {0}, iv[iv_size] = {0};
  GetKeyAndIv(key, iv);

  // Read the file contents to a string and output to cout.  Safest to read
  // contents as binary data, although non-printable characters shouldn't be
  // output to cout.
  std::ifstream infile(original_file.c_str(), std::ios::binary);
  const std::string plaintext((std::istreambuf_iterator&lt;char&gt;(infile)),
                               std::istreambuf_iterator&lt;char&gt;());
  infile.close();
  std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)\n""
            &lt;&lt; plaintext &lt;&lt; ""\n\n"";

  // Encrypt
  CryptoPP::AES::Encryption cipher(key, key_size);
  CryptoPP::CBC_Mode_ExternalCipher::Encryption encryption(cipher, iv);
  std::string cipher_text;
  CryptoPP::StreamTransformationFilter filter(encryption,
      new CryptoPP::StringSink(cipher_text));
  filter.Put(reinterpret_cast&lt;const byte*&gt;(plaintext.c_str()), plaintext.size());
  filter.MessageEnd();

  // Dump cipher text
  std::ofstream outfile(encrypted_file.c_str(), std::ios::binary);
  outfile.write(cipher_text.c_str(), cipher_text.size());
  outfile.close();
}

void Decrypt() {
  // Initialise the key and IV
  byte key[key_size] = {0}, iv[iv_size] = {0};
  GetKeyAndIv(key, iv);

  // Read the encrypted file contents to a string as binary data.
  std::ifstream infile(encrypted_file.c_str(), std::ios::binary);
  const std::string cipher_text((std::istreambuf_iterator&lt;char&gt;(infile)),
                                 std::istreambuf_iterator&lt;char&gt;());
  infile.close();

  // Decrypt
  CryptoPP::AES::Decryption cipher(key, key_size);
  CryptoPP::CBC_Mode_ExternalCipher::Decryption decryption(cipher, iv);
  std::string decrypted_test;
  CryptoPP::StreamTransformationFilter filter(decryption,
      new CryptoPP::StringSink(decrypted_test));
  filter.Put(reinterpret_cast&lt;const byte*&gt;(cipher_text.c_str()),
             cipher_text.size());
  filter.MessageEnd();

  // Dump decrypted text
  std::ofstream outfile(decrypted_file.c_str(), std::ios::binary);
  outfile.write(decrypted_test.c_str(), decrypted_test.size());
  outfile.close();
}

int main() {
  try {
    Encrypt();
    Decrypt();
  }
  catch(const CryptoPP::Exception&amp; exception) {
    std::cout &lt;&lt; ""Caught exception: "" &lt;&lt; exception.what() &lt;&lt; '\n';
    return -1;
  }
  return 0;
}
</code></pre>

<p>An even more straightforward option is to use CryptoPP's <code>FileSource</code> and <code>FileSink</code> classes to avoid reading/writing the files by hand:</p>

<pre class=""lang-c prettyprint-override""><code>void Encrypt() {
  byte key[key_size] = {0}, iv[iv_size] = {0};
  GetKeyAndIv(key, iv);
  CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption encryption;
  encryption.SetKeyWithIV(key, key_size, iv, iv_size);
  CryptoPP::FileSource file_source(original_file.c_str(), true,
    new CryptoPP::StreamTransformationFilter(encryption,
      new CryptoPP::FileSink(encrypted_file.c_str())));
}

void Decrypt() {
  byte key[key_size] = {0}, iv[iv_size] = {0};
  GetKeyAndIv(key, iv);
  CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;
  decryption.SetKeyWithIV(key, key_size, iv, iv_size);
  CryptoPP::FileSource file_source(encrypted_file.c_str(), true,
    new CryptoPP::StreamTransformationFilter(decryption,
      new CryptoPP::FileSink(decrypted_file.c_str())));
}
</code></pre>
","1763","<c++><crypto++>","1","4","1","2018-03-19 14:32:58","","0","","1033581","","2018-03-19 14:32:58","2013-02-22 15:18:23",""
"17055990","Crypto++ can't build Qt Application","<p>I am currently trying to run Crypto++ in my Qt Application. But it does not work. Hopefully somebody of you knows whats wrong, because I have not figured it out and I am on this for 3 days now. </p>

<p>To concentrate the problem, I have created a test app. Holding this code: <a href=""http://pastebin.com/1XMARtds"" rel=""nofollow noreferrer"">http://pastebin.com/1XMARtds</a> taken from <a href=""http://programmingknowledgeblog.blogspot.de/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow noreferrer"">http://programmingknowledgeblog.blogspot.de/2013/04/compiling-and-integrating-crypto-into.html</a></p>

<p>My .pro looks like this:</p>

<pre><code>TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += main.cpp

win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlib
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlibd
else:unix: LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlib

INCLUDEPATH += $$PWD/../Savor_V100/includes/cryptopp562
DEPENDPATH += $$PWD/../Savor_V100/includes/cryptopp562
</code></pre>

<p>I have compiled the library with MS Visual Studio 2012. 
When I use these settings: <a href=""https://i.imgur.com/Nd9TEIA.png"" rel=""nofollow noreferrer"">http://i.imgur.com/Nd9TEIA.png</a></p>

<p>I get a single 50mb-ish .lib file. </p>

<p>When I then try to build my application in Qt Creator (5.0.2) I get the following:
<a href=""https://i.imgur.com/RbCGQDU.png"" rel=""nofollow noreferrer"">http://i.imgur.com/RbCGQDU.png</a></p>

<p>A lot of:</p>

<pre><code>cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for 'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in main.obj
</code></pre>

<p>It also says: File not found: cryptlib.lib(cryptlib.obj)</p>

<p>If I put the .obj files in the same folder as the .lib file I get rid of the ""file not found"" errors. But nothing else changes. </p>

<p>Could somebody please explain what I am doing wrong ? The LNK2038 info on the website does not help me:(</p>
","<p>Step 7 of the instructions you linked to <a href=""http://programmingknowledgeblog.blogspot.de/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow"">here</a> appear to be strange.  Normally you'd select <code>/MD</code> and <code>/MDd</code> for Release and Debug respectively, <em>or</em> you'd select <code>/MT</code> and <code>/MTd</code>.</p>

<p>The crux is that you have your Release build of crypto linked to the Dynamic version of the C Runtime Library (via <code>/MD</code>), but your test exe is set to link to the Static version (via <code>/MT</code>).</p>

<p>You should only link to a single version of the CRT - i.e. recompile crypto++ in Release mode with <code>/MT</code> set instead of <code>/MD</code>, or change your test exe to use <code>/MD</code>.</p>

<p>For further info on these flags, see the <a href=""http://msdn.microsoft.com/en-us/library/2kzt1wy3%28v=vs.110%29.aspx"" rel=""nofollow"">msdn docs</a>.</p>
","1732","<c++><visual-studio><qt><visual-c++><crypto++>","3","2","2","2018-02-23 01:47:46","17056183","0","1","608639","","2018-02-23 01:47:46","2013-06-12 00:35:21",""
"17055990","Crypto++ can't build Qt Application","<p>I am currently trying to run Crypto++ in my Qt Application. But it does not work. Hopefully somebody of you knows whats wrong, because I have not figured it out and I am on this for 3 days now. </p>

<p>To concentrate the problem, I have created a test app. Holding this code: <a href=""http://pastebin.com/1XMARtds"" rel=""nofollow noreferrer"">http://pastebin.com/1XMARtds</a> taken from <a href=""http://programmingknowledgeblog.blogspot.de/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow noreferrer"">http://programmingknowledgeblog.blogspot.de/2013/04/compiling-and-integrating-crypto-into.html</a></p>

<p>My .pro looks like this:</p>

<pre><code>TEMPLATE = app
CONFIG += console
CONFIG -= app_bundle
CONFIG -= qt

SOURCES += main.cpp

win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlib
else:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlibd
else:unix: LIBS += -L$$PWD/../Savor_V100/libraries/ -lcryptlib

INCLUDEPATH += $$PWD/../Savor_V100/includes/cryptopp562
DEPENDPATH += $$PWD/../Savor_V100/includes/cryptopp562
</code></pre>

<p>I have compiled the library with MS Visual Studio 2012. 
When I use these settings: <a href=""https://i.imgur.com/Nd9TEIA.png"" rel=""nofollow noreferrer"">http://i.imgur.com/Nd9TEIA.png</a></p>

<p>I get a single 50mb-ish .lib file. </p>

<p>When I then try to build my application in Qt Creator (5.0.2) I get the following:
<a href=""https://i.imgur.com/RbCGQDU.png"" rel=""nofollow noreferrer"">http://i.imgur.com/RbCGQDU.png</a></p>

<p>A lot of:</p>

<pre><code>cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for 'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in main.obj
</code></pre>

<p>It also says: File not found: cryptlib.lib(cryptlib.obj)</p>

<p>If I put the .obj files in the same folder as the .lib file I get rid of the ""file not found"" errors. But nothing else changes. </p>

<p>Could somebody please explain what I am doing wrong ? The LNK2038 info on the website does not help me:(</p>
","<p>Who wants to run crypto++ on linux(I did on ubuntu), after downloading library via apt-get install, should add to pro file this:<br>
LIBS += -L/usr/lib/crypto++ -lcrypto++
Good luck!</p>
","1732","<c++><visual-studio><qt><visual-c++><crypto++>","3","1","2","2018-02-23 01:47:46","17056183","0","1","608639","","2018-02-23 01:47:46","2013-06-12 00:35:21",""
"27195515","Spaces when converting byte array to hex std::string c++","<p>I am using the following function to convert a byte array (Crypto++ key) to a Hex String</p>

<pre><code>std::string Hexa::byte_to_hex_encoder(unsigned char *array, int len){
    std::stringstream ss;
    for(int i=0;i&lt;len;++i)
        ss &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt;std::setw(2) &lt;&lt;(int)array[i];
    return ss.str();
}
</code></pre>

<p>The byte array is of size 16 and when I don't use <code>setw(2)</code> I get a hex string with lesser characters like 30 or sometimes 31. When I am using <code>setw(2)</code> I get random spaces in the hex string like</p>

<blockquote>
  <p>5CA0 138C5487D2C6D929EC36B694890</p>
</blockquote>

<p>How can I convert a byte array to hex string and vice versa without spaces in the hex string?</p>
","<p>You also need <code>setfill('0')</code> so that the numbers are properly padded.</p>

<p>Without the <code>setw</code>, a number like 7 comes out as just <code>7</code>, making your string short as you have seen. With the <code>setw</code> but no <code>setfill</code>, it's padded to the right <em>length,</em> but with a space.</p>

<p>Adding the <code>setfill</code> ensures it gets padded with zeroes.</p>

<p>For your code that would be:</p>

<pre><code>ss &lt;&lt; std::hex
   &lt;&lt; std::uppercase
   &lt;&lt; std::setw(2)
   &lt;&lt; std::setfill('0')
   &lt;&lt; (int)array[i];
</code></pre>
","1702","<c++><string><encoding><hex><crypto++>","1","3","2","2014-11-28 23:32:03","27195552","3","","608639","","2014-11-28 23:20:42","2014-11-28 20:29:34",""
"27195515","Spaces when converting byte array to hex std::string c++","<p>I am using the following function to convert a byte array (Crypto++ key) to a Hex String</p>

<pre><code>std::string Hexa::byte_to_hex_encoder(unsigned char *array, int len){
    std::stringstream ss;
    for(int i=0;i&lt;len;++i)
        ss &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt;std::setw(2) &lt;&lt;(int)array[i];
    return ss.str();
}
</code></pre>

<p>The byte array is of size 16 and when I don't use <code>setw(2)</code> I get a hex string with lesser characters like 30 or sometimes 31. When I am using <code>setw(2)</code> I get random spaces in the hex string like</p>

<blockquote>
  <p>5CA0 138C5487D2C6D929EC36B694890</p>
</blockquote>

<p>How can I convert a byte array to hex string and vice versa without spaces in the hex string?</p>
","<p>Since you have the Crypto++ tag, here's are two ways to do it in Crypto++. From the <a href=""http://www.cryptopp.com/wiki/Hexencoder"" rel=""nofollow"">HexEncoder</a> wiki page.</p>

<p>First, using Crypto++ <a href=""http://www.cryptopp.com/wiki/Pipeline"" rel=""nofollow"">pipelines</a>:</p>

<pre><code>byte decoded[] = { 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
                   0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
string encoded;

StringSource ss(decoded, sizeof(decoded), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>As with the previous example, a run produces the following output.</p>

<pre><code>$ ./cryptopp-test.exe
FFEEDDCCBBAA99887766554433221100
</code></pre>

<hr>

<p>And second, using functions:</p>

<pre><code>byte decoded[] = { 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88,
                   0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
string encoded;

HexEncoder encoder;
encoder.Put(decoded, sizeof(decoded));
encoder.MessageEnd();

word64 size = encoder.MaxRetrievable();
if(size)
{
    encoded.resize(size);       
    encoder.Get((byte*)encoded.data(), encoded.size());
}

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>A run of the above program produces the following output.</p>

<pre><code>$ ./cryptopp-test.exe
FFEEDDCCBBAA99887766554433221100
</code></pre>

<hr>

<p>There's a <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow"">HexDecoder</a> too so you can decode the encoded strings. It works nearly the same way.</p>
","1702","<c++><string><encoding><hex><crypto++>","1","0","2","2014-11-28 23:32:03","27195552","3","","608639","","2014-11-28 23:20:42","2014-11-28 20:29:34",""
"39586035","Exception thrown: write access violation. this was 0xDDDDDDDD","<p>I'm trying to encrypt a string using AES encryption provided by Crypto++ library API, version 5.6.0, linked statically</p>

<pre><code>string AESEncryptor::encrypt(const string&amp; plain)
{
    string ciphertext_buffer;

    // Hex decode symmetric key:
    HexDecoder decoder;
    decoder.Put((byte *)PRIVATE_KEY, 32 * 2);
    decoder.MessageEnd();
    word64 size = decoder.MaxRetrievable();
    char *decoded_key = new char[size];
    decoder.Get(reinterpret_cast&lt;byte*&gt;(decoded_key), size);

    // Generate Cipher, Key, and CBC
    byte key[AES::MAX_KEYLENGTH], iv[AES::BLOCKSIZE];
    StringSource(reinterpret_cast&lt;const char *&gt;(decoded_key), true, 
        new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)));
    memset(iv, 0x00, AES::BLOCKSIZE);

    CBC_Mode&lt;AES&gt;::Encryption Encryptor(key, sizeof(key), iv);
    StringSource(plain, true, 
        new StreamTransformationFilter(Encryptor, new HexEncoder(new StringSink(ciphertext_buffer))));
    return ciphertext_buffer;
}
</code></pre>

<p>On the function exit I'm receiving the following exception, while trying to call the std::string move constructor to return the value:</p>

<blockquote>
  <p>Exception thrown: write access violation. this was 0xDDDDDDDD.</p>
</blockquote>

<p>Looked like StringSink ""owns"" returned std::string some way and deletes it before trying to return, however I tried to assign it to another std::string and got the same exception.</p>

<p>Same exception appears while returning any other string, so it seems memory corrupted some way</p>
","<blockquote>
<pre><code>StringSource(plain, true, 
    new StreamTransformationFilter(Encryptor,
        new HexEncoder(new StringSink(ciphertext_buffer))));

return ciphertext_buffer;
</code></pre>
</blockquote>

<p>This code is mostly OK, but you should avoid the anonymous declarations.</p>

<blockquote>
<pre><code>Exception thrown: write access violation. this was 0xDDDDDDDD.
</code></pre>
</blockquote>

<p><a href=""https://stackoverflow.com/q/370195"">0xDDDDDDDD is the ""dead memory"" bit pattern</a>
There's quite a few issues with the code, and its hard to say which is causing you to use the dead memory. Maybe <code>PRIVATE_KEY</code> is smaller than <code>32 * 2</code> bytes?</p>

<p>You should do four things:</p>

<ul>
<li>Upgrade to <a href=""http://cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++ 5.6.4</a> (5.6.0 is from 2009)</li>
<li>Turn on memory checking with flags like <code>_CRTDBG_LEAK_CHECK_DF</code> (see <a href=""https://github.com/weidai11/cryptopp/blob/master/test.cpp#L139"" rel=""nofollow noreferrer""><code>test.cpp</code> and <code>main</code></a> for an example)</li>
<li>Stop using anonymous declarations (I've seen destructors run too soon because of them)</li>
<li>Use <a href=""http://cryptopp.com/wiki/CBC_Mode"" rel=""nofollow noreferrer"">EAX Mode</a> sample code from the <a href=""http://cryptopp.com/wiki/"" rel=""nofollow noreferrer"">Crypto++ wiki</a> as a starting point</li>
</ul>

<hr>

<blockquote>
<pre><code>// Generate Cipher, Key, and CBC
byte key[AES::MAX_KEYLENGTH], iv[AES::BLOCKSIZE];
StringSource(reinterpret_cast&lt;const char *&gt;(decoded_key), true, 
    new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)));
</code></pre>
</blockquote>

<p>Use <a href=""https://cryptopp.com/docs/ref/class_h_k_d_f.html"" rel=""nofollow noreferrer"">HKDF</a> from Crypto++ 5.6.3 and above.</p>

<hr>

<blockquote>
<pre><code>memset(iv, 0x00, AES::BLOCKSIZE);
</code></pre>
</blockquote>

<p>I believe this destroys some of CBC's security properties. You should use an <a href=""https://cryptopp.com/wiki/Authenticated_encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> mode. It relieves you of some of the details, like generating random IVs. It also has better security properties than CBC alone.</p>
","1693","<c++><aes><access-violation><crypto++>","0","0","1","2016-09-20 15:19:24","39597782","1","","608639","","2016-09-20 15:14:42","2016-09-20 05:03:45",""
"27138148","Saving key and iv to file AES implementation Crypto++","<p>So I am using the Crypto++ Library to encrypt a file. I need to save the key and iv for future use. I am following <a href=""http://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">this</a> tutorial. Here is my function :</p>

<pre><code>void AESUtil::encrypt(string filename,bool savekeys,string savefilename){
    AutoSeededRandomPool rnd;

    // Generate a random key
    byte key[AES::DEFAULT_KEYLENGTH];
    rnd.GenerateBlock(key, AES::DEFAULT_KEYLENGTH);

    // Generate a random IV
    byte iv[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv, AES::BLOCKSIZE);

    Binary b;
    string plaintext = b.decoder(filename);
    unsigned char *ciphertext= new unsigned char[plaintext.size()+1];
    ciphertext[plaintext.size()]='\0';
    if(savekeys){
        ofstream(""key.bin"", ios::binary).write((char*)key, sizeof(key));
    }
    CFB_Mode&lt;AES&gt;::Encryption cfbEncryption(key, AES::DEFAULT_KEYLENGTH, iv);
    cfbEncryption.ProcessData(ciphertext,reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()),plaintext.size()+1);
    ofstream outfile(savefilename.c_str());
    outfile.write((char*)ciphertext,sizeof(ciphertext));
}
</code></pre>

<p>The files contain data in �/���� format. I want to know the best method to save the key and iv programmatically which are a byte array to a file and the ciphertext which is a unsigned char* to a separate file.</p>
","<p>Your <code>key</code> and <code>iv</code> variables are the key and IV used to encrypt the plain text.</p>

<p>You didn't fill either; you're actually using an array filled with 0 bytes as both the key and IV for your encryption.</p>
","1673","<c++><aes><crypto++>","1","0","3","2018-03-08 18:39:07","","1","","2156877","","2014-12-05 05:11:01","2014-11-25 22:41:13",""
"27138148","Saving key and iv to file AES implementation Crypto++","<p>So I am using the Crypto++ Library to encrypt a file. I need to save the key and iv for future use. I am following <a href=""http://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">this</a> tutorial. Here is my function :</p>

<pre><code>void AESUtil::encrypt(string filename,bool savekeys,string savefilename){
    AutoSeededRandomPool rnd;

    // Generate a random key
    byte key[AES::DEFAULT_KEYLENGTH];
    rnd.GenerateBlock(key, AES::DEFAULT_KEYLENGTH);

    // Generate a random IV
    byte iv[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv, AES::BLOCKSIZE);

    Binary b;
    string plaintext = b.decoder(filename);
    unsigned char *ciphertext= new unsigned char[plaintext.size()+1];
    ciphertext[plaintext.size()]='\0';
    if(savekeys){
        ofstream(""key.bin"", ios::binary).write((char*)key, sizeof(key));
    }
    CFB_Mode&lt;AES&gt;::Encryption cfbEncryption(key, AES::DEFAULT_KEYLENGTH, iv);
    cfbEncryption.ProcessData(ciphertext,reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()),plaintext.size()+1);
    ofstream outfile(savefilename.c_str());
    outfile.write((char*)ciphertext,sizeof(ciphertext));
}
</code></pre>

<p>The files contain data in �/���� format. I want to know the best method to save the key and iv programmatically which are a byte array to a file and the ciphertext which is a unsigned char* to a separate file.</p>
","<p>The key could be saved in a separate file. Normally the key is established between sender / receiver in advance, or it is encrypted using a public key of the receiver. Note that it doesn't make sense to save the key next to the ciphertext, as it would provide no protection whatsoever. The handling of keys is called key management and entire books have been written about it.</p>

<p>The IV is a different animal. The IV should be randomly generated. For CFB it should at least be unique and identical at both sides. Usually the IV is simply prefixed to the ciphertext, it doesn't have to be kept secret. </p>
","1673","<c++><aes><crypto++>","1","1","3","2018-03-08 18:39:07","","1","","2156877","","2014-12-05 05:11:01","2014-11-25 22:41:13",""
"27138148","Saving key and iv to file AES implementation Crypto++","<p>So I am using the Crypto++ Library to encrypt a file. I need to save the key and iv for future use. I am following <a href=""http://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow"">this</a> tutorial. Here is my function :</p>

<pre><code>void AESUtil::encrypt(string filename,bool savekeys,string savefilename){
    AutoSeededRandomPool rnd;

    // Generate a random key
    byte key[AES::DEFAULT_KEYLENGTH];
    rnd.GenerateBlock(key, AES::DEFAULT_KEYLENGTH);

    // Generate a random IV
    byte iv[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv, AES::BLOCKSIZE);

    Binary b;
    string plaintext = b.decoder(filename);
    unsigned char *ciphertext= new unsigned char[plaintext.size()+1];
    ciphertext[plaintext.size()]='\0';
    if(savekeys){
        ofstream(""key.bin"", ios::binary).write((char*)key, sizeof(key));
    }
    CFB_Mode&lt;AES&gt;::Encryption cfbEncryption(key, AES::DEFAULT_KEYLENGTH, iv);
    cfbEncryption.ProcessData(ciphertext,reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()),plaintext.size()+1);
    ofstream outfile(savefilename.c_str());
    outfile.write((char*)ciphertext,sizeof(ciphertext));
}
</code></pre>

<p>The files contain data in �/���� format. I want to know the best method to save the key and iv programmatically which are a byte array to a file and the ciphertext which is a unsigned char* to a separate file.</p>
","<p>The IV is public information. You don't need to hide it. Save it the way you want.</p>

<p>The KEY is what you must keep safe. To do that you may decide how much effort you want to put on it to hide it from the external factors.</p>

<ul>
<li>I have some keys that I don't care to leave them as a ""plain text"" in the binary code. (NO SECURITY, but my mom can't figure out what to do, but a beginner in reverse engineer will laugh at it.)</li>
<li>Some keys I do a play with the bytes, like inverting parts, separating them, XOR with something. (Very unsafe, but better than nothing, a programmer with decent knowledge in reverse engineering will be able to spend some time and eventually break the security)</li>
<li>Some other cases I use 3rd party advanced obfuscation... If possible, depending on what you want, you may even replace your encryption engine with some ""white-box"" cryptography. Then you will have your keys very well protected. But this is usually hard/expensive. It doesn't seem to be your case. (Yes, even a very advanced assembly guru will not be happy to start reverse engineer this case.)</li>
</ul>

<p>Another solution, if you don't need the key on your binary, is to give it to the system's password manager. On Windows, it's called ""Data Protection API"", and on Mac, it's called ""Keychain"". Take a look at these, and then you will understand why this is considered security. But it's because all the passwords here are encrypted with the ""user password"" so nothing is stored ""on disk"". A turned-off device in this scenario is considered very secure.</p>
","1673","<c++><aes><crypto++>","1","0","3","2018-03-08 18:39:07","","1","","2156877","","2014-12-05 05:11:01","2014-11-25 22:41:13",""
"16576434","Crypto++ and Compressed EC keys","<p>How can I generate compressed ECDSA keys in Crypto++? </p>

<pre><code>AutoSeededRandomPool prng;
ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey;
privateKey.Initialize( prng, CryptoPP::ASN1::secp256r1());

const Integer&amp; x1 = privateKey.GetPrivateExponent();
cout &lt;&lt; ""priv:  "" &lt;&lt; std::hex &lt;&lt; x1 &lt;&lt; endl;
privateKey.MakePublicKey( publicKey );
const ECP::Point&amp; q = publicKey.GetPublicElement();
const Integer&amp; qx = q.x;
const Integer&amp; qy = q.y;
cout &lt;&lt; ""pub x: "" &lt;&lt; std::hex &lt;&lt; qx &lt;&lt; endl;
cout &lt;&lt; ""pub y: "" &lt;&lt; std::hex &lt;&lt; qy &lt;&lt; endl;
</code></pre>

<p>This code generates a keypair and prints the X and Y components of the public key.</p>

<p>I need to know if there is a way to print the Y component of the compressed key, or if I need to generate it from the uncompressed y component. If I need to generate it, can someone link me to a good explanation of how to work with the Integer class?</p>
","<blockquote>
  <p>How can I generate compressed ECDSA keys in CryptoPP? </p>
</blockquote>

<p>You don't create a compressed key. You generate a public key, and then you compress it if that's what is required. From <a href=""https://groups.google.com/d/msg/cryptopp-users/f1XFx9CqUyg/inqFGB5O580J"" rel=""nofollow"">How to construct a public ECDSA key with point compression turned on?</a> on the Crpyto++ user group:</p>

<pre><code>ECDSA&lt;ECP, SHA1&gt;::Verifier verifier(...);
verifier.AccessKey().AccessGroupParameters().SetPointCompression(true); 
</code></pre>

<p>In your case, it will be:</p>

<pre><code>publicKey.AccessGroupParameters().SetPointCompression(true);
</code></pre>

<p>since <code>verifier.AccessKey()</code> returns the ECDSA public key.</p>

<hr>

<blockquote>
  <p>I need to know if there is a way to print the Y component of the compressed key</p>
</blockquote>

<p>Compression is a presentation format option or optimization. You can't print the Y component on a serialized key with compression because its not there (see the ASN.1 dumps below).</p>

<p>With compression on, the Y ""shorthand"" is going to be 1 or -1, depending on the sign of the component (the sign indicates what quadrant the point is in). The idea is someone sends you a {1,X} pair or {-1,X} pair and you can solve for Y because you know which quadrant it should be in. If Y is only allowed to be positive, you only need to serialize {X} (and not {-1,X} or {1,X}). (I did not dive into the books or standards, so there may be some errata here).</p>

<hr>

<blockquote>
  <p>... or if I need to generate it from the uncompressed y component. If I need to generate it, can someone link me to a good explanation of how to work with the Integer class?</p>
</blockquote>

<p>I have no idea what you're talking about at here. Point compression affects presentation. If you turn on point compression and fetch Y, you will still get Y out. You can't compute on a compressed point. You need the X and Y coordinates.</p>

<hr>

<p>Add the following to your program:</p>

<pre><code>publicKey.AccessGroupParameters().SetPointCompression(false);
ByteQueue q1;
publicKey.Save(q1);
cout &lt;&lt; ""Uncompressed size: "" &lt;&lt; dec &lt;&lt; q1.MaxRetrievable() &lt;&lt; endl;

publicKey.AccessGroupParameters().SetPointCompression(true);
ByteQueue q2;
publicKey.Save(q2);
cout &lt;&lt; ""Compressed size: "" &lt;&lt; dec &lt;&lt; q2.MaxRetrievable() &lt;&lt; endl;
</code></pre>

<p>Here's what I got for the output:</p>

<pre><code>$ ./cryptopp-test.exe
priv:  4ce30d22d9593d9c7f4406eda1ce0740c7486106374d0abe7e352e1d5b1d5622h
pub x: 41a9bc936b6d1dd3a1ded997d7da08f1df990e9b50f9b58e9e4fd9319758ea34h
pub y: 4ad39ffb79c402063a99ecbc0cac8fde606db6764ace90933feee5f8d65937a2h
Uncompressed size: 311
Compressed size: 246
</code></pre>

<p>If you fetch Y after turning on point compression, you will still get 4ad39ffb79c402063a99ecbc0cac8fde606db6764ace90933feee5f8d65937a2h because compression affects presentation.</p>

<hr>

<p>Now, add the following to dump the uncompressed and compressed key:</p>

<pre><code>FileSink fs1(""key-1.der"", true);
q1.TransferTo(fs1);

FileSink fs2(""key-2.der"", true);
q2.TransferTo(fs2);
</code></pre>

<p>The keys are dumped in ASN.1's DER encoding and conform to Certicom's <a href=""http://www.secg.org/collateral/sec1_final.pdf"" rel=""nofollow"">SEC 1: Elliptic Curve Cryptography</a> (and to a lesser extent, <a href=""ftp://ftp.iks-jena.de/mitarb/lutz/standards/ansi/X9/x962-11-17-97.pdf"" rel=""nofollow"">ANSI 9.62</a> and <a href=""http://www.ietf.org/rfc/rfc5480.txt"" rel=""nofollow"">RFC 5480, ECC SubjectPublicKeyInfo Format</a> - see below on the Field Element's <code>OCTET STRING</code> vs <code>BIT STRING</code>).</p>

<p>You can run Peter Gutmann's <a href=""http://www.cs.auckland.ac.nz/~pgut001/dumpasn1.c%E2%80%8E"" rel=""nofollow""><code>dumpasn1</code></a> on them:</p>

<pre><code>$ dumpasn1.exe key-1.der 
  0 307: SEQUENCE {
  4 236:   SEQUENCE {
  7   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 16 224:     SEQUENCE {
 19   1:       INTEGER 1
 22  44:       SEQUENCE {
 24   7:         OBJECT IDENTIFIER prime-field (1 2 840 10045 1 1)
 33  33:         INTEGER
       :           00 FF FF FF FF 00 00 00 01 00 00 00 00 00 00 00
       :           00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF
       :           FF
       :         }
 68  68:       SEQUENCE {
 70  32:         OCTET STRING
       :           FF FF FF FF 00 00 00 01 00 00 00 00 00 00 00 00
       :           00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FC
104  32:         OCTET STRING
       :           5A C6 35 D8 AA 3A 93 E7 B3 EB BD 55 76 98 86 BC
       :           65 1D 06 B0 CC 53 B0 F6 3B CE 3C 3E 27 D2 60 4B
       :         }
138  65:       OCTET STRING
       :         04 6B 17 D1 F2 E1 2C 42 47 F8 BC E6 E5 63 A4 40
       :         F2 77 03 7D 81 2D EB 33 A0 F4 A1 39 45 D8 98 C2
       :         96 4F E3 42 E2 FE 1A 7F 9B 8E E7 EB 4A 7C 0F 9E
       :         16 2B CE 33 57 6B 31 5E CE CB B6 40 68 37 BF 51
       :         F5
205  33:       INTEGER
       :         00 FF FF FF FF 00 00 00 00 FF FF FF FF FF FF FF
       :         FF BC E6 FA AD A7 17 9E 84 F3 B9 CA C2 FC 63 25
       :         51
240   1:       INTEGER 1
       :       }
       :     }
243  66:   BIT STRING
       :     04 41 A9 BC 93 6B 6D 1D D3 A1 DE D9 97 D7 DA 08
       :     F1 DF 99 0E 9B 50 F9 B5 8E 9E 4F D9 31 97 58 EA
       :     34 4A D3 9F FB 79 C4 02 06 3A 99 EC BC 0C AC 8F
       :     DE 60 6D B6 76 4A CE 90 93 3F EE E5 F8 D6 59 37
       :     A2
       :   }

$ dumpasn1.exe key-2.der 
  0 243: SEQUENCE {
  3 204:   SEQUENCE {
  6   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 15 192:     SEQUENCE {
 18   1:       INTEGER 1
 21  44:       SEQUENCE {
 23   7:         OBJECT IDENTIFIER prime-field (1 2 840 10045 1 1)
 32  33:         INTEGER
       :           00 FF FF FF FF 00 00 00 01 00 00 00 00 00 00 00
       :           00 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF
       :           FF
       :         }
 67  68:       SEQUENCE {
 69  32:         OCTET STRING
       :           FF FF FF FF 00 00 00 01 00 00 00 00 00 00 00 00
       :           00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FC
103  32:         OCTET STRING
       :           5A C6 35 D8 AA 3A 93 E7 B3 EB BD 55 76 98 86 BC
       :           65 1D 06 B0 CC 53 B0 F6 3B CE 3C 3E 27 D2 60 4B
       :         }
137  33:       OCTET STRING
       :         03 6B 17 D1 F2 E1 2C 42 47 F8 BC E6 E5 63 A4 40
       :         F2 77 03 7D 81 2D EB 33 A0 F4 A1 39 45 D8 98 C2
       :         96
172  33:       INTEGER
       :         00 FF FF FF FF 00 00 00 00 FF FF FF FF FF FF FF
       :         FF BC E6 FA AD A7 17 9E 84 F3 B9 CA C2 FC 63 25
       :         51
207   1:       INTEGER 1
       :       }
       :     }
210  34:   BIT STRING
       :     02 41 A9 BC 93 6B 6D 1D D3 A1 DE D9 97 D7 DA 08
       :     F1 DF 99 0E 9B 50 F9 B5 8E 9E 4F D9 31 97 58 EA
       :     34
       :   }
</code></pre>

<p>Notice the differences:</p>

<pre><code># key-1.der
243  66:   BIT STRING
       :     04 41 A9 BC 93 6B 6D 1D D3 A1 DE D9 97 D7 DA 08
       :     F1 DF 99 0E 9B 50 F9 B5 8E 9E 4F D9 31 97 58 EA
       :     34 4A D3 9F FB 79 C4 02 06 3A 99 EC BC 0C AC 8F
       :     DE 60 6D B6 76 4A CE 90 93 3F EE E5 F8 D6 59 37
       :     A2
</code></pre>

<p>versus:</p>

<pre><code># key-2.der
210  34:   BIT STRING
       :     02 41 A9 BC 93 6B 6D 1D D3 A1 DE D9 97 D7 DA 08
       :     F1 DF 99 0E 9B 50 F9 B5 8E 9E 4F D9 31 97 58 EA
       :     34
       :   }
</code></pre>

<p>The first has two Integers encoded, while the second has one Integer encoded. The common value is <code>41 A9 BC 93 ... 97 58 EA 34</code>, and that's your <code>pub x</code> above. The missing string from key-2 is <code>4A D3 9F FB ... D6 59 37 A2</code>, and that's the <code>pub y</code> above. For completeness, the values are encoded as either {X,Y} or {X}, and not ASN.1's encoding of integers.</p>

<p>The final difference is the <strong>first</strong> octet of the BIT STRING: 02 versus 04 (or 03). 04 indicates its an uncompressed point. From RFC 5480, Section 2.2:</p>

<blockquote>
<pre><code>    The first octet of the OCTET STRING indicates whether the key is
    compressed or uncompressed.  The uncompressed form is indicated
    by 0x04 and the compressed form is indicated by either 0x02 or
    0x03 (see 2.3.3 in [SEC1]).  The public key MUST be rejected if
    any other value is included in the first octet.
</code></pre>
</blockquote>

<p>And after looking at the standard and section 2.2, Crypto++ may have a bug: its writing a <code>BIT STRING</code>, but the standard is clearly discussing a <code>OCTET STRING</code>.</p>

<p><strong>EDIT 1</strong>: It appears this is a Crypto++ bug under <a href=""ftp://ftp.iks-jena.de/mitarb/lutz/standards/ansi/X9/x962-11-17-97.pdf"" rel=""nofollow"">ANSI 9.62</a>, too. Section 6.2,  Syntax for Finite Field Elements and Elliptic Curve Points (p. 20)</p>

<blockquote>
<pre><code>    A finite field element shall be represented by a value of type FieldElement:
      FieldElement ::= OCTET STRING
    The value of FieldElement shall be the octet string representation of a field
    elementfollowing the conversion routine in Section 4.3.1.
    An elliptic curve point shall be represented by a value of type ECPoint:
      ECPoint ::= OCTET STRING
</code></pre>
</blockquote>

<p><strong>EDIT 2</strong>: Crypto++ is using the format specified by Certicom's <a href=""http://www.secg.org/collateral/sec1_final.pdf"" rel=""nofollow"">SEC 1: Elliptic Curve Cryptography</a>. Appendix C (page 77) states:</p>

<blockquote>
<pre><code>    Finally, a specific field element is represented by the following type
      FieldElement ::= OCTET STRING
    whose value is the octet string obtained from the conversion routines
    given in Section 2.3.5.
</code></pre>
</blockquote>
","1670","<c++><crypto++>","2","4","1","2016-12-22 05:42:22","19131865","0","1","608639","","2016-12-22 05:42:22","2013-05-15 23:06:25",""
"33603141","BER decode error when loading key","<p>I've been working on digital signer and verifier using Crypto++. I ancountered the following problem: my signer and verifier work well on the public and private keys I generated programmatically using the first example (Generate an RSA keypair and save it) from this <a href=""http://www.cryptopp.com/wiki/User_Guide:_rsa.h"" rel=""nofollow"">wiki</a>. But when I use another test key pair I was provided to test, I have the following error: ""BER decode error"" when trying to load key for signing. I've been searching the Internet, but can not manage to solve the problem. Here are my classes:</p>

<pre><code>class DSUtility
{
protected:
    DSUtility() = default;
    template&lt;typename KeyType, typename KeySourceType&gt;
    KeyType PrepareKey_(const std::string&amp; key_source);     
};

template&lt;typename KeyType, typename KeySourceType&gt;
KeyType DSUtility::PrepareKey_(const std::string&amp; key_source)
{
    CryptoPP::ByteQueue key_bytes;
    KeySourceType(key_source.c_str(), true, new CryptoPP::Base64Decoder).TransferTo(key_bytes);
    key_bytes.MessageEnd();
    KeyType key;
    key.Load(key_bytes); // FAILS WHEN TRYING TO SIGN WITH ANOTHER PRIVATE KEY
    return key;
}


class Signer : private DSUtility
{
public:     
    Signer(const std::string&amp; private_key);

    std::string Sign(const std::string&amp; data);

private:
    typedef CryptoPP::RSA::PrivateKey PrivateKey;
    CryptoPP::RSASS&lt;CryptoPP::PKCS1v15, CryptoPP::SHA256&gt;::Signer signer_;
};


Signer::Signer(const std::string&amp; private_key) :
signer_(PrepareKey_&lt;PrivateKey, CryptoPP::StringSource&gt;(private_key))
{
}

std::string Signer::Sign(const std::string&amp; data)
{
    CryptoPP::SecByteBlock signature(signer_.SignatureLength());
    signer_.SignMessage(CryptoPP::AutoSeededRandomPool(), (byte const*)data.c_str(), data.size(), signature);
    return std::string(signature.begin(), signature.end());
}
</code></pre>

<p>one of my keys (that works) looks like this:</p>

<pre><code>MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAILkZnFV77ckeZkepDk1fvsE
qli05im29PTZq0ayWZsSgis+tpzP2KpSigWimAfkOCF36Y1Zb9E8VcxBaRbEEH0ObQTQdOl0
z1Cf0mViD2dQgH+8ZucU2gKy0YDpjIJ6wZM55azNZBg1s5J9PuDyM+nMRh5RiJqEpaXSXzgV...
</code></pre>

<p>another one looks the following:</p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIICXAIBAAKBgQDGwB5n/xMsDoqo+bGaws15FYGGjsJxCM2deHJZqV2QKfvkmStf
8HntPqaJ+mc9UA6ghN1uGndChg1PuHSNVaRU2x8fem/mFUhfOJaZcYich8JAy0nm
sJUOwoRqLfKjLWmqy0QZHXDDVw+sD5uq/oOvfFFjuYIcsskHQmGTfkdJrQIDAQAB...
</code></pre>
","<blockquote>
  <p>But when I use another test key pair I was provided to test, I have the following error: ""BER decode error"" when trying to load key for signing.</p>
</blockquote>

<p>Its hard to say what's going wrong... You should provide <strong><em>real</em></strong> test keys. Its not worth the time to try and decode a fake on with ""..."" in it because we know it will fail.</p>

<p>I'm just guessing, but it might be a raw key (i.e., just the public or private key, without the identifier) rather than a key info (i.e., the outer sequence and identifier with the inner public or private key). The latter (the key info) is sometimes called a <strong><em><code>subjectPublicKeyIdnfo</code></em></strong> when its a public key.</p>

<p>You might want to take a look at <a href=""http://cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow noreferrer"">Keys and Formats</a> on the Crypto++ wiki. The guide you cited is kind of old, and its provided for historical purposes. Here's the 3-second tour:</p>

<ul>
<li>When you load a <strong><em><code>raw key</code></em></strong>, call <code>BERDecode</code></li>
<li>When you load a <strong><em><code>key info</code></em></strong>, call <code>Load</code></li>
<li>When you save a <strong><em><code>raw key</code></em></strong>, call <code>DEREecode</code></li>
<li>When you save a <strong><em><code>key info</code></em></strong>, call <code>Save</code></li>
</ul>

<hr>

<blockquote>
<pre><code>template&lt;typename KeyType, typename KeySourceType&gt; KeyType 
DSUtility::PrepareKey_(const std::string&amp; key_source)
{
    CryptoPP::ByteQueue key_bytes;
    KeySourceType(key_source.c_str(), true, new CryptoPP::Base64Decoder).TransferTo(key_bytes);
    key_bytes.MessageEnd();
    KeyType key;
    key.Load(key_bytes); // FAILS WHEN TRYING TO SIGN WITH ANOTHER PRIVATE KEY
    return key;
}
</code></pre>
</blockquote>

<p>This can probably be simplified a bit:</p>

<pre><code>template&lt;typename KeyType, typename KeySourceType&gt; KeyType 
DSUtility::PrepareKey_(const std::string&amp; key_source)
{
    ArraySource as((const byte*)key_source.data(), key_source.size(),
                                true, new Base64Decoder());
    key.Load(as);
    return key;
}
</code></pre>

<p>And if its a <strong><em><code>raw key</code></em></strong>, you might try:</p>

<pre><code>key.BERDecode(as);
</code></pre>

<hr>

<blockquote>
  <p><em>""... another one looks the following: <code>-----BEGIN RSA PRIVATE KEY-----</code>...""</em></p>
</blockquote>

<p>For the PEM encoded keys, see <a href=""https://cryptopp.com/wiki/Pem_Pack"" rel=""nofollow noreferrer"">PEM Pack</a> on the Crypto++ wiki.</p>

<p>Here's a reference to a Stack Overflow question, but it just cites the Crypto++ wiki page (in addition to other answers): <a href=""https://stackoverflow.com/q/9815001"">Load PEM encoded private RSA key in Crypto++</a>.</p>

<hr>

<blockquote>
  <p>FAILS WHEN TRYING TO SIGN WITH ANOTHER PRIVATE KEY</p>
</blockquote>

<p>Also, ""fails when trying to sign another private key"" is different than ""fails when trying to load"". I tried to stay focused on the question you asked, so it may not be the answer you were hoping for.</p>

<p>After you spend some time on Stack Overflow, you might grow weary of people who answer the question they hoped it would be <strong><em>rather than</em></strong> the question that was actually asked. I got tired of it very quickly, so I attempt to stay very focused when answering (its the reason I cite everything I answer, even if its a comment).</p>
","1652","<c++><rsa><digital-signature><crypto++>","0","1","1","2015-11-10 12:22:44","","2","","2091997","","2015-11-09 05:47:20","2015-11-09 05:41:43",""
"23400054","What is the difference between FileSink, StringSink, Filesource, StringSource Crypto++","<p>I am reading in an image, encrypting it, then decrypting it. The goal is to be looping this eventually and recording the time it takes for the process to complete. Currently what I have it reads the file in, then it encrypts it, encrypts it, the creates another file based on the recovered data. I don't need to make another file with the decrypted picture. Previously I had been using <code>StringSource</code> and <code>StringSink</code>, but that only worked for text files. I received some help at <a href=""https://stackoverflow.com/questions/23354548/how-to-read-an-image-to-a-string-for-encrypting-crypto/23355279#23355279"">How to read an image to a string for encrypting Crypto++</a> from and started using <code>FileSink</code> and <code>FileSource</code>. </p>

<p>What exactly is the difference between <code>FileSink</code>, <code>StringSink</code>, <code>FileSource</code> and <code>StringSource</code> ?</p>

<p>Also, in following example, why does cipher need to be set to something? Previously when I was just using <code>StringSource</code>, my string cipher was not initialized, but now that I am using <code>FileSource</code>, it needs to be initialized for it to work.</p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng_blowfish;

    SecByteBlock key_blowfish(Blowfish::DEFAULT_KEYLENGTH);
    prng_blowfish.GenerateBlock(key_blowfish, key_blowfish.size());

    byte iv_blowfish[Blowfish::BLOCKSIZE];
    prng_blowfish.GenerateBlock(iv_blowfish, sizeof(iv_blowfish));

    string ifilename = ""sample_files/1MB.jpg"";
    string cipher = ""1MB.enc"";
    string rfilename = ""r1MB.jpg"";

    try
    {
        EAX&lt;Blowfish&gt;::Encryption e_blowfish;
        e_blowfish.SetKeyWithIV(key_blowfish, key_blowfish.size(), iv_blowfish, sizeof(iv_blowfish));

        std::ifstream ifile(ifilename.c_str(), ios::binary);
        std::ifstream::pos_type size = ifile.seekg(0, std::ios_base::end).tellg();
        ifile.seekg(0, std::ios_base::beg);

        FileSource fs1(ifilename.c_str(), true, new AuthenticatedEncryptionFilter(e_blowfish, new FileSink(cipher.c_str())));

        EAX&lt;Blowfish&gt;::Decryption d_blowfish;
        d_blowfish.SetKeyWithIV(key_blowfish, key_blowfish.size(), iv_blowfish, sizeof(iv_blowfish));

        FileSource fs2(cipher.c_str(), true, new AuthenticatedDecryptionFilter(d_blowfish, new FileSink(rfilename.c_str()), AuthenticatedDecryptionFilter::THROW_EXCEPTION));
    }
    catch (const Exception&amp; ex)
    {
        cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
","<blockquote>
  <p>What exactly is the difference between FileSink, StringSink, FileSourcem StringSource.</p>
</blockquote>

<p>Sources, Filters and Sinks are part of the Pipeline design in Crypto++. Data flows from a source, is transformed by filters, and then ends at a sink.</p>

<p>All sources are interchangeable. All filters are interchangeable. And all sinks are interchangeable. For example, to switch between a <code>StringSink</code> and <code>FileSink</code>, you need to supply a filename with a <code>FileSink</code>. Otherwise, they operate the same. As another example, you can switch between a <code>HexEncoder</code> and <code>Base64Encoder</code> with no changes. As a final example, a <code>SocketSource</code> or <code>SocketSink</code> are going to need an IP address and port. What may (or may not) need to be changed depends on the object.</p>

<p>There are a number of sources. From <a href=""http://www.cryptopp.com/docs/ref/class_source.html"" rel=""nofollow"">Source Class Reference</a>:</p>

<ul>
<li><code>FileSource</code></li>
<li><code>StringSource</code></li>
<li><code>RandomNumberSource</code></li>
<li><code>WindowPipeSource</code></li>
<li><code>SocketSource</code></li>
</ul>

<p>There are a number of filters. You are using two of them - <code>AuthenticatedEncryptionFilter</code> and <code>AuthenticatedDecryptionFilter</code>. From <a href=""http://www.cryptopp.com/docs/ref/class_filter.html"" rel=""nofollow"">Filter Class Reference</a> and <a href=""http://www.cryptopp.com/docs/ref/class_filter_with_buffered_input.html"" rel=""nofollow"">FilterWithBufferedInput Class Reference</a>:</p>

<ul>
<li><code>HexEncoder</code></li>
<li><code>HexEncoder</code></li>
<li><code>Base32Encoder</code></li>
<li><code>Base32Decoder</code></li>
<li><code>Base64Encoder</code></li>
<li><code>Base64Encoder</code></li>
<li><code>DefaultEncryptor</code></li>
<li><code>DefaultEncryptorWithMAC</code></li>
<li><code>DefaultDecryptor</code></li>
<li><code>DefaultDecryptorWithMAC</code></li>
<li>...</li>
<li><code>StreamTransformationFilter</code></li>
<li><code>AuthenticatedEncryptionFilter</code></li>
<li><code>AuthenticatedDecryptionFilter</code></li>
</ul>

<p>There are a number of sinks. From <a href=""http://www.cryptopp.com/docs/ref/class_sink.html"" rel=""nofollow"">Sink Class Reference</a>:</p>

<ul>
<li><code>ArraySink</code></li>
<li><code>BitBucket</code></li>
<li><code>RandomNumberSink</code></li>
<li><code>StringSink</code></li>
<li><code>FileSink</code></li>
<li><code>SocketSink</code></li>
<li>...</li>
</ul>

<p>There are some advanced topics, but I don't think they matter at the moment. For example, the role of <code>BufferedTransformation</code> and what it means if <code>Attachable</code> returns <code>true</code>. The answer is both Filters and Sinks are <code>BufferedTransformation</code>'s, and <code>Attachable = true</code> means its a Filter (otherwise its a Sink).</p>

<hr>

<blockquote>
  <p>... in following example, why does cipher need to be set to something...</p>
</blockquote>

<p>A <code>StringSource</code> and <code>StringSink</code> needs nothing because its just an array of byes in memory. A <code>FileSource</code> and <code>FileSink</code> needs a filename, and you are using <code>cipher</code> for the filename. You <em>have</em> to supply a filename because the objects a file/stream related. If you were using a <code>SocketSource</code> or <code>SocketSink</code>, then you would need to supply an IP address and port (more correctly, a <code>socket_t</code>). </p>

<p>Here are the <code>FileSource</code> constructors from <a href=""http://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow"">FileSource Class Reference</a>. You are using the third constructor in your code.</p>

<pre><code>FileSource (BufferedTransformation *attachment=NULL)
FileSource (std::istream &amp;in, bool pumpAll, BufferedTransformation *attachment=NULL)
FileSource (const char *filename, bool pumpAll, BufferedTransformation *attachment=NULL, bool binary=true)
</code></pre>

<p>Here are the <code>FileSink</code> constructors from <a href=""http://www.cryptopp.com/docs/ref/class_file_sink.html"" rel=""nofollow"">FileSink Class Reference</a>. You are using the second constructor in your code.</p>

<pre><code>FileSink (std::ostream &amp;out)
FileSink (const char *filename, bool binary=true)
</code></pre>
","1634","<c++><encryption><file-io><binaryfiles><crypto++>","1","1","1","2018-09-26 07:02:28","23400493","1","","2509078","","2018-09-26 07:02:28","2014-04-30 23:56:14",""
"7847835","How to configure Crypto++ in Eclipse?","<p>I want to use Crypto++ in Eclipse.
I've installed it correctly but I dunno why it cannot find the path.</p>

<pre><code>using namespace CryptoPP;

Symbol CryptoPP cannot be resolved
</code></pre>

<p>and if I use #include ""aes.h"", for example is an unresolved inclusion.</p>

<p>How can I solve this?</p>
","<p>You have to set the include paths for your project.</p>

<p>Assuming you are using CDT go to ""Project->Properties->C/C++ Build->Settings"" and now in your configured compiler to ""Includes"" and add the path to your library. The same has to be done for your linker with ""Libraries"".</p>
","1615","<c++><crypto++>","1","1","1","2011-10-21 10:08:28","7847909","1","0","746961","","2011-10-21 10:05:45","2011-10-21 10:01:42",""
"29755261","Get SHA1 of Unicode string in Crypto++","<p>I study C++ independently and I have one problem, which I can't solve more than week. I hope you can help me.</p>

<p>I need to get a SHA1 digest of a Unicode string (like <code>Привет</code>), but I don't know how to do that.</p>

<p>I tried to do it like this, but it returns a wrong digest!</p>

<p>For <code>wstring('Ы')</code>
It returns - <code>A469A61DF29A7568A6CC63318EA8741FA1CF2A7</code> <br/>
I need - <code>8dbe718ab1e0c4d75f7ab50fc9a53ec4f0528373</code></p>

<p>Regards and sorry for my English :).</p>

<p>CryptoPP 5.6.2
MVC++ 2013</p>

<pre><code>#include &lt;iostream&gt;
#include ""cryptopp562\cryptlib.h""
#include ""cryptopp562\sha.h""
#include ""cryptopp562\hex.h""

int main() {

    std::wstring string(L""Ы"");
    int bs_size = (int)string.length() * sizeof(wchar_t);

    byte* bytes_string = new byte[bs_size];

    int n = 0; //real bytes count
    for (int i = 0; i &lt; string.length(); i++) {
        wchar_t wcharacter = string[i];

        int high_byte = wcharacter &amp; 0xFF00;

        high_byte = high_byte &gt;&gt; 8;

        int low_byte = wcharacter &amp; 0xFF;

        if (high_byte != 0) {
            bytes_string[n++] = (byte)high_byte;
        }

        bytes_string[n++] = (byte)low_byte;
    }

    CryptoPP::SHA1 sha1;
    std::string hash;

    CryptoPP::StringSource ss(bytes_string, n, true,
        new CryptoPP::HashFilter(sha1,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(hash)
            ) 
        ) 
    );

    std::cout &lt;&lt; hash &lt;&lt; std::endl;

    return 0;
}
</code></pre>
","<p>This seems to work fine for me.</p>

<p>Rather than fiddling about trying to extract the pieces I simply cast the wide character buffer to a <code>const byte*</code> and pass that (and the adjusted size) to the hash function.</p>

<pre><code>int main() {

    std::wstring string(L""Привет"");

    CryptoPP::SHA1 sha1;
    std::string hash;

    CryptoPP::StringSource ss(
        reinterpret_cast&lt;const byte*&gt;(string.c_str()), // cast to const byte*
        string.size() * sizeof(std::wstring::value_type), // adjust for size
        true,
        new CryptoPP::HashFilter(sha1,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(hash)
            )
        )
    );

    std::cout &lt;&lt; hash &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>C6F8291E68E478DD5BD1BC2EC2A7B7FC0CEE1420
</code></pre>

<p><strong>EDIT:</strong> To add.</p>

<p>The result is going to be <code>encoding</code> dependant. For example I ran this on <code>Linux</code> where <code>wchar_t</code> is 4 bytes. On <code>Windows</code> I believe <code>wchar_t</code> may be only 2 bytes.</p>

<p>For consistency it may be better to use UTF8 a store the text in a normal <code>std::string</code>. This also makes calling the API simpler:</p>

<pre><code>int main() {

    std::string string(""Привет""); // UTF-8 encoded

    CryptoPP::SHA1 sha1;
    std::string hash;

    CryptoPP::StringSource ss(
        string,
        true,
        new CryptoPP::HashFilter(sha1,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(hash)
            )
        )
    );

    std::cout &lt;&lt; hash &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>2805AE8E7E12F182135F92FB90843BB1080D3BE8
</code></pre>
","1612","<c++><unicode><sha1><crypto++><digest>","5","2","3","2015-04-24 19:07:44","29780517","1","","608639","","2015-04-24 04:49:01","2015-04-20 18:08:59",""
"29755261","Get SHA1 of Unicode string in Crypto++","<p>I study C++ independently and I have one problem, which I can't solve more than week. I hope you can help me.</p>

<p>I need to get a SHA1 digest of a Unicode string (like <code>Привет</code>), but I don't know how to do that.</p>

<p>I tried to do it like this, but it returns a wrong digest!</p>

<p>For <code>wstring('Ы')</code>
It returns - <code>A469A61DF29A7568A6CC63318EA8741FA1CF2A7</code> <br/>
I need - <code>8dbe718ab1e0c4d75f7ab50fc9a53ec4f0528373</code></p>

<p>Regards and sorry for my English :).</p>

<p>CryptoPP 5.6.2
MVC++ 2013</p>

<pre><code>#include &lt;iostream&gt;
#include ""cryptopp562\cryptlib.h""
#include ""cryptopp562\sha.h""
#include ""cryptopp562\hex.h""

int main() {

    std::wstring string(L""Ы"");
    int bs_size = (int)string.length() * sizeof(wchar_t);

    byte* bytes_string = new byte[bs_size];

    int n = 0; //real bytes count
    for (int i = 0; i &lt; string.length(); i++) {
        wchar_t wcharacter = string[i];

        int high_byte = wcharacter &amp; 0xFF00;

        high_byte = high_byte &gt;&gt; 8;

        int low_byte = wcharacter &amp; 0xFF;

        if (high_byte != 0) {
            bytes_string[n++] = (byte)high_byte;
        }

        bytes_string[n++] = (byte)low_byte;
    }

    CryptoPP::SHA1 sha1;
    std::string hash;

    CryptoPP::StringSource ss(bytes_string, n, true,
        new CryptoPP::HashFilter(sha1,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(hash)
            ) 
        ) 
    );

    std::cout &lt;&lt; hash &lt;&lt; std::endl;

    return 0;
}
</code></pre>
","<p>You say ‘but it returns wrong digest’ – what are you comparing it with?</p>

<p>Key point: digests such as SHA-1 don't work with sequences of characters, but with sequences of <em>bytes</em>.</p>

<p>What you're doing in this snippet of code is generating an ad-hoc <em>encoding</em> of the unicode characters in the string <code>""Ы""</code>.  This encoding will (as it turns out) match the UTF-16 encoding <em>if</em> the characters in the string are all in the BMP (‘basic multilingual plane’, which is true in this case) <em>and if</em> the numbers that end up in <code>wcharacter</code> are integers representing unicode codepoints (which is sort-of probably correct, but not, I think, guaranteed).</p>

<p>If the digest you're comparing it with turns an input string into an sequence of bytes using the UTF-8 encoding (which is quite likely), then that will produce a different byte sequence from yours, so that the SHA-1 digest of that sequence will be different from the digest you calculate here.</p>

<p>So:</p>

<ul>
<li><p>Check what encoding your test string is using.</p></li>
<li><p>You'd be best off using some library functions to specifically generate a UTF-16 or UTF-8 (as appropriate) encoding of the string you want to process, to ensure that the byte sequence you're working with is what you think it is.</p></li>
</ul>

<p>There's an excellent introduction to unicode and encodings in the aptly-named document <a href=""http://www.joelonsoftware.com/articles/Unicode.html"" rel=""nofollow"">The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)</a></p>
","1612","<c++><unicode><sha1><crypto++><digest>","5","3","3","2015-04-24 19:07:44","29780517","1","","608639","","2015-04-24 04:49:01","2015-04-20 18:08:59",""
"29755261","Get SHA1 of Unicode string in Crypto++","<p>I study C++ independently and I have one problem, which I can't solve more than week. I hope you can help me.</p>

<p>I need to get a SHA1 digest of a Unicode string (like <code>Привет</code>), but I don't know how to do that.</p>

<p>I tried to do it like this, but it returns a wrong digest!</p>

<p>For <code>wstring('Ы')</code>
It returns - <code>A469A61DF29A7568A6CC63318EA8741FA1CF2A7</code> <br/>
I need - <code>8dbe718ab1e0c4d75f7ab50fc9a53ec4f0528373</code></p>

<p>Regards and sorry for my English :).</p>

<p>CryptoPP 5.6.2
MVC++ 2013</p>

<pre><code>#include &lt;iostream&gt;
#include ""cryptopp562\cryptlib.h""
#include ""cryptopp562\sha.h""
#include ""cryptopp562\hex.h""

int main() {

    std::wstring string(L""Ы"");
    int bs_size = (int)string.length() * sizeof(wchar_t);

    byte* bytes_string = new byte[bs_size];

    int n = 0; //real bytes count
    for (int i = 0; i &lt; string.length(); i++) {
        wchar_t wcharacter = string[i];

        int high_byte = wcharacter &amp; 0xFF00;

        high_byte = high_byte &gt;&gt; 8;

        int low_byte = wcharacter &amp; 0xFF;

        if (high_byte != 0) {
            bytes_string[n++] = (byte)high_byte;
        }

        bytes_string[n++] = (byte)low_byte;
    }

    CryptoPP::SHA1 sha1;
    std::string hash;

    CryptoPP::StringSource ss(bytes_string, n, true,
        new CryptoPP::HashFilter(sha1,
            new CryptoPP::HexEncoder(
                new CryptoPP::StringSink(hash)
            ) 
        ) 
    );

    std::cout &lt;&lt; hash &lt;&lt; std::endl;

    return 0;
}
</code></pre>
","<blockquote>
  <p>I need to get a SHA1 digest of a Unicode string (like Привет), but I don't know how to do that.</p>
</blockquote>

<p>The trick here is you need to know how to encode the Unicode string. On Windows, a <code>wchar_t</code> is 2 octets; while on Linux a <code>wchar_t</code> is 4 otects. There's a Crypto++ wiki page on it at <a href=""http://www.cryptopp.com/wiki/Character_Set_Considerations"" rel=""nofollow noreferrer"">Character Set Considerations</a>, but its not that good.</p>

<p>To interoperate most effectively, always use UTF-8. That means you convert UTF-16 or UTF-32 to UTF-8. Because you are on Windows, you will want to call <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd374130%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">WideCharToMultiByte function</a> to convert it using <code>CP_UTF8</code>. If you were on Linux, then you would use <a href=""https://www.gnu.org/software/libiconv/"" rel=""nofollow noreferrer""><code>libiconv</code></a>.</p>

<p>Crypto++ has a built-in function called <code>StringNarrow</code> that uses C++. Its in the file <a href=""http://www.cryptopp.com/docs/ref/misc_8h_source.html"" rel=""nofollow noreferrer""><code>misc.h</code></a>. Be sure to call <code>setlocale</code> before using it.</p>

<p>Stack Overflow has a few question on using the Windows function . See, for example, <a href=""https://stackoverflow.com/q/215963"">How do you properly use WideCharToMultiByte</a>.</p>

<hr>

<blockquote>
  <p>I need - 8dbe718ab1e0c4d75f7ab50fc9a53ec4f0528373</p>
</blockquote>

<p>What is the hash (SHA-1, SHA-256, ...)? Is it a HMAC (keyed hash)? Is the information salted (like a password in storage)? How is it encoded? I have to ask because I cannot reproduce your desired results:</p>

<pre class=""lang-none prettyprint-override""><code>SHA-1:   2805AE8E7E12F182135F92FB90843BB1080D3BE8
SHA-224: 891CFB544EB6F3C212190705F7229D91DB6CECD4718EA65E0FA1B112
SHA-256: DD679C0B9FD408A04148AA7D30C9DF393F67B7227F65693FFFE0ED6D0F0ADE59
SHA-384: 0D83489095F455E4EF5186F2B071AB28E0D06132ABC9050B683DA28A463697AD
         1195FF77F050F20AFBD3D5101DF18C0D
SHA-512: 0F9F88EE4FA40D2135F98B839F601F227B4710F00C8BC48FDE78FF3333BD17E4
         1D80AF9FE6FD68515A5F5F91E83E87DE3C33F899661066B638DB505C9CC0153D
</code></pre>

<hr>

<p>Here's the program I used. Be sure to <em>specify the length of the wide string</em>. If you don't (and use <code>-1</code> for the length), then <code>WideCharToMultiByte</code> will include the terminating ASCII-Z in its calculations. Since we are using a <code>std::string</code>, we don't need the function to include the ASCII-Z terminator.</p>

<pre><code>int main(int argc, char* argv[])
{
    wstring m1 = L""Привет""; string m2;

    int req = WideCharToMultiByte(CP_UTF8, 0, m1.c_str(), (int)m1.length(), NULL, 0, NULL, NULL);
    if(req &lt; 0 || req == 0)
        throw runtime_error(""Failed to convert string"");

    m2.resize((size_t)req);

    int cch = WideCharToMultiByte(CP_UTF8, 0, m1.c_str(), (int)m1.length(), &amp;m2[0], (int)m2.length(), NULL, NULL);
    if(cch &lt; 0 || cch == 0)
        throw runtime_error(""Failed to convert string"");

    // Should not be required
    m2.resize((size_t)cch);

    string s1, s2, s3, s4, s5;
    SHA1 sha1; SHA224 sha224; SHA256 sha256; SHA384 sha384; SHA512 sha512;

    HashFilter f1(sha1, new HexEncoder(new StringSink(s1)));
    HashFilter f2(sha224, new HexEncoder(new StringSink(s2)));
    HashFilter f3(sha256, new HexEncoder(new StringSink(s3)));
    HashFilter f4(sha384, new HexEncoder(new StringSink(s4)));
    HashFilter f5(sha512, new HexEncoder(new StringSink(s5)));

    ChannelSwitch cs;
    cs.AddDefaultRoute(f1);
    cs.AddDefaultRoute(f2);
    cs.AddDefaultRoute(f3);
    cs.AddDefaultRoute(f4);
    cs.AddDefaultRoute(f5);

    StringSource ss(m2, true /*pumpAll*/, new Redirector(cs));

    cout &lt;&lt; ""SHA-1:   "" &lt;&lt; s1 &lt;&lt; endl;
    cout &lt;&lt; ""SHA-224: "" &lt;&lt; s2 &lt;&lt; endl;
    cout &lt;&lt; ""SHA-256: "" &lt;&lt; s3 &lt;&lt; endl;
    cout &lt;&lt; ""SHA-384: "" &lt;&lt; s4 &lt;&lt; endl;
    cout &lt;&lt; ""SHA-512: "" &lt;&lt; s5 &lt;&lt; endl;

    return 0;
}
</code></pre>
","1612","<c++><unicode><sha1><crypto++><digest>","5","3","3","2015-04-24 19:07:44","29780517","1","","608639","","2015-04-24 04:49:01","2015-04-20 18:08:59",""
"36000317","Link errors using cryptopp on VS2012 static library, console application and clr program","<p>I have the following project structure on VS2012 C++:</p>

<p><code>cryptopp</code>: As downloaded and build from cryptopp project.</p>

<p><code>AccessLib</code>: A static library build using cryptopp functions. </p>

<p><code>TestApp</code>: A Win32 console application that uses AccessLib (and cryptolib indirectly)</p>

<p><code>UserApp</code>: A Windows interactive application with CLR support (<code>/clr</code>) that uses AccessLib (and cryptolib indirectly)</p>

<p>Well, my first try was to make this solution work to build my console application and my windows application. BTW, <code>cryptopp</code> was build in a way described in manuals and  <a href=""https://stackoverflow.com/questions/6619042/how-do-i-install-crypto-in-visual-studio-2010"">this SO link</a>. All tests from cryptopp project are running fine in the build environment.</p>

<p>Here is how I´ve build my project:</p>

<ul>
<li><p>Set <code>AccessLib</code> as being <code>/Mtd</code> or <code>/MT</code> for Debug or Release respectively, linking with <code>cryptolib.lib</code> from <code>cryptodir\Win32\Output\Debug</code> and <code>cryptodir\Win32\Output\Release</code>respectively.</p></li>
<li><p>Set <code>TestApp</code> as being also <code>/MTd</code> or <code>/MT</code> for Debug or Release respectively, linking to <code>AccessLib.lib</code> generated from step above.</p></li>
</ul>

<p>Fine till now, but when building <code>UserApp</code>it does not work as <code>TestApp</code> needs <code>/clr</code> and that´s incompatible with <code>MTd</code>or <code>/MT</code>. </p>

<p>So, here goes my first question: I can´t have a CLR program that links to a static library that has <code>/MTd</code>or <code>/MT</code>.... What should I do to build my <code>/clr</code> program to my static library <code>AccessLib.lib</code> that access <code>cryptopp</code> as a static library also ? Should I need to convert everything to DLL project ?</p>

<p>Well, I even tried to convert to use cryptopp as a DLL, that way:</p>

<ul>
<li>Set <code>AccessLib</code> as being <code>/MDd</code> or <code>/MD</code> for Debug or Release respectively, linking with <code>cryptolib.lib</code> from <code>cryptodir\Win32\DLL_Output\Debug</code> and <code>cryptodir\Win32\DLL_Output\Release</code>respectively.</li>
</ul>

<p>That step went fine, but when trying to build <code>TestApp</code> as being also <code>/MDd</code> or <code>/MD</code> for Debug or Release respectively, linking to <code>AccessLib.lib</code> generated from step above, I got several errors like:</p>

<pre><code> 1&gt;------ Build started: Project: TestApp, Configuration: Debug Win32 ------
1&gt;cryptlib.lib(hrtimer.obj) : error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in TestApp.obj
1&gt;cryptlib.lib(pch.obj) : error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in TestApp.obj
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(pch.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: unsigned char * __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::allocate(unsigned int,void const *)"" (?allocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEPAEIPBX@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: void __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::deallocate(void *,unsigned int)"" (?deallocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEXPAXI@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: unsigned char * __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::reallocate(unsigned char *,unsigned int,unsigned int,bool)"" (?reallocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEPAEPAEII_N@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::AllocatorWithCleanup&lt;unsigned char,0&gt;(void)"" (??0?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Rijndael::Enc::Enc(void)"" (??0Enc@Rijndael@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::Rijndael::Enc::~Enc(void)"" (??1Enc@Rijndael@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Rijndael::Enc::Enc(class CryptoPP::Rijndael::Enc const &amp;)"" (??0Enc@Rijndael@CryptoPP@@QAE@ABV012@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: static char const * __cdecl CryptoPP::CBC_ModeBase::StaticAlgorithmName(void)"" (?StaticAlgorithmName@CBC_ModeBase@CryptoPP@@SAPBDXZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::CBC_Encryption::CBC_Encryption(void)"" (??0CBC_Encryption@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::CBC_Encryption::~CBC_Encryption(void)"" (??1CBC_Encryption@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::StreamTransformationFilter::~StreamTransformationFilter(void)"" (??1StreamTransformationFilter@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;)"" (??0?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@QAE@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;::~StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;(void)"" (??1?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Exception::Exception(enum CryptoPP::Exception::ErrorType,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const &amp;)"" (??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;LINK : warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library
1&gt;accesslib.lib(Encryptor.obj) : error LNK2001: unresolved external symbol ""class CryptoPP::NameValuePairs const &amp; const CryptoPP::g_nullNameValuePairs"" (?g_nullNameValuePairs@CryptoPP@@3ABVNameValuePairs@1@B)
1&gt;c:\project\dev\accesslib\Debug\TestApp.exe : fatal error LNK1120: 1 unresolved externals
========== Build: 0 succeeded, 1 failed, 1 up-to-date, 0 skipped ==========
</code></pre>

<p>I did not move to build <code>UserApp</code> with that configuration.</p>

<p>Help is appreciated to make this whole thing work together. I want to avoid usage of DLL´s at all. My original idea is to have everything as static libraries, but I don´t know if I can achieve that on that solution configuration.</p>

<p>Help appreciated.</p>
","<p>You can not link a library compiled with MT or MTd to a  program complied with MD or MDd. They have different CRT library.</p>

<p>You can rebuild cryptopp with MD or MDd</p>
","1600","<c++><visual-studio-2012><dll><static-libraries><crypto++>","1","1","2","2016-03-18 11:42:43","36003982","1","","-1","","2017-05-23 11:45:09","2016-03-14 23:59:16",""
"36000317","Link errors using cryptopp on VS2012 static library, console application and clr program","<p>I have the following project structure on VS2012 C++:</p>

<p><code>cryptopp</code>: As downloaded and build from cryptopp project.</p>

<p><code>AccessLib</code>: A static library build using cryptopp functions. </p>

<p><code>TestApp</code>: A Win32 console application that uses AccessLib (and cryptolib indirectly)</p>

<p><code>UserApp</code>: A Windows interactive application with CLR support (<code>/clr</code>) that uses AccessLib (and cryptolib indirectly)</p>

<p>Well, my first try was to make this solution work to build my console application and my windows application. BTW, <code>cryptopp</code> was build in a way described in manuals and  <a href=""https://stackoverflow.com/questions/6619042/how-do-i-install-crypto-in-visual-studio-2010"">this SO link</a>. All tests from cryptopp project are running fine in the build environment.</p>

<p>Here is how I´ve build my project:</p>

<ul>
<li><p>Set <code>AccessLib</code> as being <code>/Mtd</code> or <code>/MT</code> for Debug or Release respectively, linking with <code>cryptolib.lib</code> from <code>cryptodir\Win32\Output\Debug</code> and <code>cryptodir\Win32\Output\Release</code>respectively.</p></li>
<li><p>Set <code>TestApp</code> as being also <code>/MTd</code> or <code>/MT</code> for Debug or Release respectively, linking to <code>AccessLib.lib</code> generated from step above.</p></li>
</ul>

<p>Fine till now, but when building <code>UserApp</code>it does not work as <code>TestApp</code> needs <code>/clr</code> and that´s incompatible with <code>MTd</code>or <code>/MT</code>. </p>

<p>So, here goes my first question: I can´t have a CLR program that links to a static library that has <code>/MTd</code>or <code>/MT</code>.... What should I do to build my <code>/clr</code> program to my static library <code>AccessLib.lib</code> that access <code>cryptopp</code> as a static library also ? Should I need to convert everything to DLL project ?</p>

<p>Well, I even tried to convert to use cryptopp as a DLL, that way:</p>

<ul>
<li>Set <code>AccessLib</code> as being <code>/MDd</code> or <code>/MD</code> for Debug or Release respectively, linking with <code>cryptolib.lib</code> from <code>cryptodir\Win32\DLL_Output\Debug</code> and <code>cryptodir\Win32\DLL_Output\Release</code>respectively.</li>
</ul>

<p>That step went fine, but when trying to build <code>TestApp</code> as being also <code>/MDd</code> or <code>/MD</code> for Debug or Release respectively, linking to <code>AccessLib.lib</code> generated from step above, I got several errors like:</p>

<pre><code> 1&gt;------ Build started: Project: TestApp, Configuration: Debug Win32 ------
1&gt;cryptlib.lib(hrtimer.obj) : error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in TestApp.obj
1&gt;cryptlib.lib(pch.obj) : error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MTd_StaticDebug' doesn't match value 'MDd_DynamicDebug' in TestApp.obj
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::_Container_base12::_Container_base12(void)"" (??0_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::_Container_base12::~_Container_base12(void)"" (??1_Container_base12@std@@QAE@XZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: void __thiscall std::_Container_base12::_Orphan_all(void)"" (?_Orphan_all@_Container_base12@std@@QAEXXZ) already defined in cryptlib.lib(hrtimer.obj)
1&gt;msvcprtd.lib(MSVCP110D.dll) : error LNK2005: ""public: __thiscall std::locale::id::id(unsigned int)"" (??0id@locale@std@@QAE@I@Z) already defined in cryptlib.lib(pch.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: unsigned char * __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::allocate(unsigned int,void const *)"" (?allocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEPAEIPBX@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: void __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::deallocate(void *,unsigned int)"" (?deallocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEXPAXI@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: unsigned char * __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::reallocate(unsigned char *,unsigned int,unsigned int,bool)"" (?reallocate@?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAEPAEPAEII_N@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::AllocatorWithCleanup&lt;unsigned char,0&gt;::AllocatorWithCleanup&lt;unsigned char,0&gt;(void)"" (??0?$AllocatorWithCleanup@E$0A@@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Rijndael::Enc::Enc(void)"" (??0Enc@Rijndael@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::Rijndael::Enc::~Enc(void)"" (??1Enc@Rijndael@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Rijndael::Enc::Enc(class CryptoPP::Rijndael::Enc const &amp;)"" (??0Enc@Rijndael@CryptoPP@@QAE@ABV012@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: static char const * __cdecl CryptoPP::CBC_ModeBase::StaticAlgorithmName(void)"" (?StaticAlgorithmName@CBC_ModeBase@CryptoPP@@SAPBDXZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::CBC_Encryption::CBC_Encryption(void)"" (??0CBC_Encryption@CryptoPP@@QAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::CBC_Encryption::~CBC_Encryption(void)"" (??1CBC_Encryption@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::StreamTransformationFilter::~StreamTransformationFilter(void)"" (??1StreamTransformationFilter@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &amp;)"" (??0?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@QAE@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: virtual __thiscall CryptoPP::StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;::~StringSinkTemplate&lt;class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; &gt;(void)"" (??1?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAE@XZ) already defined in accesslib.lib(Encryptor.obj)
1&gt;cryptopp.lib(cryptopp.dll) : error LNK2005: ""public: __thiscall CryptoPP::Exception::Exception(enum CryptoPP::Exception::ErrorType,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const &amp;)"" (??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z) already defined in accesslib.lib(Encryptor.obj)
1&gt;LINK : warning LNK4098: defaultlib 'LIBCMTD' conflicts with use of other libs; use /NODEFAULTLIB:library
1&gt;accesslib.lib(Encryptor.obj) : error LNK2001: unresolved external symbol ""class CryptoPP::NameValuePairs const &amp; const CryptoPP::g_nullNameValuePairs"" (?g_nullNameValuePairs@CryptoPP@@3ABVNameValuePairs@1@B)
1&gt;c:\project\dev\accesslib\Debug\TestApp.exe : fatal error LNK1120: 1 unresolved externals
========== Build: 0 succeeded, 1 failed, 1 up-to-date, 0 skipped ==========
</code></pre>

<p>I did not move to build <code>UserApp</code> with that configuration.</p>

<p>Help is appreciated to make this whole thing work together. I want to avoid usage of DLL´s at all. My original idea is to have everything as static libraries, but I don´t know if I can achieve that on that solution configuration.</p>

<p>Help appreciated.</p>
","<blockquote>
  <p>That step went fine, but when trying to build TestApp as being also /MDd or /MD for Debug or Release respectively, linking to AccessLib.lib generated from step above, I got several errors like...</p>
</blockquote>

<p>You are mixing and matching runtimes. You should probably change Crypto++ and make it use dynamic runtime linking the the C/C++ runtime library. See <a href=""http://www.cryptopp.com/wiki/Visual_Studio#Dynamic_Runtime_Linking"" rel=""nofollow"">Visual Studio | Dynamic Runtime Linking</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
  <p>I want to avoid usage of DLL´s at all. My original idea is to have everything as static libraries, but I don´t know if I can achieve that on that solution configuration.</p>
</blockquote>

<p>Yes, this is preferred. It will work, but you need to build the Crypto++ static library using dynamic runtime linking. The project you want is <strong><em><code>cryptlib</code></em></strong>, and its output is found in <em><code>&lt;crypto++ dir&gt;/Output/{Debug|Release}/{Win32|x64}</code></em>. See the previous links.</p>

<p>You should also avoid the FIPS DLL. The DLL project is <strong><em><code>cryptdll</code></em></strong>, and its output is found in <em><code>&lt;crypto++ dir&gt;/DLL_Output/...</code></em>. The DLL is special purpose, and it only provides FIPS algorithms. Its not a general purpose DLL, it lacks most stuff you need, and it causes a lot of pain and misery.</p>

<p>I even go so far as to tell people to completely delete the <strong><em><code>cryptdll</code></em></strong> and <strong><em><code>dlltest</code></em></strong> projects because they cause so much trouble. Also see <a href=""http://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow"">FIPS DLL</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
  <p>Link errors using cryptopp on VS2012 static library, console application and clr program</p>
</blockquote>

<p>This is noteworthy... Crypto++ does not use the <strong><em><a href=""http://msdn.microsoft.com/en-us/library/b0084kay.aspx"" rel=""nofollow""><code>/clr</code></a></em></strong> option. You will need to modify the static library project settings and add it.</p>

<p>The static library's project is called <strong><em><code>cryptlib</code></em></strong>. You will need to do it for <em>Win32 Debug</em>, <em>Win32 Release</em>, <em>x64 Debug</em> and <em>x64 Release</em>.</p>
","1600","<c++><visual-studio-2012><dll><static-libraries><crypto++>","1","1","2","2016-03-18 11:42:43","36003982","1","","-1","","2017-05-23 11:45:09","2016-03-14 23:59:16",""
"23095254","Value after cryptopp base64 encoding/decoding not the same","<p>I'm playing with cryptopp and have trouble with Base64 encoding/decoding.</p>

<p>In the following code hypothetically <code>sig</code> value should be equal <code>tsig</code>, but they are different on a last character (<code>sig</code> bigger then <code>tsig</code> by one symbol). I've tried also change <code>insertLineBreaks</code> parameter in <code>Base64Encoder</code> but the result is same. 
    ...</p>

<pre><code>RSASSA_PKCS1v15_SHA_Signer privkey(privateKey);
SecByteBlock sbbSignature(privkey.SignatureLength());
privkey.SignMessage(rng, (byte const*) strContents.data(),
    strContents.size(),sbbSignature);

Base64Encoder b(new StringSink(signedData));
b.Put(sbbSignature.begin(), sbbSignature.size());

string sig;
StringSink sinksig(sig);
sinksig.Put(sbbSignature.begin(), sbbSignature.size());

string tsig;
StringSource ss(signedData, true, 
    new Base64Decoder(
        new StringSink(tsig)
    )
);
</code></pre>

<p>Where is my mistake?</p>
","<pre><code>b.Put(sbbSignature.begin(), sbbSignature.size());
</code></pre>

<p>Try:</p>

<pre><code>b.Put(sbbSignature.begin(), sbbSignature.size());
b.MessgeEnd();
</code></pre>

<hr>

<p>This does not quite look right:</p>

<pre><code>SecByteBlock sbbSignature(privkey.SignatureLength());
privkey.SignMessage(rng, (byte const*) strContents.data(),
    strContents.size(),sbbSignature);
</code></pre>

<p>Try:</p>

<pre><code>size_t maxLength = privkey.MaxSignatureLength();
SecByteBlock sbbSignature(maxLength);

size_t signatureLength = privkey.SignMessage(rng,
    (byte const*) strContents.data(), strContents.size(),
    sbbSignature);

if(maxLength != signatureLength)
    sbbSignature.resize(signatureLength);
</code></pre>

<hr>

<p>There's an example on the Crypto++ wiki at <a href=""http://www.cryptopp.com/wiki/RSA_Signature_Schemes#RSA_Signature_Scheme_with_Appendix"" rel=""nofollow"">RSA Signature Scheme with Appendix</a>, but I think its wrong after looking at it.</p>
","1594","<c++><base64><crypto++>","1","1","1","2014-04-16 23:26:58","23096372","0","","608639","","2014-04-15 23:58:01","2014-04-15 21:54:59",""
"13762340","Is this valgrind use of unitialized value of size 8 in crypto++ real or a red herring?","<p>I have an valgrind report of <code>Use of uninitialised value of size 8</code> in the library call
<code>CryptoPP::HuffmanEncoder::GenerateCodeLengths</code> on <code>Ubuntu 12.10</code> <strong>libcrypto++9_5.6.1-6_amd64.deb</strong>.</p>

<p><em>I need a sanity check: is there something wrong with the application code?  (This is a real possibility as I have just started using crypto++.)  Or should I just put the valgrind warning suppression into the ignore filter?</em>  </p>

<p>Despite the error, the code looks like it's working.</p>

<pre><code>make: `test3' is up to date.
==5420== Memcheck, a memory error detector
==5420== Copyright (C) 2002-2011, and GNU GPL'd, by Julian Seward et al.
==5420== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==5420== Command: ./test3
==5420== 
Plain text = 13312 bytes
==5420== Use of uninitialised value of size 8
==5420==    at 0x520D9A9: CryptoPP::HuffmanEncoder::GenerateCodeLengths(unsigned int*, unsigned int, unsigned int const*, unsigned long) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520E0A5: CryptoPP::Deflator::EncodeBlock(bool, unsigned int) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520EA2E: CryptoPP::Deflator::EndBlock(bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520F221: CryptoPP::Deflator::Put2(unsigned char const*, unsigned long, int, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F16DB: CryptoPP::BufferedTransformation::ChannelPut2(std::string const&amp;, unsigned char const*, unsigned long, int, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F1F76: CryptoPP::BufferedTransformation::TransferMessagesTo2(CryptoPP::BufferedTransformation&amp;, unsigned int&amp;, std::string const&amp;, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F2185: CryptoPP::BufferedTransformation::TransferAllTo2(CryptoPP::BufferedTransformation&amp;, std::string const&amp;, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x4106A4: CryptoPP::StringSource::StringSource(std::string const&amp;, bool, CryptoPP::BufferedTransformation*) (filters.h:767)
==5420==    by 0x40C7D5: main (test3.cpp:75)
==5420== 
==5420== Use of uninitialised value of size 8
==5420==    at 0x520D9A9: CryptoPP::HuffmanEncoder::GenerateCodeLengths(unsigned int*, unsigned int, unsigned int const*, unsigned long) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520E0A5: CryptoPP::Deflator::EncodeBlock(bool, unsigned int) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520EA4F: CryptoPP::Deflator::EndBlock(bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x520F221: CryptoPP::Deflator::Put2(unsigned char const*, unsigned long, int, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F16DB: CryptoPP::BufferedTransformation::ChannelPut2(std::string const&amp;, unsigned char const*, unsigned long, int, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F1F76: CryptoPP::BufferedTransformation::TransferMessagesTo2(CryptoPP::BufferedTransformation&amp;, unsigned int&amp;, std::string const&amp;, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x50F2185: CryptoPP::BufferedTransformation::TransferAllTo2(CryptoPP::BufferedTransformation&amp;, std::string const&amp;, bool) (in /usr/lib/libcrypto++.so.9.0.0)
==5420==    by 0x4106A4: CryptoPP::StringSource::StringSource(std::string const&amp;, bool, CryptoPP::BufferedTransformation*) (filters.h:767)
==5420==    by 0x40C7D5: main (test3.cpp:75)
==5420== 
Encrypted text = 110 bytes : JFuk7LvDTujLm3D8SdFZCwSXMQsslb0+AUf8sp53Z+oRDIp9aQY1azUF2PZZje/SV1q+IPz5
jGWYkJXlZv2ttADPUdMbg7ib+B4LGlb+7/k=
KEY[16]: ABD86728BB78D5722D07F247D8279CD9
IV [8]: BEBD442990B11C58
==5420== 
==5420== HEAP SUMMARY:
==5420==     in use at exit: 0 bytes in 0 blocks
==5420==   total heap usage: 118 allocs, 118 frees, 313,921 bytes allocated
==5420== 
==5420== All heap blocks were freed -- no leaks are possible
==5420== 
==5420== For counts of detected and suppressed errors, rerun with: -v
==5420== Use --track-origins=yes to see where uninitialised values come from
==5420== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 2 from 2)
</code></pre>

<p><strong>Compile</strong></p>

<p><code>g++ -std=c++11 -g3 -O2 -Wall -Wextra -Wno-unused -o test3 test3.cpp -lrt -lcryptopp</code></p>

<p><strong>test3.cpp Code</strong></p>

<pre><code>#include &lt;cryptopp/blowfish.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;cryptopp/files.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/gzip.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;cryptopp/hex.h&gt;

#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;exception&gt;

int main () 
{
    std::string plainText;
    timespec ts1, ts2;

    plainText = ""Hello, world!"";
    for (int i = 0; i &lt; 10; i++) 
        plainText = plainText + plainText;

    byte   iv [ CryptoPP::Blowfish::BLOCKSIZE         ];
    byte   key[ CryptoPP::Blowfish::DEFAULT_KEYLENGTH ]; 

    const bool generate_fast = true;
    CryptoPP::AutoSeededRandomPool rng( !generate_fast ); 
    rng.GenerateBlock( iv,  sizeof( iv  ));
    rng.GenerateBlock( key, sizeof( key ));

    std::cout &lt;&lt; ""Plain text = "" &lt;&lt; plainText.size() &lt;&lt; "" bytes\n"";

    std::string cipher, decipher;
    CryptoPP::StringSink*    sink       = new CryptoPP::StringSink( cipher  );
    CryptoPP::Base64Encoder* base64_enc = new CryptoPP::Base64Encoder( sink );
    CryptoPP::CBC_Mode&lt;CryptoPP::Blowfish&gt;::Encryption 
        twofish( key, CryptoPP::Blowfish::DEFAULT_KEYLENGTH, iv );
    CryptoPP::StreamTransformationFilter* 
        enc = new CryptoPP::StreamTransformationFilter( twofish, base64_enc );
    CryptoPP::Gzip *zip = new CryptoPP::Gzip( enc );
    CryptoPP::StringSource source( plainText, true, zip );
    std::cout &lt;&lt; ""Encrypted text = "" &lt;&lt; cipher.size() &lt;&lt; "" bytes : "" &lt;&lt; cipher;
}
</code></pre>
","<p>According to <a href=""http://valgrind.org/docs/manual/mc-manual.html"" rel=""nofollow"">this</a> valgrind will report an unitialised value when you use a value that hasn't been initialised (fairly obvious).</p>

<p>As far as your code is concerned, different C++ compilers handle declared but uninitialized values differently, depending on flags passed.  This can be to set them to zero, but it should not be assumed.</p>

<p>The 8 bytes in the valgrind output could be a pointer, and using uninitialized values for those are especially dangerous.</p>

<p>To be completely certain, you would need access to the source code for this, otherwise you always run the risk of undefined behaviour further down the line.</p>
","1594","<c++><valgrind><crypto++>","3","2","1","2014-08-14 06:38:51","","5","","","","","2012-12-07 11:38:53",""
"17306752","Decoding Hex Encoded Value with Crypto++","<p>I'm new to Cryptopp and I wanted to encode text and decode back to understand how it works.
The encoding part works fine but I cannot get the string decoded? Always the decoded string is empty. I asked in Crypto mailing and someone said this code should work but it does not.</p>

<p>I would like to know what is wrong.
Being new to crypto I cannot see what is wrong.</p>

<p>The code:</p>

<pre><code>std::string encoded = m_pkey-&gt;GetValue().ToStdString();//here under debugger its ok
std::string decoded;
CryptoPP::StringSource(encoded, true, new CryptoPP::HexDecoder(new CryptoPP::StringSink(decoded)));
</code></pre>
","<p>The Crypto++ wiki has a number of examples, including use of the <a href=""http://www.cryptopp.com/wiki/Hex_Encoder"" rel=""nofollow"">HexEncoder</a> and <a href=""http://www.cryptopp.com/wiki/Hex_Decoder"" rel=""nofollow"">HexDecoder</a> classes.</p>

<p>From the wiki:</p>

<pre><code>byte decoded[] = { 0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 
                   0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00 };
string encoded;

StringSource ss(decoded, sizeof(decoded), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource

cout &lt;&lt; encoded &lt;&lt; endl;
...

$ ./cryptopp-test.exe
FFEEDDCCBBAA99887766554433221100
</code></pre>
","1572","<c++><crypto++>","1","2","2","2015-02-16 10:48:40","19130576","0","","608639","","2015-02-16 10:48:40","2013-06-25 20:19:22",""
"17306752","Decoding Hex Encoded Value with Crypto++","<p>I'm new to Cryptopp and I wanted to encode text and decode back to understand how it works.
The encoding part works fine but I cannot get the string decoded? Always the decoded string is empty. I asked in Crypto mailing and someone said this code should work but it does not.</p>

<p>I would like to know what is wrong.
Being new to crypto I cannot see what is wrong.</p>

<p>The code:</p>

<pre><code>std::string encoded = m_pkey-&gt;GetValue().ToStdString();//here under debugger its ok
std::string decoded;
CryptoPP::StringSource(encoded, true, new CryptoPP::HexDecoder(new CryptoPP::StringSink(decoded)));
</code></pre>
","<p>The model used in the above answer is what is referred to as the ""pipeline"" pattern in Crypto++. See <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Crypto++ article on pipelining</a></p>

<p>Note the rules that apply to object ownership - if you pass a pointer to an object into a constructor, that object will be owned by the newly constructed object and deleted in its destructor. If the object is passed into the constructor by reference, the object must remain extant for the life of the newly constructed object, i.e. you retain ownership and must not delete it from under the nose of the new object!</p>
","1572","<c++><crypto++>","1","0","2","2015-02-16 10:48:40","19130576","0","","608639","","2015-02-16 10:48:40","2013-06-25 20:19:22",""
"13335688","AES and key length error","<p>I am trying to get this code to work. It is from <a href=""http://www.cryptopp.com/wiki/Aes"" rel=""nofollow"">Cryptopp AES</a></p>

<blockquote>
  <p>Demonstrates encryption and decryption using AES in CTR</p>
</blockquote>

<p>The only difference is, that I created the function <em>encryptAES</em> and <em>decryptAES</em> and inserted the code.
It works without creating these functions. But now I got the following error: <strong>AES/CTR 4 is not a valid key length but the key is 16 bit long.</strong> </p>

<pre><code>string encryptAES(const byte key[], const string&amp; plain, const byte iv[])
{
try
{
    string cipher;

    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(key, sizeof(key), iv);

    // The StreamTransformationFilter adds padding
    //  as required. ECB and CBC Mode must be padded
    //  to the block size of the cipher.
    StringSource(plain, true, 
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        ) // StreamTransformationFilter      
    ); // StringSource
    return cipher;
}
catch(const CryptoPP::Exception&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    return """";
}
}

string decryptAES(const byte key[], const string&amp; cipher, const byte iv[])
{
try
{
    string recovered;

    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV(key, sizeof(key), iv);

    // The StreamTransformationFilter removes
    //  padding as required.
    StringSource s(cipher, true, 
        new StreamTransformationFilter(d,
            new StringSink(recovered)
        ) // StreamTransformationFilter
    ); // StringSource
    return recovered;
}
catch(const CryptoPP::Exception&amp; e)
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    return """";
}
}

int main(int argc, char *argv[])
{
AutoSeededRandomPool prng;

byte key[AES::DEFAULT_KEYLENGTH];
prng.GenerateBlock(key, sizeof(key));

byte iv[AES::BLOCKSIZE];
prng.GenerateBlock(iv, sizeof(iv));

string plain = ""CTR Mode Test"";
string encoded, cipher, recovered;

/*********************************\
\*********************************/

// Pretty print key
encoded.clear();
StringSource(key, sizeof(key), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource
cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;

// Pretty print iv
encoded.clear();
StringSource(iv, sizeof(iv), true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource
cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;
cipher = encryptAES(key, plain, iv);

/*********************************\
\*********************************/

// Pretty print
encoded.clear();
StringSource(cipher, true,
    new HexEncoder(
        new StringSink(encoded)
    ) // HexEncoder
); // StringSource
cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

recovered = decryptAES(key, cipher, iv);
cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;

cin.sync();
cin.get();
} 
</code></pre>
","<p>Your functions are taking a <code>const byte key[]</code> parameter, which is essentially treated as a pointer. thus sizeof(key) is the size of a pointer on your platform.</p>

<pre><code>string encryptAES(const byte key[], const string&amp; plain, const byte iv[])

// sizeof(key) is the size of a pointer
e.SetKeyWithIV(key, sizeof(key), iv);
</code></pre>

<p>You can use a <code>std::vector&lt;&gt;</code> as an option, or pass the key_len, such as:</p>

<pre><code>string encryptAES(const byte key[], size_t key_len, const string&amp; plain, const byte iv[])

// using key_len for the length of the key
e.SetKeyWithIV(key, key_len, iv);
</code></pre>

<p>I hope that makes sense, because the same error is in a couple places.</p>
","1568","<c++><key><aes><crypto++>","3","2","1","2015-05-02 22:42:56","13335951","1","1","608639","","2015-05-02 22:42:56","2012-11-11 21:34:30",""
"21965102","AES 256 encryption - Qt equivalent for Java","<p>I have my AES 256 encryption method implemented and working fine in Java as follows!</p>

<pre><code>  private static final byte[] IV = {
    0, 2, 4, 8, 16, 32, 64, 127, 
    127, 64, 32, 16, 8, 4, 2, 0
};

  //actual encryption over here
  private static byte[] encrypt(byte[] raw, byte[] clear) throws 
Exception {  
    SecretKeySpec skeySpec = new SecretKeySpec(raw,  ""AES"");  
    Cipher cipher = null;

    if(isIVUsedForCrypto) {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(IV));  
    }
    else 
    {
        cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);  
    }
    byte[] encrypted = cipher.doFinal(clear);  
    return encrypted;  
}  
</code></pre>

<p>The byte array that is returned from the above method is finally converted to a HEX string using the following <code>toHex</code> method. </p>

<pre><code>      public static String toHex(byte[] buf) {  
    if (buf == null)  
        return """";  
    StringBuffer result = new StringBuffer(2*buf.length);  
    for (int i = 0; i &lt; buf.length; i++) {  
        appendHex(result, buf[i]);  
    }  
    return result.toString();  
}  
private final static String HEX = ""0123456789ABCDEF"";  
private static void appendHex(StringBuffer sb, byte b) {  
    sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));  
}  
</code></pre>

<p>So the end result using Java AES 256 encryption code is a HEX String.</p>

<p>Now for the Qt part,</p>

<pre><code>  QByteArray IV(""0, 2, 4, 8, 16, 32, 64, 127,127, 64, 32, 16, 8, 4, 2, 0"");


 QString encrypt(QByteArray r, const QString &amp;password)
 {
const char *sample = r.data();
string plain = password.toStdString();
string ciphertext;
// Generate Cipher, Key, and CBC
byte key[ AES::MAX_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
StringSource( reinterpret_cast&lt;const char *&gt;(sample), true,
              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );
memset( iv, 0x00, AES::BLOCKSIZE );
CBC_Mode&lt;AES&gt;::Encryption Encryptor( key, sizeof(key), iv );
StringSource( plain, true, new StreamTransformationFilter( Encryptor,
              new HexEncoder(new StringSink( ciphertext ) ) ) );
return QString::fromStdString(ciphertext);
} 
</code></pre>

<p>And from the main method i call the above function</p>

<pre><code>        QString encrypted = encrypt(result, ""test"");
</code></pre>

<p>where ""result"" is a <code>QByteArray</code> that I pass to encrypt as done similarly in java. </p>

<p>The byte arrays in both cases Java and Qt are obtained the same. I have verified that.</p>

<p><strong>My problem</strong></p>

<p>The encryption logic for Qt especially is failing somewhere due to which the <code>HEX</code> result obtained via Java and Qt don't match.</p>

<p>Can anyone tell me what I am doing wrong in the Qt part. Am I not using the <code>IV</code> or the <code>QByteArray</code> <code>result</code> correctly?</p>
","<p>Initialization vector is different in your Java code and Qt:</p>

<pre><code>private static final byte[] IV = {
    0, 2, 4, 8, 16, 32, 64, 127, 
    127, 64, 32, 16, 8, 4, 2, 0
};
</code></pre>

<p>And in C++:</p>

<pre><code>memset( iv, 0x00, AES::BLOCKSIZE ); // ==&gt; This fills the iv array with 0s
</code></pre>

<p>So you need to use same IV for both schemes.</p>

<p><strong>Update:</strong></p>

<p>In order to provide an IV for CBC mode of AES, you need to specify IV as you do in Java:</p>

<pre><code>byte iv[ AES::BLOCKSIZE ] = {0, 2, 4, 8, 16, 32, 64, 127, 
                             127, 64, 32, 16, 8, 4, 2, 0};
</code></pre>

<p>Note that AES::BLOCKSIZE is defined in library headers and it is <code>16</code>.</p>
","1561","<java><c++><qt><encryption><crypto++>","5","2","2","2014-02-24 16:12:05","21992932","2","3","","","","2014-02-23 06:43:33",""
"21965102","AES 256 encryption - Qt equivalent for Java","<p>I have my AES 256 encryption method implemented and working fine in Java as follows!</p>

<pre><code>  private static final byte[] IV = {
    0, 2, 4, 8, 16, 32, 64, 127, 
    127, 64, 32, 16, 8, 4, 2, 0
};

  //actual encryption over here
  private static byte[] encrypt(byte[] raw, byte[] clear) throws 
Exception {  
    SecretKeySpec skeySpec = new SecretKeySpec(raw,  ""AES"");  
    Cipher cipher = null;

    if(isIVUsedForCrypto) {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(IV));  
    }
    else 
    {
        cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);  
    }
    byte[] encrypted = cipher.doFinal(clear);  
    return encrypted;  
}  
</code></pre>

<p>The byte array that is returned from the above method is finally converted to a HEX string using the following <code>toHex</code> method. </p>

<pre><code>      public static String toHex(byte[] buf) {  
    if (buf == null)  
        return """";  
    StringBuffer result = new StringBuffer(2*buf.length);  
    for (int i = 0; i &lt; buf.length; i++) {  
        appendHex(result, buf[i]);  
    }  
    return result.toString();  
}  
private final static String HEX = ""0123456789ABCDEF"";  
private static void appendHex(StringBuffer sb, byte b) {  
    sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));  
}  
</code></pre>

<p>So the end result using Java AES 256 encryption code is a HEX String.</p>

<p>Now for the Qt part,</p>

<pre><code>  QByteArray IV(""0, 2, 4, 8, 16, 32, 64, 127,127, 64, 32, 16, 8, 4, 2, 0"");


 QString encrypt(QByteArray r, const QString &amp;password)
 {
const char *sample = r.data();
string plain = password.toStdString();
string ciphertext;
// Generate Cipher, Key, and CBC
byte key[ AES::MAX_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
StringSource( reinterpret_cast&lt;const char *&gt;(sample), true,
              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );
memset( iv, 0x00, AES::BLOCKSIZE );
CBC_Mode&lt;AES&gt;::Encryption Encryptor( key, sizeof(key), iv );
StringSource( plain, true, new StreamTransformationFilter( Encryptor,
              new HexEncoder(new StringSink( ciphertext ) ) ) );
return QString::fromStdString(ciphertext);
} 
</code></pre>

<p>And from the main method i call the above function</p>

<pre><code>        QString encrypted = encrypt(result, ""test"");
</code></pre>

<p>where ""result"" is a <code>QByteArray</code> that I pass to encrypt as done similarly in java. </p>

<p>The byte arrays in both cases Java and Qt are obtained the same. I have verified that.</p>

<p><strong>My problem</strong></p>

<p>The encryption logic for Qt especially is failing somewhere due to which the <code>HEX</code> result obtained via Java and Qt don't match.</p>

<p>Can anyone tell me what I am doing wrong in the Qt part. Am I not using the <code>IV</code> or the <code>QByteArray</code> <code>result</code> correctly?</p>
","<p>I guess your Java implementation misses a hash step on the key. I'm using a SHA256 hash of the key. To test c++ implementation, change code to this:</p>

<pre><code>QString encrypt(QByteArray r, const QString &amp;password)
 {
const char *sample = r.data();
string plain = password.toStdString();
string ciphertext;
// Generate Cipher, Key, and CBC
byte key[ AES::MAX_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
//StringSource( reinterpret_cast&lt;const char *&gt;(sample), true,
//              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );
for(int i=0; i&lt; AES::MAX_KEYLENGTH; ++i){
    key[i] = reinterpret_cast&lt;const char *&gt;(decodedKey)[i];
}
memset( iv, 0x00, AES::BLOCKSIZE );
CBC_Mode&lt;AES&gt;::Encryption Encryptor( key, sizeof(key), iv );
StringSource( plain, true, new StreamTransformationFilter( Encryptor,
              new HexEncoder(new StringSink( ciphertext ) ) ) );
return QString::fromStdString(ciphertext);
} 
</code></pre>
","1561","<java><c++><qt><encryption><crypto++>","5","3","2","2014-02-24 16:12:05","21992932","2","3","","","","2014-02-23 06:43:33",""
"22686709","unresolved external symbol, but dumpbin says it's ok","<p>I downloaded <code>Crypto++</code> 5.62 and built it with default project settings. In my project I set up the path to <code>cryptopp.lib</code> and defined its name in ""Additional Dependencies"". Both Crypto++ and my project - VS 2008.</p>

<p>During building of my project I get:</p>

<pre><code>main.obj : error LNK2001: unresolved external symbol 
  ""class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; const CryptoPP::DEFAULT_CHANNEL"" (?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B)

main.obj : error LNK2001: unresolved external symbol 
  ""bool (__cdecl* CryptoPP::g_pAssignIntToInteger)(class type_info const &amp;,void *,void const *)"" (?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA)
</code></pre>

<p><code>dumpbin /all cryptopp.lib</code> shows me in the public symbols section</p>

<pre><code>19471C _imp_?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B

1D6F30 __imp_?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA
</code></pre>

<p>What's wrong then? Why the linker can't find the symbols?</p>

<p><strong>upd:</strong></p>

<p>linker command line from my project settings</p>

<p><code>/OUT:""C:\Projects\crypto_hash\Debug\crypto_hash.exe"" /NOLOGO /LIBPATH:""e:\libs\cryptopp\cryptopp562\cryptopp\Win32\DLL_Output\Debug"" /MANIFEST /MANIFESTFILE:""Debug\crypto_hash.exe.intermediate.manifest"" /MANIFESTUAC:""level='asInvoker' uiAccess='false'"" /DEBUG /PDB:""C:\Projects\crypto_hash\Debug\crypto_hash.pdb"" /DYNAMICBASE /NXCOMPAT /MACHINE:X86 /ERRORREPORT:PROMPT cryptopp.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib</code></p>
","<p>Try adding <code>CRYPTOPP_IMPORTS</code> to your project defines.</p>

<p>From <code>config.h</code>:</p>

<pre><code>#ifdef CRYPTOPP_EXPORTS
# define CRYPTOPP_IS_DLL
# define CRYPTOPP_DLL __declspec(dllexport)
#elif defined(CRYPTOPP_IMPORTS)
# define CRYPTOPP_IS_DLL
# define CRYPTOPP_DLL __declspec(dllimport)
#else
# define CRYPTOPP_DLL
#endif
</code></pre>

<p>Or include Crypto++'s <code>dll.h</code>. It sets <code>CRYPTOPP_IMPORTS</code>:</p>

<pre><code>#if !defined(CRYPTOPP_IMPORTS) &amp;&amp; !defined(CRYPTOPP_EXPORTS) &amp;&amp; !defined(CRYPTOPP_DEFAULT_NO_DLL)
# ifdef CRYPTOPP_CONFIG_H
#  error To use the DLL version of Crypto++, this file must be included before any other Crypto++ header files.
# endif
# define CRYPTOPP_IMPORTS
#endif
</code></pre>

<hr>

<p>If that does not work...</p>

<p><code>g_pAssignIntToInteger</code> is from <code>algparams.cpp</code>:</p>

<pre><code>$ grep -R g_pAssignIntToInteger *
algparam.cpp:PAssignIntToInteger g_pAssignIntToInteger = NULL;
algparam.h:CRYPTOPP_DLL extern PAssignIntToInteger g_pAssignIntToInteger;
algparam.h:     if (!(g_pAssignIntToInteger != NULL &amp;&amp; typeid(T) == typeid(int) &amp;&amp; g_pAssignIntToInteger(valueType, pValue, &amp;m_value)))
integer.cpp:    if (!g_pAssignIntToInteger)
integer.cpp:        g_pAssignIntToInteger = AssignIntToInteger;
</code></pre>

<p>Looking at the declaration in <code>algparam.h</code>:</p>

<pre><code>// to allow the linker to discard Integer code if not needed.
typedef bool (CRYPTOPP_API * PAssignIntToInteger)(const std::type_info &amp;valueType, void *pInteger, const void *pInt);
CRYPTOPP_DLL extern PAssignIntToInteger g_pAssignIntToInteger;
</code></pre>

<p>And the implementation in <code>algparam.cpp</code>:</p>

<pre><code>#ifndef CRYPTOPP_IMPORTS
...

NAMESPACE_BEGIN(CryptoPP)    
PAssignIntToInteger g_pAssignIntToInteger = NULL;
...
</code></pre>

<p>So you might need to change the implementation to ensure the code uses <code>g_pAssignIntToInteger</code> (to keep it from being discarded). Unfortunately, nothing comes to mind at the moment.</p>

<hr>

<p><code>DEFAULT_CHANNEL</code> is declared in <code>cryptlib.h</code> and has storage allocated in <code>cryptolib.cpp</code>:</p>

<pre><code>$ grep -R DEFAULT_CHANNEL *
...
cryptlib.cpp:const std::string DEFAULT_CHANNEL;
...
cryptlib.h:extern CRYPTOPP_DLL const std::string DEFAULT_CHANNEL;
...
</code></pre>

<p>This might be a different problem since I'm not used to seeing issues with <code>DEFAULT_CHANNEL</code>. See how <code>CRYPTOPP_IMPORTS</code> works for you, and then ask a different question since this might be a different problem.</p>
","1551","<c++><unresolved-external><crypto++>","3","5","1","2014-04-02 11:15:22","","12","","19405","","2014-03-27 14:42:20","2014-03-27 11:48:41",""
"33087932","How to build Crypto++ library on Linux with MinGW?","<p>im trying to port a c++ project from visual studio 2013 to netbeans on ubuntu. The target is a windows executable, so far im able to compile windows exe files from netbeans using mingw as compiler.</p>

<p>The project needs the Crypto++ library and i only have the .lib version for visual studio. To include the library in netbeans i first need to build the Crypto++ library in the .a format.</p>

<p>Its not clear to me how should i do that.
Ive found informations on how to build the library for linux with mingw but not for cross compilation with mingw. The provided GNUmakefile does not work.
Should i set up a vm with windows and mingw and compile the library that way? Or maybe use the qmake ""hack"" as suggested here <a href=""http://www.qtcentre.org/threads/28809-Compiling-amp-using-Crypto-with-mingw-version-of-Qt"" rel=""nofollow"">http://www.qtcentre.org/threads/28809-Compiling-amp-using-Crypto-with-mingw-version-of-Qt</a> ? The last good Crypto++ version suggested there is quite old. This is confusing, porting the whole project is easier than having the required library.
Im open to any suggestion.</p>

<p>tldr: how to build libcryptopp.a on linux for the cross compilation of a windows exe project</p>

<p>edit:
for example if i cross compile something there are windows libraries in the /usr/i686-w64-mingw32/lib/ folder like libuser32.a. i need to make the equivalend libcryptopp.a.. sorry if is a bit unclear.
if i simply build using the steps in answer (and in the wiki) i end up with a libcryptopp.a file but i suspect is linux-only, cause if i link that library in netbeans in the .exe file im cross compiling i end up with undefined references to cryptopp stuff everywere. the paths are correct, i suspect the library needs to be replaced with the equivalent libcryptopp.a compatible with crosscompiling.</p>

<p>edit2: im trying to follow the answer down here, now im stuck here. after this command to build cryptopp.</p>

<pre><code>    make CXX=/usr/bin/i686-w64-mingw32-gcc INCLUDES=""-I /usr/i686-w64-mingw32/include"" LIBS=""-L /usr/i686-w64-mingw32/lib"" CXXFLAGS=""-std=c++0x""
</code></pre>

<p>and many variations of it i always end up with this error</p>

<p>trap.h:26:25: fatal error: Windows.h: No such file or directory
 #    include </p>

<p>which makes me think its using the right compiler to make a .a lib file for cross compiling the windows .exe with the lib.
however i dont understand whats going on now with the missing header..:(</p>

<p>Also if i try to link the lib file (used with visual studio) i get a lot of linking errors, undefined reference to cryptopp stuff.</p>

<p>ill offer a symbolic beer (a couple of $ of Bitcoins) if someone finds out how to do it.</p>
","<blockquote>
  <p>I've found informations on how to build the library for linux with mingw but not for cross compilation with mingw.</p>
</blockquote>

<p>Its relatively easy...</p>

<ol>
<li>Get Crypto++ ZIP into MinGW.</li>
<li>Unpack Crypto++ ZIP.</li>
<li>Change directories.</li>
<li>Build the library.</li>
<li>Verify <strong><em><code>All tests passed</code></em></strong>.</li>
</ol>

<p>(1) and (2) can be tricky because Cygwin and MinGW are missing a lot of tools. So <code>curl https://www.cryptopp.com/cryptopp563.zip -o cryptopp563.zip</code> may not work.</p>

<p>For (2), I seem to recall ZIP is missing, so <code>unzip -aoq cryptopp563.zip -d cryptopp-5.6.3</code> may not work.</p>

<p>At step (4), just perform <code>make static dynamic test</code> and be sure it finished with <strong><em><code>All tests passed</code></em></strong>.</p>

<p>I do a lot of testing with Cygwin and MinGW. I have a script that copies Crypto++ into the environments from my Desktop. I have not been able to figure out a way to automate it. A recent question on automating it was closed, so no one can supply an answer (see <a href=""https://softwareengineering.stackexchange.com/q/299614"">How to automate software testing for Cygwin and MinGW</a>).</p>
","1544","<c++><netbeans><mingw><cross-compiling><crypto++>","2","0","2","2017-02-23 11:43:56","","4","","5437430","","2015-10-13 00:02:26","2015-10-12 18:34:52",""
"33087932","How to build Crypto++ library on Linux with MinGW?","<p>im trying to port a c++ project from visual studio 2013 to netbeans on ubuntu. The target is a windows executable, so far im able to compile windows exe files from netbeans using mingw as compiler.</p>

<p>The project needs the Crypto++ library and i only have the .lib version for visual studio. To include the library in netbeans i first need to build the Crypto++ library in the .a format.</p>

<p>Its not clear to me how should i do that.
Ive found informations on how to build the library for linux with mingw but not for cross compilation with mingw. The provided GNUmakefile does not work.
Should i set up a vm with windows and mingw and compile the library that way? Or maybe use the qmake ""hack"" as suggested here <a href=""http://www.qtcentre.org/threads/28809-Compiling-amp-using-Crypto-with-mingw-version-of-Qt"" rel=""nofollow"">http://www.qtcentre.org/threads/28809-Compiling-amp-using-Crypto-with-mingw-version-of-Qt</a> ? The last good Crypto++ version suggested there is quite old. This is confusing, porting the whole project is easier than having the required library.
Im open to any suggestion.</p>

<p>tldr: how to build libcryptopp.a on linux for the cross compilation of a windows exe project</p>

<p>edit:
for example if i cross compile something there are windows libraries in the /usr/i686-w64-mingw32/lib/ folder like libuser32.a. i need to make the equivalend libcryptopp.a.. sorry if is a bit unclear.
if i simply build using the steps in answer (and in the wiki) i end up with a libcryptopp.a file but i suspect is linux-only, cause if i link that library in netbeans in the .exe file im cross compiling i end up with undefined references to cryptopp stuff everywere. the paths are correct, i suspect the library needs to be replaced with the equivalent libcryptopp.a compatible with crosscompiling.</p>

<p>edit2: im trying to follow the answer down here, now im stuck here. after this command to build cryptopp.</p>

<pre><code>    make CXX=/usr/bin/i686-w64-mingw32-gcc INCLUDES=""-I /usr/i686-w64-mingw32/include"" LIBS=""-L /usr/i686-w64-mingw32/lib"" CXXFLAGS=""-std=c++0x""
</code></pre>

<p>and many variations of it i always end up with this error</p>

<p>trap.h:26:25: fatal error: Windows.h: No such file or directory
 #    include </p>

<p>which makes me think its using the right compiler to make a .a lib file for cross compiling the windows .exe with the lib.
however i dont understand whats going on now with the missing header..:(</p>

<p>Also if i try to link the lib file (used with visual studio) i get a lot of linking errors, undefined reference to cryptopp stuff.</p>

<p>ill offer a symbolic beer (a couple of $ of Bitcoins) if someone finds out how to do it.</p>
","<p>Inspired by <a href=""http://wiki.amule.org/wiki/Cross-compilation_for_windows_with_mingw"" rel=""nofollow noreferrer"">http://wiki.amule.org/wiki/Cross-compilation_for_windows_with_mingw</a>:</p>

<pre class=""lang-sh prettyprint-override""><code>sudo apt-get install mingw-w64
git clone https://github.com/weidai11/cryptopp
cd cryptopp
export TARGET=i686-w64-mingw32
CXX=$TARGET-g++ RANLIB=$TARGET-ranlib AR=$TARGET-ar LDLIBS=-lws2_32 make -f GNUmakefile
</code></pre>
","1544","<c++><netbeans><mingw><cross-compiling><crypto++>","2","1","2","2017-02-23 11:43:56","","4","","5437430","","2015-10-13 00:02:26","2015-10-12 18:34:52",""
"23354548","How to read an image to a string for encrypting Crypto++","<p>I need to read a file as binary data, then be able encrypt and decrypt it. I am testing speeds of different algorithms in Crypto++. Up until now, I have been using getline to read text files.</p>

<pre><code>int main( int argc, char* argv[] ) {
string plaintext, ciphertext, encoded, recovered, sample_files_path, data_file, line_contents, file_size; 

ifstream initial_file_contents ( ""1MB.txt"");
if (initial_file_contents.is_open()) {
    plaintext = """";
    while ( getline( initial_file_contents, line_contents ) ) {
        plaintext = plaintext + line_contents;
        plaintext.push_back('\n');
        initial_file_contents.close();
    }
} else {
    cout &lt;&lt; ""Unable to open file"" &lt;&lt; endl;
}

/*BLOWFISH ALGORITHM*/
AutoSeededRandomPool blowfish_prng; // This class seeds itself using an operating system provided RNG
SecByteBlock blowfish_key(Blowfish::DEFAULT_KEYLENGTH); // Generate a random key
blowfish_prng.GenerateBlock(blowfish_key, blowfish_key.size()); // Generate a random initialization vector
byte blowfish_iv[Blowfish::BLOCKSIZE];
blowfish_prng.GenerateBlock(blowfish_iv, sizeof(blowfish_iv));

// Encrypts the plaintext
e.SetKeyWithIV( blowfish_key, blowfish_key.size(), blowfish_iv, sizeof(blowfish_iv) );
ciphertext.clear();
StringSource ss1(plaintext, true, new AuthenticatedEncryptionFilter( e, new StringSink( ciphertext ) )  ); 

// Decrypts the test
EAX&lt; Blowfish &gt;::Decryption d;
d.SetKeyWithIV( blowfish_key, blowfish_key.size(), blowfish_iv, sizeof(blowfish_iv) );
recovered.clear();
StringSource ss2(ciphertext, true, new AuthenticatedDecryptionFilter( d, new StringSink( recovered ), AuthenticatedDecryptionFilter::THROW_EXCEPTION ) ); 
return 0;
}
</code></pre>

<p>I have seen other articles like <a href=""https://stackoverflow.com/questions/2076475/reading-an-image-file-in-c-c"">Reading an image file in C/C++</a> and <a href=""https://stackoverflow.com/questions/17584784/read-a-binary-file-jpg-to-a-string-using-c"">Read a binary file (jpg) to a string using c++</a> , but I am unsure how to do it. I feel like <a href=""http://www.cplusplus.com/reference/istream/istream/read/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/istream/istream/read/</a> might be a good example, but I am still unsure how to implement it. Can someone show me how to read in a file such as a .jpg file, and store it as a string so I can encrypt it?</p>

<p>If I had a file named image.jpg, how would I read it in to be in a string variable like plaintext?</p>
","<p>Use a <a href=""http://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow noreferrer""><code>FileSource</code></a> and <a href=""http://www.cryptopp.com/docs/ref/class_file_sink.html"" rel=""nofollow noreferrer""><code>FileSink</code></a>. It avoids reading the data into an intermediate object like a <code>string</code>, but its probably a little more efficient under some cases.</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte iv[ Blowfish::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

string ofilename = ""puppy-and-teddy-orig.jpg"";
string efilename = ""puppy-and-teddy.enc"";
string rfilename = ""puppy-and-teddy-recovered.jpg"";

try {

    /*********************************\
    \*********************************/

    EAX&lt; Blowfish &gt;::Encryption e1;
    e1.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

    FileSource fs1(ofilename.c_str(), true,
                   new AuthenticatedEncryptionFilter(e1,
                       new FileSink(efilename.c_str())
                   ) );

    /*********************************\
    \*********************************/

    EAX&lt; Blowfish &gt;::Decryption d2;
    d2.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

    FileSource fs2(efilename.c_str(), true,
                   new AuthenticatedDecryptionFilter( d2,
                       new FileSink( rfilename.c_str() ),
                       AuthenticatedDecryptionFilter::THROW_EXCEPTION
                   ) );

} catch (const Exception&amp; ex) {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>Here's the image:</p>

<p><img src=""https://i.stack.imgur.com/HC5Ym.jpg"" alt=""enter image description here""></p>

<p>Here's the encrypted image under a hex editor:</p>

<p><img src=""https://i.stack.imgur.com/y6caC.png"" alt=""enter image description here""></p>

<p>Running it produces no difference between the original and recovered images:</p>

<pre><code>$ ./cryptopp-test.exe
$ diff puppy-and-teddy-orig.jpg puppy-and-teddy-recovered.jpg 
$
</code></pre>

<hr>

<p>If you <em>really</em> want to read it into a string, here are the relevant changes:</p>

<pre><code>std::ifstream ifile(""puppy-and-teddy-orig.jpg"", ios::binary);
std::ifstream::pos_type size = ifile.seekg(0, std::ios_base::end).tellg();
ifile.seekg(0, std::ios_base::beg);

string temp;
temp.resize(size);
ifile.read((char*)temp.data(), temp.size());

/*********************************\
\*********************************/

EAX&lt; Blowfish &gt;::Encryption e1;
e1.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

StringSource ss1(temp, true,
                 new AuthenticatedEncryptionFilter( e1,
                     new FileSink(efilename.c_str())
                 ) );

/*********************************\
\*********************************/

EAX&lt; Blowfish &gt;::Decryption d2;
d2.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

FileSource fs2(efilename.c_str(), true,
               new AuthenticatedDecryptionFilter(d2,
                   new FileSink(rfilename.c_str()),
                   AuthenticatedDecryptionFilter::THROW_EXCEPTION
               ) );
</code></pre>
","1541","<encryption><file-io><binaryfiles><blowfish><crypto++>","1","1","1","2014-06-18 15:35:04","23355279","6","","-1","","2017-05-23 12:28:35","2014-04-29 02:44:03",""
"4692547","How can I build the 64-bit version of the Crypto++ dll?","<p>I'm currently working on implementing the crypto++ libs into a c# app. It's all working fine in 32 bit.
However when I tried to build the c++ DLL in 64 bit, I got this error:</p>

<blockquote>
  <p>Error 1 error PRJ0019: A tool returned an error code from ""Performing Custom Build Step"" cryptopp cryptopp</p>
</blockquote>

<p>I then changed the project settings to build in Unicode from the default multibyte, and got it to build with no errors. However, it will then fail the safety check when using the <code>GetPowerUpSelfTestStatus()</code>.</p>

<p>I've googled the heck out of this, and apparently this is not an uncommon problem. However no one seems to have found a solution, or at least hasn't shared it.</p>

<p>What can I do? </p>
","<p>The problem was with the custom build step options under the project preferences. Just change the leading output directory folder from 'Win32' to 'x64' with x64 as your target platform. =/</p>
","1498","<c++><dll><64-bit><crypto++>","1","3","1","2011-08-22 20:24:49","4726550","1","","600500","","2011-08-22 20:24:49","2011-01-14 15:17:02",""
"20266368","ECDSA signature size too long?","<p>I'm creating a key pair using</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::Signer signer;
signer.AccessKey().Initialize(randomGeneratorM, ASN1::secp160r1());
...
ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
signer.AccessKey().MakePublicKey(publicKey);
</code></pre>

<p>Loading, saving, signing and verification works fine. But my signature is always 42 bytes, when I expected it to be ""40"" (twice the size of the 160 key bits).</p>

<p>The signature is generated as:</p>

<pre><code>std::string data ...
ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);
byte signatureBuffer[42];
size_t signatureLength = signer.SignMessage(
  randomGeneratorM, (const byte*)data.c_str(), data.size(), signatureBuffer);
</code></pre>

<p>I couldn't find any documentation that the signature might be encoded. So I'm curious: where do the extra bytes come from?</p>

<p>In fact, <code>signer.MaxSignatureLength()</code> returns ""42"" and for all the signatures generated so far, the signature length was never anything other.</p>

<p>I am aware that ""42"" is the answer to life, the universe and everything ;) </p>

<p>Oh, and CryptoPP V5.6.2, Visual Studio 2008 <br />
Sample signature (in hex):</p>

<blockquote>
  <p>00F9C6853895481DDA23517DE16AA44518CDB2C9A900FF9AACA718DFB2AAA9C10E45265224EC40C7FD63</p>
</blockquote>
","<blockquote>
  <p>I couldn't find any documentation that the signature might be encoded. So I'm curious: where do the extra bytes come from?</p>
</blockquote>

<p>Crypto++ uses IEEE P1363 encoding of the <code>{R,S}</code> tuple, which is a simple concatenation. The 42 is <code>MaxImage()</code> size, which is the largest the signature can be. That's based on the encoding of the <code>{R,S}</code> tuple under the P1363 standard.</p>

<p>If interested, digital signature formats are discussed at <a href=""http://www.codeproject.com/Articles/25590/Cryptographic-Interoperability-Digital-Signatures"" rel=""nofollow"">Cryptographic Interoperability: Digital Signatures</a>.</p>

<hr>

<blockquote>
  <p>00F9C6853895481DDA23517DE16AA44518CDB2C9A900FF9AACA718DFB2AAA9C10E45265224EC40C7FD63</p>
</blockquote>

<p>This breaks out to:</p>

<pre><code>00F9C6853895481DDA23517DE16AA44518CDB2C9A9
00FF9AACA718DFB2AAA9C10E45265224EC40C7FD63
</code></pre>

<p>which is a concatenation of two ASN.1 encoded values <em>without</em> the integer type information. Crypto++ knows the size of <code>R</code> and <code>S</code> because its an integral part of the domain parameters. Specifically, its <code>ASN1::secp160r1()</code> which is a 160-bit curves.</p>

<p>ASN.1 Integers are two's compliment encoded (see ITU's X.690 <a href=""http://www.itu.int/rec/T-REC-X.690-200811-I/en"" rel=""nofollow"">Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)</a> and friends), and <code>R</code> and <code>S</code> are positive per IEEE P1363 (see IEEE's P1363 Section 5.6.1 <a href=""http://grouper.ieee.org/groups/1363/IBC/material/P1363.3-D1-200805.pdf"" rel=""nofollow"">Converting Between Integers and Bit Strings</a>). So you have to have a leading <code>0x00</code> octet.</p>

<p>If you used <code>secp256r1()</code>, then <code>MaxImage()</code> and <code>MaxSignatureLength()</code> would increase accordingly.</p>

<hr>

<p>For completeness, Java using a different form of encoding. Here it is:</p>

<pre><code>SEQUENCE ::= {
  r INTEGER,
  s INTEGER
}
</code></pre>

<p>That means you have a 20 octets <code>r</code> plus 2 octets for ASN.1 integer encoding, 20 octets <code>s</code> plus 2 octets for ASN.1 integer encoding, and 2 octets for the sequence encoding. For a total of 46 octets. If <code>r</code> or <code>s</code> is negative in 2's compliment format, then you need to add a byte for the leading 0x00 octet. So it could be 48 bytes.</p>

<hr>

<p>Crypto++ offers a function for converting between P1363, Java and OpenPGP signatures called <code>DSAConvertSignatureFormat</code>. You can see the source code in <a href=""http://www.cryptopp.com/docs/ref/dsa_8cpp_source.html"" rel=""nofollow"">dsa.cpp</a> (there's not much to it).</p>
","1489","<c++><crypto++>","1","3","1","2014-01-10 08:46:49","21034979","4","","993915","","2013-11-29 07:14:35","2013-11-28 12:34:08",""
"17028444","Unable to do RSA Encryption/Decryption using Crypto++ (isValidCoding is false)","<p>I am using Crypto++ to encrypt an array of bytes using RSA. I have followed Crypto++ wiki's samples with no luck getting them to work. Encryption and Decryption in all the samples are done within a single process but I am trying to decrypt the content which is already encrypted in another process.
Here is my code:</p>

<pre><code>class FixedRNG : public CryptoPP::RandomNumberGenerator
{
public:
    FixedRNG(CryptoPP::BufferedTransformation &amp;source) : m_source(source) {}

    void GenerateBlock(byte *output, size_t size)
    {
        m_source.Get(output, size);
    }

private:
    CryptoPP::BufferedTransformation &amp;m_source;
};


uint16_t Encrypt()
{
    byte *oaepSeed = new byte[2048];
    for (int i =  0; i &lt; 2048; i++)
    {
        oaepSeed[i] = (byte)i;
    }
    CryptoPP::ByteQueue bq;
    bq.Put(oaepSeed, 2048);
    FixedRNG prng(bq);
    Integer n(""Value of N""),
    e(""11H""),
    d(""Value of D"");
    RSA::PrivateKey privKey;
    privKey.Initialize(n, e, d);
    RSA::PublicKey pubKey(privKey);
    CryptoPP::RSAES_OAEP_SHA_Encryptor encryptor( pubKey );
    assert( 0 != encryptor.FixedMaxPlaintextLength() );
    byte blockSize = encryptor.FixedMaxPlaintextLength();
    int divisionCount = fileSize / blockSize;
    int proccessedBytes = 0;
    // Create cipher text space
    uint16_t cipherSize = encryptor.CiphertextLength( blockSize );
    assert( 0 != cipherSize );

    encryptor.Encrypt(prng, (byte*)plaintext, blockSize, (byte*)output);
    return cipherSize;
}

void Decrypt(uint16_t cipherSize)
{
        byte *oaepSeed = new byte[2048];
        for (int i =  0; i &lt; 2048; i++)
        {
            oaepSeed[i] = (byte)i;
        }
        CryptoPP::ByteQueue bq;
        bq.Put(oaepSeed, 2048);
        FixedRNG prng(bq);
        Integer n(""Value of N""),
        e(""11H""),
        d(""Value of D"");
        RSA::PrivateKey privKey;
        privKey.Initialize(n, e, d);
        //RSA::PublicKey pubKey(privKey);

        CryptoPP::RSAES_OAEP_SHA_Decryptor decryptor( privKey );

        byte blockSize = decryptor.FixedMaxPlaintextLength();
        assert(blockSize != 0);

        size_t maxPlainTextSize = decryptor.MaxPlaintextLength( cipherSize );
        assert( 0 != maxPlainTextSize );
        void* subBuffer = malloc(maxPlainTextSize);
        CryptoPP::DecodingResult result = decryptor.Decrypt(prng, (byte*)cipherText, cipherSize, (byte*)subBuffer);
        assert( result.isValidCoding );
        assert( result.messageLength &lt;= maxPlainTextSize );
}
</code></pre>

<p>Unfortunately, value of isValidCoding is false. I think I am misunderstanding something about RSA encryption/decryption!!
<br/>
Note that, privKey and pubKey have been validated using KEY.Validate(prng, 3).
I have also tried to use RAW RSA instead of OAEP and SHA with no luck. I have tried to debug through crypto++ code, what I am suspicious about is <i>prng</i> variable. I think there is something wrong with it. I have also used AutoSeededRandomPool instead of FixedRNG but it didn't help.<br/> Worth to know that, if I copy the decryption code right after encryption code and execute it in Encrypt() method, everything is fine and isValidCoding is true!!</p>
","<p>This is probably not be correct:</p>

<pre><code>byte blockSize = encryptor.FixedMaxPlaintextLength();
...

encryptor.Encrypt(prng, (byte*)plaintext, blockSize, (byte*)output);
return cipherSize;
</code></pre>

<p>Try:</p>

<pre><code>size_t maxLength = encryptor.FixedMaxPlaintextLength();
size_t cipherLength = encryptor.CiphertextLength( blockSize );
...

SecureByteBlock secBlock(cipherLength);

cipherLength = encryptor.Encrypt(prng, (byte*)plaintext, blockSize, secBlock);
secBlock.resize(cipherLength);
</code></pre>

<p><code>FixedMaxPlaintextLength</code> returns a <code>size_t</code>, not a <code>byte</code>.</p>

<p>You should probably be calling <code>CiphertextLength</code> on <code>plaintext</code>.</p>

<p>I'm not really sure how you are just returning an <code>uint_t</code> from <code>encrypt()</code>.</p>

<p>You might do better by starting fresh, and using an example from the Crypto++ as a starting point. I'm not sure this design is worth pursuing.</p>

<p>If you start over, then Shoup's Elliptic Curve Integrated Encryption Scheme (ECIES) would be a good choice since it combines public key with symmetric ciphers and authentication tags.</p>
","1485","<c++><rsa><public-key-encryption><crypto++>","2","0","1","2018-06-27 02:43:47","","4","","1033581","","2018-06-27 02:43:47","2013-06-10 16:18:58",""
"28104086","How to build a project using Crypto++ library in kdevelop","<p>I wrote a small program that uses the <code>crypto++</code>library using <code>kdevelop</code> in <code>Ubuntu</code>. I get the output correctly when I compile it from the terminal using <code>-lcryptopp</code>. I would like to build and execute the program using the <code>cmake</code> from <code>kdevelop</code> itself. How can I include the <code>CRYPTOPP_DIR</code> in the <code>cmake configuration</code> for doing this.</p>

<p>Any help will be appreciated. Thankyou.</p>
","<p>Adding the following piece of code to cmake file helped me:</p>

<pre><code>FIND_LIBRARY(CRYPTOPP crypto++ /usr/lib) ## location of libcryptopp.so or libcryptopp.a
IF ( CRYPTOPP )
TARGET_LINK_LIBRARIES(${PROGRAM_NAME} cryptopp ) ## Specifying cryptopp in uppercase gave me link error.
ENDIF( CRYPTOPP )
</code></pre>

<p>If <code>pthread library</code> is needed, also add it in the cmake file.
This worked for me. Got the solution from <a href=""https://forum.anope.org"" rel=""nofollow"">https://forum.anope.org</a></p>
","1473","<build><cmake><ubuntu-14.04><crypto++><kdevelop4>","2","2","1","2015-02-27 23:55:36","28164589","2","2","608639","","2015-02-27 23:55:36","2015-01-23 06:17:45",""
"21896874","Get hexadecimal encrypted string in AES 256 Crypto++","<p>I am trying to implement the AES 256 algorithm using Crypto++ in MS visual studio. Operating system is Windows 7 (64 bit).</p>

<p>I need to provide the key as a hexadecimal string, password as string and finally i want the encrypted string to also be hexadecimal string.</p>

<p>Here is what I am trying to do:</p>

<p>My encrypt method:</p>

<pre><code>std::string encrypt(const std::string &amp;password)
{
    std::string plain = password;
    std::string ciphertext;
    char * decodedKey= ""729308A8E815F6A46EB3A8AE6D5463CA7B64A0E2E11BC26A68106FC7697E727E37011"";

    byte key[ CryptoPP::AES::MAX_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    CryptoPP::StringSource( reinterpret_cast&lt;const char *&gt;(decodedKey), true,
              new  CryptoPP::HashFilter(*(new  CryptoPP::SHA256), new CryptoPP::ArraySink(key, CryptoPP::AES::MAX_KEYLENGTH)) );
    memset( iv, 0x00,  CryptoPP::AES::BLOCKSIZE );

    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption Encryptor( key, sizeof(key), iv );
    CryptoPP::StringSource( plain, true, new CryptoPP::StreamTransformationFilter( Encryptor,
              new CryptoPP::HexEncoder(new CryptoPP::StringSink( ciphertext ) ) ) );

    std::cout&lt;&lt;""Ciphertext:"" &lt;&lt; ciphertext;
    return ciphertext;
}
</code></pre>

<p>From main method</p>

<pre><code>int main(int argc, char* argv[]) {

    encrypt(""test"");
    return 0;
}
</code></pre>

<p>At present I am hardcoding the key just for debugging purposes. My key is hexadecimal string as seen below. I need to get the output encrypted string as hex string.</p>
","<blockquote>
  <p>I need to provide the key as a hexadecimal string, password as string and finally i want the encrypted string to also be hexadecimal string.</p>
</blockquote>

<p>This is covered in the Crypto++ wiki (there's lots of examples in there ready for copy/paste). From <a href=""http://www.cryptopp.com/wiki/HexDecoder#Scripting_and_Strings"" rel=""nofollow"">HexDecoder's Scripting and Strings</a>:</p>

<blockquote>
  <p>On occasion, the mailing list will receive questions on
  cross-validation. For example, see AES CTR Chiper. Different output
  between PHP-mcrypt and Crypto++. In the question, PHP-mcrypt strings
  are used as follows:</p>

<pre><code>$key = ""1234567890123456789012345678901234567890123456789012345678901234"";
$key = pack(""H"".strlen($key), $key);
$iv = ""1111111111222222222233333333334444444444555555555566666666667777"";
$iv = pack(""H"".strlen($iv), $iv);
</code></pre>
  
  <p>One of the easiest ways to avoid typos is via Copy/Paste and a
  HexDecoder:</p>

<pre><code>string encodedKey = ""1234567890123456789012345678901234567890123456789012345678901234"";
string encodedIv = ""1111111111222222222233333333334444444444555555555566666666667777"";
string key, iv;

StringSource ssk(encodedKey, true /*pumpAll*/,
    new HexDecoder(
        new StringSink(key)
    ) // HexDecoder
); // StringSource

StringSource ssv(encodedIv, true /*pumpAll*/,
    new HexDecoder(
        new StringSink(iv)
    ) // HexDecoder
); // StringSource
</code></pre>
</blockquote>

<p>After running the above code, <code>key</code> and <code>iv</code> are hexadecimal (i.e., binary) strings rather than printable (i.e., ASCII) strings.</p>
","1469","<c++><encryption><crypto++>","1","2","1","2014-02-25 17:13:45","21907730","2","","608639","","2014-02-20 15:19:56","2014-02-20 02:28:34",""
"15449756","256-bit Rijndael blocksize?","<p>I am trying to port a decryption routine from C# program to C++ using cryptopp, but I have a problem. In the C# program, the key and IV are both 256 bits. So I tried to do something like this:</p>

<pre><code>    char *hash1 = ""......"";
    std::string hash2;

    CryptoPP::StringSource(hash1, true,new CryptoPP::Base64Decoder(new CryptoPP::StringSink(hash2)));
    CryptoPP::Rijndael::Decryption decryptor(key, 32);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( decryptor, iv);
    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, (new CryptoPP::StringSink( decryptedData ) ));
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( hash2.c_str() ), hash2.size() );
    stfDecryptor.MessageEnd();
</code></pre>

<p>and I am getting</p>

<blockquote>
  <p>StreamTransformationFilter: ciphertext length is not a multiple of block size.</p>
</blockquote>

<p>I tried to pass IV size like this:</p>

<pre><code>    CryptoPP::CBC_Mode&lt;CryptoPP::Rijndael &gt;::Decryption decr;
    decr.SetKeyWithIV(key, 32, iv, 32);
</code></pre>

<p>But then I get:</p>

<blockquote>
  <p>IV length 32 exceeds the maximum of 16.</p>
</blockquote>

<p>So, how can I decrypt data, when it was encrypted by IV with length = 32?</p>
","<p>Looking at the implementation, the current iterations of crypto++ only support Rijndael with a block size of 16 bytes. As the IV has to be precisely a single block for CBC mode, Rijndael with a 256 bit block size does not seem to be possible.</p>
","1458","<c++><encryption><aes><crypto++>","3","3","1","2015-02-16 10:43:45","15509369","6","","608639","","2015-02-16 10:43:45","2013-03-16 13:18:51",""
"31366107","How to encrypt/decrypt using RSA/OAEP if we have public key only","<p>I'm learning Crypto++ library. I've read lot of examples but didn't find how to encrypt/decrypt plain text message when the program has access to public key only, when the program not generates the keys.</p>

<pre><code>CryptoPP::RSA::PublicKey pubKey;
pubKey.Load(CryptoPP::StringSource(SSL_PUB_KEY, true, new CryptoPP::Base64Decoder()).Ref());
CryptoPP::RSAES_OAEP_SHA_Encryptor e(pubKey);
</code></pre>

<p>But what to do after that? </p>
","<p>If you encrypt with public key, you decrypt it with private key. This is the whole point of rsa - asymmetric key encryption, you need key pair.</p>

<p>RSA also support ""message signing"" that you encrypt (usually a reduced MAC hash) with private key, but then you decrypt it with public key.</p>
","1457","<c++><rsa><crypto++>","0","2","2","2015-07-14 13:53:29","31366904","5","1","608639","","2015-07-12 21:19:58","2015-07-12 08:59:22","2015-07-12 11:01:32"
"31366107","How to encrypt/decrypt using RSA/OAEP if we have public key only","<p>I'm learning Crypto++ library. I've read lot of examples but didn't find how to encrypt/decrypt plain text message when the program has access to public key only, when the program not generates the keys.</p>

<pre><code>CryptoPP::RSA::PublicKey pubKey;
pubKey.Load(CryptoPP::StringSource(SSL_PUB_KEY, true, new CryptoPP::Base64Decoder()).Ref());
CryptoPP::RSAES_OAEP_SHA_Encryptor e(pubKey);
</code></pre>

<p>But what to do after that? </p>
","<p>I've get how to do it. I missundertood what RandonGenerator is and I thought that I have to get it from a key.</p>

<p>After that I do following:</p>

<pre><code>CryptoPP::AutoSeededRandomPool rng;
string cipher;
CryptoPP::StringSource ss1(stringToEncrypt, true, new CryptoPP::PK_EncryptorFilter(rng, e, new CryptoPP::StringSink(cipher)));
</code></pre>

<p>now we have encrypted data in <code>cipher</code></p>
","1457","<c++><rsa><crypto++>","0","0","2","2015-07-14 13:53:29","31366904","5","1","608639","","2015-07-12 21:19:58","2015-07-12 08:59:22","2015-07-12 11:01:32"
"27232053","Creation of ECDSA private key given curve and private exponent?","<p>I am new to cryptopp and have been struggling for a while with the creation of  private keys for ECDSA signing.</p>

<p>I have a hex encoded private exponent <code>E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB</code>. This is stored as a string.</p>

<p>I want to use this to sign a text block using ECDSA.  My code looks a bit like this</p>

<pre><code>string Sig::genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
   AutoSeededRandomPool prng;
   ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
   privateKey.AccessGroupParameters().Initialize(ASN1::secp256r1());
   privateKey.Load(StringSource(privKeyIn, true, NULL).Ref());
   ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);

   // Determine maximum size, allocate a string with that size
   size_t siglen = signer.MaxSignatureLength();
   string signature(siglen, 0x00);

   // Sign, and trim signature to actual size
   siglen = signer.SignMessage(prng, (const byte *) messageIn.data(), (size_t) messageIn.length(),       (byte*)signature.data());
   signature.resize(siglen);
   cout &lt;&lt; signature.data() &lt;&lt; endl;
   return signature;
}
</code></pre>

<p>This code generates the following error in Visual studio on the when I try to do privateKey.load(...)</p>

<pre><code>First-chance exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
Unhandled exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
</code></pre>

<p>I am guessing I am doing something a bit stupid... any help would be great???</p>

<p>PS I had a similar issue using ECDH for GMAC generation but got round this by saving the key as a SECByteBlock but this 'trick' doesnt seem to work in this case.</p>
","<blockquote>
  <p>DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr ...</p>
</blockquote>

<p>You have a private exponent, and <em>not</em> a private key. So you should <em>not</em> call <code>Load</code> on it. That's causing the Crypto++ <code>BERDecodeErr</code> exception.</p>

<p>The answer is detailed on the <a href=""http://www.cryptopp.com/wiki/Ecdsa#Private_Key_2"" rel=""nofollow"">ECDSA wiki page</a>, but its not readily apparent. You need to perform the following to initialize the <code>privateKey</code> given the curve and exponent::</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";
exp.insert(0, ""0x"");

Integer x(exp.c_str());
privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<p>Prepending the <code>""0x""</code> ensures the <code>Integer</code> class will parse the ASCII string correctly. You can also append a <code>""h""</code> character to the string. You can see the parsing code for <code>Integer</code> class at <a href=""http://www.cryptopp.com/docs/ref/integer_8cpp_source.html"" rel=""nofollow"">Integer.cpp</a> around line 2960 in the <code>StringToInteger</code> function.</p>

<hr>

<p>Here's another way to do the same thing:</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";

HexDecoder decoder;
decoder.Put((byte*)exp.data(), exp.size());
decoder.MessageEnd();

Integer x;
x.Decode(decoder, decoder.MaxRetrievable());

privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<p>The <a href=""http://www.cryptopp.com/wiki/Hexdecoder"" rel=""nofollow""><code>HexDecoder</code></a> will perform the ASCII to binary conversion for you. The buffer held by the <code>HexDecoder</code> will then be consumed by the <code>Integer</code> using its <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow""><code>Decode (BufferedTransformation &amp;bt, size_t inputLen, Signedness=UNSIGNED)</code></a> method.</p>

<hr>

<p>And here is another way using <a href=""http://www.cryptopp.com/wiki/Hexdecoder"" rel=""nofollow""><code>HexDecoder</code></a> (Crypto++ is as bad as scripting languages at times :)...</p>

<pre><code>string exp = ""E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB"";
StringSource ss(exp, true /*punpAll*/, new HexDecoder);

Integer x;
x.Decode(ss, ss.MaxRetrievable());

privateKey.Initialize(ASN1::secp256r1(), x);
</code></pre>

<hr>

<p>After initializing the key, you should validate it:</p>

<pre><code>bool result = privateKey.Validate( prng, 3 );
if( !result ) { /* Handle error */ }
</code></pre>

<hr>

<p>This will output binary data:</p>

<pre><code>cout &lt;&lt; signature.data() &lt;&lt; endl;
</code></pre>

<p>If you want something printable/readable, run it though a Crypto++ <a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow"">HexEncoder</a>.</p>
","1447","<c++><private-key><crypto++><ecdsa><signer>","2","2","2","2015-06-16 23:05:21","27232308","2","1","15541","","2014-12-02 05:22:13","2014-12-01 15:50:43",""
"27232053","Creation of ECDSA private key given curve and private exponent?","<p>I am new to cryptopp and have been struggling for a while with the creation of  private keys for ECDSA signing.</p>

<p>I have a hex encoded private exponent <code>E4A6CFB431471CFCAE491FD566D19C87082CF9FA7722D7FA24B2B3F5669DBEFB</code>. This is stored as a string.</p>

<p>I want to use this to sign a text block using ECDSA.  My code looks a bit like this</p>

<pre><code>string Sig::genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
   AutoSeededRandomPool prng;
   ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
   privateKey.AccessGroupParameters().Initialize(ASN1::secp256r1());
   privateKey.Load(StringSource(privKeyIn, true, NULL).Ref());
   ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);

   // Determine maximum size, allocate a string with that size
   size_t siglen = signer.MaxSignatureLength();
   string signature(siglen, 0x00);

   // Sign, and trim signature to actual size
   siglen = signer.SignMessage(prng, (const byte *) messageIn.data(), (size_t) messageIn.length(),       (byte*)signature.data());
   signature.resize(siglen);
   cout &lt;&lt; signature.data() &lt;&lt; endl;
   return signature;
}
</code></pre>

<p>This code generates the following error in Visual studio on the when I try to do privateKey.load(...)</p>

<pre><code>First-chance exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
Unhandled exception at 0x7693C42D in DLLTest.exe: Microsoft C++ exception: CryptoPP::BERDecodeErr at memory location 0x0033EEA8.
</code></pre>

<p>I am guessing I am doing something a bit stupid... any help would be great???</p>

<p>PS I had a similar issue using ECDH for GMAC generation but got round this by saving the key as a SECByteBlock but this 'trick' doesnt seem to work in this case.</p>
","<p>for others looking for this later </p>

<pre><code>string genSignature(const string&amp; privKeyIn, const string&amp; messageIn)
{
    CryptoPP::Integer secretNumber(genSecretNumber(privKeyIn, messageIn));
    AutoSeededRandomPool secretNumberGenerator;

    if (encryptBase::debug)
    {
        cout &lt;&lt; ""secret number: "" &lt;&lt; secretNumber &lt;&lt; endl;
    }

    SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
    ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
    string exp(privKeyIn);
    exp.insert(0, ""0x"");
    Integer x(exp.c_str());
    privateKey.Initialize(ASN1::secp256r1(), x);
    AutoSeededRandomPool prng;
    if (!privateKey.Validate(prng, 3))
    {
        cout &lt;&lt; ""unable to verify key"" &lt;&lt; endl;
        return ""failed to verify key"";
    }

    ECDSA&lt;ECP, SHA256&gt;::Signer signer(privateKey);
    size_t siglen = signer.MaxSignatureLength();
    string signature(siglen, 0x00);
    siglen = signer.SignMessage(secretNumberGenerator, message.BytePtr(), message.size(),     (byte*)signature.data());
    signature.resize(siglen);

    string encoded;
    HexEncoder encoder;
    encoder.Put((byte *) signature.data(), signature.size());
    encoder.MessageEnd();
    word64 size = encoder.MaxRetrievable();
    if (size)
    {
        encoded.resize(size);
        encoder.Get((byte*)encoded.data(), encoded.size());
    }

    return encoded;
}
</code></pre>
","1447","<c++><private-key><crypto++><ecdsa><signer>","2","0","2","2015-06-16 23:05:21","27232308","2","1","15541","","2014-12-02 05:22:13","2014-12-01 15:50:43",""
"31698241","Linking error when compiling Crypto++ for ARMHF","<p>I'm trying to compile the crypto++ library to run for the armhf architecture. I'm following the method provided in this <a href=""https://stackoverflow.com/a/31665198/3079474"">answer</a>. I tweaked the <code>setenv-embed.sh</code> to match my system's configuration. The output of running <code>. ./setenv-embed.sh</code> is </p>

<pre><code>CPP: /usr/bin/arm-linux-gnueabihf-cpp 
CXX: /usr/bin/arm-linux-gnueabihf-g++
AR: /usr/bin/arm-linux-gnueabihf-ar
LD: /usr/bin/arm-linux-gnueabihf-ld
RANLIB: /usr/bin/arm-linux-gnueabihf-gcc-ranlib-4.8

ARM_EMBEDDED_TOOLCHAIN: /usr/bin
ARM_EMBEDDED_CXX_HEADERS: /usr/arm-linux-gnueabihf/include/c++/4.8.2
ARM_EMBEDDED_FLAGS: -march=armv7-a mfloat-abi=hard -mfpu=neon -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf 
ARM_EMBEDDED_SYSROOT: /usr/arm-linux-gnueabihf
</code></pre>

<p>which indicates that the correct compilers have been found. However, when I build the library using <code>make</code> I run into the following error</p>

<pre><code>/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc.so.6 inside /usr/arm-linux-gnueabihf
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc_nonshared.a inside /usr/arm-linux-gnueabihf        
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 inside /usr/arm-linux-gnueabihf
</code></pre>

<p>But when I open the location <code>/usr/arm-linux-gnueabihf/lib</code> I can find all the three error files mentioned above ie <code>libc.so.6</code>, <code>libc_nonshared.a</code> and <code>ld-linux-armhf.so.3</code></p>

<p>I'm trying to compile the library for Beaglebone, if that helps.</p>

<p><strong>Update 1:</strong></p>

<p>The results of running <code>make -f GNUmakefile-cross system</code> after doing a fresh <code>git pull</code></p>

<pre><code>hassan@hassan-Inspiron-7537:~/cryptopp-armhf$ make -f GNUmakefile-cross system
CXX: /usr/bin/arm-linux-gnueabihf-g++
CXXFLAGS: -DNDEBUG -g2 -Os -Wall -Wextra -DCRYPTOPP_DISABLE_ASM -march=armv7-a -mfloat-abi=hard -mfpu=neon -mthumb -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf --sysroot=/usr/arm-linux-gnueabihf -Wno-type-limits -Wno-unknown-pragmas
LDLIBS: 
GCC_COMPILER: 1
CLANG_COMPILER: 0
INTEL_COMPILER: 0
UNALIGNED_ACCESS: 
UNAME: Linux hassan-Inspiron-7537 3.13.0-35-generic #62-Ubuntu SMP Fri Aug 15 01:58:42 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
MACHINE: 
SYSTEM: 
RELEASE: 
make: Nothing to be done for `system'.
</code></pre>
","<p>The problem is simple. It is in the <code>--sysroot</code> option. The value of this option is <code>/usr/arm-linux-gnueabihf/</code> and it is used by the linker and the resulting library folder becomes
<code>/usr/arm-linux-gnueabihf/usr/arm-linux-gnueabihf/lib/</code></p>

<p>I removed the <code>--sysroot</code> option from line 68 in the file GNUmakefile-cross and everything compiled and linked OK.</p>

<p>However, I couldn't run the example on my BeagleBone Black because of mismatch of some shared libraries versions. But this wasn't a real problem for me, because in my application I link crypto++ statically, not dynamically.</p>
","1358","<c++><linker><arm><embedded><crypto++>","2","1","2","2016-02-11 00:34:06","","9","","-1","","2017-05-23 11:45:12","2015-07-29 10:44:36",""
"31698241","Linking error when compiling Crypto++ for ARMHF","<p>I'm trying to compile the crypto++ library to run for the armhf architecture. I'm following the method provided in this <a href=""https://stackoverflow.com/a/31665198/3079474"">answer</a>. I tweaked the <code>setenv-embed.sh</code> to match my system's configuration. The output of running <code>. ./setenv-embed.sh</code> is </p>

<pre><code>CPP: /usr/bin/arm-linux-gnueabihf-cpp 
CXX: /usr/bin/arm-linux-gnueabihf-g++
AR: /usr/bin/arm-linux-gnueabihf-ar
LD: /usr/bin/arm-linux-gnueabihf-ld
RANLIB: /usr/bin/arm-linux-gnueabihf-gcc-ranlib-4.8

ARM_EMBEDDED_TOOLCHAIN: /usr/bin
ARM_EMBEDDED_CXX_HEADERS: /usr/arm-linux-gnueabihf/include/c++/4.8.2
ARM_EMBEDDED_FLAGS: -march=armv7-a mfloat-abi=hard -mfpu=neon -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf 
ARM_EMBEDDED_SYSROOT: /usr/arm-linux-gnueabihf
</code></pre>

<p>which indicates that the correct compilers have been found. However, when I build the library using <code>make</code> I run into the following error</p>

<pre><code>/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc.so.6 inside /usr/arm-linux-gnueabihf
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc_nonshared.a inside /usr/arm-linux-gnueabihf        
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 inside /usr/arm-linux-gnueabihf
</code></pre>

<p>But when I open the location <code>/usr/arm-linux-gnueabihf/lib</code> I can find all the three error files mentioned above ie <code>libc.so.6</code>, <code>libc_nonshared.a</code> and <code>ld-linux-armhf.so.3</code></p>

<p>I'm trying to compile the library for Beaglebone, if that helps.</p>

<p><strong>Update 1:</strong></p>

<p>The results of running <code>make -f GNUmakefile-cross system</code> after doing a fresh <code>git pull</code></p>

<pre><code>hassan@hassan-Inspiron-7537:~/cryptopp-armhf$ make -f GNUmakefile-cross system
CXX: /usr/bin/arm-linux-gnueabihf-g++
CXXFLAGS: -DNDEBUG -g2 -Os -Wall -Wextra -DCRYPTOPP_DISABLE_ASM -march=armv7-a -mfloat-abi=hard -mfpu=neon -mthumb -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf --sysroot=/usr/arm-linux-gnueabihf -Wno-type-limits -Wno-unknown-pragmas
LDLIBS: 
GCC_COMPILER: 1
CLANG_COMPILER: 0
INTEL_COMPILER: 0
UNALIGNED_ACCESS: 
UNAME: Linux hassan-Inspiron-7537 3.13.0-35-generic #62-Ubuntu SMP Fri Aug 15 01:58:42 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
MACHINE: 
SYSTEM: 
RELEASE: 
make: Nothing to be done for `system'.
</code></pre>
","<p>Based on Crosswalking's research I think I can explain <em>what</em> is going on. I don't think I agree with the assessment <em>""The problem is simple. It is in the <code>--sysroot</code> option""</em> since the Crypto++ environment script and makefile are doing things as expected.</p>

<p>I think Crosswalking's answer could be <em>how</em> to work around it; but see open questions below. The following is from <a href=""https://github.com/weidai11/cryptopp/issues/134"" rel=""nofollow"">Crypto++ Issue 134: setenv-embedded.sh and GNUmakefile-cross</a>:</p>

<blockquote>
  <p>I think this another distro problem, similar to <a href=""https://bugs.launchpad.net/ubuntu/+source/gcc-defaults-armel-cross/+bug/1375071"" rel=""nofollow"">g++-arm-linux-gnueabi
  cannot compile a C++ program with
  --sysroot</a>.
  It might be a Ubuntu problem or a Debian problem if it is coming from
  upstream.</p>
  
  <p>When cross-compiling, we expect the following (using ARMHF):</p>
  
  <ul>
  <li><code>SYSROOT</code> is <code>/usr/arm-linux-gnueabihf</code></li>
  <li><code>INCLUDEDIR</code> is <code>/usr/arm-linux-gnueabihf/include</code></li>
  <li><code>LIBDIR</code> is <code>/usr/arm-linux-gnueabihf/lib</code></li>
  <li><code>BINDIR</code> is <code>/usr/arm-linux-gnueabihf/bin</code></li>
  </ul>
  
  <p>How <code>LIBDIR</code> morphed into into
  <code>/usr/arm-linux-gnueabihf/usr/arm-linux-gnueabihf/lib/</code> (i.e.,
  <code>$SYSROOT/$SYSROOT/lib</code>) is a mystery. But in all fairness, building
  GCC is not a trivial task.</p>
  
  <p>You should probably file a bug report with Debian or Ubuntu (or
  whomever provides the toolchain).</p>
</blockquote>

<hr>

<p>The open question for me is, since <em><code>$SYSROOT/lib</code></em> is messed up, then is <em><code>$SYSROOT/include</code></em> messed up, too?</p>

<p>If the include directory is also messed up, then the cross compile is using the host's include files, and not the target include files. That will create hard to diagnose problems later.</p>

<p>If both <em><code>$SYSROOT/include</code></em> and <em><code>$SYSROOT/lib</code></em> are messed up, then its not enough to simply remove <em><code>--sysroot</code></em>. Effectively, this is what has to be done:</p>

<pre><code># Exported by setenv-embedded
export=ARM_EMBEDDED_SYSROOT=/usr/arm-linux-gnueabihf

# Used by the makefile
-I $ARM_EMBEDDED_SYSROOT/$ARM_EMBEDDED_SYSROOT/include
-L $ARM_EMBEDDED_SYSROOT/$ARM_EMBEDDED_SYSROOT/lib
</code></pre>

<p>Which means we should be able to do the following:</p>

<pre><code># Exported by setenv-embedded
export=ARM_EMBEDDED_SYSROOT=/usr/arm-linux-gnueabihf/usr/arm-linux-gnueabihf

# Used by the makefile
--sysroot=""$ARM_EMBEDDED_SYSROOT""
</code></pre>

<hr>

<p>Finally, this looks a lot like Ubuntu's <a href=""http://bugs.launchpad.net/ubuntu/+source/gcc-defaults-armel-cross/+bug/1375071"" rel=""nofollow"">Bug 1375071: g++-arm-linux-gnueabi cannot compile a C++ program with --sysroot</a>. The bug report specifically calls out <strong><em>... the built-in paths use an extra ""/usr/arm-linux-gnueabi""</em></strong>.</p>

<blockquote>
  <p>We need the paths:</p>
  
  <p>A) /usr/arm-linux-gnueabi/include/c++/4.7.3<br>   B)
  /usr/arm-linux-gnueabi/include/c++/4.7.3/arm-linux-gnueabi</p>
  
  <p>But the built-in paths tries to use:</p>
  
  <p>C) /usr/arm-linux-gnueabi/usr/arm-linux-gnueabi/include/c++/4.7.3<br>
  D)
  /usr/arm-linux-gnueabi/usr/arm-linux-gnueabi/include/c++/4.7.3/arm-linux-gnueabi/sf
  E)
  /usr/arm-linux-gnueabi/usr/arm-linux-gnueabi/include/c++/4.7.3/backward</p>
  
  <p>Notice the built-in paths use an extra ""/usr/arm-linux-gnueabi""</p>
</blockquote>
","1358","<c++><linker><arm><embedded><crypto++>","2","0","2","2016-02-11 00:34:06","","9","","-1","","2017-05-23 11:45:12","2015-07-29 10:44:36",""
"21079564","How to verify ECDSA signature with Crypto++ without the verify function?","<p>I made a Signer/Checker mechanisms with ECDSA using Crypto++.</p>

<p>The problem is when I want to check signature it doesn't work with Verify function.</p>

<p>Can you propose me a more manual way to verify signature?</p>
","<blockquote>
  <p>How to verify ECDSA signature with Crypto++ without the verify function?</p>
</blockquote>

<p>I'm not sure how you would verify code without a verify function. I'm probably not understanding the question.</p>

<p>Just in case, here's how Crypto++ implements its verification code.</p>

<p>First, <code>ECDSA</code> is a <code>DL_Algorithm_ECDSA</code> (from <code>eccrypto.h</code>):</p>

<pre><code>//! ECDSA algorithm
template &lt;class EC&gt;
class DL_Algorithm_ECDSA : public DL_Algorithm_GDSA&lt;typename EC::Point&gt;
{
public:
    static const char * CRYPTOPP_API StaticAlgorithmName() {return ""ECDSA"";}
};
...

template &lt;class EC, class H&gt;
struct ECDSA :
    public DL_SS&lt;DL_Keys_ECDSA&lt;EC&gt;, DL_Algorithm_ECDSA&lt;EC&gt;,
               DL_SignatureMessageEncodingMethod_DSA, H&gt;
{
};
</code></pre>

<p>Next, here's verify function from <code>DL_Algorithm_GDSA</code> in <code>gfcrypt.h</code>:</p>

<pre><code>bool Verify(const DL_GroupParameters&lt;T&gt; &amp;params, const DL_PublicKey&lt;T&gt; &amp;publicKey,
                const Integer &amp;e, const Integer &amp;r, const Integer &amp;s) const
{
    const Integer &amp;q = params.GetSubgroupOrder();
    if (r&gt;=q || r&lt;1 || s&gt;=q || s&lt;1)
        return false;

    Integer w = s.InverseMod(q);
    Integer u1 = (e * w) % q;
    Integer u2 = (r * w) % q;

    return r == params.ConvertElementToInteger(
                    publicKey.CascadeExponentiateBaseAndPublicElement(u1, u2)) % q;
}
</code></pre>

<hr>

<p>The code below uses <code>VerifyMessage</code>, and its part of <code>PK_Verifier</code> declared in <code>cryptolib.h</code>:</p>

<pre><code>virtual bool VerifyMessage(const byte *message, size_t messageLen, 
                 const byte *signature, size_t signatureLength) const;
</code></pre>

<p><code>PK_Verifier</code> is the 'master' base class that objects like <code>ECDSA</code>, <code>NR</code>, and <code>RSASS</code> use to expose the consistent interface.</p>

<p>Objects like <code>ECDSA</code>, <code>NR</code>, and <code>RSASS</code> connect to <code>PK_Verifier</code> via the <code>DL_SS</code>:</p>

<pre><code>template &lt;class EC, class H&gt;
struct ECDSA :
    public DL_SS&lt;DL_Keys_ECDSA&lt;EC&gt;, DL_Algorithm_ECDSA&lt;EC&gt;, DL_SignatureMessageEncodingMethod_DSA, H&gt;
{
};
</code></pre>

<p>Finally, here's how <code>DL_SS</code> relates to <code>PK_Verifier</code> (from <code>pubkey.h</code>):</p>

<pre><code>//! Discrete Log Based Signature Scheme
template &lt;class KEYS, class SA, class MEM, class H, class ALG_INFO = DL_SS&lt;KEYS, SA, MEM, H, int&gt; &gt;
class DL_SS : public KEYS
{
    typedef DL_SignatureSchemeOptions&lt;ALG_INFO, KEYS, SA, MEM, H&gt; SchemeOptions;
    ...

    //! implements PK_Signer interface
    typedef PK_FinalTemplate&lt;DL_SignerImpl&lt;SchemeOptions&gt; &gt; Signer;
    //! implements PK_Verifier interface
    typedef PK_FinalTemplate&lt;DL_VerifierImpl&lt;SchemeOptions&gt; &gt; Verifier;
};
</code></pre>

<hr>

<blockquote>
  <p>The problem is when I want to check signature it doesn't work with Verify function.</p>
</blockquote>

<p>There's lots of code available on the Crypto++ wiki. For ECDSA, see <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a>. Below is a signing a verification sample taken from the wiki.</p>

<p><strong>Sign</strong></p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
privateKey.Load(...);
privateKey.Validate(prng, 3);

ECDSA&lt;ECP, SHA1&gt;::Signer signer(privateKey);

string message = ""Do or do not. There is no try."";

// Determine maximum size, allocate a string with the maximum size
size_t siglen = signer.MaxSignatureLength();
string signature(siglen, 0x00);

// Sign, and trim signature to actual size
siglen = signer.SignMessage( prng, message.data(), message.size(), signature.data() );
signature.resize(siglen);
</code></pre>

<p><strong>Verify</strong></p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey;
publicKey.Load(...);
publicKey.Validate(prng, 3);

ECDSA&lt;ECP, SHA1&gt;::Verifier verifier(publicKey);

bool result = verifier.VerifyMessage( message.data(), message.size(), signature.data(), signature.size() );
if(result)
  cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
else
  cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
</code></pre>
","1358","<digital-signature><crypto++><ecdsa>","0","1","1","2014-01-13 10:26:56","","1","","","","","2014-01-12 19:58:04",""
"827634","Given a filename, how can I get the Adler32 using Crypto++","<p>Given a ""string filename"", how can I get the Adler32 checksum using the C++ Crypto++ library. I am a little confused about using their Source and Sink system.</p>

<p>Below I have the skeleton of the code that does MD5, but I can't seem to find any examples or tutorials on the Adler32 usage. </p>

<pre><code>string filename = ""/tmp/data.txt""
string file_adler32_digest;
string file_md5_digest;

MD5 hashMD5;

FileSource fs( filename.c_str(), 
              true, 
              new HashFilter( hashMD5, 
              new HexEncoder( new StringSink( file_md5_digest ) ) ) );

/* Confusion begins here */   

//how do I do the adler32 ?

/* Confusion ends here */

cout &lt;&lt; file_adler32_digest &lt;&lt; endl
     &lt;&lt; file_md5_digest &lt;&lt; endl;
</code></pre>

<hr>

<p>Good samples and sample code here <a href=""http://www.cryptopp.com/wiki/Category:Sample"" rel=""nofollow noreferrer"">http://www.cryptopp.com/wiki/Category:Sample</a> for all the Crypto++ (except for the Adler32 stuff I want)</p>
","<p>If you follow this <a href=""http://www.cryptopp.com/wiki/HashFilter"" rel=""nofollow noreferrer"">http://www.cryptopp.com/wiki/HashFilter</a>, you have to change hashMD5 for hashAdler32, and file_md5_digest for file_adler32_digest</p>

<pre><code>Adler32 hashAdler32;

FileSource( filename.c_str(), 
            true, 
            new HashFilter( hashAdler32, 
            new HexEncoder( new StringSink( file_adler32_digest ) ) ) );
</code></pre>

<p>After this <code>file_adler32_digest</code> should contain the desired hash.</p>
","1356","<c++><hash><md5><crypto++><adler32>","1","1","2","2015-04-15 20:50:01","828258","0","","608639","","2015-04-15 20:32:02","2009-05-06 01:15:44",""
"827634","Given a filename, how can I get the Adler32 using Crypto++","<p>Given a ""string filename"", how can I get the Adler32 checksum using the C++ Crypto++ library. I am a little confused about using their Source and Sink system.</p>

<p>Below I have the skeleton of the code that does MD5, but I can't seem to find any examples or tutorials on the Adler32 usage. </p>

<pre><code>string filename = ""/tmp/data.txt""
string file_adler32_digest;
string file_md5_digest;

MD5 hashMD5;

FileSource fs( filename.c_str(), 
              true, 
              new HashFilter( hashMD5, 
              new HexEncoder( new StringSink( file_md5_digest ) ) ) );

/* Confusion begins here */   

//how do I do the adler32 ?

/* Confusion ends here */

cout &lt;&lt; file_adler32_digest &lt;&lt; endl
     &lt;&lt; file_md5_digest &lt;&lt; endl;
</code></pre>

<hr>

<p>Good samples and sample code here <a href=""http://www.cryptopp.com/wiki/Category:Sample"" rel=""nofollow noreferrer"">http://www.cryptopp.com/wiki/Category:Sample</a> for all the Crypto++ (except for the Adler32 stuff I want)</p>
","<blockquote>
  <p>.. a little confused about using their Source and Sink system.</p>
</blockquote>

<p>OK. That particular design is inspired by the Unix pipe system. If you understand Unix pipes and how doata flows through it, then you understand the <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Crypto++ Pipeline</a>.</p>

<p>For example, the following Unix commands:</p>

<pre><code>cat somefile.bin | hexdump
</code></pre>

<p>would become the following Crypto++ program:</p>

<pre><code>FileSource fs(""somefile.bin"", true /*pumpAll*/, new HexEncoder(new FileSink(cout)));
</code></pre>

<hr>

<blockquote>
  <p>I have the skeleton of the code that does MD5, but I need the code ... for Adler32 ...</p>
</blockquote>

<p>As Ismael showed you, its as simple as:</p>

<pre><code>Adler32 adler32;
string digest;

FileSource fs(filename.c_str(),  true /*pumpAll*/, 
              new HashFilter(adler32, 
                    new HexEncoder(
                        new StringSink(digest))));
</code></pre>

<p>But here's the insight: In Crypto++, data flows from <a href=""http://www.cryptopp.com/wiki/Category:Source"" rel=""nofollow"">Sources</a> to <a href=""http://www.cryptopp.com/wiki/Category:Sink"" rel=""nofollow"">Sinks</a>. In  between, it will encounter <a href=""http://www.cryptopp.com/wiki/Category:Filter"" rel=""nofollow"">Filters</a> that transform the data.</p>

<p>Above, you have two filters: the <a href=""http://www.cryptopp.com/wiki/HashFilter"" rel=""nofollow"">HashFilter</a> and the <a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow"">HexEncoder</a>. All the filters inherit from a <a href=""http://www.cryptopp.com/wiki/BufferedTransformation"" rel=""nofollow""><code>BufferedTransformation</code></a>, so they can all be chained together in a consistent manner.</p>

<p><code>Adler32</code> itself is not a filter. But it inherits from <a href=""http://www.cryptopp.com/wiki/HashTransformation"" rel=""nofollow""><code>HashTransformation</code></a>, and that is what <a href=""http://www.cryptopp.com/wiki/HashFilter"" rel=""nofollow"">HashFilter</a> uses. So you can swap in any <a href=""http://www.cryptopp.com/wiki/HashFilter"" rel=""nofollow"">HashFilter</a> based object and things will just work.</p>

<p>You can find a list of <a href=""http://www.cryptopp.com/wiki/HashFilter"" rel=""nofollow"">HashFilter</a> based object at <a href=""http://www.cryptopp.com/docs/ref/class_hash_transformation.html"" rel=""nofollow"">HashTransformation Class Reference</a>. They include all the hashes (like MD5, SHA and Whirlpool), Adler32 and CRC32.</p>
","1356","<c++><hash><md5><crypto++><adler32>","1","0","2","2015-04-15 20:50:01","828258","0","","608639","","2015-04-15 20:32:02","2009-05-06 01:15:44",""
"31649738","Compiling Crypto++ for armhf for cross compiling","<p>I want to cross compile the library crypto++ for deployment on a beaglebone running Debian. My host PC runs Ubuntu 14.04 LTS in a 64-bit configuration. </p>

<p>I face the following problem when I invoke the make command from eclipse</p>

<pre><code>arm-linux-gnueabihf-g++-4.8 -L/usr/include/cryptopp -o ""GCMwithAES""  ./main.o   -lcryptopp
/usr/lib/../lib/libcryptopp.so: file not recognized: File format not recognized
</code></pre>

<p>My guess is that since the compiler is configured for armhf, it cannot recognize the library that was compiled for amd64.</p>

<p>I have successfully cross compiled and run standard (ie no external libraries) programs from my host PC to my target device.</p>

<p>Solutions that I have tried</p>

<ul>
<li>Used libcrypto++ packages with the architecture specified as <code>armhf</code> as done in multiarch. The armhf libraries get installed ( as per apt) but I am unable to include and link my code with them. </li>
<li>Manually try to compile the library as per the instruction given on this <a href=""http://www.cryptopp.com/wiki/Linux"" rel=""nofollow"">wiki</a>. However, I always run into errors whenever I try to compile the library.</li>
</ul>

<p>How do I install the libcryptopp libraries of the armhf architecture on my x64 based PC so I can cross compile? or is there any other way to resolve this issue.</p>

<p><strong>Edit</strong></p>

<p>As suggested in the answer below I tried out the method suggested. I slightly modified the script <code>setenv-embed.sh</code> since I had <code>gcc-4.8</code> instead of <code>gcc-4.7</code>. The results of running the script are</p>

<pre><code>CPP: /usr/bin/arm-linux-gnueabihf-cpp 
CXX: /usr/bin/arm-linux-gnueabihf-g++
AR: /usr/bin/arm-linux-gnueabihf-ar
LD: /usr/bin/arm-linux-gnueabihf-ld
RANLIB: /usr/bin/arm-linux-gnueabihf-gcc-ranlib-4.8

ARM_EMBEDDED_TOOLCHAIN: /usr/bin
ARM_EMBEDDED_CXX_HEADERS: /usr/arm-linux-gnueabihf/include/c++/4.8.2
ARM_EMBEDDED_FLAGS: -march=armv7-a mfloat-abi=hard -mfpu=neon -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf 
ARM_EMBEDDED_SYSROOT: /usr/arm-linux-gnueabihf
</code></pre>

<p>I build the library using the make command and run into the following error</p>

<pre><code>/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc.so.6 inside /usr/arm-linux-gnueabihf
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc_nonshared.a inside /usr/arm-linux-gnueabihf        
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 inside /usr/arm-linux-gnueabihf
</code></pre>

<p>But when I open the location <code>/usr/arm-linux-gnueabihf/lib</code> I can find all the three error files mentioned above ie <code>libc.so.6</code>, <code>libc_nonshared.a</code> and <code>ld-linux-armhf.so.3</code></p>

<p>As per the suggestions of @jww, I'm shifting this to a new question since I'm having trouble linking. My results here are left for completeness.</p>
","<blockquote>
  <p>How do I install the libcryptopp libraries of the armhf architecture on my x64 based PC so I can cross compile? or is there any other way to resolve this issue.</p>
</blockquote>

<p>Checkout <a href=""http://www.cryptopp.com/wiki/ARM_Embedded_%28Command_Line%29"" rel=""nofollow"">ARM Embedded (Command Line)</a> on the Crypto++ wiki.</p>

<p><strike>Note: that wiki page is a bit dated. You can now use <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile-cross"" rel=""nofollow""><code>GNUmakefile-cross</code></a>. I have not updated the page to reflect recent changes like <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile-cross"" rel=""nofollow""><code>GNUmakefile-cross</code></a>.</strike></p>

<p><a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile-cross"" rel=""nofollow""><code>GNUmakefile-cross</code></a> is a special purpose built for cross-compiling on Android, iOS, Windows Phone, ARM Embedded, and bare metal (I doubt anyone would do the later, but I tested it as a platform). You will still need to run the <code>setenv-embedded.sh</code> script.</p>

<p>To fetch the latest sources from GitHub:</p>

<pre class=""lang-none prettyprint-override""><code>git clone https://github.com/weidai11/cryptopp.git cryptopp-armhf
</code></pre>

<p>The GitHub sources are quite active at the moment. We are preparing for a Crypto++ 5.6.3 release. 5.6.3 will include 
<a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile-cross"" rel=""nofollow""><code>GNUmakefile-cross</code></a>.</p>

<hr>

<p>The complete instructions will look something like (assuming you have the tools installed):</p>

<pre class=""lang-sh prettyprint-override""><code>git clone https://github.com/weidai11/cryptopp.git cryptopp-armhf
cd cryptopp-armhf

# Note the leading dot!!!
. ./setenv-embedded.sh
# The command above must execute successfully
# It cannot display a message like ""**CXX is not valid**""

# Build it
make -f GNUmakefile-cross static dynamic cryptest.exe

# Check it
$ find . -name cryptest.exe
./cryptest.exe
$ /usr/bin/arm-linux-gnueabi-readelf -h ./cryptest.exe | grep -i 'class\|machine' 
  Class:                             ELF32
  Machine: 
</code></pre>

<p><strike>Because the GitHub sources are quite active at the moment, I've already added all the other files from <code>Crypto++-Mobile.zip</code> and <code>Setenv-embedded.sh.zip</code> to the official Crypto++ sources. You only need to get <code>setenv-embedded.sh</code> out of the <code>Setenv-embedded.sh.zip</code>.</strike></p>
","1349","<c++><linux><eclipse><cross-compiling><crypto++>","2","2","2","2016-04-21 23:04:29","31665198","5","","3079474","","2015-07-29 10:32:25","2015-07-27 09:40:38",""
"31649738","Compiling Crypto++ for armhf for cross compiling","<p>I want to cross compile the library crypto++ for deployment on a beaglebone running Debian. My host PC runs Ubuntu 14.04 LTS in a 64-bit configuration. </p>

<p>I face the following problem when I invoke the make command from eclipse</p>

<pre><code>arm-linux-gnueabihf-g++-4.8 -L/usr/include/cryptopp -o ""GCMwithAES""  ./main.o   -lcryptopp
/usr/lib/../lib/libcryptopp.so: file not recognized: File format not recognized
</code></pre>

<p>My guess is that since the compiler is configured for armhf, it cannot recognize the library that was compiled for amd64.</p>

<p>I have successfully cross compiled and run standard (ie no external libraries) programs from my host PC to my target device.</p>

<p>Solutions that I have tried</p>

<ul>
<li>Used libcrypto++ packages with the architecture specified as <code>armhf</code> as done in multiarch. The armhf libraries get installed ( as per apt) but I am unable to include and link my code with them. </li>
<li>Manually try to compile the library as per the instruction given on this <a href=""http://www.cryptopp.com/wiki/Linux"" rel=""nofollow"">wiki</a>. However, I always run into errors whenever I try to compile the library.</li>
</ul>

<p>How do I install the libcryptopp libraries of the armhf architecture on my x64 based PC so I can cross compile? or is there any other way to resolve this issue.</p>

<p><strong>Edit</strong></p>

<p>As suggested in the answer below I tried out the method suggested. I slightly modified the script <code>setenv-embed.sh</code> since I had <code>gcc-4.8</code> instead of <code>gcc-4.7</code>. The results of running the script are</p>

<pre><code>CPP: /usr/bin/arm-linux-gnueabihf-cpp 
CXX: /usr/bin/arm-linux-gnueabihf-g++
AR: /usr/bin/arm-linux-gnueabihf-ar
LD: /usr/bin/arm-linux-gnueabihf-ld
RANLIB: /usr/bin/arm-linux-gnueabihf-gcc-ranlib-4.8

ARM_EMBEDDED_TOOLCHAIN: /usr/bin
ARM_EMBEDDED_CXX_HEADERS: /usr/arm-linux-gnueabihf/include/c++/4.8.2
ARM_EMBEDDED_FLAGS: -march=armv7-a mfloat-abi=hard -mfpu=neon -I/usr/arm-linux-gnueabihf/include/c++/4.8.2 -I/usr/arm-linux-gnueabihf/include/c++/4.8.2/arm-linux-gnueabihf 
ARM_EMBEDDED_SYSROOT: /usr/arm-linux-gnueabihf
</code></pre>

<p>I build the library using the make command and run into the following error</p>

<pre><code>/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc.so.6 inside /usr/arm-linux-gnueabihf
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/libc_nonshared.a inside /usr/arm-linux-gnueabihf        
/usr/lib/gcc-cross/arm-linux-gnueabihf/4.8/../../../../arm-linux-gnueabihf/bin/‌​ld: cannot find /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 inside /usr/arm-linux-gnueabihf
</code></pre>

<p>But when I open the location <code>/usr/arm-linux-gnueabihf/lib</code> I can find all the three error files mentioned above ie <code>libc.so.6</code>, <code>libc_nonshared.a</code> and <code>ld-linux-armhf.so.3</code></p>

<p>As per the suggestions of @jww, I'm shifting this to a new question since I'm having trouble linking. My results here are left for completeness.</p>
","<p>In addition to <a href=""https://stackoverflow.com/a/31665198/60075"">jww's answer</a>, I wanted to add some further notes. (These notes are relevant for version 5.6.3 released 20-Nov-2015.)</p>

<p>It may be necessary to edit the <code>config.h</code> file to change some options. See <a href=""https://cryptopp.com/wiki/Config.h"" rel=""nofollow noreferrer"">Config.h on the Crypto++ wiki</a>. In particular:</p>

<ul>
<li><code>CRYPTOPP_NO_UNALIGNED_DATA_ACCESS</code> may need to be defined so that the code operates properly on systems that can't do unaligned data read/writes (e.g. ARM).</li>
<li><code>CRYPTOPP_INIT_PRIORITY</code> and <code>CRYPTOPP_USER_PRIORITY</code> may need to be defined. See <a href=""https://cryptopp.com/wiki/Static_Initialization_Order_Fiasco"" rel=""nofollow noreferrer"">Static Initialization Order Fiasco - Crypto++ Wiki</a> for details.</li>
<li><code>CRYPTOPP_MAINTAIN_BACKWARDS_COMPATIBILITY_562</code> may need to be defined or undefined, depending on whether the project using it is using older API features or not.</li>
</ul>

<p>After building the library, it is very much worth running the test program <code>cryptest.exe v</code> on the target system, to check if the library has been built okay for that system. For example, by doing this, I discovered that the library doesn't work properly on the ARM-based BeagleBone Black unless I define <code>CRYPTOPP_NO_UNALIGNED_DATA_ACCESS</code> in <code>config.h</code> (it freezes indefinitely on the test step <code>Testing MessageDigest algorithm SHA-384.</code>).</p>
","1349","<c++><linux><eclipse><cross-compiling><crypto++>","2","1","2","2016-04-21 23:04:29","31665198","5","","3079474","","2015-07-29 10:32:25","2015-07-27 09:40:38",""
"3405158","Encrypt/Decrypt with AES","<p>I'm writing small program to encrypt/decrypt files using AES. I'm using Cryptopp library.</p>

<p>I need help to understand some things.</p>

<p>When I'm encrypting file I should write IV at the beginning of file to decrypt it later?</p>

<p>I wan't to check password given do decrypt file was correct. Should I:</p>

<ul>
<li><p>put some string at beginning of file (ex. TRUE) before it's encrypted. After decryption check it.</p></li>
<li><p>Check MD5 of file before encryption. Put it at beginning of encrypted file. Read MD5 before decryption, decrypt file, check MD5 of decrypted file and compare them.</p></li>
</ul>
","<p>Writing the IV at the beginning of the file is fine. Appending to the end is another option.</p>

<p>Do not put a static string into the plaintext: <a href=""http://en.wikipedia.org/wiki/Enigma_machine#Indicator"" rel=""nofollow noreferrer"">ENIGMA</a> transcripts were more easily broken for very similar reasons, and the <a href=""http://oldhome.schmorp.de/marc/fcrackzip.html#lbAF"" rel=""nofollow noreferrer"">zip format</a> makes brute-forcing passwords <a href=""https://stackoverflow.com/questions/3185719/unzip-password-protected-file/3185778#3185778"">very easy</a> for this identical mistake.</p>

<p>The md5 approach sounds tolerable; but hmac-sha256 would provide significantly stronger integrity claims. (I think you could even re-use the AES key or the IV for hmac-sha256, but I'm not positive of its safety.)</p>
","1345","<aes><crypto++>","1","1","1","2010-08-04 11:58:20","","0","1","","","","2010-08-04 11:45:41",""
"3947967","How to integrate Crypto++ into C++ Builder 2010 / [ILINK32 Error]","<p>I was trying to compile the following (example) code via C++ Builder 2010:</p>

<p><a href=""http://swarmapps.wordpress.com/2009/11/24/a-simplification-wrapper-for-the-crypto-library/"" rel=""nofollow"">http://swarmapps.wordpress.com/2009/11/24/a-simplification-wrapper-for-the-crypto-library/</a></p>

<p>( <a href=""http://pastebin.com/f6bd13d59"" rel=""nofollow"">http://pastebin.com/f6bd13d59</a> / example.cpp )</p>

<p>( <a href=""http://pastebin.com/f2fc53f83"" rel=""nofollow"">http://pastebin.com/f2fc53f83</a> / BasicCryptoPPWrap.h )</p>

<p>There were no compiler errors but the linking failed:</p>

<blockquote>
  <p>[ILINK32 Error] Error: Unresolved external 'CryptoPP::SimpleKeyingInterface::SetKey(const unsigned char *, unsigned int, CryptoPP::NameValuePairs&amp;)' referenced from E:\TEST\DEBUG\FILE1.OBJ</p>
</blockquote>

<p>How can I fix this problem?</p>
","<p>from the same page</p>

<blockquote>
  <p>The wrapper is not a standalone
  solution.  It requires your code to
  link to libcryptopp and know where the
  cryptopp header files are found.  The
  Crypto++  website can help you set up
  your system.  Once you get the
  validation suite to run successfully,
  you will be able to use this wrapper.</p>
</blockquote>
","1344","<compilation><c++builder><crypto++><c++builder-2010>","0","1","1","2011-05-30 13:29:45","","0","","650492","","2011-05-30 13:29:45","2010-10-16 06:54:06",""
"28515793","How to regenerate values in AutoSeededX917RNG","<p>I need to regenerate the pseuorandom values when I need them. My code is:</p>

<pre><code>static const unsigned int BLOCKSIZE = 5; 
byte scratch[ BLOCKSIZE ];

CryptoPP::AutoSeededX917RNG&lt;CryptoPP::AES&gt; rng;
rng.GenerateBlock(scratch,BLOCKSIZE);

std::cout &lt;&lt; ""The generated random block is:"" &lt;&lt; std::endl;
for( unsigned int i = 0; i &lt; BLOCKSIZE; i++ )
{
    std::cout &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');
    std::cout &lt;&lt; static_cast&lt;unsigned int&gt;( scratch[ i ] );
}
std::cout &lt;&lt; std::endl;
</code></pre>
","<blockquote>
  <p>How to regenerate values in AutoSeededX917RNG</p>
</blockquote>

<p>You can't because you are using an <code>AutoSeeded*</code> generator.</p>

<h2>-----</h2>

<blockquote>
  <p>I need to regenerate the pseuorandom values when I need them...</p>
</blockquote>

<p>In that case, I think you only have two choices - an <code>LC_RNG</code> (which is insecure) or an <code>RandomPool</code> (more secure, but it has gaps). Both would require you to operate the generator <strong><em>with</em></strong> the same seed to produce the same bit streams.</p>

<p><code>RandomPool</code> is a PGP style generator and its underlying algorithm is <code>MDC&lt;SHA&gt;</code>. <strike>It will produce the same stream of bits given the same seed.</strike> It uses time, so it produces a different stream for each run (even with the same seeds).</p>

<p>Do <strong><em>not</em></strong> use an <code>AutoSeeded*</code> generator, like <code>AutoSeededRandomPool</code> or <code>AutoSeededX917RNG</code>. The <code>AutoSeeded*</code> read from the OS's entropy pool and then seed the generators with the bits it read.</p>

<p>Also see <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">RandomNumberGenerator</a> on the Crypto++ wiki.</p>

<h2>-----</h2>

<p><strong>UPDATE</strong>: <code>RandomPool</code> uses time (sorry, I should have checked before I recommended it).</p>

<p>You <em>can</em> use <code>OFB_Mode&lt;T&gt;::Encryption</code> to generate reproducible random streams. The Crypto++ test program uses it (see <code>test.cpp</code> - its the generator returned from <code>GlobalRNG()</code>). An example is shown below.</p>

<pre><code>SecByteBlock seed(32 + 16);
OS_GenerateRandomBlock(false, seed, seed.size());

for(unsigned int i = 0; i &lt; 10; i++)
{
    OFB_Mode&lt;AES&gt;::Encryption prng;
    prng.SetKeyWithIV(seed, 32, seed + 32, 16);

    SecByteBlock t(16);
    prng.GenerateBlock(t, t.size());

    string s;
    HexEncoder hex(new StringSink(s));

    hex.Put(t, t.size());
    hex.MessageEnd();

    cout &lt;&lt; ""Random: "" &lt;&lt; s &lt;&lt; endl;
}
</code></pre>

<p><a href=""http://www.cryptopp.com/docs/ref/struct_o_f_b___mode.html"" rel=""nofollow""><code>OFB_mode&lt;T&gt;::Encryption</code></a> can be used as a generator because OFB mode uses <a href=""http://www.cryptopp.com/docs/ref/class_additive_cipher_template.html"" rel=""nofollow""><code>AdditiveCipherTemplate&lt;T&gt;</code></a>, which derives from <code>RandomNumberGenerator</code>.</p>

<p>Running it produces similar to below.</p>

<pre><code>$ ./cryptopp-test.exe
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
Random: DF3D3F8E8A21C39C0871B375013AA2CD
</code></pre>

<h2>-----</h2>

<p>You can also use the code below in <code>AES_RNG.h</code> for a deterministic generator based on AES-256. It will produce the same bit stream if presented with the same seed. Its a little more flexible than <code>OFB_Mode&lt;T&gt;::Encryption</code> because it can take a arbitrarily-sized seed.</p>

<p>The code to test it is as follows:</p>

<pre><code>SecByteBlock seed(32);
OS_GenerateRandomBlock(false, seed, seed.size());

for(unsigned int i = 0; i &lt; 10; i++)
{
    AES_RNG prng(seed, seed.size());

    SecByteBlock t(16);
    prng.GenerateBlock(t, t.size());

    string s;
    HexEncoder hex(new StringSink(s));

    hex.Put(t, t.size());
    hex.MessageEnd();

    cout &lt;&lt; ""Random: "" &lt;&lt; s &lt;&lt; endl &lt;&lt; endl;
}
</code></pre>

<p>Its output will look similar to below. Each run of the program will be different because each run uses a different seed (by way of <code>OS_GenerateRandomBlock</code>):</p>

<pre><code>$ ./cryptopp-test.exe 
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
Random: D9B48CB7D37C88BDF2A0B0022AB1A812
</code></pre>

<p><strong>AES_RNG.h</strong>:</p>

<pre><code>#include &lt;cryptopp/cryptlib.h&gt;
using CryptoPP::NotCopyable;
using CryptoPP::BufferedTransformation;
using CryptoPP::BlockCipher;

#include &lt;cryptopp/secblock.h&gt;
using CryptoPP::AlignedSecByteBlock;
using CryptoPP::FixedSizeSecBlock;

#include &lt;cryptopp/smartptr.h&gt;
using CryptoPP::member_ptr;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::OS_GenerateRandomBlock;
using CryptoPP::RandomNumberGenerator;

#include &lt;cryptopp/aes.h&gt;
using CryptoPP::AES;

#include &lt;cryptopp/sha.h&gt;
using CryptoPP::SHA512;

class AES_RNG : public RandomNumberGenerator, public NotCopyable
{
public:
    explicit AES_RNG(const byte *seed = NULL, size_t length = 0)
    : m_pCipher(new AES::Encryption), m_keyed(SeedHelper(seed, length))
    {
    }

    bool CanIncorporateEntropy() const
    {
        return true;
    }

    void IncorporateEntropy(const byte *input, size_t length)
    {
        m_keyed = SeedHelper(input, length, false);
    }

    void GenerateIntoBufferedTransformation(BufferedTransformation &amp;target, const std::string &amp;channel, lword size)
    {
        if (!m_keyed) {
            m_pCipher-&gt;SetKey(m_key, m_key.size());
            m_keyed = true;
        }

        while (size &gt; 0)
        {
            m_pCipher-&gt;ProcessBlock(m_seed);
            size_t len = std::min((size_t)16, (size_t)size);
            target.ChannelPut(channel, m_seed, len);
            size -= len;
        }
    }

protected:
    // Sets up to use the cipher. Its a helper to allow a throw
    //   in the contructor during initialization.  Returns true
    //   if the cipher was keyed, and false if it was not.
    bool SeedHelper(const byte* input, size_t length, bool ctor = true)
    {
        // 32-byte key, 16-byte seed
        AlignedSecByteBlock seed(32 + 16);
        SHA512 hash;

        if(ctor)
        {
            memset(m_key, 0x00, m_key.size());
            memset(m_seed, 0x00, m_seed.size());
        }

        if(input &amp;&amp; length)
        {
            // Use the user supplied seed.
            hash.Update(input, length);
        }
        else
        {
            // No seed or size. Use the OS to gather entropy.
            OS_GenerateRandomBlock(false, seed, seed.size());
            hash.Update(seed, seed.size());
        }

        hash.Update(m_key.data(), m_key.size());
        hash.TruncatedFinal(seed.data(), seed.size());

        memcpy(m_key.data(), seed.data() + 0, 32);
        memcpy(m_seed.data(), seed.data() + 32, 16);

        // Return false. This allows the constructor to complete
        //   before the pointer m_pCipher is used.
        return false;
    }

private: 
    FixedSizeSecBlock&lt;byte, 32&gt; m_key;
    FixedSizeSecBlock&lt;byte, 16&gt; m_seed;    
    member_ptr&lt;BlockCipher&gt; m_pCipher;
    bool m_keyed;
};
</code></pre>
","1333","<c++><random><crypto++>","-3","1","1","2015-02-16 11:58:11","28531036","1","","608639","","2015-02-15 21:37:41","2015-02-14 12:48:10",""
"11528956","Unable to compile crypto for SHA-256 hashing on Devc","<pre><code>#include &lt;..\cryptopp\dll.h&gt;
#include &lt;..\cryptopp\sha.h&gt;
#include &lt;..\cryptopp\hex.h&gt;
#include&lt;..\cryptopp\files.h&gt;

#include &lt;iostream&gt;
#include&lt;string&gt;

using namespace std;
using namespace CryptoPP;

const int MAX_PHRASE_LENGTH=250;

int main(int argc, char *argv[]) {

CryptoPP::SHA256 hash;
byte digest[ CryptoPP::SHA256::DIGESTSIZE ];
std::string message = ""Hello World!"";

hash.CalculateDigest( digest, (const byte*)message.c_str(), message.length());

CryptoPP::HexEncoder encoder;
std::string output;
encoder.Attach( new CryptoPP::StringSink( output ) );
encoder.Put( digest, sizeof(digest) );
encoder.MessageEnd();

std::cout &lt;&lt; ""Input string: "" &lt;&lt; message &lt;&lt; std::endl;
std::cout &lt;&lt; ""SHA256: "" &lt;&lt; output &lt;&lt; std::endl;

return 0;
}
</code></pre>

<p>errors</p>

<p>Compiler: Default compiler
Executing  g++.exe...
g++.exe ""C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.cpp"" -o ""C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.exe""    -I""C:\Dev-Cpp\lib\gcc\mingw32\3.4.2\include""  -I""C:\Dev-Cpp\include\c++\3.4.2\backward""  -I""C:\Dev-Cpp\include\c++\3.4.2\mingw32""  -I""C:\Dev-Cpp\include\c++\3.4.2""  -I""C:\Dev-Cpp\include""   -L""C:\Dev-Cpp\lib"" 
In file included from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/seckey.h:8,
                 from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/rijndael.h:7,
                 from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/aes.h:4,
                 from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\dll.h:11,
                 from C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.cpp:1:
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/cryptlib.h:277: error: function <code>std::string CryptoPP::NameValuePairs::GetValueNames() const' definition is marked dllimport.
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\/cryptlib.h:283: error: function</code>bool CryptoPP::NameValuePairs::GetIntValue(const char*, int&amp;) const' definition is marked dllimport.
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/cryptlib.h:287: error: function <code>int CryptoPP::NameValuePairs::GetIntValueWithDefault(const char*, int) const' definition is marked dllimport.
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\/cryptlib.h:291: error: function</code>static void CryptoPP::NameValuePairs::ThrowIfTypeMismatch(const char*, const std::type_info&amp;, const std::type_info&amp;)' definition is marked dllimport.
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/cryptlib.h:301: error: function `void CryptoPP::NameValuePairs::GetRequiredIntParameter(const char*, const char*, int&amp;) const' definition is marked dllimport.</p>

<p>In file included from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/aes.h:4,
                 from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\dll.h:11,
                 from C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.cpp:1:
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/rijndael.h:15: error: function `static const char* CryptoPP::Rijndael_Info::StaticAlgorithmName()' definition is marked dllimport.</p>

<p>In file included from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\dll.h:16,
                 from C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.cpp:1:
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/des.h:58: error: function `static const char* CryptoPP::DES_EDE2_Info::StaticAlgorithmName()' definition is marked dllimport.</p>

<p>C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/des.h:82: error: function `static const char* CryptoPP::DES_EDE3_Info::StaticAlgorithmName()' definition is marked dllimport.</p>

<p>In file included from C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp\dll.h:37,
                 from C:\Users\Pr\Desktop\Work\encrypt\sha256\sampeSHA256.cpp:1:
C:/Dev-Cpp/include/c++/3.4.2/backward/..\cryptopp/skipjack.h:15: error: function `static const char* CryptoPP::SKIPJACK_Info::StaticAlgorithmName()' definition is marked dllimport.</p>

<p>Execution terminated</p>
","<p>Remove <code>#include &lt;..\cryptopp\dll.h&gt;</code></p>

<p>As Fraser said, use <code>-L&lt;path to Crypto++&gt;</code>.</p>

<p>As Fraser said, use either <code>-lcryptopp</code> or <code>-lcrypto++</code>. The one you use depends on what you have. By default, its <code>-lcryptopp</code>.</p>
","1283","<dev-c++><crypto++>","0","0","1","2014-01-28 03:54:08","","6","","1532707","","2012-07-17 19:34:22","2012-07-17 18:50:58",""
"22918831","Crypto++ errors on creating cipher text","<p>I am pretty new to C++ and I need to use Crypto++. I have been looking for examples that explain how to use it. I found this <a href=""https://stackoverflow.com/questions/12306956/example-of-aes-using-crypto"">Example of AES using Crypto++</a> . And I think this is great... the only thing is when I try to build it, I get a bunch of errors!</p>

<p>First off, I had to change the include path for the header files. I am not sure why, but when I didn't add the ""crypto++"" in front of the path, it could not find the header files. Another post suggested to use it and it seems to make the errors go away.</p>

<p>In case you want to see the code I am trying to build, it is here:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;

#include ""crypto++/modes.h""
#include ""crypto++/aes.h""
#include ""crypto++/filters.h""
using namespace std;
int main(int argc, char* argv[]) {

    //
    // Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-   
    //bit). This key is secretly exchanged between two parties before communication   
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    //
    // String and Sink setup
    //
    string plaintext = ""Now is the time for all good men to come to the aide..."";
    string ciphertext;
    string decryptedtext;

    //
    // Dump Plain Text
    //
    cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; endl;
    cout &lt;&lt; plaintext;
    cout &lt;&lt; endl &lt;&lt; endl;

    // //
    // // Create Cipher Text
    // //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        cout &lt;&lt; ""0x"" &lt;&lt; hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    cout &lt;&lt; endl &lt;&lt; endl;

    //
    // Decrypt
    //
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    //
    // Dump Decrypted Text
    //
    cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; endl;
    cout &lt;&lt; decryptedtext;
    cout &lt;&lt; endl &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>These are the errors I get</p>

<pre><code>/tmp/cczoSf1S.o: In function `CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface()':
AES.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceD2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceD5Ev]+0xb): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
/tmp/cczoSf1S.o: In function `CryptoPP::SimpleKeyingInterface::SimpleKeyingInterface()':
AES.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceC2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceC5Ev]+0x8): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
/tmp/cczoSf1S.o: In function `CryptoPP::BlockTransformation::~BlockTransformation()':
AES.cpp:(.text._ZN8CryptoPP19BlockTransformationD2Ev[_ZN8CryptoPP19BlockTransformationD5Ev]+0xb): undefined reference to `vtable for CryptoPP::BlockTransformation'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Base::~Base()':
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0xc): undefined reference to `vtable for CryptoPP::Rijndael::Base'
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0x16): undefined reference to `vtable for CryptoPP::Rijndael::Base'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Enc::~Enc()':
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0xb): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0x15): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
/tmp/cczoSf1S.o: In function `CryptoPP::BlockTransformation::BlockTransformation()':
AES.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x15): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
AES.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x1e): undefined reference to `vtable for CryptoPP::BlockTransformation'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Base::Base()':
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x17): undefined reference to `vtable for CryptoPP::Rijndael::Base'
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x21): undefined reference to `vtable for CryptoPP::Rijndael::Base'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Enc::Enc()':
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x16): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x20): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
/tmp/cczoSf1S.o: In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned int)':
AES.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhj[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhj]+0x27): undefined reference to `CryptoPP::g_nullNameValuePairs'
AES.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhj[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhj]+0x44): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x44): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x50): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x54): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x78): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x80): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[vtable for CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;]+0x90): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x44): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x50): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x54): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x74): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x7c): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[vtable for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x8c): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP15BlockCipherImplINS_13Rijndael_InfoENS_11BlockCipherEEE[vtable for CryptoPP::BlockCipherImpl&lt;CryptoPP::Rijndael_Info, CryptoPP::BlockCipher&gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP15BlockCipherImplINS_13Rijndael_InfoENS_11BlockCipherEEE[vtable for CryptoPP::BlockCipherImpl&lt;CryptoPP::Rijndael_Info, CryptoPP::BlockCipher&gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP15BlockCipherImplINS_13Rijndael_InfoENS_11BlockCipherEEE[vtable for CryptoPP::BlockCipherImpl&lt;CryptoPP::Rijndael_Info, CryptoPP::BlockCipher&gt;]+0x70): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP15BlockCipherImplINS_13Rijndael_InfoENS_11BlockCipherEEE[vtable for CryptoPP::BlockCipherImpl&lt;CryptoPP::Rijndael_Info, CryptoPP::BlockCipher&gt;]+0x80): undefined reference to `CryptoPP::BlockTransformation::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP13AlgorithmImplINS_25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES5_EES6_EE[vtable for CryptoPP::AlgorithmImpl&lt;CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;, CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt; &gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP13AlgorithmImplINS_25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES5_EES6_EE[vtable for CryptoPP::AlgorithmImpl&lt;CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;, CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt; &gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP13AlgorithmImplINS_25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES5_EES6_EE[vtable for CryptoPP::AlgorithmImpl&lt;CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;, CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt; &gt;]+0x6c): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP13AlgorithmImplINS_25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES5_EES6_EE[vtable for CryptoPP::AlgorithmImpl&lt;CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;, CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt; &gt;]+0x7c): undefined reference to `CryptoPP::BlockTransformation::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES4_EE[vtable for CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES4_EE[vtable for CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES4_EE[vtable for CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;]+0x68): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP25SimpleKeyingInterfaceImplINS_8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEES4_EE[vtable for CryptoPP::SimpleKeyingInterfaceImpl&lt;CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;, CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt; &gt;]+0x78): undefined reference to `CryptoPP::BlockTransformation::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEE[vtable for CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEE[vtable for CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEE[vtable for CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;]+0x68): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP8TwoBasesINS_11BlockCipherENS_13Rijndael_InfoEEE[vtable for CryptoPP::TwoBases&lt;CryptoPP::BlockCipher, CryptoPP::Rijndael_Info&gt;]+0x78): undefined reference to `CryptoPP::BlockTransformation::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP11BlockCipherE[vtable for CryptoPP::BlockCipher]+0x24): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP11BlockCipherE[vtable for CryptoPP::BlockCipher]+0x3c): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP11BlockCipherE[vtable for CryptoPP::BlockCipher]+0x68): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
/tmp/cczoSf1S.o:(.rodata._ZTVN8CryptoPP11BlockCipherE[vtable for CryptoPP::BlockCipher]+0x78): undefined reference to `CryptoPP::BlockTransformation::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned int, unsigned int) const'
/tmp/cczoSf1S.o:(.rodata._ZTIN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[typeinfo for CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;]+0x8): undefined reference to `typeinfo for CryptoPP::Rijndael::Enc'
/tmp/cczoSf1S.o:(.rodata._ZTIN8CryptoPP11BlockCipherE[typeinfo for CryptoPP::BlockCipher]+0x10): undefined reference to `typeinfo for CryptoPP::SimpleKeyingInterface'
/tmp/cczoSf1S.o:(.rodata._ZTIN8CryptoPP11BlockCipherE[typeinfo for CryptoPP::BlockCipher]+0x18): undefined reference to `typeinfo for CryptoPP::BlockTransformation'
/tmp/cczoSf1S.o: In function `CryptoPP::SimpleKeyingInterface::SimpleKeyingInterface(CryptoPP::SimpleKeyingInterface const&amp;)':
AES.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceC2ERKS0_[_ZN8CryptoPP21SimpleKeyingInterfaceC5ERKS0_]+0x8): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
/tmp/cczoSf1S.o: In function `CryptoPP::BlockTransformation::BlockTransformation(CryptoPP::BlockTransformation const&amp;)':
AES.cpp:(.text._ZN8CryptoPP19BlockTransformationC2ERKS0_[_ZN8CryptoPP19BlockTransformationC5ERKS0_]+0x1d): undefined reference to `vtable for CryptoPP::BlockTransformation'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Base::Base(CryptoPP::Rijndael::Base const&amp;)':
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2ERKS1_[_ZN8CryptoPP8Rijndael4BaseC5ERKS1_]+0x1e): undefined reference to `vtable for CryptoPP::Rijndael::Base'
AES.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2ERKS1_[_ZN8CryptoPP8Rijndael4BaseC5ERKS1_]+0x28): undefined reference to `vtable for CryptoPP::Rijndael::Base'
/tmp/cczoSf1S.o: In function `CryptoPP::Rijndael::Enc::Enc(CryptoPP::Rijndael::Enc const&amp;)':
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2ERKS1_[_ZN8CryptoPP8Rijndael3EncC5ERKS1_]+0x1d): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
AES.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2ERKS1_[_ZN8CryptoPP8Rijndael3EncC5ERKS1_]+0x27): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
collect2: ld returned 1 exit status
[Finished in 0.7s with exit code 1]
[shell_cmd: g++ ""/home/jack/Desktop/Crytpo C++/AES.cpp"" -o ""/home/jack/Desktop/Crytpo C++/AES""]
[dir: /home/jack/Desktop/Crytpo C++]
[path: /usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games]
</code></pre>

<p>I tried putting in the lines 1 at a time, then building and it seems to start getting errors at creating the cipher text.</p>
","<p>How do you compile your project? It seems you did not link crypto++ library. If you are using gcc you can add -lcrypto++ to compile options.</p>
","1283","<c++><build><crypto++>","3","2","1","2014-04-07 18:51:09","22920630","1","","-1","","2017-05-23 12:31:32","2014-04-07 17:10:22",""
"39011387","Compile Crypto++ library for OS X Xcode project","<p>I have downloaded Crypto++ and I am trying to build it so that I can use it in a C++ Xcode project.</p>

<p>I compiled using just ""make"" command and included <code>libcryptopp.a</code> in my c++ project of my xcode. But it is giving errors:</p>

<pre><code>Undefined symbols for architecture i386:   ""CryptoPP::HashFilter::HashFilter(CryptoPP::HashTransformation&amp;,
 CryptoPP::BufferedTransformation*, bool, int, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;,
 std::__1::allocator&lt;char&gt; &gt; const&amp;, std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;,
 std::__1::allocator&lt;char&gt; &gt; const&amp;)"", referenced from:
 ...
</code></pre>
","<blockquote>
  <p>I compiled using just ""make"" command and included libcryptopp.a in my c++ project of my xcode. But it is giving errors ...</p>
</blockquote>

<p>As @halfelf said, you need to use LLVM's runtime (<code>libc++</code>) because that is what Xcode uses. Depending on the Crypto++ version you have, you may (or may not) be using GNU's runtime (<code>libstdc++</code>).</p>

<p>The easiest way to fix this is to checkout Master. Its OK to work from Master because its mostly stable and only suffers an occasional break (most development occurs on a separate branch). </p>

<pre class=""lang-none prettyprint-override""><code>$ git clone https://github.com/weidai11/cryptopp
Cloning into 'cryptopp'...
remote: Counting objects: 9116, done.
remote: Total 9116 (delta 0), reused 0 (delta 0), pack-reused 9116
Receiving objects: 100% (9116/9116), 8.05 MiB | 6.53 MiB/s, done.
Resolving deltas: 100% (6406/6406), done.
Checking connectivity... done.
</code></pre>

<p>Using Master is required because older versions of Crypto++ did not honor user's <code>CXX</code> and <code>CXXFLAGS</code>. You used to have to edit the makefile to fix it.</p>

<p>Then, perform the following:</p>

<pre class=""lang-none prettyprint-override""><code>export CXXFLAGS=""-DNDEBUG -g2 -O2 -stdlib=libc++""
$ CXX=clang++ make -j 4
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -fPIC -march=native -pipe -c cryptlib.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -fPIC -march=native -pipe -c cpu.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -fPIC -march=native -pipe -c shacal2.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -fPIC -march=native -pipe -c md5.cpp
...
</code></pre>

<p>You have to set Debug/Release build, Symbol level and Optimization level. The makefile will add the rest of the flags.</p>

<p>There's some hand waiving above since it only adds <code>-stdlib=libc++</code>. You should use the <code>CXXFLAGS</code> that Xcode uses to ensure the most trouble-free link. Using different <code>CXXFLAGS</code> has caused a lot of trouble over the years.</p>

<hr>

<p>Crypto++ is fat-binary safe (<a href=""https://stackoverflow.com/a/25531033/608639"">unlike cURL and OpenSSL</a>), so you should be able to perform the following. In fact, <a href=""https://github.com/weidai11/cryptopp/blob/master/cryptest.sh#L3393"" rel=""nofollow noreferrer"">our test script tests this class of configurations</a> (Intel and PPC fat binaries, including C++03 through C++17), so it should work out of the box for you:</p>

<pre class=""lang-none prettyprint-override""><code>export CXXFLAGS=""-DNDEBUG -g2 -O2 -stdlib=libc++ -arch i386 -arch x86_64""
$ CXX=clang++ make -j 4
$ make -j 4
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -arch i386 -arch x86_64 -fPIC -march=native -pipe -c cryptlib.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -arch i386 -arch x86_64 -fPIC -march=native -pipe -c cpu.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -arch i386 -arch x86_64 -fPIC -march=native -pipe -c shacal2.cpp
clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -arch i386 -arch x86_64 -fPIC -march=native -pipe -c md5.cpp
...
</code></pre>

<p>Using both architectures will avoid <em><code>Undefined symbols for architecture i386</code></em> and <em><code>Undefined symbols for architecture x86_64</code></em>.</p>

<hr>

<p>Here are some related Crypto++ wiki pages, but they are for iOS, and not OS X. They mostly apply, but not exactly.</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/IOS_(Xcode)"" rel=""nofollow noreferrer"">IOS (Xcode)</a></li>
<li><a href=""http://cryptopp.com/wiki/IOS_(Command_Line)"" rel=""nofollow noreferrer"">IOS (Command Line)</a></li>
</ul>

<p>Here's a wiki article on building the library from the command line. You're actually hitting the pain point discussed under <em>""Compilers and C++ Runtimes""</em>, but its not readily apparent:</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/Gnumakefile"" rel=""nofollow noreferrer"">GNUmakefile</a></li>
</ul>
","1275","<c++><xcode><macos><crypto++>","1","2","1","2016-08-19 02:01:04","39028487","5","","608639","","2016-08-19 02:01:04","2016-08-18 06:34:41",""
"9264122","verify in-app billing signature on server side","<p>I'm working on the security of the in-app billing in my application.</p>

<p>I do the verification on the server, which is in c++.</p>

<p>which ways are possible to verify it in c++?</p>

<p>can I use openssl command?</p>
","<p>You can use the OpenSSL library.  The response that your app receives from the Market is a string of JSON data and a signature string which is created using the private key for the public key that is in your developer profile.  You should keep that public key on your server, then your app can pass on the JSON string and signature to your server for verification.</p>

<p>The signature string is a base-64 encoded SHA1-with-RSA signature with PKCS#1 padding.  You should be able to verify it in a C++ program using the OpenSSL EVP_Verify... functions:
<a href=""http://www.openssl.org/docs/crypto/evp.html"" rel=""nofollow"">http://www.openssl.org/docs/crypto/evp.html</a></p>
","1248","<android><in-app-billing><crypto++>","2","2","1","2012-02-14 17:20:04","9281292","1","2","843227","","2012-02-14 16:43:41","2012-02-13 16:28:22",""
"43857083","Does compiled Crypto++ library code that uses AES/GCM encryption utilize Intel's AES-NI instructions?","<p>I'm implementing <a href=""https://www.cryptopp.com/wiki/GCM_Mode#AEAD"" rel=""nofollow noreferrer"">AES256/GCM encryption</a> and authentication using Crypto++ library. My code is compiled using Visual Studio 2008 as a C++/MFC project. This is a somewhat older project that uses a previous version of the library, <code>Cryptopp562</code>.</p>

<p>I'm curious if the resulting compiled code will use Intel's <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard--aes-/data-protection-aes-general-technology.html"" rel=""nofollow noreferrer"">AES-NI instructions</a>? And if so, what happens if the hardware (older CPU) does not support it?</p>

<p><strong>EDIT:</strong> <em>Here's an example of code that I'm testing it with:</em></p>

<pre><code>int nIV_Length = 12;
int nAES_KeyLength = 32;
BYTE* iv = new BYTE[nIV_Length];
BYTE* key = new BYTE[nAES_KeyLength];

int nLnPlainText = 128;
BYTE* pDataPlainText = new BYTE[nLnPlainText];

CryptoPP::AutoSeededRandomPool rng;
rng.GenerateBlock(iv, nIV_Length);

CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, nAES_KeyLength, iv, nIV_Length);

BYTE* pDataOut_AES_GCM = new BYTE[nLnPlainText];
memset(pDataOut_AES_GCM, 0, nLnPlainText);

BYTE mac[16] = {0};
enc.EncryptAndAuthenticate(pDataOut_AES_GCM, mac, sizeof(mac), iv, nIV_Length, NULL, 0, pDataPlainText, nLnPlainText);

delete[] pDataPlainText;
delete[] pDataOut_AES_GCM;
delete[] key;
delete[] iv;
</code></pre>
","<p>If you run code containing AES-NI instructions on x86 hardware which does not support these instructions, you should get invalid instruction errors. Unless the code does something smart (such as looking at CPUID to decide whether to run AES-NI optimized code, or something else), this can also be used to detect whether AES-NI instructions are actually used.</p>

<p>Otherwise you can always use a debugger, and set breakpoints at the AES-NI instructions to see whether your process ever uses that portion of code.</p>

<p>According to <a href=""https://cryptopp.com/release561.html"" rel=""nofollow noreferrer"">Crypto++ release notes</a> AES-NI support was added in version 5.6.1. Looking at the source code of version 5.6.5 Crypto++, if AES-NI support was enabled at compile time, then it uses run-time checks (the <code>HasAESNI()</code> function, probably utilizing CPUID) to decide whether to use these intrinsics. See <a href=""https://github.com/weidai11/cryptopp/blob/master/rijndael.cpp#L228"" rel=""nofollow noreferrer"">rijndael.cpp</a> (and <a href=""https://github.com/weidai11/cryptopp/blob/master/rijndael.cpp#L228"" rel=""nofollow noreferrer"">cpu.cpp</a> for the CPUID code) in its source code for details.</p>
","1240","<c++><aes><crypto++><aes-gcm><aes-ni>","0","2","3","2017-05-12 07:35:24","","5","","843732","","2017-05-12 06:42:02","2017-05-08 20:51:55",""
"43857083","Does compiled Crypto++ library code that uses AES/GCM encryption utilize Intel's AES-NI instructions?","<p>I'm implementing <a href=""https://www.cryptopp.com/wiki/GCM_Mode#AEAD"" rel=""nofollow noreferrer"">AES256/GCM encryption</a> and authentication using Crypto++ library. My code is compiled using Visual Studio 2008 as a C++/MFC project. This is a somewhat older project that uses a previous version of the library, <code>Cryptopp562</code>.</p>

<p>I'm curious if the resulting compiled code will use Intel's <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard--aes-/data-protection-aes-general-technology.html"" rel=""nofollow noreferrer"">AES-NI instructions</a>? And if so, what happens if the hardware (older CPU) does not support it?</p>

<p><strong>EDIT:</strong> <em>Here's an example of code that I'm testing it with:</em></p>

<pre><code>int nIV_Length = 12;
int nAES_KeyLength = 32;
BYTE* iv = new BYTE[nIV_Length];
BYTE* key = new BYTE[nAES_KeyLength];

int nLnPlainText = 128;
BYTE* pDataPlainText = new BYTE[nLnPlainText];

CryptoPP::AutoSeededRandomPool rng;
rng.GenerateBlock(iv, nIV_Length);

CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, nAES_KeyLength, iv, nIV_Length);

BYTE* pDataOut_AES_GCM = new BYTE[nLnPlainText];
memset(pDataOut_AES_GCM, 0, nLnPlainText);

BYTE mac[16] = {0};
enc.EncryptAndAuthenticate(pDataOut_AES_GCM, mac, sizeof(mac), iv, nIV_Length, NULL, 0, pDataPlainText, nLnPlainText);

delete[] pDataPlainText;
delete[] pDataOut_AES_GCM;
delete[] key;
delete[] iv;
</code></pre>
","<blockquote>
  <p>I'm curious if the resulting compiled code will use Intel's AES-NI instructions?</p>
</blockquote>

<p>Crypto++ 5.6.1 added support for AES-NI and Carryless Multiplies under GCM. It is used when two or three conditions are met. First, you are using a version of the library with the support. From the homepage under <strong><em>News</em></strong> (or the <strong>README</strong>):</p>

<blockquote>
  <ul>
  <li><p>8/9/2010 - Version 5.6.1 released</p>
  
  <ul>
  <li>added support for AES-NI and CLMUL instruction sets in AES and GMAC/GCM</li>
  </ul></li>
  </ul>
</blockquote>

<p>Second, the compiler, assembler and the linker must support the instructions. For Crypto++, that means you use at least MSVC 2008 SP1, GCC 4.3, and Binutils 2.19. For MSVC, if you look at <a href=""https://github.com/weidai11/cryptopp/blob/master/config.h"" rel=""nofollow noreferrer""><code>config.h</code></a>, its guarded as follows (<code>__AES__</code> is there for GCC and friends, too):</p>

<pre><code>#if ... (_MSC_FULL_VER &gt;= 150030729) ...
    #define CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE 1
#else
    #define CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE 0
#endif
</code></pre>

<p>You can lookup <a href=""http://qiita.com/yumetodo/items/8c112fca0a8e6b47072d"" rel=""nofollow noreferrer""><code>_MSC_FULL_VER</code></a> numbers at <a href=""http://qiita.com/yumetodo/items/8c112fca0a8e6b47072d"" rel=""nofollow noreferrer"">Visual Studio version</a>. Ironically, I've never seen a similar page on MSDN even though the service packs matter. You have to go to a Chinese site. For example, checked iterators showed up in VS2005 SP1 (IIRC).</p>

<p>For Linux and GCC compatibles, the <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile"" rel=""nofollow noreferrer""><code>GNUmakefile</code></a> checks the version of the compiler and assembler. If they are too old, then the makefile adds <code>CRYPTOPP_DISABLE_AESNI</code> to the command line to disable the support even if <code>__AES__</code> is defined.</p>

<p><code>CRYPTOPP_DISABLE_AESNI</code> shows up more often then you think. For example, if you download OpenBSD 6.0 (the current version), then 
<code>CRYPTOPP_DISABLE_AESNI</code> will be present because their assembler is so old. They are mostly stuck at the pre-GPL-2 version of their tools (apparently they did not agree to the license changes).</p>

<p>Third, the CPU supports both AES and SSE4 instructions (the reason for the SSE4 instructions is explained below). These checks are performed at runtime, and the function of interest is called <code>HasAES()</code> from <a href=""https://github.com/weidai11/cryptopp/blob/master/cpu.h"" rel=""nofollow noreferrer""><code>cpu.h</code></a> (there's also a <code>HasSSE4()</code>):</p>

<pre><code>//! \brief Determines AES-NI availability
//! \returns true if AES-NI is determined to be available, false otherwise
//! \details HasAESNI() is a runtime check performed using CPUID
inline bool HasAESNI()
{
    if (!g_x86DetectionDone)
        DetectX86Features();
    return g_hasAESNI;
}
</code></pre>

<p>The caveat of Item (3) is the library needed to be compiled with support from Item (2). If Item (2) did not include compile time support, then Item (3) cannot offer runtime support.</p>

<p>With respect to Item (3) and runtime support, we recently had to tune it. It seems some low-end Atom processors, like D2500's, have SSE2, SSE3, SSSE3 and AES-NI, but <strong><em>not</em></strong> SSE4.1 or SSE4.2. According to Intel ARK, its an optional configuration of the processor. We received one bug report about an illegal SSE4 instruction in the AES-NI codepath, so we had to add an <code>HasSSE4()</code> check. See <a href=""https://github.com/weidai11/cryptopp/pull/172"" rel=""nofollow noreferrer"">PR 172, Check for SSE4 support before using SSE4.1 instruction</a>.</p>

<hr>

<blockquote>
  <p>And if so, what happens if the hardware (older CPU) does not support it?</p>
</blockquote>

<p>Nothing. The default CXX implementation is used rather than the hardware accelerated AES.</p>

<p>You might be interested to know we also have other AES hardware acceleration, including ARMv8 Crypto and VIA Padlock. We also provide other hardware acceleration, like CRC32, Carryless-Multiplies and SHA. They all function the same way - compile time support is translated into runtime support.</p>

<hr>

<blockquote>
  <p>(Comment): I just set a breakpoint on DetectX86Features method in cpu.cpp ... and it never triggered ...</p>
</blockquote>

<p>This can be tricky for two reasons. First, the calls may be inlined in release builds so the code is shaped a little differently then you would expect.</p>

<p>Second, there's a global random number generator accessed by <code>GlobalRNG()</code>. <code>GlobalRNG()</code> is AES in OFB mode. When initializers run for the <code>test.cpp</code> translation unit, the <code>GlobalRNG()</code> is created which causes <code>DetectX86Features()</code> to run very early (before control enters <code>main</code>).</p>

<p>You may have better luck with observing the low level details with WinDbg.</p>

<hr>

<p>Its also worth mentioning that AES/GCM can be sped up by interleaving AES with GCM. I believe the idea is to perform 4 rounds of AES key calculation and 1 CLMUL in parallel. Crypto++ does not take advantage of it, but OpenSSL takes the opportunity. I don't know what Botan or mbedTLS do.</p>
","1240","<c++><aes><crypto++><aes-gcm><aes-ni>","0","1","3","2017-05-12 07:35:24","","5","","843732","","2017-05-12 06:42:02","2017-05-08 20:51:55",""
"43857083","Does compiled Crypto++ library code that uses AES/GCM encryption utilize Intel's AES-NI instructions?","<p>I'm implementing <a href=""https://www.cryptopp.com/wiki/GCM_Mode#AEAD"" rel=""nofollow noreferrer"">AES256/GCM encryption</a> and authentication using Crypto++ library. My code is compiled using Visual Studio 2008 as a C++/MFC project. This is a somewhat older project that uses a previous version of the library, <code>Cryptopp562</code>.</p>

<p>I'm curious if the resulting compiled code will use Intel's <a href=""http://www.intel.com/content/www/us/en/architecture-and-technology/advanced-encryption-standard--aes-/data-protection-aes-general-technology.html"" rel=""nofollow noreferrer"">AES-NI instructions</a>? And if so, what happens if the hardware (older CPU) does not support it?</p>

<p><strong>EDIT:</strong> <em>Here's an example of code that I'm testing it with:</em></p>

<pre><code>int nIV_Length = 12;
int nAES_KeyLength = 32;
BYTE* iv = new BYTE[nIV_Length];
BYTE* key = new BYTE[nAES_KeyLength];

int nLnPlainText = 128;
BYTE* pDataPlainText = new BYTE[nLnPlainText];

CryptoPP::AutoSeededRandomPool rng;
rng.GenerateBlock(iv, nIV_Length);

CryptoPP::GCM&lt;CryptoPP::AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, nAES_KeyLength, iv, nIV_Length);

BYTE* pDataOut_AES_GCM = new BYTE[nLnPlainText];
memset(pDataOut_AES_GCM, 0, nLnPlainText);

BYTE mac[16] = {0};
enc.EncryptAndAuthenticate(pDataOut_AES_GCM, mac, sizeof(mac), iv, nIV_Length, NULL, 0, pDataPlainText, nLnPlainText);

delete[] pDataPlainText;
delete[] pDataOut_AES_GCM;
delete[] key;
delete[] iv;
</code></pre>
","<p>Just to finish up my question, here's my findings.</p>

<p>The method that <em>forks</em> the execution to hardware supported <code>AES-NI</code> instructions, vs software implemented ones in Crypto++ library for my <a href=""https://stackoverflow.com/q/43857083/843732"">code sample above</a>, is <code>Rijndael::Enc::AdvancedProcessBlocks</code> located in <code>rijndael.cpp</code>. It starts as such:</p>

<pre><code>size_t Rijndael::Enc::AdvancedProcessBlocks(const byte *inBlocks, const byte *xorBlocks, byte *outBlocks, size_t length, word32 flags) const
{
#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
    if (HasAESNI())
        return AESNI_AdvancedProcessBlocks(AESNI_Enc_Block, AESNI_Enc_4_Blocks, (MAYBE_CONST __m128i *)(const void *)m_key.begin(), m_rounds, inBlocks, xorBlocks, outBlocks, length, flags);
#endif
</code></pre>

<p>The <code>CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE</code> preprocessor variable will be defined if you're building the Crypto++ library with at least <code>Visual Studio 2008 with SP1</code> (note that <code>SP1</code> is important.) Such dependency is necessary to be able to use <code>AES-NI</code> intrinsics (such as <a href=""https://msdn.microsoft.com/en-us/library/cc664810(v=vs.120).aspx"" rel=""nofollow noreferrer"">_mm_aesenc_si128</a> and <a href=""https://msdn.microsoft.com/en-us/library/cc714136(v=vs.120).aspx"" rel=""nofollow noreferrer"">_mm_aesenclast_si128</a>) to generate Intel's <code>AES-NI</code> machine code instructions.</p>

<p>So adding a breakpoint to the beginning of</p>

<p><a href=""https://i.stack.imgur.com/X2TY0.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/X2TY0.png"" alt=""enter image description here""></a></p>

<p>will let you debug it right from the Visual Studio. No outside debugger needed.</p>

<p>If you then step into the <code>AESNI_AdvancedProcessBlocks</code> method the actual AES encryption will be processed in one of the <code>AESNI_Enc_*</code> methods. Here's how the actual <a href=""https://software.intel.com/en-us/articles/intel-advanced-encryption-standard-instructions-aes-ni"" rel=""nofollow noreferrer""><code>aesenc</code></a> and <code>aesenclast</code> machine instructions may look like for <code>x86</code> configuration in the <code>Release</code> build:</p>

<p><a href=""https://i.stack.imgur.com/G6JNu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/G6JNu.png"" alt=""enter image description here""></a></p>

<p>So to answer my original question, for the code sample in my post above to be able to utilize Intel's <code>AES-NI</code> instructions one needs to build both the code sample and Crypto++ library with at least <code>Visual Studio 2008 with SP1</code>. (Just building it with <code>Visual Studio 2008</code>, or earlier version, <strong>will not</strong> do the job, <strong>even if</strong> the CPU that the code runs on supports <code>AES-NI</code> instructions.) After that, no other steps seem to be necessary. The library will detect the presence of <code>AES-NI</code> instructions automatically (<code>HasAESNI()</code> function) and will use them when available. Otherwise it will default to a software implementation.</p>

<p>Lastly, just from curiosity I decided to see how much difference would hardware vs software AES-GCM encryption would produce in speed. I used the following code snippet (from my code sample above):</p>

<pre><code>int nCntTest = 100000;
DWORD dwmsIniTicks = ::GetTickCount();

for(int i = 0; i &lt; nCntTest; i++)
{
    enc.EncryptAndAuthenticate(pDataOut_AES_GCM, mac, sizeof(mac), iv, nIV_Length, NULL, 0, pDataPlainText, nLnPlainText);
}

DWORD dwmsElapsed = ::GetTickCount() - dwmsIniTicks;

bool bHaveHwAES_Support = false;
#if CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE
bHaveHwAES_Support = CryptoPP::HasAESNI();
#endif
_tprintf(L""\nTimed %d AES256-GCM encryptions %s hardware encryption of %d bytes: %u ms\n"", 
    nCntTest, bHaveHwAES_Support ? L""with"" : L""without"", 
    nLnRealPlainText, dwmsElapsed);
</code></pre>

<p>Here are two results:</p>

<p><a href=""https://i.stack.imgur.com/O0yEC.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/O0yEC.png"" alt=""enter image description here""></a></p>

<p>and</p>

<p><a href=""https://i.stack.imgur.com/vdGXl.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vdGXl.png"" alt=""enter image description here""></a></p>

<p>This is obviously not an all-encompassing test. I ran it on my desktop with the <code>""Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz""</code> CPU.</p>

<p>But the good news is that <code>AES-GCM</code> encryption seems to be very fast, even without a hardware AES support.</p>
","1240","<c++><aes><crypto++><aes-gcm><aes-ni>","0","0","3","2017-05-12 07:35:24","","5","","843732","","2017-05-12 06:42:02","2017-05-08 20:51:55",""
"20967964","Crypto++ symmetric algorithms and authenticated block modes combinations","<p>I've implemented a C++ wrapper library for <a href=""http://cryptopp.com"" rel=""nofollow"">Crypto++</a> v5.6.2 and have a question about combinations of symmetric algorithms (e. g. Blowfish) and block modes (e. g. GCM).</p>

<p>I am able to encrypt and decrypt data via Blowfish/EAX, but I can't achieve the same by using Blowfish/GCM. AES/EAX and AES/GCM both work.</p>

<p>The following simple application demonstrates my problem:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

#include ""cryptopp/blowfish.h""
#include ""cryptopp/filters.h""
#include ""cryptopp/eax.h""
#include ""cryptopp/gcm.h""
#include ""cryptopp/osrng.h""
#include ""cryptopp/hex.h""

std::string encrypt(
    CryptoPP::AuthenticatedSymmetricCipher &amp;encryption,
    std::string const kPlainText,
    CryptoPP::SecByteBlock const kKey,
    unsigned const char * kIV) {
  std::string cipher_text;

  // TODO Is this the source of the problem?
  // BlockSize always returns 0 which leads to an exception if GCM block mode is used!
  std::cout &lt;&lt; encryption.BlockSize() &lt;&lt; "" bytes"" &lt;&lt; std::endl;

  encryption.SetKeyWithIV(
      kKey,
      kKey.size(),
      kIV
  );

  CryptoPP::StringSink *string_sink = new CryptoPP::StringSink(cipher_text);
  CryptoPP::BufferedTransformation *transformator = NULL;

  // The AuthenticatedEncryptionFilter adds padding as required.
  transformator = new CryptoPP::AuthenticatedEncryptionFilter(
      encryption,
      string_sink);

  bool const kPumpAll = true;
  CryptoPP::StringSource(
      kPlainText,
      kPumpAll,
      transformator);

  return cipher_text;
}

std::string decrypt(
    CryptoPP::AuthenticatedSymmetricCipher &amp;decryption,
    std::string const kCipherText,
    CryptoPP::SecByteBlock const kKey,
    unsigned const char * kIV) {
  std::string recovered_plain_text;

  decryption.SetKeyWithIV(
      kKey,
      kKey.size(),
      kIV);

  CryptoPP::StringSink *string_sink = new CryptoPP::StringSink(
      recovered_plain_text);
  CryptoPP::BufferedTransformation *transformator = NULL;
  CryptoPP::AuthenticatedDecryptionFilter *decryption_filter = NULL;

  decryption_filter = new CryptoPP::AuthenticatedDecryptionFilter(
      decryption,
      string_sink);
  transformator = new CryptoPP::Redirector(*decryption_filter);

  bool const kPumpAll = true;
  CryptoPP::StringSource(
      kCipherText,
      kPumpAll,
      transformator);

  return recovered_plain_text;
}

int main() {
  CryptoPP::AutoSeededRandomPool prng;
  CryptoPP::SecByteBlock key(CryptoPP::Blowfish::DEFAULT_KEYLENGTH);
  prng.GenerateBlock(key, key.size());

  byte iv[CryptoPP::Blowfish::BLOCKSIZE];
  prng.GenerateBlock(iv, sizeof(iv));

  // Creates templated mode objects of  block ciphers.

  // This works...
//  CryptoPP::EAX&lt;CryptoPP::Blowfish&gt;::Encryption encryption;
//  CryptoPP::EAX&lt;CryptoPP::Blowfish&gt;::Decryption decryption;

  // This does NOT work...
  CryptoPP::GCM&lt;CryptoPP::Blowfish&gt;::Encryption encryption;
  CryptoPP::GCM&lt;CryptoPP::Blowfish&gt;::Decryption decryption;

  std::string plain_text = ""Block Mode Test"";
  std::string cipher_text = encrypt(encryption, plain_text, key, iv);
  // terminate called after throwing an instance of 'CryptoPP::InvalidArgument'
  // what():  Blowfish/GCM: block size of underlying block cipher is not 16

  std::cout &lt;&lt; ""cipher text: "" &lt;&lt; std::hex &lt;&lt; cipher_text &lt;&lt; std::endl;
  std::cout &lt;&lt; ""recovered plain text: "" &lt;&lt; decrypt(decryption, cipher_text, key, iv) &lt;&lt; std::endl;
}
</code></pre>

<p>A <code>CryptoPP::InvalidArgument</code> exception is thrown if running the code above with the following text:</p>

<pre><code>Blowfish/GCM: block size of underlying block cipher is not 16
</code></pre>

<p>But when running the code instead with the block mode EAX, no exception is thrown. So my questions are:</p>

<ul>
<li>Does GCM only work with AES? Can GCM also be used with Blowfish or 3DES?</li>
<li>Is there a matrix available which lists all possible combinations of symmetric algorithms with block modes?</li>
<li>Or is this a bug in Crypto++? Because the method <code>BlockSize()</code> <strong>always</strong> returns <code>0</code> but the exception is only raised if using Blowfish (or 3DES) instead of AES. This seems to raise the exception mentioned.</li>
</ul>
","<p>GCM has been designed to work with <strong>128-bit (=16 byte) block size</strong> only. You can find this in the <a href=""http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf"" rel=""nofollow"">original paper</a> in Section 5.1.</p>

<p>Blowfish is a <strong>64-bit block size</strong> algorithm, so the two are not compatible as an ""out-of-the-box"" authenticated encryption combination. The same is true for <code>3DES</code>. The exception is not a bug in Crypto++.</p>

<p>GCM will work with other Crypto++ objects that have 128-bit block sizes. They include <code>AES</code>, <code>Cast-256</code>, <code>Rijndael</code> <code>Cameilla</code>, <code>MARS</code>, <code>Serpent</code> and <code>Twofish</code>. A table of the block sizes is available at <a href=""http://www.codeproject.com/Articles/21877/Applied-Crypto-Block-Ciphers"" rel=""nofollow"">Applied Crypto++: Block Ciphers</a>.</p>

<p>GCM will not work with larger block sizes either. For example, <code>Rijndael</code> (the parent of <code>AES</code>) offers 192-bit and 256-bit block sizes (<code>AES</code> only specifies the 128-bit block size). GCM will not work with the larger block sizes. And the same is true for <code>SHACAL-2</code>, with a 256-bit block size.</p>

<p>Crypto++'s <code>BlockSize()</code> sometimes returns 0 (it has to do with the template parameters). Instead, use the compile time constants like <code>AES::BLOCKSIZE</code>, <code>Camellia::BLOCKSIZE</code> and <code>Rijndael::BLOCKSIZE</code>. This could be considered a bug.</p>
","1235","<c++><encryption><encryption-symmetric><crypto++><block-cipher>","4","4","1","2014-01-10 06:48:16","","0","","","","","2014-01-07 09:25:56",""
"45522845","Import RSA public/private key from a string Crypto++","<p>I would like to import a RSA key directly from a string variable, to use it with Crypto++library.</p>

<p>The code would look like this:
It is an example of what I want to do,not a working code.
</p>

<pre><code>std::string publickey_str =
    ""-----BEGIN PUBLIC KEY-----""
    ""gm6mZA1NTZQJVUk9AGDb6NRngzRlRAgXBTWAispwlqsuHFoCrv02xPm1uxkLyfUq""
    ""LoA4/EQJ25okjmGkrjgak+XmQIPKmAg94gWAtvRIrLZNmCj/aPeuikmCPXkKtg2b""
    ""pdB6xzHY0ftGu0l6Vb8zttg7Wfo1kJowjoqCRwo9ex/IKwPXxE3UsugshcZOGdqT""
    ""6E3B/Vw+JoerL/LfeOU2OYcSFEXsWqjzkrGzEVuKzRnve5RlXyY0gShP33f+hDnC""
    ""F+Uu2tFfFgxRkdQPk7AKm4MCAwEAAQ==""
    ""-----END PUBLIC KEY-----"";

RSA::PublicKey publicKey;
publicKey.load(publickey_str);
</code></pre>

<p>In the Crypto++ wiki, I only find how to import/export keys from/to files (.der, .pem). Do you know how can i do the same thing with a string ?</p>

<p>Edit: i apologize,i forgot to tell that i shortened the RSA public key for the example.</p>
","<blockquote>
  <p>I only find how to import/export keys from/to files (.der, .pem). Do you know how can i do the same thing with a string ?</p>
</blockquote>

<p>In Crypto++, you can swap one source for any other source. You can change the <code>FileSource</code> for a <code>NetworkSource</code>, <code>StringSource</code>, <code>ArraySource</code>, etc.</p>

<p>The same applies to filters, too. <code>HexEncoder</code>, <code>Base64Encoder</code>, <code>HexDecoder</code>, <code>Base64Decoder</code> and all interchangeable filters. It not limited to encoders, and you can swap-in an encryption filter, signing filter or verification filter, too. They can be swapped in and out because they all implement the <code>BufferedTransformation</code> interface.</p>

<p>And the same applies to sinks as well. You can change the <code>FileSink</code> for a <code>NetworkSink</code>, <code>StringSink</code>, <code>ArraySink</code>, etc.</p>

<hr>

<p>The key you are showing is a PEM encoded key. To encode and decode in PEM, you need the <a href=""https://www.cryptopp.com/wiki/PEM_Pack"" rel=""nofollow noreferrer"">PEM Pack</a>. Its not part of the library proper so its likely missing from your copy of the library. Rather, the PEM Pack is an add-on maintained by the community and you have to download and build it.</p>

<p>To use the PEM Pack, you need to rebuild the library from sources. To set things up:</p>

<pre class=""lang-none prettyprint-override""><code>$ cd cryptopp
$ wget https://www.cryptopp.com/w/images/5/5a/Pem-pack.zip
--2017-08-05 16:30:26--  https://www.cryptopp.com/w/images/5/5a/Pem-pack.zip
Resolving www.cryptopp.com (www.cryptopp.com)... 144.217.231.241
Connecting to www.cryptopp.com (www.cryptopp.com)|144.217.231.241|:443...
...
2017-08-05 16:30:26 (862 KB/s) - ‘Pem-pack.zip’ saved [20769/20769]

$ unzip -aoq Pem-pack.zip
$ ls pem*
pem-com.cpp  pem-create-keys.sh  pem-rd.cpp    pem-verify-keys.sh
pem-com.h    pem.h               pem-test.cxx  pem-wr.cpp
</code></pre>

<p>Then, make as usual:</p>

<pre class=""lang-none prettyprint-override""><code>$ make distclean
...

$ make -j 9
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c cryptlib.cpp
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c cpu.cpp
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c integer.cpp
...
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c pem-com.cpp
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c pem-rd.cpp
g++ -DNDEBUG -g2 -O3 -fPIC -march=native -pipe -c pem-wr.cpp
...
ar r libcryptopp.a cryptlib.o cpu.o integer.o 3way.o ... zdeflate.o zinflate.o zlib.o
</code></pre>

<p>Note: <strike>I need to fix the <code>auto_ptr</code> warnings. I'll get to it later today.</strike> This has been fixed. A new version of the <a href=""https://www.cryptopp.com/wiki/PEM_Pack"" rel=""nofollow noreferrer"">PEM Pack</a> is available from the wiki.</p>

<p>Now, you have PEM support:</p>

<pre class=""lang-none prettyprint-override""><code>$ nm libcryptopp.a | grep PEM | grep ' T ' | c++filt
00000000000000a0 T CryptoPP::PEM_WriteLine(CryptoPP::BufferedTransformation&amp;, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt; const&amp;)
00000000000000f0 T CryptoPP::PEM_WriteLine(CryptoPP::BufferedTransformation&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)
0000000000000140 T CryptoPP::PEM_Base64Decode(CryptoPP::BufferedTransformation&amp;, CryptoPP::BufferedTransformation&amp;)
00000000000004e0 T CryptoPP::PEM_Base64Encode(CryptoPP::BufferedTransformation&amp;, CryptoPP::BufferedTransformation&amp;)
...
</code></pre>

<hr>

<p>Here's the code.</p>

<pre class=""lang-cxx prettyprint-override""><code>$ cat pem-test.cxx
#include &lt;string&gt;
#include &lt;iostream&gt;

#include ""integer.h""
#include ""rsa.h""
#include ""pem.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
    const std::string publickey_str =
        ""-----BEGIN PUBLIC KEY-----\n""
        ""gm6mZA1NTZQJVUk9AGDb6NRngzRlRAgXBTWAispwlqsuHFoCrv02xPm1uxkLyfUq\n""
        ""LoA4/EQJ25okjmGkrjgak+XmQIPKmAg94gWAtvRIrLZNmCj/aPeuikmCPXkKtg2b\n""
        ""pdB6xzHY0ftGu0l6Vb8zttg7Wfo1kJowjoqCRwo9ex/IKwPXxE3UsugshcZOGdqT\n""
        ""6E3B/Vw+JoerL/LfeOU2OYcSFEXsWqjzkrGzEVuKzRnve5RlXyY0gShP33f+hDnC\n""
        ""F+Uu2tFfFgxRkdQPk7AKm4MCAwEAAQ==\n""
        ""-----END PUBLIC KEY-----\n"";

    RSA::PublicKey publicKey;

    try
    {
        StringSource source(publickey_str, true);
        PEM_Load(source, publicKey);
    }
    catch(const Exception&amp; ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }

    const Integer&amp; e = publicKey.GetPublicExponent();
    std:: cout &lt;&lt; e &lt;&lt; std::endl;

    const Integer&amp; n = publicKey.GetModulus();
    std:: cout &lt;&lt; n &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Here's the result:</p>

<pre><code>$ ./test.exe
BER decode error
</code></pre>

<p>It looks like your public key is bad. I'm not going to waste time on it because its not clear to me if its a real key, or if its random junk you made up.</p>

<hr>

<p>Regarding this:</p>

<blockquote>
<pre><code>$ unzip -aoq Pem-pack.zip
$ ls pem*
pem-com.cpp  pem-create-keys.sh  pem-rd.cpp    pem-verify-keys.sh
pem-com.h    pem.h               pem-test.cxx  pem-wr.cpp
</code></pre>
</blockquote>

<p>I use the scripts for testing. You can delete them if you want. You can also delete <code>pem-test.cxx</code> if you want. It is not needed either.</p>

<pre><code> $ rm pem-*.sh pem-test.cxx
</code></pre>
","1231","<c++><rsa><crypto++>","-1","2","2","2018-03-30 11:12:19","45526356","4","","8096090","","2017-08-05 20:58:39","2017-08-05 14:10:50",""
"45522845","Import RSA public/private key from a string Crypto++","<p>I would like to import a RSA key directly from a string variable, to use it with Crypto++library.</p>

<p>The code would look like this:
It is an example of what I want to do,not a working code.
</p>

<pre><code>std::string publickey_str =
    ""-----BEGIN PUBLIC KEY-----""
    ""gm6mZA1NTZQJVUk9AGDb6NRngzRlRAgXBTWAispwlqsuHFoCrv02xPm1uxkLyfUq""
    ""LoA4/EQJ25okjmGkrjgak+XmQIPKmAg94gWAtvRIrLZNmCj/aPeuikmCPXkKtg2b""
    ""pdB6xzHY0ftGu0l6Vb8zttg7Wfo1kJowjoqCRwo9ex/IKwPXxE3UsugshcZOGdqT""
    ""6E3B/Vw+JoerL/LfeOU2OYcSFEXsWqjzkrGzEVuKzRnve5RlXyY0gShP33f+hDnC""
    ""F+Uu2tFfFgxRkdQPk7AKm4MCAwEAAQ==""
    ""-----END PUBLIC KEY-----"";

RSA::PublicKey publicKey;
publicKey.load(publickey_str);
</code></pre>

<p>In the Crypto++ wiki, I only find how to import/export keys from/to files (.der, .pem). Do you know how can i do the same thing with a string ?</p>

<p>Edit: i apologize,i forgot to tell that i shortened the RSA public key for the example.</p>
","<p>This is how I am loading a string into PublicKey</p>

<pre><code>//Create Cryptopp StringSource From Std::string
std::string PublicKeyString = ""&lt;Your key as std::string value&gt;"";
CryptoPP::StringSource PKeyStringSource(PublicKeyString, true);
CryptoPP::RSA::PublicKey publicKey;
publicKey.Load(PKeyStringSource);
</code></pre>

<p>Have a look at entire function for elaborate usage. Here I pass the keys as std::string in the function to verify signatures. <code>RSA::PublicKey</code> is created from <code>std::string</code> passed to function</p>

<pre><code>bool Signature::VerifySignature(const std::string &amp;PublicKeyString,
    const std::string &amp;data,
    const std::string &amp;SignatureStr)
{
    CryptoPP::StringSource PKeyStringSource(PublicKeyString, true);
    CryptoPP::StringSource SignStringSource(SignatureStr, true);

    CryptoPP::RSA::PublicKey publicKey;
    publicKey.Load(PKeyStringSource);

    // verify message
    bool result = false;

    m_verifier.AccessPublicKey().Load(SignStringSource);

    CryptoPP::StringSource ss2(SignatureStr + data, true,
        new CryptoPP::SignatureVerificationFilter(m_verifier,
            new CryptoPP::ArraySink((CryptoPP::byte*)&amp;result,
                sizeof(result))));

    return result;
}
</code></pre>
","1231","<c++><rsa><crypto++>","-1","1","2","2018-03-30 11:12:19","45526356","4","","8096090","","2017-08-05 20:58:39","2017-08-05 14:10:50",""
"27315687","Creation of ECDSA public key given curve and public point?","<p>I am struggling with the creation of a ECDSA public key from a string representation of a public key i.e </p>

<pre><code>string     devicePublicKey(""86FB5EB3CA0507226BE7197058B9EC041D3A3758D9D9C91902ACA3391F4E58AEF13AFF63CC4EF68942B9B94904DC1B890EDBEABD16B992110624968E894E560E"");
</code></pre>

<p>previously I found that I had to prefix this key with '04' so not sure if this is require this time?</p>

<p>I am trying to generate it to use in verifying a signature</p>

<pre><code>string ecs04b2ExpSignature(""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"");
</code></pre>

<p>where the data to be signed is</p>

<pre><code>string      ecs04b2SigningData(""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"");
</code></pre>

<p>My rough code for now looks like this</p>

<pre><code>SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
SecByteBlock signature(convertHexStrToSecByteBlock(signatureIn));

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
string inPublicKey(""04"");
inPublicKey.append(pubKeyIn);
SecByteBlock pubKey = encryptBase::convertHexStrToSecByteBlock(inPublicKey);



ECP::Point p;
publicKey.AccessGroupParameters().Initialize(CryptoPP::ASN1::secp256r1());
publicKey.GetGroupParameters().GetCurve().DecodePoint(p, pubKey, publicKey.GetGroupParameters().GetCurve().EncodedPointSize(true));
publicKey.SetPublicElement(p);

//ByteQueue qt;
//qt.Put((byte*)exp.c_str(),(size_t)exp.size());
AutoSeededRandomPool prng;
bool result = publicKey.Validate(prng, 3);
if (result) 
{  
    // Load public key (in ByteQueue, X509 format)
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);

    bool result = verifier.VerifyMessage(message.data(), messageIn.size(), signature.data(), signature.size());
    if (result)
        cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
    else
        cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
}
else
{
    cout &lt;&lt; ""Failed to validate key"" &lt;&lt; endl;
}
</code></pre>

<p>this is chopped together so wont build. Any help would be great</p>

<p>PS I asked a similar question relating to private keys here <a href=""https://stackoverflow.com/questions/27232053/creation-of-ecdsa-private-key-given-curve-and-private-exponent"">Creation of ECDSA private key given curve and private exponent?</a></p>
","<p>The answer is detailed on the <a href=""http://www.cryptopp.com/wiki/Ecdsa#Public_Key_2"" rel=""nofollow noreferrer"">ECDSA wiki page</a>, but its not readily apparent. You need to perform the following to initialize the <code>publicKey</code> given the curve and public point:</p>

<pre><code>string pt = ""2DB45A3F21889438B42C8F464C75292BACF5FDDB5DA0B492501B299CBFE92D8F""
            ""DB90FC8FF4026129838B1BCAD1402CAE47FE7D8084E409A41AFCE16D63579C5F"";

HexDecoder decoder;
decoder.Put((byte*)pt.data(), pt.size());
decoder.MessageEnd();

ECP::Point q;
size_t len = decoder.MaxRetrievable();
// len should be GetField().MaxElementByteLength()

q.identity = false;
q.x.Decode(decoder, len/2);
q.y.Decode(decoder, len/2);

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
publicKey.Initialize(ASN1::secp256r1(), q);

bool result = publicKey.Validate( prng, 3 );
if( result )
{
    cout &lt;&lt; ""Validated public key"" &lt;&lt; endl;
}
else
{
    cerr &lt;&lt; ""Failed to validate public key"" &lt;&lt; endl;
    exit(1);
}

const ECP::Point&amp; qq = publicKey.GetPublicElement();
cout &lt;&lt; ""Q.x: "" &lt;&lt; std::hex &lt;&lt; qq.x &lt;&lt; endl;
cout &lt;&lt; ""Q.y: "" &lt;&lt; std::hex &lt;&lt; qq.y &lt;&lt; endl;
</code></pre>

<p>The program above produces the following results.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
Validated public key
Q.x: 2db45a3f21889438b42c8f464c75292bacf5fddb5da0b492501b299cbfe92d8fh
Q.y: db90fc8ff4026129838b1bcad1402cae47fe7d8084e409a41afce16d63579c5fh
</code></pre>

<hr>

<p>You can't use <code>GetField().MaxElementByteLength()</code> because the only thing available are the <code>x</code> and <code>y</code> coordinates. Things like field size won't be available until you initialize the underlying <a href=""http://www.cryptopp.com/docs/ref/class_d_l___group_parameters___e_c.html"" rel=""nofollow noreferrer""><code>DL_GroupParameters_EC&lt; EC &gt;</code></a> in the public key.</p>

<p>As an example, the following causes a segmentation fault:</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
unsigned int u = publicKey.GetGroupParameters().GetCurve().GetField().MaxElementByteLength();
cout &lt;&lt; ""Field element length: "" &lt;&lt; u &lt;&lt; endl;
</code></pre>

<hr>

<p>You can tamper with the public key to ensure a validation failure with:</p>

<pre><code>q.y.Decode(decoder, len/2);
q.y++;
</code></pre>
","1230","<c++><hex><crypto++><ecdsa>","2","2","2","2019-10-22 18:21:14","27339240","0","1","-1","","2017-05-23 12:05:55","2014-12-05 12:15:11",""
"27315687","Creation of ECDSA public key given curve and public point?","<p>I am struggling with the creation of a ECDSA public key from a string representation of a public key i.e </p>

<pre><code>string     devicePublicKey(""86FB5EB3CA0507226BE7197058B9EC041D3A3758D9D9C91902ACA3391F4E58AEF13AFF63CC4EF68942B9B94904DC1B890EDBEABD16B992110624968E894E560E"");
</code></pre>

<p>previously I found that I had to prefix this key with '04' so not sure if this is require this time?</p>

<p>I am trying to generate it to use in verifying a signature</p>

<pre><code>string ecs04b2ExpSignature(""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"");
</code></pre>

<p>where the data to be signed is</p>

<pre><code>string      ecs04b2SigningData(""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"");
</code></pre>

<p>My rough code for now looks like this</p>

<pre><code>SecByteBlock message(convertHexStrToSecByteBlock(messageIn));
SecByteBlock signature(convertHexStrToSecByteBlock(signatureIn));

ECDSA&lt;ECP, SHA256&gt;::PublicKey publicKey;
string inPublicKey(""04"");
inPublicKey.append(pubKeyIn);
SecByteBlock pubKey = encryptBase::convertHexStrToSecByteBlock(inPublicKey);



ECP::Point p;
publicKey.AccessGroupParameters().Initialize(CryptoPP::ASN1::secp256r1());
publicKey.GetGroupParameters().GetCurve().DecodePoint(p, pubKey, publicKey.GetGroupParameters().GetCurve().EncodedPointSize(true));
publicKey.SetPublicElement(p);

//ByteQueue qt;
//qt.Put((byte*)exp.c_str(),(size_t)exp.size());
AutoSeededRandomPool prng;
bool result = publicKey.Validate(prng, 3);
if (result) 
{  
    // Load public key (in ByteQueue, X509 format)
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);

    bool result = verifier.VerifyMessage(message.data(), messageIn.size(), signature.data(), signature.size());
    if (result)
        cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
    else
        cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;
}
else
{
    cout &lt;&lt; ""Failed to validate key"" &lt;&lt; endl;
}
</code></pre>

<p>this is chopped together so wont build. Any help would be great</p>

<p>PS I asked a similar question relating to private keys here <a href=""https://stackoverflow.com/questions/27232053/creation-of-ecdsa-private-key-given-curve-and-private-exponent"">Creation of ECDSA private key given curve and private exponent?</a></p>
","<p>Here's the answer to your second question on how to use <code>VerifyMessage</code>:</p>

<pre><code>...
publicKey.Initialize(ASN1::secp256r1(), q);

string msg = ""020000000000000001FFFFFFFFFFFFFFFE123456789ABCDEF000B3DA2000000100000300000003030003000300"";
string sig = ""0199E984CEC75DDCA7F1DDF6E53E2E67352A2BE38A4B66F8ED596606FAB983FF300CAA76DE88CED9D563A5C03E8F3A7C000780F3F2061C611E9AA0B18B460D77"";

string mm, ss;

decoder.Detach(new StringSink(mm));
decoder.Put((byte*)msg.data(), msg.size());
decoder.MessageEnd();

decoder.Detach(new StringSink(ss));
decoder.Put((byte*)sig.data(), sig.size());
decoder.MessageEnd();

ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(publicKey);
result = verifier.VerifyMessage((byte*)mm.data(), mm.size(), (byte*)ss.data(), ss.size());

if( result )
{
    cout &lt;&lt; ""Verified message"" &lt;&lt; endl;
}
else
{ 
    cerr &lt;&lt; ""Failed to verify message"" &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>Calling <code>Detach</code> on the <code>HexDecoder</code> deletes the current filter, and replaces it with the new filter. In the code above, its the <code>StringSink</code>. You have to do it to ensure memory is not leaked.</p>

<p>Your message does not verify under the public key:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
Validated public key
Failed to verify message
</code></pre>

<p>You can also try to verify the ASCII message rather than the binary message, but it fails to verify too:</p>

<pre><code>decoder.Attach(new StringSink(mm));
decoder.Put((byte*)msg.data(), msg.size());
decoder.MessageEnd();

// Swap in the ASCII message for the binary message
mm = msg;
</code></pre>

<p>So someone gave you the wrong message, the wrong signature or the wrong public key (or some combination).</p>
","1230","<c++><hex><crypto++><ecdsa>","2","0","2","2019-10-22 18:21:14","27339240","0","1","-1","","2017-05-23 12:05:55","2014-12-05 12:15:11",""
"20655901","Crash in rjindael.cpp, function AESNI_Enc_Block when using RSA keys","<p>I am new to crypto++ and just follow an example from its cryptest project (test.cpp). I generated both public and private keys using RSA. I try to use the keys, exactly as in the example. It works perfectly well in crypto++ own project and generates unhandled exception in mine. Below is the basic code, which breaks at decryption stage. any suggestions on why?</p>

<pre><code>#include ""stdafx.h""

#include &lt;core/osrng.h&gt;
#include &lt;core/modes.h&gt;
#include &lt;core/hex.h&gt;
#include &lt;core/files.h&gt;
#include &lt;core/rsa.h&gt;
#include &lt;core/sha.h&gt;
#include &lt;core/cryptlib.h&gt;

#include &lt;iostream&gt;

using namespace CryptoPP;
using namespace std;

static OFB_Mode&lt;AES&gt;::Encryption s_globalRNG;
RandomNumberGenerator &amp; GlobalRNG()
{
    return s_globalRNG;
}

string RSAEncryptString(const char *pubFilename, const char *seed, const char *message)
{
    FileSource pubFile(pubFilename, true, new HexDecoder);
    RSAES_OAEP_SHA_Encryptor pub(pubFile);

    RandomPool randPool;

    randPool.IncorporateEntropy((byte *)seed, strlen(seed));

    string result;
    StringSource(message, true, new PK_EncryptorFilter(randPool, pub, new HexEncoder(new StringSink(result))));
    return result;
}

string RSADecryptString(const char *privFilename, const char *ciphertext)
{
    FileSource privFile(privFilename, true, new HexDecoder);
    RSAES_OAEP_SHA_Decryptor priv(privFile);

    string result;  
    StringSource(ciphertext, true, new HexDecoder(new PK_DecryptorFilter(GlobalRNG(), priv, new StringSink(result))));
    return result;
}

int _tmain(int argc, _TCHAR* argv[])
{
    char privFilename[128] = ""pri4096"";
    char pubFilename[128] = ""pub4096"";
    char seed[1024] = ""seed"";
    char message[1024] = ""test"";

    try
    {
        string ciphertext = RSAEncryptString(pubFilename, seed, message);

        string decrypted = RSADecryptString(privFilename, ciphertext.c_str());
    }
    catch(CryptoPP::Exception &amp;e)
    {
        cout &lt;&lt; ""\nCryptoPP::Exception caught: "" &lt;&lt; e.what() &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>In my project the program breaks at line</p>

<pre><code>StringSource(ciphertext, true, new HexDecoder(new PK_DecryptorFilter(GlobalRNG(), priv, new StringSink(result))));
</code></pre>

<p>And debugger points to rjindael.cpp, function AESNI_Enc_Block, line 1005.</p>
","<p>As pointed out by Yakk, I missed initialisation of the variable s_globalRNG. The following code fixes my problem.</p>

<pre><code>//just below main()

std::string seed2 = IntToString(time(NULL));
seed2.resize(16);
s_globalRNG.SetKeyWithIV((byte *)seed2.data(), 16, (byte *)seed2.data());
</code></pre>

<p>thanks a lot!</p>
","1228","<c++><encryption><crypto++>","2","2","1","2015-10-19 17:19:23","20656642","6","","608639","","2015-10-19 17:19:23","2013-12-18 10:41:51",""
"23639616","Qt crypto++ aes encrypt/decrypt not decrypting properly","<p>I have the following code:</p>

<pre><code>#define PRIVATE_KEY ""729308A8E815F6A46EB3A8AE6D5463CA7B64A0E2E11BC26A68106FC7697E727E37011""
</code></pre>

<p>To Encrypt:</p>

<pre><code>QString Encryption::AESEncrypt(const QString &amp;data)
{
string plain = data.toStdString();
string ciphertext;


// Hex decode symmetric key:
HexDecoder decoder;
decoder.Put( (byte *)PRIVATE_KEY, 32*2 );
decoder.MessageEnd();

word64 size = decoder.MaxRetrievable();
char *decodedKey = new char[size];

decoder.Get((byte *)decodedKey, size);

// Generate Cipher, Key, and CBC
byte key[ AES::MAX_KEYLENGTH ];
byte iv[ AES::BLOCKSIZE ];

StringSource( reinterpret_cast&lt;const char *&gt;(decodedKey), true,
              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );

memset( iv, 0x00, AES::BLOCKSIZE );

CBC_Mode&lt;AES&gt;::Encryption Encryptor( key, sizeof(key), iv );

StringSource( plain, true, new StreamTransformationFilter( Encryptor,
              new HexEncoder(new StringSink( ciphertext ) ) ) );

return QString::fromStdString(ciphertext);

}
</code></pre>

<p>To Decrypt:</p>

<pre><code>QString Encryption::AESDecrypt(const QString &amp;data)
{
string plain;
string encrypted = data.toStdString();

// Hex decode symmetric key:
HexDecoder decoder;
decoder.Put( (byte *)PRIVATE_KEY,32*2 );
decoder.MessageEnd();

word64 size = decoder.MaxRetrievable();
char *decodedKey = new char[size];
decoder.Get((byte *)decodedKey, size);

// Generate Cipher, Key, and CBC
byte key[ AES::MAX_KEYLENGTH ];
byte iv[ AES::BLOCKSIZE ];

StringSource( reinterpret_cast&lt;const char *&gt;(decodedKey), true,
              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );

memset( iv, 0x00, AES::BLOCKSIZE );

try
{
    CBC_Mode&lt;AES&gt;::Decryption Decryptor( key, sizeof(key), iv );


    StringSource( encrypted, true,
                  new HexDecoder(new StreamTransformationFilter( Decryptor,
                                 new StringSink( plain ) ) ) );

}
catch (Exception &amp;e) { // ...

}
catch (...) { // ...

}
return QString::fromStdString(plain);
}
</code></pre>

<p>If I run the following:</p>

<pre><code>Encryption encrypt;
QString encdata = encrypt.AESEncrypt(""This is my data"");
qDebug() &lt;&lt; ""encrypt: "" &lt;&lt; encdata;
qDebug() &lt;&lt; ""decrypt"" &lt;&lt; encrypt.AESDecrypt(encdata);
</code></pre>

<p>I get the following output:</p>

<pre><code>encrypt:  ""4E712EFDE13DA42FF798C193D17BE5D2"" 
decrypt """" 
</code></pre>

<p>So I'm not sure why its not decrypting properly. I took the code from the following <a href=""https://stackoverflow.com/questions/12306956/example-of-aes-using-crypto"">conversation</a>.  The code is failing on the second <code>StringSource</code> on decrypt and landing on the first Exception.  Any ideas on what am I doing wrong?</p>
","<p>I was getting a PKCS#7 padding error with the provided code. The code I used was modified to remove the Qt stuff and remove the function calls, so I'm not sure if I accidentally added/removed an error. </p>

<p>I was able to fix the padding issue by modifying the encoding/decoding of the key. I think the problem was here:</p>

<pre><code>StringSource( reinterpret_cast&lt;const char *&gt;(decodedKey), true,
          new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) );
</code></pre>

<p>In the code above, there was no guarantee <code>decodedKey</code> was <code>NULL</code> terminated. The fix was easy - store it in a <code>string</code> and then use <code>length()</code>.</p>

<p>The key you listed is 35 bytes in length (after decoding).</p>

<pre><code>#define COUNTOF(x) (sizeof(x)/sizeof(x[0]))
#define PRIVATE_KEY ""729308A8E815F6A46EB3A8AE6D5463CA7B64A0E2E11BC26A68106FC7697E727E37011""

string plain1 = ""Now is the time for all good men..."";
string decoded1, cipher1;

// Hex decode symmetric key:
StringSource ss1((const byte*)PRIVATE_KEY, COUNTOF(PRIVATE_KEY), true,
                 new HexDecoder(new StringSink(decoded1)));

// Generate Cipher, Key, and CBC
byte key1[ AES::MAX_KEYLENGTH ];
byte iv1[ AES::BLOCKSIZE ];

SHA256 sha1;
StringSource ss2( decoded1, true,
                 new HashFilter(sha1, new ArraySink(key1, sizeof(key1))) );

memset( iv1, 0x00, AES::BLOCKSIZE );

CBC_Mode&lt;AES&gt;::Encryption encryptor( key1, sizeof(key1), iv1 );

StringSource ss3( plain1, true, new StreamTransformationFilter( encryptor,
                                                               new HexEncoder(new StringSink( cipher1 ) ) ) );

string plain2, decoded2;
string cipher2 = cipher1;

// Hex decode symmetric key:
StringSource ss4((const byte*)PRIVATE_KEY, COUNTOF(PRIVATE_KEY), true,
                 new HexDecoder(new StringSink(decoded2)));

// Generate Cipher, Key, and CBC
byte key2[ AES::MAX_KEYLENGTH ];
byte iv2[ AES::BLOCKSIZE ];

SHA256 sha2;
StringSource ss5( decoded2, true,
                 new HashFilter(sha2, new ArraySink(key2, sizeof(key2))) );

memset( iv2, 0x00, AES::BLOCKSIZE );


CBC_Mode&lt;AES&gt;::Decryption decryptor( key2, sizeof(key2), iv2 );

StringSource ss6( cipher2, true,
                 new HexDecoder(new StreamTransformationFilter( decryptor,
                                                               new StringSink( plain2 ) ) ) );

cout &lt;&lt; ""Plain 1: "" &lt;&lt; plain1 &lt;&lt; endl;
cout &lt;&lt; ""Cipher: "" &lt;&lt; cipher1 &lt;&lt; endl;
cout &lt;&lt; ""Plain 2: "" &lt;&lt; plain2 &lt;&lt; endl;
</code></pre>

<p>Output from those three <code>cout</code>'s is:</p>

<pre><code>Plain 1: Now is the time for all good men...
Cipher: 3073448F4A71BC26CF81441F1DEE69C5DE700DF86294181B5E72E19D260DDF1E725DB3EFC74415982FFF45F9F7E290AE
Plain 2: Now is the time for all good men...
</code></pre>
","1211","<qt><encryption><crypto++>","1","0","1","2014-05-15 16:54:22","23678545","0","","-1","","2017-05-23 10:33:22","2014-05-13 19:10:16",""
"42455881","How to cast a char* to a byte* in c++?","<p>I am very new in c++ and want to cast a <code>char*</code> from a <code>std::string</code> to a <code>byte*</code>.</p>

<p>Here is my code:</p>

<pre><code>inline string XOR(const string &amp;value, const string &amp;key) {
  string retval(value);
  CryptoPP::xorbuf(&amp;retval[0], &amp;key[0], retval.length());
  return retval;
}
</code></pre>

<p>In <code>g++</code>, the output is:</p>

<pre><code>AESXCBC128.cpp: In function ‘std::string CryptoPP::XOR(const string&amp;, const string&amp;)’:
AESXCBC128.cpp:79:48: error: invalid conversion from ‘char*’ to ‘byte* {aka unsigned char*}’ [-fpermissive]
     xorbuf(&amp;retval[0], &amp;key[0], retval.length());
                                                ^
AESXCBC128.cpp:45:6: error:   initializing argument 1 of ‘void CryptoPP::xorbuf(byte*, const byte*, size_t)’ [-fpermissive]
 void xorbuf(byte *buf, const byte *mask, size_t count)
      ^
AESXCBC128.cpp:79:48: error: invalid conversion from ‘const char*’ to ‘const byte* {aka const unsigned char*}’ [-fpermissive]
     xorbuf(&amp;retval[0], &amp;key[0], retval.length());
                                                ^
AESXCBC128.cpp:45:6: error:   initializing argument 2 of ‘void CryptoPP::xorbuf(byte*, const byte*, size_t)’ [-fpermissive]
 void xorbuf(byte *buf, const byte *mask, size_t count)
</code></pre>
","<blockquote>
<pre><code>inline string XOR(const string &amp;value, const string &amp;key) {
  string retval(value);
  CryptoPP::xorbuf(&amp;retval[0], &amp;key[0], retval.length());
  return retval;
}
</code></pre>
</blockquote>

<p>Crypto++ <a href=""https://github.com/weidai11/cryptopp/blob/master/config.h#L226"" rel=""nofollow noreferrer"">typedefs a <code>byte</code> in <code>confg.h</code></a>:</p>

<pre><code>typedef unsigned char byte;
</code></pre>

<p>You can use something like:</p>

<pre><code>CryptoPP::xorbuf(
    reinterpret_cast&lt;byte*&gt;(&amp;retval[0]),
    reinterpret_cast&lt;const byte*&gt;(&amp;key[0]),
    retval.length());
</code></pre>

<p>Or, you can do it with C-style casts:</p>

<pre><code>CryptoPP::xorbuf((byte*)&amp;retval[0], (const byte*)&amp;key[0], retval.length());
</code></pre>

<hr>

<p>Here are some similar questions for <code>SecByteBlock</code>, which is a byte array rather than a char array:</p>

<ul>
<li><a href=""https://stackoverflow.com/q/31929531/608639"">How to convert SecByteBlock to string?</a></li>
<li><a href=""https://stackoverflow.com/q/26145776/608639"">string to SecByteBlock conversion</a></li>
</ul>

<p>Here are some references on C++ casting:</p>

<ul>
<li><a href=""https://stackoverflow.com/q/332030/608639"">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
<li><a href=""https://stackoverflow.com/q/28002/608639"">Regular cast vs. static_cast vs. dynamic_cast</a></li>
</ul>
","1197","<c++><string><encryption><byte><crypto++>","-3","0","1","2017-02-25 20:18:25","42460577","4","","608639","","2017-02-25 20:18:25","2017-02-25 12:09:03",""
"37782215","How to initialize RSA::PrivateKey?","<p>I'm trying to use Crypto++'s RSA encryption. The problem is how to initialize <code>RSA::PrivateKey</code> from number string?</p>

<p>The code to generate key pairs(from <a href=""http://www.cryptopp.com/wiki/Rsa_cryptography"" rel=""nofollow"">here</a>)</p>

<pre><code>cout &lt;&lt; hex ;

AutoSeededRandomPool rng;
InvertibleRSAFunction params;
params.GenerateRandomWithKeySize(rng, 2048);

params.SetPublicExponent(65537);

const Integer&amp; n = params.GetModulus();
const Integer&amp; p = params.GetPrime1();
const Integer&amp; q = params.GetPrime2();
const Integer&amp; d = params.GetPrivateExponent();
const Integer&amp; e = params.GetPublicExponent();

///////////////////////////////////////
// Dump
cout &lt;&lt; ""RSA Parameters:"" &lt;&lt; endl;
cout &lt;&lt; "" n: "" &lt;&lt; n &lt;&lt; endl;
cout &lt;&lt; "" p: "" &lt;&lt; p &lt;&lt; endl;
cout &lt;&lt; "" q: "" &lt;&lt; q &lt;&lt; endl;
cout &lt;&lt; "" d: "" &lt;&lt; d &lt;&lt; endl;
cout &lt;&lt; "" e: "" &lt;&lt; e &lt;&lt; endl;
cout &lt;&lt; endl;
</code></pre>

<p>So I get <strong>n,d,e</strong> string, should be able to initialize the private key, then I found some sample code <a href=""https://www.cryptopp.com/wiki/Raw_RSA"" rel=""nofollow"">here</a>:</p>

<pre><code>Integer n(""0xbeaadb3d839f3b5f""), e(""0x11""), d(""0x21a5ae37b9959db9"");

RSA::PrivateKey privKey;
privKey.Initialize(n, e, d);

RSA::PublicKey pubKey;
pubKey.Initialize(n, e);
</code></pre>

<p>The code works, it doesn't throw any exception. So I try to change the n,e,d to the string generated previously.</p>

<pre><code>// n: b0f2bee69386528216049775704d402cb3ff443ca2ea25a74b11c1c9c321b7ea46327b4e413f532616812fece07d061cf96e373789b3b9b05d2d31174c700a066868d26c52b5d48e6dbaf664fac66ee31747133a6569e16d12f521b56a12aadd74e7cf2534353a5e338173b8f884a568a25173f3a33782f9047af59da9b21180534923e5210c3989851f0d69d68d92c272769fbf2a833e2f522f60f76bec12d3b194c2f3b945c913649e2be54295a2f58e7c040bf61421f01077fdf234ddfe73663deec8979256c721fd65c046a7d21530adec1af2922ed6a27004bf31a04cd57981ca22208572743b6b64d4d30b0efe446fc7608b4178ff8a0ba7db3e45ecf3h
// e: 10001h
// d: 246e365ca5e6f2de8c100110a62e05aed9c39d1b8af3f8b1806589c7a82c96ce59bf1962ef50cd5aaa47c61a2e37db9c8db4cf2205c31eb35e7a3ed017443e4c9d0685ace3da243b70f1c951067425e375bbcf40ba86bd7856b9ff691d5e323ca720aaa5c6fbe65eb0404c87f6ee220e034d0148bfb89af70873ab09df2c30c74104b0973aa4e93ca95db749da4f6b2d9594ab487db1f6f194ab0b77bd91d834daf269c63d3abecad54a1a71599524e679a425c55b16a9ff7f0c37b2d259eb44ea5782f314f61cc0ac874b2e6ae870d798e90e5bc96ab57c8fd904fa9d199c46c971de3a5d7cabfdca0663373843bd41ec246e158754dabc9ec2172f7a5982edh

RSA::PrivateKey privKey;
privKey.Initialize(n, e, d);
</code></pre>

<p>It crashes. I googled a while and found <a href=""https://www.cryptopp.com/wiki/RSA_Signature_Schemes"" rel=""nofollow"">some other tip</a>:</p>

<pre><code>InvertibleRSAFunction params;
params.Initialize(n, e, d);

RSA::PrivateKey(params);
</code></pre>

<p>But it still crashes. What's the correct way of initializing a 2048-bit rsa private key?</p>
","<blockquote>
<pre><code>    // n: b0f2bee69386528216049775704d402cb3ff443ca2ea25a74b11c1c9c321b7ea46327b4e413f532616812fece07d061cf96e373789b3b9b05d2d31174c700a066868d26c52b5d48e6dbaf664fac66ee31747133a6569e16d12f521b56a12aadd74e7cf2534353a5e338173b8f884a568a25173f3a33782f9047af59da9b21180534923e5210c3989851f0d69d68d92c272769fbf2a833e2f522f60f76bec12d3b194c2f3b945c913649e2be54295a2f58e7c040bf61421f01077fdf234ddfe73663deec8979256c721fd65c046a7d21530adec1af2922ed6a27004bf31a04cd57981ca22208572743b6b64d4d30b0efe446fc7608b4178ff8a0ba7db3e45ecf3h
    // e: 10001h
    // d: 246e365ca5e6f2de8c100110a62e05aed9c39d1b8af3f8b1806589c7a82c96ce59bf1962ef50cd5aaa47c61a2e37db9c8db4cf2205c31eb35e7a3ed017443e4c9d0685ace3da243b70f1c951067425e375bbcf40ba86bd7856b9ff691d5e323ca720aaa5c6fbe65eb0404c87f6ee220e034d0148bfb89af70873ab09df2c30c74104b0973aa4e93ca95db749da4f6b2d9594ab487db1f6f194ab0b77bd91d834daf269c63d3abecad54a1a71599524e679a425c55b16a9ff7f0c37b2d259eb44ea5782f314f61cc0ac874b2e6ae870d798e90e5bc96ab57c8fd904fa9d199c46c971de3a5d7cabfdca0663373843bd41ec246e158754dabc9ec2172f7a5982edh
    RSA::PrivateKey privKey;
    privKey.Initialize(n, e, d);
</code></pre>
  
  <p>It crashes. </p>
</blockquote>

<p>We need to see the actual code. I'm guessing two things. First (1), you are not using a try/catch, so the program terminates due to the uncaught exception. To fix this:</p>

<pre><code>try
{
    // Some operation
}
catch (const Exception&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>Second (2), you are using strings rather than Integers in the call to <code>Iniaitialize</code>. To fix this:</p>

<pre><code>string n = ""b0f2bee693865282...8a0ba7db3e45ecf3h"";
string e = ""10001h"";
string d = ""246e365ca5e6f2de...9ec2172f7a5982edh"";

Integer _n(n.c_str()), _e(e.c_str()), _d(d.c_str());
RSA::PrivateKey privKey;
privKey.Initialize(_n, _e, _d);
</code></pre>

<p>The second issue should have been caught by the compiler. You should consider using <code>-Wall</code> to get a basic set of compiler diagnostics.</p>

<hr>

<p>There's a potential third issue. That's the ""key fails to validate"" case. If you add a try/catch as described in (1), then you may see an ""Invalid key material"" or similar from <code>CryptoMaterial</code> class. In this case, your parameters do not validate according to the checks performed by <code>Validate</code>.</p>

<p><code>Validate</code> is called by <code>Initialize</code> using a low-level of thoroughness (the <code>level</code> parameter below). The <code>Validate</code> function can be found in the manual at <a href=""http://www.cryptopp.com/docs/ref/class_invertible_r_s_a_function.html#a35247205517f839220a16287917ce0ce"" rel=""nofollow"">InvertibleRSAFunction::Validate</a>. Following the link <a href=""http://www.cryptopp.com/docs/ref/rsa_8cpp_source.html#l00247"" rel=""nofollow"">Definition at line 247 of file rsa.cpp</a>:</p>

<pre><code>  247 bool InvertibleRSAFunction::Validate(RandomNumberGenerator &amp;rng, unsigned int level) const
  248 {
  249     bool pass = RSAFunction::Validate(rng, level);
  250     pass = pass &amp;&amp; m_p &gt; Integer::One() &amp;&amp; m_p.IsOdd() &amp;&amp; m_p &lt; m_n;
  251     pass = pass &amp;&amp; m_q &gt; Integer::One() &amp;&amp; m_q.IsOdd() &amp;&amp; m_q &lt; m_n;
  252     pass = pass &amp;&amp; m_d &gt; Integer::One() &amp;&amp; m_d.IsOdd() &amp;&amp; m_d &lt; m_n;
  253     pass = pass &amp;&amp; m_dp &gt; Integer::One() &amp;&amp; m_dp.IsOdd() &amp;&amp; m_dp &lt; m_p;
  254     pass = pass &amp;&amp; m_dq &gt; Integer::One() &amp;&amp; m_dq.IsOdd() &amp;&amp; m_dq &lt; m_q;
  255     pass = pass &amp;&amp; m_u.IsPositive() &amp;&amp; m_u &lt; m_p;
  256     if (level &gt;= 1)
  257     {
  258         pass = pass &amp;&amp; m_p * m_q == m_n;
  259         pass = pass &amp;&amp; m_e*m_d % LCM(m_p-1, m_q-1) == 1;
  260         pass = pass &amp;&amp; m_dp == m_d%(m_p-1) &amp;&amp; m_dq == m_d%(m_q-1);
  261         pass = pass &amp;&amp; m_u * m_q % m_p == 1;
  262     }
  263     if (level &gt;= 2)
  264         pass = pass &amp;&amp; VerifyPrime(rng, m_p, level-2) &amp;&amp; VerifyPrime(rng, m_q, level-2);
  265     return pass;
  266 }
</code></pre>

<p>The remaining open question might be, where did <code>m_p</code>, <code>m_q</code>, etc come from? The answer is <code>Initialize</code> factors <code>n</code> based on <code>e</code> and <code>d</code>, and populates the <a href=""http://en.wikipedia.org/wiki/RSA_(cryptosystem)#Using_the_Chinese_remainder_algorithm"" rel=""nofollow"">CRT values</a> like <code>p</code>, <code>q</code>, <code>dp</code>, <code>dq</code>, etc. It speeds up computation later.</p>

<hr>

<p>This may be related.... <code>e=10001h</code> tells me Crypto++ probably did not generate the key pair. If Crypto++ generated the key pair, then it would use <a href=""https://www.cryptopp.com/docs/ref/class_invertible_r_s_a_function.html#a1d400269a0d1305e93623299d8184e29"" rel=""nofollow"">e=17</a> by default. How did you generate the key pair?</p>
","1195","<c++><rsa><public-key-encryption><crypto++>","1","1","1","2016-06-14 01:36:58","37799178","7","","608639","","2016-06-13 21:13:05","2016-06-13 05:12:24",""
"6817177","C2440 'initialising': Cannot convert int to unsigned char* in Microsoft VS 2010 utility file","<p>When I compile my VS 2010 C++ project the following passage raises an error in file c:\program files\microsoft visual studio  10.0\vc\include\utility</p>

<pre><code>template&lt;class _Other1,
    class _Other2&gt;
    _Pair_base(_Other1&amp;&amp; _Val1, _Other2&amp;&amp; _Val2)
    : first(_STD forward&lt;_Other1&gt;(_Val1)),
        second(_STD forward&lt;_Other2&gt;(_Val2))
    {   // construct from moved values
    }
</code></pre>

<p>The error is then followed by another error C2439 'std::_Pair_base..::first element could not be converted'</p>

<p>(All errors translated from German, so they may sound slightly different in English)</p>

<p>I am trying to compile the AxCrypt project on VS 2010, the project files have automatically been converted from VS 2008 (but I don't know if it would work there, I only have VS 2010).</p>
","<p>This code can reproduce this error:</p>

<pre><code>pair&lt;int,char*&gt; aPair(10,20);
</code></pre>

<p>Since <code>second</code> type I specified is of <code>char*</code> but I am passing an <code>int</code>, which cannot be converted to <code>char*</code>.</p>

<p>Note that this is oversimplified sample for the error you might be encountering. Probably you are using a <code>map</code>.</p>
","1194","<c++><visual-studio-2010><crypto++>","1","0","2","2016-03-16 06:36:12","","3","","608639","","2016-03-16 06:36:12","2011-07-25 13:52:09",""
"6817177","C2440 'initialising': Cannot convert int to unsigned char* in Microsoft VS 2010 utility file","<p>When I compile my VS 2010 C++ project the following passage raises an error in file c:\program files\microsoft visual studio  10.0\vc\include\utility</p>

<pre><code>template&lt;class _Other1,
    class _Other2&gt;
    _Pair_base(_Other1&amp;&amp; _Val1, _Other2&amp;&amp; _Val2)
    : first(_STD forward&lt;_Other1&gt;(_Val1)),
        second(_STD forward&lt;_Other2&gt;(_Val2))
    {   // construct from moved values
    }
</code></pre>

<p>The error is then followed by another error C2439 'std::_Pair_base..::first element could not be converted'</p>

<p>(All errors translated from German, so they may sound slightly different in English)</p>

<p>I am trying to compile the AxCrypt project on VS 2010, the project files have automatically been converted from VS 2008 (but I don't know if it would work there, I only have VS 2010).</p>
","<p>The problem was in the Crypto++ lib used which needs two small modifications before compiling on VS 2010.</p>

<pre><code>a) pubkey.h line 243: 
return HashIdentifier(NULL, 0); 
-&gt; 
return HashIdentifier((const byte*)NULL, 0); 
b) zdeflate.cpp line 389 
#if defined(_STDEXT_BEGIN) &amp;&amp; !(defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1400) 
&amp;&amp; !defined(_STLPORT_VERSION) 
-&gt; 
#if defined(_STDEXT_BEGIN) &amp;&amp; !(defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1400 
|| _MSC_VER &gt;= 1600)) &amp;&amp; !defined(_STLPORT_VERSION) 
</code></pre>

<p>More details here: 
<a href=""http://groups.google.com/group/cryptopp-users/browse_thread/thread/714f3ec6287a50b1"" rel=""nofollow"">http://groups.google.com/group/cryptopp-users/browse_thread/thread/714f3ec6287a50b1</a></p>
","1194","<c++><visual-studio-2010><crypto++>","1","1","2","2016-03-16 06:36:12","","3","","608639","","2016-03-16 06:36:12","2011-07-25 13:52:09",""
"27546541","Linker errors when building DLL dependent on static lib Crypto++","<p>Here is a preface - I have a C++ + Qt application, it consists of several projects and we are using MSVC 2012 to build it. Now, I'm implementing build scripts to start deploying build server. So, I started creating Qt .pro files for each and every project we have.</p>

<p><strong>Now the problem</strong> - we use Crypto++ library(<a href=""http://www.cryptopp.com/"" rel=""nofollow"">http://www.cryptopp.com/</a>) which we build from source code and the output is static lib, and we have DLL which depends on cryptlib.lib. </p>

<p>I wrote .pro file for Cryptlib and I'm able to build it using qmake/jom</p>

<pre><code>QT           -= core gui
QMAKE_CFLAGS += /Zc:wchar_t

TEMPLATE = lib
TARGET   = cryptlib

Release:DESTDIR = ./Release
Debug:DESTDIR   = ./Debug

CONFIG  += staticlib precompile_header
DEFINES += _USING_V110_SDK71_ WINVER=0x0501 WIN32 _WINDOWS _MBCS
DEFINES -= UNICODE

PRECOMPILED_HEADER = pch.h
DEPENDPATH += .

include(CryptoPP.pri)@
</code></pre>

<p>I wrote .pro file for my DLL - it compiles fine, <em>but I'm getting linker errors on linkage phase</em>. The most interesting thing is that when I build cryptlib with MSVC2012 and <em>then</em> build DLL with qmake - then it link OK.</p>

<p>What could be wrong? I checked all proj settings in MSVC projects and applied in my pro files. I checked names mangling in both libs built with MSVC and QT - mangled names look the same. Now I got stuck</p>

<pre><code>@# ----------------------------------------------------
# This file is generated by the Qt Visual Studio Add-in.
# ------------------------------------------------------

QT           -= gui core
QMAKE_CFLAGS += /Zc:wchar_t

TEMPLATE = lib
TARGET   = PSGLicensing

Release:DESTDIR = ./Release
Debug:DESTDIR   = ./Debug

CONFIG  += dll
DEFINES += _AFXDLL _USING_V110_SDK71_ WIN32 _WINDOWS _WINDLL _USRDLL DLL_LIBRARY PSGLICENSING_DLL_BUILD _MBCS _VC80_UPGRADE=0x0710
DEFINES -= UNICODE

PRECOMPILED_HEADER = stdafx.h
DEPENDPATH += .

win32:CONFIG(release, debug|release): LIBS += -L$$_PRO_FILE_PWD_/../CryptoPP/Release/ -lcryptlib
else:win32:CONFIG(debug, debug|release): LIBS += -L$$_PRO_FILE_PWD_/../CryptoPP/Debug/ -lcryptlib

INCLUDEPATH += $$_PRO_FILE_PWD_/../CryptoPP/
DEPENDPATH += $$_PRO_FILE_PWD_/../CryptoPP/

win32:CONFIG(release, debug|release): PRE_TARGETDEPS += $$_PRO_FILE_PWD_/../CryptoPP/Release/cryptlib.lib
else:win32:CONFIG(debug, debug|release): PRE_TARGETDEPS += $$_PRO_FILE_PWD_/../CryptoPP/Debug/cryptlib.lib

include(PSGLicensing.pri)@
</code></pre>

<p>In MSVC2012 we have following settings for</p>

<p><strong>CryptLib</strong></p>

<pre><code>*Compiler:* /Yu""pch.h"" /GS /GL /analyze- /W3 /Gy- /Zc:wchar_t /Zi /Gm- /O2 /Ob2 /Fd""Release\vc110.pdb"" /fp:precise /Zp1 /D ""_USING_V110_SDK71_"" /D ""NDEBUG"" /D ""_WINDOWS"" /D ""USE_PRECOMPILED_HEADERS"" /D ""WIN32"" /D ""WINVER=0x0501"" /D ""_VC80_UPGRADE=0x0710"" /errorReport:prompt /GF- /WX- /Zc:forScope /arch:SSE /Gd /Oy /Oi /MD /Fa""Release\"" /EHsc /nologo /Fo""Release\"" /Fp""Release\cryptlib.pch"" 

*Linker:* /OUT:""SecretPath\CryptoPP\Release\cryptlib.lib"" /LTCG /NOLOGO 
</code></pre>

<p>and here are settings for <strong>DLL</strong></p>

<pre><code>*Compiler*: /Yu""stdafx.h"" /GS /analyze- /W3 /Zc:wchar_t /I""SecretPath\PSGLicensing\IncludeExp"" /Zi /Gm- /O2 /Fd""Release\vc110.pdb"" /fp:precise /D ""_USING_V110_SDK71_"" /D ""WIN32"" /D ""_WINDOWS"" /D ""NDEBUG"" /D ""_USRDLL"" /D ""PSGLICENSING_DLL_BUILD"" /D ""_VC80_UPGRADE=0x0710"" /D ""_WINDLL"" /D ""_MBCS"" /D ""_AFXDLL"" /errorReport:prompt /WX- /Zc:forScope /Gd /Oy- /MD /Fa""Release\"" /EHsc /nologo /Fo""Release\"" /Fp""Release\PSGLicensing.pch"" 

*Linker:* /OUT:""SecretPah\PSGLicensing\Release\PSGLicensing.dll"" /MANIFEST /PDB:""SecretPath\PSGLicensing\Release\PSGLicensing.pdb"" /DYNAMICBASE:NO ""..\CryptoPP\Release\cryptlib.lib"" ""SecretPath\CryptoPP\Release\cryptlib.lib"" /DEF:"".\PSGLicensing.def"" /IMPLIB:""SecretPath\PSGLicensing\Release\PSGLicensing.lib"" /DEBUG /DLL /MACHINE:X86 /OPT:REF /SAFESEH /INCREMENTAL:NO /PGD:""SecretPath\PSGLicensing\Release\PSGLicensing.pgd"" /SUBSYSTEM:WINDOWS"",5.01"" /MANIFESTUAC:""level='asInvoker' uiAccess='false'"" /ManifestFile:""Release\PSGLicensing.dll.intermediate.manifest"" /OPT:ICF /ERRORREPORT:PROMPT /NOLOGO /TLBID:1 
</code></pre>

<p>Here is jom output</p>

<pre><code>@   C:\Qt\Qt5.2.1\Tools\QtCreator\bin\jom.exe -f Makefile.Release
    link /NOLOGO /DYNAMICBASE /NXCOMPAT /INCREMENTAL:NO /DLL /MANIFEST /MANIFESTFILE:Release\PSGLicensing.dll.embed.manifest /OUT:Release\PSGLicensing.dll @C:\Users\ANDRIY~1.GLO\AppData\Local\Temp\PSGLicensing.dll.6212.16.jom
   Creating library Release\PSGLicensing.lib and object Release\PSGLicensing.exp
GenerateRandomBlock.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::CFB_CipherTemplate&lt;class CryptoPP::AbstractPolicyHolder&lt;class CryptoPP::CFB_CipherAbstractPolicy,class CryptoPP::CFB_ModePolicy&gt; &gt;::ProcessData(unsigned char *,unsigned char const *,unsigned int)"" (?ProcessData@?$CFB_CipherTemplate@V?$AbstractPolicyHolder@VCFB_CipherAbstractPolicy@CryptoPP@@VCFB_ModePolicy@2@@CryptoPP@@@CryptoPP@@UAEXPAEPBEI@Z)
GenerateRandomBlock.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::CFB_CipherTemplate&lt;class CryptoPP::AbstractPolicyHolder&lt;class CryptoPP::CFB_CipherAbstractPolicy,class CryptoPP::CFB_ModePolicy&gt; &gt;::Resynchronize(unsigned char const *,int)"" (?Resynchronize@?$CFB_CipherTemplate@V?$AbstractPolicyHolder@VCFB_CipherAbstractPolicy@CryptoPP@@VCFB_ModePolicy@2@@CryptoPP@@@CryptoPP@@UAEXPBEH@Z)
GenerateRandomBlock.obj : error LNK2001: unresolved external symbol ""protected: virtual void __thiscall CryptoPP::CFB_CipherTemplate&lt;class CryptoPP::AbstractPolicyHolder&lt;class CryptoPP::CFB_CipherAbstractPolicy,class CryptoPP::CFB_ModePolicy&gt; &gt;::UncheckedSetKey(unsigned char const *,unsigned int,class CryptoPP::NameValuePairs const &amp;)"" (?UncheckedSetKey@?$CFB_CipherTemplate@V?$AbstractPolicyHolder@VCFB_CipherAbstractPolicy@CryptoPP@@VCFB_ModePolicy@2@@CryptoPP@@@CryptoPP@@MAEXPBEIABVNameValuePairs@2@@Z)
GenerateRandomBlock.obj : error LNK2001: unresolved external symbol ""private: virtual void __thiscall CryptoPP::CFB_EncryptionTemplate&lt;class CryptoPP::AbstractPolicyHolder&lt;class CryptoPP::CFB_CipherAbstractPolicy,class CryptoPP::CFB_ModePolicy&gt; &gt;::CombineMessageAndShiftRegister(unsigned char *,unsigned char *,unsigned char const *,unsigned int)"" (?CombineMessageAndShiftRegister@?$CFB_EncryptionTemplate@V?$AbstractPolicyHolder@VCFB_CipherAbstractPolicy@CryptoPP@@VCFB_ModePolicy@2@@CryptoPP@@@CryptoPP@@EAEXPAE0PBEI@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Update(unsigned char const *,unsigned int)"" (?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z)
LicensingEx.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Update(unsigned char const *,unsigned int)"" (?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z)
cryptlib.lib(randpool.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Update(unsigned char const *,unsigned int)"" (?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z)
cryptlib.lib(md5.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Update(unsigned char const *,unsigned int)"" (?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Update(unsigned char const *,unsigned int)"" (?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual unsigned char * __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int &amp;)"" (?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z)
LicensingEx.obj : error LNK2001: unresolved external symbol ""public: virtual unsigned char * __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int &amp;)"" (?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z)
cryptlib.lib(randpool.obj) : error LNK2001: unresolved external symbol ""public: virtual unsigned char * __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int &amp;)"" (?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z)
cryptlib.lib(md5.obj) : error LNK2001: unresolved external symbol ""public: virtual unsigned char * __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int &amp;)"" (?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual unsigned char * __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int &amp;)"" (?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Restart(void)"" (?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ)
LicensingEx.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Restart(void)"" (?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ)
cryptlib.lib(randpool.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Restart(void)"" (?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ)
cryptlib.lib(md5.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Restart(void)"" (?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::Restart(void)"" (?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char *,unsigned int)"" (?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z)
LicensingEx.obj : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char *,unsigned int)"" (?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z)
cryptlib.lib(randpool.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char *,unsigned int)"" (?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z)
cryptlib.lib(md5.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char *,unsigned int)"" (?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char *,unsigned int)"" (?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z)
LicensingEx.obj : error LNK2001: unresolved external symbol ""protected: virtual unsigned int __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::HashMultipleBlocks(unsigned int const *,unsigned int)"" (?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z)
cryptlib.lib(md5.obj) : error LNK2001: unresolved external symbol ""protected: virtual unsigned int __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::HashMultipleBlocks(unsigned int const *,unsigned int)"" (?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""protected: virtual unsigned int __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::HashMultipleBlocks(unsigned int const *,unsigned int)"" (?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""protected: virtual unsigned int __thiscall CryptoPP::IteratedHashBase&lt;unsigned int,class CryptoPP::HashTransformation&gt;::HashMultipleBlocks(unsigned int const *,unsigned int)"" (?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::ScalarMultiply(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?ScalarMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@0@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::ScalarMultiply(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?ScalarMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@0@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::CascadeScalarMultiply(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?CascadeScalarMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@000@Z)
cryptlib.lib(rsa.obj) : error LNK2019: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::CascadeScalarMultiply(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?CascadeScalarMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@000@Z) referenced in function ""public: class CryptoPP::GetValueHelperClass&lt;class CryptoPP::InvertibleRSAFunction,class CryptoPP::RSAFunction&gt; &amp; __thiscall CryptoPP::GetValueHelperClass&lt;class CryptoPP::InvertibleRSAFunction,class CryptoPP::RSAFunction&gt;::operator()&lt;class CryptoPP::Integer&gt;(char const *,class CryptoPP::Integer const &amp; (__thiscall CryptoPP::InvertibleRSAFunction::*)(void)const )"" (??$?RVInteger@CryptoPP@@@?$GetValueHelperClass@VInvertibleRSAFunction@CryptoPP@@VRSAFunction@2@@CryptoPP@@QAEAAV01@PBDP8InvertibleRSAFunction@1@BEABVInteger@1@XZ@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual void __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::SimultaneousMultiply(class CryptoPP::Integer *,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const *,unsigned int)const "" (?SimultaneousMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBEXPAVInteger@2@ABV32@PBV32@I@Z)
cryptlib.lib(rsa.obj) : error LNK2019: unresolved external symbol ""public: virtual void __thiscall CryptoPP::AbstractGroup&lt;class CryptoPP::Integer&gt;::SimultaneousMultiply(class CryptoPP::Integer *,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const *,unsigned int)const "" (?SimultaneousMultiply@?$AbstractGroup@VInteger@CryptoPP@@@CryptoPP@@UBEXPAVInteger@2@ABV32@PBV32@I@Z) referenced in function ""public: void __thiscall CryptoPP::InvertibleRSAFunction::Initialize(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)"" (?Initialize@InvertibleRSAFunction@CryptoPP@@QAEXABVInteger@2@00@Z)
cryptlib.lib(integer.obj) : error LNK2019: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractRing&lt;class CryptoPP::Integer&gt;::Exponentiate(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?Exponentiate@?$AbstractRing@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@0@Z) referenced in function ""class CryptoPP::Integer __cdecl CryptoPP::a_exp_b_mod_c(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)"" (?a_exp_b_mod_c@CryptoPP@@YA?AVInteger@1@ABV21@00@Z)
cryptlib.lib(rsa.obj) : error LNK2001: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractRing&lt;class CryptoPP::Integer&gt;::Exponentiate(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?Exponentiate@?$AbstractRing@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@0@Z)
cryptlib.lib(integer.obj) : error LNK2019: unresolved external symbol ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::AbstractRing&lt;class CryptoPP::Integer&gt;::CascadeExponentiate(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?CascadeExponentiate@?$AbstractRing@VInteger@CryptoPP@@@CryptoPP@@UBE?AVInteger@2@ABV32@000@Z) referenced in function ""public: virtual class CryptoPP::Integer __thiscall CryptoPP::ModularArithmetic::CascadeExponentiate(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?CascadeExponentiate@ModularArithmetic@CryptoPP@@UBE?AVInteger@2@ABV32@000@Z)
cryptlib.lib(integer.obj) : error LNK2019: unresolved external symbol ""public: virtual void __thiscall CryptoPP::AbstractRing&lt;class CryptoPP::Integer&gt;::SimultaneousExponentiate(class CryptoPP::Integer *,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const *,unsigned int)const "" (?SimultaneousExponentiate@?$AbstractRing@VInteger@CryptoPP@@@CryptoPP@@UBEXPAVInteger@2@ABV32@PBV32@I@Z) referenced in function ""public: virtual void __thiscall CryptoPP::ModularArithmetic::SimultaneousExponentiate(class CryptoPP::Integer *,class CryptoPP::Integer const &amp;,class CryptoPP::Integer const *,unsigned int)const "" (?SimultaneousExponentiate@ModularArithmetic@CryptoPP@@UBEXPAVInteger@2@ABV32@PBV32@I@Z)
cryptlib.lib(integer.obj) : error LNK2001: unresolved external symbol ""public: virtual class CryptoPP::Integer const &amp; __thiscall CryptoPP::AbstractEuclideanDomain&lt;class CryptoPP::Integer&gt;::Gcd(class CryptoPP::Integer const &amp;,class CryptoPP::Integer const &amp;)const "" (?Gcd@?$AbstractEuclideanDomain@VInteger@CryptoPP@@@CryptoPP@@UBEABVInteger@2@ABV32@0@Z)
Release\PSGLicensing.dll : fatal error LNK1120: 16 unresolved externals
@
</code></pre>
","<p>Here is the version of .pro file for CryptLib with which built library is linkable.</p>

<pre><code>QT           -= core gui
QMAKE_CFLAGS += /Zc:wchar_t /GL

TEMPLATE = lib
TARGET   = cryptlib

Release:DESTDIR = ./Release
Debug:DESTDIR   = ./Debug

CONFIG  += staticlib
DEFINES += _USING_V110_SDK71_ WINVER=0x0501 WIN32 _WINDOWS _MBCS USE_PRECOMPILED_HEADERS
DEFINES -= UNICODE

DEPENDPATH += .

include(CryptoPP.pri)
</code></pre>

<p>So, all I did is added <strong>USE_PRECOMPILED_HEADERS</strong> to DEFINES and removed <strong>PRECOMPILED_HEADER_FILE = pch.h</strong>. I do not know how it actually helped, but it helped.</p>
","1187","<c++><qt><qmake><unresolved-external><crypto++>","1","1","1","2014-12-19 09:48:54","27563333","7","0","635608","","2014-12-19 09:48:54","2014-12-18 12:23:36",""
"24310353","How to check if openssl or cryptopp is installed and use the library that actually exists in the system (is installed)?","<p>I wrote function that encrypts/decrypts a buffer (2 versions of the same function - first, with cryptopp, second - with openssl). </p>

<p>I would like to make something like this:</p>

<pre><code>#if defined OPENSSL
   run_aes_openssl(...);
#elif defined CRYPTOPP
   run_aes_crytopp(...);
#else
    error(...);
#end
</code></pre>

<p>Is it possible?</p>
","<blockquote>
  <p>How to check if openssl or cryptopp is installed and use the library that actually exists in the system (is installed)?</p>
</blockquote>

<p>If your application was built on the system it is running, then the code you have shown is OK. Presumably, the build system will detect both OpenSSL and Crypto++. In the case <em>both</em> are available, it looks like your code will favor OpenSSL.</p>

<p>If you application is built elsewhere and needs to check at runtime, then you will need <a href=""http://linux.die.net/man/3/dlopen"" rel=""nofollow""><code>dlopen</code></a>, <code>dlsym</code>, <code>dlclose</code> and friends.</p>

<p>In the case of runtime checking, its probably best to build a dispatch table and call through it. For example, you might have a table with function pointers to <em>your</em> internal <code>run_aes_openssl</code>, <code>run_aes_crytopp</code>, etc.</p>

<p>Upon startup, you populate the table based on the results of <code>dlopen</code>. If you find OpenSSL, then you populate your table with the OpenSSL gear. If you find Crypto++, then you populate your table with the Crypto++ gear.</p>

<hr>

<p>C++ can be painful to use with <code>dlopen</code> and friends because of name mangling. Worse, the mangling differs between distributions and runtime library versions. For example, here's a function to generate a private RSA key:</p>

<pre><code>RSA::PrivateKey key;
key.GenerateRandomWithKeySize(prng, 1024);
</code></pre>

<p>And here's the corresponding function names on Mac OS X. Debian and Red Hat will likely be different.</p>

<pre><code>$ nm cryptopp-test.exe | grep -i GenerateRandom | grep -i RSA
00000001000c7d80 T __ZN8CryptoPP21InvertibleRSAFunction14GenerateRandomERNS_21RandomNumberGeneratorERKNS_14NameValuePairsE
00000001000c8eb0 T __ZThn120_N8CryptoPP21InvertibleRSAFunction14GenerateRandomERNS_21RandomNumberGeneratorERKNS_14NameValuePairsE
</code></pre>
","1185","<c><openssl><c-preprocessor><crypto++>","4","1","2","2015-12-01 12:45:58","24317349","0","","4370109","","2015-12-01 12:45:58","2014-06-19 15:25:23",""
"24310353","How to check if openssl or cryptopp is installed and use the library that actually exists in the system (is installed)?","<p>I wrote function that encrypts/decrypts a buffer (2 versions of the same function - first, with cryptopp, second - with openssl). </p>

<p>I would like to make something like this:</p>

<pre><code>#if defined OPENSSL
   run_aes_openssl(...);
#elif defined CRYPTOPP
   run_aes_crytopp(...);
#else
    error(...);
#end
</code></pre>

<p>Is it possible?</p>
","<p>It's not quite that simple. In order to find that a macro is defined, you have to include the header that defines that macro. And C doesn't have anything like ""include foo.h iff it exists""; it has to exist otherwise there is a compilation error.</p>

<p>Normally this would be sorted out by a script that you run before compilation. Your script checks locations like <code>/usr/include</code>, <code>/usr/local/include</code>, etc., to see if the OpenSSL headers are there; and then it outputs a Makefile which contains in the CFLAGS <code>-DHAVE_OPENSSL</code>. Then your code can check for that macro.</p>

<p>This is quite a bit of hullabaloo, to keep things simple you could require the user to manually edit a file , e.g. distribute your project with something called <code>user_config.h</code> that the user is supposed to edit before compiling, to specify where they put OpenSSL and so on.</p>

<p>There is a preset system called GNU Autoconf which contains a script that checks your system for everything under the sun.  This has its advantages and disadvantages; it makes things easier for plebs downloading your source code, but it is bloaty and can be hard work for yourself.</p>
","1185","<c><openssl><c-preprocessor><crypto++>","4","2","2","2015-12-01 12:45:58","24317349","0","","4370109","","2015-12-01 12:45:58","2014-06-19 15:25:23",""
"25707739","Selection of cryptlib or cryptopp?","<p>I was compiling the Crypto++ library and there are 4 projects in the Visual Studio solution:</p>

<ul>
<li>cryptest</li>
<li>cryptlib</li>
<li>cryptopp</li>
<li>dlltest </li>
</ul>

<p>What is the meaning of cryptlib and cryptopp? In a project that use Crypto++, which of these I should be use?</p>
","","1169","<visual-studio><crypto++>","2","","0","2014-09-07 16:10:23","","2","","608639","","2014-09-07 16:10:23","2014-09-07 06:37:03",""
"19851121","cryptopp base64 trailing 0x0a","<p>I'm using CryptoPP to encode a string ""abc"", the problem is the encoded base64 string always has a trailing '0x0a'?
here's my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

#include ""crypto/base64.h""
using namespace CryptoPP;

int main() {
string in(""abc"");

string encoded;

CryptoPP::StringSource ss(
    in,
    true, 
    new CryptoPP::Base64Encoder(
        new CryptoPP::StringSink(encoded)
    )
);

cout &lt;&lt; encoded.length() &lt;&lt; endl;// outputs 5, should be 4
cout &lt;&lt; encoded;
}
</code></pre>

<p>the string ""abc"" should be encoded to ""YWJj"", but the result is YWJj\n, (\n == 0x0a), and the length is 5 .</p>

<p>Changing the source string doesn't help, any string will be encrypted with a trailing \n
Why is that?
Thanks</p>
","<p>From the <a href=""http://www.cryptopp.com/docs/ref/class_base64_encoder.html"">Base64Encoder docs</a>, the signature of the constructor is</p>

<blockquote>
<pre><code>Base64Encoder (BufferedTransformation *attachment=NULL,
               bool insertLineBreaks=true,
               int maxLineLength=72)
</code></pre>
</blockquote>

<p>So you get line breaks by default in your encoded string.  To avoid this, just do:</p>

<pre><code>CryptoPP::StringSource ss(
    in,
    true, 
    new CryptoPP::Base64Encoder(
        new CryptoPP::StringSink(encoded),
        false
    )
);
</code></pre>
","1167","<base64><crypto++>","1","6","1","2013-11-14 01:42:59","19871168","0","","2219196","","2013-11-14 01:42:59","2013-11-08 03:32:38",""
"23420683","Crypto++ SHA1 Function","<p>I can't figure out what's wrong with my function - it causes a breakpoint on return.</p>

<pre><code>std::string generateHash(std::string source)
{
    CryptoPP::SHA1 hash;
    byte digest[CryptoPP::SHA1::DIGESTSIZE];
    hash.CalculateDigest(digest, (const byte*)source.c_str(), source.size());
    std::string output;
    CryptoPP::HexEncoder encoder;
    CryptoPP::StringSink test = CryptoPP::StringSink(output);
    encoder.Attach((CryptoPP::BufferedTransformation*)&amp;CryptoPP::StringSink(output));
    encoder.Put(digest, sizeof(digest));
    encoder.MessageEnd();
    return output; // here
}
</code></pre>
","<p><code>encoder.Attach((CryptoPP::BufferedTransformation*)&amp;CryptoPP::StringSink(output));</code>   </p>

<p>In this line, <code>CryptoPP::StringSink(output)</code> is a temporary object. After this call <code>CryptoPP::StringSink(output)</code> no longer exists. So If you try to follow its address (<code>encoder.Attach</code> and <code>encoder.Put</code>), you will get undefined behavior. (Like you should never return the address of a local variable)</p>

<p>My code for reference:</p>

<pre><code> std::string generateHash(std::string source)
  {
      CryptoPP::SHA1 hash;
      byte digest[CryptoPP::SHA1::DIGESTSIZE];
      hash.CalculateDigest(digest, (const byte*)source.c_str(), source.size());
      std::string output;
      CryptoPP::HexEncoder encoder;
      CryptoPP::StringSink test = CryptoPP::StringSink(output);
      encoder.Attach(new CryptoPP::StringSink(output));
      encoder.Put(digest, sizeof(digest));
      encoder.MessageEnd();
      return output;
  }
</code></pre>
","1151","<visual-c++><crypto++>","2","3","2","2014-05-03 01:32:47","23424068","0","","3545094","","2014-05-02 04:23:27","2014-05-02 04:20:13",""
"23420683","Crypto++ SHA1 Function","<p>I can't figure out what's wrong with my function - it causes a breakpoint on return.</p>

<pre><code>std::string generateHash(std::string source)
{
    CryptoPP::SHA1 hash;
    byte digest[CryptoPP::SHA1::DIGESTSIZE];
    hash.CalculateDigest(digest, (const byte*)source.c_str(), source.size());
    std::string output;
    CryptoPP::HexEncoder encoder;
    CryptoPP::StringSink test = CryptoPP::StringSink(output);
    encoder.Attach((CryptoPP::BufferedTransformation*)&amp;CryptoPP::StringSink(output));
    encoder.Put(digest, sizeof(digest));
    encoder.MessageEnd();
    return output; // here
}
</code></pre>
","<blockquote>
<pre><code>   CryptoPP::HexEncoder encoder;
   CryptoPP::StringSink test = CryptoPP::StringSink(output);
   encoder.Attach((CryptoPP::BufferedTransformation*)&amp;CryptoPP::StringSink(output));
</code></pre>
</blockquote>

<p>Onemouth's solution is correct, but here's why you are having trouble:</p>

<ul>
<li>The <code>StringSink(output)</code> is a temporary on the stack, and it will be cleaned up when the <code>StringSink</code> destructors run</li>
<li><code>HexEncoder</code> 'owns' the pointer to <code>StringSink(output)</code>, so the <code>HexEncoder</code> will call delete on <code>StringSink(output)</code></li>
</ul>

<p>So the <code>StringSink</code> is cleaned up twice.</p>

<p>For completeness, the <code>StringSink</code> does <em>not</em> delete the string <code>output</code> because it takes a reference, not a pointer.</p>

<p>This is documented behavior in the <a href=""http://sourceforge.net/apps/trac/cryptopp/browser/trunk/c5/Readme.txt"" rel=""nofollow"">README.txt</a>:</p>

<pre><code>88  *** Important Usage Notes ***
89  
90  1. If a constructor for A takes a pointer to an object B (except primitive
91  types such as int and char), then A owns B and will delete B at A's
92  destruction.  If a constructor for A takes a reference to an object B,
93  then the caller retains ownership of B and should not destroy it until
94  A no longer needs it. 
</code></pre>

<p>Though it would be <em>highly</em> unusual, you <em>might</em> be able to do what you are trying to do and fix it as follows (but I would <em>not</em> recommend doing it the way you are):</p>

<pre><code>encoder.Attach(new Redirector(&amp;CryptoPP::StringSink(output)));
</code></pre>

<p>The <code>Redirector</code> stops the ownership chain. When the <code>Redirector</code> is destroyed, it does <em>not</em> destroy its attached transformation (which is the <code>StringSink</code>). But again, its not the way to use the library. </p>

<p><code>Redirector</code>s are useful in other places in the library, but not really in this case.</p>
","1151","<visual-c++><crypto++>","2","2","2","2014-05-03 01:32:47","23424068","0","","3545094","","2014-05-02 04:23:27","2014-05-02 04:20:13",""
"32696855","Using Crypto++ in Clion IDE","<p>I have some problem with compile correct application in fresh-installed Clion IDE. Earlier I used Code::Blocks and all compiling successfully. Project use <code>pthread</code> and <code>Crypto++</code> library. I'm already have them installed on my Ubuntu 15.04. And compile Clion project with -pthread flag. But it can't find crypto++ library. How to fix this?</p>

<p>My CMake file:</p>

<pre><code>cmake_minimum_required(VERSION 3.3)
project(Chat)

set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -std=c++11 -pthread"")

set(SOURCE_FILES
    include/Chat.h
    include/Checker.h
    include/Client.h
    include/DataTransferingInterface.h
    include/EncryptorDES.h
    include/EncryptorRSA.h
    include/Logger.h
    include/OwnerClientInterface.h
    include/OwnerServerInterface.h
    include/Parser.h
    include/SecureChat.h
    include/Server.h
    src/Chat.cpp
    src/Checker.cpp
    src/Client.cpp
    src/DataTransferingInterface.cpp
    src/EncryptorDES.cpp
    src/EncryptorRSA.cpp
    src/Logger.cpp
    src/OwnerClientInterface.cpp
    src/OwnerServerInterface.cpp
    src/Parser.cpp
    src/SecureChat.cpp
    src/Server.cpp
    main.cpp)

add_executable(Chat ${SOURCE_FILES})
</code></pre>

<p>Compile errors:</p>

<pre><code>/usr/include/cryptopp/integer.h:26: undefined reference to `vtable for CryptoPP::Integer'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::AbstractRing&lt;CryptoPP::Integer&gt;::MultiplicativeGroupT::~MultiplicativeGroupT()':
/usr/include/cryptopp/algebra.h:70: undefined reference to `vtable for CryptoPP::AbstractRing&lt;CryptoPP::Integer&gt;::MultiplicativeGroupT'
/usr/include/cryptopp/algebra.h:70: undefined reference to `CryptoPP::AbstractGroup&lt;CryptoPP::Integer&gt;::~AbstractGroup()'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::FileStore::~FileStore()':
/usr/include/cryptopp/files.h:14: undefined reference to `vtable for CryptoPP::FileStore'
/usr/include/cryptopp/files.h:14: undefined reference to `vtable for CryptoPP::FileStore'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::FileSink::~FileSink()':
/usr/include/cryptopp/files.h:77: undefined reference to `vtable for CryptoPP::FileSink'
/usr/include/cryptopp/files.h:77: undefined reference to `vtable for CryptoPP::FileSink'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::HMAC_Base::~HMAC_Base()':
/usr/include/cryptopp/hmac.h:12: undefined reference to `vtable for CryptoPP::HMAC_Base'
/usr/include/cryptopp/hmac.h:12: undefined reference to `vtable for CryptoPP::HMAC_Base'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::AlgorithmParametersTemplate&lt;char const*&gt;::AssignValue(char const*, std::type_info const&amp;, void*) const':
/usr/include/cryptopp/algparam.h:313: undefined reference to `CryptoPP::g_pAssignIntToInteger'
/usr/include/cryptopp/algparam.h:313: undefined reference to `CryptoPP::g_pAssignIntToInteger'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_EncryptorBase&lt;CryptoPP::ECPPoint&gt;::Encrypt(CryptoPP::RandomNumberGenerator&amp;, unsigned char const*, unsigned long, unsigned char*, CryptoPP::NameValuePairs const&amp;) const':
/usr/include/cryptopp/integer.h:118: undefined reference to `CryptoPP::Integer::One()'
/usr/include/cryptopp/integer.h:118: undefined reference to `CryptoPP::Integer::Zero()'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_EncryptorBase&lt;CryptoPP::ECPPoint&gt;::Encrypt(CryptoPP::RandomNumberGenerator&amp;, unsigned char const*, unsigned long, unsigned char*, CryptoPP::NameValuePairs const&amp;) const':
/usr/include/cryptopp/pubkey.h:1228: undefined reference to `CryptoPP::Integer::One()'
/usr/include/cryptopp/pubkey.h:1228: undefined reference to `CryptoPP::Integer::Integer(CryptoPP::RandomNumberGenerator&amp;, CryptoPP::Integer const&amp;, CryptoPP::Integer const&amp;, CryptoPP::Integer::RandomNumberType, CryptoPP::Integer const&amp;, CryptoPP::Integer const&amp;)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::SourceTemplate&lt;CryptoPP::FileStore&gt;::Pump2(unsigned long long&amp;, bool)':
/usr/include/cryptopp/filters.h:763: undefined reference to `CryptoPP::DEFAULT_CHANNEL'
/usr/include/cryptopp/filters.h:763: undefined reference to `CryptoPP::FileStore::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::string const&amp;, bool)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::SourceTemplate&lt;CryptoPP::FileStore&gt;::PumpMessages2(unsigned int&amp;, bool)':
/usr/include/cryptopp/filters.h:765: undefined reference to `CryptoPP::DEFAULT_CHANNEL'
/usr/include/cryptopp/filters.h:765: undefined reference to `CryptoPP::BufferedTransformation::TransferMessagesTo2(CryptoPP::BufferedTransformation&amp;, unsigned int&amp;, std::string const&amp;, bool)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::SourceTemplate&lt;CryptoPP::FileStore&gt;::PumpAll2(bool)':
/usr/include/cryptopp/filters.h:767: undefined reference to `CryptoPP::DEFAULT_CHANNEL'
/usr/include/cryptopp/filters.h:767: undefined reference to `CryptoPP::BufferedTransformation::TransferAllTo2(CryptoPP::BufferedTransformation&amp;, std::string const&amp;, bool)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::SourceTemplate&lt;CryptoPP::FileStore&gt;::SourceExhausted() const':
/usr/include/cryptopp/filters.h:769: undefined reference to `CryptoPP::BufferedTransformation::AnyRetrievable() const'
/usr/include/cryptopp/filters.h:769: undefined reference to `CryptoPP::BufferedTransformation::AnyMessages() const'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_EncryptionAlgorithm_Xor&lt;CryptoPP::HMAC&lt;CryptoPP::SHA1&gt;, false&gt;::SymmetricEncrypt(CryptoPP::RandomNumberGenerator&amp;, unsigned char const*, unsigned char const*, unsigned long, unsigned char*, CryptoPP::NameValuePairs const&amp;) const':
/usr/include/cryptopp/gfpcrypt.h:439: undefined reference to `CryptoPP::xorbuf(unsigned char*, unsigned char const*, unsigned char const*, unsigned long)'
/usr/include/cryptopp/gfpcrypt.h:441: undefined reference to `CryptoPP::HMAC_Base::Update(unsigned char const*, unsigned long)'
/usr/include/cryptopp/gfpcrypt.h:442: undefined reference to `CryptoPP::HMAC_Base::Update(unsigned char const*, unsigned long)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_EncryptionAlgorithm_Xor&lt;CryptoPP::HMAC&lt;CryptoPP::SHA1&gt;, false&gt;::SymmetricDecrypt(unsigned char const*, unsigned char const*, unsigned long, unsigned char*, CryptoPP::NameValuePairs const&amp;) const':
/usr/include/cryptopp/gfpcrypt.h:470: undefined reference to `CryptoPP::HMAC_Base::Update(unsigned char const*, unsigned long)'
/usr/include/cryptopp/gfpcrypt.h:471: undefined reference to `CryptoPP::HMAC_Base::Update(unsigned char const*, unsigned long)'
/usr/include/cryptopp/gfpcrypt.h:481: undefined reference to `CryptoPP::xorbuf(unsigned char*, unsigned char const*, unsigned char const*, unsigned long)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_KeyAgreementAlgorithm_DH&lt;CryptoPP::ECPPoint, CryptoPP::EnumToType&lt;CryptoPP::CofactorMultiplicationOption, 0&gt; &gt;::AgreeWithEphemeralPrivateKey(CryptoPP::DL_GroupParameters&lt;CryptoPP::ECPPoint&gt; const&amp;, CryptoPP::DL_FixedBasePrecomputation&lt;CryptoPP::ECPPoint&gt; const&amp;, CryptoPP::Integer const&amp;) const':
/usr/include/cryptopp/pubkey.h:1445: undefined reference to `CryptoPP::Integer::Integer(CryptoPP::Integer const&amp;)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::DL_KeyAgreementAlgorithm_DH&lt;CryptoPP::ECPPoint, CryptoPP::EnumToType&lt;CryptoPP::CofactorMultiplicationOption, 0&gt; &gt;::AgreeWithStaticPrivateKey(CryptoPP::DL_GroupParameters&lt;CryptoPP::ECPPoint&gt; const&amp;, CryptoPP::ECPPoint const&amp;, bool, CryptoPP::Integer const&amp;) const':
/usr/include/cryptopp/pubkey.h:1473: undefined reference to `CryptoPP::Integer::Integer(CryptoPP::Integer const&amp;)'
/usr/include/cryptopp/pubkey.h:1473: undefined reference to `CryptoPP::Integer::Integer(CryptoPP::Integer const&amp;)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::HMAC&lt;CryptoPP::SHA1&gt;::HMAC(unsigned char const*, unsigned long)':
/usr/include/cryptopp/hmac.h:48: undefined reference to `CryptoPP::g_nullNameValuePairs'
/usr/include/cryptopp/hmac.h:48: undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::P1363_KDF2&lt;CryptoPP::SHA1&gt;::DeriveKey(unsigned char*, unsigned long, unsigned char const*, unsigned long, unsigned char const*, unsigned long)':
/usr/include/cryptopp/pubkey.h:506: undefined reference to `CryptoPP::P1363_MGF1KDF2_Common(CryptoPP::HashTransformation&amp;, unsigned char*, unsigned long, unsigned char const*, unsigned long, unsigned char const*, unsigned long, bool, unsigned int)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::IteratedHashWithStaticTransform&lt;unsigned int, CryptoPP::EnumToType&lt;CryptoPP::ByteOrder, 1&gt;, 64u, 20u, CryptoPP::SHA1, 0u, false&gt;::Init()':
/usr/include/cryptopp/iterhash.h:90: undefined reference to `CryptoPP::SHA1::InitState(unsigned int*)'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o:(.rodata._ZTIN8CryptoPP16IteratedHashBaseIjNS_18HashTransformationEEE[_ZTIN8CryptoPP16IteratedHashBaseIjNS_18HashTransformationEEE]+0x10): undefined reference to `typeinfo for CryptoPP::HashTransformation'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o:(.rodata._ZTIN8CryptoPP25SimpleKeyingInterfaceImplINS_9HMAC_BaseENS_4HMACINS_4SHA1EEEEE[_ZTIN8CryptoPP25SimpleKeyingInterfaceImplINS_9HMAC_BaseENS_4HMACINS_4SHA1EEEEE]+0x10): undefined reference to `typeinfo for CryptoPP::HMAC_Base'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::HashTransformation::HashTransformation(CryptoPP::HashTransformation const&amp;)':
/usr/include/cryptopp/cryptlib.h:531: undefined reference to `vtable for CryptoPP::HashTransformation'
CMakeFiles/Chat.dir/src/EncryptorRSA.cpp.o: In function `CryptoPP::IteratedHashWithStaticTransform&lt;unsigned int, CryptoPP::EnumToType&lt;CryptoPP::ByteOrder, 1&gt;, 64u, 20u, CryptoPP::SHA1, 0u, false&gt;::HashEndianCorrectedBlock(unsigned int const*)':
/usr/include/cryptopp/iterhash.h:89: undefined reference to `CryptoPP::SHA1::Transform(unsigned int*, unsigned int const*)'
collect2: error: ld returned 1 exit status
CMakeFiles/Chat.dir/build.make:406: recipe for target 'Chat' failed
make[2]: *** [Chat] Error 1
CMakeFiles/Makefile2:67: recipe for target 'CMakeFiles/Chat.dir/all' failed
make[1]: *** [CMakeFiles/Chat.dir/all] Error 2
Makefile:83: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>
","<p>I performed the following after <code>add_executable</code> in my <code>CMakeLists.txt</code> to resolve the issue:</p>

<pre><code>target_link_libraries(Chat /usr/lib/libcrypto++.a)
</code></pre>
","1137","<c++><cmake><codeblocks><crypto++><clion>","2","1","1","2015-09-24 02:50:15","32697507","5","1","608639","","2015-09-24 02:50:15","2015-09-21 13:43:13",""
"16823429","Crypto++ multibyte/unicode issue","<p>I'm using Crypto++ library in my project but I've the following message:</p>

<blockquote>
  <p>In memory integrity check failed. This may be caused by debug
  breakpoints or DLL relocation.</p>
</blockquote>

<p><p>
And Visual Leak Detector detect lots of memory leaks, but I'll dctor are corectly called.
<p>
I've build Crypto with msvc-2010 (MultiByte) and I'm using cryptopp from anothre library (UNICODE)
<p>
Is this dangerous?</p>
","<blockquote>
  <p>In memory integrity check failed. </p>
</blockquote>

<p>It sound like you are using one of the pre-built FIPS libraries available for the Crypto++ website. (That's where I've seen this most often).</p>

<p>If so, you need to develop your program with the same version that was used to build the DLL. That's probably Visual Studio 6, or Visual Studio 2002/2003 or so. You will have lots of memory problems if you try to use it with Visual Studio 2010 ro 2012.</p>

<blockquote>
  <p>And Visual Leak Detector detect lots of memory leaks, but I'll dctor are corectly called. </p>
</blockquote>

<p>Ignore these. Microsoft has an unfixed bug in that damn thing dating back to the Visual Studio 6 days. You can find the bug report if you search Microsoft Connect. Its talked about on the <a href=""http://www.cryptopp.com/wiki/Profiling"" rel=""nofollow"">Leak</a> page from the Crypto++ wiki.</p>

<blockquote>
  <p>I've build Crypto with msvc-2010 (MultiByte) and I'm using cryptopp from anothre library (UNICODE) </p>
</blockquote>

<p>The other library must be built using Visual Studio 2010 also. UNICODE is OK, but you will need to handle the MBCS/UNICODE conversions. See <a href=""http://www.cryptopp.com/wiki/Mbcs"" rel=""nofollow"">Character Set Considerations</a> on the Crypto++ wiki.</p>
","1130","<c++><crypt><crypto++><visual-leak-detector>","2","1","1","2013-10-02 07:14:01","19131724","0","1","","","","2013-05-29 20:41:46",""
"42317104","GCC and Crypto++ on makefile","<p>I'm trying to compile C++ project with gcc-make command but program giving this error. I already compiled Crypto++ and added include and lib folder but I dont know how to add this dir to gcc.</p>

<p>What should I do for fixing this ""-lcrytopp"" error?</p>

<p>I'm using makefile and this is line of 33-34.</p>

<pre><code>$(TARGET): build $(OBJECTS)
    $(CC) $(OBJECTS) -o $(TARGET) -lcryptopp
</code></pre>

<p><strong>Error</strong>:</p>

<pre><code>D:\Osman\CnC RA2\Mix\ccmix-crypto\ccmix-crypto&gt;make
g++ src/mix_db_gamedb.o src/mix_db_gmd.o src/mix_header.o src/mix_db_lmd.o
src/mixid.o src/ccmix.o src/mix_file.o -o build/ccmix -lcryptopp
c:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32
/bin/ld.exe: cannot find -lcryptopp
collect2.exe: error: ld returned 1 exit status
Makefile:34: recipe for target 'build/ccmix' failed
make: *** [build/ccmix] Error 1
</code></pre>

<hr>

<p>Crypto++ directory:</p>

<p><a href=""https://i.stack.imgur.com/VVFyj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VVFyj.png"" alt=""enter image description here""></a></p>

<p>Compile error:</p>

<p><a href=""https://i.stack.imgur.com/78Oo1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/78Oo1.png"" alt=""enter image description here""></a></p>
","<p>You haven't added the directory containing the library to your link line.  It should be something like <code>-Lxxx</code> where <code>xxx</code> is the path to the directory containing the <code>cryptopp</code> library:</p>

<pre><code>$(TARGET): build $(OBJECTS)
        $(CC) $(OBJECTS) -o $(TARGET) -Lxxx -lcryptopp
</code></pre>

<p>(replace <code>xxx</code> with the directory containing the <code>cryptopp</code> library)</p>
","1120","<c++><gcc><makefile><crypto++>","0","1","2","2017-02-18 21:51:02","","7","","608639","","2017-02-18 21:32:14","2017-02-18 15:31:10",""
"42317104","GCC and Crypto++ on makefile","<p>I'm trying to compile C++ project with gcc-make command but program giving this error. I already compiled Crypto++ and added include and lib folder but I dont know how to add this dir to gcc.</p>

<p>What should I do for fixing this ""-lcrytopp"" error?</p>

<p>I'm using makefile and this is line of 33-34.</p>

<pre><code>$(TARGET): build $(OBJECTS)
    $(CC) $(OBJECTS) -o $(TARGET) -lcryptopp
</code></pre>

<p><strong>Error</strong>:</p>

<pre><code>D:\Osman\CnC RA2\Mix\ccmix-crypto\ccmix-crypto&gt;make
g++ src/mix_db_gamedb.o src/mix_db_gmd.o src/mix_header.o src/mix_db_lmd.o
src/mixid.o src/ccmix.o src/mix_file.o -o build/ccmix -lcryptopp
c:/mingw/bin/../lib/gcc/mingw32/5.3.0/../../../../mingw32
/bin/ld.exe: cannot find -lcryptopp
collect2.exe: error: ld returned 1 exit status
Makefile:34: recipe for target 'build/ccmix' failed
make: *** [build/ccmix] Error 1
</code></pre>

<hr>

<p>Crypto++ directory:</p>

<p><a href=""https://i.stack.imgur.com/VVFyj.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/VVFyj.png"" alt=""enter image description here""></a></p>

<p>Compile error:</p>

<p><a href=""https://i.stack.imgur.com/78Oo1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/78Oo1.png"" alt=""enter image description here""></a></p>
","<blockquote>
  <p>What should I do for fixing this ""-lcrytopp"" error?</p>
</blockquote>

<p>When working from the Crypto++ build directory on Unix compatibles, the project does not use <code>include</code> and <code>lib</code> (as your picture shows). Everything is placed in the root directory (as your picture shows).</p>

<p>If you perform a <code>make install</code>, then the directories are setup, but it appears you did not install. I should also say that MinGW is not usually tested anymore because the project is abandoned, so I'm not sure where <code>make install</code> actually installs to on MinGW.</p>

<p>To fix the compile error, tweak your make recipe:</p>

<pre><code>$(TARGET): build $(OBJECTS)
    $(CXX) $(CXXFLAGS) -I. $(OBJECTS) ./libcryptopp.a -o $(TARGET)
</code></pre>

<p>The recipe above uses <code>CXX</code> (C++ compiler) rather than <code>CC</code> (C compiler); it uses <code>CXXFLAGS</code> (which should be something like <code>-DNDEBUG -g2 -O2</code>); it calls out the header path (<code>-I.</code>); and it links to the static library (<code>./libcryptopp.a</code>). Linking to the static library will avoid your next set of problems.</p>

<p>You can follow MadScientist's advice and use <code>-LXXX</code> and <code>-lcryptopp</code>. You might even add a runpath with <code>-Wl,-rpath,D:\Osman\CnC RA2\Mix\ccmix-crypto\ccmix-crypto</code>. But at the end of the day, using <code>-L</code> and <code>-l</code> causes a fair amount of trouble. Avoid the future problems by statically linking <code>libcryptopp.a</code>.</p>

<p>Also see <a href=""https://www.cryptopp.com/wiki/GNUmakefile#Compiling_and_Linking"" rel=""nofollow noreferrer"">GNUmakefile | Compiling and Linking</a> on the Crypto++ wiki.</p>

<hr>

<p>Your fist picture shows <code>ipch</code> and <code>Win32</code> directories. That usually means you built the Crypto++ library with Visual Studio. Now you are building a program with GCC. You <strong><em>should not</em></strong> mix and match compilers like that. Nothing good will come of it.</p>
","1120","<c++><gcc><makefile><crypto++>","0","0","2","2017-02-18 21:51:02","","7","","608639","","2017-02-18 21:32:14","2017-02-18 15:31:10",""
"7954300","How can I return a byte value in Crypto++?","<p>I'm using Crypto++ to encrypt string with AES.
Ok it works fine, but now I want to create a function that return a byte value that is the key.</p>

<pre><code>byte AESBest::gen_key()
{
    AutoSeededRandomPool prng;

    // warning: address of local variable ‘key’ returned [enabled by default]
    byte key[AES::MAX_KEYLENGTH];

    prng.GenerateBlock(key, sizeof(key));

    //Error: invalid conversion from ‘byte {aka unsigned char}’ to ‘const byte* {aka const unsigned char*}’ [-fpermissive] }
    return key;
}
</code></pre>

<p>Well. I cannot return the key because something is not clear. When I set <code>byte key[AES::MAX_KEYLENGTH]</code> eclipse show me the warning that seems to be returned.
But when in the end return key, there is a strange error about the invalid conversion.</p>

<p>Why happen this?</p>

<p>How can I solve this problem?</p>

<hr>

<p><strong>EDIT</strong>: Well. Now I have these 2 function. But the first works good, returning the 64 chars of the aes key. (gen_all)</p>

<p>The second - I dunno why - return just 4! Why? (gen_part)</p>

<pre><code>string AESBest::gen_all()
{
    AutoSeededRandomPool prng;
    byte key[AES::MAX_KEYLENGTH];
    prng.GenerateBlock(key, sizeof(key));

    string encoded;
    encoded.clear();
    StringSource(key, sizeof(key), true,
        new HexEncoder(
            new StringSink(encoded)
        )
    );
    return encoded;
}
</code></pre>

<p>And:</p>

<pre><code>string AESBest::gen_part()
{
    AutoSeededRandomPool prng;
    std::vector&lt;byte&gt; key(AES::MAX_KEYLENGTH);
    prng.GenerateBlock(key.data(), key.size());

    string encoded;
    encoded.clear();
    StringSource(key.data(), sizeof(key.size()), true,
        new HexEncoder(
            new StringSink(encoded)
        )
    );

    return encoded;
}
</code></pre>

<p>Where is the bug in the second one?</p>

<p>EDIT: nevermind! The bug was in <code>sizeof</code>, so key.size() NO sizeof(key.size())</p>
","<p>You cannot return raw arrays in C++ (nor can you pass them as function arguments by value). Instead, use a <code>std::vector&lt;byte&gt;</code>:</p>

<pre><code>std::vector&lt;byte&gt; key(AES::MAX_KEYLENGTH);
prng.GenerateBlock(key.data(), key.size());
return key;
</code></pre>

<p>You'll have to modify the function return type accordingly. Use <code>key.data()</code> or <code>&amp;key[0]</code> to get a pointer to the underlying data array.</p>
","1113","<c++><return><aes><crypto++>","1","3","2","2015-02-16 20:52:32","7954343","6","","608639","user840718","2015-02-16 20:52:32","2011-10-31 13:20:11",""
"7954300","How can I return a byte value in Crypto++?","<p>I'm using Crypto++ to encrypt string with AES.
Ok it works fine, but now I want to create a function that return a byte value that is the key.</p>

<pre><code>byte AESBest::gen_key()
{
    AutoSeededRandomPool prng;

    // warning: address of local variable ‘key’ returned [enabled by default]
    byte key[AES::MAX_KEYLENGTH];

    prng.GenerateBlock(key, sizeof(key));

    //Error: invalid conversion from ‘byte {aka unsigned char}’ to ‘const byte* {aka const unsigned char*}’ [-fpermissive] }
    return key;
}
</code></pre>

<p>Well. I cannot return the key because something is not clear. When I set <code>byte key[AES::MAX_KEYLENGTH]</code> eclipse show me the warning that seems to be returned.
But when in the end return key, there is a strange error about the invalid conversion.</p>

<p>Why happen this?</p>

<p>How can I solve this problem?</p>

<hr>

<p><strong>EDIT</strong>: Well. Now I have these 2 function. But the first works good, returning the 64 chars of the aes key. (gen_all)</p>

<p>The second - I dunno why - return just 4! Why? (gen_part)</p>

<pre><code>string AESBest::gen_all()
{
    AutoSeededRandomPool prng;
    byte key[AES::MAX_KEYLENGTH];
    prng.GenerateBlock(key, sizeof(key));

    string encoded;
    encoded.clear();
    StringSource(key, sizeof(key), true,
        new HexEncoder(
            new StringSink(encoded)
        )
    );
    return encoded;
}
</code></pre>

<p>And:</p>

<pre><code>string AESBest::gen_part()
{
    AutoSeededRandomPool prng;
    std::vector&lt;byte&gt; key(AES::MAX_KEYLENGTH);
    prng.GenerateBlock(key.data(), key.size());

    string encoded;
    encoded.clear();
    StringSource(key.data(), sizeof(key.size()), true,
        new HexEncoder(
            new StringSink(encoded)
        )
    );

    return encoded;
}
</code></pre>

<p>Where is the bug in the second one?</p>

<p>EDIT: nevermind! The bug was in <code>sizeof</code>, so key.size() NO sizeof(key.size())</p>
","<ul>
<li><p>Warning reason: You are returning a pointer to a local array. It's
wrong because the local variable will deleted after exiting the
function.</p></li>
<li><p>Error reason: Compiler expected you return a <code>byte</code> value, but you
are returning a pointer.</p></li>
</ul>

<p>Try this:</p>

<pre><code>void AESBest::gen_key(byte *key, int size)
{
  AutoSeededRandomPool prng;
  prng.GenerateBlock(key, size);
}
</code></pre>

<p>and call it like below:</p>

<pre><code>byte key[AES::MAX_KEYLENGTH];
gen_key(key, AES::MAX_KEYLENGTH);
</code></pre>
","1113","<c++><return><aes><crypto++>","1","2","2","2015-02-16 20:52:32","7954343","6","","608639","user840718","2015-02-16 20:52:32","2011-10-31 13:20:11",""
"23505297","How to use crypto++ Blowfish correctly","<p>I have been trying all day today to finde out how to read from a binary file and decrypt it.</p>

<p>In my file, the first 4 bytes is describing the file format, the 32 bytes after it is the header, which is encrypted with Blowfish.</p>

<p>so i wrote this code to be able to do this:</p>

<pre><code>string file = ""C:\\test.bin"";    

byte *header = new byte[32];

FILE *data = fopen(file.c_str(), ""r"");

if(data == NULL)
{
    return 1; //Error opening file!
}

char type[6];

type[5] = 0;

if(fread(type, sizeof(type) - 1, 1, data) &lt; 1)
{
    return 2;
}

if(strcmp(type, ""ABCD"") != 0)
{
    return 3;
}

if(fread(header, sizeof(header), 1, data) &lt; 1)
{
    return 2; //Error reading file!
}

vector&lt;byte&gt; key;

key.push_back(0xAA);
key.push_back(0xBB);
key.push_back(0xCC);
key.push_back(0xDD);
key.push_back(0xAA);
key.push_back(0xBB);
key.push_back(0xCC);
key.push_back(0xDD);

ECB_Mode&lt;Blowfish&gt;::Decryption decryption(key.data(), key.size());

byte out[32];

decryption.ProcessData(out, header, 32);

FILE *outer =  fopen(""C:\\out.bin"", ""w"");

fwrite (out, sizeof(byte), sizeof(out), outer);
</code></pre>

<p>but this is not decrypting the data correctly.</p>

<p>What did i do wrong?</p>
","<p>There's many things a bit smelly here</p>

<ul>
<li><code>fopen</code> should use <code>""rb""</code> and <code>""wb""</code> for binary mode</li>
<li>you should use <code>memcmp</code> instead of <code>strcmp</code></li>
<li>you don't validate that <code>fread</code> actually read 4 bytes</li>
<li>you should prefer <code>unsigned char</code> for binary data (fewer pitfalls to do with sign extension and undefined behaviour on overflow)</li>
<li>if you're using C++, why use cstdlib, cstdio and cstring in the first place?</li>
<li><p>this is a <strong>bug</strong></p>

<pre><code>if(fread(header, sizeof(header), 1, data) &lt; 1)
</code></pre>

<p><code>sizeof (header)</code> is <code>sizeof(byte*)</code> here, not <code>32</code> as you seem to expect</p></li>
</ul>

<p>Here's a quick review of the code in c++ style: <strong>Update</strong> added a length field for my real-life roundtrip test (see below). </p>

<p><code>decryptor.cpp</code>:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;crypto++/blowfish.h&gt;
#include &lt;crypto++/modes.h&gt;

static std::vector&lt;byte&gt; const key { 's','e','c','r','e','t' };
static byte const SIGNATURE[] = ""ABCD""; //{ 'A','B','C','D' };

int main()
{
    if (std::ifstream data {""test.bin"", std::ios::binary})
    {
        char type[] = { 0, 0, 0, 0 };

        if (!data.read(type, 4))
        {
            return 2;
        }

        auto mismatch = std::mismatch(std::begin(SIGNATURE), std::end(SIGNATURE), std::begin(type));

        if (mismatch.first != std::end(SIGNATURE))
        {
            return 3;
        }

        uint32_t length = 0;
        if (!data.read(reinterpret_cast&lt;char*&gt;(&amp;length), sizeof(length))) // TODO use portable byte-order
        {
            return 4;
        }

        std::vector&lt;byte&gt; const ciphertext { std::istreambuf_iterator&lt;char&gt;(data), {} };
        // to read 32 bytes: 
        // std::copy_n(std::istreambuf_iterator&lt;char&gt;(data), 32, std::back_inserter(ciphertext));

        assert(data.good() || data.eof());
        assert(ciphertext.size() &gt;= length);
        assert(ciphertext.size() % CryptoPP::Blowfish::BLOCKSIZE == 0);

        CryptoPP::ECB_Mode&lt;CryptoPP::Blowfish&gt;::Decryption decryption(key.data(), key.size());

        std::vector&lt;char&gt; plaintext(ciphertext.size());

        decryption.ProcessData(reinterpret_cast&lt;byte*&gt;(plaintext.data()), ciphertext.data(), plaintext.size());
        plaintext.resize(length); // trim padding

        std::ofstream out(""out.bin"", std::ios::binary);
        out.write(plaintext.data(), plaintext.size());
    } else
    {
        return 1; //Error opening file
    }
}
</code></pre>

<p>I don't have a file yet to test it with. </p>

<p><strong>Update</strong> So, I've made <strong><a href=""http://coliru.stacked-crooked.com/a/621b67959a1d4880"" rel=""nofollow"">an <code>encryptor.cpp</code></a></strong> now too.</p>

<pre><code>echo ""Hello world"" | ./encryptor
</code></pre>

<p>results in a 40 byte file (sig + length + ciphertext = 4 + 4 + 32 = 40), in base64:</p>

<pre><code>base64 test.bin
QUJDRAwAAABCaDMrpG0WEYePd7fI0wsHAQoNkUl1CjIBCg2RSXUKMg==
</code></pre>

<p>Now, decrypting that tests out fine. Note that I found that I needed to ensure padding was done to BLOCKSIZE, and as such I added a <code>length</code> field to store the actual size of the plaintext to avoid trailing garbage after decryption.</p>

<p>You can see the roundtrip by doing</p>

<pre><code>echo 'Bye world!!' | ./encryptor &amp;&amp; ./decryptor &amp;&amp; cat out.bin
</code></pre>

<p>Which does indeed print the greeting back after decryption.</p>

<p>Note <strong>specifically</strong> the <code>TODO</code>'s. You should probably <a href=""http://www.cryptopp.com/wiki/Blowfish"" rel=""nofollow"">use <code>StreamTransformationFilter</code> which adds padding as required.</a></p>
","1112","<c++><binary><blowfish><crypto++>","0","3","1","2014-05-06 23:44:31","23505477","4","1","","","","2014-05-06 22:03:18",""
"25313584","How to create user password hash","<p>We are in the process of converting code to use Crypto++ library.  To create a hashed password for our users is this all that is necessary?  Just want to make sure we aren't missing some important piece.
Thanks you</p>

<pre><code>void test_create_hash(void)
{
   using namespace CryptoPP;
   std::string password = ""this is a users password"";
   unsigned int iterations = 1000000;

   AutoSeededRandomPool rng;

   SecByteBlock pwsalt(AES::DEFAULT_KEYLENGTH);
   rng.GenerateBlock(pwsalt,pwsalt.size());

   SecByteBlock derivedkey(AES::DEFAULT_KEYLENGTH);

   PKCS5_PBKDF2_HMAC&lt;SHA256&gt; pbkdf;

   pbkdf.DeriveKey(
      derivedkey, derivedkey.size(),
      0x00,
      (byte *) password.data(), password.size(),
      pwsalt, pwsalt.size(),
      iterations
   );
   std::string salthex;
   StringSource ss1(pwsalt,pwsalt.size(),true,
          new HexEncoder(
             new StringSink(salthex)
          )
        );
   std::string derivedhex;
   StringSource ss2(derivedkey,derivedkey.size(),true,
          new HexEncoder(
             new StringSink(derivedhex)
          )
        );

   cout &lt;&lt; ""salt stored to database:"" &lt;&lt; salthex &lt;&lt; std::endl;
   cout &lt;&lt; ""password stored to database:"" &lt;&lt; derivedhex &lt;&lt; std::endl;
}
</code></pre>
","<p>A few comments...</p>

<pre><code>SecByteBlock pwsalt(AES::DEFAULT_KEYLENGTH);
SecByteBlock derivedkey(AES::DEFAULT_KEYLENGTH);
</code></pre>

<p>What's up with AES? Perhaps:</p>

<pre><code>SecByteBlock pwsalt(SHA256::DIGEST_SIZE);
SecByteBlock derivedkey(SHA256::DIGEST_SIZE);
</code></pre>

<p>A CMAC works fine if you want to keep using AES.</p>

<hr>

<pre><code>std::string salthex;
StringSource ss(pwsalt,pwsalt.size(),true,
    new HexEncoder(
        new StringSink(salthex)
    )
);
</code></pre>

<p>You should not use anonymous declarations. It causes trouble for some GCC versions. That is, name your <code>StringSource</code>.</p>

<pre><code>std::string salthex;
StringSource ss(pwsalt,pwsalt.size(),true,
    new HexEncoder(
        new StringSink(salthex)
    )
);
</code></pre>
","1096","<c++><passwords><crypto++><pbkdf2>","2","0","1","2015-06-18 17:30:58","25378344","0","1","608639","","2015-06-18 17:30:58","2014-08-14 17:02:34",""
"33254054","QT and Crypto++ with /MTd","<p>I have two QT 5.5 projects with MSVC2013 32bit compiler. The first is Qt console application and is using crypto++ and this two in the pro file:</p>

<pre><code>QMAKE_CXXFLAGS_RELEASE += /MT
QMAKE_CXXFLAGS_DEBUG += /MTd
</code></pre>

<p>The second is Qt widgets application where is dialog based GUI builded. Individually, each starts successfully, but also individually the GUI project with the same additions in the pro file like these above is givving the same old error:</p>

<blockquote>
  <p>qtmain.lib(qtmain_win.obj):-1: error: LNK2038: mismatch detected for
  'RuntimeLibrary': value 'MD_DynamicRelease' doesn't match value
  'MT_StaticRelease' in main.obj</p>
</blockquote>

<p>Is there way to unite those two projects somehow? Also please explain the meaning and the difference between:</p>

<pre><code>multi-threaded DLL(/MD)
multi-threaded (/MT)
</code></pre>

<p>What is the link between dynamic libraries and /MD, and between static and /MT?</p>
","<blockquote>
<pre><code>qtmain.lib(qtmain_win.obj):-1: error: LNK2038: mismatch detected for 'RuntimeLibrary':
value 'MD_DynamicRelease' doesn't match value 'MT_StaticRelease' in main.obj
</code></pre>
</blockquote>

<p>This is due to mixing and matching C/C++ runtime libraries.</p>

<p>Crypto++ has four projects: <strong><em><code>Cryptlib</code></em></strong>, <strong><em><code>Cryptest</code></em></strong>, <strong><em><code>Cryptdll</code></em></strong> and <strong><em><code>Dlltest</code></em></strong>. To further complicate matters, <strong><em><code>Cryptlib</code></em></strong>, <strong><em><code>Cryptest</code></em></strong> have DLL-Import configurations re-used by <strong><em><code>Cryptdll</code></em></strong> and <strong><em><code>Dlltest</code></em></strong>. Once you understand what's going on it makes a lot of logical sense.</p>

<p>You are linking against non-DLL-Import <strong><em><code>Cryptlib</code></em></strong>, and it uses static linking. You need to switch to linking against a dynamically linked runtime library. For that, see <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment</a>. Its old, but it still applies.</p>

<p>You should also <strong><em>avoid</em></strong> anything with <code>DLL_Output</code> in its path. Though it uses proper runtime library linking, you are attempting to link against a DLL. The DLL exists for one purpose - as a security boundary for a FIPS 140-2 validated module. Its usually <strong><em>not</em></strong> what you are looking for, and usually the <strong><em>wrong</em></strong> library for the job.</p>

<p>Because you should also <strong><em>avoid</em></strong> anything with <code>DLL_Output</code>, open Configuration Manager and delete anything DLL related (for exampe, <strong><em><code>DLL-Import Release</code></em></strong>). You should also completely delete the <strong><em><code>Cryptdll</code></em></strong> and <strong><em><code>Dlltest</code></em></strong> projects to simplify your life.</p>
","1087","<c++><qt><user-interface><crypto++>","4","1","1","2015-10-22 10:11:28","33265616","4","0","608639","","2015-10-21 17:17:49","2015-10-21 08:08:23",""
"8008419","Bouncy Castle, Crypto++, Elliptic Curve Crypto (ECC), failing to decode","<p>We've got a C++ solution using the ECC part of the Crypto++ library but are having to move across to a .NET solution. Due to the minimal documentation for Microsoft's ECC code I;m currently experimenting with the slightly less minimally documented Bouncy Castle library (at least there is source code available). I've got encryption and decryption using BC working fine; decrypting data already encrypted with Crypto++ is proving somewhat more problematic. </p>

<p>My latest issue is that when I try to decrypt a string I'm getting an ""IMac codes failed to equal"" exception. Does BC add some sort of MAC to the cipher text? Any one know what could be causing this?</p>

<p>Thanks,
Patrick</p>
","<blockquote>
  <p>My latest issue is that when I try to decrypt a string I'm getting an ""IMac codes failed to equal"" exception.</p>
</blockquote>

<p>This message does not appear to be part of the current BC distro:</p>

<pre><code>$ cd bouncy-castle-153
$ grep -IR ""IMac codes failed to equal"" *
$
</code></pre>

<p>It does appear to be part of someone's GitHub; see <a href=""https://github.com/Redth/PassKitSharp/blob/master/PassKitSharp/Crypto/crypto/engines/IesEngine.cs"" rel=""nofollow"">PassKit IesEngine.cs</a>.</p>

<p>It may have been part of a past BC distro.</p>

<hr>

<blockquote>
  <p>Does BC add some sort of MAC to the cipher text?</p>
</blockquote>

<p>The name <code>IesEngine.cs</code> tells me its an <a href=""https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"" rel=""nofollow"">Integrated Encryption Scheme</a>. They are not well known and often not used, but they are <em>very</em> good schemes. They combine a lot of primitives into one, and that makes it easy to use correctly and hard to use incorrectly. More technically, the are <a href=""https://en.wikipedia.org/wiki/Ciphertext_indistinguishability"" rel=""nofollow"">IND-CCA2</a> which is a strong notion of security.</p>

<p>There are two types of schemes I am aware. The first is an IES over integers, and the second is an IES over elliptic curves. The one over integers is also known as <a href=""http://www.cryptopp.com/wiki/Discrete_Logarithm_Integrated_Encryption_Scheme"" rel=""nofollow"">Discrete Logarithm Integrated Encryption Scheme</a>, and the one over elliptic curves is usually called <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Elliptic Curve Integrated Encryption Scheme</a>. Libraries like Crypto++ and Bouncy Castle provides both of them.</p>

<p>To get back to your question, one of the things an integrated encryption scheme provides is a MAC over the ciphertext.</p>

<hr>

<blockquote>
  <p>Any one know what could be causing this?</p>
</blockquote>

<p>Unfortunately, there are a number of things that could be causing this. Most IES are incompatible due to each committee tweaking a scheme. To make matters worse, I have never seen a set of test vectors published. You have to work hard at getting things to interoperate.</p>

<p>In the case of Crypto++ and Bouncy Castle, each suffered a mild bug because there were no test vectors, so each did things a little differently. That meant the ECIES schemes did not interoperate well (or more correctly, at all). You can read about the details at <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Bouncy Castle Patch</a> on the Crypto++ wiki.</p>

<p>Moving forward, Crypto++ 5.7 <em>will</em> interop with Bouncy Castle 1.54 out of the box. In the future, the classes needed for BC will be documented at the <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Crypto++ wiki</a> and the <a href=""http://www.cryptopp.com/docs/ref/struct_e_c_i_e_s.html"" rel=""nofollow"">Crypto++ manual</a>.</p>
","1084","<c#><.net><bouncycastle><crypto++>","2","3","2","2016-06-24 15:16:59","","5","","","","","2011-11-04 11:16:16",""
"8008419","Bouncy Castle, Crypto++, Elliptic Curve Crypto (ECC), failing to decode","<p>We've got a C++ solution using the ECC part of the Crypto++ library but are having to move across to a .NET solution. Due to the minimal documentation for Microsoft's ECC code I;m currently experimenting with the slightly less minimally documented Bouncy Castle library (at least there is source code available). I've got encryption and decryption using BC working fine; decrypting data already encrypted with Crypto++ is proving somewhat more problematic. </p>

<p>My latest issue is that when I try to decrypt a string I'm getting an ""IMac codes failed to equal"" exception. Does BC add some sort of MAC to the cipher text? Any one know what could be causing this?</p>

<p>Thanks,
Patrick</p>
","<p>Please note, that the Crypto++ 5.6.3 bouncy castle patch mentioned above will only work with bouncy castle versions prior to 1.53. </p>

<p>For newer versions you can either tweak the Crypto++ patch to allow for 8 byte Mac or use the OldECIES class on the java side for interoperability.</p>
","1084","<c#><.net><bouncycastle><crypto++>","2","0","2","2016-06-24 15:16:59","","5","","","","","2011-11-04 11:16:16",""
"24803099","AtmelATAES132 Mac generation","<p>I'm trying to authenticate against an <a href=""http://www.atmel.com/devices/ATAES132.aspx"" rel=""nofollow"">Atmel ATAES132</a> Crypto Chip from a C++ application. To compute the MAC I want to use the Crypto++ library. The chip uses AES CCM to computes a MAC that is compared against a MAC I must compute in software.</p>

<p>MAC generation is described in the datasheet as crypting a 128bit datablock (B0) with CBC mode, XORing it with 128bit Authentication Only data and XORing the result with another 128bit datablock (A0) encrypted with AES CTR mode.</p>

<p>What I'm doing is this:</p>

<pre><code>string macB0string;

macB0string.append(""\x79"", 1);
macB0string.append(nonceString);
macB0string.append(""\x01\x00\x00"", 3);

// Authentication Only Data
byte aa[] = {
    0x00, 0x0E, 0x00, 0xEE, 0x03, 0x01, 0x00, 0x01, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
};

    string input, output;

input.append(macB0string);

byte zeroIV[16];
memset(zeroIV, 0, sizeof(zeroIV));

CBC_Mode&lt; AES &gt;::Encryption cbc;
cbc.SetKeyWithIV(key, sizeof(key), zeroIV);


StringSource(input, true,
    new StreamTransformationFilter(cbc,
        new StringSink(output),
        StreamTransformationFilter::NO_PADDING
        )
);

// Encrypt aa with same key and previous computed cipher as IV
// This is our cleartext MAC
CBC_Mode&lt; AES &gt;::Encryption cbc2;
cbc2.SetKeyWithIV(key, sizeof(key), (byte*)output.c_str());

string output2;
StringSource(string((const char*)aa, sizeof(aa)), true,
    new StreamTransformationFilter(cbc2,
        new StringSink(output2),
        StreamTransformationFilter::NO_PADDING
        )
);

string macA0;

macA0.append(""\0x01"", 1);
macA0.append(nonceString);
macA0.append(""\0x01\0x00\x00"", 3);


// Encrypt cleartext MAC
CTR_Mode&lt; AES &gt;::Encryption ctr;
ctr.SetKeyWithIV(key, sizeof(key), (byte*)macA0.c_str());

string MAC;

StringSource(output2, true, 
    new StreamTransformationFilter(ctr,
        new StringSink(MAC)
    )
);
</code></pre>

<p>This is exactly what is explained in the datasheet on page 112. But an authentiation attempt with the gerated MAC fails.
I used a zero filled IV in the first CBC encryption because I understood that CCM is like CBC-MAC with zero IV plus CTR encryption.</p>

<p>If someone with experience with the ATAES132 could point me in the right direction what is going wrong I would be very gratefull.</p>

<p><strong>EDIT</strong></p>

<p>This is how the CCM process is described in the datasheet.</p>

<blockquote>
  <p>The following example shows how the integrity MAC is calculated for an authentication operation requiring up to 14 bytes of authenticate-only data. This operation involves three passes through the AES crypto engine; all three using the same key. If there are more than 14 bytes of authenticate-only data, then another pass through the AES crypto engine is required.</p>
  
  <p>There are two passes through the AES crypto engine in CBC mode to create the cleartext MAC. The inputs to the crypto engine for those blocks are labeled B0 and B1, and the outputs are B’0 and B’1, respectively.</p>
  
  <ul>
  <li>B0 is composed of the following 128 bits:
  <ul>
  <li>1 byte flag, a fixed value of b0111 1001.</li>
  <li>12 byte Nonce, as generated by the Nonce command.</li>
  <li>1 byte MacCount, 1 for first MAC generation.</li>
  <li>2 byte length field, always 0x00 00 for authentication only.</li>
  </ul></li>
  <li>B1 is the XOR of B’0 with the following 128 bits:
  <ul>
  <li>2 byte length field, size of authenticate-only data.</li>
  <li>14 byte data to be authenticated only.</li>
  </ul></li>
  <li>B’1 is the cleartext MAC, which must be encrypted before being sent to the system.</li>
  </ul>
  
  <p>There is one additional pass through the AES crypto engine in CTR mode to create the key block that is used to encrypt the MAC. 
  The input to the crypto engine for this block is labeled A0 and the output is A’0. A’0 is the MAC sent to the system as the output parameter of the Auth command.</p>
  
  <ul>
  <li>A0 is composed of the following 128 bits:
  <ul>
  <li>1 byte flag – fixed value of b0000 0001.</li>
  <li>12 byte Nonce – as generated by ATAES132 during Nonce command.</li>
  <li>1 byte MacCount – one for first MAC generation.</li>
  <li>2 byte counter field – always 0x00 00 for A0.</li>
  </ul></li>
  <li>A’0 is XOR’d with the cleartext MAC (B’1) and sent to the system.</li>
  </ul>
</blockquote>

<p>And this is the code I tried</p>

<pre><code>byte key[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F
}; // Testkey Set in Chip as KeyID 1

byte nonce[] = {
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
};

byte crc[2];

string nonceCommand;

nonceCommand.append(""\x01"", 1); // Opcode
nonceCommand.append(""\x00"", 1); // Mode: 00 = Set Nonce
nonceCommand.append(""\x00\x00\x00\x00"", 4); // 4 Bytes Zero
nonceCommand.append( string((const char*)nonce, sizeof(nonce)) );

char count = nonceCommand.length() + 3; // length + 1byte count and 2bytes
                                        //  crc

nonceCommand.insert(0, &amp;count, 1);
CalcCRC(nonceCommand.length(), (byte*)nonceCommand.c_str(), crc);
nonceCommand.append( string((const char*)crc, sizeof(crc)) );


// SNIP
// Send SetNonceCommand and read response
// SNIP

string B0;
B0.append(""\x79"", 1); // FixedValue
B0.append( string((const char*)nonce, sizeof(nonce)) );
B0.append(""\x01"", 1); // MAC Count, 1 for first generation
B0.append(""\x00\x00"", 2); // 2 byte length field

string AA;
AA.append(""\x00\xEE"", 2); // Manufacturing ID
AA.append(""\x03"", 1); // Opcode
AA.append(""\x02"", 1); // Outbound authentication (we receive a MAC)
AA.append(""\x00\x01"", 2); // Key ID
AA.append(""\x00\x07"", 2); // Usage
AA.append(""\x01"", 1); // Mac Flag (1 for first generation)
AA.append(""\x00\x00\x00\x00"", 4); // 4 Bytes Zero
AA.append(""\x00"", 1); // 1 Byte padding

count = AA.length();
AA.insert(0, &amp;count, 1);
AA.insert(0, ""\x00"", 1);

// CCM 
const int TAG_SIZE = 16;
CCM&lt; AES, TAG_SIZE &gt;::Encryption ccm;
ccm.SetKeyWithIV(key, sizeof(key), nonce, sizeof(nonce));
ccm.SpecifyDataLengths(AA.length(), B0.length(), 0);

string cipher;
AuthenticatedEncryptionFilter ef(ccm,
    new StringSink(cipher)
);

ef.ChannelPut(AAD_CHANNEL, (byte*)AA.c_str(), AA.length());
ef.ChannelMessageEnd(AAD_CHANNEL);

ef.ChannelPut(DEFAULT_CHANNEL, (byte*)B0.c_str(), B0.length());
ef.ChannelMessageEnd(DEFAULT_CHANNEL);

string enc = cipher.substr(0, cipher.length() - TAG_SIZE);
string tag = cipher.substr(cipher.length() - TAG_SIZE);

// Get Outbound MAC from IC
string authCommand;
authCommand.append(""\x03"", 1); // Opcode
authCommand.append(""\x02"", 1); // Mode Outbound only
authCommand.append(""\x00\x01"", 2); // KeyID
authCommand.append(""\x00\x07"", 2); // Usage

count = authCommand.length() + 3;
authCommand.insert(0, &amp;count, 1);
CalcCRC(authCommand.length(), (byte*)authCommand.c_str(), crc);
authCommand.append( string((const char*)crc, sizeof(crc)) );

// SNIP
// Send Outbound Authentication Command to IC and receive response
// SNIP
</code></pre>

<p>This results in </p>

<pre><code>enc:    96 01 a1 0d ef 1e 5f f6 5f 9d 91 7e 80 25 71 a4 
tag:    71 2b a3 6a 7c 35 49 63 46 4c 58 0e a9 4a 2c 5e 
</code></pre>

<p>But the IC send an authentication MAC of </p>

<pre><code>ea c1 fd 60 9f 93 89 87 63 8f 9a df ee 17 85 bb
</code></pre>

<p>I don't quite get what the right input parameters for CCM mode are given the description from the datasheet</p>
","<p>I don't know that particular Atmel chip, but I do know that Crypto++ <a href=""http://www.cryptopp.com/wiki/CCM_Mode"" rel=""nofollow"">contains CCM mode encryption</a>. Are you <em>sure</em> you need to implement it yourself?</p>
","1072","<c++><encryption><aes><crypto++><atmel>","3","1","2","2017-06-03 21:28:57","24959787","2","1","1732148","","2014-07-18 09:11:21","2014-07-17 12:06:19",""
"24803099","AtmelATAES132 Mac generation","<p>I'm trying to authenticate against an <a href=""http://www.atmel.com/devices/ATAES132.aspx"" rel=""nofollow"">Atmel ATAES132</a> Crypto Chip from a C++ application. To compute the MAC I want to use the Crypto++ library. The chip uses AES CCM to computes a MAC that is compared against a MAC I must compute in software.</p>

<p>MAC generation is described in the datasheet as crypting a 128bit datablock (B0) with CBC mode, XORing it with 128bit Authentication Only data and XORing the result with another 128bit datablock (A0) encrypted with AES CTR mode.</p>

<p>What I'm doing is this:</p>

<pre><code>string macB0string;

macB0string.append(""\x79"", 1);
macB0string.append(nonceString);
macB0string.append(""\x01\x00\x00"", 3);

// Authentication Only Data
byte aa[] = {
    0x00, 0x0E, 0x00, 0xEE, 0x03, 0x01, 0x00, 0x01, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
};

    string input, output;

input.append(macB0string);

byte zeroIV[16];
memset(zeroIV, 0, sizeof(zeroIV));

CBC_Mode&lt; AES &gt;::Encryption cbc;
cbc.SetKeyWithIV(key, sizeof(key), zeroIV);


StringSource(input, true,
    new StreamTransformationFilter(cbc,
        new StringSink(output),
        StreamTransformationFilter::NO_PADDING
        )
);

// Encrypt aa with same key and previous computed cipher as IV
// This is our cleartext MAC
CBC_Mode&lt; AES &gt;::Encryption cbc2;
cbc2.SetKeyWithIV(key, sizeof(key), (byte*)output.c_str());

string output2;
StringSource(string((const char*)aa, sizeof(aa)), true,
    new StreamTransformationFilter(cbc2,
        new StringSink(output2),
        StreamTransformationFilter::NO_PADDING
        )
);

string macA0;

macA0.append(""\0x01"", 1);
macA0.append(nonceString);
macA0.append(""\0x01\0x00\x00"", 3);


// Encrypt cleartext MAC
CTR_Mode&lt; AES &gt;::Encryption ctr;
ctr.SetKeyWithIV(key, sizeof(key), (byte*)macA0.c_str());

string MAC;

StringSource(output2, true, 
    new StreamTransformationFilter(ctr,
        new StringSink(MAC)
    )
);
</code></pre>

<p>This is exactly what is explained in the datasheet on page 112. But an authentiation attempt with the gerated MAC fails.
I used a zero filled IV in the first CBC encryption because I understood that CCM is like CBC-MAC with zero IV plus CTR encryption.</p>

<p>If someone with experience with the ATAES132 could point me in the right direction what is going wrong I would be very gratefull.</p>

<p><strong>EDIT</strong></p>

<p>This is how the CCM process is described in the datasheet.</p>

<blockquote>
  <p>The following example shows how the integrity MAC is calculated for an authentication operation requiring up to 14 bytes of authenticate-only data. This operation involves three passes through the AES crypto engine; all three using the same key. If there are more than 14 bytes of authenticate-only data, then another pass through the AES crypto engine is required.</p>
  
  <p>There are two passes through the AES crypto engine in CBC mode to create the cleartext MAC. The inputs to the crypto engine for those blocks are labeled B0 and B1, and the outputs are B’0 and B’1, respectively.</p>
  
  <ul>
  <li>B0 is composed of the following 128 bits:
  <ul>
  <li>1 byte flag, a fixed value of b0111 1001.</li>
  <li>12 byte Nonce, as generated by the Nonce command.</li>
  <li>1 byte MacCount, 1 for first MAC generation.</li>
  <li>2 byte length field, always 0x00 00 for authentication only.</li>
  </ul></li>
  <li>B1 is the XOR of B’0 with the following 128 bits:
  <ul>
  <li>2 byte length field, size of authenticate-only data.</li>
  <li>14 byte data to be authenticated only.</li>
  </ul></li>
  <li>B’1 is the cleartext MAC, which must be encrypted before being sent to the system.</li>
  </ul>
  
  <p>There is one additional pass through the AES crypto engine in CTR mode to create the key block that is used to encrypt the MAC. 
  The input to the crypto engine for this block is labeled A0 and the output is A’0. A’0 is the MAC sent to the system as the output parameter of the Auth command.</p>
  
  <ul>
  <li>A0 is composed of the following 128 bits:
  <ul>
  <li>1 byte flag – fixed value of b0000 0001.</li>
  <li>12 byte Nonce – as generated by ATAES132 during Nonce command.</li>
  <li>1 byte MacCount – one for first MAC generation.</li>
  <li>2 byte counter field – always 0x00 00 for A0.</li>
  </ul></li>
  <li>A’0 is XOR’d with the cleartext MAC (B’1) and sent to the system.</li>
  </ul>
</blockquote>

<p>And this is the code I tried</p>

<pre><code>byte key[] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
    0x0C, 0x0D, 0x0E, 0x0F
}; // Testkey Set in Chip as KeyID 1

byte nonce[] = {
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11
};

byte crc[2];

string nonceCommand;

nonceCommand.append(""\x01"", 1); // Opcode
nonceCommand.append(""\x00"", 1); // Mode: 00 = Set Nonce
nonceCommand.append(""\x00\x00\x00\x00"", 4); // 4 Bytes Zero
nonceCommand.append( string((const char*)nonce, sizeof(nonce)) );

char count = nonceCommand.length() + 3; // length + 1byte count and 2bytes
                                        //  crc

nonceCommand.insert(0, &amp;count, 1);
CalcCRC(nonceCommand.length(), (byte*)nonceCommand.c_str(), crc);
nonceCommand.append( string((const char*)crc, sizeof(crc)) );


// SNIP
// Send SetNonceCommand and read response
// SNIP

string B0;
B0.append(""\x79"", 1); // FixedValue
B0.append( string((const char*)nonce, sizeof(nonce)) );
B0.append(""\x01"", 1); // MAC Count, 1 for first generation
B0.append(""\x00\x00"", 2); // 2 byte length field

string AA;
AA.append(""\x00\xEE"", 2); // Manufacturing ID
AA.append(""\x03"", 1); // Opcode
AA.append(""\x02"", 1); // Outbound authentication (we receive a MAC)
AA.append(""\x00\x01"", 2); // Key ID
AA.append(""\x00\x07"", 2); // Usage
AA.append(""\x01"", 1); // Mac Flag (1 for first generation)
AA.append(""\x00\x00\x00\x00"", 4); // 4 Bytes Zero
AA.append(""\x00"", 1); // 1 Byte padding

count = AA.length();
AA.insert(0, &amp;count, 1);
AA.insert(0, ""\x00"", 1);

// CCM 
const int TAG_SIZE = 16;
CCM&lt; AES, TAG_SIZE &gt;::Encryption ccm;
ccm.SetKeyWithIV(key, sizeof(key), nonce, sizeof(nonce));
ccm.SpecifyDataLengths(AA.length(), B0.length(), 0);

string cipher;
AuthenticatedEncryptionFilter ef(ccm,
    new StringSink(cipher)
);

ef.ChannelPut(AAD_CHANNEL, (byte*)AA.c_str(), AA.length());
ef.ChannelMessageEnd(AAD_CHANNEL);

ef.ChannelPut(DEFAULT_CHANNEL, (byte*)B0.c_str(), B0.length());
ef.ChannelMessageEnd(DEFAULT_CHANNEL);

string enc = cipher.substr(0, cipher.length() - TAG_SIZE);
string tag = cipher.substr(cipher.length() - TAG_SIZE);

// Get Outbound MAC from IC
string authCommand;
authCommand.append(""\x03"", 1); // Opcode
authCommand.append(""\x02"", 1); // Mode Outbound only
authCommand.append(""\x00\x01"", 2); // KeyID
authCommand.append(""\x00\x07"", 2); // Usage

count = authCommand.length() + 3;
authCommand.insert(0, &amp;count, 1);
CalcCRC(authCommand.length(), (byte*)authCommand.c_str(), crc);
authCommand.append( string((const char*)crc, sizeof(crc)) );

// SNIP
// Send Outbound Authentication Command to IC and receive response
// SNIP
</code></pre>

<p>This results in </p>

<pre><code>enc:    96 01 a1 0d ef 1e 5f f6 5f 9d 91 7e 80 25 71 a4 
tag:    71 2b a3 6a 7c 35 49 63 46 4c 58 0e a9 4a 2c 5e 
</code></pre>

<p>But the IC send an authentication MAC of </p>

<pre><code>ea c1 fd 60 9f 93 89 87 63 8f 9a df ee 17 85 bb
</code></pre>

<p>I don't quite get what the right input parameters for CCM mode are given the description from the datasheet</p>
","<p>I found out how to use Crypto++ AES CCM to compute the MAC for the ATAES132.
What is described in the datasheet is AES CCM but already computed for the CCM algorithm. You can't just put it into the CCM function.</p>

<p>If you want to use Crypto++ CCM Mode to compute a MAC do as follows:</p>

<pre><code>// Compute a 12 Byte Nonce as described in the datasheet
// Get the ManufacturingID from the IC

string iv = string((const char*)nonce, sizeof(nonce));
iv.append( MACCount ); // MAC Count is part of the IV giving it a size of 13

string authOnly, empty, cipher;

authOnly.append(""\x00\xEE"", 2); // Manufacturing ID
authOnly.append(""\x03"", 1); // Opcode
authOnly.append(""\x02"", 1); // Outbound authentication (we receive a MAC)
authOnly.append(""\x00\x01"", 2); // Key ID
authOnly.append(""\x00\x07"", 2); // Usage
authOnly.append(""\x01"", 1); // Mac Flag !!!NOT MACCOUNT!!!
authOnly.append(""\x00\x00\x00\x00"", 4); // 4 Bytes Zero
authOnly.append(""\x00"", 1); // 1 Byte padding

CCM&lt; AES, 16 &gt;::Enryption ccm;
ccm.SetKeyWithIV(key, sizeof(key), (byte*)iv.c_str(), iv.length());

ccm.SpecifyDataLengths(authOnly.length(), empty.length(), 0); // empty is an empty string
AuthenticatedEncryptionFilter ef(ccm,
    new StringSink(cipher)
);

ef.ChannelPut(AAD_CHANNEL, (byte*)authOnly.c_str(), authOnly.length());
ef.ChannelMessageEnd(AAD_CHANNEL);

ef.ChannelPut(DEFAULT_CHANNEL, (byte*)empty.c_str(), empty.length());
ef.ChannelMessageEnd(DEFAULT_CHANNEL);

string tag = cipher.substr( cipher.length() - TAG_SIZE);
</code></pre>

<p>Now you should have the same 16 Byte MAC as the IC has computed.</p>
","1072","<c++><encryption><aes><crypto++><atmel>","3","3","2","2017-06-03 21:28:57","24959787","2","1","1732148","","2014-07-18 09:11:21","2014-07-17 12:06:19",""
"4772837","How can one parse a ZIP file using Crypto++?","<p><a href=""http://www.cryptopp.com/"" rel=""nofollow"">Crypto++</a> includes</p>

<blockquote>
  <p>DEFLATE (RFC 1951) compression/decompression with gzip (RFC 1952) and zlib (RFC 1950) format support</p>
</blockquote>

<p>, but I'm not sure how I could translate that into reading a ZIP file. (I'm not averse to implementing my own ZIP traversing logic; but of course if the library already has that built in I don't want to duplicate things).</p>

<p>If the library doesn't provide this functionality out of the box, how does one access the zlib and gzip bits (in order to implement the compression/decompression steps)?</p>
","<p>I am not sure about the latest versions of Crypto++ but it was something like this before</p>

<pre><code>// write to file
Gzip zip(new FileSink (output_filename, true ), Gzip::DEFAULT_DEFLATE_LEVEL);
zip.Put(buf, dwBufSize);
zip.MessageEnd();
</code></pre>
","1063","<c++><gzip><zlib><crypto++>","4","3","1","2011-01-23 08:40:49","","0","","","","","2011-01-23 07:50:49",""
"17838542","Encryption and Decryption in Different Program","<p>I'm trying to implement RSA Algorithm using Crypto++ under Ubuntu 12.04
I managed to implement both encryption and decryption in one program.
Is there any way so that I can separate the encryption and decryption? What I want is when I call the encryption part, it will create a ciphertext as an output, and then when I call the decryption part, it will take the ciphertext from encryption as an input, and If I call the decryption part first, then it will create an error message.</p>

<p>This is the code for encryption and decryption:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;iomanip&gt;
using std::hex;

#include &lt;string&gt;
using std::string;

#include ""rsa.h""
using CryptoPP::RSA;

#include ""integer.h""
using CryptoPP::Integer;

#include ""osrng.h""
using CryptoPP::AutoSeededRandomPool;

int main(int argc, char** argv)
{

    // Pseudo Random Number Generator
    AutoSeededRandomPool rng;

    ///////////////////////////////////////
    // Generate Parameters
    CryptoPP::InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(rng, 3072);

    ///////////////////////////////////////
    // Generated Parameters
    const Integer&amp; n = params.GetModulus();
    const Integer&amp; p = params.GetPrime1();
    const Integer&amp; q = params.GetPrime2();
    const Integer&amp; d = params.GetPrivateExponent();
    const Integer&amp; e = params.GetPublicExponent();

    cout &lt;&lt; endl;

    ///////////////////////////////////////
    // Create Keys
    RSA::PrivateKey privateKey(params);
    RSA::PublicKey publicKey(params);
    /////////////////////////////////////////////////////////

    string message, recovered;
    Integer m, c, r;

    cout &lt;&lt; endl;
    cout &lt;&lt; ""RSA Algorithm"" &lt;&lt; endl;
    cout &lt;&lt; ""message: "" ;
    std::cin &gt;&gt; message;

    // Treat the message as a big endian array
    m = Integer((const byte *)message.data(), message.size());
    cout &lt;&lt; ""plaintext: "" &lt;&lt; hex &lt;&lt; m &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; ""ENCRYPTION"" &lt;&lt; endl;
    // Encrypt
    c = publicKey.ApplyFunction(m);
    cout &lt;&lt; ""cipherthext: "" &lt;&lt; hex &lt;&lt; c &lt;&lt; endl &lt;&lt; endl;

    cout &lt;&lt; ""DECRYPTION"" &lt;&lt; endl;
    // Decrypt
    r = privateKey.CalculateInverse(rng, c);
    cout &lt;&lt; ""plaintext: "" &lt;&lt; hex &lt;&lt; r &lt;&lt; endl;

    // Round trip the message
    size_t req = r.MinEncodedSize();
    recovered.resize(req);
    r.Encode((byte *)recovered.data(), recovered.size());

    cout &lt;&lt; ""recovered: "" &lt;&lt; recovered &lt;&lt; endl; 

    return 0;
}
</code></pre>

<p>I appreciate any help. Thank you.</p>
","<p>You can either </p>

<ol>
<li>Write two programs, each with their own main.</li>
<li>Use the <code>argv</code>you send into main to tell it what you want it to do.
<br/></li>
</ol>

<p>For option 2, there is another question <a href=""https://stackoverflow.com/questions/3024197/what-does-int-argc-char-argv-mean"">here</a>. In essence, after checking the arg count, <code>argc</code>, and remembering argv[0] is your program, you could say </p>

<pre><code>if(strcmp(argv[1], ""ENCRYPTION"")==0)
{
//... do ENCRYPTION
}...
</code></pre>
","1063","<c++><rsa><crypto++>","-1","0","1","2013-07-24 15:53:35","","3","","","","","2013-07-24 15:30:44",""
"11870342","RSASSA_PKCS1v15_SHA_Signer and PK_SignatureScheme::KeyTooShort exception","<p>I am using Crypto++ for the first time, and I am having some trouble. Why does this work in C# (with the same keys), but not with Crypto++? I will show my C# and C++ code below.</p>

<p>C# code <strong>(this works!)</strong>:</p>

<pre><code>byte[] Modulus = new byte[] { 0xA3, 0x1D, 0x6C, 0xE5, 0xFA, 0x95, 0xFD, 0xE8, 0x90, 0x21, 0xFA, 0xD1, 0x0C, 0x64, 0x19, 0x2B, 0x86, 0x58, 0x9B, 0x17, 0x2B, 0x10, 0x05, 0xB8, 0xD1, 0xF8, 0x4C, 0xEF, 0x53, 0x4C, 0xD5, 0x4E, 0x5C, 0xAE, 0x86, 0xEF, 0x92, 0x7B, 0x90, 0xD1, 0xE0, 0x62, 0xFD, 0x7C, 0x54, 0x55, 0x9E, 0xE0, 0xE7, 0xBE, 0xFA, 0x3F, 0x9E, 0x15, 0x6F, 0x6C, 0x38, 0x4E, 0xAF, 0x07, 0x0C, 0x61, 0xAB, 0x51, 0x5E, 0x23, 0x53, 0x14, 0x18, 0x88, 0xCB, 0x6F, 0xCB, 0xC5, 0xD6, 0x30, 0xF4, 0x06, 0xED, 0x24, 0x23, 0xEF, 0x25, 0x6D, 0x00, 0x91, 0x77, 0x24, 0x9B, 0xE5, 0xA3, 0xC0, 0x27, 0x90, 0xC2, 0x97, 0xF7, 0x74, 0x9D, 0x6F, 0x17, 0x83, 0x7E, 0xB5, 0x37, 0xDE, 0x51, 0xE8, 0xD7, 0x1C, 0xE1, 0x56, 0xD9, 0x56, 0xC8, 0xC3, 0xC3, 0x20, 0x9D, 0x64, 0xC3, 0x2F, 0x8C, 0x91, 0x92, 0x30, 0x6F, 0xDB };
byte[] Exponent = new byte[] { 0x00, 0x01, 0x00, 0x01 };
byte[] P = new byte[] { 0xCC, 0xE7, 0x5D, 0xFE, 0x72, 0xB6, 0xFD, 0xE7, 0x1D, 0xE3, 0x1A, 0x0E, 0xAC, 0x33, 0x7A, 0xB9, 0x21, 0xE8, 0x8A, 0x84, 0x9B, 0xDA, 0x9F, 0x1E, 0x58, 0x34, 0x68, 0x7A, 0xB1, 0x1D, 0x7E, 0x1C, 0x18, 0x52, 0x65, 0x7B, 0x97, 0x8E, 0xA7, 0x6A, 0x9D, 0xEE, 0x5A, 0x77, 0x52, 0x3B, 0x71, 0x8F, 0x33, 0xD0, 0x49, 0x5E, 0xC3, 0x30, 0x39, 0x72, 0x36, 0xBF, 0x1D, 0xD9, 0xF2, 0x24, 0xE8, 0x71 };
byte[] Q = new byte[] { 0xCB, 0xCA, 0x58, 0x74, 0xD4, 0x03, 0x62, 0x93, 0x06, 0x50, 0x1F, 0x42, 0xF6, 0xAA, 0x59, 0x36, 0xA7, 0xA1, 0xF3, 0x97, 0x5C, 0x9A, 0xC8, 0x6A, 0x27, 0xCF, 0x85, 0x05, 0x2A, 0x66, 0x41, 0x6A, 0x7F, 0x2F, 0x84, 0xC8, 0x18, 0x13, 0xC6, 0x1D, 0x8D, 0xC7, 0x32, 0x2F, 0x72, 0x19, 0x3F, 0xA4, 0xED, 0x71, 0xE7, 0x61, 0xC0, 0xCF, 0x61, 0xAE, 0x8B, 0xA0, 0x68, 0xA7, 0x7D, 0x83, 0x23, 0x0B };
byte[] DP = new byte[] { 0x4C, 0xCA, 0x74, 0xE6, 0x74, 0x35, 0x72, 0x48, 0x58, 0x62, 0x11, 0x14, 0xE8, 0xA2, 0x4E, 0x5E, 0xED, 0x7F, 0x49, 0xD2, 0x52, 0xDA, 0x87, 0x01, 0x87, 0x4A, 0xF4, 0xD0, 0xEE, 0x69, 0xC0, 0x26, 0x65, 0x53, 0x13, 0xE7, 0x52, 0xB0, 0x4A, 0xBB, 0xE1, 0x3E, 0x3F, 0xB7, 0x32, 0x21, 0x46, 0xF8, 0xC5, 0x11, 0x4D, 0x3D, 0xEF, 0x66, 0xB6, 0x50, 0xC0, 0x85, 0xB5, 0x79, 0x45, 0x8F, 0x61, 0x71 };
byte[] InverseQ = new byte[] { 0x28, 0x6A, 0xBB, 0xD1, 0x93, 0x95, 0x94, 0x1A, 0x6E, 0xED, 0xD7, 0x0E, 0xC0, 0x61, 0x2B, 0xC2, 0xEF, 0xE1, 0x86, 0x3D, 0x34, 0x12, 0x88, 0x6F, 0x94, 0xA4, 0x48, 0x6E, 0xC9, 0x87, 0x1E, 0x46, 0x00, 0x46, 0x00, 0x52, 0x8E, 0x9F, 0x47, 0xC0, 0x8C, 0xAB, 0xBC, 0x49, 0xAC, 0x5B, 0x13, 0xF2, 0xEC, 0x27, 0x8D, 0x1B, 0x6E, 0x51, 0x06, 0xA6, 0xF1, 0x62, 0x1A, 0xEB, 0x78, 0x2E, 0x88, 0x48 };
byte[] D = new byte[] { 0x9B, 0xF9, 0xDE, 0xC2, 0x45, 0x93, 0x4C, 0x4C, 0xAC, 0x48, 0x2B, 0xA8, 0x4D, 0xFC, 0xD7, 0xED, 0xB2, 0xFB, 0x72, 0xE9, 0xEA, 0xC1, 0x88, 0x39, 0x07, 0x2A, 0x6F, 0x34, 0x07, 0x81, 0x97, 0x7E, 0xCD, 0xFA, 0x21, 0x02, 0xF5, 0xDD, 0x30, 0xDD, 0x22, 0x4A, 0xB3, 0x41, 0xE5, 0x89, 0x80, 0x73, 0xC4, 0xAF, 0x90, 0x9E, 0x2B, 0x50, 0x8A, 0x0A, 0xD4, 0x6E, 0xBD, 0x0F, 0x15, 0x79, 0x37, 0x95, 0xE8, 0x3D, 0xCF, 0x4C, 0x6D, 0xFF, 0x51, 0x65, 0xE7, 0x90, 0xC1, 0xAC, 0x2D, 0xC6, 0xEB, 0x47, 0x19, 0x2D, 0xD0, 0x58, 0x74, 0x79, 0xAC, 0x08, 0x1C, 0xA3, 0x1D, 0xD0, 0xCE, 0x39, 0x2E, 0xC3, 0xFA, 0x66, 0xEF, 0xC7, 0x8E, 0x10, 0x2F, 0xE4, 0xA1, 0xE7, 0x4E, 0xA8, 0x42, 0xF0, 0xF4, 0xFD, 0x10, 0xA6, 0x67, 0x64, 0xCB, 0x3A, 0x6D, 0x4D, 0x51, 0xEC, 0x1F, 0x9D, 0x56, 0x26, 0xC2, 0xFC };
byte[] DQ = new byte[] { 0xAF, 0xDC, 0x46, 0xE7, 0x52, 0x8A, 0x35, 0x47, 0xA1, 0x1C, 0x05, 0x4E, 0x39, 0x24, 0x99, 0xE6, 0x43, 0x54, 0xCB, 0xAB, 0xE3, 0xDB, 0x22, 0x76, 0x11, 0x32, 0xD0, 0x9C, 0xBB, 0x91, 0x10, 0x84, 0x81, 0x8B, 0x15, 0x2F, 0xC3, 0x2F, 0x55, 0x38, 0xED, 0xBF, 0x67, 0x3C, 0x70, 0x5E, 0xFF, 0x80, 0x28, 0xF3, 0xB1, 0x73, 0xB6, 0xFA, 0x7F, 0x56, 0x2B, 0xE1, 0xDA, 0x4E, 0x27, 0x4E, 0xC2, 0x2F }; 


RSAParameters rsaParams = new RSAParameters();
rsaParams.Modulus = Modulus;
rsaParams.Exponent = Exponent;
rsaParams.P = P;
rsaParams.Q = Q;
rsaParams.DP = DP;
rsaParams.InverseQ = InverseQ;
rsaParams.D = D;
rsaParams.DQ = DQ;

RSACryptoServiceProvider crypt = new RSACryptoServiceProvider();
crypt.ImportParameters(rsaParams);

RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter();
formatter.SetHashAlgorithm(""SHA1"");
formatter.SetKey(crypt);

byte[] dataFile = new byte[] { 0x6F, 0x9F, 0x07, 0x04, 0xE2, 0x1A, 0xF7, 0xB8, 0xB2, 0x4F, 0x8D, 0x66, 0x49, 0xA1, 0x09, 0xA7, 0xB2, 0x22, 0x3C, 0xF9};

byte[] signature = formatter.CreateSignature(dataFile);
</code></pre>

<p>Now, my C++ code, which doesn't work:</p>

<pre><code>const char ModulusCON[0x80] = { 0xA3, 0x1D, 0x6C, 0xE5, 0xFA, 0x95, 0xFD, 0xE8, 0x90, 0x21, 0xFA, 0xD1, 0x0C, 0x64, 0x19, 0x2B, 0x86, 0x58, 0x9B, 0x17, 0x2B, 0x10, 0x05, 0xB8, 0xD1, 0xF8, 0x4C, 0xEF, 0x53, 0x4C, 0xD5, 0x4E, 0x5C, 0xAE, 0x86, 0xEF, 0x92, 0x7B, 0x90, 0xD1, 0xE0, 0x62, 0xFD, 0x7C, 0x54, 0x55, 0x9E, 0xE0, 0xE7, 0xBE, 0xFA, 0x3F, 0x9E, 0x15, 0x6F, 0x6C, 0x38, 0x4E, 0xAF, 0x07, 0x0C, 0x61, 0xAB, 0x51, 0x5E, 0x23, 0x53, 0x14, 0x18, 0x88, 0xCB, 0x6F, 0xCB, 0xC5, 0xD6, 0x30, 0xF4, 0x06, 0xED, 0x24, 0x23, 0xEF, 0x25, 0x6D, 0x00, 0x91, 0x77, 0x24, 0x9B, 0xE5, 0xA3, 0xC0, 0x27, 0x90, 0xC2, 0x97, 0xF7, 0x74, 0x9D, 0x6F, 0x17, 0x83, 0x7E, 0xB5, 0x37, 0xDE, 0x51, 0xE8, 0xD7, 0x1C, 0xE1, 0x56, 0xD9, 0x56, 0xC8, 0xC3, 0xC3, 0x20, 0x9D, 0x64, 0xC3, 0x2F, 0x8C, 0x91, 0x92, 0x30, 0x6F, 0xDB }; 
const char ExponentCON[0x4] = { 0x00, 0x01, 0x00, 0x01 }; 
const char PCON[0x40] = { 0xCC, 0xE7, 0x5D, 0xFE, 0x72, 0xB6, 0xFD, 0xE7, 0x1D, 0xE3, 0x1A, 0x0E, 0xAC, 0x33, 0x7A, 0xB9, 0x21, 0xE8, 0x8A, 0x84, 0x9B, 0xDA, 0x9F, 0x1E, 0x58, 0x34, 0x68, 0x7A, 0xB1, 0x1D, 0x7E, 0x1C, 0x18, 0x52, 0x65, 0x7B, 0x97, 0x8E, 0xA7, 0x6A, 0x9D, 0xEE, 0x5A, 0x77, 0x52, 0x3B, 0x71, 0x8F, 0x33, 0xD0, 0x49, 0x5E, 0xC3, 0x30, 0x39, 0x72, 0x36, 0xBF, 0x1D, 0xD9, 0xF2, 0x24, 0xE8, 0x71 }; 
const char QCON[0x40] = { 0xCB, 0xCA, 0x58, 0x74, 0xD4, 0x03, 0x62, 0x93, 0x06, 0x50, 0x1F, 0x42, 0xF6, 0xAA, 0x59, 0x36, 0xA7, 0xA1, 0xF3, 0x97, 0x5C, 0x9A, 0xC8, 0x6A, 0x27, 0xCF, 0x85, 0x05, 0x2A, 0x66, 0x41, 0x6A, 0x7F, 0x2F, 0x84, 0xC8, 0x18, 0x13, 0xC6, 0x1D, 0x8D, 0xC7, 0x32, 0x2F, 0x72, 0x19, 0x3F, 0xA4, 0xED, 0x71, 0xE7, 0x61, 0xC0, 0xCF, 0x61, 0xAE, 0x8B, 0xA0, 0x68, 0xA7, 0x7D, 0x83, 0x23, 0x0B }; 
const char DPCON[0x40] = { 0x4C, 0xCA, 0x74, 0xE6, 0x74, 0x35, 0x72, 0x48, 0x58, 0x62, 0x11, 0x14, 0xE8, 0xA2, 0x4E, 0x5E, 0xED, 0x7F, 0x49, 0xD2, 0x52, 0xDA, 0x87, 0x01, 0x87, 0x4A, 0xF4, 0xD0, 0xEE, 0x69, 0xC0, 0x26, 0x65, 0x53, 0x13, 0xE7, 0x52, 0xB0, 0x4A, 0xBB, 0xE1, 0x3E, 0x3F, 0xB7, 0x32, 0x21, 0x46, 0xF8, 0xC5, 0x11, 0x4D, 0x3D, 0xEF, 0x66, 0xB6, 0x50, 0xC0, 0x85, 0xB5, 0x79, 0x45, 0x8F, 0x61, 0x71 }; 
const char InverseQCON[0x40] = { 0x28, 0x6A, 0xBB, 0xD1, 0x93, 0x95, 0x94, 0x1A, 0x6E, 0xED, 0xD7, 0x0E, 0xC0, 0x61, 0x2B, 0xC2, 0xEF, 0xE1, 0x86, 0x3D, 0x34, 0x12, 0x88, 0x6F, 0x94, 0xA4, 0x48, 0x6E, 0xC9, 0x87, 0x1E, 0x46, 0x00, 0x46, 0x00, 0x52, 0x8E, 0x9F, 0x47, 0xC0, 0x8C, 0xAB, 0xBC, 0x49, 0xAC, 0x5B, 0x13, 0xF2, 0xEC, 0x27, 0x8D, 0x1B, 0x6E, 0x51, 0x06, 0xA6, 0xF1, 0x62, 0x1A, 0xEB, 0x78, 0x2E, 0x88, 0x48 }; 
const char DCON[0x80] = { 0x9B, 0xF9, 0xDE, 0xC2, 0x45, 0x93, 0x4C, 0x4C, 0xAC, 0x48, 0x2B, 0xA8, 0x4D, 0xFC, 0xD7, 0xED, 0xB2, 0xFB, 0x72, 0xE9, 0xEA, 0xC1, 0x88, 0x39, 0x07, 0x2A, 0x6F, 0x34, 0x07, 0x81, 0x97, 0x7E, 0xCD, 0xFA, 0x21, 0x02, 0xF5, 0xDD, 0x30, 0xDD, 0x22, 0x4A, 0xB3, 0x41, 0xE5, 0x89, 0x80, 0x73, 0xC4, 0xAF, 0x90, 0x9E, 0x2B, 0x50, 0x8A, 0x0A, 0xD4, 0x6E, 0xBD, 0x0F, 0x15, 0x79, 0x37, 0x95, 0xE8, 0x3D, 0xCF, 0x4C, 0x6D, 0xFF, 0x51, 0x65, 0xE7, 0x90, 0xC1, 0xAC, 0x2D, 0xC6, 0xEB, 0x47, 0x19, 0x2D, 0xD0, 0x58, 0x74, 0x79, 0xAC, 0x08, 0x1C, 0xA3, 0x1D, 0xD0, 0xCE, 0x39, 0x2E, 0xC3, 0xFA, 0x66, 0xEF, 0xC7, 0x8E, 0x10, 0x2F, 0xE4, 0xA1, 0xE7, 0x4E, 0xA8, 0x42, 0xF0, 0xF4, 0xFD, 0x10, 0xA6, 0x67, 0x64, 0xCB, 0x3A, 0x6D, 0x4D, 0x51, 0xEC, 0x1F, 0x9D, 0x56, 0x26, 0xC2, 0xFC }; 
const char DQCON[0x40] = { 0xAF, 0xDC, 0x46, 0xE7, 0x52, 0x8A, 0x35, 0x47, 0xA1, 0x1C, 0x05, 0x4E, 0x39, 0x24, 0x99, 0xE6, 0x43, 0x54, 0xCB, 0xAB, 0xE3, 0xDB, 0x22, 0x76, 0x11, 0x32, 0xD0, 0x9C, 0xBB, 0x91, 0x10, 0x84, 0x81, 0x8B, 0x15, 0x2F, 0xC3, 0x2F, 0x55, 0x38, 0xED, 0xBF, 0x67, 0x3C, 0x70, 0x5E, 0xFF, 0x80, 0x28, 0xF3, 0xB1, 0x73, 0xB6, 0xFA, 0x7F, 0x56, 0x2B, 0xE1, 0xDA, 0x4E, 0x27, 0x4E, 0xC2, 0x2F }; 

// set the params
CryptoPP::AutoSeededRandomPool rng;
InvertibleRSAFunction params;

Integer integ(ModulusCON);
params.SetModulus(integ);

Integer integ1(ExponentCON);
params.SetPublicExponent(integ1);

Integer integ2(PCON);
params.SetPrime1(integ2);

Integer integ3(QCON);
params.SetPrime2(integ3);

Integer integ4(DPCON);
params.SetModPrime1PrivateExponent(integ4);

Integer integ5(InverseQCON);
params.SetMultiplicativeInverseOfPrime2ModPrime1(integ5);

Integer integ6(DCON);
params.SetPrivateExponent(integ6);

Integer integ7(DQCON);
params.SetModPrime2PrivateExponent(integ7);

// create the keys
RSA::PrivateKey privateKey(params);
RSA::PublicKey publicKey(params);

CryptoPP::RSASSA_PKCS1v15_SHA_Signer signer(privateKey);

unsigned char data[20] = { 0x6F, 0x9F, 0x07, 0x04, 0xE2, 0x1A, 0xF7, 0xB8, 0xB2, 0x4F, 0x8D, 0x66, 0x49, 0xA1, 0x09, 0xA7, 0xB2, 0x22, 0x3C, 0xF9 };
BYTE *signature = new BYTE[0x80];
signer.SignMessage(rng, data, 20, signature);
</code></pre>

<p>Based on what I know, Crypto++'s 'RSASSA_PKCS1v15_SHA_Signer' is what I want equivalent to C#'s 'RSAPKCS1SignatureFormatter' and setting the hash algorithm to SHA1.</p>

<p>The error it throws is:</p>

<blockquote>
  <p>Unhandled exception at at 0x7646B9BC in proj.exe: Microsoft C++ exception: > CryptoPP::PK_SignatureScheme::KeyTooShort at memory location 0x0040EF18.</p>
</blockquote>

<p>Thanks for any help, Hetelek.</p>
","<p>I can't answer as to why this works in C#, but as for Crypto++, there are a couple of issues.</p>

<p><br>
Firstly, you're probably invoking the wrong constructor of <a href=""http://www.cryptopp.com/docs/ref/class_integer.html#a7fcab0564d7270017ebcca55bae1a17a"" rel=""nofollow""><code>Integer</code></a>.  I guess you want this one which converts from big-endian byte array:</p>

<pre><code>Integer (const byte *encodedInteger, size_t byteCount, Signedness s=UNSIGNED)
</code></pre>

<p>but are using <a href=""http://www.cryptopp.com/docs/ref/class_integer.html#a9e8bf8c72458dff4ceb5d6cdf9e5c97a"" rel=""nofollow"">this one</a> which convert from a string in base 2, 8, 10, or 16 (in your case base 10).</p>

<p>So, using <code>ExponentCON</code> as an example, you should do:</p>

<pre><code>const int ExponentSize(0x4);
const byte ExponentCON[ExponentSize] = { 0x00, 0x01, 0x00, 0x01 };
Integer integ1(ExponentCON, ExponentSize);
</code></pre>

<p>or possibly better still:</p>

<pre><code>std::string ExponentCON(""101h"");  // &lt;-- Note trailing 'h' indicating hex encoding
Integer integ1(ExponentCON.c_str());
</code></pre>

<p><br></p>

<p>Next, the members of <code>InvertibleRSAFunction</code> must satisfy certain conditions in order to qualify as a valid key.  These can be seen by stepping through the <a href=""http://www.cryptopp.com/docs/ref/class_invertible_r_s_a_function.html#a35247205517f839220a16287917ce0ce"" rel=""nofollow""><code>InvertibleRSAFunction::Validate</code></a> function and I assume check for the conditions <a href=""http://en.wikipedia.org/wiki/RSA_%28algorithm%29#Key_generation"" rel=""nofollow"">described here</a>.</p>

<pre><code>params.Validate(rng, 3);  // Returns false for your input data
</code></pre>

<p><br>
There are some helper functions which are designed to avoid having to set everything explicitly as you're doing.  I don't know if these are suitable for you, but I'm referring to <a href=""http://www.cryptopp.com/docs/ref/class_generatable_crypto_material.html#a38d492343c32e530a5c2781b5797f755"" rel=""nofollow""><code>InvertibleRSAFunction::GenerateRandomWithKeySize</code></a> and the overloaded <a href=""http://www.cryptopp.com/docs/ref/class_invertible_r_s_a_function-members.html"" rel=""nofollow""><code>InvertibleRSAFunction::Initialize</code></a>.</p>

<p>The <a href=""http://www.cryptopp.com/wiki/RSA#Keys"" rel=""nofollow"">Crypto++ Wiki</a> describes the use of these functions with example code.</p>
","1056","<c++><rsa><digital-signature><crypto++>","5","4","2","2016-04-08 21:28:00","","0","","608639","","2016-04-08 02:19:32","2012-08-08 17:55:23",""
"11870342","RSASSA_PKCS1v15_SHA_Signer and PK_SignatureScheme::KeyTooShort exception","<p>I am using Crypto++ for the first time, and I am having some trouble. Why does this work in C# (with the same keys), but not with Crypto++? I will show my C# and C++ code below.</p>

<p>C# code <strong>(this works!)</strong>:</p>

<pre><code>byte[] Modulus = new byte[] { 0xA3, 0x1D, 0x6C, 0xE5, 0xFA, 0x95, 0xFD, 0xE8, 0x90, 0x21, 0xFA, 0xD1, 0x0C, 0x64, 0x19, 0x2B, 0x86, 0x58, 0x9B, 0x17, 0x2B, 0x10, 0x05, 0xB8, 0xD1, 0xF8, 0x4C, 0xEF, 0x53, 0x4C, 0xD5, 0x4E, 0x5C, 0xAE, 0x86, 0xEF, 0x92, 0x7B, 0x90, 0xD1, 0xE0, 0x62, 0xFD, 0x7C, 0x54, 0x55, 0x9E, 0xE0, 0xE7, 0xBE, 0xFA, 0x3F, 0x9E, 0x15, 0x6F, 0x6C, 0x38, 0x4E, 0xAF, 0x07, 0x0C, 0x61, 0xAB, 0x51, 0x5E, 0x23, 0x53, 0x14, 0x18, 0x88, 0xCB, 0x6F, 0xCB, 0xC5, 0xD6, 0x30, 0xF4, 0x06, 0xED, 0x24, 0x23, 0xEF, 0x25, 0x6D, 0x00, 0x91, 0x77, 0x24, 0x9B, 0xE5, 0xA3, 0xC0, 0x27, 0x90, 0xC2, 0x97, 0xF7, 0x74, 0x9D, 0x6F, 0x17, 0x83, 0x7E, 0xB5, 0x37, 0xDE, 0x51, 0xE8, 0xD7, 0x1C, 0xE1, 0x56, 0xD9, 0x56, 0xC8, 0xC3, 0xC3, 0x20, 0x9D, 0x64, 0xC3, 0x2F, 0x8C, 0x91, 0x92, 0x30, 0x6F, 0xDB };
byte[] Exponent = new byte[] { 0x00, 0x01, 0x00, 0x01 };
byte[] P = new byte[] { 0xCC, 0xE7, 0x5D, 0xFE, 0x72, 0xB6, 0xFD, 0xE7, 0x1D, 0xE3, 0x1A, 0x0E, 0xAC, 0x33, 0x7A, 0xB9, 0x21, 0xE8, 0x8A, 0x84, 0x9B, 0xDA, 0x9F, 0x1E, 0x58, 0x34, 0x68, 0x7A, 0xB1, 0x1D, 0x7E, 0x1C, 0x18, 0x52, 0x65, 0x7B, 0x97, 0x8E, 0xA7, 0x6A, 0x9D, 0xEE, 0x5A, 0x77, 0x52, 0x3B, 0x71, 0x8F, 0x33, 0xD0, 0x49, 0x5E, 0xC3, 0x30, 0x39, 0x72, 0x36, 0xBF, 0x1D, 0xD9, 0xF2, 0x24, 0xE8, 0x71 };
byte[] Q = new byte[] { 0xCB, 0xCA, 0x58, 0x74, 0xD4, 0x03, 0x62, 0x93, 0x06, 0x50, 0x1F, 0x42, 0xF6, 0xAA, 0x59, 0x36, 0xA7, 0xA1, 0xF3, 0x97, 0x5C, 0x9A, 0xC8, 0x6A, 0x27, 0xCF, 0x85, 0x05, 0x2A, 0x66, 0x41, 0x6A, 0x7F, 0x2F, 0x84, 0xC8, 0x18, 0x13, 0xC6, 0x1D, 0x8D, 0xC7, 0x32, 0x2F, 0x72, 0x19, 0x3F, 0xA4, 0xED, 0x71, 0xE7, 0x61, 0xC0, 0xCF, 0x61, 0xAE, 0x8B, 0xA0, 0x68, 0xA7, 0x7D, 0x83, 0x23, 0x0B };
byte[] DP = new byte[] { 0x4C, 0xCA, 0x74, 0xE6, 0x74, 0x35, 0x72, 0x48, 0x58, 0x62, 0x11, 0x14, 0xE8, 0xA2, 0x4E, 0x5E, 0xED, 0x7F, 0x49, 0xD2, 0x52, 0xDA, 0x87, 0x01, 0x87, 0x4A, 0xF4, 0xD0, 0xEE, 0x69, 0xC0, 0x26, 0x65, 0x53, 0x13, 0xE7, 0x52, 0xB0, 0x4A, 0xBB, 0xE1, 0x3E, 0x3F, 0xB7, 0x32, 0x21, 0x46, 0xF8, 0xC5, 0x11, 0x4D, 0x3D, 0xEF, 0x66, 0xB6, 0x50, 0xC0, 0x85, 0xB5, 0x79, 0x45, 0x8F, 0x61, 0x71 };
byte[] InverseQ = new byte[] { 0x28, 0x6A, 0xBB, 0xD1, 0x93, 0x95, 0x94, 0x1A, 0x6E, 0xED, 0xD7, 0x0E, 0xC0, 0x61, 0x2B, 0xC2, 0xEF, 0xE1, 0x86, 0x3D, 0x34, 0x12, 0x88, 0x6F, 0x94, 0xA4, 0x48, 0x6E, 0xC9, 0x87, 0x1E, 0x46, 0x00, 0x46, 0x00, 0x52, 0x8E, 0x9F, 0x47, 0xC0, 0x8C, 0xAB, 0xBC, 0x49, 0xAC, 0x5B, 0x13, 0xF2, 0xEC, 0x27, 0x8D, 0x1B, 0x6E, 0x51, 0x06, 0xA6, 0xF1, 0x62, 0x1A, 0xEB, 0x78, 0x2E, 0x88, 0x48 };
byte[] D = new byte[] { 0x9B, 0xF9, 0xDE, 0xC2, 0x45, 0x93, 0x4C, 0x4C, 0xAC, 0x48, 0x2B, 0xA8, 0x4D, 0xFC, 0xD7, 0xED, 0xB2, 0xFB, 0x72, 0xE9, 0xEA, 0xC1, 0x88, 0x39, 0x07, 0x2A, 0x6F, 0x34, 0x07, 0x81, 0x97, 0x7E, 0xCD, 0xFA, 0x21, 0x02, 0xF5, 0xDD, 0x30, 0xDD, 0x22, 0x4A, 0xB3, 0x41, 0xE5, 0x89, 0x80, 0x73, 0xC4, 0xAF, 0x90, 0x9E, 0x2B, 0x50, 0x8A, 0x0A, 0xD4, 0x6E, 0xBD, 0x0F, 0x15, 0x79, 0x37, 0x95, 0xE8, 0x3D, 0xCF, 0x4C, 0x6D, 0xFF, 0x51, 0x65, 0xE7, 0x90, 0xC1, 0xAC, 0x2D, 0xC6, 0xEB, 0x47, 0x19, 0x2D, 0xD0, 0x58, 0x74, 0x79, 0xAC, 0x08, 0x1C, 0xA3, 0x1D, 0xD0, 0xCE, 0x39, 0x2E, 0xC3, 0xFA, 0x66, 0xEF, 0xC7, 0x8E, 0x10, 0x2F, 0xE4, 0xA1, 0xE7, 0x4E, 0xA8, 0x42, 0xF0, 0xF4, 0xFD, 0x10, 0xA6, 0x67, 0x64, 0xCB, 0x3A, 0x6D, 0x4D, 0x51, 0xEC, 0x1F, 0x9D, 0x56, 0x26, 0xC2, 0xFC };
byte[] DQ = new byte[] { 0xAF, 0xDC, 0x46, 0xE7, 0x52, 0x8A, 0x35, 0x47, 0xA1, 0x1C, 0x05, 0x4E, 0x39, 0x24, 0x99, 0xE6, 0x43, 0x54, 0xCB, 0xAB, 0xE3, 0xDB, 0x22, 0x76, 0x11, 0x32, 0xD0, 0x9C, 0xBB, 0x91, 0x10, 0x84, 0x81, 0x8B, 0x15, 0x2F, 0xC3, 0x2F, 0x55, 0x38, 0xED, 0xBF, 0x67, 0x3C, 0x70, 0x5E, 0xFF, 0x80, 0x28, 0xF3, 0xB1, 0x73, 0xB6, 0xFA, 0x7F, 0x56, 0x2B, 0xE1, 0xDA, 0x4E, 0x27, 0x4E, 0xC2, 0x2F }; 


RSAParameters rsaParams = new RSAParameters();
rsaParams.Modulus = Modulus;
rsaParams.Exponent = Exponent;
rsaParams.P = P;
rsaParams.Q = Q;
rsaParams.DP = DP;
rsaParams.InverseQ = InverseQ;
rsaParams.D = D;
rsaParams.DQ = DQ;

RSACryptoServiceProvider crypt = new RSACryptoServiceProvider();
crypt.ImportParameters(rsaParams);

RSAPKCS1SignatureFormatter formatter = new RSAPKCS1SignatureFormatter();
formatter.SetHashAlgorithm(""SHA1"");
formatter.SetKey(crypt);

byte[] dataFile = new byte[] { 0x6F, 0x9F, 0x07, 0x04, 0xE2, 0x1A, 0xF7, 0xB8, 0xB2, 0x4F, 0x8D, 0x66, 0x49, 0xA1, 0x09, 0xA7, 0xB2, 0x22, 0x3C, 0xF9};

byte[] signature = formatter.CreateSignature(dataFile);
</code></pre>

<p>Now, my C++ code, which doesn't work:</p>

<pre><code>const char ModulusCON[0x80] = { 0xA3, 0x1D, 0x6C, 0xE5, 0xFA, 0x95, 0xFD, 0xE8, 0x90, 0x21, 0xFA, 0xD1, 0x0C, 0x64, 0x19, 0x2B, 0x86, 0x58, 0x9B, 0x17, 0x2B, 0x10, 0x05, 0xB8, 0xD1, 0xF8, 0x4C, 0xEF, 0x53, 0x4C, 0xD5, 0x4E, 0x5C, 0xAE, 0x86, 0xEF, 0x92, 0x7B, 0x90, 0xD1, 0xE0, 0x62, 0xFD, 0x7C, 0x54, 0x55, 0x9E, 0xE0, 0xE7, 0xBE, 0xFA, 0x3F, 0x9E, 0x15, 0x6F, 0x6C, 0x38, 0x4E, 0xAF, 0x07, 0x0C, 0x61, 0xAB, 0x51, 0x5E, 0x23, 0x53, 0x14, 0x18, 0x88, 0xCB, 0x6F, 0xCB, 0xC5, 0xD6, 0x30, 0xF4, 0x06, 0xED, 0x24, 0x23, 0xEF, 0x25, 0x6D, 0x00, 0x91, 0x77, 0x24, 0x9B, 0xE5, 0xA3, 0xC0, 0x27, 0x90, 0xC2, 0x97, 0xF7, 0x74, 0x9D, 0x6F, 0x17, 0x83, 0x7E, 0xB5, 0x37, 0xDE, 0x51, 0xE8, 0xD7, 0x1C, 0xE1, 0x56, 0xD9, 0x56, 0xC8, 0xC3, 0xC3, 0x20, 0x9D, 0x64, 0xC3, 0x2F, 0x8C, 0x91, 0x92, 0x30, 0x6F, 0xDB }; 
const char ExponentCON[0x4] = { 0x00, 0x01, 0x00, 0x01 }; 
const char PCON[0x40] = { 0xCC, 0xE7, 0x5D, 0xFE, 0x72, 0xB6, 0xFD, 0xE7, 0x1D, 0xE3, 0x1A, 0x0E, 0xAC, 0x33, 0x7A, 0xB9, 0x21, 0xE8, 0x8A, 0x84, 0x9B, 0xDA, 0x9F, 0x1E, 0x58, 0x34, 0x68, 0x7A, 0xB1, 0x1D, 0x7E, 0x1C, 0x18, 0x52, 0x65, 0x7B, 0x97, 0x8E, 0xA7, 0x6A, 0x9D, 0xEE, 0x5A, 0x77, 0x52, 0x3B, 0x71, 0x8F, 0x33, 0xD0, 0x49, 0x5E, 0xC3, 0x30, 0x39, 0x72, 0x36, 0xBF, 0x1D, 0xD9, 0xF2, 0x24, 0xE8, 0x71 }; 
const char QCON[0x40] = { 0xCB, 0xCA, 0x58, 0x74, 0xD4, 0x03, 0x62, 0x93, 0x06, 0x50, 0x1F, 0x42, 0xF6, 0xAA, 0x59, 0x36, 0xA7, 0xA1, 0xF3, 0x97, 0x5C, 0x9A, 0xC8, 0x6A, 0x27, 0xCF, 0x85, 0x05, 0x2A, 0x66, 0x41, 0x6A, 0x7F, 0x2F, 0x84, 0xC8, 0x18, 0x13, 0xC6, 0x1D, 0x8D, 0xC7, 0x32, 0x2F, 0x72, 0x19, 0x3F, 0xA4, 0xED, 0x71, 0xE7, 0x61, 0xC0, 0xCF, 0x61, 0xAE, 0x8B, 0xA0, 0x68, 0xA7, 0x7D, 0x83, 0x23, 0x0B }; 
const char DPCON[0x40] = { 0x4C, 0xCA, 0x74, 0xE6, 0x74, 0x35, 0x72, 0x48, 0x58, 0x62, 0x11, 0x14, 0xE8, 0xA2, 0x4E, 0x5E, 0xED, 0x7F, 0x49, 0xD2, 0x52, 0xDA, 0x87, 0x01, 0x87, 0x4A, 0xF4, 0xD0, 0xEE, 0x69, 0xC0, 0x26, 0x65, 0x53, 0x13, 0xE7, 0x52, 0xB0, 0x4A, 0xBB, 0xE1, 0x3E, 0x3F, 0xB7, 0x32, 0x21, 0x46, 0xF8, 0xC5, 0x11, 0x4D, 0x3D, 0xEF, 0x66, 0xB6, 0x50, 0xC0, 0x85, 0xB5, 0x79, 0x45, 0x8F, 0x61, 0x71 }; 
const char InverseQCON[0x40] = { 0x28, 0x6A, 0xBB, 0xD1, 0x93, 0x95, 0x94, 0x1A, 0x6E, 0xED, 0xD7, 0x0E, 0xC0, 0x61, 0x2B, 0xC2, 0xEF, 0xE1, 0x86, 0x3D, 0x34, 0x12, 0x88, 0x6F, 0x94, 0xA4, 0x48, 0x6E, 0xC9, 0x87, 0x1E, 0x46, 0x00, 0x46, 0x00, 0x52, 0x8E, 0x9F, 0x47, 0xC0, 0x8C, 0xAB, 0xBC, 0x49, 0xAC, 0x5B, 0x13, 0xF2, 0xEC, 0x27, 0x8D, 0x1B, 0x6E, 0x51, 0x06, 0xA6, 0xF1, 0x62, 0x1A, 0xEB, 0x78, 0x2E, 0x88, 0x48 }; 
const char DCON[0x80] = { 0x9B, 0xF9, 0xDE, 0xC2, 0x45, 0x93, 0x4C, 0x4C, 0xAC, 0x48, 0x2B, 0xA8, 0x4D, 0xFC, 0xD7, 0xED, 0xB2, 0xFB, 0x72, 0xE9, 0xEA, 0xC1, 0x88, 0x39, 0x07, 0x2A, 0x6F, 0x34, 0x07, 0x81, 0x97, 0x7E, 0xCD, 0xFA, 0x21, 0x02, 0xF5, 0xDD, 0x30, 0xDD, 0x22, 0x4A, 0xB3, 0x41, 0xE5, 0x89, 0x80, 0x73, 0xC4, 0xAF, 0x90, 0x9E, 0x2B, 0x50, 0x8A, 0x0A, 0xD4, 0x6E, 0xBD, 0x0F, 0x15, 0x79, 0x37, 0x95, 0xE8, 0x3D, 0xCF, 0x4C, 0x6D, 0xFF, 0x51, 0x65, 0xE7, 0x90, 0xC1, 0xAC, 0x2D, 0xC6, 0xEB, 0x47, 0x19, 0x2D, 0xD0, 0x58, 0x74, 0x79, 0xAC, 0x08, 0x1C, 0xA3, 0x1D, 0xD0, 0xCE, 0x39, 0x2E, 0xC3, 0xFA, 0x66, 0xEF, 0xC7, 0x8E, 0x10, 0x2F, 0xE4, 0xA1, 0xE7, 0x4E, 0xA8, 0x42, 0xF0, 0xF4, 0xFD, 0x10, 0xA6, 0x67, 0x64, 0xCB, 0x3A, 0x6D, 0x4D, 0x51, 0xEC, 0x1F, 0x9D, 0x56, 0x26, 0xC2, 0xFC }; 
const char DQCON[0x40] = { 0xAF, 0xDC, 0x46, 0xE7, 0x52, 0x8A, 0x35, 0x47, 0xA1, 0x1C, 0x05, 0x4E, 0x39, 0x24, 0x99, 0xE6, 0x43, 0x54, 0xCB, 0xAB, 0xE3, 0xDB, 0x22, 0x76, 0x11, 0x32, 0xD0, 0x9C, 0xBB, 0x91, 0x10, 0x84, 0x81, 0x8B, 0x15, 0x2F, 0xC3, 0x2F, 0x55, 0x38, 0xED, 0xBF, 0x67, 0x3C, 0x70, 0x5E, 0xFF, 0x80, 0x28, 0xF3, 0xB1, 0x73, 0xB6, 0xFA, 0x7F, 0x56, 0x2B, 0xE1, 0xDA, 0x4E, 0x27, 0x4E, 0xC2, 0x2F }; 

// set the params
CryptoPP::AutoSeededRandomPool rng;
InvertibleRSAFunction params;

Integer integ(ModulusCON);
params.SetModulus(integ);

Integer integ1(ExponentCON);
params.SetPublicExponent(integ1);

Integer integ2(PCON);
params.SetPrime1(integ2);

Integer integ3(QCON);
params.SetPrime2(integ3);

Integer integ4(DPCON);
params.SetModPrime1PrivateExponent(integ4);

Integer integ5(InverseQCON);
params.SetMultiplicativeInverseOfPrime2ModPrime1(integ5);

Integer integ6(DCON);
params.SetPrivateExponent(integ6);

Integer integ7(DQCON);
params.SetModPrime2PrivateExponent(integ7);

// create the keys
RSA::PrivateKey privateKey(params);
RSA::PublicKey publicKey(params);

CryptoPP::RSASSA_PKCS1v15_SHA_Signer signer(privateKey);

unsigned char data[20] = { 0x6F, 0x9F, 0x07, 0x04, 0xE2, 0x1A, 0xF7, 0xB8, 0xB2, 0x4F, 0x8D, 0x66, 0x49, 0xA1, 0x09, 0xA7, 0xB2, 0x22, 0x3C, 0xF9 };
BYTE *signature = new BYTE[0x80];
signer.SignMessage(rng, data, 20, signature);
</code></pre>

<p>Based on what I know, Crypto++'s 'RSASSA_PKCS1v15_SHA_Signer' is what I want equivalent to C#'s 'RSAPKCS1SignatureFormatter' and setting the hash algorithm to SHA1.</p>

<p>The error it throws is:</p>

<blockquote>
  <p>Unhandled exception at at 0x7646B9BC in proj.exe: Microsoft C++ exception: > CryptoPP::PK_SignatureScheme::KeyTooShort at memory location 0x0040EF18.</p>
</blockquote>

<p>Thanks for any help, Hetelek.</p>
","<p><strong><em>TLDR</em></strong>: your private exponent, <strong><em><code>d</code></em></strong>, is wrong in your sample program. You have other, more obvious problems, too. But <strong><em><code>d</code></em></strong> is causing the mathematical problems.</p>

<p>And it begs the question, how did that work in C#? The math does not change across computer languages and runtimes.</p>

<hr>

<p>The first problem is the declarations using <code>chars</code>:</p>

<pre class=""lang-c++ prettyprint-override""><code>...
const char ExponentCON[0x4] = { 0x00, 0x01, 0x00, 0x01 }; 
...
</code></pre>

<p>This causes you to use the constructors for ASCII strings, which is the  wrong <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow""><code>Integer</code> constructor</a>. It results in at least two issues:</p>

<pre class=""lang-c++ prettyprint-override""><code>// Added for testing
if (integ != integ2 * integ3)
{
    cerr &lt;&lt; ""error: n != p*q"" &lt;&lt; endl;
}

// Added for testing
params.ThrowIfInvalid(prng, 3);
</code></pre>

<p>When running the program, <code>ThrowIfInvalid</code> validates the parameters and its the source of <code>CryptoMaterial: ...</code>:</p>

<pre class=""lang-none prettyprint-override""><code>error: n != p*q
CryptoMaterial: this object contains invalid values
</code></pre>

<hr>

<p>The <code>const char</code> need to be changed to <code>const byte</code>. Then:</p>

<pre class=""lang-c++ prettyprint-override""><code>Integer integ(ModulusCON, sizeof(ModulusCON));
params.SetModulus(integ);

Integer integ1(ExponentCON, sizeof(ExponentCON));
params.SetPublicExponent(integ1);

Integer integ2(PCON, sizeof(PCON));
params.SetPrime1(integ2);

Integer integ3(QCON, sizeof(QCON));
params.SetPrime2(integ3);
...
</code></pre>

<p>With that change in place, this error message from above disappears: <strong><em><code>error: n != p*q</code></em></strong>. But the <strong><em><code>CryptoMaterial: this object contains invalid values</code></em></strong> remains.</p>

<hr>

<p>The second problem appears to be some of your private key parameters are not correct. You can see what tests <code>InvertibleRSAFunction::Validate</code> is performing by looking at the source code in <a href=""http://www.cryptopp.com/docs/ref/rsa_8cpp_source.html#l00246"" rel=""nofollow""><code>rsa.cpp</code> near line 250</a>.</p>

<p>You can partially side step it by using <a href=""http://www.cryptopp.com/docs/ref/class_invertible_r_s_a_function.html"" rel=""nofollow""><code>Initialize</code> that takes <code>{n,e,d}</code></a>, and let <code>Initialize</code> factor and solve: </p>

<pre class=""lang-c++ prettyprint-override""><code>Integer n(ModulusCON, sizeof(ModulusCON));
Integer e(ExponentCON, sizeof(ExponentCON));
Integer d(DCON, sizeof(DCON));

params.Initialize(n,e,d);
params.ThrowIfInvalid(prng, 3);
</code></pre>

<p>However, that results in:</p>

<pre class=""lang-none prettyprint-override""><code>InvertibleRSAFunction: input is not a valid RSA private key
</code></pre>

<hr>

<p>Next, check <code>p</code> and <code>q</code>. <code>#include &lt;nbtheory.h&gt;</code>, and then:</p>

<pre class=""lang-c++ prettyprint-override""><code>Integer p(PCON, sizeof(PCON));
Integer q(QCON, sizeof(QCON));

cout &lt;&lt; ""P is prime: "" &lt;&lt; (VerifyPrime(prng, p, 10) ? ""yes"" : ""no"") &lt;&lt; endl;
cout &lt;&lt; ""Q is prime: "" &lt;&lt; (VerifyPrime(prng, q, 10) ? ""yes"" : ""no"") &lt;&lt; endl;
</code></pre>

<p>It results in:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
P is prime: yes
Q is prime: yes
</code></pre>

<p>At this point, it appears the problem is with one of the exponents.</p>

<hr>

<p>Next, assume <code>e</code> is relatively prime to <em>phi</em>, <code>#include &lt;modarith.h&gt;</code>, and then:</p>

<pre class=""lang-c++ prettyprint-override""><code>Integer n(ModulusCON, sizeof(ModulusCON));
Integer p(PCON, sizeof(PCON));
Integer q(QCON, sizeof(QCON));

Integer e(ExponentCON, sizeof(ExponentCON));    
Integer phi = (p-1)*(q-1);

ModularArithmetic ma(phi);
Integer d = ma.MultiplicativeInverse(e);

params.Initialize(n,e,d);
params.ThrowIfInvalid(prng, 3);

cout &lt;&lt; ""Validated parameters"" &lt;&lt; endl;
</code></pre>

<p>It results in:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Validated parameters
</code></pre>

<p>So, the problem is with your <code>d</code> exponent. It is easy enough to print with <code>cout &lt;&lt; std::hex &lt;&lt; d &lt;&lt; endl</code>:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Validated parameters

174bcc91cc08400b470a9357e7fd23db2384e4219af4dedc56a0afdc3e796abd965f16c680954549
b4526f01a2c9d7b727620f3ba6c848f19bd9210650ae62593249d7a4e0522ad48aea559d4f6a1f3f
6ae9953bed7c947e273d455a4982523dd90640b0a25572ae8c5e064e39807ddf778af96afd492999
acc40919a4d4f601h
</code></pre>

<p>As you can see, the first octet of the calculated <code>d</code> is 0x17, but the first octet of the <code>d</code> you provided is 0x9B.</p>

<hr>

<p>Also, you might want to do something like the following:</p>

<pre class=""lang-c++ prettyprint-override""><code>unsigned char data[20] = { 0x6F, 0x9F, 0x07, 0x04, 0xE2, 0x1A, 0xF7, 0xB8, 0xB2, 0x4F,
                           0x8D, 0x66, 0x49, 0xA1, 0x09, 0xA7, 0xB2, 0x22, 0x3C, 0xF9 };

const size_t req = signer.MaxSignatureLength(sizeof(data));
byte signature[req];
const size_t used = signer.SignMessage(prng, data, 20, signature);
// Trim 'signature' to 'used'
</code></pre>
","1056","<c++><rsa><digital-signature><crypto++>","5","1","2","2016-04-08 21:28:00","","0","","608639","","2016-04-08 02:19:32","2012-08-08 17:55:23",""
"48783809","ECDSA sign with BouncyCastle and verify with Crypto++","<p>Here is the Java code:</p>

<p></p>

<pre><code>public static String sign(String data) throws Exception {
    KeyPair keyPair = loadKeyPair(System.getProperty(""user.dir""), ""ECDSA"");
    Signature signature = Signature.getInstance(""SHA256withECDSA"", ""BC"");
    signature.initSign(keyPair.getPrivate(), new SecureRandom());

    byte[] message = data.getBytes();
    signature.update(message);

    byte[] sigBytes = signature.sign();        
    String signatureStr = new BigInteger(1, sigBytes).toString(16);
    return signatureStr;
}
</code></pre>

<p>Then the C++ Code to verify signatures</p>

<p></p>

<pre><code>bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; signature )
{
    bool result = false;

    // Hexa encoding version, more readable
    std::string decodedSignature;
    StringSource(signature, true,
                    new HexDecoder(
                       new StringSink(decodedSignature)));

    StringSource(decodedSignature+message, true,
                    new SignatureVerificationFilter(ECDSA&lt;ECP,SHA256&gt;::Verifier(key),
                       new ArraySink((byte*)&amp;result, sizeof(result))));

    return result;
}
</code></pre>

<p>I was thinking that I need to encode my signature to hexa but it didn't resolve my problem. I've written a c++ version of the sign method using crypto++ and it's verified. so why when I use the java code, the signature is not verified. Thanks</p>
","<blockquote>
  <p>... why when I use the java code, the signature is not verified?</p>
</blockquote>

<p>OpenSSL and Java use an ASN.1/DER encoding for the signature, and Crypto++ uses IEEE P1363's format for the signature.</p>

<ul>
<li>ASN.1: <code>SEQUENCE ::= { r INTEGER, s INTEGER }</code></li>
<li>P1363: <code>[byte array r][byte array s]</code></li>
</ul>

<p>You need to convert between the formats. Crypto++ provides <code>DSAConvertSignatureFormat</code> to convert between formats. There is an example on the Crypto++ wiki at <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm#OpenSSL_and_Java_Interop"" rel=""nofollow noreferrer"">Elliptic Curve Digital Signature Algorithm | OpenSSL and Java Interop</a>.</p>

<p>Here is the Crypto++ code from the wiki. It uses OpenSSL and its command line tools rather than Java. There is no material difference because OpenSSL and Java output signatures in ASN.1/DER format.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""files.h""
#include ""dsa.h""
#include ""sha.h""
#include ""hex.h""

#include &lt;iostream&gt;

using namespace CryptoPP;

int main(int argc, char* argv[])
{
    // Load DER encoded public key
    FileSource pubKey(""secp256k1-pub.der"", true /*binary*/);
    ECDSA&lt;ECP, SHA1&gt;::Verifier verifier(pubKey);

    // Java or OpenSSL created signature. It is ANS.1
    //   SEQUENCE ::= { r INTEGER, s INTEGER }.
    const byte derSignature[] = {
        0x30, 0x44, 0x02, 0x20, 0x08, 0x66, 0xc8, 0xf1,
        0x6f, 0x15, 0x00, 0x40, 0x8a, 0xe2, 0x1b, 0x40,
        0x56, 0x28, 0x9c, 0x17, 0x8b, 0xca, 0x64, 0x99,
        0x37, 0xdc, 0x35, 0xad, 0xad, 0x60, 0x18, 0x4d,
        0x63, 0xcf, 0x4a, 0x06, 0x02, 0x20, 0x78, 0x4c,
        0xb7, 0x0b, 0xa3, 0xff, 0x4f, 0xce, 0xd3, 0x01,
        0x27, 0x5c, 0x6c, 0xed, 0x06, 0xf0, 0xd7, 0x63,
        0x6d, 0xc6, 0xbe, 0x06, 0x59, 0xe8, 0xc3, 0xa5,
        0xce, 0x8a, 0xf1, 0xde, 0x01, 0xd5
    };

    // P1363 'r || s' concatenation. The size is 32+32 due to field
    // size for r and s in secp-256. It is not 20+20 due to SHA-1.
    SecByteBlock signature(verifier.SignatureLength());
    DSAConvertSignatureFormat(signature, signature.size(), DSA_P1363,
                              derSignature, sizeof(derSignature), DSA_DER);

    // Message ""Attack at dawn!""
    const byte message[] = {
        0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x20, 0x61,
        0x74, 0x20, 0x64, 0x61, 0x77, 0x6e, 0x21, 0x0a
    };

    // https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm
    bool result = verifier.VerifyMessage(message, sizeof(message), signature, signature.size());
    if (result)
        std::cout &lt;&lt; ""Verified message"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""Failed to verify message"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And here is the result of running the test program.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Signature (64):
0866C8F16F1500408AE21B4056289C178BCA649937DC35ADAD60184D63CF4A06784CB70BA3FF4FCE
D301275C6CED06F0D7636DC6BE0659E8C3A5CE8AF1DE01D5
Verified message
</code></pre>

<hr>

<p>Here is the setup I used to reproduce <code>cat test.txt | openssl dgst -ecdsa-with-SHA1 -sign sample.key -keyform DER &gt; test.sig</code>. It is from @DivB's question at <a href=""https://stackoverflow.com/q/17316178/608639"">ECDSA sign with OpenSSL, verify with Crypto++</a>.</p>

<pre class=""lang-none prettyprint-override""><code>$ cat test.txt
Attack at dawn!

$ hexdump -C test.txt
00000000  41 74 74 61 63 6b 20 61  74 20 64 61 77 6e 21 0a  |Attack at dawn!.|
00000010

# Create private key in PEM format
$ openssl ecparam -name secp256k1 -genkey -noout -out secp256k1-key.pem

$ cat secp256k1-key.pem
-----BEGIN EC PRIVATE KEY-----
MHQCAQEEIO0D5Rjmes/91Nb3dHY9dxmbM7gVfxmB2+OVuLmWMbGXoAcGBSuBBAAK
oUQDQgAEgVNEuirUNCEVdf7nLSBUgU1GXLrtIBeglIbK54s91HlWKOKjk4CkJ3/B
wGAfcYKa+DgJ2IUQSD15K1T/ghM9eQ==
-----END EC PRIVATE KEY-----

# Convert private key to ASN.1/DER format
$ openssl ec -in secp256k1-key.pem -inform PEM -out secp256k1-key.der -outform DER

$ dumpasn1 secp256k1-key.der
  0 116: SEQUENCE {
  2   1:   INTEGER 1
  5  32:   OCTET STRING
       :     ED 03 E5 18 E6 7A CF FD D4 D6 F7 74 76 3D 77 19
       :     9B 33 B8 15 7F 19 81 DB E3 95 B8 B9 96 31 B1 97
 39   7:   [0] {
 41   5:     OBJECT IDENTIFIER secp256k1 (1 3 132 0 10)
       :     }
 48  68:   [1] {
 50  66:     BIT STRING
       :       04 81 53 44 BA 2A D4 34 21 15 75 FE E7 2D 20 54
       :       81 4D 46 5C BA ED 20 17 A0 94 86 CA E7 8B 3D D4
       :       79 56 28 E2 A3 93 80 A4 27 7F C1 C0 60 1F 71 82
       :       9A F8 38 09 D8 85 10 48 3D 79 2B 54 FF 82 13 3D
       :       79
       :     }
       :   }

# Create public key from private key
$ openssl ec -in secp256k1-key.der -inform DER -pubout -out secp256k1-pub.der -outform DER

$ dumpasn1 secp256k1-pub.der
  0  86: SEQUENCE {
  2  16:   SEQUENCE {
  4   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 13   5:     OBJECT IDENTIFIER secp256k1 (1 3 132 0 10)
       :     }
 20  66:   BIT STRING
       :     04 81 53 44 BA 2A D4 34 21 15 75 FE E7 2D 20 54
       :     81 4D 46 5C BA ED 20 17 A0 94 86 CA E7 8B 3D D4
       :     79 56 28 E2 A3 93 80 A4 27 7F C1 C0 60 1F 71 82
       :     9A F8 38 09 D8 85 10 48 3D 79 2B 54 FF 82 13 3D
       :     79
       :   }

# Sign the message using the private key
$ cat test.txt | openssl dgst -ecdsa-with-SHA1 -sign secp256k1-key.der -keyform DER &gt; test.sig

# Dump the signature as hex
$ hexdump -C test.sig
00000000  30 44 02 20 08 66 c8 f1  6f 15 00 40 8a e2 1b 40  |0D. .f..o..@...@|
00000010  56 28 9c 17 8b ca 64 99  37 dc 35 ad ad 60 18 4d  |V(....d.7.5..`.M|
00000020  63 cf 4a 06 02 20 78 4c  b7 0b a3 ff 4f ce d3 01  |c.J.. xL....O...|
00000030  27 5c 6c ed 06 f0 d7 63  6d c6 be 06 59 e8 c3 a5  |'\l....cm...Y...|
00000040  ce 8a f1 de 01 d5                                 |......|
00000046

# Dump the signature as ASN.1/DER
$ dumpasn1 test.sig
  0  68: SEQUENCE {
  2  32:   INTEGER
       :     08 66 C8 F1 6F 15 00 40 8A E2 1B 40 56 28 9C 17
       :     8B CA 64 99 37 DC 35 AD AD 60 18 4D 63 CF 4A 06
 36  32:   INTEGER
       :     78 4C B7 0B A3 FF 4F CE D3 01 27 5C 6C ED 06 F0
       :     D7 63 6D C6 BE 06 59 E8 C3 A5 CE 8A F1 DE 01 D5
       :   }
</code></pre>
","1056","<java><c++><bouncycastle><crypto++><ecdsa>","2","2","2","2019-10-07 04:34:06","48784823","1","","608639","","2018-02-16 08:26:31","2018-02-14 09:36:16",""
"48783809","ECDSA sign with BouncyCastle and verify with Crypto++","<p>Here is the Java code:</p>

<p></p>

<pre><code>public static String sign(String data) throws Exception {
    KeyPair keyPair = loadKeyPair(System.getProperty(""user.dir""), ""ECDSA"");
    Signature signature = Signature.getInstance(""SHA256withECDSA"", ""BC"");
    signature.initSign(keyPair.getPrivate(), new SecureRandom());

    byte[] message = data.getBytes();
    signature.update(message);

    byte[] sigBytes = signature.sign();        
    String signatureStr = new BigInteger(1, sigBytes).toString(16);
    return signatureStr;
}
</code></pre>

<p>Then the C++ Code to verify signatures</p>

<p></p>

<pre><code>bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; signature )
{
    bool result = false;

    // Hexa encoding version, more readable
    std::string decodedSignature;
    StringSource(signature, true,
                    new HexDecoder(
                       new StringSink(decodedSignature)));

    StringSource(decodedSignature+message, true,
                    new SignatureVerificationFilter(ECDSA&lt;ECP,SHA256&gt;::Verifier(key),
                       new ArraySink((byte*)&amp;result, sizeof(result))));

    return result;
}
</code></pre>

<p>I was thinking that I need to encode my signature to hexa but it didn't resolve my problem. I've written a c++ version of the sign method using crypto++ and it's verified. so why when I use the java code, the signature is not verified. Thanks</p>
","<p>By the way, another way around your problem (especially allowing you to avoid the command line) would be to modify the Java code in order to have a way to produce the R and S values, as well as to reproduce the DER encoded values.</p>

<p>For example you can extract the R and S values from the Java signature using those:</p>

<pre><code>public static BigInteger extractR(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startR + 2, startR + 2 + lengthR));
}

public static BigInteger extractS(byte[] signature) throws Exception {
    int startR = (signature[1] &amp; 0x80) != 0 ? 3 : 2;
    int lengthR = signature[startR + 1];
    int startS = startR + 2 + lengthR;
    int lengthS = signature[startS + 1];
    return new BigInteger(Arrays.copyOfRange(signature, startS + 2, startS + 2 + lengthS));
}
</code></pre>

<p>These methods are notably <a href=""https://github.com/google/wycheproof/blob/9cd6c67936e659f64e451244c98512cf4094e52b/java/com/google/security/wycheproof/testcases/EcdsaTest.java#L572:L588"" rel=""nofollow noreferrer"">used in Wycheproof</a> to play around with the BigIntegers directly.</p>

<p>These can allow you to reconstruct the P1363 encoding used by CryptoPP in Java, but be careful not to forget the left padding with 0s of the bytearrays. (Otherwise you may have problems when the R or S bytearray is smaller than the expected length.)</p>

<p>And you can also reconstruct the DER encoded signature from big integers using:</p>

<pre><code>public static byte[] derSign(BigInteger r, BigInteger s) throws Exception {
    byte[] rb = r.toByteArray();
    byte[] sb = s.toByteArray();
    int off = (2 + 2) + rb.length;
    int tot = off + (2 - 2) + sb.length;
    byte[] der = new byte[tot + 2];
    der[0] = 0x30;
    der[1] = (byte) (tot &amp; 0xff);
    der[2 + 0] = 0x02;
    der[2 + 1] = (byte) (rb.length &amp; 0xff);
    System.arraycopy(rb, 0, der, 2 + 2, rb.length);
    der[off + 0] = 0x02;
    der[off + 1] = (byte) (sb.length &amp; 0xff);
    System.arraycopy(sb, 0, der, off + 2, sb.length);
    return der;
}
</code></pre>

<p>As you can see, these methods might be translated into C++ code, since they are really basic byte manipulations, but that's another story ;)</p>
","1056","<java><c++><bouncycastle><crypto++><ecdsa>","2","1","2","2019-10-07 04:34:06","48784823","1","","608639","","2018-02-16 08:26:31","2018-02-14 09:36:16",""
"45461770","Storing the IV with the ciphertext Crypto++ CBC AES encryption","<p>I'm trying to encrypt(and decrypt after) a file using AES in CBC mode and Crypto++ library</p>

<p>Here's what I already did:</p>

<pre><code>using namespace CryptoPP;
AutoSeededRandomPool rnd;

//generating the key and iv
SecByteBlock key(AES::MAX_KEYLENGTH);
rnd.GenerateBlock(key, key.size());
byte iv[AES::BLOCKSIZE];
rnd.GenerateBlock(iv, AES::BLOCKSIZE);
</code></pre>

<p>To encrypt a file,I open it in binary mode,and dump the content to a string :</p>

<pre><code>std::ifstream fin(file_path, std::ios::binary);
if (!fin)
{
    std::cout &lt;&lt; ""error"";
}
std::ostringstream ostrm;
ostrm &lt;&lt; fin.rdbuf();
std::string plaintext(ostrm.str());
fin.close();
</code></pre>

<p>Then,I encrypt this string using the key and iv previously generated:</p>

<pre><code>std::string ciphertext;

AES::Encryption aesEncryption(key, CryptoPP::AES::MAX_KEYLENGTH);
CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()), plaintext.length() + 1);
stfEncryptor.MessageEnd();
</code></pre>

<p>Now,i want to write the encrypted string to a file,and store the IV with it,since the iv doesn't need to be kept secret,ideally at the beginning or the end of the ciphertext</p>

<p>Here comes the problem : the IV is a byte array and the ciphertext is a string,do i need to convert one of the two to another type,or can i just do :</p>

<pre><code>std::ofstream fdout(file_path2, std::ios::binary);
if (!fdout)
{
    std::cout &lt;&lt; ""error"";
}
fdout &lt;&lt; iv;
fdout &lt;&lt; ciphertext;
fdout.close();
</code></pre>

<p>When i will try to decrypt this file,how can i extract the iv and ciphertext separately ? The IV is 16 Bytes long,but here i'm completely lost and i don't know how to do.</p>
","<p>The <code>StringSink</code> has the following documentation:</p>

<blockquote>
  <p>A <code>StringSink</code> serves as a destination for string data in the pipelining paradigm. <strong>The data can be binary or ASCII.</strong></p>
</blockquote>

<p>So although it is a string, it is internally an <em>octet- or byte string</em>. So yes, you can just save the IV and ciphertext that way.</p>

<p>But to be sure, just compare the length of the result with the IV size (16 bytes) and ciphertext size together. If it is equal then you should be fine.</p>
","1053","<c++><encryption><aes><crypto++><initialization-vector>","1","0","2","2017-08-03 21:37:13","","2","1","608639","","2017-08-03 20:42:13","2017-08-02 13:08:27",""
"45461770","Storing the IV with the ciphertext Crypto++ CBC AES encryption","<p>I'm trying to encrypt(and decrypt after) a file using AES in CBC mode and Crypto++ library</p>

<p>Here's what I already did:</p>

<pre><code>using namespace CryptoPP;
AutoSeededRandomPool rnd;

//generating the key and iv
SecByteBlock key(AES::MAX_KEYLENGTH);
rnd.GenerateBlock(key, key.size());
byte iv[AES::BLOCKSIZE];
rnd.GenerateBlock(iv, AES::BLOCKSIZE);
</code></pre>

<p>To encrypt a file,I open it in binary mode,and dump the content to a string :</p>

<pre><code>std::ifstream fin(file_path, std::ios::binary);
if (!fin)
{
    std::cout &lt;&lt; ""error"";
}
std::ostringstream ostrm;
ostrm &lt;&lt; fin.rdbuf();
std::string plaintext(ostrm.str());
fin.close();
</code></pre>

<p>Then,I encrypt this string using the key and iv previously generated:</p>

<pre><code>std::string ciphertext;

AES::Encryption aesEncryption(key, CryptoPP::AES::MAX_KEYLENGTH);
CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()), plaintext.length() + 1);
stfEncryptor.MessageEnd();
</code></pre>

<p>Now,i want to write the encrypted string to a file,and store the IV with it,since the iv doesn't need to be kept secret,ideally at the beginning or the end of the ciphertext</p>

<p>Here comes the problem : the IV is a byte array and the ciphertext is a string,do i need to convert one of the two to another type,or can i just do :</p>

<pre><code>std::ofstream fdout(file_path2, std::ios::binary);
if (!fdout)
{
    std::cout &lt;&lt; ""error"";
}
fdout &lt;&lt; iv;
fdout &lt;&lt; ciphertext;
fdout.close();
</code></pre>

<p>When i will try to decrypt this file,how can i extract the iv and ciphertext separately ? The IV is 16 Bytes long,but here i'm completely lost and i don't know how to do.</p>
","<blockquote>
  <p>Storing the IV with the ciphertext Crypto++ CBC AES encryption</p>
</blockquote>

<p>Some of the code you are using is a bit unusual to me. I'll pick a couple things out and show you some of the Crypto++ ways.</p>

<p>Before you begin, take a look at <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipelines</a> and <a href=""https://www.cryptopp.com/wiki/Pumping_Data"" rel=""nofollow noreferrer"">Pumping Data</a> on the Crypto++ wiki. Remember that data flows from sources to sinks. In between the data encounters filters which transform the data.</p>

<hr>

<pre><code>std::ifstream fin(file_path, std::ios::binary);
if (!fin)
{
    std::cout &lt;&lt; ""error"";
}
std::ostringstream ostrm;
ostrm &lt;&lt; fin.rdbuf();
std::string plaintext(ostrm.str());
fin.close();
</code></pre>

<p>A Crypto++ <code>FileSource</code> has a constructor that takes a <code>std::istream</code>. You could do something like the following. Also see <a href=""https://www.cryptopp.com/wiki/FileSource"" rel=""nofollow noreferrer""><code>FileSource</code></a> on the Crypto++ wiki.</p>

<pre><code>std::ifstream fin(file_path, std::ios::binary);
FileSource source(fin, true /*pump all*/, NULLPTR);
...
</code></pre>

<hr>

<blockquote>
<pre><code>AES::Encryption aesEncryption(key, CryptoPP::AES::MAX_KEYLENGTH);
CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);
</code></pre>
</blockquote>

<p><code>ExternalCipher</code> are for the FIPS DLL. You can use them without the DLL, but they exist for the DLL. Usually you use:</p>

<pre><code> CBC_Mode&lt;AES&gt;::Encryption encryptor;
</code></pre>

<p>Also, you usually want to avoid a <em>confidentiality-only</em> mode. Typically you want to use an <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> mode of operation. It provides <em>confidentiality and authenticity</em>.</p>

<p>Crypto++ provides CCM, EAX and GCM authenticated encryption modes of operation. OCB and EAX are very good choices. EAX mode is documented at <a href=""https://www.cryptopp.com/wiki/EAX_Mode"" rel=""nofollow noreferrer"">EAX Mode</a> on the Crypto++ wiki. OCB is not available at the moment. We are getting ready to check-in OCB mode.</p>

<hr>

<blockquote>
  <p>Now,i want to write the encrypted string to a file,and store the IV with it,since the iv doesn't need to be kept secret,ideally at the beginning or the end of the ciphertext</p>
</blockquote>

<p>Use something like the following. I did not compile it, so you will need to fix the typos.</p>

<pre><code>AutoSeededRandomPool prng;
SecByteBlock key(AES::MAXIMUM_KEYLENGTH), iv(AES::BLOCKSIZE);

RandomNumberSource rs1(prng, AES::MAXIMUM_KEYLENGTH, new ArraySink(key, key.size()));
RandomNumberSource rs2(prng, AES::BLOCKSIZE, new ArraySink(iv, iv.size()));

HexEncoder encoder(new FileSink(std::cout));

std::cout &lt;&lt; ""Key: "";
encoder.Put(key, key.size());
encoder.MessageEnd();
std::cout &lt;&lt; std::endl;

std::cout &lt;&lt; ""IV: "";
encoder.Put(iv, iv.size());
encoder.MessageEnd();
std::cout &lt;&lt; std::endl;

EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

// Plaintext message
std::string message;

// Output file
FileSink file(""message.enc"");

// Source wrappers
ArraySource as(iv, iv.size(), true,
    new Redirector(file));

// Source wrapper
StringSource ss(message, true,
    new StreamTransformationFilter(encryptor,
       new Redirector(file)));
</code></pre>

<hr>

<blockquote>
  <p>When i will try to decrypt this file,how can i extract the iv and ciphertext separately ? </p>
</blockquote>

<p>Use something like the following.</p>

<pre><code>// Key is from previous example. It cannot change
SecByteBlock key(AES::MAXIMUM_KEYLENGTH), iv(AES::BLOCKSIZE);    
FileSource fs(""message.enc"", false /* DO NOT Pump All */);

// Attach new filter
ArraySink as(iv, iv.size());
fs.Attach(new Redirector(as));
fs.Pump(AES::BLOCKSIZE);  // Pump first 16 bytes

EAX&lt;AES&gt;::Decryption decryptor;
decryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

// Detach previously attached filter, attach new filter
ByteQueue queue;
fs.Detach(new StreamTransformationFilter(decryptor, new Redirector(queue)));
fs.PumpAll();  // Pump remainder of bytes
</code></pre>

<p>The encrypted data will be in a <code>ByteQueue</code>. It does <em>not</em> provide C++ iterator-like functionality, like a pointer and a size. To get the data out of the <code>ByteQueue</code> you transfer it or copy it to another filter or a sink:</p>

<pre><code>SecByteBlock block(queue.MaxRetrievable());
ArraySink sink(block, block.size());
queue.TransferTo(sink);
</code></pre>

<p>You can get the data out of the <code>ByteQueue</code> and put it in a<code>std::string</code> with:</p>

<pre><code>std::string recovered;
StringSink sink(recovered);
queue.TransferTo(sink);
</code></pre>

<p>And you can print the IV recovered from the file with:</p>

<pre><code>HexEncoder encoder(new FileSink(std::cout));

std::cout &lt;&lt; ""IV: "";
encoder.Put(iv, iv.size());
encoder.MessageEnd();
std::cout &lt;&lt; std::endl;
</code></pre>
","1053","<c++><encryption><aes><crypto++><initialization-vector>","1","1","2","2017-08-03 21:37:13","","2","1","608639","","2017-08-03 20:42:13","2017-08-02 13:08:27",""
"14058920","Crypto++ in Eclipse Undefined Reference","<p>I'm trying to use Crypto++ for my Eclipse C++ project using the MinGW toolchain. Problem is, whenever I try to use crypto functions, I get flooded with ""undefined reference"" errors. Has anyone experienced this before? This is the what I'm getting (truncated):</p>

<p>UPDATED</p>

<pre><code>g++ -L ""C:\\Libraries\\crypto++\\Win32\\DLL_Output\\Debug"" -lpthread -lcryptopp -o ""Grum Net.exe"" ""src\\Vault\\VaultNode.o"" ""src\\User.o"" ""src\\Grum Net.o"" 
src\Grum Net.o: In function `ZN8CryptoPP18HashTransformationD2Ev':
C:/Libraries/crypto++/cryptlib.h:531: undefined reference to `vtable for CryptoPP::HashTransformation'
src\Grum Net.o: In function `ZN8CryptoPP18HashTransformationC2Ev':
C:/Libraries/crypto++/cryptlib.h:531: undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
C:/Libraries/crypto++/cryptlib.h:531: undefined reference to `vtable for CryptoPP::HashTransformation'
src\Grum Net.o: In function `ZN8CryptoPP31IteratedHashWithStaticTransformIjNS_10EnumToTypeINS_9ByteOrderELi0EEELj64ELj16ENS_5Weak13MD5ELj0ELb0EE4InitEv':
C:/Libraries/crypto++/iterhash.h:90: undefined reference to `CryptoPP::Weak1::MD5::InitState(unsigned int*)'
src\Grum Net.o:Grum Net.cpp:(.rdata$_ZTVN8CryptoPP5Weak13MD5E[__ZTVN8CryptoPP5Weak13MD5E]+0x18): undefined reference to `CryptoPP::IteratedHashBase&lt;unsigned int, CryptoPP::HashTransformation&gt;::Update(unsigned char const*, unsigned int)'
src\Grum Net.o:Grum Net.cpp:(.rdata$_ZTVN8CryptoPP5Weak13MD5E[__ZTVN8CryptoPP5Weak13MD5E]+0x1c): undefined reference to `CryptoPP::IteratedHashBase&lt;unsigned int, CryptoPP::HashTransformation&gt;::CreateUpdateSpace(unsigned int&amp;)'
src\Grum Net.o:Grum Net.cpp:(.rdata$_ZTVN8CryptoPP5Weak13MD5E[__ZTVN8CryptoPP5Weak13MD5E]+0x24): undefined reference to `CryptoPP::IteratedHashBase&lt;unsigned int, CryptoPP::HashTransformation&gt;::Restart()'
src\Grum Net.o:Grum Net.cpp:(.rdata$_ZTVN8CryptoPP5Weak13MD5E[__ZTVN8CryptoPP5Weak13MD5E]+0x44): undefined reference to `CryptoPP::IteratedHashBase&lt;unsigned int, CryptoPP::HashTransformation&gt;::TruncatedFinal(unsigned char*, unsigned int)'
src\Grum Net.o:Grum Net.cpp:(.rdata$_ZTVN8CryptoPP5Weak13MD5E[__ZTVN8CryptoPP5Weak13MD5E]+0x4c): undefined reference to `CryptoPP::HashTransformation::TruncatedVerify(unsigned char const*, unsigned int)'
</code></pre>
","<p>your <code>-L</code> is inside of your quotes. Have you tried:</p>

<pre><code>g++ -L ""C:\\Libraries\\crypto++"" -lpthread -o ""Grum Net.exe"" ""src\\VaultNode.o"" ""src\\User.o"" ""src\\Grum Net.o"" 
</code></pre>

<p>Now that g++ know where to look for your libs, you'll also need to specify which libs from the <em>C:\Libraries\crypto++</em> directory you'd like to use:</p>

<pre><code>g++ -L ""C:\\Libraries\\crypto++"" -lcryptolib1 -lcryptolib2 -lpthread -o ""Grum Net.exe"" ""src\\VaultNode.o"" ""src\\User.o"" ""src\\Grum Net.o"" 
</code></pre>
","1044","<c++><eclipse><g++><crypto++>","1","1","1","2012-12-27 18:24:16","14058935","0","","1000229","","2012-12-27 18:24:16","2012-12-27 17:48:50",""
"33051972","Encrypt data with RSA public key in Java and decrypt in Crypto++","<p>I'm trying to encrypt data with RSA public key in Java and decrypt it in Crypto++. It results in an error:</p>

<blockquote>
  <p>""RSA/EME-PKCS1-v1_5: ciphertext length of 24 doesn't match the required length of 128 for this key""</p>
</blockquote>

<p>What am I doing wrong?</p>

<p><strong><em>Java</em></strong>:</p>

<pre class=""lang-java prettyprint-override""><code>String cipher = Encryption.encryptStrRSA(txt, pubKeyk);

public static String encryptStrRSA(String str, PublicKey pubKey)
    throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
    IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {

    Cipher cipher = Cipher.getInstance(""RSA/NONE/PKCS1Padding"", ""BC"");
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);

    byte[] encryptedAesKey = cipher.doFinal(str.getBytes());
    String cipherStr = new String(encryptedAesKey);

    System.out.println(cipherStr);
    return cipherStr;
}

public static PublicKey strToPublicKey(String key64) throws GeneralSecurityException {
    byte[] data = Base64.getDecoder().decode(key64);
    X509EncodedKeySpec spec = new X509EncodedKeySpec(data);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    return fact.generatePublic(spec);
}

public static String publicKeyToStr(PublicKey publ) throws GeneralSecurityException {
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    X509EncodedKeySpec spec = fact.getKeySpec(publ, X509EncodedKeySpec.class);
    return Base64.getEncoder().encode(spec.getEncoded()).toString();
}
</code></pre>

<p><strong><em>Crypto++</em></strong>:</p>

<pre class=""lang-c++ prettyprint-override""><code>using namespace CryptoPP;

RSAES_PKCS1v15_Decryptor priv(privString);
StringSource( cipher, cipherSize, true, new 
Base64Decoder( new PK_DecryptorFilter(randPool, priv, new StringSink(sdata))));
</code></pre>
","<p>It is dangerous to use String instances for keeping binary data -- you should use byte[] instead.</p>

<p>Additionally, in the java code there is no Base64 wrapping of the resulting ciphertext, but in the C++ code it is being unwrapped from Base64.</p>

<p>Modified your code to return byte[] and encode the result using Base64:</p>

<pre><code>public static byte[] encryptRSA(String str, PublicKey pubKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {
    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"", ""BC"");
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);
    return cipher.doFinal(str.getBytes());
}

String cipher = Base64.getEncoder().encodeToString(Encryption.encryptRSA(""0123456789ABCDEF"", pubKeyk));
</code></pre>

<p>Then you can decrypt in Crypto++ the same way you did.</p>

<p>Good luck!</p>
","1040","<java><c++><interop><rsa><crypto++>","1","1","1","2015-10-15 10:52:03","","3","4","608639","","2015-10-11 19:20:36","2015-10-10 08:33:39",""
"45142246","How to compile Crypto++ cross platform on osx","<p>My desktop application has dependency on the Crypto++ library. First I tried to install Crypto++ from Brew and link with my application. First error has arrived when I tried to run application to an older mac (with older cpu, which I suppose does not have AESNI instructions). it crashed with:</p>

<pre><code>Crashed Thread:        56

Exception Type:        EXC_BAD_INSTRUCTION (SIGILL)
Exception Codes:       0x0000000000000001, 0x0000000000000000
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Illegal instruction: 4
Termination Reason:    Namespace SIGNAL, Code 0x4
Terminating Process:   exc handler [0]
</code></pre>

<p>After that I compiled crytpo++ with an older mac. so far all was good. but recently I encountered same error with even older cpu.</p>

<p>Basically the question is: is there a way to compile Crypto++ so the deployed lib would be cross platform ?</p>
","<blockquote>
  <p>... the question is: is there a way to compile crypto++ so the deployed lib would be cross platform ?</p>
</blockquote>

<p>Yes, but only within the processor family.</p>

<p>The problem is likely the use of a newer instruction, but not AES. There are three reasons I suspect it.</p>

<p>First, the makefile adds <code>-march=native</code> when building. This gets you all the CPU features for the machine you are building on.</p>

<p>Second, the newer instruction could be from SSE4, AVX or BMI because you compile on a newer Mac; while your older Mac can only handle, say, SSE4 in the case of a Core2 Duo.</p>

<p>Third, AES is guarded at runtime, so those particular machine instructions are not executed if the CPU lacks AESNI. However, other instructions the compiler may emit, like AVX or BMI, are not guarded.</p>

<hr>

<p>Here's my OS X test environment:</p>

<ul>
<li>MacBook, early 2010

<ul>
<li>Intel Core2 Duo</li>
<li>OS X 10.9</li>
<li>SSE 4.1</li>
</ul></li>
<li>MacBook Pro, late 2012

<ul>
<li>Intel Core i7</li>
<li>OS X 10.8</li>
<li>SSE 4.1, SSE 4.2, AESNI, RDRAND, AVX</li>
</ul></li>
</ul>

<p>Based on the list above, if I compile on the MacBook Pro (SSE 4.1, SSE 4.2, AESNI, RDRAND, AVX) for the MacBook (SSE 4.1), then I need to limit the target machine to SSE 4.1. Otherwise, Clang is sure to emit instructions the older MacBook cannot handle.</p>

<p>To limit the target machine in Crypto++:</p>

<pre><code>git clone https://github.com/weidai11/cryptopp.git
cd cryptopp

export CXXFLAGS=""-DNDEBUG -g2 -O2 -DDISABLE_NATIVE_ARCH=1 -msse2 -msse3 -mssse3 -msse4.1""
make -j 4
</code></pre>

<p><code>-DDISABLE_NATIVE_ARCH</code> is a relatively new addition. I don't believe its in Crypto++ 5.6.5. You need Master for it, and it will be in the upcoming Crypto++ 6.0.</p>

<p>If you need to remove the makefile code that adds <code>-march=native</code>, then its not hard to find. Open <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile"" rel=""nofollow noreferrer""><code>GNUmakefile</code></a>, and delete this block around line 200:</p>

<pre><code># BEGIN_NATIVE_ARCH
# Guard use of -march=native (or -m{32|64} on some platforms)
# Don't add anything if -march=XXX or -mtune=XXX is specified
ifeq ($(DISABLE_NATIVE_ARCH),0)
ifeq ($(findstring -march,$(CXXFLAGS)),)
ifeq ($(findstring -mtune,$(CXXFLAGS)),)
   ifeq ($(GCC42_OR_LATER)$(IS_NETBSD),10)
      CXXFLAGS += -march=native
   else ifneq ($(CLANG_COMPILER)$(INTEL_COMPILER),00)
      CXXFLAGS += -march=native
   else
     # GCC 3.3 and ""unknown option -march=""
     # Ubuntu GCC 4.1 compiler crash with -march=native
     # NetBSD GCC 4.8 compiler and ""bad value (native) for -march= switch""
     # Sun compiler is handled below
     ifeq ($(SUN_COMPILER)$(IS_X64),01)
       CXXFLAGS += -m64
     else ifeq ($(SUN_COMPILER)$(IS_X86),01)
       CXXFLAGS += -m32
     endif # X86/X32/X64
   endif
endif  # -mtune
endif  # -march
endif  # DISABLE_NATIVE_ARCH
# END_NATIVE_ARCH
</code></pre>

<p>After that, you should be able to run your binary on both machines.</p>

<p>The GNUmakefile is kind of a monstrosity. There's a lot to it. We documented it at <a href=""https://www.cryptopp.com/wiki/GNUmakefile"" rel=""nofollow noreferrer"">GNUmakefile</a> on the Crypto++ wiki.</p>

<hr>

<p>You can also limit the machine you are compiling for using <code>-mtune</code>. For example:</p>

<pre><code>$ export CXXFLAGS=""-DNDEBUG -g2 -O2 -mtune=core2""
$ make -j 3
g++ -DNDEBUG -g2 -O2 -mtune=core2 -fPIC -pipe -c cryptlib.cpp
g++ -DNDEBUG -g2 -O2 -mtune=core2 -fPIC -pipe -c cpu.cpp
g++ -DNDEBUG -g2 -O2 -mtune=core2 -fPIC -pipe -c integer.cpp
...
</code></pre>

<hr>

<blockquote>
  <p>First I tried to install Crypto++ from Brew and link with my application...</p>
</blockquote>

<p>I don't use Brew, so I don't know how to to set <code>CXXFLAGS</code> when using it. Hopefully one of the Homebrew folks will provide some information about it.</p>

<p>Maybe <a href=""https://stackoverflow.com/q/10921133/608639"">Build and install Brew apps that are x86_64 instead of i386?</a> and <a href=""https://stackoverflow.com/q/9186033/608639"">Using Homebrew with alternate GCC</a> will help.</p>

<hr>

<p>It is also possible you are compiling on an x86_64 machine, and then trying to run it on an i386 machine. If that is the case, then it likely won't work. </p>

<p>You may be able to build a fat library with the following, and it may work on both machines. Notice the addition of <code>-arch x86_64 -arch i386</code>.</p>

<pre><code>export CXXFLAGS=""-DNDEBUG -g2 -O2 -DDISABLE_NATIVE_ARCH=1 -arch x86_64 -arch i386 -msse2 -msse3 -mssse3 -msse4.1""
make -j 4
</code></pre>

<p>You might also be interested in <a href=""https://www.cryptopp.com/wiki/IOS_(Command_Line)"" rel=""nofollow noreferrer"">iOS (Command Line)</a> on the Crypto++ wiki. It goes into some detail about fat binaries in the context of iOS. The same concepts apply to OS X.</p>

<hr>

<p>If you encounter a compile error for <code>-msse4.1</code> or <code>-msse4.2</code>, then you may need <code>-msse4_1</code> or <code>-msse4_2</code>. Different compilers accept (or expect) slightly different syntax.</p>

<hr>

<p>For comparison using Linux, below is the difference in CPU capabilities between a Core2 Duo and a 3rd gen Core i5. Notice the Core i5 has SSE4.2 and AVX, while the Core2 Duo does not. AVX makes a heck of a difference, and compilers aggressively use the instruction set.</p>

<p>On OS X, you want to run <code>sysctl machdep.cpu.features</code>. I showed the one for my old MacBook from early 2010.</p>

<p><strong><em>Core i5</em></strong>:</p>

<pre><code>$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 58
model name      : Intel(R) Core(TM) i5-3230M CPU @ 2.60GHz
...
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca 
cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc
rep_good nopl xtopology nonstop_tsc cpuid pni pclmulqdq ssse3 cx16 sse4_1 
sse4_2 x2apic popcnt aes xsave avx rdrand hypervisor lahf_lm
</code></pre>

<p><strong><em>Core2 Duo</em></strong>:</p>

<pre><code>$ cat /proc/cpuinfo
processor       : 0
vendor_id       : GenuineIntel
cpu family      : 6
model           : 23
model name      : Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz
...
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca
cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm
constant_tsc arch_perfmon pebs bts rep_good nopl aperfmperf pni dtes64
monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm
</code></pre>

<p><strong><em>Core Duo (MacBook)</em></strong>:</p>

<pre><code>$ sudo sysctl machdep.cpu.features
machdep.cpu.features: FPU VME DE PSE TSC MSR PAE MCE CX8 APIC SEP MTRR PGE
MCA CMOV PAT PSE36 CLFSH DS ACPI MMX FXSR SSE SSE2 SS HTT TM PBE SSE3 DTES64
MON DSCPL VMX SMX EST TM2 SSSE3 CX16 TPR PDCM SSE4.1
</code></pre>
","1039","<c++><macos><homebrew><crypto++>","1","1","1","2017-07-18 10:33:22","45150181","0","","608639","","2017-07-17 18:02:09","2017-07-17 10:49:13",""
"27461633","Qt and Crypto++ linker errors","<p>I'm getting a bunch of LNK2001 and LNK2019 errors with Qt 5.4 and Crypto++. Tried both static and dynamic linking. Libs are in the project folder and .pro file has something like:</p>

<pre><code>win32: LIBS += -L$$PWD/ -lcryptlib

INCLUDEPATH += $$PWD/include

DEPENDPATH += $$PWD/include

win32:!win32-g++: PRE_TARGETDEPS += $$PWD/cryptlib.lib

else:win32-g++: PRE_TARGETDEPS += $$PWD/libcryptlib.a
</code></pre>

<p>As soon as I reference something from cryptopp header files I get 15+ linker errors. Also, lib was built with the same MSVC2013 compiler I'm using for Qt.</p>

<p>Any ideas?</p>

<p>EDIT: Yeah, sorry for not including the errors.</p>

<pre><code>main.obj:-1: error: LNK2019: unresolved external symbol ""public: __cdecl CryptoPP::Algorithm::Algorithm(bool)"" (??0Algorithm@CryptoPP@@QEAA@_N@Z) referenced in function ""public: __cdecl CryptoPP::BlockTransformation::BlockTransformation(void)"" (??0BlockTransformation@CryptoPP@@QEAA@XZ)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const *,unsigned __int64,class CryptoPP::NameValuePairs const &amp;)"" (?SetKey@SimpleKeyingInterface@CryptoPP@@UEAAXPEBE_KAEBVNameValuePairs@2@@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::SimpleKeyingInterface::GetNextIV(class CryptoPP::RandomNumberGenerator &amp;,unsigned char *)"" (?GetNextIV@SimpleKeyingInterface@CryptoPP@@UEAAXAEAVRandomNumberGenerator@2@PEAE@Z)

main.obj:-1: error: LNK2019: unresolved external symbol ""protected: unsigned __int64 __cdecl CryptoPP::SimpleKeyingInterface::ThrowIfInvalidIVLength(int)"" (?ThrowIfInvalidIVLength@SimpleKeyingInterface@CryptoPP@@IEAA_KH@Z) referenced in function ""public: virtual void __cdecl CryptoPP::BlockOrientedCipherModeBase::Resynchronize(unsigned char const *,int)"" (?Resynchronize@BlockOrientedCipherModeBase@CryptoPP@@UEAAXPEBEH@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned int __cdecl CryptoPP::BlockTransformation::OptimalDataAlignment(void)const "" (?OptimalDataAlignment@BlockTransformation@CryptoPP@@UEBAIXZ)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char *,unsigned char const *,unsigned __int64)"" (?ProcessLastBlock@StreamTransformation@CryptoPP@@UEAAXPEAEPEBE_K@Z)

main.obj:-1: error: LNK2019: unresolved external symbol ""void * __cdecl CryptoPP::AlignedAllocate(unsigned __int64)"" (?AlignedAllocate@CryptoPP@@YAPEAX_K@Z) referenced in function ""public: unsigned char * __cdecl CryptoPP::AllocatorWithCleanup&lt;unsigned char,1&gt;::allocate(unsigned __int64,void const *)"" (?allocate@?$AllocatorWithCleanup@E$00@CryptoPP@@QEAAPEAE_KPEBX@Z)

main.obj:-1: error: LNK2019: unresolved external symbol ""void __cdecl CryptoPP::AlignedDeallocate(void *)"" (?AlignedDeallocate@CryptoPP@@YAXPEAX@Z) referenced in function ""public: void __cdecl CryptoPP::AllocatorWithCleanup&lt;unsigned char,1&gt;::deallocate(void *,unsigned __int64)"" (?deallocate@?$AllocatorWithCleanup@E$00@CryptoPP@@QEAAXPEAX_K@Z)

main.obj:-1: error: LNK2019: unresolved external symbol ""void * __cdecl CryptoPP::UnalignedAllocate(unsigned __int64)"" (?UnalignedAllocate@CryptoPP@@YAPEAX_K@Z) referenced in function ""public: unsigned char * __cdecl CryptoPP::AllocatorWithCleanup&lt;unsigned char,1&gt;::allocate(unsigned __int64,void const *)"" (?allocate@?$AllocatorWithCleanup@E$00@CryptoPP@@QEAAPEAE_KPEBX@Z)

main.obj:-1: error: LNK2019: unresolved external symbol ""void __cdecl CryptoPP::UnalignedDeallocate(void *)"" (?UnalignedDeallocate@CryptoPP@@YAXPEAX@Z) referenced in function ""public: void __cdecl CryptoPP::AllocatorWithCleanup&lt;unsigned char,1&gt;::deallocate(void *,unsigned __int64)"" (?deallocate@?$AllocatorWithCleanup@E$00@CryptoPP@@QEAAXPEAX_K@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::BlockOrientedCipherModeBase::UncheckedSetKey(unsigned char const *,unsigned int,class CryptoPP::NameValuePairs const &amp;)"" (?UncheckedSetKey@BlockOrientedCipherModeBase@CryptoPP@@UEAAXPEBEIAEBVNameValuePairs@2@@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::CBC_Encryption::ProcessData(unsigned char *,unsigned char const *,unsigned __int64)"" (?ProcessData@CBC_Encryption@CryptoPP@@UEAAXPEAEPEBE_K@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const *,unsigned int,class CryptoPP::NameValuePairs const &amp;)"" (?UncheckedSetKey@Base@Rijndael@CryptoPP@@UEAAXPEBEIAEBVNameValuePairs@3@@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual void __cdecl CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const *,unsigned char const *,unsigned char *)const "" (?ProcessAndXorBlock@Enc@Rijndael@CryptoPP@@UEBAXPEBE0PEAE@Z)

main.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned __int64 __cdecl CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const *,unsigned char const *,unsigned char *,unsigned __int64,unsigned int)const "" (?AdvancedProcessBlocks@Enc@Rijndael@CryptoPP@@UEBA_KPEBE0PEAE_KI@Z)
</code></pre>

<p>I'm using downloaded Qt, and in about section of Qt Creator it says it's compiled with MSVC 2010 32bit.</p>
","","1036","<c++><qt><linker><crypto++>","1","","0","2014-12-13 20:22:43","","22","","999943","","2014-12-13 20:22:43","2014-12-13 17:27:19",""
"45186444","How to read and write an AES key to and from a file?","<p>I am trying to write an AES key to a file then read it later. I'm using the Crypto++ library, and the AES key is initialized as follows. Below, <code>byte</code> is a typedef of <code>unsigned char</code>.</p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH]
</code></pre>

<p>The key is 32 bytes long. I try to write it into a file with this:</p>

<pre><code>FILE* file = fopen(""C:\\key"", ""wb"");
fwrite(key, 1, sizeof(key), file);
fclose(file);
</code></pre>

<p>And recover it using:</p>

<pre><code>FILE* read_file = fopen(""C:\\key"", ""rb"");
fseek(read_file, 0, SEEK_END);
long int size = ftell(read_file);
fclose(read_file);

read_file = fopen(""C:\\key"", ""rb"");
unsigned char * in = (unsigned char *)malloc(size);
byte readed_key = fread(in, sizeof(unsigned char), size, read_file);
fclose(read_file);
if (key == readed_key)
{
    cout &lt;&lt; ""this is the right key !"";
}
free(in);
</code></pre>

<p>However, I get an error message:</p>

<blockquote>
  <p>incompatible operand types : byte* and byte.</p>
</blockquote>

<p>I don't understand why, since <code>readed_key</code> and <code>key</code> are initialized with <code>byte</code> and not <code>byte*</code>.</p>

<hr>

<p>I looked at <a href=""https://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a> on the Crypto++ wiki, and the key is generated as follow. I figured out that I was just creating the key (not generating it):</p>

<pre><code>SecByteBlock key(0x00, AES::MAX_KEYLENGTH);
rnd.GenerateBlock( key, key.size() );
</code></pre>

<p>With that I can't use </p>

<pre><code>std::vector&lt;byte&gt; key(32);
rnd.GenerateBlock(key, key.size());
</code></pre>

<p>Because <code>rnd.Generateblock</code> can't convert <code>std::vector&lt; byte &gt; into byte*</code></p>

<p>This is driving me crazy....</p>
","<p><code>key</code> is an <em>array</em> of <code>byte</code>, i.e. its type is <code>byte[32]</code> (assuming that <code>CryptoPP::AES::MAX_KEYLENGTH</code> is an integer constant equal to 32). <code>byte[N]</code> decays to <code>byte*</code> in certain contexts, including during comparisons using <code>==</code> such as in your <code>if (key == readed_key)</code> line.</p>

<p><code>readed_key</code> is defined to be <code>byte</code>, which is not the same.</p>

<p>Also, you're using <a href=""https://linux.die.net/man/3/fread"" rel=""nofollow noreferrer""><code>fread (3)</code></a> incorrectly; the return value is the number of items read, not the data that was read. The data you read is stored in the <code>in</code> array. You need to compare each element of <code>key</code> against each element of <code>in</code>, to check that the keys are the same.</p>

<p><em>Edit:</em> Thanks to <a href=""https://stackoverflow.com/users/611117/vasek"">@vasek</a> for pointing out that the comparison should be written</p>

<pre><code>if (memcmp(key, in, size) == 0) { /* keys are equal */ }
</code></pre>

<hr>

<p>Since you're using C++ (The Crypto++ library is a C++ library), you could use higher-level abstractions to avoid manual memory management with <code>malloc</code>/<code>free</code> and make the code easier to work with:</p>

<p><a href=""http://coliru.stacked-crooked.com/a/9ebc1a553b68e709"" rel=""nofollow noreferrer"">live example</a>:</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using byte = char;

int main() {
    std::vector&lt;byte&gt; key(32);
    // Code would go here to generate the `key`
    // ...

    {
        std::ofstream out(""C:\\key"", std::ios::out | std::ios::binary);
        out.write(key.data(), key.size());
    } // file is closed automatically here!

    std::vector&lt;byte&gt; read_key(32);
    {
        std::ifstream in(""C:\\key"", std::ios::in | std::ios::binary);
        in.read(read_key.data(), read_key.size());
    }

    if (key == read_key) {
        std::cout &lt;&lt; ""Keys are equal!\n"";
    }

    return 0;    
}
</code></pre>

<p>Here, the <code>std::vector&lt;byte&gt;</code> handles the memory allocation (you just tell it the size in the constructor; use <code>.data()</code> to get a pointer to the contents; comparison of the full key comes for free with <code>std::vector</code>'s <code>operator==</code>), and the C++ iostreams <code>read</code>/<code>write</code> is a little easier to follow compared to <code>fread</code>/<code>fwrite</code>. You can still do the seek to determine the key size; I'll leave that as an <a href=""http://en.cppreference.com/w/cpp/io/basic_fstream"" rel=""nofollow noreferrer"">exercise to the reader</a>.</p>
","1032","<c++><arrays><vector><file-io><crypto++>","1","2","2","2018-03-09 13:28:22","45216095","2","","608639","","2017-07-20 12:55:33","2017-07-19 09:29:57",""
"45186444","How to read and write an AES key to and from a file?","<p>I am trying to write an AES key to a file then read it later. I'm using the Crypto++ library, and the AES key is initialized as follows. Below, <code>byte</code> is a typedef of <code>unsigned char</code>.</p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH]
</code></pre>

<p>The key is 32 bytes long. I try to write it into a file with this:</p>

<pre><code>FILE* file = fopen(""C:\\key"", ""wb"");
fwrite(key, 1, sizeof(key), file);
fclose(file);
</code></pre>

<p>And recover it using:</p>

<pre><code>FILE* read_file = fopen(""C:\\key"", ""rb"");
fseek(read_file, 0, SEEK_END);
long int size = ftell(read_file);
fclose(read_file);

read_file = fopen(""C:\\key"", ""rb"");
unsigned char * in = (unsigned char *)malloc(size);
byte readed_key = fread(in, sizeof(unsigned char), size, read_file);
fclose(read_file);
if (key == readed_key)
{
    cout &lt;&lt; ""this is the right key !"";
}
free(in);
</code></pre>

<p>However, I get an error message:</p>

<blockquote>
  <p>incompatible operand types : byte* and byte.</p>
</blockquote>

<p>I don't understand why, since <code>readed_key</code> and <code>key</code> are initialized with <code>byte</code> and not <code>byte*</code>.</p>

<hr>

<p>I looked at <a href=""https://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a> on the Crypto++ wiki, and the key is generated as follow. I figured out that I was just creating the key (not generating it):</p>

<pre><code>SecByteBlock key(0x00, AES::MAX_KEYLENGTH);
rnd.GenerateBlock( key, key.size() );
</code></pre>

<p>With that I can't use </p>

<pre><code>std::vector&lt;byte&gt; key(32);
rnd.GenerateBlock(key, key.size());
</code></pre>

<p>Because <code>rnd.Generateblock</code> can't convert <code>std::vector&lt; byte &gt; into byte*</code></p>

<p>This is driving me crazy....</p>
","<blockquote>
  <p>How to read and write an AES key to and from a file?</p>
</blockquote>

<p>I'm going to avoid your code since its mostly C code. Andrew pointed out some of the problems with it, so there's no sense in rehashing it. Instead I'll show you the Crypto++ and C++ way of doing things. I'll also discuss <code>SecByteBlock</code> a little.</p>

<hr>

<p>Here's the Crypto++ way to read the data into a byte array using sources and sinks. You can read more about them at <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipelines</a> in the Crypto++ wiki.</p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH];
FileSource fs(""C:\\key.bin"", true, new ArraySink(key, sizeof(key)));
</code></pre>

<p>Here's the Crypto++ way to write data to a file using sources and sinks.</p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH];
ArraySource as(key, sizeof(key), true, new FileSink(""C:\\key.bin""));
</code></pre>

<hr>

<p>Here's the C++ way to read the data into a byte array using streams. Its taken from <a href=""https://stackoverflow.com/q/5420317/608639"">Reading and writing binary file</a></p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH];
std::ifstream fs(""C:\\key.bin"", std::ios::binary);
fs.read(key, sizeof(key));
</code></pre>

<p>Here's the C++ way to write data to a file using streams.</p>

<pre><code>byte key[CryptoPP::AES::MAX_KEYLENGTH];
std::ofstream fs(""C:\\key.bin"", std::ios::binary);
fs.write(key, sizeof(key));
</code></pre>

<hr>

<blockquote>
<pre><code>std::vector&lt;byte&gt; key(32);
rnd.GenerateBlock(key, key.size());
</code></pre>
  
  <p>Because rnd.Generateblock can't convert <code>std::vector&lt; byte &gt;</code> into
  <code>byte*</code>. This is driving me crazy....</p>
</blockquote>

<p>Here, you need a non-const pointer to the first element. Take the address of the first element in your vector. The same would apply to a <code>std::string</code>.</p>

<pre><code>std::vector&lt;byte&gt; key(32);
rnd.GenerateBlock(&amp;key[0], key.size());
</code></pre>

<hr>

<p>Since the key is sensitive, you should use a <code>SecByteBlock</code>. It zeroizes the key from memory once you are done using it.</p>

<p>Generally speaking, if the information is sensitive, then you want to use a <code>SecBlock&lt;T&gt;</code>. In the case of <code>SecByteBlock</code>, <code>T</code> is a <code>byte</code> and there's a typedef for <code>SecByteBlock</code>. But you can make a <code>SecBlock&lt;T&gt;</code> out of anything.</p>

<p>Here's the Crypto++ way to read the data into a <code>SecByteBlock</code> using sources and sinks.</p>

<pre><code>SecByteBlock key(AES::MAX_KEYLENGTH);
FileSource fs(""C:\\key.bin"", true, new ArraySink(key.begin(), key.size()));
</code></pre>

<hr>

<p><code>SecByteBlock</code> <em>can</em> initialize elements to a known value upon construction. You are using the feature below. All elements are initialized to <code>0x00</code>.</p>

<pre><code>SecByteBlock key(0x00, AES::MAX_KEYLENGTH);
rnd.GenerateBlock(key, key.size());
</code></pre>

<p>Since you are overwriting the elements immediately with random data, you <em>should</em> forgo initialization. Just ask for an uninitialized block of memory:</p>

<pre><code>SecByteBlock key(AES::MAX_KEYLENGTH);
rnd.GenerateBlock(key, key.size());
</code></pre>
","1032","<c++><arrays><vector><file-io><crypto++>","1","3","2","2018-03-09 13:28:22","45216095","2","","608639","","2017-07-20 12:55:33","2017-07-19 09:29:57",""
"28427500","MT / MD mismatch when compiling cryptopp despite no library dependencies","<p>I'm currently trying to compile a static 64 bit version of cryptopp (more precisely, the cryptlib VS project) using MS Visual Studio 2013 on a Windows 8.1 machine. Since it is a static release build, I've set the Runtime Library to Multithreaded (/MT).</p>

<p>However the linker throws several of the following errors:</p>

<pre><code>error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in adhoc.obj
</code></pre>

<p>In most of the similar cases I've found here and on google, this was caused by one library setting /MT and another one setting /MD. The weird thing about this case is that the linker does not include any libraries (except maybe some Visual-Studio-internal magic) and there are no additional include directories. The linker command line assembles as:</p>

<pre><code>/OUT:""build\x64\static_release\cryptlib64.lib"" /LTCG /MACHINE:X64 /NOLOGO
</code></pre>

<p>In the project file, I couldn't find any other &lt;RuntimeLibrary&gt; settings except for those on project level so I'd assume there is no .cpp file which has a /MD switch.</p>

<p>To sum it up, this means my library defines /MT, but something which is used by crytlib internally seems having /MD defined. Is there a way to find out what object/cpp/define/library/whatever has that switch defined?</p>
","<p><s>Cleaning the solution and then rebuilding might help. It seems the linker is still trying to use the old object files (before you applied /MT).</s></p>
","1027","<c++><visual-c++><visual-studio-2013><linker-errors><crypto++>","1","1","3","2015-10-24 01:57:44","28431672","3","","808151","","2015-02-10 09:11:09","2015-02-10 08:56:07",""
"28427500","MT / MD mismatch when compiling cryptopp despite no library dependencies","<p>I'm currently trying to compile a static 64 bit version of cryptopp (more precisely, the cryptlib VS project) using MS Visual Studio 2013 on a Windows 8.1 machine. Since it is a static release build, I've set the Runtime Library to Multithreaded (/MT).</p>

<p>However the linker throws several of the following errors:</p>

<pre><code>error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in adhoc.obj
</code></pre>

<p>In most of the similar cases I've found here and on google, this was caused by one library setting /MT and another one setting /MD. The weird thing about this case is that the linker does not include any libraries (except maybe some Visual-Studio-internal magic) and there are no additional include directories. The linker command line assembles as:</p>

<pre><code>/OUT:""build\x64\static_release\cryptlib64.lib"" /LTCG /MACHINE:X64 /NOLOGO
</code></pre>

<p>In the project file, I couldn't find any other &lt;RuntimeLibrary&gt; settings except for those on project level so I'd assume there is no .cpp file which has a /MD switch.</p>

<p>To sum it up, this means my library defines /MT, but something which is used by crytlib internally seems having /MD defined. Is there a way to find out what object/cpp/define/library/whatever has that switch defined?</p>
","<p>This linker diagnostic is a 100% accurate hint that you are in fact linking .obj or .lib files that were built wrong.  Almost always .lib files that you don't know about because you didn't have to explicitly list them as Additional Dependencies.  MSVC++ makes it pretty easy to specify link dependencies without having to use the setting, like using Add Reference or <code>#pragma comment(lib, ""yadayada.lib"")</code> in a source code file.  Very convenient of course, but not so visible when you are trying to troubleshoot linker errors like this.</p>

<p>It is easily diagnosable however, the linker has an option to show you what it is actually linking.  Use Project + Properties, Linker, Command Line and add the <code>/VERBOSE</code> option.  The linker now gets very chatty to the Output window, showing you every .lib file it loads and what symbols it uses from the .lib file.</p>

<p>The .lib name should be enough of a hint to know where to start looking, you ought to know the #include from there.  Whether you can <em>really</em> build with /MT is still up in the air, if it is an import library of a DLL then the odds dwindle rapidly.  Avoid forcing it, having more than one copy of the CRT in a process is fraught with trouble.</p>
","1027","<c++><visual-c++><visual-studio-2013><linker-errors><crypto++>","1","3","3","2015-10-24 01:57:44","28431672","3","","808151","","2015-02-10 09:11:09","2015-02-10 08:56:07",""
"28427500","MT / MD mismatch when compiling cryptopp despite no library dependencies","<p>I'm currently trying to compile a static 64 bit version of cryptopp (more precisely, the cryptlib VS project) using MS Visual Studio 2013 on a Windows 8.1 machine. Since it is a static release build, I've set the Runtime Library to Multithreaded (/MT).</p>

<p>However the linker throws several of the following errors:</p>

<pre><code>error LNK2038: mismatch detected for 'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in adhoc.obj
</code></pre>

<p>In most of the similar cases I've found here and on google, this was caused by one library setting /MT and another one setting /MD. The weird thing about this case is that the linker does not include any libraries (except maybe some Visual-Studio-internal magic) and there are no additional include directories. The linker command line assembles as:</p>

<pre><code>/OUT:""build\x64\static_release\cryptlib64.lib"" /LTCG /MACHINE:X64 /NOLOGO
</code></pre>

<p>In the project file, I couldn't find any other &lt;RuntimeLibrary&gt; settings except for those on project level so I'd assume there is no .cpp file which has a /MD switch.</p>

<p>To sum it up, this means my library defines /MT, but something which is used by crytlib internally seems having /MD defined. Is there a way to find out what object/cpp/define/library/whatever has that switch defined?</p>
","<blockquote>
  <p>The weird thing about this case is that the linker does not include any libraries (except maybe some Visual-Studio-internal magic) </p>
</blockquote>

<p>There is a good chance that is where its coming from if you are certian its not something in your gear.</p>

<p>If Dynamic C++ Runtime Linking is an option for you, then you might consider using it for Crypto++. To ease the troubles of converting Crypto++ to Visual Studio 2010 (and above) and converting to <code>/MD</code> and <code>/MDd</code>, you can use <a href=""http://cryptopp.com/wiki/Visual_studio#Dynamic_C.2B.2B_Runtime_Linking"" rel=""nofollow noreferrer""><code>vs2010-dynamic.zip</code></a>. Just unpack it over top of the existing Crypto++ sources.</p>

<hr>

<p>Also see <a href=""https://stackoverflow.com/q/14714877"">Mismatch Detected for 'RuntimeLibrary' and Crypto++</a> on Stack Overflow.</p>
","1027","<c++><visual-c++><visual-studio-2013><linker-errors><crypto++>","1","0","3","2015-10-24 01:57:44","28431672","3","","808151","","2015-02-10 09:11:09","2015-02-10 08:56:07",""
"13824992","Order independent hashing","<p>I'm creating keys for key-value data by taking a few (&lt;10) pieces of information that identify the data and producing one hash from them combined. For this, I've been using CryptoPP's <code>SHA256::Update</code> function, which lets you add pieces at a time:
    </p>

<pre><code>#include ""sha.h""
...
byte outputBuf[CryptoPP::SHA256::DIGESTSIZE];
CryptoPP::SHA256 hash;
hash.Update(pData1, lenData1); // pData* can point to int, double or std::string
hash.Update(pData2, lenData2);
...
hash.Final(outputBuf);
</code></pre>

<p>I've noticed that the order of the calls to <code>Update</code> matters (i.e. if you change the order of the two <code>Update</code> statements, you'll get a different hash). I would like this to be order independent instead. So:</p>

<ul>
<li>Does CryptoPP offer a way to do this?</li>
<li>If not, can you suggest an alternative approach? So far I think using <code>xor</code> to combine the  parameters would work. One problem is that if two pieces of data are the same, they'll cancel out. Can you foresee problems with this?</li>
</ul>
","<p>The comment saying that xor will increase the number of collisions is only true, if you consider <code>{1, 2}</code> and <code>{2, 1}</code> to be <em>different</em> inputs. I guess, you don't, as otherwise you wouldn't want an order-independent hash. So <code>h({1, 2}) = h({2, 1})</code> is no collision as you're providing <em>the same input</em>.</p>

<p>The simplest solution is sorting and than using your favorite hash function. It is as <em>secure</em> as your hash function (confirm on crypto.stackexchange.com if you care).</p>

<p>Xoring hashes is definitely a bad idea as two equal elements cancel out. Adding them is much better, but with two equal elements, the least significant bit will be zero (with four such elements, two bits will be zero, etc.). This may be acceptable.</p>

<p>Note that any such method is pretty insecure as it allows finding collisions much faster (proof upon request). You may or may not need security, but don't try to invent a secure method, as it's practically impossible (every well-known hash function has many man-months of analysis behind it).</p>
","1026","<c++><hash><crypto++>","1","2","1","2017-06-07 14:24:36","","9","","","","","2012-12-11 17:05:43",""
"21862706","crypto++ fails with string from a file?","<p>I am using version 5.6.2 of the cryptopp library, and attempting to do some simple AES encryption of a string which I then send to a file and then attempt read again.</p>

<p>My calls all work fine when I encrypt and decrypt a string in the same function. But it's saving the thing to a file that is not working. </p>

<p>My unit test is like this:</p>

<pre><code>TEST_METHOD(TestEncryptedFile)
{
    using namespace std;
    HardWareInfo info;
    std::ofstream outfile(_T(""test.dat""), std::ios_base::binary);
    const char* cyphert = info.ToEncryptedString();
    if (!outfile.bad())
    {
        outfile &lt;&lt; cyphert;
        outfile.close();
    }

    std::ifstream infile(_T(""test.dat""), std::ios_base::binary);
    if (!infile.bad())
    {
        stringstream sstr;
        sstr &lt;&lt; infile.rdbuf();
        infile.close();

        std::string ss = sstr.str();
        HardWareInfo deserializd;
        deserializd.FromEncryptedString(ss.c_str());
    }
}
</code></pre>

<p>But it fails with a thrown exception (The second one) stating something about an invalid PKCS block:</p>

<pre><code>if (length != s)
    throw InvalidCiphertext(""StreamTransformationFilter: ciphertext length is not a multiple of block size"");
m_cipher.ProcessData(space, inString, s);
if (m_padding == PKCS_PADDING)
{
    byte pad = space[s-1];
    if (pad &lt; 1 || pad &gt; s || std::find_if(space+s-pad, space+s, std::bind2nd(std::not_equal_to&lt;byte&gt;(), pad)) != space+s)
        throw InvalidCiphertext(""StreamTransformationFilter: invalid PKCS #7 block padding found"");
    length = s-pad;
}
</code></pre>

<p>My code calling the decrypt routines is like this:</p>

<pre><code>std::string ciphertext = cyphertext
std::string decryptedtext;

CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(decryptedtext));
stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(ciphertext.c_str()), ciphertext.size());
stfDecryptor.MessageEnd();
</code></pre>

<p>Any idea what I'm doing wrong?</p>

<p>Thanks!</p>
","<blockquote>
  <p>deserializd.FromEncryptedString(ss.c_str());</p>
</blockquote>

<p>As @Iridium said, this is the problem. It may not be your only issue, though (we would need to see more code).</p>

<p>You need to change that function signature:</p>

<pre><code>deserializd.FromEncryptedString(ss.c_str(), ss.length());
</code></pre>
","1025","<c++><encryption><crypto++>","1","0","1","2014-04-17 06:16:45","","7","","","","","2014-02-18 18:46:40",""
"51808431","'byte' : ambiguous symbol error when using of Crypto++ and Windows SDK","<p>In <em>Visual Studio 2012</em>, I'm trying to encrypt a file with Crypto++ library with <code>AES</code> encryption and <code>CBC</code> mode as following :</p>

<pre><code>#include &lt;Windows.h&gt;
#include ""aes.h""
#include ""modes.h""
#include ""files.h""
#include &lt;Shlwapi.h&gt;

using namespace CryptoPP;

INT main(INT argc, CHAR *argv[])
{
    CHAR szKey[16] = {0};
    CHAR szInitVector[AES::DEFAULT_KEYLENGTH] = {0};

    StrCpyA(szKey, ""qqwweeff88lliioo"");
    StrCpyA(szInitVector, ""eerrttooppkkllhh"");

    CBC_Mode&lt;AES&gt;::Encryption encryptor((byte*)szKey, AES::DEFAULT_KEYLENGTH, (byte*)szInitVector);
    FileSource fs(""in.txt"", true, new StreamTransformationFilter(encryptor, new FileSink(""out.aes"")));

    return 0;
}
</code></pre>

<p>In <code>Qt</code> it does work!, But here I wondered why got the following <code>error</code> :</p>

<pre><code>error C2872: 'byte' : ambiguous symbol
could be 'c:\program files (x86)\windows kits\8.0\include\shared\rpcndr.h(164) : unsigned char byte'
or 'z:\cryptography\app_aesencryption\aes headers\config.h(237) : CryptoPP::byte'
</code></pre>

<p>Due to prevent of <code>ambiguous symbol</code> error, even I cast bellow statement with <code>CryptoPP::byte*</code> :</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption encryptor((CryptoPP::byte*)szKey, AES::DEFAULT_KEYLENGTH, (CryptoPP::byte*)szInitVector);
</code></pre>

<p>I didn't get any error for <code>'byte' : ambiguous symbol</code>, But It give me many <code>errors</code> as :</p>

<pre><code>error LNK 2038
</code></pre>

<p>By the way, I linked <code>.lib</code> file of Crypto++, So I think this error is Unlikely for this.
Is last <code>error</code> related to <code>CryptoPP::byte*</code>? Is there any solution?</p>
","<p>The first problem solved with changing <code>byte*</code> to <code>CryptoPP::byte*</code> :</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption encryptor((CryptoPP::byte*)szKey, AES::DEFAULT_KEYLENGTH, (CryptoPP::byte*)szInitVector);
</code></pre>

<p>But to solving the second problem (<code>error LNK 2038</code>) :</p>

<p>This is related to <code>link error</code>, Every body that using of <code>crypto++</code> in <em>Visual Studio</em> may have this problem.</p>

<p>First I was download library from bellow link for <em>visual studio</em> in which containt <code>.sln</code> (VS Solution) :</p>

<ul>
<li><blockquote>
  <p><a href=""https://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">https://www.cryptopp.com/#download</a></p>
</blockquote></li>
<li><p>I build the library via <kbd>Batch Build</kbd> as <code>cryptlib</code> project in both state (<code>Debug|Win32</code> and <code>Release|Win32</code>)</p></li>
<li>Because I used of <code>Debug</code> mode, I linked <code>cryptlib.lib</code> in <code>cryptopp700\Win32\Output\Debug</code> in dependencies section.</li>
<li>Also add dependencies for header files...</li>
</ul>

<p>But I forgot something in project properties :</p>

<p>Finally, I set Runtime Library option to <kbd>Multi-threaded Debug (/MTd)</kbd></p>

<p>This option is in :</p>

<ul>
<li><p><kbd>Project Properties</kbd></p></li>
<li><p><kbd>Configuration Properties</kbd></p></li>
<li><p><kbd>C/C++</kbd></p></li>
<li><p><kbd>Code Generation</kbd></p></li>
<li><p><kbd>Runtime Library</kbd></p></li>
</ul>
","990","<c++><winapi><encryption><crypto++><cbc-mode>","0","0","2","2018-08-13 18:05:54","51809082","20","1","4134099","","2018-08-13 09:30:49","2018-08-12 11:36:26",""
"51808431","'byte' : ambiguous symbol error when using of Crypto++ and Windows SDK","<p>In <em>Visual Studio 2012</em>, I'm trying to encrypt a file with Crypto++ library with <code>AES</code> encryption and <code>CBC</code> mode as following :</p>

<pre><code>#include &lt;Windows.h&gt;
#include ""aes.h""
#include ""modes.h""
#include ""files.h""
#include &lt;Shlwapi.h&gt;

using namespace CryptoPP;

INT main(INT argc, CHAR *argv[])
{
    CHAR szKey[16] = {0};
    CHAR szInitVector[AES::DEFAULT_KEYLENGTH] = {0};

    StrCpyA(szKey, ""qqwweeff88lliioo"");
    StrCpyA(szInitVector, ""eerrttooppkkllhh"");

    CBC_Mode&lt;AES&gt;::Encryption encryptor((byte*)szKey, AES::DEFAULT_KEYLENGTH, (byte*)szInitVector);
    FileSource fs(""in.txt"", true, new StreamTransformationFilter(encryptor, new FileSink(""out.aes"")));

    return 0;
}
</code></pre>

<p>In <code>Qt</code> it does work!, But here I wondered why got the following <code>error</code> :</p>

<pre><code>error C2872: 'byte' : ambiguous symbol
could be 'c:\program files (x86)\windows kits\8.0\include\shared\rpcndr.h(164) : unsigned char byte'
or 'z:\cryptography\app_aesencryption\aes headers\config.h(237) : CryptoPP::byte'
</code></pre>

<p>Due to prevent of <code>ambiguous symbol</code> error, even I cast bellow statement with <code>CryptoPP::byte*</code> :</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption encryptor((CryptoPP::byte*)szKey, AES::DEFAULT_KEYLENGTH, (CryptoPP::byte*)szInitVector);
</code></pre>

<p>I didn't get any error for <code>'byte' : ambiguous symbol</code>, But It give me many <code>errors</code> as :</p>

<pre><code>error LNK 2038
</code></pre>

<p>By the way, I linked <code>.lib</code> file of Crypto++, So I think this error is Unlikely for this.
Is last <code>error</code> related to <code>CryptoPP::byte*</code>? Is there any solution?</p>
","<blockquote>
  <p>'byte' : ambiguous symbol error when using of Crypto++</p>
</blockquote>

<p>We had to move <code>byte</code> from global namespace to <code>CryptoPP</code> namespace due to C++17 and <code>std::byte</code>. The change occurred at <a href=""https://github.com/weidai11/cryptopp/commit/00f9818b5d8e"" rel=""nofollow noreferrer"">Commit 00f9818b5d8e</a>, which was part of the Crypto++ 6.0 release.</p>

<p>Crypto++ used to put <code>byte</code> in the global namespace for compatibility with Microsoft SDKs. Without the global byte then you would encounter <em><code>'byte' : ambiguous symbol error</code></em> again.</p>

<p>The error you are seeing is because you used <code>using namespace CryptoPP;</code> <strong><em>and</em></strong> the Microsoft kits still put a <code>byte</code> in the global namespace. The error did not surface under Qt because Qt does not put a byte in the global namespace.</p>

<p>There are several work-arounds discussed at <a href=""https://www.cryptopp.com/wiki/Std::byte"" rel=""nofollow noreferrer""><code>std::byte</code></a> on the Crypto++ wiki.</p>

<p>Incidentally, Microsoft kit code will break when it encounters a C++17 compiler and <code>std::byte</code> because of Microsoft's global <code>byte</code>. You will encounter the same error when using the Windows kits. Ironically, Microsoft employees authored C++ <code>std::byte</code>. Also see <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0298r0.pdf"" rel=""nofollow noreferrer"">PR0298R0, A byte type definition</a>.</p>
","990","<c++><winapi><encryption><crypto++><cbc-mode>","0","2","2","2018-08-13 18:05:54","51809082","20","1","4134099","","2018-08-13 09:30:49","2018-08-12 11:36:26",""
"39104141","AES Decryption only in Crypto++","<p>I have a method based on the crypto++ examples (but with hardcoded key and iv) in which i encrypt and decrypt a string, which works fine. Now when i comment out the encryption code and set the ciphertext to the Output that i receive from the encryption part i only get nonsense instead of the string i started with. Here is my code (with the encryption part commented out):</p>

<pre><code>byte iv[CryptoPP::AES::BLOCKSIZE];
byte key[CryptoPP::AES::MAX_KEYLENGTH];
std::string strKey = ""F5C3DD6EA4F2AE1713F4B9B21FD0011CCECB5CA8858F313B5EA3E85CD1F6E70E"";
std::string striv = ""DEA43ED679566B66FD2B5126149F34A"";

int x = 0;
for (unsigned int i = 0; i &lt; strKey.length(); i += 2) {
    std::string bytestring = strKey.substr(i, 2);
    key[x] = (char)strtol(bytestring.c_str(), NULL, 16);
    x++;
}
int y = 0;
for (unsigned int i = 0; i &lt; striv.length(); i += 2) {
    std::string bytestring = striv.substr(i, 2);
    iv[y] = (char)strtol(bytestring.c_str(), NULL, 16);
    y++;
}

std::string plain = ""test mode"";
std::string cipher, encoded, recovered;
cipher = ""F190D36A0FEEF07C5B"";

/*
//print key
encoded.clear();
CryptoPP::StringSource(key, sizeof(key), true,
    new CryptoPP::HexEncoder(new CryptoPP::StringSink(encoded)));
std::cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; std::endl;

//print iv
encoded.clear();
CryptoPP::StringSource(iv, sizeof(iv), true,
    new CryptoPP::HexEncoder(new CryptoPP::StringSink(encoded)));
std::cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; std::endl;

try
{
    std::cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; std::endl;

    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption en;
    en.SetKeyWithIV(key, sizeof(key), iv);
    CryptoPP::StringSource(plain, true, new CryptoPP::StreamTransformationFilter(en, new CryptoPP::StringSink(cipher)));
    std::cout &lt;&lt; ""cipher: "" &lt;&lt; cipher;
}
catch (const std::exception&amp; e)
{
    std::cout &lt;&lt; ""CryptInit Exception: "" &lt;&lt; e.what() &lt;&lt; std::endl;
}

encoded.clear();
CryptoPP::StringSource(cipher, true,
    new CryptoPP::HexEncoder(new CryptoPP::StringSink(encoded)));
std::cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; std::endl;
//*/
try
{
    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Decryption de;
    de.SetKeyWithIV(key, sizeof(key), iv);

    CryptoPP::StringSource s(cipher, true,
        new CryptoPP::StreamTransformationFilter(de, new CryptoPP::StringSink(recovered)));

    std::cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; std::endl;

}
catch (const std::exception&amp; e)
{
    std::cout &lt;&lt; ""CryptInit Exception: "" &lt;&lt; e.what() &lt;&lt; std::endl;
}
</code></pre>

<p>This is the Output i receive: ├─Ö.k░®Y♫µµâî¶¸ƒ├v</p>

<p>For reproduction purposes here are the required includes:</p>

<pre><code>#include &lt;cryptopp\aes.h&gt;
#include &lt;cryptopp\filters.h&gt;
#include &lt;cryptopp\modes.h&gt;
#include &lt;cryptopp\hex.h&gt;
#include &lt;cryptopp\cryptlib.h&gt;
</code></pre>
","<pre><code>cipher = ""F190D36A0FEEF07C5B"";
</code></pre>

<p>And:</p>

<pre><code>CryptoPP::StringSource s(cipher, true,
    new CryptoPP::StreamTransformationFilter(de, new CryptoPP::StringSink(recovered)));
</code></pre>

<p>It looks like you are trying to decrypt a hex encoded string. You probably need to run the cipher text through a <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow""><code>HexDecoder</code></a>. Maybe something like:</p>

<pre><code>StringSource s(cipher, true,
    new HexDecoder(
        new StreamTransformationFilter(de, new StringSink(recovered))));
</code></pre>
","989","<c++><crypto++>","1","1","1","2016-08-24 04:10:11","39114280","0","","","","","2016-08-23 14:36:31",""
"31660366","Integrate Crypto++ code to Qt Application In Linux","<p>I try to use <a href=""https://stackoverflow.com/questions/21885140/aes-256-encryption-in-c-and-qt-5"">this</a> example code of using AES algorithm.
I am new to qt and linux and try to figure out how should I use this library.</p>

<p>I downloaded the file Crypto++ 5.0 from <a href=""http://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">here</a> and unzip it . Now I have direcory in ~/Downloads/crypto with many cpp and header files but I dont know what's next. which file should I compile? how can I integrate this to small Qt project? If I copy the code from the link , the compiler cant find all the include files (which is make sense). so what i need to do to run this small example?</p>

<p>I use Qt 5.4.1, th compiler is g++</p>
","<p>I found the blog describing Crypto++, Qt and Linux:</p>

<p><a href=""https://inphamousdevelopment.wordpress.com/2011/05/06/crypto-and-linux/"" rel=""nofollow"">https://inphamousdevelopment.wordpress.com/2011/05/06/crypto-and-linux/</a></p>

<p>The main idea is that you should not using downloaded files but use terminal:</p>

<pre><code>sudo apt-get install libcrypto++8 libcrypto++8-dbg libcrypto++-dev
</code></pre>

<p>To add library to the project use the following:</p>

<pre><code>LIBS += -L/usr/lib/crypto++ -lcrypto++
INCS += -I/usr/include/crypto++
</code></pre>

<p>See the first link for more details, hope it helps.</p>
","983","<c++><linux><qt><crypto++>","0","0","1","2015-07-28 18:42:18","31684613","2","","-1","","2017-05-23 12:06:08","2015-07-27 18:16:30",""
"26007768","Loading a key from memory in Crypto++","<p>I'm trying to save a public DLIES key to memory and then read it again, but I keep getting exception <code>BER decode error</code>. I use <code>ArraySink</code>, <code>ArraySource</code> and a <code>char[64]</code> buffer to transfer the key between two <code>CryptoPP::DLIES&lt;&gt;::PublicKey</code>. I even verify that the public key is good. What am I missing?</p>

<p>Below is the full sample that doesn't work properly. How to modify it so that it'll properly load the key?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;gfpcrypt.h&gt;
#include &lt;filters.h&gt;
#include &lt;osrng.h&gt;

int main() {
    try {
        CryptoPP::DefaultAutoSeededRNG rng;

        CryptoPP::DLIES&lt;&gt;::PrivateKey privateKey;
        privateKey.GenerateRandomWithKeySize(rng, 10);

        CryptoPP::DLIES&lt;&gt;::PublicKey publicKey;
        privateKey.MakePublicKey(publicKey);

        if (!publicKey.Validate(rng, 3)) {
            std::cout &lt;&lt; ""Something wrong with public key."" &lt;&lt; std::endl;
            return 1;
        }

        byte buf[64];
        CryptoPP::ArraySink sink(buf, 64);
        publicKey.Save(sink);

        CryptoPP::ArraySource source((const char *)buf, sink.TotalPutLength());
        CryptoPP::DLIES&lt;&gt;::PublicKey pk;
        pk.Load(source);
    } catch (CryptoPP::Exception &amp;ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>
","<p>The problem lied in not setting <code>pumpAll=true</code> 3rd parameter of the <code>ArraySource</code> constructor. After adding it, it worked. Another working solution was to use <code>ByteQueue</code> instead. For the sake of completeness, I paste both working examples below.</p>

<p><code>ArraySource</code> version:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;gfpcrypt.h&gt;
#include &lt;filters.h&gt;
#include &lt;osrng.h&gt;

int main() {
    try {
        CryptoPP::DefaultAutoSeededRNG rng;

        CryptoPP::DLIES&lt;&gt;::PrivateKey privateKey;
        privateKey.GenerateRandomWithKeySize(rng, 10);

        CryptoPP::DLIES&lt;&gt;::PublicKey publicKey;
        privateKey.MakePublicKey(publicKey);

        if (!publicKey.Validate(rng, 3)) {
            std::cout &lt;&lt; ""Something wrong with sent public key."" &lt;&lt; std::endl;
            return 1;
        }

        byte buf[64];
        CryptoPP::ArraySink sink(buf, 64);
        publicKey.Save(sink);

        CryptoPP::ArraySource source(buf, sink.TotalPutLength(), true);
        CryptoPP::DLIES&lt;&gt;::PublicKey pk;
        pk.Load(source);

        if (!pk.Validate(rng, 3)) {
            std::cout &lt;&lt; ""Something wrong with received public key."" &lt;&lt; std::endl;
            return 1;
        }
    } catch (CryptoPP::Exception &amp;ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>

<p><code>ByteQueue</code> version (which I found more convenient in the end):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;gfpcrypt.h&gt;
#include &lt;filters.h&gt;
#include &lt;osrng.h&gt;

int main() {
    try {
        CryptoPP::DefaultAutoSeededRNG rng;

        CryptoPP::DLIES&lt;&gt;::PrivateKey privateKey;
        privateKey.GenerateRandomWithKeySize(rng, 10);

        CryptoPP::DLIES&lt;&gt;::PublicKey publicKey;
        privateKey.MakePublicKey(publicKey);

        if (!publicKey.Validate(rng, 3)) {
            std::cout &lt;&lt; ""Something wrong with sent public key."" &lt;&lt; std::endl;
            return 1;
        }

        CryptoPP::ByteQueue queue;
        publicKey.Save(queue);
        CryptoPP::lword size = queue.TotalBytesRetrievable();

        byte buf[64];
        queue.Get(buf, size);

        CryptoPP::ByteQueue queue2;
        queue2.Put(buf, size);
        CryptoPP::DLIES&lt;&gt;::PublicKey pk;
        pk.Load(queue2);

        if (!pk.Validate(rng, 3)) {
            std::cout &lt;&lt; ""Something wrong with received public key."" &lt;&lt; std::endl;
            return 1;
        }
    } catch (CryptoPP::Exception &amp;ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>
","971","<c++><crypto++>","2","1","1","2014-09-24 10:40:17","26014828","3","1","","","","2014-09-24 02:55:01",""
"35713800","Android SpongyCastle ECDH secp384r1 Key Size Incorrect","<p>I am trying to used SpongyCastle on Android for ECDH secp384r1 Public/Private Key pair generation. The problem I an running into is, the keys that I am generating are way too big.</p>

<p>The public key is 120 bytes and the private key is 194 bytes. There is obviously some sort of encoding going on here. I do not want all of this extra info, I am looking for the 49 byte and 48 byte compressed public/private keys.</p>

<p>Here is how I am generating my keys:</p>

<pre><code>ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(""secp384r1"");
KeyPairGenerator kpg = KeyPairGenerator.getInstance(""ECDH"", ""SC"");
kpg.initialize(ecParamSpec);

KeyPair kpA = kpg.generateKeyPair();

byte[] publicKeyBytes = kpA.getPublic().getEncoded();
byte[] privateKeyBytes = kpA.getPrivate().getEncoded();
</code></pre>

<p>I am going down this route because I was previously using CryptoPP and the NDK to generate the key pairs and extract the shared secret, which you can see an example of <a href=""https://github.com/tcolligan-ap/ECDHTest"" rel=""nofollow noreferrer"">here</a>.</p>

<p>However I ran into an <a href=""https://stackoverflow.com/questions/34906495/library-not-found-due-to-targetsdkversion-armeabi-v7a-and-libcryptopp-so"">issue</a> getting CryptoPP to work on Android Marshmallow, so now I am resorting to SpongyCastle.</p>

<p>The main issue being, this needs to work with an iOS app this is already using the CryptoPP implementation, so I need to figure out how to make this line up with that version, if that is even possible.</p>

<p>Basically I need a Java SpongyCastle implementation that lines up with the following C++ cryptopp implementation:</p>

<pre><code>   // Generate a public private key pair using ECDH (Elliptic Curve Diffie Hellman)
   OID CURVE = secp384r1(); // the key is 384 bits (48 bytes) long
   AutoSeededRandomPool rng;

   // Because we are using point compression
   // Private Key 48 bytes
   // Public Key 49 bytes
   // If compression was not used the public key would be 65 bytes long
   ECDH &lt; ECP &gt;::Domain dhA( CURVE );
   dhA.AccessGroupParameters().SetPointCompression(true);

   SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
   dhA.GenerateKeyPair(rng, privA, pubA);

   jobject publicKeyByteBuffer = (*env).NewDirectByteBuffer(pubA.BytePtr(), pubA.SizeInBytes());
   jobject privateKeyByteBuffer = (*env).NewDirectByteBuffer(privA.BytePtr(), privA.SizeInBytes());

   // Return the ECDH Key Pair back as a Java ECDHKeyPair object
   jclass keyPairClass = (*env).FindClass(""com/tcolligan/ecdhtest/ECDHKeyPair"");
   jmethodID midConstructor = (*env).GetMethodID(keyPairClass, ""&lt;init&gt;"", ""(Ljava/nio/ByteBuffer;Ljava/nio/ByteBuffer;)V"");
   jobject keyPairObject = (*env).NewObject(keyPairClass, midConstructor, publicKeyByteBuffer, privateKeyByteBuffer);

   return keyPairObject;
</code></pre>

<p>The first step is I need to figure out how to extract the 49 and 48 byte compressed keys from the SpongyCastle implementation. </p>

<p>After that extracting the shared secret using those keys would be the priority. I am pretty new to Encryption overall and using these libraries, so any help here would be greatly appreciated.</p>
","<p>I was able to figure out the answer. The following code will give me keys with the sizes that I am looking for.</p>

<pre><code>ECGenParameterSpec ecParamSpec = new ECGenParameterSpec(""secp384r1"");
KeyPairGenerator kpg = KeyPairGenerator.getInstance(""ECDH"", ""SC"");
kpg.initialize(ecParamSpec);

KeyPair kpA = kpg.generateKeyPair();

BCECPublicKey publicKey = (BCECPublicKey)kpA.getPublic();
BCECPrivateKey privateKey = (BCECPrivateKey)kpA.getPrivate();

byte[] publicKeyBytes = publicKey.getQ().getEncoded(true);
byte[] privateKeyBytes = privateKey.getD().toByteArray();
</code></pre>

<p>Good news is, it also seems to be compatible with the cryptopp C++ implementation.</p>
","965","<java><android><bouncycastle><crypto++><spongycastle>","4","2","1","2016-03-01 19:53:12","35731109","0","2","-1","","2017-05-23 10:28:05","2016-03-01 02:53:06",""
"23619006","Using the CryptoPP vectors in the GCM sample code","<p>I have downloaded the CryptoPP library and I am able to run the sample codes and get results (for CCM and GCM modes).</p>

<p>The next step for me is to try out the test vectors for each of these modes. From my understanding im suppose to try out the different keys, IVs and plaintexts as specified in the test vectors. Then I have to verify that the expected results are also specified in each vector.</p>

<p>What I can seem to understand is how to input these keys and IVs for the vectors. From the code as shown below, it seems to be using a random key.</p>

<p>Preferably I would like to input the keys and IVs from command prompt and then run the test code. Just setting the vectors from the code in Visual Studio would do though.</p>

<p>Please find the sample code and one of the vectors below:</p>

<p>Sample Code:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key( AES::DEFAULT_KEYLENGTH );
prng.GenerateBlock( key, key.size() );

byte iv[ AES::BLOCKSIZE * 16 ];
prng.GenerateBlock( iv, sizeof(iv) );    

const int TAG_SIZE = 12;

// Plain text
string pdata=""Authenticated Encryption"";

// Encrypted, with Tag
string cipher, encoded;

// Recovered plain text
string rpdata;

/*********************************\
\*********************************/

try
{
    GCM&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

    StringSource( pdata, true,
        new AuthenticatedEncryptionFilter( e,
            new StringSink( cipher ), false, TAG_SIZE
        ) // AuthenticatedEncryptionFilter
    ); // StringSource
}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

try
{
    GCM&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

    AuthenticatedDecryptionFilter df( d,
        new StringSink( rpdata ),
        DEFAULT_FLAGS, TAG_SIZE
    ); // AuthenticatedDecryptionFilter

    // The StringSource dtor will be called immediately
    //  after construction below. This will cause the
    //  destruction of objects it owns. To stop the
    //  behavior so we can get the decoding result from
    //  the DecryptionFilter, we must use a redirector
    //  or manually Put(...) into the filter without
    //  using a StringSource.
    StringSource( cipher, true,
        new Redirector( df /*, PASS_EVERYTHING */ )
    ); // StringSource

    // If the object does not throw, here's the only
    //  opportunity to check the data's integrity
    if( true == df.GetLastResult() ) {
        cout &lt;&lt; ""recovered text: "" &lt;&lt; rpdata &lt;&lt; endl;
    }
}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>One of the vectors:</p>

<pre class=""lang-none prettyprint-override""><code>GCM Test Case #14 (AES-256)
Variable          Value
-------------------------------------------------
K               : 00000000000000000000000000000000
                : 00000000000000000000000000000000
P               : 00000000000000000000000000000000
IV              : 000000000000000000000000
H               : dc95c078a2408989ad48a21492842087
Y_0             : 00000000000000000000000000000001
E(K,Y_0)        : 530f8afbc74536b9a963b4f1c4cb738b
Y_1             : 00000000000000000000000000000002
E(K,Y_1)        : cea7403d4d606b6e074ec5d3baf39d18
X_1             : fd6ab7586e556dba06d69cfe6223b262
len(A)||len(C)  : 00000000000000000000000000000080
GHASH(H,A,C)    : 83de425c5edc5d498f382c441041ca92
C               : cea7403d4d606b6e074ec5d3baf39d18

T               : d0d1c8a799996bf0265b98b5d48ab919
</code></pre>
","<blockquote>
  <p>I have downloaded the CryptoPP library and I am able to run the sample codes and get results (for CCM and GCM modes).</p>
</blockquote>

<p>Crypto++ does not use the examples from its wiki when running its self tests. The self test code is much more hairier.</p>

<blockquote>
  <p>What I can seem to understand is how to input these keys and IVs for the vectors. From the code as shown below, it seems to be using a random key.</p>
</blockquote>

<p>The Crypto++ test vectors are located in <code>&lt;crypto++ dir&gt;/TestVectors</code>. I don't believe the vector you show in your question is from Crypto++. For example, here's from <code>&lt;crypto++ dir&gt;/TestVectors/gcm.txt</code>:</p>

<pre><code>AlgorithmType: AuthenticatedSymmetricCipher
Name: AES/GCM
Source: aes-modes-src-07-10-08/Testvals/gcm.1, Basic Tests for GCM (compiled by B. R. Gladman)
Key: 00000000000000000000000000000000
IV:  000000000000000000000000
MAC: 00000000000000000000000000000000 
Test: NotVerify
Key: 00000000000000000000000000000000
IV:  000000000000000000000000
MAC: 58e2fccefa7e3061367f1d57a4e7455a 
Test: Encrypt
Key: 00000000000000000000000000000000
IV:  000000000000000000000000
Plaintext: 00000000000000000000000000000000
Ciphertext: 0388dace60b6a392f328c2b971b2fe78
MAC: ab6e47d42cec13bdf53a67b21257bddf 
Test: Encrypt
...
</code></pre>

<p>You can see how the Crypto++ test suite consumes it when you use the <code>cryptest.exe v</code> command. The source files that execute the self tests are <code>validat1.cpp</code>, <code>validat2.cpp</code> and <code>validat3.cpp</code>. The GCM testing starts in <code>validat1.cpp</code> on line 95:</p>

<pre><code>pass=ValidateGCM() &amp;&amp; pass;
</code></pre>

<p>Here's <code>ValidateGCM</code> around line 1395:</p>

<pre><code>bool ValidateGCM()
{
    cout &lt;&lt; ""\nAES/GCM validation suite running...\n"";
    cout &lt;&lt; ""\n2K tables:"";
    bool pass = RunTestDataFile(""TestVectors/gcm.txt"", MakeParameters(Name::TableSize(), (int)2048));
    cout &lt;&lt; ""\n64K tables:"";
    return RunTestDataFile(""TestVectors/gcm.txt"", MakeParameters(Name::TableSize(), (int)64*1024)) &amp;&amp; pass;
}
</code></pre>

<p>Its a real pain to untangle <code>RunTestDataFile</code>, <code>TestDataFile</code> and <code>TestAuthenticatedSymmetricCipher</code> (and friends). They are implemented in <code>datatest.cpp</code>. The pain point is <code>TestAuthenticatedSymmetricCipher</code> around line 450 of <code>datatest.cpp</code>.</p>

<p>I usually go to the applicable standard, pull the test vectors, and then write my own self tests. In the case of deterministic encryption like AES/GCM, you can write a Known Answer Test (KAT). For non-deterministic tests, you will need to write a Pairwise Consistency Test (PCT). Essentially, you verify you can round trip data from a public/private key pair operation, like a DH or RSA key.</p>
","961","<c++><visual-studio-2010><encryption><vector><crypto++>","0","0","1","2014-05-13 06:40:21","23624331","4","","589259","","2014-05-12 22:02:10","2014-05-12 21:14:29",""
"21503467","Building Crypto++ 5.6.2 with Cygwin x86_64","<p>I am attempting to build CryptoPP with Cygwin x86_64, but I'm having some trouble with <code>osrng.cpp</code>.</p>

<p>I'm using gcc's C++ compiler, and I'm getting the following error at <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.cpp#l50"" rel=""nofollow noreferrer"">line 50 of <code>osrng.cpp</code></a></p>

<pre><code>$ make
g++ -DNDEBUG -g -O2 -march=native -pipe -c osrng.cpp
osrng.cpp: In constructor ‘CryptoPP::MicrosoftCryptoProvider::MicrosoftCryptoProvider()’:
osrng.cpp:50:80: error: invalid conversion from ‘CryptoPP::MicrosoftCryptoProvider::ProviderHandle* {aka long unsigned int*}’ to ‘HCRYPTPROV* {aka long long unsigned int*}’ [-fpermissive]
  if(!CryptAcquireContext(&amp;m_hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
                                                                                ^
In file included from /usr/include/w32api/windows.h:95:0,
                 from osrng.cpp:19:
/usr/include/w32api/wincrypt.h:646:26: error:   initializing argument 1 of ‘WINBOOL CryptAcquireContextA(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD)’ [-fpermissive]
   WINIMPM WINBOOL WINAPI CryptAcquireContextA(HCRYPTPROV *phProv,LPCSTR szContainer,LPCSTR szProvider,DWORD dwProvType,DWORD dwFlags);
                          ^
GNUmakefile:208: recipe for target 'osrng.o' failed
make: *** [osrng.o] Error 1
</code></pre>

<p>I have successfully compiled the whole thing under the 32bit version of Cygwin before.</p>

<p>How can I fix this for the 64bit edition?</p>

<p><strong>EDIT</strong> As suggested by <a href=""https://stackoverflow.com/users/580360/yaakov"">@Yakov</a>'s <a href=""https://stackoverflow.com/a/21506951/1296709"">answer</a>, I replaced <code>if defined(_WIN64)if defined(__x86_64__)</code> by <code>if</code> in <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.h#l30"" rel=""nofollow noreferrer"">line 30 of <code>osrng.h</code></a>.
Sadly though, I immediately run into the next problem, indicated by the following error:</p>

<pre><code>$ make
g++ -DNDEBUG -g -O2 -march=native -pipe -c fipstest.cpp
In file included from dll.h:30:0,
                 from fipstest.cpp:8:
osrng.h:34:19: error: expected ‘;’ at end of member declaration
  typedef unsigned __int64 ProviderHandle; // type HCRYPTPROV, avoid #include &lt;windows.h&gt;
                   ^
osrng.h:34:27: error: ‘ProviderHandle’ does not name a type
  typedef unsigned __int64 ProviderHandle; // type HCRYPTPROV, avoid #include &lt;windows.h&gt;
                           ^
osrng.h:38:2: error: ‘ProviderHandle’ does not name a type
  ProviderHandle GetProviderHandle() const {return m_hProvider;}
  ^
osrng.h:40:2: error: ‘ProviderHandle’ does not name a type
  ProviderHandle m_hProvider;
  ^
GNUmakefile:208: recipe for target 'fipstest.o' failed
make: *** [fipstest.o] Error 1
</code></pre>
","<p>Thankfully, GCC error messages have improved significantly in recent releases.  The <code>{aka}</code>s tell you that there is a mismatch between <code>long</code> and <code>long long</code>.  Keep in mind that Win64 is LLP64: <code>long</code> is still only 32-bits, and you need a <code>long long</code> to match the size of a pointer.  Most (all?) other 64-bit platforms are LP64, meaning that <code>long</code> matches the size of a pointer.</p>

<p>In this particular case, see the <code>if defined(_WIN64)</code> in <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.h#l30"" rel=""nofollow""><code>osrng.h</code></a>; you will need to change that condition to <code>if defined(__x86_64__)</code> instead.</p>

<p>You might run into problems with the <code>__int64</code> type as well. Replace those with <code>long long</code>. (Occurs <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/config.h#l113"" rel=""nofollow"">here</a>, <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/config.h#l220"" rel=""nofollow"">here</a> and <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.h#l31"" rel=""nofollow"">here</a>.)</p>
","958","<gcc><compiler-errors><cygwin><x86-64><crypto++>","1","2","2","2015-06-29 02:18:24","21506951","0","","-1","","2017-05-23 12:30:03","2014-02-01 20:47:59",""
"21503467","Building Crypto++ 5.6.2 with Cygwin x86_64","<p>I am attempting to build CryptoPP with Cygwin x86_64, but I'm having some trouble with <code>osrng.cpp</code>.</p>

<p>I'm using gcc's C++ compiler, and I'm getting the following error at <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.cpp#l50"" rel=""nofollow noreferrer"">line 50 of <code>osrng.cpp</code></a></p>

<pre><code>$ make
g++ -DNDEBUG -g -O2 -march=native -pipe -c osrng.cpp
osrng.cpp: In constructor ‘CryptoPP::MicrosoftCryptoProvider::MicrosoftCryptoProvider()’:
osrng.cpp:50:80: error: invalid conversion from ‘CryptoPP::MicrosoftCryptoProvider::ProviderHandle* {aka long unsigned int*}’ to ‘HCRYPTPROV* {aka long long unsigned int*}’ [-fpermissive]
  if(!CryptAcquireContext(&amp;m_hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
                                                                                ^
In file included from /usr/include/w32api/windows.h:95:0,
                 from osrng.cpp:19:
/usr/include/w32api/wincrypt.h:646:26: error:   initializing argument 1 of ‘WINBOOL CryptAcquireContextA(HCRYPTPROV*, LPCSTR, LPCSTR, DWORD, DWORD)’ [-fpermissive]
   WINIMPM WINBOOL WINAPI CryptAcquireContextA(HCRYPTPROV *phProv,LPCSTR szContainer,LPCSTR szProvider,DWORD dwProvType,DWORD dwFlags);
                          ^
GNUmakefile:208: recipe for target 'osrng.o' failed
make: *** [osrng.o] Error 1
</code></pre>

<p>I have successfully compiled the whole thing under the 32bit version of Cygwin before.</p>

<p>How can I fix this for the 64bit edition?</p>

<p><strong>EDIT</strong> As suggested by <a href=""https://stackoverflow.com/users/580360/yaakov"">@Yakov</a>'s <a href=""https://stackoverflow.com/a/21506951/1296709"">answer</a>, I replaced <code>if defined(_WIN64)if defined(__x86_64__)</code> by <code>if</code> in <a href=""http://sourceforge.net/p/cryptopp/code/328/tree/trunk/c5/osrng.h#l30"" rel=""nofollow noreferrer"">line 30 of <code>osrng.h</code></a>.
Sadly though, I immediately run into the next problem, indicated by the following error:</p>

<pre><code>$ make
g++ -DNDEBUG -g -O2 -march=native -pipe -c fipstest.cpp
In file included from dll.h:30:0,
                 from fipstest.cpp:8:
osrng.h:34:19: error: expected ‘;’ at end of member declaration
  typedef unsigned __int64 ProviderHandle; // type HCRYPTPROV, avoid #include &lt;windows.h&gt;
                   ^
osrng.h:34:27: error: ‘ProviderHandle’ does not name a type
  typedef unsigned __int64 ProviderHandle; // type HCRYPTPROV, avoid #include &lt;windows.h&gt;
                           ^
osrng.h:38:2: error: ‘ProviderHandle’ does not name a type
  ProviderHandle GetProviderHandle() const {return m_hProvider;}
  ^
osrng.h:40:2: error: ‘ProviderHandle’ does not name a type
  ProviderHandle m_hProvider;
  ^
GNUmakefile:208: recipe for target 'fipstest.o' failed
make: *** [fipstest.o] Error 1
</code></pre>
","<p>You might also find <code>word64</code> useful. From Crypto++'s <code>config.h</code>:</p>

<pre><code>#if defined(_MSC_VER) || defined(__BORLANDC__)
    typedef unsigned __int64 word64;
    #define W64LIT(x) x##ui64
#else
    typedef unsigned long long word64;
    #define W64LIT(x) x##ULL
#endif
</code></pre>

<p>There's a couple of Cygwin defines in there too. But they don't look interesting. For example:</p>

<pre><code>#ifndef TYPE_OF_SOCKLEN_T
#   if defined(_WIN32) || defined(__CYGWIN__)
#       define TYPE_OF_SOCKLEN_T int
#   else
#       define TYPE_OF_SOCKLEN_T ::socklen_t
#   endif
#endif

#if defined(__CYGWIN__) &amp;&amp; defined(PREFER_WINDOWS_STYLE_SOCKETS)
#   define __USE_W32_SOCKETS
#endif
</code></pre>

<p>(Sorry about the comment here. Its too bing to fit in the little comment block).</p>
","958","<gcc><compiler-errors><cygwin><x86-64><crypto++>","1","0","2","2015-06-29 02:18:24","21506951","0","","-1","","2017-05-23 12:30:03","2014-02-01 20:47:59",""
"30860777","Use previously generated private key in ECIES","<p>I wan to encrypt /decrypt data using ECIES , I am using cryptopp for this.</p>

<pre><code>AutoSeededRandomPool prng;

//get private key generated
ECIES&lt;ECP&gt;::Decryptor d0(prng, ASN1::secp256r1());
PrintPrivateKey(d0.GetKey());

//get public key 
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

//encrypt the message
string em0; // encrypted message
StringSource ss1 (message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );

//decrypt the message   
string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d1, new StringSink(dm0) ) );
</code></pre>

<p>Everything else is fine but I want to do the above same thing using already generated 'private key' and not randomly generated 'private key' unlike the case above. How can I do this?</p>

<h3>I have tried the following code but it just simply crashes</h3>

<pre><code>AutoSeededRandomPool prng;

std::string  privatekeyString=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";

CryptoPP::HexDecoder decoder;
decoder.Put((byte*)privatekeyString.data(), privatekeyString.size());
decoder.MessageEnd();

ECIES&lt;ECP&gt; ::Decryptor d0;
d0.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());
</code></pre>

<h2>crash point</h2>

<pre><code>//load private key  
d0.AccessKey().Load(decoder);
PrintPrivateKey(d0.GetKey());

//get public key    
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d0, new StringSink(dm0) ) );
cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt;   endl;
</code></pre>

<h2>Edit 2</h2>

<p>In response to @jww answer I managed to decode the message with the private key as:</p>

<pre><code>  try
  {
    AutoSeededRandomPool prng;

    std::string exponent=""AsIAECwYD55qTnovWLW+hrwXlHg="";
    StringSource ss(exponent, true /*pumpAll*/, new CryptoPP::HexDecoder);


    Integer x;
    x.Decode(ss, ss.MaxRetrievable(), Integer::UNSIGNED);
    // cout &lt;&lt; ""Exponent: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; endl;

    ECIES&lt;ECP&gt;::Decryptor decryptor;
    decryptor.AccessKey().Initialize(ASN1::secp128r1(), x);

    bool valid = decryptor.AccessKey().Validate(prng, 3);
    if(!valid)
    {
        cout&lt;&lt;""Exponent is not valid for P-128""&lt;&lt;endl;
        return;
    }
      //  throw  Exception(CryptoPP::Exception::OTHER_ERROR, ""Exponent is not valid for P-256"");

    // Or: decryptor.AccessKey().ThrowIfInvalid(prng, 3);

    cout &lt;&lt; ""Exponent is valid for P-128"" &lt;&lt; endl;

    PrintPrivateKey(decryptor.GetKey());


    //get public key
    ECIES&lt;ECP&gt;::Encryptor encryptor(decryptor);
    PrintPublicKey(encryptor.GetKey());



    string em0; // encrypted message
    StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
    cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

    string dm0; // decrypted message
    StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, decryptor, new StringSink(dm0) ) );
    cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt; endl;

}
catch(const CryptoPP::Exception&amp; ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>But when I try to encrypt the message using public key I got error </p>

<h3>CryptoPP::CryptoMaterial::InvalidMaterial: CryptoMaterial: this object contains invalid values</h3>

<p>Here is my code:</p>

<pre><code>std::string     public_point=""AsIAEFjzIcX+Kvhe8AmLoGUc8aYAEAwf5ecREGZ2u4RLxQuav/A="";
StringSource ss(public_point, true, new CryptoPP::HexDecoder);

ECIES&lt;ECP&gt;::Encryptor encryptor;
    encryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());

ECP::Point point;
encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());
cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

encryptor.AccessKey().SetPublicElement(point);


encryptor.AccessKey().ThrowIfInvalid(prng, 3);

PrintPublicKey(encryptor.GetKey());



string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;
</code></pre>
","<p>The problem I am having is you don't appear to know what you have, and the some of the parameters you are using are wrong when taken with the other parameters. So its pretty much a stab in the dark.</p>

<hr>

<p>First, you should wrap the disk operations in a <code>try/catch</code>. I/O can always cause problems, so be sure to catch exceptions related to the <code>iostream</code> stuff. You should also catch the Crypto++ Exception related to key loading. That will handle the ""crash"" with no information.</p>

<p>So your code might look something like:</p>

<pre><code>try
{
    // Read key from disk, load it into Crypto++ object
}
catch(const Exception&amp; ex)
{
    cerr &lt;&lt; ""Caught Crypto++ exception "" &lt;&lt; ex.what() &lt;&lt; endl;
}
catch(const std::runtime_error&amp; ex)
{
    cerr &lt;&lt; ""Caught C++ runtime error "" &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<p>Second, this looks like a private exponent, and not a private key:</p>

<pre class=""lang-c++ prettyprint-override""><code>std::string  privatekeyString=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";
</code></pre>

<p>And its too big to be in <code>P-128</code>. Maybe you should do something like:</p>

<pre class=""lang-c++ prettyprint-override""><code>try
{
    AutoSeededRandomPool prng;

    std::string exponent=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";
    StringSource ss(exponent, true /*pumpAll*/, new HexDecoder);

    Integer x;
    x.Decode(ss, ss.MaxRetrievable(), Integer::UNSIGNED);        
    // cout &lt;&lt; ""Exponent: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; endl;

    ECIES&lt;ECP&gt;::Decryptor decryptor;
    decryptor.AccessKey().Initialize(ASN1::secp256r1(), x);

    bool valid = decryptor.AccessKey().Validate(prng, 3);
    if(!valid)
        throw  Exception(Exception::OTHER_ERROR, ""Exponent is not valid for P-256"");

    // Or: decryptor.AccessKey().ThrowIfInvalid(prng, 3);

    cout &lt;&lt; ""Exponent is valid for P-256"" &lt;&lt; endl;        
}
catch(const Exception&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<p>Or, you can:</p>

<pre><code>ECIES&lt;ECP&gt;::Decryptor decryptor;
decryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp256r1());
decryptor.AccessKey().SetPrivateExponent(x);
</code></pre>

<hr>

<p>If you add the following to the program above:</p>

<pre class=""lang-c++ prettyprint-override""><code>// Encode key, use OID versus domain paramters
string encoded;
HexEncoder encoder(new StringSink(encoded));

decryptor.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);
decryptor.GetKey().Save(encoder);

cout &lt;&lt; ""Private key: "" &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>You will get the following for the private key:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./ecies-test.exe
Exponent: 2c200102c180f9e6a4e7a2f58b5be86bc179478h
Private key: 3041020100301306072A8648CE3D020106082A8648CE3D030107042730250201010
42000000000000000000000000002C200102C180F9E6A4E7A2F58B5BE86BC179478
</code></pre>

<p>As you can see, the key <strong><em>is not</em></strong> <code>""02C200102C180F9E6A4E7A2F58B5BE86BC179478""</code>.</p>

<p>The 12 leading 0's look suspicious to me. Though the exponent validates, you should verify the exponent and the field. The closest fit I could find is the curve <code>secp160r2</code> (of course, curves like <code>secp192k1</code> and <code>secp224k1</code> work too).</p>

<p>The private key above is the hex encoding of <code>ecies.priv.der</code> shown below.</p>

<hr>

<p>Third, this could be a public point in compressed form due to the leading <code>02</code>.</p>

<pre class=""lang-c++ prettyprint-override""><code>std::string  privatekeyString=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";
</code></pre>

<p>If that is the case, then you are supposed to be able to do this, but I can't get it to decode the point (see <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Cryptography#Minimizing_Key_Size_for_Persistence"" rel=""nofollow"">Minimizing Key Size for Persistence</a> on the wiki). <code>x</code> and <code>y</code> are 0 after the operation; maybe the problem is with the field:</p>

<pre><code>std::string public_point=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";
StringSource ss(public_point, true, new HexDecoder);

ECIES&lt;ECP&gt;::Encryptor encryptor;
encryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());

ECP::Point point;
encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());
cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

encryptor.AccessKey().SetPublicElement(point);
encryptor.AccessKey().ThrowIfInvalid(prng, 3);
</code></pre>

<hr>

<p>Fourth, you should probably save the entire key, and not just the exponent. Here's a program for you that shows you how to save and load the keys. It also shows you how to perform encryption and decryption in one-liners.</p>

<pre class=""lang-c++ prettyprint-override""><code>/////////////////////////////////////////////////
// Part one - generate keys

ECIES&lt;ECP&gt;::Decryptor decryptor(prng, ASN1::secp256r1());
ECIES&lt;ECP&gt;::Encryptor encryptor(decryptor);

/////////////////////////////////////////////////
// Part two - save keys

FileSink fs1(""ecies.priv.der"", true /*binary*/);
decryptor.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);
decryptor.GetKey().Save(fs1);

FileSink fs2(""ecies.pub.der"", true /*binary*/);
encryptor.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);
encryptor.GetKey().Save(fs2);

/////////////////////////////////////////////////
// Part three - encrypt/decrypt

string message, encrypted, recovered;

if(argc &gt;= 2 &amp;&amp; argv[1] != NULL)
    message = argv[1];
else
    message = ""Attack at dawn!"";

StringSource ss1 (message,   true /*pumpAll*/, new PK_EncryptorFilter(prng, encryptor, new StringSink(encrypted)));
StringSource ss2 (encrypted, true /*pumpAll*/, new FileSink(""ecies.encrypted.bin"", true /*binary*/));
StringSource ss3 (encrypted, true /*pumpAll*/, new PK_DecryptorFilter(prng, decryptor, new StringSink(recovered)));

cout &lt;&lt; recovered &lt;&lt; endl;
</code></pre>

<hr>

<p>Here is what a private key looks like from the test program above. Notice it has the field encoded into the structure so you don't have to guess at it (<code>P-256</code> versus <code>P-128</code> versus <code>P-521</code>).</p>

<pre class=""lang-none prettyprint-override""><code>$ dumpasn1 ecies.priv.der 
  0  65: SEQUENCE {
  2   1:   INTEGER 0
  5  19:   SEQUENCE {
  7   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 16   8:     OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7)
       :     }
 26  39:   OCTET STRING, encapsulates {
 28  37:     SEQUENCE {
 30   1:       INTEGER 1
 33  32:       OCTET STRING
       :         00 00 00 00 00 00 00 00 00 00 00 00 02 C2 00 10
       :         2C 18 0F 9E 6A 4E 7A 2F 58 B5 BE 86 BC 17 94 78
       :       }
       :     }
       :   }
</code></pre>

<p>And the public key:</p>

<pre class=""lang-none prettyprint-override""><code>$ dumpasn1 ecies.pub.der 
  0  89: SEQUENCE {
  2  19:   SEQUENCE {
  4   7:     OBJECT IDENTIFIER ecPublicKey (1 2 840 10045 2 1)
 13   8:     OBJECT IDENTIFIER prime256v1 (1 2 840 10045 3 1 7)
       :     }
 23  66:   BIT STRING
       :     04 08 9B D2 1C 3A DC 08 8B 1F F1 D0 F4 97 A0 87
       :     FE 4F 78 EA E2 B8 30 B8 E7 06 37 68 27 4C 71 CD
       :     63 C3 E2 90 66 64 2B 1C F6 79 00 36 AF 72 4C 61
       :     69 FA E9 06 00 9A 15 32 0B 85 B5 88 B2 C5 88 46
       :     5E
       :   }
</code></pre>

<hr>

<p>Crypto++ has a wiki page on ECIES. See <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Elliptic Curve Integrated Encryption Scheme</a>. They also have Bouncy Castle interop workarounds.</p>

<hr>

<p>You can also PEM encode the keys, but you need a patch to do it because its not part of the library. For the patch, see <a href=""http://www.cryptopp.com/wiki/PEM_Pack"" rel=""nofollow"">PEM Pack</a> on the Crypto++ wiki.</p>
","955","<c++><public-key-encryption><crypto++><elliptic-curve>","4","2","3","2015-06-18 09:52:44","30912098","11","1","3632958","","2015-06-17 07:26:08","2015-06-16 06:58:26",""
"30860777","Use previously generated private key in ECIES","<p>I wan to encrypt /decrypt data using ECIES , I am using cryptopp for this.</p>

<pre><code>AutoSeededRandomPool prng;

//get private key generated
ECIES&lt;ECP&gt;::Decryptor d0(prng, ASN1::secp256r1());
PrintPrivateKey(d0.GetKey());

//get public key 
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

//encrypt the message
string em0; // encrypted message
StringSource ss1 (message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );

//decrypt the message   
string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d1, new StringSink(dm0) ) );
</code></pre>

<p>Everything else is fine but I want to do the above same thing using already generated 'private key' and not randomly generated 'private key' unlike the case above. How can I do this?</p>

<h3>I have tried the following code but it just simply crashes</h3>

<pre><code>AutoSeededRandomPool prng;

std::string  privatekeyString=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";

CryptoPP::HexDecoder decoder;
decoder.Put((byte*)privatekeyString.data(), privatekeyString.size());
decoder.MessageEnd();

ECIES&lt;ECP&gt; ::Decryptor d0;
d0.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());
</code></pre>

<h2>crash point</h2>

<pre><code>//load private key  
d0.AccessKey().Load(decoder);
PrintPrivateKey(d0.GetKey());

//get public key    
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d0, new StringSink(dm0) ) );
cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt;   endl;
</code></pre>

<h2>Edit 2</h2>

<p>In response to @jww answer I managed to decode the message with the private key as:</p>

<pre><code>  try
  {
    AutoSeededRandomPool prng;

    std::string exponent=""AsIAECwYD55qTnovWLW+hrwXlHg="";
    StringSource ss(exponent, true /*pumpAll*/, new CryptoPP::HexDecoder);


    Integer x;
    x.Decode(ss, ss.MaxRetrievable(), Integer::UNSIGNED);
    // cout &lt;&lt; ""Exponent: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; endl;

    ECIES&lt;ECP&gt;::Decryptor decryptor;
    decryptor.AccessKey().Initialize(ASN1::secp128r1(), x);

    bool valid = decryptor.AccessKey().Validate(prng, 3);
    if(!valid)
    {
        cout&lt;&lt;""Exponent is not valid for P-128""&lt;&lt;endl;
        return;
    }
      //  throw  Exception(CryptoPP::Exception::OTHER_ERROR, ""Exponent is not valid for P-256"");

    // Or: decryptor.AccessKey().ThrowIfInvalid(prng, 3);

    cout &lt;&lt; ""Exponent is valid for P-128"" &lt;&lt; endl;

    PrintPrivateKey(decryptor.GetKey());


    //get public key
    ECIES&lt;ECP&gt;::Encryptor encryptor(decryptor);
    PrintPublicKey(encryptor.GetKey());



    string em0; // encrypted message
    StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
    cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

    string dm0; // decrypted message
    StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, decryptor, new StringSink(dm0) ) );
    cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt; endl;

}
catch(const CryptoPP::Exception&amp; ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>But when I try to encrypt the message using public key I got error </p>

<h3>CryptoPP::CryptoMaterial::InvalidMaterial: CryptoMaterial: this object contains invalid values</h3>

<p>Here is my code:</p>

<pre><code>std::string     public_point=""AsIAEFjzIcX+Kvhe8AmLoGUc8aYAEAwf5ecREGZ2u4RLxQuav/A="";
StringSource ss(public_point, true, new CryptoPP::HexDecoder);

ECIES&lt;ECP&gt;::Encryptor encryptor;
    encryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());

ECP::Point point;
encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());
cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

encryptor.AccessKey().SetPublicElement(point);


encryptor.AccessKey().ThrowIfInvalid(prng, 3);

PrintPublicKey(encryptor.GetKey());



string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;
</code></pre>
","<p>I'm going to add another answer to show you how to serialize private exponents and public points in case you had trouble with the public points. It also shows you how to <code>Save</code> the <em>PrivateKeyInfo</em> and <em>SubjectPublicKeyInfo</em>.</p>

<p>Its produces output similar to below. You will need a patch for the <a href=""http://www.cryptopp.com/wiki/Base64URLEncoder"" rel=""nofollow""><code>Base64URLEncoder</code></a>. its not part of the library.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./ecies-test.exe
Private exponent
  Hex: 57E91FA3EF48706D07E56D8CB566204A4416B833EFB9687D75A37D572EC42277
  Base64: V+kfo+9IcG0H5W2MtWYgSkQWuDPvuWh9daN9Vy7EInc=
  Base64 (URL safe): V-kfo-9IcG0H5W2MtWYgSkQWuDPvuWh9daN9Vy7EInc=
Pubic point
  Hex: 037142DE6143B6AD44C74135FE71222AC1406F541E53CB635112DE4928EC94763C
  Base64: A3FC3mFDtq1Ex0E1/nEiKsFAb1QeU8tjURLeSSjslHY8
  Base64 (URL safe): A3FC3mFDtq1Ex0E1_nEiKsFAb1QeU8tjURLeSSjslHY8
Private key (PrivateKeyInfo)
  3059301306072A8648CE3D020106082A8648CE3D030107034200047142DE6143B6AD44C74135FE71
  222AC1406F541E53CB635112DE4928EC94763CFA903D9282691AE47A2D718297465EF44E905A89ED
  2D4553ED1DF906A6E2383B
Public key (SubjectPublicKeyInfo)
  3041020100301306072A8648CE3D020106082A8648CE3D03010704273025020101042057E91FA3EF
  48706D07E56D8CB566204A4416B833EFB9687D75A37D572EC42277
</code></pre>

<hr>

<p>With the private exponent and public point above, the following works just fine:</p>

<pre class=""lang-c++ prettyprint-override""><code>string pub_point(""A7EDDUXAA4/6kOZ8H+firJ95YtKZvDrPFmyVoisyBfuW"");
StringSource ss(pub_point, true, new Base64Decoder);

ECIES&lt;ECP&gt;::Encryptor encryptor;
encryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp256r1());

ECP::Point point;
encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());

encryptor.AccessKey().SetPublicElement(point);
encryptor.AccessKey().ThrowIfInvalid(prng, 3);
</code></pre>

<hr>

<pre class=""lang-c++ prettyprint-override""><code>ECIES&lt;ECP&gt;::Decryptor decryptor;
decryptor.AccessKey().Initialize(prng, ASN1::secp256r1());

const Integer&amp; priv_exp = decryptor.GetKey().GetPrivateExponent();
SecByteBlock x(priv_exp.MinEncodedSize());
priv_exp.Encode(x, x.size());

string s1, s2, s3;    
HexEncoder f1(new StringSink(s1));
Base64Encoder f2(new StringSink(s2));
Base64URLEncoder f3(new StringSink(s3));

ChannelSwitch cs1;
cs1.AddDefaultRoute(f1);
cs1.AddDefaultRoute(f2);
cs1.AddDefaultRoute(f3);

ArraySource as1(x, x.size(), true /*pumpAll*/, new Redirector(cs1));

cout &lt;&lt; ""Private exponent"" &lt;&lt; endl;
cout &lt;&lt; ""  Hex: "" &lt;&lt; s1 &lt;&lt; endl;
cout &lt;&lt; ""  Base64: "" &lt;&lt; s2 &lt;&lt; endl;
cout &lt;&lt; ""  Base64 (URL safe): "" &lt;&lt; s3 &lt;&lt; endl;

//////////////////////////////////////////

ECIES&lt;ECP&gt;::Encryptor encryptor(decryptor);
ECP::Point pub_point = encryptor.GetKey().GetGroupParameters().ExponentiateBase(priv_exp);
SecByteBlock y(encryptor.GetKey().GetGroupParameters().GetCurve().EncodedPointSize(true /*compressed*/));
encryptor.GetKey().GetGroupParameters().GetCurve().EncodePoint(y, pub_point, true /*compressed*/);

string s4, s5, s6;    
HexEncoder f4(new StringSink(s4));
Base64Encoder f5(new StringSink(s5));
Base64URLEncoder f6(new StringSink(s6));

ChannelSwitch cs2;
cs2.AddDefaultRoute(f4);
cs2.AddDefaultRoute(f5);
cs2.AddDefaultRoute(f6);

ArraySource as2(y, y.size(), true /*pumpAll*/, new Redirector(cs2));

cout &lt;&lt; ""Pubic point"" &lt;&lt; endl;
cout &lt;&lt; ""  Hex: "" &lt;&lt; s4 &lt;&lt; endl;
cout &lt;&lt; ""  Base64: "" &lt;&lt; s5 &lt;&lt; endl;
cout &lt;&lt; ""  Base64 (URL safe): "" &lt;&lt; s6 &lt;&lt; endl;

//////////////////////////////////////////

string s10, s11;
HexEncoder hex1(new StringSink(s10));
HexEncoder hex2(new StringSink(s11));

encryptor.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);
encryptor.GetKey().Save(hex1);
decryptor.AccessKey().AccessGroupParameters().SetEncodeAsOID(true);
decryptor.GetKey().Save(hex2);

cout &lt;&lt; ""Private key"" &lt;&lt; endl;
cout &lt;&lt; s10 &lt;&lt; endl;

cout &lt;&lt; ""Public key"" &lt;&lt; endl;
cout &lt;&lt; s11 &lt;&lt; endl;
</code></pre>
","955","<c++><public-key-encryption><crypto++><elliptic-curve>","4","1","3","2015-06-18 09:52:44","30912098","11","1","3632958","","2015-06-17 07:26:08","2015-06-16 06:58:26",""
"30860777","Use previously generated private key in ECIES","<p>I wan to encrypt /decrypt data using ECIES , I am using cryptopp for this.</p>

<pre><code>AutoSeededRandomPool prng;

//get private key generated
ECIES&lt;ECP&gt;::Decryptor d0(prng, ASN1::secp256r1());
PrintPrivateKey(d0.GetKey());

//get public key 
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

//encrypt the message
string em0; // encrypted message
StringSource ss1 (message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );

//decrypt the message   
string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d1, new StringSink(dm0) ) );
</code></pre>

<p>Everything else is fine but I want to do the above same thing using already generated 'private key' and not randomly generated 'private key' unlike the case above. How can I do this?</p>

<h3>I have tried the following code but it just simply crashes</h3>

<pre><code>AutoSeededRandomPool prng;

std::string  privatekeyString=""02C200102C180F9E6A4E7A2F58B5BE86BC179478"";

CryptoPP::HexDecoder decoder;
decoder.Put((byte*)privatekeyString.data(), privatekeyString.size());
decoder.MessageEnd();

ECIES&lt;ECP&gt; ::Decryptor d0;
d0.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());
</code></pre>

<h2>crash point</h2>

<pre><code>//load private key  
d0.AccessKey().Load(decoder);
PrintPrivateKey(d0.GetKey());

//get public key    
ECIES&lt;ECP&gt;::Encryptor e0(d0);
PrintPublicKey(e0.GetKey());

string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, e0, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

string dm0; // decrypted message
StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, d0, new StringSink(dm0) ) );
cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt;   endl;
</code></pre>

<h2>Edit 2</h2>

<p>In response to @jww answer I managed to decode the message with the private key as:</p>

<pre><code>  try
  {
    AutoSeededRandomPool prng;

    std::string exponent=""AsIAECwYD55qTnovWLW+hrwXlHg="";
    StringSource ss(exponent, true /*pumpAll*/, new CryptoPP::HexDecoder);


    Integer x;
    x.Decode(ss, ss.MaxRetrievable(), Integer::UNSIGNED);
    // cout &lt;&lt; ""Exponent: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; endl;

    ECIES&lt;ECP&gt;::Decryptor decryptor;
    decryptor.AccessKey().Initialize(ASN1::secp128r1(), x);

    bool valid = decryptor.AccessKey().Validate(prng, 3);
    if(!valid)
    {
        cout&lt;&lt;""Exponent is not valid for P-128""&lt;&lt;endl;
        return;
    }
      //  throw  Exception(CryptoPP::Exception::OTHER_ERROR, ""Exponent is not valid for P-256"");

    // Or: decryptor.AccessKey().ThrowIfInvalid(prng, 3);

    cout &lt;&lt; ""Exponent is valid for P-128"" &lt;&lt; endl;

    PrintPrivateKey(decryptor.GetKey());


    //get public key
    ECIES&lt;ECP&gt;::Encryptor encryptor(decryptor);
    PrintPublicKey(encryptor.GetKey());



    string em0; // encrypted message
    StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
    cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;

    string dm0; // decrypted message
    StringSource ss2 (em0, true, new PK_DecryptorFilter(prng, decryptor, new StringSink(dm0) ) );
    cout &lt;&lt;""decrypted msg: ""&lt;&lt; dm0&lt;&lt;""  and its length: ""&lt;&lt;dm0.length() &lt;&lt; endl;

}
catch(const CryptoPP::Exception&amp; ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>But when I try to encrypt the message using public key I got error </p>

<h3>CryptoPP::CryptoMaterial::InvalidMaterial: CryptoMaterial: this object contains invalid values</h3>

<p>Here is my code:</p>

<pre><code>std::string     public_point=""AsIAEFjzIcX+Kvhe8AmLoGUc8aYAEAwf5ecREGZ2u4RLxQuav/A="";
StringSource ss(public_point, true, new CryptoPP::HexDecoder);

ECIES&lt;ECP&gt;::Encryptor encryptor;
    encryptor.AccessKey().AccessGroupParameters().Initialize(ASN1::secp128r1());

ECP::Point point;
encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());
cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

encryptor.AccessKey().SetPublicElement(point);


encryptor.AccessKey().ThrowIfInvalid(prng, 3);

PrintPublicKey(encryptor.GetKey());



string em0; // encrypted message
StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(em0) ) );
cout&lt;&lt;""encrypted msg: ""&lt;&lt;em0&lt;&lt;""  and its length: ""&lt;&lt;em0.length()&lt;&lt;endl;
</code></pre>
","<p>As <a href=""https://stackoverflow.com/users/608639/jww"">jww</a> suggested I have successfully completed encryption and decryption.
Below are the code snippets if anyone wants.</p>

<h3>Decryption</h3>

<pre><code>string decrypt(std::string encryptedMessage ,  std::string   privateKeyExponent)
{
    string decryptedMessage;
    try
    {
        AutoSeededRandomPool prng;

        //since the 'privateKeyExponent' is in base-64 format use Base64Decoder
        StringSource ss(privateKeyExponent, true /*pumpAll*/, new CryptoPP::Base64Decoder);

        Integer x;
        x.Decode(ss, ss.MaxRetrievable(), Integer::UNSIGNED);

        ECIES&lt;ECP&gt;::Decryptor decryptor;

        //curve used is secp256k1
        //make decryptor's access key using decoded private exponent's value
        decryptor.AccessKey().Initialize(ASN1::secp256k1(), x);

        //check whether decryptor's access key is valid or not
        bool valid = decryptor.AccessKey().Validate(prng, 3);
        if(!valid)
           decryptor.AccessKey().ThrowIfInvalid(prng, 3);

        cout &lt;&lt; ""Exponent is valid for P-256k1"" &lt;&lt; endl;

        //decrypt the message using private key
        StringSource ss2 (encryptedMessage, true, new PK_DecryptorFilter(prng, decryptor, new StringSink(decryptedMessage) ) );
        cout &lt;&lt;""decrypted msg: ""&lt;&lt; decryptedMessage&lt;&lt;""  and its length: ""&lt;&lt;decryptedMessage.length() &lt;&lt; endl;

    }
    catch(const CryptoPP::Exception&amp; ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }
    return decryptedMessage;
}
</code></pre>

<h3>Encryption</h3>

<pre><code>string encrypt(std::string message ,  std::string  compressedPublicKeyPoint)
{
    string encryptedMessage;
    try
    {
        AutoSeededRandomPool prng;

        //public key is a point consisting of ""public key point x"" and ""public key point y""
        //compressed public key also known as ""public-point"" formed using point-compression of public key


        //since the key is in base-64 format use Base64Decoder
        StringSource ss(compressedPublicKeyPoint, true, new CryptoPP::Base64Decoder);
     ECIES&lt;ECP&gt;::Encryptor encryptor;

        //curve used is secp256k1
        encryptor.AccessKey().AccessGroupParameters()
       .Initialize(ASN1::secp256k1());

        //get point on the used curve
        ECP::Point point;
        encryptor.GetKey().GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());
        cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
        cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

        //set encryptor's public element
        encryptor.AccessKey().SetPublicElement(point);

        //check whether the encryptor's access key thus formed is valid or not
        encryptor.AccessKey().ThrowIfInvalid(prng, 3);

        // encrypted message
        StringSource ss1(message, true, new PK_EncryptorFilter(prng, encryptor, new StringSink(encryptedMessage) ) );
        cout&lt;&lt;""encrypted msg: ""&lt;&lt;encryptedMessage&lt;&lt;""  and its length: ""&lt;&lt;encryptedMessage.length()&lt;&lt;endl;
    }
    catch(const CryptoPP::Exception&amp; ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }

    return encryptedMessage;
}
</code></pre>
","955","<c++><public-key-encryption><crypto++><elliptic-curve>","4","0","3","2015-06-18 09:52:44","30912098","11","1","3632958","","2015-06-17 07:26:08","2015-06-16 06:58:26",""
"25116612","cryptoPP AES, weird encryption output","<p>I am new and testing out cryptoPP, I am trying out to encrypt a single character at a time using cryptoPP, I notice some characters do not encrypt properly and exhibit weird behaviour like more or less than 16 characters, or weird arrangements.</p>

<p>The code I am using is:</p>

<pre><code>std::string data;
std::cin &gt;&gt; data;

std::string plaintext = data;

std::string ciphertext;
byte key[16 ] = {1,2,3,5,6,7,8,9,0,1,2,3,4,5,6} ; 
byte iv[ 16 ]={1,2,3,5,6,7,8,9,0,1,2,3,4,5,6};

memset( key, 0, sizeof(key));
memset( iv, 0, sizeof(iv) );

CryptoPP::AES::Encryption aesEncryption(key, 16);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length());
stfEncryptor.MessageEnd();

std::cout &lt;&lt; ciphertext &lt;&lt; std::endl;

std::ofstream file(""d:\\log.txt"", std::ofstream::out | std::ofstream::app);
file.write(ciphertext.c_str(), ciphertext.size());
file.close();

system(""PAUSE"");
</code></pre>

<p>The decrypt code is as below:</p>

<pre><code>byte key[16 ] = {1,2,3,5,6,7,8,9,0,1,2,3,4,5,6} ; 
byte iv[ 16 ]={1,2,3,5,6,7,8,9,0,1,2,3,4,5,6};

memset( key, 0, 16  );
memset( iv, 0, 16 );

std::string decryptedtext;
std::string test = get_file_contents(""d:\\log.txt"");

for (int i = 0; i &lt; test.length() ; i += 16)  {

    std::string block = test.substr(i, i + 16);
    test.replace(i, i + 16, block);

    CryptoPP::AES::Decryption aesDecryption(key, 16);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( block.c_str() ), 16 );
    stfDecryptor.MessageEnd();
}

std::cout &lt;&lt; decryptedtext &lt;&lt; std::endl;

std::ofstream fout(""d:\\aesencrypt.txt"");
fout &lt;&lt; decryptedtext;
</code></pre>

<p>It works if I do not type certain characters. Issues happen when I typed in the character ""c"" or ""r"", it becomes weird and I am unable to parse 16 characters when I decrypt. 
The decrypt will fail because the encrypted text are not in alignment or more or less than 16 characters.</p>
","<p>I run exactly your code without write/read to/from files and it works. (It works with 'c' and 'r' as well). I combined those two fragments into one, eliminated files and assigned <code>test = ciphertext;</code>. Perhaps the problem is with reading/writing into files...</p>

<p>It does not matter that you encrypt one character or more: CBC mode adds padding if the input is not a multiple of the block size.  </p>
","949","<c++><encryption><aes><crypto++>","0","0","1","2014-10-02 16:33:44","","2","","608639","","2014-08-07 05:32:00","2014-08-04 10:27:01",""
"41085445","File Encryption with AES in Java decrtypion in C++ using cryptopp","<p>I'm experimenting with Crypto++ library and javax.crypto library.</p>

<p>So what I'm trying to do is... encrypting a text file using AES with CFB mode in java, and then decrypt the encrypted file using crypto++ in C++</p>

<p>here is the java class for encryption</p>

<pre><code>public class CryptoUtils {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/CFB8/NoPadding"";

    Charset CHARSET = Charset.forName(""UTF8"");

    public static void encrypt(byte[] key, byte[] iv, File inputFile, File outputFile) throws CryptoException {
        doCrypto(Cipher.ENCRYPT_MODE, key, iv, inputFile, outputFile);
    }

    public static void decrypt(byte[] key, byte[] iv, File inputFile, File outputFile) throws CryptoException {
        doCrypto(Cipher.DECRYPT_MODE, key, iv, inputFile, outputFile);
    }

    private static void doCrypto(int cipherMode, byte[] key, byte[] iv, File inputFile, File outputFile)
            throws CryptoException {
        try {
            Key secretKey = new SecretKeySpec(key, ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);

            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(cipherMode, secretKey, ivSpec);

            FileInputStream inputStream = new FileInputStream(inputFile);
            byte[] inputBytes = new byte[(int) inputFile.length()];
            inputStream.read(inputBytes);

            byte[] outputBytes = cipher.doFinal(inputBytes);

            FileOutputStream outputStream = new FileOutputStream(outputFile);
            outputStream.write(outputBytes);

            inputStream.close();
            outputStream.close();
        } catch (Exception e) {
            throw new CryptoException(""Error encrypting/decrypting file"", e);
        }
    }
}
</code></pre>

<p>here is the calling class, with key and iv initialized...</p>

<pre><code>public class Main {
    public static void main(String[] args) {
        byte[] key = new byte[16];
        byte[] iv = new byte[16];

        for(int i = 0; i &lt; key.length; i++) {
            key[i] = 0x0;
            iv[i] = 0x0;
        }

        Charset CHARSET = Charset.forName(""UTF8"");

        String keyStr = new String(key);
        String ivStr = new String(iv);

        File inputFile = new File(""target.txt"");
        File encryptedFile = new File(""target.enc"");
        File decryptedFile = new File(""target.dec"");

        try {
            //CryptoUtils.decrypt(keyStr.getBytes(CHARSET), ivStr.getBytes(CHARSET), encryptedFile, decryptedFile);
            //CryptoUtils.encrypt(keyStr.getBytes(CHARSET), ivStr.getBytes(CHARSET), inputFile, encryptedFile);
            CryptoUtils.encrypt(key, iv, inputFile, encryptedFile);
            //CryptoUtils.decrypt(key, iv, encryptedFile, decryptedFile);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>and here is the C++ code... </p>

<pre><code>byte key[AES::DEFAULT_KEYLENGTH];
byte iv[AES::DEFAULT_KEYLENGTH];

void encrypt64(char* in, char* out) {
    CFB_Mode&lt;AES&gt;::Encryption e;
    e.SetKeyWithIV(key, sizeof(key), iv);

    FileSource f(in, true,
                new StreamTransformationFilter(e,
                new HexEncoder(new FileSink(out))));
}

void decrypt64(char* in, char* out) {
    CFB_Mode&lt;AES&gt;::Decryption d;
    d.SetKeyWithIV(key, sizeof(key), iv);

    FileSource f(in, true,
                new HexDecoder(new StreamTransformationFilter(d, new FileSink(out))));
}

int main() {
    memset(key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH);
    memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);

    decrypt64(""target.enc"", ""target.dec2"");

    return 0;
}
</code></pre>

<p>as its apparent key and iv in both codes are same. still it doesn't work.. </p>

<p>I've been at this hours now.. but as I'm a noob in cryptography and cryptography libraries.. so could not find any answer or may be found but didnt got into my head... :/</p>

<p>anyway.. please let me know what I'm doing wrong and how can I fix it... thanks in advance :)</p>
","","948","<java><c++><crypto++>","1","","0","2016-12-11 11:15:38","","4","3","5860919","","2016-12-11 11:15:38","2016-12-11 11:04:40",""
"35789830","Can't Compile Crypto++ Library for IOS","<p>I'm trying to build a static cryptopp library for ios. I'm basing my steps from these sites:
<a href=""http://cryptopp.com/wiki/IOS_(Command_Line)#Xcode_Project"" rel=""nofollow noreferrer"">http://cryptopp.com/wiki/IOS_(Command_Line)#Xcode_Project</a> <br>
<a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow noreferrer"">https://github.com/noloader/cryptopp-5.6.2-ios</a> <br>
<a href=""https://www.cryptopp.com/"" rel=""nofollow noreferrer"">https://www.cryptopp.com/</a></p>

<p>1.) I downloaded the latest cryptopp version 5.6.3 <br>
2.) I downloaded noloader's cryptopp-5.6.2-ios becasue it has updated:</p>

<pre><code>setenv-ios.sh - i had to edit this to search for sdk 9.2
GNUmakefile
config.h
build-for-ios.sh
</code></pre>

<p><br>
3.) I copied the four files to my cryptopp 5.6.3 directory and replaced GNUmakefile and config.h
<br>
4.) I checked out IOS_Command_Line instruction to invoke setenv-ios.sh first.
<br>
5.) Then, as noloader said, run build-for-ios.sh.</p>

<p>However, i'm getting this error:
<a href=""https://i.stack.imgur.com/LtTlJ.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LtTlJ.png"" alt=""enter image description here""></a></p>

<p><br>
Has anyone successfully built the library using the latest ios SDK and cryptopp version? If so, can you please point me to the right direction. Thanks.</p>
","<p>The documentation was not correct under <a href=""https://cryptopp.com/wiki/IOS_%28Command_Line%29#Build_the_Library"" rel=""nofollow"">IOS (Command Line) | Build the Library</a>. After setting the environment with <code>setenv-ios.sh</code>, you should use <code>GNUmakefile-cross</code>:</p>

<pre><code>$ make -f GNUmakefile-cross static dynamic cryptest.exe
clang++ -DNDEBUG -g2 -Os -fPIC -pipe -Wall -Wno-delete-non-virtual-dtor  -arch armv7 -isysroot 
/Applications/Xcode-5_1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk
-stdlib=libc++ -c cryptlib.cpp
clang++ -DNDEBUG -g2 -Os -fPIC -pipe -Wall -Wno-delete-non-virtual-dtor  -arch armv7 -isysroot 
/Applications/Xcode-5_1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk
-stdlib=libc++ -c cpu.cpp
clang++ -DNDEBUG -g2 -Os -fPIC -pipe -Wall -Wno-delete-non-virtual-dtor  -arch armv7 -isysroot 
/Applications/Xcode-5_1.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS7.1.sdk
-stdlib=libc++ -c 3way.cpp
...
</code></pre>

<p>I <em>thought</em> we updated the iOS procedures when we updated the Android procedures. I'm not sure what went wrong the documentation updates.</p>

<hr>

<p>We checked in the scripts for <code>setenv-ios.sh</code>, <code>setenv-android.sh</code> and <code>setenv-embedded.sh</code> in March 2016. <code>GNUmakefile-cross</code> was already in the library. Also see <a href=""http://github.com/weidai11/cryptopp/commit/a78b9dfa0840f92fed9d61f1a4a3b5ce403e55fd"" rel=""nofollow"">Commit a78b9dfa0840f92f, Added iOS environment and test script</a> and <a href=""http://github.com/weidai11/cryptopp/commit/22d6374ce7151ad030a3194edf2cb37a30318820"" rel=""nofollow"">Commit 22d6374ce7151ad0, Added Android and embedded environment and test script</a>.</p>

<p>All you should need to do now is the following:</p>

<pre><code>git clone https://github.com/weidai11/cryptopp.git
cd cryptopp

. ./setenv-ios.sh
make -f GNUmakefile-cross static dynamic cryptest.exe
...
</code></pre>

<p>The new/updated files will be available in the ZIP at the next Crypto++ release, which will be either 5.6.4 or 5.7.0.</p>
","944","<ios><xcode><static-libraries><crypto++>","1","1","1","2016-03-09 21:59:00","35875565","2","","608639","","2016-03-05 03:19:43","2016-03-04 06:55:31",""
"28233023","Different results when encrypting with Common Crypto and Crypto++ with AES","<p>I get different results when encrypting the same file (binary data) with the same key with Apple's Common Crypto and Crypto++. The algorithm I'm using is AES.</p>

<p>Here's the code in Objective C using Common Crypto:</p>

<pre><code>void FileUtil::writeToFileEncrypt(string fileName, const void *data, int size, string key, int *sizeOut)
{
    int numBytesEncrypted = 0;
    char keyPtr[kCCKeySizeAES256+1];

    if (key.length() &gt; 32)
    {
        key = key.substr(0, 32);
    }

    memcpy(keyPtr, key.c_str(), sizeof(keyPtr));

    if (key.length() &lt; 32)
    {
        for (int i = key.length(); i &lt; 32; i++)
        {
            keyPtr[i] = '0';
        }
    }

    size_t bufferSize = size + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);

    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                      keyPtr, kCCKeySizeAES256,
                                      NULL /* initialization vector (optional) */,
                                      data, size, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);

    if (cryptStatus == kCCSuccess) {
        cout &lt;&lt; ""encrypt success"" &lt;&lt; endl;
    }

    ofstream myfile;
    myfile.open (fileName.c_str(), ios::out | ios::binary);
    myfile.write((const char *)buffer, numBytesEncrypted);
    myfile.close();

    free(buffer);

    *sizeOut = numBytesEncrypted;
}
</code></pre>

<p>Here's the code in C++ using Crypto++</p>

<pre><code>void EncryptUtils::encrypt(string fileName, unsigned char *chars, string key, int *length, int dataLength)
{
    unsigned char *iv = (unsigned char *)""0000000000000000"";

    char keyPtr[32 + 1];

    if (key.length() &gt; 32)
    {
        key = key.substr(0, 32);
    }

    memcpy(keyPtr, key.c_str(), sizeof(keyPtr));

    if (key.length() &lt; 32)
    {
        for (int i = key.length(); i &lt; 32; i++)
        {
            keyPtr[i] = '0';
        }
    }
    keyPtr[32] = '\0';

    CryptoPP::AES::Encryption aesEncryption((unsigned char *)keyPtr, 32);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    int newBufSize = (sizeof(unsigned char *) * dataLength) + 32;
    unsigned char *newBuf = (unsigned char *)malloc(newBufSize);
    CryptoPP::ArraySink *arraySink = new CryptoPP::ArraySink(newBuf, newBufSize);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, arraySink, CryptoPP::StreamTransformationFilter::PKCS_PADDING);
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(chars), (unsigned int)dataLength);
    stfEncryptor.MessageEnd();

    *length = arraySink-&gt;TotalPutLength();

    ofstream myfile;
    myfile.open (fileName.c_str(), ios::out | ios::binary);
    myfile.write((const char *)newBuf, *length);
    myfile.close();
}
</code></pre>

<p>I need to get both of them to produce the same results. Is there something I overlooked?</p>
","<ol>
<li><p>The ""Objective-C"" version is not written in Objective-C, it is in C++. the actual encryption used <code>CCCrypt</code> which is plain ""C"".</p></li>
<li><p>The ""Objective-C"" version has no <code>iv</code> supplied so it defaults to all zeros. The C++ version supplies an <code>iv</code> of ASCII ""0"" characters, that is not the same as all zero data.This is probably the error.</p></li>
<li><p>Provide input and output hex data dumps for each including key, iv, data in and data out immediately prior to and after the encryption calls.</p></li>
</ol>
","937","<c++><objective-c><encryption><crypto++><commoncrypto>","2","1","2","2015-01-30 20:16:04","28236272","2","","","","","2015-01-30 09:41:16",""
"28233023","Different results when encrypting with Common Crypto and Crypto++ with AES","<p>I get different results when encrypting the same file (binary data) with the same key with Apple's Common Crypto and Crypto++. The algorithm I'm using is AES.</p>

<p>Here's the code in Objective C using Common Crypto:</p>

<pre><code>void FileUtil::writeToFileEncrypt(string fileName, const void *data, int size, string key, int *sizeOut)
{
    int numBytesEncrypted = 0;
    char keyPtr[kCCKeySizeAES256+1];

    if (key.length() &gt; 32)
    {
        key = key.substr(0, 32);
    }

    memcpy(keyPtr, key.c_str(), sizeof(keyPtr));

    if (key.length() &lt; 32)
    {
        for (int i = key.length(); i &lt; 32; i++)
        {
            keyPtr[i] = '0';
        }
    }

    size_t bufferSize = size + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);

    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128, kCCOptionPKCS7Padding,
                                      keyPtr, kCCKeySizeAES256,
                                      NULL /* initialization vector (optional) */,
                                      data, size, /* input */
                                      buffer, bufferSize, /* output */
                                      &amp;numBytesEncrypted);

    if (cryptStatus == kCCSuccess) {
        cout &lt;&lt; ""encrypt success"" &lt;&lt; endl;
    }

    ofstream myfile;
    myfile.open (fileName.c_str(), ios::out | ios::binary);
    myfile.write((const char *)buffer, numBytesEncrypted);
    myfile.close();

    free(buffer);

    *sizeOut = numBytesEncrypted;
}
</code></pre>

<p>Here's the code in C++ using Crypto++</p>

<pre><code>void EncryptUtils::encrypt(string fileName, unsigned char *chars, string key, int *length, int dataLength)
{
    unsigned char *iv = (unsigned char *)""0000000000000000"";

    char keyPtr[32 + 1];

    if (key.length() &gt; 32)
    {
        key = key.substr(0, 32);
    }

    memcpy(keyPtr, key.c_str(), sizeof(keyPtr));

    if (key.length() &lt; 32)
    {
        for (int i = key.length(); i &lt; 32; i++)
        {
            keyPtr[i] = '0';
        }
    }
    keyPtr[32] = '\0';

    CryptoPP::AES::Encryption aesEncryption((unsigned char *)keyPtr, 32);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    int newBufSize = (sizeof(unsigned char *) * dataLength) + 32;
    unsigned char *newBuf = (unsigned char *)malloc(newBufSize);
    CryptoPP::ArraySink *arraySink = new CryptoPP::ArraySink(newBuf, newBufSize);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, arraySink, CryptoPP::StreamTransformationFilter::PKCS_PADDING);
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(chars), (unsigned int)dataLength);
    stfEncryptor.MessageEnd();

    *length = arraySink-&gt;TotalPutLength();

    ofstream myfile;
    myfile.open (fileName.c_str(), ios::out | ios::binary);
    myfile.write((const char *)newBuf, *length);
    myfile.close();
}
</code></pre>

<p>I need to get both of them to produce the same results. Is there something I overlooked?</p>
","<p>This is wrong:</p>

<pre><code>memcpy(keyPtr, key.c_str(), sizeof(keyPtr));
</code></pre>

<p>It tries to copy 33 bytes. I think you need something like:</p>

<pre><code>size_t ksize = std::min(sizeof(keyPtr), key.size());
assert(ksize == 16 || ksize == 24 || ksize == 32);
</code></pre>

<h2>-----</h2>

<p>In general, the design is wrong:</p>

<pre><code>keyPtr[32] = '\0';
</code></pre>

<p>Keys are binary, and not ASCII strings. If you are using passwords, then its still wrong since you should be using a KDF to digest the password into a suitable key.</p>

<h2>-----</h2>

<p>The common Crypto code lacks an IV and may not use the same padding as the Crypto++ example.</p>

<h2>-----</h2>

<p>The use of AES appears to be wrong. It appears your are operating the cipher in ECB mode, so its only providing confidentiality <strong><em>if</em></strong> the data is less than a block size. Its subject to reordering and manipulation, so its not providing authenticity assurances. You should use an <a href=""http://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow"">Authenticated Encryption</a> like <a href=""http://www.cryptopp.com/wiki/Eax_mode"" rel=""nofollow"">EAX</a>, <a href=""http://www.cryptopp.com/wiki/Gcm_mode"" rel=""nofollow"">GCM</a> or <a href=""http://www.cryptopp.com/wiki/Ccm_mode"" rel=""nofollow"">CCM</a> mode.</p>

<p>Since Common Crypto is lame (it does not provide authenticated encryption modes) and Crypto++ provides everything you need (and it runs nearly everywhere), you should use Crypto++ and an authenticated encryption mode.</p>
","937","<c++><objective-c><encryption><crypto++><commoncrypto>","2","0","2","2015-01-30 20:16:04","28236272","2","","","","","2015-01-30 09:41:16",""
"3515694","Why are Crypto++ and Ruby generating slightly different SHA-1 hashes?","<p>I'm using two different libraries to generate a SHA-1 hash for use in file validation - an older version of the <a href=""http://www.cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> library and the Digest::SHA1 class implemented by Ruby. While I've seen other instances of mismatched hashes caused by encoding differences, the two libraries are outputting hashes that are <em>almost</em> identical.</p>

<p>For instance, passing a file through each process produces the following results:</p>

<p>Crypto++
01c15e4f46d8181b984fa2a2c740f8f67130acac</p>

<p>Ruby:
eac15e4f46d8181b984fa2a2c740f8f67130acac</p>

<p>As you can see, only the first two characters of the hash string are different, and this behavior repeats itself over many files. I've taken a look at the source code for each implementation, and the only difference I found at first glance was in the data hex that is being used for the 160-bit hashing. I have no idea how that hex is used in the algorithm, and I figured it'd probably be quicker for me to ask the question in case anyone had encountered this issue before.</p>

<p>I've included the data from the respective libraries below. I also included the values from OpenSSL, since each of the three libraries had slightly different values.</p>

<p>Crypto++:</p>

<pre><code>digest[0] = 0x67452301L;
digest[1] = 0xEFCDAB89L;
digest[2] = 0x98BADCFEL;
digest[3] = 0x10325476L;
digest[4] = 0xC3D2E1F0L;
</code></pre>

<p>Ruby:</p>

<pre><code>context-&gt;state[0] = 0x67452301;
context-&gt;state[1] = 0xEFCDAB89;
context-&gt;state[2] = 0x98BADCFE;
context-&gt;state[3] = 0x10325476;
context-&gt;state[4] = 0xC3D2E1F0;
</code></pre>

<p>OpenSSL:</p>

<pre><code>#define INIT_DATA_h0 0x67452301UL
#define INIT_DATA_h1 0xefcdab89UL
#define INIT_DATA_h2 0x98badcfeUL
#define INIT_DATA_h3 0x10325476UL
#define INIT_DATA_h4 0xc3d2e1f0UL
</code></pre>

<p>By the way, here is the code being used to generate the hash in Ruby. I do not have access to the source code for the Crypto++  implementation.</p>

<pre><code>File.class_eval do
    def self.hash_digest filename, options = {}
        opts = {:buffer_length =&gt; 1024, :method =&gt; :sha1}.update(options)
        hash_func = (opts[:method].to_s == 'sha1') ? Digest::SHA1.new : Digest::MD5.new
        open(filename, ""r"") do |f|
            while !f.eof
                b = f.read
                hash_func.update(b)
            end
        end
        hash_func.hexdigest
    end
end
</code></pre>
","<p>I would guess that you are off by a byte in printing out the SHA-1 hashes. Can we see the code that is printing them? If not, here are a couple of potentially useful diagnostics:</p>

<ol>
<li><p>Make a very short file (say, one word), and put its contents in as a hex string at <a href=""http://www.fileformat.info/tool/hash.htm"" rel=""nofollow noreferrer"">http://www.fileformat.info/tool/hash.htm</a>. You would need to know exactly the hex contents of the file, though. You can use xxd to that on Unix, but you'll have to watch out for endianness issues. I'm not sure how to do it on other OSs. </p></li>
<li><p>Does running the same file through the same SHA-1 implementation several times always print out the same value in that first byte? If so, does that value change when you change files?</p></li>
</ol>
","929","<c++><ruby><hash><sha1><crypto++>","4","2","2","2010-08-22 04:41:24","","5","","172669","","2010-08-18 19:21:15","2010-08-18 19:02:27",""
"3515694","Why are Crypto++ and Ruby generating slightly different SHA-1 hashes?","<p>I'm using two different libraries to generate a SHA-1 hash for use in file validation - an older version of the <a href=""http://www.cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> library and the Digest::SHA1 class implemented by Ruby. While I've seen other instances of mismatched hashes caused by encoding differences, the two libraries are outputting hashes that are <em>almost</em> identical.</p>

<p>For instance, passing a file through each process produces the following results:</p>

<p>Crypto++
01c15e4f46d8181b984fa2a2c740f8f67130acac</p>

<p>Ruby:
eac15e4f46d8181b984fa2a2c740f8f67130acac</p>

<p>As you can see, only the first two characters of the hash string are different, and this behavior repeats itself over many files. I've taken a look at the source code for each implementation, and the only difference I found at first glance was in the data hex that is being used for the 160-bit hashing. I have no idea how that hex is used in the algorithm, and I figured it'd probably be quicker for me to ask the question in case anyone had encountered this issue before.</p>

<p>I've included the data from the respective libraries below. I also included the values from OpenSSL, since each of the three libraries had slightly different values.</p>

<p>Crypto++:</p>

<pre><code>digest[0] = 0x67452301L;
digest[1] = 0xEFCDAB89L;
digest[2] = 0x98BADCFEL;
digest[3] = 0x10325476L;
digest[4] = 0xC3D2E1F0L;
</code></pre>

<p>Ruby:</p>

<pre><code>context-&gt;state[0] = 0x67452301;
context-&gt;state[1] = 0xEFCDAB89;
context-&gt;state[2] = 0x98BADCFE;
context-&gt;state[3] = 0x10325476;
context-&gt;state[4] = 0xC3D2E1F0;
</code></pre>

<p>OpenSSL:</p>

<pre><code>#define INIT_DATA_h0 0x67452301UL
#define INIT_DATA_h1 0xefcdab89UL
#define INIT_DATA_h2 0x98badcfeUL
#define INIT_DATA_h3 0x10325476UL
#define INIT_DATA_h4 0xc3d2e1f0UL
</code></pre>

<p>By the way, here is the code being used to generate the hash in Ruby. I do not have access to the source code for the Crypto++  implementation.</p>

<pre><code>File.class_eval do
    def self.hash_digest filename, options = {}
        opts = {:buffer_length =&gt; 1024, :method =&gt; :sha1}.update(options)
        hash_func = (opts[:method].to_s == 'sha1') ? Digest::SHA1.new : Digest::MD5.new
        open(filename, ""r"") do |f|
            while !f.eof
                b = f.read
                hash_func.update(b)
            end
        end
        hash_func.hexdigest
    end
end
</code></pre>
","<p>This isn't making much sense.  If there were something wrong with the SHA1 implementation, such as with those numbers, it would likely produce hashes that are completely different than the real SHA1 hashes, rather than just one byte off.  Even if there were something wrong with your file reading loop, that it would drop a newline or something, you would still get a completely different hash by changing one byte in the stream, it wouldn't be one byte off of the real SHA1 hash.</p>

<p>If I do use your method in the following program, I get the correct results.</p>

<pre><code>#!/usr/bin/env ruby
require 'digest/sha1'
require 'digest/md5'

File.class_eval do
  def self.hash_digest filename, options = {}
    opts = {:buffer_length =&gt; 1024, :method =&gt; :sha1}.update(options)
    hash_func = (opts[:method].to_s == 'sha1') ? Digest::SHA1.new : Digest::MD5.new
    open(filename, ""r"") do |f|
      while !f.eof
        b = f.read
        hash_func.update(b)
      end
    end
    hash_func.hexdigest
  end
end

puts File.hash_digest(ARGV[0])
</code></pre>

<p>And its output compared with that of OpenSSL.</p>

<pre><code>tmp$ dd if=/dev/urandom of=random.bin bs=1MB count=1
1+0 records in
1+0 records out
1000000 bytes (1.0 MB) copied, 0.287903 s, 3.5 MB/s
tmp$ ./digest.rb random.bin
a511d8153426ebea4e4694cde78db4e3a9e413d1
tmp$ openssl sha1 random.bin
SHA1(random.bin)= a511d8153426ebea4e4694cde78db4e3a9e413d1
</code></pre>

<p>So there's nothing wrong with your hashing method.  Something is going wrong between its return value and it being printed.</p>
","929","<c++><ruby><hash><sha1><crypto++>","4","2","2","2010-08-22 04:41:24","","5","","172669","","2010-08-18 19:21:15","2010-08-18 19:02:27",""
"42044531","How to load Base64 RSA keys in Crypto++","<p>I'm trying to write helper functions for a program I'm making and I need to return the keys as strings. Found a way to convert the RSA keys from PrivateKey/PublicKey to Base64 string.</p>

<pre class=""lang-cpp prettyprint-override""><code>int main()
{
    //Generate params
    AutoSeededRandomPool rng;
    InvertibleRSAFunction params;
    params.Initialize(rng, 4096);

    //Generate Keys
    RSA::PrivateKey privKey(params);
    RSA::PublicKey pubKey(params);

    //Encode keys to Base64
    string encodedPriv, encodedPub;

    Base64Encoder privKeySink(new StringSink(encodedPriv));
    privKey.DEREncode(privKeySink);

    Base64Encoder pubKeySink(new StringSink(encodedPub));
    privKey.DEREncode(pubKeySink);

    RSA::PrivateKey pvKeyDecoded;
    RSA::PublicKey pbKeyDecoded;

    //how to decode...

    system(""pause"");
    return 0;
}
</code></pre>

<p>Now, how do I load the encoded keys back? I wasn't able to find any information on that.</p>
","<blockquote>
<pre><code>RSA::PrivateKey pvKeyDecoded;
RSA::PublicKey pbKeyDecoded;

//how to decode...
</code></pre>
</blockquote>

<p>You can do something like:</p>

<pre><code>StringSource ss(encodedPriv, true, new Base64Decoder);
pvKeyDecoded.BERDecode(ss);
</code></pre>

<hr>

<p>You should also fix this:</p>

<pre><code>Base64Encoder pubKeySink(new StringSink(encodedPub));
privKey.DEREncode(pubKeySink);  // pubKey.DEREncode
</code></pre>

<p>And you should call <code>MessageEnd()</code> once the key is written:</p>

<pre><code>Base64Encoder privKeySink(new StringSink(encodedPriv));
privKey.DEREncode(privKeySink);
privKeySink.MessageEnd();

Base64Encoder pubKeySink(new StringSink(encodedPub));
pubKey.DEREncode(pubKeySink);
pubKeySink.MessageEnd();
</code></pre>

<p>You might also find <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow noreferrer"">Keys and Formats</a> helpful from the Crypto++ wiki.</p>
","907","<c++><encryption><rsa><crypto++>","2","3","1","2017-02-05 16:04:54","42052556","0","","608639","","2017-02-05 13:27:13","2017-02-04 19:16:26",""
"34237971","Conducting Diffie Hellman between Java and Crypto++ (C++)","<p>I want to encrypt some data between a c++ client and a java server. Searching the web I found crypto++ to use on the client and on the java side to use the KeyAgreement built in java class(btw, I already have bouncycastle jar in my project, I can use it if it's somehow better than the built in one).</p>

<p>I was able to perform DH on on every side with itself as an example, but due to key sizes I cannot make them to agree on a secret key.</p>

<p>My C++ code:</p>

<pre><code>// g++ -g3 -ggdb -O0 -I. -I/usr/include/cryptopp dh-agree.cpp -o dh-agree.exe -lcryptopp -lpthread
// g++ -g -O2 -I. -I/usr/include/cryptopp dh-agree.cpp -o dh-agree.exe -lcryptopp -lpthread

#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;

#include &lt;sys/socket.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

#include &lt;string&gt;
using std::string;

#include &lt;stdexcept&gt;
using std::runtime_error;

#include ""osrng.h""
using CryptoPP::AutoSeededRandomPool;

#include ""integer.h""
using CryptoPP::Integer;

#include ""nbtheory.h""
using CryptoPP::ModularExponentiation;

#include ""dh.h""
using CryptoPP::DH;

#include ""secblock.h""
using CryptoPP::SecByteBlock;

#include &lt;hex.h&gt;
using CryptoPP::HexEncoder;

#include &lt;filters.h&gt;
using CryptoPP::StringSink;
int main(int argc, char** argv)
{
    try
    {
        // RFC 5114, 1024-bit MODP Group with 160-bit Prime Order Subgroup
        // http://tools.ietf.org/html/rfc5114#section-2.1
        Integer p(""0xB10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6""
            ""9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0""
            ""13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70""
            ""98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0""
            ""A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708""
            ""DF1FB2BC2E4A4371"");

        Integer g(""0xA4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F""
            ""D6406CFF14266D31266FEA1E5C41564B777E690F5504F213""
            ""160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1""
            ""909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A""
            ""D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24""
            ""855E6EEB22B3B2E5"");

        Integer q(""0xF518AA8781A8DF278ABA4E7D64B7CB9D49462353"");        

        // Schnorr Group primes are of the form p = rq + 1, p and q prime. They
        // provide a subgroup order. In the case of 1024-bit MODP Group, the
        // security level is 80 bits (based on the 160-bit prime order subgroup).       

        // For a compare/contrast of using the maximum security level, see
        // dh-agree.zip. Also see http://www.cryptopp.com/wiki/Diffie-Hellman
        // and http://www.cryptopp.com/wiki/Security_level .

        DH dh;
        AutoSeededRandomPool rnd;

        dh.AccessGroupParameters().Initialize(p, q, g);

        if(!dh.GetGroupParameters().ValidateGroup(rnd, 3)) 
            throw runtime_error(""Failed to validate prime and generator"");

        size_t count = 0;

        p = dh.GetGroupParameters().GetModulus();
        q = dh.GetGroupParameters().GetSubgroupOrder();
        g = dh.GetGroupParameters().GetGenerator();

        // http://groups.google.com/group/sci.crypt/browse_thread/thread/7dc7eeb04a09f0ce
        Integer v = ModularExponentiation(g, q, p);
        if(v != Integer::One())
            throw runtime_error(""Failed to verify order of the subgroup"");

        //////////////////////////////////////////////////////////////

        SecByteBlock priv(dh.PrivateKeyLength());
        SecByteBlock pub(dh.PublicKeyLength());
        dh.GenerateKeyPair(rnd, priv, pub);
        printf(""lengths: %d %d\n"",dh.PrivateKeyLength(),dh.PublicKeyLength());
        byte* pubData = pub.data();     
        for(int j = 0; j &lt; pub.size()-1; j++)
            printf(""%02X:"", pubData[j]);    
        printf(""%02X\n"", pubData[pub.size()-1]);    
        // Send pub to Java
        sendData(pub.data(),pub.size());
        // Read pubB from Java
        byte pubBbytes[10000];
        int n = readData(pubBbytes,sizeof(pubBbytes));
        SecByteBlock pubB(pubBbytes,n);
        //////////////////////////////////////////////////////////////

        SecByteBlock sharedA(dh.AgreedValueLength());

        if(!dh.Agree(sharedA, priv, pubB))
            throw runtime_error(""Failed to reach shared secret (1A)"");


        //////////////////////////////////////////////////////////////

        Integer a;

        a.Decode(sharedA.BytePtr(), sharedA.SizeInBytes());
        cout &lt;&lt; ""Shared secret (A): "" &lt;&lt; std::hex &lt;&lt; a &lt;&lt; endl;
    }

    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return -2;
    }

    catch(const std::exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return -1;
    }

    return 0;
}
</code></pre>

<p>Server code in Java:</p>

<pre><code>package test;
/*
 * Copyright (c) 1997, 2001, Oracle and/or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Oracle nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.KeyAgreement;
import javax.crypto.spec.DHParameterSpec;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 2 parties: Alice and Bob.
 *
 * By default, preconfigured parameters (1024-bit prime modulus and base
 * generator used by SKIP) are used.
 * If this program is called with the ""-gen"" option, a new set of
 * parameters is created.
 */

public class DHKeyAgreement2 {

    private DHKeyAgreement2() {}

    public final static String sP = ""B10B8F96A080E01DDE92DE5EAE5D54EC52C99FBCFB06A3C6"" +
            ""9A6A9DCA52D23B616073E28675A23D189838EF1E2EE652C0"" +
            ""13ECB4AEA906112324975C3CD49B83BFACCBDD7D90C4BD70"" +
            ""98488E9C219A73724EFFD6FAE5644738FAA31A4FF55BCCC0"" +
            ""A151AF5F0DC8B4BD45BF37DF365C1A65E68CFDA76D4DA708"" +
            ""DF1FB2BC2E4A4371"";

    public final static String sG = ""A4D1CBD5C3FD34126765A442EFB99905F8104DD258AC507F"" +
            ""D6406CFF14266D31266FEA1E5C41564B777E690F5504F213"" +
            ""160217B4B01B886A5E91547F9E2749F4D7FBD7D3B9A92EE1"" +
            ""909D0D2263F80A76A6A24C087A091F531DBF0A0169B6A28A"" +
            ""D662A4D18E73AFA32D779D5918D08BC8858F4DCEF97C2A24"" +
            ""855E6EEB22B3B2E5"";


    public static void main(String argv[]) {
        try {
            DHKeyAgreement2 keyAgree = new DHKeyAgreement2();
            keyAgree.run();
        } catch (Exception e) {
            System.err.println(""Error: "" + e);
            System.exit(1);
        }
    }

    private void run() throws Exception {

        DHParameterSpec dhSkipParamSpec;

        // use some pre-generated, default DH parameters
        System.out.println(""Using SKIP Diffie-Hellman parameters"");
        BigInteger p = new BigInteger(sP,16);
        BigInteger g = new BigInteger(sG,16);
        System.out.println(""P "" + sP.length() + "" is: "" + toHexString(p.toByteArray()));
        System.out.println(""G "" + sG.length() + "" is: "" + toHexString(g.toByteArray()));
        dhSkipParamSpec = new DHParameterSpec(p,g);
        /*
         * Alice creates her own DH key pair, using the DH parameters from
         * above
         */
        System.out.println(""ALICE: Generate DH keypair ..."");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance(""DH"");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Alice creates and initializes her DH KeyAgreement object
        System.out.println(""ALICE: Initialization ..."");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance(""DH"");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();
        byte[] alicePrivKeyEnc = aliceKpair.getPrivate().getEncoded();
        System.out.println(""Alice pub key size: "" + alicePubKeyEnc.length);
        System.out.println(""Alice pub key: "" + toHexString(alicePubKeyEnc));
        System.out.println(""Alice priv key size: "" + alicePrivKeyEnc.length);
        System.out.println(""Alice priv key: "" + toHexString(alicePrivKeyEnc));
        ServerSocket ss = new ServerSocket(5454);
        Socket accept = ss.accept();
        byte[] bobPubKeyEnc = readByteArrayFromSocket(accept);
        System.out.println(""Read bob's pubkey: "" + toHexString(bobPubKeyEnc));
        sendByteArrayToBob(alicePubKeyEnc);
        System.out.println(""Sent Alice's pubkey"");

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instantiate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance(""DH"");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println(""ALICE: Execute PHASE1 ..."");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        int aliceLen = aliceSharedSecret.length;

        System.out.println(""Alice secret: "" +
          toHexString(aliceSharedSecret));
    }
}
</code></pre>

<p>My output from C++:</p>

<pre><code>lengths: 20 128
77:61:FD:93:D9:23:38:41:6D:B0:9B:F8:7A:FB:CE:CA:0E:DF:7D:0A:95:F6:B4:55:FF:64:32:03:2C:B5:9C:47:05:06:FF:1B:72:F3:C6:8A:91:68:13:98:DE:56:0C:D6:02:30:C2:4B:DB:AD:0A:B3:7D:2A:7E:DD:13:A8:7C:97:4A:46:79:6A:85:C7:5B:79:29:D8:E5:2B:F4:59:21:B3:29:EA:6A:2F:FB:70:A1:C8:FD:5C:31:E1:92:A9:B0:67:74:65:3D:C1:1B:33:4B:DE:1C:EB:1E:A1:3A:36:29:0F:DF:A2:FA:5D:DA:69:DC:6D:00:D7:76:95:3A:FD:7D:76
sent 128 bytes, remaining 0
Failed to reach shared secret (1A)
</code></pre>

<p>And output from Java:</p>

<pre><code>Using SKIP Diffie-Hellman parameters
P 256 is: 00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71
G 256 is: 00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5
ALICE: Generate DH keypair ...
ALICE: Initialization ...
Alice pub key size: 426
Alice pub key: 30:82:01:A6:30:82:01:1B:06:09:2A:86:48:86:F7:0D:01:03:01:30:82:01:0C:02:81:81:00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71:02:81:81:00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5:02:02:02:00:03:81:84:00:02:81:80:25:E7:BD:24:57:C9:59:EE:E0:EC:7A:F3:D6:22:1C:84:68:52:D9:19:40:5F:1B:C6:CB:A9:3A:42:BF:AB:3C:C2:EC:6F:BC:F9:F9:B2:70:AC:A2:E5:CE:36:FC:06:4F:2D:B3:4F:B5:25:D9:59:AD:D6:AD:B6:17:FA:09:76:AE:89:99:91:52:9B:E0:10:1D:9F:AC:50:AF:02:6D:25:F6:E8:DD:B8:6C:51:17:44:59:98:52:4B:E9:75:E1:D1:26:FE:EA:73:EF:C7:89:7F:70:A8:ED:6F:57:28:A4:0F:1B:F8:21:7D:A5:A2:59:B9:74:42:42:45:BA:EC:E2:53:B3:C4
Alice priv key size: 362
Alice priv key: 30:82:01:66:02:01:00:30:82:01:1B:06:09:2A:86:48:86:F7:0D:01:03:01:30:82:01:0C:02:81:81:00:B1:0B:8F:96:A0:80:E0:1D:DE:92:DE:5E:AE:5D:54:EC:52:C9:9F:BC:FB:06:A3:C6:9A:6A:9D:CA:52:D2:3B:61:60:73:E2:86:75:A2:3D:18:98:38:EF:1E:2E:E6:52:C0:13:EC:B4:AE:A9:06:11:23:24:97:5C:3C:D4:9B:83:BF:AC:CB:DD:7D:90:C4:BD:70:98:48:8E:9C:21:9A:73:72:4E:FF:D6:FA:E5:64:47:38:FA:A3:1A:4F:F5:5B:CC:C0:A1:51:AF:5F:0D:C8:B4:BD:45:BF:37:DF:36:5C:1A:65:E6:8C:FD:A7:6D:4D:A7:08:DF:1F:B2:BC:2E:4A:43:71:02:81:81:00:A4:D1:CB:D5:C3:FD:34:12:67:65:A4:42:EF:B9:99:05:F8:10:4D:D2:58:AC:50:7F:D6:40:6C:FF:14:26:6D:31:26:6F:EA:1E:5C:41:56:4B:77:7E:69:0F:55:04:F2:13:16:02:17:B4:B0:1B:88:6A:5E:91:54:7F:9E:27:49:F4:D7:FB:D7:D3:B9:A9:2E:E1:90:9D:0D:22:63:F8:0A:76:A6:A2:4C:08:7A:09:1F:53:1D:BF:0A:01:69:B6:A2:8A:D6:62:A4:D1:8E:73:AF:A3:2D:77:9D:59:18:D0:8B:C8:85:8F:4D:CE:F9:7C:2A:24:85:5E:6E:EB:22:B3:B2:E5:02:02:02:00:04:42:02:40:3C:16:B6:8F:73:CD:9D:0F:19:D5:A7:54:61:FC:A9:AF:3E:79:78:B8:5E:3E:3D:58:52:2F:95:5E:0D:3F:E0:19:92:17:22:B4:06:9A:E4:ED:9D:55:54:3F:1F:DE:20:36:31:5A:AC:58:FB:A3:C2:7E:65:31:A4:F0:43:37:A2:37
Read 128 bytes
Read bob's pubkey: 77:61:FD:93:D9:23:38:41:6D:B0:9B:F8:7A:FB:CE:CA:0E:DF:7D:0A:95:F6:B4:55:FF:64:32:03:2C:B5:9C:47:05:06:FF:1B:72:F3:C6:8A:91:68:13:98:DE:56:0C:D6:02:30:C2:4B:DB:AD:0A:B3:7D:2A:7E:DD:13:A8:7C:97:4A:46:79:6A:85:C7:5B:79:29:D8:E5:2B:F4:59:21:B3:29:EA:6A:2F:FB:70:A1:C8:FD:5C:31:E1:92:A9:B0:67:74:65:3D:C1:1B:33:4B:DE:1C:EB:1E:A1:3A:36:29:0F:DF:A2:FA:5D:DA:69:DC:6D:00:D7:76:95:3A:FD:7D:76
Sent Alice's pubkey
Error: java.security.spec.InvalidKeySpecException: Inappropriate key specification
</code></pre>

<p>Seems like altough I use the same G and P in both programs, the keys generated in C++ are 128\20 byte long (public\private) while in java they are 426\362 byte long. I was wondering where I can set the desired key length in crypto++ but yet to discover that. Also I removed some helper function from the codes above, so I guess copy-paste and trying to compile them won't work. If anyone will actually want to do that I will submit my complete code.</p>

<p>Thanks</p>
","","879","<java><c++><crypto++><diffie-hellman><java-security>","2","","0","2015-12-12 08:45:30","","4","","","","","2015-12-12 08:45:30",""
"34906495","library not found due to targetSdkVersion (armeabi-v7a and libcryptopp.so)","<p>I have created a sample project that uses Crypto++'s native C++ Libraries and the NDK to generate some ECDH key pairs. You can find the project <a href=""http://github.com/tcolligan-ap/ECDHTest"" rel=""nofollow"">here</a>.</p>

<p>This project runs perfectly fine on most android devices (ran on a handful of 4.4 and 5.0 devices). However I recently ran the app on a Nexus 5 and Nexus 7, both running Android 6.0.1, and the app crashed with the following error.</p>

<pre><code>java.lang.UnsatisfiedLinkError: dlopen failed: library ""./obj/local/armeabi-v7a/libcryptopp.so"" not found
</code></pre>

<p>I am not really sure what is going on here, as the project obviously has these files, and they should be fine. This seems like it might be some sort of NDK related issue but I am not really sure.</p>

<p>I tried removing the armeabi-v7a folder, which forced the app to use the armeabi files on the Nexus Devices, but it could not find those files either.</p>

<p>I opened up the apk and all of the correct .so files are in there with the appropriate folders.</p>

<p>Not really sure if this is an Android Marshmallow issue, a Nexus architecture issue, or some .so file compile issue. I am new to using the NDK so would appreciate ideas on where to look to fix this.</p>

<p><strong><em>EDIT</em></strong>: After looking into it a little more looks like this is an Android Marshmallow issue. A related issue was mentioned <a href=""https://stackoverflow.com/questions/32845956/android-m-crash-java-lang-unsatisfiedlinkerror-dlopen-failed"">here</a>. Changing my <strong><em><code>targetSdkVersion</code></em></strong> to <strong><em><code>22</code></em></strong> ""fixes"" the crash. But obviously this is not a very future friendly fix.</p>

<p>Apparently on Android Marshmallow, they switched from OpenSSL to BoringSSL. This is probably the root issue, as I would imagine Crypto++ uses functionality from OpenSSL and links against it?</p>

<p>Still looking around for an actual fix that lets me <strong><em><code>targetSdkVersion 23</code></em></strong>. Will probably try out some of the solutions listed in this <a href=""https://sourcedna.com/blog/20150806/predicting-app-crashes-on-android-m.html"" rel=""nofollow"">article</a> and see what happens. </p>

<p><strong><em>EDIT 2</em></strong>:
Crypto++ does not link against OpenSSL so there goes that theory. Help here is still appreciated.</p>
","","873","<java><android><android-ndk><java-native-interface><crypto++>","5","","0","2016-01-20 22:34:04","","2","1","5655109","","2016-01-20 22:34:04","2016-01-20 17:22:13",""
"49529167","Crypto++ library link error using Visual Studio 2017","<p>I'm trying to use the Crypto++ librairy in my project (windows application). Using it, include, compilation work fine, but impossible to deal with the link error</p>

<p>Here is some exemple of link errors, there is more, but don't think it's revelant to copy paste all of them</p>

<pre><code>error LNK2019: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::encrypt(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?encrypt@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z) referenced in function ""public: void __thiscall PStore::storeReversibleCrypt(wchar_t *,char *)"" (?storeReversibleCrypt@PStore@@QAEXPA_WPAD@Z)
error LNK2001: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::hashPassword(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?hashPassword@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@0@Z)

fatal error LNK1120: 4 unresolved externals
</code></pre>

<p>Basically, I add the ""Win32\Output\Release"" directory of crypto++ to my linker's additionnal library directories properties, and also the main folder to my C/C++'s General's property ""Additional Include Directories"" </p>

<p>I've tried a lot of thinks, like adding the library as a new project (same errors), adding all cpp files to my project and compiling with it (not compiling), adding only .cpp files I was using (not realistic, too much), linking all different folder of the cryptopp610 releases (cryptdll, cryptlib, dll_output, Output, same errors), and now, I don't really know what more I can try. I makre also a lots of search, trying all solution I saw (don't remember all of them), still the same problems. I also try to create a new project to add crypto++ without long compilation or mysterious problem, but I also get linker error.</p>

<p>Do anyone got any advice to help me ? Anyway, thank's a lot, and pardon my English</p>

<p><strong>EDIT</strong>: Need to add that on the new blank project, I get 63 unresolved external symbol, so I think I forgot to do some basic stuff, but can't figure out which</p>
","<p>It could be Ws2_32.lib there is missing from the linker</p>
","872","<c++><windows><visual-studio-2017><linker-errors><crypto++>","1","0","2","2018-03-28 16:55:10","49540099","0","","608639","","2018-03-28 16:55:10","2018-03-28 08:04:46",""
"49529167","Crypto++ library link error using Visual Studio 2017","<p>I'm trying to use the Crypto++ librairy in my project (windows application). Using it, include, compilation work fine, but impossible to deal with the link error</p>

<p>Here is some exemple of link errors, there is more, but don't think it's revelant to copy paste all of them</p>

<pre><code>error LNK2019: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::encrypt(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?encrypt@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z) referenced in function ""public: void __thiscall PStore::storeReversibleCrypt(wchar_t *,char *)"" (?storeReversibleCrypt@PStore@@QAEXPA_WPAD@Z)
error LNK2001: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::hashPassword(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?hashPassword@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@0@Z)

fatal error LNK1120: 4 unresolved externals
</code></pre>

<p>Basically, I add the ""Win32\Output\Release"" directory of crypto++ to my linker's additionnal library directories properties, and also the main folder to my C/C++'s General's property ""Additional Include Directories"" </p>

<p>I've tried a lot of thinks, like adding the library as a new project (same errors), adding all cpp files to my project and compiling with it (not compiling), adding only .cpp files I was using (not realistic, too much), linking all different folder of the cryptopp610 releases (cryptdll, cryptlib, dll_output, Output, same errors), and now, I don't really know what more I can try. I makre also a lots of search, trying all solution I saw (don't remember all of them), still the same problems. I also try to create a new project to add crypto++ without long compilation or mysterious problem, but I also get linker error.</p>

<p>Do anyone got any advice to help me ? Anyway, thank's a lot, and pardon my English</p>

<p><strong>EDIT</strong>: Need to add that on the new blank project, I get 63 unresolved external symbol, so I think I forgot to do some basic stuff, but can't figure out which</p>
","<pre><code>error LNK2019: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::encrypt(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?encrypt@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@@Z) referenced in function ""public: void __thiscall PStore::storeReversibleCrypt(wchar_t *,char *)"" (?storeReversibleCrypt@PStore@@QAEXPA_WPAD@Z)
error LNK2001: unresolved external symbol ""public: static class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt; __cdecl CryptoV2::hashPassword(class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;,class std::basic_string&lt;char,struct std::char_traits&lt;char&gt;,class std::allocator&lt;char&gt; &gt;)"" (?hashPassword@CryptoV2@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V23@0@Z)
</code></pre>

<p>The missing symbols are not from Crypto++. Crypto++ uses the <code>CryptoPP</code> namespace. The missing symbols are from the <code>CryptoV2</code> namespace or class. I'm guessing that's another crypto library.</p>

<p>You were right in adding directories and a library to the linker settings. However, you need to do it for the <code>CryptoV2</code> library (in addition to the Crypto++ library).</p>

<p>For completeness, it looks like these are missing:</p>

<pre><code>std::string CryptoV2::encrypt(std::string);
std::string CryptoV2::hashPassword(std::string, std::string);
</code></pre>
","872","<c++><windows><visual-studio-2017><linker-errors><crypto++>","1","1","2","2018-03-28 16:55:10","49540099","0","","608639","","2018-03-28 16:55:10","2018-03-28 08:04:46",""
"32639324","Integer to char* and char* to Integer conversion","<p>I'm using the Crypto++ library, and I created this simple class:</p>

<pre><code>class EncoderRSA
{
    public:
        EncoderRSA();
        void keyGeneration();
        void substitutePublicKey(Integer e, Integer n);
        Integer encode(std::string plainText);
        std::string decode(Integer cypher);
    private:
        AutoSeededRandomPool prng;  // Pseudo Random Number Generator
        RSA::PublicKey publicKey;   // For encrypt plain text
        RSA::PrivateKey privateKey; // For decrypt plain text
};
</code></pre>

<p>But I have some problem: when I encoded my message using <code>EncoderRSA::encode(message)</code>, I want to convert it from <code>Integer</code> to <code>char*</code> (for send by sockets) and from <code>char*</code> to <code>Integer</code> (after receive on the other side). How can I do it?</p>
","<blockquote>
  <p>Integer to char* and char* to Integer conversion</p>
</blockquote>

<p>I'm going to answer the question in the title, and side step the body's question because that appear to <strong><em>encrypt</em></strong>, and not <strong><em>encode</em></strong>.</p>

<p><strong><em><code>Integer</code> to <code>char*</code></em></strong></p>

<p>Its easy to get a <code>char*</code> because the <code>Integer</code> class (<a href=""http://www.cryptopp.com/docs/ref/integer_8h_source.html"" rel=""nofollow"">header</a>, <a href=""http://www.cryptopp.com/docs/ref/integer_8cpp_source.html"" rel=""nofollow"">implementation</a>) overloads <code>operator&lt;&lt;</code>.</p>

<p>So, you would do something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include ""integer.h""
...

using std::cout;
using std::endl;
using std::string;
using CryptoPP::Integer;

// Perhaps this is received from the EncoderRSA::encode() function
Integer n = ...;

ostringstream oss;
oss &lt;&lt; n;

// Create this temporary; otherwise, you might get yourself into trouble
string str(oss.str());
cout &lt;&lt; ""string: "" &lt;&lt; str &lt;&lt; endl;
cout &lt;&lt; ""char*: "" &lt;&lt; str.c_str() &lt;&lt; endl;
</code></pre>

<p><strong><em><code>char*</code> to <code>Integer</code></em></strong></p>

<p>This is just as easy because the <code>Integer</code> class has a constructor for it. From <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow""><code>integer.h</code></a>:</p>

<pre><code>// convert from string (requires NULL terminator)
Integer (const char *str)
</code></pre>

<p>Here's the program:</p>

<pre><code>#include &lt;string&gt;

#include ""integer.h""
...

using std::cout;
using std::endl;
using std::string;
using CryptoPP::Integer;

// Read from the wire
const char data[] = ""12345678901234567890123456789012345678901234567890123456789012345678901234567890."";

// Perhaps this is passed to the EncoderRSA::decode() function
Integer n(data, strlen(data));
</code></pre>

<hr>

<p>If you want the <code>byte</code> array version, then...</p>

<p><strong><em><code>Integer</code> to <code>byte*</code></em></strong></p>

<pre><code>#include &lt;vector&gt;

#include ""integer.h""
...

using std::vector;
using CryptoPP::Integer;

// Perhaps this is received from the EncoderRSA::encode() function
Integer n = ...;
size_t sz = n.MinEncodedSize();

vector v;
v.resize(sz);

n.Encode(&amp;v[0], v.size());
</code></pre>

<p><strong><em><code>byte*</code> to <code>Integer</code></em></strong></p>

<p>This is just as easy because the <code>Integer</code> class has a constructor for it. From <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow""><code>integer.h</code></a>:</p>

<pre><code>// convert from string (does NOT require NULL terminator)
Decode (const byte *input, size_t inputLen, Signedness=UNSIGNED)
</code></pre>

<p>Here's the program:</p>

<pre><code>#include ""integer.h""
...

using CryptoPP::Integer;

// Read from the wire; pretend they are binary
const char byte[] = ""12345678901234567890123456789012345678901234567890123456789012345678901234567890"";

// Perhaps this is passed to the EncoderRSA::decode() function
Integer n;
n.decode(data, sizeof(data));
</code></pre>

<hr>

<p>You can get even fancier with the encoding and decoding. For example, here's a program that HexEncodes encodes them:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

#include ""integer.h""
...

using std::cout;
using std::endl;
using std::string;
using CryptoPP::Integer;

// Perhaps this is received from the EncoderRSA::encode() function
Integer n(""0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"");
string encoded;

size_t req = n.MinEncodedSize();
encoded.reserve(req);

HexEncoder encoder(new StringSink(encoded));
n.Encode(encoder, req);

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>It produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe 
FEDCBA0987654321FEDCBA0987654321FEDCBA0987654321FEDCBA0987654321
</code></pre>

<p>And you can switch to a Base64 encoder with:</p>

<pre><code>Base64Encoder encoder(new StringSink(encoded));
n.Encode(encoder, req);

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>It produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe 
/ty6CYdlQyH+3LoJh2VDIf7cugmHZUMh/ty6CYdl
</code></pre>
","870","<c++><type-conversion><rsa><crypto++>","-1","1","2","2015-10-13 16:45:51","33108208","2","","608639","","2015-09-17 21:01:19","2015-09-17 20:21:58",""
"32639324","Integer to char* and char* to Integer conversion","<p>I'm using the Crypto++ library, and I created this simple class:</p>

<pre><code>class EncoderRSA
{
    public:
        EncoderRSA();
        void keyGeneration();
        void substitutePublicKey(Integer e, Integer n);
        Integer encode(std::string plainText);
        std::string decode(Integer cypher);
    private:
        AutoSeededRandomPool prng;  // Pseudo Random Number Generator
        RSA::PublicKey publicKey;   // For encrypt plain text
        RSA::PrivateKey privateKey; // For decrypt plain text
};
</code></pre>

<p>But I have some problem: when I encoded my message using <code>EncoderRSA::encode(message)</code>, I want to convert it from <code>Integer</code> to <code>char*</code> (for send by sockets) and from <code>char*</code> to <code>Integer</code> (after receive on the other side). How can I do it?</p>
","<p>Resolve of this problem are next two methods:</p>

<pre><code>Integer EncryptorRSA::stringToInteger(std::string str) {
    Integer integer(str.c_str());
    return integer;
}

std::string EncryptorRSA::integerToString(Integer integer) {
    std::stringstream stream;
    stream &lt;&lt; std::hex &lt;&lt; integer;
    return stream.str();
}
</code></pre>
","870","<c++><type-conversion><rsa><crypto++>","-1","0","2","2015-10-13 16:45:51","33108208","2","","608639","","2015-09-17 21:01:19","2015-09-17 20:21:58",""
"22733862","Android Crypto++ compiling by command line, GNUmakefile","<p>I have a problem to make appriopriate GNUmakefile, which should create Crypto++ library for Android. I am using this <a href=""http://www.cryptopp.com/wiki/Android_%28Command_Line%29"" rel=""nofollow"">tutorial</a>, and I'm stuck on patching makefile. Where can I find file GNUmakefile-android.patch which there is mentioned? I've tryied to add manually lines to file but I am not sure I am doing it correct. Now my GNUmakefile looks like this:</p>

<pre><code>CXXFLAGS = -DNDEBUG -g -O2
# -O3 fails to link on Cygwin GCC version 4.5.3
# -fPIC is supported. Please report any breakage of -fPIC as a bug.
# CXXFLAGS += -fPIC
# the following options reduce code size, but breaks link or makes link very slow on some systems
# CXXFLAGS += -ffunction-sections -fdata-sections
# LDFLAGS += -Wl,--gc-sections
ARFLAGS = -cr   # ar needs the dash on OpenBSD
RANLIB = ranlib
CP = cp
MKDIR = mkdir
EGREP = egrep
UNAME = $(shell uname)
ISX86 = $(shell uname -m | $(EGREP) -c ""i.86|x86|i86|amd64"")
IS_SUN_CC = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun"")
IS_LINUX = $(shell $(CXX) -dumpmachine 2&gt;&amp;1 | $(EGREP) -c ""linux"")
IS_MINGW = $(shell $(CXX) -dumpmachine 2&gt;&amp;1 | $(EGREP) -c ""mingw"")
CLANG_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -i -c ""clang version"")

# Set in the environment
ifeq ($(IS_CROSS_COMPILE),1)
  ISX86=0
  IS_LINUX=0
  IS_MINGW=0
  IS_DARWIN=0
  UNAME=CrossCompile
endif

# Default prefix for make install
ifeq ($(PREFIX),)
PREFIX = /usr
endif

ifeq ($(CXX),gcc)   # for some reason CXX is gcc on cygwin 1.1.4
CXX = g++
endif


ifeq ($(IS_ANDROID),1)
  CPP=arm-linux-androideabi-cpp
  CXX=arm-linux-androideabi-g++
  AR=arm-linux-androideabi-ar
  RANLIB=arm-linux-androideabi-ranlib
  LD=arm-linux-androideabi-ld

  CXXFLAGS += -fPIC -DCRYPTOPP_DISABLE_ASM --sysroot=$(ANDROID_SYSROOT) -I$(ANDROID_STL_INC)
  LDLIBS += $(ANDROID_STL_LIB)
endif

#if defined(__ANDROID__)
# include &lt;sys/select.h&gt;
#endif

ifeq ($(ISX86),1)

GCC42_OR_LATER = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c ""^gcc version (4.[2-9]|[5-9])"")
INTEL_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\)"")
ICC111_OR_LATER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\) ([2-9][0-9]|1[2-9]|11\.[1-9])"")
GAS210_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.[1-9][0-9]|[3-9])"")
GAS217_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.1[7-9]|2\.[2-9]|[3-9])"")
GAS219_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.19|2\.[2-9]|[3-9])"")

ifneq ($(GCC42_OR_LATER),0)
ifeq ($(UNAME),Darwin)
CXXFLAGS += -arch x86_64 -arch i386
else
CXXFLAGS += -march=native
endif
endif

ifneq ($(INTEL_COMPILER),0)
CXXFLAGS += -wd68 -wd186 -wd279 -wd327
ifeq ($(ICC111_OR_LATER),0)
# ""internal error: backend signals"" occurs on some x86 inline assembly with ICC 9 and some x64 inline assembly with ICC 11.0
# if you want to use Crypto++'s assembly code with ICC, try enabling it on individual files
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
endif
endif

ifeq ($(GAS210_OR_LATER),0) # .intel_syntax wasn't supported until GNU assembler 2.10
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
else
ifeq ($(GAS217_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_SSSE3
else
ifeq ($(GAS219_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_AESNI
endif
endif
ifeq ($(UNAME),SunOS)
CXXFLAGS += -Wa,--divide    # allow use of ""/"" operator
endif
endif

endif   # ISX86

ifeq ($(UNAME),)    # for DJGPP, where uname doesn't exist
CXXFLAGS += -mbnu210
else
CXXFLAGS += -pipe
endif

ifeq ($(IS_MINGW),1)
LDLIBS += -lws2_32
endif

ifeq ($(IS_LINUX),1)
LDFLAGS += -pthread
ifneq ($(shell uname -i | $(EGREP) -c ""(_64|d64)""),0)
M32OR64 = -m64
endif
endif

ifeq ($(UNAME),Darwin)
AR = libtool
ARFLAGS = -static -o
CXX = c++
IS_GCC2 = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c gcc-932)
ifeq ($(IS_GCC2),1)
CXXFLAGS += -fno-coalesce-templates -fno-coalesce-static-vtables
LDLIBS += -lstdc++
LDFLAGS += -flat_namespace -undefined suppress -m
endif
endif

ifeq ($(UNAME),SunOS)
LDLIBS += -lnsl -lsocket
M32OR64 = -m$(shell isainfo -b)
endif

ifneq ($(CLANG_COMPILER),0)
CXXFLAGS += -Wno-tautological-compare
endif

ifneq ($(IS_SUN_CC),0)  # override flags for CC Sun C++ compiler
CXXFLAGS = -DNDEBUG -O -g0 -native -template=no%extdef $(M32OR64)
LDFLAGS =
AR = $(CXX)
ARFLAGS = -xar -o
RANLIB = true
SUN_CC10_BUGGY = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun .* 5\.10 .* (2009|2010/0[1-4])"")
ifneq ($(SUN_CC10_BUGGY),0)
# -DCRYPTOPP_INCLUDE_VECTOR_CC is needed for Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21 and was fixed in May 2010
# remove it if you get ""already had a body defined"" errors in vector.cc
CXXFLAGS += -DCRYPTOPP_INCLUDE_VECTOR_CC
endif
endif

SRCS = $(wildcard *.cpp)
ifeq ($(SRCS),)             # workaround wildcard function bug in GNU Make 3.77
SRCS = $(shell echo *.cpp)
endif

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

all: cryptest.exe
static: libcryptopp.a
dynamic: libcryptopp.so

test: cryptest.exe
    ./cryptest.exe v

clean:
    -$(RM) cryptest.exe libcryptopp.a libcryptopp.so $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTI MPORTOBJS) $(DLLTESTOBJS)

install:
    $(MKDIR) -p $(PREFIX)/include/cryptopp $(PREFIX)/lib $(PREFIX)/bin
    -$(CP) *.h $(PREFIX)/include/cryptopp
    -$(CP) *.a $(PREFIX)/lib
    -$(CP) *.so $(PREFIX)/lib
    -$(CP) *.exe $(PREFIX)/bin

remove:
    -$(RM) -rf $(PREFIX)/include/cryptopp
    -$(RM) $(PREFIX)/lib/libcryptopp.a
    -$(RM) $(PREFIX)/lib/libcryptopp.so
    -$(RM) $(PREFIX)/bin/cryptest.exe

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)
    $(RANLIB) $@

libcryptopp.so: $(LIBOBJS)
    $(CXX) $(CXXFLAGS) -shared -o $@ $(LDFLAGS) $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) ./libcryptopp.a $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

cryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

adhoc.cpp: adhoc.cpp.proto
ifeq ($(wildcard adhoc.cpp),)
    cp adhoc.cpp.proto adhoc.cpp
else
    touch adhoc.cpp
endif

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>

<p>When I execute command 'make static dynamic cryptest.exe' I get this error:</p>

<pre><code>g++ -DNDEBUG -g -O2 -march=native -DCRYPTOPP_DISABLE_ASM -pipe -c shacal2.cpp
In file included from cryptlib.h:83:0,
                 from seckey.h:8,
                 from shacal2.h:7,
                 from shacal2.cpp:9:
stdcpp.h:9:20: fatal error: stddef.h: No such file or directory
 #include &lt;stddef.h&gt;
                    ^
compilation terminated.
GNUmakefile:233: polecenia dla obiektu 'shacal2.o' nie powiodły się
make: *** [shacal2.o] Błąd 1
</code></pre>

<p>I am using cygwin to compile this. I would be grateful for help.</p>
","<blockquote>
  <p>Where can I find file GNUmakefile-android.patch which there is mentioned?</p>
</blockquote>

<p>The downloads are at the bottom of the page.</p>

<hr>

<blockquote>
  <p>Now my GNUmakefile looks like this:</p>
</blockquote>

<pre><code>&gt; # Set in the environment
&gt; ifeq ($(IS_CROSS_COMPILE),1)
&gt;   ISX86=0
&gt;   IS_LINUX=0
&gt;   IS_MINGW=0
&gt;   IS_DARWIN=0
&gt;   UNAME=CrossCompile
&gt; endif
</code></pre>

<p>This unsets the ""host"" flags used by the Makefile. Otherwise, Crypto++ will set <code>CXXFLAGS</code> for the host (i.e, your Desktop computer), and not the target (i.e., your Android device).</p>

<p>Next you need the <code>CXXFLAGS</code> for the target. From the same tutorial:</p>

<pre><code>ifeq ($(IS_ANDROID),1)
  CPP=arm-linux-androideabi-cpp
  CXX=arm-linux-androideabi-g++
  AR=arm-linux-androideabi-ar
  RANLIB=arm-linux-androideabi-ranlib
  LD=arm-linux-androideabi-ld

  CXXFLAGS += -fPIC -DCRYPTOPP_DISABLE_ASM --sysroot=$(ANDROID_SYSROOT) -I$(ANDROID_STL_INC)
  LDLIBS += $(ANDROID_STL_LIB)
endif
</code></pre>

<p>There's also a couple of one/two liners to ensure some Android specific includes are found.</p>

<hr>

<p>The last question should be: where is <code>IS_CROSS_COMPILE</code>, <code>IS_ANDROID</code>, <code>ANDROID_SYSROOT</code> and friends set? The answer is in <code>setenv-android.sh</code>.</p>

<p>The download for <code>setenv-android.sh</code> is at the bottom of the page, too.</p>

<hr>

<blockquote>
  <p>When I execute command 'make static dynamic cryptest.exe' I get this error:</p>

<pre><code>g++ -DNDEBUG -g -O2 -march=native -DCRYPTOPP_DISABLE_ASM -pipe -c shacal2.cpp
</code></pre>
</blockquote>

<p>You did not run <code>setenv-android.sh</code>. As the tutorial states, the compiler command that you should see:</p>

<pre><code>arm-linux-androideabi-g++ -DNDEBUG -g -O2 -DCRYPTOPP_DISABLE_ASM -pipe -fPIC
--sysroot=/opt/android-ndk-r9/platforms/android-14/arch-arm -I/opt/android-ndk-r9/sources/
cxx-stl/stlport/stlport/ -c 3way.cpp
...
</code></pre>

<hr>

<blockquote>
  <p>I am using cygwin to compile this. </p>
</blockquote>

<p>The tutorial was written against the Android NDK. The procedures and scripts were tested on Linux and Mac OS X.</p>

<p>The NDK should work with Cygwin; and Crypto++ should work with Cygwin. However, the combination of Android and Cygwin on Windows was never tested, and the Makefile might need more tuning. I just don't know because its was never tested.</p>

<p>Can you set up a Linux virtual machine in Windows? It might be easier to complete the process.</p>

<hr>

<blockquote>
  <p>When I execute command 'make static dynamic cryptest.exe'...</p>
</blockquote>

<p>For completeness, <code>cryptest.exe</code> will fail if its executed on the host computer. You should push <code>cryptest.exe</code> to the device via <code>adb</code> (along with the test vectors), and then execute it on the device. I think the tutorial covers that too.</p>
","864","<android><android-ndk><cygwin><crypto++>","3","2","2","2014-06-19 13:45:39","22776949","2","","","","","2014-03-29 16:48:06",""
"22733862","Android Crypto++ compiling by command line, GNUmakefile","<p>I have a problem to make appriopriate GNUmakefile, which should create Crypto++ library for Android. I am using this <a href=""http://www.cryptopp.com/wiki/Android_%28Command_Line%29"" rel=""nofollow"">tutorial</a>, and I'm stuck on patching makefile. Where can I find file GNUmakefile-android.patch which there is mentioned? I've tryied to add manually lines to file but I am not sure I am doing it correct. Now my GNUmakefile looks like this:</p>

<pre><code>CXXFLAGS = -DNDEBUG -g -O2
# -O3 fails to link on Cygwin GCC version 4.5.3
# -fPIC is supported. Please report any breakage of -fPIC as a bug.
# CXXFLAGS += -fPIC
# the following options reduce code size, but breaks link or makes link very slow on some systems
# CXXFLAGS += -ffunction-sections -fdata-sections
# LDFLAGS += -Wl,--gc-sections
ARFLAGS = -cr   # ar needs the dash on OpenBSD
RANLIB = ranlib
CP = cp
MKDIR = mkdir
EGREP = egrep
UNAME = $(shell uname)
ISX86 = $(shell uname -m | $(EGREP) -c ""i.86|x86|i86|amd64"")
IS_SUN_CC = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun"")
IS_LINUX = $(shell $(CXX) -dumpmachine 2&gt;&amp;1 | $(EGREP) -c ""linux"")
IS_MINGW = $(shell $(CXX) -dumpmachine 2&gt;&amp;1 | $(EGREP) -c ""mingw"")
CLANG_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -i -c ""clang version"")

# Set in the environment
ifeq ($(IS_CROSS_COMPILE),1)
  ISX86=0
  IS_LINUX=0
  IS_MINGW=0
  IS_DARWIN=0
  UNAME=CrossCompile
endif

# Default prefix for make install
ifeq ($(PREFIX),)
PREFIX = /usr
endif

ifeq ($(CXX),gcc)   # for some reason CXX is gcc on cygwin 1.1.4
CXX = g++
endif


ifeq ($(IS_ANDROID),1)
  CPP=arm-linux-androideabi-cpp
  CXX=arm-linux-androideabi-g++
  AR=arm-linux-androideabi-ar
  RANLIB=arm-linux-androideabi-ranlib
  LD=arm-linux-androideabi-ld

  CXXFLAGS += -fPIC -DCRYPTOPP_DISABLE_ASM --sysroot=$(ANDROID_SYSROOT) -I$(ANDROID_STL_INC)
  LDLIBS += $(ANDROID_STL_LIB)
endif

#if defined(__ANDROID__)
# include &lt;sys/select.h&gt;
#endif

ifeq ($(ISX86),1)

GCC42_OR_LATER = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c ""^gcc version (4.[2-9]|[5-9])"")
INTEL_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\)"")
ICC111_OR_LATER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\) ([2-9][0-9]|1[2-9]|11\.[1-9])"")
GAS210_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.[1-9][0-9]|[3-9])"")
GAS217_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.1[7-9]|2\.[2-9]|[3-9])"")
GAS219_OR_LATER = $(shell $(CXX) -xc -c /dev/null -Wa,-v -o/dev/null 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.19|2\.[2-9]|[3-9])"")

ifneq ($(GCC42_OR_LATER),0)
ifeq ($(UNAME),Darwin)
CXXFLAGS += -arch x86_64 -arch i386
else
CXXFLAGS += -march=native
endif
endif

ifneq ($(INTEL_COMPILER),0)
CXXFLAGS += -wd68 -wd186 -wd279 -wd327
ifeq ($(ICC111_OR_LATER),0)
# ""internal error: backend signals"" occurs on some x86 inline assembly with ICC 9 and some x64 inline assembly with ICC 11.0
# if you want to use Crypto++'s assembly code with ICC, try enabling it on individual files
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
endif
endif

ifeq ($(GAS210_OR_LATER),0) # .intel_syntax wasn't supported until GNU assembler 2.10
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
else
ifeq ($(GAS217_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_SSSE3
else
ifeq ($(GAS219_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_AESNI
endif
endif
ifeq ($(UNAME),SunOS)
CXXFLAGS += -Wa,--divide    # allow use of ""/"" operator
endif
endif

endif   # ISX86

ifeq ($(UNAME),)    # for DJGPP, where uname doesn't exist
CXXFLAGS += -mbnu210
else
CXXFLAGS += -pipe
endif

ifeq ($(IS_MINGW),1)
LDLIBS += -lws2_32
endif

ifeq ($(IS_LINUX),1)
LDFLAGS += -pthread
ifneq ($(shell uname -i | $(EGREP) -c ""(_64|d64)""),0)
M32OR64 = -m64
endif
endif

ifeq ($(UNAME),Darwin)
AR = libtool
ARFLAGS = -static -o
CXX = c++
IS_GCC2 = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c gcc-932)
ifeq ($(IS_GCC2),1)
CXXFLAGS += -fno-coalesce-templates -fno-coalesce-static-vtables
LDLIBS += -lstdc++
LDFLAGS += -flat_namespace -undefined suppress -m
endif
endif

ifeq ($(UNAME),SunOS)
LDLIBS += -lnsl -lsocket
M32OR64 = -m$(shell isainfo -b)
endif

ifneq ($(CLANG_COMPILER),0)
CXXFLAGS += -Wno-tautological-compare
endif

ifneq ($(IS_SUN_CC),0)  # override flags for CC Sun C++ compiler
CXXFLAGS = -DNDEBUG -O -g0 -native -template=no%extdef $(M32OR64)
LDFLAGS =
AR = $(CXX)
ARFLAGS = -xar -o
RANLIB = true
SUN_CC10_BUGGY = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun .* 5\.10 .* (2009|2010/0[1-4])"")
ifneq ($(SUN_CC10_BUGGY),0)
# -DCRYPTOPP_INCLUDE_VECTOR_CC is needed for Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21 and was fixed in May 2010
# remove it if you get ""already had a body defined"" errors in vector.cc
CXXFLAGS += -DCRYPTOPP_INCLUDE_VECTOR_CC
endif
endif

SRCS = $(wildcard *.cpp)
ifeq ($(SRCS),)             # workaround wildcard function bug in GNU Make 3.77
SRCS = $(shell echo *.cpp)
endif

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

all: cryptest.exe
static: libcryptopp.a
dynamic: libcryptopp.so

test: cryptest.exe
    ./cryptest.exe v

clean:
    -$(RM) cryptest.exe libcryptopp.a libcryptopp.so $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTI MPORTOBJS) $(DLLTESTOBJS)

install:
    $(MKDIR) -p $(PREFIX)/include/cryptopp $(PREFIX)/lib $(PREFIX)/bin
    -$(CP) *.h $(PREFIX)/include/cryptopp
    -$(CP) *.a $(PREFIX)/lib
    -$(CP) *.so $(PREFIX)/lib
    -$(CP) *.exe $(PREFIX)/bin

remove:
    -$(RM) -rf $(PREFIX)/include/cryptopp
    -$(RM) $(PREFIX)/lib/libcryptopp.a
    -$(RM) $(PREFIX)/lib/libcryptopp.so
    -$(RM) $(PREFIX)/bin/cryptest.exe

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)
    $(RANLIB) $@

libcryptopp.so: $(LIBOBJS)
    $(CXX) $(CXXFLAGS) -shared -o $@ $(LDFLAGS) $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) ./libcryptopp.a $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

cryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

adhoc.cpp: adhoc.cpp.proto
ifeq ($(wildcard adhoc.cpp),)
    cp adhoc.cpp.proto adhoc.cpp
else
    touch adhoc.cpp
endif

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>

<p>When I execute command 'make static dynamic cryptest.exe' I get this error:</p>

<pre><code>g++ -DNDEBUG -g -O2 -march=native -DCRYPTOPP_DISABLE_ASM -pipe -c shacal2.cpp
In file included from cryptlib.h:83:0,
                 from seckey.h:8,
                 from shacal2.h:7,
                 from shacal2.cpp:9:
stdcpp.h:9:20: fatal error: stddef.h: No such file or directory
 #include &lt;stddef.h&gt;
                    ^
compilation terminated.
GNUmakefile:233: polecenia dla obiektu 'shacal2.o' nie powiodły się
make: *** [shacal2.o] Błąd 1
</code></pre>

<p>I am using cygwin to compile this. I would be grateful for help.</p>
","<p>I had the same problem compiling, and now seem to have successfully compiled on cygwin.  AFter following the instructions referenced by the previous answer (link <a href=""http://www.cryptopp.com/wiki/Android_%28Command_Line%29"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a>), I then ran into the issue of g++ being unable to locate the headers.</p>

<p>Courtesy of g++'s handy -v option, I found the problem.  The issue is that g++ is unable to parse the <strong>""/opt/android-ndk-r9d/etc/...""</strong> paths within the cygwin environment.  Adding the -v option to the GNUMakeFile patch of the <strong>CXXFLAGS</strong> showed that both the <strong>$ANDROID_STL_INC</strong> and the <strong>$ANDROID_TOOLCHAIN</strong> variables set by the setenv-android.sh script both fell under
""Ignoring nonexistent directory ...""</p>

<p>I fixed this by replacing the <strong>$(ANDROID_TOOLCHAIN)</strong> and the <strong>$(ANDROID_STL_INC)</strong> with the <strong>WINDOWS</strong> style paths (e.g. <strong>C:/cygwin/c/opt/android-ndk-r9d/etc/...</strong>) and the libraries compiled.  Hurray.</p>

<p>However, cryptest.exe seems to have failed.  Will update as I fix more.</p>

<p><strong>UPDATE</strong></p>

<p>Same issue, the <strong>$ANDROID_STL_LIB</strong> set by setenv-android.sh also can't be parsed.  Replaced the <strong>LBLIBS</strong> in the GNUMakeFile with the <strong>WINDOWS</strong> style path C:/cygwin/c/opt/android-ndk-r9d/etc/.../libstlport_shared.so and full compilation.</p>
","864","<android><android-ndk><cygwin><crypto++>","3","4","2","2014-06-19 13:45:39","22776949","2","","","","","2014-03-29 16:48:06",""
"21128386","Is there public key initialization API with point compression?","<p>I am tumbling around with CryptoPP and cannot find answer to this specific question. Here is sample source code (partial)</p>

<pre><code>    AutoSeededRandomPool prng;

//Generate a private key
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
privateKey.Initialize(prng, CryptoPP::ASN1::secp256r1());

// Generate publicKey
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;
privateKey.MakePublicKey(publicKey);

// Extract Component values
Integer p   = privateKey.GetGroupParameters().GetCurve().GetField().GetModulus();
Integer a   = privateKey.GetGroupParameters().GetCurve().GetA();
Integer b   = privateKey.GetGroupParameters().GetCurve().GetB();
Integer Gx  = privateKey.GetGroupParameters().GetSubgroupGenerator().x;
Integer Gy  = privateKey.GetGroupParameters().GetSubgroupGenerator().y;
Integer n   = privateKey.GetGroupParameters().GetSubgroupOrder();
Integer h   = privateKey.GetGroupParameters().GetCofactor();
Integer Qx  = publicKey.GetPublicElement().x;
Integer Qy  = publicKey.GetPublicElement().y;
Integer x   = privateKey.GetPrivateExponent();

// Construct Point elelemt;
ECP curve(p,a,b);
ECP::Point G(Gx,Gy);
ECP::Point Q(Qx,Qy);

//Build publicKey using elements (no point compression)
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey GeneratedPublicKey;
GeneratedPublicKey.Initialize(curve,G,n,Q);
assert(GeneratedPublicKey.Validate(prng, 3));

//Build publicKey using elements (with point compression)?
</code></pre>

<p>With this way, I can generate publicKey using component values. However, I cannot
make it work with point compression-which means I don't have Qy value- Is there a 
way to do it? Initialize method has two overloading but none of them are for point
compression situation.</p>

<p>My question is specific with Crypto++ on ""PublicKey.Initialize(curve,G,n,Q)"". Since I cannot transfer whole publicKey with my current project-which I am force to specify domain
parameter as index value and can only transfer Qx value. So I should initialize publicKey
using something like ""PublicKey.Initialize(curve,G,n,Q)"" However, I cannot find such initialization API concerning point compression. </p>

<p>So, this is not about ""how to do a point compression"" but ""Is there a way to initialize
public key without having Qy value?""</p>
","<blockquote>
  <p>How to Construct ECDSA publicKey using only with x value (Point compression)?</p>
</blockquote>

<p><code>x</code> is the private exponent. The public key is a point on the curve; and it does not use the private exponent.</p>

<p>To get the public key: take the private exponent, and raise your base point to it. That is, <code>Q = G^x</code>.</p>

<p>If you want to set the private exponent on a private key or decryptor, then set the domain parameters (i.e., <code>DL_GroupParameters_EC&lt; ECP &gt;</code> or <code>DL_GroupParameters_EC&lt; EC2M &gt;</code>) and then call <code>SetPrivateExponent(x);</code>.</p>

<hr>

<p>Have you reviewed your previous question at <a href=""https://stackoverflow.com/questions/20781563/crypto-ecsda-compressed-key-how-can-i-recover-compressed-y-value-from-other-e"">How can I recover compressed y value from sender?</a>? The community took the time to provide you with an answer and sample code, but you did not acknowledge or follow up.</p>

<p>I think <a href=""https://stackoverflow.com/users/589259/owlstead"">owlstead</a> said it best <a href=""https://stackoverflow.com/questions/18734616/rsa-encryption-and-decryption"">here</a>: </p>

<blockquote>
  <p>Why would we care answer you if you are not inclined to accept answers
  or even follow up to them? Your questions are all right, but the way
  you treat the community is terrible.</p>
</blockquote>
","861","<crypto++><ecdsa>","1","1","2","2017-08-21 11:58:23","","1","","608639","","2016-04-11 07:42:17","2014-01-15 03:05:12",""
"21128386","Is there public key initialization API with point compression?","<p>I am tumbling around with CryptoPP and cannot find answer to this specific question. Here is sample source code (partial)</p>

<pre><code>    AutoSeededRandomPool prng;

//Generate a private key
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
privateKey.Initialize(prng, CryptoPP::ASN1::secp256r1());

// Generate publicKey
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;
privateKey.MakePublicKey(publicKey);

// Extract Component values
Integer p   = privateKey.GetGroupParameters().GetCurve().GetField().GetModulus();
Integer a   = privateKey.GetGroupParameters().GetCurve().GetA();
Integer b   = privateKey.GetGroupParameters().GetCurve().GetB();
Integer Gx  = privateKey.GetGroupParameters().GetSubgroupGenerator().x;
Integer Gy  = privateKey.GetGroupParameters().GetSubgroupGenerator().y;
Integer n   = privateKey.GetGroupParameters().GetSubgroupOrder();
Integer h   = privateKey.GetGroupParameters().GetCofactor();
Integer Qx  = publicKey.GetPublicElement().x;
Integer Qy  = publicKey.GetPublicElement().y;
Integer x   = privateKey.GetPrivateExponent();

// Construct Point elelemt;
ECP curve(p,a,b);
ECP::Point G(Gx,Gy);
ECP::Point Q(Qx,Qy);

//Build publicKey using elements (no point compression)
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey GeneratedPublicKey;
GeneratedPublicKey.Initialize(curve,G,n,Q);
assert(GeneratedPublicKey.Validate(prng, 3));

//Build publicKey using elements (with point compression)?
</code></pre>

<p>With this way, I can generate publicKey using component values. However, I cannot
make it work with point compression-which means I don't have Qy value- Is there a 
way to do it? Initialize method has two overloading but none of them are for point
compression situation.</p>

<p>My question is specific with Crypto++ on ""PublicKey.Initialize(curve,G,n,Q)"". Since I cannot transfer whole publicKey with my current project-which I am force to specify domain
parameter as index value and can only transfer Qx value. So I should initialize publicKey
using something like ""PublicKey.Initialize(curve,G,n,Q)"" However, I cannot find such initialization API concerning point compression. </p>

<p>So, this is not about ""how to do a point compression"" but ""Is there a way to initialize
public key without having Qy value?""</p>
","<blockquote>
  <p>""Is there a way to initialize public key without having Qy value?""</p>
</blockquote>

<p>Yes, there is. Here is an crypto++ example:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/ecp.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;

using namespace CryptoPP;
using std::cout;
using std::endl;

int main() 
{
    OID curve = ASN1::secp256r1();
    ECDH&lt;ECP&gt;::Domain domain(curve);  

    SecByteBlock privKey(domain.PrivateKeyLength());
    SecByteBlock pubKey(domain.PublicKeyLength());
    AutoSeededRandomPool prng;
    domain.GenerateKeyPair(prng, privKey, pubKey); 

    // Convert public key to string representation
    std::string pub_str;
    HexEncoder encoder;
    encoder.Attach( new StringSink(pub_str) );
    encoder.Put( pubKey.data(), pubKey.size() );
    encoder.MessageEnd();

    // Uncompressed point - first byte '04' in front of the string. 
    std::cout &lt;&lt; ""Uncompressed public key (point) "" &lt;&lt; pub_str &lt;&lt; endl;

    // Extract x value from the point  
    std::string public_point_x = pub_str.substr(2, 64);

    // Compressed - '02' byte in front of the string. 
    public_point_x = ""02"" + public_point_x;
    std::cout &lt;&lt; ""Compressed public key (point)   "" &lt;&lt; public_point_x &lt;&lt; endl;

    // ----- reconstruct point from compressed point/value.
    StringSource ss(public_point_x, true, new HexDecoder);   
    ECP::Point point;
    domain.GetGroupParameters().GetCurve().DecodePoint(point, ss, ss.MaxRetrievable());

    cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; endl;
    cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>I hope this is the answer to your question. I was using ECDH, but it should work equally well with ECDSA class.</p>
","861","<crypto++><ecdsa>","1","1","2","2017-08-21 11:58:23","","1","","608639","","2016-04-11 07:42:17","2014-01-15 03:05:12",""
"27533953","cryptopp error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token","<p>I've added a security module, which requires cryptopp to be installed, is written in C and contains the following includes:</p>

<pre><code>#include &lt;Python.h&gt;
#include &lt;common/credentials.h&gt;
#include ""proto/security.pb.h""
#include &lt;string.h&gt;
</code></pre>

<p>I've googled the error and have verified that the Python.h header exists, the -I/usr/include/python2.6 shows up in the make, python-devel-2.6.6-52.el6.x86_64 package is installed. Am I missing a flag?  Is it the ""namespace"" or is it a parsing error?</p>

<pre><code>g++ -o /home/build/workarea/1.0.0/build_fileclient/baseutils/src/cc/unixusergrouphelper.os -c -g -Wall -isystem/usr/local/protobuf-2.5.0//include -O2 -pthread -fPIC -fPIC -I/home/build/workarea/1.0.0/build_fileclient -I. -I/usr/include -I/usr/local/protobuf-2.5.0/include -I/home/build/workarea/1.0.0/build_fileclient/fs -Ifs -I/home/build/workarea/1.0.0/build_fileclient/fs/common/gperftools/src -Ifs/common/gperftools/src -I/home/build/workarea/1.0.0/build_fileclient/fs/server -Ifs/server -I/home/build/workarea/1.0.0/build_fileclient/fs/client -Ifs/client -I/usr/local/java/include -I/usr/local/java/include/linux -I/usr/include/python2.6 -I/home/build/workarea/1.0.0/build_fileclient/fs/client/fileclient/java/fs-jni/target/native/javah -Ifs/client/fileclient/java/fs-jni/target/native/javah -I/home/build/workarea/1.0.0/build_version -I/home/build/workarea/github/dl/hadoop-common/hadoop-hdfs-project/hadoop-hdfs -I/home/build/workarea/github/dl/hadoop-common/hadoop-hdfs-project/hadoop-hdfs/target/native baseutils/src/cc/unixusergrouphelper.cc
In file included from /usr/include/cryptopp/osrng.h:6:0,
                 from fs/common/credentials.h:6,
                 from baseutils/src/cc/securitymodule.c:2:
/usr/include/cryptopp/config.h:97:1: error: unknown type name 'namespace'
/usr/include/cryptopp/config.h:97:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
In file included from /usr/include/cryptopp/cryptlib.h:83:0,
                 from /usr/include/cryptopp/randpool.h:4,
                 from /usr/include/cryptopp/osrng.h:10,
                 from fs/common/credentials.h:6,
                 from baseutils/src/cc/securitymodule.c:2:
/usr/include/cryptopp/stdcpp.h:14:18: fatal error: memory: No such file or directory
compilation terminated.
In file included from /usr/include/cryptopp/osrng.h:6:0,
                 from fs/common/credentials.h:6,
                 from baseutils/src/cc/securitymodule.c:2:
/usr/include/cryptopp/config.h:97:1: error: unknown type name 'namespace'
/usr/include/cryptopp/config.h:97:1: error: expected '=', ',', ';', 'asm' or '__attribute__' before '{' token
In file included from /usr/include/cryptopp/cryptlib.h:83:0,
                 from /usr/include/cryptopp/randpool.h:4,
                 from /usr/include/cryptopp/osrng.h:10,
                 from fs/common/credentials.h:6,
                 from baseutils/src/cc/securitymodule.c:2:
/usr/include/cryptopp/stdcpp.h:14:18: fatal error: memory: No such file or directory
compilation terminated.
</code></pre>
","<p>GCC decides what language a file is written in based on the filename's suffix. Either rename the file to *.cc or *.cpp, or pass <code>-x c++</code> to g++.</p>
","857","<python><gcc><crypto++>","2","2","1","2014-12-17 20:31:01","27534321","1","","","","","2014-12-17 20:07:34",""
"16159363","Exception thrown in iOS app using cryptopp static library on XCode 4.6.2","<p>Here's some detail of what I have. </p>

<ul>
<li>Separately compiled crypto++ build and have a static library (libcryptopp.a).</li>
<li>Created sample single view app and linked against above library, created new group to include crypto++ headers. These headers are NOT copied into the app's target folder. </li>
<li><p>Created a new .mm file in the app from which I am executing some sample code which I want to send to the console for now. Note that this sample code is pretty much unmodified from that provided in the test file SymmetricCipher.cpp.</p>

<hr></li>
<li><p>Settings under project Build Settings:</p>

<p>Apple LLVM compiler 4.2 settings</p></li>
<li>C Language dialect - GNU99</li>
<li>C++ Language dialect - GNU++11</li>
<li><p>C++ Standard Library - libstdc++</p>

<hr></li>
<li><p>Made exact same changes to an existing project and just inserted sample code in existing file to test output. That worked without any problems. </p></li>
<li><p>Code in standalone app throws exception <strong>""EXC_BAD_ACCESS (code=2, address=0x20)""</strong></p>

<pre><code>  #import ""TestView.h""

  //Include C++ headers
  #ifdef __cplusplus
  #include ""aes.h""

  // Includes all required Crypto++
  // Block Cipher Headers
  #include ""SymmetricCipher.h""

  #include &lt;iostream&gt;
  #include &lt;iomanip&gt;

  // Crypto++ Includes
  #include ""modes.h"" // xxx_Mode&lt; &gt;
  #include ""filters.h"" // StringSource and
  // StreamTransformation

  #include ""sha.h""
  #include ""base64.h""

  #endif


  @implementation TestView

  - (id)initWithFrame:(CGRect)frame
  {
      self = [super initWithFrame:frame];
      if (self) {
          // Initialization code
         }
      return self;
  }

  - (void)testBlock
  {

  //Test code
  byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];

  ::memset( key, 0x01, CryptoPP::AES::DEFAULT_KEYLENGTH );
  ::memset( iv, 0x01, CryptoPP::AES::BLOCKSIZE );

  // Message M
  std::string PlainText = ""Yoda said,Do or Do Not. There is no try."";

  // Cipher Text Sink
  std::string CipherText;

  // Encryptor
  CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption
  Encryptor( key, sizeof(key), iv );

  // Encryption
  CryptoPP::StringSource( PlainText, true,
                   new CryptoPP::StreamTransformationFilter( Encryptor, new             CryptoPP::StringSink(CipherText )) // StreamTransformationFilter
                   ); // StringSource

  // example of hashing followed by base64 encoding, using filters
  std::string digest;

  CryptoPP::SHA256 hash;  // don't use MD5 anymore. It is considered insecure

  CryptoPP::StringSource foo(PlainText, true,
                       new CryptoPP::HashFilter(hash, new CryptoPP::Base64Encoder (new CryptoPP::StringSink(digest))));

  NSLog(@""SHA256 Hash %s"", digest.c_str());

  }

  @end
</code></pre></li>
</ul>
","<p>The Crypto++ code is good. Your problem lies elsewhere.</p>

<p>Instead of trying to cross compile Crypto++, perhaps you should try out <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow noreferrer"">cryptopp-5.6.2-ios on GitHub</a>. Its got a pre-built fat library for 6.1 SDK (<code>armv7</code>, <code>armv7s</code>, <code>i386</code>); and a pre-built fat library for 7.0 SDK (<code>armv7</code>, <code>armv7s</code>, <code>arm64</code>, <code>i386</code>).</p>

<p><img src=""https://i.stack.imgur.com/QahoC.png"" alt=""Crypto++/iOS test code""></p>
","854","<c++><ios><objective-c><xcode><crypto++>","0","1","1","2013-10-04 03:39:46","","3","1","184646","","2013-09-11 10:55:34","2013-04-23 01:24:28",""
"7362607","where can i find source code for libcrypto++?","<p>I am using libcrypto++ for aes encryption. I would like to add in my code the methods: EVP_CipherInit_ex(), EVP_CipherUpdate(), EVP_CipherFinal_ex(). Where can I find this source codes?</p>

<p>thx. appreciate</p>
","<p>Here you go:
<a href=""http://www.openssl.org/source/"" rel=""nofollow"">http://www.openssl.org/source/</a>
The downloadable tar.gz on the page contains both header and source files for the most common cryptography algorithms, including EVP</p>

<p>However, I believe you are misunderstanding what static linking means, and how it is different from dynamic linking. Here is a decent article:
<a href=""http://kb.iu.edu/data/akqn.html"" rel=""nofollow"">http://kb.iu.edu/data/akqn.html</a></p>

<p>You don't need to manually add the .cpp and .h files to your project, just include the .h where you need to use the methods and link to the .lib.</p>

<p>Despite my and commenters' suggestions, if you still wish to manually add the .cpp and .h files, here is where they are located within the archive I linked above:</p>

<pre><code>crypto\evp\evp.h
crypto\evp\evp_*.c
</code></pre>
","844","<c++><linker><crypto++>","0","1","1","2013-01-11 16:25:24","7362674","2","","411022","","2013-01-11 16:25:24","2011-09-09 13:47:05",""
"40935112","ECIES with AES and CBC in Crypto++","<p><br>
I need to implement in Crypto++ the equivalent to BouncyCastle's <em><strong>""ECIESwithAES-CBC/NONE/PKCS7Padding""</strong></em>. <br></p>

<p>
The main reason is that I need to encrypt data on iOS and decrypt it on the backend with BouncyCastle in Java and we want to use those specific algorithms/configurations.
</p>

<p>I have zero experience with C++, but here is what I've got so far in Crypto++:</p>

<pre><code>// loaded private key
const unsigned char* privateKey;
size_t keyLength;

AutoSeededRandomPool prng;

ECIES_BC&lt;ECP&gt;::Decryptor decryptor;
decryptor.AccessPrivateKey().Load(StringStore(privateKey, keyLength).Ref());
ECIES_BC&lt;ECP&gt;::Encryptor encryptor(decryptor);

std::string plain(""a""); // the message
std::string cipher;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte iv[ AES::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

CBC_Mode&lt; AES &gt;::Encryption e;
e.SetKeyWithIV( key, key.size(), iv );

StringSource ss1( plain, true,
        new StreamTransformationFilter( e,
                new StringSink( cipher ), StreamTransformationFilter::PKCS_PADDING
                                      ) // StreamTransformationFilter
                 ); // StringSource


std::string cryptogram;
StringSource ss2 (cipher, true,
                            new PK_EncryptorFilter(prng, encryptor, new StringSink(cryptogram) ) );
// ... decrypt cryptogram in bouncy castle
</code></pre>

<p>Here is the java part:</p>

<pre><code>private static final Provider SECURITY_PROVIDER = new BouncyCastleProvider();

public byte[] decryptMessage(byte[] message) throws Exception {
    KeyFactory keyFactory = KeyFactory.getInstance(""EC"", SECURITY_PROVIDER);
    PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(
            IOUtils.toByteArray(getClass().getResourceAsStream(""/key.pkcs8"")));
    PrivateKey privKey = keyFactory.generatePrivate(privSpec);

    Cipher cipher = Cipher.getInstance(""ECIESwithAES-CBC/NONE/PKCS5Padding"", SECURITY_PROVIDER);
    cipher.init(Cipher.DECRYPT_MODE, privKey);
    byte[] result = cipher.doFinal(message);
    return result;
}
</code></pre>

<p>Currently when I take the output from Crypto++ and try to decrypt it in BouncyCastle, it throws an exception:</p>

<pre><code>javax.crypto.BadPaddingException: pad block corrupted
  at org.bouncycastle.jcajce.provider.asymmetric.ec.IESCipher.engineDoFinal(Unknown Source)
  at javax.crypto.Cipher.doFinal(Cipher.java:2087)
  ...
</code></pre>

<p>I'm not sure if it is really a padding issue or am I doing something completely wrong?</p>

<p>Any suggestions and help would be greatly appreciated.<br>
Thank you!</p>

<p>PS: I've already applied the bouncy castle patch mentioned at <a href=""https://www.cryptopp.com/wiki/Elliptic_curve_integrated_encryption_scheme#Bouncy_Castle_Patch"" rel=""nofollow noreferrer"">CryptoWiki</a></p>
","<p>ECIES has a few different encryption methods, depending on the standard being used. At the moment, Crypto++ only implements the P1363 XOR method (below is from <a href=""https://github.com/weidai11/cryptopp/blob/master/gfpcrypt.h#L539"" rel=""nofollow noreferrer"">gfpcrypt.h</a>). That probably explains most of the exception.</p>

<p>In order to fix things, I believe you have three choices. First, you can use the XOR method since both Bouncy Castle and Crypto++ have it.</p>

<p>Second, you may be able to use <a href=""https://github.com/randombit/botan"" rel=""nofollow noreferrer"">Jack Lloyd's Botan</a>. Both Botan and Crypto++ attempt to align with Bouncy Castle in an effort to promote interop, but Botan has a few more encryption methods.</p>

<p>Third, Crypto++ needs to add another encryption method compatible with Bouncy Castle. I suppose it would be called <code>DL_EncryptionAlgorithm_AES_CBC</code>. I'm not sure what the <strong><em><code>None</code></em></strong> refers to in <strong><em><code>AES-CBC/NONE/PKCS7Padding</code></em></strong>.</p>

<p>Crypto++ would be happy to add <code>DL_EncryptionAlgorithm_AES_CBC</code>. To add it, I need someone to work with who has Java/BC experience. If you are interested, contact me a <em>noloader, gmail account</em>.</p>

<hr>

<p>Regarding <em>""Botan and Crypto++ attempt to align with Bouncy Castle in an effort to promote interop""</em> ... Things are a mess for users. Martínez, Encinas, and Ávila note in <a href=""http://www.researchgate.net/profile/Carmen_Sanchez_Avila/publication/255970113_A_Survey_of_the_Elliptic_Curve_Integrated_Encryption_Scheme/links/02e7e5212654222f0a000000.pdf"" rel=""nofollow noreferrer"">A Survey of the Elliptic Curve Integrated Encryption Scheme</a>:</p>

<blockquote>
  <p>... it is not possible to implement a software version compatible with
  all those standards, regarding both the specific operations and the
  list of allowed functions and algorithms.</p>
</blockquote>

<p>I can point out countless examples of interop problems, from your question to problems with Bitcoin and Zcash standardizing their protocol because of too many incompatible choices. It goes on and on.</p>

<hr>

<p>These comments are from <a href=""https://github.com/weidai11/cryptopp/blob/master/gfpcrypt.h#L539"" rel=""nofollow noreferrer"">gfpcrypt.h</a>, and available in the <a href=""https://www.cryptopp.com/docs/ref/struct_e_c_i_e_s.html"" rel=""nofollow noreferrer"">Crypto++ Manual for ECIES</a>:</p>

<pre><code>//! \class DL_EncryptionAlgorithm_Xor
//! \brief P1363 based XOR Encryption Method
//! \tparam MAC MessageAuthenticationCode derived class used for MAC computation
//! \tparam DHAES_MODE flag indicating DHAES mode
//! \tparam LABEL_OCTETS flag indicating the label is octet count
//! \details DL_EncryptionAlgorithm_Xor is based on an early P1363 draft, which itself appears to be based on an
//!   early Certicom SEC-1 draft (or an early SEC-1 draft was based on a P1363 draft). Crypto++ 4.2 used it in its Integrated
//!   Ecryption Schemes with &lt;tt&gt;NoCofactorMultiplication&lt;/tt&gt;, &lt;tt&gt;DHAES_MODE=false&lt;/tt&gt; and &lt;tt&gt;LABEL_OCTETS=true&lt;/tt&gt;.
//! \details If you need this method for Crypto++ 4.2 compatibility, then use the ECIES template class with
//!   &lt;tt&gt;NoCofactorMultiplication&lt;/tt&gt;, &lt;tt&gt;DHAES_MODE=false&lt;/tt&gt; and &lt;tt&gt;LABEL_OCTETS=true&lt;/tt&gt;.
//! \details If you need this method for Bouncy Castle 1.54 and Botan 1.11 compatibility, then use the ECIES template class with
//!   &lt;tt&gt;NoCofactorMultiplication&lt;/tt&gt;, &lt;tt&gt;DHAES_MODE=ture&lt;/tt&gt; and &lt;tt&gt;LABEL_OCTETS=false&lt;/tt&gt;.
//! \details Bouncy Castle 1.54 and Botan 1.11 compatibility are the default template parameters.
//! \since Crypto++ 4.0
template &lt;class MAC, bool DHAES_MODE, bool LABEL_OCTETS=false&gt;
class DL_EncryptionAlgorithm_Xor : public DL_SymmetricEncryptionAlgorithm
{
public:

    bool ParameterSupported(const char *name) const {return strcmp(name, Name::EncodingParameters()) == 0;}
    size_t GetSymmetricKeyLength(size_t plaintextLength) const
        {return plaintextLength + static_cast&lt;size_t&gt;(MAC::DIGESTSIZE);}
    size_t GetSymmetricCiphertextLength(size_t plaintextLength) const
        {return plaintextLength + static_cast&lt;size_t&gt;(MAC::DIGESTSIZE);}
    size_t GetMaxSymmetricPlaintextLength(size_t ciphertextLength) const
        {return SaturatingSubtract(ciphertextLength, static_cast&lt;size_t&gt;(MAC::DIGESTSIZE));}
    void SymmetricEncrypt(RandomNumberGenerator &amp;rng, const byte *key, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &amp;parameters) const
    {
        CRYPTOPP_UNUSED(rng);
        const byte *cipherKey = NULL, *macKey = NULL;
        if (DHAES_MODE)
        {
            macKey = key;
            cipherKey = key + MAC::DEFAULT_KEYLENGTH;
        }
        else
        {
            cipherKey = key;
            macKey = key + plaintextLength;
        }

        ConstByteArrayParameter encodingParameters;
        parameters.GetValue(Name::EncodingParameters(), encodingParameters);

        if (plaintextLength)    // Coverity finding
            xorbuf(ciphertext, plaintext, cipherKey, plaintextLength);

        MAC mac(macKey);
        mac.Update(ciphertext, plaintextLength);
        mac.Update(encodingParameters.begin(), encodingParameters.size());
        if (DHAES_MODE)
        {
            byte L[8];
            PutWord(false, BIG_ENDIAN_ORDER, L, (LABEL_OCTETS ? word64(encodingParameters.size()) : 8 * word64(encodingParameters.size())));
            mac.Update(L, 8);
        }
        mac.Final(ciphertext + plaintextLength);
    }
    DecodingResult SymmetricDecrypt(const byte *key, const byte *ciphertext, size_t ciphertextLength, byte *plaintext, const NameValuePairs &amp;parameters) const
    {
        size_t plaintextLength = GetMaxSymmetricPlaintextLength(ciphertextLength);
        const byte *cipherKey, *macKey;
        if (DHAES_MODE)
        {
            macKey = key;
            cipherKey = key + MAC::DEFAULT_KEYLENGTH;
        }
        else
        {
            cipherKey = key;
            macKey = key + plaintextLength;
        }

        ConstByteArrayParameter encodingParameters;
        parameters.GetValue(Name::EncodingParameters(), encodingParameters);

        MAC mac(macKey);
        mac.Update(ciphertext, plaintextLength);
        mac.Update(encodingParameters.begin(), encodingParameters.size());
        if (DHAES_MODE)
        {
            byte L[8];
            PutWord(false, BIG_ENDIAN_ORDER, L, (LABEL_OCTETS ? word64(encodingParameters.size()) : 8 * word64(encodingParameters.size())));
            mac.Update(L, 8);
        }
        if (!mac.Verify(ciphertext + plaintextLength))
            return DecodingResult();

        if (plaintextLength)    // Coverity finding
            xorbuf(plaintext, ciphertext, cipherKey, plaintextLength);

        return DecodingResult(plaintextLength);
    }
};
</code></pre>
","844","<java><ios><bouncycastle><crypto++><ecies>","2","1","1","2016-12-03 06:11:12","40937746","0","3","","","","2016-12-02 14:59:04",""
"9910272","Get started with Crypto++","<p>I don't know if it's right to ask this question here or not.<br>
I'm trying to use Crypto++ library in a project. I can't even get started with it. This is the code I'm trying:  </p>

<pre><code>#include &lt;cryptlib.h&gt;
#include &lt;sha.h&gt;

int main()
{
    SHA hash;  // ERROR here. can't find SHA
    return 0;
}
</code></pre>

<p>I tried reading the readme file included in the download package. I tried <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow"">this</a> and still didn't manage to get it to work. I'm using VS2010.</p>
","<p>From <a href=""http://www.trolocsis.com/crypto++/sha_8h-source.html"" rel=""nofollow"">here</a>:</p>

<pre><code>NAMESPACE_BEGIN(CryptoPP)

class CRYPTOPP_DLL SHA : public ...
</code></pre>

<p>it appears that <code>SHA</code> is a member of namespace <code>CryptoPP</code>. Try:</p>

<pre><code>CryptoPP::SHA hash;
</code></pre>
","841","<c++><visual-studio><visual-studio-2010><crypto++>","0","2","1","2012-03-28 15:03:20","9910345","0","","","","","2012-03-28 15:00:01",""
"22895747","Generating Random Numbers Within a Specified Range Using Crypto++","<p>How do you generate random numbers within a specified range using the crypto++ AutoSeededRandomPool random number generator.</p>
","<blockquote>
  <p>How do you generate random numbers within a specified range ...</p>
</blockquote>

<p>Use an <code>Integer</code>, which is multi-precision. The contructor of interest:</p>

<pre><code>Integer (RandomNumberGenerator &amp;rng, const Integer &amp;min, const Integer &amp;max,
         RandomNumberType rnType=ANY, const Integer &amp;equiv=Zero(), const Integer &amp;mod=One())
</code></pre>

<p>See <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow"">Integer Class Reference</a> for details.</p>

<hr>

<blockquote>
  <p>... using the crypto++ <code>AutoSeededRandomPool</code></p>
</blockquote>

<p><code>AutoSeededRandomPool</code> is derived from <code>RandomNumberGenerator</code>, so you will be able to use it.</p>

<p>See <a href=""http://www.cryptopp.com/docs/ref/class_auto_seeded_random_pool.html"" rel=""nofollow"">AutoSeededRandomPool Class Reference</a> for details.</p>
","825","<c++><random><crypto++>","1","1","1","2014-04-06 15:17:24","","0","","608639","","2014-04-06 15:17:24","2014-04-06 15:04:35",""
"19083530","Base64 encoding fails","<p>I am using Crypto++ for other encryption needs; however, I also need to store binary information as ascii text. To do that I have synthesized examples of Crypto++'s base 64 filter into the following block of code. </p>

<pre><code>bool saveData(const unsigned char * buffer, size_t length)
{

    int lenb64 = (ceil(length / 3.0) * 4) + 1;
    unsigned char * temp_str = (unsigned char *)malloc(lenb64);

    CryptoPP::ArraySource as(buffer, length, new CryptoPP::Base64Encoder(
        new CryptoPP::ArraySink(temp_str, lenb64)));

    //do something with temp_str.
    free(temp_str); //Then free the tempstr.
    //Return true if do something worked, else false.
}
</code></pre>

<p>The problem I'm having is that after this operation temp_str is still filled with garbage. I have looked around, and cannot find any examples that do anything other than what I've done above. Is there something I'm missing?</p>
","<p><code>CryptoPP::ArraySource</code> is a <code>typedef</code> of <a href=""http://www.cryptopp.com/docs/ref/class_string_source.html"" rel=""nofollow""><code>CryptoPP::StringSource</code></a>.  The signature of <code>StringSource</code>'s relevant constructor is:</p>

<pre><code>StringSource(const byte *string,
             size_t length,
             bool pumpAll,
             BufferedTransformation *attachment=NULL);
</code></pre>

<p>So your third argument which is a pointer to a <code>CryptoPP::Base64Encoder</code> is being cast to a <code>bool</code>, and the fourth argument is the default <code>NULL</code>.</p>

<p>To resolve this, just do:</p>

<pre><code>CryptoPP::ArraySource(buffer, length, true,
    new CryptoPP::Base64Encoder(
        new CryptoPP::ArraySink(temp_str, lenb64)));
</code></pre>
","824","<c++><crypto++>","3","2","2","2015-05-02 21:32:19","19101957","0","","608639","","2015-05-02 21:32:08","2013-09-29 21:32:35",""
"19083530","Base64 encoding fails","<p>I am using Crypto++ for other encryption needs; however, I also need to store binary information as ascii text. To do that I have synthesized examples of Crypto++'s base 64 filter into the following block of code. </p>

<pre><code>bool saveData(const unsigned char * buffer, size_t length)
{

    int lenb64 = (ceil(length / 3.0) * 4) + 1;
    unsigned char * temp_str = (unsigned char *)malloc(lenb64);

    CryptoPP::ArraySource as(buffer, length, new CryptoPP::Base64Encoder(
        new CryptoPP::ArraySink(temp_str, lenb64)));

    //do something with temp_str.
    free(temp_str); //Then free the tempstr.
    //Return true if do something worked, else false.
}
</code></pre>

<p>The problem I'm having is that after this operation temp_str is still filled with garbage. I have looked around, and cannot find any examples that do anything other than what I've done above. Is there something I'm missing?</p>
","<blockquote>
  <p>The problem I'm having is that after this operation temp_str is still filled with garbage. </p>
</blockquote>

<p>Its actually unintialized data as Fraser pointed out.</p>

<p>The Crypto++ wiki has a page covering the topic at <a href=""http://www.cryptopp.com/wiki/Missing_data"" rel=""nofollow"">Missing Data</a>.</p>

<hr>

<p>You can also avoid the size calculation and buffer management with:</p>

<pre><code>string base64;
CryptoPP::ArraySource as(buffer, length, true,
    new CryptoPP::Base64Encoder(
        new CryptoPP::StringSink(base64)));
</code></pre>
","824","<c++><crypto++>","3","0","2","2015-05-02 21:32:19","19101957","0","","608639","","2015-05-02 21:32:08","2013-09-29 21:32:35",""
"25878671","Raw RSA encryption and decryption using Crypto++","<p>I'm using <a href=""https://gist.github.com/JacobHacker/8d496d66cab4bda98e79"" rel=""nofollow noreferrer"">Raw RSA encryption and decryption.</a> tutorial and <a href=""http://www.cryptopp.com/wiki/Raw_RSA"" rel=""nofollow noreferrer"">Raw RSA</a> from the Crypto++ wiki to develop a simple code that encrypt/decrypt string using RSA using Crypto++.</p>

<p>I'm using Visual studio 2010. The code run without error. But, I don't understand what is the significant of n, e, d ? Why can't I change it?</p>

<p>I respected the algorithm of RSA and I chose this value:</p>

<pre><code>    // La clé publique est la paire (e, n) et la clé secrète est d, donc aussi p et q.
    // p = 3, q = 11, n = 3 x 11, f = (11–1).(3–1) = 20. On choisit d=7 (7 et 20 sont bien premiers entre eux).
    // e = 3 car e.d= 20 * 1 + 1
</code></pre>

<p>But always I have debug error:
<img src=""https://i.stack.imgur.com/vTJsD.png"" alt=""enter image description here"">
<img src=""https://i.stack.imgur.com/plzlq.png"" alt=""enter image description here""></p>

<p>Can someone help me ?</p>
","<pre><code> // p = 3, q = 11, n = 3 x 11, f = (11–1).(3–1) = 20. On choisit d=7
 //    (7 et 20 sont bien premiers entre eux).
 // e = 3 car e.d= 20 * 1 + 1
</code></pre>

<p>These parameters are artificially small. Probably too small.</p>

<p>One of the properties of RSA is the message size must be smaller than the modulus size. 3x11 = 33, and that's 2<sup>5</sup> (give or take). So your message must be smaller than 5 bits.</p>

<p>Crypto++ specifies messages sizes in bytes, not bits. So you will likely never be able to encrypt anything under the modulus of 33.</p>

<p>Unfortunately, the cited wiki page does not discuss that <code>size_in_bits(message) &lt; size_in_bits(modulus)</code>. And I can't change it at the moment because Crypto++ is broken for writes (reads are OK).</p>

<p>Also, here's from <a href=""http://www.cryptopp.com/docs/ref/rsa_8cpp_source.html"" rel=""nofollow""><code>rsa.cpp</code></a>:</p>

<pre><code>if (modulusSize &lt; 16)
  throw InvalidArgument(""InvertibleRSAFunction: specified modulus size is too small"");
</code></pre>

<p>So you should probably specify a modulus at least 2<sup>16</sup> in size. 2<sup>16</sup> is 65536.</p>

<p>Finally, until we see the relevant parts of your program and error message, this is just speculation.</p>
","809","<c++><encryption><rsa><public-key-encryption><crypto++>","2","0","1","2014-09-16 23:59:30","25879731","7","","3531447","","2014-09-16 21:58:46","2014-09-16 21:23:59",""
"34156787","Android - undefined reference to cryptopp","<p>I successfully compiled and executed Cryptopp in IOS but i really struggling to make work it in android. </p>

<p>Here i am using Cryptopp 5.6.3, NDK r10e and android studio 1.5 , I can successfully build libcryptopp.so through ndk-build but it throughs number of errors like undefined reference to 'vtable for CryptoPP::AutoSeededX917RNG' when i make rebuild through android studio.</p>

<p><strong>In Android.mk</strong></p>

<pre><code>LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE    := crypt_user
LOCAL_SRC_FILES := crypt_user.cpp
LOCAL_SHARED_LIBRARIES := cryptopp

include $(BUILD_SHARED_LIBRARY)

include $(CLEAR_VARS)

LOCAL_MODULE := cryptopp
LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcryptopp.so
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include

include $(PREBUILT_SHARED_LIBRARY)
</code></pre>

<p><strong>in Application.mk</strong></p>

<pre><code>APP_ABI := armeabi
APP_CPPFLAGS += -fexceptions -frtti
APP_STL := stlport_shared
#APP_STL := gnustl_shared
</code></pre>

<p><strong>in build.gradle</strong></p>

<pre><code>apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
    buildToolsVersion ""23.0.0""

    defaultConfig {
        applicationId ""com.kasbah.jeeva.ndklearning""
        minSdkVersion 16
        targetSdkVersion 23
        versionCode 1
        versionName ""1.0""

        ndk {
            moduleName = ""crypt_user""
            cFlags(""-fexceptions"")
            stl = ""stlport_shared""
        }

    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            debuggable true
            jniDebuggable true
        }
    }
}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:23.1.1'
    compile 'com.android.support:design:23.1.1'
}
</code></pre>

<p><strong>In crypt_user.cpp</strong></p>

<pre><code>#include &lt;jni.h&gt;
#include ""../cryptopp/include/cryptlib.h""

#include ""../cryptopp/include/osrng.h""
//using CryptoPP::AutoSeededRandomPool;
using CryptoPP::AutoSeededX917RNG;

#include ""../cryptopp/include/aes.h""
using CryptoPP::AES;

#ifdef __cplusplus
extern ""C"" {
#endif
jlong Java_com_kasbah_jeeva_ndklearning_MainActivity_fun
    (JNIEnv* env, jobject o, jint i) {

    AutoSeededX917RNG&lt;AES&gt; rng;

  long long t = CryptoPP::INFINITE_TIME / i;
  return t;
}
#ifdef __cplusplus
}
#endif
</code></pre>

<p>I can compile it successfully when i didnt use any cryptopp related code.</p>

<p>Please help me to solve this problem because i am fighting with this for more than 2 weeks..</p>

<p><a href=""https://i.stack.imgur.com/kMhYh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/kMhYh.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/NDTOo.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NDTOo.png"" alt=""enter image description here""></a></p>
","<blockquote>
  <p>... number of errors like undefined reference to <code>'vtable for CryptoPP::AutoSeededX917RNG'</code></p>
</blockquote>

<p>Use <code>nm</code> to ensure the symbol is present:</p>

<pre><code>$ arm-linux-androideabi-nm -D --demangle libcryptopp.so | grep AutoSeededX917RNG | sed 's|CryptoPP::||g'
00181ec4 W AutoSeededX917RNG&lt;Rijndael&gt;::IncorporateEntropy(unsigned char const*, unsigned int)
0017d728 W AutoSeededX917RNG&lt;Rijndael&gt;::GenerateIntoBufferedTransformation(BufferedTransformation&amp;, std::string const&amp;, unsigned long long)
00181c18 W AutoSeededX917RNG&lt;Rijndael&gt;::Reseed(unsigned char const*, unsigned int, unsigned char const*, unsigned char const*)
00181ddc W AutoSeededX917RNG&lt;Rijndael&gt;::Reseed(bool, unsigned char const*, unsigned int)
00181e80 W AutoSeededX917RNG&lt;Rijndael&gt;::AutoSeededX917RNG(bool, bool)
00181e80 W AutoSeededX917RNG&lt;Rijndael&gt;::AutoSeededX917RNG(bool, bool)
00169d90 W AutoSeededX917RNG&lt;Rijndael&gt;::~AutoSeededX917RNG()
00169d6c W AutoSeededX917RNG&lt;Rijndael&gt;::~AutoSeededX917RNG()
00169d6c W AutoSeededX917RNG&lt;Rijndael&gt;::~AutoSeededX917RNG()
0017d724 W AutoSeededX917RNG&lt;Rijndael&gt;::CanIncorporateEntropy() const
0023336c D typeinfo for AutoSeededX917RNG&lt;Rijndael&gt;
001fe0bc R typeinfo name for AutoSeededX917RNG&lt;Rijndael&gt;
00232308 V vtable for AutoSeededX917RNG&lt;Rijndael&gt;
</code></pre>

<hr>

<blockquote>
  <p>in Application.mk<br>
  ...</p>
</blockquote>

<p>Below is what my <code>Android.mk</code> looks like for a shared object that provides random numbers. You can find it on GitHub at <a href=""https://github.com/noloader/Android-PRNG"" rel=""nofollow"">Android-PRNG</a>. Notice the STLport stuff is first, the Crypto++ stuff is second, and then the PRNG library is third.</p>

<p>The PRNG library is simple. It contains one file - <code>libprng.cpp</code>. It samples sensors to develop seeds for a random number generator. Android Java calls into the PRNG library.</p>

<pre><code>LOCAL_PATH := $(call my-dir)

# NDK_DEBUG_IMPORTS := 1

#########################################################
# STLport library
include $(CLEAR_VARS)

STLPORT_INCL     := /opt/android-ndk-r10d/sources/cxx-stl/stlport/stlport
STLPORT_LIB      := /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/$(TARGET_ARCH_ABI)

LOCAL_MODULE := stlport_shared
LOCAL_SRC_FILES := $(STLPORT_LIB)/libstlport_shared.so

LOCAL_EXPORT_CPPFLAGS :=
LOCAL_EXPORT_C_INCLUDES := $(STLPORT_INCL)

include $(PREBUILT_SHARED_LIBRARY)

LOCAL_SHARED_LIBRARIES  := stlport_shared

#########################################################
# Crypto++ library
include $(CLEAR_VARS)

CRYPTOPP_INCL   := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/include
CRYPTOPP_LIB    := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/lib

LOCAL_MODULE       := cryptopp
LOCAL_SRC_FILES    := $(CRYPTOPP_LIB)/libcryptopp.so

LOCAL_EXPORT_CPPFLAGS := -Wno-unused-parameter -Wno-unused-variable -Wno-unused-function
LOCAL_EXPORT_C_INCLUDES := $(CRYPTOPP_INCL) $(CRYPTOPP_INCL)/cryptopp

include $(PREBUILT_SHARED_LIBRARY)

LOCAL_SHARED_LIBRARIES  := cryptopp

#########################################################
# PRNG library
include $(CLEAR_VARS)

APP_STL         := stlport_shared
APP_MODULES     := prng stlport_shared cryptopp

# My ass... LOCAL_EXPORT_C_INCLUDES is useless
LOCAL_C_INCLUDES   := $(STLPORT_INCL) $(CRYPTOPP_INCL)

LOCAL_CPP_FEATURES := rtti exceptions

LOCAL_CPP_FLAGS    := -Wno-unused-parameter -Wno-unused-variable -Wno-unused-function
LOCAL_CPP_FLAGS    += -Wl,--exclude-libs,ALL

LOCAL_LDLIBS            := -llog -landroid
LOCAL_SHARED_LIBRARIES  := cryptopp stlport_shared

LOCAL_MODULE    := prng
LOCAL_SRC_FILES := libprng.cpp

include $(BUILD_SHARED_LIBRARY)
</code></pre>

<hr>

<p>The GitHub project builds fine using <code>ndk-build</code>:</p>

<pre><code>~$ cd Android-PRNG
Android-PRNG$ ndk-build
Android NDK: WARNING: APP_PLATFORM android-14 is larger than android:minSdkVersion 9 in ./AndroidManifest.xml    
[armeabi] Gdbserver      : [arm-linux-androideabi-4.8] libs/armeabi/gdbserver
[armeabi] Gdbsetup       : libs/armeabi/gdb.setup
[x86] Gdbserver      : [x86-4.8] libs/x86/gdbserver
[x86] Gdbsetup       : libs/x86/gdb.setup
[mips] Gdbserver      : [mipsel-linux-android-4.8] libs/mips/gdbserver
[mips] Gdbsetup       : libs/mips/gdb.setup
[armeabi-v7a] Gdbserver      : [arm-linux-androideabi-4.8] libs/armeabi-v7a/gdbserver
[armeabi-v7a] Gdbsetup       : libs/armeabi-v7a/gdb.setup
[x86_64] Gdbserver      : [x86_64-4.9] libs/x86_64/gdbserver
[x86_64] Gdbsetup       : libs/x86_64/gdb.setup
[armeabi] Prebuilt       : libcryptopp.so &lt;= /usr/local/cryptopp/android-armeabi/lib/
[armeabi] Install        : libcryptopp.so =&gt; libs/armeabi/libcryptopp.so
[armeabi] Compile++ thumb: prng &lt;= libprng.cpp
[armeabi] Prebuilt       : libstlport_shared.so &lt;= /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/armeabi/
[armeabi] StaticLibrary  : libstdc++.a
[armeabi] SharedLibrary  : libprng.so
[armeabi] Install        : libprng.so =&gt; libs/armeabi/libprng.so
[armeabi] Install        : libstlport_shared.so =&gt; libs/armeabi/libstlport_shared.so
[x86] Prebuilt       : libcryptopp.so &lt;= /usr/local/cryptopp/android-x86/lib/
[x86] Install        : libcryptopp.so =&gt; libs/x86/libcryptopp.so
[x86] Compile++      : prng &lt;= libprng.cpp
[x86] Prebuilt       : libstlport_shared.so &lt;= /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/x86/
[x86] StaticLibrary  : libstdc++.a
[x86] SharedLibrary  : libprng.so
[x86] Install        : libprng.so =&gt; libs/x86/libprng.so
[x86] Install        : libstlport_shared.so =&gt; libs/x86/libstlport_shared.so
[mips] Prebuilt       : libcryptopp.so &lt;= /usr/local/cryptopp/android-mips/lib/
[mips] Install        : libcryptopp.so =&gt; libs/mips/libcryptopp.so
[mips] Compile++      : prng &lt;= libprng.cpp
[mips] Prebuilt       : libstlport_shared.so &lt;= /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/mips/
[mips] StaticLibrary  : libstdc++.a
[mips] SharedLibrary  : libprng.so
[mips] Install        : libprng.so =&gt; libs/mips/libprng.so
[mips] Install        : libstlport_shared.so =&gt; libs/mips/libstlport_shared.so
[armeabi-v7a] Prebuilt       : libcryptopp.so &lt;= /usr/local/cryptopp/android-armeabi-v7a/lib/
[armeabi-v7a] Install        : libcryptopp.so =&gt; libs/armeabi-v7a/libcryptopp.so
[armeabi-v7a] Compile++ thumb: prng &lt;= libprng.cpp
[armeabi-v7a] Prebuilt       : libstlport_shared.so &lt;= /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/armeabi-v7a/
[armeabi-v7a] StaticLibrary  : libstdc++.a
[armeabi-v7a] SharedLibrary  : libprng.so
[armeabi-v7a] Install        : libprng.so =&gt; libs/armeabi-v7a/libprng.so
[armeabi-v7a] Install        : libstlport_shared.so =&gt; libs/armeabi-v7a/libstlport_shared.so
[x86_64] Prebuilt       : libcryptopp.so &lt;= /usr/local/cryptopp/android-x86_64/lib/
[x86_64] Install        : libcryptopp.so =&gt; libs/x86_64/libcryptopp.so
[x86_64] Compile++      : prng &lt;= libprng.cpp
[x86_64] Prebuilt       : libstlport_shared.so &lt;= /opt/android-ndk-r10d/sources/cxx-stl/stlport/libs/x86_64/
[x86_64] StaticLibrary  : libstdc++.a
[x86_64] SharedLibrary  : libprng.so
[x86_64] Install        : libprng.so =&gt; libs/x86_64/libprng.so
[x86_64] Install        : libstlport_shared.so =&gt; libs/x86_64/libstlport_shared.so
</code></pre>
","809","<android><c++><android-ndk><crypto++>","1","1","1","2015-12-14 12:12:21","","0","","","","","2015-12-08 13:11:11",""
"27363756","Gzip compress/uncompress a long char array","<p>I need to compress a large byte array, im already using the Crypto++ library in the application, so having the compression/decompression part in the same library would be great.</p>

<p>this little test works as expected:</p>

<pre><code>///
string test = ""bleachbleachtestingbiatchbleach123123bleachbleachtestingb.....more"";
string compress(string input)
{
    string result ("""");
    CryptoPP::StringSource(input, true, new CryptoPP::Gzip(new CryptoPP::StringSink(result), 1));
    return result;
}

string decompress(string _input)
{
    string _result ("""");
    CryptoPP::StringSource(_input, true, new CryptoPP::Gunzip(new CryptoPP::StringSink(_result), 1));
    return _result;
}

void main()
{
    string compressed = compress(test);
    string decompressed = decompress(compressed);
    cout &lt;&lt; ""orginal size :"" &lt;&lt; test.length() &lt;&lt; endl;
    cout &lt;&lt; ""compressed size :"" &lt;&lt; compressed.length() &lt;&lt; endl;
    cout &lt;&lt; ""decompressed size :"" &lt;&lt; decompressed.length() &lt;&lt; endl;
    system(""PAUSE"");
}
</code></pre>

<p>I need to compress something like this:</p>

<pre><code>unsigned char long_array[194506]
{
  0x00,0x00,0x02,0x00,0x00,0x04,0x00,0x00,0x00,
  0x01,0x00,0x02,0x00,0x00,0x04,0x02,0x00,0x04,
  0x04,0x00,0x02,0x00,0x01,0x04,0x02,0x00,0x04,
  0x01,0x00,0x02,0x02,0x00,0x04,0x02,0x00,0x00,
  0x03,0x00,0x02,0x00,0x00,0x04,0x01,0x00,0x04,
  ....
};
</code></pre>

<p>i tried to use the long_array as const char * and as byte then feed it to the compress function, it seems to be compressed but the decompressed one has a size of 4, and its clearly uncomplete. maybe its too long.
How could i rewrite those compress/uncompress functions to work with that byte array?
Thank you all. :)</p>
","<blockquote>
  <p>i tried to use the array as const char * and as byte then feed it to the compress function, it seems to be compressed but the decompressed one has a size of 4, and its clearly uncomplete.</p>
</blockquote>

<p>Use the alternate <code>StringSource</code> constructor that takes a <a href=""http://www.cryptopp.com/docs/ref/class_string_source.html"" rel=""nofollow"">pointer and a length</a>. It will be immune to embedded <code>NULL's</code>.</p>

<pre><code>CryptoPP::StringSource ss(long_array, sizeof(long_array), true,
    new CryptoPP::Gzip(
        new CryptoPP::StringSink(result), 1)
));
</code></pre>

<p>Or, you can use:</p>

<pre><code>Gzip zipper(new StringSink(result), 1);
zipper.Put(long_array, sizeof(long_array));
zipper.MessageEnd();
</code></pre>

<p>Crypto++ added an <a href=""http://www.cryptopp.com/wiki/ArraySource"" rel=""nofollow""><code>ArraySource</code></a> at 5.6. You can use it too (but its really a <code>typedef</code> for a <code>StringSource</code>):</p>

<pre><code>CryptoPP::ArraySource as(long_array, sizeof(long_array), true,
    new CryptoPP::Gzip(
        new CryptoPP::StringSink(result), 1)
));
</code></pre>

<p>The <code>1</code> that is used as an argument to <code>Gzip</code> is a deflate level. <code>1</code> is one of the lowest compressions. You might consider using <code>9</code> or <code>Gzip::MAX_DEFLATE_LEVEL</code> (which is 9). The default log<sub>2</sub> windows size is the max size, so there's no need to turn any knobs on it.</p>

<pre><code>Gzip zipper(new StringSink(result), Gzip::MAX_DEFLATE_LEVEL);
</code></pre>

<p>You should also name your declarations. I've seen GCC generate bad code when using anonymous declarations.</p>

<p>Finally,  use <code>long_array</code> (or similar) because <code>array</code> is a keyword in C++ 11.</p>
","807","<c++><arrays><visual-c++><gzip><crypto++>","2","2","1","2015-10-16 21:23:31","","3","","4061696","","2014-12-09 10:47:43","2014-12-08 17:46:07",""
"25752161","_free_base ""Error reading register value""","<p>I have some code from my test application:</p>

<pre><code>char* buff = new char[0];
f_hStream.read(buff, size);
string cut_header = zCrypto::from_base64( string(buff, size) );

if ( cut_header.length() == 0 ) break;

const char* dec = zCrypto::decrypt( cut_header );
printf( ""Header &gt;&gt; %s\n"", dec );
vector&lt;string&gt; header = split(string(dec), ';');
</code></pre>

<h3><code>decrypt</code> function ></h3>

<pre><code>const char* zCrypto::decrypt(const std::string&amp; str_in) {
    const string key = zCrypto::from_base64(""&lt;base_64line_here&gt;"");
    const string iv = zCrypto::from_base64(""&lt;base_64line_here&gt;"");

    std::string str_out;
    CryptoPP::CBC_Mode&lt;CryptoPP::Rijndael&gt;::Decryption decryption((byte*)key.c_str(), key.length(), (byte*)iv.c_str());

    CryptoPP::StringSource encryptor(str_in, true,
        new CryptoPP::StreamTransformationFilter(decryption,
            new CryptoPP::StringSink(str_out)
        )
    );

    return str_out.data();
}
</code></pre>

<p>And i getting debugger error on line <strong>const char* dec = zCrypto::decrypt( cut_header );</strong>, if i trying to launch application without <em>MVS</em> debugger, he just crash - <code>Application has stopped working...</code> </p>

<p>P.S. I can't change <code>Code Generation</code> - <code>Runtime Library</code> from <strong>/MT</strong>, cryptopp functions in my app compiling without errors only with this type.</p>

<p>Decryption works fine too, whats I do wrong?</p>

<h2>UPDATE:</h2>

<p>I change </p>

<pre><code>const char* zCrypto::decrypt(const std::string&amp; str_in) {
</code></pre>

<p>to</p>

<pre><code>string zCrypto::decrypt(const std::string&amp; str_in) {
</code></pre>

<p>and </p>

<pre><code>char* buff = new char[0];
const char* dec = zCrypto::decrypt( cut_header );
</code></pre>

<p>to</p>

<pre><code>char* buff = new char[size];
string dec = zCrypto::decrypt( cut_header );
</code></pre>

<p><strong>I'm still getting error.</strong></p>
","<p>This line does not sound right.</p>

<pre><code>char* buff = new char[0];
</code></pre>

<p>You probably need:</p>

<pre><code>char* buff = new char[size];
</code></pre>
","805","<c++><encryption><runtime-error><crypto++>","0","1","1","2016-05-17 14:11:29","","5","","3455601","","2014-09-10 07:14:29","2014-09-09 19:27:18",""
"45669056","How to encrypt using AES with sha256 hash as key crypto++","<p>I have a string hashed using SHA256 to use as a key but how would I use this key to encrypt a string with AES in CBC mode and crypto++?
Thanks.</p>
","<p>I ended up achieving the desired outcome with the below code.</p>

<pre><code>    QString qhash = ""hash"";
    std::string plain = ""message"";
    std::string ciphertext;
    std::string stdhash = qhash.toStdString();

    CryptoPP::HexDecoder decoder;
    decoder.Put((byte*)stdhash.data(),qhash.size());
    decoder.MessageEnd();

    CryptoPP::word64 size = decoder.MaxRetrievable();
    char *decodedKey = new char[size];
    decoder.Get((byte *)decodedKey, size);

    byte hash[CryptoPP::AES::MAX_KEYLENGTH], iv[ CryptoPP::AES::BLOCKSIZE ];

    CryptoPP::StringSource(reinterpret_cast&lt;const char *&gt;(decodedKey), true,new CryptoPP::ArraySink(hash, CryptoPP::AES::MAX_KEYLENGTH));
    memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);
    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption Encryptor(hash,sizeof(hash),iv);
    CryptoPP::StringSource( plain, true, new CryptoPP::StreamTransformationFilter( Encryptor, new CryptoPP::HexEncoder(new CryptoPP::StringSink( ciphertext )) ) );
    return ciphertext;
</code></pre>
","804","<c++><encryption><aes><crypto++>","0","0","1","2017-08-14 22:49:14","45684139","9","","6622587","","2017-08-14 08:25:06","2017-08-14 07:03:30",""
"22100851","Failing on call to _mm_loadu_si128() with AESNI intrinsics enabled","<p>We are compiling a 32bit application that links with a static build of <code>cryptopp</code>.</p>

<blockquote>
  <p><strong>gcc :</strong> 4.4.7<br>
  <strong>CPU :</strong> Intel Xeon E5-2680<br>
  <strong>OS :</strong> CentoOS 6.5<br>
  <strong>Crypto++ :</strong> 5.6.2</p>
</blockquote>

<p>Our program compiles and runs fine on this machine. When we attempt to run on  </p>

<blockquote>
  <p><strong>CPU :</strong> Intel Xeon X5690<br>
  <strong>OS :</strong> CentoOS 6.5<br>
  <strong>gcc :</strong> 4.4.6</p>
</blockquote>

<p>We are getting a segmentation fault in cryptopp -> rijndael.cpp -> Rijndael::Base::UncheckedSetKey() call to _mm_loadu_si128()</p>

<p>If we build cryptopp with CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE set to 0 everything runs ok.  It seems like AES-NI should be available on this server, and the cryptopp call to HasAESNI() returns true. </p>

<p>Any ideas as to what could be causing this, or how to track down further?</p>
","<blockquote>
  <p>We get the error when compiling on the E5-2680, and copying to the X5690. </p>
</blockquote>

<p>Oh, that's interesting. Try adding <code>-mtune=pentium4</code> to <code>CXXFLAGS</code>. The Intel Xeon E5-2680 has the AVX instruction set; while the Intel Xeon X5690 only has SSE 4.2. Crypto++ uses the the double quadword multiply (<code>PCLMULQDQ</code>) and <code>AES-NI</code> instructions from the AVX instruction set (which the other processor lacks).</p>

<p>If <code>-mtune=pentium4</code> does not work, then you are going to have to disable via <code>CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE</code>. Now that I think about it, that's what you are probably going to have to do since this is a compile time feature selection, and not a runtime feature selection.</p>
","804","<gcc><centos><intel><crypto++>","1","0","2","2017-04-01 04:29:16","22634491","2","","608639","","2014-12-29 01:37:51","2014-02-28 16:41:12",""
"22100851","Failing on call to _mm_loadu_si128() with AESNI intrinsics enabled","<p>We are compiling a 32bit application that links with a static build of <code>cryptopp</code>.</p>

<blockquote>
  <p><strong>gcc :</strong> 4.4.7<br>
  <strong>CPU :</strong> Intel Xeon E5-2680<br>
  <strong>OS :</strong> CentoOS 6.5<br>
  <strong>Crypto++ :</strong> 5.6.2</p>
</blockquote>

<p>Our program compiles and runs fine on this machine. When we attempt to run on  </p>

<blockquote>
  <p><strong>CPU :</strong> Intel Xeon X5690<br>
  <strong>OS :</strong> CentoOS 6.5<br>
  <strong>gcc :</strong> 4.4.6</p>
</blockquote>

<p>We are getting a segmentation fault in cryptopp -> rijndael.cpp -> Rijndael::Base::UncheckedSetKey() call to _mm_loadu_si128()</p>

<p>If we build cryptopp with CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE set to 0 everything runs ok.  It seems like AES-NI should be available on this server, and the cryptopp call to HasAESNI() returns true. </p>

<p>Any ideas as to what could be causing this, or how to track down further?</p>
","<p>The ""Intel(R) Xeon(R) CPU <strong>E5606</strong>  @ 2.13GH"" don't support ""<strong>AESNI</strong>"" instruction too.  I have compiled Crypto++ on ""Intel Xeon <strong>E312xx</strong> (Sandy Bridge)"",  and get the same error on ""<strong>E5606</strong>""! Disable ""AESNI"" in the CMakeLists.txt file, turn on ""DISABLE_AESNI"" option. 
<code>option(DISABLE_AESNI ""Disable AES-NI"" ON)</code></p>
","804","<gcc><centos><intel><crypto++>","1","0","2","2017-04-01 04:29:16","22634491","2","","608639","","2014-12-29 01:37:51","2014-02-28 16:41:12",""
"25327066","HexDecoder output empty","<p>I'm having a bit of an issue with cryptopp562 (on Debian for what it matters) I have a hex string and am trying to convert it to a decimal int. I'm using the HexDecoder in cryptopp (since I'm already using cryptopp for other things in the project). Since I don't know of a way to go straight from a hex string to a decimal int in one step, I have an intermediate step of decimal string. So it goes</p>

<p>Hex string > Decimal string > Decimal int</p>

<p>However my pipeline appears to be incorrect, but I can't for the life of me figure out why. I'm not even getting the hex string to decimal string bit right, so my decimal int just constantly reads 0. I've used Base64Encoder (and Decoder), and ZlibCompressor (and Decompressor) in the past with no problem, so this is sort of a little embarrassing because it should just be more of the same.</p>

<pre><code>std::string RecoveredDecimalString;
std::string RecoveredHex = ""39""; //Hex, so would be 63 in decimal
CryptoPP::StringSource (RecoveredHex, true /*PumpAll*/,
    new CryptoPP::HexDecoder(
        new CryptoPP::StringSink(RecoveredDecimalString) /*StringSink*/
    )/*HexDecoder*/
);/*StringSource*/
</code></pre>

<p>But like I say, after running this, RecoveredDecimalString.empty() returns true. At first I thought it was because I'd missed off the pump all parameter, but adding that made no difference, still nothing's flowing.</p>

<p><a href=""https://stackoverflow.com/questions/17306752/decoding-hex-encoded-value-with-cryptopp"">A similar question was asked (and answered) a year ago</a>. The answer came back as ""read the cryptoPP wiki"", but I can't see how my code is different from what's on their wiki.</p>

<p>What have I forgotten? I know it's going to be something very small.</p>
","<pre><code>std::string RecoveredDecimalString;
std::string RecoveredHex = ""39""; //Hex, so would be 63 in decimal
CryptoPP::StringSource (RecoveredHex, true /*PumpAll*/,
    new CryptoPP::HexDecoder(
        new CryptoPP::StringSink(RecoveredDecimalString) /*StringSink*/
    )/*HexDecoder*/
);/*StringSource*/
</code></pre>

<p>Name your <code>StringSource</code>. In the update to your code, notice the <code>StringSource</code> was named <code>ss</code>.</p>

<pre><code>std::string decoded;
std::string encoded = ""39""; //Hex, so would be 63 in decimal
CryptoPP::StringSource ss(encoded, true /*PumpAll*/,
    new CryptoPP::HexDecoder(
        new CryptoPP::StringSink(decoded) /*StringSink*/
    )/*HexDecoder*/
);/*StringSource*/
</code></pre>

<p>Some versions of GCC have trouble with anonymous declarations. I tracked it down some time ago to <code>StringSink</code> destructors running too soon (before the data was pumped). I wanted to file a GCC bug report, but I could never get it reduced to a minimal case.</p>

<p>You could also perform:</p>

<pre><code>std::string decoded;
std::string encoded = ""39""; //Hex, so would be 63 in decimal

CryptoPP::HexDecoder decoder(new CryptoPP::StringSink(decoded));
decoder.Put(encoded.data(), encoded.size());
decoder.MessageEnd();
</code></pre>
","800","<c++><hex><pipeline><crypto++>","3","1","1","2015-02-16 10:49:50","25378020","3","","-1","","2017-05-23 12:05:42","2014-08-15 13:15:53",""
"32846409","LNK1104 Cryptopp.lib with CRYPTOPP_DEFAULT_NO_DLL defined in dll project","<p>I'm using Visual Studio 2013, with the 2012 toolset and I'm trying to split an win32 executable project up into an exe that consumes a dll that contains all the program logic. The end goal is to be able to create a seperate project for unit tests that can link against the new dll.</p>

<p>Now the old version of the project compiles absolutely fine and uses cryptlib.lib (thanks SVN!), but once I separated it out in to a dll with the program logic and the same project settings I get the following error when I attempt to build the dll:</p>

<p>Error   546 error LNK1104: cannot open file 'cryptopp.lib'  </p>

<p>I have the directory that contains cryptlib.lib in my linker settings and I'm linking against it just as I did in the previous project settings. Based on the documentation it shouldn't be trying to link against cryptopp.lib because CRYPTOPP_DEFAULT_NO_DLL is defined in the preprocessor settings.</p>

<p>I also tried adding the directory that contains cryptopp.lib to the VC++ directory paths and I added cryptopp.lib to my linker settings, and it still gives me the same error. I don't want to use the dll version of cryptopp, but at this point I just need the thing to work.</p>

<p>All the projects are using the 2012 toolsets, and all are being compiled as win32 projects so I'm not sure where to go from here.</p>
","<p>Well I figured out what was happening, if not why. For some reason the preprocessor definitions don't seem to be getting applied. If I put CRYPTOPP_DEFAULT_NO_DLL at the top of all the include files it works as expected.</p>
","796","<c++><visual-studio><dll><crypto++>","0","0","1","2015-09-29 20:30:41","","5","","2429553","","2015-09-29 17:51:28","2015-09-29 14:19:42",""
"23871082","decrypt a given ciphered text using aes algorithm","<p>I am new to cryptography and trying to implement product key validation system. For that purpose, I am using crytopp library for AES algo. Following is my code for decrypting a ciphered text generated by AES algorithm.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;sstream&gt;
#include &lt;cryptopp/dll.h&gt;
#include &lt;cryptopp/md5.h&gt;
#include &lt;iomanip&gt;
#include ""cryptopp/modes.h""
#include ""cryptopp/aes.h""
#include ""cryptopp/filters.h""
#include&lt;stdio.h&gt;
#include ""cryptopp/base64.h""

#define CRYPTOPP_DEFAULT_NO_DLL

void error(std::string err)
{
    std::cout &lt;&lt; err &lt;&lt; ""\n"";
    exit(1);
}

void decrypt()
{

    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    std::string plaintext;
    std::string ciphertext;
    std::string decryptedtext;

    //std::stringstream ss;
    std::cout&lt;&lt; ""Enter Fingerprint:  "";
    std::getline(std::cin , ciphertext);    
    std::cout &lt;&lt; ciphertext.c_str();

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

    std::cout &lt;&lt; ciphertext[i] ;

    }
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

    //std::cout &lt;&lt; ciphertext[i] &lt;&lt; "" "";
    //std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    std::cout &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) ;

    }

    memset( key, 0xACD3, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );


    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );


    std::string src;

    CryptoPP::StringSource ss(ciphertext, true, 
        new CryptoPP::Base64Decoder(
        new CryptoPP::StringSink(src)
        )
        );

     std::cout &lt;&lt; src &lt;&lt; "" "";



    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( src.c_str() ), src.size() );
    stfDecryptor.MessageEnd();
}

void generateActivationKey(char *license_string_dect , char *activation_key){}

int main(int argc , char * argv[])
{
    char *license_string_dect , *activation_key;
    /*if(argc &lt; 2)
      error(""License Key Not Provided"");*/
    decrypt();
    std::cout&lt;&lt; license_string_dect;
    generateActivationKey(license_string_dect , activation_key);
    std::cout&lt;&lt; activation_key;
    return 0;
}
</code></pre>

<p>Now, the problem is , when ciphered text is passed as a string </p>

<pre><code>7ff8b3ea8a2b37a3d28669c9713a7b3fa2502580d5d232cee8a5733ef70ff48e9e8498a94c25ea7b04043a1fc23b1a1eb1eb2f6976270a181ca6e788090
</code></pre>

<p>I get the following error</p>

<pre><code> terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: ciphertext length is not a multiple of block size.
</code></pre>

<p>I googled for this but dint get an appropriate way to only decrypt a given ciphered text </p>

<p>plz help</p>

<p>I used this to get the FingerPrint:</p>

<pre><code>// Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-   
    //bit). This key is secretly exchanged between two parties before communication   
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[16]; 
    byte iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0xACD3 , CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );
    //
    // String and Sink setup
    //

    std::string plaintext = ""vcm7878air:14522569:a12bc"";
    std::string ciphertext;
    std::string decryptedtext;
    //
    // Dump Plain Text
    //
    //std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    //std::cout &lt;&lt; plaintext;
    //std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Create Cipher Text
    //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    std::cout &lt;&lt; ""Fingerprint is :"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        std::cout &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i]));
    }
</code></pre>
","","796","<c++><encryption><crypto++>","0","","0","2014-06-06 06:00:54","","16","0","3505704","","2014-05-26 14:54:17","2014-05-26 13:17:37",""
"32633527","Serializing a public key for sending over network","<p>I have some Client/Server application. It works correct. And I want to add the cryptography to it. I find Crypto++ library, and make some simple project using it: for DES encoding, and for RSA encoding. It contains two classes: <code>EncoderDes</code> and <code>EncoderRSA</code>:</p>

<pre><code>class EncoderDES
{
    public:
        EncoderDES();
        std::string encode(std::string plainText);
        std::string decode(std::string cypher);
        std::string toReadable(std::string cypher);
        void doIt();
    private:
        AutoSeededRandomPool prng;
        SecByteBlock key;
        byte iv[];
};

class EncoderRSA
{
    public:
        EncoderRSA();
        void keyGeneration();
        void substitutePublicKey(Integer e, Integer n);
        Integer encode(std::string plainText);
        std::string decode(Integer cypher);
    private:
        AutoSeededRandomPool prng;
        RSA::PublicKey publicKey;
        RSA::PrivateKey privateKey;
};
</code></pre>

<p>I think, Server must generate the DES key, and pass it to each client by RSA. And in this step I have some questions:
 1. How to send (and how to receive) RSA::PublicKey?
 2. How to send (and how to receive) SecByteBlock?</p>

<p>(I can't send them, because I can't:
 1. convert RSA::PublicKey to char*
 2. convert char* to RSA::PublicKey
 3. convert SecByteBlock to string.)</p>

<p>I can only convert string to SecByteBlock:</p>

<pre><code>SecByteBlock stringToKey(string decodedKey) {
    SecByteBlock receivedKey(decodedKey.data(), decodedKey.size());
    return receivedKey;
}
</code></pre>

<p>But don't sure that it's correct.</p>

<p>How to resolve this problems?</p>
","<blockquote>
  <p>I have some Client/Server application...</p>
</blockquote>

<p>Before you go too far down a rabbit hole, scrap most of the existing design.</p>

<p>To encrypt communications between the client and server, use an <a href=""https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">Integrated Encryption Scheme</a>. Crypto++ has two of them. The first is <a href=""http://www.cryptopp.com/wiki/Elliptic_curve_integrated_encryption_scheme"" rel=""nofollow noreferrer"">Elliptic Curve Integrated Encryption Scheme</a>, and it operates over the field of elliptic curves. The second is <a href=""http://www.cryptopp.com/wiki/Discrete_Logarithm_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer""> Discrete Logarithm Integrated Encryption Scheme</a>, and it operates over the field of integers.</p>

<p>Both schemes are state of the art, and they tie the ciphertext (and decryption) to the other's public key. The plain text is encrypted and the cipher text is MAC'd, so it provides <a href=""https://cryptopp.com/wiki/Authenticated_encryption"" rel=""nofollow noreferrer"">confidentiality and authenticity</a>. They also ensure you <em>don't</em> reuse a security context. Integrated Encryption Schemes are some of the most secure schemes you can use because they are <a href=""https://en.wikipedia.org/wiki/Ciphertext_indistinguishability"" rel=""nofollow noreferrer"">IND-CCA2</a> (its a very strong notion of security).</p>

<p>You still need to solve the <a href=""https://www.google.com/search?q=key+distribution+problem"" rel=""nofollow noreferrer"">key distribution problem</a> from your earlier question. But once you have a public key, the system mostly works. I can only say ""mostly"" because I don't know what you are doing to guard against insertions and replays at the network level.</p>

<hr>

<blockquote>
  <p>I can't send them, because I can't: 1. convert RSA::PublicKey to char* 2. convert char* to RSA::PublicKey 3. convert SecByteBlock to string.</p>
</blockquote>

<p>You should visit <a href=""http://www.cryptopp.com/wiki/Keys_and_formats"" rel=""nofollow noreferrer"">Keys and Formats</a> on the Crypto++ wiki. It shows you how to serialize them. Also see <a href=""https://stackoverflow.com/q/19808488"">Safe way to sending a public key over a socket</a> on Stack Overflow.</p>

<p>A quick nudge in the right direction: use <code>Save</code> and <code>Load</code>; and <em>don't</em> use <code>DEREncode</code> or <code>BERDecode</code>. <code>Save</code> and <code>Load</code> operate on the subject public key info, and it includes an algorithm identifier in addition to the key. That usually helps you later because the key type is part of the public key.</p>
","790","<c++><encryption><type-conversion><client-server><crypto++>","2","2","1","2015-09-20 01:37:30","32634563","1","","608639","","2015-09-17 21:05:12","2015-09-17 14:55:37",""
"22343259","cryptopp foreign library dependency","<p>I tried to install <code>happstack-server-tls</code> package via cabal on Arch Linux (3.12.9), but got this error:</p>

<pre><code>Resolving dependencies...
Configuring happstack-server-tls-7.1.0...
Failed to install happstack-server-tls-7.1.0
Last 10 lines of the build log ( /home/boris/.cabal/logs/happstack-server-tls-7.1.0.log ):
Configuring happstack-server-tls-7.1.0...
/bin/sh: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)
setup-Cabal-1.16.0-x86_64-linux-ghc-7.6.3: Missing dependency on a foreign
library:
* Missing C library: cryptopp
This problem can usually be solved by installing the system package that
provides this library (you may need the ""-dev"" version). If the library is
already installed but in a non-standard location then you can use the flags
--extra-include-dirs= and --extra-lib-dirs= to specify where it is.
cabal: Error: some packages failed to install:
happstack-server-tls-7.1.0 failed during the configure step. The exception
was:
ExitFailure 1
</code></pre>

<p>After seeing this error message for the first time, I have installed <code>crypto++</code> via pacman. But it didn't help me.</p>

<p>I even tried this:</p>

<pre><code>$ whereis libcryptopp.a                                                                                           
libcryptopp: /usr/lib/libcryptopp.so
$ cabal install happstack-server-tls --extra-include-dirs=/usr/lib/ --extra-lib-dirs=/usr/lib/
</code></pre>

<p>But still no luck.</p>

<p>I checked, if crypto++ lib works with this test.cpp file:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include ""cryptopp/integer.h""
using CryptoPP::Integer;

int main( int, char** ) {

    Integer i;

    cout &lt;&lt; ""i: "" &lt;&lt; i &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>And with <code>g++ -g3 -ggdb -O0 -Wall -Wextra -Wno-unused -o test test.cpp -lcryptopp -pthread</code> test.cpp compiled well. </p>

<p>Then I tried to</p>

<pre><code>$ cd /usr/lib
$ g++ -fpic -nostartfiles -nostdlib -shared libcryptopp.so -o libcryptopp.dylib
</code></pre>

<p>But again, still no luck. </p>

<p>Have someone faced this problem? Has it any solutions? </p>
","<p>run <code>cabal unpack happstack-server-tls</code> to fetch and unpack the source code in a local directory. Then edit the <code>happstack-server-tls.cabal</code> and try removing these lines:</p>

<pre><code>if !os(darwin)
    Extra-Libraries: cryptopp
</code></pre>
","784","<c++><cabal><archlinux><crypto++><happstack>","2","2","1","2014-03-13 14:25:40","22381646","0","","","","","2014-03-12 06:05:03",""
"23702414","QT console application with Crypto++ library","<p>This is driving me nuts. Using crypto++ ver 5.6.2. Qt 5.2.1 on Mac OSX.
All the projects are built inside QT Creator.  Im not using make from the command line</p>

<p>I build crypto++ by unpacking and building as follow:</p>

<ol>
<li>qmake -project </li>
<li>Deleted the GNUmakefile</li>
<li><p>Open in QT and modified the .pro file by adding</p>

<pre><code>macx {
    DEFINES += CRYPTOPP_DISABLE_ASM
}
</code></pre></li>
</ol>

<p>The target is cryptopp:</p>

<pre><code>TARGET = cryptopp
</code></pre>

<p>Set to release, ran qmake and did a rebuild all.  The dylibs get generated:</p>

<ul>
<li>libcryptopp.1.0.0.dylib</li>
<li>libcryptopp.1.0.dylib (Alias)</li>
<li>libcryptopp.1.dylib (Alias)</li>
<li>libcryptopp.dylib (Alias)</li>
</ul>

<p>Created a bare console application and included my crypto class.
Modified the .pro file as follow:</p>

<pre><code>macx {

    # CONFIG += release cryptopp
    LIBS += /Users/adviner/Qt5.2.1/5.2.1/clang_64/lib/libcryptopp.1.0.0.dylib

    QMAKE_POST_LINK += install_name_tool -change libcryptopp.1.0.0.dylib $$[QT_INSTALL_LIBS]/libcryptopp.1.0.0.dylib $(TARGET)
}
</code></pre>

<p>In the console test app in debug mode.  Ran qmake and then rebuild all.  I keep getting the following error:</p>

<pre><code>:-1: error: symbol(s) not found for architecture x86_64
:-1: error: linker command failed with exit code 1 (use -v to see invocation)
</code></pre>

<p>I've checked both the projects and they both include x86_64) in the qmake build steps:</p>

<pre><code>cryptopp lib:
qmake /Users/myname/Projects/QTLibs/Source/crypto/cryptopp562/cryptopp562.pro -r -spec macx-clang CONFIG+=x86_64
</code></pre>

<p>Test console app:</p>

<pre><code>qmake /Users/myname/Projects/Test/CryptoTest/CryptoTest.pro -r -spec macx-clang CONFIG+=debug CONFIG+=x86_64 CONFIG+=declarative_debug CONFIG+=qml_debug
</code></pre>

<p>Ive done some google search but nothing seems to answer my problem.  Any ideas?  I have built the same crypto++ lib on windows using Qt 5.2.1 and used in my app with no problems.</p>
","<p>OK i finally figured it out.  When I built the crypto++ lib on the Mac I added as described above:</p>

<pre><code>macx {
    DEFINES += CRYPTOPP_DISABLE_ASM
}
</code></pre>

<p>Well on the console application I had to also add this in the .pro file and it works now</p>

<p>I found the following tip also to modify</p>

<p>/Users/adviner/Qt5.2.1/5.2.1/clang_64/mkspecs/macx-clang/qmake.conf</p>

<p>From
    QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.6</p>

<p>To
    QMAKE_MACOSX_DEPLOYMENT_TARGET = 10.9</p>

<p>But it didnt do anything for me.  </p>

<p>Only solution was to put on both lib and test the CRYPTOPP_DISABLE_ASM</p>
","783","<c++><macos><qt><x86-64><crypto++>","1","2","1","2017-06-17 19:30:53","23706645","0","","608639","","2017-06-17 19:30:53","2014-05-16 18:35:49",""
"9869261","Load RSA PKCS#1 private key from memory?","<p>I have to write a program to establish a secure communication with a USB device. I have to use the private key generated from it which is stored in PKCS#1 format. As I have used Crypto++ in order part of my program, I would like to utilize it for this purpose as well.</p>

<p>However, I cannot find a way to import RSA private key from memory. It accepts private key in PKCS#8 format only. Could some pro show me a sample code on how to do it? Many thanks!</p>
","<p>PKCS#1 format is ASN.1 encoded. For <code>RSAPublicKey</code> and <code>RSAPrivateKey</code>, its as easy as:</p>

<pre><code>RSA::PublicKey publicKey(...);

ByteQueue queue;
publicKey.Save(queue);

// The public key is now in the ByteQueue in PKCS #1 format

// ------------

// Load a PKCS #1 private key
byte key[] = {...}
ArraySource arr(key, sizeof(key));

RSA::PrivateKey privateKey;
privateKey.Load(arr);

// The private key is now ready to use
</code></pre>

<p>Saving and loading keys is discussed in more detail at the Crypto++ wiki under <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow"">Keys and Formats</a>.</p>
","780","<crypto++>","2","2","1","2015-02-18 00:07:46","19153150","0","","608639","","2015-02-18 00:04:19","2012-03-26 09:01:45",""
"26963303","Unable to make on MingW due to unrecognized option","<p>I have no clue why it doesn't work.. Normally this is supposed to be the easy part, I'm trying to get this fucked up thing to work for days and it still doesn't do anything. Please Help me because I'm very close to throwing this computer through the window.</p>

<pre><code>&gt; C:\...\Downloads\crypto50&gt;mingw32-make -f 

&gt; GNUmakefile process_begin:
&gt; CreateProcess(NULL, uname, ...) failed. process_begin:
&gt; CreateProcess(NULL, uname, ...) failed. process_begin:
&gt; CreateProcess(NULL, uname, ...) failed. g++ -g -mbnu210 -c md5.cpp
&gt; g++: error: unrecognized command line option '-mbnu210'
&gt; GNUmakefile:58: recipe for target 'md5.o' failed mingw32-make: ***
&gt; [md5.o] Error 1
</code></pre>

<p>And when I try to follow this guys tutorial <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">https://sites.google.com/site/ievgensychov/cryptopp</a> this is what happens:</p>

<pre><code>&gt; g++ -DNDEBUG -g -O2 -c shacal2.cpp g++ -DNDEBUG -g -O2 -c seed.cpp g++
&gt; -DNDEBUG -g -O2 -c shark.cpp In file included from shark.h:9:0,
&gt;                  from shark.cpp:4: secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::p ointer
&gt; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = unsigned char; boo l
&gt; T_Align16 = false; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::pointer = uns igned char*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::size_type = unsigned
&gt; int]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = unsigned
&gt; char; A = CryptoPP::AllocatorWith Cleanup&lt;unsigned char&gt;;
&gt; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int]' algparam.h:17:2: 
&gt; required from here secblock.h:91:14: error: 'CheckSize' was not
&gt; declared in this scope, and no decl arations were found by
&gt; argument-dependent lookup at the point of instantiation [
&gt; -fpermissive]    CheckSize(n);
&gt;               ^ secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; unsigned char&gt;' are not found by unqualified
&gt; lookup secblock.h:91:14: note: use 'this-&gt;CheckSize' instead
&gt; secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::p ointer CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = unsigned char; boo l
&gt; T_Align16 = true; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::pointer = unsi gned char*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::size_type = unsigned i
&gt; nt]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = unsigned
&gt; char; A = CryptoPP::AllocatorWith Cleanup&lt;unsigned char, true&gt;;
&gt; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int ]' modes.h:63:34:  
&gt; required from here secblock.h:91:14: error: 'CheckSize' was not
&gt; declared in this scope, and no decl arations were found by
&gt; argument-dependent lookup at the point of instantiation [
&gt; -fpermissive] secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; unsigned char&gt;' are not found by unqualified
&gt; lookup secblock.h:91:14: note: use 'this-&gt;CheckSize' instead
&gt; secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::p ointer CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = long long unsigned  int;
&gt; bool T_Align16 = false; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::poin ter = long long unsigned int*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::siz e_type = unsigned
&gt; int]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = long long
&gt; unsigned int; A = CryptoPP::Allo catorWithCleanup&lt;long long unsigned
&gt; int&gt;; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int]'
&gt; shark.h:22:27:   required from 'CryptoPP::BlockCipherFinal&lt;DIR,
&gt; BASE&gt;::BlockCiph erFinal() [with CryptoPP::CipherDir DIR =
&gt; (CryptoPP::CipherDir)0u; BASE = Crypto PP::SHARK::Enc]'
&gt; shark.cpp:43:20:   required from here secblock.h:91:14: error:
&gt; 'CheckSize' was not declared in this scope, and no decl arations were
&gt; found by argument-dependent lookup at the point of instantiation [
&gt; -fpermissive] secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; long long unsigned int&gt;' are not found by
&gt; unqualified lookup secblock.h:91:14: note: use 'this-&gt;CheckSize'
&gt; instead GNUmakefile:73: recipe for target 'shark.o' failed
&gt; mingw32-make: *** [shark.o] Error 1
&gt; 
&gt; c:\cryptopp&gt;mingw32-make test g++ -DNDEBUG -g -O2 -c shark.cpp In file
&gt; included from shark.h:9:0,
&gt;                  from shark.cpp:4: secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::p ointer
&gt; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = unsigned char; boo l
&gt; T_Align16 = false; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::pointer = uns igned char*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::size_type = unsigned
&gt; int]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = unsigned
&gt; char; A = CryptoPP::AllocatorWith Cleanup&lt;unsigned char&gt;;
&gt; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int]' algparam.h:17:2: 
&gt; required from here secblock.h:91:14: error: 'CheckSize' was not
&gt; declared in this scope, and no decl arations were found by
&gt; argument-dependent lookup at the point of instantiation [
&gt; -fpermissive]    CheckSize(n);
&gt;               ^ secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; unsigned char&gt;' are not found by unqualified
&gt; lookup secblock.h:91:14: note: use 'this-&gt;CheckSize' instead
&gt; secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::p ointer CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = unsigned char; boo l
&gt; T_Align16 = true; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::pointer = unsi gned char*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::size_type = unsigned i
&gt; nt]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = unsigned
&gt; char; A = CryptoPP::AllocatorWith Cleanup&lt;unsigned char, true&gt;;
&gt; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int ]' modes.h:63:34:  
&gt; required from here secblock.h:91:14: error: 'CheckSize' was not
&gt; declared in this scope, and no decl arations were found by
&gt; argument-dependent lookup at the point of instantiation [
&gt; -fpermissive] secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; unsigned char&gt;' are not found by unqualified
&gt; lookup secblock.h:91:14: note: use 'this-&gt;CheckSize' instead
&gt; secblock.h: In instantiation of 'CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::p ointer CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = long long unsigned  int;
&gt; bool T_Align16 = false; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::poin ter = long long unsigned int*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::siz e_type = unsigned
&gt; int]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = long long
&gt; unsigned int; A = CryptoPP::Allo catorWithCleanup&lt;long long unsigned
&gt; int&gt;; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int]'
&gt; shark.h:22:27:   required from 'CryptoPP::BlockCipherFinal&lt;DIR,
&gt; BASE&gt;::BlockCiph erFinal() [with CryptoPP::CipherDir DIR =
&gt; (CryptoPP::CipherDir)0u; BASE = Crypto PP::SHARK::Enc]'
&gt; shark.cpp:43:20:   required from here secblock.h:91:14: error:
&gt; 'CheckSize' was not declared in this scope, and no decl arations were
&gt; found by argument-dependent lookup at the point of instantiation [
&gt; -fpermissive] secblock.h:91:14: note: declarations in dependent base 'CryptoPP::AllocatorBase&lt; long long unsigned int&gt;' are not found by
&gt; unqualified lookup secblock.h:91:14: note: use 'this-&gt;CheckSize'
&gt; instead GNUmakefile:73: recipe for target 'shark.o' failed
&gt; mingw32-make: *** [shark.o] Error 1
&gt; 
&gt; c:\cryptopp&gt;mkdir include\cryptopp
&gt; 
&gt; c:\cryptopp&gt;mkdir lib
&gt; 
&gt; c:\cryptopp&gt;copy *.h include\cryptopp 3way.h adler32.h aes.h algebra.h
&gt; algparam.h arc4.h argnames.h asn.h authenc.h base32.h base64.h
&gt; basecode.h bench.h blowfish.h blumshub.h camellia.h cast.h cbcmac.h
&gt; ccm.h channels.h cmac.h config.h cpu.h crc.h cryptlib.h default.h
&gt; des.h dh.h dh2.h dll.h dmac.h dsa.h eax.h ec2n.h eccrypto.h ecp.h
&gt; elgamal.h emsa2.h eprecomp.h esign.h factory.h files.h filters.h
&gt; fips140.h fltrimpl.h gcm.h gf256.h gf2n.h gf2_32.h gfpcrypt.h gost.h
&gt; gzip.h hex.h hmac.h hrtimer.h ida.h idea.h integer.h iterhash.h
&gt; lubyrack.h luc.h mars.h md2.h md4.h md5.h mdc.h misc.h modarith.h
&gt; modes.h modexppc.h mqueue.h mqv.h nbtheory.h network.h nr.h oaep.h
&gt; oids.h osrng.h panama.h pch.h pkcspad.h polynomi.h pssr.h pubkey.h
&gt; pwdbased.h queue.h rabin.h randpool.h rc2.h rc5.h rc6.h resource.h
&gt; rijndael.h ripemd.h rng.h rsa.h rw.h safer.h salsa.h seal.h secblock.h
&gt; seckey.h seed.h serpent.h serpentp.h sha.h shacal2.h shark.h simple.h
&gt; skipjack.h smartptr.h socketft.h sosemanuk.h square.h stdcpp.h
&gt; strciphr.h tea.h tiger.h trdlocal.h trunhash.h ttmac.h twofish.h
&gt; validate.h vmac.h wait.h wake.h whrlpool.h winpipes.h words.h xtr.h
&gt; xtrcrypt.h zdeflate.h zinflate.h zlib.h
&gt;       134 file(s) copied.
&gt; 
&gt; c:\cryptopp&gt;copy *.a lib
&gt; *.a Het systeem kan het opgegeven bestand niet vinden.
&gt;         0 file(s) copied.
</code></pre>
","<blockquote>
  <p>I'm trying to get this fucked up thing to work for days and it still doesn't do anything...</p>
</blockquote>

<p>It looks like you have two problems.</p>

<hr>

<blockquote>
  <p>g++: error: unrecognized command line option '-mbnu210'</p>
</blockquote>

<p>This is from line 72 of <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/GNUmakefile"" rel=""nofollow"">GNUMakefile</a>:</p>

<pre><code>ifeq ($(UNAME),) # for DJGPP, where uname doesn't exist
CXXFLAGS += -mbnu210
else
CXXFLAGS += -pipe
endif
</code></pre>

<p>It sounds like your MinGW is not set up properly. More specifically, either (1) <code>mingw-developer-tools</code> is not installed (via <code>mingw-get</code>), or (2) your paths are not quite right and lack the <code>C:\MinGW\msys\1.0\bin</code> path (that's where <code>uname</code> lives).</p>

<p>You might try something like the following before the DJGPP test. Open the <code>GNUMakefile</code>, and add the test and assignment.</p>

<pre><code>ifeq ($(IS_MINGW),1)
UNAME=mingw
endif
</code></pre>

<p>I would add it at around line 28, before the test for X86 (i.e., line 29 that starts with <code>ifeq ($(ISX86),1)</code>). You could also add it at around line 71 after the X86 block but before the DJGPP test.</p>

<p>One other thing to keep in mind: <code>IS_MINGW</code> is set on line 17 with the following:</p>

<pre><code>IS_MINGW = $(shell $(CXX) -dumpmachine 2&gt;&amp;1 | $(EGREP) -c ""mingw"")
</code></pre>

<p><em>If</em> <code>IS_MINGW</code> is <em>not</em> set correctly, then you might want to set it to 1 unconditionally.</p>

<hr>

<pre><code>&gt; g++ -DNDEBUG -g -O2 -c shacal2.cpp g++ -DNDEBUG -g -O2 -c seed.cpp g++
&gt; -DNDEBUG -g -O2 -c shark.cpp In file included from shark.h:9:0,
&gt;                  from shark.cpp:4: secblock.h: In instantiation of 
&gt; 'CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::p ointer
&gt; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::allocate(CryptoPP::Allocato rWithCleanup&lt;T,
&gt; T_Align16&gt;::size_type, const void*) [with T = unsigned char; boo l
&gt; T_Align16 = false; CryptoPP::AllocatorWithCleanup&lt;T,
&gt; T_Align16&gt;::pointer = uns igned char*;
&gt; CryptoPP::AllocatorWithCleanup&lt;T, T_Align16&gt;::size_type = unsigned
&gt; int]': secblock.h:247:25:   required from 'CryptoPP::SecBlock&lt;T,
&gt; A&gt;::SecBlock(CryptoPP: :SecBlock&lt;T, A&gt;::size_type) [with T = unsigned
&gt; char; A = CryptoPP::AllocatorWith Cleanup&lt;unsigned char&gt;;
&gt; CryptoPP::SecBlock&lt;T, A&gt;::size_type = unsigned int]' algparam.h:17:2: 
&gt; required from here secblock.h:91:14: error: 'CheckSize' was not
&gt; declared in this scope, and no decl arations were found by
&gt; argument-dependent lookup at the point of instantiation [
&gt; -fpermissive]    CheckSize(n);
&gt;               ^ secblock.h:91:14: note: declarations in dependent base 
&gt; 'CryptoPP::AllocatorBase&lt; unsigned char&gt;' are not found by unqualified
&gt; lookup secblock.h:91:14: note: use 'this-&gt;CheckSize' instead
</code></pre>

<p>Stop using Crypto++ 5.0, and use the latest version of Crypto++ (either <a href=""http://www.cryptopp.com/#download"" rel=""nofollow"">5.6.2 from the website</a>, or checkout the latest Crypto++ from <a href=""http://www.cryptopp.com/wiki/Svn"" rel=""nofollow"">SVN</a>).</p>

<p>The problem is argument dependent name lookups. The problem was fixed at <a href=""http://sourceforge.net/p/cryptopp/code/522/"" rel=""nofollow"">revision 522</a> and <a href=""http://sourceforge.net/p/cryptopp/code/539/"" rel=""nofollow"">revision 539</a>. The problem did not show its head until recently (relatively speaking), with later versions of GCC (circa GCC 4.7 or so).</p>

<p>If you check the latest <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/secblock.h"" rel=""nofollow"">secblock.h</a> on Sourceforge, then you will see the this particular issue was already fixed by changing the statement to <code>this-&gt;CheckSize()</code> as suggested by GCC.</p>

<p>If you have some straglers that were not fixed, then add <code>this-&gt;</code> to the problem statement. For example, in the compile problem above, you would open <code>secblock.h</code>, scroll down to line 91, and then change the statement to <code>this-&gt;CheckSize()</code>.</p>
","778","<compiler-errors><mingw><gnu-make><crypto++>","1","0","1","2014-11-19 05:39:53","","1","","608639","","2014-11-17 03:25:33","2014-11-16 23:26:07",""
"47791590","Encrypting and Decrypting a byte array/vector using the CryptoPP library","<p>I am trying to encrypt a byte array that has been parsed to a string. This seems to work for all cases, except for the case that the byte array contains 0x00.</p>

<pre><code>int main()
{
    byte cipherTextWithZeroByte[32] = {
        0xD3, 0xFA, 0xD6, 0xEC, 0x84, 0x4E, 0xD3, 0xD8,
        0x2B, 0x76, 0x6C, 0xE8, 0x02, 0xF2, 0xB2, 0x6F,
        0x00, 0xE8, 0x99, 0x8C, 0xEC, 0x4B, 0x3C, 0x7D,         
        0xAC, 0xDE, 0x86, 0x02, 0x51, 0xAB, 0x3F, 0x04
    };

    string cipherText((char *)cipherTextWithZeroByte);
    string plainText = decrypt(cipherText, sizeof(cipherTextWithZeroByte));

    return 1;
}

string decrypt(string cipherText, int size)
{
    string decryptedText;

    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, 
              new CryptoPP::HexEncoder(
                           new CryptoPP::StringSink(decryptedText)));

    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(cipherText.c_str()), size);
    stfDecryptor.MessageEnd();

    return decryptedText;
}
</code></pre>

<p>In this case, the byte array contains 0x00. This causes the cipherText to be cut short leading to an invalid length. An exception is thrown stating: '<em>StreamTransformationFilter: invalid PKCS #7 block padding found</em>'</p>

<p>So I thought it would be better to use an <strong>ArraySource</strong> and <strong>ArraySink</strong> to be sure that a string is not zero terminated.</p>

<pre><code>int main()
{
    byte cipherTextWithZeroByte[32] = {
        0xD3, 0xFA, 0xD6, 0xEC, 0x84, 0x4E, 0xD3, 0xD8,
        0x2B, 0x76, 0x6C, 0xE8, 0x02, 0xF2, 0xB2, 0x6F,
        0x00, 0xE8, 0x99, 0x8C, 0xEC, 0x4B, 0x3C, 0x7D,         
        0xAC, 0xDE, 0x86, 0x02, 0x51, 0xAB, 0x3F, 0x04
    };

    vector&lt;byte&gt; cipherTextData(cipherTextWithZeroByte, cipherTextWithZeroByte + sizeof(cipherTextWithZeroByte) / sizeof(cipherTextWithZeroByte[0]));
    vector&lt;byte&gt; plainTextData = decrypt(cipherTextData);

    return 1;
}

vector&lt;byte&gt; decrypt(vector&lt;byte&gt; cipherText)
{
    vector&lt;byte&gt; plainText;
    plainText.resize(cipherText.size());

    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));


    CryptoPP::ArraySource ss(&amp;cipherText[0], cipherText.size(), true,
              new CryptoPP::HexEncoder(
                  new CryptoPP::StreamTransformationFilter(decryptor,
                      new CryptoPP::ArraySink(plainText.data(), plainText.size()))));

    return plainText;
}
</code></pre>

<p>In this case, an exception is thrown that the ciphertext is not a multiple of the key length, which clearly is not the case here. (Key = 16 bytes, Ciphertext = 16 bytes). I think that the library casts the byte array to a string leaving out all the data after the 0x00 byte.</p>

<p>What am I doing wrong?</p>
","<p>Encryption is a binary byte not a character operation. As such the encrypted output can not be cast to a string. If you need a string output encode the encrypted data to a string compatible format common formats are Base64 and hexadecimal.</p>

<p>In particular a null byte in a character string by convention in ""C"" like signals languages the end of the string.</p>

<p>That is on encryption encode the binary data to a string format and on decryption first decode the string representation to binary data by using the inverse of the encoding operation. </p>
","762","<c++><encryption><aes><crypto++>","0","1","1","2017-12-13 14:11:27","","3","","","","","2017-12-13 11:10:12",""
"11589036","How can I use crypto++ without read/write a key file?","<p>I'm using Crypto++ RSA api to encrypt and decrypt something, RSAES_OAEP_SHA_Encryptor and RSAES_OAEP_SHA_Decryptor both need a file which stores the pub/pri key。</p>

<p>:( , but I need to store the keys in my C++ code variables, any way to avoid accessing a file?</p>

<p>Or is there any better lib than Crypto++?</p>
","<p>A cursory glance at the user guide and API docs suggests you should be able to replace the FileSource with a <a href=""http://www.cryptopp.com/docs/ref/class_string_source.html#a86185516e7339e3a6192be9b88493a00"" rel=""nofollow"">StringSource</a>.</p>
","751","<c++><rsa><crypto++>","2","1","2","2013-10-04 08:17:34","","1","","","","","2012-07-21 02:36:45",""
"11589036","How can I use crypto++ without read/write a key file?","<p>I'm using Crypto++ RSA api to encrypt and decrypt something, RSAES_OAEP_SHA_Encryptor and RSAES_OAEP_SHA_Decryptor both need a file which stores the pub/pri key。</p>

<p>:( , but I need to store the keys in my C++ code variables, any way to avoid accessing a file?</p>

<p>Or is there any better lib than Crypto++?</p>
","<p>The Crpyto++ <a href=""http://www.cryptopp.com/wiki/Keys_and_formats"" rel=""nofollow"">Keys and Formats</a> wiki page covers this in depth. You can use <code>DEREncodePrivateKey</code>, <code>DEREncodePublicKey</code>, <code>BERDecodePrivateKey</code>, and <code>BERDecodePublicKey</code>. Here's the brief tour with two examples.</p>

<p>The first saves the key to a file using DER encoding.</p>

<pre><code>ByteQueue q1;
publicKey.DEREncodePublicKey(q1);

FileSink fs1(""key_1.der"", true);
q1.TransferTo(fs1);
</code></pre>

<p>The second saves the key to a string using DER encoding.</p>

<pre><code>ByteQueue q2;
publicKey.DEREncodePublicKey(q2);

string key_2;
StringSink ss2(key_2);
q2.TransferTo(ss2);
</code></pre>

<p>You can use <code>BERDecodePublicKey</code> to recover the saved keys.</p>

<p>When using private keys, use <code>DEREncodePrivateKey</code> and <code>BERDecodePrivateKey</code>.</p>
","751","<c++><rsa><crypto++>","2","0","2","2013-10-04 08:17:34","","1","","","","","2012-07-21 02:36:45",""
"21024399","Get ECDSA signature with Crypto++","<p>I have to get ECDSA signature in variable using Crypto++.<br>
I tried to get it after launching SignMessage but signature is empty.<br>
How could i get it?  </p>
","<p>Have you had a look at the Crypto++ wiki? There's a lot of stuff on <a href=""http://www.cryptopp.com/wiki/Ecdsa"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a>.</p>

<p>Its not really clear what you are doing or where things went wrong, so here's a copy and paste from the wiki:</p>

<p>Signing:</p>

<pre><code>ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
privateKey.Load(...);

AutoSeededRandomPool prng;
string message = ""Yoda said, Do or do not. There is no try."";
string signature;

StringSource ss1( message, true /*pump all*/,
    new SignerFilter( prng,
        ECDSA&lt;ECP,SHA1&gt;::Signer( privateKey ),
        new StringSink( signature )
    ) // SignerFilter
); // StringSource
</code></pre>

<p>Verification:</p>

<pre><code>ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey;
publicKey.Load(...);

// Result of the verification process
bool result = false;

// Exactly what was signed in the previous step
string message = ...;
// Output from the signing operation in the previous step
string signature = ...;

StringSource ss2( signature+message, true /*pump all*/,
    new SignatureVerificationFilter(
        ECDSA&lt;ECP,SHA1&gt;::Verifier(publicKey),
        new ArraySink( (byte*)&amp;result, sizeof(result) )
    ) // SignatureVerificationFilter
);

// Verification failure?
if( !result ) {...}
</code></pre>

<p>If you would like the verifcation to throw on a failure, then try:</p>

<pre><code>static const int VERIFICATION_FLAGS = SIGNATURE_AT_BEGIN | THROW_EXCEPTION;
StringSource ss3( signature+message, true /*pump all*/,
    new SignatureVerificationFilter(
        ECDSA&lt;ECP,SHA1&gt;::Verifier(publicKey),
        NULL, /* No need for attached filter */
        VERIFICATION_FLAGS
    ) // SignatureVerificationFilter
);
</code></pre>
","742","<c++><crypto++><ecdsa>","0","0","1","2018-10-25 04:42:50","","0","","2509078","","2018-10-25 04:42:50","2014-01-09 15:31:12",""
"8158128","Crypto++ convert Adler32 digest (byte array) to uint32_t","<p>I have the following problem: I'm trying to calculate the adler32 checksum of a data block using <code>Crypto++</code>,  but I get the wrong checksum after converting the byte[4] array output to a uint32_t.</p>

<p>This function with crc32 works just fine:</p>

<pre><code>CryptoPP::CRC32 crc;
byte digest[CryptoPP::CRC32::DIGESTSIZE];
crc.CalculateDigest(digest, (const byte*)pData.data(), pData.size());
uint32_t checksum = *(uint32_t*)digest; //this works fine
</code></pre>

<p>but the function calculating the adler32 returns a invalid value:</p>

<pre><code>CryptoPP::Adler32 adler;
byte digest[CryptoPP::Adler32::DIGESTSIZE];
adler.CalculateDigest(digest, (const byte*)pData.data(), pData.size());
uint32_t checksum = *(uint32_t*)digest; //this returns a invalid value
</code></pre>

<p>hope someone could give me a hint.</p>

<p>greetz Fabian</p>
","<p>The problem is that this code doesn't do what you want:</p>

<pre><code>uint32_t checksum = *(uint32_t*)digest; //this returns a invalid value
</code></pre>

<p>This code says to read the digest as if it held a 32-bit integer in the form this CPU natively stores 32-bit integers. But it doesn't contain that. It contains an array of 4-bytes that represent the hash, but not as an x86-CPU style integer.</p>

<p>Try this:</p>

<pre><code>uint32_t checksum = ntohl(*(uint32_t*)digest);
</code></pre>

<p>This says to read the raw bytes into an integer, and then convert them to X86 host format.</p>
","738","<crypto++><adler32><uint32-t>","1","0","2","2011-11-17 16:38:24","","0","","856306","","2011-11-17 15:28:14","2011-11-16 20:20:53",""
"8158128","Crypto++ convert Adler32 digest (byte array) to uint32_t","<p>I have the following problem: I'm trying to calculate the adler32 checksum of a data block using <code>Crypto++</code>,  but I get the wrong checksum after converting the byte[4] array output to a uint32_t.</p>

<p>This function with crc32 works just fine:</p>

<pre><code>CryptoPP::CRC32 crc;
byte digest[CryptoPP::CRC32::DIGESTSIZE];
crc.CalculateDigest(digest, (const byte*)pData.data(), pData.size());
uint32_t checksum = *(uint32_t*)digest; //this works fine
</code></pre>

<p>but the function calculating the adler32 returns a invalid value:</p>

<pre><code>CryptoPP::Adler32 adler;
byte digest[CryptoPP::Adler32::DIGESTSIZE];
adler.CalculateDigest(digest, (const byte*)pData.data(), pData.size());
uint32_t checksum = *(uint32_t*)digest; //this returns a invalid value
</code></pre>

<p>hope someone could give me a hint.</p>

<p>greetz Fabian</p>
","<p>well i found out that crypto++'s adler32 implementation initializes s1 = 1; s2 = 0 in the adler32.h <a href=""http://www.cryptopp.com/docs/ref/adler32_8h_source.html"" rel=""nofollow"">http://www.cryptopp.com/docs/ref/adler32_8h_source.html</a> but it should be s1 = 0 and s2 = 0. now all my checksums are correct but i still dont get why cryto++'s implementation is ""wrong"". greetz Fabian</p>
","738","<crypto++><adler32><uint32-t>","1","0","2","2011-11-17 16:38:24","","0","","856306","","2011-11-17 15:28:14","2011-11-16 20:20:53",""
"34303850","Cross-compilation for ARM-embedded","<p>I am trying to install Crypto++ for cross-compilation on a beaglebone black and I am using Ubuntu for compilation. I am quite a newbie in this please help me out.</p>

<p>I did:</p>

<pre><code>. ./setenv-embedded.sh
</code></pre>

<p>And everything seems fine. Then I tried to the the make command:</p>

<pre><code>make -f GNUmakefile-cross static static dynamic cryptest.exe
</code></pre>

<p>But I did not get the same output as shown at <a href=""https://www.cryptopp.com/wiki/ARM_Embedded_%28Command_Line%29"" rel=""nofollow noreferrer"">ARM Embedded (Command Line)</a>.</p>

<p>And then trying to test it.</p>

<pre><code>/usr/bin/arm-linux-gnueabi-readelf -h ./cryptest.exe | grep -i 'class\|machine' 
Class:       Elf32
Machine:     Intel 80386
</code></pre>

<p>The machine is still Intel not ARM:</p>

<p><a href=""https://i.stack.imgur.com/ViLpp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ViLpp.png"" alt=""enter image description here""></a></p>

<p>Can you help me with this one?</p>

<p>Thank you very much</p>
","<p>If you notice, you get a message ""nothing needs to be done for 'static'"" (and friends).</p>

<p>You need to perform a <code>make clean</code> or <code>make distclean</code> to remove the previous i686/x86_64 build.</p>

<p>You should also ensure you are using the latest <code>GNUmakefile-cross</code> and the latest <code>setenv-embedded.sh</code>. <em>If</em> you are using Crypto++ 5.6.3 or above, then its already in Git and you only need to <code>git pull</code>. <em>If</em> you are using Crypto++ 5.6.2 and earlier, then you can download them from <a href=""http://www.cryptopp.com/wiki/ARM_Embedded_%28Command_Line%29"" rel=""nofollow"">ARM Embedded (Command Line)</a>.</p>

<hr>

<p>Here's what it looks like for me on Ubuntu 14.04.</p>

<pre><code>$ . ./setenv-embedded.sh 
CPP: /usr/bin/arm-linux-gnueabi-cpp
CXX: /usr/bin/arm-linux-gnueabi-g++
AR: /usr/bin/arm-linux-gnueabi-ar
LD: /usr/bin/arm-linux-gnueabi-ld
RANLIB: /usr/bin/arm-linux-gnueabi-gcc-ranlib-4.7
ARM_EMBEDDED_TOOLCHAIN: /usr/bin
ARM_EMBEDDED_CXX_HEADERS: /usr/arm-linux-gnueabi/include/c++/4.7.3
ARM_EMBEDDED_FLAGS: -I/usr/arm-linux-gnueabi/include/c++/4.7.3 -I/usr/arm-linux-gnueabi/include/c++/4.7.3/arm-linux-gnueabi
ARM_EMBEDDED_SYSROOT: /usr/arm-linux-gnueabi

$ make -f GNUmakefile-cross 
/usr/bin/arm-linux-gnueabi-g++ -DNDEBUG -g2 -Os -fPIC -pipe
  -I/usr/arm-linux-gnueabi/include/c++/4.7.3
  -I/usr/arm-linux-gnueabi/include/c++/4.7.3/arm-linux-gnueabi
  --sysroot=/usr/arm-linux-gnueabi -c cryptlib.cpp
  ...
</code></pre>

<p>And then:</p>

<pre><code>$ /usr/bin/arm-linux-gnueabi-readelf -h ./libcryptopp.a | grep -i 'class\|machine' | head -2
  Class:                             ELF32
  Machine:                           ARM
</code></pre>

<hr>

<blockquote>
  <p>But I did not get the same output as shown at ARM Embedded (Command Line).</p>
</blockquote>

<p>I can't dump things for <code>libcryptopp.so</code> or <code>cryptest.exe</code> because it appears Ubuntu tool chain took a regression. The linker can no longer link an executable.</p>

<hr>

<p>Ubuntu's cross-compiler is kind of borked. We filed a few bug reports against in when writing the examples on the wiki. Its the reason we provide an example of using ARM's cross-compiler at <a href=""http://www.cryptopp.com/wiki/ARM_Embedded_%28Bare_Metal%29"" rel=""nofollow"">ARM Embedded (Bare Metal)</a>.</p>
","732","<ubuntu><arm><embedded><crypto++>","0","2","1","2016-06-14 00:49:41","","4","","608639","","2016-06-14 00:44:20","2015-12-16 04:17:58",""
"36028294","Adding Cryptopp to Android.mk","<p>I have tried building cryptopp library for android.I have used this part of the tutorial. 
<a href=""https://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">https://www.cryptopp.com/wiki/Android_(Command_Line)</a></p>

<pre><code>$ cat build-all-android.sh 
#!/bin/bash

for arch in armeabi armeabi-v7a armeabi-v7a-hard arm64-v8a mips mips64 x86 x86_64
do
    . ./setenv-android.sh $arch stlport
    if [ ""$?"" -eq ""0"" ]; then
        make -f GNUmakefile-cross distclean
        make -f GNUmakefile-cross static dynamic
        sudo make -f GNUmakefile-cross install PREFIX=/usr/local/cryptopp/android-$arch
    fi
done
</code></pre>

<p>I was able to make the libraries.
My problem is, I can't add it to my project. 
It seems like I need to edit my Android.mk file but I can't seem to do it properly. I added this block to my Anroid.mk</p>

<pre><code>#########################################################
# STLport library
include $(CLEAR_VARS)

STLPORT_INCL     := /Applications/Cocos/Android/android-ndk-r10e/sources/cxx-stl/stlport
STLPORT_LIB      := /Applications/Cocos/Android/android-ndk-r10e/sources/cxx-stl/stlport/libs/$(TARGET_ARCH_ABI)

LOCAL_MODULE := stlport_shared
LOCAL_SRC_FILES := $(STLPORT_LIB)/libstlport_shared.so
LOCAL_CPP_FEATURES += rtti exceptions

LOCAL_EXPORT_CPPFLAGS :=
LOCAL_EXPORT_C_INCLUDES := $(STLPORT_INCL)

include $(PREBUILT_SHARED_LIBRARY)

LOCAL_SHARED_LIBRARIES  := stlport_shared

#########################################################
# Crypto++ library
include $(CLEAR_VARS)

CRYPTOPP_INCL   := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/include
CRYPTOPP_LIB    := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/lib

LOCAL_MODULE       := cryptopp
LOCAL_SRC_FILES    := $(CRYPTOPP_LIB)/libcryptopp.so
LOCAL_CPP_FEATURES := rtti exceptions

LOCAL_EXPORT_C_INCLUDES := $(CRYPTOPP_INCL) $(CRYPTOPP_INCL)/cryptopp

include $(PREBUILT_SHARED_LIBRARY)

LOCAL_SHARED_LIBRARIES  := cryptopp

#########################################################
</code></pre>

<p>I based this on the Crypto++ wiki page <a href=""https://www.cryptopp.com/wiki/Android_Activity"" rel=""nofollow"">Android Activity</a> which referenced <a href=""https://github.com/noloader/Android-PRNG"" rel=""nofollow"">AndroidPRNG</a>, which demonstrates using Crypto++ as a shared object on Android.</p>

<p>I'm stuck because I can't make it work. I'm very new to android so I don't exactly know what to do about it. I was able to make the ios version of it run. I followed the XCode tutorial. It's just this that's making me crazy. I would appreciate all the help I can get. Is there something wrong with how I build? After building, do I copy it to my project or just linking the installed verion is fine? How do I properly add/link it to my project? Sorry for asking so many questions. </p>

<p>PS: I'm using cocos2dx for my project. Maybe it's worth mentioning.</p>
","<p>After reading and trying all sorts of combination for my Android.mk, I was able to compile cryptopp with cocos2dx.</p>

<p>Anyway, here's how i fixed the compiler error:</p>

<p>FIRST - Build the libraries</p>

<pre><code>cat build-all-android.sh 
#!/bin/bash

for arch in armeabi armeabi-v7a armeabi-v7a-hard arm64-v8a mips mips64 x86 x86_64
do
    AOSP_PI=""android-16"" . ./setenv-android.sh $arch gnu-static
    if [ ""$?"" -eq ""0"" ]; then
        make -f GNUmakefile-cross distclean
        make -f GNUmakefile-cross static dynamic
        sudo make -f GNUmakefile-cross install PREFIX=/usr/local/cryptopp/android-$arch
    fi
done
</code></pre>

<p>Notice that I used gnu-static -> this is because cocos2dx is using gnu-static.</p>

<p><br></p>

<p>SECOND - Update Android.mk</p>

<pre><code># Crypto++ library
include $(CLEAR_VARS)

CRYPTOPP_INCL   := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/include
CRYPTOPP_LIB    := /usr/local/cryptopp/android-$(TARGET_ARCH_ABI)/lib
LOCAL_MODULE       := cryptopp
LOCAL_SRC_FILES    := $(CRYPTOPP_LIB)/libcryptopp.a
LOCAL_CPP_FEATURES := rtti exceptions
LOCAL_EXPORT_C_INCLUDES := $(CRYPTOPP_INCL) $(CRYPTOPP_INCL)/cryptopp
include $(PREBUILT_STATIC_LIBRARY)
LOCAL_SHARED_LIBRARIES  := cryptopp
</code></pre>

<p><br><br>---------------------------------------- FOR WINDOWS ----------------------------------------<br><br>
The answer above only works for mac. In Windows, I tried installing the cryptopp libraries but I wasn't successful. AOSP_TOOLCHAIN_PATH was invalid. I tried fixing it by updating the setenv-android.sh to include ""windows-x86_64"". I was able to fix that part but sadly I had a ""make:not a command"" error. I was told that I had to download it for my cygwin. </p>

<p>I'm currently downloading it. I will udpate this answer when I'm able to install the make and sudo commands to my Windows. <br></p>

<p>In the mean time, here's what I did to make my project using cryptopp compile in Windows assuming that you have successfully compiled it in mac: <br>
1.) Copy the cryptopp android specific libraries and header files from <code>/usr/local/cryptopp</code> to your jni folder. It should look something like this:
<a href=""https://i.stack.imgur.com/Y4Nde.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Y4Nde.png"" alt=""folder hierarchy for cryptopp""></a></p>

<p>Note: In <code>/usr/local/cryptopp</code> the include files are located in the specific android folder. In the example above, I placed the include file outside since they are all using the same header files. This way, we will avoid duplicated header files. <br> <br>
2.) After copying, update your Android.mk. Make it point to your new cryptopp directory instead. If you followed the hierarchy in step1, your Android.mk code for cryptopp will look something like this:</p>

<pre><code># Crypto++ library
include $(CLEAR_VARS)

CRYPTOPP_INCL   := $(LOCAL_PATH)/Cryptopp/include
CRYPTOPP_LIB    := Cryptopp/android-$(TARGET_ARCH_ABI)/lib
LOCAL_MODULE       := cryptopp
LOCAL_SRC_FILES    := $(CRYPTOPP_LIB)/libcryptopp.a
LOCAL_CPP_FEATURES := rtti exceptions
LOCAL_EXPORT_C_INCLUDES := $(CRYPTOPP_INCL) $(CRYPTOPP_INCL)/cryptopp
include $(PREBUILT_STATIC_LIBRARY)
LOCAL_SHARED_LIBRARIES  := cryptopp
</code></pre>

<p>Note: Notice that we didn't use <code>$(LOCAL_PATH)</code> for the <code>CRYPTOPP_LIB</code> which was used by <code>LOCAL_SRC_FILES</code>. This is to avoid having a missing directory: <code>jni/jni/Cryptopp/android-$(TARGET_ARCH_ABI)/lib/libcryptopp.a</code>. Remember that <code>LOCAL_SRC_FILES</code> start searching in <code>jni/</code>.</p>
","727","<android><shared-libraries><cocos2d-x><static-libraries><crypto++>","0","2","1","2016-03-30 08:18:22","36255417","4","","608639","","2016-03-18 05:50:23","2016-03-16 06:31:39",""
"14543596","Crypto++ low level AES API (a la SJCL)","<p>I'm trying to reverse engineer a protocol from a javascript implementation, and I'm stuck on an AES encryption method. I'm programming this in C++, with the Crypto++ library. It's using the SJCL library, and it calls <code>ciphertext = (new sjcl.cipher.aes(key)).encrypt(plaintext)</code>. From the SJCL documentation, I can see that this is a low-level interface. <code>ciphertext</code>, <code>key</code>, and <code>plaintext</code> are all 4-element arrays of 32-bit integers. As far as I know, and could find on google, Crypto++ only provides high-level interfaces. Is there any way to get Crypto++ to do what SJCL is doing? Also, what exactly does that <code>encrypt</code> method do?</p>

<p><a href=""http://bitwiseshiftleft.github.com/sjcl/doc/symbols/sjcl.cipher.aes.html"" rel=""nofollow"">http://bitwiseshiftleft.github.com/sjcl/doc/symbols/sjcl.cipher.aes.html</a></p>

<p>Edit: I noticed the javascript code converted <code>plantext</code> from a string to ints, and I think I tried every combination of changing endianess of every variable. I tried all combinations that made sense, anyway. I also tried creating arrays of <code>int32_t</code>'s and initializing them with what was input into that line of javascript. Here's what I've got now:</p>

<pre><code>void crypto()
{
    SecByteBlock key(16);
    int32_t plain[4] = { 0x93C467E3, 0x7DB0C7A4, 0xD1BE3F81, 0x0152CB56 }, cipher[4];
    int32_t* keyBuf = (int32_t*) key.BytePtr();

    keyBuf[0] = 1885434739;
    keyBuf[1] = 2003792484;
    keyBuf[2] = 0;
    keyBuf[3] = 0;

    cout &lt;&lt; ""plain = ["" &lt;&lt; plain[0] &lt;&lt; "", "" &lt;&lt; plain[1] &lt;&lt; "", "" &lt;&lt; plain[2] &lt;&lt; "", "" &lt;&lt; plain[3] &lt;&lt; ""]\n"";

    cout &lt;&lt; ""key = ["" &lt;&lt; keyBuf[0] &lt;&lt; "", "" &lt;&lt; keyBuf[1] &lt;&lt; "", "" &lt;&lt; keyBuf[2] &lt;&lt; "", "" &lt;&lt; keyBuf[3] &lt;&lt; ""]\n"";

    ECB_Mode&lt;AES&gt;::Encryption e;
    e.SetKey(key, key.size());

    StringSource((const byte*) plain, 16, true, new StreamTransformationFilter( e, new ArraySink((byte*)cipher, 16) ) );

    cout &lt;&lt; ""cipher = ["" &lt;&lt; cipher[0] &lt;&lt; "", "" &lt;&lt; cipher[1] &lt;&lt; "", "" &lt;&lt; cipher[2] &lt;&lt; "", "" &lt;&lt; cipher[3] &lt;&lt; ""]\n"";

}

function crypto()
{
    var key = [1885434739, 2003792484, 1885434739, 2003792484];
    var plain = [0x93C467E3,0x7DB0C7A4,0xD1BE3F81,0x0152CB56];
    console.log(""plain = ""+plain);
    console.log(""key = ""+key);
    var cipher = (new sjcl.cipher.aes(key)).encrypt(plain);
    console.log(""cipher = ""+cipher);
}
</code></pre>

<p>Here's the output of the C++ version:</p>

<pre><code>plain = [2479122403, 2108737444, 3518906241, 22203222]
key = [1885434739, 2003792484, 1885434739, 2003792484]
cipher = [3437909595, 1341853431, 2532744872, 2416113380]
</code></pre>

<p>and JavaScript:</p>

<pre><code>plain = 2479122403,2108737444,3518906241,22203222
key = 1885434739,2003792484,1885434739,2003792484
cipher = -1974659585,-1567997661,-1863224381,-318378846
</code></pre>
","<p>Yes, you should use the integers as big endian representation of byte arrays. So the highest byte should be to the left. Then you get 16 byte input/output, for 128 bit AES. You can use Crypto++ or other higher level cryptography libs in ECB mode to perform a block encrypt/decrypt.</p>

<p>Note that the SJCL <code>aes</code> class only implements the primitive. It is used within SJCL as implementation of one of the <a href=""http://bitwiseshiftleft.github.com/sjcl/doc/symbols/sjcl.mode.ccm.html"" rel=""nofollow"">ccm</a> or <a href=""http://bitwiseshiftleft.github.com/sjcl/doc/symbols/sjcl.mode.ocb2.html"" rel=""nofollow"">ocb2</a> modes of encryption. Those modes in turn are used by the convenience library, but - if I remember correctly - that one goes straight to using JSON encoding/decoding, which may be a step too far for you.</p>
","726","<javascript><c++><encryption><aes><crypto++>","0","2","1","2013-01-28 06:09:35","","0","","1091954","","2013-01-28 06:09:35","2013-01-27 01:43:28",""
"30412236","Setting up crypto++","<p>I downloaded crypto++ 5.6.2 (the zip file) and built it using just <code>make</code> (I have gcc 4.8.1). It seemed to work and gave me a <code>libcryptopp.a</code> file.</p>

<p>Now, to test the setup, I tried to compile the <code>test.cpp</code> file that was provided with the download (link here: <a href=""http://www.cryptopp.com/docs/ref/test_8cpp_source.html"" rel=""nofollow"">http://www.cryptopp.com/docs/ref/test_8cpp_source.html</a>).</p>

<p>First, I compiled it with </p>

<p><code>g++ -Wall -std=c++11 -g -Iinclude -I/c/libraries/cryptopp562 -c test.cpp -o obj/test.o</code></p>

<p>which gave a lot of warnings (deprecations and unused variables mostly) but worked and I got the <code>test.o</code> file.</p>

<p>Now, to link it, I used</p>

<p><code>g++ obj/test.o -o bin/test -L/c/libraries/cryptopp562 -lcryptopp</code></p>

<p>But this gave a lot of <code>undefined reference</code> errors and failed. </p>

<p>For example</p>

<p><code>D:\.../test.cpp:119: undefined reference to `RegisterFactories()'</code></p>

<p>But when you look at the <code>test.cpp</code> file (<a href=""http://www.cryptopp.com/docs/ref/test_8cpp_source.html"" rel=""nofollow"">http://www.cryptopp.com/docs/ref/test_8cpp_source.html</a>), there is only the declaration to <code>RegisterFactories()</code>, but no definition. Does this mean, it needs to find it from the library? (A local declaration shouldn't be needed in this case, no?)</p>

<p>Ok, so what do I have to do to get the whole library to work? Use <code>gmake</code> to build it? Or use an older <code>gcc</code>? Or maybe my compile/link commands are incorrect? </p>
","<p>test.cpp is not self-contained. It used a lot of other files. Actually it is already used in the build (see GNUmakefile). After the build, libcryptopp.a and cryptest.exe are generated. test.cpp is used in building cryptest.exe.</p>

<p>The specific function you mentioned is defined in regtest.cpp. It also uses a lot of other functions in other C++ files.</p>
","711","<c++><c++11><gcc><crypto++>","2","0","2","2015-05-23 20:54:52","30417444","2","","","","","2015-05-23 11:41:40",""
"30412236","Setting up crypto++","<p>I downloaded crypto++ 5.6.2 (the zip file) and built it using just <code>make</code> (I have gcc 4.8.1). It seemed to work and gave me a <code>libcryptopp.a</code> file.</p>

<p>Now, to test the setup, I tried to compile the <code>test.cpp</code> file that was provided with the download (link here: <a href=""http://www.cryptopp.com/docs/ref/test_8cpp_source.html"" rel=""nofollow"">http://www.cryptopp.com/docs/ref/test_8cpp_source.html</a>).</p>

<p>First, I compiled it with </p>

<p><code>g++ -Wall -std=c++11 -g -Iinclude -I/c/libraries/cryptopp562 -c test.cpp -o obj/test.o</code></p>

<p>which gave a lot of warnings (deprecations and unused variables mostly) but worked and I got the <code>test.o</code> file.</p>

<p>Now, to link it, I used</p>

<p><code>g++ obj/test.o -o bin/test -L/c/libraries/cryptopp562 -lcryptopp</code></p>

<p>But this gave a lot of <code>undefined reference</code> errors and failed. </p>

<p>For example</p>

<p><code>D:\.../test.cpp:119: undefined reference to `RegisterFactories()'</code></p>

<p>But when you look at the <code>test.cpp</code> file (<a href=""http://www.cryptopp.com/docs/ref/test_8cpp_source.html"" rel=""nofollow"">http://www.cryptopp.com/docs/ref/test_8cpp_source.html</a>), there is only the declaration to <code>RegisterFactories()</code>, but no definition. Does this mean, it needs to find it from the library? (A local declaration shouldn't be needed in this case, no?)</p>

<p>Ok, so what do I have to do to get the whole library to work? Use <code>gmake</code> to build it? Or use an older <code>gcc</code>? Or maybe my compile/link commands are incorrect? </p>
","<blockquote>
  <p>Setting up crypto++</p>
</blockquote>

<p>The instructions to setup Crypto++ under Linux are on the wiki at <a href=""http://www.cryptopp.com/wiki/Linux#Build_and_Install_the_Library"" rel=""nofollow"">Build and Install the Library</a>.</p>

<hr>

<blockquote>
  <p>... to test the setup, I tried to compile the <code>test.cpp</code> ...</p>
</blockquote>

<p>If you want to build the test suite, then you run <code>make cryptest.exe</code>.</p>

<p>If you want to run the test suite after building it, you run <code>./cryptest.exe v</code>.</p>

<hr>

<blockquote>
  <p><code>undefined reference to RegisterFactories()</code></p>
</blockquote>

<p>There are 9 source files that are used in the test suite. They are:</p>

<ul>
<li>validate.h, bench.h</li>
<li>test.cpp, datatest.cpp</li>
<li>bench.cpp, bench2.cpp</li>
<li>validat1.cpp, validat2.cpp, validat3.cpp</li>
</ul>

<hr>

<blockquote>
  <p>... what do I have to do to get the whole library to work?</p>
</blockquote>

<p><code>make cryptest.exe</code> and <code>./cryptest.exe v</code> usually work fine :)</p>

<p>I usually run <code>make static dynamic cryptest.exe</code> to build both the static archive and the shared object.</p>

<p>You can also run individual test with <code>tv</code> command. For example, <code>./cryptest.exe tv sha1</code> will run SHA-1 related tests. <code>tv</code> is ""test vectors"", and they are located in the `TestVectors"" directory of the sources.</p>

<hr>

<p>Related, if you want the test suite to run after installation, then you will need the <a href=""http://www.cryptopp.com/wiki/Datadir"" rel=""nofollow"">DataDir Patch</a>.</p>

<p>Its a patch supplied by the community. Its not part of the Crypto++ library (though it should probably be part of the library).</p>
","711","<c++><c++11><gcc><crypto++>","2","2","2","2015-05-23 20:54:52","30417444","2","","","","","2015-05-23 11:41:40",""
"40646410","Effecient way for encrypt large data using Crypto++","<p>I am looking for a solution to encrypt/decrypt a big file (some GBs) using Crypto++. Several days ago, I was thinking about using StringSource in <a href=""https://stackoverflow.com/questions/40586525/encrypt-big-char-using-stdstring-with-crypto"">this question</a>, read the whole file into a char array, then encrypt/decrypt it using CTR mode.</p>

<p>Encrypt a string to a string</p>

<pre><code>string  encryptString(string plain, byte key[], int sizeKey, byte iv[], int sizeIV){
    string cipher;
    try{
        CTR_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        StringSource s(plain, true,
            new StreamTransformationFilter(e,
            new StringSink(cipher)
            )
            );

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return cipher;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return NULL;
    }
}
</code></pre>

<p>Decrypt a string to a string</p>

<pre><code>string  decryptString(string cipher, byte key[], int sizeKey, byte iv[], int sizeIV){
    string reco;
    try{
        CTR_Mode&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        StringSource s(cipher, true,
            new StreamTransformationFilter(d,
            new StringSink(reco)
            )
            );

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return reco;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return reco;
    }
}
</code></pre>

<p>Wrap the encrypt string above</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long len){
    string ss(plainText, len);
    long lengSS = ss.length();

    string cipher = encryptString(ss, key, sizeKey, iv, sizeIV);
    len = cipher.size();
    char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0';
    return writable;
}
</code></pre>

<p>Wrap the decrypt string above</p>

<pre><code>char* decrypt(char * cipher, byte key[], int sizeKey, byte iv[], int sizeIV, long len){
    string ss(cipher, len);
    long lengSS = ss.length();
    string recovered = decryptString(ss, key, sizeKey, iv, sizeIV);
    //FileUtil::writeStringToFile(""d2.txt"", recovered);
    char * writable = new char[recovered.size() ];
    std::copy(recovered.begin(), recovered.end(), writable);
    writable[recovered.size() ] = '\0';
    return writable;
}
</code></pre>

<p>The main</p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    byte key[AES::DEFAULT_KEYLENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8', '1', '2', '3', '4', '5', '6', '7', '8' };
    byte iv[AES::BLOCKSIZE] = { '8', '7', '6', '5', '4', '3', '2', '1', '8', '7', '6', '5', '4', '3', '2', '1' };
    //prng.GenerateBlock(iv, sizeof(iv));
    char* pdata = ""CTR encrypt mode 1234567890"";
    char * sourceFileName = ""1MB.txt"";
    char * targetFileName = ""1MB.aes.crpp.txt"";

    /*
    Looking for parameters.
    param 0: e to encrypt. d to decrypt
    param 1: sourceFileName
    param 2: targetFileName
    */
    if (argc &gt; 1){

        char * action = argv[1];
        sourceFileName = argv[2];
        targetFileName = argv[3];
        long size = 0;

        char * pdata = FileUtil::readAllByte(sourceFileName, size);

        string ext = getExtension(sourceFileName);

        char * result1 = NULL;
        if (strcmp(action, ""e"") == 0){
            result1 = encrypt(pdata, key, sizeof(key), iv, sizeof(iv), size);
        }
        else if (strcmp(action, ""d"") == 0){
            result1 = decrypt(pdata, key, sizeof(key), iv, sizeof(iv), size);
        }
        FileUtil::writeFile(targetFileName, result1, size);
        //FileUtil::writeStringToFile(targetFileName, recovered1);
    }
    else{
        cout &lt;&lt; ""Missing/Invalid params"" &lt;&lt; endl;

    }
    return 0;

}
</code></pre>

<p>Now this solution can encrypt/decrypt file have size up to several hundreds MB. But when I using it with 1GB text file, its got error:</p>

<pre><code>Unhandled exception at 0x74DFA6F2 in AES-CRPP.exe: Microsoft C++ exception: std::bad_alloc at memory location 0x00AFE480.
</code></pre>

<p>at the line:</p>

<pre><code>char*encrypt(...){
string ss(data, len)
...
}
</code></pre>

<p>I have 8GB of RAM and its look like reading 1GB of char and convert it into string cause the error.
In another <a href=""https://stackoverflow.com/questions/40601847/gargage-redundancy-character-at-the-end-of-original-text-when-decrypt-using-cryp/40610145?noredirect=1#comment68513953_40610145"">question</a>, jww gave me a hint at the bottom, but I cannot make it work. Is there a solution for large byte (char) array encrypt using Crypto++</p>

<p>About using FileSource
Document here: <a href=""https://www.cryptopp.com/wiki/FileSource"" rel=""nofollow noreferrer"">enter link description here</a>
Code example:</p>

<pre><code>EAX&lt; Blowfish &gt;::Encryption e1;
        e1.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

        CryptoPP::FileSource fs1(ofilename.c_str(), true,
            new AuthenticatedEncryptionFilter(e1,
            new FileSink(efilename.c_str())
            ));



        EAX&lt; Blowfish &gt;::Decryption d2;
        d2.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

        CryptoPP::FileSource fs2(efilename.c_str(), true,
            new AuthenticatedDecryptionFilter(d2,
            new FileSink(rfilename.c_str()),
            AuthenticatedDecryptionFilter::THROW_EXCEPTION
            ));
</code></pre>

<p>It doesn't allow me to export the output cipher to a temporatory char * variable, instead of saving directly to a file. Of course I can wait for the file to file encryption to completed, then read the output file into the memory again, but its seem so bad.</p>
","","706","<c++><crypto++><large-data>","1","","0","2018-03-04 17:31:54","","3","","4393935","","2018-03-04 17:31:54","2016-11-17 03:50:22",""
"34439990","ECDH Shared Secret does not match between Crypto++ and Android","<p>So I am writing an ECDH implementation on Android using Java and the Crypto++ 5.6.3 Library.</p>

<p>I wrote some C++ JNI code to call Crypto++ functions, I have one function to generate the public/private key pair, and another function to extract the shared secret. There seems to be an issue however with the shared secrets not matching.</p>

<p>Th situation is as follows. Alice and Bob both generate their own Public and Private Key Pairs. They exchange public keys successfully.</p>

<p>To get the shared secret Alice does the following :</p>

<pre><code>byte[] sharedSecret = getSharedSecret(bobPublicKey, alicePrivateKey);
</code></pre>

<p>Bob does a similar operation :</p>

<pre><code>byte[] sharedSecret = getSharedSecret(alicePublicKey, bobPrivateKey);
</code></pre>

<p>The issue I am seeing is, the two shared secrets do not match each other. Is there some misunderstanding on my part on how this is supposed to work?</p>

<p>I am assuming there is just a specific implementation issue on my side relating to the shared secret but I am not sure. The C++ JNI implementation is below. The retrieveSharedSecret function always outputs ""It Worked"". Any ideas on what I am doing wrong here?</p>

<pre><code>JNIEXPORT jobject JNICALL Java_com_myproject_test_cryptopp_ECDHLibrary_generateKeyPair
        (JNIEnv *env, jclass)
{
    // Generate a public private key pair using ECDH (Elliptic Curve Diffie Hellman)
    OID CURVE = secp256r1(); // the key is 256 bits (32 bytes) long
    AutoSeededRandomPool rng;

    // Because we are using point compression
    // Private Key 32 bytes
    // Public Key 33 bytes
    // If compression was not used the public key would be 65 bytes long
    ECDH &lt; ECP &gt;::Domain dhA( CURVE );
    dhA.AccessGroupParameters().SetPointCompression(true);

    SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
    dhA.GenerateKeyPair(rng, privA, pubA);

    jobject publicKeyByteBuffer = (*env).NewDirectByteBuffer(pubA.BytePtr(), pubA.SizeInBytes());
    jobject privateKeyByteBuffer = (*env).NewDirectByteBuffer(privA.BytePtr(), privA.SizeInBytes());

    // Return the ECDH Key Pair back as our custom Java ECDHKeyPair class object
    jclass keyPairClass = (*env).FindClass(""com/myproject/test/cryptopp/ECDHKeyPair"");
    jmethodID midConstructor = (*env).GetMethodID(keyPairClass, ""&lt;init&gt;"", ""(Ljava/nio/ByteBuffer;Ljava/nio/ByteBuffer;)V"");
    jobject keyPairObject = (*env).NewObject(keyPairClass, midConstructor, publicKeyByteBuffer, privateKeyByteBuffer);

    return keyPairObject;
}

JNIEXPORT jobject JNICALL Java_com_myproject_test_cryptopp_ECDHLibrary_retrieveSharedSecret
        (JNIEnv *env, jclass, jbyteArray publicKeyArray, jbyteArray privateKeyArray)
{
    // Use the same ECDH Setup that is specified in the generateKeyPair method above
    OID CURVE = secp256r1();
    DL_GroupParameters_EC&lt;ECP&gt; params(CURVE);
    ECDH&lt;ECP&gt;::Domain dhAgreement(params);
    dhAgreement.AccessGroupParameters().SetPointCompression(true);

    // Figure out how big the public and private keys are
    // Public Key: This belongs to the other user
    // Private Key: This is out personal private key
    int pubLen = (int)(*env).GetArrayLength(publicKeyArray);
    int privLen = (int)(*env).GetArrayLength(privateKeyArray);

    // Convert the keys from a jbyteArray to a SecByteBlock so that they can be passed
    // into the CryptoPP Library functions.
    unsigned char* pubData = new unsigned char[pubLen];
    (*env).GetByteArrayRegion(publicKeyArray, 0, pubLen, reinterpret_cast&lt;jbyte*&gt;(pubData));

    unsigned char* privData = new unsigned char[privLen];
    (*env).GetByteArrayRegion(privateKeyArray, 0, privLen, reinterpret_cast&lt;jbyte*&gt;(privData));

    SecByteBlock pubB(pubData, pubLen) , privA(privData, privLen);

    // Now extract shared secret between the two keys
    SecByteBlock sharedSecretByteBlock(dhAgreement.AgreedValueLength());
    ALOG(""Shared Agreed Value Length: %d"", dhAgreement.AgreedValueLength());

    bool didWork = dhAgreement.Agree(sharedSecretByteBlock, privA, pubB);

    ALOG(""Key Agreement: %s"", didWork ? ""It Worked"" : ""It Failed"");
    ALOG(""Shared Secret Byte Size: %d"", sharedSecretByteBlock.SizeInBytes());

    // Return the shared secret as a Java ByteBuffer
    jobject publicKeyByteBuffer = (*env).NewDirectByteBuffer(sharedSecretByteBlock.BytePtr(), sharedSecretByteBlock.SizeInBytes());

    return publicKeyByteBuffer;
}
</code></pre>

<p><strong>EDIT:</strong>
I put my test project up on Github <a href=""https://github.com/tcolligan-ap/ECDHTest"" rel=""nofollow"">here</a> so that others can take a look and try their own luck. Contains some instructions in the README on how to get it up and running.</p>
","<p>I was able to figure it out with some help from a friend. The issue was the retrieveSharedSecret method and the fact that it was directly returning a byte buffer, which was pointing to a memory address that was in scope during the C++ method call, but then out of scope as soon it got back out into the Java code. So I was essentially getting garbage memory as my shared secret.</p>

<p>I tweaked the code so that the method returns a custom SharedSecret Java object, just like the keyGeneration method does. Doing that allows all the info I need to be copied over properly I and don't have to worry about this scope issue.</p>

<p>Revised method code is below. I will also update the <a href=""https://github.com/tcolligan-ap/ECDHTest"" rel=""nofollow"">Github</a> project so that it can exist as a working example of how to use Android Studio with the NDK (non-experimental) and CryptoPP.</p>

<pre><code>// Use the same ECDH Setup that is specified in the generateKeyPair method above
OID CURVE = secp256r1();
DL_GroupParameters_EC&lt;ECP&gt; params(CURVE);
ECDH&lt;ECP&gt;::Domain dhAgreement(params);
dhAgreement.AccessGroupParameters().SetPointCompression(true);

// Figure out how big the public and private keys are
// Public Key: This belongs to the other user
// Private Key: This is out personal private key
int pubLen = (int)(*env).GetArrayLength(publicKeyArray);
int privLen = (int)(*env).GetArrayLength(privateKeyArray);

// Convert the keys from a jbyteArray to a SecByteBlock so that they can be passed
// into the CryptoPP Library functions.
unsigned char* pubData = new unsigned char[pubLen];
(*env).GetByteArrayRegion(publicKeyArray, 0, pubLen, reinterpret_cast&lt;jbyte*&gt;(pubData));

unsigned char* privData = new unsigned char[privLen];
(*env).GetByteArrayRegion(privateKeyArray, 0, privLen, reinterpret_cast&lt;jbyte*&gt;(privData));

SecByteBlock pubB(pubData, pubLen) , privA(privData, privLen);

// Now extract shared secret between the two keys
SecByteBlock sharedSecretByteBlock(dhAgreement.AgreedValueLength());
ALOG(""Shared Agreed Value Length: %d"", dhAgreement.AgreedValueLength());

bool didWork = dhAgreement.Agree(sharedSecretByteBlock, privA, pubB);

ALOG(""Key Agreement: %s"", didWork ? ""It Worked"" : ""It Failed"");
ALOG(""Shared Secret Byte Size: %d"", sharedSecretByteBlock.SizeInBytes());

// Return the shared secret as a Java ByteBuffer
jobject sharedSecretByteBuffer = (*env).NewDirectByteBuffer(sharedSecretByteBlock.BytePtr(), sharedSecretByteBlock.SizeInBytes());

// Return the ECDH Key Pair back as a Java ECDHKeyPair object
jclass keyPairClass = (*env).FindClass(""com/tcolligan/ecdhtest/SharedSecret"");
jmethodID midConstructor = (*env).GetMethodID(keyPairClass, ""&lt;init&gt;"", ""(Ljava/nio/ByteBuffer;)V"");
jobject sharedSecretObject = (*env).NewObject(keyPairClass, midConstructor, sharedSecretByteBuffer);

return sharedSecretObject;
</code></pre>
","697","<java><android><c++><java-native-interface><crypto++>","2","1","1","2016-01-04 00:22:10","34583206","3","1","5655109","","2016-01-03 20:14:26","2015-12-23 16:30:37",""
"13249421","Error C2711 while trying to compile my project using crypto++","<p>I'm trying to compile a project using crypto++. My project is using clr and when I'm trying to compile the code, I end up with the followings errors:</p>

<pre><code>'main' : this function cannot be compiled as managed, consider using #pragma unmanaged

'int main(cli::array&lt;Type&gt; ^)' : managed type or function cannot be used in an unmanaged function
</code></pre>

<p>My project is using <code>clr</code> and I'm using <code>/MD</code> as runtime Library. I setted the same parameters when I compiled crypto++.</p>

<p>Edit: my main function</p>

<pre><code>     int main(array&lt;System::String ^&gt; ^args)
{
    Console::WriteLine(L""Hello World"");

    // Generate keys
    AutoSeededRandomPool rng;

    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize( rng, 1536 );

    RSA::PrivateKey privateKey( params );
    RSA::PublicKey publicKey( params );

    std::string plain=""RSA Encryption"", cipher, recovered;


    // Encryption
    RSAES_OAEP_SHA_Encryptor e( publicKey );

    StringSource( plain, true,
        new PK_EncryptorFilter( rng, e,
            new StringSink( cipher )
        ) // PK_EncryptorFilter
     ); // StringSource

    // Decryption
    RSAES_OAEP_SHA_Decryptor d( privateKey );

    StringSource( cipher, true,
        new PK_DecryptorFilter( rng, d,
            new StringSink( recovered )
        ) // PK_DecryptorFilter
     ); // StringSource

    assert( plain == recovered );
    std::cin.ignore();
    return 0;
}
</code></pre>
","<p>You'll get this error if you attempt to perform any unmanaged instruction in managed code.  See <a href=""http://msdn.microsoft.com/en-us/library/z3sskk32.aspx"" rel=""nofollow"">here</a>.</p>

<p>The likes of <code>assert()</code> and <code>std::string</code> are native methods/types respectively which means they deal in raw pointers and don't obey the rules of managed C++.  Mixing unmanaged code like this with managed code can be achieved by using <a href=""http://msdn.microsoft.com/en-us/library/ms235282.aspx"" rel=""nofollow"">PInvoke/DllImport</a>.</p>
","678","<c++><visual-studio-2008><compilation><clr><crypto++>","0","2","1","2012-11-06 11:15:37","13249836","1","","1280608","","2012-11-06 11:05:12","2012-11-06 10:51:13",""
"43967330","Crypto++ aes-256-ecb result is different with openssl","<p>I'm trying to encrypt a simple string such as ""Hello World!"" via Crypto++, and decrypt it via Crypto++ succeed. but I got an error when decrypt Crypto++ encrypted result via OpenSSL command.</p>

<p>My C++ code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;aes.h&gt;
#include &lt;base64.h&gt;
#include &lt;modes.h&gt;

std::string aes_encrypt(std::string key, std::string plain)
{
    std::string result;
    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption ecb_encryptor((byte *)key.c_str(), CryptoPP::AES::MAX_KEYLENGTH);
    auto encryptor = new CryptoPP::StreamTransformationFilter(ecb_encryptor,
        new CryptoPP::Base64Encoder(new CryptoPP::StringSink(result), false),
        CryptoPP::StreamTransformationFilter::ZEROS_PADDING);
    CryptoPP::StringSource(plain, true, encryptor);

    return result;
}

std::string aes_decrypt(std::string key, std::string cipher)
{
    std::string result;
    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption ecb_decryptor((byte *)key.c_str(), CryptoPP::AES::MAX_KEYLENGTH);
    auto decryptor = new CryptoPP::Base64Decoder(new CryptoPP::StreamTransformationFilter(ecb_decryptor,
        new CryptoPP::StringSink(result),
        CryptoPP::StreamTransformationFilter::ZEROS_PADDING));
    CryptoPP::StringSource(cipher, true, decryptor);

    return result;
}

int main(int argc, char **argv)
{
    const char *key = ""1234567890"";
    const char *plain = ""Hello World!"";

    std::cout &lt;&lt; ""plain: "" &lt;&lt; plain &lt;&lt; std::endl;
    std::string cipher = aes_encrypt(key, plain);
    std::cout &lt;&lt; ""cipher: "" &lt;&lt; aes_encrypt(key, plain) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""plain: "" &lt;&lt; aes_decrypt(key, cipher) &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>plain: Hello World!
cipher: bVgt4KsCOTULujusMJvhhw==
plain: Hello World!
</code></pre>

<p>OpenSSL command:</p>

<pre><code>xxx@xxxdeMacBook-Pro ~ $ echo -n 'Hello World!' | openssl enc -e -aes-256-ecb -nosalt -a -A -pass pass:1234567890
7sQWFmxUUQ8DpoXh9DXS8g==
xxx@xxxdeMacBook-Pro ~ $ echo -n '7sQWFmxUUQ8DpoXh9DXS8g==' | openssl enc -d -aes-256-ecb -nosalt -a -A -pass pass:1234567890
Hello World!
</code></pre>

<p>Try to use OpenSSL to decrypt Crypto++ result failed:</p>

<pre><code>xxx@xxxdeMacBook-Pro ~ $ echo -n 'bVgt4KsCOTULujusMJvhhw==' | openssl enc -d -aes-256-ecb -nosalt -a -A -pass pass:1234567890
bad decrypt
78710:error:06065064:digital envelope routines:EVP_DecryptFinal_ex:bad decrypt:/BuildRoot/Library/Caches/com.apple.xbs/Sources/OpenSSL098/OpenSSL098-64.50.6/src/crypto/evp/evp_enc.c:330:
</code></pre>
","<p>That's because you're using a different padding (Zero Padding in Crypto++ vs. PKCS#7 padding in OpenSSL) and a completely different key. </p>

<p>In OpenSSL, the key is derived from the password that you provide (it's called <code>-pass</code> after all) using the EVP_BytesToKey function.<br>
If you want to use a proper AES key, you can use the <code>-K</code> commandline option to provide a Hex encoded key (should be 32, 48 or 64 characters long).</p>

<p>In Crypto++ you're directly passing a broken key to <code>ecb_encryptor</code>. AES supports keys of 16, 24 and 32 bytes length and nothing in between. But you're providing a 10 byte key and tell Crypto++ that the key is actually 32 byte long. This probably results in a random key because the remaining bytes in memory probably contain some junk values.<br>
If you want to use the password-based encryption of OpenSSL, Crypto++ provides an implementation of <a href=""https://www.cryptopp.com/wiki/OPENSSL_EVP_BytesToKey"" rel=""nofollow noreferrer"">OpenSSL's EVP_BytesToKey function</a>. </p>

<p>Whether you decide to use an valid AES key or a password is up to you. Remember that an AES key is supposed to be randomly generated to be secure and a password must be long enough to provide any good security. I would say the password must be roughly 30% longer than the bit strength that you're going for (for 128 bit security you would need a randomly generated password of 21 characters containing uppercase, lowercase letters and digits).</p>

<h3>Security considerations:</h3>

<p>You should never use <a href=""https://crypto.stackexchange.com/q/14487/13022"">ECB mode</a>. It's deterministic and therefore not semantically secure. You should at the very least use a randomized mode like <a href=""https://crypto.stackexchange.com/q/22260/13022"">CBC</a> or <a href=""https://crypto.stackexchange.com/a/2378/13022"">CTR</a>. It is better to authenticate your ciphertexts so that attacks like a <a href=""https://crypto.stackexchange.com/q/18185/13022"">padding oracle attack</a> are not possible. This can be done with authenticated modes like GCM or EAX, or with an <a href=""https://crypto.stackexchange.com/q/202/13022"">encrypt-then-MAC</a> scheme.</p>
","674","<encryption><openssl><aes><crypto++><ecb>","1","5","1","2017-05-14 20:31:25","43967400","0","","","","","2017-05-14 18:14:16",""
"16484429","Pass AES ciphertext as parameter","<p>I am trying to write 2 different functions to encrypt and decrypt the data using AES in cryptopp. I want to pass the ciphertext as a parameter to the decryption function. However on the decryption function, it recieves some special symbols as ciphertext &amp; thus doesn't decrypt properly. Please help.</p>

<pre><code>// -- AES encryption function ----------
void Security_packetAgent::encryption(char out[])
{ 
    std::string plaintext = out;
    std::string ciphertext = """";

    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ )
    {
        std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    std::cout&lt;&lt;""\nMessage encrypted ..."";
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
    sprintf(out, ""%s"", ciphertext.c_str());
    printf(""Final Data: %s : %s "", out, reinterpret_cast&lt;const unsigned char*&gt;(ciphertext.c_str()));
}

// ---- AES decryption  ------------------
void Security_packetAgent::decryption(char out[])
{ 
    cout&lt;&lt;""\nCipher recieved: ""&lt;&lt;out;
    std::cout&lt;&lt;""\nEntered decryption .."";
    std::string ciphertext = out;
    std::string decryptedtext;

    cout&lt;&lt;""\nCipher recieved: ""&lt;&lt;reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str());
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
    std::cout &lt;&lt; decryptedtext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;    
}
</code></pre>
","<p>You shouldn't be constructing <code>std::string</code> out of a <code>char*</code>, if the <code>char*</code> is pointing to something that isn't a text string, such as encrypted data.</p>

<pre><code>std::string ciphertext = out;
</code></pre>

<p>The construction of <code>ciphertext</code> is going to stop copying from <code>out</code> as soon as it reaches a 0 byte. Instead, you need to also pass in the <strong>length</strong> of the encrypted data and use the <code>std::string(const char* data, size_t size)</code> constructor.</p>

<pre><code>std::string ciphertext(out, outSize);
</code></pre>

<p>Alternatively, you can also use the constructor taking a begin and end iterator.</p>
","672","<c++><encryption><aes><encryption-symmetric><crypto++>","0","3","1","2015-05-02 22:04:21","","2","","608639","","2015-05-02 22:04:21","2013-05-10 14:19:40",""
"40362351","How to seek in CTR mode and decrypt part of the stream?","<p>I have a question in partial decoding in cryptopp. 
USE AES 256 CTR;</p>

<p>Encode source:</p>

<pre class=""lang-cxx prettyprint-override""><code>CTR_Mode&lt; AES &gt;::Encryption e;
e.SetKeyWithIV(key, 32, iv);
string encrypt;
string a = ""Example text to encoding"";
encrypt.clear();
StringSource s(a, true,
    new StreamTransformationFilter(e,
        new StringSink(encrypt)
    )
);
</code></pre>

<p>Decode source:</p>

<pre class=""lang-cxx prettyprint-override""><code>CTR_Mode&lt;AES&gt;::Decryption d;
d.SetKeyWithIV(key, 32, iv);
string x;

StringSource s1(encrypt, true,
    new StreamTransformationFilter(d,
        new StringSink(x)
    )
);
</code></pre>

<p>It works fine. But I don't know how decrypt only part. For example, example <code>encrypt.begin()+10</code></p>

<p>Part Decode:</p>

<pre class=""lang-cxx prettyprint-override""><code>CTR_Mode&lt;AES&gt;::Decryption d;
d.SetKeyWithIV(key, 32, iv);
d.DiscardBytes(5);  //bit to skip
string todecrypt = encrypt.substr(5,10); // part of encrypted message
string x;

StringSource s1(todecrypt, true,
    new StreamTransformationFilter(d,
        new StringSink(x)
    )
);
</code></pre>
","<blockquote>
  <p>How to seek in CTR mode and decrypt part of the stream?</p>
</blockquote>

<p>Using a <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Crypto++ Pipeline</a> is a tad bit awkward because <a href=""http://github.com/weidai11/cryptopp/issues/248"" rel=""nofollow noreferrer""><code>Discard</code> or <code>Skip</code> on a <code>Source</code> does not work as expected</a>. You have to <code>Pump</code> data into <em>""nothing""</em> under the current implementation. Also see <a href=""https://stackoverflow.com/q/39166041/608639"">Skip'ing on a Source does not work as expected</a> on Stack Overflow.</p>

<p>Below is an example of using AES/CTR and seeking in the stream. It needs to perform a ""two part"" seek. First, it discards bytes on the <code>Source</code> called <code>cipher</code>. Second, it seeks in the keystream on the encryption object called <code>enc</code> to synchronize the counter. Once the seek is performed, the remainder of the cipher text is decrypted by calling <code>PumpAll()</code>, which pumps the remainder of the data through the pipeline.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""modes.h""
#include ""aes.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
    string plain = ""Now is the time for all good men to come to the aide of their country"";

    byte key[AES::DEFAULT_KEYLENGTH] = {0};
    byte nonce[AES::BLOCKSIZE] = {0};

    CTR_Mode&lt;AES&gt;::Encryption enc;
    enc.SetKeyWithIV(key, sizeof(key), nonce, sizeof(nonce));

    string cipher;
    StringSource ss1(plain, true, new StreamTransformationFilter(enc, new StringSink(cipher)));

    for(size_t i=0; i&lt;cipher.size(); i++)
    {   
        CTR_Mode&lt;AES&gt;::Decryption dec;
        dec.SetKeyWithIV(key, sizeof(key), nonce, sizeof(nonce));

        StringSource ss2(cipher, false);
        ss2.Pump(i);
        dec.Seek(i);

        string recover;
        StreamTransformationFilter stf(dec, new StringSink(recover));

        // Attach the decryption filter after seeking
        ss2.Attach(new Redirector(stf));
        ss2.PumpAll();

        cout &lt;&lt; i &lt;&lt; "": "" &lt;&lt; recover &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>Here is the result:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe 
0: Now is the time for all good men to come to the aide of their country
1: ow is the time for all good men to come to the aide of their country
2: w is the time for all good men to come to the aide of their country
3:  is the time for all good men to come to the aide of their country
4: is the time for all good men to come to the aide of their country
5: s the time for all good men to come to the aide of their country
6:  the time for all good men to come to the aide of their country
7: the time for all good men to come to the aide of their country
8: he time for all good men to come to the aide of their country
9: e time for all good men to come to the aide of their country
10:  time for all good men to come to the aide of their country
11: time for all good men to come to the aide of their country
12: ime for all good men to come to the aide of their country
13: me for all good men to come to the aide of their country
14: e for all good men to come to the aide of their country
15:  for all good men to come to the aide of their country
16: for all good men to come to the aide of their country
17: or all good men to come to the aide of their country
18: r all good men to come to the aide of their country
19:  all good men to come to the aide of their country
20: all good men to come to the aide of their country
21: ll good men to come to the aide of their country
22: l good men to come to the aide of their country
23:  good men to come to the aide of their country
24: good men to come to the aide of their country
25: ood men to come to the aide of their country
26: od men to come to the aide of their country
27: d men to come to the aide of their country
28:  men to come to the aide of their country
29: men to come to the aide of their country
30: en to come to the aide of their country
31: n to come to the aide of their country
32:  to come to the aide of their country
33: to come to the aide of their country
34: o come to the aide of their country
35:  come to the aide of their country
36: come to the aide of their country
37: ome to the aide of their country
38: me to the aide of their country
39: e to the aide of their country
40:  to the aide of their country
41: to the aide of their country
42: o the aide of their country
43:  the aide of their country
44: the aide of their country
45: he aide of their country
46: e aide of their country
47:  aide of their country
48: aide of their country
49: ide of their country
50: de of their country
51: e of their country
52:  of their country
53: of their country
54: f their country
55:  their country
56: their country
57: heir country
58: eir country
59: ir country
60: r country
61:  country
62: country
63: ountry
64: untry
65: ntry
66: try
67: ry
68: y
</code></pre>

<hr>

<p>Now that you've seen the general pattern, here are the modifications for your dataset using the range <code>[5,10]</code>.</p>

<p>You do <em>not</em> have to call <code>stf.MessageEnd()</code> because recovered text is ready as soon as the XOR is preformed. Others modes may need the call to <code>MessageEnd()</code>. Also see <a href=""https://cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow noreferrer"">Init-Update-Final</a> on the Crypto++ wiki.</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource ss2(cipher, false);
ss2.Pump(5);
dec.Seek(5);

string recover;
StreamTransformationFilter stf(dec, new StringSink(recover));

// Attach the decryption filter after seeking
ss2.Attach(new Redirector(stf));
ss2.Pump(10 - 5 + 1);

cout &lt;&lt; ""'"" &lt;&lt; recover &lt;&lt; ""'"" &lt;&lt; endl;
</code></pre>

<p>It produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe 
's the '
</code></pre>

<p>And here's a little more:</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource ss2(cipher, false);
ss2.Pump(5);
dec.Seek(5);

string recover;
StreamTransformationFilter stf(dec, new StringSink(recover));

// Attach the decryption filter after seeking
ss2.Attach(new Redirector(stf));
ss2.Pump(10 - 5 + 1);

cout &lt;&lt; ""'"" &lt;&lt; recover &lt;&lt; ""'"" &lt;&lt; endl;

ss2.Pump(1);

cout &lt;&lt; ""'"" &lt;&lt; recover &lt;&lt; ""'"" &lt;&lt; endl;

ss2.Pump(1);

cout &lt;&lt; ""'"" &lt;&lt; recover &lt;&lt; ""'"" &lt;&lt; endl;
</code></pre>

<p>It produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe 
's the '
's the t'
's the ti'
</code></pre>

<hr>

<p>Earlier I said <em>""Using a <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Crypto++ Pipeline</a> is a tad bit awkward""</em>. Here's all we want to do, but we can't at the moment:</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource ss(cipher, false, new StreamTransformationFilter(dec, new StringSink(x)));
ss.Skip(5); // Discard bytes and synchronize stream
ss.Pump(5); // Process bytes [5,10]

cout &lt;&lt; x &lt;&lt; endl;
</code></pre>

<hr>

<p>Regarding Rob's comment <em>""You must decrypt an entire 16-byte block...""</em> - If you were working with another mode, like CBC mode, then you would have to process preceding plain text or cipher text; and you would have to operate on blocks. CBC mode and its chaining properties demand it.</p>

<p>However, CTR is designed a little differently. Its designed to be seekable, and it allows you to jump around in the stream. In this respect, its a lot like OFB mode. (CTR mode and OFB mode differ in the way they generate the keystream. But both XOR the keystream with the plain text or cipher text).</p>
","671","<c++><encryption><decode><crypto++>","2","2","1","2016-11-02 21:51:14","","3","1","608639","","2016-11-02 03:43:55","2016-11-01 14:39:47",""
"40047190","Error: <memory> no such file or directory on Android with JNI","<p>I am trying to compile Crypto++ library on Android using JNI. I have cloned the project of <a href=""https://github.com/morgwai/ndktutorial"" rel=""nofollow"">https://github.com/morgwai/ndktutorial</a>. I imported the project into android studio, I am able to call the JNI class and read the Crypto++, but when the library gets called I get an inside error which says ""memory"" no such file or directory pointing to <code>#include &lt;memory&gt;</code>.</p>

<p>Here is my build.gradle:</p>

<pre class=""lang-gradle prettyprint-override""><code>apply plugin: 'com.android.model.application'
model {
    android {
        compileSdkVersion 23
        buildToolsVersion ""23.0.3""

        defaultConfig {
            applicationId ""com.moham.myapplication""
            minSdkVersion.apiLevel 22
            targetSdkVersion.apiLevel 23
            versionCode 1
            versionName ""1.0""
        }
        buildTypes {
            release {
                minifyEnabled false
                proguardFiles.add(file('proguard-android.txt'))
            }

        }
        ndk {
            moduleName ""crypt_user.cpp""
        }
    }
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:24.2.1'
}
</code></pre>

<p>Also here is the error I get when I compile:</p>

<pre class=""lang-none prettyprint-override""><code>MYPATH\Android\sdk\ndk-bundle\platforms\android-23\arch-arm64\usr\include\stdcpp.h
Error:(10, 18) memory: No such file or directory
compilation terminated.
Error:Execution failed for task ':app:compileCrypt_userArm64-v8aDebugSharedLibra
ryCrypt_userMainCpp'.
&gt; A build operation failed.
      C++ compiler failed while compiling crypt_user.cpp.
  See the complete log at: file:///D:/MyApplication/app/build/tmp/compileCrypt_u
serArm64-v8aDebugSharedLibraryCrypt_userMainCpp/output.txt
</code></pre>

<p>Thank you in advance.</p>
","<p>Add</p>

<pre><code>APP_STL = c++_shared
</code></pre>

<p>to your Application.mk</p>
","670","<android><android-studio><gradle><java-native-interface><crypto++>","1","0","1","2019-05-29 06:15:54","","7","","608639","","2016-10-14 21:50:20","2016-10-14 15:44:50",""
"49478640","Convert string to byte in crypto++","<p>I am using the AES cipher with Crypto++. I have a key that recorded in the file during encryption. I extract key from file to string and try to use for decrypt.</p>

<p>Is there any way i can convert the string that contains the key <code>string s1</code> to <code>CryptoPP::byte</code>? There fragment of code.</p>

<pre><code>encoded.clear();
StringSource(key, sizeof(key), true,
    new HexEncoder(
        new StringSink(encoded)
));

ofstream fout1(""key.txt""); 
fout1 &lt;&lt; encoded; 
fout1.close(); 

string s1;                
ifstream TextFile1(""key.txt"");            

while (!TextFile1.eof())                       
{
    if (TextFile1.eof())
        break;
    TextFile1 &gt;&gt; s1;
}
</code></pre>
","<blockquote>
  <p>I have a key that recorded in the file during encryption. I extract key from file to string and try to use for decrypt.</p>
</blockquote>

<p>It sounds like you have a file structured similar to below:</p>

<pre><code>[...key...][...iv...][...encrypted data...]
</code></pre>

<p>It is a bit unusual to store a key like that, but here is how it goes... Below I assume you are using AES-128 in CTR mode. That means <code>[...key...]</code> is 16 bytes, and <code>[...iv...]</code> is 16 bytes. The remainder is encrypted data.</p>

<p>I generate the sample file with:</p>

<pre class=""lang-none prettyprint-override""><code>$ head -c 128 &lt; /dev/urandom &gt; message.enc
$ hexdump -C message.enc
00000000  17 44 79 6b e6 96 ff d0  9e 3e 8c c4 fe 57 56 a2  |.Dyk.....&gt;...WV.|
00000010  bb 59 9c a6 fb ab 73 de  a7 a9 4a 22 14 6e c4 af  |.Y....s...J"".n..|
00000020  31 13 04 4d f2 79 f8 7c  7a 0b 16 2c bd be 6e 4c  |1..M.y.|z..,..nL|
00000030  b6 61 0a 6c 33 d3 f0 73  25 44 ec f5 cd f5 cd da  |.a.l3..s%D......|
00000040  3d 13 72 98 65 19 e1 c5  f8 49 1e 07 c7 dc ac b7  |=.r.e....I......|
00000050  ce 03 d1 90 94 08 aa 9d  a0 8b b0 cd ff 9c b9 67  |...............g|
00000060  8a 2c 6f d9 7e fa d2 07  0f a0 48 99 57 77 2b d1  |.,o.~.....H.Ww+.|
00000070  c7 28 2a bc 80 22 21 fb  4a ba cb b2 0e b6 2c ff  |.(*..""!.J.....,.|
</code></pre>

<p>The key is <code>17 44 ... 56 a2</code>. The iv is <code>bb 59 ... c4 af</code>. The encrypted data starts at <code>31 13 04 4d...</code>.</p>

<p>And the program:</p>



<pre><code>$ cat test.cxx
#include ""filters.h""
#include ""files.h""
#include ""modes.h""
#include ""aes.h""
#include ""hex.h""

#include &lt;iostream&gt;

int main()
{
    using namespace CryptoPP;
    // Key and iv are stored at the head of the file
    SecByteBlock key(16), iv(16);
    FileSource fs(""message.enc"", false /* DO NOT Pump All */);

    // Attach new filter
    ArraySink ak(key, key.size());
    fs.Detach(new Redirector(ak));
    fs.Pump(16);  // Pump first 16 bytes

    // Attach new filter
    ArraySink av(iv, iv.size());
    fs.Detach(new Redirector(av));
    fs.Pump(16);  // Pump next 16 bytes

    CTR_Mode&lt;AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

    // Detach previously attached filter, attach new filter
    ByteQueue queue;
    fs.Detach(new StreamTransformationFilter(decryptor, new Redirector(queue)));
    fs.PumpAll();  // Pump remainder of bytes

    std::cout &lt;&lt; ""Key: "";
    StringSource(key, key.size(), true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""IV: "";
    StringSource(iv, iv.size(), true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Message: "";
    HexEncoder hex(new FileSink(std::cout));
    queue.TransferTo(hex);
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>You can call either <code>Attach</code> or <code>Detach</code> to attach a new filter. Both attach a new filter. The difference is, <code>Attach</code> returns the old filter and you have to free it. <code>Detach</code> deletes the old filter for you.</p>

<p>Finally:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ -Wall -I . test.cxx ./libcryptopp.a -o test.exe
$ ./test.exe
Key: 1744796BE696FFD09E3E8CC4FE5756A2
IV: BB599CA6FBAB73DEA7A94A22146EC4AF
Message: 84F6DC079CA04BDFACB645CB11CC2F828573F1841B1B9267CB296B6A977BE19D68B05FA
AF41AB73498F45629EE050B132174A2798C12C29A7033ADD1999BECD00B101F2616112D7E6968EA0
A1BE159CD0EE43549BA6534C8D4AB8F5E7D9E3E44
</code></pre>

<hr>

<p>Unrelated to Crypto++, you usually want to avoid this:</p>

<pre><code>while (!TextFile1.eof())                       
{
    if (TextFile1.eof())
        break;
    TextFile1 &gt;&gt; s1;
}
</code></pre>

<p>I believe it is usually better to follow <a href=""https://stackoverflow.com/q/5605125/608639"">Why is iostream::eof inside a loop condition considered wrong?</a> (I even think <code>TextFile1 &gt;&gt; s1;</code> should be in between the <code>TextFile1.eof()</code> checks. You don't reach <code>eof()</code> until you try to perform a read).</p>
","670","<c++><visual-studio><aes><crypto++>","1","0","1","2018-03-28 16:59:48","","2","","608639","","2018-03-28 04:16:37","2018-03-25 17:18:20",""
"39770259","Getting warning while compiling using cryptopp library","<p>I have a encrypted file using AES algorithm in CBC mode. I have key from database.
I am trying to compile below code using cryptopp 5.6.2 library. It gets compiled without -Wall flag but when I enable that flag below warnings appears.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;exception&gt;
#include &lt;sstream&gt;

#include ""cryptopp/modes.h""
#include ""cryptopp/aes.h""
#include ""cryptopp/filters.h""
#include ""cryptopp/cryptlib.h""
#include ""cryptopp/hex.h""
#include ""cryptopp/filters.h""
#include ""cryptopp/aes.h""
#include ""cryptopp/ccm.h""
#include ""cryptopp/files.h""

using namespace std;
using namespace CryptoPP;

int main(int argc, char* argv[])
{
    try
    {
        byte no[16]  ;
        byte noiv[16];
        std::string out;
        std::string fileName(""./encrypted.txt"");
        CBC_Mode&lt;AES&gt;::Decryption d;
        d.SetKeyWithIV(no, sizeof(no), noiv);
        CryptoPP::FileSource(fileName.c_str(), true, new StreamTransformationFilter(d, new CryptoPP::FileSink(""decrypted.txt""), CryptoPP::StreamTransformationFilter::PKCS_PADDING));
    }
    catch (CryptoPP::Exception&amp; e)
    {
        std::cout &lt;&lt; std::endl &lt;&lt; e.what() &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>Gets below errors on enabling -Wall flag</p>

<pre><code>In file included from ./cryptopp_5.6.2/include/cryptopp/modes.h:12,
                 from poc.cpp:6:
./cryptopp_5.6.2/include/cryptopp/algparam.h: In constructor ‘CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter(const T&amp;, bool) [with T = std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;]’:
./cryptopp_5.6.2/include/cryptopp/filters.h:793:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:26: warning: unused variable ‘cryptopp_assert_26’
In file included from ./cryptopp_5.6.2/include/cryptopp/modes.h:12,
                 from poc.cpp:6:
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = std::ostream*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = const wchar_t*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = const char*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = std::istream*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = const int*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = unsigned char]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = const byte*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/algparam.h: In member function ‘void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void*) const [with T = CryptoPP::RandomNumberGenerator*]’:
poc.cpp:36:   instantiated from here
./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
./cryptopp_5.6.2/include/cryptopp/misc.h: At global scope:
./cryptopp_5.6.2/include/cryptopp/misc.h:548: warning: ‘std::string CryptoPP::StringNarrow(const wchar_t*, bool)’ defined but not used
</code></pre>
","<blockquote>
  <p>below code using cryptopp 5.6.2 library...</p>
</blockquote>

<p>5.6.2 is kind of old. We are getting ready to release Crypto++ 5.6.5.</p>

<hr>

<blockquote>
  <p>It gets compiled without -Wall flag but when I enable that flag below warnings appears.</p>

<pre><code>./cryptopp_5.6.2/include/cryptopp/algparam.h:322: warning: unused variable ‘p’
</code></pre>
</blockquote>

<p>The warning was cleared about 18 months ago. It was first seen in a release at Crypto++ 5.6.3. Also see <a href=""https://github.com/weidai11/cryptopp/commit/5f25c7363534656ce6e1ecac63ca694e6d4ba7d6"" rel=""nofollow"">Commit 5f25c736: Add CRYPTOPP_UNUSED to help supress unused variable warnings</a>.</p>

<hr>

<blockquote>
  <p>Gets below errors on enabling -Wall flag ...</p>
</blockquote>

<p>Crypto++ is now clean at <code>-Wall -Wextra</code> under GCC and compatibles. Its also clean under MSC with <code>/W4</code>. Finally, its clean under Solaris' SunCC.</p>

<p>If interested, here is the release process and security gates we are required to pass through for a release (from <a href=""http://cryptopp.com/wiki/Release_process#Analysis_Tools"" rel=""nofollow"">Release Process | Analysis Tools</a>):</p>

<ul>
<li>Compiler Warnings</li>
<li>Clang and GCC Sanitizers</li>
<li>Valgrind</li>
<li>Enterprise Analysis</li>
<li>Coverity</li>
</ul>

<p>Right now, Coverity is holding-up 5.6.5. We recently expanded Coverity coverage to <a href=""http://cryptopp.com/wiki/Coverity_Scan"" rel=""nofollow"">Linux, Unix, OS X, and Windows</a> (previously it was Linux only). Coverity is producing findings and we are working through them. </p>
","668","<c++><c++11><crypto++>","1","1","1","2016-09-30 18:05:18","","4","","2830652","","2016-09-29 13:37:34","2016-09-29 12:23:30",""
"16843787","Use Crypto++ in personal project on Windows","<p>I have a small project to create in a course at my University that requires using the Crypto++ libraries. The requirement is that we don't include the whole source code/binary files of Crypto++ but link it from an outside directory. (E.g. C:\cryptopp). This is because the reviewer will link his/her own directory to asses my code.</p>

<p>Now, I am really bad at creating Makefiles and don't understand the content of them completely.</p>

<p>I am using MinGW on Windows 7.</p>

<p>So my main question would be, what do I need to write in the Makefile to use Crypto++ in my project from an outside folder?</p>
","<p>Suppose you have the following makefile:</p>

<pre><code>unit.exe: unit.o
  g++ unit.o -o unit.exe

unit.o: unit.cc unit.h
  g++ -c unit.cc -o unit.o
</code></pre>

<p>In order to modify it to use an external library you have to use the GCC <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.7.3/gcc/Directory-Options.html#Directory-Options"" rel=""nofollow"">-I</a> and <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.7.3/gcc/Link-Options.html#Link-Options"" rel=""nofollow"">-L</a> options:</p>

<pre><code>unit.exe: unit.o
  g++ unit.o -o unit.exe -L /c/cryptopp -l ws2_32 -l cryptopp

unit.o: unit.cc unit.h
  g++ -I /c/cryptopp -c unit.cc -o unit.o
</code></pre>

<p>Often a makefile would contain a variable that is passed to the compiler and a variable that is passed to the linker, for example <a href=""http://en.wikipedia.org/wiki/CFLAGS"" rel=""nofollow"">CFLAGS</a> and LDFLAGS. If that is the case, then it might be easier to add the ""-I"" and ""L"" options to the compiler and linker variables.</p>

<p>See also <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">here</a> for a way to comiple CryptoPP.</p>
","665","<c++><windows-7><makefile><mingw><crypto++>","1","1","1","2018-08-29 01:16:14","16844096","0","","608639","","2018-08-29 01:16:14","2013-05-30 18:51:34",""
"5943552","Base64Decode: How to get the data","<p>This seems like it would be an easy question, but crypto++ seems to be designed in a funky, ""as obtuse as possible"" sorta way, so I'm wondering...</p>

<p>How can I get the binary data out of the CryptoPP::Base64Decode object? Assuming I don't want to write it to a file, or encode it some other way, how do I just get at the actual binary data?</p>

<p>Edit: figured it out; not sure how to close/delete it, anyone? What's the appropriate thing for me to do here now?</p>
","<p>Nevermind, figured it out. For reference, I wanted to get the MaxRetrievable and Get methods of the BufferedTransformation subclass.</p>
","664","<c++><crypto++>","1","1","2","2015-02-16 10:42:14","","1","","608639","","2015-02-16 10:42:14","2011-05-09 23:16:07",""
"5943552","Base64Decode: How to get the data","<p>This seems like it would be an easy question, but crypto++ seems to be designed in a funky, ""as obtuse as possible"" sorta way, so I'm wondering...</p>

<p>How can I get the binary data out of the CryptoPP::Base64Decode object? Assuming I don't want to write it to a file, or encode it some other way, how do I just get at the actual binary data?</p>

<p>Edit: figured it out; not sure how to close/delete it, anyone? What's the appropriate thing for me to do here now?</p>
","<blockquote>
  <p>This seems like it would be an easy question, but crypto++ seems to be
  designed in a funky, ""as obtuse as possible"" sorta way, so I'm wondering...</p>
</blockquote>

<p>Its not an easy question if you are not familiar with the Crypto++ design. There's actually two designs at work.</p>

<p>First is a classical Update/Final. Its implemented in Crypto++ with <code>Put</code> and <code>Get</code> and friends.</p>

<p>The second is a pipleline design. That's where data flows from source to sink, and you'll see it as, for example:</p>

<pre><code>FileSource fs( ""Hello World"", true /*pumpAll*/
    new HexEncoder( e,
        new FileSink( ""encoded.txt"" )     
); // FileSource
</code></pre>

<p>The pipeline is equivalent to Unix commands:</p>

<pre><code>echo ""Hello World"" | base64 &gt;&gt; encoded.txt
</code></pre>

<p>The pipeline generalizes to:</p>

<pre><code>Source -&gt; Filter -&gt; Filter -&gt; ... -&gt; Filter -&gt; Sink
</code></pre>

<p>Internally, Source will call <code>Put</code> on the first filter; the first filter will transform the data and call <code>Put</code> on the second filter, and so on. The last filter will call <code>Put</code> on the Sink. More correctly, the Source and Filters will call <code>Put2</code>, but that's an implementation detail.</p>

<p>If there is no Sink:</p>

<pre><code>Source -&gt; Filter -&gt; NULL
</code></pre>

<p>then the Filter will internally buffer the transformed data. You can use <code>Get</code>, <code>GetWord16</code>, <code>GetWord32</code>, <code>MaxRetrievable</code>, <code>AnyRetrievable</code>, etc to extract data from the filter or sink.</p>

<p><code>Put</code>, <code>Get</code>, <code>MaxRetrievable</code> and friends are part of the <code>BufferedTransformation</code> interface, and that's an interface that all filters and sinks implement (there's really no need for a source to implement it). If a class does not provide <code>Put</code>, <code>Get</code> and friends, then its not a filter or sink. Documentation for the class is located at <a href=""http://www.cryptopp.com/docs/ref/class_buffered_transformation.html"" rel=""nofollow"">BufferedTransformation Class Reference</a>.</p>

<p>There's a lot more to it, including blocking and pumping data in blocks, but its not really needed for a Base64 filter or object. The <code>pumpAll</code> in the above example means to push all data at once.</p>
","664","<c++><crypto++>","1","0","2","2015-02-16 10:42:14","","1","","608639","","2015-02-16 10:42:14","2011-05-09 23:16:07",""
"34169937","Do I need to use CryptoPP DLL with Qt?","<p>So on <a href=""https://www.cryptopp.com/wiki/Visual_Studio"" rel=""nofollow"">official Crypto++ Visual Studio Wiki page</a> and <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow"">in this tutorial</a> it is mentioned, you must use CryptoPP as DLL when working with Qt.</p>

<p>But is this really true? Can't I just compile cryptlib as /MD and /MDd into <code>cryptlib.lib</code>, instead of <code>cryptopp.dll</code> and use that with my project? Why would I need to include external DLL?</p>

<p>I am struggling with compiling CryptoPP as DLL, so I would like to know if I am not just wasting my time and there is a way to use cryptlib.lib directly (compiled with correct Runtime /MD or /MDd)</p>

<p>Thanks</p>
","<blockquote>
  <p>Do I need to use CryptoPP DLL with Qt?</p>
</blockquote>

<p>No. But libraries like QT and MFC use dynamic C++ rumtimes, so you will need to switch to dynamic runtimes for Crypto++.</p>

<hr>

<blockquote>
  <p>But is this really true? Can't I just compile cryptlib as /MD and /MDd into cryptlib.lib, instead of cryptopp.dll and use that with my project? Why would I need to include external DLL?</p>
</blockquote>

<p>Yes. Just change to the dynamic C++ runtime library, and then link to the static library.</p>

<hr>

<blockquote>
  <p>I am struggling with compiling CryptoPP as DLL</p>
</blockquote>

<p>Yeah, its a pain. Folks should avoid it unless they have to use it.</p>

<hr>

<blockquote>
  <p>Why would anyone use dll other than the fips signed (which is already compiled)</p>
</blockquote>

<p>Those doing business in US Federal and US DoD <em>must</em> use the FIPS version. They have no choice. The OMB does not allow agencies to use anything other than validated cryptography.</p>

<p>The DLL is special purpose. <em>If</em> you want the FIPS DLL, then you can only use it on Windows 2000 SP1, Windows XP SP3 and Windows Server 2003 SP1.</p>

<p>The DLL <em>only</em> has approved algorithms. Its missing a bunch of stuff, like utilities (i.e., <code>HexEncoder</code>) and non-approved algorithms (i.e., <code>MD5</code>, <code>Whirlpool</code>, <code>Camellia</code>, etc).</p>

<p>If you want to supplement the DLL, then you have to add the missing algorithms from the static LIB. As you can imagine, that's going to be a pain point.</p>

<p>The signature for integrity assurances is provided by SHA-1/HMAC using the static key <code>{0x47, 0x1E, 0x33, 0x96, 0x65, 0xB1, 0x6A, 0xED, 0x0B, 0xF8, 0x6B, 0xFD, 0x01, 0x65, 0x05, 0xCC}</code>. Anyone can tamper with it, and create valid signatures over it.</p>

<p>We created a page on the topic. You can find it on the Crypto++ wiki at <a href=""https://cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow"">FIPS DLL</a>. It provides things like implementation details, and discusses things like Operational Environments.</p>
","661","<c++><qt><dll><compilation><crypto++>","3","1","1","2015-12-11 19:39:05","34192492","0","","","","","2015-12-09 02:50:31",""
"45612083","Avoid newline when using Crypto++ Base64 encoder","<p>Im trying to generate the SHA512 of a base64 encoded string with Crypto++.</p>

<p>My sample input is: <code>test123</code></p>

<p>Base64: <code>dGVzdDEyMw==</code></p>

<p>SHA512 of B64 (expected): </p>

<pre><code>f78fa0aa79abd53b8181c5d21bdeb882bf45cd462a6e6e1b5043417de1800626
ed2a51b1a56626e9b9558da66a2f609d31db76bd88e80afbb7b03cda518b207d
</code></pre>

<p>SHA512 of B64 (not expected): <code>9f012fff26c89f2650f7446a37e80ba6466d69ffc77bb9ffc8c09ab779b24a23bb6a2f3c28512668ebca8628303ab5a31067d930cd1af60c745a2c34e5b4b1d2</code></p>

<p>SHA512 calculation:</p>

<pre><code>byte *digest = new byte[CryptoPP::SHA512::DIGESTSIZE];
std::string encoded;
std::string test(""test123"");

CryptoPP::StringSource ss((byte*)test.data(), test.size(), true, new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded))); // StringSource

// Calculate hash
CryptoPP::SHA512().CalculateDigest(digest, (byte*)encoded.data(), encoded.size());
</code></pre>

<p>If i leave out base64 and calculate the SHA512 directly, i get the correct hash. Therefore the calculation can't be completely wrong.</p>

<p>But why doesn't it work with base64?</p>
","<blockquote>
  <p>SHA512 of B64 (correct):</p>

<pre><code>f78fa0aa79abd53b8181c5d21bdeb882bf45cd462a6e6e1b5043417de1800626
ed2a51b1a56626e9b9558da66a2f609d31db76bd88e80afbb7b03cda518b207d
</code></pre>
</blockquote>

<p>It sounds like whatever is calculating this hash is producing unexpected results. Its probably due to a newline, missing padding, etc.</p>

<p>I can reproduce it with the following. It appears to be a newline issue.</p>

<pre class=""lang-none prettyprint-override""><code>$ echo 'dGVzdDEyMw' | sha512sum
9c00af94b3dc300fab0fd1fdad7e9eeb20bb0bdff6e6c75d9072e241976b0cc8
56f2a1d355c35f29c3d354895565f971721f58cbb20f0608f57a882b0afb412c

$ echo -n 'dGVzdDEyMw' | sha512sum
c20144e3136f57d5aae2374aa48759911364bb44167fe642cc8b4da140396584
04ce9e2f3dfc9bd69d69cfbb449384e6ea5377c39a07fdb2c2920d78a2a56a80

$ echo  'dGVzdDEyMw==' | sha512sum
9f012fff26c89f2650f7446a37e80ba6466d69ffc77bb9ffc8c09ab779b24a23
bb6a2f3c28512668ebca8628303ab5a31067d930cd1af60c745a2c34e5b4b1d2

$ echo -n 'dGVzdDEyMw==' | sha512sum
f78fa0aa79abd53b8181c5d21bdeb882bf45cd462a6e6e1b5043417de1800626
ed2a51b1a56626e9b9558da66a2f609d31db76bd88e80afbb7b03cda518b207d
</code></pre>

<p>Here is the constructor for <a href=""https://www.cryptopp.com/wiki/Base64Encoder"" rel=""nofollow noreferrer""><code>Base64Encoder</code></a>. You can find the docs at either <a href=""https://www.cryptopp.com/docs/ref/"" rel=""nofollow noreferrer"">the manual</a> or <a href=""https://www.cryptopp.com/wiki/Base64Encoder"" rel=""nofollow noreferrer"">the wiki</a>.</p>

<pre class=""lang-cxx prettyprint-override""><code>Base64Encoder(BufferedTransformation *attachment = NULL,
              bool insertLineBreaks = true,
              int maxLineLength = 72)
</code></pre>

<p>You should use <code>insertLineBreaks = false</code>. Maybe something like:</p>

<pre><code>StringSource ss((byte*)test.data(), test.size(), true,
    new Base64Encoder(new StringSink(encoded), false /* Newline */));
</code></pre>

<p>Since you are using a <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipeline</a>, you can do it in one shot with the following. I unrolled all the <code>new</code>'s to help with visualization as data flows from the source to the sink.</p>

<pre class=""lang-cxx prettyprint-override""><code>SHA512 hash;
StringSource ss(test /* std::string */, true,
    new Base64Encoder(
        new HashFilter(hash,
            new StringSink(encoded)
        ),
    false /* Newline */)
);
</code></pre>
","660","<c++><base64><crypto++><sha512>","1","2","1","2017-08-11 03:56:20","45626694","0","1","608639","","2017-08-11 03:54:55","2017-08-10 11:10:56",""
"43018107","How to encrypt and decrypt with RC6 using Crypto++","<p>I want to encrypt and decrypt strings with RC6 but I don't understand how
it works with the Crypto++ library, could you give me a snippet ?</p>

<p>Thanks you !</p>
","<p>Here's a snippet of <a href=""https://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">code from the Crypto++ website</a> demonstrating how to use the library to encrypt a string using AES (where as jww had pointed out, ""RC6 is one of the AES candidates"" and the snippet should be usable as a starting point for RC6 as well):</p>

<pre><code>byte key[AES::DEFAULT_KEYLENGTH], iv[AES::BLOCKSIZE];
string plainText;

// ... populate key, iv, plainText here

string cipher;
StringSink* sink = new StringSink(cipher);
Base64Encoder* base64_enc = new Base64Encoder(sink);
CBC_Mode&lt;AES&gt;::Encryption aes(key, sizeof(key), iv);
StreamTransformationFilter* aes_enc = new StreamTransformationFilter(aes, base64_enc);
StringSource source(plainText, true, aes_enc);
</code></pre>

<p>I found this information when internet searching for sample code for the Crypto++ library. Admittedly, it wasn't as straight forward for me to find as I had expected.</p>

<p>The Related sidebar on StackOverflow is pointing out other pages that I believe can also help, like the Q &amp; A for <a href=""https://stackoverflow.com/questions/42817362/encrypt-decrypt-byte-array-crypto"">Encrypt/Decrypt byte array Crypto++</a>.</p>

<p><strong>Update:</strong> An update just showed up today (March 26, 2017) at <a href=""https://www.cryptopp.com/wiki/RC6"" rel=""nofollow noreferrer"">the RC6 web page at the Crypto++ wiki site</a>. It's got RC6 specific code there now which looks like exactly what you need.</p>
","646","<c++><encryption><crypto++><block-cipher>","-2","2","1","2017-03-27 01:01:58","","3","","608639","","2017-03-26 21:51:49","2017-03-25 15:18:23",""
"36532431","What is wrong with this sha 256 function?","<p>I'm starting to use crypto++ lib and maybe I have some misconceptions. </p>

<p>I don't realize why the following code produces a bad sha 256</p>

<pre><code># include &lt;string&gt;
# include &lt;iostream&gt;
# include ""cryptopp/cryptlib.h""
# include &lt;cryptopp/sha.h&gt;
# include &lt;cryptopp/hex.h&gt;

using namespace std;

string sha256_hex(const string &amp; str)
{
  byte digest[CryptoPP::SHA256::DIGESTSIZE];
  CryptoPP::SHA256().CalculateDigest(digest, (byte*) &amp;str[0], str.size());

  string ret;
  CryptoPP::HexEncoder encoder;
  encoder.Attach(new CryptoPP::StringSink(ret));
  encoder.Put(digest, sizeof(digest));
  encoder.MessageEnd();

  return ret;
}

int main(int argc, char *argv[])
{
  auto sha256 = sha256_hex(argv[1]);
  cout &lt;&lt; ""str     = "" &lt;&lt; argv[1] &lt;&lt; endl
       &lt;&lt; ""sha 256 = "" &lt;&lt; sha256_hex(sha256) &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>The following command</p>

<pre><code>./test-sha256 hello
</code></pre>

<p>produces the following output</p>

<pre><code>str     = hello
sha 256 = DD9F20FF4F1DD817C567DE6C16915DC0A731A4DF51088F55CEF4CD2F89CF9620
</code></pre>

<p>However according to this online calculator <a href=""http://www.xorbin.com/tools/sha256-hash-calculator"" rel=""nofollow"">enter link description here</a>, the correct sha 256 for <code>""hello""</code> would be <code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code>.</p>

<p>So my question is what am I doing wrong? </p>

<p>I have an additional question: how and when the memory used by the <code>StringSink</code> object should be freed?</p>

<p>Thanks in advance</p>
","<p>Most probably, I see the problem is here:</p>

<pre><code>CryptoPP::SHA256().CalculateDigest(digest, (byte*) &amp;str[0], str.size());
</code></pre>

<p>You better pass <code>str.c_str()</code>. Use debugger to see what exactly is being passed - does it translate to <code>hello</code> ?</p>
","639","<c++><sha><crypto++>","1","1","3","2016-04-11 06:16:31","36532611","1","","","","","2016-04-10 16:33:40",""
"36532431","What is wrong with this sha 256 function?","<p>I'm starting to use crypto++ lib and maybe I have some misconceptions. </p>

<p>I don't realize why the following code produces a bad sha 256</p>

<pre><code># include &lt;string&gt;
# include &lt;iostream&gt;
# include ""cryptopp/cryptlib.h""
# include &lt;cryptopp/sha.h&gt;
# include &lt;cryptopp/hex.h&gt;

using namespace std;

string sha256_hex(const string &amp; str)
{
  byte digest[CryptoPP::SHA256::DIGESTSIZE];
  CryptoPP::SHA256().CalculateDigest(digest, (byte*) &amp;str[0], str.size());

  string ret;
  CryptoPP::HexEncoder encoder;
  encoder.Attach(new CryptoPP::StringSink(ret));
  encoder.Put(digest, sizeof(digest));
  encoder.MessageEnd();

  return ret;
}

int main(int argc, char *argv[])
{
  auto sha256 = sha256_hex(argv[1]);
  cout &lt;&lt; ""str     = "" &lt;&lt; argv[1] &lt;&lt; endl
       &lt;&lt; ""sha 256 = "" &lt;&lt; sha256_hex(sha256) &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>The following command</p>

<pre><code>./test-sha256 hello
</code></pre>

<p>produces the following output</p>

<pre><code>str     = hello
sha 256 = DD9F20FF4F1DD817C567DE6C16915DC0A731A4DF51088F55CEF4CD2F89CF9620
</code></pre>

<p>However according to this online calculator <a href=""http://www.xorbin.com/tools/sha256-hash-calculator"" rel=""nofollow"">enter link description here</a>, the correct sha 256 for <code>""hello""</code> would be <code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code>.</p>

<p>So my question is what am I doing wrong? </p>

<p>I have an additional question: how and when the memory used by the <code>StringSink</code> object should be freed?</p>

<p>Thanks in advance</p>
","<p>Aren't you computing the hash of the hash here? You call <code>sha256_hex</code> twice, once with <code>argv[1]</code> as argument, and once with <code>sha256</code> itself as argument.</p>
","639","<c++><sha><crypto++>","1","5","3","2016-04-11 06:16:31","36532611","1","","","","","2016-04-10 16:33:40",""
"36532431","What is wrong with this sha 256 function?","<p>I'm starting to use crypto++ lib and maybe I have some misconceptions. </p>

<p>I don't realize why the following code produces a bad sha 256</p>

<pre><code># include &lt;string&gt;
# include &lt;iostream&gt;
# include ""cryptopp/cryptlib.h""
# include &lt;cryptopp/sha.h&gt;
# include &lt;cryptopp/hex.h&gt;

using namespace std;

string sha256_hex(const string &amp; str)
{
  byte digest[CryptoPP::SHA256::DIGESTSIZE];
  CryptoPP::SHA256().CalculateDigest(digest, (byte*) &amp;str[0], str.size());

  string ret;
  CryptoPP::HexEncoder encoder;
  encoder.Attach(new CryptoPP::StringSink(ret));
  encoder.Put(digest, sizeof(digest));
  encoder.MessageEnd();

  return ret;
}

int main(int argc, char *argv[])
{
  auto sha256 = sha256_hex(argv[1]);
  cout &lt;&lt; ""str     = "" &lt;&lt; argv[1] &lt;&lt; endl
       &lt;&lt; ""sha 256 = "" &lt;&lt; sha256_hex(sha256) &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>The following command</p>

<pre><code>./test-sha256 hello
</code></pre>

<p>produces the following output</p>

<pre><code>str     = hello
sha 256 = DD9F20FF4F1DD817C567DE6C16915DC0A731A4DF51088F55CEF4CD2F89CF9620
</code></pre>

<p>However according to this online calculator <a href=""http://www.xorbin.com/tools/sha256-hash-calculator"" rel=""nofollow"">enter link description here</a>, the correct sha 256 for <code>""hello""</code> would be <code>2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824</code>.</p>

<p>So my question is what am I doing wrong? </p>

<p>I have an additional question: how and when the memory used by the <code>StringSink</code> object should be freed?</p>

<p>Thanks in advance</p>
","<p>As for the second part of the question:</p>

<p>In the Crypto++ <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Pipelining system</a>, filters and sinks are owned by the object they are attached to. They are automatically deleted by the destructor of that object.</p>

<p>And from ""Important Usage Notes"" in <a href=""http://github.com/weidai11/cryptopp/blob/master/Readme.txt"" rel=""nofollow"">ReadMe.txt</a>:</p>

<blockquote>
  <p>If a constructor for A takes a pointer to an object B (except primitive types such as int and char), then A owns B and will delete B at A's destruction. If a constructor for A takes a reference to an object B, then the caller retains ownership of B and should not destroy it until A no longer needs it.</p>
</blockquote>
","639","<c++><sha><crypto++>","1","2","3","2016-04-11 06:16:31","36532611","1","","","","","2016-04-10 16:33:40",""
"19113633","How to perform unpadding after decryption of stream using CryptoPP","<p>I've got the stream to decrypt. I divide it into blocks and pass each block to the method below. The data I need to decrypt is encrypted by 16 - bytes blocks and if the last block is less than 16, then all the rest bytes are filled by padding. Then in the moment of decryption I'm getting my last block result as the value including these additional padding bytes. How can I determine the length of original data and return only it or determine the padding bytes and remove them, considering different paddings could be used?</p>

<pre><code>void SymmetricAlgorithm::Decrypt(byte* buffer, size_t dataBytesSize) {    
     MeterFilter meter(new ArraySink(buffer, dataBytesSize));
     CBC_Mode&lt;CryptoPP::Rijndael&gt;::Decryption dec(&amp;Key.front(), Key.size(), &amp;IV.front());
        StreamTransformationFilter* filter = new StreamTransformationFilter(dec, new Redirector(meter), PKCS_PADDING);
        ArraySource(buffer, dataBytesSize, true, filter);
        dec.Resynchronize(&amp;IV.front());
}
</code></pre>

<p>Now I'm trying with PKCS_PADDING and Rijndael, but in general I might need work with any algorithm and any padding.</p>
","<blockquote>
  <p>I divide it into blocks and pass each block to the method below</p>
</blockquote>

<p>In this case, you might consider calling <code>ProcessBlock</code> directly:</p>

<pre><code>CBC_Mode&lt;Rijndael&gt;::Decryption dec(...);

// Assume 'b' is a 16-byte block
dec.ProcessBlock(b);
</code></pre>

<p>The block is processed in place, so its destructive. You will also be responsible for processing the last block, including the removal of padding.</p>

<p>By blocking and removing padding, you are doing the work of the <code>StreamTransformationFilter</code> (and friends).</p>
","635","<c++><encryption><byte><padding><crypto++>","1","1","2","2013-10-03 13:22:53","19133085","0","1","2416510","","2013-10-01 10:26:55","2013-10-01 10:17:06",""
"19113633","How to perform unpadding after decryption of stream using CryptoPP","<p>I've got the stream to decrypt. I divide it into blocks and pass each block to the method below. The data I need to decrypt is encrypted by 16 - bytes blocks and if the last block is less than 16, then all the rest bytes are filled by padding. Then in the moment of decryption I'm getting my last block result as the value including these additional padding bytes. How can I determine the length of original data and return only it or determine the padding bytes and remove them, considering different paddings could be used?</p>

<pre><code>void SymmetricAlgorithm::Decrypt(byte* buffer, size_t dataBytesSize) {    
     MeterFilter meter(new ArraySink(buffer, dataBytesSize));
     CBC_Mode&lt;CryptoPP::Rijndael&gt;::Decryption dec(&amp;Key.front(), Key.size(), &amp;IV.front());
        StreamTransformationFilter* filter = new StreamTransformationFilter(dec, new Redirector(meter), PKCS_PADDING);
        ArraySource(buffer, dataBytesSize, true, filter);
        dec.Resynchronize(&amp;IV.front());
}
</code></pre>

<p>Now I'm trying with PKCS_PADDING and Rijndael, but in general I might need work with any algorithm and any padding.</p>
","<p>As it happens, I found what I needed occasionally in the example from this <a href=""https://stackoverflow.com/questions/16001214/inplace-aes-cbc-ecb-mode-encrypting-decrypting-using-crypto"">question</a>.
Appreciate your help, Gabriel L., but I didn't want make my method not to use padding at all. Sorry for unclear explanations, I wanted to extract plain data from decrypted data, which includes padding symbols. And the bold row in this code shows how to find out plain data bytes count.</p>

<pre><code>void SymmetricAlgorithm::Decrypt(byte* buffer, size_t dataBytesSize) {    
 MeterFilter meter(new ArraySink(buffer, dataBytesSize));
 CBC_Mode&lt;CryptoPP::Rijndael&gt;::Decryption dec(&amp;Key.front(), Key.size(), &amp;IV.front());
    StreamTransformationFilter* filter = new StreamTransformationFilter(dec, new Redirector(meter), PKCS_PADDING);
    ArraySource(buffer, dataBytesSize, true, filter);
    int t = meter.GetTotalBytes(); //plain data bytes count
    dec.Resynchronize(&amp;IV.front());
}
</code></pre>
","635","<c++><encryption><byte><padding><crypto++>","1","0","2","2013-10-03 13:22:53","19133085","0","1","2416510","","2013-10-01 10:26:55","2013-10-01 10:17:06",""
"18513719","Library build error on Android","<p>After more than two days of building errors, I give up... </p>

<p>I followed this good tutorial here: <a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a> . 
It compiles, and the ""cryptest.exe"" passes all tests. So, I guess that the static library ""libcryptopp.a"" is OK. </p>

<p>So, I move the ""libcryptopp.a"" and all the headers files in the Android project. </p>

<p>But when it comes to the building step (as often... :-) ), there are compilation errors, like: </p>

<pre><code>    .../Classes/libs/android/libcryptopp.a(files.o): in function std::basic_filebuf&lt;char, std::char_traits&lt;char&gt; &gt;::_M_unshift() 
    [clone .part.40]:/Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/stlport/stlport/stl/_fstream.h:322: 
    error: undefined reference to 'std::_Filebuf_base::_M_write(char*, int)' 

    and ~50 others ... 
</code></pre>

<p>""undefined reference to"" errors usually mean that a library is not present, but ""libcryptopp.a"" is correct here. So I expect that something is missing in the ""Android.mk"": </p>

<pre><code>    include $(CLEAR_VARS) 
    LOCAL_MODULE    := cryptopp-prebuilt 
    LOCAL_SRC_FILES := ...narf/Classes/libs/android/libcryptopp. 
    include $(PREBUILT_STATIC_LIBRARY) 


    include $(CLEAR_VARS) 
    /* 
       here are included other library 
    */ 

    LOCAL_STATIC_LIBRARIES := cryptopp-prebuilt                 
    include $(BUILD_SHARED_LIBRARY) 
</code></pre>

<p>After tries with ""APP_STL := stlport_static/dynamic"", ""APP_STL := gnustl_static/dynamic"", etc... no more chances. </p>

<p>Being really not a building/compilation expert (even worse on Android), can somebody help me. 
Thank you very much! </p>
","<p>Ok. It is working now!</p>

<p>So the linking of ""libcryptopp.a"" is not working on my Android project with ""stlport"" but only with ""gnustl_static"". Perhaps because of others include like ""cocosd2-x"". </p>

<p>So following the tuto ""<a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a>"" you must change the script ""setenv-android.sh"" to have a result like this:</p>

<pre><code>    ANDROID_STL_INC: /Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/gnu-libstdc++/4.6/include/
    ANDROID_STL_LIB: /Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/libgnustl_static.a
</code></pre>

<p>and also move the files (just for the compilation) </p>

<pre><code>    /Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/include/bits 
</code></pre>

<p>in</p>

<pre><code>    /Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/gnu-libstdc++/4.6/include/bits
</code></pre>

<p>otherwise there are compilation problems...</p>

<p>Ouf!</p>
","634","<android><build><crypto++>","2","3","2","2015-02-16 10:46:08","18529102","0","","608639","","2015-02-16 10:46:08","2013-08-29 14:28:34",""
"18513719","Library build error on Android","<p>After more than two days of building errors, I give up... </p>

<p>I followed this good tutorial here: <a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a> . 
It compiles, and the ""cryptest.exe"" passes all tests. So, I guess that the static library ""libcryptopp.a"" is OK. </p>

<p>So, I move the ""libcryptopp.a"" and all the headers files in the Android project. </p>

<p>But when it comes to the building step (as often... :-) ), there are compilation errors, like: </p>

<pre><code>    .../Classes/libs/android/libcryptopp.a(files.o): in function std::basic_filebuf&lt;char, std::char_traits&lt;char&gt; &gt;::_M_unshift() 
    [clone .part.40]:/Users/toto/Developer/NDKs/AndroidNDKs/android-ndk-r8e/sources/cxx-stl/stlport/stlport/stl/_fstream.h:322: 
    error: undefined reference to 'std::_Filebuf_base::_M_write(char*, int)' 

    and ~50 others ... 
</code></pre>

<p>""undefined reference to"" errors usually mean that a library is not present, but ""libcryptopp.a"" is correct here. So I expect that something is missing in the ""Android.mk"": </p>

<pre><code>    include $(CLEAR_VARS) 
    LOCAL_MODULE    := cryptopp-prebuilt 
    LOCAL_SRC_FILES := ...narf/Classes/libs/android/libcryptopp. 
    include $(PREBUILT_STATIC_LIBRARY) 


    include $(CLEAR_VARS) 
    /* 
       here are included other library 
    */ 

    LOCAL_STATIC_LIBRARIES := cryptopp-prebuilt                 
    include $(BUILD_SHARED_LIBRARY) 
</code></pre>

<p>After tries with ""APP_STL := stlport_static/dynamic"", ""APP_STL := gnustl_static/dynamic"", etc... no more chances. </p>

<p>Being really not a building/compilation expert (even worse on Android), can somebody help me. 
Thank you very much! </p>
","<p>I think there are a couple problems with your answer.</p>

<p>First, when multiple libraries use the standard runtimes, you <em>must</em> use the shared object version and not the static version. That's covered in ANDROID_NDK_ROOT/docs/CPLUSPLUS-SUPPORT.html.</p>

<p>Second, you probably have a problem with library load order. Static linking makes it go away because references to <code>std::_Filebuf_base::_M_write(char*, int)</code> (and friends) are resolved at compile time, and not link/load time. To fix this, you must load <code>libstlport_shared.so</code> (or <code>libgnustl_shared.so</code>) first, and then load <code>libcryptopp.so</code> second.</p>

<p>If you load <code>libcryptopp.so</code> first, then there is no runtime loaded into the process to resolve <code>std::_Filebuf_base::_M_write(char*, int)</code> (and friends). That's covered under the wiki page with the <code>LD_PRELOAD</code> tricks.</p>

<p>To fix it in Android Java, you would perform the following. See <a href=""https://groups.google.com/forum/?fromgroups#!topic/android-ndk/F7DnfSQt8qs"" rel=""nofollow"">Is -rpath working?</a> for details.</p>

<pre><code>static {
    System.loadLibrary(""stlport_shared"");
    System.loadLibrary(""cryptopp"");
}
</code></pre>

<p>The Crypto+++ Andrid wiki page has been updated: <a href=""http://www.cryptopp.com/wiki/Android_(ommand_Line)#Android_Activity"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(ommand_Line)#Android_Activity</a>.</p>
","634","<android><build><crypto++>","2","0","2","2015-02-16 10:46:08","18529102","0","","608639","","2015-02-16 10:46:08","2013-08-29 14:28:34",""
"17546977","AES CBC decryption works, CTR does not","<p>I am trying to decrypt data using AES CBC and CTR mode. The ciphertext has been prepended with the 16 byte IV.</p>

<p>I have my ciphertext data in the following format:</p>

<pre><code>vector&lt;vector&lt;byte&gt;&gt; CBCMessages;
vector&lt;vector&lt;byte&gt;&gt; CBCKeys;
vector&lt;vector&lt;byte&gt;&gt; CTRMessages;
vector&lt;vector&lt;byte&gt;&gt; CTRKeys;
</code></pre>

<p>I am using Crypto++ to decrypt the data. This is my code:</p>

<pre><code>for (int i = 0; i &lt; CBCMessages.size(); i++)
{
    std::string decryptedtext;

    // split IV from ciphertext
    byte iv[16];
    std::copy(CBCMessages[i].begin(), CBCMessages[i].begin()+16, iv);
    CBCMessages[i].erase(CBCMessages[i].begin(), CBCMessages[i].begin()+16);

    // this block works fine
    AES::Decryption aesDecryption(&amp;(CBCKeys[i][0]), CBCKeys[i].size());
    CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );
    StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( &amp;(CBCMessages[i][0]) ), CBCMessages[i].size() );
    stfDecryptor.MessageEnd();

    std::cout &lt;&lt; decryptedtext &lt;&lt; std::endl;
}

for (int i = 0; i &lt; CTRMessages.size(); i++)
{
    std::string decryptedtext;

    // split IV from ciphertext
    byte iv[16];
    std::copy(CTRMessages[i].begin(), CTRMessages[i].begin()+16, iv);
    CTRMessages[i].erase(CTRMessages[i].begin(), CTRMessages[i].begin()+16);

    // this block produces junk
    AES::Decryption aesDecryption(&amp;(CTRKeys[i][0]), CTRKeys[i].size());
    CTR_Mode_ExternalCipher::Decryption ctrDecryption( aesDecryption, iv );
    StreamTransformationFilter stfDecryptor(ctrDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( &amp;(CTRMessages[i][0]) ), CTRMessages[i].size() );
    stfDecryptor.MessageEnd();

    std::cout &lt;&lt; decryptedtext &lt;&lt; std::endl;

    // try again with different method - this works fine
    decryptedtext.clear();
    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( &amp;(CTRKeys[i][0]), CTRKeys[i].size(), iv, 16 );
    StringSource( reinterpret_cast&lt;const unsigned char*&gt;( &amp;(CTRMessages[i][0]) ), CTRMessages[i].size(), true, 
        new StreamTransformationFilter( d,
            new StringSink( decryptedtext )
        )
    );

    std::cout &lt;&lt; decryptedtext &lt;&lt; std::endl;
}
</code></pre>

<p>As you can see, the middle block (first block for CTR decryption) produces junk output. Note that this block should actually be pretty identical to the block used for CBC decryption.</p>

<p>The block used for CBC decryption is basically copied from <a href=""http://www.cryptopp.com/fom-serve/cache/79.html"" rel=""nofollow"">this FAQ entry</a> (answer by 2005-Oct-21 10:38am jeffrey). I have then altered this block to use it for CTR decryption which is when it failed to work. The second CTR block is inspired by the ""Sample Program"" section <a href=""http://www.cryptopp.com/wiki/CTR_Mode"" rel=""nofollow"">here</a>.</p>

<p>What seems to be the problem in the first CTR code block?</p>
","<p>It is probably because</p>

<p><strong>AES::Decryption</strong> aesDecryption(&amp;(CTRKeys[i][0]), CTRKeys[i].size());</p>

<p><a href=""https://upload.wikimedia.org/wikipedia/commons/3/3c/CTR_decryption_2.svg"" rel=""nofollow"">https://upload.wikimedia.org/wikipedia/commons/3/3c/CTR_decryption_2.svg</a></p>

<p>CTR Mode needs <strong>AES::Encryption</strong> to decrypt the ciphertest</p>

<p><a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow"">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>
","633","<c++><crypto++>","2","2","1","2013-07-14 08:12:09","17637658","1","","","","","2013-07-09 11:23:17",""
"21890441","Constant time password digest compares using Crypto++","<p>I'm writing a program which hashes passwords with the <a href=""http://cryptopp.com/"" rel=""nofollow"">pbkdf2 method using cryptopp</a>.</p>

<p>I have problems with validating the passwords. I have tried to compare the output in ""length-constant"" time but it always fails and returns false. </p>

<pre><code>// a and b are std strings containing the output of the DeriveKey function

unsigned diff = a.length() ^ b.length();
for(unsigned i = 0; i &lt; a.length() &amp;&amp; i &lt; b.length(); i++)
{
      diff |= (unsigned)a[i] ^ (unsigned)b[i];
}

bool equal = diff == 0;
</code></pre>

<p>Is using ""slow equals"" even the right way to validate pbkdf2 passwords? I am a bit confused on this.</p>
","<blockquote>
  <p>I'm writing a program which hashes passwords with the pbkdf2 method using cryptopp.</p>
</blockquote>

<p>You linked to the Crypto++ main page, and not a your particular use of PBKDF. Here's <a href=""https://stackoverflow.com/a/27261798/608639"">some code</a> just in case (it uses the IETF test vectors from <a href=""http://www.ietf.org/rfc/rfc6070.txt"" rel=""nofollow noreferrer"">RFC 6070</a>):</p>

<pre><code>int main(int argc, char* argv[])
{
    byte password[] =""password"";
    size_t plen = strlen((const char*)password);

    byte salt[] = ""salt"";
    size_t slen = strlen((const char*)salt);

    int c = 1;
    byte derived[20];

    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf2;
    pbkdf2.DeriveKey(derived, sizeof(derived), 0, password, plen, salt, slen, c);

    string result;
    HexEncoder encoder(new StringSink(result));

    encoder.Put(derived, sizeof(derived));
    encoder.MessageEnd();

    cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;

    return 0;
}
</code></pre>

<hr>

<blockquote>
  <p>I have tried to compare the output in ""length-constant"" time but it always fails and returns false. </p>
</blockquote>

<p>Crypto++ has a constant time compare built in. Use <code>VerifyBufsEqual</code> from <a href=""http://www.cryptopp.com/docs/ref/misc_8h_source.html"" rel=""nofollow noreferrer""><code>misc.h</code></a>. The source is available in <a href=""http://www.cryptopp.com/docs/ref/misc_8cpp_source.html"" rel=""nofollow noreferrer""><code>misc.cpp</code></a>.</p>

<pre class=""lang-sh prettyprint-override""><code>$ cd cryptopp
$ grep -R VerifyBufsEqual *
cryptlib.cpp:   return VerifyBufsEqual(digest, digestIn, digestLength);
default.cpp:    if (!VerifyBufsEqual(check, check+BLOCKSIZE, BLOCKSIZE))
fipstest.cpp:   if (!VerifyBufsEqual(expectedModuleMac, actualMac, macSize))
fipstest.cpp:   if (VerifyBufsEqual(expectedModuleMac, actualMac, macSize))
misc.cpp:bool VerifyBufsEqual(const byte *buf, const byte *mask, size_t count)
misc.h:CRYPTOPP_DLL bool CRYPTOPP_API VerifyBufsEqual(const byte *buf1, const byte *buf2, size_t count);
pssr.cpp:   valid = VerifyBufsEqual(representative + representativeByteLength - u, hashIdentifier.first, hashIdentifier.second) &amp;&amp; valid;
pubkey.cpp: return VerifyBufsEqual(representative, computedRepresentative, computedRepresentative.size());
secblock.h:     return m_size == t.m_size &amp;&amp; VerifyBufsEqual(m_ptr, t.m_ptr, m_size*sizeof(T));
</code></pre>

<p>What I'm not clear about: <code>VerifyBufsEqual</code> is predicated upon buffers of equal lengths. I'm not sure if its OK to overlook the ""not-equal length"" case.</p>

<hr>

<p>There's also a question on the Information Stack Exchange that may be relevant: <a href=""https://security.stackexchange.com/q/9192/29925"">Timing attacks on password hashes</a>. But I'm not certain if/how it generalizes to arbitrary buffer compares.</p>

<p>The question piqued my interest in an answer to the general problem (the question has always been there): <a href=""https://security.stackexchange.com/q/77428/29925"">Constant time compares when array sizes are not equal?</a>. That should tell us if  we have the proper tools in <code>VerifyBufsEqual</code> (Crypto++), <code>CRYPTO_memcmp</code> (OpenSSL), etc.</p>
","628","<c++><hash><crypto++><pbkdf2>","2","1","1","2015-01-05 00:51:23","27771530","0","","608639","","2015-01-05 00:02:41","2014-02-19 19:29:42",""
"2798998","using crypto++ on iphone sdk with pycrypto on app engine","<p>I'm trying to encrypt http requests using crypto++ and decrypt them with pycrypto on the app engine server end. Using Arc4 encryption, I can successfully encrypt and decrypt on the iphone end but when I try decrypting on app engine, the result is garbled.  The ciphertext after encrypting on the client is the same as the text received on the server when I check logging, so if they are visually the same, why would decrypting fail? </p>

<p>I thought maybe it has something to do with the encoding of the NSString, as I find I need to call encode() on the cipher on the server end before decrypting just to avoid decrypt() failing on it attempting to encode the cipher in ascii. I have a separate post that delves a bit into this. Can anyone offer some advice?</p>

<p><a href=""https://stackoverflow.com/questions/2794942/crypto-pycrypto-with-google-app-engine"">crypto++ / pycrypto with google app engine</a></p>

<p>Update:
I have discovered that the ciphertext resulting from encrypting in C with Crypto++ is not the same as the ciphertext from encrypting in python with PyCrypto.  Could there be something I'm doing wrong with initializing the keys?  I do something like:</p>

<pre><code>    ARC4::Encryption enc(""a"");
</code></pre>

<p>in C. And in python I do:</p>

<pre><code>testobj=ARC4.new('a')
</code></pre>

<p>The %-encoded resulting cipher is different in C than in python.  I noticed that in C, I can pass a 2nd parameter for keylength, which I guessed should be 1 for ""a"", resulting in a different cipher than when putting no parameter.  The %-encoded result was still different from the python encoding, though.</p>

<p>Does anything look particularly amiss with my init perhaps?</p>
","<p>I've discovered that the problem was not with the init of either crypto impl but rather mistakenly trying to stuff the encrypted cipher text into an NSString which cant simply take raw binary data with no particular encoding. The trick was to encode the data in base64 or base16 so that it is is readable, then use unhexlify on the server end before decrypting. </p>
","627","<iphone><objective-c><google-app-engine><crypto++><pycrypto>","1","0","1","2010-05-12 03:32:27","2815965","3","","-1","","2017-05-23 12:30:45","2010-05-09 20:05:10",""
"44680703","RandomNumberGenerator requirement during RSA encryption and decryption?","<p>I'm trying to encrypt a message with a public key and decrypt the cipher with the private key using crypto++ like this in the shell:</p>

<pre><code>openssl rsautl -encrypt -inkey id_rsa.pub.pem -pubin -in message -out message.enc
</code></pre>

<p>and</p>

<pre><code>openssl rsautl -decrypt -inkey id_rsa.pem -in message.enc -out message.dec
</code></pre>

<p>Encryption/Decryption is done in separate applications. I started with the example from <a href=""https://www.cryptopp.com/wiki/RSA_Cryptography"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/RSA_Cryptography</a>.
My code:</p>

<pre><code>std::string publicEncrypt(std::string const&amp; plain) {
    auto cipher = std::string{};
    CryptoPP::RSAES_OAEP_SHA_Encryptor e(getPublicKey());
    CryptoPP::StringSource(plain, true,
        new CryptoPP::PK_EncryptorFilter(CryptoPP::NullRNG(), e,
                new CryptoPP::StringSink(cipher)));
   return cipher;
}

std::string privateDecrypt(std::string const&amp; cipher) {
    auto decrypted = std::string{};
    CryptoPP::RSAES_OAEP_SHA_Decryptor d(getPrivateKey());
    CryptoPP::StringSource(cipher, true,
        new CryptoPP::PK_DecryptorFilter(CryptoPP::NullRNG(), d,
                new CryptoPP::StringSink(decrypted)));
    return decrypted;
}
</code></pre>

<p>My questions: </p>

<ol>
<li>Why is a random number generator (RNG) needed for EncryptorFilter/DecryptorFilter?</li>
<li>The RNG has to be the same for encryption/decription, right? So, how to share between processes?</li>
</ol>

<p>Using the NullRNG() as recommended by <a href=""https://stackoverflow.com/users/608639/jww"">https://stackoverflow.com/users/608639/jww</a> in <a href=""https://stackoverflow.com/questions/17028444/unable-to-do-rsa-encrption-decryption-using-crypto-isvalidcoding-is-false"">Unable to do RSA Encrption/Decryption using Crypto++ (isValidCoding is false)</a> leads to </p>

<pre><code>std::exception NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes.
</code></pre>

<p>I guess I fundamentally miss something. Thanks for hints and advices.</p>

<p>If I use this code in a unit test with a global RNG, everything works fine.</p>
","<blockquote>
  <p>Why is a random number generator (RNG) needed for EncryptorFilter/DecryptorFilter?</p>
</blockquote>

<p>The signing and verification classes are abstract interfaces setup in <a href=""https://github.com/weidai11/cryptopp/blob/master/cryptlib.h"" rel=""nofollow noreferrer""><code>cryptlib.h</code></a>. Some cryptosystems use them, others do not. A class will specialize and can forgo using a generator. Sometimes a class does not need a generator for one of the operations. <code>NullRNG</code> can be used if not needed.</p>

<p>The reason RSA needs a RNG during public key operations is message padding. Padding is often part of the message formatting function. As @PuzzlePalace pointed out, OAEP padding is randomized and not deterministic.</p>

<p>The reason RSA needs a RNG during private key operations is blinding. For RSA and other RSA-like schemes (like Rabin-Williams), blinding is just a multiplication by a random value to mask the inversion by the priavte key to recover the original value. Later, after signing or decryption, the blinding value is removed and the result of the operation remains.</p>

<p>Related, a reason DSA or ECDSA would <strong><em>not</em></strong> need a RNG during private key operations is <a href=""https://tools.ietf.org/html/rfc6979"" rel=""nofollow noreferrer"">RFC 6979, Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)</a>. Deterministic signatures don't use randomized formatting or randomized <code>k</code>'s.</p>

<p>Another reason a RNG is needed for public key and private key operations is validation checks on the key. For example, a key might be checked to ensure a particular constraint holds, like its prime or it has a particular Jacobi symbol.</p>

<hr>

<blockquote>
  <p>The RNG has to be the same for encryption/decryption, right? So, how to share between processes?</p>
</blockquote>

<p>No, the generators can be different. The only requirements is they produce a random stream for some reasonable definition of what it means to be ""random"". Without splitting too many hairs, it means the generator produces a uniform distribution.</p>

<p>You can find more reading on Crypto++ generators at <a href=""https://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow noreferrer""><code>RandomNumberGenerator</code></a> on the wiki.</p>

<hr>

<blockquote>
  <p>If I use this code in a unit test with a global RNG, everything works fine.</p>
</blockquote>

<p>One quick word of caution... <code>GlobalRNG</code> is part of the <code>Test</code> namespace. It is defined in <a href=""https://github.com/weidai11/cryptopp/blob/master/test.cpp"" rel=""nofollow noreferrer""><code>test.cpp : 115</code></a>:</p>

<pre><code>NAMESPACE_BEGIN(CryptoPP)
NAMESPACE_BEGIN(Test)

ANONYMOUS_NAMESPACE_BEGIN
OFB_Mode&lt;AES&gt;::Encryption s_globalRNG;
NAMESPACE_END

RandomNumberGenerator &amp; GlobalRNG()
{
    return dynamic_cast&lt;RandomNumberGenerator&amp;&gt;(s_globalRNG);
}

NAMESPACE_END  // Test
NAMESPACE_END  // CryptoPP
</code></pre>

<p><code>GlobalRNG</code> is a deterministic generator and its not part of the library proper. Your code will fail to compile in the field if you depend on it.</p>

<p>Use one of the other generators discussed at <a href=""https://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow noreferrer""><code>RandomNumberGenerator</code></a> on the wiki. <code>AutoSeededRandomPool</code> is a good choice.</p>

<hr>

<blockquote>
  <p>Using the NullRNG() as recommended by <a href=""https://stackoverflow.com/users/608639/jww"">https://stackoverflow.com/users/608639/jww</a> in Unable to do RSA
  Encrption/Decryption using Crypto++ (isValidCoding is false) leads to</p>

<pre><code>std::exception NullRNG: NullRNG should only be passed to functions that don't need to generate random bytes.
</code></pre>
</blockquote>

<p>That information is incorrect. I need to fix it. Thanks.</p>

<hr>

<p>Interestingly (in a morbid sort of way), Crypto++ took <a href=""https://www.cvedetails.com/cve/CVE-2015-2141/"" rel=""nofollow noreferrer"">CVE-2015-2141</a> due to blinding in Rabin-Williams. The blinding value needed to be a quadratic residue; otherwise an attacker could prepare special messages to reveal the private key.</p>

<p>The full paper by Evgeny Sidorov is available at <a href=""https://eprint.iacr.org/2015/368.pdf"" rel=""nofollow noreferrer"">Breaking the Rabin-Williams digital signature system implementation in the Crypto++ library</a>. Here's what the new and improved inverse function looks like after fixing Sidorov's attack (from <a href=""https://github.com/weidai11/cryptopp/blob/master/rw.cpp"" rel=""nofollow noreferrer""><code>rw.cpp</code></a>):</p>

<pre><code>ModularArithmetic modn(m_n), modp(m_p), modq(m_q);
Integer r, rInv;

do
{
    // Do this in a loop for people using small numbers for testing
    r.Randomize(rng, Integer::One(), m_n - Integer::One());
    // Fix for CVE-2015-2141. Thanks to Evgeny Sidorov for reporting.
    // Squaring to satisfy Jacobi requirements suggested by Jean-Pierre Munch.
    r = modn.Square(r);
    rInv = modn.MultiplicativeInverse(r);
} while (rInv.IsZero());
</code></pre>

<p>If you read Section 6 of Sidorov's paper, he suggests generating a random <code>r</code>, and then checking the Jacobi symbol of <code>r</code> to ensure its a quadratic residue. If it was not a QR, then try a new random <code>r</code>. The triage used the method, but it showed the scheme slowed down considerably because a random <code>r</code> satisfies the condition with probability 1/16.</p>

<p>However, we knew squaring <code>r</code> ensured we satisfied Jacobi on the first try because <em>r<sup>2</sup> mod n</em> was always a quadratic residue. The squaring/multiplication only takes <code>log (exp)</code> (not <code>n log (n)</code>), so it turned out to be a significant speedup over trial and error. Before we released the next version of the library, we switched to the squaring method.</p>
","623","<c++><rsa><public-key-encryption><crypto++>","4","3","1","2017-06-23 18:23:40","","3","1","608639","","2017-06-22 03:03:06","2017-06-21 15:43:41",""
"33263734","Rebuild Crypto++ 5.6.2 for /MD release under Visual Studio 2013","<p>I want to rebuild Crypto++ via MSVC 2013 so when I am using the library to be able to build my project with /MD or /MDd, NOT /MT or /MTd, because I am using QT 5.5.1 with MSVC2013 32bit compiler and it seems if I want to make GUI interface - it is using /MD or /MDd! In <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">this</a> article in section <code>Static Versus Dynamic Linking</code> is mentioned the necessity for rebuilding (not building) and how you can see from my other <a href=""https://stackoverflow.com/questions/33254054/qt-5-5-crypto-and-gui-with-mtd"">question</a> I did it, but it is only working for debug mode. For Release mode the errors from 117 go to 53, but again the same old error occures:</p>

<blockquote>
  <p>cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for
  'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value
  'MD_DynamicRelease' in main.obj</p>
</blockquote>

<p>I am doing just what I mentioned <a href=""https://stackoverflow.com/a/33259856/5467838"">here</a></p>
","<blockquote>
  <p>I want to rebuild Crypto++ via MSVC 2013...</p>
</blockquote>

<p>OK, so the pain points here are the <a href=""http://blogs.msdn.com/b/vcblog/archive/2010/03/02/visual-studio-2010-c-project-upgrade-guide.aspx"" rel=""nofollow noreferrer"">Microsoft changes to MSBuild at 2010</a>. To make matters worse, <a href=""http://blogs.msdn.com/b/vcblog/archive/2010/02/16/project-settings-changes-with-vs2010.aspx"" rel=""nofollow noreferrer"">VCUpgrade does a rather poor job of up-converting projects</a>.</p>

<p>To help users with the upgrade process, Crypto++ provides a file called <a href=""https://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer""><code>vs2010.zip</code></a>. The archive contains the pre-converted solution file, project files and filters for Visual Studio 2010 and above. The files were released in October 2015 with a 5.6.3 Release Candidate.</p>

<p>The upgraded solution files are mostly successful. They build 20 of 24 configurations properly from the IDE. 4 of them fail on the first attempt; but the process recovers on the second attempt and builds all 24. We know its a dependency/ordering issue, but we don't know how to solve it. There's an open question on Stack Overflow at <a href=""https://stackoverflow.com/q/33191432"">How to control order of Batch Build → Build All</a>.</p>

<p>There is now a page on the subject of Visual Studio 2010 and VCUpgrade. See <a href=""https://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer"">Visual Studio</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
  <p>In this article ...</p>
</blockquote>

<p>I wrote <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">that article</a> years ago. You are on the right track.</p>

<hr>

<blockquote>
  <p>I did it, but it is only working for debug mode. For Release mode the errors from 117 go to 53, but again the same old error occures:</p>

<pre><code>cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for 'RuntimeLibrary':
value 'MT_StaticRelease' doesn't match value 'MD_DynamicRelease' in main.obj
</code></pre>
</blockquote>

<p>We added a ZIP file for you. The ZIP is a pre-converted Visual Studio 2010 solution and project files that utilizes dynamic runtime linking (<code>/MD</code> and <code>/MDd</code>). (Its not really just you since a lot of folks have asked about it over the years).</p>

<p>The solution to your problems are:</p>

<ol>
<li>download <a href=""https://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer""><code>vs2010-dynamic.zip</code></a> from the Crypto++ wiki</li>
<li>unzip over top of the exiting Crypto++ distribution files.</li>
</ol>
","617","<c++><qt><visual-studio-2013><release><crypto++>","0","1","2","2015-10-24 00:57:00","33265325","2","","-1","","2017-05-23 12:03:58","2015-10-21 15:48:23",""
"33263734","Rebuild Crypto++ 5.6.2 for /MD release under Visual Studio 2013","<p>I want to rebuild Crypto++ via MSVC 2013 so when I am using the library to be able to build my project with /MD or /MDd, NOT /MT or /MTd, because I am using QT 5.5.1 with MSVC2013 32bit compiler and it seems if I want to make GUI interface - it is using /MD or /MDd! In <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">this</a> article in section <code>Static Versus Dynamic Linking</code> is mentioned the necessity for rebuilding (not building) and how you can see from my other <a href=""https://stackoverflow.com/questions/33254054/qt-5-5-crypto-and-gui-with-mtd"">question</a> I did it, but it is only working for debug mode. For Release mode the errors from 117 go to 53, but again the same old error occures:</p>

<blockquote>
  <p>cryptlib.lib(cryptlib.obj):-1: error: LNK2038: mismatch detected for
  'RuntimeLibrary': value 'MT_StaticRelease' doesn't match value
  'MD_DynamicRelease' in main.obj</p>
</blockquote>

<p>I am doing just what I mentioned <a href=""https://stackoverflow.com/a/33259856/5467838"">here</a></p>
","<p>I am using cryptopp from source with /MD, built on vs2013 using the latest cryptopp version (5.6.2). You want to be up to date on encryption or security software, plus they may have fixed platform build issues. </p>

<p>The issues you cite sound like intermediate files from building a project with /MT set, even if it was later changed to /MD (although it is dangerously easy to forget to change the drop-down to ""all configurations"", and change just the debug settings in one project).</p>

<p>First clean solution, then make sure you change every project to /MD in [bold]all configurations[bold], and clean solution again. Now search for and delete any debug or release folders and .obj .lib .dll files, because I don't trust ""clean solution"". It can only get files it intends to build under the current settings, but the linker might find more in the link search (/verbose:lib).</p>

<p>Then rebuild all.</p>
","617","<c++><qt><visual-studio-2013><release><crypto++>","0","0","2","2015-10-24 00:57:00","33265325","2","","-1","","2017-05-23 12:03:58","2015-10-21 15:48:23",""
"53669777","Cannot compile, error: cryptlib.h: No such file or directory","<p>I've downloaded Crypto++ 7.0.0 from the official site, build a static library out of it, included cryptlib header with:</p>

<pre><code>#include ""cryptlib.h""
</code></pre>

<p>and when I try to compile my program with:</p>

<pre><code>gcc main.cpp ./cryptopp700/libcryptopp.a
</code></pre>

<p>it throws at me errors like this:</p>

<pre><code>main.cpp:2:10: fatal error: cryptlib.h: No such file or directory
 #include ""cryptlib.h""
          ^~~~~~~~~~~~
compilation terminated.
</code></pre>

<p>I also tried with:</p>

<pre><code>-L. -llibcryptopp //while moving libcryptopp.a to the same directory main.cpp is
-L./cryptopp700 -llibcryptopp
</code></pre>

<p>so I started wondering if I was doing something wrong, but as I was checking out code examples with static libraries, everything seemed to be fine.</p>

<p>Help please.</p>
","<p>Based on:</p>

<blockquote>
<pre><code>main.cpp:2:10: fatal error: cryptlib.h: No such file or directory
</code></pre>
</blockquote>

<p>And:</p>

<blockquote>
<pre><code>gcc main.cpp ./cryptopp700/libcryptopp.a
</code></pre>
</blockquote>

<p>Your directory structure looks like:</p>

<pre><code>+- Project Folder
  |
  +- main.cpp
  |
  +- cryptopp700
    |
    +- cryltib.h
    +- ...
    +- libcryptopp.a
</code></pre>

<p>You should only need to add <code>cryptopp700/</code> to your include header search path with <code>-I</code>:</p>

<pre><code>g++ main.cpp -I ./cryptopp700 ./cryptopp700/libcryptopp.a
</code></pre>

<p>Note that you should also use <strong><em>g++</em></strong> (the C++ compiler), not <strong><em>gcc</em></strong> (the C compiler).</p>

<hr>

<p>You can also install the library since it has been built. By default it installs into <code>/usr/local</code> with:</p>

<pre><code>skylake:cryptopp$ sudo make install
[sudo] password for jwalton:
install -m 644 *.h /usr/local/include/cryptopp
install -m 644 libcryptopp.a /usr/local/lib
install cryptest.exe /usr/local/bin
install -m 644 TestData/*.dat /usr/local/share/cryptopp/TestData
install -m 644 TestVectors/*.txt /usr/local/share/cryptopp/TestVectors
</code></pre>

<p>You can install into an alternate location using <code>PREFIX</code>:</p>

<pre><code>skylake:cryptopp$ sudo make install PREFIX=/opt/local
install -m 644 *.h /opt/local/include/cryptopp
install -m 644 libcryptopp.a /opt/local/lib
install cryptest.exe /opt/local/bin
install -m 644 TestData/*.dat /opt/local/share/cryptopp/TestData
install -m 644 TestVectors/*.txt /opt/local/share/cryptopp/TestVectors
</code></pre>

<p>Then, you would change you compile and link command to something like:</p>

<pre><code>g++ main.cpp -I /usr/local/include/cryptopp -o main.exe /usr/local/lib/libcryptopp.a
</code></pre>

<hr>

<p>After an install like shown below, I normally tell folks to run the self tests. Unfortunately, the won't work if all you did was a <code>make -j 4</code> or similar.</p>

<pre><code>$ make -j 4
...

$ sudo make install
[sudo] password for jwalton:
install -m 644 *.h /usr/local/include/cryptopp
install -m 644 libcryptopp.a /usr/local/lib
install cryptest.exe /usr/local/bin
install -m 644 TestData/*.dat /usr/local/share/cryptopp/TestData
install -m 644 TestVectors/*.txt /usr/local/share/cryptopp/TestVectors
</code></pre>

<p>Here's the error you would get:</p>

<pre><code>skylake:cryptopp$ cd /opt/local/bin/
skylake:bin$ ./cryptest.exe v
Using seed: 1544189072

Testing Settings...

passed:  Your machine is little endian.
passed:  Aligned data access.
passed:  sizeof(byte) == 1
passed:  sizeof(word16) == 2
passed:  sizeof(word32) == 4
passed:  sizeof(word64) == 8
passed:  sizeof(word128) == 16
passed:  sizeof(hword) == 4, sizeof(word) == 8, sizeof(dword) == 16
passed:  cacheLineSize == 64
hasSSE2 == 1, hasSSSE3 == 1, hasSSE4.1 == 1, hasSSE4.2 == 1, hasAVX == 1, hasAVX2 == 1, hasAESNI == 1, hasCLMUL == 1, hasRDRAND == 1, hasRDSEED == 1, hasSHA == 0, isP4 == 0
...

SHA validation suite running...

Exception caught: Can not open file TestVectors/sha.txt for reading
</code></pre>

<p>My thinking is things should ""just work"" for you. You should not need to worry about <code>CRYPTOPP_DATA_DIR</code> for a common case. And you certainly should not have to RTFM to make the common case work. That tells me there's a defect in our engineering process.</p>

<p>We are going to fix that now: Issue 760, <a href=""https://github.com/weidai11/cryptopp/issues/760"" rel=""nofollow noreferrer"">Make self-tests run after install by a typical user</a>. </p>
","614","<c++><gcc><static-libraries><crypto++>","1","0","1","2018-12-07 13:26:45","53670190","2","","608639","","2018-12-07 12:56:46","2018-12-07 12:41:08",""
"15203562","Crypto++ giving a compiler error in algparam.h","<p>I have the following lines in a rather large file:</p>

<pre><code>#include &lt;sha.h&gt;
#include &lt;hex.h&gt;
</code></pre>

<p>Which, when compiled, throws this compiler error:</p>

<pre><code>1&gt;d:\work\app\tools\cryptopp\algparam.h(322): error C2061: syntax error : identifier 'buffer'
1&gt;          d:\work\app\tools\cryptopp\algparam.h(321) : while compiling class template member function 'void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void *) const'
1&gt;          with
1&gt;          [
1&gt;              T=bool
1&gt;          ]
1&gt;          d:\work\app\tools\cryptopp\algparam.h(329) : see reference to class template instantiation 'CryptoPP::AlgorithmParametersTemplate&lt;T&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              T=bool
1&gt;          ]
</code></pre>

<p>I'm pretty sure I'm forgetting something, but I'm not sure what. If I don't include hex.h, I don't have any problems and I get a SHA256 hash just fine, but when I do include hex.h, the error pops up.</p>

<p><strong>Edit</strong></p>

<p>In case anyone wonders, from algparam.h of Crypto++ toolkit:</p>

<pre><code>void MoveInto(void *buffer) const //&lt;=== line 320
{
    AlgorithmParametersTemplate&lt;T&gt;* p = new(buffer)
    AlgorithmParametersTemplate&lt;T&gt;(*this);
}

CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate&lt;bool&gt;; // &lt;== line 329
</code></pre>

<p><strong>Edit</strong>: Removed unrelated code</p>
","<p>I fixed the problem by temporarily undefining <code>new</code>, which was defined as a macro to some extra debugging code.</p>

<pre><code>#pragma push_macro(""new"")
#undef new
/* #includes for Crypto++ go here */
#pragma pop_macro(""new"")
</code></pre>
","614","<c++><crypto++>","6","6","2","2015-01-19 07:05:56","16263366","8","","608639","","2015-01-19 07:05:56","2013-03-04 14:15:01",""
"15203562","Crypto++ giving a compiler error in algparam.h","<p>I have the following lines in a rather large file:</p>

<pre><code>#include &lt;sha.h&gt;
#include &lt;hex.h&gt;
</code></pre>

<p>Which, when compiled, throws this compiler error:</p>

<pre><code>1&gt;d:\work\app\tools\cryptopp\algparam.h(322): error C2061: syntax error : identifier 'buffer'
1&gt;          d:\work\app\tools\cryptopp\algparam.h(321) : while compiling class template member function 'void CryptoPP::AlgorithmParametersTemplate&lt;T&gt;::MoveInto(void *) const'
1&gt;          with
1&gt;          [
1&gt;              T=bool
1&gt;          ]
1&gt;          d:\work\app\tools\cryptopp\algparam.h(329) : see reference to class template instantiation 'CryptoPP::AlgorithmParametersTemplate&lt;T&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              T=bool
1&gt;          ]
</code></pre>

<p>I'm pretty sure I'm forgetting something, but I'm not sure what. If I don't include hex.h, I don't have any problems and I get a SHA256 hash just fine, but when I do include hex.h, the error pops up.</p>

<p><strong>Edit</strong></p>

<p>In case anyone wonders, from algparam.h of Crypto++ toolkit:</p>

<pre><code>void MoveInto(void *buffer) const //&lt;=== line 320
{
    AlgorithmParametersTemplate&lt;T&gt;* p = new(buffer)
    AlgorithmParametersTemplate&lt;T&gt;(*this);
}

CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate&lt;bool&gt;; // &lt;== line 329
</code></pre>

<p><strong>Edit</strong>: Removed unrelated code</p>
","<p>If you're including Crypto++ in a Visual Studio project with MFC support, this error might be caused by this line:</p>

<pre><code>#ifdef _DEBUG
#define new DEBUG_NEW
#endif
</code></pre>

<p>Make sure to remove it or comment it out.</p>
","614","<c++><crypto++>","6","1","2","2015-01-19 07:05:56","16263366","8","","608639","","2015-01-19 07:05:56","2013-03-04 14:15:01",""
"12628315","Convert ECIES ECP CryptoPP to JAVA","<p>I have a 202 byte key and that is used to decrypt a binary file.</p>

<pre><code>StringSource keyStr( key, Z3_KEY_LENGTH, true );
AutoSeededRandomPool rng;
ECIES&lt;ECP&gt;::Decryptor ellipticalEnc( keyStr );
unsigned char *tmpBuffer( new unsigned char[ src.Size() ] );
DecodingResult dr = ellipticalEnc.Decrypt( rng, src.Data(), src.Size(), tmpBuffer );
</code></pre>

<p>I tried to use jsafejce for this:</p>

<pre><code>PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(key);
KeyFactory factory = KeyFactory.getInstance(""EC"", ""JsafeJCE"");
PrivateKey privateKey = factory.generatePrivate(privKeySpec);
Cipher eciesDecrypter = Cipher.getInstance(""ECIES/SHA1/HMACSHA1"", ""JsafeJCE"");
</code></pre>

<p>and</p>

<pre><code>Cipher eciesDecrypter = Cipher.getInstance(""ECIESwithXOR/SHA1/HMACSHA1"", ""JsafeJCE"");
</code></pre>

<p>But with the first I get a block error, must be divided by 16, and with the second I get a mac check error.</p>

<p>Does anyone have any suggestions?</p>
","<p>Have you tried adding some empty bytes to the end of your key so that it is 208 bytes long? That might fix your block size error.</p>
","610","<java><bouncycastle><jce><elliptic-curve><crypto++>","1","0","2","2014-01-18 16:58:59","","0","2","384985","","2012-09-27 20:07:45","2012-09-27 18:57:58",""
"12628315","Convert ECIES ECP CryptoPP to JAVA","<p>I have a 202 byte key and that is used to decrypt a binary file.</p>

<pre><code>StringSource keyStr( key, Z3_KEY_LENGTH, true );
AutoSeededRandomPool rng;
ECIES&lt;ECP&gt;::Decryptor ellipticalEnc( keyStr );
unsigned char *tmpBuffer( new unsigned char[ src.Size() ] );
DecodingResult dr = ellipticalEnc.Decrypt( rng, src.Data(), src.Size(), tmpBuffer );
</code></pre>

<p>I tried to use jsafejce for this:</p>

<pre><code>PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(key);
KeyFactory factory = KeyFactory.getInstance(""EC"", ""JsafeJCE"");
PrivateKey privateKey = factory.generatePrivate(privKeySpec);
Cipher eciesDecrypter = Cipher.getInstance(""ECIES/SHA1/HMACSHA1"", ""JsafeJCE"");
</code></pre>

<p>and</p>

<pre><code>Cipher eciesDecrypter = Cipher.getInstance(""ECIESwithXOR/SHA1/HMACSHA1"", ""JsafeJCE"");
</code></pre>

<p>But with the first I get a block error, must be divided by 16, and with the second I get a mac check error.</p>

<p>Does anyone have any suggestions?</p>
","<p>Well, I don't really know what you are trying to do in your code. I'll try and answer some of the questions.</p>

<hr>

<blockquote>
  <p>Convert ECIES ECP CryptoPP to JAVA</p>
</blockquote>

<p>To get the point out of Crypto++, its about as hard as:</p>

<pre><code>// Assuming your key was DER Encoded
byte key[Z3_KEY_LENGTH] = ...;

ECIES&lt;ECP&gt;::Decryptor decryptor;
decryptor.BERDecodePublicKey(ArraySource(key, sizeof(key)).Ref(), false, sizeof(key));

const ECPPoint&amp; point = decryptor.GetPublicElement();
const Integer&amp; x = point.x;
const Integer&amp; y = point.y;
</code></pre>

<p>If your key was not DER Encoded, refer to <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow"">Keys and Formats</a> from the Crypto++ wiki. You also have the wiki page on <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Elliptic Curve Integrated Encryption Scheme</a>.</p>

<p>Java 7 provides and <a href=""http://docs.oracle.com/javase/7/docs/api/java/security/spec/ECPoint.html"" rel=""nofollow"">ECPoint class</a>, and it takes an X and Y coordinate.</p>

<hr>

<pre><code>&gt; ECIES&lt;ECP&gt;::Decryptor ellipticalEnc( keyStr );
&gt; unsigned char *tmpBuffer( new unsigned char[ src.Size() ] );
&gt; DecodingResult dr = ellipticalEnc.Decrypt( rng, src.Data(), src.Size(), tmpBuffer );
</code></pre>

<p>This does not look quite right, but you have not showed enough code.</p>

<pre><code>size_t maxLength = decryptor.MaxPlaintextLength( src.Size() );
unsigned char *tmpBuffer = new unsigned char[ maxLength ];

DecodingResult dr = ellipticalEnc.Decrypt( rng, src.Data(), src.Size(), tmpBuffer );
if( !result.isValidCoding )
    throw runtime_error(""failed to decrypt cipher text"");

unsigned char *buffer = new unsigned char[ result.messageLength ];
std::cpy(tmpBuffer, buffer, result.messageLength);
</code></pre>
","610","<java><bouncycastle><jce><elliptic-curve><crypto++>","1","1","2","2014-01-18 16:58:59","","0","2","384985","","2012-09-27 20:07:45","2012-09-27 18:57:58",""
"39210356","Passing RSA keys between Java and Crypto++ code","<p>I have a server written in java that generates RSA key pair. I want to use the private key in a C++ client for decryption.</p>

<p>This is the code I use to create the private key:</p>

<pre><code>KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
keyGen.initialize(4096);
KeyPair keyPair = keyGen.genKeyPair();

PrivateKey privateKey = keyPair.getPrivate();
byte[] encoded = privateKey.getEncoded();
String b64Encoded = Base64.getEncoder().encodeToString(encoded);
</code></pre>

<p>I then save the base64 encoded string and try to load it as a private key in my cpp code.</p>

<p>I decode the base64 string to a binary array and then use the following code to try loading the private key (encodedString should be the DER encoded data after decoding it from base64):</p>

<pre><code>ByteQueue queue;

StringSource ss(encodedString,true);
ss.TransferTo(queue);
queue.MessageEnd();

key.BERDecodePrivateKey(queue, false , queue.MaxRetrievable());
</code></pre>

<p>However this code always crashes with exception: <code>CryptoPP::BERDecodeErr</code>.</p>

<p>I believe both libraries use PKCS#8 to encode the key parameters.</p>

<p><strong>Note:</strong> When I create the key pair using crypto++ and then encode it (DER + base64) I get a 3172/3176 chars string while in my java code I get a 3168 chars string. I'm not sure whether this info helps with anything.</p>
","<p>It looks like you need to call <code>Load</code> and not <code>BERDecodePrivateKey</code>. You call <code>Load</code> when you have a key+info (like version and algorithm id); while you call <code>BERDecodePrivateKey</code> when you have just a key. The following works for me.</p>

<p><strong><em>If</em></strong> the private key is password protected, then you will need the <a href=""http://www.cryptopp.com/wiki/Pem_Pack"" rel=""nofollow"">PEM Pack</a>. The PEM Pack is a community contribution, but its maintained like the proper library.</p>

<pre class=""lang-java prettyprint-override""><code>$ cat rsa_java.java 
import java.io.*;
import java.util.*;
import java.security.*;

public class rsa_java {
    public static void main (String[] args) throws Exception {

    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
    keyGen.initialize(4096);
    KeyPair keyPair = keyGen.genKeyPair();

    PrivateKey privateKey = keyPair.getPrivate();
    byte[] encodedPrivateKey = privateKey.getEncoded();
    String b64Encoded = Base64.getEncoder().encodeToString(encodedPrivateKey);

    try (PrintStream out = new PrintStream(new FileOutputStream(""rsa_key.txt"")))
    {
        out.print(b64Encoded);
    }
}
</code></pre>

<p>And:</p>

<pre class=""lang-cxx prettyprint-override""><code>$ cat rsa_cryptopp.cxx
#include &lt;iostream&gt;
using namespace std;

#include ""cryptopp/rsa.h""
#include ""cryptopp/files.h""
#include ""cryptopp/osrng.h""
#include ""cryptopp/base64.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  try
  {
    RSA::PrivateKey key;
    FileSource fs(""rsa_key.txt"", true, new Base64Decoder);
    key.Load(fs);

    cout &lt;&lt; ""Loaded RSA key"" &lt;&lt; endl;

    AutoSeededRandomPool prng;
    key.Validate(prng, 3);

    cout &lt;&lt; ""Validated RSA key"" &lt;&lt; endl;
  }
  catch(const Exception&amp; ex)
  {
    cout &lt;&lt; ""Exception: "" &lt;&lt; ex.what() &lt;&lt; endl;
  }

  return 0;
}
</code></pre>

<p>It results in:</p>

<pre class=""lang-bash prettyprint-override""><code>$ javac rsa_java.java &amp;&amp; java rsa_java
$ g++ -I. rsa_cryptopp.cxx cryptopp/libcryptopp.a -o rsa_cryptopp.exe
$ ./rsa_cryptopp.exe 
Loaded RSA key
Validated RSA key
</code></pre>

<hr>

<p>For completeness, here's the key with the Base64 encoding. Its 3168 bytes:</p>

<pre class=""lang-none prettyprint-override""><code>$ fold -w 80 -s rsa_key.txt
MIIJRAIBADANBgkqhkiG9w0BAQEFAASCCS4wggkqAgEAAoICAQC+Ncoo+FjXzMgjNm7NaKloa6omc0og
lpozL1Y4efyA9F9OCjBk4Tub87XtFBjcJqFv/BRMGF3f21/kfmt5vHcOFf2f8mZDbyYxyYoVXFf8fmnQ
E+82WrhCsY44/ZPPCCQV6Yyo83JMgZydRMt879r6dWlXlTLAuTpSXS5OptgCtlHu0fWsaPDbzQzqvgsL
5DdsN6rsZ76PTAV6DqgNR9JSoWf+It/MFwMAlBV9fTRpBaMK4EcKBp38NEb1zHvPlrs3iIsPm3eEnGl5
Rvu0VAI4tXsyRuRG/zTMvsP3/rpFTgDssCXuMjZbGsf0oSO4adtj1LZl9j6y7Gz1d+5ou0zvs4YAKhAj
NaxA8RJNnfbiofoMnFM+nc3hVvOodo2Yg6uvRJDZOe5llsv59zF5P9cGr6maJC/PR3qynczFpvpl9CAE
GDE+AKkJHjYUP6dsGbe6krpxLQCqsU1QIv89wdEyW4OHHTPaHqvodajBgLlgqysMgv1k2wV5Vyrwn9H9
etNky+pf4PsJykp5ut80zLTPXBVvb3o5PtOaZ/gwQ8ooPkgv6Uw6bveVbt/ZjScVK+Bg+KKn9B4ELbMm
ht6XC/y3LPrwjVEhgZqCF8TsG7KDOIRx2+v1hiSOZExvIGd/P5y9GQAYijbY416OyJ5fX0XxI11hCsT8
hy8m+FmPJwlzSwIDAQABAoICAQCGtjPSJmlNlRQdlDyPL9PjR3U/PCHAyMi2/YyT/Rku/2PMMn0pxTbh
cY5kNPqSWK23URHS/uLlW0oj2sEle6vaBwsUT6nLkpm7YyBvlnIeOi2Yl7Wwijm7ymKOzFD1rK9Z8YmU
Uq6drqIL5CA2AO3Wunb794f1ZHoAwUu9mn6cFSIcAQl8rOoA0c2XJzdNmbkC5L4iJiuY819hnaW5midE
LFopa+uScK3IqBg8QwNuafaaClNlr2AOsbub89GwKPG5F/Rc/l98RQaSRQqZIXJdVXLGHd0oxzBO3cCP
EBI+aUtQVkTW2SsUBPiesc1Jm3cs0gbIWcj4EWftxZ3NAPIwDSLdvH4ppM8DOh/XnlkChN7ibTONz+1P
BoKIZaIx4gQPhgcMiqZQq4cEZ7bAz6rfbY+LbTlpPLt1ygDEuaW5idm/PwsQX+5h2MYB57bbPI5esGYn
WXxXz3ooHcaC7ubKcYyO5Y9A79x0rl3gRKSsWvD/GULWFU3JDrUYEpOQ5gELzeVu3fthAMi6TucTjNuH
sgKlEFg5rgwKrOdd3VfYUF7mUqH/zDTTYOFvsmnpP5n2tiO+q1as4KZ8CgviLx7fkmVF6rgXKv1Q7q96
EwzprOLmMqnSiuJS8U9UfUQtCVmYlCw5dAbf4F5JkiaipF+SumyVXus50fxefmLWk9E+0QKCAQEA3hrs
45/xKZhb9+dlvKgNtuzoyhTZf1jSk3VfGXcvJPeiLQQbd09zT0NwVt2xYh5SBqZHNss7JnRaP563b82q
4wURa7Lt9EYqnH96QiRcdCp6a4tlsUXlc5YKYLULJAUnpg1UKIw1ptnpXiKaR/Xd8f31jnfa0X1uFoVl
VO5CHcfR0JxBSefZFlIaHqN13waMngF0m42rW9kQ3cWjH3CoIwPwJgB52YzOwC8jtt5zWPVmfzmmYt8l
64uqZtxNhjm0ayZBtieErVr5ESiyepDQyQY5+2dS6lWV5dpdzgjmy/F4PAv8VMKVyoznjrvO6GZp1sP3
uk47YN994y8IMAgMGQKCAQEA2zzOi4ftgblt/6RyIpMMMdtHTqfxujf5Zz0Zkj4FUX/nr4fUUIo5GrMt
kFClIgg+XL1nj9oC34OLEDzmLTBz4CjV2H0O8aYLDHYBmYYF7+yjm+zBheQHrP74XczcTBTfHkhyI98y
acrVmwgTzfDNuBqsX36LMG7DveyHfoQptUVSchLfrbQalGEP152/W+gdZPOuTQfnv511vVj7/N21NUmP
6RutWwsmwJPzE3U0VARdRaf3VIj3maNw5IOcxdcM1RjebYqefovbzUOG3tmEiXe54mHZGlyFNjrs2xPX
xDJdcl+5b8RsnxpY6OJEgsvgWhD4mmgGLhIEXtFWQRWnAwKCAQEA1y5y751XwprQD3/qezq9/snMR2yn
w89ERITkXAGydThNsRtXmOIqr1KBFke2wX7qrXKPcDC53+m+PgEBa5pww313gUZbb9xDEFgZFNexkwJM
lMD7ByLWyINHDqaYYo9z+FbVgGtG154rkH4pxyoXm4oWS68nGutQqxUWNZCYEc40Is4gGwA6vHtSvvhT
DH6F4dc7KDG7IUNOKe5+ucklvLbmBYtUgkb/UAbbrSIb0sX+RaiO4R+c13X646jwmuhxOZZY96eVzXZj
9BHfyQtgnEIiDsXt+QZuMcC8PQ82u8P4XwSltWDISvL0rL6cGWCPjflSmveMY7BjgKViY1aIkQKCAQBW
P0eqEKFY5U/mwBS+kUa83lzhDqTD831EJf9HTurcswq8PR1DSf1JCbAlE/TCvKd76G8zYjq7H463pp2O
rX8IckgeUKRuYDn8fvgGI3l2d4utrag8OgbjAbNHg24u6A8WZL2yav30LH137eeMnuzvPl8NekTbmtea
gdCT7v5Rd6IFinNAbJgAQ2buFfrP9zKJImwxlaiP8yv8f2MyiS3edsAMnnzGUk6+d/Wqc/NQEh93Zaqh
MPjnEis5WqV0FzPPKWdnhJ7xfafMyoHmbX/8bINOEdxMyJUHTosbbGT3pDCq7AmRdJ6ewMi1ZT46jmYG
SKLka4Py39ekTYo3NINtAoIBAQCn0XE5cvtI7PCg6FG4R3+KtMWS+f6vlx1Ltb9gRCSfTncOTWr9bsHK
/uOMBt5P/J1GpobzdFFviVlXy2lZIMmVPYBsYIfyy8i8lARB+pRZ3aNXcQ197nHB0vmezu338vHb0jXe
LJo8gmXh6pMXsIdK7ZKnxwOq/qHk7tex523+LHu6L52T3/EA9sfCyB1auF5Vcc9qwDyROhoXOwz7wyXR
388U3RzxZxsznFf6n1TVPal54csnmX83xiYnokgrXcYkUCiKWqgBO/DtRAqLlInAYUxYWSdlcZKK2pd1
EG5tg/5boz5Sf8iZbN9A7ixxMBCjJlAz44xJthi4bNE6WkP5
</code></pre>
","606","<java><c++><encryption><rsa><crypto++>","2","2","1","2016-08-31 01:54:57","39239096","1","1","608639","","2016-08-31 00:24:38","2016-08-29 15:53:02",""
"28816212","PumpMessages in crypto++, reading a key file?","<p>I'm writing an AES key and iv to the file with crypto++ by using following code:</p>

<pre><code>// write the key:
SecByteBlock key(AES::DEFAULT_KEYLENGTH);
SecByteBlock iv(AES::BLOCKSIZE);

string file = m_file_name + "".key"";
FileSink* key_out = new FileSink(file.c_str());
Base64Encoder base64_key_enc(key_out);

base64_key_enc.Put(key.BytePtr(), key.size());
base64_key_enc.MessageEnd();
base64_key_enc.Put(iv.BytePtr(), iv.size());
base64_key_enc.MessageEnd();
</code></pre>

<p>and to read a the key and iv from the file back I use following:</p>

<pre><code>// read key
string file = m_file_name + "".key"";
SecByteBlock key(AES::DEFAULT_KEYLENGTH);
ArraySink* arr_key_in = new ArraySink(key, key.size());
Base64Decoder* base64_key_dec = new Base64Decoder(arr_key_in);
FileSource source(file.c_str(), false, base64_key_dec);
source.PumpMessages(1); // read only the key 

// read iv
SecByteBlock iv(AES::BLOCKSIZE);
ArraySink* arr_iv_in = new ArraySink(iv, iv.size());
base64_key_dec-&gt;Detach(arr_iv_in);
source.PumpAll(); // read the rest (the iv)
</code></pre>

<p>Problem is that after reading a file the key is correct but iv is not, so i wornder what could be wrong with my sintax?</p>

<p>the contents of a key file are base64 hex encoded and it looks like so:</p>

<p><strong>2Gnh3TbAJeQPmza9FKdqNg==
FowuKut3pBl7g0Or+4FJUg==</strong></p>

<p>the <strong>==</strong> means end of the message/key...
First on is the key, while the other one is the iv, the above code does not read the iv from the file properly.</p>

<p>What is wrong with my code?</p>
","<blockquote>
  <p>Problem is that after reading a file the key is correct but iv is not, so i wonder what could be wrong with my syntax?</p>
</blockquote>

<p>I think the problem is the library does not understand your notion of a message, so it does not know how to stream the message. I suspect its reading everything in one shot.</p>

<p>You <em>might</em> be able to correct it with <code>source.Pump(AES::DEFAULT_KEYLENGTH * 4 / 3)</code>. I think that's correct, to compensate for the base encoding expansion. Or, you could read Base64 concatenated strings, split on the space, and then process the two messages separately.</p>

<p>Or you could try the following. Its not much different than yours, except it writes a length prefix so the Key and IV can be easily delineated and recovered.</p>

<p>A typical run looks like:</p>

<pre><code>$ ./cryptopp-test.exe
Key 1: 434477042E70083441961B2F98A9FB1C
IV 1: 73A06DA15676B5AFB80C1741B3651982
Encoded: ABBDRHcELnAINEGWGy+YqfscABBzoG2hVna1r7gMF0GzZRmC
Key 2: 434477042E70083441961B2F98A9FB1C
IV 2: 73A06DA15676B5AFB80C1741B3651982
</code></pre>

<hr>

<pre><code>HexEncoder hex;
string filename = ""test.txt"", r1, r2, r3, r4, r5;

Base64Encoder encoder;
AlgorithmParameters params = MakeParameters(Pad(), false)(InsertLineBreaks(), false);
encoder.Initialize(params);

SecByteBlock k1(AES::DEFAULT_KEYLENGTH), v1(AES::BLOCKSIZE);

// Generate random key and iv
OS_GenerateRandomBlock(false, k1, k1.size());
OS_GenerateRandomBlock(false, v1, v1.size());

// Print key
hex.Detach(new StringSink(r1));
hex.Put(k1, k1.size());
hex.MessageEnd();

cout &lt;&lt; ""Key 1: "" &lt;&lt; r1 &lt;&lt; endl;

// Print iv
hex.Detach(new StringSink(r2));
hex.Put(v1, v1.size());
hex.MessageEnd();

cout &lt;&lt; ""IV 1: "" &lt;&lt; r2 &lt;&lt; endl;

// Write key
encoder.PutWord16(static_cast&lt;word16&gt;(k1.size()), BIG_ENDIAN_ORDER);
encoder.Put(k1.data(), k1.size());

// Write iv
encoder.PutWord16(static_cast&lt;word16&gt;(v1.size()), BIG_ENDIAN_ORDER);
encoder.Put(v1.data(), v1.size());
encoder.MessageEnd();

// Save it
FileSink f1(filename.c_str(), true);
encoder.CopyTo(f1);
f1.MessageEnd();

// Print Base64 encoded
StringSink ss(r3);
encoder.TransferTo(ss);
ss.MessageEnd();

cout &lt;&lt; ""Encoded: "" &lt;&lt; r3 &lt;&lt; endl;

// Read file
ByteQueue queue;
FileSource f2(filename.c_str(), false, new Base64Decoder(new Redirector(queue)));
f2.PumpAll();

// Read key and iv
SecByteBlock k2, v2;
word16 size = 0;

// Read key
queue.GetWord16(size, BIG_ENDIAN_ORDER);
k2.resize(size);
queue.Get(k2, k2.size());

// Read iv
queue.GetWord16(size, BIG_ENDIAN_ORDER);
v2.resize(size);
queue.Get(v2, v2.size());

// Print key
hex.Detach(new StringSink(r4));
hex.Put(k2, k2.size());
hex.MessageEnd();

cout &lt;&lt; ""Key 2: "" &lt;&lt; r4 &lt;&lt; endl;

// Print iv
hex.Detach(new StringSink(r5));
hex.Put(v2, v2.size());
hex.MessageEnd();

cout &lt;&lt; ""IV 2: "" &lt;&lt; r5 &lt;&lt; endl;
</code></pre>

<hr>

<p>The reference for the <code>MakeParameters</code> trick to remove padding and line breaks is at <a href=""http://www.cryptopp.com/wiki/NameValuePairs"" rel=""nofollow"">NameValuePairs</a> on the Crypto++ wiki.</p>

<p>The reference for the <code>OS_GenerateRandomBlock</code> is at <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">RandomNumberGenerator</a> on the Crypto++ wiki.</p>

<p>And you can find <a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow"">HexEncoder</a>, <a href=""http://www.cryptopp.com/wiki/Base64Encoder"" rel=""nofollow"">Base64Encoder</a>, <a href=""http://www.cryptopp.com/wiki/Redirector"" rel=""nofollow"">Redirector</a> and friends on the Crypto++ wiki.</p>

<hr>

<p>Also, <code>AES::DEFAULT_KEYLENGTH</code> is 16 bytes (AES-128). That's usually enough for most people's needs. You could bump that to 32, if desired (AES-256).</p>
","580","<c++><file-io><aes><crypto++>","1","1","1","2015-03-02 23:57:50","28821436","0","","","","","2015-03-02 17:45:40",""
"38545180","Getting exception ""RSA/OAEP-MGF1(SHA-1): ciphertext length of 154 doesn't match the required length of 192 for this key"" during decrypting session key","<p>I am getting ""RSA/OAEP-MGF1(SHA-1): ciphertext length of 154 doesn't match the required length of 192 for this key"" when I try to decrypt encrypted session key which uses crypto++ library.</p>

<p>Following are code snippets for the same:</p>

<pre><code>std::string encrypt_session_key(PAES_KEY_WITH_IV pKey)
{
        std::string ciphered;
        CryptoPP::SecByteBlock block(pKey-&gt;key.size());

        try {
                CryptoPP::RSAES&lt; CryptoPP::OAEP&lt;CryptoPP::SHA&gt; &gt;::Encryptor enc(RSA_master_pubKey);
                enc.Encrypt(rng, pKey-&gt;key, pKey-&gt;key.size(), block);
                ciphered.assign((char *)block.BytePtr());
        }
        catch (const CryptoPP::Exception&amp; e)
        {
                std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
                b_success = false;
        }
        return ciphered;
}

PAES_KEY_WITH_IV decrypt_session_key(std::string &amp; ciphered)
{
        CryptoPP::SecByteBlock rec(ciphered.size());
        CryptoPP::SecByteBlock block((const byte *)ciphered.data(), ciphered.size());
        PAES_KEY_WITH_IV pKey = new AES_KEY_WITH_IV;
        try {
                CryptoPP::RSAES&lt; CryptoPP::OAEP&lt;CryptoPP::SHA&gt; &gt;::Decryptor dec(RSA_master_privKey);
                dec.Decrypt(rng, block, block.size(), rec);

                pKey-&gt;key = rec;
        }
        catch (const CryptoPP::Exception&amp; e)
        {
                std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
                b_success = false;
        }
        return pKey;
}
</code></pre>

<p>Here I have given both code for encrypting and decrypting session key. </p>

<p>Can some one tell me Why I am getting above exception ?</p>

<p>Please note that : I am using Version 5.6.3 of crypto++ library.</p>

<p>Thanks in Advance.</p>
","<blockquote>
  <p>ciphered.assign((char *)block.BytePtr());</p>
</blockquote>

<p>The cipher text will likely have an embedded <code>NULL</code>. You cannot treat it like a <code>char*</code>.</p>

<p>Use the <a href=""http://www.cplusplus.com/reference/string/string/assign/"" rel=""nofollow"">fourth <code>append</code> overload</a> instead, which provides the pointer and the length of a buffer:</p>

<pre><code>ciphered.assign((char *)block.BytePtr(), block.SizeInBytes());
</code></pre>

<p>You are still casting it to a <code>char*</code> to get it into the <code>std::string</code> object. But its really a more like a <a href=""http://www.sgi.com/tech/stl/Rope.html"" rel=""nofollow""><code>Rope</code></a> - its a string of octets without character traits.</p>
","578","<c++><crypto++>","1","0","1","2016-07-26 18:31:11","","0","","383045","","2016-07-23 18:37:04","2016-07-23 18:29:35",""
"19425885","Cryptopp in multi-threaded DLL, VS2010","<p>I'm trying to use Cryptopp 5.6.2 on XPSP3 using VS 2010. New to this...</p>

<p>I need to use the mult-threading DLLs as that is what my application uses, so I changed all references in the Crypto++ project properties from <code>/MT[d]</code> to <code>/MD[d]</code>. All Crypto++ seems to build OK.</p>

<p>However, all is not happy with my C++ console app - I have the standard <code>GetNewAndDeleteForCryptoPP</code> and that seems to be called OK (remove it and cryptopp gives an error, include it and cryptopp doesn't print warnings).</p>

<p>All seems fine until I add in the line <code>PKCS5_PBKDF2_HMAC&lt;SHA256&gt;</code>. It compiles fine but causes two LNK2001 errors for unresolved symbols for <code>CryptoPP::ThreadUserTimer::GetCurrentTimerValue(void)</code> and
<code>CryptoPP::ThreadUserTimer::TicksPerSecond(void)</code>.</p>

<p>Running out of ideas here - I can't paste the code due to arcane rules at the place I work, however I have included <code>dll.h</code>, <code>cryptlib.h</code>, <code>osrng.h</code>, <code>aes.h</code>, <code>sha.h</code>, <code>hex.h</code>, <code>integer.h</code>, <code>modes.h</code> and <code>pwdbased.h</code>.</p>

<p>Am I missing something blindingly obvious?</p>
","<p>I was having this issue too, it doesn't look like that class is being exported. Adding <code>CRYPTOPP_DLL</code> to the declaration of <code>ThreadUserTimer</code> in <code>hrtimer.h</code> will fix it. </p>
","576","<c++><visual-studio-2010><crypto++>","2","2","2","2014-01-10 04:28:03","","1","","608639","","2014-01-10 04:17:01","2013-10-17 11:47:33",""
"19425885","Cryptopp in multi-threaded DLL, VS2010","<p>I'm trying to use Cryptopp 5.6.2 on XPSP3 using VS 2010. New to this...</p>

<p>I need to use the mult-threading DLLs as that is what my application uses, so I changed all references in the Crypto++ project properties from <code>/MT[d]</code> to <code>/MD[d]</code>. All Crypto++ seems to build OK.</p>

<p>However, all is not happy with my C++ console app - I have the standard <code>GetNewAndDeleteForCryptoPP</code> and that seems to be called OK (remove it and cryptopp gives an error, include it and cryptopp doesn't print warnings).</p>

<p>All seems fine until I add in the line <code>PKCS5_PBKDF2_HMAC&lt;SHA256&gt;</code>. It compiles fine but causes two LNK2001 errors for unresolved symbols for <code>CryptoPP::ThreadUserTimer::GetCurrentTimerValue(void)</code> and
<code>CryptoPP::ThreadUserTimer::TicksPerSecond(void)</code>.</p>

<p>Running out of ideas here - I can't paste the code due to arcane rules at the place I work, however I have included <code>dll.h</code>, <code>cryptlib.h</code>, <code>osrng.h</code>, <code>aes.h</code>, <code>sha.h</code>, <code>hex.h</code>, <code>integer.h</code>, <code>modes.h</code> and <code>pwdbased.h</code>.</p>

<p>Am I missing something blindingly obvious?</p>
","<p><a href=""https://stackoverflow.com/users/1520427/user1520427"">user1520427</a> provided you the answer. You need to add <code>CRYPTOPP_DLL</code> for a few classes and functions.</p>

<p><code>PKCS5_PBKDF2_HMAC&lt;SHA256&gt;</code> is a header only implementation, so it does not need  <code>CRYPTOPP_DLL</code>. See <a href=""http://www.cryptopp.com/docs/ref/pwdbased_8h_source.html"" rel=""nofollow noreferrer"">pwdbased.h</a>.</p>

<p>However, <code>ThreadUserTimer</code> is <em>not</em> header only, so you need to modify <a href=""http://www.cryptopp.com/docs/ref/hrtimer_8h_source.html"" rel=""nofollow noreferrer""><code>hrtimer.h</code></a>:</p>

<p>OLD:</p>

<pre><code>00042 class ThreadUserTimer : public TimerBase
00043 {
00044    ...
00048 };
</code></pre>

<p>NEW:</p>

<pre><code>00042 class CRYPTOPP_DLL ThreadUserTimer : public TimerBase
00043 {
00044     ...
00048 };
</code></pre>
","576","<c++><visual-studio-2010><crypto++>","2","1","2","2014-01-10 04:28:03","","1","","608639","","2014-01-10 04:17:01","2013-10-17 11:47:33",""
"18968579","Cooperation between Eclipse and Crypto++","<p>I am trying to use the Crypto++ Library for AES encryption/decryption. Installation went on well, and I created a Project in Eclipse. In the Project Explorer, under the ""includes"" category, I can see <code>/usr/include/crypt.h</code>, <code>/usr/include/crypt++/aes.h</code> and <code>/usr/include/cryptpp/aes.h</code>.</p>

<p>When I type <code>#include &lt;aes.h&gt;</code>, Eclipse interprets it as an ""Unresolved Inclusion"". On the one hand, it seems normal because <code>aes.h</code> is not located directly in the <code>/usr/include</code> directory. On the other hand, on every Tutorial I have found they seem to <code>#include</code> <code>aes.h</code>; neither do they refer to <code>crypto++/aes.h</code> nor to <code>cryptopp/aes.h</code>.</p>

<p>I have one year's experience in C and C++ using gedit, but this is my first attempt to use Eclipse. I have installed the C/C++ Development Plugin, and the <code>include</code> directory settings seem to be correct. Is there something I am missing?</p>
","<p>As you you've said that's normal since the file are located in a folder inside /usr/include, not directly into the include directory, anyway this has nothing to do with Eclipse or any other IDE but it's just a matter of GCC and the enviromental variable ""C_INCLUDE_PATH"" if you're using plain C or ""CPLUS_INCLUDE_PATH"" if you're with g++, if you really don't want to use the <code>#include cryptopp/aes.h</code> sintax just append the /usr/include/cryptopp folder to the appropriate enviromental variable, maybe with a line like this one in your .bashrc file</p>

<pre><code>C_INCLUDE_PATH= $C_INCLUDE_PATH:/usr/include/cryptopp
</code></pre>

<p>anyway, I don't really see any problem in using <code>#include cryptopp/aes.h</code></p>
","574","<c++><eclipse><crypto++>","0","1","1","2018-04-20 01:23:29","18968912","0","","608639","","2018-04-20 01:23:29","2013-09-23 20:49:31",""
"35893860","Decrypted file has strange characters after AES CBC decryption process","<p>I am decrypting a file with AES CBC method using the Cryptopp library in vc++, VS2015 and QT libraries. I could obtain a result file decrypted but there are some characters which are not being decrypted correctly.</p>

<p>The code I use is:</p>

<pre><code>const std::string encrypted_file(""C:\\TEMP\\G0030013.xml"");
const std::string decrypted_file(""C:\\TEMP\\decrypted0.xml"");
const int key_size(CryptoPP::AES::DEFAULT_KEYLENGTH);
const int iv_size(CryptoPP::AES::BLOCKSIZE);

CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;

CryptoPP::StreamTransformationFilter *decryptor =
        new CryptoPP::StreamTransformationFilter(decryption,
        new CryptoPP::FileSink(decrypted_file.c_str()),
            CryptoPP::StreamTransformationFilter::BlockPaddingScheme::ZEROS_PADDING);


decryption.SetKeyWithIV(key, key_size, iv, iv_size);
CryptoPP::FileSource file_source(encrypted_file.c_str(), true, decryptor);
</code></pre>

<p>The resultant xml is:</p>

<pre><code>&lt;BG Val=""149"" Dt=""2014-01-14"" Tm=""15:37"" D=""1""/&gt;
&lt;BG Val=""158"" Dt=""2014-01-14"" Tm=""15:39"" Flg=""M3"" D=""í/Ë‰OæÚ…f÷ûâÄò"" Dt=""2014-01-14"" Tm=""16:00"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:01"" D=""1""/&gt;
&lt;BG Val=""60"" Dt=""2014-01-14"" Tm=""16:12"" D=""1""/&gt;
&lt;BG Val=""58"" Dt=""2014-01-14"" Tm=""16:13"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:16"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2014-01-14"" Tm=""16:32"" D=""1""/&gt;
&lt;BG Val=""168"" Dt=""2014-01-14"" Tm=""16:33"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2015-06-29"" Tm=""17:52"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""138"" Dt=""2015-07-03"" Tm=""09:00"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""141"" Dt=""2015-07-03"" Tm=""18:24"" D=""ðÂwÝfIïs¯¤eåˆöm5"" Dt=""2015-07-06"" Tm=""08:28"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""147"" Dt=""2013-10-18"" Tm=""08:40"" Ctrl=""?"" D=""1""/&gt;
&lt;BG Val=""142"" Dt=""2015-11-19"" Tm=""10:57"" Ctrl=""?"" D=""1""/&gt;
</code></pre>

<p>When it should be:</p>

<pre><code>&lt;BG Val=""149"" Dt=""2014-01-14"" Tm=""15:37"" D=""1""/&gt;
&lt;BG Val=""158"" Dt=""2014-01-14"" Tm=""15:39"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""57"" Dt=""2014-01-14"" Tm=""16:00"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:01"" D=""1""/&gt;
&lt;BG Val=""60"" Dt=""2014-01-14"" Tm=""16:12"" D=""1""/&gt;
&lt;BG Val=""58"" Dt=""2014-01-14"" Tm=""16:13"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:16"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2014-01-14"" Tm=""16:32"" D=""1""/&gt;
&lt;BG Val=""168"" Dt=""2014-01-14"" Tm=""16:33"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2015-06-29"" Tm=""17:52"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""138"" Dt=""2015-07-03"" Tm=""09:00"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""141"" Dt=""2015-07-03"" Tm=""18:24"" D=""1""/&gt;
&lt;BG Val=""135"" Dt=""2015-07-06"" Tm=""08:28"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""147"" Dt=""2013-10-18"" Tm=""08:40"" Ctrl=""?"" D=""1""/&gt;
&lt;BG Val=""142"" Dt=""2015-11-19"" Tm=""10:57"" Ctrl=""?"" D=""1""/&gt;
</code></pre>

<p>I am wondering if there is a Charset issue and it exist a way to read the encrypted file from hexadecimal to avoid this kind of problems. </p>
","<p>It is not the encryption, encryption just works on 8-bit bytes ad has no concept of what they are.</p>

<p>Padding only adds bytes to the end of the data and can only affect the last 16 bytes so it is not a padding problem.</p>

<p>It could be a difference in the string encoding, the string to be encrypted is converted to bytes based on an encoding and after decryption the bytes are re-encoded to a string with sone encoding.</p>
","571","<c++><encryption><istream><crypto++>","0","2","2","2017-05-07 19:00:14","","7","","","","","2016-03-09 14:07:52",""
"35893860","Decrypted file has strange characters after AES CBC decryption process","<p>I am decrypting a file with AES CBC method using the Cryptopp library in vc++, VS2015 and QT libraries. I could obtain a result file decrypted but there are some characters which are not being decrypted correctly.</p>

<p>The code I use is:</p>

<pre><code>const std::string encrypted_file(""C:\\TEMP\\G0030013.xml"");
const std::string decrypted_file(""C:\\TEMP\\decrypted0.xml"");
const int key_size(CryptoPP::AES::DEFAULT_KEYLENGTH);
const int iv_size(CryptoPP::AES::BLOCKSIZE);

CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;

CryptoPP::StreamTransformationFilter *decryptor =
        new CryptoPP::StreamTransformationFilter(decryption,
        new CryptoPP::FileSink(decrypted_file.c_str()),
            CryptoPP::StreamTransformationFilter::BlockPaddingScheme::ZEROS_PADDING);


decryption.SetKeyWithIV(key, key_size, iv, iv_size);
CryptoPP::FileSource file_source(encrypted_file.c_str(), true, decryptor);
</code></pre>

<p>The resultant xml is:</p>

<pre><code>&lt;BG Val=""149"" Dt=""2014-01-14"" Tm=""15:37"" D=""1""/&gt;
&lt;BG Val=""158"" Dt=""2014-01-14"" Tm=""15:39"" Flg=""M3"" D=""í/Ë‰OæÚ…f÷ûâÄò"" Dt=""2014-01-14"" Tm=""16:00"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:01"" D=""1""/&gt;
&lt;BG Val=""60"" Dt=""2014-01-14"" Tm=""16:12"" D=""1""/&gt;
&lt;BG Val=""58"" Dt=""2014-01-14"" Tm=""16:13"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:16"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2014-01-14"" Tm=""16:32"" D=""1""/&gt;
&lt;BG Val=""168"" Dt=""2014-01-14"" Tm=""16:33"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2015-06-29"" Tm=""17:52"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""138"" Dt=""2015-07-03"" Tm=""09:00"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""141"" Dt=""2015-07-03"" Tm=""18:24"" D=""ðÂwÝfIïs¯¤eåˆöm5"" Dt=""2015-07-06"" Tm=""08:28"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""147"" Dt=""2013-10-18"" Tm=""08:40"" Ctrl=""?"" D=""1""/&gt;
&lt;BG Val=""142"" Dt=""2015-11-19"" Tm=""10:57"" Ctrl=""?"" D=""1""/&gt;
</code></pre>

<p>When it should be:</p>

<pre><code>&lt;BG Val=""149"" Dt=""2014-01-14"" Tm=""15:37"" D=""1""/&gt;
&lt;BG Val=""158"" Dt=""2014-01-14"" Tm=""15:39"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""57"" Dt=""2014-01-14"" Tm=""16:00"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:01"" D=""1""/&gt;
&lt;BG Val=""60"" Dt=""2014-01-14"" Tm=""16:12"" D=""1""/&gt;
&lt;BG Val=""58"" Dt=""2014-01-14"" Tm=""16:13"" D=""1""/&gt;
&lt;BG Val=""56"" Dt=""2014-01-14"" Tm=""16:16"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2014-01-14"" Tm=""16:32"" D=""1""/&gt;
&lt;BG Val=""168"" Dt=""2014-01-14"" Tm=""16:33"" D=""1""/&gt;
&lt;BG Val=""155"" Dt=""2015-06-29"" Tm=""17:52"" Flg=""M3"" D=""1""/&gt;
&lt;BG Val=""138"" Dt=""2015-07-03"" Tm=""09:00"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""141"" Dt=""2015-07-03"" Tm=""18:24"" D=""1""/&gt;
&lt;BG Val=""135"" Dt=""2015-07-06"" Tm=""08:28"" Flg=""M1"" D=""1""/&gt;
&lt;BG Val=""147"" Dt=""2013-10-18"" Tm=""08:40"" Ctrl=""?"" D=""1""/&gt;
&lt;BG Val=""142"" Dt=""2015-11-19"" Tm=""10:57"" Ctrl=""?"" D=""1""/&gt;
</code></pre>

<p>I am wondering if there is a Charset issue and it exist a way to read the encrypted file from hexadecimal to avoid this kind of problems. </p>
","<p>This does not look right:</p>

<pre><code>const int key_size(CryptoPP::AES::DEFAULT_KEYLENGTH);
const int iv_size(CryptoPP::AES::BLOCKSIZE);
</code></pre>

<p>I don't think its illegal, its just unusual. I think you are getting 1 int initialized to the value (either <code>AES::DEFAULT_KEYLENGTH</code> or <code>AES::BLOCKSIZE</code>).</p>

<p>Usually you do something like:</p>

<pre><code>// Memory is allocated
SecByteBlock key(AES::DEFAULT_KEYLENGTH);
SecByteBlock iv(AES::BLOCKSIZE);

// Set them to 0
memset(key, 0x00, key.size());
memset(iv, 0x00, iv.size());
</code></pre>

<p>Then, if you only copy 14-bytes into <code>key</code>, the two tail bytes will be in a known state.</p>

<p>Based on the above, I'm guessing you are using some garbage for the keys.</p>

<hr>

<blockquote>
  <p>... CryptoPP::FileSource file_source(encrypted_file.c_str(), ...</p>
</blockquote>

<p>In general, you have to be careful of using <code>c_str()</code> because there's no telling when an embedded NULL can show up in the plain text or the cipher text. You should be OK for the code above when using it as a filename. But here's some plain text that includes an embedded NULL:</p>

<pre><code>std::string plain(""asdfg\0hjkl"", 10); 
</code></pre>

<p>Better, use the overload of the source, filters and sinks that take either (1) the <code>byte*</code> (data) and <code>size_t</code> (length); or (2) the <code>std::string</code> (not the C-string). (2) uses <code>string::data</code> and <code>string::length</code> so embedded NULLs don't fool the machinery.</p>

<p>Maybe something like the following from <a href=""https://www.cryptopp.com/wiki/CBC_mode"" rel=""nofollow noreferrer"">CBC Mode</a> on the Crypto++ wiki:</p>

<pre><code>CBC_Mode&lt; AES &gt;::Encryption e;
e.SetKeyWithIV( key, key.size(), iv );

// The StreamTransformationFilter adds padding
//  as required. ECB and CBC Mode must be padded
//  to the block size of the cipher.
StringSource ss( plain, true, 
    new StreamTransformationFilter( e,
        new StringSink( cipher )
    ) // StreamTransformationFilter      
); // StringSource
</code></pre>

<p>And:</p>

<pre><code>CBC_Mode&lt; AES &gt;::Decryption d;
d.SetKeyWithIV( key, key.size(), iv );

// The StreamTransformationFilter removes
//  padding as required.
StringSource ss( cipher, true, 
    new StreamTransformationFilter( d,
        new StringSink( recovered )
    ) // StreamTransformationFilter
); // StringSource
</code></pre>

<p>Instead of a <code>StringSink</code>, you can simply use a <code>FileSink</code>:</p>

<pre><code>... new FileSink(decrypted_file.c_str())
</code></pre>

<hr>

<p>CBC mode provides confidentiality only, and it does not detect tampering. Usually, you want to detect tampering too. To that end, check out <a href=""http://www.cryptopp.com/wiki/EAX_Mode"" rel=""nofollow noreferrer"">EAX mode</a>, <a href=""http://www.cryptopp.com/wiki/CCM_Mode"" rel=""nofollow noreferrer"">CCM mode</a> and <a href=""http://www.cryptopp.com/wiki/GCM_Mode"" rel=""nofollow noreferrer"">GCM mode</a>. Also see <a href=""http://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> on the Crypto++ wiki.</p>
","571","<c++><encryption><istream><crypto++>","0","1","2","2017-05-07 19:00:14","","7","","","","","2016-03-09 14:07:52",""
"29652055","How to decode non-key ASN1 data?","<p>Is it possible to use crypto++ library to decode arbitrary ASN1 data (which has couple of sequences and integers) which I have in a byte array. ash.h contains methods which all take BufferedTransformation as input, but that class is interface for different ciphers and hashes, which really seems to be not related to my simple case at all. I also found ASN1Object in cryptlib.h but it's another interface and I haven't managed to find any implementing classes.</p>

<p>Have I thought it way too complex for myself or is it actually difficult to decode arbitrary ASN1 data?</p>

<p>I am actually using this in Swift/objective-c iOS application, so if anyone has a simple solution with whatever else tool, let me know.</p>

<p>EDIT: Adding an example structure of the data</p>

<pre><code>SEQUENCE
    SEQUENCE
        INTEGER
        INTEGER
    SEQUENCE
        INTEGER
        INTEGER
</code></pre>

<p>There's always the parent sequence which contains 1 to n sequences which contain 2 integers (elgamal encryption pair (g^r, mh^r)) each.</p>
","<pre><code>SEQUENCE
    SEQUENCE
        INTEGER
        INTEGER
    SEQUENCE
        INTEGER
        INTEGER
</code></pre>

<p>For this, you would want something like:</p>

<pre><code>ArraySource as(data, size);    
Integer i1, i2, i3, i4;

BERSequenceDecoder d1(as);
    BERSequenceDecoder d2(d1);
        i1.BERDecode(d2);
        i2.BERDecode(d2);
        d2.MessageEnd();
    BERSequenceDecoder d3(d2);
        i3.BERDecode(d3);
        i4.BERDecode(d3);
        d3.MessageEnd();
  d1.MessageEnd();
</code></pre>

<hr>

<blockquote>
  <p>which contain 2 integers (elgamal encryption pair (g^r, mh^r)) each.</p>
</blockquote>

<p>Once you have the parameters (see below), you should call one of the <code>Initialize</code> functions with the parameters. <em>Don't</em> call the ones that take a PRNG because they create parameters and keys.</p>

<p>See <a href=""http://www.cryptopp.com/docs/ref/gfpcrypt_8h_source.html"" rel=""nofollow"">gfpcrypt.h</a> for some of the relevant class definitions. Also see <a href=""http://www.cryptopp.com/wiki/ElGamal"" rel=""nofollow"">ElGamal - Crypto++ Wiki</a>.</p>

<hr>

<p>Here's an example that generates integer pairs and packages them in ASN.1 structures like you desire. It then reads them back in and stops when there's nothing left to consume (i.e., the inner Integer pairs are optional).</p>

<p>You would run it like <code>./asn1-test.exe</code> or <code>./asn1-test.exe 3</code> or <code>./asn1-test.exe 6</code> or <code>./asn1-test.exe 128</code>. The size is only 48-bits so you don't waste time generating integers you don't need.</p>

<pre><code>static const unsigned int BIT_COUNT = 48;

int main(int argc, char* argv[])
{
    unsigned int count = 2;
    if(argc &gt;= 2 &amp;&amp; argv[1] != NULL)
    {
        istringstream iss(argv[1]);
        iss &gt;&gt; count;

        if(iss.fail()) count = 2;
    }

    cout &lt;&lt; ""Testing "" &lt;&lt; count &lt;&lt; "" integer pairs"" &lt;&lt; endl;

    // Count to pairs
    count *= 2;

    try
    {            
        AutoSeededRandomPool prng;

        vector&lt;Integer&gt; vv;
        vv.resize(count);

        for(unsigned int i = 0; i &lt; count; i += 2)
        {
            vv[i] = Integer(prng, BIT_COUNT);
            vv[i + 1] = Integer(prng, BIT_COUNT);
        }

        // Scratch for holding ASN.1 encoded structures in Crypto++
        ByteQueue queue;

        // Encode them
        {
            DERSequenceEncoder outer(queue);

            for(unsigned int i = 0; i &lt; count; i += 2)
            {
                DERSequenceEncoder inner(outer);

                vv[i].DEREncode(inner);
                vv[i + 1].DEREncode(inner);

                inner.MessageEnd();
            }

            outer.MessageEnd();
        }

        // Save it to file (use dumpasn1 to view it)
        FileSink fs(""sequences.der"", true);
        queue.CopyTo(fs);
        fs.MessageEnd();

        // Decode them
        {
            BERSequenceDecoder outer(queue);

            // Ensure we break from the loop based on EndReached()
            for( ; ; )
            {
                if(outer.EndReached()) break;

                BERSequenceDecoder inner(outer);

                Integer i1, i2;

                i1.BERDecode(inner);
                i2.BERDecode(inner);

                cout &lt;&lt; ""Pair"" &lt;&lt; endl;
                cout &lt;&lt; std::hex &lt;&lt; ""  Integer: "" &lt;&lt; i1 &lt;&lt; endl;
                cout &lt;&lt; std::hex &lt;&lt; ""  Integer: "" &lt;&lt; i2 &lt;&lt; endl;

                inner.MessageEnd();
            }

            outer.MessageEnd();
        }

    } catch (const Exception&amp; ex) {
        cerr &lt;&lt; std::dec &lt;&lt; ex.what() &lt;&lt; endl;
        exit (1);
    }

    return 0;
}
</code></pre>

<p>And here's what a run and dump looks like:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./asn1-test.exe 3
Testing 3 integer pairs
Pair
  Integer: 301818b3c631h
  Integer: 1ff0ebf1ca4bh
Pair
  Integer: f97e9d28e9cah
  Integer: 94813cab125fh
Pair
  Integer: 8a146ea68e7ch
  Integer: 60d48ef2462fh

$ dumpasn1 sequences.der 
  0  57: SEQUENCE {
  2  16:   SEQUENCE {
  4   6:     INTEGER 30 18 18 B3 C6 31
 12   6:     INTEGER 1F F0 EB F1 CA 4B
       :     }
 20  18:   SEQUENCE {
 22   7:     INTEGER 00 F9 7E 9D 28 E9 CA
 31   7:     INTEGER 00 94 81 3C AB 12 5F
       :     }
 40  17:   SEQUENCE {
 42   7:     INTEGER 00 8A 14 6E A6 8E 7C
 51   6:     INTEGER 60 D4 8E F2 46 2F
       :     }
       :   }

0 warnings, 0 errors.
</code></pre>

<p>Here are the includes to save you the trouble of looking them up:</p>

<pre><code>#include &lt;iostream&gt;
using std::ostream;
using std::cin;
using std::cout;
using std::cerr;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;vector&gt;
using std::vector;

#include &lt;sstream&gt;
using std::istringstream;

#include &lt;cryptopp/cryptlib.h&gt;
using CryptoPP::Exception;

#include &lt;cryptopp/filters.h&gt;
using CryptoPP::StringSource;
using CryptoPP::StringSink;

#include &lt;cryptopp/files.h&gt;
using CryptoPP::FileSink;

#include &lt;cryptopp/integer.h&gt;
using CryptoPP::Integer;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::AutoSeededRandomPool;

#include &lt;cryptopp/asn.h&gt;
#include &lt;cryptopp/oids.h&gt;
namespace ASN1 = CryptoPP::ASN1;
using CryptoPP::DERSequenceEncoder;
using CryptoPP::BERSequenceDecoder;

#include &lt;cryptopp/queue.h&gt;
using CryptoPP::ByteQueue;
</code></pre>
","571","<c++><asn.1><crypto++>","2","4","1","2015-04-20 10:09:28","29681388","2","","608639","","2015-04-18 20:37:56","2015-04-15 13:49:22",""
"31001997","How to get a key stream block for a specific counter in AES/CTR encryption","<p>I'm using Crypto++ library</p>

<p>I made the IV and key and passed them to the function</p>

<pre><code>    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(key, 16, iv);
</code></pre>

<p>Then when I encrypt I use the transformation filter on the string itself to get the encrypted string.</p>

<p><img src=""https://i.stack.imgur.com/WJedY.png"" alt=""enter image description here""></p>

<p>I want to get the final cipher key which XORed with the string to encrypt it ?
Is there a way to get it from encryption object ?</p>
","<p>If you just need the key stream that was XORed with the first 16 bytes of plaintext (as the picture suggests) then you need to encrypt a block of 16 bytes set to <code>00</code> using the same AES CTR mode. A block of key stream, when XOR'ed with all zero's simply returns the same stream. So you can do this for as many blocks of plaintext that you require. As you already guessed you need to use the same key and IV.</p>

<p>If you want to only decrypt something much further in the stream then you need to calculate a new 16 byte IV. You can do this because the IV is directly used as initial counter (possibly right-padded with zeros). So you just need to calculate how many blocks where pre-processed and then add this value (as big endian value) to the IV. This of course only works for block boundaries, you may need to discard some bytes from the key stream if you want to jump to a very specific offset.</p>
","570","<encryption><aes><crypto++>","1","0","1","2015-06-28 11:05:37","31099085","5","","589259","","2015-06-28 10:59:23","2015-06-23 11:49:25",""
"21701571","ECDSA signing and verification in windows and linux","<p>This is continuation of my previous post (<a href=""https://stackoverflow.com/questions/20992760/understanding-bcryptsignhash-output-signature"">Understanding BCryptSignHash output signature</a>).</p>

<p>Let me clearly state my problem:</p>

<ol>
<li>I need to sign a data in windows application level.</li>
<li>I need to verify the same in linux application level and windows driver (that i have wrote).</li>
</ol>

<p>I tried following:</p>

<ol>
<li><p>Using CryptoAPI, i was able to sign in windows application level and verify in the windows driver. In linux, i tried to use simpleECDSA (<a href=""http://jonasfj.dk/blog/2007/12/simpleecdsa-a-simple-implementation-of-ecdsa-in-c/"" rel=""nofollow noreferrer"">http://jonasfj.dk/blog/2007/12/simpleecdsa-a-simple-implementation-of-ecdsa-in-c/</a>) to verify the signature (generated using cryptoAPI). I was able to convert the binary key blobs from cryptoAPI in simpleECDSA but could not interpret the signature.</p></li>
<li><p>Using Crypto++ library, i was able to sign in windows application level and verify in linux application level but could not use the same to verify in windows driver.</p></li>
</ol>

<p>Kindly let me know if there is a library available or a way that i could use the same public/private key and signature across windows application/driver and linux.</p>

<p>Am new to cryptography hence forgive my naiveness.</p>

<p>Thanks,</p>

<p>F</p>
","","568","<linux><windows><cryptoapi><crypto++>","2","","0","2014-02-11 12:14:04","","11","","-1","","2017-05-23 11:59:09","2014-02-11 12:14:04",""
"45797203","SHA256 in Crypto++ library","<p>Let us focus on SHA256.</p>

<p>According to the following website,
<a href=""http://www.fileformat.info/tool/hash.htm"" rel=""nofollow noreferrer"">http://www.fileformat.info/tool/hash.htm</a>, the 'Binary hash' of 123 is 3d73c0...... and the 'String hash' of 123 is a665a4.......</p>

<p>I can obtain the 'String hash' by using the library of crypto++ as the following code:</p>

<pre><code>CryptoPP::SHA256 hash;
string digest;
CryptoPP::StringSource d1pk(""123"", true, new CryptoPP::HashFilter(hash, new HexEncoder(new CryptoPP::StringSink(digest))));

cout&lt;&lt; ""digest : "" &lt;&lt; digest &lt;&lt;endl;
</code></pre>

<p>How can I obtain the 'Binary hash' by using the library of crypto++?</p>
","<p>The website you linked is a hash tool, and allows for input as either string or bytes.</p>

<p>When you enter a string it will get the bytes of it and then hash that, so the ""Binary Hash"" is no different. It accepts data in another format, hexadecimal, and converts that to bytes to be hashed.</p>

<p>This is the best explanation of what is going on, but I can not be completely definitive without seeing their source.</p>
","568","<c++><crypto++>","0","0","1","2017-08-21 12:34:58","","3","","","","","2017-08-21 12:30:40",""
"30579350","Cannot locate symbol ""_ZNSt12__node_alloc13_M_deallocateEPvj"" on X86 Android","<p>I am using latest NDK and Crypto++ 5.6.2. I compiled it for armeabi,armeabi-v7a, mips and x86 by following these instructions <a href=""http://www.cryptopp.com/wiki/Android_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/Android_(Command_Line)</a></p>

<p>I am currently using SHA256 from Crypto++.
I tested it on three devices (<code>arm</code> based android <code>2.3</code>,<code>5</code> and <code>5.1</code>) and it works fine. But when I try it on Genymotion (<code>x86</code>) and bundled android emulator(<code>x86</code>) it's not working.</p>

<p><code>dlopen failed: cannot locate symbol ""_ZNSt12__node_alloc13_M_deallocateEPvj""</code></p>

<p>any idea why this is happening?</p>
","<blockquote>
<pre><code> dlopen failed: cannot locate symbol ""_ZNSt12__node_alloc13_M_deallocateEPvj""
</code></pre>
</blockquote>

<p>Can you use <code>c++filt</code> to demangle/decode <code>_ZNSt12__node_alloc13_M_deallocateEPvj</code>? Also, does <code>nm -D</code> show the symbol present?</p>

<p>That almost looks like a STL node. If that's the case, then you're probably not including the C++ or STL library; or you're not calling <code>loadLibrary</code> in the right order. You need to include and preload <code>libstlport_shared.so</code>.</p>

<p>The wiki page even discusses a similar problem with <code>_ZNSt12__node_alloc11_M_allocateERj</code>:</p>

<blockquote>
  <p>If you link to both libstlport_shared.so and libcryptopp.so, then you will have to preload libstlport_shared.so: </p>

<pre><code>shell@android:/ $ cd /data/local/tmp
shell@android:/data/local/tmp $ ls
TestData
TestVectors
cryptest.exe
libcryptopp.so
libstlport_shared.so
shell@android:/data/local/tmp $
shell@android:/data/local/tmp $ LD_LIBRARY_PATH=./; ./cryptest.exe v
link_image[1936]:  5431 could not load needed library './libcryptopp.so' for './cryptest.exe'
(reloc_library[1285]:  5431 cannot locate '_ZNSt12__node_alloc11_M_allocateERj'...)
CANNOT LINK EXECUTABLE
shell@android:/data/local/tmp $
shell@android:/data/local/tmp $ export LD_PRELOAD=`pwd`/libstlport_shared.so
shell@android:/data/local/tmp $ echo $LD_PRELOAD                               
/data/local/tmp/libstlport_shared.so
shell@android:/data/local/tmp $
shell@android:/data/local/tmp $ LD_LIBRARY_PATH=./; ./cryptest.exe v
Using seed: 1375005963

Testing Settings...
...
</code></pre>
</blockquote>
","557","<android><android-ndk><crypto++>","2","0","1","2015-06-01 18:12:38","","0","","608639","","2015-06-01 18:12:38","2015-06-01 17:15:45",""
"21180035","AS3Crypto & CryptoPP Rijndael ECB","<p>I'm wondering how you would code your AS3 decryption method if I use this CryptoPP function to encrypt the data:</p>

<pre><code>std::string encrypt(const std::string&amp; str_in, const std::string&amp; key, const std::string&amp; iv)
{
std::string str_out;
CryptoPP::ECB_Mode&lt;CryptoPP::Rijndael&gt;::Encryption encryption((byte*)key.c_str(), key.length());

CryptoPP::StringSource encryptor(str_in, true,
    new CryptoPP::StreamTransformationFilter(encryption,
        new CryptoPP::Base64Encoder(
            new CryptoPP::StringSink(str_out),
            false // do not append a newline
        ),
        CryptoPP::StreamTransformationFilter::PKCS_PADDING
    )
);
return str_out;
}
</code></pre>

<p>What I have here gives me the first several characters of the original text and ending with some random bytes.</p>

<pre><code>var type = ""aes-128-ecb"";  // I've tried aes, aes-128-ecb
var key = Hex.toArray(Hex.fromString(""xxxxxxxxxxxxx""));

function decryptByteArray(data:ByteArray):String
{
    //var data:ByteArray = Base64.decodeToByteArray(txt);
    var pad:IPad = new NullPad();  // i've also tried PKCS5
    var mode:ICipher = Crypto.getCipher(type, key, pad);
    var ivmode:IVMode = mode as IVMode;
    ivmode.IV = Hex.toArray(Hex.fromString(""""));
    pad.setBlockSize(mode.getBlockSize());
    mode.decrypt(data);
    return Hex.toString(Hex.fromArray(data));
}
</code></pre>

<p>I've also tried PKCS5 as padding method but gets this error:</p>

<pre><code>Error: PKCS#5:unpad: Invalid padding value. expected [166], found [229]
at com.hurlant.crypto.symmetric::PKCS5/unpad()
at com.hurlant.crypto.symmetric::CBCMode/decrypt()
at DecryptionTestAS3Crypto_fla::MainTimeline/decryptByteArray()
at DecryptionTestAS3Crypto_fla::MainTimeline/loaderComplete()
at flash.events::EventDispatcher/dispatchEventFunction()
at flash.events::EventDispatcher/dispatchEvent()
at flash.net::URLLoader/onComplete()
</code></pre>

<p>Not sure what's wrong here.  Any help would be appreciated!!</p>
","","555","<c++><actionscript-3><encryption><aes><crypto++>","1","","0","2014-01-17 07:19:41","","1","","","","","2014-01-17 07:19:41",""
"42545105","Crypto++ explicit destruction during encryption/decryption?","<p>I wrote some wrapper functions to encrypt/decrypt files using crypto++. I tried looking in the wiki but could find my answer. I am wondering if I need to explicitly destroy my objects that are created?</p>

<p>I found in the wiki that some objects when passed into functions are destroyed for you, but no examples of my exact use were there so I just wanted to be sure.</p>

<pre class=""lang-cpp prettyprint-override""><code>   CryptoPP::AutoSeededRandomPool prng;
   //Key generation
   byte key[AES::DEFAULT_KEYLENGTH];
   prng.GenerateBlock(key, sizeof(key));
   //IV generation
   byte iv[AES::BLOCKSIZE];
   prng.GenerateBlock(iv, sizeof(iv));



   //print key
   encoded.clear();
   StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

   //print iv
   encoded.clear();
   StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;

   //See function below
   encrypt_file(inFile, outFile, key, iv, err); 

   inFile.close();
   outFile.close();
</code></pre>

<p>Once in this function the bytes arrays are truncated for some reason</p>

<h2>Encrypt_file</h2>

<pre class=""lang-cpp prettyprint-override""><code>    bool encrypt_file(std::ifstream&amp; inFile,
       std::ofstream&amp; outFile,
       const byte* key, const byte* iv,
       std::string&amp; errMsg)
    {
       std::string encoded;
       //print key
       encoded.clear();
       StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

       //print iv
       encoded.clear();
       StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;
       try {
          CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption e;
          e.SetKeyWithIV(key, sizeof(key), iv);
          CryptoPP::FileSource(inFile, true, new CryptoPP::StreamTransformationFilter(e, new CryptoPP::FileSink(outFile)));
          inFile.close();
          outFile.close();
       }
       catch (CryptoPP::Exception&amp; e) {
          errMsg = e.GetWhat();
          return false;
       }
       return true;
    }
</code></pre>

<h2>Output:</h2>

<pre><code>key: 6574D7BDFD0DD3BC59CD3846D4A196A8
Size of key: 16
iv: 1B4ED692F91A32246B41F63F6B8C6EAA
Size of iv: 16
key: 6574D7BDFD0DD3BC
Size of key: 8
iv: 1B4ED692F91A3224
Size of iv: 8
</code></pre>
","<p>No, you don't. The objects you create have <a href=""http://en.cppreference.com/w/cpp/language/storage_duration"" rel=""nofollow noreferrer""><em>automatic storage duration</em></a>, which means their destructor will be automatically invoked at the end of their scope. Moreover, the arguments that you pass with <code>new</code> will be owned by the Crypto++ objects, and their corresponding destructor will release the memory for you. They fall into the category of a <em>sink</em> or a <em>filter</em>, and it turns out that you also pass the ownership. For more details see:</p>

<p><a href=""https://www.cryptopp.com/wiki/Pipelining#Ownership"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Pipelining#Ownership</a></p>

<p>Basically this is what happens (super simplified example):</p>

<pre><code>#include &lt;iostream&gt;

struct Foo{};

class X
{
    Foo *p_;
public:
    X(Foo* p): p_(p) {}
    // we'd also need a copy ctor and copy assignment operator, ignored here
    ~X()
    {
        std::cout &lt;&lt; ""Releasing the memory...\n"";
        delete p_;
    }
};

int main()
{
    X x(new Foo()); // sinking, no memory leak
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/5fe9aaf9e5366455"" rel=""nofollow noreferrer""><kbd>Live on Coliru</kbd></a></p>

<p>I have to say that this is by far my least favourite style of software design. One can use templates and mixins to probably achieve similar things (read about <a href=""https://en.wikipedia.org/wiki/Policy-based_design"" rel=""nofollow noreferrer"">policy based design</a>), without pointers floating around with no clear ownership.</p>
","553","<c++><encryption><crypto++>","3","3","2","2017-03-02 06:17:49","42545963","0","","","user3854783","2017-03-02 04:49:08","2017-03-02 01:10:06",""
"42545105","Crypto++ explicit destruction during encryption/decryption?","<p>I wrote some wrapper functions to encrypt/decrypt files using crypto++. I tried looking in the wiki but could find my answer. I am wondering if I need to explicitly destroy my objects that are created?</p>

<p>I found in the wiki that some objects when passed into functions are destroyed for you, but no examples of my exact use were there so I just wanted to be sure.</p>

<pre class=""lang-cpp prettyprint-override""><code>   CryptoPP::AutoSeededRandomPool prng;
   //Key generation
   byte key[AES::DEFAULT_KEYLENGTH];
   prng.GenerateBlock(key, sizeof(key));
   //IV generation
   byte iv[AES::BLOCKSIZE];
   prng.GenerateBlock(iv, sizeof(iv));



   //print key
   encoded.clear();
   StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

   //print iv
   encoded.clear();
   StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;

   //See function below
   encrypt_file(inFile, outFile, key, iv, err); 

   inFile.close();
   outFile.close();
</code></pre>

<p>Once in this function the bytes arrays are truncated for some reason</p>

<h2>Encrypt_file</h2>

<pre class=""lang-cpp prettyprint-override""><code>    bool encrypt_file(std::ifstream&amp; inFile,
       std::ofstream&amp; outFile,
       const byte* key, const byte* iv,
       std::string&amp; errMsg)
    {
       std::string encoded;
       //print key
       encoded.clear();
       StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

       //print iv
       encoded.clear();
       StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;
       try {
          CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption e;
          e.SetKeyWithIV(key, sizeof(key), iv);
          CryptoPP::FileSource(inFile, true, new CryptoPP::StreamTransformationFilter(e, new CryptoPP::FileSink(outFile)));
          inFile.close();
          outFile.close();
       }
       catch (CryptoPP::Exception&amp; e) {
          errMsg = e.GetWhat();
          return false;
       }
       return true;
    }
</code></pre>

<h2>Output:</h2>

<pre><code>key: 6574D7BDFD0DD3BC59CD3846D4A196A8
Size of key: 16
iv: 1B4ED692F91A32246B41F63F6B8C6EAA
Size of iv: 16
key: 6574D7BDFD0DD3BC
Size of key: 8
iv: 1B4ED692F91A3224
Size of iv: 8
</code></pre>
","<blockquote>
  <p>I wrote some wrapper functions to encrypt/decrypt files using crypto++. I tried looking in the wiki but could find my answer. I am wondering if I need to explicitly destroy my objects that are created?</p>
</blockquote>

<p>It depends. From the <a href=""https://github.com/weidai11/cryptopp/blob/master/Readme.txt#L92"" rel=""nofollow noreferrer"">README</a> under <strong><em>Important Usage Notes</em></strong> (the two items are listed):</p>

<blockquote>
  <ol>
  <li><p>If a constructor for A takes a pointer to an object B (except primitive types such as int and char), then A owns B and will delete B
  at A's destruction.  If a constructor for A takes a reference to an
  object B, then the caller retains ownership of B and should not
  destroy it until A no longer needs it.</p></li>
  <li><p>Crypto++ is thread safe at the class level. This means you can use Crypto++ safely in a multithreaded application, but you must provide
  synchronization when multiple threads access a common Crypto++ object.</p></li>
  </ol>
</blockquote>

<p>Here's your code. It looks good, and it will not need to be changed. But we can walk though it for completeness (the <code>CryptoPP</code> were removed for brevity):</p>

<pre><code>FileSource(inFile, true, new StreamTransformationFilter(encryptor, new FileSink(outFile)));
</code></pre>

<ol>
<li>you have the stack based <code>FileSource</code>. Its an automatic variable and it is deleted when it goes out of scope. Its boilerplate C++.</li>
<li>you have <code>inFile</code>. Its a reference, you are responsible for deleting it. Its stack based, and it is deleted when it goes out of scope in the caller. Its boilerplate C++.</li>
<li>you have the <code>StreamTransformationFilter</code> created with <code>new</code>. Its a pointer and the <code>FileSource</code> owns it. It will be deleted when the <code>FileSource</code> destructor runs. Pipelines are an acquired taste.</li>
<li>you have <code>encryptor</code>. Its a reference, you are responsible for deleting it. Its stack based, and it is deleted when it goes out of scope. Its boilerplate C++.</li>
<li>you have the <code>FileSink</code> created with <code>new</code>. Its a pointer and the <code>StreamTransformationFilter</code> owns it. It will be deleted when the <code>StreamTransformationFilter</code> destructor runs. Pipelines are an acquired taste.</li>
<li>you have <code>outFile</code>. Its a reference, you are responsible for deleting it. Its stack based, and it is deleted when it goes out of scope in the caller. Its boilerplate C++.</li>
</ol>

<p>The information is on the wiki, but its kind of hard to find if you don't know what you are looking for. Also see <a href=""https://www.cryptopp.com/wiki/Pipelining#Ownership"" rel=""nofollow noreferrer"">Pipelining | Ownership</a> on the wiki.</p>

<hr>

<p>Related, this looks suspect:</p>

<pre><code>e.SetKeyWithIV(key, sizeof(key), iv);
</code></pre>

<p>Because <code>key</code> is a function parameter declared as <code>... byte key[], byte iv[] ...</code>, I believe it <a href=""https://stackoverflow.com/q/1461432/608639"">decays to a pointer</a> with a size of 4 (i686) or 8 (x86_64). You should use something like the following, which allows you to specify the size of the array:</p>

<pre><code>bool encrypt_file(std::ifstream&amp; inFile,
    std::ofstream&amp; outFile,
    const byte* key, size_t ksize,
    const byte* iv, size_t vsize,
    std::string&amp; errMsg)
{
    ...
    e.SetKeyWithIV(key, ksize, iv);
    ...
}
</code></pre>

<p>So, given:</p>

<pre><code>byte key[AES::DEFAULT_KEYLENGTH];
prng.GenerateBlock(key, sizeof(key));
byte iv[AES::BLOCKSIZE];
prng.GenerateBlock(iv, sizeof(iv));
</code></pre>

<p>Then call it like so:</p>

<pre><code>encrypt_file(inFile, outFile, key, sizeof(key), iv, sizeof(iv), err); 
</code></pre>
","553","<c++><encryption><crypto++>","3","2","2","2017-03-02 06:17:49","42545963","0","","","user3854783","2017-03-02 04:49:08","2017-03-02 01:10:06",""
"39318776","error: ‘GlobalRNG’ was not declared in this scope","<p>I'm using Crypto++ to encrypt files in C++. And I'm using the code below.</p>

<p>It doesn't contain the headers files so I added my own :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/secblock.h&gt;
#include &lt;cryptopp/files.h&gt;
#include &lt;cryptopp/queue.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;cryptopp/integer.h&gt;
#include &lt;cryptopp/dh.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/eax.h&gt;
#include &lt;cryptopp/tea.h&gt;
#include &lt;cryptopp/blowfish.h&gt;
#include &lt;cryptopp/pssr.h&gt;
#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/nbtheory.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/gzip.h&gt;
#include &lt;cryptopp/blowfish.h&gt;
#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/rng.h&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/rdrand.h&gt;

using namespace std;
using namespace CryptoPP;
</code></pre>

<p>But unfortunately the code doesn't work <br>
Saying that the GlobalRNG is not declared !<br></p>

<pre><code>error: ‘GlobalRNG’ was not declared in this scope
</code></pre>

<p>I googled and kept looking for a solution for 2 days i found that it's a bug and fixed but i'm having the latest version : 5.6.3 !<br>
<br>
So i really don't know why this error is showing !<br>
<br></p>
","<p>In the version <em>5.6.3</em> <code>GlobalRNG</code> is defined in the file <code>validate.h</code>, as:</p>

<pre><code>// Functions that need a RNG; uses AES inf CFB mode with Seed.
CryptoPP::RandomNumberGenerator &amp; GlobalRNG();
</code></pre>

<p>Just add this inclusion:</p>

<pre><code>#include &lt;cryptopp/validate.h&gt;
</code></pre>

<p>to solve definition problem.</p>
","547","<c++><crypto++>","0","1","2","2017-02-28 00:06:47","39318964","8","","608639","","2017-02-27 23:49:27","2016-09-04 15:53:47",""
"39318776","error: ‘GlobalRNG’ was not declared in this scope","<p>I'm using Crypto++ to encrypt files in C++. And I'm using the code below.</p>

<p>It doesn't contain the headers files so I added my own :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/secblock.h&gt;
#include &lt;cryptopp/files.h&gt;
#include &lt;cryptopp/queue.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/base64.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;cryptopp/integer.h&gt;
#include &lt;cryptopp/dh.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/eax.h&gt;
#include &lt;cryptopp/tea.h&gt;
#include &lt;cryptopp/blowfish.h&gt;
#include &lt;cryptopp/pssr.h&gt;
#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/nbtheory.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/gzip.h&gt;
#include &lt;cryptopp/blowfish.h&gt;
#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/rng.h&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/rdrand.h&gt;

using namespace std;
using namespace CryptoPP;
</code></pre>

<p>But unfortunately the code doesn't work <br>
Saying that the GlobalRNG is not declared !<br></p>

<pre><code>error: ‘GlobalRNG’ was not declared in this scope
</code></pre>

<p>I googled and kept looking for a solution for 2 days i found that it's a bug and fixed but i'm having the latest version : 5.6.3 !<br>
<br>
So i really don't know why this error is showing !<br>
<br></p>
","<p><code>GloablaRNG</code> is part of testing and bench-marking. It should not be part of the library proper (i.e., <code>libcryptopp.a</code> or <code>libcryptopp.so</code>). If your programs are complaining about a missing <code>GloablaRNG</code>, then the library was cross-contaminated with some of the testing and bench-marking gear.</p>

<p>These are the files used for testing and bench-marking. They should <strong><em>not</em></strong> be included in your build of the library or your project:</p>

<ul>
<li>validate.h</li>
<li><p>bench.h</p></li>
<li><p>test.cpp</p></li>
<li>bench1.cpp, bench2.cpp</li>
<li>validat0.cpp, validat1.cpp, validat2.cpp, validat3.cpp</li>
<li>datatest.cpp, regtest.cpp, fipsalgt.cpp, dlltest.cpp</li>
</ul>

<hr>

<p>You are free to use a function called <code>GlobalRNG()</code>. Here's how its used in the library's test and bench-marking gear. But you might consider using an <code>AutoSeededRandomPool</code> instead. The <code>AutoSeededRandomPool</code> is a PGP-style generator, and its seeded from <code>/dev/urandom</code>, <code>/dev/srandom</code>, <code>/dev/random</code> or the Windows entropy pool.</p>

<p><strong><em>Declaration in validate.h</em></strong></p>

<pre><code>NAMESPACE_BEGIN(CryptoPP)
NAMESPACE_BEGIN(Test)

CryptoPP::RandomNumberGenerator &amp; GlobalRNG();

NAMESPACE_END  // Test
NAMESPACE_END  // CryptoPP
</code></pre>

<p><strong><em>Definition in test.cpp</em></strong></p>

<pre><code>NAMESPACE_BEGIN(CryptoPP)
NAMESPACE_BEGIN(Test)

ANONYMOUS_NAMESPACE_BEGIN
OFB_Mode&lt;AES&gt;::Encryption s_globalRNG;
NAMESPACE_END

RandomNumberGenerator &amp; GlobalRNG()
{
    return dynamic_cast&lt;RandomNumberGenerator&amp;&gt;(s_globalRNG);
}
NAMESPACE_END  // Test
NAMESPACE_END  // CryptoPP
</code></pre>

<p><strong><em>Seeding in test.cpp</em></strong></p>

<pre><code>// Don't do this in production because it creates a deterministic generator
OFB_Mode&lt;AES&gt;::Encryption&amp; aesg = dynamic_cast&lt;OFB_Mode&lt;AES&gt;::Encryption&amp;&gt;(Test::GlobalRNG());
aesg.SetKeyWithIV((byte *)seed.data(), 16, (byte *)seed.data());
</code></pre>

<hr>

<p>A lot of folks have had this problem over the years. At Crypto++ 6.0, we moved <code>GlobalRNG()</code> into the <code>Test</code> namespace. <code>Test</code> is a new namespace, and we hope <code>Test::GlobalRNG()</code> will provide the signals that something is amiss in your library build or project configuration.</p>

<p>Also see <a href=""https://github.com/weidai11/cryptopp/issues/379"" rel=""nofollow noreferrer"">Issue 379, Add Test namespace within CryptoPP namespace</a> and  <a href=""https://github.com/weidai11/cryptopp/commit/73836e58a5f5c11cd7bf7db76e9d02013975fc9a"" rel=""nofollow noreferrer"">Commit 73836e58a5f5c11c</a>.</p>
","547","<c++><crypto++>","0","0","2","2017-02-28 00:06:47","39318964","8","","608639","","2017-02-27 23:49:27","2016-09-04 15:53:47",""
"37777373","Encrypt file using file buffer loop","<p>Last year I made an encryption program using AES 256 GCM using C++ and the crypto++ lib. This year I wanted to upgrade it to QT and change the way I was reading in the file. The old way was reading the entire file into a char* and then encrypting it and writing it out. I noticed that big files did not work, so I needed to switch this to a buffer.</p>

<p>I switched it to a read 8kb, encrypt, write repeat system, but now every time it loops, it adds an additional 33bytes to the output, and I am not sure why. This means that if the file size &lt; 8KB it works, if the filesize is between 8KB and 16KB the output adds an extra 33bytes, if the filesize is between 16KB and 24KB the output adds an extra 66bytes etc.</p>

<p>What I have been able to figure out so far is it is not the encryption code since it works on files less than 8KB, and it is not the file loop code, since I replaced the encryption code with a simple copy file code, and it copied the file correctly. </p>

<p>I think the problem is I am not resetting a variable and it is somehow messing up the data feed to the encryption code every loop.</p>

<p>here is my code</p>

<pre><code>void encryptfile(double progressbarfilecount, bool&amp; threadstatus) {    

// variables for file data
int buffersize = 8192;
string fullfilename;
string filepath;
string filename;
char memblock[8192];
streampos size;
double filesize;
double encryptedfilesize;
string datastring;
CryptoPP::SecByteBlock initializationvector(32);
string initializationvectorstring;
string cipher;
string encoded;
QMessageBox msgBox;

// encrypt the file
// get the filepath and filename
fullfilename = listbox1-&gt;item(progressbarfilecount)-&gt;text().toUtf8().constData();
size_t found = fullfilename.find_last_of(""/\\"");
filepath = fullfilename.substr(0,found);
filename = fullfilename.substr(found + 1);

// get the file size
//QFile myFile(QString::fromStdString(fullfilename));
//filesize = myFile.size();
//myFile.close();
filesize = getfilesize(fullfilename);
 qDebug() &lt;&lt; ""filesize:"" &lt;&lt; QString::number(filesize);

// setup the file data
ifstream originalfile(fullfilename, ios::in | ios::binary | ios::ate);
ofstream encryptedfile(fullfilename + "".txt"", ios::app);

// get random initializationvector
randomnumber.GenerateBlock(initializationvector, initializationvector.size());

// convert it to a string for the text filee
initializationvectorstring = string((char *)initializationvector.begin(),32);

// check if we should get the checksum of the original file
if (testencryptiontogglebuttonguisetting == ""On"") {
    originalfilechecksum &lt;&lt; checksum(fullfilename);
}



// here is the loop where the problem maybe



// encrypt the file 8KB at a time
for (encryptedfilesize = 0; encryptedfilesize &lt; filesize; encryptedfilesize+= buffersize) {
    // check if the data left to write is less than the buffer size
    if (filesize - encryptedfilesize &lt; buffersize) {
        buffersize = filesize - encryptedfilesize;
        qDebug() &lt;&lt; ""new buffersize:"" &lt;&lt; QString::number(buffersize);
    }

    // read the file into a memory block
    originalfile.seekg(encryptedfilesize);
    originalfile.read(memblock, buffersize);

    // convert the memoryblock to readable hexadecimal
    datastring = stringtohexadecimal(string(memblock, buffersize), true);

    // encrypt
    try
    {
    GCM&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(key, sizeof(key), initializationvector,initializationvector.size());
    // Not required for GCM mode (but required for CCM mode)
    // e.SpecifyDataLengths( adata.size(), pdata.size(), 0 );

    AuthenticatedEncryptionFilter ef(e,new StringSink(cipher), false, TAG_SIZE); // AuthenticatedEncryptionFilter

    // AuthenticatedEncryptionFilter::ChannelPut
    //  defines two channels: """" (empty) and ""AAD""
    //   channel """" is encrypted and authenticated
    //   channel ""AAD"" is authenticated
    ef.ChannelPut(""AAD"", (const byte*)adata.data(), adata.size());
    ef.ChannelMessageEnd(""AAD"");

    // Authenticated data *must* be pushed before
    //  Confidential/Authenticated data. Otherwise
    //  we must catch the BadState exception
    ef.ChannelPut("""", (const byte*)datastring.data(), datastring.size());
    ef.ChannelMessageEnd("""");

    // Pretty print
    StringSource(cipher, true,new HexEncoder(new StringSink(encoded), true, 16, "" ""));
    }
    catch (CryptoPP::BufferedTransformation::NoChannelSupport&amp;)
    {
    // The tag must go in to the default channel:
    //  ""unknown: this object doesn't support multiple channels""
        if (operatingsystem() == ""Linux"") {
            system(""error_message_encrypt_file_error.sh"");
        }
        if (operatingsystem() == ""Windows"") {
            ShellExecute(0, L""open"", L""error_message_encrypt_file_error.vbs"", 0, 0, SW_NORMAL);
        }
    //msgBox.setText(""No Channel Support"");
    //msgBox.exec();
    return;
    }
    catch (CryptoPP::AuthenticatedSymmetricCipher::BadState&amp;)
    {
    // Pushing PDATA before ADATA results in:
    //  ""GMC/AES: Update was called before State_IVSet""
        if (operatingsystem() == ""Linux"") {
            system(""error_message_encrypt_file_error.sh"");
        }
        if (operatingsystem() == ""Windows"") {
            ShellExecute(0, L""open"", L""error_message_encrypt_file_error.vbs"", 0, 0, SW_NORMAL);
        }
    //msgBox.setText(""Data was read before adata"");
    //msgBox.exec();
    return;
    }
    catch (CryptoPP::InvalidArgument&amp;)
    {
        if (operatingsystem() == ""Linux"") {
            system(""error_message_encrypt_file_invalid.sh"");
        }
        if (operatingsystem() == ""Windows"") {
            ShellExecute(0, L""open"", L""error_message_encrypt_file_invalid.vbs"", 0, 0, SW_NORMAL);
        }
    //msgBox.setText(""Invalid Argument"");
    //msgBox.exec();
    return;
    }

    // convert the cipher to hexadecimal string
    cipher = stringtohexadecimal(cipher, true);

    // write the encrypted file to a text file with the original file extension
    // check to see if we need to write the initialization vector
    if (encryptedfilesize == 0) {
        initializationvectorstring = stringtohexadecimal(initializationvectorstring, true);
        encryptedfile &lt;&lt; initializationvectorstring;
        qDebug() &lt;&lt; ""wrote the initilization vector"";
    }
    encryptedfile &lt;&lt; encoded;        
    qDebug() &lt;&lt; ""encrypted filesize:"" &lt;&lt; QString::number(encryptedfilesize);

    // clear the variables
    encoded = """";
    cipher = """";
    initializationvectorstring = """";
    keys = """";

}

// close the file data
originalfile.close();
encryptedfile.close();
</code></pre>

<p>If anyone could help me figure out what is wrong with the code, I would appreciate it.</p>
","<blockquote>
  <p>Last year I made an encryption program using AES 256 GCM using C++ and the crypto++ lib. This year I wanted to upgrade it to QT and change the way I was reading in the file. The old way was reading the entire file into a char* and then encrypting it and writing it out. I noticed that big files did not work, so I needed to switch this to a buffer...</p>
</blockquote>

<p>At the highest levels, you appear to have two design requirements. First, you need to chunk your data while avoiding cipher text expansion. Second, you need to integrate an authenticated encryption scheme.</p>

<p>The extra 16 bytes or so on each loop are due to the authentication tag being added to each encrypted chunk. Believe it or not, this is sometimes a desirable property. For example, image downloading a 4.7 GB Gentoo image and finding out the entire image is corrupt and eventually rejected. Its due to:</p>

<pre><code>for (encryptedfilesize = 0; encryptedfilesize &lt; filesize; encryptedfilesize+= buffersize)
{
    ...
    AuthenticatedEncryptionFilter ef(e,new StringSink(cipher), false, TAG_SIZE); // AuthenticatedEncryptionFilter    
    ...
}
</code></pre>

<p>To achieve your goals, I think you are going to need to do two things. First, to answer the question of <em>how to block or chunk the data</em>, you are going to need to <code>Pump</code> your data (as Crypto++ calls it in <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipeline parlance</a>). This has actually been covered previously, but its not readily apparent:</p>

<ul>
<li><a href=""https://stackoverflow.com/q/29949471"">Cannot kill Qt thread with CryptoPP FileSink running in the thread run method</a></li>
<li><a href=""https://stackoverflow.com/q/35734114"">Crypto++ exception calling messageEnd</a></li>
<li><a href=""https://stackoverflow.com/q/35241696"">Use of Pipelines to encrypt a file</a></li>
</ul>

<p>The above handles the blocking or chunking of data in Crypto++. The second issue, <em>how to avoid an authentication tag on each block</em>, has not been asked here (if memory server me correctly).</p>

<p>The answer to the second question can be found at <a href=""http://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow noreferrer"">Init-Update-Final</a> on the Crypto++ wiki. The short of it is, don't create a new <code>AuthenticatedEncryptionFilter</code> on each loop iteration. Rather, use a single filter and call <code>MaxRetrievable()</code> to determine if there's any cipher text ready. If there is, then retrieve it as it becomes available. Otherwise, the filter will buffer it indefinitely.</p>

<p>The <a href=""http://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow noreferrer"">Init-Update-Final</a> page has an example. Here's how the <code>update</code> function looks. I believe it mostly works as you expect from, say, Java (that's why we called it <code>JavaCipher</code>):</p>

<pre><code>size_t JavaCipher::update(const byte* in, size_t isize, byte* out, size_t osize)
{
    if(in &amp;&amp; isize)
        m_filter.get()-&gt;Put(in, isize);

    if(!out || !osize || !m_filter.get()-&gt;AnyRetrievable())
        return 0;

    size_t t = STDMIN(m_filter.get()-&gt;MaxRetrievable(), (word64)osize);
    return m_filter.get()-&gt;Get(out, t);
}
</code></pre>

<p>When you call <code>final</code>, that's when the authentication tag is generated. While its not readily apparent, the tag is generated in the call to <code>MessageEnd()</code>:</p>

<pre><code>size_t JavaCipher::final(byte* out, size_t osize)
{
    m_filter.get()-&gt;MessageEnd();

    if(!out || !osize || !m_filter.get()-&gt;AnyRetrievable())
        return 0;

    size_t t = STDMIN(m_filter.get()-&gt;MaxRetrievable(), (word64)osize);
    return m_filter.get()-&gt;Get(out, t);
}
</code></pre>

<p>I have <em>not</em> tested this with an <a href=""http://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">authenticated encryption mode</a> like EAX, CCM or GCM. We can work through any issues you experience while updating the wiki page for the benefit of others.</p>

<p>I already know you are going to need to swap-out <code>JavaCiper</code> member <code>StreamTransformationFilter</code> for a <a href=""http://www.cryptopp.com/wiki/AuthenticatedEncryptionFilter"" rel=""nofollow noreferrer""><code>AuthenticatedEncryptionFilter</code></a> for encryption, and an <a href=""http://www.cryptopp.com/wiki/AuthenticatedDecryptionFilter"" rel=""nofollow noreferrer""><code>AuthenticatedDecryptionFilter</code></a> for decryption. Artjom also details some potential issues in his comments.</p>

<hr>

<p>My apologies for not providing a lot of code. In my mind's eye, your design needs some minor work, so you are not ready for code (yet).</p>

<p>I'm guessing you <em>will</em> be ready for code in your next set of questions (if you ask them here).</p>
","542","<c++><qt><file><encryption><crypto++>","0","0","1","2016-06-14 00:00:43","","6","","608639","","2016-06-13 21:39:12","2016-06-12 17:54:30",""
"38898135","C# encrypt and Crypto++ decrypt","<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

#include""modes.h""   
#include ""aes.h""
#include ""filters.h""

int main(int argc, char* argv[]) {

    //Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-   
    //bit). This key is secretly exchanged between two parties before communication   
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ] = {0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};
    byte iv[ CryptoPP::AES::BLOCKSIZE ]={0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01};

    //Now is the time for all good men to come to the aide..."";
    //std::string plaintext=""{50602604|U800EDE73F241AC2E58A7D74C879D1D77|4DB6C4}"";
    std::string ciphertext;
    std::string decryptedtext;

    //
    // Dump Plain Text
    //
    std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; plaintext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Create Cipher Text
    //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Decrypt
    //
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    //
    // Dump Decrypted Text
    //
    std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
    std::cout &lt;&lt; decryptedtext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Please check revised C# code  at <a href=""https://stackoverflow.com/questions/38875447/getting-different-output-when-using-aes-encryption-in-c-sharp-and-online-tool/38878258?noredirect=1#comment65123196_38878258"">Getting different output when using AES encryption in c# and online tool</a>.</p>

<p>Ideally I want to decrypt that encrypted output of c# using c++ (crypto++).
But while testing encryption and decryption in c++ i am not getting same output as c# in encryption itself.</p>

<p>Below is my SAMPLE CODE.
and my OUTPUT IS:</p>

<pre><code>Plain Text (51 bytes)
{50602604|U800EDE73F241AC2E58A7D74C879D1D77|4DB6C4}
Cipher Text (64 bytes)
0x36 0xe7 0x78 0xf8 0xb8 0x97 0x15 0x6c 0xc3 0x73 0xea 0xa8 0x1b 0x12 0x71 0xc2 0xa0 0x5a 0xf2 0x40 0x60 0x89 0x6b 0x8 0x70 0x90 0xc9 0xb6 0x75 0x57 0xf7 0x22 0x73 0x3d 0x15 0xab 0xb1 0xd5 0xe5 0x73 0x85 0xe 0xa5 0x7e 0xa9 0xd2 0x7c 0xf2 0x87 0x83 0xac 0x79 0xc3 0x13 0xb7 0x89 0xfc 0x63 0x68 0x75 0x99 0x87 0x37 0xab
Decrypted Text:
{50602604|U800EDE73F241AC2E58A7D74C879D1D77|4DB6C4}
</code></pre>
","","542","<c#><c++><encryption><aes><crypto++>","0","","0","2016-08-11 20:08:04","","3","","-1","","2017-05-23 12:22:56","2016-08-11 13:44:22",""
"48783559","Diffie-Hellman key exchange between Crypto++ and Python","<p>Consider the Diffie-Hellman key exchange between client and server, where the client application is written in c++ and the back-end is written in python.
The client application uses <a href=""https://cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> lib for crypto stuff and Python uses <a href=""https://cryptography.io"" rel=""nofollow noreferrer"">cryptography</a>.</p>

<p>Here client application part where private and public key generate </p>

<pre><code>//domain parameters
OID CURVE = secp256k1();
AutoSeededX917RNG&lt;AES&gt; rng;
ECDH &lt; ECP &gt;::Domain dhA(CURVE);

// application private and publik key
SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
std::string privB64(R""(P3VfVpnSYcKQWX+6EZOly2XKy6no4UAB0cQhjBfyBD4=)"");
privA.Assign(reinterpret_cast&lt;const byte*&gt;(FromB64(privB64).c_str()), dhA.PrivateKeyLength());
dhA.GeneratePublicKey(rng, privA, pubA);

// serializa public key into integer
Integer intPub;
intPub.Decode(pubA.BytePtr(), pubA.SizeInBytes());
std::string ret;
intPub.DEREncode(CryptoPP::StringSink(ret));
std::cout &lt;&lt; ToB64(ret);// the output is loaded into python
</code></pre>

<p>Now the question is that I don't know how to deserialize the public key into python <a href=""https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicKey"" rel=""nofollow noreferrer"">EllipticCurvePublicKey</a>. When I use <a href=""https://cryptography.io/en/latest/hazmat/primitives/asymmetric/serialization/#cryptography.hazmat.primitives.serialization.load_der_public_key"" rel=""nofollow noreferrer"">cryptography.hazmat.primitives.serialization.load_der_public_key()</a>
I'm getting </p>

<pre><code>ValueError: Could not deserialize key data
</code></pre>

<p>Does anyone try to implement Diffie-Hellman key exchange between Crypto++ and Python using those two libraries?</p>
","<p>The issue was when serialized data in some way was transferred to backend how to recover it with Python <code>EllipticCurvePublicKey</code> type interface. Even if I decide to use protobuf the same question would arise.</p>

<p>But now I found the solution I'll put it here if anyone also will encounter this issue.</p>

<p>As I find out there is no interface to directly load Python <code>EllipticCurvePublicKey</code> object from Crypto++ <code>SecByteBlock</code> serialized object (which is representing the Diffie-Hellman public key in this scope).</p>

<p>To do this we need to convert public key into elliptic curve point and the serialize each coordinate of point (which is a big integer) in the way as you can see in this code snipped:</p>

<pre class=""lang-cxx prettyprint-override""><code>CryptoPP::DL_GroupParameters_EC&lt;ECP&gt; params(CURVE);    
CryptoPP::ECPPoint p = params.DecodeElement(pubA.BytePtr(), true);
std::cout &lt;&lt; CryptoPP::IntToString(p.x) &lt;&lt; std::endl;// this will be send to backend
std::cout &lt;&lt; CryptoPP::IntToString(p.y) &lt;&lt;std::endl;
</code></pre>

<p>To recover the two integers (x and y coordinates of the point) in the Python code as a DH public key you need to do the following </p>

<pre class=""lang-python prettyprint-override""><code># assuming that the x and y values are from client side 
x = 109064308162845536717682288676453496629093274218806834681903624047410153913758
y = 63162707562199639283552673289102028849183508196715869820627148926667819088660
peer_public_key =cryptography.hazmat.primitives.asymmetric.ec.EllipticCurvePublicNumbers(x, y, ec.SECP256K1()).public_key(default_backend())
</code></pre>
","533","<python><c++><crypto++><diffie-hellman><python-cryptography>","2","2","1","2018-02-17 15:21:42","48807366","0","","608639","","2018-02-15 00:51:42","2018-02-14 09:23:10",""
"45186660","Sign precomputed hash with ECDSA or DSA","<p>I'm playing around with Crypto++ signers and use the following code, straight out of the wiki:</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
const Integer D(string(""8964e19c5ae38669db3047f6b460863f5dc6c4510d3427e33545caf9527aafcf"").c_str());
privateKey.Initialize(CryptoPP::ASN1::secp256r1(), D);
if (!privateKey.Validate(rng, 3)) {
    cerr &lt;&lt; ""ECDSA privateKey key validation failed after setting private parameter."" &lt;&lt; endl;
    return 1;
}

ECDSA&lt;ECP,SHA256&gt;::Signer signer(privateKey);
StringSource ss1(message, true,
    new SignerFilter(rng, signer,
        new HexEncoder(new StringSink(signature), false)
    ) // SignerFilter
); // StringSource
int slen = signature.length() / 2;
// since it's IEEE P1363 format to display r and s:
cout &lt;&lt; signature.substr(0, slen) &lt;&lt; ""\n""
     &lt;&lt; signature.substr(slen, slen) &lt;&lt; endl;
</code></pre>

<p>Now, I'd like to know how I could override the SHA256 there to specify directly the digest value I want to pass to the signature algorithm.</p>

<p>I've digged into the <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Message_Signing"" rel=""nofollow noreferrer"">wiki</a> and the <a href=""https://www.cryptopp.com/docs/ref/struct_e_c_d_s_a.html"" rel=""nofollow noreferrer"">doxygen documentation</a>, but had no success doing so. At first I thought maybe the <a href=""https://www.cryptopp.com/docs/ref/class_null_hash.html"" rel=""nofollow noreferrer"">NullHash</a> could help there, but it is really only the zero hash according to the source. I also had some hope with the <a href=""https://www.cryptopp.com/docs/ref/class_p_k___message_accumulator.html"" rel=""nofollow noreferrer"">PK_MessageAccumulator</a> but it does not appear to work as I expected. </p>

<p>So, is there some sort of ""identity"" function inheriting from the HashTransformation class that I completely missed?<br>
If not, how would you go around building something like that allowing to specify the digest to be signed directly?</p>
","<blockquote>
  <p><code>H(M)=M</code> might work. Would it be possible to feed such a custom <code>HashTransformation</code> to the <code>ECDSA&lt;ECP,H&gt;::Signer</code>?</p>
</blockquote>

<p>Yes. The program is below. It provides an <code>IdentityHash</code> class that copies input to output. It needs a template parameter to specify the hash size.</p>

<p>But be careful. The message is formatted after it is hashed. Really what we have is <code>to_sign = MF(H(M))</code>.</p>

<pre class=""lang-cxx prettyprint-override""><code>$ cat test.cxx
#include ""cryptlib.h""
#include ""secblock.h""
#include ""eccrypto.h""
#include ""osrng.h""
#include ""oids.h""
#include ""hex.h""

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace CryptoPP;

template &lt;unsigned int HASH_SIZE = 32&gt;
class IdentityHash : public HashTransformation
{
public:
    CRYPTOPP_CONSTANT(DIGESTSIZE = HASH_SIZE)
    static const char * StaticAlgorithmName()
    {
        return ""IdentityHash"";
    }

    IdentityHash() : m_digest(HASH_SIZE), m_idx(0) {}

    virtual unsigned int DigestSize() const
    {
        return DIGESTSIZE;
    }

    virtual void Update(const byte *input, size_t length)
    {
        size_t s = STDMIN(STDMIN&lt;size_t&gt;(DIGESTSIZE, length),
                                         DIGESTSIZE - m_idx);    
        if (s)
            ::memcpy(&amp;m_digest[m_idx], input, s);
        m_idx += s;
    }

    virtual void TruncatedFinal(byte *digest, size_t digestSize)
    {
        if (m_idx != DIGESTSIZE)
            throw Exception(Exception::OTHER_ERROR, ""Input size must be "" + IntToString(DIGESTSIZE));

        ThrowIfInvalidTruncatedSize(digestSize);

        if (digest)
            ::memcpy(digest, m_digest, digestSize);

        m_idx = 0;
    }

private:
    SecByteBlock m_digest;
    size_t m_idx;
};

int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    ECDSA&lt;ECP, IdentityHash&lt;32&gt; &gt;::PrivateKey privateKey;
    privateKey.Initialize(prng, ASN1::secp256r1());

    std::string message;
    message.resize(IdentityHash&lt;32&gt;::DIGESTSIZE);
    ::memset(&amp;message[0], 0xAA, message.size());

    ECDSA&lt;ECP, IdentityHash&lt;32&gt; &gt;::Signer signer(privateKey);
    std::string signature;

    StringSource ss(message, true,
                        new SignerFilter(prng, signer,
                            new HexEncoder(new StringSink(signature))
                        ) // SignerFilter
                    ); // StringSource

    std::cout &lt;&lt; ""Signature: "" &lt;&lt; signature &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>I know it compiles and produces output. I have no idea if it is the correct output:</p>

<pre class=""lang-none prettyprint-override""><code>skylake:cryptopp$ g++ test.cxx ./libcryptopp.a -o test.exe
skylake:cryptopp$ ./test.exe
Signature: cafb8fca487c7d5023fbc76ccf96f107f72a07fecca77254e8845a2c8f2ed0ee8b50b
8ee0702beb7572eaa30c8d250a7b082c79f2f02e58ccfb97d7091755e91
</code></pre>

<hr>

<p>You can test <code>IdentityHash</code> with the following. The class <code>IdentityHash</code> did not change from the previous example. The <code>main</code> function did.</p>

<pre class=""lang-cxx prettyprint-override""><code>$ cat test.cxx
#include ""cryptlib.h""
#include ""secblock.h""

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace CryptoPP;

template &lt;unsigned int HASH_SIZE = 32&gt;
class IdentityHash : public HashTransformation
{
public:
    CRYPTOPP_CONSTANT(DIGESTSIZE = HASH_SIZE)
    static const char * StaticAlgorithmName()
    {
        return ""IdentityHash"";
    }

    IdentityHash() : m_digest(HASH_SIZE), m_idx(0) {}

    virtual unsigned int DigestSize() const
    {
        return DIGESTSIZE;
    }

    virtual void Update(const byte *input, size_t length)
    {
        size_t s = STDMIN(STDMIN&lt;size_t&gt;(DIGESTSIZE, length),
                                         DIGESTSIZE - m_idx);    
        if (s)
            ::memcpy(&amp;m_digest[m_idx], input, s);
        m_idx += s;
    }

    virtual void TruncatedFinal(byte *digest, size_t digestSize)
    {
        if (m_idx != DIGESTSIZE)
            throw Exception(Exception::OTHER_ERROR, ""Input size must be "" + IntToString(DIGESTSIZE));

        ThrowIfInvalidTruncatedSize(digestSize);

        if (digest)
            ::memcpy(digest, m_digest, digestSize);

        m_idx = 0;
    }

private:
    SecByteBlock m_digest;
    size_t m_idx;
};

int main(int argc, char* argv[])
{
    std::string message;
    message.resize(IdentityHash&lt;32&gt;::DIGESTSIZE);
    ::memset(&amp;message[0], 'A', message.size());

    IdentityHash&lt;32&gt; hash;
    hash.Update((const byte*)message.data(), message.size());

    std::string digest(32, 0);
    hash.TruncatedFinal((byte*)digest.data(), digest.size());

    std::cout &lt;&lt; ""Message: "" &lt;&lt; message &lt;&lt; std::endl;
    std::cout &lt;&lt; "" Digest: "" &lt;&lt; digest &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>It produces:</p>

<pre class=""lang-none prettyprint-override""><code>skylake:cryptopp$ g++ test.cxx ./libcryptopp.a -o test.exe
skylake:cryptopp$ ./test.exe
Message: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 Digest: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre>
","527","<c++><digital-signature><crypto++>","3","3","1","2017-07-23 01:36:18","45195519","2","1","608639","","2017-07-20 16:43:51","2017-07-19 09:38:29",""
"50791207","Cannot link to Crypto++ on Debian due to undefined references","<p>I have a project that depends on Crypto++ on Debian 8.10. The project has a library (called <code>common</code> that uses Crypto++ ) and the executable (<code>hwinfo</code>). I'm using Cmake for building purposes.</p>

<p>Here is my library build Cmake:</p>

<pre class=""lang-cmake prettyprint-override""><code>cmake_minimum_required(VERSION 3.2.2)
set (CMAKE_CXX_STANDARD 11)
include_directories()
file(GLOB SOURCES ""*.cpp"")
project(common)
add_library(common ${SOURCES})
find_library(LIBCRYPTOPP cryptopp)
target_link_libraries(common ${LIBCRYPTOPP})
install(TARGETS common 
    ARCHIVE DESTINATION ${PROJECT_SOURCE_DIR}/../../lib
    LIBRARY DESTINATION ${PROJECT_SOURCE_DIR}/../../lib)
</code></pre>

<p>And my executable Cmake file:</p>

<pre class=""lang-cmake prettyprint-override""><code>cmake_minimum_required(VERSION 3.2.2)
set (CMAKE_CXX_STANDARD 11)
include_directories(../common)
file(GLOB SOURCES ""*.cpp"")
project(hwinfo)
add_executable(hwinfo ${SOURCES})
find_library(LIBCOMMON common PATHS ${PROJECT_SOURCE_DIR}/../../lib)
find_library(LIBCRYPTOPP cryptopp)
message(STATUS ""CRYPTO LIBRARY ===&gt;"" ${LIBCRYPTOPP})
message(STATUS ""MY COMMON LIBRARY ===&gt;"" ${LIBCOMMON})
target_link_libraries(hwinfo ${LIBCRYPTOPP} ${LIBCOMMON})
install(TARGETS hwinfo 
    RUNTIME DESTINATION ${PROJECT_SOURCE_DIR}/../../bin)
</code></pre>

<p>From the diagnostic messages in the executable Cmake (<code>message (STATUS...</code>)):</p>

<pre class=""lang-none prettyprint-override""><code>-- CRYPTO LIBRARY ===&gt;/usr/local/lib/libcryptopp.a
-- MY COMMON LIBRARY ===&gt;/home/myself/dev/common/lib/libcommon.a
</code></pre>

<p>So, the libraries are being found. Here are the errors I'm getting on compilation. I've cropped some errors otherwise I wouldn't be able to post, but seen that all crypto calls are undefined:</p>

<pre class=""lang-none prettyprint-override""><code>...    
[ 64%] Linking CXX executable hwinfo
../../../lib/libcommon.a(Encryptor.cpp.o): In function `common::Encryptor::encrypt(std::string)':
Encryptor.cpp:(.text+0x2a6): undefined reference to `CryptoPP::CipherModeFinalTemplate_ExternalCipher&lt;CryptoPP::CBC_Encryption&gt;::CipherModeFinalTemplate_ExternalCipher(CryptoPP::BlockCipher&amp;, unsigned char const*, int)'
Encryptor.cpp:(.text+0x2c5): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
Encryptor.cpp:(.text+0x2ed): undefined reference to `CryptoPP::StreamTransformationFilter::StreamTransformationFilter(CryptoPP::StreamTransformation&amp;, CryptoPP::BufferedTransformation*, CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `common::Encryptor::decrypt(std::string)':
Encryptor.cpp:(.text+0x477): undefined reference to `CryptoPP::CipherModeFinalTemplate_ExternalCipher&lt;CryptoPP::CBC_Decryption&gt;::CipherModeFinalTemplate_ExternalCipher(CryptoPP::BlockCipher&amp;, unsigned char const*, int)'
Encryptor.cpp:(.text+0x4a5): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
Encryptor.cpp:(.text+0x4cd): undefined reference to `CryptoPP::StreamTransformationFilter::StreamTransformationFilter(CryptoPP::StreamTransformation&amp;, CryptoPP::BufferedTransformation*, CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface()':
Encryptor.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceD2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceD5Ev]+0x13): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BufferedTransformation::~BufferedTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP22BufferedTransformationD2Ev[_ZN8CryptoPP22BufferedTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BufferedTransformation'
Encryptor.cpp:(.text._ZN8CryptoPP22BufferedTransformationD2Ev[_ZN8CryptoPP22BufferedTransformationD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::BufferedTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SimpleKeyingInterface::SimpleKeyingInterface()':
Encryptor.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceC2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceC5Ev]+0xf): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::StreamTransformation::~StreamTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP20StreamTransformationD2Ev[_ZN8CryptoPP20StreamTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::StreamTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockOrientedCipherModeBase::Resynchronize(unsigned char const*, int)':
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBase13ResynchronizeEPKhi[_ZN8CryptoPP27BlockOrientedCipherModeBase13ResynchronizeEPKhi]+0x23): undefined reference to `CryptoPP::SimpleKeyingInterface::ThrowIfInvalidIVLength(int)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Filter::~Filter()':
Encryptor.cpp:(.text._ZN8CryptoPP6FilterD2Ev[_ZN8CryptoPP6FilterD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Filter'
Encryptor.cpp:(.text._ZN8CryptoPP6FilterD2Ev[_ZN8CryptoPP6FilterD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Filter'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::FilterWithBufferedInput::~FilterWithBufferedInput()':
Encryptor.cpp:(.text._ZN8CryptoPP23FilterWithBufferedInputD2Ev[_ZN8CryptoPP23FilterWithBufferedInputD5Ev]+0x13): undefined reference to `vtable for CryptoPP::FilterWithBufferedInput'
Encryptor.cpp:(.text._ZN8CryptoPP23FilterWithBufferedInputD2Ev[_ZN8CryptoPP23FilterWithBufferedInputD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::FilterWithBufferedInput'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;::~SecBlock()':
Encryptor.cpp:(.text._ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEED2Ev[_ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEED5Ev]+0x27): undefined reference to `CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt;::deallocate(void*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;::New(unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEE3NewEm[_ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEE3NewEm]+0x32): undefined reference to `CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt;::reallocate(unsigned char*, unsigned long, unsigned long, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockTransformation::BlockTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x19): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x24): undefined reference to `vtable for CryptoPP::BlockTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockTransformation::~BlockTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationD2Ev[_ZN8CryptoPP19BlockTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BlockTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Base::Base()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x20): undefined reference to `vtable for CryptoPP::Rijndael::Base'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x2c): undefined reference to `vtable for CryptoPP::Rijndael::Base'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Base::~Base()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Base'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Base'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Enc::Enc()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x2b): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Enc::~Enc()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x4f): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockOrientedCipherModeBase::~BlockOrientedCipherModeBase()':
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBaseD2Ev[_ZN8CryptoPP27BlockOrientedCipherModeBaseD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BlockOrientedCipherModeBase'
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBaseD2Ev[_ZN8CryptoPP27BlockOrientedCipherModeBaseD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::BlockOrientedCipherModeBase'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::CBC_Encryption::~CBC_Encryption()':
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_EncryptionD2Ev[_ZN8CryptoPP14CBC_EncryptionD5Ev]+0x13): undefined reference to `vtable for CryptoPP::CBC_Encryption'
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_EncryptionD2Ev[_ZN8CryptoPP14CBC_EncryptionD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::CBC_Encryption'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Dec::Dec()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecC2Ev[_ZN8CryptoPP8Rijndael3DecC5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecC2Ev[_ZN8CryptoPP8Rijndael3DecC5Ev]+0x2b): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Dec::~Dec()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecD2Ev[_ZN8CryptoPP8Rijndael3DecD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecD2Ev[_ZN8CryptoPP8Rijndael3DecD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)1, CryptoPP::Rijndael::Dec&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x4f): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::CBC_Decryption::~CBC_Decryption()':
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_DecryptionD2Ev[_ZN8CryptoPP14CBC_DecryptionD5Ev]+0x13): undefined reference to `vtable for CryptoPP::CBC_Decryption'
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_DecryptionD2Ev[_ZN8CryptoPP14CBC_DecryptionD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::CBC_Decryption'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::AllocatorWithCleanup&lt;unsigned char, true&gt;::allocate(unsigned long, void const*)':
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv]+0x40): undefined reference to `CryptoPP::AlignedAllocate(unsigned long)'
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv]+0x4e): undefined reference to `CryptoPP::UnalignedAllocate(unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::AllocatorWithCleanup&lt;unsigned char, true&gt;::deallocate(void*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm]+0x39): undefined reference to `CryptoPP::AlignedDeallocate(void*)'
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm]+0x47): undefined reference to `CryptoPP::UnalignedDeallocate(void*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xa0): undefined reference to `CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xa8): undefined reference to `CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xf0): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x100): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x120): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xa0): undefined reference to `CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xa8): undefined reference to `CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xe8): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xf8): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x118): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xa0): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xa8): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xf0): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x100): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x120): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xa0): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xa8): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xe8): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xf8): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x118): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
   Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2ERKS1_[_ZN8CryptoPP8Rijndael3EncC5ERKS1_]+0x36): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
collect2: error: ld returned 1 exit status
cpp/hwinfo/CMakeFiles/hwinfo.dir/build.make:85: recipe for target 'cpp/hwinfo/hwinfo' failed
make[2]: *** [cpp/hwinfo/hwinfo] Error 1
CMakeFiles/Makefile2:167: recipe for target 'cpp/hwinfo/CMakeFiles/hwinfo.dir/all' failed
make[1]: *** [cpp/hwinfo/CMakeFiles/hwinfo.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>

<p>I've no idea of what is causing that. </p>

<p>Why is my Crypto++ library not being loaded to resolve the symbols as they are explicitly declared on my Cmake file?</p>

<hr>

<p><strong><em>EDIT</em></strong>: After inverting the libraries order, as follows:</p>

<pre class=""lang-cmake prettyprint-override""><code>target_link_libraries(hwinfo ${LIBCOMMON} ${LIBCRYPTOPP})
</code></pre>

<p>I'm getting fewer error messages, but still undefined symbols as follows:</p>

<pre class=""lang-none prettyprint-override""><code>[71%] Linking CXX executable hwinfo
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)1, CryptoPP::Rijndael::Dec&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12CBC_ModeBaseE[_ZTVN8CryptoPP12CBC_ModeBaseE]+0x128): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP14CipherModeBaseE[_ZTVN8CryptoPP14CipherModeBaseE]+0x100): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP15SymmetricCipherE[_ZTVN8CryptoPP15SymmetricCipherE]+0xe8): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
collect2: error: ld returned 1 exit status
cpp/hwinfo/CMakeFiles/hwinfo.dir/build.make:85: recipe for target 'cpp/hwinfo/hwinfo' failed
make[2]: *** [cpp/hwinfo/hwinfo] Error 1
CMakeFiles/Makefile2:167: recipe for target 'cpp/hwinfo/CMakeFiles/hwinfo.dir/all' failed
make[1]: *** [cpp/hwinfo/CMakeFiles/hwinfo.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>
","<p>Order matters! If library A depends on library B, then library A must come <em>before</em> library B when linking. So the simple solution is to change the order in which you link your ""common"" library and the cryptopp library.</p>

<p>Also note that since you apparently create a static library, you don't actually <em>link</em> anything when creating the library. So the <code>target_link_libraries</code> command is useless for the library, as your project is currently set up.</p>

<p>My suggestion is that you link the two <code>CMakeLists.txt</code> files together, so the main executable <code>CMakeLists.txt</code> file uses the library <code>CMakeLists.txt</code> file (for example using the <code>add_subdirectory</code> command). Then you first of all don't need to install the library, and you could make <code>COMMON</code> depend on <code>CRYPTOPP</code> and CMake would link in correct order.</p>
","525","<c++><gcc><cmake><debian><crypto++>","1","1","2","2018-06-13 15:54:35","","1","","608639","","2018-06-13 15:47:20","2018-06-11 05:53:07",""
"50791207","Cannot link to Crypto++ on Debian due to undefined references","<p>I have a project that depends on Crypto++ on Debian 8.10. The project has a library (called <code>common</code> that uses Crypto++ ) and the executable (<code>hwinfo</code>). I'm using Cmake for building purposes.</p>

<p>Here is my library build Cmake:</p>

<pre class=""lang-cmake prettyprint-override""><code>cmake_minimum_required(VERSION 3.2.2)
set (CMAKE_CXX_STANDARD 11)
include_directories()
file(GLOB SOURCES ""*.cpp"")
project(common)
add_library(common ${SOURCES})
find_library(LIBCRYPTOPP cryptopp)
target_link_libraries(common ${LIBCRYPTOPP})
install(TARGETS common 
    ARCHIVE DESTINATION ${PROJECT_SOURCE_DIR}/../../lib
    LIBRARY DESTINATION ${PROJECT_SOURCE_DIR}/../../lib)
</code></pre>

<p>And my executable Cmake file:</p>

<pre class=""lang-cmake prettyprint-override""><code>cmake_minimum_required(VERSION 3.2.2)
set (CMAKE_CXX_STANDARD 11)
include_directories(../common)
file(GLOB SOURCES ""*.cpp"")
project(hwinfo)
add_executable(hwinfo ${SOURCES})
find_library(LIBCOMMON common PATHS ${PROJECT_SOURCE_DIR}/../../lib)
find_library(LIBCRYPTOPP cryptopp)
message(STATUS ""CRYPTO LIBRARY ===&gt;"" ${LIBCRYPTOPP})
message(STATUS ""MY COMMON LIBRARY ===&gt;"" ${LIBCOMMON})
target_link_libraries(hwinfo ${LIBCRYPTOPP} ${LIBCOMMON})
install(TARGETS hwinfo 
    RUNTIME DESTINATION ${PROJECT_SOURCE_DIR}/../../bin)
</code></pre>

<p>From the diagnostic messages in the executable Cmake (<code>message (STATUS...</code>)):</p>

<pre class=""lang-none prettyprint-override""><code>-- CRYPTO LIBRARY ===&gt;/usr/local/lib/libcryptopp.a
-- MY COMMON LIBRARY ===&gt;/home/myself/dev/common/lib/libcommon.a
</code></pre>

<p>So, the libraries are being found. Here are the errors I'm getting on compilation. I've cropped some errors otherwise I wouldn't be able to post, but seen that all crypto calls are undefined:</p>

<pre class=""lang-none prettyprint-override""><code>...    
[ 64%] Linking CXX executable hwinfo
../../../lib/libcommon.a(Encryptor.cpp.o): In function `common::Encryptor::encrypt(std::string)':
Encryptor.cpp:(.text+0x2a6): undefined reference to `CryptoPP::CipherModeFinalTemplate_ExternalCipher&lt;CryptoPP::CBC_Encryption&gt;::CipherModeFinalTemplate_ExternalCipher(CryptoPP::BlockCipher&amp;, unsigned char const*, int)'
Encryptor.cpp:(.text+0x2c5): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
Encryptor.cpp:(.text+0x2ed): undefined reference to `CryptoPP::StreamTransformationFilter::StreamTransformationFilter(CryptoPP::StreamTransformation&amp;, CryptoPP::BufferedTransformation*, CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `common::Encryptor::decrypt(std::string)':
Encryptor.cpp:(.text+0x477): undefined reference to `CryptoPP::CipherModeFinalTemplate_ExternalCipher&lt;CryptoPP::CBC_Decryption&gt;::CipherModeFinalTemplate_ExternalCipher(CryptoPP::BlockCipher&amp;, unsigned char const*, int)'
Encryptor.cpp:(.text+0x4a5): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
Encryptor.cpp:(.text+0x4cd): undefined reference to `CryptoPP::StreamTransformationFilter::StreamTransformationFilter(CryptoPP::StreamTransformation&amp;, CryptoPP::BufferedTransformation*, CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface()':
Encryptor.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceD2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceD5Ev]+0x13): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BufferedTransformation::~BufferedTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP22BufferedTransformationD2Ev[_ZN8CryptoPP22BufferedTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BufferedTransformation'
Encryptor.cpp:(.text._ZN8CryptoPP22BufferedTransformationD2Ev[_ZN8CryptoPP22BufferedTransformationD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::BufferedTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SimpleKeyingInterface::SimpleKeyingInterface()':
Encryptor.cpp:(.text._ZN8CryptoPP21SimpleKeyingInterfaceC2Ev[_ZN8CryptoPP21SimpleKeyingInterfaceC5Ev]+0xf): undefined reference to `vtable for CryptoPP::SimpleKeyingInterface'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::StreamTransformation::~StreamTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP20StreamTransformationD2Ev[_ZN8CryptoPP20StreamTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::StreamTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockOrientedCipherModeBase::Resynchronize(unsigned char const*, int)':
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBase13ResynchronizeEPKhi[_ZN8CryptoPP27BlockOrientedCipherModeBase13ResynchronizeEPKhi]+0x23): undefined reference to `CryptoPP::SimpleKeyingInterface::ThrowIfInvalidIVLength(int)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Filter::~Filter()':
Encryptor.cpp:(.text._ZN8CryptoPP6FilterD2Ev[_ZN8CryptoPP6FilterD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Filter'
Encryptor.cpp:(.text._ZN8CryptoPP6FilterD2Ev[_ZN8CryptoPP6FilterD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Filter'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::FilterWithBufferedInput::~FilterWithBufferedInput()':
Encryptor.cpp:(.text._ZN8CryptoPP23FilterWithBufferedInputD2Ev[_ZN8CryptoPP23FilterWithBufferedInputD5Ev]+0x13): undefined reference to `vtable for CryptoPP::FilterWithBufferedInput'
Encryptor.cpp:(.text._ZN8CryptoPP23FilterWithBufferedInputD2Ev[_ZN8CryptoPP23FilterWithBufferedInputD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::FilterWithBufferedInput'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;::~SecBlock()':
Encryptor.cpp:(.text._ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEED2Ev[_ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEED5Ev]+0x27): undefined reference to `CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt;::deallocate(void*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;::New(unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEE3NewEm[_ZN8CryptoPP8SecBlockIhNS_20AllocatorWithCleanupIhLb0EEEE3NewEm]+0x32): undefined reference to `CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt;::reallocate(unsigned char*, unsigned long, unsigned long, bool)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockTransformation::BlockTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x19): undefined reference to `CryptoPP::Algorithm::Algorithm(bool)'
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationC2Ev[_ZN8CryptoPP19BlockTransformationC5Ev]+0x24): undefined reference to `vtable for CryptoPP::BlockTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockTransformation::~BlockTransformation()':
Encryptor.cpp:(.text._ZN8CryptoPP19BlockTransformationD2Ev[_ZN8CryptoPP19BlockTransformationD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BlockTransformation'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Base::Base()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x20): undefined reference to `vtable for CryptoPP::Rijndael::Base'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseC2Ev[_ZN8CryptoPP8Rijndael4BaseC5Ev]+0x2c): undefined reference to `vtable for CryptoPP::Rijndael::Base'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Base::~Base()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Base'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael4BaseD2Ev[_ZN8CryptoPP8Rijndael4BaseD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Base'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Enc::Enc()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2Ev[_ZN8CryptoPP8Rijndael3EncC5Ev]+0x2b): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Enc::~Enc()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncD2Ev[_ZN8CryptoPP8Rijndael3EncD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x4f): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockOrientedCipherModeBase::~BlockOrientedCipherModeBase()':
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBaseD2Ev[_ZN8CryptoPP27BlockOrientedCipherModeBaseD5Ev]+0x13): undefined reference to `vtable for CryptoPP::BlockOrientedCipherModeBase'
Encryptor.cpp:(.text._ZN8CryptoPP27BlockOrientedCipherModeBaseD2Ev[_ZN8CryptoPP27BlockOrientedCipherModeBaseD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::BlockOrientedCipherModeBase'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::CBC_Encryption::~CBC_Encryption()':
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_EncryptionD2Ev[_ZN8CryptoPP14CBC_EncryptionD5Ev]+0x13): undefined reference to `vtable for CryptoPP::CBC_Encryption'
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_EncryptionD2Ev[_ZN8CryptoPP14CBC_EncryptionD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::CBC_Encryption'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Dec::Dec()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecC2Ev[_ZN8CryptoPP8Rijndael3DecC5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecC2Ev[_ZN8CryptoPP8Rijndael3DecC5Ev]+0x2b): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::Rijndael::Dec::~Dec()':
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecD2Ev[_ZN8CryptoPP8Rijndael3DecD5Ev]+0x13): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3DecD2Ev[_ZN8CryptoPP8Rijndael3DecD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::Rijndael::Dec'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)1, CryptoPP::Rijndael::Dec&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x4f): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::CBC_Decryption::~CBC_Decryption()':
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_DecryptionD2Ev[_ZN8CryptoPP14CBC_DecryptionD5Ev]+0x13): undefined reference to `vtable for CryptoPP::CBC_Decryption'
Encryptor.cpp:(.text._ZN8CryptoPP14CBC_DecryptionD2Ev[_ZN8CryptoPP14CBC_DecryptionD5Ev]+0x1f): undefined reference to `vtable for CryptoPP::CBC_Decryption'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::AllocatorWithCleanup&lt;unsigned char, true&gt;::allocate(unsigned long, void const*)':
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv]+0x40): undefined reference to `CryptoPP::AlignedAllocate(unsigned long)'
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE8allocateEmPKv]+0x4e): undefined reference to `CryptoPP::UnalignedAllocate(unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::AllocatorWithCleanup&lt;unsigned char, true&gt;::deallocate(void*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm]+0x39): undefined reference to `CryptoPP::AlignedDeallocate(void*)'
Encryptor.cpp:(.text._ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm[_ZN8CryptoPP20AllocatorWithCleanupIhLb1EE10deallocateEPvm]+0x47): undefined reference to `CryptoPP::UnalignedDeallocate(void*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xa0): undefined reference to `CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xa8): undefined reference to `CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0xf0): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x100): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEE]+0x120): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xa0): undefined reference to `CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xa8): undefined reference to `CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xe8): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0xf8): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEES4_EE]+0x118): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Dec::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xa0): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xa8): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0xf0): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x100): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEE]+0x120): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x48): undefined reference to `CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned long, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x78): undefined reference to `CryptoPP::SimpleKeyingInterface::GetNextIV(CryptoPP::RandomNumberGenerator&amp;, unsigned char*)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x88): undefined reference to `CryptoPP::Rijndael::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xa0): undefined reference to `CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xa8): undefined reference to `CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xe8): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0xf8): undefined reference to `CryptoPP::BlockTransformation::OptimalDataAlignment() const'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEES4_EE]+0x118): undefined reference to `non-virtual thunk to CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
   Encryptor.cpp:(.text._ZN8CryptoPP8Rijndael3EncC2ERKS1_[_ZN8CryptoPP8Rijndael3EncC5ERKS1_]+0x36): undefined reference to `vtable for CryptoPP::Rijndael::Enc'
collect2: error: ld returned 1 exit status
cpp/hwinfo/CMakeFiles/hwinfo.dir/build.make:85: recipe for target 'cpp/hwinfo/hwinfo' failed
make[2]: *** [cpp/hwinfo/hwinfo] Error 1
CMakeFiles/Makefile2:167: recipe for target 'cpp/hwinfo/CMakeFiles/hwinfo.dir/all' failed
make[1]: *** [cpp/hwinfo/CMakeFiles/hwinfo.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>

<p>I've no idea of what is causing that. </p>

<p>Why is my Crypto++ library not being loaded to resolve the symbols as they are explicitly declared on my Cmake file?</p>

<hr>

<p><strong><em>EDIT</em></strong>: After inverting the libraries order, as follows:</p>

<pre class=""lang-cmake prettyprint-override""><code>target_link_libraries(hwinfo ${LIBCOMMON} ${LIBCRYPTOPP})
</code></pre>

<p>I'm getting fewer error messages, but still undefined symbols as follows:</p>

<pre class=""lang-none prettyprint-override""><code>[71%] Linking CXX executable hwinfo
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
../../../lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)1, CryptoPP::Rijndael::Dec&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12CBC_ModeBaseE[_ZTVN8CryptoPP12CBC_ModeBaseE]+0x128): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP14CipherModeBaseE[_ZTVN8CryptoPP14CipherModeBaseE]+0x100): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP15SymmetricCipherE[_ZTVN8CryptoPP15SymmetricCipherE]+0xe8): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
collect2: error: ld returned 1 exit status
cpp/hwinfo/CMakeFiles/hwinfo.dir/build.make:85: recipe for target 'cpp/hwinfo/hwinfo' failed
make[2]: *** [cpp/hwinfo/hwinfo] Error 1
CMakeFiles/Makefile2:167: recipe for target 'cpp/hwinfo/CMakeFiles/hwinfo.dir/all' failed
make[1]: *** [cpp/hwinfo/CMakeFiles/hwinfo.dir/all] Error 2
Makefile:129: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>
","<p>Based on this:</p>

<blockquote>
  <p>I have a project that depends on cryptopp on Debian 8.10</p>
</blockquote>

<p>And this:</p>

<pre class=""lang-none prettyprint-override""><code>../../../lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP15SymmetricCipherE[_ZTVN8CryptoPP15SymmetricCipherE]+0xe8):
undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
collect2: error: ld returned 1 exit status
</code></pre>

<p>And this:</p>

<pre class=""lang-none prettyprint-override""><code>-- CRYPTO LIBRARY ===&gt;/usr/local/lib/libcryptopp.a
</code></pre>

<p>It looks like you have two copies of the Crypo++ library and you are mixing and matching them.</p>

<p>I think the easiest/best fix is to run the following commands. They remove your copy so you use Debian's copy.</p>

<pre class=""lang-bash prettyprint-override""><code>rm -rf /usr/local/include/cryptopp
rm -rf /usr/local/lib/*cryptopp*
rm -rf /usr/local/bin/cryptest*
rm -rf /usr/local/share/cryptopp
</code></pre>

<hr>

<p>The reason I think its a problem is because <code>ProcessLastBlock</code> now returns a <code>size_t</code>. That change happened at Crypto++ 6.0. The change was needed for authenticated encryption modes like OCB. OCB handles padding of the last block itself, so it needed a way to specify how much of the provided buffer was used.</p>

<p>Crypto++ 5.6.3 and earlier used <code>ProcessLastBlock</code> that returned <code>void</code>. There was a tight coupling of a block cipher mode and an explicit requirement the last block was always a full block size. But like I said, that did not hold as we started adding additional modes of operation.</p>

<p>Also see the head notes in <a href=""https://github.com/weidai11/cryptopp/blob/master/filters.cpp#L694"" rel=""nofollow noreferrer""><code>filters.cpp</code></a> and the function <code>StreamTransformationFilter::LastPut</code>:</p>

<pre class=""lang-cxx prettyprint-override""><code>// This block is new to StreamTransformationFilter. It somewhat of a hack and was added
//  for OCB mode; see GitHub Issue 515. The rub with OCB is, its a block cipher and the
//  last block size can be 0. However, ""last block = 0"" is not the 0 predacted in the
//  original code. In the orginal code 0 means ""nothing special"" so DEFAULT_PADDING is
//  applied. OCB's 0 literally means a final block size can be 0 or non-0; and no padding
//  is needed in either case because OCB has its own scheme (see handling of P_* and A_*).
// Stream ciphers have policy objects to convey how to operate the cipher. The Crypto++
//  framework operates well when MinLastBlockSize() is 1. However, it did not appear to
//  cover the OCB case either because we can't stream OCB. It needs full block sizes. In
//  response we hacked a IsLastBlockSpecial(). When true StreamTransformationFilter
//  defers to the mode for processing of the last block.
// The behavior supplied when IsLastBlockSpecial() will likely have to evolve to capture
//  more complex cases from different authenc modes. I suspect it will have to change
//  from a simple bool to something that conveys more information, like ""last block
//  no padding"" or ""custom padding applied by cipher"".
// In some respect we have already hit the need for more information. For example, OCB
//  calculates the checksum on the cipher text at the same time, so we don't need the
//  disjoint behavior of calling ""EncryptBlock"" followed by a separate ""AuthenticateBlock"".
//  Additional information may allow us to avoid the two spearate calls.
</code></pre>

<hr>

<p>And to reiterate from <a href=""https://www.cryptopp.com/wiki/Linux#Distribution_Package"" rel=""nofollow noreferrer"">Linux | Distribution Package</a> on the wiki:</p>

<pre><code>$ lsb_release -a
No LSB modules are available.
Distributor ID: Debian
Description:    Debian GNU/Linux 8.10 (jessie)
Release:        8.10
Codename:       jessie

$ apt-cache search libcrypto++
...
libcrypto++-dev - General purpose cryptographic library - C++ development
libcrypto++-doc - General purpose cryptographic library - documentation
libcrypto++-utils - General purpose cryptographic library - utilities and data files
libcrypto++9 - General purpose cryptographic library - shared library
libcrypto++9-dbg - General purpose cryptographic library - debug symbols
</code></pre>

<p>So you need <code>libcrypto++9</code>, <code>libcrypto++-dev</code> and possibly <code>libcrypto++9-dbg</code>.</p>
","525","<c++><gcc><cmake><debian><crypto++>","1","0","2","2018-06-13 15:54:35","","1","","608639","","2018-06-13 15:47:20","2018-06-11 05:53:07",""
"41798497","Memory leak in Crypto++ RSAES class","<p>I'm trying to learn how to use <a href=""https://www.cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> classes. My goal is to generate public and private keys for RSA encryption and then do basic encryption and decryption of a plaintext.</p>

<p>So I'm taking their example <a href=""https://www.cryptopp.com/wiki/RSA_Encryption_Schemes"" rel=""nofollow noreferrer"">from here</a> -- ""<em>RSA Encryption Scheme (OAEP and SHA) using Filters</em>"", slightly modified for readability:</p>

<p>This parts works OK:</p>

<pre><code>CryptoPP::AutoSeededRandomPool rng;

//Generate Parameters
CryptoPP::InvertibleRSAFunction params;
params.GenerateRandomWithKeySize(rng, 3072);

//Create Keys
CryptoPP::RSA::PrivateKey privateKey(params);
CryptoPP::RSA::PublicKey publicKey(params);

std::string plain=""Hello world!"", cipher, recovered;

//Encryption
CryptoPP::RSAES_OAEP_SHA_Encryptor e(publicKey);
</code></pre>

<p>But then when I call this block:</p>

<pre><code>CryptoPP::StringSink* pSS = new CryptoPP::StringSink( cipher );
CryptoPP::PK_EncryptorFilter* pEF = new CryptoPP::PK_EncryptorFilter( rng, e, pSS);

CryptoPP::StringSource ss1( plain, true, pEF);
</code></pre>

<p>It causes the memory leak(s). I get the following in the <code>Visual Studio</code> output window:</p>

<pre><code>Detected memory leaks!
Dumping objects -&gt;
{24781} normal block at 0x029BCFF8, 28 bytes long.
 Data: &lt;class CryptoPP::&gt; 63 6C 61 73 73 20 43 72 79 70 74 6F 50 50 3A 3A 
{24780} normal block at 0x029BCFB0, 8 bytes long.
 Data: &lt;        &gt; F8 CF 9B 02 00 00 00 00 
Object dump complete.
</code></pre>

<p>OK, so I did the most obvious thing and added these:</p>

<pre><code>delete pEF;
delete pSS;
</code></pre>

<p>but it caused an unhandled exception, so I assumed that one of the destructors in Crypto++ classes took care of deleting some of those objects.</p>

<p>So the question is -- where is this leak coming from?</p>

<p>I tried stepping into <code>StringSink</code>, <code>PK_EncryptorFilter</code> and <code>StringSource</code> with a Visual Studio debugger to see what's going on, but the code is quite convoluted to figure it out right away.</p>

<p>Any idea how to fix those memory leaks?</p>
","<blockquote>
  <p>It causes the memory leak(s). I get the following in the Visual Studio
  output window:</p>

<pre><code>Detected memory leaks!
Dumping objects -&gt;
{24781} normal block at 0x029BCFF8, 28 bytes long.
 Data: &lt;class CryptoPP::&gt; 63 6C 61 73 73 20 43 72 79 70 74 6F 50 50 3A 3A 
{24780} normal block at 0x029BCFB0, 8 bytes long.
 Data: &lt;        &gt; F8 CF 9B 02 00 00 00 00 
Object dump complete.
</code></pre>
</blockquote>

<p>The code you used looks a tad bit unusual, but I believe its well formed.</p>

<p>I believe what you are seeing is Microsoft's decades old bug <a href=""https://stackoverflow.com/q/40034232"">typeinfo.name() memory leaks</a>. Its been around since the VC 5.0 or VC 6.0 days.</p>

<hr>

<blockquote>
<pre><code>CryptoPP::StringSink* pSS = new CryptoPP::StringSink( cipher );
CryptoPP::PK_EncryptorFilter* pEF = new CryptoPP::PK_EncryptorFilter( rng, e, pSS);

CryptoPP::StringSource ss1( plain, true, pEF);
</code></pre>
</blockquote>

<p>Here's what a pipeline often looks like:</p>

<pre><code>CryptoPP::StringSource ss( plain, true,
    new CryptoPP::PK_EncryptorFilter( rng, e,
        new CryptoPP::StringSink( cipher )));
</code></pre>

<p>Everything that follows the code above is a red herring. You went down a rabbit hole because Microsoft won't fix their bugs.</p>

<hr>

<blockquote>
  <p>OK, so I did the most obvious thing and added these:</p>

<pre><code>delete pEF;
delete pSS;
</code></pre>
  
  <p>but it caused an unhandled exception</p>
</blockquote>

<p>Yeah, that was not right. From the <a href=""https://github.com/weidai11/cryptopp/blob/master/Readme.txt"" rel=""nofollow noreferrer"">Readme.txt</a>:</p>

<blockquote>
  <p><strong>* Important Usage Notes *</strong></p>
  
  <ol>
  <li><p>If a constructor for A takes a pointer to an object B (except primitive types such as int and char), then A owns B and will delete B
  at A's destruction.  If a constructor for A takes a reference to an
  object B, then the caller retains ownership of B and should not
  destroy it until A no longer needs it.</p></li>
  <li><p>Crypto++ is thread safe at the class level. This means you can use Crypto++ safely in a multithreaded application, but you must provide
  synchronization when multiple threads access a common Crypto++ object.</p></li>
  </ol>
</blockquote>

<p><code>pEF</code> and <code>pSS</code> were pointers, and they were owned by someone else. They got deleted twice, which caused the exception.</p>

<hr>

<blockquote>
  <p>Memory leak in Crypto++ RSAES class ...</p>
</blockquote>

<p>If you run the <code>cryptest.exe</code> program, then you will see 60 or 80 leaks reported. I've tried to find a solution to that bug for about 10 or 15 years. Most recently was <a href=""https://stackoverflow.com/q/40034232"">How to remediate Microsoft typeinfo.name() memory leaks?</a> on Stack Overflow.</p>

<p><strong><em>EDIT</em></strong> also see <a href=""https://groups.google.com/forum/#!topic/cryptopp-users/32OQVPdflZk"" rel=""nofollow noreferrer"">Windows Debug build memory leaks cleared</a> on the user list and <a href=""https://github.com/weidai11/cryptopp/commit/301437e693fe8bff"" rel=""nofollow noreferrer"">Commit 301437e693fe8bff</a>. The library moved to static initialization from dynamic initialization to avoid problems on Microsoft platforms. The static initializer list is accessed with <code>inti_seg</code> on Windows; and <code>constructor</code> and <code>init_priority</code> attributes with GCC.</p>

<p>Its a ""best effort"" to use static initialization, if available. Otherwise, things fall back to dynamic initialization. Here, ""static initialization"" means getting the library into the CRT static initialization list that runs constructor functions and calls global object ctors (and not a vanilla C++ static object).</p>
","525","<c++><windows><visual-studio><memory-leaks><crypto++>","4","1","1","2019-04-09 12:27:30","","7","","608639","","2019-04-09 12:27:30","2017-01-23 02:36:31",""
"23300694","How to loop over Blowfish Crypto++","<p>I am running Crypto++ doing speed tests on encryption algorithms. I am trying to time how long it takes to encrypt, then decrypt the data(eventually with more file sizes and different algorithms). I am running into a problem where I cannot loop over the code. In the following code, I am using Blowfish, but when I get to the encryption part, it gives me the error:</p>

<pre><code>HashVerificationFilter: message hash or MAC not valid
</code></pre>

<p>What can I do to fix this? Do I need to put it in a function? If so, how would I do that?</p>

<pre><code>/**
 * g++ encryption_tests.cpp -o encryption_tests -lcryptopp -lpthread -L.
 */
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;ctime&gt;


#include ""cryptoplusplus/osrng.h""
using CryptoPP::AutoSeededRandomPool;

#include ""cryptoplusplus/cryptlib.h""
using CryptoPP::Exception;

#include ""cryptoplusplus/hex.h""
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include ""cryptoplusplus/modes.h""
#include ""cryptoplusplus/aes.h""

#include ""cryptoplusplus/filters.h""
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::AuthenticatedEncryptionFilter;
using CryptoPP::AuthenticatedDecryptionFilter;
using namespace std;

#include ""cryptoplusplus/filters.h""
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::AuthenticatedEncryptionFilter;
using CryptoPP::AuthenticatedDecryptionFilter;

#include ""cryptoplusplus/blowfish.h""
using CryptoPP::Blowfish;

#include ""crypto++/eax.h""
using CryptoPP::EAX;

#include ""cryptoplusplus/secblock.h""
using CryptoPP::SecByteBlock;

int main( int argc, char* argv[] ) {
    // Declaring variables
    const int NUMBER_OF_RUNS = 3;
    const int NUMBER_OF_TXT_FILES = 9;
    const int NUMBER_OF_JPG_FILES = 6;
    const int NUMBER_OF_PNG_FILES = 6;
    const int NUMBER_OF_AVI_FILES = 2;

    string file_names_txt[NUMBER_OF_TXT_FILES] = { ""10B.txt"", ""100B.txt"", ""1KB.txt"", ""10KB.txt"", ""100KB.txt"", ""1MB.txt"", ""5MB.txt"", ""10MB.txt"", ""20MB.txt"" };
    string file_names_jpg[NUMBER_OF_JPG_FILES] = { ""1KB.jpg"", ""10KB.jpg"", ""100KB.jpg"", ""1MB.jpg"", ""3MB.jpg"", ""5MB.jpg"" };
    string file_names_png[NUMBER_OF_PNG_FILES] = { ""100B.png"", ""500B.png"",""1KB.png"", ""10KB.png"",""1MB.png"", ""5MB.png"" };
    string file_names_avi[NUMBER_OF_AVI_FILES] = { ""4MB.avi"", ""10MB.avi"" };

    int time_data [NUMBER_OF_RUNS];
    string plaintext, cipher, encoded, recovered, sample_files_path, data_file, line_contents; 
    string initial_cpp_time_data = """";
    clock_t time_start, time_stop;
    double run_time, time_difference, time_average = 0;

    // This loop will run the test NUMBER_OF_RUNS times
    for ( int i = 0 ; i &lt; NUMBER_OF_RUNS ; i++ ) {
        time_start = clock();

    // This class seeds itself using an operating system provided RNG
    AutoSeededRandomPool prng;
    // Generate a random key
    SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
    prng.GenerateBlock(key, key.size());
    // Generate a random initialization vector
    byte iv[Blowfish::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
    // Set key width
    EAX&lt; Blowfish &gt;::Encryption e;
    e.SetKeyWithIV(key, key.size(), iv);

    // Grab the data from the file we want to run the test on
    sample_files_path = ""sample_files/"" + file_names_txt[8];
    ifstream initial_file_contents ( sample_files_path.c_str() );
    if (initial_file_contents.is_open()) {
        while ( getline( initial_file_contents, line_contents ) ) {
            plaintext = plaintext + line_contents;
            plaintext.push_back('\n');
            initial_file_contents.close();
        }
    } else {
        cout &lt;&lt; ""Unable to open file"" &lt;&lt; endl;
    }

    // Encrypts the plaintext
    try {
        StringSource(plaintext, true, new AuthenticatedEncryptionFilter(e, new StringSink(cipher) ) ); 
    } catch ( const CryptoPP::Exception&amp; e ) {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }


        // Decrypts the test
        try {
            EAX&lt; Blowfish &gt;::Decryption d;
            d.SetKeyWithIV(key, key.size(), iv);
            StringSource s(cipher, true, new AuthenticatedDecryptionFilter( d, new StringSink(recovered) ) );
        } catch ( const CryptoPP::Exception&amp; e ) {
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            exit(1);
        }

        // Stop the clock, calculate the time difference, turn to milliseconds
        time_stop = clock();
        time_difference = time_stop - time_start;
        run_time = time_difference / ( CLOCKS_PER_SEC / 1000 );
        time_data[i] = run_time;
        cout &lt;&lt; ""time_data["" &lt;&lt; i &lt;&lt; ""]: "" &lt;&lt; time_data[i] &lt;&lt; "" milliseconds"" &lt;&lt; endl;
    }

    //Grab the data from the old file
    ifstream initial_cpp_time_data_file ( ""cpp_time_data.txt"" );
    if (initial_cpp_time_data_file.is_open()) {
        while ( getline( initial_cpp_time_data_file, line_contents ) ) {
            initial_cpp_time_data = initial_cpp_time_data + line_contents;
            initial_cpp_time_data.push_back('\n');
        }
            initial_cpp_time_data_file.close();
    } else {
        initial_cpp_time_data = """";
    }

    // Created a new file
    ofstream time_data_file;
    time_data_file.open(""cpp_time_data.txt"");

    // Insert old data first
    time_data_file &lt;&lt; initial_cpp_time_data &lt;&lt; endl;

    // Show the file the test ran on and insert the new data
    time_data_file &lt;&lt; sample_files_path &lt;&lt; endl;
    for ( int i = 0 ; i &lt; NUMBER_OF_RUNS ; i++ ) {
        time_data_file &lt;&lt; ""time_data["" &lt;&lt; i &lt;&lt; ""]: "" &lt;&lt; time_data[i] &lt;&lt; "" milliseconds"" &lt;&lt; endl;
        time_average = time_average + time_data[i];
    }
    time_average = time_average / NUMBER_OF_RUNS;
    time_data_file &lt;&lt; ""The average time for this is "" &lt;&lt; time_average &lt;&lt; "" milliseconds"" &lt;&lt; endl;
    cout &lt;&lt; ""The average time for this is "" &lt;&lt; time_average &lt;&lt; "" milliseconds"" &lt;&lt; endl;
    time_data_file.close();
    cout &lt;&lt; ""Done!\n"";

    return 0;
}
</code></pre>
","<p>At each iteration of the loop, you have to call:</p>

<ul>
<li><code>cipher.clear()</code></li>
<li><code>recovered.clear()</code></li>
</ul>

<p>Otherwise, the <code>StringSink</code>'s just keep adding to the end of a previous value. You will fail on the 2nd and subsequent iterations of your loop (the 1st should be OK).</p>

<p>Also, there is no <code>Resynchronize</code>, so you can't call <code>e.Resynchronize(iv)</code> to restart a cipher. You have to call <code>e.SetKeyWithIV(key, key.size(), iv)</code> at each iteration of your loop.</p>

<p>Below, I could not duplicate your reuse problem. The encryption object was reused, while the decryption object was created new for each iteration. The result of running the program:</p>

<pre><code>$ ./cryptopp-test.exe
plain text: String 1
recovered text: String 1
plain text: String 2
recovered text: String 2
plain text: String 3
recovered text: String 3
plain text: String 4
recovered text: String 4
plain text: String 5
recovered text: String 5
</code></pre>

<hr>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte iv[ Blowfish::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

vector&lt;string&gt; vv;
vv.push_back(""String 1"");
vv.push_back(""String 2"");
vv.push_back(""String 3"");
vv.push_back(""String 4"");
vv.push_back(""String 5"");

string plain, cipher, recovered;

try {

    EAX&lt; Blowfish &gt;::Encryption e1;
    e1.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

    for(unsigned i = 0; i &lt; vv.size(); i++)
    {
        /*********************************\
        \*********************************/

        plain = vv[i];
        cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

        e1.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

        cipher.clear();
        StringSource ss1(plain, true,
                         new AuthenticatedEncryptionFilter( e1,
                             new StringSink( cipher )
                         )  ); // StringSource

        /*********************************\
        \*********************************/

        EAX&lt; Blowfish &gt;::Decryption d2;
        d2.SetKeyWithIV( key, key.size(), iv, sizeof(iv) );

        recovered.clear();
        StringSource ss2(cipher, true,
                         new AuthenticatedDecryptionFilter( d2,
                             new StringSink( recovered ),
                             AuthenticatedDecryptionFilter::THROW_EXCEPTION
                         ) ); // StringSource

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
    }

} catch (const Exception&amp; ex) {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>
","524","<c++><linux><encryption><blowfish><crypto++>","1","2","1","2014-04-26 23:01:09","23303750","1","","","","","2014-04-25 18:42:41",""
"44597569","Crypto++ build with msvc /MDd cryptlib.lib Can't find cryptopp.lib when linking","<p>I built the last available version of the library (5.6.5) wanting to use it in a Qt msvc project. The issue is, that the linker want's for some reason the cryptopp.lib that is produced when building the fips dll.</p>

<p>This is my config (only the relevant):</p>

<pre><code>INCLUDEPATH += $$PWD/thirdparty/Win/cryptopp/include
LIBS += -L$$PWD/thirdparty/Win/cryptopp/debug/ -lcryptlib
</code></pre>

<p>The compiler output: </p>

<pre><code>LINK : fatal error LNK1104: cannot open file 'cryptopp.lib'
</code></pre>

<p>EDIT: 
The link command + the result: Which the result is the same as above.</p>

<p><code>link /NOLOGO /DYNAMICBASE /NXCOMPAT /NODEFAULTLIB:MSVCRT /DEBUG /SUBSYSTEM:WINDOWS ""/MANIFESTDEPENDENCY:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' publicKeyToken='6595b64144ccf1df' language='*' processorArchitecture='*'"" /MANIFEST:embed /OUT:debug\QtTrafficBrowser.exe @C:\Users\Mij\AppData\Local\Temp\QtTrafficBrowser.exe.1316.6203.jom
LINK : fatal error LNK1104: cannot open file 'cryptopp.lib'
jom: C:\Users\Mij\qt_creator\qtTrafficBrowser\build-QtTrafficBrowser-Desktop_Qt_5_8_0_MSVC2015_32bit-Debug\Makefile.Debug [debug\QtTrafficBrowser.exe] Error 1104
jom: C:\Users\Mij\qt_creator\qtTrafficBrowser\build-QtTrafficBrowser-Desktop_Qt_5_8_0_MSVC2015_32bit-Debug\Makefile [debug] Error 2</code></p>

<p>I am not trying to use the DLL!! I know it's different and I knew it from the start so stop asking me not to use it. The problem is that when linking with cryptlib.lib the linker asks for cryptopp.lib also. Is it clear?</p>
","<p>I was dumb.
I added the dll.h into my project, that's why it was asking for the cryptopp.lib. 
Removed it, and boom, works. </p>

<p>People having a similar issue, look at this also. <a href=""https://stackoverflow.com/questions/32846409/lnk1104-cryptopp-lib-with-cryptopp-default-no-dll-defined-in-dll-project"">LNK1104 Cryptopp.lib with CRYPTOPP_DEFAULT_NO_DLL defined in dll project</a></p>
","504","<c++><windows><qt><crypto++>","0","0","1","2017-06-19 11:44:16","44629664","7","","3666125","","2017-06-19 11:20:24","2017-06-16 20:34:48",""
"46052701","How to use Crypto++ to perfom DH key exchange (CryptoPP::DH::Agree returns false)","<p>I'm trying to use Crypto++ to perform Diffie-Hellman key exchange. I have written a simple program to check if this is working. As you can guess, it is not.</p>

<p>This program was written based on wiki article: <a href=""https://www.cryptopp.com/wiki/Diffie-Hellman"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Diffie-Hellman</a> It is generating public and private keys and then uses them to cal function <code>CryptoPP::DH::Agree</code>. It was working when I was using the same pair of keys for both sides like it is on the wiki. This does not have much practical sense though. However, when I trying to use different keys, <code>CryptoPP::DH::Agree</code> returns <code>false</code>.</p>

<p>I suspect that I'm doing something incorrectly but I have no idea what.</p>

<pre class=""lang-c++ prettyprint-override""><code>#include &lt;crypto++/cryptlib.h&gt;
#include &lt;crypto++/dh.h&gt;
#include &lt;cryptopp/dh2.h&gt;
#include &lt;crypto++/osrng.h&gt;
#include &lt;crypto++/integer.h&gt;
#include &lt;crypto++/nbtheory.h&gt;
#include &lt;iostream&gt;


static CryptoPP::AutoSeededRandomPool rnd;
static CryptoPP::DH dhA, dhB;
static CryptoPP::SecByteBlock privKeyA, pubKeyA, privKeyB, pubKeyB;


static void createDomainParameters(CryptoPP::DH &amp;dh)
{
    CryptoPP::PrimeAndGenerator pg;
    pg.Generate(1, rnd, 512, 511);
    const CryptoPP::Integer p = pg.Prime();
    const CryptoPP::Integer q = pg.SubPrime();
    const CryptoPP::Integer g = pg.Generator();

    std::cout &lt;&lt; ""P: "" &lt;&lt; p &lt;&lt; '\n';
    std::cout &lt;&lt; ""Q: "" &lt;&lt; q &lt;&lt; '\n';
    std::cout &lt;&lt; ""G: "" &lt;&lt; g &lt;&lt; '\n';

    dh = CryptoPP::DH(p, q, g);
}

static void createAsymetricKey(const CryptoPP::DH &amp;dh, CryptoPP::SecByteBlock &amp;privKey, CryptoPP::SecByteBlock &amp;pubKey)
{
    privKey = CryptoPP::SecByteBlock(dh.PrivateKeyLength());
    pubKey = CryptoPP::SecByteBlock(dh.PublicKeyLength());
    dh.GenerateKeyPair(rnd, privKey, pubKey);

    CryptoPP::Integer a, b;

    a.Decode(privKey.BytePtr(), privKey.SizeInBytes());
    std::cout &lt;&lt; ""privKey: "" &lt;&lt; a &lt;&lt; std::endl;

    b.Decode(pubKey.BytePtr(), pubKey.SizeInBytes());
    std::cout &lt;&lt; ""pubKey:  "" &lt;&lt; b &lt;&lt; std::endl;
}

static void createSymetricKey(const CryptoPP::DH &amp;dh, const CryptoPP::SecByteBlock &amp;privKey, const CryptoPP::SecByteBlock &amp;pubKey)
{
    CryptoPP::SecByteBlock shared(dh.AgreedValueLength());
    if(!dh.Agree(shared, privKey, pubKey))
        throw std::runtime_error(""Failed to reach shared secret"");

    CryptoPP::Integer x;
    x.Decode(shared.BytePtr(), shared.SizeInBytes());
    std::cout &lt;&lt; ""shared: "" &lt;&lt; x &lt;&lt; std::endl;
}

int main()
{
    std::cout &lt;&lt; std::hex;

    createDomainParameters(dhA);
    std::cout &lt;&lt; std::endl;
    createDomainParameters(dhB);

    std::cout &lt;&lt; ""\n------------------------------\n"" &lt;&lt; std::endl;
    createAsymetricKey(dhA, privKeyA, pubKeyA);
    std::cout &lt;&lt; std::endl;
    createAsymetricKey(dhB, privKeyB, pubKeyB);

    if(dhA.AgreedValueLength() != dhB.AgreedValueLength())
        throw std::runtime_error(""Shared secret size mismatch"");

    std::cout &lt;&lt; ""\n------------------------------\n"" &lt;&lt; std::endl;
    createSymetricKey(dhA, privKeyA, pubKeyB);
    std::cout &lt;&lt; std::endl;
    createSymetricKey(dhB, privKeyB, pubKeyA);

    return 0;
}
</code></pre>

<p>When you change calls of <code>createSymetricKey</code> so it uses key from the same pair, it works.</p>

<pre class=""lang-c++ prettyprint-override""><code>createSymetricKey(dhA, privKeyA, pubKeyA);
std::cout &lt;&lt; std::endl;
createSymetricKey(dhB, privKeyB, pubKeyB);
</code></pre>

<p>AFAIK this has no sense though. What is the correct way to use <code>CryptoPP::DH::Agree</code>?</p>
","","502","<crypto++><diffie-hellman>","1","","0","2017-09-05 10:25:05","","3","1","","","","2017-09-05 10:25:05",""
"29264531","How can I run in Crypto++ library benchmarks test?","<p>Can someone help me how can I run in Crypto++ benchmarks test?</p>

<p>I have to make some tests. I found Crypto++ but I don't know how use benchmarks test in <a href=""http://www.cryptopp.com/"" rel=""nofollow"">Crypto++</a>. I also want to run them after installing the library.</p>

<p>Thanks for help.</p>
","<blockquote>
  <p>Can someone help me how can I run in Crypto++ benchmarks test?</p>
</blockquote>

<pre><code>$ cd cryptopp-src
$ make static cryptest.exe
$ ./cryptest.exe b 3 2.76566 &gt; benchmarks.html
</code></pre>

<p><code>cryptest.exe</code> takes three arguments: (1) <code>b</code> for benchmarks, (2) <code>time</code> for the length of each test, in seconds, and (3) <code>freq</code> for CPU frequency in GiHz. The example above, each test is run for 3 seconds. And the CPU is 2.8 GHz, which works out to be about 2.76566 GiHz.</p>

<p>You can also do this little trick. It will produce a well-formed HTML page:</p>

<pre><code>$ CRYPTOPP_CPU_FREQ=2.76566 make bench
</code></pre>

<p><em>IF</em> you are using Crypto++ 5.6.5 or earlier, then use <code>CRYPTOPP_CPU_SPEED</code>. If you are using Crypto++ 6.0 or later, then use <code>CRYPTOPP_CPU_FREQ</code>.</p>

<p>The output of the tests will look similar to <a href=""https://www.cryptopp.com/benchmarks.html"" rel=""nofollow noreferrer"">Crypto++ 5.6.0 Benchmarks</a>. It takes 5 or 10 minutes to produce the results.</p>

<p>The source files of interest are <code>test.cpp</code> (handles the <code>b</code> option of <code>cryptest.exe</code>), <code>bench1.cpp</code> and <code>bench2.cpp</code> (implements the benchmarking based on algorithm).</p>

<hr>

<p>We recently added a <a href=""https://www.cryptopp.com/wiki/Benchmarks"" rel=""nofollow noreferrer"">wiki page covering Benchmarks</a>. It discusses the basic stuff like how to run the benchmark suite. It also discusses how that portion of the library operates, like the way algorithms register themselves and how the benchmarks are timed. Also see <a href=""https://www.cryptopp.com/wiki/Benchmarks"" rel=""nofollow noreferrer"">Benchmarks</a> on the Crypto++ wiki.</p>
","502","<benchmarking><crypto++>","1","1","1","2017-11-27 12:58:15","29268094","1","","608639","","2015-04-11 21:36:17","2015-03-25 19:13:57",""
"46989046","CLion and Crypto++ library","<p>Some time ago I started coding my application in Visual Studio 2015, had no issues setting all of the library dependencies.</p>

<p>Now, I decided to move to CLion. However my application has a dependency of <code>cryptopp</code> library, which I need to link in my CLion project.</p>

<p>Currently, I'm facing tons of <code>undefined reference</code> errors</p>

<pre><code>undefined reference to `CryptoPP::Integer::Integer(char const*)'
undefined reference to `CryptoPP::Integer::Integer(char const*)'
undefined reference to `CryptoPP::Integer::Integer(char const*)'
undefined reference to `CryptoPP::DH_Domain&lt;CryptoPP::DL_GroupParameters_GFP_DefaultSafePrime, CryptoPP::EnumToType&lt;CryptoPP::CofactorMultiplicationOption, 0&gt; &gt;::AccessGroupParameters()'
undefined reference to `CryptoPP::DH_Domain&lt;CryptoPP::DL_GroupParameters_GFP_DefaultSafePrime, CryptoPP::EnumToType&lt;CryptoPP::CofactorMultiplicationOption, 0&gt; &gt;::GetGroupParameters() const'
undefined reference to `CryptoPP::DH_Domain&lt;CryptoPP::DL_GroupParameters_GFP_DefaultSafePrime, CryptoPP::EnumToType&lt;CryptoPP::CofactorMultiplicationOption, 0&gt; &gt;::GetGroupParameters() const'
[..]
</code></pre>

<p>I have indeed set include directories in my CMakeLists:</p>

<pre><code>set(EXTERN_LIBS E:/dev/libs)

include_directories(${EXTERN_LIBS} ${EXTERN_LIBS}/include)
link_directories(${EXTERN_LIBS})
</code></pre>

<p>However, I still cannot get it to work.</p>

<p>I'm using MinGW for my project. Here is a preview of settings and versions:</p>

<p><a href=""https://i.stack.imgur.com/eqUeb.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eqUeb.png"" alt=""enter image description here""></a></p>

<p><strong>How can I properly add <code>cryptopp</code> library into my project in CLion?</strong></p>
","<p>I think we may have mostly cleared the MinGW/C++11 issue at <a href=""https://github.com/weidai11/cryptopp/commit/e4cef84883b2"" rel=""nofollow noreferrer"">Commit e4cef84883b2</a>. You should work from Master or perform a <code>git pull</code>, and then uncomment the define for <code>CRYPTOPP_NO_CXX11</code> in <a href=""https://github.com/weidai11/cryptopp/blob/master/config.h#L57"" rel=""nofollow noreferrer""><code>config.h</code> : 65</a> (or so):</p>

<pre><code>// Define CRYPTOPP_NO_CXX11 to avoid C++11 related features shown at the
// end of this file. Some compilers and standard C++ headers advertise C++11
// but they are really just C++03 with some additional C++11 headers and
// non-conforming classes. You might also consider `-std=c++03` or
// `-std=gnu++03`, but they are required options when building the library
// and all programs. CRYPTOPP_NO_CXX11 is probably easier to manage but it may
// cause -Wterminate warnings under GCC. MSVC++ has a similar warning.
// Also see https://github.com/weidai11/cryptopp/issues/529
// #define CRYPTOPP_NO_CXX11 1
</code></pre>

<p>I think the problems is, you are hitting issues related to Windows and its lack of proper C++11 support, but you are getting them indirectly. They are indirect because MinGW and GCC is layered on top. MinGW and GCC cannot possibly provide C++11 because the underlying platform cannot.</p>

<p>I think your best bet at this point is to define <code>CRYPTOPP_NO_CXX11</code>. I don't believe we can do it for you like we do on Windows because the defines we need access to are hidden behind MinGW and GCC. And we also have some MSVC++ bugs to workaround.</p>

<p>Here's how we do it on Windows, but we don't have access to these defines in MinGW (from <code>config.h</code> : 950):</p>

<pre><code>// Dynamic Initialization and Destruction with Concurrency (""Magic Statics"")
// MS at VS2015 with Vista (19.00); GCC at 4.3; LLVM Clang at 2.9; Apple Clang at 4.0; Intel 11.1; SunCC 5.13.
// Microsoft's implementation only works for Vista and above, so its further
// limited. http://connect.microsoft.com/VisualStudio/feedback/details/1789709
#if (CRYPTOPP_MSC_VERSION &gt;= 1900) &amp;&amp; ((WINVER &gt;= 0x0600) || (_WIN32_WINNT &gt;= 0x0600)) || \
    (CRYPTOPP_LLVM_CLANG_VERSION &gt;= 20900) || (CRYPTOPP_APPLE_CLANG_VERSION &gt;= 40000) || \
    (__INTEL_COMPILER &gt;= 1110) || (CRYPTOPP_GCC_VERSION &gt;= 40300) || (__SUNPRO_CC &gt;= 0x5130)
# define CRYPTOPP_CXX11_DYNAMIC_INIT 1
#endif // Dynamic Initialization compilers
</code></pre>

<p>If you define <code>CRYPTOPP_NO_CXX11</code>, then the following will <em>not</em> be defined and you will avoid the problems: <code>CRYPTOPP_CXX11_DYNAMIC_INIT</code>, <code>CRYPTOPP_CXX11_SYNCHRONIZATION</code>, and <code>CRYPTOPP_CXX11_ATOMICS</code>.</p>

<hr>

<p>The second issue, the one related to Clion and Cmake, was settled as follows. We setup a separate GitHub with our Autotools and Cmake files. The Autotools  files are at <a href=""https://github.com/noloader/cryptopp-autotools"" rel=""nofollow noreferrer"">cryptopp-autotools</a>, and the Cmake files are at <a href=""https://github.com/noloader/cryptopp-cmake"" rel=""nofollow noreferrer"">cryptopp-cmake</a>.</p>

<p>The repositories are in my GiHub because this is the sort of administrivia that Wei Dai, who wrote the library and provides the Crypto++ GitHub, prefers to avoid. The logical separation also helps establish the logical boundary so folks know Autotools and CMake are not part of the official Crypto++ distribution.</p>

<p>The community is responsible for Autotools and Cmake, and we will work with the community on issues. If the community puts in the work, then Autotools and Cmake will improve. If either Autotools or CMake gets stable, then we will add a tarball with the files to the official distribution.</p>

<p>Currently Autotools and Cmake are in states that needs improvement. The problems with Cmake are detailed at <a href=""https://www.cryptopp.com/wiki/CMake#Current_Status"" rel=""nofollow noreferrer"">CMake | Current Status</a> on the wiki. The problems with Autotools are not really documented because I work with distro maintainers on them. Its kind of like we know what the prolems are, but most others do not.</p>
","501","<c++><mingw><static-libraries><clion><crypto++>","3","2","1","2017-11-06 15:41:54","47139733","9","0","608639","","2017-10-29 12:11:15","2017-10-28 11:10:58",""
"37488545","How to build Crypto++ 5.6.2 in for Qt with Visual Studio 2013?","<p>I'm trying to build Crypto++ 5.6.2 in for Qt with Visual Studio 2013, but its producing errors. Here is what I've done so far.</p>

<ul>
<li>Downloaded <a href=""http://www.cryptopp.com/#download"" rel=""nofollow"">Crypto++ 5.6.2</a></li>
<li>Downloaded <a href=""http://www.cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow"">vs2010.zip</a> and <a href=""http://www.cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow"">vs2010-dynamic.zip</a> and overwrite the exiting project files.</li>
</ul>

<p>The page says this about <code>vs2010-dynamic.zip</code>, but the ZIP includes only <code>cryptest.sln</code> for VS2005. Just a single file. But anyway, I used the file:</p>

<blockquote>
  <p>archive of a pre-converted solution file, project files and filters for Visual Studio 2010 and above."" </p>
</blockquote>

<p>I then:</p>

<ul>
<li><p>Opened <code>cryptest.sln</code> in MSVC2013, and set ""Multi-threaded DLL (/MD)"" for each project (project --> properties --> C/C++ --> Code Generation --> Runtime Library --> /MD)</p></li>
<li><p>Build --> 'Batch Build' --> Check cryptdll, cryptest, cryptlib, dlltest (Release|win32) --> Build</p></li>
</ul>

<p>It resulted in a DLL and LIB in <code>DLL_Output</code> directory. I then:</p>

<ul>
<li>Moved the DLL to the directory where Qt executable resides.</li>
<li>In Qt, I added two lines to <code>test.pro</code>:

<ul>
<li><code>INCLUDEPATH += ""../extern/msvc2013/cryptopp562/include""</code></li>
<li><code>LIBS += -L""..\extern\msvc2013\cryptopp562\include\cryptopp\Win32\DLL_Output\Release"" -lcryptopp</code></li>
</ul></li>
</ul>

<p>But in Qt, I've got the following errors:</p>

<pre><code>mainwindow.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned __int64 __thiscall CryptoPP::ThreadUserTimer::GetCurrentTimerValue(void)"" (?GetCurrentTimerValue@ThreadUserTimer@CryptoPP@@UAE_KXZ)

mainwindow.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned __int64 __thiscall CryptoPP::ThreadUserTimer::TicksPerSecond(void)"" (?TicksPerSecond@ThreadUserTimer@CryptoPP@@UAE_KXZ)

mainwindow.obj:-1: error: LNK2019: unresolved external symbol ""class CryptoPP::NameValuePairs const &amp; const CryptoPP::g_nullNameValuePairs"" (?g_nullNameValuePairs@CryptoPP@@3ABVNameValuePairs@1@B) referenced in function ""public: __thiscall CryptoPP::HMAC::HMAC(unsigned char const *,unsigned int)"" (??0?$HMAC@VSHA256@CryptoPP@@@CryptoPP@@QAE@PBEI@Z)

release\user_account_registration.exe:-1: error: LNK1120: 3 unresolved externals
</code></pre>

<p>Do you have any ideas why I am getting the errors?</p>

<p>Any help/comment/insight would be really appreciated.</p>
","<pre><code>mainwindow.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned __int64 __thiscall CryptoPP::ThreadUserTimer::GetCurrentTimerValue(void)"" (?GetCurrentTimerValue@ThreadUserTimer@CryptoPP@@UAE_KXZ)

mainwindow.obj:-1: error: LNK2001: unresolved external symbol ""public: virtual unsigned __int64 __thiscall CryptoPP::ThreadUserTimer::TicksPerSecond(void)"" (?TicksPerSecond@ThreadUserTimer@CryptoPP@@UAE_KXZ)

mainwindow.obj:-1: error: LNK2019: unresolved external symbol ""class CryptoPP::NameValuePairs const &amp; const CryptoPP::g_nullNameValuePairs"" (?g_nullNameValuePairs@CryptoPP@@3ABVNameValuePairs@1@B) referenced in function ""public: __thiscall CryptoPP::HMAC::HMAC(unsigned char const *,unsigned int)"" (??0?$HMAC@VSHA256@CryptoPP@@@CryptoPP@@QAE@PBEI@Z)
</code></pre>

<p>If you look at the source code for <a href=""http://github.com/weidai11/cryptopp/blob/master/hrtimer.h"" rel=""nofollow"">hrtimer.h</a>, <code>ThreadUserTimer</code> is missing <code>CRYPTOPP_DLL</code>. That means the DLL does not export <code>ThreadUserTimer</code> (and many other classes).</p>

<p>In general, you should avoid the <a href=""http://cryptopp.com/wiki/Fips_dll"" rel=""nofollow"">FIPS DLL</a> unless you have a hard requirement to do so. Its special purpose, and its not easy to work with. It also has <em>Operational Environment</em> requirements from FIPS 140-2. I doubt you want to limit yourself to Visual Studio 2005 and Windows Server 2003.</p>

<p>If you insist on using the <a href=""http://cryptopp.com/wiki/Fips_dll"" rel=""nofollow"">FIPS DLL</a>, then you need to link against the DLL as expected. ""As expected"" means you use the <code>cryptopp.lib</code> import library at compile/link time; and <code>cryptopp.dll</code> at runtime. You also have to link again <code>cryptlib.lib</code> to get the missing classes, like <code>ThreadUserTimer</code>, while setting <code>CRYPTOPP_IMPORTS</code> to avoid duplicate symbols when using both libraries.</p>

<hr>

<p>Instead of using the DLL, download the updated (and fixed) <code>vs2010-dynamic.zip</code>. Use it to build the Crypto++ library and then use the static library. ""Use the static library"" means to link against <code>cryptlib.lib</code> only.</p>

<p>The project files from <code>vs2010-dynamic.zip</code> might reference some source files that you don't have because its built from the latest stable sources. If the source file is missing, then simply delete it from the project file. Off the top of my head, Crypto++ 5.6.2 should be missing HKDF, RDRAND, RDSEED, ChaCha, BLAKE2, Base64URLEncoder, Base64URLDecoder, etc. It also lacks the rename of <code>bench.cpp</code> to <code>bench1.cpp</code>.</p>

<p>The <a href=""http://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow"">Visual Studio</a> wiki page has more information on Windows project files and artifacts like <code>cryptlib.lib</code>.</p>

<hr>

<pre><code>INCLUDEPATH += "".../cryptopp562/include""
LIBS += -L""...\cryptopp562\include\cryptopp\Win32\DLL_Output\Release"" -lcryptopp
</code></pre>

<p>I think you should use <em>only</em> <code>-lcryptlib</code> because its the static library, and it has everything you need. The path to the library is <code>$(Platform)\Output\$(Configuration)</code>, but I don't know how to translate it into something QT composer can use.</p>

<p>Otherwise, I think you need to specify both <code>-lcryptopp -lcryptlib</code>, and add <code>CRYPTOPP_IMPORTS</code> to preprocessor definitions.</p>

<hr>

<p><a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010.zip</code></a>, <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2010-dynamic.zip</code></a> and <a href=""http://cryptopp.com/wiki/Visual_Studio#Downloads"" rel=""nofollow""><code>vs2005-dynamic.zip</code></a> are built from the <a href=""http://github.com/weidai11/cryptopp"" rel=""nofollow"">latest GitHub sources</a>. As of this writing (JUN 1 2016), that's effectively pre-Crypto++ 5.6.4. If you are using the ZIP files with a down level Crypto++, like 5.6.2 or 5.6.3, then you will run into minor problems.</p>

<p>There are two minor problems I am aware. First is a rename of <a href=""http://groups.google.com/d/msg/cryptopp-users/Inz3uhNxd4g/Y6VJPUg4EQAJ"" rel=""nofollow""><code>bench.cpp</code> to <code>bench1.cpp</code></a>. Its error is either:</p>

<ul>
<li><code>C1083: Cannot open source file: 'bench1.cpp': No such file or directory</code></li>
<li><code>LNK2001: unresolved external symbol ""void __cdecl OutputResultOperations(char const *,char const *,bool,unsigned long,double)"" (?OutputResultOperations@@YAXPBD0_NKN@Z)</code></li>
</ul>

<p>The fix is to either (1) open <code>cryptest.vcxproj</code> in notepad, find <code>bench1.cpp</code>, and then rename it to <code>bench.cpp</code>. Or (2) rename <code>bench.cpp</code> to <code>bench1.cpp</code> on the filesystem.</p>

<p>The second problem is a little trickier because its a moving target. Down level releases, like 5.6.2 or 5.6.3, are missing the latest classes available in <a href=""http://github.com/weidai11/cryptopp"" rel=""nofollow"">GitHub</a>. They include HKDF (5.6.3), RDRAND (5.6.3), RDSEED (5.6.3), ChaCha (5.6.4), BLAKE2 (5.6.4), Poly1305 (5.6.4), etc.</p>

<p>The fix is to remove the missing source files from the Visual Studio project files since they don't exist for the down level releases.</p>

<p>Another option is to add the missing class files from the latest sources, but there could be complications. For example, many of the sources subtly depend upon the latest <code>config.h</code>, <code>cpu.h</code> and <code>cpu.cpp</code>. The ""subtlety"" is you won't realize you are getting an under-performing class.</p>

<p>An example of under-performing class is BLAKE2. <code>config.h</code> adds compile time ARM-32 and ARM-64 detection. <code>cpu.h</code> and <code>cpu.cpp</code> adds runtime ARM instruction detection. If you add BLAKE2 without the other files, then none of the detection occurs and you get a straight C/C++ implementation. The NEON implementation runs around 9 to 12 cycles per byte, while the C/C++ implementation runs around 40 cycles per byte.</p>
","500","<qt><dll><crypto++>","0","0","1","2016-06-01 09:25:07","37494396","11","","608639","","2016-06-01 00:58:59","2016-05-27 16:41:15",""
"36209805","Error verifying message using Crypto++ on iOS","<h1>Problem</h1>

<p>I am trying to verify a given message with its signature and public key. It works fine using the iOS provided Security Framework, but I cannot manage to make it work using the Crypto++ library (must use).</p>

<p>I followed the same steps using the CryptoPP Library and verified everything 10 times, rewrote some parts differently, but it still throws the same exception: </p>

<blockquote>
  <p>""PK_Signer: key too short for this signature scheme""</p>
</blockquote>

<h1>context</h1>

<h3>Data worked with</h3>

<ul>
<li>I receive a JWT (Json Web Token) with a header, payload and signature.</li>
<li>I retrieve the service's base64 encoded X509 certificate (which includes the public key).</li>
</ul>

<h3>Steps followed for verification</h3>

<ol>
<li><p><strong>Certificate</strong></p>

<ol>
<li>Base64 decode the certificate</li>
<li>Extract the public key from certificate</li>
</ol></li>
<li><p><strong>Signature (third segment of a JWB)</strong></p>

<ol>
<li>Pad the signature to a multiple of 4 with some ""=""</li>
<li>URLBase64 decode it</li>
</ol></li>
<li><p><strong>Message to verify</strong></p>

<ol>
<li>Message = (JSW Header) + ""."" + (JWT Payload). This is already done in the code, message is argument named ""headerAndPayload.</li>
</ol></li>
<li><p><strong>Verify SHA256 bytes with PKCS1, RSA</strong></p>

<ol>
<li>SHA256 digest of the Message</li>
<li>Verification using:

<ol>
<li>Public Key</li>
<li>SHA256 Digest of the message</li>
<li>Signature</li>
</ol></li>
</ol></li>
</ol>

<h2>iOS Working Code</h2>

<p>(Only parts that matter, as verification works fine on iOS)</p>

<ul>
<li><p><strong>Certificate</strong></p>

<ol>
<li><p><code>NSData *certificateData = [[NSData alloc] initWithBase64EncodedString:certificateString options:0];</code></p></li>
<li><p><code>SecKeyRef getPublicKeyFromCertificate(certificateData)</code> found online, works fine.</p></li>
</ol></li>
<li><p><strong>Verify SHA256 bytes with PKCS1, RSA</strong></p>

<pre><code>BOOL PKCSVerifyBytesSHA256withRSA(NSData* message, NSData* signature, SecKeyRef publicKey)
{
    size_t signedHashBytesSize = SecKeyGetBlockSize(publicKey);
    const void* signedHashBytes = [signature bytes];

    size_t hashBytesSize = CC_SHA256_DIGEST_LENGTH;
    void* hashBytes = malloc(hashBytesSize);
    if (!CC_SHA256([message bytes], (CC_LONG)[message length], hashBytes)) {
        return NULL;
    }

    OSStatus status = SecKeyRawVerify(publicKey,
                                  kSecPaddingPKCS1SHA256,
                                  hashBytes,
                                  hashBytesSize,
                                  signedHashBytes,
                                  signedHashBytesSize);

    return status == errSecSuccess;
}
</code></pre></li>
</ul>

<h2>Code using CryptoPP Library (working with same set of data)</h2>

<p>I copy/paste the whole code with numbers corresponding to the description and some additional comments, like size of structures returned.</p>

<pre><code>+(bool)verifyBase64EncodedCertificate:(NSString *)certificateString
         base64URLEncodedJWTSignature:(NSString *)urlEncodedSignature
                              message:(NSString *)headerAndPayload
{
    // 1. Certificate
    // 1.1 Decode the certificate
    std::string base64EncodedCertificate = certificateString.UTF8String;
    std::string decodedCertificate;
    CryptoPP::StringSource ss(base64EncodedCertificate,
                              true,
                              new CryptoPP::Base64Decoder(new CryptoPP::StringSink(decodedCertificate))
                              );

    // 1.2 Extract Public Key from certificate
    CryptoPP::ByteQueue certificateByteQueue, publicKeyByteQueue;
    certificateByteQueue.Put((byte *)&amp;decodedCertificate[0], decodedCertificate.size());
    certificateByteQueue.MessageEnd();
    try
    {
        GetPublicKeyFromCert(certificateByteQueue, publicKeyByteQueue);
        // This method comes from CryptoPP docs so I assume it works... certificate gets checked again later on.
    }
    catch(std::exception &amp;)
    {
        std::cerr &lt;&lt; ""Failed to extract the public key from the CA certificate."" &lt;&lt; std::endl;
        return nil;
    }
    //publicKeyByteQueue.CurrentSize() = 294


    // 2. Decode Signature
    std::string base64URLEncodedSignature = urlEncodedSignature.UTF8String;
    unsigned long paddingForURLEncodedSignature = 4 - (base64URLEncodedSignature.length() % 4);
    base64URLEncodedSignature.insert(base64URLEncodedSignature.begin(), paddingForURLEncodedSignature, '=');
    std::string decodedSignature;
    CryptoPP::StringSource ss1(base64URLEncodedSignature,
                               true,
                               new CryptoPP::Base64URLDecoder(new CryptoPP::StringSink(decodedSignature))
                               );
    const byte *decodedSignaturePointer = (byte *)&amp;decodedSignature[0];
    size_t decodedSignatureSize = decodedSignature.size();

    // Certificate Signature as Byte Block
    CryptoPP::SecByteBlock certSignature;
    certSignature.Assign(decodedSignaturePointer, decodedSignatureSize);

    // decodedSignatureSize = 256
    // certSignature.size() = 256


    // 3. Message to verify (available already concatenated)
    std::string message = headerAndPayload.UTF8String;
    const byte *messagePointer = (const byte *)message.c_str();
    const size_t messageLength = message.length();        
    // MessageLength = 693

    // 4.1 hash message using SHA256
    byte digest [CryptoPP::SHA256::DIGESTSIZE];
    CryptoPP::SHA256().CalculateDigest(digest, messagePointer, messageLength);

    // 4.2  Create Verifier assigned public key and test
    CryptoPP::AutoSeededRandomPool prng;
    CryptoPP::RSASS&lt;CryptoPP::PKCS1v15, CryptoPP::SHA256&gt;::Verifier verifier;
    verifier.AccessKey().Load(publicKeyByteQueue);
    if (!verifier.AccessKey().Validate(prng, 3))
    {
        throw CryptoPP::Exception(CryptoPP::Exception::OTHER_ERROR, ""Failed to validate public key"");
    }        

    // verifier.SignatureLength() = 256 = certSignature.size()
    if(certSignature.size() != verifier.SignatureLength())
    {
        std::cerr &lt;&lt; ""The signature size is does not match the algorithm used for signing."" &lt;&lt; std::endl;
        return 0;
    }

    // 4. Actual Verification (1st way of doing it)
    CryptoPP::SignatureVerificationFilter vf(verifier);
    try
    {
        vf.Put(digest, CryptoPP::SHA256::DIGESTSIZE);
        vf.Put(certSignature, certSignature.size());
        vf.MessageEnd(); // Throws exception here PK_Signer: key too short for this signature scheme
    }
    catch(std::exception &amp;e)
    {
        std::cerr &lt;&lt; ""Caught an exception while verifying the signature:"" &lt;&lt; std::endl;
        std::cerr &lt;&lt; ""\t"" &lt;&lt; e.what() &lt;&lt; std::endl;
        return 0;
    }
    if(vf.GetLastResult())
    {
        std::cout &lt;&lt; ""The signature verified."" &lt;&lt; std::endl;
    }
    else
    {
        std::cout &lt;&lt; ""Signature verification failed."" &lt;&lt; std::endl;
    }
    return 1;


    // 4. Actual Verification (2d way of doing it)
    bool verified = verifier.VerifyMessage(digest,                  CryptoPP::SHA256::DIGESTSIZE,
                                           decodedSignaturePointer, decodedSignatureSize);
    // Also throw same exception PK_Signer: key too short for this signature scheme

    return verified;
</code></pre>

<p>The only difference I can see between the pure iOS code and the CryptoPP code is during the verification process, the iOS method takes an additional argument <em>kSecPaddingPKCS1SHA256</em></p>

<pre><code>SecKeyRawVerify(publicKey,
                kSecPaddingPKCS1SHA256,
                ...)
</code></pre>

<p>But otherwise I feel like I have replicated exactly the same concepts using the CryptoPP library.</p>

<p>Any help is very appreciated, thanks.</p>
","<blockquote>
  <p>vf.Put(digest, CryptoPP::SHA256::DIGESTSIZE);</p>
</blockquote>

<p>The signature is <em>not</em> the hash size. The signature is the size of the modulus (or more correctly, <strong><em><code>[0,n-1]</code></em></strong>). After protocol framing, the signature may be larger than the modulus size. Also see <a href=""https://crypto.stackexchange.com/q/3505"">What is the length of an RSA signature?</a> on the Cryptography Stack Exchange.</p>

<p>As for creating an equivalent iOS example, using the ""Raw Sign"" or ""Raw Encrypt"", see <a href=""http://www.cryptopp.com/wiki/Raw_RSA"" rel=""nofollow noreferrer"">Raw RSA</a> on the Crypto++ wiki. Its usually a bad idea for you to do the low level things like a modular exponentiation. You should try to stay in the protocols and cryptosystems, like <code>RSASSA_PKCS1v15_SHA_Signer</code> and <code>RSASSA_PKCS1v15_SHA_Verifier</code>.</p>

<p>Also checkout the <a href=""http://www.cryptopp.com/docs/ref/annotated.html"" rel=""nofollow noreferrer""><code>RSASS</code> class</a>, which is RSA Signature Scheme. I'm guessing you will probably want a <code>RSASS&lt;PKCS1v15, SHA256&gt;::Signer</code> and <code>RSASS&lt;PKCS1v15, SHA256&gt;::Verifier</code>:</p>

<pre><code>$ grep -IR Signer * | grep typedef
luc.h:typedef LUCSS&lt;PKCS1v15, SHA&gt;::Signer LUCSSA_PKCS1v15_SHA_Signer;
pubkey.h:   typedef PK_FinalTemplate&lt;TF_SignerImpl&lt;SchemeOptions&gt; &gt; Signer;
pubkey.h:   typedef PK_FinalTemplate&lt;DL_SignerImpl&lt;SchemeOptions&gt; &gt; Signer;
rsa.h:typedef RSASS&lt;PKCS1v15, SHA&gt;::Signer RSASSA_PKCS1v15_SHA_Signer;
rsa.h:typedef RSASS&lt;PKCS1v15, Weak1::MD2&gt;::Signer RSASSA_PKCS1v15_MD2_Signer;
rsa.h:typedef RSASS&lt;PKCS1v15, Weak1::MD5&gt;::Signer RSASSA_PKCS1v15_MD5_Signer;
</code></pre>
","495","<ios><security><rsa><public-key><crypto++>","1","0","1","2016-04-02 02:29:52","36368423","0","","608639","","2016-04-02 02:03:58","2016-03-24 20:52:46",""
"43818185","Build crypto562 with minGW","<p>I have an application which has been build (compiled) on mingw 4.8.1, crypto562,boost 1_58_0 and uses openssl 0.9.8h. </p>

<p>For this, I am using: 
<code>g++ -std=c++11 -s -D_WIN32_WINNT=0x0501 LOG.cpp -U__STRICT_ANSI__  Jobs.cpp Crdir.cpp Upload.cpp TCP_UPGRADED.cpp -o E:\Happy.exe  -IC:\\MinGW\\ -IC:\\MinGW\\boost  -LC:\\MinGW -lssl -lcrypto -lgdi32 -lboost_program_options-mgw48-mt-1_58 -lboost_system-mgw48-mt-1_58 -lboost_filesystem-mgw48-mt-1_58 -lPCRYPT  -ltiny  -lwsock32 -lws2_32 -lShlwapi</code> command to compile it. It works fine. </p>

<p>But now I upgraded Opensll, wingwm, boost library to opensll 1.1.0e, boost1_64.
If I compile, I get error like duplicate section.</p>

<pre><code>C:\\MinGW/libcryptopp.a(randpool.o): duplicate section `.rdata$_ZTVN8CryptoPP8ClonableE[__ZTVN8CryptoPP8ClonableE]has different size
</code></pre>

<p>so I thought I need to build crypto library with upgraded library, but I don't have any idea how to build with mingw environment,
in internet i am getting support or suggestions related to VS and QT library.</p>

<p>Please help me to generate (Build) a <code>libcryptopp.a</code> file.</p>
","<p>I am able to generated <code>libcryptopp.a</code> library by following 
 the step mentioned over in this link <a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow noreferrer"">click here</a> and</p>

<ol>
<li>set PATH=%PATH%;C:\MinGW\msys2\usr\bin 
(if you don't have msys2 then download the msys2 and update it )</li>
<li>cd C:\cryptopp</li>
<li>mingw32-make</li>
<li>mingw32-make test</li>
<li>mkdir include\cryptopp</li>
<li>mkdir lib</li>
<li>copy *.h include\cryptopp</li>
<li>copy *.a lib</li>
</ol>
","493","<c++><windows><mingw><crypto++>","1","2","1","2017-05-13 03:32:42","43893480","1","","6227615","","2017-05-06 11:40:18","2017-05-06 08:06:33",""
"43833859","AES/CFB Cipher mode decrypting from the string fail","<p>Seems like I misunderstand how is CFB cipher mode works. This leads to an error. Approaches 1 and 2 do not work because I am reading encrypted text from a created string. But approach 3 works because it gets crypted text from c string just encrypted. Can't figure it out why?</p>

<p>Code:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

#include ""modes.h""
#include ""aes.h""
#include ""filters.h""

using namespace std;
using namespace CryptoPP;

int main()
{
    byte key[AES::DEFAULT_KEYLENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6' };
    byte iv[AES::BLOCKSIZE] = { '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8' };

    string data = ""fur fur fur fur fur"";

    cout &lt;&lt; ""1: Original text: "" &lt;&lt; data &lt;&lt; endl;

    CFB_Mode&lt;AES&gt;::Encryption cfbEncryption(key, sizeof(key), iv);
    const char* data_c_str = data.c_str();
    cfbEncryption.ProcessData((byte*)data_c_str, (byte*)data_c_str, data.length() + 1);

    cout &lt;&lt; ""2: Encrypted text: "" &lt;&lt; data_c_str &lt;&lt; endl;

    string d(data_c_str); // after assigning c str to a string. Can get it to work!
    const char* data_c_str2 = d.c_str(); // get c str. Now the value of it the same as data_c_str. 

    // Approach 1 Failure

    string decr;

    CFB_Mode&lt;AES&gt;::Decryption cfbDecryption(key, sizeof(key), iv);

    StreamTransformationFilter stfDecryptor(cfbDecryption, new StringSink(decr));
    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(data_c_str2), d.size() + 1);
    stfDecryptor.MessageEnd();

    cout &lt;&lt; ""3. Approach 1.: Decrypted text: "" &lt;&lt; decr &lt;&lt; endl; // output ""fur fur fur fur""

    // Approach 2 Failure

    CFB_Mode&lt;AES&gt;::Decryption cfbDecryption2(key, sizeof(key), iv);
    cfbDecryption2.ProcessData((byte*)data_c_str2, (byte*)data_c_str2, data.length() + 1);

    cout &lt;&lt; ""4. Approach 2.: Decrypted text: "" &lt;&lt; data_c_str2 &lt;&lt; endl; // output ""fur fur fur furЂuФX""


    // Approach 3 Success. Note that below code works properly because of usage data_c_str taken from data after encryption.

    CFB_Mode&lt;AES&gt;::Decryption cfbDecryption3(key, sizeof(key), iv);
    cfbDecryption3.ProcessData((byte*)data_c_str, (byte*)data_c_str, data.length() + 1);

    cout &lt;&lt; ""5. Approach 3.: Decrypted text: "" &lt;&lt; data_c_str &lt;&lt; endl; // output ""fur fur fur fur fur""

    cin.get();

    return 0;
}
</code></pre>
","<p>I figured it out.</p>

<pre><code>auto dl = data.length();
auto dl2 = d.length();

cout &lt;&lt; ""Encrypted data length: "" &lt;&lt; dl &lt;&lt; endl; // output: 19
cout &lt;&lt; ""Encrypted data length at assigned string: "" &lt;&lt; dl2 &lt;&lt; endl; // output: 14
</code></pre>

<p>The length of encrypted string and newly assigned string are not the same because the encrypted text contains '\0' char at 14th byte of an array.</p>
","490","<c++><encryption><aes><crypto++><cfb-mode>","0","0","1","2018-04-05 10:12:35","43834528","2","","608639","","2017-05-07 19:04:01","2017-05-07 16:27:15",""
"40100629","Android and Crypto++ AES 128bit encrypted results not matching","<p>I am trying to use the same key and VI to encrypt and decryp the same message, say <code>aabbcc@gmail.com</code>. The key length is 128 bit as I know that in Java/Android, 256 is not easy to implement.</p>

<p>Here is my function to do the AES encryption using Crypto++</p>

<pre><code>string encryptString(string toBeEncrypted) {
//
// Create Cipher Text
//
CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

std::string ciphertext;

std::cout &lt;&lt; ""To be encrypted ("" &lt;&lt; toBeEncrypted.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
std::cout &lt;&lt; toBeEncrypted;
std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext), CryptoPP::StreamTransformationFilter::PKCS_PADDING);
stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (toBeEncrypted.c_str()), toBeEncrypted.length() + 1);
stfEncryptor.MessageEnd();

}
</code></pre>

<p>key is ""4ff539a893fed04840749287bb3e4152"" and IV is ""79f564e83be16711759ac7c730072bd0"". </p>

<p>They are stored in binary in a ubuntu running in VMWare on a x86 Windows.</p>

<p>The function to convert <code>key</code> and <code>iv</code> from byte to hex array is:</p>

<pre><code>std::string hexToStr(unsigned char *data, int len)
{
    std::stringstream ss;
    ss&lt;&lt;std::hex;
    for(int i(0);i&lt;len;++i){
        ss&lt;&lt;std::setfill('0')&lt;&lt;std::setw(2)&lt;&lt;(int)data[i];
    }

return ss.str();
}
</code></pre>

<p>I checked the hex string vs the memory of byte array <code>key</code> and <code>iv</code>, and they are matching.</p>

<p>The results for encrypting <code>aabbcc@gmail.com</code> is <code>c08a50b45ff16650542e290e05390a6c6fe533e11e9f802ad7d47681fd41f964</code> from C++.</p>

<p>I obtained this by passing the returned string <code>ciphertext</code> into the function <code>hexToStr</code> like <code>cout&lt;&lt;TFFHelper::hexStr((unsigned char *)ciphertext.c_str(), ciphertext.length())&lt;&lt;endl;</code></p>

<p>I can also decrpt it with the following function, and I passed the raw string rather than the hex string into this function.</p>

<pre><code>string TFFEncryption::decryptString(string toBeDecrypted) {

string decryptedtext;
CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(decryptedtext), CryptoPP::StreamTransformationFilter::PKCS_PADDING);
stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt; (toBeDecrypted.c_str()), toBeDecrypted.size());
stfDecryptor.MessageEnd();

return decryptedtext;
}
</code></pre>

<hr>

<p>I put the same VI and KEY in my Android code, and try to encrypt. It ends up in a half matching results after encrypting.</p>

<p>Android code is as follow:</p>

<pre><code>public class myAES {
private static final String key = ""4ff539a893fed04840749287bb3e4152"";
private static final String initVector = ""79f564e83be16711759ac7c730072bd0"";
private final  static char[] hexArray = ""0123456789ABCDEF"".toCharArray();

public static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i &lt; len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)
                + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}

public static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    for ( int j = 0; j &lt; bytes.length; j++ ) {
        int v = bytes[j] &amp; 0xFF;
        hexChars[j * 2] = hexArray[v &gt;&gt;&gt; 4];
        hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F];
    }
    return new String(hexChars);
}

public static byte[] encrypt(String value) {
    try {
        IvParameterSpec iv = new IvParameterSpec(hexStringToByteArray(initVector));
        SecretKeySpec skeySpec = new SecretKeySpec(hexStringToByteArray(key), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

        byte[] encrypted = cipher.doFinal(value.getBytes());
        Log.v(""Encryption successful"", bytesToHex(encrypted));
        return encrypted;
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}

public static String decrypt(byte[] encrypted) {
    try {
        IvParameterSpec iv = new IvParameterSpec(hexStringToByteArray(initVector));
        SecretKeySpec skeySpec = new SecretKeySpec(hexStringToByteArray(key), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

        byte[] original = cipher.doFinal(encrypted);
        Log.v(""Decryption successful"", new String(original, ""UTF-8""));
        return new String(original);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    return null;
}
}
</code></pre>

<p>I got the result of <code>C08A50B45FF16650542E290E05390A6CFE5466FC480F0667517B248410930B69</code>. </p>

<p>I used the same piece of code in Netbeans on Java8, running on the same Ubuntu of the C++ code, and got exactly the same results as what I mentioned on the previous line (Android results). I don't think this is OS dependent, but probably I did something wrong with either Java or C++ in my code.</p>

<p>So the first half of the hex strings are matching, and the later half is not. I tried to reduced the phrase <code>aabbcc@gmail.com</code> into <code>abc@gmail.com</code>, which results in complete different results from C++ vs Java (Ubuntu vs Android).</p>

<p>However, if I decrpt that binary array in Java, I got the original phrase <code>aabbcc@gmail.com</code> or <code>abc@gmail.com</code>. </p>

<p>I have the following questions.</p>

<ol>
<li>What did I do wrong?</li>
<li>Is it the proper way to case <code>const char *</code> into <code>unsigned char *</code>? I think it should be OK as I am getting the hex string of the binary</li>
<li>Is the half matching results caused by padding?</li>
</ol>
","<p>The email in the <strong>Crypto++</strong> message is <code>'0'</code> terminated, but the message in <strong>Java</strong> is not.</p>

<p>As <strong>AES</strong> is a block cipher with a block length of 128 bits (16 bytes), and your email is exactly 16 bytes long, the first block gets encrypted the same way in both implementations. The <code>'0'</code> in the first position of the second block gives the difference in the second block of the encryption.</p>

<p>Notice the extra <code>'00'</code> in below screenshot using <a href=""http://aes.online-domain-tools.com/"" rel=""nofollow"">this online tool</a>. All the <code>'0f'</code> following the <code>'00'</code> is the <strong>PKCS5 Padding</strong> that this tool did not remove here .. </p>

<p><a href=""https://i.stack.imgur.com/YE5gC.png"" rel=""nofollow""><img src=""https://i.stack.imgur.com/YE5gC.png"" alt=""enter image description here""></a></p>
","489","<android><c++><encryption><crypto++><javax.crypto>","3","2","1","2016-10-18 23:50:32","40117901","6","3","2946066","","2016-10-18 15:49:50","2016-10-18 06:00:50",""
"22275440","Apple Mach-O linking errors when using Crypto++","<p>I'm trying to use Crypto++ but I don't have very much C++ experience. I'm attempting to run performance tests on the encryption and decryption starting with AES. I <code>make install</code>'ed the source, and I am able to include it as shown below, but when I try to compile and run using Xcode it raises 38 linking errors starting with </p>

<pre><code>CryptoPP::AlignedAllocate(unsigned long)"", referenced from:
    CryptoPP::AllocatorWithCleanup&lt;unsigned char, true&gt;::allocate(unsigned long,
    void const*) in main.o`
</code></pre>

<p>Here is my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

#include &lt;string&gt;
#include &lt;string.h&gt;

#include &lt;chrono&gt;
#include &lt;unistd.h&gt;

#include &lt;/usr/include/cryptopp/aes.h&gt;
#include &lt;/usr/include/cryptopp/modes.h&gt;
#include &lt;/usr/include/cryptopp/filters.h&gt;

using namespace std;

const int stringlength = 1000;
char *stringdir = ""/Users/Noah/Desktop/EncryptionTimer/EncryptionTimer/strings/"";

char *read(const char *filepath)
{
    FILE *file = fopen(filepath, ""r"");

    fseek(file, 0, SEEK_END);
    long int length = ftell(file);
    char *buffer = (char*) malloc(sizeof(char) * length + 1);

    rewind(file);
    fread(buffer, 1, length, file);
    fclose(file);

    buffer[-1] = '\0';
    return buffer;
}

int main(int argc, const char * argv[])
{
    fstream fout(""./output.txt"");
    for (int fileindex = 1; fileindex &lt;= 1; fileindex++)
    {
        ostringstream convert;
        convert &lt;&lt; fileindex;
        string name = convert.str() + "".txt"";

        char *filename = new char[name.size() + 1];
        copy(name.begin(), name.end(), filename);
        filename[-1] = '\0';

        char *filepath = new char[sizeof(*stringdir) + sizeof(*filename)];

        strncat(filepath, stringdir, strlen(stringdir));
        strncat(filepath, filename, strlen(filename));

        cout &lt;&lt; filepath &lt;&lt; ""..."";
        fout &lt;&lt; filepath &lt;&lt; ""..."";

        char *contents = read(filepath);
        string plaintext = string(contents);
        string ciphertext;

        byte key[CryptoPP::AES::DEFAULT_KEYLENGTH], iv[CryptoPP::AES::BLOCKSIZE];
        memset(key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH);
        memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);

        cout &lt;&lt; ""ready"" &lt;&lt; ""..."";
        fout &lt;&lt; ""ready"" &lt;&lt; ""..."";

        // Encrypt
        auto t_start1 = std::chrono::high_resolution_clock::now();

        for (int i = 0; i &lt; 1000; i++)
        {
            CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
            CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

            CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
            stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()), plaintext.length() + 1);
            stfEncryptor.MessageEnd();
        }

        auto t_end1 = std::chrono::high_resolution_clock::now();
        fout &lt;&lt; ""\nElapsed encrypt time: ""
        &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(t_end1 - t_start1).count()
        &lt;&lt; "" microseconds\n"" &lt;&lt; endl;
        cout &lt;&lt; ""finished..."" &lt;&lt; endl;


        // Decrypt
        auto t_start2 = std::chrono::high_resolution_clock::now();

        for (int i = 0; i &lt; 1000; i++)
        {
            CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
            CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

            CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(ciphertext));
            stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size());
            stfDecryptor.MessageEnd();
        }

        auto t_end2 = std::chrono::high_resolution_clock::now();
        fout &lt;&lt; ""\nElapsed decrypt time: ""
        &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(t_end2 - t_start2).count()
        &lt;&lt; "" microseconds\n"" &lt;&lt; endl;
        cout &lt;&lt; ""\nDecryption Finished"" &lt;&lt; endl;


    }
    fout.close();
}
</code></pre>

<p>Any suggestions would be appreciated :D.</p>
","<blockquote>
  <p>when I try to compile and run (using Xcode) it raises 38 linking errors...</p>
</blockquote>

<p>You need to add the Crypto++ headers and library to your Xcode project. The images below were taken from the <a href=""http://www.cryptopp.com/wiki/Main_Page"" rel=""nofollow noreferrer"">Crypto++ wiki</a>, and presumes Crypto++ is installed in <code>/usr/local/cryptopp</code>.</p>

<p>Add the headers here:</p>

<p><img src=""https://i.stack.imgur.com/F9JIQ.png"" alt=""enter image description here""></p>

<p>Add the library here:</p>

<p><img src=""https://i.stack.imgur.com/uFFky.png"" alt=""enter image description here""></p>

<p>If you are cross-compiling for iOS (its Mach-O too), the Crypto++ wiki has a couple of pages on the subject:</p>

<ul>
<li><a href=""http://www.cryptopp.com/wiki/IOS_%28Xcode%29"" rel=""nofollow noreferrer"">IOS (Xcode)</a></li>
<li><a href=""http://www.cryptopp.com/wiki/IOS_%28Command_Line%29"" rel=""nofollow noreferrer"">IOS (Command Line)</a></li>
</ul>

<p>If you want a pre-built Crypto++ for iOS with ARMv7, ARMv7s, ARM64 and i386 (simulator), see this <a href=""https://github.com/noloader"" rel=""nofollow noreferrer"">Github account</a>.</p>

<hr>

<p>Before you make the library yourself, you should open the makefile (<code>GNUmakefile</code>), and uncomment <code>CXXFLAGS = -fPIC</code>.</p>

<p>Also, because of <code>#include &lt;chrono&gt;</code>, you might need to add <code>CXXFLAGS += -stdc++11</code>. I'm not sure because I don't recall trying to mic C++ 03 and C++ 11.</p>

<hr>

<p>Crypto++ 5.6.2 and earlier also required <code>-DCRYPTOPP_DISABLE_ASM</code> on Intel platforms because of Clang's integrated assembler and Apple's downlevel linker.</p>

<p>Crypto++ 5.6.3 and above managed to work around most of the issues. Problems that could not be worked around effectively had <code>-DCRYPTOPP_DISABLE_ASM</code> applied to the offending translation unit rather than the entire library.</p>
","488","<c++><encryption><crypto++>","2","0","1","2016-02-18 04:12:41","22602685","0","","608639","","2016-02-18 04:09:47","2014-03-08 21:41:36",""
"28791536","Load RSA public key created in JSBN, then encrypt a message","<p>I am trying to create a RSA key pair in JavaScript using <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn"" rel=""nofollow"">JSBN</a> and transfer the public key to Crypto++. Then, I am trying to encrypt a message in Crypto++ and send it back to JavaScript and decrypt it.</p>

<p>But I am relatively new at this, so I think I am doing something wrong ( data is not getting decrypted ofc ) </p>

<p>any help would be greatly appreciated :D </p>

<p>Here is my cpp code </p>

<pre><code>Integer n(nStr-&gt;c_str()),
e(""0x10001"");

RSA::PublicKey pubKey;
pubKey.Initialize(n, e);

AutoSeededRandomPool rng;
if (!pubKey.Validate(rng, 3))
    throw std::exception(""Rsa private key validation failed"");

////////////////////////////////////////////////
// Encryption
RSAES_PKCS1v15_Encryptor enc(pubKey);
StringSource ss1(data, true,
        new PK_EncryptorFilter(rng, enc,
            new StringSink(retStr)
        ));

std::string retData2 = """";

StringSource ss2((const byte*)retStr.data(), retStr.size(), true,
        new Base64Encoder(
            new StringSink(retData2)
        ));

retStr = retData2;
</code></pre>

<p>And my javascript code </p>

<pre><code>// nStr in CPP is ""0x"" + localStorage.getItem(""rsa_public"")  from javascript
// data in CPP is ""secret""

var rsa = new RSAKey();
var publickey = localStorage.getItem(""rsa_public"");
var privatekey = localStorage.getItem(""rsa_private"");
rsa.setPrivate(publickey, ""10001"", privatekey);
alert(b64tohex(dec) + ""\n"" + rsa.encrypt(""secret"")); &lt;-- these don't match at all .. and ofc rsa.decrypt returns null
</code></pre>

<p>dec in javascript is retStr from CPP</p>
","<p>The PKCS#1 v1.5 Padding that is used by JSBN and your Crypto++ code is a random padding, so if you encrypt data with the same key it will look differently. You have to check whether your implementation works by encrypting on one end and decrypting on the other in both directions.</p>
","488","<javascript><c++><encryption><rsa><crypto++>","1","2","2","2015-03-01 19:19:08","28792232","3","","608639","","2015-03-01 18:49:56","2015-03-01 08:27:43",""
"28791536","Load RSA public key created in JSBN, then encrypt a message","<p>I am trying to create a RSA key pair in JavaScript using <a href=""http://www-cs-students.stanford.edu/~tjw/jsbn"" rel=""nofollow"">JSBN</a> and transfer the public key to Crypto++. Then, I am trying to encrypt a message in Crypto++ and send it back to JavaScript and decrypt it.</p>

<p>But I am relatively new at this, so I think I am doing something wrong ( data is not getting decrypted ofc ) </p>

<p>any help would be greatly appreciated :D </p>

<p>Here is my cpp code </p>

<pre><code>Integer n(nStr-&gt;c_str()),
e(""0x10001"");

RSA::PublicKey pubKey;
pubKey.Initialize(n, e);

AutoSeededRandomPool rng;
if (!pubKey.Validate(rng, 3))
    throw std::exception(""Rsa private key validation failed"");

////////////////////////////////////////////////
// Encryption
RSAES_PKCS1v15_Encryptor enc(pubKey);
StringSource ss1(data, true,
        new PK_EncryptorFilter(rng, enc,
            new StringSink(retStr)
        ));

std::string retData2 = """";

StringSource ss2((const byte*)retStr.data(), retStr.size(), true,
        new Base64Encoder(
            new StringSink(retData2)
        ));

retStr = retData2;
</code></pre>

<p>And my javascript code </p>

<pre><code>// nStr in CPP is ""0x"" + localStorage.getItem(""rsa_public"")  from javascript
// data in CPP is ""secret""

var rsa = new RSAKey();
var publickey = localStorage.getItem(""rsa_public"");
var privatekey = localStorage.getItem(""rsa_private"");
rsa.setPrivate(publickey, ""10001"", privatekey);
alert(b64tohex(dec) + ""\n"" + rsa.encrypt(""secret"")); &lt;-- these don't match at all .. and ofc rsa.decrypt returns null
</code></pre>

<p>dec in javascript is retStr from CPP</p>
","<pre><code>RSAES_PKCS1v15_Encryptor enc(pubKey);
StringSource ss1(data, true,
        new PK_EncryptorFilter(rng, enc,
            new StringSink(retStr)
        ));
...
StringSource ss2((const byte*)retStr.data(), retStr.size(), true,
        new Base64Encoder(
            new StringSink(retData2)
        ));
</code></pre>

<p>I'm not sure this is correct <em>for interop'ing with Javascript and JSBN</em>. It is correct stand alone, and it is correct for interop'ing with OpenSSL.</p>

<p>Crypto++ uses an early Base64 encoding scheme. It was seen in email and other standards of the time (the time was around the 1990s). The alphabet uses the plus (+) and forward slash (/) characters.</p>

<p>The Javascript and JSON technologies like JSON Web Keys (JWKs) tend to favor the Base64 encoding using the URL or Web Safe alphabet. The alphabet uses the minus (-) and underscore (_) characters.</p>

<p>Both the old and new Base64 encoding schemes are specified in <a href=""http://tools.ietf.org/html/rfc4648"" rel=""nofollow"">RFC 4648, The Base16, Base32, and Base64 Data Encodings</a>.</p>

<p>You should fetch the patch for the <a href=""http://www.cryptopp.com/wiki/Base64URLEncoder"" rel=""nofollow"">Base64URLEncoder</a>, and apply it in-place over top of the Crypto++ sources. After you patch, you will have the existing <code>Base6Encoder</code> and the new <code>Base64URLEncoder</code>. Finally, recompile and reinstall the library. You have to patch it because its not part of the Crypto++ library as written and offered by Wei Dai.</p>

<p>Then, do the following:</p>

<pre><code>RSAES_PKCS1v15_Encryptor enc(pubKey);
string encoded;

StringSource ss(data, true,
        new PK_EncryptorFilter(prng, enc,
            new Base64URLEncoder(
                new StringSink(encoded)
        )));

// Print encoded cipher text
cout &lt;&lt; encoded &lt;&lt; endl;

return encoded;
</code></pre>

<p>As for <em>""these don't match at all...""</em> - I think that's expected. RSA encryption uses randomized padding so that when you encrypt messages <em><code>m1</code></em> and <em><code>m2</code></em>, the cipher text is different. Its called ""semantic security"" and its a strong (stronger?) notion of security. This way, the bad guy can't tell when the same message has been sent twice.</p>
","488","<javascript><c++><encryption><rsa><crypto++>","1","1","2","2015-03-01 19:19:08","28792232","3","","608639","","2015-03-01 18:49:56","2015-03-01 08:27:43",""
"42373267","Convert encoded std::string from Base16 to Base10?","<p>I have a <code>std::string</code> with a large integer encoded in Base16:</p>

<pre class=""lang-none prettyprint-override""><code>bbb91c1c95b656f386b19ab284b9c0f66598e7761cd71569734bb72b6a7153b77613a6cef8e63
e9bd9bb1e0e53a0fd8fa2162b160fcb7b461689afddf098bfc32300cf6808960127f1d9f0e287
f948257f7e0574b56585dd1efe1192d784b9c93f9c2215bd4867062ea30f034265374fa013ab4
5af06cd8554fd55f1c442c2ed
</code></pre>

<p>I want a <code>std::string</code> with a large integer encoded in Base10:</p>

<pre class=""lang-none prettyprint-override""><code>13182363340585954094154991955162141609757130565683854218475776626603716062690
50741824486137510938646762753180989129520441058729412931959771922633699694948
46611764803267065720664398942078304585998290003537553345030144535441671492050
01138054588415687622649540474976282005406232907125282540703919964112809484362
9
</code></pre>

<p>How do I convert the strings from Base16 to Base10?</p>
","<p>Since you don't want a library, you need some code. It's not a trivial problem, but not too complex either. Let's start with <a href=""https://stackoverflow.com/a/22004815/5987"">my <code>Bignum</code> class from another answer</a> and add a couple of functions to it.</p>

<pre><code>class Bignum
{
    //...

    Bignum&amp; operator+=(int rhs)
    {
        assert(rhs &gt;= 0 &amp;&amp; rhs &lt;= 999999999);
        uint32_t carry = rhs;
        for (size_t i = 0; i &lt; parts.size(); i++)
        {
            uint32_t sum = parts[i] + carry;
            parts[i] = (uint32_t)(sum % 1000000000UL);
            carry = (uint32_t)(sum / 1000000000UL);
        }
        if (carry != 0)
            parts.push_back(carry);
        return *this;
    }

    void FromHex(const char * pString)
    {
        while (*pString != 0)
        {
            char ch = toupper(*pString++);
            assert((ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F'));
            int digit = (ch &lt;= '9') ? (ch - '0') : (ch - 'A' + 10);
            *this *= 16;
            *this += digit;
        }
    }
</code></pre>

<p>See the whole thing in action: <a href=""http://coliru.stacked-crooked.com/a/cb5061a00c945875"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/a/cb5061a00c945875</a></p>
","485","<c++><windows><hex><decimal><crypto++>","0","1","2","2017-02-22 07:49:20","","3","","608639","","2017-02-21 20:18:31","2017-02-21 16:49:28","2017-02-22 22:15:28"
"42373267","Convert encoded std::string from Base16 to Base10?","<p>I have a <code>std::string</code> with a large integer encoded in Base16:</p>

<pre class=""lang-none prettyprint-override""><code>bbb91c1c95b656f386b19ab284b9c0f66598e7761cd71569734bb72b6a7153b77613a6cef8e63
e9bd9bb1e0e53a0fd8fa2162b160fcb7b461689afddf098bfc32300cf6808960127f1d9f0e287
f948257f7e0574b56585dd1efe1192d784b9c93f9c2215bd4867062ea30f034265374fa013ab4
5af06cd8554fd55f1c442c2ed
</code></pre>

<p>I want a <code>std::string</code> with a large integer encoded in Base10:</p>

<pre class=""lang-none prettyprint-override""><code>13182363340585954094154991955162141609757130565683854218475776626603716062690
50741824486137510938646762753180989129520441058729412931959771922633699694948
46611764803267065720664398942078304585998290003537553345030144535441671492050
01138054588415687622649540474976282005406232907125282540703919964112809484362
9
</code></pre>

<p>How do I convert the strings from Base16 to Base10?</p>
","<blockquote>
  <p>Convert encoded std::string from Base16 to Base10?</p>
</blockquote>

<p>The following should work for you. The code below shows you how to do it with C-style strings, which is easy to conceptualize. Your previous question at <a href=""https://stackoverflow.com/q/42351335/608639"">Convert CryptoPP::Integer to LPCTSTR</a> has the references.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""integer.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  string s2, s1 =
      ""bbb91c1c95b656f386b19ab284b9c0f66598e7761cd71569734bb72b6a7153b77613a6cef8e63""
      ""e9bd9bb1e0e53a0fd8fa2162b160fcb7b461689afddf098bfc32300cf6808960127f1d9f0e287""
      ""f948257f7e0574b56585dd1efe1192d784b9c93f9c2215bd4867062ea30f034265374fa013ab4""
      ""5af06cd8554fd55f1c442c2ed"";

  // Append 'h' to indicate Base16
  // Integer n((s1 + ""h"").c_str());

  // Prepend '0x' to indicate Base16
  Integer n((""0x"" + s1).c_str());

  // Convert to Base10
  s2 = IntToString&lt;Integer&gt;(n, 10);
  cout &lt;&lt; s2 &lt;&lt; endl;

  return 0;
}
</code></pre>

<hr>

<p>The code above shows you how to do it with C-style strings, which is easy to conceptualize. Another way to do it uses a Crypto++ <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer""><code>Pipeline</code></a> to convert the ASCII string into a big-endian array of bytes. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""integer.h""
#include ""filters.h""
#include ""hex.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  string s3, s2, s1 =
      ""bbb91c1c95b656f386b19ab284b9c0f66598e7761cd71569734bb72b6a7153b77613a6cef8e63""
      ""e9bd9bb1e0e53a0fd8fa2162b160fcb7b461689afddf098bfc32300cf6808960127f1d9f0e287""
      ""f948257f7e0574b56585dd1efe1192d784b9c93f9c2215bd4867062ea30f034265374fa013ab4""
      ""5af06cd8554fd55f1c442c2ed"";

  // Use a HexDecoder to convert to big-endian array
  StringSource ss(s1, true, new HexDecoder(new StringSink(s2)));

  // Use big-endian array to construct n
  Integer n((const byte*)s2.data(), s2.size());

  // Convert to Base10
  s3 = IntToString&lt;Integer&gt;(n, 10);
  cout &lt;&lt; s3 &lt;&lt; endl;

  return 0;
}
</code></pre>

<hr>

<p>Here's another way to perform the conversion using a Crypto++ <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer""><code>Pipeline</code></a>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""integer.h""
#include ""filters.h""
#include ""hex.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  string s2, s1 =
      ""bbb91c1c95b656f386b19ab284b9c0f66598e7761cd71569734bb72b6a7153b77613a6cef8e63""
      ""e9bd9bb1e0e53a0fd8fa2162b160fcb7b461689afddf098bfc32300cf6808960127f1d9f0e287""
      ""f948257f7e0574b56585dd1efe1192d784b9c93f9c2215bd4867062ea30f034265374fa013ab4""
      ""5af06cd8554fd55f1c442c2ed"";

  // Use a source to convert to big-endian array
  StringSource ss(s1, true, new HexDecoder);

  // Use big-endian array to construct n
  Integer n;
  n.Decode(ss, ss.MaxRetrievable());

  // Convert to Base10
  s2 = IntToString&lt;Integer&gt;(n, 10);
  cout &lt;&lt; s2 &lt;&lt; endl;

  return 0;
}
</code></pre>

<hr>

<p>If you are interested in the algorithm that converts the ASCII string to a byte array for internal representation, then see <a href=""https://github.com/weidai11/cryptopp/blob/master/integer.cpp#L3133"" rel=""nofollow noreferrer""><code>StringToInteger</code> in <code>integer.cpp</code></a>. It repeatedly divides by the base (2, 8, 10, 16, etc).</p>
","485","<c++><windows><hex><decimal><crypto++>","0","1","2","2017-02-22 07:49:20","","3","","608639","","2017-02-21 20:18:31","2017-02-21 16:49:28","2017-02-22 22:15:28"
"23242666","how to encrypt data using Cryptopp::TEA?","<p>I've been searching for a while and couldn't find any document about CryptoPP::TEA encrypting.</p>

<p>Anyone know how to encrypt data using CryptoPP::TEA?</p>

<p>Thanks.</p>
","<blockquote>
  <p>Anyone know how to encrypt data using CryptoPP::TEA?</p>
</blockquote>

<p>Crypto++ provides implementations for TEA and XTEA. I recall there can be some interop problems because there's a newer TEA variant (but I don't recall the details).</p>

<p>TEA and XTEA are just block ciphers, so they can be used like any other block cipher (such as 3DES, AES or Cameilla). Because it can be used like any other block cipher, the code below is from Crypto++'s <a href=""http://www.cryptopp.com/wiki/CBC_Mode"" rel=""nofollow"">CBC Mode</a> wiki page. All I did was change AES to TEA.</p>

<p>Here is the output of the program:</p>

<pre><code>$ ./cryptopp-test.exe
plain text: CBC Mode Test
cipher text: 483ABA61693D885532604E376703A91D
recovered text: CBC Mode Test
</code></pre>

<p>And here is the program:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(TEA::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte iv[ TEA::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

string plain = ""CBC Mode Test"";
string cipher, encoded, recovered;

/*********************************\
\*********************************/

try
{
    cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

    CBC_Mode&lt; TEA &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), iv );

    StringSource ss(plain, true,
                        new StreamTransformationFilter( e,
                            new StringSink( cipher )
                        ) // StreamTransformationFilter
                    ); // StringSource
}
catch( const CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

// Pretty print cipher text
StringSource ss(cipher, true,
                    new HexEncoder(
                        new StringSink( encoded )
                    ) // HexEncoder
                ); // StringSource

cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
    CBC_Mode&lt; TEA &gt;::Decryption d;
    d.SetKeyWithIV( key, key.size(), iv );

    StringSource ss(cipher, true, 
                        new StreamTransformationFilter( d,
                            new StringSink( recovered )
                        ) // StreamTransformationFilter
                    ); // StringSource

    cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
}
catch( const CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}
</code></pre>
","484","<crypto++>","1","1","1","2014-04-24 00:43:14","23257013","0","","","","","2014-04-23 11:17:10",""
"47483413","Invalid PKCS #7 block padding found when using Crypto++","<p>We are using the code below with the Crypto++ library. We need to encrypt and decrypt <code>char*</code>. Encryption is working fine without any issue and we are able to get the cipher text. But getting an error while decrypting as ""invalid pkcs #7 block padding found"". What could be the issue...?</p>

<p>Encryption Block:</p>

<pre><code>char* cspl_crypto::encrypt_rijndael(byte key[], byte iv[], int keysize, char plainText[], int plainTextSize)
{
    vector&lt;byte&gt; cipher;

    std::vector&lt;byte&gt; plain(plainText, plainText + plainTextSize);

    CBC_Mode&lt;AES&gt;::Encryption enc; 
    enc.SetKeyWithIV(key, keysize, iv, keysize);

    // Make room for padding
    cipher.resize(plain.size()+AES::BLOCKSIZE);
    ArraySink cs(&amp;cipher[0], cipher.size());

    ArraySource(plain.data(), plain.size(), true,
        new StreamTransformationFilter(enc, new Redirector(cs)));

    // Set cipher text length now that its known
    cipher.resize(cs.TotalPutLength());
    char returnValue[cipher.size()];
    copy(cipher.begin(), cipher.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Decyption Block:</p>

<pre><code>char* cspl_crypto::decrypt_rijndael(byte key[], byte iv[], int keysize, char cipher[], int size )
{
    std::vector&lt;byte&gt; v(cipher, cipher + size);
    vector&lt;byte&gt; recover;
    CBC_Mode&lt;AES&gt;::Decryption dec;
    dec.SetKeyWithIV(key, keysize, iv, keysize);

    // Recovered text will be less than cipher text
    recover.resize(v.size());
    ArraySink rs(&amp;recover[0], recover.size());

    ArraySource(v.data(), v.size(), true,
        new StreamTransformationFilter(dec, new Redirector(rs)));

    // Set recovered text length now that its known
    recover.resize(rs.TotalPutLength());

    char returnValue[recover.size()];
    copy(recover.begin(), recover.end(), returnValue);

    return returnValue;
}
</code></pre>
","","481","<c++><encryption><crypto++><pkcs#7>","0","","0","2017-11-27 13:43:36","","2","0","608639","","2017-11-27 13:43:36","2017-11-25 06:55:17",""
"40688691","How to save encrypted FileSource data to byte array?","<p>This is the code of Crypto++ FileSource to encrypt a large file. Its works perfectly but all in blackbox and doesn't allow me to save encrypted data to a byte array when encrypting. I want to know the mechanism beneath in order to save the temporary data. The document seem to be interface provided only, in <a href=""https://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow noreferrer"">FileSource Class Reference</a>.</p>

<pre class=""lang-cxx prettyprint-override""><code>EAX&lt; Blowfish &gt;::Encryption e1;
e1.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

FileSource fs1(ofilename.c_str(), true,
    new AuthenticatedEncryptionFilter(e1,
        new FileSink(efilename.c_str())));
</code></pre>

<p>Hope someone can tell me the mechanism or somewhere where I can learn about it.</p>
","<blockquote>
  <p>... and doesn't allow me to save encrypted data to a byte array when encrypting. I want to know the mechanism beneath in order to save the temporary data.</p>
</blockquote>

<p>Its not really clear to me what you want to do with a temporary array, so the answers below may not be correct.</p>

<p>There are two ways to create a temporary result in an array. First is a serial operation where you encrypt the file into an array, and then write the array to disk. Second is a parallel operation where both the array and encrypted file are created at the same time.</p>

<p>You can't use a C++11 <code>std::array</code> because the size of the array is <em>not</em> known at runtime. You can use a <code>std::vector</code>, and a snippet is provided blow.</p>

<hr>

<p><strong><em>Serial</em></strong></p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;

#include ""osrng.h""
#include ""eax.h""
#include ""modes.h""
#include ""blowfish.h""
#include ""filters.h""
#include ""files.h""

using namespace CryptoPP;

int main(int argc, char* argv[])
{
    SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH), iv(Blowfish::BLOCKSIZE);
    string ifilename(""config.h""), ofilename(""config.h.enc"");

    memset(key, 0x00, key.size());
    memset(iv, 0x00, iv.size());

    EAX&lt; Blowfish &gt;::Encryption enc;
    enc.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

    ifstream strm(ifilename.c_str(), ios::in | ios::binary);
    size_t len = strm.seekg(0, std::ios_base::end).tellg();
    strm.seekg(0, std::ios_base::beg);

    cout &lt;&lt; ""Data size: "" &lt;&lt; len &lt;&lt; "", tag size: "" &lt;&lt; enc.TagSize() &lt;&lt; endl;

    FileSource fs1(strm, false);
    len += enc.TagSize();

    cout &lt;&lt; ""Expected encrypted data and tag size: "" &lt;&lt; len &lt;&lt; endl;
    len += Blowfish::BLOCKSIZE;
    cout &lt;&lt; ""Overcommitted encrypted data and tag size: "" &lt;&lt; len &lt;&lt; endl;

    unique_ptr&lt;byte[]&gt; ptr(new byte[len]);
    ArraySink as1(ptr.get(), len);

    fs1.Detach(new AuthenticatedEncryptionFilter(enc, new Redirector(as1)));
    fs1.PumpAll();

    len = as1.TotalPutLength();
    cout &lt;&lt; ""Encrypted data and tag size: "" &lt;&lt; as1.TotalPutLength() &lt;&lt; endl;

    ArraySource as2(ptr.get(), len, true, new FileSink(ofilename.c_str()));

    return 0;
}
</code></pre>

<p>The serial example produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Data size: 38129, tag size: 8
Expected encrypted data and tag size: 38137
Overcommitted encrypted data and tag size: 38145
Encrypted data and tag size: 38137

$ ls -l config.*
-rw-r--r--. 1 ... 38223 Nov 19 04:40 config.compat
-rw-r--r--. 1 ... 38129 Nov 19 04:40 config.h
-rw-r--r--. 1 ... 38137 Nov 19 06:03 config.h.enc
</code></pre>

<hr>

<p><strong><em>Parallel</em></strong></p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;

#include ""osrng.h""
#include ""eax.h""
#include ""modes.h""
#include ""blowfish.h""
#include ""filters.h""
#include ""files.h""
#include ""channels.h""

using namespace CryptoPP;

int main(int argc, char* argv[])
{
    SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH), iv(Blowfish::BLOCKSIZE);
    string ifilename(""config.h""), ofilename(""config.h.enc"");

    memset(key, 0x00, key.size());
    memset(iv, 0x00, iv.size());

    EAX&lt; Blowfish &gt;::Encryption enc;
    enc.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

    ifstream strm(ifilename.c_str(), ios::in | ios::binary);
    size_t len = strm.seekg(0, std::ios_base::end).tellg();
    strm.seekg(0, std::ios_base::beg);

    // Overcommit
    len += enc.TagSize() + Blowfish::BLOCKSIZE;

    // The one and only source
    FileSource fs1(strm, false);

    // The first sink
    FileSink fs2(ofilename.c_str(), true);

    // The second sink
    unique_ptr&lt;byte[]&gt; ptr(new byte[len]);
    ArraySink as1(ptr.get(), len);

    // The magic to output to both sinks
    ChannelSwitch cs;
    cs.AddDefaultRoute(as1);
    cs.AddDefaultRoute(fs2);

    fs1.Detach(new AuthenticatedEncryptionFilter(enc, new Redirector(cs)));
    fs1.PumpAll();

    return 0;
}
</code></pre>

<p>The parallel example produces:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe

$ ls -l config.*
-rw-r--r--. 1 ... 38223 Nov 19 04:40 config.compat
-rw-r--r--. 1 ... 38129 Nov 19 04:40 config.h
-rw-r--r--. 1 ... 38137 Nov 19 06:02 config.h.enc
</code></pre>

<hr>

<p><strong><em>std::vector</em></strong></p>

<p>Instead of:</p>

<pre><code>unique_ptr&lt;byte[]&gt; ptr(new byte[len]);
ArraySink as1(ptr.get(), len);
</code></pre>

<p>You can use:</p>

<pre><code>std::vector&lt;byte&gt; v;
...

v.resize(len);
ArraySink as(&amp;v[0], v.size());
...

// Perform encryption
fs.Detach(new AuthenticatedEncryptionFilter(enc, new Redirector(as)));
fs.PumpAll();

// Resize now you know the size of ciphertext and tag
v.resize(as.TotalPutLength());
</code></pre>
","480","<c++><encryption><crypto++>","0","0","1","2016-11-19 12:10:17","","3","","608639","","2016-11-19 08:57:54","2016-11-19 02:46:44",""
"37996442","Decrypt cipher text encrypted with PyCrypto using cryptopp","<p>My server encrypts files using pycrypto with AES in CTR mode. My counter is a simple counter like this:</p>

<pre><code>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02
\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03
</code></pre>

<p>I wanna decrypt the cipher text with c++'s cryptopp library in my clients. How should I do so?</p>

<p>Python code:</p>

<pre><code>encryptor = AES.new(
    CRYPTOGRAPHY_KEY,
    AES.MODE_CTR,
    counter=Counter.new(128),
)
cipher = encryptor.encrypt(plain_text)
</code></pre>

<p>C++ code so far:</p>

<pre><code>byte ctr[] = ""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01""
mDecryptor = new CryptoPP::CTR_Mode&lt;CryptoPP::AES&gt;::Decryption(key, 32, ctr);
std::string plain;
CryptoPP::StringSource(std::string(data, len), true, new CryptoPP::StreamTransformationFilter(*mDecryptor, new CryptoPP::StringSink(plain)));
</code></pre>

<p>but after running this <code>plain</code> is garbage.</p>

<p><strong>Update:</strong></p>

<p>Sample encrypted data you can try to decrypt with crypto++ so that you can help me even if you don't know python and you're just experienced with crypto++:</p>

<p>Try to decrypt this base64 encoded text:</p>

<pre><code>2t0lLuSBY7NkfK5I4kML0qjcZl3xHcEQBPbDo4TbvQaXuUT8W7lNbRCl8hfSGJA00wgUXhAjQApcuTCZckb9e6EVOwsa+eLY78jo2CqYWzhGez9zn0D2LMKNmZQi88WuTFVw9r1GSKIHstoDWvn54zISmr/1JgjC++mv2yRvatcvs8GhcsZVZT8dueaNK6tXLd1fQumhXCjpMyFjOlPWVTBPjlnsC5Uh98V/YiIa898SF4dwfjtDrG/fQZYmWUzJ8k2AslYLKGs=
</code></pre>

<p>with this key:</p>

<pre><code>12341234123412341234123412341234
</code></pre>

<p>with counter function described in the beginning of this post using crypto++. If you succeed post the decrypted text (which contains only numbers) and your solution please.</p>

<p><strong>Update2:</strong>
I'm not providing an IV in python code, the python module ignores IV. I the IV thing is what causing the problem.</p>
","<p>As I read their source codes I can say PyCrypto and Crypto++ Both are perfect libraries for cryptography for Python and C++. The problem was that I was prefixing the encrypted data with some meta information about file and I totally forgot about that, after handling these meta data in client Crypto++ decrypted my files.</p>

<p>As I didn't find this documented explicitly anywhere (not even in Wikipedia) I write it here:
Any combination of Nonce, IV and Counter like concatenation, xor, or likes will work for CTR mode, but the standard that most libraries implement is to concatenate these values in order. So the value that is used in block cipher algorithm is usually: Nonce + IV + Counter. And counter usually starts from 1 (not 0).</p>
","480","<python><pycrypto><crypto++>","0","0","1","2016-06-27 19:31:36","38002618","9","","1349278","","2016-06-27 19:31:36","2016-06-23 15:54:08",""
"27769938","Encrypt unsigned int value in form of bits stream by AES_CFB mode","<p>I have c++ code that encrypts a string as a plaintext using AES_CFB and generates a same size ciphertext, but the problem is the data type of input and output, So could anyone help me to let it encrypts an unsigned int number and generates unsigned int number ciphertext  withe keeping the same  length for the plaintext and chipertext (length of bits ). </p>

<pre><code>string ENCRYPTOR(const std::string&amp; PlainText)
{
    byte key[16]= ""1234ff"";//  byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ];
    byte iv[16]= ""123456"";//byte iv[ CryptoPP::AES::BLOCKSIZE ];

    std::string CipherText;

    // Encryptor
    CryptoPP::CFB_Mode&lt; CryptoPP::AES &gt;::Encryption encryptor( key, sizeof(key), iv);

    // Encryption
    CryptoPP::StringSource( PlainText, true,
        new CryptoPP::StreamTransformationFilter( encryptor,
            new CryptoPP::StringSink( CipherText ) ) ); 

    return (CipherText);
}

string DECRYPTOR(const string&amp; CipherText)
{
    byte key[16]= ""1234ff"";
    byte iv[16]= ""123456""; 

    std::string RecoveredText;

    // Decryptor
    CryptoPP::CFB_Mode&lt; CryptoPP::AES &gt;::Decryption decryptor( key, sizeof(key), iv );

    // Decryption
    CryptoPP::StringSource( CipherText, true,
        new CryptoPP::StreamTransformationFilter( decryptor,
            new CryptoPP::StringSink( RecoveredText ) ) ); 

    return (RecoveredText);
}

int main()
{
    string ciphertext;
    string plaintext = ""3555"";
    ciphertext= ENCRYPTOR(plaintext);
    string retrivdat = DECRYPTOR(ciphertext);

    cout&lt;&lt;""The plaintext data is:  ""&lt;&lt;plaintext&lt;&lt;endl;
    cout&lt;&lt;""The ciphertextdata is:  ""&lt;&lt;ciphertext&lt;&lt;endl;
    Coot&lt;&lt;""The retrieved data is:  ""&lt;&lt;retrivdat&lt;&lt;end;

    return 0;
}
</code></pre>

<hr>

<p>The output is </p>

<pre><code>The plaintext data is:  3555
The chepertext data is:  ï¥R_
The retrieved data is:  3555
</code></pre>
","<blockquote>
  <p>Encrypt unsigned int value in form of bits stream by AES_CFB mode</p>
</blockquote>

<p>Igor and Owlstead raised some valid points about size of integers and endianess. The easiest solution to avoid them is probably encode the integer as a string:</p>

<pre><code>unsigned int n = ...;
ostringstream oss;

oss &lt;&lt; n;

string plainText = oss.str();
</code></pre>

<p>Later, you can convert it back with:</p>

<pre><code>string recovered = ...;
istringstream iss(recovered);

unsigned int n;
iss &gt;&gt; n;
</code></pre>

<hr>

<pre><code>byte key[16]= ""1234ff"";//  byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ];
byte iv[16]= ""123456"";//byte iv[ CryptoPP::AES::BLOCKSIZE ];
</code></pre>

<p>Your key and IV are too small. You should be getting compiler warnings because of it. <code>AES::DEFAULT_KEYLENGTH</code> is 16, so you need at least 16 characters for the key. <code>AES::BLOCKSIZE</code> is 16, so you need at least 16 characters for the initialization vector.</p>

<p>If the code above happens to work, then its purely because of luck. You should probably visit <a href=""http://www.cryptopp.com/wiki/CFB_Mode"" rel=""nofollow noreferrer"">CFB Mode</a> on the Crypto++ wiki. It has a working example.</p>

<p>Alternately, use <code>PBKDF</code> to stretch the short key and short IV. You can find an example at <a href=""https://stackoverflow.com/a/27261798/608639"">Crypto++ pbkdf2 output is different than Rfc2898DeriveBytes (C#) and crypto.pbkdf2 (JavaScript)</a> on Stack Overflow.</p>

<hr>

<blockquote>
  <p>The chepertext data is:  ï¥R_</p>
</blockquote>

<p>You can make this printable with:</p>

<pre><code>string encoded;
HexEncoder hexer(new StringSink(encoded));

hexer.Put((byte*)cipherText.data(), cipherText.size());
hexer.MessageEnd();

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p>Alternately, you can use the following (with pipelines):</p>

<pre><code>string encoded;

StringSource ss(cipherText, true,
    new HexEncoder(
        new StringSink(encoded)));

cout &lt;&lt; encoded &lt;&lt; endl;
</code></pre>

<p><a href=""http://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow noreferrer""><code>HexEncoder</code></a> and <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow noreferrer""><code>HexDecoder</code></a> are discussed on the Crypto++ wiki, too.</p>
","473","<c++><encryption><encoding><crypto++>","-2","0","2","2015-01-05 23:22:47","","4","","608639","","2015-01-04 22:55:12","2015-01-04 20:21:49",""
"27769938","Encrypt unsigned int value in form of bits stream by AES_CFB mode","<p>I have c++ code that encrypts a string as a plaintext using AES_CFB and generates a same size ciphertext, but the problem is the data type of input and output, So could anyone help me to let it encrypts an unsigned int number and generates unsigned int number ciphertext  withe keeping the same  length for the plaintext and chipertext (length of bits ). </p>

<pre><code>string ENCRYPTOR(const std::string&amp; PlainText)
{
    byte key[16]= ""1234ff"";//  byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ];
    byte iv[16]= ""123456"";//byte iv[ CryptoPP::AES::BLOCKSIZE ];

    std::string CipherText;

    // Encryptor
    CryptoPP::CFB_Mode&lt; CryptoPP::AES &gt;::Encryption encryptor( key, sizeof(key), iv);

    // Encryption
    CryptoPP::StringSource( PlainText, true,
        new CryptoPP::StreamTransformationFilter( encryptor,
            new CryptoPP::StringSink( CipherText ) ) ); 

    return (CipherText);
}

string DECRYPTOR(const string&amp; CipherText)
{
    byte key[16]= ""1234ff"";
    byte iv[16]= ""123456""; 

    std::string RecoveredText;

    // Decryptor
    CryptoPP::CFB_Mode&lt; CryptoPP::AES &gt;::Decryption decryptor( key, sizeof(key), iv );

    // Decryption
    CryptoPP::StringSource( CipherText, true,
        new CryptoPP::StreamTransformationFilter( decryptor,
            new CryptoPP::StringSink( RecoveredText ) ) ); 

    return (RecoveredText);
}

int main()
{
    string ciphertext;
    string plaintext = ""3555"";
    ciphertext= ENCRYPTOR(plaintext);
    string retrivdat = DECRYPTOR(ciphertext);

    cout&lt;&lt;""The plaintext data is:  ""&lt;&lt;plaintext&lt;&lt;endl;
    cout&lt;&lt;""The ciphertextdata is:  ""&lt;&lt;ciphertext&lt;&lt;endl;
    Coot&lt;&lt;""The retrieved data is:  ""&lt;&lt;retrivdat&lt;&lt;end;

    return 0;
}
</code></pre>

<hr>

<p>The output is </p>

<pre><code>The plaintext data is:  3555
The chepertext data is:  ï¥R_
The retrieved data is:  3555
</code></pre>
","<p>So you can:</p>

<ol>
<li>encode the number into the minimum number of x bytes, for instance using an unsigned big endian number</li>
<li>encrypt with CFB, resulting in the same number of x bytes</li>
<li>decrypt the number</li>
<li>decode the number from the resulting x bytes (using the same encoding scheme of course)</li>
</ol>

<p>If you want to see the ciphertext as number you'll have to decode the ciphertext as if it was a (signed or unsigned) number.</p>

<p>Note that you will still have to deal with the uniqueness of the IV. If you need to store the IV then there will be significant overhead.</p>
","473","<c++><encryption><encoding><crypto++>","-2","0","2","2015-01-05 23:22:47","","4","","608639","","2015-01-04 22:55:12","2015-01-04 20:21:49",""
"23588331","RSAES_OAEP_SHA_Decryptor MaxPlaintextLength returning zero","<p>I have to write a small authentication server that, when a client connects, sends a RSA public exponent and modulus to it, and the client returns the username and password encrypted with them. The part where I get the exponent and modulus works fine, the client receives them, and sends the encoded block back; that's not a problem. The problem is in decoding it: the RSA Decryptor always returns 0 as MaxPlaintextLength, and no matter how many different ways I try to move the data around, I can't get it to work.</p>

<p>I'm providing hex dumps of the different parts after the code.</p>

<pre><code>// These are static in the namespace to keep the key loaded.
static CryptoPP::AutoSeededRandomPool rsaRng;
static CryptoPP::InvertibleRSAFunction rsaParameters;
static CryptoPP::RSA::PrivateKey rsaPrivateKey(rsaParameters);

// This is done when the client connects.
{
    rsaPrivateKey.GenerateRandomWithKeySize(rsaRng, 1024);

    // This is where GetPublicExponent() and GetModulus() are
    // encoded and sent to the client. They are sent correctly
    // and I receive the encrypted data in a char buffer.
}

// This runs when I receive the encrypted data, which starts
// at &amp;dataBuffer[7] and has a length of rsaPayloadLen.
{
    int rsaPlainSize;
    byte *rsaBuffer;

    rsaBuffer = new byte[rsaPayloadLen];
    memcpy(&amp;rsaBuffer[0], &amp;dataBuffer[7], rsaPayloadLen);

    CryptoPP::SecByteBlock rsaCypher(rsaBuffer, rsaPayloadLen);
    CryptoPP::RSAES_OAEP_SHA_Decryptor rsaDecryptor(rsaPrivateKey);

    // At this point I inspected rsaCypher and it does contain the
    // expected binary data, and rsaCypher.size() returns 256.

    rsaPlainSize = rsaDecryptor.MaxPlaintextLength(rsaCypher.size());

    // rsaPlainSize is 0. I have no idea why!
}
</code></pre>

<p>Hex dumps of everything at the time of calling MaxPlaintextLength:</p>

<pre><code>rsaPrivateKey.GetPublicExponent():
000000: 11                                               .

rsaPrivateKey.GetPrivateExponent():
000000: 10 7a fd fd 9e a9 72 8c c3 5d 5b 80 e8 f4 6f bc  .z....r..][...o.
000010: bc 6a 7a 51 4f 9f af d3 e4 76 a5 4a 9d fe 17 37  .jzQO....v.J...7
000020: 03 cf 82 24 33 e2 a0 d8 97 26 0a 6b ac 9d b1 de  ...$3....&amp;.k....
000030: 39 d5 3a 93 aa 65 66 be 17 43 3c 00 20 77 68 0a  9.:..ef..C&lt;. wh.
000040: ac 2f 77 1e b8 c4 7f 64 52 54 7c 17 54 b6 e6 a4  ./w....dRT|.T...
000050: 95 49 60 7b 7b 16 6a 41 72 54 03 a2 2d 3a 80 8b  .I`{{.jArT..-:..
000060: aa 74 fa 77 22 5d 0a d9 81 b2 b2 48 01 db 43 e8  .t.w""].....H..C.
000070: 16 1c c4 c3 a6 bf 45 7e 90 d3 6a 37 10 40 9f 71  ......E~..j7.@.q

rsaPrivateKey.GetModulus():
000000: d2 20 26 61 a6 f0 74 82 ba e6 4e ab 9a 2c 90 a6  . &amp;a..t...N..,..
000010: 62 4d 97 8c b7 34 01 cd a0 e8 bb 77 5e 67 a7 fd  bM...4.....w^g..
000020: 70 95 bb 4d 95 89 82 c9 87 25 04 dc d8 da 9b d1  p..M.....%......
000030: 61 5e aa da bc 8c dd f7 a8 99 3d 01 9d f2 6e 89  a^........=...n.
000040: e4 75 ec 91 31 e9 86 f4 da 43 4a ca a4 66 6b 04  .u..1....CJ..fk.
000050: c2 c9 a1 18 1d fa 81 b0 6e ef a5 13 04 44 88 89  ........n....D..
000060: 42 41 be 9c 7c 77 75 96 50 07 70 ad eb 60 e5 05  BA..|wu.P.p..`..
000070: aa a8 d8 27 03 28 cf bb c7 f5 cb 0d b3 b3 96 7f  ...'.(..........

rsaPrivateKey.GetPrime1():
000000: d7 9e af ac e4 04 42 e4 58 9c 39 19 0e 56 7c ef  ......B.X.9..V|.
000010: b3 bf b6 26 73 25 d8 ab d7 5e d1 e0 56 49 ae 66  ...&amp;s%...^..VI.f
000020: c4 d8 81 bc d0 be c2 ef f4 6a 09 72 ef 72 35 7e  .........j.r.r5~
000030: 15 f4 f9 3b f8 be f9 3a a1 0d 3e d0 eb c8 34 11  ...;...:..&gt;...4.

rsaPrivateKey.GetPrime2():
000000: f9 7a 0e 1c 9a 1b eb d1 67 f1 e3 88 1d f3 f1 62  .z......g......b
000010: 9f a2 5c cb 49 76 de 42 25 e1 a4 de ed 50 f3 2d  ..\.Iv.B%....P.-
000020: c0 15 c3 70 b5 96 68 51 25 f7 06 24 e4 43 0d b8  ...p..hQ%..$.C..
000030: 7a c5 12 2c 7c 63 20 73 70 61 01 fe b8 b3 71 8f  z..,|c spa....q.

Plain text buffer that was encrypted:
000000: 73 74 72 69 6e 67 62 75 66 66 65 72 00 00 00 00  stringbuffer....
000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00        ..............

rsaCypher:
000000: 0e 9e bd 34 10 16 98 a5 b8 e4 0c 9b 4f 23 71 6d  ...4........O#qm
000010: af d6 e8 c1 4d 97 b9 32 cb 25 eb 01 fe 4f 5c 79  ....M..2.%...O\y
000020: 2d d8 32 c4 4f fa e9 2e 58 dd fd 37 7f 08 97 d8  -.2.O...X..7....
000030: 95 bb 6f 04 46 fa 83 77 05 01 43 75 ca be b4 4a  ..o.F..w..Cu...J
000040: 60 f9 e7 4a 91 3d bc ac fb e9 41 f3 9d b7 df d3  `..J.=....A.....
000050: a7 03 80 3a 7f 35 98 46 ca 06 b1 f3 d1 7b 56 83  ...:.5.F.....{V.
000060: 1b 00 7d 97 59 39 be 46 d5 cf 6d 2c b3 a7 8e 30  ..}.Y9.F..m,...0
000070: 39 ca ca d5 59 a2 71 43 e7 7e 75 b3 3c d6 a3 a5  9...Y.qC.~u.&lt;...
000080: aa 89 e3 e9 32 e1 a9 c1 a5 a8 f5 66 be 7f c9 ba  ....2......f....
000090: 65 35 0f 61 a0 d4 fa c7 ac 8e 28 7c 39 26 3f 01  e5.a......(|9&amp;?.
0000a0: 34 ad 82 69 5e c4 ab 92 48 47 42 04 02 48 79 c4  4..i^...HGB..Hy.
0000b0: 39 6e f2 2c 7c 19 71 34 36 38 1c eb c1 f2 33 f0  9n.,|.q468....3.
0000c0: 49 b9 7e bb c3 16 ed d7 f7 3e 10 a7 cc 2b 8c 31  I.~......&gt;...+.1
0000d0: f1 17 c7 a5 49 ce dd a3 c6 e2 9c 3c 2f 37 e4 97  ....I......&lt;/7..
0000e0: ac b7 24 17 b3 f8 75 6f 2a 85 cb 23 7a e1 77 72  ..$...uo*..#z.wr
0000f0: 02 0b 90 28 9b 9b ff 5d 6f 9b 11 11 d3 8b dd 4b  ...(...]o......K

rsaCypher.size(): 256

rsaDecryptor.MaxPlaintextLength(rsaCypher.size()): 0
</code></pre>

<p>I'm really completely at a loss and the only reason I've spent the whole weekend fighting this is because I'm going to need CryptoPP later for Blowfish and Adler32, otherwise I would have just used another RSA library.</p>
","<blockquote>
  <p>RSAES_OAEP_SHA_Decryptor MaxPlaintextLength returning zero...</p>
</blockquote>

<p>Your calculation of <code>rsaPayloadLen</code> is probably not correct. I would suggest you check the size of the ciphertext before you transmit it and after you recover it. I <em>think</em> its size is <code>rsaPayloadLen</code> in you code above.</p>

<p>From the comments in <code>cryptlib.h</code>:</p>

<pre><code>//! maximum length of plaintext for a given ciphertext length
/*! \note This function returns 0 if ciphertextLength is not valid (too long or too short). */
virtual size_t MaxPlaintextLength(size_t ciphertextLength) const =0;
</code></pre>

<p>I cannot duplicate when I take plain text, encrypt it, and then pass <code>ciphertext.size()</code> into <code>MaxPlaintextLength</code>. I <em>can</em> duplicate if I pass <code>ciphertext.size() - 1</code> into <code>MaxPlaintextLength</code>.</p>

<p>As a work around to get you a little further along, you might try using <code>FixedMaxPlaintextLength()</code>. It takes no arguments and only depends upon the public key length. You can use it to find the largest buffer based on the key. But you could fail on decryption.</p>

<p>You should probably show us your encryption code, too. You might not be sizing a buffer correctly.</p>
","470","<c++><encryption><rsa><crypto++>","2","2","2","2016-02-18 04:18:54","23599274","0","","608639","","2016-02-18 04:18:06","2014-05-11 02:30:30",""
"23588331","RSAES_OAEP_SHA_Decryptor MaxPlaintextLength returning zero","<p>I have to write a small authentication server that, when a client connects, sends a RSA public exponent and modulus to it, and the client returns the username and password encrypted with them. The part where I get the exponent and modulus works fine, the client receives them, and sends the encoded block back; that's not a problem. The problem is in decoding it: the RSA Decryptor always returns 0 as MaxPlaintextLength, and no matter how many different ways I try to move the data around, I can't get it to work.</p>

<p>I'm providing hex dumps of the different parts after the code.</p>

<pre><code>// These are static in the namespace to keep the key loaded.
static CryptoPP::AutoSeededRandomPool rsaRng;
static CryptoPP::InvertibleRSAFunction rsaParameters;
static CryptoPP::RSA::PrivateKey rsaPrivateKey(rsaParameters);

// This is done when the client connects.
{
    rsaPrivateKey.GenerateRandomWithKeySize(rsaRng, 1024);

    // This is where GetPublicExponent() and GetModulus() are
    // encoded and sent to the client. They are sent correctly
    // and I receive the encrypted data in a char buffer.
}

// This runs when I receive the encrypted data, which starts
// at &amp;dataBuffer[7] and has a length of rsaPayloadLen.
{
    int rsaPlainSize;
    byte *rsaBuffer;

    rsaBuffer = new byte[rsaPayloadLen];
    memcpy(&amp;rsaBuffer[0], &amp;dataBuffer[7], rsaPayloadLen);

    CryptoPP::SecByteBlock rsaCypher(rsaBuffer, rsaPayloadLen);
    CryptoPP::RSAES_OAEP_SHA_Decryptor rsaDecryptor(rsaPrivateKey);

    // At this point I inspected rsaCypher and it does contain the
    // expected binary data, and rsaCypher.size() returns 256.

    rsaPlainSize = rsaDecryptor.MaxPlaintextLength(rsaCypher.size());

    // rsaPlainSize is 0. I have no idea why!
}
</code></pre>

<p>Hex dumps of everything at the time of calling MaxPlaintextLength:</p>

<pre><code>rsaPrivateKey.GetPublicExponent():
000000: 11                                               .

rsaPrivateKey.GetPrivateExponent():
000000: 10 7a fd fd 9e a9 72 8c c3 5d 5b 80 e8 f4 6f bc  .z....r..][...o.
000010: bc 6a 7a 51 4f 9f af d3 e4 76 a5 4a 9d fe 17 37  .jzQO....v.J...7
000020: 03 cf 82 24 33 e2 a0 d8 97 26 0a 6b ac 9d b1 de  ...$3....&amp;.k....
000030: 39 d5 3a 93 aa 65 66 be 17 43 3c 00 20 77 68 0a  9.:..ef..C&lt;. wh.
000040: ac 2f 77 1e b8 c4 7f 64 52 54 7c 17 54 b6 e6 a4  ./w....dRT|.T...
000050: 95 49 60 7b 7b 16 6a 41 72 54 03 a2 2d 3a 80 8b  .I`{{.jArT..-:..
000060: aa 74 fa 77 22 5d 0a d9 81 b2 b2 48 01 db 43 e8  .t.w""].....H..C.
000070: 16 1c c4 c3 a6 bf 45 7e 90 d3 6a 37 10 40 9f 71  ......E~..j7.@.q

rsaPrivateKey.GetModulus():
000000: d2 20 26 61 a6 f0 74 82 ba e6 4e ab 9a 2c 90 a6  . &amp;a..t...N..,..
000010: 62 4d 97 8c b7 34 01 cd a0 e8 bb 77 5e 67 a7 fd  bM...4.....w^g..
000020: 70 95 bb 4d 95 89 82 c9 87 25 04 dc d8 da 9b d1  p..M.....%......
000030: 61 5e aa da bc 8c dd f7 a8 99 3d 01 9d f2 6e 89  a^........=...n.
000040: e4 75 ec 91 31 e9 86 f4 da 43 4a ca a4 66 6b 04  .u..1....CJ..fk.
000050: c2 c9 a1 18 1d fa 81 b0 6e ef a5 13 04 44 88 89  ........n....D..
000060: 42 41 be 9c 7c 77 75 96 50 07 70 ad eb 60 e5 05  BA..|wu.P.p..`..
000070: aa a8 d8 27 03 28 cf bb c7 f5 cb 0d b3 b3 96 7f  ...'.(..........

rsaPrivateKey.GetPrime1():
000000: d7 9e af ac e4 04 42 e4 58 9c 39 19 0e 56 7c ef  ......B.X.9..V|.
000010: b3 bf b6 26 73 25 d8 ab d7 5e d1 e0 56 49 ae 66  ...&amp;s%...^..VI.f
000020: c4 d8 81 bc d0 be c2 ef f4 6a 09 72 ef 72 35 7e  .........j.r.r5~
000030: 15 f4 f9 3b f8 be f9 3a a1 0d 3e d0 eb c8 34 11  ...;...:..&gt;...4.

rsaPrivateKey.GetPrime2():
000000: f9 7a 0e 1c 9a 1b eb d1 67 f1 e3 88 1d f3 f1 62  .z......g......b
000010: 9f a2 5c cb 49 76 de 42 25 e1 a4 de ed 50 f3 2d  ..\.Iv.B%....P.-
000020: c0 15 c3 70 b5 96 68 51 25 f7 06 24 e4 43 0d b8  ...p..hQ%..$.C..
000030: 7a c5 12 2c 7c 63 20 73 70 61 01 fe b8 b3 71 8f  z..,|c spa....q.

Plain text buffer that was encrypted:
000000: 73 74 72 69 6e 67 62 75 66 66 65 72 00 00 00 00  stringbuffer....
000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00        ..............

rsaCypher:
000000: 0e 9e bd 34 10 16 98 a5 b8 e4 0c 9b 4f 23 71 6d  ...4........O#qm
000010: af d6 e8 c1 4d 97 b9 32 cb 25 eb 01 fe 4f 5c 79  ....M..2.%...O\y
000020: 2d d8 32 c4 4f fa e9 2e 58 dd fd 37 7f 08 97 d8  -.2.O...X..7....
000030: 95 bb 6f 04 46 fa 83 77 05 01 43 75 ca be b4 4a  ..o.F..w..Cu...J
000040: 60 f9 e7 4a 91 3d bc ac fb e9 41 f3 9d b7 df d3  `..J.=....A.....
000050: a7 03 80 3a 7f 35 98 46 ca 06 b1 f3 d1 7b 56 83  ...:.5.F.....{V.
000060: 1b 00 7d 97 59 39 be 46 d5 cf 6d 2c b3 a7 8e 30  ..}.Y9.F..m,...0
000070: 39 ca ca d5 59 a2 71 43 e7 7e 75 b3 3c d6 a3 a5  9...Y.qC.~u.&lt;...
000080: aa 89 e3 e9 32 e1 a9 c1 a5 a8 f5 66 be 7f c9 ba  ....2......f....
000090: 65 35 0f 61 a0 d4 fa c7 ac 8e 28 7c 39 26 3f 01  e5.a......(|9&amp;?.
0000a0: 34 ad 82 69 5e c4 ab 92 48 47 42 04 02 48 79 c4  4..i^...HGB..Hy.
0000b0: 39 6e f2 2c 7c 19 71 34 36 38 1c eb c1 f2 33 f0  9n.,|.q468....3.
0000c0: 49 b9 7e bb c3 16 ed d7 f7 3e 10 a7 cc 2b 8c 31  I.~......&gt;...+.1
0000d0: f1 17 c7 a5 49 ce dd a3 c6 e2 9c 3c 2f 37 e4 97  ....I......&lt;/7..
0000e0: ac b7 24 17 b3 f8 75 6f 2a 85 cb 23 7a e1 77 72  ..$...uo*..#z.wr
0000f0: 02 0b 90 28 9b 9b ff 5d 6f 9b 11 11 d3 8b dd 4b  ...(...]o......K

rsaCypher.size(): 256

rsaDecryptor.MaxPlaintextLength(rsaCypher.size()): 0
</code></pre>

<p>I'm really completely at a loss and the only reason I've spent the whole weekend fighting this is because I'm going to need CryptoPP later for Blowfish and Adler32, otherwise I would have just used another RSA library.</p>
","<p>The whole problem was the key size. The doc said I should use a 1024-bit key, but the other program was expecting a 1152-byte key; apparently that change was never documented. Everything works fine after changing a single line:</p>

<pre><code>rsaPrivateKey.GenerateRandomWithKeySize(rsaRng, 1152);
</code></pre>

<p>Leaving this answer here in case someone else ever has this problem. Check the key sizes, and don't trust the documentation!</p>
","470","<c++><encryption><rsa><crypto++>","2","1","2","2016-02-18 04:18:54","23599274","0","","608639","","2016-02-18 04:18:06","2014-05-11 02:30:30",""
"32504572","RSA Signature Size Mismatch","<p>As stated <a href=""https://stackoverflow.com/questions/6658728/rsa-signature-size"">here</a>, the length of the message signature is equal to the modulus of the Private Key, <em>aka</em> the Public Key.</p>

<p>I'm implementing a system that signs a message, and I have a size mismatch that I can't solve.
I use <code>crypto++</code>.</p>

<p>Here is the code I use :</p>

<pre><code>/* Create RSA Keys */
RSA::PrivateKey privateKey;
privateKey.GenerateRandomWithKeySize(prng, 3072);
RSA::PublicKey publicKey(privateKey);
cout &lt;&lt; ""&gt;&gt; RSA Keys generated"";
    /* Key Size */
    string spki;
    StringSink sSink(spki);
    publicKey.Save(sSink);
    cout &lt;&lt;"" (""&lt;&lt; spki.size()&lt;&lt;"" bytes)""&lt;&lt;endl;

RSASSA_PKCS1v15_SHA_Signer signer(privateKey);
size_t length = signer.MaxSignatureLength();
cout &lt;&lt;""MaxSignatureLength "" &lt;&lt;length&lt;&lt;endl;
    SecByteBlock signature( length );
</code></pre>

<p>And the output is :</p>

<pre><code>&gt;&gt; RSA Keys generated (420 bytes)
&gt;&gt; ServerHello sent (436 bytes)
   MaxSignatureLength 384
   RSA Signature length 384
</code></pre>

<p>Shouldn't the <code>MaxSignatureLength</code>, and the <code>RSA Signature length</code> 420 bytes long ?</p>

<p>Is the problem with the algorithm I use ?</p>
","<blockquote>
  <p>Shouldn't the MaxSignatureLength, and the RSA Signature length 420 bytes long ?</p>
</blockquote>

<p>No. You are asking for a key with 3072-bits or 384 bytes. That's the limit on the size of the signature.</p>

<p>Each cryptosystem will likely be different in this area. </p>

<blockquote>
<pre><code>cout &lt;&lt;"" (""&lt;&lt; spki.size()&lt;&lt;"" bytes)""&lt;&lt;endl;
</code></pre>
</blockquote>

<p>This is the size of <code>{OID,n,e}</code> with the <a href=""http://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One"" rel=""nofollow noreferrer"">ASN.1</a> framing or overhead. See your previous question <a href=""https://stackoverflow.com/a/32419626/608639"">Sending PublicKey within packet payload</a> for what it looks like (in particular, the output of the command <code>dumpasn1 rsa-public.der</code>).</p>

<blockquote>
<pre><code>cout &lt;&lt;""MaxSignatureLength "" &lt;&lt;length&lt;&lt;endl;
</code></pre>
</blockquote>

<p>This is <code>n - 1</code> for RSA, if I recall correctly.</p>

<blockquote>
  <p>Is the problem with the algorithm I use ?</p>
</blockquote>

<p>No, you are doing things correctly by calling <code>MaxSignatureLength()</code>.</p>

<hr>

<pre><code> &gt;&gt; RSA Keys generated (420 bytes)
 &gt;&gt; ServerHello sent (436 bytes)
</code></pre>

<p>I'm just speculating, but it appears you appear to have design issues, too.</p>

<p>When you encrypt a message, like the <code>ServerHello</code>, you usually encrypt it under a symmetric cipher, like AES or Camellia. Then, you take that symmetric cipher key, and encrypt it under the RSA key. Finally, you send the pair <code>{encrypted symmetric cipher key, encrypted message under symmetric cipher}</code> to the other party.</p>

<p>In the system partially described above, you're only encrypting 16 or 32 bytes under the public key.</p>

<hr>

<p>I <em>think</em> what you should be doing is using an Integrated Encryption Scheme to send encrypted message back and forth. For that, see <a href=""https://cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">Elliptic Curve Integrated Encryption Scheme (ECIES)</a> and <a href=""https://cryptopp.com/wiki/Discrete_Logarithm_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">Discrete Logarithm Integrated Encryption Scheme (DLIES)</a>. ECIES operates over elliptic curves, and DLIES operate over integers.</p>

<p>Integrated Encryption Schemes have some very desireable security properties, like they are <a href=""https://en.wikipedia.org/wiki/Ciphertext_indistinguishability"" rel=""nofollow noreferrer"">IND-CCA2</a>. They achieve it by <em>not</em> allowing you to do some things, like reusing a security context, so the security is baked into the scheme.</p>

<p>You still have to solve the key distribution problem, though. That's a thorny problem, and we don't have a good, scalable solution.</p>

<p>And now you see why algorithm agility is important, and why you want that OID sent as part of the key during the handshake phase :)</p>
","462","<c++><rsa><digital-signature><crypto++>","5","3","1","2015-09-12 01:28:31","32514242","2","1","-1","","2017-05-23 11:44:28","2015-09-10 14:24:32",""
"47474980","Invalid PKCS #7 block padding when using Crypto++","<p>We are using cryptopp library. We are using the below coding. Encryption is working file without any issue and we are able to get the cipher text. But getting an error while decrypting as ""Block padding found"". What could be the issue...?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""modes.h""
#include ""hex.h""
#include ""aes.h""
#include ""osrng.h""
using namespace CryptoPP;
using CryptoPP::AutoSeededRandomPool;

class cspl_crypto{

public:
  cspl_crypto();
  byte* generate_block(int size);
  char* encrypt_rijndael(byte[], byte[], int, char*, int);
  char* decrypt_rijndael(byte[], byte[], int, char*, int);
  string readFile();
  void writeFile(string);
};

cspl_crypto::cspl_crypto()
{

}

int main(int argc, char* argv[])
{
  vector&lt;byte&gt; plain;
  cspl_crypto ccrypto;
  AutoSeededRandomPool prng;

    byte key[AES::DEFAULT_KEYLENGTH];
    prng.GenerateBlock(key, sizeof(key));

    byte iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));
</code></pre>

<p>Converting string to char *</p>

<pre><code>  string str(""testing""); //ccrypto.readFile()
char plainArray[str.size()];
strcpy(plainArray, str.c_str());

char* cipher  = ccrypto.encrypt_rijndael(key, iv, sizeof(key), plainArray, 
sizeof(plainArray));

//char cipherCharArray[cipherText.size()];
// strcpy(cipherCharArray, cipherText.c_str());

char* recover = ccrypto.decrypt_rijndael(key, iv, sizeof(key), cipher, 
sizeof(cipher));

// cout &lt;&lt; ""Recovered text: "" &lt;&lt; recoverText &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Encryption Block:</p>

<pre><code>char* cspl_crypto::encrypt_rijndael(byte key[], byte iv[], int keysize, char 
plainText[], int plainTextSize){
    vector&lt;byte&gt; cipher;

       std::vector&lt;byte&gt; plain(plainText, plainText + plainTextSize);

    CBC_Mode&lt;AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, keysize, iv, keysize);

// Make room for padding
cipher.resize(plain.size()+AES::BLOCKSIZE);
ArraySink cs(&amp;cipher[0], cipher.size());

ArraySource(plain.data(), plain.size(), true,
        new StreamTransformationFilter(enc, new Redirector(cs)));

// Set cipher text length now that its known
cipher.resize(cs.TotalPutLength());
    char returnValue[cipher.size()];
    copy(cipher.begin(), cipher.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Decyption Block:</p>

<pre><code>char* cspl_crypto::decrypt_rijndael(byte key[], byte iv[], int keysize, char 
cipher[], int size ){
 std::vector&lt;byte&gt; v(cipher, cipher + size);
 vector&lt;byte&gt; recover;
  CBC_Mode&lt;AES&gt;::Decryption dec;
  dec.SetKeyWithIV(key, keysize, iv, keysize);

  // Recovered text will be less than cipher text
  recover.resize(v.size());
  ArraySink rs(&amp;recover[0], recover.size());

  ArraySource(v.data(), v.size(), true,
    new StreamTransformationFilter(dec, new Redirector(rs)));

  // Set recovered text length now that its known
  recover.resize(rs.TotalPutLength());

        char returnValue[recover.size()];
        copy(recover.begin(), recover.end(), returnValue);

    return returnValue;
}
</code></pre>

<p>Library:</p>

<pre><code>string cspl_crypto::readFile(){

  string line;
  string returnValue = """";
  ifstream myfile (""N07.txt"");
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
      returnValue +=  line + '\n';
    }
    myfile.close();
  }

  else returnValue = ""Unable to open file""; 

return returnValue;

}
</code></pre>
","","462","<c++><encryption><crypto++><pkcs#7>","0","","0","2017-11-27 13:47:55","","2","","608639","","2017-11-27 13:47:55","2017-11-24 14:07:23",""
"27291653","Error C2664 compiling DLL based on old crypto++ library","<p>I'm not a C++ programmer and i'm just trying to compile an old DLL (VS6 I think) in VS2010 based on the crypto++ library for the purpose of debugging it to find out how it works as I have to write some code in another language to be able to read things it encrypts</p>

<p>When I try to compile the DLL I get Error C2664 on the first typename in this bit of code</p>

<pre><code> #else /* _ITERATOR_DEBUG_LEVEL == 0 */
    _Vector_val(_Alloc _Al = _Alloc())
        : _Alval(_Al)
        {   // construct allocator from _Al
        typename _Alloc::template rebind&lt;_Container_proxy&gt;::other
            _Alproxy(_Alval);
        this-&gt;_Myproxy = _Alproxy.allocate(1);
        _Cons_val(_Alproxy, this-&gt;_Myproxy, _Container_proxy());
        this-&gt;_Myproxy-&gt;_Mycont = this;

        _Myfirst = 0;
        _Mylast = 0;
        _Myend = 0;
        }

    ~_Vector_val()
        {   // destroy proxy
        typename _Alloc::template rebind&lt;_Container_proxy&gt;::other
            _Alproxy(_Alval);
        this-&gt;_Orphan_all();
        _Dest_val(_Alproxy, this-&gt;_Myproxy);
        _Alproxy.deallocate(this-&gt;_Myproxy, 1);
        this-&gt;_Myproxy = 0;
        }
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
</code></pre>

<p>I've had a Google but I don't understand enough about the answer to be able to change it</p>

<p>The actual error shown in the build is this</p>

<pre><code>1&gt;c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(441): error C2664: 'CryptoPP::AllocatorWithCleanup&lt;T&gt;::AllocatorWithCleanup(const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;)' : cannot convert parameter 1 from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;'
</code></pre>

<p>But i'm not sure how that relates to the line it points to when I double click as I cant seem to find any of the words it uses ?</p>

<p>Thanks very much in advance for your time and assistance</p>

<p>PS I darn't look at a newer version of the library that probably would compile as I wont know if they have changed any of the encryption methods used</p>

<p>Here is the full contents of the output window</p>

<pre><code>1&gt;------ Build started: Project: dfxext, Configuration: Debug Win32 ------
1&gt;  StdAfx.cpp
1&gt;  _WIN32_WINNT not defined. Defaulting to _WIN32_WINNT_MAXVER (see WinSDKVer.h)
1&gt;  CDialogSK.cpp
1&gt;  CMSDialog.cpp
1&gt;  CtlStockIcon.cpp
1&gt;  DonorflexDLL.cpp
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\donorflexdll.cpp(63): warning C4996: 'CWinApp::SetDialogBkColor': CWinApp::SetDialogBkColor is no longer supported. Instead, handle WM_CTLCOLORDLG in your dialog
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\afxwin.h(5365) : see declaration of 'CWinApp::SetDialogBkColor'
1&gt;  DonProgress.cpp
1&gt;  EnterpriseRegistrationDialog.cpp
1&gt;  GradientFillBox.cpp
1&gt;  interfaces.cpp
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(308): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(105) : see declaration of 'strcpy'
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(508): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(188) : see declaration of 'strncpy'
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(538): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(188) : see declaration of 'strncpy'
1&gt;c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(441): error C2664: 'CryptoPP::AllocatorWithCleanup&lt;T&gt;::AllocatorWithCleanup(const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;)' : cannot convert parameter 1 from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;'
1&gt;          with
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=CryptoPP::HuffmanDecoder::CodeInfo
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          Reason: cannot convert from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt;'
1&gt;          with
1&gt;          [
1&gt;              T=CryptoPP::HuffmanDecoder::CodeInfo
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(437) : while compiling class template member function 'std::_Vector_val&lt;_Ty,_Alloc&gt;::_Vector_val(_Alloc)'
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Alloc=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(481) : see reference to class template instantiation 'std::_Vector_val&lt;_Ty,_Alloc&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Alloc=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;          c:\users\andrew.cmac\documents\temp c++ project search\common\c++\libcrypto\zinflate.h(79) : see reference to class template instantiation 'std::vector&lt;_Ty,_Ax&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Ax=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;  MD5Checksum.cpp
1&gt;  ProgressDialog.cpp
1&gt;  SmallProgressDialog.cpp
1&gt;  SplashScreen.cpp
1&gt;  SplashScreenIdleThread.cpp
1&gt;  Generating Code...
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</code></pre>

<p>The only references to the text 'max_size' in the whole libraray are these and they ar all in a file called secblock.h</p>

<pre><code>size_type max_size() const {return ~size_type(0)/sizeof(T);}    // switch to std::numeric_limits&lt;T&gt;::max later
size_type max_size() const {return 0;}
size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}
</code></pre>

<p>This is the interfaces.cpp file. Hopefully that is what you meant</p>

<pre><code>// DonorflexDLL.cpp : Defines the initialization routines for the DLL.
//

#include ""stdafx.h""
#include ""constants.h""
#include ""interfaces.h""

#include ""DonProgress.h""

#include ""..\libzipproxy\zipproxy.h""

#include ""MD5Checksum.h""
#include ""GradientFillBox.h""

#include &lt;NamedPipeClient.h&gt;
#include &lt;PCREWrapper.h&gt;

#include ""EnterpriseRegistrationDialog.h""

#include ""SplashScreen.h""
#include ""SplashScreenIdleThread.h""

#include &lt;InstanceManagerClient.h&gt;

// Headers to support cryptography:
#include &lt;string&gt;       // STL
#include &lt;default.h&gt;    // Crypto++ libraries.
#include &lt;hex.h&gt;        // Hex Encoders and Decords from CryptoPP
#include &lt;base64.h&gt;     // base64 Encoders and Decords from CryptoPP
#include &lt;zlib.h&gt;       // Compression

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define LIBVER 95

using namespace ui;
using namespace threads;
using namespace std;
using namespace CryptoPP;

/////////////////////////////////////////////////////////////////////////////
// CDon32App

/////////////////////////////////////////////////////////////////////////////
// CDon32App construction

/////////////////////////////////////////////////////////////////////////////
// The one and only CDon32App object

// Global functions for access from DataFlex:

UINT DFXAPI DON32_Version() {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To supply the current version of the library to the Donorflex base system:

    // Local Variables:

    // Code:
    return LIBVER;  // Define globally in Don32.h
}

void DFXAPI DON32_About() {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To show the Donorflex Gi About screen.

    // Local variables:

    // Code:
    // TODO
}

HIMAGELIST DFXAPI DON32_GetImageList(UINT uiWhich) {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To return the handle of the standard image list.

    // Local variables:

    // Code:
    // TODO:

    // Returns:
    return NULL;
}

void DFXAPI DON32_AddBubbleMessage(LPCSTR lpszMsg, DWORD iFont) {
}

// InitBubble, resets the contents of the string arrays and font type,
// must be called before using the bubble routine.
void DFXAPI DON32_InitBubbleWindow(void) {
}

// Tip of the day support:

void DFXAPI DON32_TipAtStartup(void) {

}

void DFXAPI DON32_TipOfTheDay(void) {

}

// Progress Box Thread Control:

/*
Purpose / Description:
    This interface is historic and was imported from the original DON32 library

*/
void DFXAPI DON32_BeginProgressThread(HWND hWndParent, DWORD dwAnim, LPSTR lpsCaption, LPSTR lpsTitle, LPSTR lpsMsg, int iCancel) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsCaption, lpsTitle, lpsMsg, iCancel, RGB(0,0x65,0xFF)); // TODO replace this with proper default colour.
}

void DFXAPI DFX_SmallProgress(HWND hWndParent, DWORD dwAnim, LPSTR lpsTitle, LPSTR lpsMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsTitle, lpsMsg);
}

/*
Description:
    New interface as of 26/01/2004 by EN to facilitate setting of theme colours
    throughout the donorflex application.
*/
void DFXAPI DFX_Progress(HWND hWndParent, DWORD dwAnim, LPSTR lpsCaption, LPSTR lpsTitle, LPSTR lpsMsg, int iCancel, COLORREF gradientColour) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsCaption, lpsTitle, lpsMsg, iCancel, gradientColour);
}

void DFXAPI DON32_EndProgressThread(void) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;CloseInstance();
}

void DFXAPI DON32_ProgressSuspend(void) {
    // NOTE: This function is not implemeted in Donorflex.
}

// Progress Box Control:

void DFXAPI DON32_ProgressMsgA(LPSTR lpszMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;SetDialogMessageA(lpszMsg);
}

void DFXAPI DON32_ProgressMsgB(LPSTR lpszMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;SetDialogMessageB(lpszMsg);
}

void DFXAPI DON32_ProgressMeter(int iLow, int iHigh) {
}

void DFXAPI DON32_ProgressSet(int iPos) {
}

void DFXAPI DON32_ProgressStep() {
}

DWORD DFXAPI DON32_QueryProgress(void) {
    DWORD dword = FALSE;
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) dword = (DWORD)instance-&gt;isCancelled();

    return dword;
}

void DFXAPI DON32_ProgressResume(void) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;ResetDialog();

}

void DFXAPI DON32_EnableSysTray(HWND hwndTarget) {
}

HWND DFXAPI DON32_ShowBubbleWindow(HWND hParent, DWORD bClose) {
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CCMAC32App

/////////////////////////////////////////////////////////////////////////////
// CCMAC32App construction


/////////////////////////////////////////////////////////////////////////////
// The one and only CCMAC32App object

// CCMAC32App theApp;

////////////////////////////
// Globals

int DFXAPI CMAC32_GetPassword(LPCSTR lpszTitle, LPCSTR lpszValue) {
    return 0;
}

int DFXAPI CMAC32_ChangePassword(LPCSTR lpszValue, LPSTR lpszNew) {
    return 0;
}

int DFXAPI CMAC32_Dialog(DWORD wRscId) {
    return 0;
}

int DFXAPI CMAC32_SysLog(DWORD wType) {
    return 0;
}

UINT DFXAPI CMAC32_Version(void) {

    return LIBVER;
}

// New interfaces for Donorflex 6 / 9:

void DFXAPI AMO_Begin(void)
{

    // TODO Needs reworking to fit 6.1 service process architecture
}


// NEW!! Introduced for revised who's logged in processing,
// returns nonzero on success.
BOOL DFXAPI AMO_SetDetails(LPCSTR lpUserId, LPCSTR lpDetails)
{
    //client::InstanceManagerClient c;

    return false; //c.RegisterInstance(::GetCurrentProcessId(), lpUserId, NULL, lpDetails);
}

char current_user_id[24];

BOOL DFXAPI AMO_SetUserId(LPCSTR userId)
{
    //AMO_SetDetails(userId, TEXT(""No Details specified""));
    //strncpy(current_user_id, userId, sizeof(current_user_id));

    return false;   // TODO
}

BOOL DFXAPI AMO_Workspace(LPCSTR lpWorkspace)
{
    // Overwrite the previous details against the current process id, based on the stored user name above.
    AMO_SetDetails(current_user_id, lpWorkspace);

    return false;   // TODO
}

BOOL DFXAPI AMO_NextMessage(LPSTR buffer)
{
    return false;   // TODO current indicates no more messages.
}

BOOL DFXAPI AMO_Broadcast(void)
{
    // TODO

    return false;
}

void DFXAPI CMS_Begin(HWND hwnd)
{

    return; // TODO
}

BOOL DFXAPI CMS_SendMessage(LPCSTR lpMsg)
{


    return false; // TODO
}

BOOL DFXAPI CMS_SendMessage2(LPCSTR lpMsg, LPCSTR lpUserName)
{
    // TODO: Support for user name passing.


    return false;
}

// MD5 interface:

BOOL DFXAPI MD5_Hash(LPCSTR lpSource, UINT nLength, LPSTR lpResult)
{
    CString result;
    LPTSTR lptResult;

    result = core::CMD5Checksum::GetMD5((BYTE*)lpSource, nLength);

    lptResult = result.LockBuffer();
    strcpy(lpResult, lptResult);
    result.UnlockBuffer();

    return FALSE;
}

BOOL DFXAPI UTL_CheckExclusive(LPCSTR sFilename)
{
    // Purpose
    // To determine whether or not a file can be open exclusively.

    // Returns:
    //  true if file can be accessed exclusively
    //  false if file cannot be accessed exclusively

    // Locals:
    CFile oFile;
    CFileException oFileException;
    BOOL bRetcode;

    // Code:
    bRetcode = oFile.Open(sFilename, CFile::modeRead|CFile::shareExclusive, &amp;oFileException);

    return bRetcode;
}

/*
Purpose / Description:
    This interface provides a means by which a dataflex window can be
    dynamically subclassed to provide a gradient fill mechanism suitable
    for all colours and gradients.

Arguments:
    hWnd    - a handle of a window to be dynamically subclassed.
    red, green, blue - the colour.
*/
BOOL DFXAPI DFX_SubclassGradient(HWND hWnd, COLORREF col)
{
    if (CWnd::FromHandlePermanent(hWnd)) return true;

    CGradientFillBox *wnd = new CGradientFillBox(col);

    BOOL ret = wnd-&gt;SubclassWindow(hWnd);

    if (!ret) delete wnd;

    return ret;
}

/*
General purpose window subclassing.
*/
BOOL DFXAPI DFX_Subclass(HWND hWnd, int type, LPVOID lpExtra) {

/*
    if (CWnd::FromHandlePermanent(hWnd)) return true;

    // TODO CGradientFillBox *wnd = new CGradientFillBox(col);

    BOOL ret = wnd-&gt;SubclassWindow(hWnd);

    if (!ret) delete wnd;
    return ret;
*/
    return false;
}

BOOL DFXAPI DFX_Unsubclass(HWND hWnd) {

    CWnd *wnd = CWnd::FromHandlePermanent(hWnd);
    if (!wnd) return false;

    wnd-&gt;UnsubclassWindow();

    return true;
}

/*
Purpose / Description:
    This is a general purpose interface for subclassing windows
    for any type. It should be used in preference to the DFX_SubclassGradient
    function.

Arguments:
*/

/*
Purpose / Description:
    This interface allows the dataflex system to notify the subclassed window
    that a change in window colour has occured.

Arguments:
    hWnd        - The handle of the window to take the notification
    COLORREF    - The color reference that should be used from now on.

*/
BOOL DFXAPI DFX_NotifyColourChange (HWND hWnd, COLORREF col) {

    CGradientFillBox *wnd;

    // Get the window class that is mapped to this
    wnd = DYNAMIC_DOWNCAST(CGradientFillBox, CWnd::FromHandlePermanent(hWnd));

    // If the window handle is null then return the error condition:
    ASSERT(wnd);
    if (!wnd) return true;

    // Now update the COLOREF value associated with the window class:
    wnd-&gt;SetTargetColour(col);

    return false;
}

BOOL DFXAPI DFX_GradientFillDirection(HWND hWnd, int direction) {
    CGradientFillBox *wnd;

    wnd = DYNAMIC_DOWNCAST(CGradientFillBox, CWnd::FromHandlePermanent(hWnd));
    ASSERT(wnd);
    if (!wnd) return true;

    wnd-&gt;SetFillDirection(direction);

    return false;
}

// Integer value that governs if thin client mode is active or not:
int operatingmode = OM_NORMAL;

/*
Description:
    This API provides a method of switching off the animation and colour
    used in the user interactive side of the DLL.

    This is required in order to reduce bandwidth required to operate
    version 6+ of donorflex.

Assumptions &amp; Pre-conditions:
    None

Arguments:
    mode        - Can either be 0 for standard or 1 for thin terminal services mode.
*/
int DFXAPI DFX_SetOperatingMode(int mode) {

    operatingmode = mode;

    return mode;
}

int DFXAPI DFX_GetOperatingMode() {
    return operatingmode;
}


int DFXAPI DFX_ShowSplashScreen(LPCSTR lpsFilename, COLORREF transparency, LPCSTR lpsRegName, LPCSTR lpsSerialNo, int regx, int regy, int serx, int sery)
{
    CPoint reg_point(regx, regy);
    CPoint ser_point(serx, sery);

    SplashScreenIdleThread::Show(lpsFilename, transparency, lpsRegName, lpsSerialNo, reg_point, ser_point);

    return 0;
}

int DFXAPI DFX_HideSplashScreen(HWND hwParent)
{
    SplashScreenIdleThread::Hide(hwParent);

    return 0;
}

// 13.04.2005: EN : New string encryption routine:

int DFXAPI DFX_EncryptString(const char * encoding, const char * instring, char * outstring, int outbuffsize, const char * passphrase)
{
    // Encrypts the given string buffer using the given passphrase and returns the output in the
    // buffer provided. Make sure that the size of the passed buffer is adequate.
    string ls;

    BufferedTransformation * encryptor = NULL;

    try {

        if (!strcmp(encoding, ""base64"")) encryptor = new DefaultEncryptorWithMAC(passphrase, new Base64Encoder(new StringSink(ls), false));
        if (!strcmp(encoding, ""hex"")) encryptor = new DefaultEncryptorWithMAC(passphrase, new HexEncoder(new StringSink(ls)));
        if (!strcmp(encoding, ""zlib"")) encryptor = new DefaultEncryptorWithMAC (passphrase, new ZlibCompressor(new StringSink(ls)));
        if (!strcmp(encoding, ""none"")) encryptor = new DefaultEncryptorWithMAC (passphrase, new StringSink(ls));

        encryptor-&gt;Put((byte *)instring, strlen(instring));
        encryptor-&gt;MessageEnd();
    }
    catch (...) {
        // Catch all errors
        ls = ""ERROR"";
    }

    // Cleanup:
    if (encryptor!=NULL) delete encryptor;

    // Copy returned string into the output buffer:
    strncpy(outstring, ls.c_str(), (size_t)outbuffsize);

    return ls.size();
}

int DFXAPI DFX_DecryptString(const char * encoding, const char * instring, char * outstring, int outbuffsize, const char * passphrase)
{
    string ls;

    BufferedTransformation * decryptor = NULL;

    try {

        if (!strcmp(encoding, ""base64"")) decryptor = new Base64Decoder(new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""hex"")) decryptor = new HexDecoder(new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""zlib"")) decryptor = new ZlibDecompressor (new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""none"")) decryptor = new DefaultDecryptorWithMAC(passphrase, new StringSink(ls));

        decryptor-&gt;Put((byte *)instring, strlen(instring));
        decryptor-&gt;MessageEnd();
    }
    catch (...) {
        // Stop any errors causing a complete mess.
        ls = ""ERROR"";
    }

    // Cleanup:
    if (decryptor != NULL) delete decryptor;

    // Copy returned string into the output buffer:
    strncpy(outstring, ls.c_str(), (size_t)outbuffsize);

    return ls.size();   // No error.
}
</code></pre>
","<p>Check the parameter. Seems that it is required that ""first parameter template argument"" (the one in ""&lt;>"" braces in the parameter initialization) is allowed to be cast to type that is required.</p>

<p>Post more code, post code from the call stack, i cant write a more detailed answer with given information...</p>

<p>(Trying to guess answer...)
Maybe yours STL implementation for allocators differs from other stl implementations in code for 'max_size'. Check the 'max_size' code in the crypto++ allocator, compare it to code for standard allocator...</p>
","460","<c++><dll><crypto++><c2664>","0","0","2","2014-12-04 12:13:54","","0","","3173234","","2014-12-04 11:58:51","2014-12-04 10:29:01",""
"27291653","Error C2664 compiling DLL based on old crypto++ library","<p>I'm not a C++ programmer and i'm just trying to compile an old DLL (VS6 I think) in VS2010 based on the crypto++ library for the purpose of debugging it to find out how it works as I have to write some code in another language to be able to read things it encrypts</p>

<p>When I try to compile the DLL I get Error C2664 on the first typename in this bit of code</p>

<pre><code> #else /* _ITERATOR_DEBUG_LEVEL == 0 */
    _Vector_val(_Alloc _Al = _Alloc())
        : _Alval(_Al)
        {   // construct allocator from _Al
        typename _Alloc::template rebind&lt;_Container_proxy&gt;::other
            _Alproxy(_Alval);
        this-&gt;_Myproxy = _Alproxy.allocate(1);
        _Cons_val(_Alproxy, this-&gt;_Myproxy, _Container_proxy());
        this-&gt;_Myproxy-&gt;_Mycont = this;

        _Myfirst = 0;
        _Mylast = 0;
        _Myend = 0;
        }

    ~_Vector_val()
        {   // destroy proxy
        typename _Alloc::template rebind&lt;_Container_proxy&gt;::other
            _Alproxy(_Alval);
        this-&gt;_Orphan_all();
        _Dest_val(_Alproxy, this-&gt;_Myproxy);
        _Alproxy.deallocate(this-&gt;_Myproxy, 1);
        this-&gt;_Myproxy = 0;
        }
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
</code></pre>

<p>I've had a Google but I don't understand enough about the answer to be able to change it</p>

<p>The actual error shown in the build is this</p>

<pre><code>1&gt;c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(441): error C2664: 'CryptoPP::AllocatorWithCleanup&lt;T&gt;::AllocatorWithCleanup(const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;)' : cannot convert parameter 1 from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;'
</code></pre>

<p>But i'm not sure how that relates to the line it points to when I double click as I cant seem to find any of the words it uses ?</p>

<p>Thanks very much in advance for your time and assistance</p>

<p>PS I darn't look at a newer version of the library that probably would compile as I wont know if they have changed any of the encryption methods used</p>

<p>Here is the full contents of the output window</p>

<pre><code>1&gt;------ Build started: Project: dfxext, Configuration: Debug Win32 ------
1&gt;  StdAfx.cpp
1&gt;  _WIN32_WINNT not defined. Defaulting to _WIN32_WINNT_MAXVER (see WinSDKVer.h)
1&gt;  CDialogSK.cpp
1&gt;  CMSDialog.cpp
1&gt;  CtlStockIcon.cpp
1&gt;  DonorflexDLL.cpp
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\donorflexdll.cpp(63): warning C4996: 'CWinApp::SetDialogBkColor': CWinApp::SetDialogBkColor is no longer supported. Instead, handle WM_CTLCOLORDLG in your dialog
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\atlmfc\include\afxwin.h(5365) : see declaration of 'CWinApp::SetDialogBkColor'
1&gt;  DonProgress.cpp
1&gt;  EnterpriseRegistrationDialog.cpp
1&gt;  GradientFillBox.cpp
1&gt;  interfaces.cpp
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(308): warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(105) : see declaration of 'strcpy'
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(508): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(188) : see declaration of 'strncpy'
1&gt;c:\users\andrew.cmac\documents\temp c++ project search\common\c++\agk_vs2010_dfxext\interfaces.cpp(538): warning C4996: 'strncpy': This function or variable may be unsafe. Consider using strncpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\string.h(188) : see declaration of 'strncpy'
1&gt;c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(441): error C2664: 'CryptoPP::AllocatorWithCleanup&lt;T&gt;::AllocatorWithCleanup(const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;)' : cannot convert parameter 1 from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt; &amp;'
1&gt;          with
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=CryptoPP::HuffmanDecoder::CodeInfo
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          Reason: cannot convert from 'CryptoPP::AllocatorWithCleanup&lt;T&gt;' to 'const CryptoPP::AllocatorWithCleanup&lt;T&gt;'
1&gt;          with
1&gt;          [
1&gt;              T=CryptoPP::HuffmanDecoder::CodeInfo
1&gt;          ]
1&gt;          and
1&gt;          [
1&gt;              T=std::_Container_proxy
1&gt;          ]
1&gt;          No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(437) : while compiling class template member function 'std::_Vector_val&lt;_Ty,_Alloc&gt;::_Vector_val(_Alloc)'
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Alloc=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;          c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector(481) : see reference to class template instantiation 'std::_Vector_val&lt;_Ty,_Alloc&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Alloc=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;          c:\users\andrew.cmac\documents\temp c++ project search\common\c++\libcrypto\zinflate.h(79) : see reference to class template instantiation 'std::vector&lt;_Ty,_Ax&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              _Ty=CryptoPP::HuffmanDecoder::CodeInfo,
1&gt;              _Ax=CryptoPP::AllocatorWithCleanup&lt;CryptoPP::HuffmanDecoder::CodeInfo&gt;
1&gt;          ]
1&gt;  MD5Checksum.cpp
1&gt;  ProgressDialog.cpp
1&gt;  SmallProgressDialog.cpp
1&gt;  SplashScreen.cpp
1&gt;  SplashScreenIdleThread.cpp
1&gt;  Generating Code...
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</code></pre>

<p>The only references to the text 'max_size' in the whole libraray are these and they ar all in a file called secblock.h</p>

<pre><code>size_type max_size() const {return ~size_type(0)/sizeof(T);}    // switch to std::numeric_limits&lt;T&gt;::max later
size_type max_size() const {return 0;}
size_type max_size() const {return STDMAX(m_fallbackAllocator.max_size(), S);}
</code></pre>

<p>This is the interfaces.cpp file. Hopefully that is what you meant</p>

<pre><code>// DonorflexDLL.cpp : Defines the initialization routines for the DLL.
//

#include ""stdafx.h""
#include ""constants.h""
#include ""interfaces.h""

#include ""DonProgress.h""

#include ""..\libzipproxy\zipproxy.h""

#include ""MD5Checksum.h""
#include ""GradientFillBox.h""

#include &lt;NamedPipeClient.h&gt;
#include &lt;PCREWrapper.h&gt;

#include ""EnterpriseRegistrationDialog.h""

#include ""SplashScreen.h""
#include ""SplashScreenIdleThread.h""

#include &lt;InstanceManagerClient.h&gt;

// Headers to support cryptography:
#include &lt;string&gt;       // STL
#include &lt;default.h&gt;    // Crypto++ libraries.
#include &lt;hex.h&gt;        // Hex Encoders and Decords from CryptoPP
#include &lt;base64.h&gt;     // base64 Encoders and Decords from CryptoPP
#include &lt;zlib.h&gt;       // Compression

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define LIBVER 95

using namespace ui;
using namespace threads;
using namespace std;
using namespace CryptoPP;

/////////////////////////////////////////////////////////////////////////////
// CDon32App

/////////////////////////////////////////////////////////////////////////////
// CDon32App construction

/////////////////////////////////////////////////////////////////////////////
// The one and only CDon32App object

// Global functions for access from DataFlex:

UINT DFXAPI DON32_Version() {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To supply the current version of the library to the Donorflex base system:

    // Local Variables:

    // Code:
    return LIBVER;  // Define globally in Don32.h
}

void DFXAPI DON32_About() {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To show the Donorflex Gi About screen.

    // Local variables:

    // Code:
    // TODO
}

HIMAGELIST DFXAPI DON32_GetImageList(UINT uiWhich) {
    // Version: 1.0 01/05/1997

    // Purpose:
    // To return the handle of the standard image list.

    // Local variables:

    // Code:
    // TODO:

    // Returns:
    return NULL;
}

void DFXAPI DON32_AddBubbleMessage(LPCSTR lpszMsg, DWORD iFont) {
}

// InitBubble, resets the contents of the string arrays and font type,
// must be called before using the bubble routine.
void DFXAPI DON32_InitBubbleWindow(void) {
}

// Tip of the day support:

void DFXAPI DON32_TipAtStartup(void) {

}

void DFXAPI DON32_TipOfTheDay(void) {

}

// Progress Box Thread Control:

/*
Purpose / Description:
    This interface is historic and was imported from the original DON32 library

*/
void DFXAPI DON32_BeginProgressThread(HWND hWndParent, DWORD dwAnim, LPSTR lpsCaption, LPSTR lpsTitle, LPSTR lpsMsg, int iCancel) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsCaption, lpsTitle, lpsMsg, iCancel, RGB(0,0x65,0xFF)); // TODO replace this with proper default colour.
}

void DFXAPI DFX_SmallProgress(HWND hWndParent, DWORD dwAnim, LPSTR lpsTitle, LPSTR lpsMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsTitle, lpsMsg);
}

/*
Description:
    New interface as of 26/01/2004 by EN to facilitate setting of theme colours
    throughout the donorflex application.
*/
void DFXAPI DFX_Progress(HWND hWndParent, DWORD dwAnim, LPSTR lpsCaption, LPSTR lpsTitle, LPSTR lpsMsg, int iCancel, COLORREF gradientColour) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance(hWndParent, dwAnim, lpsCaption, lpsTitle, lpsMsg, iCancel, gradientColour);
}

void DFXAPI DON32_EndProgressThread(void) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;CloseInstance();
}

void DFXAPI DON32_ProgressSuspend(void) {
    // NOTE: This function is not implemeted in Donorflex.
}

// Progress Box Control:

void DFXAPI DON32_ProgressMsgA(LPSTR lpszMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;SetDialogMessageA(lpszMsg);
}

void DFXAPI DON32_ProgressMsgB(LPSTR lpszMsg) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;SetDialogMessageB(lpszMsg);
}

void DFXAPI DON32_ProgressMeter(int iLow, int iHigh) {
}

void DFXAPI DON32_ProgressSet(int iPos) {
}

void DFXAPI DON32_ProgressStep() {
}

DWORD DFXAPI DON32_QueryProgress(void) {
    DWORD dword = FALSE;
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) dword = (DWORD)instance-&gt;isCancelled();

    return dword;
}

void DFXAPI DON32_ProgressResume(void) {
    CDonProgressThread *instance = CDonProgressThread::GetInstance();

    if (instance) instance-&gt;ResetDialog();

}

void DFXAPI DON32_EnableSysTray(HWND hwndTarget) {
}

HWND DFXAPI DON32_ShowBubbleWindow(HWND hParent, DWORD bClose) {
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CCMAC32App

/////////////////////////////////////////////////////////////////////////////
// CCMAC32App construction


/////////////////////////////////////////////////////////////////////////////
// The one and only CCMAC32App object

// CCMAC32App theApp;

////////////////////////////
// Globals

int DFXAPI CMAC32_GetPassword(LPCSTR lpszTitle, LPCSTR lpszValue) {
    return 0;
}

int DFXAPI CMAC32_ChangePassword(LPCSTR lpszValue, LPSTR lpszNew) {
    return 0;
}

int DFXAPI CMAC32_Dialog(DWORD wRscId) {
    return 0;
}

int DFXAPI CMAC32_SysLog(DWORD wType) {
    return 0;
}

UINT DFXAPI CMAC32_Version(void) {

    return LIBVER;
}

// New interfaces for Donorflex 6 / 9:

void DFXAPI AMO_Begin(void)
{

    // TODO Needs reworking to fit 6.1 service process architecture
}


// NEW!! Introduced for revised who's logged in processing,
// returns nonzero on success.
BOOL DFXAPI AMO_SetDetails(LPCSTR lpUserId, LPCSTR lpDetails)
{
    //client::InstanceManagerClient c;

    return false; //c.RegisterInstance(::GetCurrentProcessId(), lpUserId, NULL, lpDetails);
}

char current_user_id[24];

BOOL DFXAPI AMO_SetUserId(LPCSTR userId)
{
    //AMO_SetDetails(userId, TEXT(""No Details specified""));
    //strncpy(current_user_id, userId, sizeof(current_user_id));

    return false;   // TODO
}

BOOL DFXAPI AMO_Workspace(LPCSTR lpWorkspace)
{
    // Overwrite the previous details against the current process id, based on the stored user name above.
    AMO_SetDetails(current_user_id, lpWorkspace);

    return false;   // TODO
}

BOOL DFXAPI AMO_NextMessage(LPSTR buffer)
{
    return false;   // TODO current indicates no more messages.
}

BOOL DFXAPI AMO_Broadcast(void)
{
    // TODO

    return false;
}

void DFXAPI CMS_Begin(HWND hwnd)
{

    return; // TODO
}

BOOL DFXAPI CMS_SendMessage(LPCSTR lpMsg)
{


    return false; // TODO
}

BOOL DFXAPI CMS_SendMessage2(LPCSTR lpMsg, LPCSTR lpUserName)
{
    // TODO: Support for user name passing.


    return false;
}

// MD5 interface:

BOOL DFXAPI MD5_Hash(LPCSTR lpSource, UINT nLength, LPSTR lpResult)
{
    CString result;
    LPTSTR lptResult;

    result = core::CMD5Checksum::GetMD5((BYTE*)lpSource, nLength);

    lptResult = result.LockBuffer();
    strcpy(lpResult, lptResult);
    result.UnlockBuffer();

    return FALSE;
}

BOOL DFXAPI UTL_CheckExclusive(LPCSTR sFilename)
{
    // Purpose
    // To determine whether or not a file can be open exclusively.

    // Returns:
    //  true if file can be accessed exclusively
    //  false if file cannot be accessed exclusively

    // Locals:
    CFile oFile;
    CFileException oFileException;
    BOOL bRetcode;

    // Code:
    bRetcode = oFile.Open(sFilename, CFile::modeRead|CFile::shareExclusive, &amp;oFileException);

    return bRetcode;
}

/*
Purpose / Description:
    This interface provides a means by which a dataflex window can be
    dynamically subclassed to provide a gradient fill mechanism suitable
    for all colours and gradients.

Arguments:
    hWnd    - a handle of a window to be dynamically subclassed.
    red, green, blue - the colour.
*/
BOOL DFXAPI DFX_SubclassGradient(HWND hWnd, COLORREF col)
{
    if (CWnd::FromHandlePermanent(hWnd)) return true;

    CGradientFillBox *wnd = new CGradientFillBox(col);

    BOOL ret = wnd-&gt;SubclassWindow(hWnd);

    if (!ret) delete wnd;

    return ret;
}

/*
General purpose window subclassing.
*/
BOOL DFXAPI DFX_Subclass(HWND hWnd, int type, LPVOID lpExtra) {

/*
    if (CWnd::FromHandlePermanent(hWnd)) return true;

    // TODO CGradientFillBox *wnd = new CGradientFillBox(col);

    BOOL ret = wnd-&gt;SubclassWindow(hWnd);

    if (!ret) delete wnd;
    return ret;
*/
    return false;
}

BOOL DFXAPI DFX_Unsubclass(HWND hWnd) {

    CWnd *wnd = CWnd::FromHandlePermanent(hWnd);
    if (!wnd) return false;

    wnd-&gt;UnsubclassWindow();

    return true;
}

/*
Purpose / Description:
    This is a general purpose interface for subclassing windows
    for any type. It should be used in preference to the DFX_SubclassGradient
    function.

Arguments:
*/

/*
Purpose / Description:
    This interface allows the dataflex system to notify the subclassed window
    that a change in window colour has occured.

Arguments:
    hWnd        - The handle of the window to take the notification
    COLORREF    - The color reference that should be used from now on.

*/
BOOL DFXAPI DFX_NotifyColourChange (HWND hWnd, COLORREF col) {

    CGradientFillBox *wnd;

    // Get the window class that is mapped to this
    wnd = DYNAMIC_DOWNCAST(CGradientFillBox, CWnd::FromHandlePermanent(hWnd));

    // If the window handle is null then return the error condition:
    ASSERT(wnd);
    if (!wnd) return true;

    // Now update the COLOREF value associated with the window class:
    wnd-&gt;SetTargetColour(col);

    return false;
}

BOOL DFXAPI DFX_GradientFillDirection(HWND hWnd, int direction) {
    CGradientFillBox *wnd;

    wnd = DYNAMIC_DOWNCAST(CGradientFillBox, CWnd::FromHandlePermanent(hWnd));
    ASSERT(wnd);
    if (!wnd) return true;

    wnd-&gt;SetFillDirection(direction);

    return false;
}

// Integer value that governs if thin client mode is active or not:
int operatingmode = OM_NORMAL;

/*
Description:
    This API provides a method of switching off the animation and colour
    used in the user interactive side of the DLL.

    This is required in order to reduce bandwidth required to operate
    version 6+ of donorflex.

Assumptions &amp; Pre-conditions:
    None

Arguments:
    mode        - Can either be 0 for standard or 1 for thin terminal services mode.
*/
int DFXAPI DFX_SetOperatingMode(int mode) {

    operatingmode = mode;

    return mode;
}

int DFXAPI DFX_GetOperatingMode() {
    return operatingmode;
}


int DFXAPI DFX_ShowSplashScreen(LPCSTR lpsFilename, COLORREF transparency, LPCSTR lpsRegName, LPCSTR lpsSerialNo, int regx, int regy, int serx, int sery)
{
    CPoint reg_point(regx, regy);
    CPoint ser_point(serx, sery);

    SplashScreenIdleThread::Show(lpsFilename, transparency, lpsRegName, lpsSerialNo, reg_point, ser_point);

    return 0;
}

int DFXAPI DFX_HideSplashScreen(HWND hwParent)
{
    SplashScreenIdleThread::Hide(hwParent);

    return 0;
}

// 13.04.2005: EN : New string encryption routine:

int DFXAPI DFX_EncryptString(const char * encoding, const char * instring, char * outstring, int outbuffsize, const char * passphrase)
{
    // Encrypts the given string buffer using the given passphrase and returns the output in the
    // buffer provided. Make sure that the size of the passed buffer is adequate.
    string ls;

    BufferedTransformation * encryptor = NULL;

    try {

        if (!strcmp(encoding, ""base64"")) encryptor = new DefaultEncryptorWithMAC(passphrase, new Base64Encoder(new StringSink(ls), false));
        if (!strcmp(encoding, ""hex"")) encryptor = new DefaultEncryptorWithMAC(passphrase, new HexEncoder(new StringSink(ls)));
        if (!strcmp(encoding, ""zlib"")) encryptor = new DefaultEncryptorWithMAC (passphrase, new ZlibCompressor(new StringSink(ls)));
        if (!strcmp(encoding, ""none"")) encryptor = new DefaultEncryptorWithMAC (passphrase, new StringSink(ls));

        encryptor-&gt;Put((byte *)instring, strlen(instring));
        encryptor-&gt;MessageEnd();
    }
    catch (...) {
        // Catch all errors
        ls = ""ERROR"";
    }

    // Cleanup:
    if (encryptor!=NULL) delete encryptor;

    // Copy returned string into the output buffer:
    strncpy(outstring, ls.c_str(), (size_t)outbuffsize);

    return ls.size();
}

int DFXAPI DFX_DecryptString(const char * encoding, const char * instring, char * outstring, int outbuffsize, const char * passphrase)
{
    string ls;

    BufferedTransformation * decryptor = NULL;

    try {

        if (!strcmp(encoding, ""base64"")) decryptor = new Base64Decoder(new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""hex"")) decryptor = new HexDecoder(new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""zlib"")) decryptor = new ZlibDecompressor (new DefaultDecryptorWithMAC(passphrase, new StringSink(ls)));
        if (!strcmp(encoding, ""none"")) decryptor = new DefaultDecryptorWithMAC(passphrase, new StringSink(ls));

        decryptor-&gt;Put((byte *)instring, strlen(instring));
        decryptor-&gt;MessageEnd();
    }
    catch (...) {
        // Stop any errors causing a complete mess.
        ls = ""ERROR"";
    }

    // Cleanup:
    if (decryptor != NULL) delete decryptor;

    // Copy returned string into the output buffer:
    strncpy(outstring, ls.c_str(), (size_t)outbuffsize);

    return ls.size();   // No error.
}
</code></pre>
","<p>You probably need to update Crypto++.</p>

<p>Lots of google hits on this: <a href=""https://www.google.co.uk/search?q=crypto%2B%2B+HuffManDecoder+compile+error&amp;oq=crypto%2B%2B+HuffManDecoder+compile+error&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8&amp;gws_rd=ssl"" rel=""nofollow"">https://www.google.co.uk/search?q=crypto%2B%2B+HuffManDecoder+compile+error&amp;oq=crypto%2B%2B+HuffManDecoder+compile+error&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8&amp;gws_rd=ssl</a></p>
","460","<c++><dll><crypto++><c2664>","0","2","2","2014-12-04 12:13:54","","0","","3173234","","2014-12-04 11:58:51","2014-12-04 10:29:01",""
"5921296","Decryption Memory Issue","<p>I've recently been making a server which uses AES256 to encrypt/decrypt data, it took awhile to get it to send correctly. However now I'm having an issue I believe is down to memory, if I send the word ""hello"" it'll decrypt fine, if I then send ""helloo"", it'll also decrypt fine, but if I send anything shorter than ""helloo"" after, it'll error during decryption and if you print the encrypted string it received it's got what it should have plus the additional length of the old string.</p>

<p>e.g</p>

<pre><code>hello:  ####################
helloo: ##############################
hi:     #####(#########################) //has the additional length made up from the encrypted string of ""helloo"" minus the first however many characters ""hi"" is
</code></pre>

<p>The code:</p>

<pre><code>std::string decryptString(std::string ciphertext, byte *key, byte *iv)
{
    std::string decodedtext;
    CryptoPP::StringSource(ciphertext, true, 
                           new CryptoPP::HexDecoder(new CryptoPP::StringSink(decodedtext)));

    std::string plaintext;

    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Decryption dec;
    dec.SetKeyWithIV((const byte *)key, CryptoPP::AES::MAX_KEYLENGTH, 
                     (const byte *)iv, CryptoPP::AES::BLOCKSIZE);

    CryptoPP::AuthenticatedDecryptionFilter adf(dec, new CryptoPP::StringSink(plaintext));

    adf.Put((const byte *)decodedtext.data(), decodedtext.size());
    adf.MessageEnd();

    return plaintext;
}
</code></pre>
","<p>Try using valgrind to find memory errors in your code.</p>

<p>Oh, and a tip: post the code itself, it might lead to more interesting answers.</p>
","457","<c++><crypto++>","1","1","2","2015-05-02 21:33:02","","5","0","608639","","2015-05-02 21:33:02","2011-05-07 13:13:37",""
"5921296","Decryption Memory Issue","<p>I've recently been making a server which uses AES256 to encrypt/decrypt data, it took awhile to get it to send correctly. However now I'm having an issue I believe is down to memory, if I send the word ""hello"" it'll decrypt fine, if I then send ""helloo"", it'll also decrypt fine, but if I send anything shorter than ""helloo"" after, it'll error during decryption and if you print the encrypted string it received it's got what it should have plus the additional length of the old string.</p>

<p>e.g</p>

<pre><code>hello:  ####################
helloo: ##############################
hi:     #####(#########################) //has the additional length made up from the encrypted string of ""helloo"" minus the first however many characters ""hi"" is
</code></pre>

<p>The code:</p>

<pre><code>std::string decryptString(std::string ciphertext, byte *key, byte *iv)
{
    std::string decodedtext;
    CryptoPP::StringSource(ciphertext, true, 
                           new CryptoPP::HexDecoder(new CryptoPP::StringSink(decodedtext)));

    std::string plaintext;

    CryptoPP::GCM&lt;CryptoPP::AES&gt;::Decryption dec;
    dec.SetKeyWithIV((const byte *)key, CryptoPP::AES::MAX_KEYLENGTH, 
                     (const byte *)iv, CryptoPP::AES::BLOCKSIZE);

    CryptoPP::AuthenticatedDecryptionFilter adf(dec, new CryptoPP::StringSink(plaintext));

    adf.Put((const byte *)decodedtext.data(), decodedtext.size());
    adf.MessageEnd();

    return plaintext;
}
</code></pre>
","<p>If you always pass the same initialization vector to this method, may be the reason is in it. Try</p>

<pre><code>dec.Resynchronize(iv);
</code></pre>
","457","<c++><crypto++>","1","0","2","2015-05-02 21:33:02","","5","0","608639","","2015-05-02 21:33:02","2011-05-07 13:13:37",""
"26503146","How can I find the add round key and mix column codes in AES of the crypto++ library","<p>I am new in C++  code, I try to open the AES code in the crypt++ library for add round key and mix column but I do not know how to access them
Any one help me please
Thanks</p>
","<p>I think it is not easy to find the internal code of AES rounds, </p>
","453","<c++><c><eclipse><aes><crypto++>","0","-1","2","2014-10-22 10:13:06","","3","1","","","","2014-10-22 08:24:41","2014-11-10 19:34:35"
"26503146","How can I find the add round key and mix column codes in AES of the crypto++ library","<p>I am new in C++  code, I try to open the AES code in the crypt++ library for add round key and mix column but I do not know how to access them
Any one help me please
Thanks</p>
","<p>The AES implementation is in <a href=""http://sourceforge.net/p/cryptopp/code/HEAD/tree/trunk/c5/rijndael.cpp"" rel=""nofollow"">rijndael.cpp</a>. You asked for the sbox, add round key and mix operations; they're all in the QUARTER_ROUND macros:</p>

<ul>
<li><code>QUARTER_ROUND_FE</code> - the first encryption round</li>
<li><code>QUARTER_ROUND_E</code> - subsequent encryption rounds</li>
<li><code>QUARTER_ROUND_LE</code> - the last encryption round</li>
</ul>

<p>and equivalent decryption macros ending in <code>D</code> not <code>E</code>. These are defined as</p>

<pre><code>#define QUARTER_ROUND(L, T, t, a, b, c, d)  \
    a ^= L(T, 3, byte(t)); t &gt;&gt;= 8;\
    b ^= L(T, 2, byte(t)); t &gt;&gt;= 8;\
    c ^= L(T, 1, byte(t)); t &gt;&gt;= 8;\
    d ^= L(T, 0, t);

#define TL_M(T, i, x) (*(word32 *)((byte *)T + x*8 + (i+3)%4+1))
#define QUARTER_ROUND_E(t, a, b, c, d)      QUARTER_ROUND(TL_M, Te, t, a, b, c, d)
</code></pre>

<p>where</p>

<ul>
<li><code>TL_M</code> is the mixing macro</li>
<li><code>Te</code> is the encryption S-box</li>
<li><code>t</code> is a 32-bit portion of the key</li>
<li><code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> are 32-bit portions of the current block</li>
</ul>
","453","<c++><c><eclipse><aes><crypto++>","0","1","2","2014-10-22 10:13:06","","3","1","","","","2014-10-22 08:24:41","2014-11-10 19:34:35"
"25070949","cryptopp plaintext fixed length limit","<p>When i pass <code>initialText86</code>, the code below works as it should. When i pass <code>initialText87</code> it fails to construct <code>StringSource ss1</code>, and we meet exception <code>invalid argument</code>!</p>

<p>How can i encode string with length 87?</p>

<pre><code>#include &lt;string&gt;
#include &lt;new&gt;

using namespace std;

#include &lt;../pub/cryptopp/rsa.h&gt;
#include &lt;../pub/cryptopp/osrng.h&gt;
#include &lt;../pub/cryptopp/oaep.h&gt;
#include &lt;../pub/cryptopp/sha.h&gt;

using namespace CryptoPP;

AutoSeededRandomPool&amp; rng_get() {
    static AutoSeededRandomPool defRng;
    return defRng;
}

string rsa_encode( const string&amp; plainText, const RSA::PublicKey&amp; pubKey ) {
    RSAES_OAEP_SHA_Encryptor rsaEnc( pubKey );
    string cipherText;
    StringSource ss1( reinterpret_cast&lt; const byte* &gt;( plainText.c_str() ), plainText.size(), true,
        new PK_EncryptorFilter( rng_get(), rsaEnc,
            new StringSink( cipherText )
        ) // PK_EncryptorFilter
    ); // StringSource
    return move( cipherText );
}

string rsa_decode( const string&amp; cipherText, const RSA::PrivateKey&amp; secretKey ) {
    RSAES_OAEP_SHA_Decryptor rsaDec( secretKey );
    string plainText;
    StringSource ss2( reinterpret_cast&lt; const byte* &gt;( cipherText.c_str() ), cipherText.size(), true,
        new PK_DecryptorFilter( rng_get(), rsaDec,
            new StringSink( plainText )
        ) // PK_DecryptorFilter
    ); // StringSource
    return move( plainText );
}

static const size_t keyLength = 1024;
RSA::PrivateKey _secretKey;
RSA::PublicKey  _pubKey;

bool test( const string&amp; initialText ) {
    auto cipherText = rsa_encode( initialText, _pubKey );
    auto plainText = rsa_decode( cipherText, _secretKey );
    return plainText == initialText;
}

int main() {
    _secretKey.GenerateRandomWithKeySize(rng_get(), keyLength );
    new( &amp;_pubKey ) RSA::PublicKey( _secretKey );
    string initialText87 = ""111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"";
    string initialText86 = ""11111111111111111111111111111111111111111111111111111111111111111111111111111111111111"";
    auto testResult = test( initialText87 );
    assert( testResult );
    return testResult ? 0 : -1;
}
</code></pre>
","<p>The length of data that can be encrypted using RSA is determined primarily by the size of the key you're using. You appear to be using OAEP, so the maximum length is:</p>

<pre><code>keyLength - 2 - 2 * hashLength
</code></pre>

<p>Where <code>keyLength</code> is the length of the RSA modulus in bytes. You're using a 1024 bit key so:</p>

<pre><code>keyLength = 1024 / 8 = 128
</code></pre>

<p>And since you're using OAEP with SHA-1</p>

<pre><code>hashLength = 20
</code></pre>

<p>So the maximum you can encrypt is:</p>

<pre><code>128 - 2 - 2 * 20 = 86
</code></pre>

<p>Which is exactly what your example shows.</p>

<p>To encrypt more data, you <em>could</em> use a larger RSA key, but RSA really shouldn't be used for encrypting large amounts of data, so is usually used as part of a hybrid cryptosystem where RSA is instead used to encrypt a randomly generated key for a symmetric algorithm like AES, and then the symmetric algorithm is used to encrypt the actual data so avoiding the length limits associated with RSA.</p>
","440","<exception><rsa><crypto++>","0","1","1","2014-08-04 01:20:16","25087592","0","","608639","","2014-08-04 01:20:16","2014-08-01 00:11:59",""
"42400956","How can I do XOR operation in Crypto++?","<p>I want to perform XOR operation in AES before and after encryption in AES (like DESX) with new keys. But XOR operation takes too much time.</p>

<p>How can I reduce the XOR operation time?</p>

<p>Here is my code:</p>

<pre><code>string XOR(string value, string key)
{
    string retval(value);

    short unsigned int klen=key.length();
    short unsigned int vlen=value.length();
    short unsigned int k=0;
    short unsigned int v=0;

    for(v;v&lt;vlen;v++)
    {
        retval[v]=value[v]^key[k];
        k=(++k&lt;klen?k:0);
    }

    return retval;
}

int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    byte key1[AES::DEFAULT_KEYLENGTH];
    prng.GenerateBlock(key1, sizeof(key1));

    byte key[AES::DEFAULT_KEYLENGTH];
    prng.GenerateBlock(key, sizeof(key));

    byte key2[AES::DEFAULT_KEYLENGTH];
    prng.GenerateBlock(key2, sizeof(key2));

    byte iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));

    string plain = ""AESX CBC Mode Test"";
    string cipher,encoded, encodediv, encodedkey1, encodedkey, 
    encodedkey2, recovered, prerecovered, postrecovered, 
    prewhiten, postwhiten;

    // Pretty print key1
    StringSource(key1, sizeof(key1), true,
        new HexEncoder(
            new StringSink(encodedkey1)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""key1: "" &lt;&lt; encodedkey1 &lt;&lt; endl;

    // Pretty print iv
    StringSource(iv, sizeof(iv), true,
        new HexEncoder(
            new StringSink(encodediv)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""iv: "" &lt;&lt; encodediv &lt;&lt; endl;

    // Pretty print key
    StringSource(key, sizeof(key), true,
        new HexEncoder(
            new StringSink(encodedkey)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""key: "" &lt;&lt; encodedkey &lt;&lt; endl;

    // Pretty print key2
    StringSource(key2, sizeof(key2), true,
        new HexEncoder(
            new StringSink(encodedkey2)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""key2: "" &lt;&lt; encodedkey2 &lt;&lt; endl;

    cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

    prewhiten = XOR(plain, encodedkey1);

    try
    {
        cout &lt;&lt; ""pre whiten text: "" &lt;&lt; prewhiten &lt;&lt; endl;

        CBC_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeof(key), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(prewhiten, true, 
            new StreamTransformationFilter(e,
                new StringSink(cipher)
            ) // StreamTransformationFilter
        ); // StringSource

    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/

    // Pretty print
    encoded.clear();
    StringSource(cipher, true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource
    cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

    postwhiten = XOR(encoded, encodedkey2);

    cout &lt;&lt; ""post whiten text: "" &lt;&lt; postwhiten &lt;&lt; endl;

    //decryption

    prerecovered = XOR(postwhiten, encodedkey2);

    encoded.clear();
    StringSource(prerecovered, true,
        new HexEncoder(
            new StringSink(encoded)
        ) // HexEncoder
    ); // StringSource

    cout &lt;&lt; ""pre recovered text: "" &lt;&lt; encoded &lt;&lt; endl;

    try
    {
        CBC_Mode&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, sizeof(key), iv);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(prerecovered, true, 
            new HexDecoder(
                new StreamTransformationFilter(d,
                    new StringSink(recovered)
                ) // StreamTransformationFilter
            )//HexDecoder
        ); // StringSource

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    postrecovered = XOR(recovered, encodedkey1);

    cout &lt;&lt; ""post recovered text: "" &lt;&lt; postrecovered &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Any help would be appreciated.</p>
","<blockquote>
  <p>How can I do XOR operation in Crypto++?</p>
</blockquote>

<p>There are two ways to use the library to perform an XOR. First, there are two  functions <a href=""https://github.com/weidai11/cryptopp/blob/master/misc.cpp#L28"" rel=""nofollow noreferrer""><code>xorbuf</code></a> in <code>misc.h</code>. The first implementation is shown below, and it uses a single in/out buffer with a mask:</p>

<pre><code>void xorbuf(byte *buf, const byte *mask, size_t count)
{
    size_t i=0;
    if (IsAligned&lt;word32&gt;(buf) &amp;&amp; IsAligned&lt;word32&gt;(mask))
    {
        if (!CRYPTOPP_BOOL_SLOW_WORD64 &amp;&amp; IsAligned&lt;word64&gt;(buf) &amp;&amp; IsAligned&lt;word64&gt;(mask))
        {
            for (i=0; i&lt;count/8; i++)
                ((word64*)(void*)buf)[i] ^= ((word64*)(void*)mask)[i];
            count -= 8*i;
            if (!count)
                return;
            buf += 8*i;
            mask += 8*i;
        }

        for (i=0; i&lt;count/4; i++)
            ((word32*)(void*)buf)[i] ^= ((word32*)(void*)mask)[i];
        count -= 4*i;
        if (!count)
            return;
        buf += 4*i;
        mask += 4*i;
    }

    for (i=0; i&lt;count; i++)
        buf[i] ^= mask[i];
}
</code></pre>

<p>There's a second <code>xorbuf(byte *output, const byte *input, const byte *mask, size_t count)</code> that uses separate in and out buffers with a mask.</p>

<p>The second way to XOR is use an <code>ArrayXorSink</code> from <a href=""https://github.com/weidai11/cryptopp/blob/master/filters.cpp#L565"" rel=""nofollow noreferrer""><code>filters.h</code></a>. Internally, <code>ArrayXorSink</code> calls <code>xorbuf</code> for you. You would use this is you prefer <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">pipelines</a>.</p>

<pre><code>size_t ArrayXorSink::Put2(const byte *begin, size_t length, int messageEnd, bool blocking)
{
    // Avoid passing NULL pointer to xorbuf
    size_t copied = 0;
    if (m_buf &amp;&amp; begin)
    {
        copied = STDMIN(length, SaturatingSubtract(m_size, m_total));
        xorbuf(m_buf+m_total, begin, copied);
    }
    m_total += copied;
    return length - copied;
}
</code></pre>

<hr>

<blockquote>
<pre><code>string XOR(string value, string key)
{
    string retval(value);

    short unsigned int klen=key.length();
    short unsigned int vlen=value.length();
    short unsigned int k=0;
    short unsigned int v=0;

    for(v;v&lt;vlen;v++)
    {
        retval[v]=value[v]^key[k];
        k=(++k&lt;klen?k:0);
    }

    return retval;
}
</code></pre>
</blockquote>

<p>For this, you could do something like the following. It asks the compiler to <code>inline</code> the function, and it passes the <code>value</code> and <code>key</code> by constant reference to avoid the copies.</p>

<pre><code>inline string XOR(const string&amp; value, const string&amp; key)
{
    ASSERT(key.length() == value.length());

    string retval(value);
    xorbuf(&amp;retval[0], &amp;key[0], retval.length());
    return retval; 
}
</code></pre>

<p>The trick is, you have to take the address of element 0 to get the non-const pointer and avoid potential undefined behavior. You may need to cast to a <code>byte*</code>.</p>

<hr>

<blockquote>
  <p>How can I reduce the XOR operation time?</p>
</blockquote>

<p>You probably want to use an operand size larger that 1-byte when its feasible. The library's <code>xorbuf</code> uses <code>word32</code> and <code>word64</code> when available. </p>

<p>In addition, if you have AVX, then you can operate on buffers up to 512-bit. If you keep your buffers aligned, then GCC will try use the larger buffers at <code>-O3</code> and above. <code>-O3</code> is significant because that's when GCC starts aggressive vectorization and using features provided by AVX and AVX2.</p>

<p>The Crypto++ library endured a non-trivial amount of pain a couple of years ago because its buffers were not aligned as GCC expected, and it was causing SEGFAULT's <code>-O3</code> and above. See, for example, <a href=""https://groups.google.com/d/msg/cryptopp-users/AUKPXDduHww/lk0AE9fAVKcJ"" rel=""nofollow noreferrer"">Crash on Cygwin i386 with -O3</a>.</p>

<p>The alignment problem was not limited to Cygwin; Cygwin happened to demonstrate it. The problem surfaced on occasion under other platforms and CPUs, like ARM when NEON was enabled. We believe all the issues have been cleared.</p>
","439","<c++><encryption><aes><xor><crypto++>","0","0","1","2017-02-25 00:03:34","42406615","2","","608639","","2017-02-23 16:26:02","2017-02-22 19:51:22",""
"8480143","RSA decrypting Crypto++ generated message in PHP","<p>I have generated a public/private keypair with Crypto++, and I encode a password on the client side with Crypto++ (RSAES_OAEP_SHA_Encryptor), then I base64 encode it. Now I'd like to decode it in the server side PHP script (via phpseclib). Private key is on the format ""MIIEuwIBADANBgkqhkiG9w0BAQ...."" (no breaks), then I format it like:</p>

<pre><code>static $BEGIN_MARKER = ""-----BEGIN RSA PRIVATE KEY-----"";
static $END_MARKER = ""-----END RSA PRIVATE KEY-----"";
$pem = $BEGIN_MARKER . ""\n"";
$pem .= chunk_split($key, 64, ""\n"");
$pem .= $END_MARKER . ""\n"";
</code></pre>

<p>before loading it with:</p>

<pre><code>$rsa-&gt;loadKey($pem,CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
</code></pre>

<p>which seems to work. But decoding the message via:</p>

<pre><code>$rsa-&gt;setEncryptionMode(CRYPT_RSA_ENCRYPTION_OAEP);
$plaintext = $rsa-&gt;decrypt(base64_decode($input));
</code></pre>

<p>yields just an empty string. No errors are given. </p>

<p>I have a similar ASP.Net C# handler that can decode the message without problems...</p>

<p>Any ideas ?</p>
","<p>I was using 0.2.2 distribution of phpseclib, then I tried the SVN head of phpseclib, and it works perfectly :)</p>
","431","<php><rsa><crypto++>","1","1","1","2011-12-13 06:36:00","8484884","0","1","255635","","2011-12-12 20:26:32","2011-12-12 20:02:58",""
"39350337","Saving Crypto++ objects to std::vector","<p>I want to save Crypto++ keys to <code>std::vector&lt;uint8_t&gt;</code>. Unfortunately there is only <code>CryptoPP::StringSink</code>, that takes <code>std::string</code> reference but no <code>CryptoPP::VectorSink</code> that would take a reference to <code>std::vector</code>.</p>

<p><strong>Following code works fine</strong></p>

<pre><code>std::string spki;
CryptoPP::StringSink ss(spki);

CryptoPP::RSA::PublicKey publicKey(...);
publicKey.Save(ss);
</code></pre>

<p><strong>But I want this</strong></p>

<pre><code>std::vector&lt;uint8_t&gt; spki;
CryptoPP::VectorSink vs(spki);

CryptoPP::RSA::PublicKey publicKey(...);
publicKey.Save(vs);
</code></pre>

<p><strong>The problem</strong></p>

<p><code>VectorSink</code> can not be created just by using a typedef because of  <code>traits_type::char_type</code> inside <code>StringSinkTemplate</code>:</p>

<pre><code>using CryptoPP::StringSinkTemplate;
typedef StringSinkTemplate&lt; std::vector&lt;byte&gt; &gt; VectorSink;

In file included from cryptopp-test.cpp:65:
In file included from /usr/local/include/cryptopp/files.h:5:
/usr/local/include/cryptopp/filters.h:590:22: error: no member named
      'traits_type' in 'std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt;
      &gt;'
        typedef typename T::traits_type::char_type char_type;
                         ~~~^
cryptopp-test.cpp:243:20: note: in instantiation of template class
      'CryptoPP::StringSinkTemplate&lt;std::vector&lt;unsigned char,
      std::allocator&lt;unsigned char&gt; &gt; &gt;' requested here
        VectorSink vs(spki);
</code></pre>

<p>How can I create a <code>VectorSink</code>?</p>
","<p><strong>Working implementation of VectorSink</strong></p>

<pre><code>// Written and placed in the public domain by rrmmnn
// Copyright assigned to the Crypto++ project.

namespace CryptoPP {

class VectorSink : public Bufferless&lt;Sink&gt; {
public:

  VectorSink(std::vector&lt;uint8_t&gt;&amp; out)
    : _out(&amp;out) {
  }

  size_t Put2(const byte *inString, size_t length, int /*messageEnd*/, bool /*blocking*/) {
    _out-&gt;insert(_out-&gt;end(), inString, inString + length);
    return 0;
  }

private:  
  std::vector&lt;uint8_t&gt;* _out;
};

}
</code></pre>
","428","<c++><stdvector><crypto++>","2","4","1","2016-09-11 17:07:02","39350338","5","","608639","","2016-09-06 14:02:09","2016-09-06 13:32:42",""
"28546166","How to recompile Crypto++ with GCC-4.8?","<p>My question is how can I recompile Crypto++ with GCC-4.8 in FreeBSD 9.2?</p>

<p>I'm having the following error, and I noticed that recompiling CrypTopp would solve the problem.</p>

<pre><code>undefined reference to `CryptoPP::AlignedDeallocate(void*)'
</code></pre>

<p>Thanks!</p>
","<blockquote>
  <p>My question is how can I recompile Crypto++ with GCC-4.8 in FreeBSD 9.2?</p>
</blockquote>

<p>There's usually 3 or 4  things to be mindful of with later versions of GCC and the BSDs. They are enumerated below. If you have a specific problem, then you should ask.</p>

<h2>-----</h2>

<p>First, install <code>gmake</code> and use it instead of the BSD's anemic <code>make</code>. So you would compile with something like:</p>

<pre><code>cd cryptopp
gmake GNUmakefile
</code></pre>

<p>I think other dependencies include <code>gettext</code> and <code>libiconv</code>.</p>

<h2>-----</h2>

<p>Second, the Crypto++ makefile sometimes blows away your choice of <code>CXX</code> and maybe <code>LD</code>. Open the <code>GNUmakefile</code> and hard code them to want you want if its occurring.</p>

<h2>-----</h2>

<p>Third, Crypto++ has some bug fixes for dependent name lookups. This only affects later versions of GCC, like 4.7 or 4.8 and above. See, for example, <a href=""https://stackoverflow.com/q/26963303/608639"">Unable to make on MingW due to unrecognized option</a>.</p>

<p>So you should be using Crypto++ from SVN, and <strong><em>not</em></strong> the ZIP file from the website. See <a href=""http://www.cryptopp.com/wiki/SVN"" rel=""nofollow noreferrer"">SVN</a> on the Crypto++ wiki on how to check it out.</p>

<h2>-----</h2>

<p>Fourth, install Crypto++ into <code>/usr/local</code>, and not <code>/usr</code>. For some reason, one of the BSDs (OpenBSD) treat everything in <code>/usr/include</code> as a C file, and does not honor a C++ file. It will lead to unexplained compile failures. You can read about it on the Crypto++ wiki: <a href=""http://www.cryptopp.com/wiki/Linux#OpenBSD"" rel=""nofollow noreferrer"">Linux and OpenBSD</a>.</p>

<p>So your install would look like:</p>

<pre><code>sudo gmake install PREFIX=/usr/local
</code></pre>

<h2>-----</h2>

<p>There should also be a port available. You should try and use it if its available. For example its available as <a href=""https://svnweb.freebsd.org/ports/head/security/cryptopp/"" rel=""nofollow noreferrer"">cryptopp-5.6.3-2</a> under FreeBSD. OpenBSD has a patch at <a href=""http://openbsd.7691.n7.nabble.com/fix-net-synergy-td228522.html"" rel=""nofollow noreferrer"">Fix: net/synergy</a>, so its probably available in their ports tree, too.</p>

<h2>-----</h2>

<p>Finally, there is a Crypto++ wiki page covering Linux and the BSDs at <a href=""http://www.cryptopp.com/wiki/Linux"" rel=""nofollow noreferrer"">Linux and BSD</a>. Its basically everything I know about building and running Crypto++ on *nix variants. If you are a die hard BSD guy, then my apologies for lumping Linux and BSD together on one page.</p>
","426","<compilation><freebsd><crypto++>","1","0","1","2015-02-16 19:48:07","","0","","608639","","2015-02-16 19:32:19","2015-02-16 16:38:21",""
"24364308","CryptoPP: how to use SocketSource and SocketSink","<p>I'm trying to send a string via SocketSource and SocketSink. But somehow it won't work properly. I simply want to send it from my server to the client. Here's the code:</p>

<p>Server:</p>

<pre><code>    CryptoPP::Socket server;
    CryptoPP::Socket client;
    sockaddr_in client_sadr;
    CryptoPP::socklen_t size_sock = sizeof(sockaddr_in);
    timeval timev = {3, 0};
    std::string test(""a simple test"");

    CryptoPP::Socket::StartSockets();

    server.Create(SOCK_STREAM);
    server.Bind(4213, NULL);
    server.Listen();

    server.Accept(client, (sockaddr*)&amp;client_sadr, &amp;size_sock);

    std::cout &lt;&lt; ""Client connected"" &lt;&lt; std::endl;

    while (!client.SendReady(&amp;timev));
    CryptoPP::StringSource ss(test, true, new CryptoPP::SocketSink(client));

    std::cout &lt;&lt; ""Data sent"" &lt;&lt; std::endl;

    std::cin.ignore();

    client.CloseSocket();
    server.CloseSocket();

    CryptoPP::Socket::ShutdownSockets();
</code></pre>

<p>Client:</p>

<pre><code>    CryptoPP::Socket client;
    CryptoPP::socklen_t size_sock = sizeof(sockaddr_in);
    timeval timev = {3, 0};
    std::string test;

    Socket::StartSockets();

    client.Create(SOCK_STREAM);
    client.Connect(""127.0.0.1"", 4213);

    std::cout &lt;&lt; ""connected"" &lt;&lt; std::endl;

    while (!client.ReceiveReady(&amp;timev));
    CryptoPP::SocketSource(client, true, new StringSink(test));

    std::cout &lt;&lt; test &lt;&lt; std::endl;

    std::cin.ignore();

    client.CloseSocket();
    Socket::ShutdownSockets();
</code></pre>

<p>What happens now: The connection is established as wished, and the server sends the data, the client receives it and waits at cin.ignore(). But the server seemes to hang up while sending, because it won't print ""Data send"". It only does this, when the client closes the connection.
My question now is, am I doing something wrong, or is this just the normal behavior of SocketSource and SocketSink and i have to reconnect everytime...</p>

<p>Thanks for your help :)</p>
","<p>The following is from <code>test.cpp</code>. It might give you some ideas. I don't recall reading on how to use them (and I've never used them in a program). Its the only place I've ever seen <code>PumpAll2</code> and non-blocking used.</p>

<p>You might find they work better on Windows than Linux.</p>

<pre><code>void ForwardTcpPort(const char *sourcePortName, const char *destinationHost,
        const char *destinationPortName)
{
    SocketsInitializer sockInit;

    Socket sockListen, sockSource, sockDestination;

    int sourcePort = Socket::PortNameToNumber(sourcePortName);
    int destinationPort = Socket::PortNameToNumber(destinationPortName);

    sockListen.Create();
    sockListen.Bind(sourcePort);
    setsockopt(sockListen, IPPROTO_TCP, TCP_NODELAY, ""\x01"", 1);

    cout &lt;&lt; ""Listing on port "" &lt;&lt; sourcePort &lt;&lt; "".\n"";
    sockListen.Listen();

    sockListen.Accept(sockSource);
    cout &lt;&lt; ""Connection accepted on port "" &lt;&lt; sourcePort &lt;&lt; "".\n"";
    sockListen.CloseSocket();

    cout &lt;&lt; ""Making connection to "" &lt;&lt; destinationHost &lt;&lt; "", port "" &lt;&lt; destinationPort &lt;&lt; "".\n"";
    sockDestination.Create();
    sockDestination.Connect(destinationHost, destinationPort);

    cout &lt;&lt; ""Connection made to "" &lt;&lt; destinationHost &lt;&lt; "", starting to forward.\n"";

    SocketSource out(sockSource, false, new SocketSink(sockDestination));
    SocketSource in(sockDestination, false, new SocketSink(sockSource));

    WaitObjectContainer waitObjects;

    while (!(in.SourceExhausted() &amp;&amp; out.SourceExhausted()))
    {
        waitObjects.Clear();

        out.GetWaitObjects(waitObjects, CallStack(""ForwardTcpPort - out"", NULL));
        in.GetWaitObjects(waitObjects, CallStack(""ForwardTcpPort - in"", NULL));

        waitObjects.Wait(INFINITE_TIME);

        if (!out.SourceExhausted())
        {
            cout &lt;&lt; ""o"" &lt;&lt; flush;
            out.PumpAll2(false);
            if (out.SourceExhausted())
                cout &lt;&lt; ""EOF received on source socket.\n"";
        }

        if (!in.SourceExhausted())
        {
            cout &lt;&lt; ""i"" &lt;&lt; flush;
            in.PumpAll2(false);
            if (in.SourceExhausted())
                cout &lt;&lt; ""EOF received on destination socket.\n"";
        }
    }
}
</code></pre>
","425","<c++><windows><sockets><crypto++>","1","1","1","2014-06-23 16:26:46","24370550","0","","","","","2014-06-23 11:05:13",""
"28570666","Differences in functionalities provided by OpenSSL and Crypto++","<p>I am wondering if there are any functionalities that are explicitly provided in openssl but not in crypto++, or vice versa.</p>

<p>I am trying to write a unified interface to both the libraries so that I can switch between using an underlying crypto library without modifying my calling source code. At this point, I want to figure out if there is anything substantial that can only be done in one of those libraries. I know that the basic hashing, encryption and signing functionalities are provided in both.</p>

<p>Any comments or points of wisdom will be appreciated. Thanks.</p>
","<blockquote>
  <p>I am wondering if there are any functionalities that are explicitly provided in openssl but not in crypto++, or vice versa.</p>
</blockquote>

<p>Yes, there are lots of differences between them.</p>

<p>OpenSSL is more similar to Peter Gutmann's <a href=""https://www.cs.auckland.ac.nz/~pgut001/cryptlib/"" rel=""nofollow"">Cryptlib</a> and GNU's <a href=""http://www.gnutls.org/"" rel=""nofollow"">GnuTLS</a>. Perhaps even Jack Lloyd's <a href=""http://botan.randombit.net/"" rel=""nofollow"">Botan</a>. I don't think OpenSSL and Crypto++ is a good comparison.</p>

<p>Crypto++ provides more low level cryptographic primitives. Crypto++ provides nothing related to TLS and DTLS. Crypto++ is like a low level cryptographic Swiss army knife.</p>

<p>OpenSSL provides some low level cryptographic primitives, support for hardware modules, and working TLS and DTLS implementations. Because it supports hardware, it provides a PKCS 11 interface. Because it supports TLS and DTLS, it has richer socket support and an X509 parser.</p>

<p>There are many other similarities and differences. If you want to know a specific similarity or difference, then you need to ask about a specific feature.</p>

<hr>

<p>You might also want to look at the OpenSSL wiki's <a href=""https://wiki.openssl.org/index.php/Related_Links"" rel=""nofollow"">Related Links</a> page. It lists other, similar libraries.</p>
","425","<api><interface><openssl><crypto++>","0","1","1","2015-02-18 01:30:28","","0","1","608639","","2015-02-18 01:30:28","2015-02-17 20:36:06",""
"12334165","Compile cryptopp using Visual C++ 2010 Express","<p>I need to compile cryptopp (32-bit) using Visual C++ 2010 express. I downloaded the 5.6.1 version, opened the crypttest.sln, VS required to do some conversion - which failed. The *.vcproj files have x64 platform specified in them which - somehow - fails. I tried to tweak the .vcproj files and remove the x64, but it staill fails on some strange error:</p>

<pre><code>This application has been updated to include settings related to the User Account Control 
(UAC) feature of Windows Vista. By default, when run on Windows Vista with UAC enabled, this 
application is marked to run with the same privileges as the process that launched it.     This
 marking also disables the application from running with virtualization. You can change
UAC related settings from the Property Pages of the project
</code></pre>

<p>I need to compile the static library in some different mode (need to link it to a different dll), but I somehow cannot find out how to even load it into the Visual Studio. </p>
","<p>That problem has been around for a while. See, for example, <a href=""http://blogs.msdn.com/b/djpark/archive/2007/11/07/how-to-use-solutions-and-projects-between-visual-studio-2005-and-2008.aspx"" rel=""nofollow noreferrer"">How to use solutions and projects between Visual Studio 2005 and 2008</a> from the MSDN blogs.</p>

<p>You can change it from the Project's property page. See <a href=""http://msdn.microsoft.com/en-us/library/bb384691.aspx"" rel=""nofollow noreferrer"">/MANIFESTUAC</a> on MSDN.</p>

<p><img src=""https://i.stack.imgur.com/dXvsz.png"" alt=""UAC Property Page""></p>

<p>You can also open the <code>*.proj</code> file (or <code>*.projx</code> file) and remove it by hand. Just look for the offending line number; or search for <code>EnableUAC</code> (and friends) under the <code>Link</code> node in the XML. There might be four different entries - one each for <code>Debug</code> and <code>Release</code>, and one each for <code>x86</code> and <code>x64</code>.</p>

<p><img src=""https://i.stack.imgur.com/qOplH.png"" alt=""UAC PROJX file Link Node""></p>
","425","<compilation><crypto++>","0","0","1","2013-10-09 02:29:59","","2","0","","","","2012-09-08 20:24:08",""
"41800218","How to convert base64 to Integer in Crypto++?","<p>I use Crypto++ library. I have a base64 string saved as CString. I want to convert my string to Integer. actually this base64 built from an Integer and now i want to convert to Integer again.but two Integer not equal.in the other words second Integer not equal with original Integer.</p>

<pre><code>Base64Decoder bd;
CT2CA s(c);
std::string strStd(s);

bd.Put((byte*)strStd.data(), strStd.size());
bd.MessageEnd();

word64 size = bd.MaxRetrievable();
vector&lt;byte&gt; cypherVector(size);

string decoded;
if (size &amp;&amp; size &lt;= SIZE_MAX)
{
    decoded.resize(size);
    bd.Get((byte*)decoded.data(), decoded.size());
}

Integer cipherMessage((byte*)decoded.data(), decoded.size());
</code></pre>
","<blockquote>
<pre><code>string decoded;
if (size &amp;&amp; size &lt;= SIZE_MAX)
{
    decoded.resize(size);
    bd.Get((byte*)decoded.data(), decoded.size());
}
</code></pre>
</blockquote>

<p>You have a string called <code>decoded</code>, but you never actually decode the data by running it through a <a href=""https://www.cryptopp.com/wiki/Base64Decoder"" rel=""nofollow noreferrer""><code>Base64Decoder</code></a>.</p>

<p>Use something like the following. I don't have a MFC project handy to test, so I'm going to assume you converted the <code>CString</code> to a <code>std::string</code>.</p>

<pre><code>// Converted from Unicode CString
std::string str;

StringSource source(str, true, new Base64Decoder);
Integer value(val, source.MaxRetrievable());
std::cout &lt;&lt; std::hex &lt;&lt; value &lt;&lt; std::endl;
</code></pre>

<p>The <code>StringSource</code> is a <code>BufferedTransformation</code>. The <code>Integer</code> constructor <a href=""https://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow noreferrer"">you are using is</a>:</p>

<pre><code>Integer (BufferedTransformation &amp;bt, size_t byteCount, Signedness sign=UNSIGNED, ByteOrder order=BIG_ENDIAN_ORDER)
</code></pre>

<p>In between the <code>StringSource</code> and the <code>Integer</code> is the <code>Base64Decoder</code>. its a filter that decodes the string on the fly. So data flows from the source (<code>StringSource</code>) to the sink (<code>Integer</code> constructor).</p>

<p>Also see <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipelines</a> on the Crypto++ wiki.</p>
","409","<c++><base64><crypto++><bigint>","2","0","1","2017-01-26 13:52:54","","1","","608639","","2017-01-26 13:48:57","2017-01-23 06:11:43",""
"3872934","Small Windows alternative to Crypto++ for decoding RSA?","<p>Crypto++ is huge (compiled) and I would like to find an alternative to decode a RSA encoded block.</p>

<p>I'm looking for a solution for Windows.</p>
","<p>If you are using Qt, QCA is a small alternative.</p>
","408","<windows><crypto++>","2","0","3","2010-10-07 14:53:04","3882920","0","","","","","2010-10-06 13:27:43",""
"3872934","Small Windows alternative to Crypto++ for decoding RSA?","<p>Crypto++ is huge (compiled) and I would like to find an alternative to decode a RSA encoded block.</p>

<p>I'm looking for a solution for Windows.</p>
","<p>You may want to check OpenSSL library for windows (<a href=""http://gnuwin32.sourceforge.net/packages/openssl.htm"" rel=""nofollow"">http://gnuwin32.sourceforge.net/packages/openssl.htm</a>). I don't know the actual size increase caused by Crypto++,  the latest OpenSSL dll's size (that you need to deploy along with your application) is around 1.5MB.</p>
","408","<windows><crypto++>","2","0","3","2010-10-07 14:53:04","3882920","0","","","","","2010-10-06 13:27:43",""
"3872934","Small Windows alternative to Crypto++ for decoding RSA?","<p>Crypto++ is huge (compiled) and I would like to find an alternative to decode a RSA encoded block.</p>

<p>I'm looking for a solution for Windows.</p>
","<p>If you're using Windows (only) why not use the Windows CryptoAPI?</p>

<p>Crypto API certainly has the ability to perform RSA encryption/decryption. It also has some logic for encoding and decoding PKCS#7/CMS message formats. It's not clear from your question exactly what you want to do.</p>
","408","<windows><crypto++>","2","1","3","2010-10-07 14:53:04","3882920","0","","","","","2010-10-06 13:27:43",""
"29379910","Does Digest Init-Update-Final mechanism make a copy of input data?","<p>I compute a hash using <em>init-update-final</em> mechanism i.e. initialize the hash context, followed by hash update with various sizes of input data, and a final digest calculation. This can be done using <a href=""https://www.openssl.org/docs/crypto/EVP_MD_CTX_md.html"" rel=""nofollow"">the EVP_DigestInit, EVP_DigestUpdate and EVP_DigestFinal_Ex functions of OpenSSL</a> or the <a href=""http://www.cryptopp.com/docs/ref/class_s_h_a512.html"" rel=""nofollow"">Update and Final methods of Crypto++</a>.</p>

<p>From what I can dig up from the source code of <em>OpenSSL</em> and <em>Crypto++</em>, it seems like the input data actually get copied and stored. Can anyone confirm this? Is this a limitation of the hashing process or is it a standard procedure? And does this vary with the digest algorithm used?</p>

<p>I was under the impression that the hashing algorithm would compute some internal state based on the chunk of input data, and the final digest will be computed based on the internal states collected over all the various update calls. This does not seem to be the case. Obviously I do not understand the mechanics of hashing algorithms enough. </p>
","<blockquote>
  <p>From what I can dig up from the source code of OpenSSL and Crypto++, it seems like the input data actually get copied and stored. Can anyone confirm this?</p>
</blockquote>

<p>Yes and no. The input is not usually stored. Partial inputs are buffered until a full block is available to process.</p>

<p>The buffering is part of the state of the hash. Once consumed, the storage for the partial block may be used if additional partial blocks are encountered. When the hash object is destroyed, the data in the partial blocks get wiped or zeroized.</p>

<p>How much data can potentially be stored depends on the hash's internals and block size. This statement is generally true for iterative hashes like MD5, SHA1 and SHA512. But I don't know about recursive hash functions like SHA3.</p>

<p>The strategy applies to both OpenSSL and Crypto++.</p>

<p>In the case of Crypto++, a hash's output will be buffered internally if no <code>AttachedTransformation</code> is present.</p>

<hr>

<p>Also see <a href=""http://cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow"">Init-Update-Final</a> on the Crypto++ wiki. Its a recent addition, being added in January 2016.</p>
","403","<hash><openssl><crypto++><digest><evp-cipher>","1","1","1","2016-01-18 01:33:18","29381838","0","","","","","2015-03-31 22:49:06",""
"23878893","Why does this throw ""CryptoMaterial: this object contains invalid values"" in C++, but works fine in python","<p>I am interfacing with Mega.co.nz's API, using a python library as a reference and this code is throwing. The private key is of a temporary account.</p>

<p>When I only use the first prime it works, but if I include the second one it throws, yet everything works fine in the python code.</p>

<p>This code throws ""CryptoMaterial: this object contains invalid values""</p>

<pre><code>// g++ test.cpp -o test -lcryptopp
#include &lt;iostream&gt;

#include &lt;cryptopp/rsa.h&gt;
#include &lt;cryptopp/integer.h&gt;
#include &lt;cryptopp/osrng.h&gt;

using namespace CryptoPP;

const Integer c(""10857166326382703760062779528766843368820930576598213227278471554906214169288262514203969639120532785228356073660117311791556795787311220009132632364495267243081665670086710276242234063736282452747089977833464270310556099739736793916154923086192702968111366046442015937417526298511445199340095898060147092158884693079554126699550560654798428433227449793922222881580173315635171540012289392792883134869370184160735204631001817822007869637755937740560912176149892518538187132538381475906064954503330035090788011376816518843886790979724470958150966813982521146398987188066116582925811581312709558507015381360737728282160"");
const Integer n(""13427557315502247597000078151163920443026153459996461135918747863095898679484680068841870307134991870634527490898047374333864169992533593470214214321618599580908993204307520436691605704402046321917552215500601059547120681142391461211832942043578807378527059669212765719156841060911214035328326209517003764423649629080809193207761562938380209994488934153009055462878017442054432223170713164757958714200660834201842865647297155663529615291314825578660639925675604438589594375258126020834604025620095899336598293228999530739615479725715448390873778015506002443516234879727296164834962067569248938506798206172807824155467"");
const Integer d(""11307416686738734818526381600980143530969392387365440956563156095238651519566046373761574995482098417376444202861513578386411932625291447132811969955047241752344415329943175104582404803706986376351622918316295629092312152540961230494175109089329522002970155510916013237184708261819969713960695755382740012146034212919647492076234405993178655740138052420647985859442037931597940897198569337697554456337486998070498389971468780232363941255237291940175758993311124407117751983734467699346428299766707608212611622303248258864115688090242455959830749262966169383160757942327094420226154106561552020347355716010319448907163"");
const Integer p(""100826948907457598414845964524448089304988432540271591225687687675999370502892903258891517574080931665624511494151970577170497712420499991942965423848183374943909439781466449525683097361603853112400332604761081878780250618758818492357490355994233490146112828080518628573284802902011591132699377690748913996743"");
const Integer q(""133174289820338768818359856956108213770008470949300663564909710605878037244519172983221279725814092327501516062026008560426937338300041407758960697270460830193354454791979178335037322285526761471721659139131141459697849499793713446217272909739442810866721995133352912243119263125394323211613915719804564581469"");


int main(){
    AutoSeededRandomPool prng;

    InvertibleRSAFunction rsa;

    rsa.SetModulus(n);
    rsa.SetPrivateExponent(d);
    rsa.SetPrime1(p);
    rsa.SetPrime2(q); // Works fine if this line is removed
    RSA::PrivateKey privKey(rsa);

    Integer r = privKey.CalculateInverse(prng, c); // Throws here
    std::cout &lt;&lt; ""r: "" &lt;&lt; r &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>But this python code works:</p>

<pre><code>from Crypto.PublicKey import RSA

c = 10857166326382703760062779528766843368820930576598213227278471554906214169288262514203969639120532785228356073660117311791556795787311220009132632364495267243081665670086710276242234063736282452747089977833464270310556099739736793916154923086192702968111366046442015937417526298511445199340095898060147092158884693079554126699550560654798428433227449793922222881580173315635171540012289392792883134869370184160735204631001817822007869637755937740560912176149892518538187132538381475906064954503330035090788011376816518843886790979724470958150966813982521146398987188066116582925811581312709558507015381360737728282160L
n = 13427557315502247597000078151163920443026153459996461135918747863095898679484680068841870307134991870634527490898047374333864169992533593470214214321618599580908993204307520436691605704402046321917552215500601059547120681142391461211832942043578807378527059669212765719156841060911214035328326209517003764423649629080809193207761562938380209994488934153009055462878017442054432223170713164757958714200660834201842865647297155663529615291314825578660639925675604438589594375258126020834604025620095899336598293228999530739615479725715448390873778015506002443516234879727296164834962067569248938506798206172807824155467L
d = 11307416686738734818526381600980143530969392387365440956563156095238651519566046373761574995482098417376444202861513578386411932625291447132811969955047241752344415329943175104582404803706986376351622918316295629092312152540961230494175109089329522002970155510916013237184708261819969713960695755382740012146034212919647492076234405993178655740138052420647985859442037931597940897198569337697554456337486998070498389971468780232363941255237291940175758993311124407117751983734467699346428299766707608212611622303248258864115688090242455959830749262966169383160757942327094420226154106561552020347355716010319448907163L
p = 100826948907457598414845964524448089304988432540271591225687687675999370502892903258891517574080931665624511494151970577170497712420499991942965423848183374943909439781466449525683097361603853112400332604761081878780250618758818492357490355994233490146112828080518628573284802902011591132699377690748913996743L
q = 133174289820338768818359856956108213770008470949300663564909710605878037244519172983221279725814092327501516062026008560426937338300041407758960697270460830193354454791979178335037322285526761471721659139131141459697849499793713446217272909739442810866721995133352912243119263125394323211613915719804564581469L

rsa_decrypter = RSA.construct( (n, 0L, d, p, q) )

print( rsa_decrypter.key._decrypt(c) )
</code></pre>
","<p>I checked the source. the exception is throw from <code>RSAFunction::Validate</code>, because <code>e</code> is not set. </p>

<p>However, setting <code>e</code> doesn't fix it, as then it is also thrown from <code>InvertibleRSAFunction::Validate</code> because <code>dp</code>, <code>dq</code>, and <code>u</code> are not set. </p>

<p>An RSA private key minimally only requires N, D. However, usually there are additionally the five integers P, Q, DP, DQ, QP. These extra integers are intermediate steps which make the calculation much faster. It is possible but very slow to do the calculation just using N and D. (You basically have to do log2(D) times as many calculations).</p>

<p>E is required for a public operation; but typically a private key is published as a key pair which includes E.</p>

<p>The Crypto++ private key operation also uses E however: it does some extra steps involving random data, which I presume is to prevent timing attacks.  </p>

<p>I'd guess that the Python version works because it does not do this timing attack prevention; and it also computes any values that were missing. (They can all be computed from <code>N</code> and <code>D</code> as I mentioned, but this is slow).</p>

<p>Here is additional code to compute the missing values for yourself, this works for me:</p>

<pre><code>rsa.SetModulus(n);
rsa.SetPrivateExponent(d);
rsa.SetPrime1(p);
rsa.SetPrime2(q);

// add this:
rsa.SetModPrime1PrivateExponent( d % (p-1) );
rsa.SetModPrime2PrivateExponent( d % (q-1) );
rsa.SetMultiplicativeInverseOfPrime2ModPrime1( q.InverseMod(p) );
rsa.SetPublicExponent( d.InverseMod((p-1) * (q-1)) );
</code></pre>

<p>Note that in general, private key files should contain all of these values - it's unusual (to me, anyway) that you would be sitting there with N,D,P,Q but not the others.</p>
","403","<c++><crypto++>","4","2","1","2014-05-27 06:55:20","23881674","9","","","","","2014-05-26 23:19:55",""
"37685190","Crypto++ output data length","<p>I am trying to use AES encryption from Crypto++ libary:</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption e;
</code></pre>

<p>I have a binary data block that I need to encrypt. The class seems to provide a method called <code>ProcessData</code> for this purpose:</p>

<pre><code>virtual void ProcessData(byte *outString, const byte *inString, size_t length);
</code></pre>

<p>Looks like the last parameter is the size of the input data. What is not clear is why the method does not return me the size of the encrypted data. Is it assumed that the size of output data block is exactly the same as the length of input data block? Is this valid even if the size of input data is just one byte? Regards.</p>
","<blockquote>
<pre><code>virtual void ProcessData(byte *outString, const byte *inString, size_t length);
</code></pre>
  
  <p>Looks like the last parameter is the size of the input data. What is not clear is why the method does not return me the size of the encrypted data...</p>
</blockquote>

<p><code>ProcessData</code> is the workhorse of all block ciphers (but not stream ciphers or other types of objects). Also see the Crypto++ manual and <a href=""http://www.cryptopp.com/docs/ref/cryptlib_8h.html"" rel=""nofollow"">cryptlib.h File Reference</a>. <code>cryptlib.h</code> is described as <em>""Abstract base classes that provide a uniform interface to this library""</em>.</p>

<p><code>ProcessData</code> operates on block-sized lengths of data. So <code>INSIZE</code> is equal to <code>OUTSIZE</code> is equal to <code>BLOCKSIZE</code>. Note that there is no <code>INSIZE</code> or <code>OUTSIZE</code> - I used them for discussion. Each block cipher will provide a constant for <code>BLOCKSIZE</code>. There will be a <code>AES::BLOCKSIZE</code>, <code>DES_EDE::BLOCKSIZE</code>, etc.</p>

<p>Typically you <em>do not</em> use <code>ProcessData</code> directly. You can use it directly, but you will be responsible for all the associated details (more on the details below).</p>

<p>Typically you use a <code>StreamTransformationFilter</code>, but its not readily apparent why. <code>StreamTransformationFilter</code> provides input buffering, output buffering, and padding as required. Its briefly discussed at <a href=""http://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow"">Init-Update-Final</a> on the wiki.</p>

<p>Here's how it looks in practice from the <a href=""http://www.cryptopp.com/wiki/CBC_mode"" rel=""nofollow"">CBC mode</a> example on the Crypto++ wiki:</p>

<pre><code>try
{
    cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

    CBC_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), iv );

    // The StreamTransformationFilter adds padding
    //  as required. ECB and CBC Mode must be padded
    //  to the block size of the cipher.
    StringSource ss( plain, true, 
        new StreamTransformationFilter( e,
            new StringSink( cipher )
        ) // StreamTransformationFilter      
    ); // StringSource
}
catch( const CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>In the above, <code>CBC_mode</code> and <code>StreamTransformationFilter</code> work together to give you desired results. <code>CBC_mode</code> calls <code>ProcessData</code> and handles the cipher chaining details. <code>StreamTransformationFilter</code> feeds the plain text in its preferred size. If there's not enough plain text, then <code>StreamTransformationFilter</code> buffers it on input. If there's no output buffer, then <code>StreamTransformationFilter</code> buffers cipher text, too.</p>

<p><code>StreamTransformationFilter</code> will also apply padding as required. There's a default padding, but you can override it. <code>StreamTransformationFilter</code> knows what padding to apply because it asks the mode (<code>CBC_mode</code>) if the padding is required and what the padding should be.</p>

<hr>

<blockquote>
  <p>... Is it assumed that the size of output data block is exactly the same as the length of input data block? Is this valid even if the size of input data is just one byte?</p>
</blockquote>

<p>This is where the <code>StreamTransformationFilter</code> fits into the equation.</p>

<p>Be sure to check out <a href=""http://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow"">Init-Update-Final</a> on the wiki. It should provide the glue for you if you are used to Java or OpenSSL programming. It should help ""make it click"" for you.</p>
","403","<aes><crypto++>","3","1","1","2016-06-11 23:10:12","37689299","1","","","","","2016-06-07 17:01:07",""
"30871161","Extra data in result for AES/GCM decryption","<p>I have the following code, basically grabbed right from the Crypto++ wiki at <a href=""http://www.cryptopp.com/wiki/AuthenticatedDecryptionFilter"" rel=""nofollow"">http://www.cryptopp.com/wiki/AuthenticatedDecryptionFilter</a></p>

<p>The problem is, with the output I get ""plaintext: abc1230000000077C8E390"" instead of what I'd expect, just ""plaintext: abc123"" </p>

<p>What is the extra data at the end?</p>

<p>Also- two more small questions that are based on the same codebase:</p>

<ol>
<li><p>would this method serve as a drop-in replacement for using actual random byte data for pdata- or since it's string must it actually be like usual text?</p></li>
<li><p>I assume adata is meant to be transferred in plaintext, so when storing the ciphertext, am I correct that both the iv and adata are in plaintext, and the user only provides the key (to decrypt the ciphertext with those 4 elements: key (provided by user), ciphertext (made available), iv (made available), and adata (made available)?</p></li>
</ol>

<p>Thank you!</p>

<pre><code>AutoSeededRandomPool prng;

byte key[ AES::DEFAULT_KEYLENGTH ];
prng.GenerateBlock( key, sizeof(key) );

byte iv[ AES::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

string adata( 16, (char)0x00 );

string cipherText = encryptData(""abc123"", adata, key, iv);
string plainText = decryptData(cipherText, adata, key, iv);
cout &lt;&lt; ""plaintext: "" &lt;&lt; plainText &lt;&lt; endl;

//Utilities
string MainWindow::encryptData(string pdata, string adata, const byte *key, const byte *iv) {
    const int TAG_SIZE = 16;

    string cipher;

    try
        {
            GCM&lt; AES &gt;::Encryption e;
            e.SetKeyWithIV( key, AES::DEFAULT_KEYLENGTH, iv, AES::BLOCKSIZE );

            AuthenticatedEncryptionFilter ef( e,
                new StringSink( cipher ), false, TAG_SIZE
            ); // AuthenticatedEncryptionFilter

            ef.ChannelPut( ""AAD"", (const byte*)adata.data(), adata.size() );
            ef.ChannelMessageEnd(""AAD"");

            ef.ChannelPut( """", (const byte*)pdata.data(), pdata.size() );
            ef.ChannelMessageEnd("""");
        }
        catch( CryptoPP::BufferedTransformation::NoChannelSupport&amp; e )
        {
            cerr &lt;&lt; ""Caught NoChannelSupport..."" &lt;&lt; endl;
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            cerr &lt;&lt; endl;
        }
        catch( CryptoPP::AuthenticatedSymmetricCipher::BadState&amp; e )
        {
            cerr &lt;&lt; ""Caught BadState..."" &lt;&lt; endl;
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            cerr &lt;&lt; endl;
        }
        catch( CryptoPP::InvalidArgument&amp; e )
        {
            cerr &lt;&lt; ""Caught InvalidArgument..."" &lt;&lt; endl;
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            cerr &lt;&lt; endl;
        }

    return(cipher);
}

string MainWindow::decryptData(string cipher, string adata, const byte *key, const byte *iv) {
    const int TAG_SIZE = 16;
    string radata, rpdata;
    try
    {
        GCM&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV( key, AES::DEFAULT_KEYLENGTH, iv, AES::BLOCKSIZE );

        string enc = cipher.substr( 0, cipher.length()-TAG_SIZE );
        string mac = cipher.substr( cipher.length()-TAG_SIZE );

        assert( cipher.size() == enc.size() + mac.size() );
        assert( enc.size() == pdata.size() );
        assert( TAG_SIZE == mac.size() );

        radata = adata;

        AuthenticatedDecryptionFilter df( d, NULL,
            AuthenticatedDecryptionFilter::MAC_AT_BEGIN |
            AuthenticatedDecryptionFilter::THROW_EXCEPTION, TAG_SIZE );

        df.ChannelPut( """", (const byte*)mac.data(), mac.size() );
        df.ChannelPut( ""AAD"", (const byte*)adata.data(), adata.size() );
        df.ChannelPut( """", (const byte*)enc.data(), enc.size() );

        df.ChannelMessageEnd( ""AAD"" );
        df.ChannelMessageEnd( """" );

        string retrieved;
        size_t n = (size_t)df.MaxRetrievable();
        retrieved.resize( n );

        if( n &gt; 0 ) { df.Get( (byte*)retrieved.data(), n ); }
        rpdata = retrieved;
        assert( rpdata == pdata );

    }
    catch( CryptoPP::InvalidArgument&amp; e )
    {
        cerr &lt;&lt; ""Caught InvalidArgument..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch( CryptoPP::AuthenticatedSymmetricCipher::BadState&amp; e )
    {
        cerr &lt;&lt; ""Caught BadState..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch( CryptoPP::HashVerificationFilter::HashVerificationFailed&amp; e )
    {
        cerr &lt;&lt; ""Caught HashVerificationFailed..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }

    return rpdata;    
}
</code></pre>
","<blockquote>
  <p>The problem is, with the output I get ""plaintext: abc1230000000077C8E390""</p>
</blockquote>

<p>My guess here is you reused a string. Crypto++ will append, and not overwrite, in a <code>StringSink</code>. So you got <code>abc123</code>, and then you managed to append <code>0000000077C8E390</code> somehow.</p>

<hr>

<p>The following works for me. Its a mildly modified version of your program. It makes <code>adata</code> and <code>pdata</code> global, renames them to avoid name hiding, and passes the message through <code>pdata</code>.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./cryptopp-test.exe
plaintext: Now is the time for all good men to come to the aide of their country

$ ./cryptopp-test.exe wxyz
plaintext: wxyz
</code></pre>

<hr>

<p>Because you are using <code>THROW_EXCEPTION</code>, you don't need this:</p>

<pre class=""lang-c++ prettyprint-override""><code>b = df.GetLastResult();
assert( true == b );
</code></pre>

<hr>

<blockquote>
  <p>I assume adata is meant to be transferred in plaintext...</p>
</blockquote>

<p>Yes. It would be something like an IP address, a disk sector or counter (among others).</p>

<p>More correctly, its data that is authenticated only. If its tampered with, it will be detected.</p>

<hr>

<blockquote>
  <p>... am I correct that both the iv and adata are in plaintext</p>
</blockquote>

<p>The IV can be a public or private parameter.</p>

<p>If its a public parameter, then it does not need to be authenticated. Its a little non-intuitive, but that's because tampering with the IV will tamper with the cipher's state, so decryption will fail as if you used the wrong key.</p>

<hr>

<blockquote>
  <p>... the user only provides the key (to decrypt the ciphertext with those 4 elements: key (provided by user), ciphertext (made available), iv (made available), and adata (made available)?</p>
</blockquote>

<p>The <code>pdata</code> gets confidentiality and authenticity assurances; and <code>adata</code> gets authenticity assurances only.</p>

<p>The key and IV are customary. Handle them like you always do (or should do :).</p>

<hr>

<pre class=""lang-c++ prettyprint-override""><code>using CryptoPP::DEFAULT_CHANNEL;
using CryptoPP::AAD_CHANNEL;

string encryptData(const string&amp; pdata, const string&amp; adata, const byte *key, unsigned int ksize, const byte *iv, unsigned int vsize);
string decryptData(const string&amp; cipher, const string&amp; adata, const byte *key, unsigned int ksize, const byte *iv, unsigned int vsize);

string xadata = ""172.16.1.10"";
string xpdata = ""Now is the time for all good men to come to the aide of their country"";

static const unsigned int TAG_SIZE = 16;

int main(int argc, char* argv[])
{
    (void)argc; (void)argv;

    if(argc &gt;= 2)
        xpdata = argv[1];

    try {

        AutoSeededRandomPool prng;

        byte key[ AES::DEFAULT_KEYLENGTH ];
        prng.GenerateBlock( key, sizeof(key) );

        byte iv[ AES::BLOCKSIZE ];
        prng.GenerateBlock( iv, sizeof(iv) );

        string cipherText = encryptData(xpdata, xadata, key, sizeof(key), iv, sizeof(iv));
        string plainText = decryptData(cipherText, xadata, key, sizeof(key), iv, sizeof(iv));

        cout &lt;&lt; ""plaintext: "" &lt;&lt; plainText &lt;&lt; endl;
    }
    catch(CryptoPP::Exception&amp; ex)
    {
        cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }

    return 0;
}

//Utilities
string encryptData(const string&amp; pdata, const string&amp; adata, const byte *key, unsigned int ksize, const byte *iv, unsigned int vsize) {

    string cipher;

    GCM&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( key, ksize, iv, vsize );

    AuthenticatedEncryptionFilter ef( e,
                                     new StringSink( cipher ), false, TAG_SIZE
                                     ); // AuthenticatedEncryptionFilter

    ef.ChannelPut(AAD_CHANNEL, (const byte*)adata.data(), adata.size() );
    ef.ChannelMessageEnd(AAD_CHANNEL);

    ef.ChannelPut(DEFAULT_CHANNEL, (const byte*)pdata.data(), pdata.size() );
    ef.ChannelMessageEnd(DEFAULT_CHANNEL);

    return(cipher);
}

string decryptData(const string&amp; cipher, const string&amp; adata, const byte *key, unsigned int ksize, const byte *iv, unsigned int vsize) {

    string recovered;

    GCM&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( key, ksize, iv, vsize );

    const string&amp; enc = cipher.substr( 0, cipher.length()-TAG_SIZE );
    const string&amp; mac = cipher.substr( cipher.length()-TAG_SIZE );

    assert( cipher.size() == enc.size() + mac.size() );
    assert( enc.size() == xpdata.size() );
    assert( TAG_SIZE == mac.size() );

    AuthenticatedDecryptionFilter df( d, new StringSink(recovered),
                                     AuthenticatedDecryptionFilter::MAC_AT_BEGIN |
                                     AuthenticatedDecryptionFilter::THROW_EXCEPTION, TAG_SIZE );

    df.ChannelPut(DEFAULT_CHANNEL, (const byte*)mac.data(), mac.size() );
    df.ChannelPut(AAD_CHANNEL, (const byte*)adata.data(), adata.size() );
    df.ChannelPut(DEFAULT_CHANNEL, (const byte*)enc.data(), enc.size() );

    df.ChannelMessageEnd(AAD_CHANNEL);
    df.ChannelMessageEnd(DEFAULT_CHANNEL);

    assert( recovered == xpdata );        
    return(recovered);
}
</code></pre>
","402","<c++><encryption><aes><crypto++>","0","0","1","2015-06-17 05:07:52","30882103","0","","608639","","2015-06-17 04:32:08","2015-06-16 14:54:30",""
"27739140","How to add filename to archive if compressing using Gzip class?","<p>I'm using Gzip to compress data before encryption. </p>

<pre><code>Gzip gz;
gz.Put(file,size)
gz.MessageEnd();
gz.Get(file,gz.MaxRetrievable());
</code></pre>

<p>I want the created gzip file to include the original filename as metadata. How do i do this through the Crypto++ interface?</p>
","<blockquote>
  <p>I want the created gzip file to include the original filename as metadata. How do i do this through the Crypto++ interface?</p>
</blockquote>

<p>You can't out-of-the-box. It appears to be a limitation of Crypto++. (But see below).</p>

<p>From <a href=""https://www.ietf.org/rfc/rfc1952.txt"" rel=""nofollow noreferrer"">RFC 1952</a> there's clearly a field for it:</p>

<pre><code>  (if FLG.FNAME set)

     +=========================================+
     |...original file name, zero-terminated...| (more--&gt;)
     +=========================================+
</code></pre>

<p>But Crypto++ does not allow you to set it (from <a href=""https://svn.code.sf.net/p/cryptopp/code/trunk/c5/gzip.cpp"" rel=""nofollow noreferrer"">gzip.c source code</a>):</p>

<pre><code>void Gzip::WritePrestreamHeader()
{
    m_totalLen = 0;
    m_crc.Restart();

    AttachedTransformation()-&gt;Put(MAGIC1);
    AttachedTransformation()-&gt;Put(MAGIC2);
    AttachedTransformation()-&gt;Put(DEFLATED);
    AttachedTransformation()-&gt;Put(0);       // general flag
    AttachedTransformation()-&gt;PutWord32(0); // time stamp
    byte extra = (GetDeflateLevel() == 1) ? FAST : ((GetDeflateLevel() == 9) ? SLOW : 0);
    AttachedTransformation()-&gt;Put(extra);
    AttachedTransformation()-&gt;Put(GZIP_OS_CODE);
}
</code></pre>

<p>And Crypto++ silently discards it if its present when its unzipping (<code>Gunzip</code> is the GZIP decompressor) (from <a href=""https://svn.code.sf.net/p/cryptopp/code/trunk/c5/gzip.cpp"" rel=""nofollow noreferrer"">gzip.c source code</a>):</p>

<pre><code>void Gunzip::ProcessPrestreamHeader()
{
    ...

    if (flags &amp; EXTRA_FIELDS)   // skip extra fields
    {
        word16 length;
        if (m_inQueue.GetWord16(length, LITTLE_ENDIAN_ORDER) != 2) throw HeaderErr();
        if (m_inQueue.Skip(length)!=length) throw HeaderErr();
    }

    if (flags &amp; FILENAME)   // skip filename
        do
            if(!m_inQueue.Get(b)) throw HeaderErr();
        while (b);

    if (flags &amp; COMMENTS)   // skip comments
        do
            if(!m_inQueue.Get(b)) throw HeaderErr();
        while (b);
}
</code></pre>

<hr>

<p>You're the first person I recall asking for it in about 15 years, so its not a popular request :) </p>

<p>Here's how to modify the sources to add a filetime, filename and comment. You can find the patch on the Crypto++ wiki pages for <a href=""http://www.cryptopp.com/wiki/Gzip"" rel=""nofollow noreferrer"">Gzip</a> and <a href=""http://www.cryptopp.com/wiki/Gunzip"" rel=""nofollow noreferrer"">Gunzip</a>. You can find the SVN diff on Pastebin at <a href=""http://pastebin.com/bE0qX42u"" rel=""nofollow noreferrer"">Diff for Crypto++ gzip for filename and comment processing</a>. The fles are mostly the same, but the wiki is more current because its got some reset code in <code>Gzip::WritePoststreamTail</code>.</p>

<p>First, add the following protected members to the <code>Gzip</code> and <code>Gunzip</code> classes:</p>

<pre><code>word32 m_filetime;
std::string m_filename;
std::string m_comment;
</code></pre>

<p>Second, add an initializer for <code>m_filetime</code> for each constructor (both <code>Gzip</code> and <code>Gunzip</code>). For example, here's one for one of the <code>Gzip</code> ctors:</p>

<pre><code>Gzip(const NameValuePairs &amp;parameters, BufferedTransformation *attachment=NULL)
    : Deflator(parameters, attachment), m_filetime(0) {}
</code></pre>

<p>Third, add public setters to the <code>Gzip</code> class:</p>

<pre><code>void SetFiletime(word32 filetime) { m_filetime = filetime; }
void SetFilename(const std::string&amp; filename) { m_filename = filename; }
void SetComment(const std::string&amp; comment) { m_comment = comment; }
</code></pre>

<p>Fourth, add public getters to the <code>Gunzip</code> class:</p>

<pre><code>word32 GetFiletime() const { return m_filetime; }
const std::string&amp; GetFilename() const { return m_filename; }
const std::string&amp; GetComment() const { return m_comment; }
</code></pre>

<p>Fifth, change <code>Gzip::WritePrestreamHeader</code> to the following in the cpp file:</p>

<pre><code>void Gzip::WritePrestreamHeader()
{
    m_totalLen = 0;
    m_crc.Restart();

    int flags = 0;
    if(!m_filename.empty())
        flags |= FILENAME;
    if(!m_comment.empty())
        flags |= COMMENTS;

    AttachedTransformation()-&gt;Put(MAGIC1);
    AttachedTransformation()-&gt;Put(MAGIC2);
    AttachedTransformation()-&gt;Put(DEFLATED);
    AttachedTransformation()-&gt;Put((byte)flags);    // general flag
    AttachedTransformation()-&gt;PutWord32(m_filetime, LITTLE_ENDIAN_ORDER);    // time stamp

    byte extra = (GetDeflateLevel() == 1) ? FAST : ((GetDeflateLevel() == 9) ? SLOW : 0);
    AttachedTransformation()-&gt;Put(extra);        
    AttachedTransformation()-&gt;Put(GZIP_OS_CODE);

    if(!m_filename.empty())
        AttachedTransformation()-&gt;Put((const unsigned char*)m_filename.data(), m_filename.size() +1);

    if(!m_comment.empty())
        AttachedTransformation()-&gt;Put((const unsigned char*)m_comment.data(), m_comment.size() +1);
}
</code></pre>

<p>Sixth, change <code>Gzip::WritePoststreamTail</code> to the following in the cpp file:</p>

<pre><code>void Gzip::WritePoststreamTail()
{
    SecByteBlock crc(4);
    m_crc.Final(crc);
    AttachedTransformation()-&gt;Put(crc, 4);
    AttachedTransformation()-&gt;PutWord32(m_totalLen, LITTLE_ENDIAN_ORDER);

    m_filetime = 0;

    m_filename.erase(0);
    m_filename.reserve(16);

    m_comment.erase(0);
    m_comment.reserve(32);
}
</code></pre>

<p>Seventh, change <code>Gunzip::ProcessPrestreamHeader</code> to the following in the cpp file:</p>

<pre><code>void Gunzip::ProcessPrestreamHeader()
{
    m_length = 0;
    m_crc.Restart();

    m_filetime = 0;

    m_filename.erase(0);
    m_filename.reserve(16);

    m_comment.erase(0);
    m_comment.reserve(32);

    byte buf[6];
    byte b, flags;

    if (m_inQueue.Get(buf, 2)!=2) throw HeaderErr();
    if (buf[0] != MAGIC1 || buf[1] != MAGIC2) throw HeaderErr();
    if (!m_inQueue.Get(b) || (b != DEFLATED)) throw HeaderErr();     // skip CM flag
    if (!m_inQueue.Get(flags)) throw HeaderErr();
    if (flags &amp; (ENCRYPTED | CONTINUED)) throw HeaderErr();
    if (m_inQueue.GetWord32(m_filetime, LITTLE_ENDIAN_ORDER) != 4) throw HeaderErr();
    if (m_inQueue.Skip(2)!=2) throw HeaderErr();    // Skip extra flags and OS type

    if (flags &amp; EXTRA_FIELDS)   // skip extra fields
    {
        word16 length;
        if (m_inQueue.GetWord16(length, LITTLE_ENDIAN_ORDER) != 2) throw HeaderErr();
        if (m_inQueue.Skip(length)!=length) throw HeaderErr();
    }

    if (flags &amp; FILENAME)   // extract filename
    {
        do
        {
            if(!m_inQueue.Get(b)) throw HeaderErr();
            if(b) m_filename.append( 1, (char)b );
        }
        while (b);
    }

    if (flags &amp; COMMENTS)   // extract comments
    {
        do
        {
            if(!m_inQueue.Get(b)) throw HeaderErr();
            if(b) m_comment.append( 1, (char)b );
        }
        while (b);
    }
}
</code></pre>

<hr>

<p>Here's how to use it:</p>

<pre><code>try {

    Gzip zipper(new FileSink(""gzip-test.gz"", true));
    zipper.SetFilename(""test-filename.txt"");
    zipper.SetComment(""This is a test of filenames and comments"");

    string data = ""abcdefghijklmnopqrstuvwxyz"";
    zipper.Put( (unsigned char*) data.c_str(), data.size());
    zipper.MessageEnd();        
}
catch(CryptoPP::Exception&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<p>The compressed file name is <code>gzip-test.gz</code>. The original filename field in the header is <code>test-filename.txt</code>, and the comment in the header is <code>This is a test of filenames and comments</code>.</p>

<p>You can see it in action using a hex editor:</p>

<p><img src=""https://i.stack.imgur.com/mCe5N.png"" alt=""enter image description here""></p>

<hr>

<p>Here's how it works in practice with both <code>gzip -d</code> and the default archive extractor on Mac OS X: the embedded filename is ignored, and the file is saved using the archive filename less the <code>gz</code> extension:</p>

<p><img src=""https://i.stack.imgur.com/GuXzG.png"" alt=""enter image description here""></p>

<p>I don't know if that's expected behavior or not since the filename member has something to do with preserving long filenames on filesystems that don't support them.</p>

<p>There's an open question on the behavior on Super User: <a href=""https://superuser.com/q/859785/173513"">Is Gzip supposed to honor original filename for decompress?</a>.</p>

<p><strong>EDIT</strong>: thanks to Simon on Super User, one must use <code>gunzip -N &lt;gz-file&gt;</code> to extract using the original filename stashed away in the header.</p>

<hr>

<p>For completeness, here's what a round trip looks like when writing the archive to an in-memory string rather than an on-disk file.</p>

<pre><code>string s1, s2;
string data = ""abcdefghijklmnopqrstuvwxyz"";

Gzip zipper(new StringSink(s1));
zipper.SetFilename(""test-filename.txt"");
zipper.SetComment(""This is a test of filenames and comments"");

zipper.Put( (unsigned char*) data.c_str(), data.size());
zipper.MessageEnd();

Gunzip unzipper(new StringSink(s2));
unzipper.Put( (unsigned char*) s1.data(), s1.size());
unzipper.MessageEnd();

cout &lt;&lt; ""Filename: "" &lt;&lt; unzipper.GetFilename() &lt;&lt; endl;
cout &lt;&lt; ""Comment: "" &lt;&lt; unzipper.GetComment() &lt;&lt; endl;
cout &lt;&lt; ""Data: "" &lt;&lt; s2 &lt;&lt; endl;
</code></pre>

<p>It produces expected results.</p>

<hr>

<p>There's an important caveat with the modifications above. The mods work well when the archive contains a single file. But <em>if</em> the stream contains multiple files, then the filetime, filename and comment will only be provided for the last filestream. If they are missing from the last filestream, then they will be empty in the getters.</p>

<p>The reason for the limitation has to do with the way Crypto++ pipelines are architected. In Crypto++, each stream is considered a message. You can call <code>NextMessage()</code> and get back the bytes in the stream. But the stream is a collection of unpacked bytes, and not a higher level structure that can accomodate the extra fields.</p>

<p>I'm pretty sure the fix for it is non-trivial. I believe it means that the <code>Gzip</code> compressor and <code>Gunzip</code> decompressor will need channels added so that you can retrieve the additional data, like the way you retrieve the cipher text (<code>DEFAULT_CHANNEL</code>) or authentication tag (<code>AAD_CHANNEL</code>) from an Authenticated Encryption filter.</p>
","399","<c++><gzip><crypto++>","4","5","1","2015-01-04 04:54:54","27739692","1","","608639","","2015-01-02 09:13:10","2015-01-02 07:59:23",""
"40093175","Generating an ONVIF authentication digest using Crypto++?","<p>The <a href=""http://www.onvif.org/Portals/0/documents/WhitePapers/ONVIF_WG-APG-Application_Programmer&#39;s_Guide.pdf"" rel=""nofollow"">ONVIF</a> authentication spec section 6.1.1.3 has what looks like a straight forward description of how to generate a digest. However, when using Crypto++ for Base64 and SHA1 operations, I cannot generate the same hash as the specification. I must be doing something wrong but cannot see what.</p>

<pre><code>std::string nonce = ""LKqI6G/AikKCQrN0zqZFlg=="";
std::string dt = ""2010-09-16T07:50:45Z"";
std::string pwd = ""userpassword"";

{
    // result should be tuOSpGlFlIXsozq4HFNeeGeFLEI=
    // as per spec. This approach is also used here:
    // https://github.com/agsh/onvif/blob/master/lib/cam.js

    CryptoPP::Base64Decoder decoder;
    decoder.Put((byte*)nonce.data(), nonce.size());
    std::vector&lt;uint8_t&gt; bytes(decoder.MaxRetrievable(),0);
    decoder.Get(&amp;bytes[0],bytes.size());

    //
    CryptoPP::SHA1 hash;
    byte digest[CryptoPP::SHA1::DIGESTSIZE];
    hash.Update(bytes.data(), bytes.size());
    hash.Update((const byte*)dt.c_str(), dt.size());
    hash.Update((const byte*)pwd.c_str(), pwd.size());
    hash.Final(digest);

    CryptoPP::Base64Encoder encoder;
    encoder.Put(digest, CryptoPP::SHA1::DIGESTSIZE);
    std::string hash64(encoder.MaxRetrievable(), 0);
    encoder.Get((byte*)hash64.data(), hash64.size());
    // generates woEIuU+ryXxcwkTZ9ktbKGeQ
    std::cout &lt;&lt; hash64 &lt;&lt; std::endl;
}
</code></pre>

<p>Any thoughts on this one much appreciated.</p>

<p>[edit: remove C# references]</p>
","<blockquote>
<pre><code>CryptoPP::Base64Decoder decoder;
decoder.Put((byte*)nonce.data(), nonce.size());
std::vector&lt;uint8_t&gt; bytes(decoder.MaxRetrievable(),0);
decoder.Get(&amp;bytes[0],bytes.size());
</code></pre>
</blockquote>

<p>Call <code>MessageEnd</code>:</p>

<pre class=""lang-cxx prettyprint-override""><code>Base64Decoder decoder;
decoder.Put((byte*)nonce.data(), nonce.size());
decoder.MessageEnd();

vector&lt;uint8_t&gt; bytes(decoder.MaxRetrievable(),0);
decoder.Get(&amp;bytes[0],bytes.size());
</code></pre>

<p>Ditto:</p>

<pre class=""lang-cxx prettyprint-override""><code>Base64Encoder encoder;
encoder.Put(digest, 20);
encoder.MessageEnd();

string hash64(encoder.MaxRetrievable(), 0);
encoder.Get((byte*)hash64.data(), hash64.size());
</code></pre>

<p>Also see <a href=""http://www.cryptopp.com/wiki/Base64Encoder#Missing_Data"" rel=""nofollow"">Base64Encoder | Missing Data</a> and <a href=""http://www.cryptopp.com/wiki/Base64Decoder#Missing_Data"" rel=""nofollow"">Base64Decoder | Missing Data</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
  <p>Nor indeed can I duplicate the result using any other approaches, like a full C# test bed using all of the .NET crypto resources.</p>
</blockquote>

<p>I don't know C# as well as Crypto++, so I can't help with a C# example that works as expected with ONVIF authentication.</p>

<hr>

<p>Here's the result I get:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ test.cxx -I. ./libcryptopp.a -o test.exe
$ ./test.exe 
tuOSpGlFlIXsozq4HFNeeGeFLEI=
</code></pre>

<p>And the <code>cat test.cxx</code>:</p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include ""base64.h""
#include ""sha.h""

std::string nonce = ""LKqI6G/AikKCQrN0zqZFlg=="";
std::string dt = ""2010-09-16T07:50:45Z"";
std::string pwd = ""userpassword"";

int main(int argc, char* argv[])
{
    CryptoPP::Base64Decoder decoder;
    decoder.Put((byte*)nonce.data(), nonce.size());
    decoder.MessageEnd();    
    std::vector&lt;uint8_t&gt; bytes(decoder.MaxRetrievable(),0);
    decoder.Get(&amp;bytes[0],bytes.size());

    CryptoPP::SHA1 hash;
    byte digest[CryptoPP::SHA1::DIGESTSIZE];
    hash.Update(bytes.data(), bytes.size());
    hash.Update((const byte*)dt.c_str(), dt.size());
    hash.Update((const byte*)pwd.c_str(), pwd.size());
    hash.Final(digest);

    CryptoPP::Base64Encoder encoder;
    encoder.Put(digest, 20);
    encoder.MessageEnd();    
    std::string hash64(encoder.MaxRetrievable(), 0);
    encoder.Get((byte*)hash64.data(), hash64.size());

    std::cout &lt;&lt; hash64 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
","398","<c++><crypto++><onvif>","1","0","1","2016-10-18 10:59:30","40096834","0","","52146","","2016-10-18 10:59:30","2016-10-17 18:23:49",""
"52235030","Cipher text is not a multiple of block size","<p>I've written a simple AES encryption program for a piece of text and whenever I attempt to decrypt the text, I am thrown an error;</p>

<blockquote>
  <p>StreamTransformationFilter: ciphertext length is not a multiple of block size</p>
</blockquote>

<p>This is my method of encryption;</p>

<pre><code>c_crypto::cryptkey aes_key;

c_crypto::make_keys(aes_key);

std::string testmessage = ""test"";

c_crypto::encrypt_buffer(testmessage, aes_key.enc_key, aes_key.enc_iv);
c_crypto::decrypt_buffer(testmessage, aes_key.enc_key, aes_key.enc_iv);

std::cout &lt;&lt; testmessage &lt;&lt; std::endl;
</code></pre>

<p>cryptkey struct;</p>

<pre><code>struct cryptkey {
    unsigned char enc_key[AES_KEY_SIZE];
    unsigned char enc_iv[AES_KEY_SIZE];
};
</code></pre>

<p><code>AES_KEY_SIZE</code> = 16</p>

<p>The <code>make_keys()</code> function simply calls;</p>

<pre><code>void c_crypto::random_bytes(const int &amp;amount, unsigned char *result) {
    CryptoPP::AutoSeededRandomPool rng;
    rng.GenerateBlock(result, amount);
}
</code></pre>

<p>With the paramters of <code>AES_KEY_SIZE</code> of either <code>cryptkey.enc_iv</code> or <code>cryptkey.enc_key</code></p>

<p>In the decrypt function;</p>

<pre><code>void c_crypto::decrypt_buffer(std::string &amp;input, unsigned char key[AES_KEY_SIZE], unsigned char iv[AES_KEY_SIZE]) {
    input = base64_decode(input);

    CryptoPP::AES::Decryption aesDecryption(key, AES_KEY_SIZE);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink(input));
    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(input.c_str()), input.size());
    stfDecryptor.MessageEnd();
}
</code></pre>

<p>The error is thrown in stfDecryptor.MessageEnd();</p>

<p>Here is the encrypt function if it is of any use;</p>

<pre><code>void c_crypto::encrypt_buffer(std::string &amp;input, unsigned char key[AES_KEY_SIZE], unsigned char iv[AES_KEY_SIZE]) {
    CryptoPP::AES::Encryption aesEncryption(key, AES_KEY_SIZE);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(input));
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(input.c_str()), input.length());
    stfEncryptor.MessageEnd();

    input = base64_encode(input);
}
</code></pre>

<p>EDIT: </p>

<p>Here's my decode and encode functions:</p>

<pre><code>std::string c_crypto::base64_encode(std::string &amp;input) {
    std::string result;
    CryptoPP::StringSource(input, true, new CryptoPP::Base64Encoder(new CryptoPP::StringSink(result)));
    return result;
}

std::string c_crypto::base64_decode(std::string &amp;input) {
    std::string result;
    CryptoPP::StringSource(input, true, new CryptoPP::Base64Decoder(new CryptoPP::StringSink(result)));
    std::cout &lt;&lt; (input.size() % 16 == 0) &lt;&lt; std::endl;
    return result;
}
</code></pre>
","<blockquote>
<pre><code>void c_crypto::encrypt_buffer(std::string &amp;input, unsigned char key[AES_KEY_SIZE], unsigned char iv[AES_KEY_SIZE]) {
    CryptoPP::AES::Encryption aesEncryption(key, AES_KEY_SIZE);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(input));
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(input.c_str()), input.length());
    stfEncryptor.MessageEnd();

    input = base64_encode(input);
}
</code></pre>
</blockquote>

<p>Don't use the same string as a source and a sink like you are doing. Use a separate temporary instead.</p>

<p>Most (all?) block ciphers can take a 16-byte block and encrypt or decrypt in place. However, in the case of string, the as string changes the underlying allocation changes. When the allocation changes the underlying pointer changes.</p>

<p>Maybe use something like the following. The temporaries sidestep the problems of using a string as both a source and sink. It also provides better exception safety. If something goes sideways your <code>input</code> is left unchanged.</p>

<pre><code>void c_crypto::encrypt_buffer(std::string &amp;input, unsigned char key[AES_KEY_SIZE], unsigned char iv[AES_KEY_SIZE]) {
    AES::Encryption aesEncryption(key, AES_KEY_SIZE);
    CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    std::string encrypted; encrypted.reserve(input.size()+16);
    StreamTransformationFilter stfEncryptor(cbcEncryption, new StringSink(encrypted));
    stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(input.c_str()), input.length());
    stfEncryptor.MessageEnd();

    std::string encoded = base64_encode(encrypted);
    std::swap(encoded, input);
}

void c_crypto::decrypt_buffer(std::string &amp;input, unsigned char key[AES_KEY_SIZE], unsigned char iv[AES_KEY_SIZE]) {
    std::string decoded = base64_decode(input);
    std::string decrypted; decrypted.reserve(decoded.size());

    AES::Decryption aesDecryption(key, AES_KEY_SIZE);
    CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    StreamTransformationFilter stfDecryptor(cbcDecryption, new StringSink(decrypted));
    stfDecryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(decoded.c_str()), decoded.size());
    stfDecryptor.MessageEnd();

    std::swap(decrypted, input);
}
</code></pre>

<hr>

<p>Using a buffer as an in/out parameter works fine. In this example the pointer will not change part way through the process:</p>

<pre><code>byte buff[16] = {0};
CBC_Mode&lt;AES&gt;::Encryption enc(key, 16, iv);
enc.ProcessBlock(buff);
</code></pre>

<p>However your use case is a little trickier because the cipher text is <em>appended</em> to the string <code>input</code> by way of <code>StringSink(input)</code>, which inevitably makes <code>input</code> grow and invalidates the iterators being used to feed the data into the encryptor via <code>StringSource(input, ...)</code>.</p>

<p>If interested, the <code>ProcessBlock</code> and <code>ProcessString</code> are the low-level member functions used to transform the data. Filters like <code>StreamTransformationFilter</code> simply calls it for you. There's no magic or mischief. It is just a high level way to process data. Also see <a href=""https://www.cryptopp.com/docs/ref/class_block_transformation.html"" rel=""nofollow noreferrer""><code>BlockTransformation</code></a> in the doxygen manual.</p>

<hr>

<p>Regarding padding, you used:</p>

<pre><code>StreamTransformationFilter stfEncryptor(cbcEncryption, new StringSink(input));
</code></pre>

<p>Which is really this <a href=""https://www.cryptopp.com/docs/ref/class_stream_transformation_filter.html"" rel=""nofollow noreferrer""><code>StreamTransformationFilter</code></a> constructor:</p>

<pre><code>StreamTransformationFilter (StreamTransformation &amp;c, BufferedTransformation *attachment=NULL, BlockPaddingScheme padding=DEFAULT_PADDING)
</code></pre>

<p><code>DEFAULT_PADDING</code> is one of two things. For modes that need padding, like ECB and CBC, it is PKCS #7 padding (<code>PKCS_PADDING</code>). For modes that <em>don't</em> need padding, like CTR, it is no padding (<code>NO_PADDING</code>).</p>

<p>You should usually take the default when it comes to padding schemes.</p>
","395","<c++><encryption><crypto++>","1","1","1","2018-09-09 21:23:10","52241223","5","","9827515","","2018-09-09 02:46:37","2018-09-08 11:49:48",""
"30888018","Can I specify the nonce and counter in AES encryption counter mode?","<p>I'm trying to use the library Crypto++ to make AES Counter mode based encryption/decryption</p>

<p>I want to split the IV value into nonce and counter.<br>
Is there any API that directly takes the nonce and counter to construct the IV ?</p>

<p>I did the following to achieve it </p>

<pre><code>byte counter[AES::BLOCKSIZE/2] = {0x0};     // initialized to zero : 64 bit counter
string counterstr ;
byte nonce[AES::BLOCKSIZE/2];                // 64 bit nonce 
string noncestr ;
prng.GenerateBlock(nonce, sizeof(nonce));
StringSource(nonce, sizeof(nonce), true,
    new HexEncoder(
    new StringSink(noncestr)
    ) // HexEncoder
    );
StringSource(counter, sizeof(counter), true,
    new HexEncoder(
    new StringSink(counterstr)
    ) // HexEncoder
    );
SecByteBlock no = HexDecodeString(noncestr);
SecByteBlock ctr = HexDecodeString(counterstr);
string ivv = noncestr + counterstr;
SecByteBlock ivvb = HexDecodeString(ivv);
</code></pre>

<p>then I use </p>

<pre><code>e.SetKeyWithIV(key, sizeof(key), iv);
</code></pre>

<h3>Questions:</h3>

<ul>
<li><p>Is this the only way to achieve this or is there any other easier way?</p></li>
<li><p>Does the counter value increment automatically when doing encryption or decryption of  blocks?</p></li>
<li><p>This one is trivial, should I specify another nonce value for each block?</p></li>
</ul>
","<blockquote>
  <p>Is this the only way to achieve this or is there any other easier way?</p>
</blockquote>

<p>No. The increment function operates on the full 128-bit block. See <a href=""http://www.cryptopp.com/wiki/CTR_Mode"" rel=""nofollow"">CTR mode and Counter Increment</a> on the Crypto++ wiki.</p>

<p>The longer answer is Yes <strong><em>if</em></strong> you provide your own <code>IncrementCounter</code> function. The longer answer can be Yes <strong><em>if</em></strong> you use the high order bits for the nonce and low order bits for the counter (see more below).</p>

<hr>

<blockquote>
  <p>Does the counter value increment automatically when doing encryption or decryption of blocks?</p>
</blockquote>

<p>Yes.</p>

<hr>

<blockquote>
  <p>This one is trivial, should I specify another nonce value for each block?</p>
</blockquote>

<p>No. The counter is incremented.</p>

<hr>

<blockquote>
  <p>Is there any API that directly takes the nonce and counter to construct the IV ?</p>
</blockquote>

<p>No. In more practical terms, there is a limit to how much plain text can be encrypted under a key/nonce pair (or security context). I think its well below 2 GB. If my recollection is correct, then you will have to re-key long before your counter gets into the high 64-bits.</p>

<p>In effect, that means you can use the high 64-bits as the random nonce, and use the lower 64-bits as the counter. So your code would look something like:</p>

<pre><code>byte counter[AES::BLOCKSIZE] = {0};
prng.GenerateBlock(counter, 8);
</code></pre>

<p>After the code above executes, the high 64-bits will be random, and the low 64-bits will start at 0 and serve as the counter.</p>

<p>Since 2 GB is about the limit, you can use a 12-4 split rather than a 8-8 split:</p>

<pre><code>byte counter[AES::BLOCKSIZE] = {0};
prng.GenerateBlock(counter, 12);
</code></pre>

<p>After the code above executes, the high 96-bits will be random, and the low 32-bits will start at 0 and serve as the counter.</p>

<hr>

<p>Related, never reuse a nonce. Each message must have its own, unique security context. That usually means a unique nonce (the other option is to provide a unique key for each message). Otherwise, you can trivially recover the key with an <code>XOR</code>.</p>
","395","<encryption><aes><crypto++>","3","0","1","2015-06-18 17:38:14","30889252","0","","608639","","2015-06-18 17:38:14","2015-06-17 09:47:37",""
"45424357","What is compliance with FIPS 140-2 in CRYPTOPP?","<p>How can I meet such compliance? In the method <code>GenerateRandom</code> of <code>InvertibleRSAFunction</code>, I am getting an exception when the method <code>SignaturePairwiseConsistencyTest_FIPS_140_Only(signer, verifier)</code> is called.
Am I choosing the seed wrong? Or the length?</p>

<pre><code>if (FIPS_140_2_ComplianceEnabled())
{
    RSASS&lt;PKCS1v15, SHA&gt;::Signer signer(*this);
    RSASS&lt;PKCS1v15, SHA&gt;::Verifier verifier(signer);
    SignaturePairwiseConsistencyTest_FIPS_140_Only(signer, verifier);

    RSAES&lt;OAEP&lt;SHA&gt; &gt;::Decryptor decryptor(*this);
    RSAES&lt;OAEP&lt;SHA&gt; &gt;::Encryptor encryptor(decryptor);
    EncryptionPairwiseConsistencyTest_FIPS_140_Only(encryptor, decryptor);
}
</code></pre>
","<blockquote>
  <p>How can I meet FIPS140-2 compliance?</p>
</blockquote>

<p>That's a big topic. Crypto++ has a wiki page on the subject at <a href=""https://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">FIPS DLL</a>. Below are some of the higher level bullet points.</p>

<ul>
<li>Validation on applicable to Windows</li>
<li>Must download prebuilt FIPS DLL</li>
<li>Operational Environments:

<ul>
<li>Windows 2000 Professional Operating System, Service Pack 1</li>
<li>Windows 2000 Professional Operating System, Service Pack 1</li>
<li>Windows XP Professional with SP2 and Windows Server 2003 X64 with SP1 </li>
</ul></li>
</ul>

<p>In the summer of 2017 I gave a talk at <a href=""http://icmconference.org/?page_id=4983"" rel=""nofollow noreferrer"">International Cryptographic Module Conference</a>. The talk was titled <a href=""http://icmconference.org/?presentation=s25a"" rel=""nofollow noreferrer"">Crypto++: Past Validations and Future Directions</a>.</p>

<p>The short of it is:</p>

<ul>
<li>Crypto++ is on the historical validation list. For all intents and purposes, we are no longer validated</li>
<li>Crypto++ probably will not seek another validation. Its too expensive</li>
<li>Validating a C++ library is no different than a C library</li>
<li>Implementing and using a C++ library is painful compared to a C library</li>
<li>Crypto++ can use OpenSSL's <a href=""https://wiki.openssl.org/index.php/FIPS_modules"" rel=""nofollow noreferrer"">FIPS Object Module</a> (FOM) to provide validated cryptography. I demonstrated it at the talk</li>
</ul>

<p>It may seem kind of odd that Crypto++ would wrap OpenSSL. I think it is, too. However, FIPS 140-2 is a process. It has very little to do with the actual technical implementation of the algorithms. Crypto++ wrapping the OpenSSL module was an immediate solution to a number of problems that costs nothing (as opposed to $100,000 USD for a new validation).</p>

<hr>

<p><strong><em>June 2019 edit</em></strong>: We marked the FIPS related Visual Studio projects as deprecated at <a href=""https://cryptopp.com/release800.html"" rel=""nofollow noreferrer"">Crypto++ 8.0 release</a>. As discussed at <a href=""https://cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">FIPS DLL</a> on the Crypto++ wiki, the two projects are <code>cryptdll.vcxproj</code> and <code>dlltest.vcxproj</code>. They are subject to removal in a future release.</p>

<p>We are not going to remove the two project until we have something in place to potentially provide FIPS validated cryptography. That will likely be a wrapper around OpenSSL's FIPS Object Module. The idea is, we funnel validations to OpenSSL and the world benefits. Users pay $5,000 or $10,000 to OpenSSL for the new platform validation. Crypto++ supports the OpenSSL validation/integration at no charge.</p>

<p>The downside to the user is, the user losses exclusivity because anyone in the world can use the new platform. The upside to the user is, it does not cost $150,000 for a private validation. Effectively our policy will force users to pool resources for the better good of everyone.</p>
","394","<crypto++><fips>","1","3","1","2019-06-12 11:01:09","45425064","0","","608639","","2017-07-31 20:21:36","2017-07-31 20:00:42",""
"27142355","Different g++ compile options needed on raspbian and Linux Mint for Cryptopp program?","<p>This question doesn't address a specific problem I need solved, it is a question about the reasons for solutions.</p>

<p>I wrote some code in C++ that relied on the cryptopp library, specifically version 5.6.2.</p>

<p>I intended this code to be run on my Raspberry Pi eventually (running Raspbian), but it's much slower than my laptop so I did all of the development and testing there, in Linux Mint. </p>

<p>When compiling on my laptop I used this command:</p>

<pre><code>g++ -o sim-test sim.cpp -lcryptopp
</code></pre>

<p>Today I ran the code for the first time on my Raspberry Pi and I ran into problems.</p>

<p>Specifically when trying to compile I got this:</p>

<pre><code>/usr/lib/gcc/arm-linux-gnueabihf/4.6/../../../libcryptopp.so: undefined reference to `pthread_key_create'
/usr/lib/gcc/arm-linux-gnueabihf/4.6/../../../libcryptopp.so: undefined reference to `pthread_getspecific'
/usr/lib/gcc/arm-linux-gnueabihf/4.6/../../../libcryptopp.so: undefined reference to `pthread_key_delete'
/usr/lib/gcc/arm-linux-gnueabihf/4.6/../../../libcryptopp.so: undefined reference to `pthread_setspecific'
collect2: ld returned 1 exit status
</code></pre>

<p>So I tried adding pthread to the path and it compiled fine. But when I ran my program I immediately got a segfault. GDB's stacktrace is rather long but here it is:</p>

<pre><code>#0  CryptoPP::BufferedTransformation::ChannelPut2 (this=0x6e080, channel=..., begin=0x6d624 ""\330&lt;\244\333\177\034a\216"", length=8, messageEnd=0, blocking=true) at cryptlib.cpp:356
#1  0xb6e67248 in CryptoPP::StringStore::CopyRangeTo2 (this=&lt;optimized out&gt;, target=..., begin=@0xbefff238: 0, end=18446744073709551615, channel=..., blocking=true) at filters.cpp:1069
#2  0xb6e67198 in CryptoPP::StringStore::TransferTo2 (this=0xbefff4c0, target=..., transferBytes=@0xbefff268: 18446744073709551615, channel=..., blocking=true) at filters.cpp:1059
#3  0xb6e126a8 in TransferMessagesTo2 (blocking=true, channel=..., messageCount=@0xbefff2ac: 0, target=..., this=0xbefff4c0) at cryptlib.cpp:509
#4  CryptoPP::BufferedTransformation::TransferMessagesTo2 (this=0xbefff4c0, target=..., messageCount=@0xbefff2ac: 0, channel=..., blocking=true) at cryptlib.cpp:494
#5  0xb6e12890 in CryptoPP::BufferedTransformation::TransferAllTo2 (this=0xbefff4c0, target=..., channel=..., blocking=&lt;optimized out&gt;) at cryptlib.cpp:555
#6  0x0004ebb8 in CryptoPP::SourceTemplate&lt;CryptoPP::StringStore&gt;::PumpAll2(bool) ()
#7  0x0003668c in CryptoPP::Source::PumpAll() ()
#8  0x000366e4 in CryptoPP::Source::SourceInitialize(bool, CryptoPP::NameValuePairs const&amp;) ()
#9  0x00036a80 in CryptoPP::StringSource::StringSource(std::string const&amp;, bool, CryptoPP::BufferedTransformation*) ()
#10 0x00030a14 in AESEncrypt(std::string&amp;, std::string&amp;, unsigned char*, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;) ()
#11 0x00032270 in Simulation(std::string&amp;, std::string&amp;, void (*)(CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;, int*), void (*)(CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;, unsigned char**, int*, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;), void (*)(std::string&amp;, std::string&amp;, unsigned char*, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;), void (*)(std::string&amp;, std::string&amp;, unsigned char*, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;), void (*)(std::string&amp;, std::string&amp;, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;), void (*)(std::string&amp;, std::string&amp;, CryptoPP::SecBlock&lt;unsigned char, CryptoPP::AllocatorWithCleanup&lt;unsigned char, false&gt; &gt;&amp;), int*, int*, int*) ()
#12 0x000326b0 in main ()
</code></pre>

<p>So I do some searching and I come across this post:</p>

<p><a href=""https://stackoverflow.com/questions/20527947/cryptopp-on-centos4-8-segmentation-fault-when-link-with-pthread"">cryptopp on centos4.8 segmentation fault when link with pthread</a></p>

<p>The asker has -static in their g++ command so I figure I'll give that a shot, and it works! My program runs just fine with no segfaults!</p>

<p>To be clear this is my final g++ command string:</p>

<pre><code>g++ -o sim-test sim.cpp -lcryptopp -static -pthread
</code></pre>

<p>But it ran just fine in Mint before, so why did I need to change the command string so much to get it to work on Raspbian?</p>

<p>I should also note that I've tested it and this command string compiles and runs just fine in Mint...</p>
","","391","<c++><linux><g++><raspbian><crypto++>","4","","0","2014-11-26 14:12:03","","0","","1114272","","2014-11-26 14:12:03","2014-11-26 06:02:45",""
"50543950","Load PEM encoded RSA public key using Crypto++","<p>With CryptoPP 5.6.4,i was importing a RSA public key as follow:</p>

<pre><code>#include &lt;pem.h&gt;

const std::string publickey_str = ""rsa_key here"";
RSA::PublicKey publicKey;
try
{
    StringSource source(publickey_str, true);
    PEM_Load(source, publicKey);
}
catch (const Exception&amp; ex)
{
    std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;
    return;
}
</code></pre>

<p>Today I downloaded and compiled Crypto++ 7.0.0 , and i was surprised to see that pem.h is no longer present in cryptopp folder. Documentation hasn't changed, and I couldn't find where the <code>PEM_load</code> function has been moved.</p>

<p>Does anybody know it ?</p>

<hr>

<p><strong><em>EDIT</em></strong>: after adding the PEM pack and rebuilding Crypto++ (everything went fine), I'm getting a unresolved external symbol when compiling my project (which is using <code>PEM_Load</code>, along with other parts of Crypto++:</p>

<pre><code>""void __cdecl CryptoPP::PEM_Load(class CryptoPP::BufferedTransformation &amp;,class CryptoPP::RSAFunction &amp;)""
(?PEM_Load@CryptoPP@@YAXAEAVBufferedTransformation@1@AEAVRSAFunction@1@@Z)
</code></pre>

<p>I added cryptlib.lib to the linker, set the <code>/MT</code> flag, and cryptopp has been built statically using VS2017. I don't have the error on other Crypto++ functions, either from <code>aes.h</code>, <code>rsa.h</code>, etc...</p>

<p>EDIT 2:
As requested by jww,there are <a href=""https://pastebin.com/BgXXWvPq"" rel=""nofollow noreferrer"">CryptoPP's cryptlib.vcxproj</a> and <a href=""https://pastebin.com/xPndLUiX"" rel=""nofollow noreferrer"">my project vcxproj file</a></p>
","","386","<c++><crypto++>","0","","0","2018-05-28 05:49:01","","10","","8096090","","2018-05-28 05:49:01","2018-05-26 14:50:50",""
"32459580","SecByteBlock to string conversion errors","<p>I have to send a randomly generated number (<code>rng</code>) within a packet, and, thus, have to convert a <code>SecByteBlock</code>. I use <a href=""https://github.com/pellegre/libcrafter"" rel=""nofollow noreferrer""><code>libcrafter</code></a> to put <code>rng</code> array into a <code>RawLayer</code> packet.</p>

<p>I followed <a href=""https://stackoverflow.com/a/31930838/3494633"">this answer</a>; but it gets me an <em>invalid conversion</em> error.</p>

<p>Here's the code I use:</p>

<pre><code>AutoSeededRandomPool prng;
SecByteBlock rng1;
prng.GenerateBlock( rng1, rng1.size() );

string rng1_str(reinterpret_cast&lt;char const*&gt;(rng1));

std::string rng1_str = std::string(rng1.data(), rng1.size());

Crafter::RawLayer number(rng1_str);
</code></pre>

<p>The two ideas don't work, both give me:</p>

<pre><code>error: invalid conversion from ‘CryptoPP::AllocatorWithCleanup&lt;unsigned char&gt;::pointer {aka unsigned char*}’
to ‘const char*’ [-fpermissive]
std::string rng1_str = std::string(rng1.data(), rng1.size());
</code></pre>

<p>Since the <code>RawLayer</code> accepts as constructor a <code>std::string</code> or a <code>const byte*</code>, I'd like to convert the <code>SecBlockByte</code> into one of these two formats...</p>
","<p>The output of the PRNG likely has an embedded NULL, so you can't operate on its data with customary C-string operations. That means the first statement is probably wrong.</p>

<blockquote>
<pre><code>string rng1_str(reinterpret_cast&lt;char const*&gt;(rng1));

std::string rng1_str = std::string(rng1.data(), rng1.size());
</code></pre>
</blockquote>

<p>I'm not sure what you are doing with the second statement, but it needs to be cast just like the first one (and you can do away with the assignment):</p>

<pre><code>std::string rng1_str(reinterpret_cast&lt;const char*&gt;(rng1.data()), rng1.size());
</code></pre>

<hr>

<p>Since you said you <em>""the <code>RawLayer</code> accepts as constructor a <code>std::string</code> or a <code>const byte*</code>""</em>, you might try:</p>

<pre><code>SecByteBlock rng(16);
prng.GenerateBlock( rng, rng.size() );

Crafter::RawLayer number( rng.data(), rng.size() );
</code></pre>

<p>Also, be sure to size the <code>SecByteBlock</code>. A raw declaration of one is a 0-sized array with <em>no</em> memory block backing it. That is, <code>rng.size()</code> will be 0 with just the following:</p>

<pre><code>SecByteBlock rng;
</code></pre>

<p>You can also do the following:</p>

<pre><code>SecByteBlock rng;
// Make it 16-bytes in size, memory uninitialized
rng.New(16);
</code></pre>

<p>Or:</p>

<pre><code>SecByteBlock rng;
// Make it 16-bytes in size, memory initialized to 0
rng.CleanNew(16);
</code></pre>

<p>If you want to get really fancy and avoid the runtime allocation of the memory block, then use a <a href=""http://www.cryptopp.com/docs/ref/secblock_8h_source.html"" rel=""nofollow""><code>FixedSizeSecBlock</code></a>:</p>

<pre><code>FixedSizeSecBlock&lt;byte, 16&gt; rng;
</code></pre>

<p>But this is a more advanced technique, so don't get bogged down with it.</p>

<hr>

<p>I find C/C++ unwillingness to automatically convert between a <code>signed char</code> and an <code>unsigned char</code> very annoying because its all just 8-bit binary data to me (I understand the need for the language rules). But I think its ridiculous I need a <code>reinterpret_cast</code> rather than a <code>static_cast</code>.</p>
","386","<c++><crypto++><libcrafter>","0","1","2","2015-09-09 07:02:19","","9","","-1","","2017-05-23 11:44:43","2015-09-08 13:49:31",""
"32459580","SecByteBlock to string conversion errors","<p>I have to send a randomly generated number (<code>rng</code>) within a packet, and, thus, have to convert a <code>SecByteBlock</code>. I use <a href=""https://github.com/pellegre/libcrafter"" rel=""nofollow noreferrer""><code>libcrafter</code></a> to put <code>rng</code> array into a <code>RawLayer</code> packet.</p>

<p>I followed <a href=""https://stackoverflow.com/a/31930838/3494633"">this answer</a>; but it gets me an <em>invalid conversion</em> error.</p>

<p>Here's the code I use:</p>

<pre><code>AutoSeededRandomPool prng;
SecByteBlock rng1;
prng.GenerateBlock( rng1, rng1.size() );

string rng1_str(reinterpret_cast&lt;char const*&gt;(rng1));

std::string rng1_str = std::string(rng1.data(), rng1.size());

Crafter::RawLayer number(rng1_str);
</code></pre>

<p>The two ideas don't work, both give me:</p>

<pre><code>error: invalid conversion from ‘CryptoPP::AllocatorWithCleanup&lt;unsigned char&gt;::pointer {aka unsigned char*}’
to ‘const char*’ [-fpermissive]
std::string rng1_str = std::string(rng1.data(), rng1.size());
</code></pre>

<p>Since the <code>RawLayer</code> accepts as constructor a <code>std::string</code> or a <code>const byte*</code>, I'd like to convert the <code>SecBlockByte</code> into one of these two formats...</p>
","<p>As the aim was to put the <code>SecByteBlock</code> into a <code>Crafter::RawLayer</code>, I simply had to cast it into a <code>const byte*</code>...</p>

<p>The following lines do the thing.</p>

<pre><code>SecByteBlock rng1;
prng.GenerateBlock( rng1, rng1.size() );

Crafter::RawLayer number(reinterpret_cast&lt;const byte*&gt;(rng1.data()), rng1.size());
</code></pre>
","386","<c++><crypto++><libcrafter>","0","0","2","2015-09-09 07:02:19","","9","","-1","","2017-05-23 11:44:43","2015-09-08 13:49:31",""
"45779676","How to print out the private key in ECDSA by using crypto++?","<p>I am trying to use the Elliptic Curve DSA.</p>

<p>In the part of ""Generate private key"" in the following code which I am using crypto++ library, the private exponent is printed out in the console.</p>

<p>How can I print out the private key itself?</p>

<pre><code>int main( int, char** ) {

    AutoSeededRandomPool prng;
    ByteQueue privateKey, publicKey, testKey;

    string message = ""Do or do not. There is no try."";

    //////////////////////////////////////////////////////

    // Generate private key
    ECDSA&lt;ECP, SHA1&gt;::PrivateKey privKey;
    privKey.Initialize( prng, secp256r1() );
    privKey.Save( privateKey );

    cout&lt;&lt;""the size : ""&lt;&lt;sizeof(privateKey)&lt;&lt;endl;

    cout&lt;&lt;""output 1 : ""&lt;&lt; privKey.GetPrivateExponent() &lt;&lt;endl;
    cout&lt;&lt;""output 2 : ""&lt;&lt; std::hex &lt;&lt; privKey.GetPrivateExponent() &lt;&lt;endl;
    cout&lt;&lt;""output 3 : ""&lt;&lt; std::hex &lt;&lt; &amp;privateKey &lt;&lt;endl;
    cout&lt;&lt;""output 4 : ""&lt;&lt; std::hex &lt;&lt; &amp;privKey &lt;&lt;endl;

    // Create public key
    ECDSA&lt;ECP, SHA1&gt;::PublicKey pubKey;
    privKey.MakePublicKey( pubKey );
    pubKey.Save( publicKey );

    //////////////////////////////////////////////////////    

    // Load private key (in ByteQueue, PKCS#8 format)
    ECDSA&lt;ECP, SHA1&gt;::Signer signer( privateKey );

    // Determine maximum size, allocate a string with that size
    size_t siglen = signer.MaxSignatureLength();
    string signature(siglen, 0x00);

    // Sign, and trim signature to actual size
    siglen = signer.SignMessage( prng, (const byte*)message.data(), message.size(), (byte*)signature.data() );
    signature.resize(siglen);

    //////////////////////////////////////////////////////    

    // Load public key (in ByteQueue, X509 format)
    ECDSA&lt;ECP, SHA1&gt;::Verifier verifier( publicKey );

    bool result = verifier.VerifyMessage( (const byte*)message.data(), message.size(), (const byte*)signature.data(), signature.size() );
    if(result)
        cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
    else
        cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; endl;

    return 0;
}
</code></pre>
","","385","<c++><crypto++>","1","","0","2017-08-20 07:46:28","","1","","7894151","","2017-08-20 07:46:28","2017-08-20 07:40:37",""
"40586525","Encrypt big char* using std::string with Crypto++","<p>I am new with Crypto++. I want to using Crypto++ library to encrypt/decrypt a large byte array in C++. The data can be anything, so asume its binary format.
First, I tried with ""byte array"" (char * or char[]). </p>

<pre><code>byte PlainText[] = {
  'H','e','l','l','o',' ',
  'W','o','r','l','d',
  0x0,0x0,0x0,0x0,0x0
};

byte key[ AES::DEFAULT_KEYLENGTH ];
::memset( key, 0x01, AES::DEFAULT_KEYLENGTH );

// Encrypt
ECB_Mode&lt; AES &gt;::Encryption Encryptor( key, sizeof(key) );

byte cbCipherText[AES::BLOCKSIZE];

Encryptor.ProcessData( cbCipherText, PlainText, sizeof(PlainText) );
</code></pre>

<p>We use ProcessData() to encrypt the plain text, since it allows us to receive the result in a single line of code. Next, we enter a DMZ, and then decrypt the cipher text.</p>

<p>// Decrypt</p>

<pre><code>ECB_Mode&lt; AES &gt;::Decryption Decryptor( key, sizeof(key) );

byte cbRecoveredText[AES::BLOCKSIZE];

Decryptor.ProcessData( cbRecoveredText, cbCipherText, sizeof(cbCipherText) );
</code></pre>

<p>The code above work perfect with small data (16KB). But it doesn't work with large data because ""is not multiple of block size"". Then, I think about using StreamTransformationFilter, which can automatic do the padding job for me. So I tried to encrypt and decrypt a std::string with encryptString() and decryptString() like below:</p>

<pre><code>string  encryptString(string plain, byte key[], int sizeKey, byte iv[], int sizeIV){
    string cipher;
    try{
        CBC_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true,
            new StreamTransformationFilter(e,
            new StringSink(cipher)
            ) // StreamTransformationFilter
            ); // StringSource

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return cipher;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return NULL;
    }
}

string  decryptString(string cipher, byte key[], int sizeKey, byte iv[], int sizeIV){
    string reco;
    try{
        CBC_Mode&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        StringSource s(cipher, true,
            new StreamTransformationFilter(d,
            new StringSink(reco)
            ) // StreamTransformationFilter
            ); // StringSource

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return reco;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return reco;
    }
}
</code></pre>

<p>They are worked for large text file too. But, wait, my goal is encrypt/decrypt ANY byte array. And sometime they aren't string.
So I think about wrap the above two function to work with char *.</p>

<pre><code>//wrap encryptString()
char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV){
    string cipher = encryptString(plainText, key, sizeKey, iv, sizeIV);
    FileUtil::writeFile(""ss1.txt"", cipher, cipher.length());
    long len = cipher.size() + 1;
     char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0'; 

    // don't forget to free the string after finished using it
    //delete[] writable;
    return writable;
}

//wrap decryptString()
char* decrypt(char * cipher,  byte key[], int sizeKey, byte iv[], int sizeIV){
    long len = strlen(cipher);
    string recovered = decryptString(cipher, key, sizeKey, iv, sizeIV);
    char * writable = new char[recovered.size() + 1];
    std::copy(recovered.begin(), recovered.end(), writable);
    writable[recovered.size()] = '\0'; // don't forget the terminating 0

    // don't forget to free the string after finished using it
    //delete[] writable;
    return writable;
}
</code></pre>

<p>The result is: 
When I read 1MB of text to encrypt() function, write the encrypted string ""cipher"" to ""ss1.txt"", its 1MB too. But to ""writable"", its only a part of ""cipher"" (about 1KB), and decrypted result is a part of original text too. Seem like '\0' was met somewhere and its terminated my char array?
I feel like going around now. Is there a way to using Crypto++ with (any) large byte (binary) array?</p>

<p>Additionally, I want to avoid using FileSource (Crypto++), because it doesn't allow me to save the encrypted value to variable.</p>
","","380","<c++><arrays><crypto++><large-data>","0","","0","2017-09-21 13:38:42","","4","","-1","","2017-09-22 17:44:54","2016-11-14 10:26:50",""
"28217744","Error while sending encrypted data with Boost::asio::async_send_to","<p>I am developing an encrypted version of a realtime communication application. The issue I have is, that the encrypted data pakets sent to the receiver are faulty. An example from the error log: (hex encoded data, the original data is pure byte code).</p>

<p>sent: <code>262C1688215232656B5235B691826A21C51D37A99413050BAEADB81D8892493FC0DB519250199F5BE73E18F2703946593C4F6CEA396A168B3313FA689DE84F380606ED3C322F2ADFC561B9F1571E29DF5870B59D2FCF497E01D9CD5DFCED743559C3EE5B00678966C8D73EA3A5CD810BB848309CDF0F955F949FDBA618C401DA70A10C36063261C5DBAB0FC0F1</code></p>

<p>received:    <code>262C1688215232656B5235B691826A21C51D37A99413050BAEADB81D8892493FC0DB519250199F5BE73E18F2703946593C4F6CEA396A168B3313FA689DE84F380606ED3C322F2ADFC561B9F1571E29DF5870B59D2FCF497E01D9CD5DFCED743559C3EE5B00CDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCD</code></p>

<p>This is the call of the send-method: </p>

<pre><code>string encSendBuffer = sj-&gt;cipherAgent-&gt;encrypt(sj-&gt;dFC-&gt;sendBuffer, sj-&gt;dFC-&gt;sendBytes);    

char* newSendBuffer = new char[encSendBuffer.length() + 1];
strcpy(newSendBuffer, encSendBuffer.c_str());

sj-&gt;dFC-&gt;s-&gt;async_send_to(boost::asio::buffer(newSendBuffer, encSendBuffer.length()),
    *sj-&gt;dFC-&gt;f,
    boost::bind(&amp;sender::sendHandler, this,
    boost::asio::placeholders::error,
    boost::asio::placeholders::bytes_transferred)
)
</code></pre>

<p><code>sj-&gt;dFC-&gt;s</code> is a UDP-Socket and <code>sj-&gt;dFC-&gt;f</code> is an UDP Endpoint.
The error code of the sendHandler is always <code>system: 0</code></p>

<p>This is how I do the encryption using the Crypto++ library: (extract)</p>

<pre><code>string cipherEngine::encrypt(char* input, int length)
{
    string cipher = """";

    CTR_Mode&lt;AES&gt;::Encryption e;
    e.SetKeyWithIV(key, keyLength, iv);

    ArraySource as((byte*)input, length, true,
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        )
    );

    return cipher;
}
</code></pre>

<p><strong>UPDATE:</strong> Code of the receive function:</p>

<pre><code>void receiver::receive(){
    int maxLength = 4096;

    sj-&gt;dFC-&gt;s-&gt;async_receive_from(boost::asio::buffer(input,maxLength),
                                   senderEndpoint, 
                                   boost::bind(&amp;receiver::handleReceiveFrom, this, boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred));
}
</code></pre>

<p>After the Data is received, it is stored in the char buffer <code>input</code> and decrypted in the <code>handleReceiveFrom</code> function.</p>

<p>Without encryption everything is fine. The number of bytes that are sended is always correct, on receiver side too. The length of de ""CD""- blocks are quite random. I already checked the encryption and the decrypted data is the same as the original plain text. </p>

<p>Does any know where this behavior comes from?</p>
","<p>The key here is that the erroneous data begins after the first null (0x00) value in your encrypted data array.  The following line:</p>

<pre><code>strcpy(newSendBuffer, encSendBuffer.c_str());
</code></pre>

<p>...looks like it's only copying up to the data until that null byte into newSendBuffer.  The send function is sending that buffer contents just fine; the buffer just doesn't have the data you expect.  You'll need to load newSendBuffer in a different way, not using strcpy(), that can handle null bytes.  Try std::memcpy().</p>
","379","<c++><encryption><aes><boost-asio><crypto++>","3","4","2","2015-01-29 16:42:19","28219511","5","","4035821","","2015-01-29 16:23:20","2015-01-29 14:58:39",""
"28217744","Error while sending encrypted data with Boost::asio::async_send_to","<p>I am developing an encrypted version of a realtime communication application. The issue I have is, that the encrypted data pakets sent to the receiver are faulty. An example from the error log: (hex encoded data, the original data is pure byte code).</p>

<p>sent: <code>262C1688215232656B5235B691826A21C51D37A99413050BAEADB81D8892493FC0DB519250199F5BE73E18F2703946593C4F6CEA396A168B3313FA689DE84F380606ED3C322F2ADFC561B9F1571E29DF5870B59D2FCF497E01D9CD5DFCED743559C3EE5B00678966C8D73EA3A5CD810BB848309CDF0F955F949FDBA618C401DA70A10C36063261C5DBAB0FC0F1</code></p>

<p>received:    <code>262C1688215232656B5235B691826A21C51D37A99413050BAEADB81D8892493FC0DB519250199F5BE73E18F2703946593C4F6CEA396A168B3313FA689DE84F380606ED3C322F2ADFC561B9F1571E29DF5870B59D2FCF497E01D9CD5DFCED743559C3EE5B00CDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCDCD</code></p>

<p>This is the call of the send-method: </p>

<pre><code>string encSendBuffer = sj-&gt;cipherAgent-&gt;encrypt(sj-&gt;dFC-&gt;sendBuffer, sj-&gt;dFC-&gt;sendBytes);    

char* newSendBuffer = new char[encSendBuffer.length() + 1];
strcpy(newSendBuffer, encSendBuffer.c_str());

sj-&gt;dFC-&gt;s-&gt;async_send_to(boost::asio::buffer(newSendBuffer, encSendBuffer.length()),
    *sj-&gt;dFC-&gt;f,
    boost::bind(&amp;sender::sendHandler, this,
    boost::asio::placeholders::error,
    boost::asio::placeholders::bytes_transferred)
)
</code></pre>

<p><code>sj-&gt;dFC-&gt;s</code> is a UDP-Socket and <code>sj-&gt;dFC-&gt;f</code> is an UDP Endpoint.
The error code of the sendHandler is always <code>system: 0</code></p>

<p>This is how I do the encryption using the Crypto++ library: (extract)</p>

<pre><code>string cipherEngine::encrypt(char* input, int length)
{
    string cipher = """";

    CTR_Mode&lt;AES&gt;::Encryption e;
    e.SetKeyWithIV(key, keyLength, iv);

    ArraySource as((byte*)input, length, true,
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        )
    );

    return cipher;
}
</code></pre>

<p><strong>UPDATE:</strong> Code of the receive function:</p>

<pre><code>void receiver::receive(){
    int maxLength = 4096;

    sj-&gt;dFC-&gt;s-&gt;async_receive_from(boost::asio::buffer(input,maxLength),
                                   senderEndpoint, 
                                   boost::bind(&amp;receiver::handleReceiveFrom, this, boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred));
}
</code></pre>

<p>After the Data is received, it is stored in the char buffer <code>input</code> and decrypted in the <code>handleReceiveFrom</code> function.</p>

<p>Without encryption everything is fine. The number of bytes that are sended is always correct, on receiver side too. The length of de ""CD""- blocks are quite random. I already checked the encryption and the decrypted data is the same as the original plain text. </p>

<p>Does any know where this behavior comes from?</p>
","<p>Thank you Joachim Pileborg and Jack O'Reilly! You are right indeed.</p>

<p>I changed my code from <code>strcpy(newSendBuffer, encSendBuffer.c_str());</code></p>

<p>to </p>

<pre><code>for (int i = 0; i &lt; encSendBuffer.length(); i++)
{
    newSendBuffer[i] = encSendBuffer.at(i);
}
</code></pre>

<p>on sender and receiver side. It actually solved the problem. It is quite naive code but it does what it should.</p>

<p><code>std::memcpy()</code> seems to be much more elegant and i will try it out.</p>
","379","<c++><encryption><aes><boost-asio><crypto++>","3","0","2","2015-01-29 16:42:19","28219511","5","","4035821","","2015-01-29 16:23:20","2015-01-29 14:58:39",""
"36825951","CryptoPP::selfTestFailure when using FIPS validated library and AES","<p>I have a server. I want to add to it AES encryption.
I've tried using the Crypto++, after a lot of searching it compiled but it always throw exceptions that come from ""CryptoPP::selfTestFailure"".
I've read somewhere that it has something with this define in the file fips140.cpp:</p>

<pre><code>// Define this to 1 to turn on FIPS 140-2 compliance features, including additional tests during 
// startup, random number generation, and key generation. These tests may affect performance.
#ifndef CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2
#define CRYPTOPP_ENABLE_COMPLIANCE_WITH_FIPS_140_2 0
endif
</code></pre>

<p>but when i change the define to 1 the project that i took the DLL from don't compile.
what did i do wrong? / is there any other way to implantation the AES algorithm? </p>
","<blockquote>
  <p>... after a lot of searching it compiled but it always throw exceptions that come from ""CryptoPP::selfTestFailure"". I've read somewhere that it has something with this define in the file fips140.cpp:</p>
</blockquote>

<p>The <a href=""http://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">FIPS DLL</a> is a special purpose Windows DLL with considerable restrictions. One of the restrictions is the Operational Environment or OE. The OE includes OS versions and service pack levels.</p>

<p>For the FIPS DLL, here are the approved OE's:</p>

<ul>
<li>5.0.4 - Windows 2000 Professional Operating System, Service Pack 1</li>
<li>5.2.3 - Windows 2000 Professional Operating System, Service Pack 1</li>
<li>5.3.0 - Windows XP Professional with SP2 and Windows Server 2003 X64 with SP1</li>
</ul>

<p>If the OS is wrong, or the Service Pack level is wrong, then that can cause the self test failure. One of the reasons it can cause a failure is because the DLL locates certain specific memory functions from the C++ runtime. If it does not find them, it throws an exception.</p>

<p>There's a not-so-readily apparent dependency, and that's the version of Visual Studio. The last version of the library that was validated is 5.3, and for it you need Visual Studio 2005.</p>

<p>Usually what you have to do now is set up a a build/test machine with the specific OS, ervice Pack level and Visual Studio, and then build and test on it. Then, when you install Crypto++ and your program in production, you use the <a href=""http://www.google.com/search?num=40&amp;q=windows+compatibility+tab+site%3Amicrosoft.com"" rel=""nofollow noreferrer"">compatibility tab</a> to provide the runtime OE.</p>

<hr>

<blockquote>
  <p>when i change the define to 1 the project that I took the DLL from don't compile. what did i do wrong?</p>
</blockquote>

<p>If you want or need more specific answers, then you need to provide more information, like your version of Windows, your version of Visual Studio, and a call stack.</p>

<hr>

<p>I would also encourage you to avoid the FIPS DLL if possible. Most users don't realize its special purpose and don't know how to use it properly. Its a pain in the butt to work with and its a constant source of problems.</p>

<p>If you want a DLL, then create a wrapper DLL that exports the symbols you want to export. Then, link to the static version of the Crypto++ library.</p>
","377","<c++><encryption><aes><crypto++><fips>","1","2","1","2017-08-24 12:48:22","","6","1","608639","","2016-04-24 23:31:19","2016-04-24 16:38:26",""
"43352882","AES/CFB encryption with Crypto++ not working","<p>I have a simple console program that should encrypt files with AES CFB algorithm from Crypto++ library. For some reason it is not working. Encoding part:</p>

<pre><code>byte data[16] = { 0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44, 
                  0x88, 0x44, 0x88, 0x44 };

byte result[16] = { 0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44, 
                  0x88, 0x44, 0x88, 0x44 };

//Sample key
byte key[16] = { 0x88, 0x44, 0x88, 0x44,
                 0x88, 0x44, 0x88, 0x44,
                 0x88, 0x44, 0x88, 0x44, 
                 0x88, 0x44, 0x88, 0x44 };

//Generate random Initialization Vector
byte iv[16];
CryptoPP::AutoSeededRandomPool rnd;
rnd.GenerateBlock(iv, CryptoPP::AES::BLOCKSIZE /*16*/);

//Through VisualStudio debug/watch functionality I have found out that Crypto++ randomizer works properly so at this point ""iv"" contains random values

CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption tmp(key, 16, iv, 1);
tmp.ProcessData(data, result, 16);
</code></pre>

<p>The problem is that after last line of code in this part (tmp.ProcessData(data, result, 16);) nothing in <code>result</code> changes.
I was guided by this official tutorial:
<a href=""https://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Advanced_Encryption_Standard</a></p>
","","376","<c++><encryption><aes><crypto++>","0","","0","2017-05-07 19:06:01","","9","","608639","","2017-05-07 19:06:01","2017-04-11 17:45:44",""
"37163270","DefaultDecryptorWithMAC throws exception ""cannot decrypt message with this passphrase""","<p>I'm experiencing the exact same issue as <a href=""http://comments.gmane.org/gmane.comp.encryption.cryptopp/2518"" rel=""nofollow"">this</a>.  Want to encrypt on Ubuntu (VM guest) and decrypt on Windows (host).  </p>

<p>In this case, because I'm using DefaultEncryptorWithMAC with AES-256, I 
get the exception ""cannot decrypt message with this passphrase"".  </p>

<p><strong>EDIT</strong></p>

<p>A buildable example: <a href=""https://www.cryptopp.com/wiki/DefaultEncryptorWithMAC"" rel=""nofollow"">this</a> slightly modified.  Ubuntu guest:</p>

<pre><code>//$ cat &gt; secret-message.txt
//Now is the time for all good men to come to the aide of their country

#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;
using std::ofstream;

#include &lt;string&gt;
using std::string;

#include &lt;cryptopp/default.h&gt;
using CryptoPP::DefaultEncryptorWithMAC;
using CryptoPP::DefaultDecryptorWithMAC;

#include &lt;cryptopp/filters.h&gt;
using CryptoPP::StringSource;
using CryptoPP::StringSink;
using CryptoPP::HashFilter;

#include &lt;cryptopp/files.h&gt;
using CryptoPP::FileSource;
using CryptoPP::FileSink;

#include &lt;cryptopp/hex.h&gt;
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include &lt;cryptopp/sha.h&gt;
using CryptoPP::SHA1;

#define UNUSED(x) (void(x))

int main(int argc, char *argv[])
{
    UNUSED(argc); UNUSED(argv);

    std::locale l("""");
    cout &lt;&lt; ""Locale: "" &lt;&lt; l.name() &lt;&lt; endl;

    string password = ""super secret password"";
    string encrypted, decrypted;
    ofstream ofs(""./secret-message-enc.txt"", ofstream::binary);

    cout &lt;&lt; ""Password: "" &lt;&lt; password &lt;&lt; endl;

    FileSource fs1(""./secret-message.txt"", true,
            new DefaultEncryptorWithMAC(
                (byte*)password.data(), password.size(),
                new HexEncoder(
                    new StringSink(encrypted)
                    )
                )
            );

    cout &lt;&lt; ""Encrypted: "" &lt;&lt; encrypted &lt;&lt; endl;

    ofs &lt;&lt; encrypted;

    SHA1 hash;
    string digest;

    StringSource ss1(encrypted, true, new HashFilter(hash, new HexEncoder(new StringSink(digest))));

    cout &lt;&lt; ""SHA1: "" &lt;&lt; digest &lt;&lt; endl;

    StringSource ss(encrypted, true,
            new HexDecoder(
                new DefaultDecryptorWithMAC(
                    (byte*)password.data(), password.size(),
                    new StringSink(decrypted)
                    )
                )
            );

    cout &lt;&lt; ""Decrypted: "" &lt;&lt; decrypted &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Gives:</p>

<pre>Locale: en_CA.UTF-8
Password: super secret password
Encrypted: 9B6F165AE9491B477E0E8E1CE23BE735242303078D246C8D6828BFC5D047B30BDBFC929ACAD30E97A94708BA4B36B24120A42AB53366C4FA8E68087E659F4CB9206E519BCB5C9551C775723DA2BADFF3903D27CBA1914B3E7403F9D59121587A83D434C4A84DB40A27E5FC19C3F7FF2E
SHA1: 7D2043DE8B51B20810B18026F5318EDDC1EF9196
Decrypted: Now is the time for all good men to come to the aide of their country</pre>

<p>Transfer <code>secret-message-enc.txt</code> to Windows host.  VS2013 compiled with UNICODE project setting:</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;
using std::ifstream;

#include &lt;string&gt;
using std::string;

#include ""default.h""
using CryptoPP::DefaultDecryptorWithMAC;

#include ""filters.h""
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::HashFilter;

#include ""files.h""
using CryptoPP::FileSource;

#include ""hex.h""
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include ""sha.h""
using CryptoPP::SHA1;

#define UNUSED(x) (void(x))

int main(int argc, char *argv[])
{
    UNUSED(argc); UNUSED(argv);

    std::locale l("""");
    cout &lt;&lt; ""Locale: "" &lt;&lt; l.name() &lt;&lt; endl;

    string password = ""super secret password"";
    string encrypted, decrypted;
    ifstream ifs(""./secret-message-enc.txt"", ifstream::binary);

    cout &lt;&lt; ""Password: "" &lt;&lt; password &lt;&lt; endl;

    ifs &gt;&gt; encrypted;
    cout &lt;&lt; ""Encrypted: "" &lt;&lt; encrypted &lt;&lt; endl;

    SHA1 hash;
    string digest;

    FileSource fs1(""./secret-message-enc.txt"", true, new HashFilter(hash, new HexEncoder(new StringSink(digest))));

    cout &lt;&lt; ""SHA1: "" &lt;&lt; digest &lt;&lt; endl;

    try
    {
        FileSource fs2(""./secret-message-enc.txt"", true,
                new HexDecoder(
                    new DefaultDecryptorWithMAC(
                        (byte*)password.data(), password.size(),
                            new StringSink(decrypted)
                    )
                )
            );

        cout &lt;&lt; ""Decrypted: "" &lt;&lt; decrypted &lt;&lt; endl;
    }
    catch (CryptoPP::Exception e)
    {
        cout &lt;&lt; e.what() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>

<p>Gives,</p>

<pre>Locale: English_United States.1252
Password: super secret password
Encrypted: 9B6F165AE9491B477E0E8E1CE23BE735242303078D246C8D6828BFC5D047B30BDBFC929ACAD30E97A94708BA4B36B24120A42AB53366C4FA8E68087E659F4CB9206E519BCB5C9551C775723DA2BADFF3903D27CBA1914B3E7403F9D59121587A83D434C4A84DB40A27E5FC19C3F7FF2E
SHA1: 7D2043DE8B51B20810B18026F5318EDDC1EF9196
DefaultDecryptor: cannot decrypt message with this passphrase</pre>
","","370","<c++><windows><ubuntu><encryption><crypto++>","0","","0","2016-05-15 17:09:07","","6","0","608639","","2016-05-15 17:09:07","2016-05-11 12:52:00",""
"34453457","Crypto++ 32bit compilation on a 64bit machine","<p>I am using <code>cryptopp</code> on a Ubuntu 64bit machine. I need to compile the library for 32bit, but I cannot find out how.</p>

<p>Shall I make some change in the GNU Makefile or use an optional argument when calling <code>make</code>?</p>
","<p>You could try building it with <code>make CC='gcc -m32' CXX='g++ -m32'</code> but you'll probably need several 32 bits libraries.</p>

<p>You could also set up a 32 bits distribution in a <code>chroot</code>-ed environment (using <code>debootstrap</code>) and build your <code>crypto++</code> inside.</p>
","370","<c++><crypto++>","3","5","3","2015-12-25 00:55:21","34453547","1","","717822","","2015-12-24 22:50:05","2015-12-24 13:21:29",""
"34453457","Crypto++ 32bit compilation on a 64bit machine","<p>I am using <code>cryptopp</code> on a Ubuntu 64bit machine. I need to compile the library for 32bit, but I cannot find out how.</p>

<p>Shall I make some change in the GNU Makefile or use an optional argument when calling <code>make</code>?</p>
","<p><code>gcc</code> and <code>g++</code> have a specific option to force to compile in 32bit mode, it is <code>-m32</code>. So, if the Makefile system of your application is properly set, you just need to run the compilation as follow:</p>

<pre><code>$&gt; CXX='g++ -m32' make
</code></pre>

<p>That should be enough.</p>
","370","<c++><crypto++>","3","4","3","2015-12-25 00:55:21","34453547","1","","717822","","2015-12-24 22:50:05","2015-12-24 13:21:29",""
"34453457","Crypto++ 32bit compilation on a 64bit machine","<p>I am using <code>cryptopp</code> on a Ubuntu 64bit machine. I need to compile the library for 32bit, but I cannot find out how.</p>

<p>Shall I make some change in the GNU Makefile or use an optional argument when calling <code>make</code>?</p>
","<blockquote>
  <p>Shall I make some change in the GNU Makefile or use an optional argument when calling make?</p>
</blockquote>

<p>Everyone's answers should work for you. To be pedantic, the following will also work for Crypto++ 5.6.3 and above. It was added to <code>CXXFLAGS</code> because its a compiler option:</p>

<pre><code>export CXXFLAGS=""-DNDEBUG -g2 -O2 -m32""
make static dynamic cryptest.exe
...

# Run validation suite
./cryptest.exe v

# Run test vectors
./cryptest.exe tv all
</code></pre>

<hr>

<p>Crypto++ 5.6.2 used to use the following (from <a href=""https://www.cryptopp.com/docs/ref562/_g_n_umakefile_source.html"" rel=""nofollow"">5.6.2's GNUMakefile</a>):</p>

<pre><code> 1 CXXFLAGS = -DNDEBUG -g -O2
 2 # -O3 fails to link on Cygwin GCC version 4.5.3
 3 # -fPIC is supported. Please report any breakage of -fPIC as a bug.
 4 # CXXFLAGS += -fPIC
 ...
 8 ARFLAGS = -cr  # ar needs the dash on OpenBSD
 9 RANLIB = ranlib
...
25 ifeq ($(CXX),gcc)  # for some reason CXX is gcc on cygwin 1.1.4
26 CXX = g++
27 endif
...
</code></pre>

<p>Notice it unconditionally sets both <code>CXX</code> and <code>CXXFLAGS</code>. This bothered the hell out of me and some other users, so it was one of the first things we changed when Wei turned the library over to the community.</p>

<p>Crypto++ 5.6.3 and above changed that. The makefile attempts to honor everything the user provides, including <code>CXX</code>, <code>CXXFLAGS</code>, <code>AR</code>, <code>ARFLAGS</code>, etc (from <a href=""https://www.cryptopp.com/docs/ref563/_g_n_umakefile_source.html"" rel=""nofollow"">5.6.3's GNUMakefile</a>):</p>

<pre><code> 1 # Base CXXFLAGS used if the user did not specify them
 2 CXXFLAGS ?= -DNDEBUG -g2 -O2
...
14 AR ?= ar
15 ARFLAGS ?= -cr # ar needs the dash on OpenBSD
16 RANLIB ?= ranlib
...
49 # We honor ARFLAGS, but the ""v"" often option used by default causes a noisy make
50 ifeq ($(ARFLAGS),rv)
51 ARFLAGS = r
52 endif
...
</code></pre>

<hr>

<p>The same principles apple to <code>GNUmakefile-cross</code> if you are performing cross-compiles for embedded and mobile platforms.</p>
","370","<c++><crypto++>","3","1","3","2015-12-25 00:55:21","34453547","1","","717822","","2015-12-24 22:50:05","2015-12-24 13:21:29",""
"9009037","valgrind: Disrupting crypto++ zlib test","<p>I am getting a strange error with valgrind on a program that makes use of Crypto++'s zlib functions:</p>

<pre><code>vex x86-&gt;IR: unhandled instruction bytes: 0xC5 0xF9 0x6E 0x45
==8605== valgrind: Unrecognised instruction at address 0x814c88b.
==8605==    at 0x814C88B: CryptoPP::ByteQueue::TransferTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, std::string const&amp;, bool) (misc.h:189)
==8605==    by 0x814C3E6: CryptoPP::ByteQueue::Get(unsigned char*, unsigned int) (cryptlib.h:901)
==8605==    by 0x815DAAE: CryptoPP::ZlibDecompressor::ProcessPoststreamTail() (zlib.cpp:84)
==8605==    by 0x815B6EC: CryptoPP::Inflator::ProcessInput(bool) (zinflate.cpp:349)
==8605==    by 0x815BC25: CryptoPP::Inflator::Put2(unsigned char const*, unsigned int, int, bool) (zinflate.cpp:295)
==8605==    by 0x805E40C: CryptoPP::BufferedTransformation::Put(unsigned char const*, unsigned int, bool) (cryptlib.h:789)
</code></pre>

<p>I know that Crypto++ uses some hand-coded assembly in certain areas to speed things up, and I've read that instructions starting with 0xC5 are never present in compiled code. Could this be due to an assembly instruction from a piece of hand-coded assembly? And if so, can I disable this check by valgrind so that I can continue to test my program?</p>
","<p>This is an <a href=""http://en.wikipedia.org/wiki/Advanced_Vector_Extensions"" rel=""nofollow"">AVX</a> instruction.  <a href=""https://bugs.kde.org/show_bug.cgi?id=273475"" rel=""nofollow"">Valgrind does not currently support AVX instructions</a>, but AVX support is under development.  Because valgrind works by emulating each instruction, it is not just a check that you can bypass unless you want it to jump directly to the actual instruction, which would disable valgrind altogether for the remainder of the execution.</p>
","366","<c++><valgrind><crypto++>","0","1","1","2012-01-26 03:39:09","9013657","0","","","","","2012-01-25 19:32:17",""
"25570094","Invalid CRC32 Hash Generation","<p>I'm creating <strong>SHA1</strong> and <strong>CRC32</strong> hash from plain text using Crypto++ Library as the following: </p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/crc.h&gt;

#include &lt;string.h&gt;
#include &lt;iostream&gt;

int main()
{
    // Calculate SHA1

    std::string data = ""Hello World"";
    std::string base_encoded_string;

    byte sha_hash[CryptoPP::SHA::DIGESTSIZE];
    CryptoPP::SHA().CalculateDigest(sha_hash, (byte*)data.data(), data.size());
    CryptoPP::StringSource ss1( std::string(sha_hash, sha_hash+CryptoPP::SHA::DIGESTSIZE), true,
        new CryptoPP::HexEncoder( new CryptoPP::StringSink( base_encoded_string ) ));

    std::cout &lt;&lt; base_encoded_string &lt;&lt; std::endl;
    base_encoded_string.clear();

    // Calculate CRC32

    byte crc32_hash[CryptoPP::CRC32::DIGESTSIZE];
    CryptoPP::CRC32().CalculateDigest(crc32_hash, (byte*)data.data(), data.size());
    CryptoPP::StringSource ss2( std::string(crc32_hash, crc32_hash+CryptoPP::CRC32::DIGESTSIZE), true,
        new CryptoPP::HexEncoder( new CryptoPP::StringSink( base_encoded_string ) ));

    std::cout &lt;&lt; base_encoded_string &lt;&lt; std::endl;
    base_encoded_string.clear();

}
</code></pre>

<p>The output I get is:</p>

<blockquote>
  <p>0A4D55A8D778E5022FAB701977C5D840BBC486D0<br>
  56B1174A<br>
  Press any key to continue . . .</p>
</blockquote>

<p>And, out of these I confirmed that CRC32 is incorrect according to various online resources such as this one: <a href=""http://www.fileformat.info/tool/hash.htm?text=Hello+World"" rel=""nofollow"">http://www.fileformat.info/tool/hash.htm?text=Hello+World</a></p>

<p>I have no idea why because I'm creating CRC32 hash by following the same procedure as I followed for SHA1. Is there really different way or am I really doing something wrong in here?</p>
","<blockquote>
  <p>byte crc32_hash[CryptoPP::CRC32::DIGESTSIZE];</p>
</blockquote>

<p>I believe you have a bad endian interaction. Treat the CRC32 value is an integer, not a byte array.</p>

<p>So try this:</p>

<pre><code>int32_t crc = (crc32_hash[0] &lt;&lt; 0) | (crc32_hash[1] &lt;&lt; 8) |
                (crc32_hash[2] &lt;&lt; 16) | (crc32_hash[3] &lt;&lt; 24);
</code></pre>

<p><em>If</em> <code>crc32_hash</code> is integer aligned, then you can:</p>

<pre><code>int32_t crc = ntohl(*(int32_t*)crc32_hash);
</code></pre>

<p>Or, this might be easier:</p>

<pre><code>int32_t crc32_hash;
CryptoPP::CRC32().CalculateDigest(&amp;crc32_hash, (byte*)data.data(), data.size());
</code></pre>

<p>I might be wrong about <code>int32_t</code>, it might be <code>uint32_t</code> (I did not look at the standard).</p>
","365","<hash><sha1><crypto++><crc32>","0","1","1","2014-09-03 14:54:52","","0","","608639","","2014-09-03 14:54:52","2014-08-29 14:11:42",""
"34929863","Network setup and class ""Veins::ObstacleControl"" not found","<p>I will be grateful if you help me to figure out my problems with veins:
I successfully installed veins 4a2 and sumo 0.21.0 and Omnet 4.4 , the simulation example works fine.</p>

<p>Next, I imported Crypto++ 5.6.3 in the workspace as a new project under C/C++ → Existing Code as Makefile Project. Then I linked it to veins as follow:</p>

<ul>
<li>in Project References I selected the Crypto++ </li>
<li>in Makemake options, I select Link → and write Crypto++</li>
</ul>

<p>I include in my code #include&lt; rsa.h> etc… , it is recognized and there is no syntax errors, but when I run the simulation (omnet.ini), opp_run.exe crash.</p>

<p>The system is Windows 10 and the error is :</p>

<pre><code>&lt;!&gt; Error in module (cCompoundModule) RSUExampleScenario (id=1) during network setup: Class ""Veins::ObstacleControl"" not found -- perhaps its code was not linked in, or the class wasn't registered with Register_Class(), or in the case of modules and channels, with Define_Module()/Define_Channel().

TRAPPING on the exception above, due to a debug-on-errors=true configuration option. Is your debugger ready?

Simulation terminated with exit code: -2147483645
Working directory: C:/Simulateur/veins-4a2/veins-veins-4a2/examples/veins
Command line: c:/Simulateur/omnetpp-4.4-src-windows/omnetpp-4.4/bin/opp_run.exe -r 0 -n .;../../src/veins --tkenv-image-path=../../images omnetpp.ini

Environment variables:
OMNETPP_ROOT=c:/Simulateur/omnetpp-4.4-src-windows/omnetpp-4.4
PATH=;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\bin;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\msys\bin;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\mingw\bin;c:/Simulateur/omnetpp-4.4-src-windows/omnetpp-4.4/ide/jre/bin/client;c:/Simulateur/omnetpp-4.4-src-windows/omnetpp-4.4/ide/jre/bin;c:/Simulateur/omnetpp-4.4-src-windows/omnetpp-4.4/ide/jre/lib/i386;.;C:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\msys\local\bin;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\mingw\bin;C:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\msys\bin;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\bin;c:\Windows\system32;c:\Windows;c:\Windows\System32\Wbem;c:\Windows\System32\WindowsPowerShell\v1.0\;c:\Program Files (x86)\ATI Technologies\ATI.ACE\Core-Static;c:\Program Files (x86)\AMD\ATI.ACE\Core-Static;c:\Windows\system32\config\systemprofile\.dnx\bin;c:\Program Files\Microsoft DNX\Dnvm\;c:\Program Files\Microsoft SQL Server\120\Tools\Binn\;c:\Program Files (x86)\Skype\Phone\;c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4;
OMNETPP_IMAGE_PATH=c:\Simulateur\omnetpp-4.4-src-windows\omnetpp-4.4\images
</code></pre>

<p><strong><em>Question</em></strong>: How to link another C++ library, like Crypto++, to my veins project?</p>
","<p>Veins generates a dynamic library of its simulation modules. When using opp_run you will need to tell it to load this library. Otherwise the simulation will not be able to instantiate any of Veins’ modules.</p>

<p>Try doing the Veins tutorial to see what command line parameters OMNeT++ uses to launch the simulation.</p>
","363","<windows><linker><crypto++><omnet++><veins>","-1","1","1","2016-09-30 19:49:15","","2","","608639","","2016-01-23 19:23:55","2016-01-21 17:02:47",""
"27443321","Decrypting data from DefaultEncryptorWithMAC","<p>When using DefaultEncryptorWithMAC in CryptoPP at it's heart it seems to use this Mash Function</p>

<pre><code>// The purpose of this function Mash() is to take an arbitrary length input
// string and *deterministicly* produce an arbitrary length output string such
// that (1) it looks random, (2) no information about the input is
// deducible from it, and (3) it contains as much entropy as it can hold, or
// the amount of entropy in the input string, whichever is smaller.

static void Mash(const byte *in, size_t inLen, byte *out, size_t outLen, int iterations)
{
    if (BytePrecision(outLen) &gt; 2)
        throw InvalidArgument(""Mash: output legnth too large"");

    size_t bufSize = RoundUpToMultipleOf(outLen, (size_t)DefaultHashModule::DIGESTSIZE);
    byte b[2];
    SecByteBlock buf(bufSize);
    SecByteBlock outBuf(bufSize);
    DefaultHashModule hash;

    unsigned int i;
    for(i=0; i&lt;outLen; i+=DefaultHashModule::DIGESTSIZE)
    {
        b[0] = (byte) (i &gt;&gt; 8);
        b[1] = (byte) i;
        hash.Update(b, 2);
        hash.Update(in, inLen);
        hash.Final(outBuf+i);
    }

    while (iterations-- &gt; 1)
    {
        memcpy(buf, outBuf, bufSize);
        for (i=0; i&lt;bufSize; i+=DefaultHashModule::DIGESTSIZE)
        {
            b[0] = (byte) (i &gt;&gt; 8);
            b[1] = (byte) i;
            hash.Update(b, 2);
            hash.Update(buf, bufSize);
            hash.Final(outBuf+i);
        }
    }

    memcpy(out, outBuf, outLen);
}
</code></pre>

<p>According to this page <a href=""http://www.cryptopp.com/wiki/DefaultEncryptorWithMAC"" rel=""nofollow"">http://www.cryptopp.com/wiki/DefaultEncryptorWithMAC</a></p>

<blockquote>
  <p>DefaultEncryptorWithMAC uses 2-key Triple DES as the default
  encryptor, and SHA1 as the default hash for the MAC. The block cipher
  is operated in CBC Mode. The password is mashed rather than derived
  using a Password Based Key Derivation Function. Each run through the
  DefaultEncryptorWithMAC produces a different result due to the use of
  a salt based on time and clock.</p>
</blockquote>

<p>I'm trying to read this encrypted string with another library and am really struggling ie do the equivalent operation of DefaultDecryptorWithMAC (<a href=""http://www.cryptopp.com/wiki/DefaultDecryptorWithMAC"" rel=""nofollow"">http://www.cryptopp.com/wiki/DefaultDecryptorWithMAC</a>)</p>

<p>If I put my secret key through and online SHA1 encrypted I don't get the same result as the Mash function above ?</p>

<p>According to the above webpage it seems to suggest it's using standard encryption techiques I have been unable to decry-pt the result with anything else</p>

<p>Hopefully someone here has experience decrypting the result of these function from this library</p>

<p>Thanks in advance</p>
","<p>From the comments:</p>

<blockquote>
  <p>I obviously know the secret key the whole salt/clock/mashing thing is
  making it almost impossible for me to decrypt a string that has been
  encrypted with the above method.</p>
</blockquote>

<p>If you look at the code for <a href=""http://www.cryptopp.com/docs/ref/class_default_encryptor_with_m_a_c.html"" rel=""nofollow"">DefaultEncryptorWithMAC</a> (<a href=""http://www.cryptopp.com/docs/ref/default_8h_source.html"" rel=""nofollow"">h file</a> and <a href=""http://www.cryptopp.com/docs/ref/default_8cpp_source.html"" rel=""nofollow"">cpp file</a>), you will see that the output has more stuff than just the data encrypted under a mashed password. So its not enough to derive the ""secret key"" in the mash function and key the <code>DES_EDE2</code> cipher and operate it in CBC mode.</p>

<p>Looking at the function <a href=""http://www.cryptopp.com/docs/ref/default_8cpp_source.html"" rel=""nofollow"">DefaultEncryptor::FirstPut</a> (which inherits from <code>ProxyFilter</code>) on line 83, there is preamble written. The preamble is the salt and a key check. So the layout of the encrypted data is:</p>

<pre><code>[SALT][KEYCHECK][ENCRYPTED DATA]
</code></pre>

<p>SALT is calculated based on <code>DefaultHashModule::DIGESTSIZE</code>; but only 8 bytes is written. Then, the KEYCHECK is calculated based on <code>DefaultHashModule::DIGESTSIZE</code>; but only <code>Default_BlockCipher::Encryption::BLOCKSIZE</code> is written.</p>

<p>When it comes time to decrypt, you strip off the salt and use it to re-derive the IV. You strip off the key check and validate the key you derived. Then you key a decryptor with the derived key and iv.</p>
","359","<encryption><crypto++><chilkat>","1","0","1","2014-12-15 07:49:46","","4","","608639","","2014-12-15 07:49:30","2014-12-12 12:06:05",""
"11345088","Encrypt QDataStream with AES","<p>im writing a Qt application on linux (Qt 4.8.1) which writes data byte by byte to a QDataStream object. The data stream goes into a file.
Now i need to encrypt this data with AES-256.
I choose crypto++ lib for this purpose but im struggling with the implementation.</p>

<p>Does anybody know if it is possible at all to encrypt a QDataStream with the given filter classes of crypto++ lib?</p>

<p>greetz 
maggie</p>
","<p>Might be a interesting to reimplement QIODevice, or maybe better QFile... In particular I would reimplement:</p>

<pre><code>virtual qint64 readData(char* data, qint64 maxSize) = 0;
virtual qint64 readLineData(char* data, qint64 maxSize);
virtual qint64 writeData(const char* data, qint64 maxSize) = 0;
</code></pre>

<p>This way you should be able to use QDataStream transparently.</p>
","356","<c++><qt><crypto++>","0","1","1","2012-07-05 18:30:27","","0","","","","","2012-07-05 13:13:33",""
"30006008","AES/GCM with GunZip, cannot decompress correctly","<p><strong>EDIT</strong> I have rephrased the question yet again and provided a MINIMAL working example which can reproduce the bug. </p>

<p>I am trying to use GCM for file encryption. My underlining framework is Qt. Idea is this:</p>

<ol>
<li>load sourceFile e.g. a.jpg</li>
<li>encrypt the file in GCM mode as PDATA</li>
<li>into ADATA store single byte (for now, in real application this will be more with info such as IV, original files name etc.)</li>
<li><p>append ADATA to encrypted file</p></li>
<li><p>load encrypted file and extract ADATA/PDATA/MAC</p></li>
<li>feed this data in correct order to AuthenticatedDecryptionFilter and expect decrypted file to be stored into FileSink</li>
</ol>

<p>I need a loop that goes through the unencrypted file and pumps the file into AuthenticatedEncryptionFilter, as I need to check isAlive for threading purposes in real application. Therefore I cannot use simple pipelining and have to go over data manually in loops.</p>

<p><strong>Now to the problem</strong></p>

<p>Hash Verification fails on the code below (exception is thrown on derypt)</p>

<pre><code>#include &lt;qdebug.h&gt;
#include &lt;CryptoPP/cryptlib.h&gt;
#include &lt;CryptoPP/gcm.h&gt;
#include &lt;CryptoPP/aes.h&gt;
#include &lt;CryptoPP/filters.h&gt;
#include &lt;CryptoPP/files.h&gt;
#include &lt;CryptoPP/gzip.h&gt;
#include &lt;qfile.h&gt;
#include &lt;qfileinfo.h&gt;


using namespace CryptoPP;
using namespace std;
int main(int argc, char *argv[])
{

    byte * key = new byte[16];
    byte * iv = new byte[16];

    memset(key, 0, 16);
    memset(iv, 0, 16);

    const int TAG_SIZE = 16;
    const int BUFFER_SIZE = 4096;

    byte keyLength = 16;
    byte blockSize = 16;

    const char * sourceFileName = ""C:\\Users\\Tomas\\Documents\\Visual Studio 2013\\Projects\\testgcm\\Win32\\Debug\\source.jpg"";
    const char * sourceFileName2 = ""C:\\Users\\Tomas\\Documents\\Visual Studio 2013\\Projects\\testgcm\\Win32\\Debug\\source2.jpg"";
    const char * destFileName = ""C:\\Users\\Tomas\\Documents\\Visual Studio 2013\\Projects\\testgcm\\Win32\\Debug\\source.jpg.enc"";


    try
    {

        GCM&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, keyLength, iv, blockSize);

        AuthenticatedEncryptionFilter ef(e,
            new FileSink(destFileName), false, TAG_SIZE
            ); 

        // AuthenticatedEncryptionFilter::ChannelPut
        //  defines two channels: """" (empty) and ""AAD""
        //   channel """" is encrypted and authenticated
        //   channel ""AAD"" is authenticated


        // this is the block for ADATA
        QByteArray adata;
        adata.append((char)1);

        ef.ChannelPut(""AAD"", (const byte *)adata.data(), adata.size());
        ef.ChannelMessageEnd(""AAD"");

        FileStore fs(sourceFileName);

        int mr = 0;

        while (mr = fs.MaxRetrievable()){
            fs.TransferTo(ef, BUFFER_SIZE,"""");
        }

        ef.ChannelMessageEnd("""");

        // append ADATA to encrypted file

        QFile file(QString::fromStdString(destFileName));
        file.open(QIODevice::Append);

        file.write(adata);

        file.close();

        // HELP: is the encrypted file in this format now? ENC_TEXT||MAC(TAG_SIZE)||HEADER(1)


    }
    catch (CryptoPP::BufferedTransformation::NoChannelSupport&amp; e)
    {
        // The tag must go in to the default channel:
        //  ""unknown: this object doesn't support multiple channels""
        cerr &lt;&lt; ""Caught NoChannelSupport..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch (CryptoPP::AuthenticatedSymmetricCipher::BadState&amp; e)
    {
        // Pushing PDATA before ADATA results in:
        //  ""GMC/AES: Update was called before State_IVSet""
        cerr &lt;&lt; ""Caught BadState..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch (CryptoPP::InvalidArgument&amp; e)
    {
        cerr &lt;&lt; ""Caught InvalidArgument..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }

    // DECRYPTION


    try
    {

        // now extract ADATA and MAC from enc file
        QFile file(QString::fromStdString(destFileName));
        file.open(QIODevice::ReadOnly);
        file.seek(file.size() - 1);

        // ADATA
        QByteArray adata = file.read(1);

        // exract MAC

        file.seek(file.size() - 1 - TAG_SIZE);
        QByteArray mac = file.read(TAG_SIZE);

        GCM&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, keyLength, iv);


        // Object will not throw an exception
        //  during decryption\verification _if_
        //  verification fails.

        AuthenticatedDecryptionFilter df(d, new FileSink(sourceFileName2),
            AuthenticatedDecryptionFilter::MAC_AT_BEGIN |
            AuthenticatedDecryptionFilter::THROW_EXCEPTION, TAG_SIZE);


        df.ChannelPut("""", (const byte*)mac.data(), mac.size());

        // The order of the following calls are important
        df.ChannelPut(""AAD"", (const byte*)adata.data(), adata.size());

        // open enc file
        FileStore fs(destFileName);


        // when we read the file, we dont care for the ADATA and TAG, so we omit it
        int omitSize = (adata.size() + mac.size());

        // max retrievable (for FileStore this is how many bytes are not read yet)
        int mr = 0;

        // get part without tag and footer
        while (((mr = fs.MaxRetrievable()) &gt; omitSize)){
            mr = ((mr - omitSize) &lt; BUFFER_SIZE) ? (mr - omitSize) : BUFFER_SIZE;
            fs.TransferTo(df, mr, """");
        }

        // we pumped teh whole filestore into df. it was supposed to be pumping it to GUnzip and then to FileSink

        // and signal this is all
        df.ChannelMessageEnd(""AAD"");
        df.ChannelMessageEnd("""");


    }
    catch (CryptoPP::InvalidArgument&amp; e)
    {
        cerr &lt;&lt; ""Caught InvalidArgument..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch (CryptoPP::AuthenticatedSymmetricCipher::BadState&amp; e)
    {
        // Pushing PDATA before ADATA results in:
        //  ""GMC/AES: Update was called before State_IVSet""
        cerr &lt;&lt; ""Caught BadState..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }
    catch (CryptoPP::HashVerificationFilter::HashVerificationFailed&amp; e)
    {
        cerr &lt;&lt; ""Caught HashVerificationFailed..."" &lt;&lt; endl;
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        cerr &lt;&lt; endl;
    }




}
</code></pre>

<p>I suspect I am feeding the info into decryptor in a wrong way, but I am following <a href=""http://www.cryptopp.com/wiki/GCM_Mode#AEAD"" rel=""nofollow"">official CryptoPP example</a>.</p>

<p>Please help,
Thanks</p>
","<p>This was trivial in the end. ALWAYS MAKE SURE YOU PASS ivSize into </p>

<pre><code>GCM&lt; AES &gt;::Decryption d;
d.SetKeyWithIV(key, keyLength, iv, blockSize);
</code></pre>

<p>and</p>

<pre><code> GCM&lt; AES &gt;::Encryption e;
 e.SetKeyWithIV(key, keyLength, iv, blockSize);
</code></pre>

<p>even though they are optional. Failure to do so will result in incorrect decryption</p>
","352","<c++><qt><encryption><crypto++><aes-gcm>","1","2","1","2015-05-04 01:48:56","30021473","3","0","4847251","","2015-05-04 01:26:28","2015-05-02 18:33:37",""
"51413024","Passing a key to AES decryption in Crypto++","<p>I have searched a lot for this issue but did not find any solution. In my current project, I have to work on encrypting images with a sender receiver form. So i have to generate a key in the sender part to encrypt the file, and i have to use the same key (which is passed as an argument to the main) to get the original data, to continue program execution. </p>

<p>I save the key on a text file:</p>

<pre><code>   void GetKeyAndIv() {
// Initialize the key and IV
prng.GenerateBlock( key, key.size() );
prng.GenerateBlock(iv, iv.size());
};

    /*********************Begin of the Function***********************/
//Function encrypt a file (original file) and store the result in another file (encrypted_file)
void Encrypt(std::string original_file, std::string encrypted_file_hex,string encrypted_file,string binary) {

    ofstream out;
    out.open(""Key.txt"");
    out.clear();
    out&lt;&lt;""key = ""&lt;&lt; key&lt;&lt;endl;
    out&lt;&lt;""iv = ""&lt;&lt; iv&lt;&lt;endl;

    string cipher, encoded;

    //Getting the encryptor ready
    CBC_Mode&lt; CryptoPP::AES &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), iv );


  try
  {

        ifstream infile(original_file.c_str(), ios::binary);
        ifstream::pos_type size = infile.seekg(0, std::ios_base::end).tellg();
        infile.seekg(0, std::ios_base::beg);

        //read the original file and print it
        string temp;
        temp.resize(size);
        infile.read((char*)temp.data(), temp.size());
        infile.close();


         // Encryption
CryptoPP::StringSource ss( temp, true,
   new CryptoPP::StreamTransformationFilter( e,
      new CryptoPP::StringSink( cipher )//,
      //CryptoPP::BlockPaddingSchemeDef::NO_PADDING
   ) // StreamTransformationFilter
); // StringSource




 std::ofstream outfile1(encrypted_file.c_str(),ios::out | ios::binary);
  outfile1.write(cipher.c_str() , cipher.size());


  }
catch( const CryptoPP::Exception&amp; e )
{

    cout &lt;&lt;""Encryption Error:\n"" &lt;&lt;e.what() &lt;&lt; endl;
    system(""pause"");
    exit(1);
}
</code></pre>

<p>Then i pass it to the client side using the following code:</p>

<pre><code>int main(int argc, char* argv[])
{
.....
        string s1=argv[7];
        SecByteBlock b1(reinterpret_cast&lt;const byte*&gt;(&amp;s1[0]), s1.size());
        string s2=argv[8];
        SecByteBlock iv1(reinterpret_cast&lt;const byte*&gt;(&amp;s2[0]), s2.size());
.....
}
</code></pre>

<p>I got an error while trying to decrypt the file, using the following code</p>

<pre><code>   void Decrypt(std::string encrypted_file,SecByteBlock key,SecByteBlock iv,string decrypted_file) {


        string recovered;
     try
     {
          // Read the encrypted file contents to a string as binary data.
      std::ifstream infile(encrypted_file.c_str(), std::ios::binary);
      const std::string cipher_text((std::istreambuf_iterator&lt;char&gt;(infile)),
                                     std::istreambuf_iterator&lt;char&gt;());
      infile.close();


      CBC_Mode&lt; CryptoPP::AES &gt;::Decryption d;
        d.SetKeyWithIV( key, key.size(), iv );
</code></pre>

<p>Decryption Error:
<strong>StreamTransformationFilter: invalid PKCS #7 block padding found</strong></p>

<p>Which means i have different key during decryption process. Why this happened, and if anyone can help solving this issue.</p>
","<p>It happen if the key used for decryption in not the same as the key that has been used for encryption.</p>

<p>During decryption, in PKCS#7 mode, just after decrypting the last block of 16 bytes, there is a check of padding bytes in order to know the original length of the message (which is not necessary a multiple of 16 bytes) : the last byte should be 0x01, or the last two bytes should be equal to 0x02, or the last three bytes should be equal to 0x03, ... When the decryption key is not the same as the encryption key, the padding bytes are not decrypted correctly and this implies a PKCS#7 block padding error when decrypting.</p>
","348","<c++><encryption><crypto++>","2","0","1","2018-07-22 13:47:11","","3","1","10085404","","2018-07-21 21:21:29","2018-07-19 01:21:23",""
"33198362","Using public key coordinate with Crypto++'s ECDH class","<p>I'm using crypto++ for ECDH key agreement</p>

<pre><code>ECDH.Agree(key, privateKey, outherpublicKey);
</code></pre>

<p>Given that for public key I have only X and Y coordinates. How to generate publicKey from this values ?</p>

<pre><code>ECDH.Agree(key,privateKey, getPublicKey(X,Y))
</code></pre>

<p>Thanks in advance</p>
","<blockquote>
  <p>Given that for public key I have only X and Y coordinates. How to generate publicKey from this values?<br>
  <code>ECDH.Agree(key,privateKey, getPublicKey(X,Y))</code></p>
</blockquote>

<p><code>{x,y}</code> is a point on the curve, but its never been easy to work with it directly.</p>

<p>This is all we really want to do but it does not work. The problem is <code>ECDH::Domain</code> are only domain parameters. The public point and the private exponent are layered on top.</p>

<pre><code>OID curve = ASN1::secp256r1();
DL_GroupParameters_EC&lt;ECP&gt; params(curve);

Integer x(""..."");
Integer y(""..."");
ECP::Point q(x, y);

DL_PublicKey_EC&lt;ECP&gt; pubKey;
pubKey.Initialize(params, q);

ECDH &lt; ECP &gt;::Domain theirs(pubKey);
</code></pre>

<p>To further complicate matters, the keys produced by the ECDH protocol are temporary or ephemeral. They are not meant to be persisted; rather, they are meant to be used once and discarded. So Crypto++ does not make it easy to persist them (by, say, providing a <code>DEREncode</code>).</p>

<p><strong><em>Analysis</em></strong></p>

<p>To use the <code>{x,y}</code> coordinate, we need to figure out how the library is using it. The ephemeral public and private keys are created in <a href=""http://www.cryptopp.com/docs/ref/pubkey_8h_source.html#l01380"" rel=""nofollow""><code>pubkey.h</code></a> around line 1380. The code for them is below:</p>

<pre><code>void GeneratePrivateKey(RandomNumberGenerator &amp;rng, byte *privateKey)
{
    Integer x(rng, Integer::One(), GetAbstractGroupParameters().GetMaxExponent());
    x.Encode(privateKey, PrivateKeyLength());
}

void GeneratePublicKey(RandomNumberGenerator &amp;rng, const byte *privateKey, byte *publicKey)
{
    const DL_GroupParameters&lt;T&gt; &amp;params = GetAbstractGroupParameters();
    Integer x(privateKey, PrivateKeyLength());
    Element y = params.ExponentiateBase(x);
    params.EncodeElement(true, y, publicKey);
}
</code></pre>

<p>The line of interest above is the <code>params.EncodeElement(true, y, publicKey)</code>. To see what's going on there, we need to look at <a href=""http://www.cryptopp.com/docs/ref/eccrypto_8h_source.html#l00061"" rel=""nofollow""><code>eccrypto.h</code></a> around line 70, and note that <code>reversible</code> is <code>true</code>:</p>

<pre><code>void EncodeElement(bool reversible, const Element &amp;element, byte *encoded)
{
    if (reversible)
        GetCurve().EncodePoint(encoded, element, m_compress);
    else
        element.x.Encode(encoded, GetEncodedElementSize(false));
}
</code></pre>

<p><code>params.EncodeElement</code> calls <code>ECP::EncodePoint</code>. To see what that does we can examine <a href=""http://www.cryptopp.com/docs/ref/ecp_8cpp_source.html#l00118"" rel=""nofollow""><code>ecp.cpp</code></a> around line 120. The routine writes a uncompressed point, but blocks <code>x</code> and <code>y</code> on the maximum size of the public element, which should be the field size or the subgroup order.</p>

<pre><code>void ECP::EncodePoint(BufferedTransformation &amp;bt, const Point &amp;P, bool compressed)
{
    if (P.identity)
        NullStore().TransferTo(bt, EncodedPointSize(compressed));
    else if (compressed)
    {
        bt.Put(2 + P.y.GetBit(0));
        P.x.Encode(bt, GetField().MaxElementByteLength());
    }
    else
    {
        unsigned int len = GetField().MaxElementByteLength();
        bt.Put(4);      // uncompressed
        P.x.Encode(bt, len);
        P.y.Encode(bt, len);
    }
}
</code></pre>

<p>Don't worry too much about the <code>BufferedTransformation</code>. There are ways to turn a <code>byte[]</code> into one, and it happened before the code shown above. If you trace the code, you will see its transformed via an <code>ArraySource</code>:</p>

<pre><code>byte myArray[PublicEphemeralKeyLength()];
ArraySource as(myArray, COUNTOF(myArray));
</code></pre>

<p>Above, <code>as</code> is a <code>BufferedTransformation</code> that wraps the <code>byte[]</code> you passed into the function.</p>

<p>The final open question is the maximum size of the field element. That appears to be the modulus size less one, in bytes:</p>

<pre><code>$ grep -I -A 1 MaxElementByteLength modarith.h 
    unsigned int MaxElementByteLength() const
        {return (m_modulus-1).ByteCount();}
</code></pre>

<p><strong><em>Agreement</em></strong></p>

<p>Given the above information, here's what you should do. You need to supply the values for <code>x</code> and <code>y</code> in <code>ECP::Point q(x,y)</code>. They are just Crypto++ Integers.</p>

<pre><code>OID curve = ASN1::secp256r1();
DL_GroupParameters_EC&lt;ECP&gt; params(curve);

size_t size = params.GetEncodedElementSize(true);
vector&lt;byte&gt; othersPublicKey(size);

ECP::Point q(x,y);
params.EncodeElement(true, q, &amp;othersPublicKey[0]);
</code></pre>

<p>Then you can call:</p>

<pre><code>ecdh.Agree(key, myPrivateKey, &amp;othersPublicKey[0]);
</code></pre>

<p>One note: <code>params.GetEncodedElementSize(true)</code> should equal <code>PublicEphemeralKeyLength()</code>. If they are not equal, then something is wrong.</p>

<hr>

<p>If you need to modify compression, then you can:</p>

<pre><code>params.SetPointCompression(true);
</code></pre>

<hr>

<p>I'll get this added to Crypto++'s <a href=""https://cryptopp.com/wiki/Elliptic_Curve_Diffie-Hellman"" rel=""nofollow"">Elliptic Curve Diffie-Hellman</a> wiki page so others don't have to go rummaging for it.</p>
","348","<c++><crypto++><elliptic-curve><diffie-hellman>","1","0","1","2015-10-19 17:46:49","33206001","3","","608639","","2015-10-19 17:46:49","2015-10-18 13:19:28",""
"43665377","TripleDES in CFB mode using Crypto++ and .NET","<p>I am trying to get same result using TripleDES using C++ app which has <a href=""https://www.cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> and .NET app which uses <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.tripledescryptoserviceprovider(v=vs.110).aspx"" rel=""nofollow noreferrer"">TripleDESCryptoServiceProvider</a>. I tried setting Key and IV the same but I am getting different results. </p>

<p>This question was already asked <a href=""https://stackoverflow.com/questions/17112036/tripledes-encoding-in-c-sharp-and-crypto-differs"">here</a>, but there is no clear answer. </p>

<p>Here is C++ example</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;


#include ""dll.h""
#include ""mybase64.h""

using namespace std;

USING_NAMESPACE(CryptoPP)



int main()
{
std::cout &lt;&lt; ""Crypto++ Example"" &lt;&lt; endl;

std:cout &lt;&lt; ""TEST"" &lt;&lt; endl;


const int textSize = 4;
const int keySize = 24; 

byte iv[] = { 240, 4, 37, 12, 167, 153, 233, 177 };
byte key[] = {191, 231, 220, 196, 173, 36, 92, 125, 146, 210, 117, 220, 95, 104, 154, 69, 180, 113, 146, 19, 124, 62, 60, 79};


byte encryptedText[textSize];

char cText[] = {'T', 'E', 'S', 'T'};

byte* text = new byte[textSize];

for (int ndx = 0; ndx&lt;4; ndx++)
{
    text[ndx] = (byte)cText[ndx];
}


CFB_FIPS_Mode&lt;DES_EDE3&gt;::Encryption encryption;

encryption.SetKeyWithIV(key, keySize, iv);

encryption.ProcessString(encryptedText, text, 4);

string encoded;

encoded = base64_encode(encryptedText, 4);

cout &lt;&lt; encoded &lt;&lt; endl;

system(""pause"");

return 0;
 }
</code></pre>

<p>which produces following result: </p>

<pre><code>K3zUUA==
</code></pre>

<p>Here is C# example:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.IO;

namespace TripleDESExample
{
   class Program
   {
       static void Main(string[] args)
       {
           string message = ""TEST"";
           byte[] iv = { 240, 4, 37, 12, 167, 153, 233, 177 };
           byte[] key = { 191, 231, 220, 196, 173, 36, 92, 125, 146, 210, 117, 220, 95, 104, 154, 69, 180, 113, 146, 19, 124, 62, 60, 79 };

           byte[] data = Encoding.ASCII.GetBytes(message);

           using (var tdes = new TripleDESCryptoServiceProvider())
           {
               tdes.Mode = CipherMode.CFB;
               tdes.Padding = PaddingMode.Zeros;

               tdes.IV = iv;
               tdes.Key = key;

               using (var ms = new MemoryStream())
               {
                   using (var crypto = new CryptoStream(ms, tdes.CreateEncryptor(), CryptoStreamMode.Write))
                   {
                       crypto.Write(data, 0, data.Length);
                       crypto.Close();

                    }


                    Array.Copy(ms.ToArray(), data, data.Length);

                    Console.WriteLine(string.Format(""Encrypted: {0}"", Convert.ToBase64String(data)));

               }
           }

           Console.WriteLine(""Press any key..."");
           Console.ReadKey();
       }
   }
 }
</code></pre>

<p>Which produces following result: </p>

<pre><code>K7nXyg==
</code></pre>

<p>So you can see that they produce different result. </p>

<pre><code>K7nXyg==  
K3zUUA==
</code></pre>

<p>Can anyone point what could be the issue for them showing different result. </p>

<p>If possible please provide example code. </p>

<p>---------------------UPDATE 4/27/2017-----------------------------------------</p>

<p>Now tried using a little differently implementation of .NET giving me different result as well... </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Text;
using System.Security.Cryptography;
using System.IO;

namespace TripleDESExample
{
   class Program
   {
       static void Main(string[] args)
       {
           string message = ""TEST"";


        byte[] iv = { 240, 4, 37, 12, 167, 153, 233, 177 };
        byte[] key = { 191, 231, 220, 196, 173, 36, 92, 125, 146, 210, 117, 220, 95, 104, 154, 69, 180, 113, 146, 19, 124, 62, 60, 79 };



        byte[] bytes = Encoding.ASCII.GetBytes(message);

        TripleDESCryptoServiceProvider cryptoServiceProvider1 = new TripleDESCryptoServiceProvider();
        cryptoServiceProvider1.Key = key;
        cryptoServiceProvider1.IV = iv;
        cryptoServiceProvider1.Mode = CipherMode.CFB;
        cryptoServiceProvider1.Padding = PaddingMode.Zeros;
        TripleDESCryptoServiceProvider cryptoServiceProvider2 = cryptoServiceProvider1;


        byte[] inArray = cryptoServiceProvider2.CreateEncryptor().TransformFinalBlock(bytes, 0, bytes.Length);
        cryptoServiceProvider2.Clear();

        Console.WriteLine(string.Format(""Encrypted: {0}"", Convert.ToBase64String(inArray, 0, inArray.Length)));



        Console.WriteLine(""Press any key..."");
        Console.ReadKey();
       }
   }
 }
</code></pre>

<p>which gives me: </p>

<pre><code>K7nXyp+x9kY=
</code></pre>

<p>Why?</p>

<p>------UPDATE 4/28/2017-----------</p>

<p><a href=""https://www.codeproject.com/Articles/21877/Applied-Crypto-Block-Ciphers"" rel=""nofollow noreferrer"">This</a> article describes very well Crypto++ implementation.</p>

<p>When I try to increment BlockSize and FeedbackSize I get following error: </p>

<p><a href=""https://i.stack.imgur.com/LJFdd.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/LJFdd.png"" alt=""enter image description here""></a></p>

<hr>

<p>Based on the discussion <a href=""https://groups.google.com/forum/#!topic/cryptopp-users/ycLWj3Dmdjs"" rel=""nofollow noreferrer"">here</a> it seems like .NET TripleDESCryptoServiceProvider uses CipherMode.CFB in 8-bit while Crypto++ uses it with 128-bit. When trying to set FeedbackSize for .NET higher it throws exception. </p>

<p>Does anyone know how to resolve this issue?</p>
","<p>From the comments:</p>

<blockquote>
  <blockquote>
    <p>The issue is likely the feedback size. I believe .Net uses a small feedback size, like 8-bits, for CFB mode. Crypto++ uses the full block size for CFB mode. I'd recommend getting a baseline using CBC mode. Once you arrive at the same result in .Net and Crypto++, then switch to CFB mode and turn knobs on the feedback size.</p>
  </blockquote>
  
  <p>Do you have example how to accomplish this?</p>
</blockquote>

<p>You can find examples of <a href=""https://www.cryptopp.com/wiki/CBC_Mode"" rel=""nofollow noreferrer"">CBC Mode</a> on the Crypto++ wiki. Other wiki pages of interest may be <a href=""https://www.cryptopp.com/wiki/TripleDES"" rel=""nofollow noreferrer"">TripleDES</a> and <a href=""https://www.cryptopp.com/wiki/CFB_Mode"" rel=""nofollow noreferrer"">CFB Mode</a>.</p>

<p>You can also find test vectors for these modes of operation on the <a href=""http://csrc.nist.gov/groups/STM/cavp/block-ciphers.html"" rel=""nofollow noreferrer"">NIST website</a>.</p>

<p>You really need to get to a baseline. You should not use random messages and random keys and ivs until you achieve your baseline.</p>

<hr>

<p>Here's an example of using a less-than-blocksize feedback size in Crypto++. The example is available at <a href=""https://www.cryptopp.com/wiki/CFB_Mode"" rel=""nofollow noreferrer"">CFB Mode</a> on the Crypto++ wiki (we added it for this answer). You will have to dial in your parameters random parameters (but I suggest you baseline first with something like the NIST test vectors).</p>

<p>You should be wary of using a feedback size that is smaller than the block size because it can reduce the security of the block cipher. If given a choice, you should increase the feedback size for Mcrypt or .Net; and not reduce the feedback size for Crypto++.</p>

<pre><code>SecByteBlock key(AES::DEFAULT_KEYLENGTH), iv(AES::BLOCKSIZE);
memset(key, 0x00, key.size());
memset(iv, 0x00, iv.size());

AlgorithmParameters params = MakeParameters(Name::FeedbackSize(), 1 /*8-bits*/)
                                      (Name::IV(), ConstByteArrayParameter(iv));

string plain = ""CFB Mode Test"";
string cipher, encoded, recovered;

/*********************************\
\*********************************/

try
{
   cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

   CFB_Mode&lt; AES &gt;::Encryption enc;
   enc.SetKey( key, key.size(), params );

   StringSource ss1( plain, true, 
      new StreamTransformationFilter( enc,
         new StringSink( cipher )
      ) // StreamTransformationFilter      
   ); // StringSource
}
catch( CryptoPP::Exception&amp; ex )
{
   cerr &lt;&lt; ex.what() &lt;&lt; endl;
   exit(1);
}

/*********************************\
\*********************************/

// Pretty print cipher text
StringSource ss2( cipher, true,
   new HexEncoder(
      new StringSink( encoded )
   ) // HexEncoder
); // StringSource
cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
   CFB_Mode&lt; AES &gt;::Decryption dec;
   dec.SetKey( key, key.size(), params );

   // The StreamTransformationFilter removes
   //  padding as required.
   StringSource ss3( cipher, true, 
      new StreamTransformationFilter( dec,
         new StringSink( recovered )
      ) // StreamTransformationFilter
   ); // StringSource

   cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
}
catch( CryptoPP::Exception&amp; ex )
{
   cerr &lt;&lt; ex.what() &lt;&lt; endl;
   exit(1);
}
</code></pre>

<p>It produces the following output:</p>

<pre><code>$ ./test.exe
plain text: CFB Mode Test
cipher text: 2506FBCA6F97DC7653B414C291
recovered text: CFB Mode Test
</code></pre>

<hr>

<blockquote>
  <p>So you can see that they produce different result.</p>
  
  <p>K7nXyg==<br>
  K3zUUA==</p>
</blockquote>

<p>The following reproduces <code>K7nXyg==</code>, but its not clear to me that's what you want. You really should get to your baseline. Then you can tell us things like a key with no parity and an 8-bit feedback size.</p>

<pre><code>const byte key[] = { 191, 231, 220, 196, 173, 36, 92, 125,
                     146, 210, 117, 220, 95, 104, 154, 69,
                     180, 113, 146, 19, 124, 62, 60, 79 };
const byte  iv[] = { 240, 4, 37, 12, 167, 153, 233, 177 };

ConstByteArrayParameter cb(iv, sizeof(iv));
AlgorithmParameters params = MakeParameters(Name::FeedbackSize(), 1 /*8-bits*/)
                                           (Name::IV(), ConstByteArrayParameter(iv, sizeof(iv)));

string plain = ""TEST"";
string cipher, encoded, recovered;

/*********************************\
\*********************************/

try
{
   cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

   CFB_Mode&lt; DES_EDE3 &gt;::Encryption enc;
   enc.SetKey( key, sizeof(key), params );

   StringSource ss1( plain, true, 
      new StreamTransformationFilter( enc,
         new StringSink( cipher )
      ) // StreamTransformationFilter      
   ); // StringSource
}
catch( CryptoPP::Exception&amp; ex )
{
   cerr &lt;&lt; ex.what() &lt;&lt; endl;
   exit(1);
}

/*********************************\
\*********************************/

// Pretty print cipher text
StringSource ss2( cipher, true,
   new Base64Encoder(
      new StringSink( encoded )
   ) // HexEncoder
); // StringSource
cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
   CFB_Mode&lt; DES_EDE3 &gt;::Decryption dec;
   dec.SetKey( key, sizeof(key), params );

   // The StreamTransformationFilter removes
   //  padding as required.
   StringSource ss3( cipher, true, 
      new StreamTransformationFilter( dec,
         new StringSink( recovered )
      ) // StreamTransformationFilter
   ); // StringSource

   cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
}
catch( CryptoPP::Exception&amp; ex )
{
   cerr &lt;&lt; ex.what() &lt;&lt; endl;
   exit(1);
}
</code></pre>
","346","<c#><c++><.net><crypto++><tripledes>","2","1","1","2017-05-07 19:11:49","","4","","-1","","2017-05-23 12:26:15","2017-04-27 18:25:52",""
"32805772","How to change the include file path with autotools?","<p>I am developing a simple chat application, which use crypto++, in ubuntu. The folder for crypto++'s header files is <code>/usr/include/crypto++/</code>. </p>

<p>After I upload the source tagbar to <code>CentOS</code>, I found that the folder for crypto++'s header files is <code>/usr/include/cryptopp</code>. So in <code>CentOS</code>, the compiler could not find the head files for <code>cryptopp</code>.</p>

<p>Source File:</p>

<pre><code>#include ""crypto++/md5.h""
</code></pre>

<p>Configure.ac:</p>

<pre><code>AC_SEARCH_LIBS([_ZTIN8CryptoPP14CBC_EncryptionE], [crypto++ cryptopp], 
        [],[AC_MSG_ERROR([avchat requires crypto++/cryptopp])])
</code></pre>

<p>How to make the source bundle portable both on ubuntu and centos?</p>
","","345","<autotools><crypto++>","3","","0","2015-09-27 07:57:07","","6","","","","","2015-09-27 07:57:07",""
"27385456","AES padding and writing the ciphertext to a disk file","<p>I have a string which I encrypt with the following mehtod in C++ using Crypto++:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::ifstream t(filename); //File to be encrypt
std::stringstream buffer;
buffer &lt;&lt; t.rdbuf();

ofstream combined_file2(filename2); //Encrypted file
combined_file2 &lt;&lt; encrypt(buffer.str());

string encrypt(string data)
{
  // Key and IV setup
  std::string key = ""0123456789abcdef"";
  std::string iv = ""aaaaaaaaaaaaaaaa"";

  //Alternative
  //byte key[CryptoPP::AES::DEFAULT_KEYLENGTH], iv[CryptoPP::AES::BLOCKSIZE];
  //memset(key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH);
  //memset(iv, 0x00, CryptoPP::AES::BLOCKSIZE);

  std::string plaintext = data;
  std::string ciphertext;

  // Create Cipher Text
  CryptoPP::AES::Encryption aesEncryption((byte *)key.c_str(), CryptoPP::AES::DEFAULT_KEYLENGTH);
  CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, (byte *)iv.c_str());

  //Alternative
  //CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
  //CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

  CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext));
  stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()), plaintext.length() + 1);
  stfEncryptor.MessageEnd();

  return ciphertext;
}
</code></pre>

<p>When I try to decrypt the file in my C# Application, I get the message, that the length of the data is invalid. I think that the lenght of th byte array isn't a multiple of 16, so I get the error. I try to use a padding, but it is not working right.</p>

<p>Here is how I decrypt the file:</p>

<pre class=""lang-cs prettyprint-override""><code>string plaintext = Decrypt(File.ReadAllBytes(path));

private static string Decrypt(byte[] cipherText)
{
   if (cipherText == null || cipherText.Length &lt;= 0)
       throw new ArgumentNullException(""cipherText"");
   byte[] Key = GetBytes(ConfigurationManager.AppSettings[""aes_key""]);
   byte[] IV = GetBytes(ConfigurationManager.AppSettings[""aes_iv""]);

   // Declare the string used to hold the decrypted text.
   string plaintext = null;

   // Create an RijndaelManaged object with the specified key and IV.
   using (RijndaelManaged rijAlg = new RijndaelManaged())
   {
     rijAlg.Key = Key;
     //rijAlg.IV = IV;
     //for testing                
     rijAlg.IV = new byte[] { 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97 };

    // Create a decrytor to perform the stream transform.
    ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV);

    // Create the streams used for decryption.
    using (MemoryStream msDecrypt = new MemoryStream(cipherText))
    {
      using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
      {
        using (StreamReader srDecrypt = new StreamReader(csDecrypt))
        {
          // Read the decrypted bytes from the decrypting stream
          // and place them in a string.
          plaintext = srDecrypt.ReadToEnd();
        }
      }
    }
  }
  return plaintext;
}
</code></pre>

<p>How can I solve the problem? Is there any function to do the padding, or maybe padding is the wrong way?</p>
","<p>Based on the comment:</p>

<blockquote>
  <p>In C++ I save a file combined_file2 &lt;&lt; encrypt(buffer.str()); which I
  read in my C# program string plaintext =
  Decrypt(File.ReadAllBytes(path));</p>
</blockquote>

<p>I don't think embedded NULLs is causing problems from the <code>encrypt</code> function since its returning a <code>string</code>, and that includes an explicit length.</p>

<p>However, an embedded NULL and the way the file is being written to disk in C++ (or read from disk in C#) will be a problem since this will stop at the first embedded NULL: <code>combined_file2 &lt;&lt; encrypt(buffer.str())</code>.</p>

<p>Perhaps something like the following would be helpful:</p>

<pre><code>StringSource ss(ciphertext, true /*pumpAll*/);
FileSink fs(""my-encrypted-file.bin"", true /*binary*/);
ss.TransferTo(fs);
</code></pre>

<p>If you are using a C++ stream, then use the <code>write</code> method on the stream object:</p>

<pre><code>ofstream combined_file2;
...
combined_file2.write(ciphertext.data(), ciphertext.size());
</code></pre>
","345","<c#><c++><encryption><padding><crypto++>","2","0","1","2014-12-15 01:05:59","","9","","608639","","2014-12-13 00:11:22","2014-12-09 17:49:10",""
"54943628","How to install Crypto++ in Visual Studio 2017","<p>Any guides are all for Visial Studio 2015 or lower, I've tried following them but I haven't really gotten anywhere. I read the latest version of Crypto++ has been ported to work with Visual Studio 2017 so it should be possible. How shall I go about this?</p>

<p>The reason for me needing this is because I believe it's the easiest way to implement AES 128 bit. Is there a better (easier) way with the default libraries?</p>
","","345","<c++><visual-studio><visual-studio-2017><c++17><crypto++>","1","","0","2019-03-01 11:22:16","","10","","","","","2019-03-01 11:22:16",""
"3936354","Crypto++ linker error using ANT","<p>I am trying to reverse engineer a previous employee's build process for some custom software he wrote for us. I've seen to get everything to compile okay, but I get an error in the linking process that points to a problem with crypto++. Any clues?</p>

<pre><code>compile.util:

compile:
     [echo] Compiling: util
       [cc] Starting dependency analysis for 55 files.
       [cc] 55 files are up to date.
       [cc] 0 files to be recompiled from dependency analysis.
       [cc] 0 total files to be compiled.

link.util:

link:
     [echo] Linking shared library: libutil
       [cc] 0 total files to be compiled.
       [cc] Starting link
       [cc] /usr/bin/ld: /home/john/softwarename/thirdparty/crypto/5.6.1_64/libcryptopp.a(cryptlib.o): relocation R_X86_64_32 against `CryptoPP::DEFAULT_CHANNEL' can not be used when making a shared object; recompile with -fPIC
       [cc] /home/john/softwarename/thirdparty/crypto/5.6.1_64/libcryptopp.a: could not read symbols: Bad value
       [cc] collect2: ld returned 1 exit status

BUILD FAILED
/home/john/softwarename/build/build.xml:167: Following error occured while executing this line
/home/john/softwarename/build/link.xml:27: gcc failed with return code 1
</code></pre>

<p>Os is Fedora 11</p>
","<p>Every object file you link into a shared library must be position independent, meaning the loader can move it wherever it wants in memory and it will still work.  Your crypto library was not compiled that way, hence the admonition to recompile it with <code>-fPIC</code> added to your compile flags.  Alternately, you can make libutil a static library instead of a shared one.  Without more details on your build files, I can't provide more details on how to do that or which one to choose.</p>
","342","<ant><fedora><linker-errors><crypto++><fedora11>","1","1","1","2010-10-14 19:05:17","","0","","","","","2010-10-14 18:30:59",""
"49353664","Generate random prime via Crypto++","<p>I'm trying to generate random prime of given bitlength (4000b), by using <code>GenerateRandom</code> and <code>FirstPrime</code>, but I cannot find how to use function <code>FirstPrime</code>, only signature. Result is always <code>0</code>. First attempt was using <code>PrimeAndGenerator</code> - it's working but it's too slow.</p>

<pre><code>...

r.GenerateRandom(rng, params)

...

const int PrimeSelector *pSelector = params.GetValueWithDefault(Name::PointerToPrimeSelector(), (const PrimeSelector *)NULL);

Integer equiv = params.GetValueWithDefaul(""EquivalentTo"", Integer::Zero());

FirstPrime(p, 2*r, equiv, 2*r, pSelector);
</code></pre>

<p>Thanks for help with <code>FirstPrime</code>.</p>
","<blockquote>
  <p>I'm trying to generate random prime of given bit length ... using <code>GenerateRandom</code></p>
</blockquote>

<p>This is probably about the simplest method. It finds primes without a special form. You have to do other things if you want Sophie-Germain primes or other types of prime numbers.</p>

<pre><code>$ cat test.cxx
#include ""integer.h""
#include ""osrng.h""
#include ""nbtheory.h""
#include ""hrtimer.h""
#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    ThreadUserTimer timer;
    AutoSeededRandomPool prng;
    Integer x;

    timer.StartTimer();

    do {
        x.Randomize(prng, 4096);
    } while(!IsPrime(x));

    double t = timer.ElapsedTimeAsDouble();
    std::cout &lt;&lt; ""Time: "" &lt;&lt; t &lt;&lt; "" seconds"" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<hr>

<p>Here is a more complete example using Crypto++'s <a href=""https://www.cryptopp.com/wiki/NameValuePairs"" rel=""nofollow noreferrer""><code>NameValuePairs</code></a>. The Names of parameters, like <em><code>""BitLength""</code></em>, come from <code>Integer</code> class and <code>GenerateRandomNoThrow</code> function. <code>GenerateRandomNoThrow</code> is what all the generate methods get routed to.</p>

<pre><code>$ cat test.cxx
#include ""integer.h""
#include ""osrng.h""
#include ""hrtimer.h""
#include ""algparam.h""
#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    Integer x;
    ThreadUserTimer timer;
    AutoSeededRandomPool prng;

    AlgorithmParameters params = MakeParameters(""BitLength"", 4096)
        (""RandomNumberType"", Integer::PRIME);

    timer.StartTimer();
    x.GenerateRandom(prng, params);    
    double t = timer.ElapsedTimeAsDouble();

    std::cout &lt;&lt; ""Time: "" &lt;&lt; t &lt;&lt; "" seconds"" &lt;&lt; std::endl;
    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<hr>

<p>Finally, if you include <a href=""https://www.cryptopp.com/docs/ref/nbtheory_8h.html"" rel=""nofollow noreferrer""><code>&lt;cryptopp/nbtheory.h&gt;</code></a>, then you can use:</p>

<pre><code>/// \brief Generates a provable prime
/// \param rng a RandomNumberGenerator to produce keying material
/// \param bits the number of bits in the prime number
/// \returns Integer() meeting Maurer's tests for primality
Integer MaurerProvablePrime(RandomNumberGenerator &amp;rng, unsigned int bits);

/// \brief Generates a provable prime
/// \param rng a RandomNumberGenerator to produce keying material
/// \param bits the number of bits in the prime number
/// \returns Integer() meeting Mihailescu's tests for primality
/// \details Mihailescu's methods performs a search using algorithmic progressions.
Integer MihailescuProvablePrime(RandomNumberGenerator &amp;rng, unsigned int bits);
</code></pre>

<p>And:</p>

<pre><code>/// \brief Finds a random prime of special form
/// \param p an Integer reference to receive the prime
/// \param max the maximum value
/// \param equiv the equivalence class based on the parameter mod
/// \param mod the modulus used to reduce the equivalence class
/// \param pSelector pointer to a PrimeSelector function for the application to signal suitability
/// \returns true if and only if FirstPrime() finds a prime and returns the prime through p. If FirstPrime()
///   returns false, then no such prime exists and the value of p is undefined
/// \details FirstPrime() uses a fast sieve to find the first probable prime
///   in &lt;tt&gt;{x | p&lt;=x&lt;=max and x%mod==equiv}&lt;/tt&gt;
bool FirstPrime(Integer &amp;p, const Integer &amp;max, const Integer &amp;equiv, const Integer &amp;mod, const PrimeSelector *pSelector);
</code></pre>

<hr>

<blockquote>
  <p>First attempt was using PrimeAndGenerator - it's working but it's too slow.</p>
</blockquote>

<p>It is all relative... You should be finding primes with a complexity of about <em><code>log(N) / N</code></em>.</p>

<p>Below are two timings from a Core i5 Skylake running at 3.1 GHz. It is one of the faster machines I use for testing.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Time: 2.87 seconds
ef55559d8b53a21e566b3d814232fe6d159757a2f6133a6a9ee914ef86b8c0f599dee12672bb3004
484c946fd8e2b32e143ef76ccfd850061cf6545b116709fe35d5a5c0ac9ae793e23439db79ee5202
c5a5d443660fd3e119bfb224a5e8481f0f364871d0f5d78894675d98e755dcf1401b76f6271936b8
b7d4b0d5568590e3be893e3394ac145421dba1127d4cf954ee80ec2de7cd738e1ea439884a141923
06c60c1cd929694404477b6dbb4d71bda24a0ac57cfca0c8e1efa669ab153a89f8f1609556783864
db975ccd9bdfe41c28c5e364306187ee1ad73f8afb1fce1a62ac62e275e77e1575a834424c0bca2f
b2f088b08657ca71ee12895826be19b9eb7b007a0a539e4f8600e564459611d9e0b5691a7972986a
57812bf685be369ba6976e4971cbdaa0dd9110d50ba815141b02462a41b6c7f3e768fb774043033d
e49cf814eaa38acd5139c0cff1451ad504f84104e198e7186b35e2c4d7abffdb559863933fe420d2
3df9dbf9160331d3d67efa7f5ddd1361f7aac6a153b449d0747016e6f0b9bdda8fea3561daf5e8ed
5b1202ad47100c0f6fa49a8e33145b7e7519c67c55ea0c023d58dfec159cf15a72972b16c368cb36
f213a24c7c298cd70cb385b7b486e42f4e3765d727b6ca82147dde069970ed7c0ba06404191b2683
8b40c11c720e465fa9eb72aac4f4abe4c683e5a6d7d570b9c3febf538cbee637h

$ ./test.exe
Time: 0.36 seconds
2533da252e2b55e18438307a507fca9046752e10a05a0819a1a19a8aff44c88f4a85d5e93b4b4e8d
e95e7ec34c2dd2add51b315d307e61cd126620618179c5e65e1a86fb62a8c8dda256cf6dee34b36e
a4953e03b4d5c7510043654bda8ace21f91ac8cfde6f498c3fad2bcdb07ca80ae66fe728cf7b0a08
bf94acae1784e4a8d518a6fe184ba3f75569d8a03dcb2c8281a7df047e6731a1ae33d95cf6e54260
84c33ae61e5c1adc09add84e5a771062af78aa0d91bd14bd6c953c8c4e64faf9bbaef5c619e01bd0
663f446a647a3de78ffb2c82c31cdaac33f8709cadb864e6d3be8d2163086c3e4aa7c079f6c8689f
0fd9f93f1723fc23abaa9d2afdc8bc98b14b58fb1cbdca1fa9872f7d4a540296634bea90a8a209ef
50f71313a4c623a13161cd89be2c6d0cee543ed9e337bab428bcf841ef66194e99c382c7f1aa08ab
ab1934b96773fc405f68449a104b20a60d4772415a199d40b84350bf8a2e54a86f8327c6842f3f4a
47de313deda74fe0ad8a5652ea54761c905f52862d3a24e07f59de2d1fa713c0e55a74b478507754
3599c3c1f8c1346bce1f56d7eabc17155a85e93b3ad94ba6435aa18d6787292ae5eeba816516613d
855b7eea13807585ec9f0ad2eab13bff34e9324059c67ece8bc1db0b07b3bfb7979b62dc5261ebb8
a53c3782b8da8633d52c01847d773f1b62dbb416a910b03862df81d1c5ecc1ddh
</code></pre>

<p>Below are two timings from a Celeron J3455 running at 1.5 GHz. It is one of the lower performing but modern machines I use for testing.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Time: 11.94
ae7fb4fa8ca52292e59a636de9d7a7f72082180e2859548a18259773901798fba67ff188aa49e8b7
1bf31978d19f796764c5a57708c56af7468c2994b5ecb02abab34e7f31749bbe937955664561c679
fc03fbb32a526a4689d7eb96019d14865320928f6eeaf7d2db3e22f6db6a1c027ba5a0726e2000ea
0e43b3ca0f7fa53f5e1227eeed38519493e56da2540c6bad0e76a7b3ea50931d4f0b17694cb310c9
2979024be0eb0336eafde548b4d7b34f30d17df6f6129c2379526eadc0167056c9fc0cac6b6ebf19
0aea8963ff16463b8d8acbf751e0261f1f755eac4a24814047450b6dcb7f845005f1c9d42a5f8579
91b180e3991e0cc2a0e7ee0b0ed5781b6ec8007bd80525ecae0b5114ff6bb8bedae92cf7a26bfd97
8451217cf316e7fcfa5bee85550381b351e0e7657a1e8e4e78d850ffc75f24d096f12a6be4060781
fc6fdcbf079e8fdb6177af82aa9f37d13cf9f43f92df3bb460c40c25d2012104ab6097a84ddf34fe
7d952f665da49b52b31b7c5479f833f184928044216f7cf453a06f0963ad78ec31460acb52b7c128
d7182c68a8e81cbde2a04d67fb728ec859ca76da4b6bcab4f97a3921a997b5431a1483b9076c8cb4
1d1f39f96c0aa991778a086a2866e196b4612c6cffe8214a2d6d448d6d2d0177e8a5f4cbe13b71d7
95afb5322228d648d649aa8ed1dd7fd9ae160ee9944fc6d67563fd482ab8673h

$ ./test.exe
Time: 0.22
5be555fef0060fb14b4d3991e16767bb5ad674f65cd43b437e258716a3a096184488107015fba0d2
56460a756245d267522afdfbc6a6eb3ad111a5d802cd6a524b0f9f171b07587969ec48cc6cc02e1d
0a3b88787e260e182dfb0f8dc14bb728cf0bbdefc88c5f357d883ea935e9b13809f8e781aa54ee99
3ec0331974616848480edcf82455c7e69161a02be060bc900997b4e19c21b28b69bf23820317420d
fe860ce88f889ef4d9e70659861cd9926925b993bea33687a3a7289ec8a2ff4cc81387b8756f33b1
9172136586d35b348801b202669a5dc8dc519ba27c6ee49da9703c3c6757ce2a8c8d1b46ce526158
701397151b6a4a70137e982fbd2ab1995edd300cb0347d60293fcfea05f3df048d8cc88c229bfd7d
913eb124bfd167bc38441810d145eb658a7f924c607194b1d8916055139b20f09485b676f22eaca8
4aa812d51d78fb3c87b36e6b134c58009b5729a4df3ca96083df3882f9d88ba6d557df1c398cf0c3
f4ea2b9f1f61a749f602e589d97e784009fdd0b267cdda26b3914324e15dc3efca2372951fdab4f9
8c4546668f095171e0d84623604ef311faa828083dc0a5fe41e3bb4b61f1f7ac475524117e5a36cc
2062e4308d549e9efb57df0be94c4772bb72c938e4f89b5d48103c8f8cc9757dedbc66248eb5ea48
68ea792107451952571d07879e3faf2416dde7070fb18b1bf13a4ea986a2e735h
</code></pre>
","339","<c++><primes><crypto++>","0","1","1","2018-03-26 21:01:41","","1","","6190930","","2018-03-19 00:50:14","2018-03-18 22:56:38",""
"23318355","Running compiled code on another machine crash (mingw-w64 32 and 64 bit toolchain ) cryptopp","<p>I have one problem that I can't understand.</p>

<p>First I am making program that is using Crypto++ for RSA. I have separated toolchain for 32bit and 64bit mingw-w64. So I downloaded cryptopp source and build it for 2 times for 32 bit and 64bit and copied lib and include files. I used default make...</p>

<p>So I have compile my code and with static libraries and when I run it on machine that is compiled,32bit and 64bit works ok. But When I copy it to another machine XP 64bit or Win7 32bit it crash on runtime. On Win7 I use only 32bit and on XP I use 32 and 64.</p>

<p>I was searching for a while and found that it crash on this code:</p>

<pre><code>StringSource ss1(message, true,
        new SignerFilter(rng, signer,
            new StringSink(signature)
       )
    );
</code></pre>

<p>But running only this it doesn't crash.</p>

<pre><code>new SignerFilter(rng, signer,
                new StringSink(signature)
           )
</code></pre>

<p>Does anyone have a clue what can it be?</p>

<p>This is my test code</p>

<pre><code>AutoSeededRandomPool rng;

string privKey, privKey_Base64 = 
""MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAMm4ybhUat8MwkHwWxwEFQ/7\
0wsJIT+Y3sIUFhwF8BslsJrhkTYYbhMYM9gHi/T5Y0m75h4jXesZNgfv0SUie1/6aWe61eZG\
bCMUgWh/6+onNtQOiJV88VgxBJG45OOinlG3l7NJpZZukiEXNqlv4dj2mWLgt6cIC8Gz2QQh\
cb9zAgERAoGANWWezukrWSkGPqGBh2p+C8KozjcfY6h3M1+rf+N0Q2vb7MM9Bso7QUor101K\
scmLOSo1YlSn62iOTWUgxhCoL4WbZK2UDxrMhdtEV+i4jtkopceJF6x5XBOBYdKPjEbJxd2m\
FPMBxA8NaI4D+WdSGCrzCSmAAp/A1qHFJZErdXkCQQD7P7htvv3slqYQMJZB+BLVMnE7TNOY\
YLCxbAVRTM70pvE/sn9DwXQEJQcOTavv6hr1AU0OC70KtYxQDo5eN7ppAkEAzYlPaAQEn0Kf\
x/lNQI/0j2rUGlJMA6m9bsw3TCR0hhmRa3HIb912o1bkYi9PTvp/JnO6UlaKvkTRq1N2EJXX\
ewJBAN2wsco/HEk5oZXQhJSPmCWG3GGABf7r5zMjE8A0tpuiXGVhQx2qsalN2Qye4wDdn1Cm\
y4TdLlS+TqD9yOm4s4kCQQC1WwnUP8fX0V/OkK2TUdfJ1rsmSJ1spNRStDDKtsErB4BPvr/q\
O+EmthTPGq9jzfe4hDr9W2tclxNa70oOolS3AkEA7qZDM0BHALxK/2Q6lU2zpjfh1gUxLAlg\
OGyIGTafq1o0y2b5HGrmwVYQAGaUPlBLVRLRBxhL+kXnSzXhTR1xRA==\
"";

CryptoPP::StringSource tasdst(privKey_Base64, true, new CryptoPP::Base64Decoder(new CryptoPP::StringSink(privKey)));

string pubKey, pubKey_Base64 =
""MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQDJuMm4VGrfDMJB8FscBBUP+9MLCSE/mN7C\
FBYcBfAbJbCa4ZE2GG4TGDPYB4v0+WNJu+YeI13rGTYH79ElIntf+mlnutXmRmwjFIFof+vq\
JzbUDoiVfPFYMQSRuOTjop5Rt5ezSaWWbpIhFzapb+HY9pli4LenCAvBs9kEIXG/cwIBEQ==\
"";

CryptoPP::StringSource tasdst2(pubKey_Base64, true, new CryptoPP::Base64Decoder(new CryptoPP::StringSink(pubKey)));

RSA::PrivateKey privateKey;
char const *a = privKey.c_str();
size_t dataLen = privKey.size();
privateKey.Load(CryptoPP::StringStore((const byte*)a,(size_t)dataLen).Ref());

RSA::PublicKey publicKey;
char const *b = pubKey.c_str();
dataLen = pubKey.size();
publicKey.Load(CryptoPP::StringStore((const byte*)b,(size_t)dataLen).Ref());

string message = ""RSA Signature"", signature;
std::cout &lt;&lt; message &lt;&lt; std::endl;

RSASSA_PKCS1v15_SHA_Signer signer(privateKey);

StringSource ss1(message, true,
    new SignerFilter(rng, signer,
        new StringSink(signature)
    )
);

string encoded, decoded;

CryptoPP::StringSource(signature, true, new CryptoPP::Base64Encoder(new CryptoPP::StringSink(encoded)));

CryptoPP::StringSource tasdst3(encoded, true, new CryptoPP::Base64Decoder(new CryptoPP::StringSink(decoded)));

RSASSA_PKCS1v15_SHA_Verifier verifier(publicKey);
StringSource ss2(message+decoded, true,
    new SignatureVerificationFilter(
        verifier, NULL,
        SignatureVerificationFilter::THROW_EXCEPTION
    )
);
</code></pre>
","<p>After just a little looking around. I found out that there is problem with building libcryptopp and just a few lines of code fixed symptoms that was before.</p>

<p>Here is what to change in GNUmakefile:
<a href=""https://sites.google.com/site/ievgensychov/cryptopp"" rel=""nofollow"">https://sites.google.com/site/ievgensychov/cryptopp</a></p>

<p>Yes, problem is solved.</p>
","334","<crypto++><cross-compiling><mingw-w64>","1","0","1","2014-04-29 07:31:51","","2","","608639","","2014-04-27 09:05:16","2014-04-27 01:27:28",""
"48515103","Encrypting files with crypto++ using RSA","<p>I wanted to encrypt a large binary file using crypto++ library with asymmetric encryption(RSA) algorithm. I have searched for working example and couldn't find it. 
Is it possible? What kind of things should i consider when i implement it using this library</p>
","","332","<c++><windows><encryption><crypto++>","0","","0","2018-01-30 06:21:13","","4","","","","","2018-01-30 06:21:13",""
"45430213","Headers not found when using Qt5 and Crypto++","<p>I have compiled and tried to link the cryptopp library to my .pro file but I get this error: </p>

<pre><code>error: 'cryptopp/aes.h' file not found
#include &lt;cryptopp/aes.h&gt;
</code></pre>

<p>Below is my .pro file:</p>

<pre><code>QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = Journal
TEMPLATE = app
DEFINES += QT_DEPRECATED_WARNINGS
LIBS += -L/usr/local/lib/libcryptopp.a -lcryptopp
CONFIG += console c++11

SOURCES += \
        main.cpp \
        mainwindow.cpp \
    encrypt.cpp

HEADERS += \
        mainwindow.h \
    filesio.h \
    encrypt.h

FORMS += \
        mainwindow.ui
</code></pre>

<p>How could I resolve this error?
Thanks</p>
","<p>As suggested by vahancho, you need to add below line in you qmake project file.</p>

<blockquote>
  <p>INCLUDEPATH += path to parent directory of 'cryptopp'</p>
</blockquote>
","332","<c++><qt><crypto++>","0","1","1","2017-08-02 01:14:44","45435436","6","","608639","","2017-08-02 01:14:44","2017-08-01 06:16:23",""
"43419366","Encryption with Crypto++/AES CFB not working","<p>I have a simple console program that should encrypt files with AES CFB algorithm from Crypto++ library. For some reason it is not working. Encoding part:</p>

<pre><code>byte data[16] = { 0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44,
                  0x88, 0x44, 0x88, 0x44, 
                  0x88, 0x44, 0x88, 0x44 };

byte result[16] = { 0x88, 0x44, 0x88, 0x44,
                    0x88, 0x44, 0x88, 0x44,
                    0x88, 0x44, 0x88, 0x44, 
                    0x88, 0x44, 0x88, 0x44 };

//Sample key
byte key[16] = { 0x88, 0x44, 0x88, 0x44,
                 0x88, 0x44, 0x88, 0x44,
                 0x88, 0x44, 0x88, 0x44, 
                 0x88, 0x44, 0x88, 0x44 };

//Generate random Initialization Vector
byte iv[16];
CryptoPP::AutoSeededRandomPool rnd;
rnd.GenerateBlock(iv, CryptoPP::AES::BLOCKSIZE /*16*/);

//Through VisualStudio debug/watch functionality I have found out that
//Crypto++ randomizer works properly so at this point ""iv"" contains random values

CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption tmp(key, 16, iv, 1);
tmp.ProcessData(data, result, 16);
</code></pre>

<p>The problem is that when this code completes <code>result</code> is supposed to be filled with cyphertext but it just remains filled with <code>px88</code> and <code>0x44</code>. <br/><br/>
I was guided by this official tutorial: <a href=""https://www.cryptopp.com/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Advanced_Encryption_Standard</a></p>
","<p><code>ProcessData</code> is <code>outstring</code>, then <code>instring</code> then length. You've switched the input and output parameters <code>data</code> &amp; <code>result</code> (most API's would put output parameters last in their method declarations, so this could explain the mistake).</p>
","329","<c++><encryption><aes><crypto++>","-1","3","1","2017-04-21 06:16:56","43420608","3","","","","","2017-04-14 21:15:05",""
"32832661","Use ECDH key with ECIES","<p>In Crypto++, I'm trying to use a public key generated by ECDH to encrypt a message with ECIES. Is that possible? The key is stored in a SecByteBlock. I've tried two options: 1) reading the bytes directly via StringSource; 2) creating an Integer and encoding it to BER, then trying to decode it in the public key. None of these options worked, both generate a BER format exception.</p>

<p>What might I be doing wrong? Is there any other way to set the ECIES encryptor public key's bytes directly?</p>

<p>Thanks!</p>
","<p>For anyone wondering, what I was actually trying to do was this... Suppose that at some point a key pair was generated in the following way:</p>

<pre><code>ECDH&lt;ECP&gt;::Domain domain(some_curve);
SecByteBlock prv(domain.PrivateKeyLength()), pub(domain.PublicKeyLength());
domain.GenerateKeyPair(AutoSeededRandomPool(), prv, pub);
</code></pre>

<p>Later, given just the raw (bytes) representation, if you need to load these keys for encryption, you could do:</p>

<pre><code>auto&amp; params = domain.GetGroupParameters();
ECIES&lt;ECP&gt;::PrivateKey prv_key;
ECIES&lt;ECP&gt;::PublicKey pub_key;
prv_key.Initialize(params, Integer(prv.begin(), prv.size());
pub_key.Initialize(params, params.DecodeElement(pub, true));
</code></pre>

<p>And then create Encryptor/Decryptor as needed:</p>

<pre><code>ECIES&lt;ECP&gt;::Encryptor encptor(pub_key);
ECIES&lt;ECP&gt;::Decryptor decptor(prv_key);
</code></pre>

<p>Anyway, thanks for the help in the comments, it put me in the right direction to find the answer!</p>
","326","<crypto++>","0","2","1","2015-09-30 03:07:24","","3","","608639","","2015-09-30 03:07:24","2015-09-28 22:13:55",""
"6661633","Advice about the Encryption Method I should Use","<p>Ok, so I need some advice on which encryption method I should use for my current project. All the questions about this subject on here are to do with networking and passing encrypted data from one machine to another.</p>

<p>A brief summary of how the system works is:</p>

<p><em>I have some data that is held in tables that are in text format. I then use a tool to parse this data and serialize it to a dat file. This works fine but I need to encrypt this data as it will be stored with the application in a public place. The data wont be sent anywhere it is simply read by the application. I just need it to be encrypted so that if it were to fall into the wrong hands, it would not be possible to read the data.</em></p>

<p>I am using the crypto++ library for my encryption and I have read that it can perform most types of encryption algorithms. I have noticed however that most algorithms use a public and private key to encrypt/decrypt the data. This would mean I would have to store the private key with the data which seems counter intuitive to me. Are there any ways that I can perform the encryption without storing a private key with the data?</p>
","<p>I see no reason to use asymmetric crypto in your case. I see two decent solutions depending on the availability of internet access:</p>

<ol>
<li>Store the key on a server. Only if the user of the program logs in to the server he gets back the key to his local storage.</li>
<li>Use a Key-Derivation-Function such as PBKDF2 to derive the key from a password.</li>
</ol>

<p>Of course all of this fails if the attacker is patient and installs a keylogger and waits until you access the files the next time. There is no way to secure your data once your machine has been compromised.</p>
","326","<c++><encryption><crypto++>","3","4","5","2011-07-12 12:48:31","6661740","1","","46642","","2011-07-12 10:13:09","2011-07-12 08:51:06",""
"6661633","Advice about the Encryption Method I should Use","<p>Ok, so I need some advice on which encryption method I should use for my current project. All the questions about this subject on here are to do with networking and passing encrypted data from one machine to another.</p>

<p>A brief summary of how the system works is:</p>

<p><em>I have some data that is held in tables that are in text format. I then use a tool to parse this data and serialize it to a dat file. This works fine but I need to encrypt this data as it will be stored with the application in a public place. The data wont be sent anywhere it is simply read by the application. I just need it to be encrypted so that if it were to fall into the wrong hands, it would not be possible to read the data.</em></p>

<p>I am using the crypto++ library for my encryption and I have read that it can perform most types of encryption algorithms. I have noticed however that most algorithms use a public and private key to encrypt/decrypt the data. This would mean I would have to store the private key with the data which seems counter intuitive to me. Are there any ways that I can perform the encryption without storing a private key with the data?</p>
","<p>If your application can read the data and people have access to that application, someone with enough motivation and time will eventually figure out (by disassembling your application) how to read the data.</p>

<p>In other words, all the information that is needed to decipher the encrypted data is already in the hand of the attacker. You have the consumer=attacker problem in all DRM-related designs and this is why people can easily decrypt DVDs, BluRays, M4As, encrypted eBooks, etc etc etc...</p>
","326","<c++><encryption><crypto++>","3","1","5","2011-07-12 12:48:31","6661740","1","","46642","","2011-07-12 10:13:09","2011-07-12 08:51:06",""
"6661633","Advice about the Encryption Method I should Use","<p>Ok, so I need some advice on which encryption method I should use for my current project. All the questions about this subject on here are to do with networking and passing encrypted data from one machine to another.</p>

<p>A brief summary of how the system works is:</p>

<p><em>I have some data that is held in tables that are in text format. I then use a tool to parse this data and serialize it to a dat file. This works fine but I need to encrypt this data as it will be stored with the application in a public place. The data wont be sent anywhere it is simply read by the application. I just need it to be encrypted so that if it were to fall into the wrong hands, it would not be possible to read the data.</em></p>

<p>I am using the crypto++ library for my encryption and I have read that it can perform most types of encryption algorithms. I have noticed however that most algorithms use a public and private key to encrypt/decrypt the data. This would mean I would have to store the private key with the data which seems counter intuitive to me. Are there any ways that I can perform the encryption without storing a private key with the data?</p>
","<p>That is called an asymmetric encryption when you use public/private key pairs.</p>

<p>You could use a symmetric encryption algorithm, that way you would only require one key.</p>

<p>That key will still need to be stored somewhere (it could be in the executable). But if the user has access to the .dat, he probably also has access to the exe. Meaning he could still extract that information. But if he has access to the pc (and the needed rights) he could read all the information from memory anyways.</p>

<p>You could ask the user for a passphrase (aka password) and use that to encrypt symmetrically. This way you don't need to store the passphrase anywhere.</p>
","326","<c++><encryption><crypto++>","3","1","5","2011-07-12 12:48:31","6661740","1","","46642","","2011-07-12 10:13:09","2011-07-12 08:51:06",""
"6661633","Advice about the Encryption Method I should Use","<p>Ok, so I need some advice on which encryption method I should use for my current project. All the questions about this subject on here are to do with networking and passing encrypted data from one machine to another.</p>

<p>A brief summary of how the system works is:</p>

<p><em>I have some data that is held in tables that are in text format. I then use a tool to parse this data and serialize it to a dat file. This works fine but I need to encrypt this data as it will be stored with the application in a public place. The data wont be sent anywhere it is simply read by the application. I just need it to be encrypted so that if it were to fall into the wrong hands, it would not be possible to read the data.</em></p>

<p>I am using the crypto++ library for my encryption and I have read that it can perform most types of encryption algorithms. I have noticed however that most algorithms use a public and private key to encrypt/decrypt the data. This would mean I would have to store the private key with the data which seems counter intuitive to me. Are there any ways that I can perform the encryption without storing a private key with the data?</p>
","<p>Short answer: don't bother.</p>

<p>Long answer: If you store your .DAT file with the application, you'll have to store the key somewhere too. Most probably in the same place (maybe hidden in the code). So if a malicious user wants to break your encryption all he has to do is to look for that key, and that's it. It doesn't really matter which method or algorithm you use. Even if you don't store the decryption key with the application, it will get there eventually, and the malicious user can catch it with the debugger at run time (unless you're using a dedicated secured memory chip and running on a device that has the necessary protections)</p>

<p>That said, many times the mere fact that the data is encrypted is enough protection because the data is just not worth the trouble. If this is your case - then you can just embed the key in the code and use any symmetric algorithm available (AES would be the best pick).</p>
","326","<c++><encryption><crypto++>","3","3","5","2011-07-12 12:48:31","6661740","1","","46642","","2011-07-12 10:13:09","2011-07-12 08:51:06",""
"6661633","Advice about the Encryption Method I should Use","<p>Ok, so I need some advice on which encryption method I should use for my current project. All the questions about this subject on here are to do with networking and passing encrypted data from one machine to another.</p>

<p>A brief summary of how the system works is:</p>

<p><em>I have some data that is held in tables that are in text format. I then use a tool to parse this data and serialize it to a dat file. This works fine but I need to encrypt this data as it will be stored with the application in a public place. The data wont be sent anywhere it is simply read by the application. I just need it to be encrypted so that if it were to fall into the wrong hands, it would not be possible to read the data.</em></p>

<p>I am using the crypto++ library for my encryption and I have read that it can perform most types of encryption algorithms. I have noticed however that most algorithms use a public and private key to encrypt/decrypt the data. This would mean I would have to store the private key with the data which seems counter intuitive to me. Are there any ways that I can perform the encryption without storing a private key with the data?</p>
","<p>Common way to solve your issue is:</p>

<ul>
<li>use symetric key algorithm to cipher your data, common algorithm are AES, twofish. most probably, you want to use CBC chaining.</li>
<li>use a digest (sha-256) and sign it with an asymetric algorithm (RSA), using your private key : this way you embed a signature and a public key to check it, making sure that if your scrambling key is compromised, other persons won't be able to forge your personal data. Of course, if you need to update these data, then you can't use this private key mechanism.</li>
</ul>

<p>In any case, you should check</p>

<ul>
<li>symetric cipher vs asymetric ones</li>
<li>signature vs ciphering</li>
<li>mode of operation, meaning how you chain one block to the next one for block ciphers, like AES, 3DES (CBC vs ECB)</li>
</ul>

<p>As previously said, if your data is read andwritten by same application, in any way, it will be very hard to prevent malicious users to steal these data. There are ways to hide keys in the code (you can search for Whitebox cryptography), but it will be definitely fairly complex (and obviously not relying on a simple external crypto library which can be easily templated to steal the key). </p>
","326","<c++><encryption><crypto++>","3","2","5","2011-07-12 12:48:31","6661740","1","","46642","","2011-07-12 10:13:09","2011-07-12 08:51:06",""
"12201384","Why is PHP Mcrypt returning post message garbage?","<p>Using the same (basic) code from <a href=""https://stackoverflow.com/questions/12187689/crypto-to-php-mcrypt-not-working/"">here</a> but switching to MCRYPT_RIJNDAEL_128, I'm now getting the correct data out of php mcrypt_decrypt, except in certain circumstances, it's padding out the end of my message a newline with seemingly random binary characters.</p>

<p>The following, for example, came back from a request to decrypt:</p>

<pre><code>{""messageData"":{""identity"":""test"",""msg_id"":0,""token"":""fakeToken58586""},""messageName"":""fetchSavedData_request""}\n\b\b\b\b\b\b\b\b
</code></pre>

<p>I would think this is a padding issue, but even if I pad out my string to the correct length, I occasionally get garbage, and strings that would normally need to be padded, do occasionally come back correct.</p>

<p>What's going on here?</p>
","<p>As @Jack pointed out in the comments, this is apparently a common problem. The code <a href=""http://au2.php.net/manual/en/function.mdecrypt-generic.php#107979"" rel=""nofollow"">here</a> works to remove control characters at the end of encrypted data.</p>

<p>Reproduced here for posterity:</p>

<pre><code>$data = preg_replace( ""/\p{Cc}*$/u"", """", $data);
</code></pre>
","322","<php><c++><mcrypt><crypto++>","0","0","1","2012-08-30 17:58:11","12202776","4","","-1","","2017-05-23 11:49:06","2012-08-30 16:25:58",""
"32401929","Sending PublicKey within packet payload","<p>For an academic network application, I'd like to set up an RSA key exchange between 2 virtual machines. I am using Crypto++ to generate the <code>RSA::PublicKey</code>, and I must now send it within a custom layer-2 frame (the packet will be crafted with <a href=""http://code.google.com/p/libcrafter/"" rel=""nofollow""><code>libcrafter</code></a>).</p>

<p>The thing is, I have no idea of <strong>how write the key in the network</strong>, such as the receiver, sniffing the packet, is able to re-build, somehow, the <code>RSA::PublicKey</code>.</p>

<p>I tried to save it <em>raw</em> in a string, but as they say <a href=""http://www.cryptopp.com/wiki/Keys_and_Formats"" rel=""nofollow"">here</a>, the <code>PublicKey</code> class contains other data, then simply the raw key (data that I don't need). nevertheless, I manage to success that, but at the reception I can't simply rebuild the PublicKey...</p>

<p>Could it be possible, somehow, to concatenate the modulus, the primes and the public exponent, in order to rebuild the <code>publicKey</code> at the reception?</p>

<p><strong><em>Sender</em></strong></p>

<p>Here is the code I use at the sender. It's the essential lines, but my program has other functionality, and it would be too long to post it entirely here).</p>

<pre><code>AutoSeededRandomPool rng;
RSA::PrivateKey privateKey;
privateKey.GenerateRandomWithKeySize(rng, 3072);
RSA::PublicKey publicKey(privateKey);
cout &lt;&lt; ""&gt;&gt; Key generated"" &lt;&lt;endl;

/* Convert key to string then to const char* */
std::string publicKeyString;
publicKey.BEREncode( StringSink(publicKeyString).Ref() );

const char * publicKeyChar = publicKeyString.c_str();
cout &lt;&lt;""key size : ""&lt;&lt;publicKeyString.size()&lt;&lt; endl;

/* Send Packet */
Crafter::RawLayer type1(""K"");
Crafter::RawLayer key_send(publicKeyChar);
//Crafter::RawLayer key_send(publicKeyString.c_str(), publicKeyString.length());
Crafter::Packet packet_key (ether_header / type1 / key_send);
packet_key.Send(iface);
</code></pre>

<p><strong><em>Receiver</em></strong></p>

<p>And here is my attempt to recover the key.</p>

<pre><code>/* Extract Payload */
PayloadLayer *payload_rcv = pack_recu.getLayerOfType&lt;PayloadLayer&gt;();
size_t payload_size  = payload_rcv-&gt;getPayloadLen() ; 
Crafter::byte *payload = payload_rcv-&gt;getPayload();

cout &lt;&lt; ""&gt;&gt; Public Key recieved""&lt;&lt;endl;

// Convert into RSA::PublicKey
stringstream ss;
for (int i=0; i&lt; payload_size; i++)
    ss &lt;&lt; payload[i];
string payload_string = ss.str();
cout &lt;&lt; ""Payload Size: ""&lt;&lt;payload_size&lt;&lt;endl;
cin.get();
StringSource stringSource(payload_string, true);
RSA::PublicKey publicKey2;
publicKey2.BERDecode(stringSource);

data-&gt;publicKey = publicKey2;
</code></pre>

<p>And here is the result of running the program:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::BERDecodeErr'
what():  BER decode error
</code></pre>

<p>I'm sure the error comes from the conversion from string to <code>publicKey...</code> The <code>BERDecode</code> function war originally thought to recover the key <em>from a file</em>...</p>

<p>Does anyone has a solution ? I think that sending apart all the elements to rebuild the key could be better, but I can't figure how to do it...</p>
","<blockquote>
  <p>publicKey.BEREncode( StringSink(publicKeyString).Ref() );</p>
  
  <p>const char * publicKeyChar = publicKeyString.c_str();</p>
</blockquote>

<p>A BER encoding likely has an embedded <code>NULL</code>, so you cannot use customary C-string operations on it:</p>

<pre><code>const char * publicKeyChar = publicKeyString.c_str();
...
Crafter::RawLayer key_send(publicKeyChar);
</code></pre>

<p>When writing the encoded public key, the following looks correct. You should uncomment it and use it (I use <code>data</code> and <code>size</code> because it logically separates from C-strings and length).</p>

<pre><code>Crafter::RawLayer key_send(publicKeyString.data(), publicKeyString.size());
</code></pre>

<p>So the whole Crypto++ thing might look like the following:</p>

<pre><code>// Host's private key, generate or Load() it...
RSA::PrivateKey privKey;
...

// Create a public key from the private key
RSA::PublicKey pubKey(privKey);

// Temporaries
string spki;
StringSink ss(spki);

// Use Save to DER encode the Subject Public Key Info (SPKI)
pubKey.Save(ss);

Crafter::RawLayer key_send(spki.data(), spki.size());
</code></pre>

<p>Then, to reconstruct it:</p>

<pre><code>// Key payload
const PayloadLayer&amp; payload_rcv = *pack_recu.getLayerOfType&lt;PayloadLayer&gt;();

// Get a contiguous array (I don't know what this is called in Crafter)
payload_rcv.PullUp();

// Use the array directly to avoid the copy
ArraySource as(payload_rcv.data(), payload_rcv.size(), true /*pumpAll*/);
RSA::PublicKey pubKey;

// Use Load to BER decode the Subject Public Key Info (SPKI)
pubKey.Load(as);

// Validate it before using it
AutoSeededRandomPool prng;
pubKey.ThrowIfInvalid(prng);
</code></pre>

<p>I think its important to use the Subject Public Key Info (SPKI) rather than just the Public Key. The SPKI includes an algorithm identifier by way of an OID. It will make algorithm agility a little easier later on. Later, you can switch to a ECDSA key or an ed25519 key, and they key type will be part of the key payload.</p>

<hr>

<blockquote>
<pre><code>terminate called after throwing an instance of 'CryptoPP::BERDecodeErr'
what():  BER decode error
</code></pre>
</blockquote>

<p>Obviously, you should set up a <code>try/catch</code>, and catch a <code>BERDecodeErr</code>:</p>

<pre><code>try
{
    // Use Load to BER decode the Subject Public Key Info (SPKI)
    pubKey.Load(as);

    // Validate it before using it
    AutoSeededRandomPool prng;
    pubKey.ThrowIfInvalid(prng);
}
catch(const BERDecodeErr&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
catch(const InvalidMaterial&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<p>And here's what the Subject Public Key Info looks like:</p>

<pre class=""lang-none prettyprint-override""><code>$ cat cryptopp-test.cpp
...
int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    RSA::PrivateKey rsaPrivate;
    rsaPrivate.GenerateRandomWithKeySize(prng, 3072);

    RSA::PublicKey rsaPublic(rsaPrivate);
    FileSink sink(""rsa-public.der"");
    rsaPublic.Save(sink);

    return 0;
}
</code></pre>

<p>And then use something like Peter Gutmann's <a href=""http://www.cs.auckland.ac.nz/~pgut001/"" rel=""nofollow""><code>dumpasn1</code></a>:</p>

<pre class=""lang-none prettyprint-override""><code>$ dumpasn1 rsa-public.der
  0 416: SEQUENCE {
  4  13:   SEQUENCE {
  6   9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
 17   0:     NULL
       :     }
 19 397:   BIT STRING, encapsulates {
 24 392:     SEQUENCE {
 28 385:       INTEGER
       :         00 CE B0 19 0D 0C EB 87 BD 6B 51 6C BB 00 9C EE
       :         1D 75 9C 28 DC 0E 8E 88 9A 95 8A 3B 6C BD 1F 3F
       :         03 05 22 8E 3D 19 33 D7 C5 A3 28 4F 13 3D 9E BF
       :         5A 54 51 AE D6 DA C3 AC 1D 9C 4C A3 47 C0 04 8F
       :         9D 0A DD 38 60 56 E3 9C DB 7C EA A8 3F 52 93 99
       :         40 90 14 41 0A 3B 58 F2 13 9F 38 64 18 DD 62 55
       :         D2 32 53 A0 D5 1A 54 E7 8D 23 01 E0 97 ED F9 C7
       :         68 9F E2 00 48 99 53 40 6E 7E 5C DA 47 39 4A 41
       :                 [ Another 257 bytes skipped ]
417   1:       INTEGER 17
       :       }
       :     }
       :   }

0 warnings, 0 errors.
</code></pre>
","322","<c++><rsa><ethernet><crypto++>","3","3","1","2015-09-07 09:43:43","32419626","1","","608639","","2015-09-06 02:07:22","2015-09-04 15:43:51",""
"34035207","Why does Crypto++ think my messages are larger than they are?","<p>I'm using the <code>Crypto++</code> library for C++ to encrypt 128-bit messages with their public key and my private key from disk. However, when I call my function the program terminates with the error message:</p>

<blockquote>
  <p>terminate called after throwing an instance of
  'CryptoPP::InvalidArgument'   what():  RSA/OAEP-MGF1(SHA-1): message
  length of 256 exceeds the maximum of 214 for this public key</p>
</blockquote>

<p>I'm not sure why it thinks my messages are 256-bit when they are clearly 128-bit. Below is my code:</p>

<pre><code>std::string encryptWithBothKeys(std::string key_name1, std::string key_name2, std::string plain){
    std::string cipher1, cipher2;
    AutoSeededRandomPool rng;

    RSA::PublicKey pub_key;
    RSA::PrivateKey priv_key;
    loadPublicKey(key_name1, pub_key);
    loadPrivateKey(key_name2, priv_key);

    RSAES_OAEP_SHA_Encryptor e_pub(pub_key);
    RSAES_OAEP_SHA_Encryptor e_priv(priv_key);

    StringSource ss1(plain, true,
      new PK_EncryptorFilter(rng, e_pub,
        new StringSink(cipher1)
      )
    );

    StringSource ss2(cipher1, true,
      new PK_EncryptorFilter(rng, e_priv,
        new StringSink(cipher2)
      )
    );

    return cipher2;
}

void load(const std::string&amp; filename, BufferedTransformation&amp; bt){
  FileSource file(filename.c_str(), true /*pumpAll*/);

  file.TransferTo(bt);
  bt.MessageEnd();
}

void loadPrivateKey(const std::string&amp; filename, PrivateKey&amp; key){
  ByteQueue queue;

  load(filename, queue);
  key.Load(queue);  
}

void loadPublicKey(const std::string&amp; filename, PublicKey&amp; key){
  ByteQueue queue;

  load(filename, queue);
  key.Load(queue);  
}
</code></pre>

<p>And in the main function I call it like this:</p>

<pre><code>std::string encrypted_msg = encryptWithBothKeys(""their.pub"", ""my.key"", ""0123456789ABCDEF"");
</code></pre>

<p>Any suggestions?</p>

<p>EDIT: Turns out the ciphertext after the first encryption is size 256. I guess I need to figure out why it's increasing the size.</p>
","<blockquote>
  <p>I'm not sure why it thinks my messages are 256-bit when they are clearly 128-bit. Below is my code:</p>
</blockquote>

<p>Those are bytes, not bits.</p>

<p>What size RSA modulus are you using? I'm guessing its a 2048-bit key, which is 256 bytes, which leaves ≈214 bytes due to OAEP padding.</p>

<p>So the question becomes, what is the size of <code>plain</code> and <code>cipher1</code> during this:</p>

<pre><code>StringSource ss1(plain, true,
  new PK_EncryptorFilter(rng, e_pub,
    new StringSink(cipher1)
  )
);
</code></pre>

<p>My guess is <code>plain1</code> is small enough. However, when its padded and encrypted, it expands to 256 bytes as <code>cipher1</code>. So the message <code>cipher1</code> is too large when this is executed:</p>

<pre><code>StringSource ss2(cipher1, true,
  new PK_EncryptorFilter(rng, e_priv,
    new StringSink(cipher2)
  )
);
</code></pre>

<p>Also, should the above be using <code>PK_DecryptorFilter</code>? Are you certain you want to encrypt again? If so, then why are you using <code>e_priv</code>?</p>

<p>Encrypting with the private key is not a valid cryptographic operation. If you want the ""encrypt with the private key"" thing, it usually means you want a <strong><em>Probabilistic Signature Scheme with Recovery (PSSR)</em></strong>. Crypto++ supplies a couple of them.</p>
","321","<c++><crypto++>","1","1","1","2015-12-03 18:39:00","","3","","3853454","","2015-12-02 05:20:16","2015-12-02 04:54:48",""
"21924257","I use CBC_CTS_Mode_ExternalCipher and get garbled output","<p>Ok I hate doing this but I am getting frustrated because there is little to no documentation on the CBC_CTS_Mode_ExternalCipher .</p>

<p>I have a partially known key for AES128.  I built a function to generate all possible combinations and permutations of the unknown and known parts of the key.  Let me rephrase that... sorry, the function creates a key in the format that I am wanting, that is 16 bytes of hex, but the output of the decryption is all messed up  I was going to just decrypt the message and XOR for CBC manually but I do not have the time. </p>

<p>When the decryption outputs I get all sorts of symbols, numbers, letters and crazyness. </p>

<pre><code>string ciphertext = ""C7A4123420BF4EFFB815BC0EA8B46D00F440D068CDD9BB28860DC3E9B312710743"";
string plaintext;

CryptoPP::AES::Decryption aesDecryption(tmp, CryptoPP::AES::DEFAULT_KEYLENGTH);
CryptoPP::CBC_CTS_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new 
    CryptoPP::StringSink( plaintext ) );

stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ),
    ciphertext.size() );
stfDecryptor.MessageEnd();
</code></pre>

<p>Can someone with more knowledge help explain why this is not working or explain a better way of decrypting a ciphertext string in CBC mode when you already have the ciphertext for cryptanalysis?</p>

<p>Thanks</p>

<p><strong>EDIT</strong>: Replaced ""The key works but the decryption doesnt"", with Let me rephrase that... sorry, the function creates a key in the format that I am wanting, that is 16 bytes of hex, but the output of the decryption is all messed up</p>
","<blockquote>
  <p>a better way of decrypting a ciphertext string in CBC mode when you already have the ciphertext for cryptanalysis</p>
</blockquote>

<p>You are using CTS mode, not CBC mode. So the first step is to use the correct mode ;)</p>

<p>Here's an example of CBC encryption and decryption from the Crypto++ wiki <a href=""http://www.cryptopp.com/wiki/CBC_Mode"" rel=""nofollow"">CBC Mode</a>:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte iv[ AES::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );

string plain = ""CBC Mode Test"";
string cipher, encoded, recovered;

/*********************************\
\*********************************/

try
{
    cout &lt;&lt; ""plain text: "" &lt;&lt; plain &lt;&lt; endl;

    CBC_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( key, key.size(), iv );

    // The StreamTransformationFilter adds padding
    //  as required. ECB and CBC Mode must be padded
    //  to the block size of the cipher.
    StringSource ss( plain, true, 
        new StreamTransformationFilter( e,
            new StringSink( cipher )
        ) // StreamTransformationFilter      
    ); // StringSource
}
catch( const CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

/*********************************\
\*********************************/

// Pretty print cipher text
StringSource ss( cipher, true,
    new HexEncoder(
        new StringSink( encoded )
    ) // HexEncoder
); // StringSource
cout &lt;&lt; ""cipher text: "" &lt;&lt; encoded &lt;&lt; endl;

/*********************************\
\*********************************/

try
{
    CBC_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( key, key.size(), iv );

    // The StreamTransformationFilter removes
    //  padding as required.
    StringSource ss( cipher, true, 
        new StreamTransformationFilter( d,
            new StringSink( recovered )
        ) // StreamTransformationFilter
    ); // StringSource

    cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;
}
catch( const CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>Here's a typical output:</p>

<pre><code>$ ./driver.exe 
key: B00DDF9D93E199EFEAE967805E0A5228
iv: CA8A8878F145C9B9B3C31A1F15C34A6D
plain text: CBC Mode Test
cipher text: D6AF39534926C21CFF3E7477A7146FF3
recovered text: CBC Mode Test
</code></pre>

<hr>

<blockquote>
  <p>string ciphertext = ""C7A4123420BF4EFFB815BC0EA8B46D00F440D068CDD9BB28860DC3E9B312710743""</p>
</blockquote>

<p>The second thing you will probably want to do is change that string from hexadecimal encoded to binary. That's covered in the Crypto++ wiki under <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow"">HexDecoder</a>:</p>

<pre><code>string encoded = ""FFEEDDCCBBAA99887766554433221100"";
string decoded;

StringSource ss(encoded,
    new HexDecoder(
        new StringSink(decoded)
    ) // HexDecoder
); // StringSource
</code></pre>

<p>After the above code runs, you will have a binary string with possibly embedded <code>NULL</code>s. So be sure to use <code>decoded.data()</code> for the pointer, and <code>decoded.size()</code> for the length of the binary string.</p>

<hr>

<blockquote>
  <p>When the decryption outputs I get all sorts of symbols, numbers, letters and crazyness. </p>
</blockquote>

<p>That could mean decryption has failed. The only way to really tell is if you supply an authentication tag like an HMAC over the cipher text. Otherwise, you will get those results.</p>

<p>If you use a mode that requires padding (like CBC mode), then you will still get spurious hits when the padding happens to be correct. The only unambiguous way to tell is to provide an authentication tag.</p>

<hr>

<blockquote>
  <p>I built a function to generate all possible combinations and permutations of the unknown and known parts of the key. </p>
</blockquote>

<p>You should show that routine too in case it has an error. We can't comment on the way you are permuting bits, but we can comment on whether it looks like its producing a binary string as Crypto++ uses.</p>

<hr>

<blockquote>
  <p>I was going to just decrypt the message and XOR for CBC manually but I do not have the time. </p>
</blockquote>

<p>I really don't know what to make of this... Do you want to operate AES in ECB mode and then perform the XOR yourself? If so, you might consider an <a href=""http://www.cryptopp.com/docs/ref/class_array_xor_sink.html"" rel=""nofollow"">ArrayXorSink</a>.</p>
","318","<aes><crypto++><cbc-mode>","0","1","1","2014-02-21 17:29:53","21941172","3","","608639","","2014-02-21 17:12:27","2014-02-21 02:43:32",""
"39799435","Omnet++ framework and linking Crypto++","<p>Can you help me with the steps to link/import Crypto++ library to OMNeT++ framework properly, please.</p>

<p>I use OMNeT++ 5.0/inetmanet 3.0 version (Windows 10).</p>
","<p>OMNeT++ on windows is a C++ simulation library that is built in MinGW environment with GCC (on windows). As such, everything that applies to a general program applies here. You need to have the crypto++ headers in the /tools/win32/mingw32/include folder, the libraries in the tools/win32/mingw32/lib and the dll in the bin directory...</p>

<p>You may be able to install the library and the headers with:</p>

<pre><code>pacman -Su mingw-w64-i686-crypto++
</code></pre>

<p>After that you can just use the include file of the library as usual. You have to add the crypto library to the linker command line (in the IDE: Project / Properties and add the library in the ""Makemake"" dialog on the Libraries tab.</p>
","317","<omnet++><crypto++>","-2","0","1","2016-10-04 14:19:41","","4","","608639","","2016-10-01 08:54:17","2016-09-30 20:16:14",""
"40799869","Manual CBC encryption handing with Crypto++","<p>I am trying to play around with a manual encryption in CBC mode but still use Crypto++, just to know can I do it manually.
The CBC algorithm is (AFAIK):</p>

<pre><code>Presume we have n block K[1]....k[n]
0. cipher = empty;
1. xor(IV, K1) -&gt; t1
2. encrypt(t1) -&gt; r1
3. cipher += r1
4. xor (r1, K2) -&gt; t2
5. encrypt(t2) -&gt; r2
6. cipher += r2
7. xor(r2, K3)-&gt;t3
8. ...
</code></pre>

<p>So I tried to implement it with Crypto++. I have a text file with alphanumeric characters only. Test 1 is read file chunk by chunk (16 byte) and encrypt them using CBC mode manually, then sum up the cipher. Test 2 is use Crypto++ built-in CBC mode.
<br />
<strong>Test 1</strong></p>

<pre><code>char* key;
char* iv;
//Iterate in K[n] array of n blocks
BSIZE = 16;

std::string vectorToString(vector&lt;char&gt; v){
    string s ="""";
    for (int i = 0; i &lt; v.size(); i++){
        s[i] = v[i];
    }
    return s;
}

vector&lt;char&gt; xor( vector&lt;char&gt; s1, vector&lt;char&gt; s2, int len){

    vector&lt;char&gt; r;
    for (int i = 0; i &lt; len; i++){
        int u = s1[i] ^ s2[i];
        r.push_back(u);
    }
    return r;
}

vector&lt;char&gt; byteToVector(byte *b, int len){
    vector&lt;char&gt; v;
    for (int i = 0; i &lt; len; i++){
        v.push_back( b[i]);
    }
    return v;
}

string cbc_manual(byte [n]){
    int i = 0;
    //Open a file and read from it, buffer size = 16
    // , equal to DEFAULT_BLOCK_SIZE
    std::ifstream fin(fileName, std::ios::binary | std::ios::in);
    const int BSIZE = 16;

    vector&lt;char&gt; encryptBefore;
    //This function will return cpc
    string cpc ="""";
    while (!fin.eof()){

        char buffer[BSIZE];
        //Read a chunk of file 
        fin.read(buffer, BSIZE);
        int sb = sizeof(buffer);
        if (i == 0){
            encryptBefore = byteToVector( iv, BSIZE);
        }

        //If i == 0, xor IV with current buffer
        //else, xor encryptBefore with current buffer

        vector&lt;char&gt; t1 = xor(encryptBefore, byteToVector((byte*) buffer, BSIZE), BSIZE);
            //After xored, encrypt the xor result, it will be current step cipher
        string r1= encrypt(t1, BSIZE).c_str();
        cpc += r1;
        const char* end = r1.c_str() ;

        encryptBefore = stringToVector( r1);


        i++;
    }
    return cpc;
}
</code></pre>

<p>This is my encrypt() function, because we have only one block so I use ECB (?) mode</p>

<pre><code>string encrypt(string s, int size){
    ECB_Mode&lt; AES &gt;::Encryption e;
    e.SetKey(key, size);

    string cipher;
    StringSource ss1(s, true,
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        ) // StreamTransformationFilter      
        ); // StringSource
    return cipher;
}
</code></pre>

<p><br/>
And this is 100% Crypto++ made solution:
<br/>
<strong>Test 2</strong></p>

<pre><code>encryptCBC(char * plain){
    CBC_Mode &lt; AES &gt;::Encryption encryption(key, sizeof(key), iv);
    StreamTransformationFilter encryptor(encryption, NULL);
    for (size_t j = 0; j &lt; plain.size(); j++)
        encryptor.Put((byte)plain[j]);

    encryptor.MessageEnd();
    size_t ready = encryptor.MaxRetrievable();

    string cipher(ready, 0x00);
    encryptor.Get((byte*)&amp;cipher[0], cipher.size());
}
</code></pre>

<p>Result of Test 1 and Test 2 are different. In the fact, ciphered text from Test 1 is contain the result of Test 2. Example:</p>

<blockquote>
  <p>Test 1's result aaa[....]bbb[....]ccc[...]... </p>
  
  <p>Test 2 (Crypto++ built-in CBC)'s result: aaabbbccc...</p>
</blockquote>

<p>I know the xor() function may cause a problem relate to ""sameChar ^ sameChar = 0"", but is there any problem relate to algorithm in my code?</p>

<p>This is my Test 2.1 after the 1st solution of jww.</p>

<pre><code>static string auto_cbc2(string plain, long size){
    CBC_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));
    string cipherText;

    CryptoPP::StringSource ss(plain, true,
        new CryptoPP::StreamTransformationFilter(e,
        new CryptoPP::StringSink(cipherText)
        , BlockPaddingSchemeDef::NO_PADDING
        ) // StreamTransformationFilter
        ); // StringSource
    return cipherText;
}
</code></pre>

<p>It throw an error:</p>

<blockquote>
  <p>Unhandled exception at 0x7407A6F2 in AES-CRPP.exe: Microsoft C++
  exception: CryptoPP::InvalidDataFormat at memory location 0x00EFEA74</p>
</blockquote>

<p>I only got this error when use BlockPaddingSchemeDef::NO_PADDING, tried to remove BlockPaddingSchemeDef or using BlockPaddingSchemeDef::DEFAULT_PADDING, I got no error . :?</p>
","<pre><code>StringSource ss1(s, true,
    new StreamTransformationFilter(e,
        new StringSink(cipher)));
</code></pre>

<p>This uses PKCS padding by default. It takes a 16-byte input and produces a 32-byte output due to padding. You should do one of two things.</p>

<p>First, you can use <a href=""http://www.cryptopp.com/docs/ref/struct_block_padding_scheme_def.html"" rel=""nofollow noreferrer""><code>BlockPaddingScheme::NO_PADDING</code></a>. Something like:</p>

<pre><code>StringSource ss1(s, true,
    new StreamTransformationFilter(e,
        new StringSink(cipher)
    BlockPaddingScheme::NO_PADDING));
</code></pre>

<p>Second, you can process blocks manually, 16 bytes at a time. Something like:</p>

<pre><code>AES::Encryption encryptor(key, keySize);

byte ibuff[&lt;some size&gt;] = ...;
byte obuff[&lt;some size&gt;];
ASSERT(&lt;some size&gt; % AES::BLOCKSIZE == 0);

unsigned int BLOCKS = &lt;some size&gt;/AES::BLOCKSIZE;
for (unsigned int i=0; i&lt;BLOCKS; i==)
{
    encryptor.ProcessBlock(&amp;ibuff[i*16], &amp;obuff[i*16]);
    // Do the CBC XOR thing...
}
</code></pre>

<p>You may be able to call <a href=""https://www.cryptopp.com/docs/ref/class_block_transformation.html#a6e484184bbf368bb0bb26f05fe2d4c35"" rel=""nofollow noreferrer""><code>ProcessAndXorBlock</code></a> from the <a href=""http://www.cryptopp.com/docs/ref/class_block_cipher.html"" rel=""nofollow noreferrer""><code>BlockCipher</code> base class</a> and do it in one shot.</p>
","316","<crypto++><cbc-mode>","0","0","1","2016-11-28 07:07:52","40808484","0","","2874409","","2016-11-28 07:07:52","2016-11-25 07:36:51",""
"34205766","Encryption and decryption with Serpent using Crypto++ and Bouncy Castle?","<p>I need to build an app on windows/mac using Java and separate apps native on IOS and Android for encrypting with Serpent. </p>

<p>I implemented using Bouncy Castle on Java for win/mac and with Crypto++ on iOS, but what I encrypt with Bouncy Castle cannot be decrypted with Crypto++ or the other way around.</p>

<p>Does anyone know why Bouncy Castle and Crypto++ are not inter-oping?</p>

<p>Thank you!</p>
","<p>With BC you need to use the version at <a href=""http://www.bouncycastle.org/betas"" rel=""nofollow"">http://www.bouncycastle.org/betas</a> It turns out the NESSIE vectors in fact define the correct input/output ordering. The AES submission had them reversed.</p>

<p>If it's any help the AES submission where implemented is now called Tnepres, only versions compliant with the NESSIE vectors are called Serpent. The 1.54 beta of BC offers both Tnepres and Serpent. Unfortunately, due to a misunderstanding between BC and the Serpent authors, BC 1.53 and earlier in fact implements Tnepres.</p>
","314","<ios><encryption><bouncycastle><crypto++>","0","2","1","2015-12-12 06:34:14","","2","","608639","","2015-12-12 06:34:14","2015-12-10 15:29:45","2015-12-16 06:06:58"
"54548803","Retrieve ECDSA public key from only x-compressed coordinate using Crypto++ library","<p>I'm implementing a security daemon on the vehicular communication scope.</p>

<p>I could receive a message with a signature and the compressed X coordinate of a point to verify that signature. The elliptic curve can be either the secp256 or the brainpoolp256r1 and the algorithm is ECDSA.</p>

<p>My question is: how can I recover the ECC Point (and so the public key) given only the compressed X coordinate with the Crypto++ library?</p>

<p>I followed some links which explain it (and many others) <a href=""https://www.cryptopp.com/wiki/Point_Compression"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/Point_Compression</a> <a href=""https://stackoverflow.com/questions/16576434/crypto-and-compressed-ec-keys"">Crypto++ and Compressed EC keys</a> but they don't fit my problem.</p>

<p>I tried to produce code to resolve the problem, but it won't work:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cryptopp/cryptlib.h&gt;
#include &lt;cryptopp/ecp.h&gt;
#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;

using namespace CryptoPP;
using std::cout;
using std::endl;
using std::string;

int main() 
{
    string compactPoint = ""937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3"";

    AutoSeededRandomPool generator;
    ECDSA&lt;ECP, SHA256&gt;::PublicKey pubKey;
    OID curve       = ASN1::secp256r1();


    StringSource ss (compactPoint, true, new CryptoPP::HexDecoder);
    ECP::Point point;

    pubKey.GetGroupParameters().GetCurve().DecodePoint (point, ss, ss.MaxRetrievable());

    std::cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Can you help me please?</p>
","<p>The easiest solution is probably to prepend <code>""02""</code> oe <code>""03""</code> to the <a href=""https://tools.ietf.org/id/draft-jivsov-ecc-compact-00.xml#NIST-SP800-133"" rel=""nofollow noreferrer"">compact representation</a>. Crypto++ will then decode it as a compressed public key.</p>

<pre><code>$ cat test.cxx

#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""ecp.h""
#include ""hex.h""
#include ""oids.h""

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    ECDSA&lt;ECP, SHA256&gt;::PublicKey pubKey;
    pubKey.AccessGroupParameters().Initialize(ASN1::secp256r1());

    std::string compactPoint = ""02"" /* compressed */
        ""937120662418500f3ad7c892b1db7e7c""
        ""2d85ec48c74e99d64dcb7083082bb4f3"";

    StringSource ss (compactPoint, true, new HexDecoder);
    ECP::Point point;

    pubKey.GetGroupParameters().GetCurve().DecodePoint (point, ss, ss.MaxRetrievable());

    std::cout &lt;&lt; ""Result after decompression X: "" &lt;&lt; std::hex &lt;&lt; point.x &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Result after decompression Y: "" &lt;&lt; std::hex &lt;&lt; point.y &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And then building and running the program. Notice the library solves for the <code>y</code> portion of the coordinate.</p>

<pre class=""lang-none prettyprint-override""><code>cryptopp$ g++ test.cxx ./libcryptopp.a -o test.exe
cryptopp$ ./test.exe
Result after decompression X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Result after decompression Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
</code></pre>

<hr>

<p>And to save you the trouble of looking it up, you can set the public element for <code>publicKey</code> using:</p>

<pre><code>pubKey.SetPublicElement(point);

std::cout &lt;&lt; ""X: "" &lt;&lt; std::hex &lt;&lt; pubKey.GetPublicElement().x &lt;&lt; std::endl;
std::cout &lt;&lt; ""Y: "" &lt;&lt; std::hex &lt;&lt; pubKey.GetPublicElement().y &lt;&lt; std::endl;
</code></pre>

<p>Running with the additional code produces the expected result:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Result after decompression X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Result after decompression Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Y: cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h
</code></pre>

<hr>

<p>If interested, here is the code you are using to decode the point from <a href=""https://github.com/weidai11/cryptopp/blob/master/ecp.cpp"" rel=""nofollow noreferrer""><code>ecp.cpp</code></a>:</p>

<pre><code>bool ECP::DecodePoint(ECP::Point &amp;P, BufferedTransformation &amp;bt, size_t encodedPointLen) const
{
    byte type;
    if (encodedPointLen &lt; 1 || !bt.Get(type))
        return false;

    switch (type)
    {
    case 0:
        P.identity = true;
        return true;
    case 2:
    case 3:
    {
        if (encodedPointLen != EncodedPointSize(true))
            return false;

        Integer p = FieldSize();

        P.identity = false;
        P.x.Decode(bt, GetField().MaxElementByteLength());
        P.y = ((P.x*P.x+m_a)*P.x+m_b) % p;

        if (Jacobi(P.y, p) !=1)
            return false;

        P.y = ModularSquareRoot(P.y, p);

        if ((type &amp; 1) != P.y.GetBit(0))
            P.y = p-P.y;

        return true;
    }
    case 4:
    {
        if (encodedPointLen != EncodedPointSize(false))
            return false;

        unsigned int len = GetField().MaxElementByteLength();
        P.identity = false;
        P.x.Decode(bt, len);
        P.y.Decode(bt, len);
        return true;
    }
    default:
        return false;
    }
}
</code></pre>

<p>I mention it in case you want to solve for the <code>y</code> coordinate yourself, populate the <code>point</code>, and then call <code>SetPublicElement</code> directly.</p>

<hr>

<p>You can also prepend <code>03</code> instead of <code>02</code>. The difference is, the decoding returns either <code>y</code> or <code>p-y</code>. The variability is introduced due to the modular square root shown above. We need to see the generation algorithm to determine what the value should be.</p>

<p>Here is the difference when using <code>03</code> instead of <code>02</code>:</p>

<pre><code>$ ./test.exe
X: 937120662418500f3ad7c892b1db7e7c2d85ec48c74e99d64dcb7083082bb4f3h
Y: 303508b051c3113b66c6d70fb68f3010cbc46595dd8d8057e6d942de0da913a9h
</code></pre>

<p>Notice <code>03</code> produces the <code>y</code> coordinate <code>303508b051c3113b66c6d70fb68f3010cbc46595dd8d8057e6d942de0da913a9h</code> instead of <code>02</code> and <code>cfcaf74eae3ceec5993928f04970cfef343b9a6b22727fa81926bd21f256ec56h</code>.</p>
","310","<c++><compression><public-key><crypto++><ecdsa>","1","0","1","2019-02-07 17:44:58","54550787","2","1","4359602","","2019-02-06 08:59:53","2019-02-06 07:47:47",""
"40120894","Can't BER decode RSA public key with NDK Android","<p>I have problems using Crypto++ to save a RSA public key string. When decoding the key, I always get a BERDecodeErr exception.</p>

<p>Code:</p>

<pre class=""lang-cxx prettyprint-override""><code>string RsaEncryptor::encryptor(string plaintext, string publicKey)
{
    std::string cipher;
    AutoSeededRandomPool prng;

    try
    {
        ByteQueue queue;
        Base64Decoder decoder(new Redirector(queue));
        decoder.Put((const byte *) publicKey.data(), publicKey.size());
        decoder.MessageEnd();

        RSA::PublicKey rsaPublick;
        rsaPublick.BERDecodePublicKey(queue, false, (size_t) queue.MaxRetrievable());

        // BERDecodePrivateKey is a void function. Here's the only check
        // we have regarding the DER bytes consumed.
        CRYPTOPP_ASSERT(queue.IsEmpty());

        bool valid = rsaPublick.Validate(prng, 3);
        if (!valid)
            cipher = ""RSA private key is not valid"";

        RSAES_OAEP_SHA_Encryptor e(rsaPublick);
        StringSource ss(plaintext, true,
                     new PK_EncryptorFilter(prng, e,
                                            new StringSink(cipher)
                     ) // PK_EncryptorFilter
        ); // StringSource
    }
    catch (CryptoPP::Exception &amp;e) {
        cipher = e.what();
    }
    return cipher;
}
</code></pre>

<p>The public key is:</p>

<pre class=""lang-none prettyprint-override""><code>MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQDs648aASMAR9VprkzNVS7b‌​36N1hiYvbBG0c
dE0QkS3‌​H/sc3+Ej92lGBQErpBu9‌​LVhwN/beBX4QnbCn1eNS‌​rKoOzS4yqWlwOaCe0WLm‌​FDHCn1
cMTkX89cT4A0pc‌​jBbY+0W7htxWcqHxEQH9‌​x/AjQ9/4blerh1i6/lLI‌​o6hn2hB8kQIB
</code></pre>
","<blockquote>
<pre><code>MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQDs648aASMAR9VprkzNVS7b‌​36N1hiYvbBG0c
dE0QkS3‌​H/sc3+Ej92lGBQErpBu9‌​LVhwN/beBX4QnbCn1eNS‌​rKoOzS4yqWlwOaCe0WLm‌​FDHCn1
cMTkX89cT4A0pc‌​jBbY+0W7htxWcqHxEQH9‌​x/AjQ9/4blerh1i6/lLI‌​o6hn2hB8kQIB
</code></pre>
</blockquote>

<p>The key is malformed.</p>

<p>Stripping the Base64 encoding:</p>

<pre class=""lang-cxx prettyprint-override""><code>FileSource fs1(""key.b64"", true, new Base64Decoder);
FileSink fs2(""key.der"");        
fs1.CopyTo(fs2);
</code></pre>

<p>And then viewing it under Gutmann's <a href=""https://www.cs.auckland.ac.nz/~pgut001/"" rel=""nofollow""><code>dumpasn1</code></a> reveals:</p>

<pre class=""lang-none prettyprint-override""><code>$ dumpasn1 key.der
  0 157: SEQUENCE {
  3  13:   SEQUENCE {
  5   9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
 16   0:     NULL
       :     }
 18 139:   BIT STRING, encapsulates {
 22 135:     SEQUENCE {
 25 129:       INTEGER
       :         00 EC EB 8F 1A 01 23 00 47 D5 69 AE 4C CD 55 2E
       :         DB DF A3 75 86 26 2F 6C 11 B4 71 D1 34 42 44 B7
       :         1F FB 1C DF E1 23 F7 69 46 05 01 2B A4 1B BD 2D
       :         58 70 37 F6 DE 05 7E 10 9D B0 A7 D5 E3 52 AC AA
       :         0E CD 2E 32 A9 69 70 39 A0 9E D1 62 E6 14 31 C2
       :         9F 57 0C 4E 45 FC F5 C4 F8 03 4A 5C 8C 16 D8 FB
       :         45 BB 86 DC 56 72 A1 F1 11 01 FD C7 F0 23 43 DF
       :         F8 6E 57 AB 87 58 BA FE 52 C8 A3 A8 67 DA 10 7C
       :         91
157   1:       INTEGER -1
       :         Error: Integer has a negative value.
       :       }
       :     }
       :   }
</code></pre>

<p>From above, the problem ASN.1 is at position 157. Looking at the file sizes:</p>

<pre class=""lang-none prettyprint-override""><code>-rw-r--r--  1 jwalton  staff  261 Oct 18 23:09 key.b64
-rw-r--r--  1 jwalton  staff  159 Oct 18 23:18 key.der
</code></pre>

<p>It looks like there's two byte remaining to be processed. The <code>02</code> is the ASN.1 tag for an <code>INTEGER</code>. It should be followed by a length and a value, but there's only the length octet (<code>01</code>) is present. The value is missing.</p>

<pre class=""lang-none prettyprint-override""><code>$ xxd -g 1 key.der
0000000: 30 81 9d 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01  0..0...*.H......
0000010: 05 00 03 81 8b 00 30 81 87 02 81 81 00 ec eb 8f  ......0.........
0000020: 1a 01 23 00 47 d5 69 ae 4c cd 55 2e db df a3 75  ..#.G.i.L.U....u
0000030: 86 26 2f 6c 11 b4 71 d1 34 42 44 b7 1f fb 1c df  .&amp;/l..q.4BD.....
0000040: e1 23 f7 69 46 05 01 2b a4 1b bd 2d 58 70 37 f6  .#.iF..+...-Xp7.
0000050: de 05 7e 10 9d b0 a7 d5 e3 52 ac aa 0e cd 2e 32  ..~......R.....2
0000060: a9 69 70 39 a0 9e d1 62 e6 14 31 c2 9f 57 0c 4e  .ip9...b..1..W.N
0000070: 45 fc f5 c4 f8 03 4a 5c 8c 16 d8 fb 45 bb 86 dc  E.....J\....E...
0000080: 56 72 a1 f1 11 01 fd c7 f0 23 43 df f8 6e 57 ab  Vr.......#C..nW.
0000090: 87 58 ba fe 52 c8 a3 a8 67 da 10 7c 91 02 01     .X..R...g..|...
</code></pre>

<p>Here's another view of the problem. <code>02</code> is the ASN.1 <code>INTEGER</code>, <code>01</code> is the length of the integer, but the value is missing:</p>

<pre class=""lang-none prettyprint-override""><code>0000090: 87 58 ba fe 52 c8 a3 a8 67 da 10 7c 91 ***02 01 ??***
</code></pre>

<hr>

<p>Here's what a good 1024 bit key looks like. Its different than yours:</p>

<pre class=""lang-none prettyprint-override""><code>$ dumpasn1 key.der
  0 157: SEQUENCE {
  3  13:   SEQUENCE {
  5   9:     OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)
 16   0:     NULL
       :     }
 18 139:   BIT STRING, encapsulates {
 22 135:     SEQUENCE {
 25 129:       INTEGER
       :         00 D0 52 BA 4B 3F 44 AA 7B C9 C2 84 46 17 D6 17
       :         A0 43 03 69 7B 18 06 5B D4 EA 29 E2 74 24 40 62
       :         58 16 52 9D 73 82 77 D7 9D 13 97 53 71 76 9F B2
       :         99 CA 36 1E D4 E1 DF 0D BE C4 07 1E A0 F2 F2 E9
       :         EF 32 FA 00 4B 0B 8E C2 91 BA 8B 1D 1C 4D F0 98
       :         6C 64 C5 9E 4D EE 58 17 06 20 C9 3C 9A F0 33 BB
       :         A8 FC 7B 7B 6C F9 C6 FD A0 17 76 3A 3D 1D 7E E7
       :         42 C2 49 AD 4C 26 AE B6 F6 DC 99 A3 24 99 1A 30
       :         D9
157   1:       INTEGER 17
       :       }
       :     }
       :   }

0 warnings, 0 errors.
</code></pre>

<p>Notice there are two octets following the <code>02</code> (<code>01 11</code> below), and not one octet (like yours):</p>

<pre class=""lang-none prettyprint-override""><code>$ xxd -g 1 key.der
0000000: 30 81 9d 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01  0..0...*.H......
0000010: 05 00 03 81 8b 00 30 81 87 02 81 81 00 d0 52 ba  ......0.......R.
0000020: 4b 3f 44 aa 7b c9 c2 84 46 17 d6 17 a0 43 03 69  K?D.{...F....C.i
0000030: 7b 18 06 5b d4 ea 29 e2 74 24 40 62 58 16 52 9d  {..[..).t$@bX.R.
0000040: 73 82 77 d7 9d 13 97 53 71 76 9f b2 99 ca 36 1e  s.w....Sqv....6.
0000050: d4 e1 df 0d be c4 07 1e a0 f2 f2 e9 ef 32 fa 00  .............2..
0000060: 4b 0b 8e c2 91 ba 8b 1d 1c 4d f0 98 6c 64 c5 9e  K........M..ld..
0000070: 4d ee 58 17 06 20 c9 3c 9a f0 33 bb a8 fc 7b 7b  M.X.. .&lt;..3...{{
0000080: 6c f9 c6 fd a0 17 76 3a 3d 1d 7e e7 42 c2 49 ad  l.....v:=.~.B.I.
0000090: 4c 26 ae b6 f6 dc 99 a3 24 99 1a 30 d9 02 01 11  L&amp;......$..0....
</code></pre>
","309","<android><android-ndk><rsa><crypto++>","1","1","1","2016-10-19 09:10:54","","5","","608639","","2016-10-19 03:08:50","2016-10-19 02:05:35",""
"34167305","Having trouble decrypting a well-formed cipher text using Crypto++","<h2>Background</h2>

<p>I've been struggling with decrypting an apparently well-formed cipher text for about a day. Assume we've got the following hex-encoded cipher text which contains exactly 160 characters thereby having 80 bytes.</p>

<pre><code>QString c = ""1BFAC407AF0D440A2D6176C0B5D125AA96088490299AC18C74623C0EF1BB1372E554FC4150A8066220E943697BE2491D8AE13AA036B298425AC510A8A917D59EBB69708B9040AB3A84C63043EAD4AB07"";
QString k = CryptoUtils::hexEncode(""abc"");
QString p = CryptoUtils::decrypt(c, k);

qDebug() &lt;&lt; p;
</code></pre>

<p>Provided we're using AES 256, AFAIK, the key must be of length 32 bytes and cipher text of a length of multiple of 16 bytes, which all these consditions are met regarding my snippet code.</p>

<p>Please note that I'm using SHA256 feeding with a pass phrase to generate a 32 bytes key. So, this ensures that all keys are of length 32 bytes.</p>

<p><a href=""https://github.com/abforce/DBO-Proxy-Server/blob/Part1/Sources/CPPs/Utils/cryptoutils.cpp"" rel=""nofollow"">Full source codes</a> of those function can be found on my repo on GitHub (at branch Part1).</p>

<hr>

<h2>My Question</h2>

<p>When I want to run this code, my app crashes. Here's the exception:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
The program has unexpectedly finished.
</code></pre>

<p>I searched around about this problem and figured out it could be because of the trailing <code>\0</code> once you encrypted the plain text. However, I couldn't just solve the problem. Please help me out, it's just driving me crazy.</p>
","<blockquote>
  <p>Full source codes of those function can be found on my repo on GitHub</p>
</blockquote>

<p>I'd make these changes at minimum:</p>

<pre><code>QString CryptoUtils::encrypt(QString text, QString keyhex)
{
    ...

    // name the variable, kill the memory leak
    SHA256 sha256;
    StringSource ss1(decodedKey, size, true, new HashFilter(sha256, new ArraySink(key, AES::MAX_KEYLENGTH)));
    ...

    // name the variable
    StringSource ss2(plain, true, new StreamTransformationFilter(Encryptor, new HexEncoder(new StringSink(encrypted))));

    // verify embedded NULLs don't affect results
    QString qs = QString::fromStdString(encrypted);
    assert(qs.length() == encrypted.length());
}
</code></pre>

<p>And:</p>

<pre><code>QString CryptoUtils::decrypt(QString text, QString keyhex)
{
    // bad karma here...
    string encrypted = text.toStdString();
    assert(encrypted.length() == text.length());
    ...

    // name the variable, kill the memory leak
    SHA256 sha256;
    StringSource ss1(decodedKey, size, true, new HashFilter(sha256, new ArraySink(key, AES::MAX_KEYLENGTH)));
    ...

    // name the variable,
    StringSource ss2(encrypted, true, new HexDecoder(new StreamTransformationFilter(Decryptor, new StringSink(plain))));

    // verify embedded NULLs don't affect results
    QString qs = QString::fromStdString(plain);
    assert(qs.length() == plain.length());
}
</code></pre>
","309","<qt><encryption><aes><crypto++>","2","1","2","2015-12-11 19:40:47","34197549","3","0","","","","2015-12-08 22:30:05",""
"34167305","Having trouble decrypting a well-formed cipher text using Crypto++","<h2>Background</h2>

<p>I've been struggling with decrypting an apparently well-formed cipher text for about a day. Assume we've got the following hex-encoded cipher text which contains exactly 160 characters thereby having 80 bytes.</p>

<pre><code>QString c = ""1BFAC407AF0D440A2D6176C0B5D125AA96088490299AC18C74623C0EF1BB1372E554FC4150A8066220E943697BE2491D8AE13AA036B298425AC510A8A917D59EBB69708B9040AB3A84C63043EAD4AB07"";
QString k = CryptoUtils::hexEncode(""abc"");
QString p = CryptoUtils::decrypt(c, k);

qDebug() &lt;&lt; p;
</code></pre>

<p>Provided we're using AES 256, AFAIK, the key must be of length 32 bytes and cipher text of a length of multiple of 16 bytes, which all these consditions are met regarding my snippet code.</p>

<p>Please note that I'm using SHA256 feeding with a pass phrase to generate a 32 bytes key. So, this ensures that all keys are of length 32 bytes.</p>

<p><a href=""https://github.com/abforce/DBO-Proxy-Server/blob/Part1/Sources/CPPs/Utils/cryptoutils.cpp"" rel=""nofollow"">Full source codes</a> of those function can be found on my repo on GitHub (at branch Part1).</p>

<hr>

<h2>My Question</h2>

<p>When I want to run this code, my app crashes. Here's the exception:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
The program has unexpectedly finished.
</code></pre>

<p>I searched around about this problem and figured out it could be because of the trailing <code>\0</code> once you encrypted the plain text. However, I couldn't just solve the problem. Please help me out, it's just driving me crazy.</p>
","<p>The <code>hexEncode</code> function seems to misbehave:</p>

<pre><code>QString CryptoUtils::hexEncode(QString text)
{
    byte *bytearray = (byte *) text.toLatin1().data();
    int length = text.toLatin1().length();

    return hexEncode(bytearray, length);
}
</code></pre>

<p>Should be replaced with:</p>

<pre><code>QString CryptoUtils::hexEncode(QString text)
{
    byte *bytearray = (byte *) text.toStdString().data();
    int length = text.length();

    return hexEncode(bytearray, length);
}
</code></pre>
","309","<qt><encryption><aes><crypto++>","2","0","2","2015-12-11 19:40:47","34197549","3","0","","","","2015-12-08 22:30:05",""
"2790888","build errors with Crypto++ on iphone","<p>I am trying to build Crypto++ for iPhone but encountering issues.  I managed to get it to build to the device by removing a few .asm files and test.cpp but two issues:</p>

<p>1) the simulator gets build errors relating to:<br>
  {standard input}:13583:suffix or operands invalid for `call'<p>
2) there are hundreds of warnings (kind of annoying)</p>

<p>Has anyone gotten crypto++ to work on iphone and found a way to resolve these issues?</p>
","<p>I found someone who ported to iPhone here: <a href=""http://www.ugosweb.com/cryptopp.aspx#ip"" rel=""nofollow noreferrer"">http://www.ugosweb.com/cryptopp.aspx#ip</a></p>

<p>A few things to keep in mind when using it are to set the preprocessor directive as described, but often being able to see the setting to add that directive requires selecting ""Active SDK::Use Base SDK"" from the top left drop down of xcode, <em>then</em> going into the target settings (get info).  Without these steps, the setting in the target settings just isn't there, at least with some xcode versions.</p>

<p>Further, copying the ported proj files works fine but be sure to leave out of your project the ones he leaves out.  The files are still around in his crypto folder so do not do a blanket file add to the project and leave it at that.</p>
","307","<iphone><build><crypto++>","1","1","1","2010-05-08 03:35:31","2792849","0","","","","","2010-05-07 18:41:48",""
"34741428","BouncyCastle RSA Probabilistic Signature Scheme with Recovery","<p>The following code sign message with recovery, How implementation with C# BouncyCastle? </p>

<pre><code>std::vector&lt;unsigned char&gt; data{ 1,2,3,4,5,6 };

CryptoPP::AutoSeededRandomPool rng;
CryptoPP::InvertibleRSAFunction params;
params.GenerateRandomWithKeySize(rng, 2048);

CryptoPP::RSA::PrivateKey privateKey(params);
CryptoPP::RSA::PublicKey publicKey(params);
CryptoPP::RSASS&lt;CryptoPP::PSSR, CryptoPP::SHA1&gt;::Signer signer(privateKey);

CryptoPP::SecByteBlock signature(signer.MaxSignatureLength(data.size()));

unsigned long signatureLen = signer.SignMessageWithRecovery(rng, &amp;data[0],
    data.size(), NULL, 0, signature);

std::vector&lt;unsigned char&gt; encrypted;
encrypted.assign(signatureLen, 0);
memcpy(&amp;encrypted[0], signature.m_ptr, signatureLen);
</code></pre>
","<p>I think the <a href=""http://www.bouncycastle.org/docs/docs1.5on/index.html?org/bouncycastle/crypto/signers/ISO9796d2PSSSigner.html"" rel=""nofollow""><code>Iso9796d2PssSigner</code></a> class in the <a href=""http://www.bouncycastle.org/docs/docs1.5on/index.html?org/bouncycastle/crypto/signers/ISO9796d2PSSSigner.html"" rel=""nofollow""><code>Org.BouncyCastle.Crypto.Signers</code></a> namespace should probably do what you want. You can find examples of use in the source of ISO9796Test.cs.</p>
","306","<c#><bouncycastle><crypto++>","2","3","1","2016-01-18 22:51:04","34752998","1","","608639","","2016-01-12 11:25:08","2016-01-12 10:40:35",""
"29902020","Integer to string conversion issues","<p>I am experiencing a few problems with Crypto++'s <code>Integer</code> class. I am using the latest release, 5.6.2.</p>

<p>I'm attempting to convert Integer to string with the following code:</p>

<pre><code>CryptoPP::Integer i(""12345678900987654321"");

std::ostrstream oss;
oss &lt;&lt; i;
std::string s(oss.str());
LOGDEBUG(oss.str()); // Pumps log to console and log file
</code></pre>

<p>The output appears to have extra garbage data:</p>

<pre><code>12345678900987654321.ÍÍÍÍÍÍÍÍÍÍÍýýýý««««««««îþîþ
</code></pre>

<p>I get the same thing when I output directly to the console:</p>

<pre><code>std::cout &lt;&lt; ""Dec: "" &lt;&lt; i &lt;&lt; std::endl; // Same result
</code></pre>

<p>Additionally, I cannot get precision or scientific notation working. The following will output the same results:</p>

<pre><code>std::cout.precision(5); // Does nothing with CryptoPP::Integer
std::cout &lt;&lt; ""Dec: "" &lt;&lt; std::setprecision(1) &lt;&lt; std::dec &lt;&lt; i &lt;&lt; std::endl;
std::cout &lt;&lt; ""Sci: "" &lt;&lt; std::setprecision(5) &lt;&lt; std::scientific &lt;&lt; i &lt;&lt; std::endl;
</code></pre>

<p>On top of all of this, sufficiently large numbers breaks the entire thing.</p>

<pre><code>CryptoPP::Integer i(""12345"");

// Calculate i^16
for (int x = 0; x &lt; 16; x++)
{
    i *= i;
}

std::cout  &lt;&lt; i &lt;&lt; std::endl; // Will never finish
</code></pre>

<p>Ultimately I'm trying to get something where I can work with large <code>Integer</code> numbers, and can output a string in scientific notation. I have no problems with extracting the <code>Integer</code> library or modifying it as necessary, but I would prefer working with stable code.</p>

<p>Am I doing something wrong, or is there a way that I can get this working correctly? </p>
","<blockquote>
  <p>I'm attempting to convert Integer to string with the following code:</p>

<pre><code>CryptoPP::Integer i(""12345678900987654321"");

std::ostrstream oss;
oss &lt;&lt; i;
std::string s(oss.str());
LOGDEBUG(oss.str()); // Pumps log to console and log file
</code></pre>
  
  <p>The output appears to have extra garbage data:</p>

<pre><code>12345678900987654321.ÍÍÍÍÍÍÍÍÍÍÍýýýý««««««««îþîþ
</code></pre>
</blockquote>

<p>I can't reproduce this with Crypto++ 5.6.2 on Visual Studio 2010. The corrupted output is likely the result of some other issue, not a bug in Crypto++. If you haven't done so already, I'd suggest trying to reproduce this in a minimal program just using <code>CryptoPP::Integer</code> and <code>std::cout</code>, and none of your other application code, to eliminate all other possible problems. If it's not working in a trivial stand-alone test (which would be surprising), there could be problems with the way the library was built (e.g. maybe it was built with a different C++ runtime or compiler version from what your application is using). If your stand-alone test passes, you can add in other string operations, logging code etc. until you find the culprit.</p>

<p>I do notice though that you're using <a href=""http://en.cppreference.com/w/cpp/io/ostrstream"" rel=""nofollow noreferrer""><code>std::ostrstream</code></a> which is deprecated. You may want to use <a href=""http://en.cppreference.com/w/cpp/io/basic_ostringstream"" rel=""nofollow noreferrer""><code>std::ostringstream</code> instead</a>. <a href=""https://stackoverflow.com/a/2820289/4486839"">This Stack Overflow answer to the question ""Why was std::strstream deprecated?""</a> may be of interest, and it may even the case that the issues mentioned in that answer are causing your problems here.</p>

<blockquote>
  <p>Additionally, I cannot get precision or scientific notation working.
  The following will output the same results:</p>

<pre><code>std::cout.precision(5); // Does nothing with CryptoPP::Integer
std::cout &lt;&lt; ""Dec: "" &lt;&lt; std::setprecision(1) &lt;&lt; std::dec &lt;&lt; i &lt;&lt; std::endl;
std::cout &lt;&lt; ""Sci: "" &lt;&lt; std::setprecision(5) &lt;&lt; std::scientific &lt;&lt; i &lt;&lt; std::endl;
</code></pre>
</blockquote>

<p><code>std::setprecision</code> and <code>std::scientific</code> <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed"" rel=""nofollow noreferrer"">modify floating-point input/output</a>. So, with regular integer types in C++ like <code>int</code> or <code>long long</code> this wouldn't work either (but I can see that especially with arbitrary-length integers like <code>CryptoPP:Integer</code> being able to output in scientific notation with a specified precision would make sense).</p>

<p>Even if C++ didn't define it like this, Crypto++'s implementation would still need to heed those flags. From looking at the Crypto++ implementation of <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Integer &amp;a)</code>, I can see that the only iostream flags it recognizes are <code>std::ios::oct</code> and <code>std::ios::hex</code> (for octal and hex format numbers respectively).</p>

<p>If you want scientific notation, you'll have to format the output yourself (or use a different library).</p>

<blockquote>
  <p>On top of all of this, sufficiently large numbers breaks the entire
  thing.</p>

<pre><code>CryptoPP::Integer i(""12345"");

// Calculate i^16
for (int x = 0; x &lt; 16; x++)
{
    i *= i;
}

std::cout  &lt;&lt; i &lt;&lt; std::endl; // Will never finish
</code></pre>
</blockquote>

<p>That will actually calculate <code>i^(2^16) = i^65536</code>, not <code>i^16</code>, because on each loop you're multiplying <code>i</code> with its new intermediate value, not with its original value. The actual result with this code would be 268,140 digits long, so I expect it's just taking Crypto++ a long time to produce that output.</p>

<p>Here is the code adjusted to produce the correct result:</p>

<pre><code>CryptoPP::Integer i(""12345"");
CryptoPP::Integer i_to_16(1);

// Calculate i^16
for (int x = 0; x &lt; 16; x++)
{
    i_to_16 *= i;
}

std::cout &lt;&lt; i_to_16 &lt;&lt; std::endl;
</code></pre>
","302","<c++><crypto++>","1","2","2","2015-05-06 05:09:36","29929378","6","0","608639","","2015-04-28 21:25:37","2015-04-27 17:13:10",""
"29902020","Integer to string conversion issues","<p>I am experiencing a few problems with Crypto++'s <code>Integer</code> class. I am using the latest release, 5.6.2.</p>

<p>I'm attempting to convert Integer to string with the following code:</p>

<pre><code>CryptoPP::Integer i(""12345678900987654321"");

std::ostrstream oss;
oss &lt;&lt; i;
std::string s(oss.str());
LOGDEBUG(oss.str()); // Pumps log to console and log file
</code></pre>

<p>The output appears to have extra garbage data:</p>

<pre><code>12345678900987654321.ÍÍÍÍÍÍÍÍÍÍÍýýýý««««««««îþîþ
</code></pre>

<p>I get the same thing when I output directly to the console:</p>

<pre><code>std::cout &lt;&lt; ""Dec: "" &lt;&lt; i &lt;&lt; std::endl; // Same result
</code></pre>

<p>Additionally, I cannot get precision or scientific notation working. The following will output the same results:</p>

<pre><code>std::cout.precision(5); // Does nothing with CryptoPP::Integer
std::cout &lt;&lt; ""Dec: "" &lt;&lt; std::setprecision(1) &lt;&lt; std::dec &lt;&lt; i &lt;&lt; std::endl;
std::cout &lt;&lt; ""Sci: "" &lt;&lt; std::setprecision(5) &lt;&lt; std::scientific &lt;&lt; i &lt;&lt; std::endl;
</code></pre>

<p>On top of all of this, sufficiently large numbers breaks the entire thing.</p>

<pre><code>CryptoPP::Integer i(""12345"");

// Calculate i^16
for (int x = 0; x &lt; 16; x++)
{
    i *= i;
}

std::cout  &lt;&lt; i &lt;&lt; std::endl; // Will never finish
</code></pre>

<p>Ultimately I'm trying to get something where I can work with large <code>Integer</code> numbers, and can output a string in scientific notation. I have no problems with extracting the <code>Integer</code> library or modifying it as necessary, but I would prefer working with stable code.</p>

<p>Am I doing something wrong, or is there a way that I can get this working correctly? </p>
","<blockquote>
<pre><code>LOGDEBUG(oss.str()); // Pumps log to console and log file
</code></pre>
  
  <p>The output appears to have extra garbage data:</p>

<pre><code>12345678900987654321.ÍÍÍÍÍÍÍÍÍÍÍýýýý««««««««îþîþ
</code></pre>
</blockquote>

<p>I suspect what you presented is slighty simplified from what you are doing in real life. I believe the problem is related to <code>LOGDEBUG</code> and the <code>ostringstream</code>. And I believe you are outputting <code>char*</code>'s, and not <code>string</code>'s (though we have not seen the code for your loggers).</p>

<p>The <code>std::string</code> returned from <code>oss.str()</code> is temporary. So this:</p>

<pre><code>LOGDEBUG(oss.str());
</code></pre>

<p>Is slighty different than this:</p>

<pre><code>string t(oss.str());
LOGDEBUG(t);
</code></pre>

<p>You should always make a copy of the <code>string</code> in an <code>ostringstream</code> when you intend to use it. Or <em>ensure</em> the use is contained in <em>one</em> statement.</p>

<p>The best way I've found is to have:</p>

<pre><code>// Note: reference, and the char* is used in one statement
void LOGDEBUG(const ostringstream&amp; oss) {
    cout &lt;&lt; oss.str().c_str() &lt;&lt; endl;
}
</code></pre>

<p>Or</p>

<pre><code>// Note: copy of the string below
void LOGDEBUG(string str) {
    cout &lt;&lt; str.c_str() &lt;&lt; endl;
}
</code></pre>

<p>You <em>can't</em> even do this (this one bit me in production):</p>

<pre><code>const char* msg = oss.str().c_str();
cout &lt;&lt; msg &lt;&lt; endl;
</code></pre>

<p>You can't do it because the <code>string</code> returned from <code>oss.str()</code> is temporary. So the <code>char*</code> is junk after the statement executes.</p>

<p>Here's how you fix it:</p>

<pre><code>const string t(oss.str());
const char* msg = t.c_str();
cout &lt;&lt; msg &lt;&lt; endl;
</code></pre>

<p>If you run <em>Valgrind</em> on your program, then you will probably get what should seem to be unexplained findings related to your use of <code>ostringstream</code> and <code>strings</code>.</p>

<p>Here is a similar logging problem: <a href=""https://stackoverflow.com/q/1540831/608639"">stringstream temporary ostream return problem</a>. Also see <a href=""https://stackoverflow.com/q/2433071/608639"">Turning temporary stringstream to c_str() in single statement</a>. And here was the one I experienced: <a href=""https://stackoverflow.com/q/21283133/608639"">Memory Error with std:ostringstream and -std=c++11?</a></p>

<hr>

<p>As Matt pointed out in the comment below, you should be using an <code>ostringstream</code>, and not an <code>ostrstream</code>. <code>ostrstream</code> has been deprecated since C++98, and you should have gotten a warning when using it.</p>

<p>So use this instead:</p>

<pre><code>#include &lt;sstream&gt;
...

std::ostringstream oss;
...
</code></pre>

<p>But I believe the root of the problem is the way you are using the <code>std::string</code> in the <code>LOGDEBUG</code> function or macro.</p>

<hr>

<p>Your other questions related to Integer were handled in Softwariness's answer and related comments. So I won't rehash them again.</p>
","302","<c++><crypto++>","1","1","2","2015-05-06 05:09:36","29929378","6","0","608639","","2015-04-28 21:25:37","2015-04-27 17:13:10",""
"20781563","How can I recover compressed y value from sender?","<p>I am working on following scenario:</p>

<ol>
<li>Generate private and public key</li>
<li><p>Generate compressed public key with:</p>

<p><code>PublicKey.AccessGroupParameters().SetPointCompression(true)</code></p></li>
<li><p>Sign some data and send to other end with compressed public key.</p></li>
<li><p>[At other end] verify signature using public key</p></li>
</ol>

<p>For step 4, I need recover y value. Is there some API I can use among Crypto++?</p>
","<blockquote>
  <p>For step 4, I need recover y value. Is there some API I can use among Crypto++?</p>
</blockquote>

<p>During verification, you will load the persisted or serialized key after setting point compression to <code>true</code>.</p>

<hr>

<p>Below is a little program to experiment with point compression. You can find it on the Crypto++ wiki under <a href=""http://www.cryptopp.com/wiki/Point_Compression"" rel=""nofollow"">Point Compression</a>.</p>

<p>It generates a random key, then creates two public key - one with and and without compression. They two public keys are serialized. Then, it loads two new public keys with the serialized values.</p>

<p>Key 1 (no compress) and Key 2 (compress) and saved, then Key 3 (no compress) and Key 4 (no compress) are loaded from saved values. The keys are the same, and the output is:</p>

<pre><code>$ ./cryptopp-test.exe
Key 1 size (no compression): 214
  3081D33081A406072A8648CE3D0201308198020101302006072A8648CE3D0101021500FFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFF7FFFFFFF302C0414FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC0414
1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA450429044A96B5688EF573284664698968C38BB913CB
FC8223A628553168947D59DCC912042351377AC5FB3202150100000000000000000001F4C8F927AED3
CA752257020101032A0004CBFD13CEB20D677D9D3781AFA2E66B7BD5BC0E3C4EB8702144AA62BE5235
DFC691567AA2A7101AB1

Key 2 size (compression): 174
  3081AB30819006072A8648CE3D0201308184020101302006072A8648CE3D0101021500FFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFF7FFFFFFF302C0414FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC0414
1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA450415024A96B5688EF573284664698968C38BB913CB
FC8202150100000000000000000001F4C8F927AED3CA75225702010103160003CBFD13CEB20D677D9D
3781AFA2E66B7BD5BC0E3C

Key 3 (after deserialization of Key 1):
  y3.x: cbfd13ceb20d677d9d3781afa2e66b7bd5bc0e3ch
  y3.y: 4eb8702144aa62be5235dfc691567aa2a7101ab1h
Key 4 (after deserialization of Key 2):
  y4.x: cbfd13ceb20d677d9d3781afa2e66b7bd5bc0e3ch
  y4.y: 4eb8702144aa62be5235dfc691567aa2a7101ab1h
</code></pre>

<p>Here's the program to create, copy, save, load, compress, uncompress and serialize the keys and points.</p>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;cryptopp/osrng.h&gt;
using CryptoPP::AutoSeededRandomPool;

#include &lt;cryptopp/secblock.h&gt;
using CryptoPP::SecByteBlock;

#include &lt;cryptopp/filters.h&gt;
using CryptoPP::StringSource;
using CryptoPP::StringSink;

#include &lt;cryptopp/hex.h&gt;
using CryptoPP::HexEncoder;

#include &lt;cryptopp/sha.h&gt;
using CryptoPP::SHA1;

#include &lt;cryptopp/integer.h&gt;
using CryptoPP::Integer;

#include &lt;cryptopp/eccrypto.h&gt;
using CryptoPP::ECP;
using CryptoPP::ECDSA;

#include &lt;cryptopp/oids.h&gt;
using CryptoPP::ASN1::secp160r1;

int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    // Generate a private key, and two public keys.
    //   One with and one without compression
    ECDSA&lt;ECP, SHA1&gt;::PrivateKey privateKey;
    privateKey.Initialize(prng, secp160r1());

    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey1;
    privateKey.MakePublicKey(publicKey1);

    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey2;
    privateKey.MakePublicKey(publicKey2);
    publicKey2.AccessGroupParameters().SetPointCompression(true);

    // Save the public keys
    string p1, p2;
    publicKey1.Save(StringSink(p1).Ref());
    publicKey2.Save(StringSink(p2).Ref());

    // Print some stuff about them
    string s3, s4;
    StringSource ss3(p1, true, new HexEncoder(new StringSink(s3)));
    StringSource ss4(p2, true, new HexEncoder(new StringSink(s4)));

    cout &lt;&lt; ""Key 1 (not compressed): "" &lt;&lt; p1.size() &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""  "" &lt;&lt; s3 &lt;&lt; endl;
    cout &lt;&lt; ""Key 2 (compressed): "" &lt;&lt; p2.size() &lt;&lt; "" bytes"" &lt;&lt; endl;
    cout &lt;&lt; ""  "" &lt;&lt; s4 &lt;&lt; endl;
    cout &lt;&lt; endl;

    // Two new keys to load up the persisted keys
    ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey3, publicKey4;
    publicKey4.AccessGroupParameters().SetPointCompression(true);

    publicKey3.Load(StringSource(p1, true).Ref());
    publicKey4.Load(StringSource(p2, true).Ref());

    // And validate them
    publicKey3.Validate(prng, 3);
    publicKey4.Validate(prng, 3);

    // Get the public elements of the loaded keys
    const ECP::Point&amp; y3 = publicKey3.GetPublicElement();
    const Integer&amp; y3_x = y3.x;
    const Integer&amp; y3_y = y3.y;

    const ECP::Point&amp; y4 = publicKey4.GetPublicElement();
    const Integer&amp; y4_x = y4.x;
    const Integer&amp; y4_y = y4.y;

    // Print some stuff about them
    cout &lt;&lt; ""Key 3 (after deserialization of Key 1):"" &lt;&lt; endl;
    cout &lt;&lt; ""  y3.x: "" &lt;&lt; std::hex &lt;&lt; y3_x &lt;&lt; endl;
    cout &lt;&lt; ""  y3.y: "" &lt;&lt; std::hex &lt;&lt; y3_y &lt;&lt; endl;
    cout &lt;&lt; ""Key 4 (after deserialization of Key 2):"" &lt;&lt; endl;
    cout &lt;&lt; ""  y4.x: "" &lt;&lt; std::hex &lt;&lt; y4_x &lt;&lt; endl;
    cout &lt;&lt; ""  y4.y: "" &lt;&lt; std::hex &lt;&lt; y4_y &lt;&lt; endl;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>

<hr>

<p>You can even cross wires when loading the serialized keys and it just works. Below, the compressed key was loaded from a non-compressed serialization (and vice-versa):</p>

<pre><code>//////////////////////////////////////////////////////////////////////
// Two new keys to load up the persisted keys, but crossing wires
//   so so there's a compress/uncompressed mismatch
ECDSA&lt;ECP, SHA1&gt;::PublicKey publicKey5, publicKey6;
publicKey6.AccessGroupParameters().SetPointCompression(true);

// This should be `p1`
publicKey5.Load(StringSource(p2, true).Ref());
// This should be `p2`
publicKey6.Load(StringSource(p1, true).Ref());

// Get the public elemnts of the loaded keys
const ECP::Point&amp; y5 = publicKey5.GetPublicElement();
const Integer&amp; y5_x = y5.x;
const Integer&amp; y5_y = y5.y;

const ECP::Point&amp; y6 = publicKey6.GetPublicElement();
const Integer&amp; y6_x = y6.x;
const Integer&amp; y6_y = y6.y;

// Print some stuff about them
cout &lt;&lt; ""Key 5 (after deserialization of Key 1):"" &lt;&lt; endl;
cout &lt;&lt; ""  y5.x: "" &lt;&lt; std::hex &lt;&lt; y5_x &lt;&lt; endl;
cout &lt;&lt; ""  y5.y: "" &lt;&lt; std::hex &lt;&lt; y5_y &lt;&lt; endl;
cout &lt;&lt; ""Key 6 (after deserialization of Key 2):"" &lt;&lt; endl;
cout &lt;&lt; ""  y6.x: "" &lt;&lt; std::hex &lt;&lt; y6_x &lt;&lt; endl;
cout &lt;&lt; ""  y6.y: "" &lt;&lt; std::hex &lt;&lt; y6_y &lt;&lt; endl;
cout &lt;&lt; endl;
</code></pre>

<hr>

<p>If you want to get at the underlying domain parameters (like the base point), use:</p>

<pre><code>const DL_GroupParameters_EC&lt; ECP &gt;&amp; params = publicKey.GetGroupParameters()
</code></pre>
","297","<signing><elliptic-curve><crypto++><ecdsa><compression>","1","3","1","2019-02-01 11:30:57","21036981","0","","608639","","2015-10-19 17:42:13","2013-12-26 08:23:25",""
"20527947","cryptopp on centos4.8 segmentation fault when link with pthread","<p>I have a program compiled and running on centos4.8.  I have downloaded and compiled cryptopp 5.6.2 into a static library.  When running a test program I get a segmentation fault on call to </p>

<pre><code>CTR_Mode&lt; AES &gt;::Encryption e;
e.SetKeyWithIV( key, key.size(), ctr ); // segmentation fault here
</code></pre>

<p>I can recreate this in a small program.  If I link with libpthread.a I get the fault, if I do not link with it, the program runs as expected.</p>

<p>My application depends on linking with pthread, so I am hoping to find a way to compile cryptopp that is compatible.
Thank you</p>
","<p>So it seems...</p>

<p>On CentOS 4.8 with gcc 3.4.6 cryptopp needs #define CRYPTOPP_DISABLE_UNCAUGHT_EXCEPTION when linking statically.  Hope this saves someone some time!</p>
","296","<c++><linux><centos><crypto++>","2","1","1","2013-12-12 16:48:42","","5","","","","","2013-12-11 19:12:46",""
"39476502","HashVerificationFilter: message hash or MAC not valid Error on modified GCM AE code","<p>I am referring to sample code on Crypto++ wiki at <a href=""https://www.cryptopp.com/wiki/CCM_Mode"" rel=""nofollow noreferrer"">CCM Mode</a>. I have done few modifications for testing purposes and now it is throwing:</p>

<pre><code>terminate called after throwing an instance of 'HashVerificationFilter::HashVerificationFailed'
what(): HashVerificationFilter: message hash or MAC not valid
Aborted (core dumped)
</code></pre>

<p>I have seen <a href=""https://stackoverflow.com/questions/30936448/message-hash-or-mac-not-valid-exception-after-decryption"">'message hash or MAC not valid' exception after decryption</a>. But I would like to pass byte array instead of string, so I think I have to use <code>sizeof()</code> operator instead of <code>size()</code>. The code is below.</p>

<p>When pass key and iv, <code>sizeof</code> function is giving their sizes as 8 instead 16 bytes. </p>

<p>Is the error because of <code>AuthenticatedDecryptionFilter::DEFAULT_FLAGS</code>? </p>

<hr>

<p>Here is the code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
//#include ""libcryptoWrapperGCM.h""
using std::cout;
using std::endl;
using std::cerr;

#include &lt;string&gt;
#include &lt;stdint.h&gt;
using std::string;

#include ""hex.h""
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include ""osrng.h""
using CryptoPP::AutoSeededRandomPool;

#include ""cryptlib.h""
using CryptoPP::BufferedTransformation;
using CryptoPP::AuthenticatedSymmetricCipher;

#include ""filters.h""
using CryptoPP::Redirector;
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::AuthenticatedEncryptionFilter;
using CryptoPP::AuthenticatedDecryptionFilter;

#include ""aes.h""
using CryptoPP::AES;

#include ""gcm.h""
using CryptoPP::GCM;

#include ""assert.h""

void GCM_Encode(byte key[], byte iv[], string pdata, string cipher, const int TAG_SIZE)
    {

        // Encrypted, with Tag
        string encoded;

        cout &lt;&lt; ""key size= "" &lt;&lt; sizeof(key) &lt;&lt; endl;
        cout &lt;&lt; ""IV size= "" &lt;&lt; sizeof(iv) &lt;&lt; endl;

        /*********************************\
        \*********************************/

        try
        {
            GCM&lt; AES &gt;::Encryption e;
            e.SetKeyWithIV( key, sizeof(key), iv, sizeof(iv) );

            StringSource ss1( pdata, true,
                new AuthenticatedEncryptionFilter( e,
                    new StringSink( cipher ), false, TAG_SIZE
                ) // AuthenticatedEncryptionFilter
            ); // StringSource

            cout &lt;&lt; ""Encoded value: "" &lt;&lt; cipher &lt;&lt; endl;
        }
        catch( CryptoPP::Exception&amp; e )
        {
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            exit(1);
        }
    }

        /*********************************\
        \*********************************/

void GCM_Decode(byte key[], byte iv[], string cipher, string rpdata, const int TAG_SIZE)
    {
        try
        {
            GCM&lt; AES &gt;::Decryption d;
            d.SetKeyWithIV( key, sizeof(key), iv, sizeof(iv) );

            AuthenticatedDecryptionFilter df( d,
                new StringSink( rpdata ),
                AuthenticatedDecryptionFilter::DEFAULT_FLAGS, TAG_SIZE
            ); // AuthenticatedDecryptionFilter

            // The StringSource dtor will be called immediately
            //  after construction below. This will cause the
            //  destruction of objects it owns. To stop the
            //  behavior so we can get the decoding result from
            //  the DecryptionFilter, we must use a redirector
            //  or manually Put(...) into the filter without
            //  using a StringSource.
            StringSource ss2( cipher, true,
                new Redirector( df /*, PASS_EVERYTHING */ )
            ); // StringSource

            // If the object does not throw, here's the only
            //  opportunity to check the data's integrity
            if( true == df.GetLastResult() ) {
                cout &lt;&lt; ""recovered text: "" &lt;&lt; rpdata &lt;&lt; endl;
            }
        }
        catch( CryptoPP::Exception&amp; e )
        {
            cerr &lt;&lt; e.what() &lt;&lt; endl;
            exit(1);
        }

    }

int main()
{
    byte key[]= {0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f};
    byte iv[] = {0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f};
    string pdata = ""Authenticated Encryption"";
    const int TAG_SIZE = 12;
    string rpdata, cipher;

    //void GCM_Encode(byte key[], byte iv[],  string pdata, string cipher, const int TAG_SIZE)
    GCM_Encode( key, iv, pdata, cipher, TAG_SIZE);
    cout &lt;&lt; ""======INT MAIN======"" &lt;&lt; endl;
    cout &lt;&lt; ""Encryption complete"" &lt;&lt; endl;
    cout &lt;&lt; ""cipher= "" &lt;&lt; cipher &lt;&lt; endl; 


    //void GCM_Decode(byte key[], byte iv[], string cipher, string rpdata, const int TAG_SIZE)
    GCM_Decode( key, iv, cipher, rpdata, TAG_SIZE);
    cout &lt;&lt; ""Decryption complete"" &lt;&lt; endl;
    cout &lt;&lt; ""rpdata= "" &lt;&lt; rpdata &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>GDB output is,</p>

<pre><code>Encryption complete
cipher= 
HashVerificationFilter: message hash or MAC not valid
[Inferior 1 (process 16632) exited with code 01]
</code></pre>

<p>Compilation command</p>

<pre><code>g++ -g3 -O3 -fPIC GCM_Test2.cpp -o GCMTest3 -lcryptopp -pthread -lrt -lc
</code></pre>

<p>Include path added using,</p>

<pre><code>export CPLUS_INCLUDE_PATH=/usr/local/include/cryptopp
</code></pre>

<p>No output on <code>locate raise.c</code></p>
","<p>Problem is that both functions GCM_Encode were interpreting wrong size of key and iv. </p>

<pre><code>cout &lt;&lt; ""sizeof(key)= "" &lt;&lt; sizeof(key) &lt;&lt; endl;
cout &lt;&lt; ""sizeof(iv)= "" &lt;&lt; sizeof(iv) &lt;&lt; endl;
</code></pre>

<p>is 8 and not 16. So idea is to convert it to string and get its size using <code>.size()</code> </p>

<pre><code>std::string key1( reinterpret_cast&lt;char const*&gt;(key), sizeof(key) )
std::string iv1( reinterpret_cast&lt;char const*&gt;(iv), sizeof(iv) )
</code></pre>

<p>But remember to provide original byte array to <code>SetKeyWithIV</code> function as it does not accept string as its argument. </p>

<pre><code>e.SetKeyWithIV( key, key1.size(), iv, iv1.size() )
</code></pre>
","295","<exception><encryption><aes><crypto++>","0","1","1","2016-09-15 05:58:34","","2","0","-1","","2017-05-23 10:33:51","2016-09-13 18:12:39",""
"24080135","AES encryption and decryption of the first 16 bytes of the cipher text","<p>I have a binary file which is encrypted using AES 128-bit encryption by other people.</p>

<p>Now I get the key in some ways. And I'm sure the key is correct.</p>

<p>The following is my code for decryption:</p>

<pre><code>const BYTE key[16] = {0x04 ,0x38, 0x04, 0x31, 0x2D ,0x32 ,0x0C ,0x30, 0x43 ,0x2E ,0x08 ,0x04, 0x16, 0x30 ,0x22 ,0x0C};

CryptoPP::AES::Decryption decryptor;
decryptor.SetKey(key, 16);

DWORD steps = len / CryptoPP::AES::BLOCKSIZE;
BYTE *cur = inbuff;

for (DWORD i = 0; i &lt; steps; i++)
{
    decryptor.ProcessBlock(cur);
    cur += CryptoPP::AES::BLOCKSIZE;
}
</code></pre>

<p>Strange thing is that only the first 16 bytes of the file can be decrypted correctly.</p>

<p>The rest of the decrypted bytes will become junk data...</p>

<p>Then what's wrong with my code?</p>
","","293","<c++><encryption><crypto++>","2","","0","2016-02-18 04:21:02","","1","1","608639","","2016-02-18 04:21:02","2014-06-06 10:55:58",""
"33397436","DSA public key bigger than private key","<p>If I generate a private and public key for DSA using Crypto++:</p>

<pre><code>CryptoPP::AutoSeededRandomPool rng;

CryptoPP::DSA::PrivateKey privateKey;

privateKey.GenerateRandomWithKeySize(rng, 2048);

CryptoPP::DSA::PublicKey publicKey;

privateKey.MakePublicKey(publicKey);
</code></pre>

<p>When I encode the private key like so:</p>

<pre><code>CryptoPP::ByteQueue privateKeyQueue;
key.DEREncodePrivateKey(privateKeyQueue);
</code></pre>

<p>Then the information pushed to the queue for the private key is smaller than the encoded data for the public key:</p>

<pre><code>CryptoPP::ByteQueue publicKeyQueue;
key.DEREncodePublicKey(publicKeyQueue);
</code></pre>

<p>Is this expected and is this the right way to generate my public key that will be shared with others?</p>

<p>I've only every worked with RSA before and the public key is much smaller than the private key.</p>
","<p>So... treading lightly because modulo arithmetic is not my strong point...</p>

<p>Source of my information is here:</p>

<p><a href=""https://en.wikipedia.org/wiki/Digital_Signature_Algorithm"" rel=""nofollow"">https://en.wikipedia.org/wiki/Digital_Signature_Algorithm</a></p>

<blockquote>
  <p>Choose an approved cryptographic hash function H. In the original DSS, H was always SHA-1, but the stronger SHA-2 hash functions are approved for use in the current DSS.[5][9] The hash output may be truncated to the size of a key pair.</p>
  
  <p>Decide on a key length L and N. This is the primary measure of the cryptographic strength of the key. The original DSS constrained L to be a multiple of 64 between 512 and 1024 (inclusive). NIST 800-57 recommends lengths of 2048 (or 3072) for keys with security lifetimes extending beyond 2010 (or 2030), using correspondingly longer N.[10] FIPS 186-3 specifies L and N length pairs of (1024,160), (2048,224), (2048,256), and (3072,256).</p>
  
  <p>Choose an N-bit prime q. N must be less than or equal to the hash output length.</p>
</blockquote>

<p>(so q is N bits long - say 256 for a 3072-bit key)</p>

<blockquote>
  <p>Choose an L-bit prime modulus p such that p–1 is a multiple of q.
  Choose g, a number whose multiplicative order modulo p is q. This may be done by setting g = h(p–1)/q mod p for some arbitrary h (1 &lt; h &lt; p−1), and trying again with a different h if the result comes out as 1. Most choices of h will lead to a usable g; commonly h=2 is used.</p>
</blockquote>

<p>(so p would be 3072 bits long)</p>

<p>The algorithm parameters (p, q, g) may be shared between different users of the system.</p>

<blockquote>
  <p>Per-user keys</p>
  
  <p>Given a set of parameters, the second phase computes private and public keys for a single user:</p>
  
  <p>Choose x by some random method, where 0 &lt; x &lt; q.
  Calculate y = gx mod p.</p>
  
  <p>Public key is (p, q, g, y). </p>
</blockquote>

<p>public key has a p in it - so it must be at least 3072 bits long</p>

<blockquote>
  <p>Private key is x.</p>
</blockquote>

<p>since x depends on q, it will have (in our case) 256 bits - this is the private key length.</p>

<p>Does that seem reasonable?</p>
","292","<c++><public-key-encryption><crypto++><dsa>","0","1","1","2015-11-03 18:33:43","33398949","0","","608639","","2015-11-03 18:33:43","2015-10-28 17:16:25",""
"47510106","Compiling bfx-cpp-api - Byte datatype undeclared","<p>So I am looking to compile this project <a href=""https://github.com/MMquant/bfx-cpp-api"" rel=""nofollow noreferrer"">https://github.com/MMquant/bfx-cpp-api</a> using the example code. I have included the cryptopp file that was suggested in the read me. It is found here: <a href=""https://github.com/weidai11/cryptopp"" rel=""nofollow noreferrer"">https://github.com/weidai11/cryptopp</a>.</p>

<p>I am using Ubutnu version 17.10 and the GNU compiler. </p>

<p>Here's how I am compiling:</p>

<pre><code>g++ example.cpp BitfinexAPI.cpp BitfinexAPI.hpp  -Icryptopp -I.  -o a -w -std=c++17
</code></pre>

<p>It seems strange that BitFinex would support broken code so I am fairly sure that the issue must be something that I am doing. </p>

<p>The errors I am getting are related to line 936 where the datatype 'byte' is not declared. My prediction is that I am missing a header file somewhere but any help would be appreciated. </p>

<hr>

<pre><code>$ g++ example.cpp BitfinexAPI.cpp BitfinexAPI.hpp  -Icryptopp -I.  -o a -w -std=c++17
BitfinexAPI.cpp: In static member function ‘static int BitfinexAPI::getBase64(const string&amp;, std::__cxx11::string&amp;)’:
BitfinexAPI.cpp:936:5: error: ‘byte’ was not declared in this scope
     byte buffer[1024] = {};
     ^~~~
BitfinexAPI.cpp:936:5: note: suggested alternative:
In file included from ../cryptopp/seckey.h:9:0,
                 from ../cryptopp/hmac.h:9,
                 from BitfinexAPI.cpp:37:
../cryptopp/config.h:222:23: note:   ‘CryptoPP::byte’
 typedef unsigned char byte;
                       ^~~~
BitfinexAPI.cpp:940:9: error: ‘buffer’ was not declared in this scope
         buffer[i] = content[i];
         ^~~~~~
BitfinexAPI.cpp:940:9: note: suggested alternative: ‘setbuffer’
         buffer[i] = content[i];
         ^~~~~~
         setbuffer
BitfinexAPI.cpp:943:21: error: ‘buffer’ was not declared in this scope
     StringSource ss(buffer, content.length(), true, new Base64Encoder( new StringSink(encoded), false));
                     ^~~~~~
BitfinexAPI.cpp:943:21: note: suggested alternative: ‘setbuffer’
     StringSource ss(buffer, content.length(), true, new Base64Encoder( new StringSink(encoded), false));
                     ^~~~~~
                     setbuffer
BitfinexAPI.cpp: In static member function ‘static int BitfinexAPI::getHmacSha384(const string&amp;, const string&amp;, std::__cxx11::string&amp;)’:
BitfinexAPI.cpp:963:33: error: ISO C++ forbids declaration of ‘type name’ with no type [-fpermissive]
     SecByteBlock byteKey((const byte*)key.data(), key.size());
                                 ^~~~
BitfinexAPI.cpp:963:27: error: expected primary-expression before ‘const’
     SecByteBlock byteKey((const byte*)key.data(), key.size());
                           ^~~~~
BitfinexAPI.cpp:963:27: error: expected ‘)’ before ‘const’
</code></pre>
","<p>A bit tricky but I (think?) found it. <code>byte</code> is defined in the <code>cryptopp</code> code at:</p>

<p><a href=""https://github.com/weidai11/cryptopp/blob/master/config.h"" rel=""nofollow noreferrer"">https://github.com/weidai11/cryptopp/blob/master/config.h</a></p>

<p>line 222. So I'm guessing the <code>config.h</code> on your system is non-existent, probably because you didn't properly install the header. A common problem is having the library</p>

<pre><code>sudo apt-get install libcrypto++
</code></pre>

<p>but missing the developer files (specifically the headers)</p>

<pre><code>sudo apt-get install libcrypto++-dev
</code></pre>

<p>I'm not 100% about the package names (Debian user), should be close though.</p>

<p><strong>Good catch from JTejedor</strong>:</p>

<p>Seems like the crypto guys placed a namespace around their definitions so as to not conflict with <code>std::byte</code>. You may want to add a <code>CryptoPP::</code> to the byte definition in bfx (line 936), and if that works open a bug to the guys over there (or request a pull).</p>
","291","<c++><gnu><crypto++>","2","2","2","2017-11-28 02:44:28","47512723","1","","608639","","2017-11-28 02:29:49","2017-11-27 11:38:51",""
"47510106","Compiling bfx-cpp-api - Byte datatype undeclared","<p>So I am looking to compile this project <a href=""https://github.com/MMquant/bfx-cpp-api"" rel=""nofollow noreferrer"">https://github.com/MMquant/bfx-cpp-api</a> using the example code. I have included the cryptopp file that was suggested in the read me. It is found here: <a href=""https://github.com/weidai11/cryptopp"" rel=""nofollow noreferrer"">https://github.com/weidai11/cryptopp</a>.</p>

<p>I am using Ubutnu version 17.10 and the GNU compiler. </p>

<p>Here's how I am compiling:</p>

<pre><code>g++ example.cpp BitfinexAPI.cpp BitfinexAPI.hpp  -Icryptopp -I.  -o a -w -std=c++17
</code></pre>

<p>It seems strange that BitFinex would support broken code so I am fairly sure that the issue must be something that I am doing. </p>

<p>The errors I am getting are related to line 936 where the datatype 'byte' is not declared. My prediction is that I am missing a header file somewhere but any help would be appreciated. </p>

<hr>

<pre><code>$ g++ example.cpp BitfinexAPI.cpp BitfinexAPI.hpp  -Icryptopp -I.  -o a -w -std=c++17
BitfinexAPI.cpp: In static member function ‘static int BitfinexAPI::getBase64(const string&amp;, std::__cxx11::string&amp;)’:
BitfinexAPI.cpp:936:5: error: ‘byte’ was not declared in this scope
     byte buffer[1024] = {};
     ^~~~
BitfinexAPI.cpp:936:5: note: suggested alternative:
In file included from ../cryptopp/seckey.h:9:0,
                 from ../cryptopp/hmac.h:9,
                 from BitfinexAPI.cpp:37:
../cryptopp/config.h:222:23: note:   ‘CryptoPP::byte’
 typedef unsigned char byte;
                       ^~~~
BitfinexAPI.cpp:940:9: error: ‘buffer’ was not declared in this scope
         buffer[i] = content[i];
         ^~~~~~
BitfinexAPI.cpp:940:9: note: suggested alternative: ‘setbuffer’
         buffer[i] = content[i];
         ^~~~~~
         setbuffer
BitfinexAPI.cpp:943:21: error: ‘buffer’ was not declared in this scope
     StringSource ss(buffer, content.length(), true, new Base64Encoder( new StringSink(encoded), false));
                     ^~~~~~
BitfinexAPI.cpp:943:21: note: suggested alternative: ‘setbuffer’
     StringSource ss(buffer, content.length(), true, new Base64Encoder( new StringSink(encoded), false));
                     ^~~~~~
                     setbuffer
BitfinexAPI.cpp: In static member function ‘static int BitfinexAPI::getHmacSha384(const string&amp;, const string&amp;, std::__cxx11::string&amp;)’:
BitfinexAPI.cpp:963:33: error: ISO C++ forbids declaration of ‘type name’ with no type [-fpermissive]
     SecByteBlock byteKey((const byte*)key.data(), key.size());
                                 ^~~~
BitfinexAPI.cpp:963:27: error: expected primary-expression before ‘const’
     SecByteBlock byteKey((const byte*)key.data(), key.size());
                           ^~~~~
BitfinexAPI.cpp:963:27: error: expected ‘)’ before ‘const’
</code></pre>
","<blockquote>
  <p>Here's how I am compiling:</p>

<pre><code>g++ example.cpp BitfinexAPI.cpp BitfinexAPI.hpp  -Icryptopp -I.  -o a -w -std=c++17
</code></pre>
  
  <p>It seems strange that BitFinex would support broken code so I am
  fairly sure that the issue must be something that I am doing. </p>
  
  <p>The errors I am getting are related to line 936 where the datatype
  'byte' is not declared. My prediction is that I am missing a header
  file somewhere but any help would be appreciated.</p>
</blockquote>

<p>@kabanus identified the problem.</p>

<p>Crypto++ used to provide a <code>byte</code> in the global C++ namespace. It was there for two reasons. First, it was a convenience item on Linux. You could use <code>byte</code> instead of <code>CryptoPP::byte</code>. Second, it avoided compiler errors on Windows. Microsoft SDK's provide a <code>byte</code> in the global namespace, and if we put a <code>byte</code> at <code>CryptoPP::byte</code> then compile errors resulted from ambiguous definitions.</p>

<p>C++17 came along and offered a <code>std::byte</code>; see <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0298r0.pdf"" rel=""nofollow noreferrer"">P0298R0, A byte type definition</a>. The global Crypto++ <code>byte</code> broke Linux when folks used a <code>using namespace std</code>. And it completely broke Microsoft because Microsoft SDK's provides a global <code>byte</code>. Ironically, the authors of P0298R0 work for Microsoft.</p>

<p>Crypto++ placing a <code>byte</code> in the global namespace was a C++ No-No. We got away with it for years, but it jumped up and bit us in C++17. We moved it into our namespace where it belongs. The check-in occurred at <a href=""http://github.com/weidai11/cryptopp/commit/00f9818b5d8e"" rel=""nofollow noreferrer"">Commit 00f9818b5d8e</a>, which happened after 5.6.5 was released and prior to 6.0 release.</p>

<p>Looking at the source for <code>BitfinexAPI.cpp</code>, this is probably the solution... open <code>BitfinexAPI.cpp</code>, and add the following at the top of the file:</p>

<pre><code>// CRYPTOPP_NO_GLOBAL_BYTE signals byte is at CryptoPP::byte
#if defined(CRYPTOPP_NO_GLOBAL_BYTE)
  using CryptoPP::byte;
#endif
</code></pre>

<p>Also see <a href=""https://www.cryptopp.com/wiki/Std::byte"" rel=""nofollow noreferrer"">std::byte</a> on the Crypto++ wiki. We took the time to document it because of all the problems <code>std::byte</code>, Microsoft's global <code>byte</code> and our <code>byte</code> definitions are going to cause.</p>

<hr>

<p>Related, you don't need to specify the C++ header on the command line. The compile error is due to the changes detailed above. All you need is:</p>

<pre><code>g++ -std=c++17 example.cpp BitfinexAPI.cpp -I. ./cryptopp/libcryptopp.a -o example.exe
</code></pre>

<p>This assumes a directory structure of:</p>

<pre><code>- bfx-api/
  |
  +- cryptopp/
</code></pre>

<p>The <code>cryptopp/libcryptopp.a</code> is a convenient way to sidestep those stupid Linux path problems that have existed for years. You link against the static archive which means you don't need a library at runtime.</p>

<hr>

<p>Now open in the BFX issue tracker: <a href=""https://github.com/MMquant/bfx-cpp-api/issues/2"" rel=""nofollow noreferrer"">Crypto++ byte change at Crypto++ 6.0</a>. It should help the project engineer around the changes.</p>
","291","<c++><gnu><crypto++>","2","2","2","2017-11-28 02:44:28","47512723","1","","608639","","2017-11-28 02:29:49","2017-11-27 11:38:51",""
"48937867","Crypto++ causes undefined reference in Qt Creator, but not in code::blocks","<p>Nearly every function from Crypto++ produces undefined reference in Qt Creator, code::blocks however runs just great.</p>

<pre><code>LIBS+= -lcryptopp  
</code></pre>

<p>in .pro file seems to work as I can include needed files and declare variables unless constructor is overloaded.</p>

<p>For example  </p>

<pre><code>CryptoPP::Integer integer;  
std::string str=CryptoPP::IntToString(integer, 10);  
</code></pre>

<p>Throws  </p>

<pre><code>.../main.cpp:54: undefined reference to `std::string CryptoPP::IntToString&lt;CryptoPP::Integer&gt;(CryptoPP::Integer, unsigned int)'  
collect2: error: ld returned 1 exit status  
make: *** [PDBM] Error 1  
07:10:21: The process ""/usr/bin/make"" exited with code 2.  

&lt;a href=""https://pastebin.com/c9nWekZR""&gt;cryptest.pro&lt;/a&gt;  
&lt;a href=""https://pastebin.com/0ku8Dncw""&gt;Makefile&lt;/a&gt;  
&lt;a href=""https://pastebin.com/ii1AM1Dx""&gt;full rebuild&lt;/a&gt; //sorry, stackoverflow wants those links to be a code 
</code></pre>

<p>/usr/lib/ contains libcrypto++.a, libcrypto++.so, libcryptopp.so and link to libcrypto++.a named libcryptopp.a  </p>

<p>New findings: I have tried to compile this library before and now my project folder has all the .h and .cpp files in cryptopp folder. To provide all the code without showing the code new project has been created and more errors appeared:</p>

<pre><code>In file included from /usr/include/cryptopp/secblock.h:7:0,
                 from /usr/include/cryptopp/integer.h:7,
                 from ../cryptest/main.cpp:7:
/usr/include/cryptopp/misc.h: In instantiation of ‘std::string CryptoPP::IntToString(T, unsigned int) [with T = CryptoPP::Integer; std::string = std::basic_string&lt;char&gt;]’:
../cryptest/main.cpp:54:54:   required from here
/usr/include/cryptopp/misc.h:424:58: error: invalid cast from type ‘CryptoPP::Integer’ to type ‘char’
   result = char((digit &lt; 10 ? '0' : ('a' - 10)) + digit) + result;
                                                          ^
Makefile:1113: recipe for target 'main.o' failed
</code></pre>

<p>Which means that cryptopp has been using those new .h files. So it is not only a problem with linker as I previously thought.</p>

<p>I'm on Ubuntu 16.04, using Qt 5.8 and Crypto++ from repository.</p>
","<blockquote>
<pre><code>-lcryptopp
</code></pre>
</blockquote>

<p>This option simply tells your linker that you want to link to a shared library called <code>libcryptopp.so</code>. However, it does not tell your linker <em>where</em> to find the shared library.</p>

<p>You must specify the folder which contains the developer's copy of the library, using the <code>-L</code> option. For example, if the library is in /usr/lib, then write this:</p>

<pre><code>LIBS += -L/usr/lib/ -lcryptopp
</code></pre>
","289","<linux><qt><undefined-reference><crypto++>","0","1","1","2018-02-23 17:42:47","","10","","9398723","","2018-02-23 17:42:47","2018-02-22 21:53:48",""
"18504803","MD4 hashing with Crypto++ results in wrong hash?","<p>I'm using Crypto++ to generate a MD4-Hash from a given password. But the generated hash doesn't seem to be correct. I think I'm misusing the CryptoPP functions somewhere. </p>

<pre><code>CryptoPP::Weak1::MD4 hash2;
byte digest2[CryptoPP::Weak1::MD4::DIGESTSIZE];
hash.CalculateDigest(digest2, (byte*)password, strlen(password));
CryptoPP::HexEncoder encoder2;
std::string output2;
encoder2.Attach(new CryptoPP::StringSink(output2));
encoder2.Put(digest,sizeof(digest2));
encoder2.MessageEnd();
printf(""END %s \n"", output2.c_str());
</code></pre>

<p>My variable password contains the value ""test"". The printed output is: </p>

<p>END 3CC942AE509EC070B2548515E00F8CE8</p>

<p>The expected value, tested by some MD4 Hash Generators, is: </p>

<p>db346d691d7acc4dc2625db19f9e3f52</p>

<p>Any ideas? </p>
","<p>Okay, I found the solution by myself. It doesn't work the way I posted above. </p>

<p>Here the correct code, it may be useful for someone else: </p>

<pre><code>std::string value;
CryptoPP::Weak1::MD4 hashmd4;
CryptoPP::StringSource (password, true,
  new CryptoPP::HashFilter( hashmd4,
    new CryptoPP::HexEncoder(
      new CryptoPP::StringSink(value)
    )
  )
);
</code></pre>
","281","<c++><hash><crypto++>","0","0","2","2014-01-28 03:48:59","18505781","0","","","","","2013-08-29 07:32:14",""
"18504803","MD4 hashing with Crypto++ results in wrong hash?","<p>I'm using Crypto++ to generate a MD4-Hash from a given password. But the generated hash doesn't seem to be correct. I think I'm misusing the CryptoPP functions somewhere. </p>

<pre><code>CryptoPP::Weak1::MD4 hash2;
byte digest2[CryptoPP::Weak1::MD4::DIGESTSIZE];
hash.CalculateDigest(digest2, (byte*)password, strlen(password));
CryptoPP::HexEncoder encoder2;
std::string output2;
encoder2.Attach(new CryptoPP::StringSink(output2));
encoder2.Put(digest,sizeof(digest2));
encoder2.MessageEnd();
printf(""END %s \n"", output2.c_str());
</code></pre>

<p>My variable password contains the value ""test"". The printed output is: </p>

<p>END 3CC942AE509EC070B2548515E00F8CE8</p>

<p>The expected value, tested by some MD4 Hash Generators, is: </p>

<p>db346d691d7acc4dc2625db19f9e3f52</p>

<p>Any ideas? </p>
","<blockquote>
  <p>hash.CalculateDigest(digest2, (byte*)password, strlen(password));</p>
</blockquote>

<p>This should be:</p>

<pre><code> hash2.CalculateDigest(digest2, (byte*)password, strlen(password));
</code></pre>

<p>That is, <code>hash2</code>, not <code>hash</code>.</p>

<hr>

<blockquote>
  <p>encoder2.Put(digest,sizeof(digest2));</p>
</blockquote>

<p>This should be:</p>

<pre><code>encoder2.Put(digest2,sizeof(digest2));
</code></pre>

<p>That is, <code>digest2</code>, not <code>digest</code>.</p>

<hr>

<blockquote>
  <p>The expected value, tested by some MD4 Hash Generators, is:</p>
  
  <p>db346d691d7acc4dc2625db19f9e3f52</p>
</blockquote>

<p>Yep, that's what I get using the code you posted after the typos were fixed.</p>
","281","<c++><hash><crypto++>","0","0","2","2014-01-28 03:48:59","18505781","0","","","","","2013-08-29 07:32:14",""
"25703769","Getting ""Java Result: -1073741571"" on loading library Cryptopp","<p>I'm trying to load custom c++ dll <em>(using jni)</em> to java, but i have a <strong>problem:</strong> my dll using cryptopp library, and when java tries to load depending <em>(including cryptopp)</em>, the application quits with the message: </p>

<blockquote>
  <p><strong>Java Result:</strong> -1073741571</p>
</blockquote>

<p>What is that, can i fix this without removing cryptopp?</p>

<hr>

<p><strong><em>Update:</em></strong></p>

<p>If i commented files zCypto.h and zCypro.cpp, and deleted all usage of cryptopp library, it works without any errors, error has thrown if i load cryptopp.
Java code:</p>

<pre><code>public static void main(String[] args){
    System.loadLibrary(""cryptopp"");
    System.loadLibrary(""ZCPP_Code64"");
}
</code></pre>

<p>CPP Source (I make dll in Visual Studio 2012):</p>

<pre><code>#include ""zCrypto.h""

JNIEXPORT void JNICALL Java_ru_zontwelg_Loader_loadCache 
(JNIEnv *env, jobject jobj)
{

std::fstream stream;
stream.open(""C:\\testing_capturing\\enc.zwac"", ios_base::binary | ios_base::in);

// Other decode &amp; read stuff here ...

stream.close();
}
</code></pre>

<p>Header:</p>

<pre><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class ru_zontwelg_Loader */

#ifndef _Included_ru_zontwelg_Loader
#define _Included_ru_zontwelg_Loader

extern ""C"" {

    /*
     * Class:     ru_zontwelg_Loader
     * Method:    loadCache
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_ru_zontwelg_Loader_loadCache
        (JNIEnv *, jobject);

}

#endif
</code></pre>

<p>zCrypto.h:</p>

<pre><code>#ifndef ZontWelg_zCrypto
#define ZontWelg_zCrypto

#include &lt;dll.h&gt;

#include &lt;cstdio&gt;
#include &lt;Windows.h&gt;
#include &lt;iostream&gt;

#include ""cryptlib.h""
using CryptoPP::Exception;

#include ""hex.h""
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include ""base64.h""
using CryptoPP::Base64Encoder;
using CryptoPP::Base64Decoder;

#include ""filters.h""
using CryptoPP::StringSink;
using CryptoPP::StringSource;
using CryptoPP::StreamTransformationFilter;

#include ""sha.h""
#include ""rsa.h""
#include ""hex.h""
#include ""osrng.h""
#include ""secblock.h""
#include ""modes.h""
#include ""aes.h""
using CryptoPP::AES;

//#include ""ccm.h""
using CryptoPP::CBC_Mode;

#pragma comment(lib, ""cryptlib.lib"")
//#pragma comment(lib, ""crypt32.lib"")
#pragma comment(lib, ""cryptopp.lib"")

using namespace std;

class zCrypto {
public:
    static string base64(string in);
    static string from_base64(string in);

    static string decrypt(const std::string&amp; str_in);
};

#endif
</code></pre>
","<p>This looks odd to me, but I'm not a JNI expert by any stretch:</p>

<pre class=""lang-java prettyprint-override""><code>public static void main(String[] args){
    System.loadLibrary(""cryptopp"");
    System.loadLibrary(""ZCPP_Code64"");
}
</code></pre>

<p>I would expect to see something like (from one of my Crypto++/Android/JNI projects):</p>

<pre class=""lang-java prettyprint-override""><code>public class PRNG {

    static {
        System.loadLibrary(""stlport_shared"");
        System.loadLibrary(""cryptopp"");
        System.loadLibrary(""prng"");
    }

    private static native int CryptoPP_Reseed(byte[] bytes);

    private static native int CryptoPP_GetBytes(byte[] bytes);

    private static Object lock = new Object();

    // Returns the number of bytes consumed.
    public static int Reseed(byte[] seed) {
        synchronized (lock) {
            return CryptoPP_Reseed(seed);
        }
    }

    // Returns the number of bytes generated.
    public static int GetBytes(byte[] bytes) {
        synchronized (lock) {
            return CryptoPP_GetBytes(bytes);
        }
    }
}
</code></pre>

<p>Don't worry about the <code>stlport_shared</code> because its an Android thing.</p>

<hr>

<p>This also looks odd:</p>

<pre class=""lang-cxx prettyprint-override""><code>#pragma comment(lib, ""cryptlib.lib"")
//#pragma comment(lib, ""crypt32.lib"")
#pragma comment(lib, ""cryptopp.lib"")
</code></pre>

<p>Because you are calling <code>System.loadLibrary(""cryptopp"")</code>, that means you are using the Crypto++ DLL. It also means this is not needed: <code>#pragma comment(lib, ""cryptlib.lib"")</code>. Pick static linking or dynamic linking, but not both.</p>

<p>It would probably be easiest if you (1) built your <code>ZCPP_Code64</code> DLL, and (2) statically linked to Crypto++. Then your static loader would look like:</p>

<pre class=""lang-java prettyprint-override""><code>    static {
        System.loadLibrary(""ZCPP_Code64"");
    }
</code></pre>

<hr>

<p><em>If</em> you choose static linking against Crypto++, then you will probably have to rebuild the static lib. That's because you'll end up in this configuration:</p>

<pre class=""lang-none prettyprint-override""><code>Your DLL -&gt; dynamic linking against the C Runtime
Crypto++ LIB -&gt; static linking against the C Runtime
</code></pre>

<p>That will cause a bunch of duplicate symbols (C Runtime symbols). What you want is:</p>

<pre class=""lang-none prettyprint-override""><code>Your DLL -&gt; dynamic linking against the C Runtime
Crypto++ LIB -&gt; dynamic linking against the C Runtime
</code></pre>

<p>To fix it, you open the Cryptlib project, and change the Runtime linking object from static to dynamic. See ""Static Versus Dynamic Linking"" at <a href=""http://www.codeproject.com/Articles/16388/Compiling-and-Integrating-Crypto-into-the-Microsof"" rel=""nofollow noreferrer"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment</a>.</p>

<hr>

<p>This looks OK to me:</p>

<pre class=""lang-java prettyprint-override""><code>JNIEXPORT void JNICALL Java_ru_zontwelg_Loader_loadCache 
(JNIEnv *env, jobject jobj)
{
    ...
}
</code></pre>

<p>What I am not sure about... where native libraries need to be located on Windows. For that, take a look at <a href=""https://stackoverflow.com/questions/12566732/java-jni-and-dependent-libraries-on-windows"">Java JNI and dependent libraries on Windows</a>.</p>

<hr>

<p>You are also going to have to perform locking <em>if</em> multiple threads access the same underlying Crypto++ object. In my case, the underlying object was an <code>AutoSeededRandomPool</code>:</p>

<pre class=""lang-java prettyprint-override""><code>public class PRNG {

    ...

    // Returns the number of bytes consumed.
    public static int Reseed(byte[] seed) {
        synchronized (lock) {
            return CryptoPP_Reseed(seed);
        }
    }

    // Returns the number of bytes generated.
    public static int GetBytes(byte[] bytes) {
        synchronized (lock) {
            return CryptoPP_GetBytes(bytes);
        }
    }
}
</code></pre>

<p>In you case, it might be a <code>Base64Encoder</code> or <code>Base64Decoder</code>.</p>

<p>Remember, all Crypto++ class objects are thread safe meaning they don't access global or shared data. But they are not safe when multiple threads (mis)use the same object.</p>

<hr>

<p>The book I consult for JNI issues is <a href=""https://rads.stackoverflow.com/amzn/click/com/0201325772"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The Java Native Interface: Programmer's Guide and Specification</a>.</p>

<hr>

<p>Finally, sorry about the ""answer"". Its not really an answer. Rather, its a large comment that would not fit in a comment block.</p>
","280","<java><java-native-interface><native-code><crypto++>","1","1","1","2014-09-07 08:58:09","","4","","3455601","","2014-09-07 06:38:01","2014-09-06 19:06:17",""
"9658408","Distributing a program(source files) using some library","<p>I wrote a program which uses Cryptopp library. I have created the static library and will include it my distribution, but the program also requires a lot of header files. My question is do I need to include all those header files with my distribution?</p>

<p>For examples, I wrote a code which uses <code>des.h</code>, <code>modes.h</code> and <code>filters.h</code>which in turn is based on other header files in Cryptopp, a long chain. Do I include all header files from the Cryptopp library?</p>

<p>Making it more general, if I write some code which use other libraries(like Cryptopp or boost) what all do I need to include in distro?</p>

<p><strong>Update</strong>: I want to distribute the source, not just the binaries. So that the user can compile my program from scratch if we wants to. I'm including the static library, but confused about header files. Do I need to include them all?</p>
","<p>No, you only distribute binary files. You don't need headers to run a program.</p>

<p>If, however, you're distributing a library (not a program), you need to supply headers. Your headers, not third-party headers.</p>

<p>You can exclude the third-party headers by a number of techniques, if they are part of the implementation only. If not, you'll need to supply them also. Assuming you don't need that, and you only use them internally, you can use forward declarations:</p>

<pre><code>//MyClass.h
class ExternalClass;
class MyClass
{
   ExternalClass* p;
} ;
</code></pre>

<p>This way, you only need to include the third-party header in your implementation file, which you don't distribute anyway.</p>
","279","<c++><c><distribution><crypto++>","0","3","2","2012-03-11 20:20:53","9658447","0","","1241347","","2012-03-11 20:20:53","2012-03-11 20:03:35",""
"9658408","Distributing a program(source files) using some library","<p>I wrote a program which uses Cryptopp library. I have created the static library and will include it my distribution, but the program also requires a lot of header files. My question is do I need to include all those header files with my distribution?</p>

<p>For examples, I wrote a code which uses <code>des.h</code>, <code>modes.h</code> and <code>filters.h</code>which in turn is based on other header files in Cryptopp, a long chain. Do I include all header files from the Cryptopp library?</p>

<p>Making it more general, if I write some code which use other libraries(like Cryptopp or boost) what all do I need to include in distro?</p>

<p><strong>Update</strong>: I want to distribute the source, not just the binaries. So that the user can compile my program from scratch if we wants to. I'm including the static library, but confused about header files. Do I need to include them all?</p>
","<p>Generally, you want to do one of two things: either don't distribute the library at all or else distribute the <em>whole</em> library, exactly as-is.</p>

<p>If you're only distributing a binary executable, the first makes sense. If you're distributing source code, you can do either. Trying to do halfway between the two and just distribute parts of the library upon which your code depends is a recipe for problems.</p>
","279","<c++><c><distribution><crypto++>","0","0","2","2012-03-11 20:20:53","9658447","0","","1241347","","2012-03-11 20:20:53","2012-03-11 20:03:35",""
"39278597","Exception ""AES: 4 is not a valid key length"" on BegleboneBlack","<p>I installed Crypto++ on BeagleBone black by following native installation method provided at <a href=""http://cryptopp.com/wiki/Arm_(Command_Line)"" rel=""nofollow"">ARM (Command Line)</a>. Then when I ran <code>cryptest.sh</code>, it runs smoothly.</p>

<p>Here is my small test-code to test Crypto++ functionality.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include ""libcryptoWrapperGCM.h""
int main(int argc,char* argv[]){
    byte key[]  = ""123456789012345"";
    byte vi[]   = ""123456789012345"";
    char p[205] = { 0x00, 0x01, 0x00, 0x25, 0x00, 0x00, 0x00, 0x09,   
         0x00, 0x01, 0x00, 0x05, 0x6f, 0x74, 0x6f, 0x63, 0x6e, 0xf0, 0x01, 0x00, 0x14, 0x00, 0x01, 0x00,    
         0x06, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x31, 0x00, 0x01, 0x00, 0x06, 0x70, 0x61, 0x72, 0x61, 0x6d,   
         0x32, 0xf0, 0x02, 0x00, 0xa0, 0x00, 0x23, 0x00, 0x40, 0x38, 0x34, 0x32, 0x33, 0x32, 0x30, 0x33,    
         0x34, 0x62, 0x66, 0x61, 0x36, 0x38, 0x38, 0x32, 0x38, 0x30, 0x64, 0x37, 0x36, 0x38, 0x35, 0x64,   
         0x39, 0x66, 0x62, 0x62, 0x65, 0x36, 0x34, 0x32, 0x37, 0x36, 0x37, 0x36, 0x33, 0x34, 0x61, 0x64, 
         0x36, 0x34, 0x37, 0x32, 0x66, 0x66, 0x37, 0x33, 0x63, 0x33, 0x34, 0x32, 0x65, 0x63, 0x34, 0x32,  
         0x35, 0x38, 0x31, 0x35, 0x37, 0x66, 0x61, 0x33, 0x61, 0x00, 0x24, 0x00, 0x40, 0x36, 0x35, 0x30,    
         0x38, 0x63, 0x39, 0x31, 0x36, 0x63, 0x37, 0x39, 0x30, 0x63, 0x66, 0x37, 0x33, 0x34, 0x61, 0x31,    
         0x64, 0x34, 0x35, 0x65, 0x30, 0x32, 0x62, 0x30, 0x64, 0x39, 0x61, 0x39, 0x65, 0x37, 0x35, 0x36,    
         0x37, 0x34, 0x66, 0x36, 0x64, 0x61, 0x62, 0x31, 0x63, 0x61, 0x30, 0x32, 0x64, 0x31, 0x64, 0x66,    
         0x64, 0x37, 0x39, 0x63, 0x66, 0x39, 0x35, 0x38, 0x35, 0x64, 0x36, 0x31, 0x33, 0x00, 0x25, 0x00,    
         0x08, 0x00, 0x00, 0x00, 0x00, 0x57, 0x16, 0x69, 0x13, 0x00, 0x26, 0x00, 0x08, 0x00, 0x00, 0x00,    
         0x00, 0x00, 0x06, 0x0b, 0x94};
    char *p_data_ptr = p; 
    byte *ebuffer = malloc(205+12);
    char *d = GcmEncode(key,vi, p_data_ptr,205,ebuffer,0);
    int i ;
    for(i=0; i&lt; 205+12; i++){
        printf(""0x%02x, "",ebuffer[i] &amp; 0xff);
    }
    char *buffer = malloc(205);

    char* decodedMessage = GcmDecode(key, vi,ebuffer, 217,buffer,0);

    return 1;
}
</code></pre>

<p>When I run the program I get Exception:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidKeyLength'
  what():  AES: 4 is not a valid key length
Aborted
</code></pre>

<p>The odd thing is that it only happens on BeagleBone Black and not x86 machine, even though both have Ubuntu 14.04.</p>

<p>Any idea how to solve this issue? Thank you.</p>

<p>Edit 1:
Here is the wrapper source:</p>

<pre><code> #include ""gcm.h""

 using CryptoPP::GCM;


 #include ""assert.h""

 extern ""C"" {
     const char* GcmEncode(byte key_hash[],byte iv_hash[], byte*  p_data_ptr,size_t length,uint8_t* destination, int offset) {
         string cipher,encoded;
         encoded.clear();
         GCM&lt; AES &gt;::Encryption e;
         e.SetKeyWithIV( key_hash, sizeof(key_hash), iv_hash, sizeof(iv_hash) );
         const int TAG_SIZE = 16;
         StringSource(p_data_ptr,length, true,
                 new AuthenticatedEncryptionFilter( e,
                     new StringSink( cipher ), false, TAG_SIZE)
                 );
         encoded.clear();

         StringSource(cipher, true,
                 new HexEncoder(new StringSink( encoded ))
                 );
         memcpy(&amp;(destination[offset]),cipher.c_str(),length+12);
         return cipher.c_str();//NEED TO BE FREED IN FOLLOWING METHOD

     }
     const char *GcmDecode(byte key_hash[], byte iv_hash[], byte *cipher_ptr,size_t length,  uint8_t* destination, int offset){
         size_t pLength = length - 16;
         string rpdata;
         const int TAG_SIZE = 16;
         GCM&lt; AES &gt;::Decryption d;
         d.SetKeyWithIV(key_hash, sizeof(key_hash), iv_hash, sizeof(iv_hash));
         AuthenticatedDecryptionFilter df(d,new StringSink( rpdata ),
                 AuthenticatedDecryptionFilter::DEFAULT_FLAGS,
                 TAG_SIZE
                 );
         StringSource(cipher_ptr,length, true,new Redirector(df));
         bool b = df.GetLastResult();
         if( true == b ){
             memcpy(&amp;(destination[offset]),rpdata.c_str(),pLength);
             return NULL;//NEED TO BE FREED IN FOLLOWING METHOD
         }
         else{
             return NULL;
         }
     }

 }
</code></pre>

<p>And this is the valgrind output:</p>

<pre><code>==26349== 
terminate called after throwing an instance of 'CryptoPP::InvalidKeyLength'
  what():  AES: 4 is not a valid key length
==26349== 
==26349== HEAP SUMMARY:
==26349==     in use at exit: 462 bytes in 6 blocks
==26349==   total heap usage: 11 allocs, 5 frees, 562 bytes allocated
==26349== 
==26349== LEAK SUMMARY:
==26349==    definitely lost: 0 bytes in 0 blocks
==26349==    indirectly lost: 0 bytes in 0 blocks
==26349==      possibly lost: 201 bytes in 3 blocks
==26349==    still reachable: 261 bytes in 3 blocks
==26349==         suppressed: 0 bytes in 0 blocks
==26349== Rerun with --leak-check=full to see details of leaked memory
==26349== 
==26349== For counts of detected and suppressed errors, rerun with: -v
==26349== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
Aborted
ubuntu@arm:/home/otocn/Daemon$ valgrind --leak-check=full ./a.out 
==26350== Memcheck, a memory error detector
==26350== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26350== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info
==26350== Command: ./a.out
==26350== 
terminate called after throwing an instance of 'CryptoPP::InvalidKeyLength'
  what():  AES: 4 is not a valid key length
==26350== 
==26350== HEAP SUMMARY:
==26350==     in use at exit: 462 bytes in 6 blocks
==26350==   total heap usage: 11 allocs, 5 frees, 562 bytes allocated
==26350== 
==26350== 16 bytes in 1 blocks are possibly lost in loss record 2 of 6
==26350==    at 0x482E9E0: operator new(unsigned int) (vg_replace_malloc.c:318)
==26350==    by 0x4C85191: std::string::_Rep::_S_create(unsigned int, unsigned int, std::allocator&lt;char&gt; const&amp;) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x4C86289: char* std::string::_S_construct&lt;char const*&gt;(char const*, char const*, std::allocator&lt;char&gt; const&amp;, std::forward_iterator_tag) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x4C86569: std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(char const*, std::allocator&lt;char&gt; const&amp;) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x49BA727: __static_initialization_and_destruction_0 (cryptlib.cpp:52)
==26350==    by 0x49BA727: _GLOBAL__sub_I.00276_cryptlib.cpp (cryptlib.cpp:939)
==26350==    by 0x400B19D: call_init (dl-init.c:78)
==26350==    by 0x400B22F: _dl_init (dl-init.c:126)
==26350==    by 0x4000BF1: ??? (in /lib/arm-linux-gnueabihf/ld-2.19.so)
==26350== 
==26350== 45 bytes in 1 blocks are possibly lost in loss record 4 of 6
==26350==    at 0x482E9E0: operator new(unsigned int) (vg_replace_malloc.c:318)
==26350==    by 0x4C85191: std::string::_Rep::_S_create(unsigned int, unsigned int, std::allocator&lt;char&gt; const&amp;) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x4C859E5: std::string::_Rep::_M_clone(std::allocator&lt;char&gt; const&amp;, unsigned int) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x4C85A57: std::string::reserve(unsigned int) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x4C85C13: std::string::append(char const*, unsigned int) (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350==    by 0x49C4663: append (basic_string.h:1009)
==26350==    by 0x49C4663: operator+&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; (basic_string.h:2406)
==26350==    by 0x49C4663: CryptoPP::InvalidKeyLength::InvalidKeyLength(std::string const&amp;, unsigned int) (simple.h:50)
==26350==    by 0x49C2E2D: CryptoPP::SimpleKeyingInterface::ThrowIfInvalidKeyLength(unsigned int) (cryptlib.cpp:119)
==26350==    by 0x49C2E79: CryptoPP::SimpleKeyingInterface::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;) (cryptlib.cpp:102)
==26350==    by 0x4A23D8D: CryptoPP::GCM_Base::SetKeyWithoutResync(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;) (gcm.cpp:138)
==26350==    by 0x49C8F41: CryptoPP::AuthenticatedSymmetricCipherBase::SetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;) (authenc.cpp:53)
==26350==    by 0x49C2CB3: CryptoPP::SimpleKeyingInterface::SetKeyWithIV(unsigned char const*, unsigned int, unsigned char const*, unsigned int) (cryptlib.cpp:113)
==26350==    by 0x49BAAB7: GcmEncode (in /home/otocn/Daemon/libcryptoc.so)
==26350== 
==26350== 140 bytes in 1 blocks are possibly lost in loss record 5 of 6
==26350==    at 0x482E358: malloc (vg_replace_malloc.c:296)
==26350==    by 0x4C46081: __cxa_allocate_exception (in /usr/lib/arm-linux-gnueabihf/libstdc++.so.6.0.19)
==26350== 
==26350== LEAK SUMMARY:
==26350==    definitely lost: 0 bytes in 0 blocks
==26350==    indirectly lost: 0 bytes in 0 blocks
==26350==      possibly lost: 201 bytes in 3 blocks
==26350==    still reachable: 261 bytes in 3 blocks
==26350==         suppressed: 0 bytes in 0 blocks
==26350== Reachable blocks (those to which a pointer was found) are not shown.
==26350== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==26350== 
==26350== For counts of detected and suppressed errors, rerun with: -v
==26350== ERROR SUMMARY: 3 errors from 3 contexts (suppressed: 0 from 0)
Aborted
</code></pre>
","","279","<encryption><beagleboneblack><crypto++>","0","","0","2016-09-07 21:11:37","","12","","4254541","","2016-09-07 21:11:37","2016-09-01 18:30:45",""
"41700910","Encrypt with Crypto++ and Decrypt with Python.CRYPTO","<p>I'm working on a project that uses Crypto++ to encrypt some data using RSA.</p>

<p>Here is my Crypto++ code: </p>

<pre class=""lang-cxx prettyprint-override""><code>string plain = ""Text123"", encoded, cipher;
string pkey = ""..."";

StringSource ss1(pkey, true);
RSA::PublicKey publicKey;
PEM_Load(ss, publicKey);
RSAES_OAEP_SHA_Encryptor e(publicKey);

StringSource ss2(plain, true,
    new PK_EncryptorFilter(prng, e,
        new StringSink(cipher)
    ) 
); 

StringSource ss3(cipher, true,
    new Base64Encoder(
        new StringSink(encoded)
    )
);
cout &lt;&lt; encoded;
</code></pre>

<p>And I'm trying to decrypt the encrypted message in Python. Here is my Python code: </p>

<pre class=""lang-python prettyprint-override""><code>from Crypto.PublicKey import RSA
from base64 import b64decode  

cipher_text = ""[THE OUTPUT OF C++]""
rsakey = RSA.importKey(open(""private.txt"", ""r"").read())
raw_cipher_data = b64decode(cipher_text)
decrypted = rsakey.decrypt(raw_cipher_data)
</code></pre>

<p>But I'm getting unreadable characters.</p>

<p>Whys am I getting unreadable characters? Can any one help me with this?</p>

<p>Thanks in advance.</p>
","","278","<python><c++><encryption><pycrypto><crypto++>","2","","0","2017-01-17 23:36:25","","1","","608639","","2017-01-17 23:36:25","2017-01-17 15:24:31",""
"30950856","BAD_ACCESS (code=EXC_I386_GPFLT) when signing with ECDSA","<p>I am trying to use Crypto++ on iOS. I downloaded a prebuilt version of the library from <a href=""https://github.com/debris/cryptopp-ios"" rel=""nofollow noreferrer"">Marek Kotewicz's GitHub</a>.</p>

<p>I am struggling hard to run <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">this sample code</a> from the Crypto++ wiki.</p>

<pre><code>ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PublicKey publicKey;

AutoSeededRandomPool prng, rrng;

privateKey.Initialize(prng, CryptoPP::ASN1::secp256k1());    
privateKey.MakePublicKey(publicKey);

string signature;       
string message = ""Do or do not. There is no try."";

StringSource s(message, true,
             new SignerFilter(rrng,
                              ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer(privateKey),
                              new StringSink(signature)));
</code></pre>

<p>Its crashing with the following. Its showing up in Xcode output window:</p>

<pre><code>BAD_ACCESS (code=EXC_I386_GPFLT)  
</code></pre>

<p>This is the code snippet from memory.h of c++ file where it is pointing the BAD_ACCESS</p>

<pre><code> _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}
</code></pre>

<p>I am getting BAD_ACCESS(code=1 , address=0x0) error
pointing to this line of code of library</p>

<pre><code> -&gt;  0x1065dfa8d &lt;+85&gt;:  movq   -0x58(%rbp), %rdi
</code></pre>

<p><img src=""https://i.stack.imgur.com/Vm1D9.png"" alt=""This is the debugger output""></p>
","<blockquote>
  <p>Its crashing with the following. Its showing up in Xcode output window:</p>

<pre><code>BAD_ACCESS(code=EXC_I386_GPFLT)  
</code></pre>
</blockquote>

<p>The code looks OK to me.</p>

<hr>

<blockquote>
  <p>I am trying to use Crypto++ on iOS. I downloaded a prebuilt version of the library from Marek Kotewicz's GitHub.</p>
</blockquote>

<p>I'm just taking a stab in the dark. It presumes the code you showed above is <em>really</em> all you are doing in, say, a test <code>ViewController</code>.</p>

<p>The precompiled library appears to be using GNU's Standard C++ library. I would switch to LLVM's Standard C++ library by building Crypto++ with <code>-stdlib=c++</code> (and not GNU's <code>-stdlib=stdc++</code>). Apple switched to it years ago, and Xcode uses it by default.</p>

<p>You can find a GitHub with the fat library using LLVM Standard C++ at <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">noloader/cryptopp-5.6.2-ios</a>.</p>

<p>Or, you can build the fat library yourself. For that, see <a href=""http://www.cryptopp.com/wiki/IOS_%28Command_Line%29"" rel=""nofollow"">iOS (Command Line)</a> on the Crypto++ wiki. The prebuilt library at <a href=""https://github.com/noloader/cryptopp-5.6.2-ios"" rel=""nofollow"">cryptopp-5.6.2-ios</a> uses those instructions.</p>

<hr>

<blockquote>
<pre><code>AutoSeededRandomPool prng, rrng;
</code></pre>
</blockquote>

<p>You only need one of these.</p>

<hr>

<blockquote>
<pre><code>StringSource s(message, true,
               new SignerFilter(rrng,
                   ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer(privateKey),
                       new StringSink(signature)));
</code></pre>
</blockquote>

<p>Over the years, I've come to wonder about the temporary signer created for the pipeline. I've changed the Crypto++ wiki to stop using them. Use this code instead:</p>

<pre><code>ECDSA&lt;ECP, CryptoPP::SHA256&gt;::PrivateKey privateKey;
...
ECDSA&lt;ECP, CryptoPP::SHA256&gt;::Signer signer(privateKey);
...

StringSource s(message, true,
               new SignerFilter(prng, signer,
                   new StringSink(signature)));
</code></pre>
","277","<c++><ios><crypto++><ecdsa>","0","0","1","2019-10-11 09:34:25","","10","","3632958","","2015-06-21 09:05:58","2015-06-20 06:04:37",""
"37261470","'Application': is not a class or namespace name","<p>I'm trying to utilize Cryptopp AES Library on C++ Form App. by using the Visual Studio 2015 with Update 2.</p>

<p>The thing is that I have to use ""No common Runtime Support"". However when I do this, It gives me some errors, like:</p>

<pre class=""lang-none prettyprint-override""><code>Severity    Code    Description Project File    Line    Suppression State
Error   C2653   'Application': is not a class or namespace name SON c:\Users\Win\documents\visual studio 2015\Projects\SON\SON\MyForm.cpp   18  

Severity    Code    Description Project File    Line    Suppression State
Error   C2871   'Data': a namespace with this name does not exist   SON c:\users\win\documents\visual studio 2015\projects\son\son\MyForm.h 9   

Severity    Code    Description Project File    Line    Suppression State
Error   C2871   'Drawing': a namespace with this name does not exist    SON c:\users\win\documents\visual studio 2015\projects\son\son\MyForm.h 10  

Severity    Code    Description Project File    Line    Suppression State
Error   C3861   'EnableVisualStyles': identifier not found  SON c:\Users\Win\documents\visual studio 2015\Projects\SON\SON\MyForm.cpp   18  
</code></pre>

<p>But, when I build the code with Common Language Runtime Support, it doesn't give any error, but this time I couldn't create a UI for Form App.</p>

<p>Here are my CPP code, I didn't make any changes on it</p>

<pre><code>#include ""MyForm.h""
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace System;
using namespace System::Windows::Forms;

#include ""C:\Users\Win\Desktop\cryptopp562\osrng.h""
using CryptoPP::AutoSeededRandomPool;



[STAThread]
void Main(array&lt;std::string^&gt;^ args)
{
    Application::EnableVisualStyles();
    Application::SetCompatibleTextRenderingDefault(false);

    MyForm form;
    Application::Run(%form);
}
</code></pre>

<p>Thanks in advance.</p>
","","276","<winforms><visual-studio><c++-cli><crypto++><managed-c++>","0","","0","2016-05-17 02:42:12","","3","","608639","","2016-05-17 02:42:12","2016-05-16 19:11:42",""
"36392637","Modular Arithmetic addition and subtraction using Crypto++","<p>I am very new to this, but I am trying to add two Integers in modular format using Crypto++ Library.</p>

<p>My program is very simple,</p>

<pre><code>AutoSeededRandomPool prng;
Integer r0, m;

m = Integer( prng, 64);
r0 = Integer( prng, 64);

cout &lt;&lt; ""m: "" &lt;&lt; std::hex &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; ""r0:"" &lt;&lt; std::hex &lt;&lt; r0 &lt;&lt; endl;

Integer n1(r0 + m);
</code></pre>

<p>But this simply didn't work. It complied fine, but it crashed when I was trying to run it.</p>

<p>Could anyone give a sample code for addition/subtraction using Crypto++ please</p>
","<blockquote>
  <p>Modular Arithmetic (addition/subtraction) using Crypto++</p>
</blockquote>

<p>We have closed some of the missing documentation gaps based on this question, so I won't address the sample code. The improved docs are available at <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow noreferrer"">Integer Class Reference</a> and <a href=""http://cryptopp.com/wiki/Integer"" rel=""nofollow noreferrer"">Integer on the Crypto++ wiki</a>.</p>

<p>However, there may be a bug or (at least) unexpected results from using the <a href=""http://www.cryptopp.com/docs/ref/class_modular_arithmetic.html"" rel=""nofollow noreferrer"">ModularArithmetic class</a>. The class describes itself as <em>""Ring of congruence classes modulo n""</em>. Mathematically, a Ring is a group with closure and two well defined operations.</p>

<p>The disconnect is, which two operations are the ones included with <code>ModularArithmetic&lt;Integer&gt;</code>. Based on some sample code, it looks like its <code>Multiply</code> and <code>Exponentiate</code>, which is mostly expected (though it could have been <code>Add</code> and <code>Multiply</code>).</p>

<p>I don't think the mathematical definition of Ring gives <code>ModularArithmetic</code> a license to produce unexpected results. However, <code>ModularArithmetic</code> is kind of unique, and it may be accumulating intermediate results that one must then reduce using <code>Multiply</code> and <code>Exponentiate</code>. (It does accumulate results to speed up operations).</p>

<p>The open question for me is, what do we do... I'm trying to solicit some feedback at the moment on the issue.</p>

<hr>

<p>Here's the test program:</p>

<pre><code>int main(int argc, char* argv[])
{
  Integer m(""4294967295""), n(""0x1000000000000000000000000000000""), j;
  j = 1999;

  ModularArithmetic ma(j);

  cout &lt;&lt; ""n+m mod j: "" &lt;&lt; ma.Add(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; (n+m) % j &lt;&lt; endl;
  cout &lt;&lt; ""n-m mod j: "" &lt;&lt; ma.Subtract(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; (n-m) % j &lt;&lt; endl;
  cout &lt;&lt; ""n*m mod j: "" &lt;&lt; ma.Multiply(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; (n*m) % j &lt;&lt; endl;
  cout &lt;&lt; ""n/m mod j: "" &lt;&lt; ma.Divide(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; (n/m) % j &lt;&lt; endl;
  cout &lt;&lt; ""n%m mod j: "" &lt;&lt; ma.Reduce(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; (n%m) % j &lt;&lt; endl;
  cout &lt;&lt; ""n^m mod j: "" &lt;&lt; ma.Exponentiate(n, m) &lt;&lt; endl;
  cout &lt;&lt; ""  cross-check: "" &lt;&lt; a_exp_b_mod_c(n,m,j) &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>Here are the results:</p>

<pre><code>$ ./test.exe 
n+m mod j: 1329227995784915872903807064575309872.
  cross-check: 1755.
n-m mod j: 1329227995784915872903807055985377281.
  cross-check: 50.
n*m mod j: 266.
  cross-check: 266.
n/m mod j: 599.
  cross-check: 1997.
n%m mod j: 1329227995784915872903807055985377281.
  cross-check: 1608.
n^m mod j: 1326.
  cross-check: 1326.
</code></pre>

<hr>

<p><strong><em>EDIT 1</em></strong></p>

<blockquote>
  <p>The disconnect is, which two operations are the ones included with <code>ModularArithmetic&lt;Integer&gt;</code>...</p>
</blockquote>

<p>So I had a chance to go though the source code and <a href=""http://github.com/weidai11/cryptopp/commit/caea6f1c593ec93abe38339c3757e637f546c616"" rel=""nofollow noreferrer"">add more missing documentation</a>. Of particular interest is <a href=""https://cryptopp.com/docs/ref/class_abstract_ring.html"" rel=""nofollow noreferrer""><code>AbstractRing&lt; T &gt;</code> Class Template Reference</a>, which <code>ModularArithmetic</code> inherits from. It confirms that multiply and exponentiation are the operations (and it gives rise to helpers, like <code>Square</code>).</p>

<p>What I am not clear about is why <code>ModularArithmetic</code> is providing <code>Add</code>, <code>Subtract</code> and friends but arriving at unexpected results. It could well be that its effectively accumulating the results and waiting to be reduced with a <code>Multiply</code> or <code>Exponentiate</code>, but I don't see any comments in the source code.</p>

<hr>

<p><strong><em>EDIT 2</em></strong></p>

<p>The reason <code>ModularArithmetic</code> appears to produce incorrect results for <code>Add</code>, <code>Subtract</code> and friends is the class is meant to be fast for specific problems, and it does not perform a full reduction using the Euclidean extended algorithm. Rather, it performs <em>at most</em> one subtraction. That means the accumulated value <code>n</code> to be reduced by the modulus <code>p</code> must be in the range <code>[0, 2p)</code>.</p>
","276","<c++><crypto++><modular-arithmetic>","2","1","1","2017-02-08 13:08:04","36413722","10","1","608639","","2017-02-08 12:58:49","2016-04-03 23:40:29",""
"54388944","Linker error while building crypto++ with Qt program","<p><strong>Problem</strong> </p>

<p>I add all the crypto++'s header file and source file(.h,.cpp) to my Qt5 project.<br>
I built it,and it give me ten link errors.</p>

<p><strong>BackGround</strong></p>

<p>I'm using Qt5.9.7 version.<br>
The compiler is msvc2017-64bit.<br>
The crypto++ is the newest 8.0.0 version.  </p>

<p><strong>Errors</strong>  </p>

<pre><code>test.obj:-1: error: LNK2005: main already defined in main.obj
gcm.obj:-1: error: LNK2019: unresolved external symbol GCM_AuthenticateBlocks_2K_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::GCM_Base::AuthenticateBlocks(unsigned char const *,unsigned __int64)"" (?AuthenticateBlocks@GCM_Base@CryptoPP@@MEAA_KPEBE_K@Z)
gcm.obj:-1: error: LNK2019: unresolved external symbol GCM_AuthenticateBlocks_64K_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::GCM_Base::AuthenticateBlocks(unsigned char const *,unsigned __int64)"" (?AuthenticateBlocks@GCM_Base@CryptoPP@@MEAA_KPEBE_K@Z)
integer.obj:-1: error: LNK2019: unresolved external symbol Baseline_Add referenced in function ""int __cdecl CryptoPP::Add(unsigned __int64 *,unsigned __int64 const *,unsigned __int64 const *,unsigned __int64)"" (?Add@CryptoPP@@YAHPEA_KPEB_K1_K@Z)
integer.obj:-1: error: LNK2019: unresolved external symbol Baseline_Sub referenced in function ""int __cdecl CryptoPP::Subtract(unsigned __int64 *,unsigned __int64 const *,unsigned __int64 const *,unsigned __int64)"" (?Subtract@CryptoPP@@YAHPEA_KPEB_K1_K@Z)
rdrand.obj:-1: error: LNK2019: unresolved external symbol MASM_RDRAND_GenerateBlock referenced in function ""public: virtual void __cdecl CryptoPP::RDRAND::GenerateBlock(unsigned char *,unsigned __int64)"" (?GenerateBlock@RDRAND@CryptoPP@@UEAAXPEAE_K@Z)
rdrand.obj:-1: error: LNK2019: unresolved external symbol MASM_RDSEED_GenerateBlock referenced in function ""public: virtual void __cdecl CryptoPP::RDSEED::GenerateBlock(unsigned char *,unsigned __int64)"" (?GenerateBlock@RDSEED@CryptoPP@@UEAAXPEAE_K@Z)
rijndael.obj:-1: error: LNK2019: unresolved external symbol Rijndael_Enc_AdvancedProcessBlocks_SSE2 referenced in function ""public: virtual unsigned __int64 __cdecl CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const *,unsigned char const *,unsigned char *,unsigned __int64,unsigned int)const "" (?AdvancedProcessBlocks@Enc@Rijndael@CryptoPP@@UEBA_KPEBE0PEAE_KI@Z)
salsa.obj:-1: error: LNK2019: unresolved external symbol Salsa20_OperateKeystream referenced in function ""protected: virtual void __cdecl CryptoPP::Salsa20_Policy::OperateKeystream(enum CryptoPP::KeystreamOperation,unsigned char *,unsigned char const *,unsigned __int64)"" (?OperateKeystream@Salsa20_Policy@CryptoPP@@MEAAXW4KeystreamOperation@2@PEAEPEBE_K@Z)
sha.obj:-1: error: LNK2019: unresolved external symbol SHA256_HashMultipleBlocks_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::SHA256::HashMultipleBlocks(unsigned int const *,unsigned __int64)"" (?HashMultipleBlocks@SHA256@CryptoPP@@MEAA_KPEBI_K@Z)
sosemanuk.obj:-1: error: LNK2019: unresolved external symbol Sosemanuk_OperateKeystream referenced in function ""protected: virtual void __cdecl CryptoPP::SosemanukPolicy::OperateKeystream(enum CryptoPP::KeystreamOperation,unsigned char *,unsigned char const *,unsigned __int64)"" (?OperateKeystream@SosemanukPolicy@CryptoPP@@MEAAXW4KeystreamOperation@2@PEAEPEBE_K@Z)
</code></pre>
","<pre><code>gcm.obj:-1: error: LNK2019: unresolved external symbol GCM_AuthenticateBlocks_2K_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::GCM_Base::AuthenticateBlocks(unsigned char const *,unsigned __int64)"" (?AuthenticateBlocks@GCM_Base@CryptoPP@@MEAA_KPEBE_K@Z)
gcm.obj:-1: error: LNK2019: unresolved external symbol GCM_AuthenticateBlocks_64K_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::GCM_Base::AuthenticateBlocks(unsigned char const *,unsigned __int64)"" (?AuthenticateBlocks@GCM_Base@CryptoPP@@MEAA_KPEBE_K@Z)
integer.obj:-1: error: LNK2019: unresolved external symbol Baseline_Add referenced in function ""int __cdecl CryptoPP::Add(unsigned __int64 *,unsigned __int64 const *,unsigned __int64 const *,unsigned __int64)"" (?Add@CryptoPP@@YAHPEA_KPEB_K1_K@Z)
integer.obj:-1: error: LNK2019: unresolved external symbol Baseline_Sub referenced in function ""int __cdecl CryptoPP::Subtract(unsigned __int64 *,unsigned __int64 const *,unsigned __int64 const *,unsigned __int64)"" (?Subtract@CryptoPP@@YAHPEA_KPEB_K1_K@Z)
rdrand.obj:-1: error: LNK2019: unresolved external symbol MASM_RDRAND_GenerateBlock referenced in function ""public: virtual void __cdecl CryptoPP::RDRAND::GenerateBlock(unsigned char *,unsigned __int64)"" (?GenerateBlock@RDRAND@CryptoPP@@UEAAXPEAE_K@Z)
rdrand.obj:-1: error: LNK2019: unresolved external symbol MASM_RDSEED_GenerateBlock referenced in function ""public: virtual void __cdecl CryptoPP::RDSEED::GenerateBlock(unsigned char *,unsigned __int64)"" (?GenerateBlock@RDSEED@CryptoPP@@UEAAXPEAE_K@Z)
rijndael.obj:-1: error: LNK2019: unresolved external symbol Rijndael_Enc_AdvancedProcessBlocks_SSE2 referenced in function ""public: virtual unsigned __int64 __cdecl CryptoPP::Rijndael::Enc::AdvancedProcessBlocks(unsigned char const *,unsigned char const *,unsigned char *,unsigned __int64,unsigned int)const "" (?AdvancedProcessBlocks@Enc@Rijndael@CryptoPP@@UEBA_KPEBE0PEAE_KI@Z)
salsa.obj:-1: error: LNK2019: unresolved external symbol Salsa20_OperateKeystream referenced in function ""protected: virtual void __cdecl CryptoPP::Salsa20_Policy::OperateKeystream(enum CryptoPP::KeystreamOperation,unsigned char *,unsigned char const *,unsigned __int64)"" (?OperateKeystream@Salsa20_Policy@CryptoPP@@MEAAXW4KeystreamOperation@2@PEAEPEBE_K@Z)
sha.obj:-1: error: LNK2019: unresolved external symbol SHA256_HashMultipleBlocks_SSE2 referenced in function ""protected: virtual unsigned __int64 __cdecl CryptoPP::SHA256::HashMultipleBlocks(unsigned int const *,unsigned __int64)"" (?HashMultipleBlocks@SHA256@CryptoPP@@MEAA_KPEBI_K@Z)
sosemanuk.obj:-1: error: LNK2019: unresolved external symbol Sosemanuk_OperateKeystream referenced in function ""protected: virtual void __cdecl CryptoPP::SosemanukPolicy::OperateKeystream(enum CryptoPP::KeystreamOperation,unsigned char *,unsigned char const *,unsigned __int64)"" (?OperateKeystream@SosemanukPolicy@CryptoPP@@MEAAXW4KeystreamOperation@2@PEAEPEBE_K@Z)
</code></pre>

<p>These functions are in the MASM source files, like <a href=""https://github.com/weidai11/cryptopp/blob/master/x64dll.asm"" rel=""nofollow noreferrer""><code>x64dll.asm</code></a>, <a href=""https://github.com/weidai11/cryptopp/blob/master/x64masm.asm"" rel=""nofollow noreferrer""><code>x64masm.asm</code></a> and <a href=""https://github.com/weidai11/cryptopp/blob/master/rdrand.asm"" rel=""nofollow noreferrer""><code>rdrand.asm</code></a>. You should add the source files or use <code>-DCRYPTOPP_DISABLE_ASM</code>.</p>

<p>Once you add the missing source files I suspect you will have more troubles because you probably did not add preprocessor macros present in the Crypto++ Visual Studio solution and project files. You can get them from <a href=""https://github.com/weidai11/cryptopp/blob/master/cryptlib.vcxproj"" rel=""nofollow noreferrer""><code>cryptlib.vcxproj</code></a> (and vcxproj friends). Look for the <code>PreprocessorDefinitions</code> tag.</p>

<p>You should probably step back a bit. Build the library using Visual Studio solution and project files. You only need to build <code>cryptlib</code> project, debug and release configurations. Then, add the Crypto++ library as a linker option to your Qt project.</p>

<p>Also see <a href=""https://cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer"">Visual Studio</a> on the Crypto++ wiki. Pay particular attention to the section <a href=""https://cryptopp.com/wiki/Visual_Studio#Runtime_Linking"" rel=""nofollow noreferrer"">Runtime Linking</a>. Because you are using Qt, you will need to switch to Dynamic Runtime Linking. The wiki page tells you how to do it.</p>

<hr>

<p>Related to building Crypto++ with Qt and your program, you should understand there are multiple projects in the Visual Studio solution. When you said you <em>""added all header and source files""</em>, you added both the library (<code>cryptlib.vcxproj</code>) and the test suite (<code>cryptest.vcxproj</code>). You only need the library files, and not the test files.</p>

<p>Your Qt program supplied a <code>main</code> functions and the Crypto++ test suite provided a <code>main</code>, and that is why you are experiencing:</p>

<pre><code>test.obj:-1: error: LNK2005: main already defined in main.obj
</code></pre>

<p>You can get a list of the  header and source files by jumping over to Linux and then <code>make sources</code>. You are interested in <em><code>Library sources</code></em> and <em><code>Library headers</code></em>.</p>

<pre><code>$ make sources
***** Library sources *****
cryptlib.cpp cpu.cpp integer.cpp 3way.cpp adler32.cpp algebra.cpp algparam.cpp a
rc4.cpp aria.cpp aria_simd.cpp ariatab.cpp asn.cpp authenc.cpp base32.cpp base64
.cpp basecode.cpp bfinit.cpp blake2.cpp blake2b_simd.cpp blake2s_simd.cpp blowfi
sh.cpp blumshub.cpp camellia.cpp cast.cpp casts.cpp cbcmac.cpp ccm.cpp chacha.cp
p chacha_avx.cpp chacha_simd.cpp cham.cpp cham_simd.cpp channels.cpp cmac.cpp cr
c.cpp crc_simd.cpp darn.cpp default.cpp des.cpp dessp.cpp dh.cpp dh2.cpp dll.cpp
 donna_32.cpp donna_64.cpp donna_sse.cpp dsa.cpp eax.cpp ec2n.cpp eccrypto.cpp e
cp.cpp elgamal.cpp emsa2.cpp eprecomp.cpp esign.cpp files.cpp filters.cpp fips14
0.cpp fipstest.cpp gcm.cpp gcm_simd.cpp gf256.cpp gf2_32.cpp gf2n.cpp gf2n_simd.
cpp gfpcrypt.cpp gost.cpp gzip.cpp hc128.cpp hc256.cpp hex.cpp hight.cpp hmac.cp
p hrtimer.cpp ida.cpp idea.cpp iterhash.cpp kalyna.cpp kalynatab.cpp keccak.cpp
keccakc.cpp lea.cpp lea_simd.cpp lsh.cpp luc.cpp mars.cpp marss.cpp md2.cpp md4.
cpp md5.cpp misc.cpp modes.cpp mqueue.cpp mqv.cpp nbtheory.cpp neon_simd.cpp oae
p.cpp ospstore.cpp osrng.cpp padlkrng.cpp panama.cpp pkcspad.cpp poly1305.cpp po
lynomi.cpp ppc_power7.cpp ppc_power8.cpp ppc_power9.cpp ppc_simd.cpp pssr.cpp pu
bkey.cpp queue.cpp rabbit.cpp rabin.cpp randpool.cpp rc2.cpp rc5.cpp rc6.cpp rdr
and.cpp rdtables.cpp rijndael.cpp rijndael_simd.cpp ripemd.cpp rng.cpp rsa.cpp r
w.cpp safer.cpp salsa.cpp scrypt.cpp seal.cpp seed.cpp serpent.cpp sha.cpp sha3.
cpp sha_simd.cpp shacal2.cpp shacal2_simd.cpp shark.cpp sharkbox.cpp simeck.cpp
simeck_simd.cpp simon.cpp simon128_simd.cpp simon64_simd.cpp skipjack.cpp sm3.cp
p sm4.cpp sm4_simd.cpp sosemanuk.cpp speck.cpp speck128_simd.cpp speck64_simd.cp
p square.cpp squaretb.cpp sse_simd.cpp strciphr.cpp tea.cpp tftables.cpp threefi
sh.cpp tiger.cpp tigertab.cpp ttmac.cpp tweetnacl.cpp twofish.cpp vmac.cpp wake.
cpp whrlpool.cpp xed25519.cpp xtr.cpp xtrcrypt.cpp zdeflate.cpp zinflate.cpp zli
b.cpp

***** Library headers *****
3way.h adler32.h adv_simd.h aes.h aes_armv4.h algebra.h algparam.h androidpay.h
arc4.h argnames.h aria.h arm_simd.h asn.h authenc.h base32.h base64.h basecode.h
 blake2.h blowfish.h blumshub.h camellia.h cast.h cbcmac.h ccm.h chacha.h cham.h
 channels.h cmac.h config.h cpu.h crc.h cryptlib.h darn.h default.h des.h dh.h d
h2.h dll.h dmac.h donna.h donna_32.h donna_64.h donna_sse.h drbg.h dsa.h eax.h e
c2n.h eccrypto.h ecp.h ecpoint.h elgamal.h emsa2.h eprecomp.h equihash.h esign.h
 fhmqv.h files.h filters.h fips140.h fltrimpl.h gcm.h gf256.h gf2_32.h gf2n.h gf
pcrypt.h gost.h gzip.h hashfwd.h hc128.h hc256.h hex.h hight.h hkdf.h hmac.h hmq
v.h hrtimer.h ida.h idea.h integer.h iterhash.h kalyna.h keccak.h keccakc.h lea.
h lsh.h lubyrack.h luc.h mars.h md2.h md4.h md5.h mdc.h mersenne.h misc.h modari
th.h modes.h modexppc.h mqueue.h mqv.h naclite.h nbtheory.h nr.h oaep.h oids.h o
spstore.h osrng.h ossig.h padlkrng.h panama.h pch.h pem.h pkcspad.h poly1305.h p
olynomi.h ppc_simd.h pssr.h pubkey.h pwdbased.h queue.h rabbit.h rabin.h randpoo
l.h rc2.h rc5.h rc6.h rdrand.h rijndael.h ripemd.h rng.h rsa.h rw.h safer.h sals
a.h scrypt.h seal.h secblock.h seckey.h seed.h serpent.h serpentp.h sha.h sha3.h
 shacal2.h shark.h simeck.h simon.h simple.h siphash.h skipjack.h sm3.h sm4.h sm
artptr.h sosemanuk.h speck.h square.h stdcpp.h strciphr.h tea.h threefish.h tige
r.h trap.h trunhash.h ttmac.h tweetnacl.h twofish.h vmac.h wake.h whrlpool.h wor
ds.h xed25519.h xtr.h xtrcrypt.h zdeflate.h zinflate.h zlib.h

***** Test sources *****
adhoc.cpp test.cpp bench1.cpp bench2.cpp bench3.cpp datatest.cpp dlltest.cpp fip
salgt.cpp validat0.cpp validat1.cpp validat2.cpp validat3.cpp validat4.cpp valid
at5.cpp validat6.cpp validat7.cpp validat8.cpp validat9.cpp validat10.cpp regtes
t1.cpp regtest2.cpp regtest3.cpp regtest4.cpp

***** Test headers *****
bench.h factory.h validate.h
</code></pre>
","274","<c++><windows><visual-studio><qt5><crypto++>","2","2","1","2019-01-27 15:33:52","54389722","1","","608639","","2019-01-27 15:26:23","2019-01-27 14:02:44",""
"44454283","Calculate RSA and save to file in HEX","<p>i'm trying to to encrypt a buffer with rsa and then save the data in hex format to file. I'm using Crypto++ 5.6.5.</p>

<p>Loading keys (working):</p>

<pre><code>try
{
    // Read RSA public
    FileSource fs1(""public.pem"", true);
    PEM_Load(fs1, pubKey);

    // Read RSA encrypted private
    FileSource fs2(""private.pem"", true);
    PEM_Load(fs2, privKey, ""1234"", 4);
}
catch(const Exception&amp; ex)
{
    cout &lt;&lt; ""ERROR: RSA:"" &lt;&lt; ex.what() &lt;&lt; endl;
    SystemLog_Print(""RSA: Couldn't load keys"");
}
</code></pre>

<p>Encrypt (ok?):</p>

<pre><code>std::string RSA_Encrypt(unsigned char *buf, uint8_t len)
{
    AutoSeededRandomPool rng;
    std::string plain;
    std::string cipher, recovered;

    for(int i = 0; i &lt; len; ++i) {
        plain.push_back(buf[i]);
    }

    // Encryption
    RSAES_OAEP_SHA_Encryptor e(pubKey);

    StringSource ss1(plain, true, new PK_EncryptorFilter(rng, e, new StringSink(cipher)));

    // Test Decryption
    RSAES_OAEP_SHA_Decryptor d(privKey);

    StringSource ss2(cipher, true, new PK_DecryptorFilter(rng, d, new StringSink(recovered)));

    if(memcmp(plain.data(), recovered.data(), plain.size()) != 0) {
        cout &lt;&lt; ""RSA Mismatch"" &lt;&lt; endl;
    }

    return cipher;
}
</code></pre>

<p>Now i'm stuck with writing the encrypted data to a file in readable HEX like: </p>

<blockquote>
  <p>AB123CDE456</p>
</blockquote>

<p>Using stream operators like std::hex doesn't seem to work.
Could you give me any advice how to do this?</p>

<p>Not working:</p>

<pre><code>unsigned char *buf[] = ""123456789"";
file &lt;&lt; std::hex &lt;&lt; RSA_Encrypt(buf, 9);
</code></pre>

<p>Prints only some unreadable binary data;</p>
","<p>A hex output function could look like this:</p>

<pre><code>void writeHex(std::ostream &amp;out, const char *data, size_t len)
{
  char digits[] = ""0123456789ABCDEF"";
  for (size_t i = 0; i &lt; len; ++i) {
    unsigned byte = (unsigned)data[i];
    out &lt;&lt; digits[byte &gt;&gt; 4] &lt;&lt; digits[byte &amp; 0xf];
  }
}
</code></pre>

<p>With a small sample to test it:</p>

<pre><code>#include &lt;iostream&gt;

void writeHex(std::ostream &amp;out, const char *data, size_t len)
{
  char digits[] = ""0123456789ABCDEF"";
  for (size_t i = 0; i &lt; len; ++i) {
    unsigned byte = (unsigned)data[i];
    out &lt;&lt; digits[byte &gt;&gt; 4] &lt;&lt; digits[byte &amp; 0xf];
  }
}

int main()
{
  // sample data
  char data[] =
    ""This is some test data:\n""
    ""\x00\x01\x02\x03\0x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f""
    ""\x10\x11\x12\x13\0x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f""
    ""\x20\x21\x22\x23\0x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f""
    ""\x30\x31\x32\x33\0x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"";
  // test writeHex()
  writeHex(std::cout, data, sizeof data);
  std::cout &lt;&lt; std::endl;
  // done
  return 0;
}
</code></pre>

<p>Compiled and tested with VS2013 on Windows 10 (64 bit):</p>

<pre><code>5468697320697320736F6D65207465737420646174613A0A000102030078303405060708090A0B0C0D0E0F101112130078313415161718191A1B1C1D1E1F202122230078323425262728292A2B2C2D2E2F303132330078333435363738393A3B3C3D3E3F00
</code></pre>

<p>The human-readable text at the begin of my test <code>data[]</code> can be checked using an <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> table. I simply searched for ""000102"" and saw the ""0A"" (for <code>\n</code>) before. The ""00"" at the end of output is for the string 0-terminator (which is considered by <code>sizeof</code> also).</p>
","271","<c++><encryption><hex><rsa><crypto++>","1","0","3","2017-06-10 00:52:57","","5","","2880355","","2017-06-09 09:43:37","2017-06-09 09:33:37",""
"44454283","Calculate RSA and save to file in HEX","<p>i'm trying to to encrypt a buffer with rsa and then save the data in hex format to file. I'm using Crypto++ 5.6.5.</p>

<p>Loading keys (working):</p>

<pre><code>try
{
    // Read RSA public
    FileSource fs1(""public.pem"", true);
    PEM_Load(fs1, pubKey);

    // Read RSA encrypted private
    FileSource fs2(""private.pem"", true);
    PEM_Load(fs2, privKey, ""1234"", 4);
}
catch(const Exception&amp; ex)
{
    cout &lt;&lt; ""ERROR: RSA:"" &lt;&lt; ex.what() &lt;&lt; endl;
    SystemLog_Print(""RSA: Couldn't load keys"");
}
</code></pre>

<p>Encrypt (ok?):</p>

<pre><code>std::string RSA_Encrypt(unsigned char *buf, uint8_t len)
{
    AutoSeededRandomPool rng;
    std::string plain;
    std::string cipher, recovered;

    for(int i = 0; i &lt; len; ++i) {
        plain.push_back(buf[i]);
    }

    // Encryption
    RSAES_OAEP_SHA_Encryptor e(pubKey);

    StringSource ss1(plain, true, new PK_EncryptorFilter(rng, e, new StringSink(cipher)));

    // Test Decryption
    RSAES_OAEP_SHA_Decryptor d(privKey);

    StringSource ss2(cipher, true, new PK_DecryptorFilter(rng, d, new StringSink(recovered)));

    if(memcmp(plain.data(), recovered.data(), plain.size()) != 0) {
        cout &lt;&lt; ""RSA Mismatch"" &lt;&lt; endl;
    }

    return cipher;
}
</code></pre>

<p>Now i'm stuck with writing the encrypted data to a file in readable HEX like: </p>

<blockquote>
  <p>AB123CDE456</p>
</blockquote>

<p>Using stream operators like std::hex doesn't seem to work.
Could you give me any advice how to do this?</p>

<p>Not working:</p>

<pre><code>unsigned char *buf[] = ""123456789"";
file &lt;&lt; std::hex &lt;&lt; RSA_Encrypt(buf, 9);
</code></pre>

<p>Prints only some unreadable binary data;</p>
","<p>OK, for anyone interested...
I found a generic hex formatter here: <a href=""https://stackoverflow.com/questions/5100718/integer-to-hex-string-in-c"">Integer to hex string in C++</a></p>

<p>I slightly modified it like this:</p>

<pre><code>template&lt; typename T &gt;
std::string int2hex(T i)
{
  std::stringstream stream;
  stream &lt;&lt; std::setfill ('0') &lt;&lt; std::setw(sizeof(T)*2)
         &lt;&lt; std::hex &lt;&lt; (int32_t)i;
  return stream.str();
}
</code></pre>

<p>Now i call my routines like this:</p>

<pre><code>buf = RSA_Encrypt(data, 32);

// Write hash to sig file
for(unsigned int i = 0 ; i &lt; buf.size() ; ++i) {
    uint8_t val = buf[i];
    file &lt;&lt; int2hex(val);
}
</code></pre>

<p>Now i get HEX chars in my file.</p>
","271","<c++><encryption><hex><rsa><crypto++>","1","1","3","2017-06-10 00:52:57","","5","","2880355","","2017-06-09 09:43:37","2017-06-09 09:33:37",""
"44454283","Calculate RSA and save to file in HEX","<p>i'm trying to to encrypt a buffer with rsa and then save the data in hex format to file. I'm using Crypto++ 5.6.5.</p>

<p>Loading keys (working):</p>

<pre><code>try
{
    // Read RSA public
    FileSource fs1(""public.pem"", true);
    PEM_Load(fs1, pubKey);

    // Read RSA encrypted private
    FileSource fs2(""private.pem"", true);
    PEM_Load(fs2, privKey, ""1234"", 4);
}
catch(const Exception&amp; ex)
{
    cout &lt;&lt; ""ERROR: RSA:"" &lt;&lt; ex.what() &lt;&lt; endl;
    SystemLog_Print(""RSA: Couldn't load keys"");
}
</code></pre>

<p>Encrypt (ok?):</p>

<pre><code>std::string RSA_Encrypt(unsigned char *buf, uint8_t len)
{
    AutoSeededRandomPool rng;
    std::string plain;
    std::string cipher, recovered;

    for(int i = 0; i &lt; len; ++i) {
        plain.push_back(buf[i]);
    }

    // Encryption
    RSAES_OAEP_SHA_Encryptor e(pubKey);

    StringSource ss1(plain, true, new PK_EncryptorFilter(rng, e, new StringSink(cipher)));

    // Test Decryption
    RSAES_OAEP_SHA_Decryptor d(privKey);

    StringSource ss2(cipher, true, new PK_DecryptorFilter(rng, d, new StringSink(recovered)));

    if(memcmp(plain.data(), recovered.data(), plain.size()) != 0) {
        cout &lt;&lt; ""RSA Mismatch"" &lt;&lt; endl;
    }

    return cipher;
}
</code></pre>

<p>Now i'm stuck with writing the encrypted data to a file in readable HEX like: </p>

<blockquote>
  <p>AB123CDE456</p>
</blockquote>

<p>Using stream operators like std::hex doesn't seem to work.
Could you give me any advice how to do this?</p>

<p>Not working:</p>

<pre><code>unsigned char *buf[] = ""123456789"";
file &lt;&lt; std::hex &lt;&lt; RSA_Encrypt(buf, 9);
</code></pre>

<p>Prints only some unreadable binary data;</p>
","<blockquote>
  <p>Now i'm stuck with writing the encrypted data to a file in readable
  HEX like:</p>

<pre><code>AB123CDE456
</code></pre>
</blockquote>

<p>Add a <a href=""https://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow noreferrer""><code>HexEncoder</code></a> and use a <a href=""https://www.cryptopp.com/wiki/FileSink"" rel=""nofollow noreferrer""><code>FileSink</code></a> in the pipeline:</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource ss(plain, true, new PK_EncryptorFilter(rng, enc, new HexEncoder(new FileSink(""file.enc""))));  
</code></pre>

<p>With the change above, the data is hex encoded as it travels through the pipeline.</p>

<p>Later, when you are ready to read the data, you use a <a href=""https://www.cryptopp.com/wiki/FileSource"" rel=""nofollow noreferrer""><code>FileSource</code></a> and add a <a href=""https://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow noreferrer""><code>HexDecoder</code></a> in the pipeline. Ad the decoder is added before the decryptor, not afterwards like when encrypting.</p>

<pre class=""lang-cxx prettyprint-override""><code>FileSource fs(""file.enc"", true, new HexDecoder, new PK_DecryptorFilter(rng, dec, new StringSink(recovered))));  
</code></pre>

<hr>

<p>You should probably avoid this because its <em>not</em> a constant time compare:</p>

<pre class=""lang-cxx prettyprint-override""><code>if(memcmp(plain.data(), recovered.data(), plain.size()) != 0) {
    cout &lt;&lt; ""RSA Mismatch"" &lt;&lt; endl;
}
</code></pre>

<p>Use <a href=""https://www.cryptopp.com/wiki/VerifyBufsEqual"" rel=""nofollow noreferrer""><code>VerifyBufsEqual</code></a> instead:</p>

<pre class=""lang-cxx prettyprint-override""><code>bool equal = VerifyBufsEqual(plain.data(), recovered.data(), plain.size());
</code></pre>

<p><code>VerifyBufsEqual</code> requires same size buffers, so maybe something like:</p>

<pre><code>bool equal = (plain.size() == recovered.size());
size_t size = STDMIN(plain.size(), recovered.size());
equal = VerifyBufsEqual(plain.data(), recovered.data(), size) &amp;&amp; equal;
</code></pre>

<hr>

<p>This may help...</p>

<p>Instead of using an intermediate <code>std::string</code>:</p>

<pre class=""lang-cxx prettyprint-override""><code>std::string RSA_Encrypt(unsigned char *buf, uint8_t len)
{
    ...    
    for(int i = 0; i &lt; len; ++i) {
        plain.push_back(buf[i]);
    }  
    ...    
    StringSource ss(plain, true, new PK_EncryptorFilter(rng, enc, new StringSink(cipher)));    
    ...
}
</code></pre>

<p>You can use the <code>buf</code> and <code>len</code> instead:</p>

<pre class=""lang-cxx prettyprint-override""><code>std::string RSA_Encrypt(unsigned char *buf, uint8_t len)
{ 
    ...    
    ArraySource as(buf, len, true, new PK_EncryptorFilter(rng, enc, new StringSink(cipher)));    
    ...
}
</code></pre>

<p>An <a href=""https://www.cryptopp.com/wiki/ArraySource"" rel=""nofollow noreferrer""><code>ArraySource</code></a> is really a typedef of a <a href=""https://www.cryptopp.com/wiki/StringSource"" rel=""nofollow noreferrer""><code>StringSource</code></a> using a constructor overload.</p>
","271","<c++><encryption><hex><rsa><crypto++>","1","0","3","2017-06-10 00:52:57","","5","","2880355","","2017-06-09 09:43:37","2017-06-09 09:33:37",""
"47325517","How to use a different alphabet for Base32 classes?","<p>On python when I do:</p>

<pre><code>encoded = base64.b32encode(""1ACC64E9510C32CE8E34"".decode('hex'))
</code></pre>

<p>I get <code>DLGGJ2KRBQZM5DRU</code>. While on Crypto++:</p>

<pre><code>std::string decoded2;
std::string first_20=""1ACC64E9510C32CE8E34"";

StringSource ssv(first_20, true /*pumpAll*/,
    new HexDecoder(
        new StringSink(decoded2)
    ) // HexDecoder
); // StringSource
boost::algorithm::to_lower(decoded2);

StringSource ss( decoded2, true,

    new Base32Encoder(
        new StringSink(hash_sink)
    ) // Base64Decoder
); // StringSource

std::cout&lt;&lt;""encoded raw:""&lt;&lt;hash_sink&lt;&lt;std::endl;
</code></pre>

<p>I get <code>DMGGJ4MTBS3N7DTW</code> which is wrong.</p>

<p>Is there a way I can encode the string above in c++ and get the same result as python does it ?</p>
","<p>I found the perfect solution github</p>

<pre><code>static const CryptoPP::byte ALPHABET[]          = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ234567""; // Most libraries use RFC4648.

const std::string decode( const std::string&amp; encoded )
{
    std::string decoded;

    static int decoding_array[256];
    CryptoPP::Base32Decoder::InitializeDecodingLookupArray(decoding_array, 
                               ALPHABET, 
                               32, 
                               true); // false = case insensitive

    CryptoPP::Base32Decoder b32decoder;
    CryptoPP::AlgorithmParameters dp = CryptoPP::MakeParameters(
                                       CryptoPP::Name::DecodingLookupArray(),
                                       (const int *)decoding_array,
                                       false);
    b32decoder.IsolatedInitialize(dp); 

    b32decoder.Attach( new CryptoPP::StringSink( decoded ) );
    b32decoder.Put( (std::uint8_t*)encoded.c_str(), encoded.size() );
    b32decoder.MessageEnd();

    return decoded;
}
</code></pre>

<p>I hope the guy who downvoted me can also see this.
I'm very new to crypto++ and cryptography as a whole.</p>
","269","<python><c++><base64><crypto++><base32>","-3","0","1","2017-11-28 08:25:38","","6","","608639","","2017-11-28 08:25:38","2017-11-16 09:06:45",""
"24237654","Truncated output from CFB mode when calling from C#","<p>I have pretty annoying issue which I'm unable to solve for 2 days. I have an <code>encrypt()</code> method which makes use of Crypto++ library written in C++. The method is implemented as follows:</p>

<pre><code>string CRijndaelHelper::Encrypt(string text)
{
    CFB_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(_key, sizeof(_key), _iv);

    string cipher, encoded;

    // CFB mode must not use padding. Specifying
    //  a scheme will result in an exception
    StringSource ss(text, true,
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        ));     

    return cipher;
};
</code></pre>

<p>When I call this method within the native environment it works perfectly, encrypting the whole 26Kb xml string without any problem.</p>

<p>Eventually I've had to implement the encryption in C# code, for that purpose I wrote the following wrapper code in native dll for later use with PInvoke:</p>

<pre><code>extern ""C""
API_EXPORT char* _cdecl encrypt(char* contents)
{   
    string cont(contents);
    CRijndaelHelper rij;
    string transformedText = rij.Encrypt(cont);     
    return marshalReturn(transformedText);  
}
</code></pre>

<p>While the PInvoke part looks as follows:</p>

<pre><code>[DllImport(""EncryptDecrypt.dll"", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Cdecl)]
[return: MarshalAs(UnmanagedType.LPStr)]
public static extern string encrypt([MarshalAs(UnmanagedType.LPStr)] string contents);
</code></pre>

<p>And everything looks working perfect except that I get in <code>transformedText</code> variable only first 540 bytes encrypted and that's all. </p>

<p>Please advise.</p>
","<blockquote>
  <p>... returns a string which is correctly encrypted when invoked from native code</p>
</blockquote>

<p>The problem is not you C++ <code>encrypt</code>, which uses a <code>std::string</code>. The problem is with marshalling it back to managed code as a <code>char*</code>.</p>

<p>Change <code>CRijndaelHelper::Encrypt</code> to the following to remove the embedded <code>NULL</code> that will be sprinkled liberally with a probability of 1/255:</p>

<pre><code>#include &lt;cryptopp/base64.h&gt;
using CryptoPP::Base64Encoder;
...

string CRijndaelHelper::Encrypt(string text)
{
    CFB_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(_key, sizeof(_key), _iv);

    string cipher, encoded;

    // CFB mode must not use padding. Specifying
    //  a scheme will result in an exception
    StringSource ss(text, true,
        new StreamTransformationFilter(e,
            new Base64Encoder(
                new StringSink(cipher)
        )));     

    return cipher;
};
</code></pre>

<p>With the <code>Base64</code> encoding, the marshaling as a <code>char*</code> will <em>not</em> truncate the encryption results on the first <code>NULL</code> byte encountered.</p>

<p>Then, for decryption:</p>

<pre><code>StringSource ss(cipher, true,
    new Base64Decoder(
        new StreamTransformationFilter(d,
            new StringSink(text)
    )));   
</code></pre>
","268","<c#><c++><encryption><pinvoke><crypto++>","1","1","2","2016-02-21 15:29:44","24239856","4","","608639","","2016-02-21 15:29:44","2014-06-16 06:20:54",""
"24237654","Truncated output from CFB mode when calling from C#","<p>I have pretty annoying issue which I'm unable to solve for 2 days. I have an <code>encrypt()</code> method which makes use of Crypto++ library written in C++. The method is implemented as follows:</p>

<pre><code>string CRijndaelHelper::Encrypt(string text)
{
    CFB_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(_key, sizeof(_key), _iv);

    string cipher, encoded;

    // CFB mode must not use padding. Specifying
    //  a scheme will result in an exception
    StringSource ss(text, true,
        new StreamTransformationFilter(e,
            new StringSink(cipher)
        ));     

    return cipher;
};
</code></pre>

<p>When I call this method within the native environment it works perfectly, encrypting the whole 26Kb xml string without any problem.</p>

<p>Eventually I've had to implement the encryption in C# code, for that purpose I wrote the following wrapper code in native dll for later use with PInvoke:</p>

<pre><code>extern ""C""
API_EXPORT char* _cdecl encrypt(char* contents)
{   
    string cont(contents);
    CRijndaelHelper rij;
    string transformedText = rij.Encrypt(cont);     
    return marshalReturn(transformedText);  
}
</code></pre>

<p>While the PInvoke part looks as follows:</p>

<pre><code>[DllImport(""EncryptDecrypt.dll"", CharSet = CharSet.Auto, CallingConvention = CallingConvention.Cdecl)]
[return: MarshalAs(UnmanagedType.LPStr)]
public static extern string encrypt([MarshalAs(UnmanagedType.LPStr)] string contents);
</code></pre>

<p>And everything looks working perfect except that I get in <code>transformedText</code> variable only first 540 bytes encrypted and that's all. </p>

<p>Please advise.</p>
","<p>Your fundamental problem is that you are working on the wrong types. Encryption works with byte arrays and not with text. You need to stop using <code>string</code>, <code>char*</code> and so on. You need to use <code>unsigned char*</code> in the unmanaged code, and <code>byte[]</code> in the managed code. </p>

<p>It might be hard for you to accept this advice, but I proffer it all the same. On top of the problems with zero bytes being treated as null terminators (the reason for your truncation), your current approach simply neglects the issue of text encoding. You cannot do that.</p>

<p>You presumably have good reasons why you wish to transform a string to another string. That's fine, but the encryption part of the transformation needs to operate on byte arrays. The way to handle encryption of text to text is to use a chain of transformations. The transformation when encrypting runs like this:</p>

<ol>
<li>Convert string to byte array using well-defined encoding. For instance, UTF-8.</li>
<li>Encrypt byte array, which results in another byte array being output.</li>
<li>Encode this encrypted byte array as text using, for example, base64.</li>
</ol>

<p>This respects the fact that encryption operates on byte arrays, as well as being explicit about the text encoding.</p>

<p>In the opposite direction you reverse the steps:</p>

<ol>
<li>Decode the base64 to an encrypted byte array.</li>
<li>Decrypt this byte array.</li>
<li>Decode the decrypted byte array using UTF-8 to obtain the original string.</li>
</ol>
","268","<c#><c++><encryption><pinvoke><crypto++>","1","2","2","2016-02-21 15:29:44","24239856","4","","608639","","2016-02-21 15:29:44","2014-06-16 06:20:54",""
"30442336","Build and run library on a Cortex M3 using KEIL uVision IDE","<p>I want to use the Crypto++ library on an ARM cortex M3 microcontroller using the Keil uVision IDE.</p>

<p>How do I build and run library on a Cortex M3 using KEIL uVision IDE</p>
","<blockquote>
  <p>I want to use the Crypto++ library on an ARM cortex M3 microcontroller using the Keil uVision IDE.</p>
</blockquote>

<p>Crypto++ has a wiki page on cross-compiling for the platform. See <a href=""http://www.cryptopp.com/wiki/ARM_Embedded_%28Bare_Metal%29"" rel=""nofollow"">ARM Embedded (Bare Metal)</a> on the Crypto++ wiki. It uses ARM/Terry Guo's cross-compiler, so it has the latest processor support.</p>

<p>Fro Cortex M3, you are going to want to add either <code>-mthumb -mcpu=cortex-m3</code> or <code>-mthumb -march=armv7-m</code> to <code>CXXFLAGS</code>. You also need to link against the <code>armv7-m</code> multilib. (I'm not sure which C++ runtime is used).</p>

<p>There's also <a href=""http://www.cryptopp.com/wiki/ARM_Embedded_%28Command_Line%29"" rel=""nofollow"">ARM Embedded (Command Line)</a> on the Crypto++ wiki. But it uses Debian's cross tools, and they leave a lot to be desired at times.</p>

<p>Unfortunately, I know nothing about Keil uVision IDE, so I don't know where the pain points are.</p>

<hr>

<blockquote>
  <p>How do I build and run library </p>
</blockquote>

<p>To build the library, you run <code>make static dynamic cryptest.exe</code>.</p>

<p>Once you build the library, you need to install <code>cryptest.exe</code> on the board, <em>in addition to</em> the test vectors and data in <code>TestVectors</code> and <code>TestData</code>.</p>

<p>You have to maintain the directory structure because the paths to the test data and vectors are hard coded. Once the board is loaded as so:</p>

<pre><code>+ Filesystem
|
+ --- cryptest.exe
|
+ --- TestData/
|
+ --- TestVectors/
|
...
</code></pre>

<p>Then you simply run <code>./cryptest.exe v</code> to execute the tests.</p>

<p>But at 10 MHz to 150 MHz or so, the Cortex M3 is going to be quite painful :) Not to mention the memory pressures of a 3.5 MB binary on a resource contrained board....</p>

<p>You can fix the hard coded paths with the <a href=""http://www.cryptopp.com/wiki/Datadir"" rel=""nofollow"">DataDir Patch</a>. Its provided by the community, but I think it should be part of the library. It cause every distro maintainer I know troubles.</p>

<hr>

<blockquote>
  <p>Has anyone tried it before?</p>
</blockquote>

<p>Probably, but not that I am aware. If you get results, then please report back. I lack an exemplary platform, so I could not add typical results to the wiki page.</p>
","266","<arm><embedded><crypto++><cortex-m3>","-1","0","1","2015-05-26 02:42:45","","5","","608639","","2015-05-25 21:43:51","2015-05-25 16:22:49",""
"29760112","Decrypt of file displays both original and cipher text?","<p>I am working to encrypt and decrypt files using Crypto++. In encryption, <code>key</code>  and random <code>IV</code> are generated and <code>hexencoded</code> where as text from file is encrypted. Both <code>IV</code> and <code>cipher</code> text are written to the same file.</p>

<p>In decryption, <code>key</code> is generated using same criteria as encryption and random <code>IV</code> is extracted from the file and <code>hexdecoded</code>. Text after <code>iv</code> length is stored in a string and decrypted. </p>

<p>What happens is I can see the original file so I know that it is working but it also displays <code>cipher</code> text after the original file text. Does any one how to solve it?</p>

<pre><code> //some code to declare variables, read from file and so on 

  unsigned char * inputContent = (unsigned char *) malloc(fileSize * sizeof(char));     //create char array of same size as file content 

 //inputContent is for storing file data    

  string rawString(reinterpret_cast&lt;char*&gt;(inputContent), fileSize);        //convert char array to string

  //extract iv, key and cipher from rawString
  string rawIV;
  rawIV = rawString.substr(0, 32);

  //code to hexdecode iv

  string cipher;
  cipher = rawString.substr(32, fileSize - 32);

  string recovered;

  CBC_Mode&lt; AES &gt;::Decryption d;
  d.SetKeyWithIV(key, sizeof(key), iv);

  StringSource s_recover(cipher, true, 
      new StreamTransformationFilter(d,
                new StringSink(recovered)
            )
        );  

  const char * writeContent = recovered.c_str();

  if(pwrite(fd, writeContent, recovered.length(), 0) &lt;= 0)
  {
      return -1;    //error
  }
</code></pre>

<p>Thanks in advance. ☺</p>
","<p>You might try something like this. But its hard to say if it will actually work since its not clear what you are actually doing or where the problem lies.</p>

<pre><code>FileSource fs(""&lt;filename&gt;"", false /*pumpAll*/);    
SecByteBlock key(AES::DEFAULT_KEYLENGTH), iv(AES::BLOCKSIZE);

// Fetch key from somewhere
key = ...;

// Fetch IV from file
fs.Detach(new HexDecoder(new ArraySink(iv, iv.size()));
fs.Pump(32);

CBC_Mode&lt; AES &gt;::Decryption dec;
dec.SetKeyWithIV(key, key.size(), iv, iv.size());

string recovered;
fs.Detach(new HexDecoder(new StreamTransformationFilter(dec, new StringSink(recovered))));
fs.PumpAll();
</code></pre>

<p>You can also use the following <em>if</em> you get the <a href=""http://www.cryptopp.com/wiki/SecByteBlockSink"" rel=""nofollow noreferrer""><code>SecByteBlockSink</code> patch</a>:</p>

<pre><code>SecByteBlock recovered;
fs.Detach(new HexDecoder(new StreamTransformationFilter(dec, new SecByteBlockSink(recovered))));
fs.PumpAll();
</code></pre>

<hr>

<p><code>rawString</code> isn't needed below:</p>

<pre><code>//create char array of same size as file content 
unsigned char * inputContent = (unsigned char *) malloc(fileSize * sizeof(char));     

//inputContent is for storing file data    

//convert char array to string
string rawString(reinterpret_cast&lt;char*&gt;(inputContent), fileSize);
</code></pre>

<p>Maybe you should try:</p>

<pre><code>ArraySource as(inputContent, fileSize, false /*pumpAll*/);
</code></pre>

<p>Using the <a href=""http://www.cryptopp.com/wiki/ArraySource"" rel=""nofollow noreferrer""><code>ArraySource</code></a> means you don't make a copy of the data (the <code>string</code> copies the data), and its ready to go for Crypto++.</p>

<p>Also, since you're already into C++ code, use an <code>unique_ptr</code> and <code>new</code> rather than <code>malloc</code>. The <code>unique_ptr</code> will handle cleanup for you. (Or, use a <code>std::vector</code>).</p>

<pre><code>unique_ptr&lt;byte[]&gt; buffer(new byte[fileSize]);
</code></pre>

<hr>

<p>I don't know how you are going to make a file descriptor work in the grand scheme of things. Crypto++ is a C++ library, and C++ uses I/O streams. Maybe this will help: <a href=""https://stackoverflow.com/q/2746168"">How to construct a c++ fstream from a POSIX file descriptor?</a></p>

<p>Also see <a href=""https://stackoverflow.com/q/11558447"">Retrieving file descriptor from a std::fstream</a> and <a href=""https://stackoverflow.com/q/109449"">Getting a FILE* from a std::fstream</a>.</p>
","262","<c++><aes><crypto++><cbc-mode>","-2","0","1","2015-04-21 23:14:33","29783751","11","","4812502","","2015-04-21 20:17:23","2015-04-20 23:17:38",""
"49143894","Encrypt and decrypt a file from disk rather than memory?","<p>When I am trying to encrypt and decrypt a 250MB file using AES algorithm, I am getting the following error. When I am trying with datasets less than 250, I am able to get the output.</p>

<p><a href=""https://i.stack.imgur.com/YsPBn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YsPBn.png"" alt=""enter image description here""></a></p>
","<p>From the COMMENTS:</p>

<pre><code>string cipher, encoded, recovered;
FileSource file(""C:/Users/sai/desktop/RA/250.avi"", true, new StringSink(plain));
</code></pre>

<p>This may or may not work depending on several factors. On a desktop or server you should have no problems because it will have a lot of RAM and a swap file. </p>

<p>On a mobile device it will probably die if the file is large. If it dies then the problem is probably because <code>StringSink</code> is an in-memory string but the device ran out of memory.</p>

<hr>

<p>From the COMMENTS:</p>

<blockquote>
  <p>... Do I need to break the file into chunks and then encrypt and decrypt? </p>
</blockquote>

<p>No, you should not need to break the file into chunks. The <code>FileSource</code> will do it for you. It will break the data into 4096 chunks, if I recall correctly. What you probably need to do is switch from a <code>StringSink</code> to a <code>FileSink</code>.</p>

<p>Also see <a href=""https://www.cryptopp.com/wiki/Pumping_Data#Encryption"" rel=""nofollow noreferrer"">Pumping Data | Encryption</a> on the Crypto++ wiki. Here's the sample provided:</p>

<pre><code>inline bool EndOfFile(const FileSource&amp; file)
{
  std::istream* stream = const_cast&lt;FileSource&amp;&gt;(file).GetStream();
  return stream-&gt;eof();
}

int main(int argc, char* argv[])
{
  try
  {
      byte key[AES::DEFAULT_KEYLENGTH]={}, iv[AES::BLOCKSIZE]={};
      CTR_Mode&lt;AES&gt;::Encryption encryptor;
      encryptor.SetKeyWithIV(key, sizeof(key), iv);

      MeterFilter meter;
      StreamTransformationFilter filter(encryptor);

      FileSource source(""plain.bin"", false);
      FileSink sink(""cipher.bin"");

      source.Attach(new Redirector(filter));
      filter.Attach(new Redirector(meter));
      meter.Attach(new Redirector(sink));

      const word64 BLOCK_SIZE = 4096;
      word64 processed = 0;

      while(!EndOfFile(source) &amp;&amp; !source.SourceExhausted())
      {
        source.Pump(BLOCK_SIZE);
        filter.Flush(false);

        processed += BLOCK_SIZE;

        if (processed % (1024*1024*10) == 0)
          cout &lt;&lt; ""Processed: "" &lt;&lt; meter.GetTotalBytes() &lt;&lt; endl;
      }

      // Signal there is no more data to process.
      // The dtor's will do this automatically.
      filter.MessageEnd();
  }
  catch(const Exception&amp; ex)
  {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
  }

  return 0;
}
</code></pre>

<hr>

<p>From the TITLE:</p>

<blockquote>
  <p>[How to] encrypt and decrypt a file from disk rather than memory?</p>
</blockquote>

<p>Try something like the following. Your code is missing the encryption or decryption object, so be sure to include one in the real code.</p>

<pre><code>FileSource file(""C:/Users/sai/desktop/RA/250.avi"", true, new FileSink(""C:/Users/sai/desktop/RA/250.avi.enc""));
</code></pre>

<p>Or, you can use the code that shows you how to manually pump data.</p>

<hr>

<p>From the COMMENTS:</p>

<pre><code>int start_s = clock();
</code></pre>

<p>Also see <a href=""https://www.cryptopp.com/wiki/Benchmarks#Sample_Program"" rel=""nofollow noreferrer"">Benchmarks | Sample Program</a> on the Crypto++ wiki. Here's the sample provided:</p>

<pre><code>const double runTimeInSeconds = 3.0;
const double cpuFreq = 2.7 * 1000 * 1000 * 1000;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    SecByteBlock key(16);
    prng.GenerateBlock(key, key.size());

    CTR&lt;AES&gt;::Encryption cipher;
    cipher.SetKeyWithIV(key, key.size(), key);

    const int BUF_SIZE = RoundUpToMultipleOf(2048U,
        dynamic_cast&lt;StreamTransformation&amp;&gt;(cipher).OptimalBlockSize());

    AlignedSecByteBlock buf(BUF_SIZE);
    prng.GenerateBlock(buf, buf.size());

    double elapsedTimeInSeconds;
    unsigned long i=0, blocks=1;

    ThreadUserTimer timer;
    timer.StartTimer();

    do
    {
        blocks *= 2;
        for (; i&lt;blocks; i++)
            cipher.ProcessString(buf, BUF_SIZE);
        elapsedTimeInSeconds = timer.ElapsedTimeAsDouble();
    }
    while (elapsedTimeInSeconds &lt; runTimeInSeconds);

    const double bytes = static_cast&lt;double&gt;(BUF_SIZE) * blocks;
    const double ghz = cpuFreq / 1000 / 1000 / 1000;
    const double mbs = bytes / elapsedTimeInSeconds / 1024 / 1024;
    const double cpb = elapsedTimeInSeconds * cpuFreq / bytes;

    std::cout &lt;&lt; cipher.AlgorithmName() &lt;&lt; "" benchmarks..."" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; ghz &lt;&lt; "" GHz cpu frequency""  &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; cpb &lt;&lt; "" cycles per byte (cpb)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; mbs &lt;&lt; "" MiB per second (MiB)"" &lt;&lt; std::endl;   

    return 0;
}
</code></pre>
","260","<c++><encryption><crypto++>","-2","-2","1","2018-03-17 16:32:22","","5","","608639","","2018-03-09 01:24:50","2018-03-07 04:01:48",""
"45292536","Crypto++ AutoSeededRandomPool copy constructor implicitly deleted","<p>My question is about a crypto++ constructor and why it is in the state of being ""implicitly deleted"" even though it follows the examples provided in the documentation.</p>

<p>I am trying to go off of the code provided by the example on <a href=""https://www.cryptopp.com/wiki/Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">Crypto++'s documentation to create a digital signature key pair</a>, but I am having trouble calling the constructor for AutoSeededRandomPool objects.
Here is the command I am calling to the terminal: </p>

<pre><code>g++  -I /usr/local/include/ -l cryptopp -std=c++11 -c -o build/account.o src/account.cpp 
</code></pre>

<p>I am getting the following error: </p>

<pre><code>error: call to implicitly-deleted copy constructor of 'CryptoPP::AutoSeededRandomPool',
note: copy constructor of 'AutoSeededRandomPool' is implicitly deleted because base
class 'CryptoPP::RandomPool' has a deleted copy constructor
</code></pre>

<p>Additionally, I get this unusual message: </p>

<pre><code>clang: warning: -lcryptopp: 'linker' input unused [-Wunused-command-line-argument]
</code></pre>

<p>Here is are the files I use to generate the public/private key pair. They pretty much follow the example: </p>

<pre><code>DSA::PrivateKey create_private_key(AutoSeededRandomPool rng) {
  DSA::PrivateKey private_Key;
  private_Key.GenerateRandomWithKeySize(rng, 1024);
  return private_Key;
}

DSA::PublicKey create_public_key(DSA::PrivateKey private_key, AutoSeededRandomPool rng) {
  DSA::PublicKey public_Key;
  public_Key.AssignFrom(private_key);
  if (!private_key.Validate(rng, 3) || !public_Key.Validate(rng, 3))
  {
    throw std::runtime_error(""DSA key generation failed"");
  }
  return public_Key;
}
</code></pre>

<p>I declare and initialize the <code>AutoSeededRandomPool</code> object in a constructor as follows:</p>

<pre><code>account::account() {
  balance = 0;
  AutoSeededRandomPool rng;
  private_key = utils::create_private_key(rng);
  public_key = utils::create_public_key(private_key, rng);
}
</code></pre>

<p>I have linked in the libraries necessary for this, and I am linking them in when I call g++. Additionally, if anyone knows if there are any more detailed examples of Crypto++ code, those resources would be greatly appreciated. </p>
","<blockquote>
<pre><code> g++ -I /usr/local/include/ -l cryptopp -std=c++11 -c -o build/account.o src/account.cpp 
</code></pre>
  
  <p>clang: warning: -lcryptopp: 'linker' input unused</p>
</blockquote>

<p>Try:</p>

<pre><code>g++ ... src/account.cpp -c -o build/account.o
</code></pre>

<p>Omit <code>-l cryptopp</code>. It is only needed during link.</p>

<hr>

<blockquote>
<pre><code>DSA::PrivateKey create_private_key(AutoSeededRandomPool rng) {
  DSA::PrivateKey private_Key;
  private_Key.GenerateRandomWithKeySize(rng, 1024);
  return private_Key;
}
</code></pre>
  
  <p>error: call to implicitly-deleted copy constructor of
  'CryptoPP::AutoSeededRandomPool', note: copy constructor of
  'AutoSeededRandomPool' is implicitly deleted because base class
  'CryptoPP::RandomPool' has a deleted copy constructor</p>
</blockquote>

<p>Pass <code>rng</code> by reference:</p>

<pre><code>DSA::PrivateKey create_private_key(AutoSeededRandomPool&amp; rng) {
    ...
}
</code></pre>

<p>Do it in both <code>create_private_key</code> and <code>create_public_key</code>.</p>

<p>The reason is, <code>AutoSeededRandomPool</code> base class is <code>RandomPool</code>, and <code>RandomPool</code> base class is <code>NotCopyable</code>. <code>NotCopyable</code> hides copy and assignment by making them private. I guess that's where the ""implicit"" part comes from the compiler error.</p>

<pre><code>class RandomPool : public RandomNumberGenerator, public NotCopyable
{
    ...
}
</code></pre>

<hr>

<p><strong><em>IF</em></strong> you don't want to pass by reference, then create one locally. There are certain reasons why you <strong><em>want</em></strong> to do this when generating a private key. See <a href=""https://rads.stackoverflow.com/amzn/click/com/0470474246"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Cryptography Engineering: Design Principles and Practical Applications</a> for more details.</p>

<pre><code>DSA::PrivateKey create_private_key() {
  AutoSeededRandomPool rng;
  DSA::PrivateKey private_Key;
  private_Key.GenerateRandomWithKeySize(rng, 1024);
  return private_Key;
}
</code></pre>

<hr>

<p>Related, when you link, place <code>-lcryptopp</code> at the end of the command. Something like:</p>

<pre><code>g++ -o myprog -std=c++11 build/account.o build/some-other-object.o -lcryptopp -pthread
</code></pre>

<p>Order matters because LD is a single pass linker. Libraries always go at the end. You can work around it with options like <code>-(</code> and <code>--start-group</code>, but its easy to remember to place libraries at the end.</p>

<hr>

<p>Some more of the C++11 backstory is, when you experience <code>copy constructor implicitly deleted</code>, you usually define one in your class. See, for example, <a href=""https://stackoverflow.com/q/23951989/608639"">Use of deleted function error</a>.</p>

<p>However, in the case of <code>AutoSeededRandomPool</code>, we don't want them copied for several reasons. The Crypto++ <code>Algorithm</code> class, which is a base class of <code>AutoSeededRandomPool</code>, has a <code>Clone</code>. However, we don't want the generator cloned, either. Again, see <a href=""https://rads.stackoverflow.com/amzn/click/com/0470474246"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Cryptography Engineering: Design Principles and Practical Applications</a>.</p>
","260","<c++11><constructor><crypto++><dsa>","1","0","1","2017-07-25 22:05:54","45312870","2","","608639","","2017-07-25 20:30:45","2017-07-25 01:44:46",""
"47860570","How To Create and Verify Blind RSA Signatures With Crypto++?","<p>I've read through the whitepapers and specifications relating to blind signatures which I've been able to come across, inclusive of the Wikipedia entries, but these tend to focus on the mathematical theory behind it.</p>

<p>Is there a concise practical implementation of RSA blind signatures within c++ using the Crypto++ library?</p>
","<blockquote>
  <p>Is there a concise practical implementation of RSA blind signatures within c++ using the Crypto++ library?</p>
</blockquote>

<p>Yes. The Crypto++ wiki has a section on blind signatures for RSA at <a href=""https://www.cryptopp.com/wiki/Raw_RSA#RSA_Blind_Signature"" rel=""nofollow noreferrer"">Raw RSA | RSA Blind Signature</a>. Below is the code taken from the wiki.</p>

<p>Crypto++ lacks blind signature classes. The method below follows the basic algorithm as detailed at <a href=""https://en.wikipedia.org/wiki/Blind_signature"" rel=""nofollow noreferrer"">Blind Signatures</a>. However, it differs from Wikipedia by applying the <code>s(s'(x)) = x</code> cross-check. The cross-check was present in <a href=""http://www.hit.bme.hu/~buttyan/courses/BMEVIHIM219/2009/Chaum.BlindSigForPayment.1982.PDF"" rel=""nofollow noreferrer"">Chaum's original paper</a>, but it is missing from the wiki article. A second difference from Chaum's paper and wikipedia is, the code below uses <code>H(m)</code> rather than <code>m</code>. That's due to <a href=""http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-212.pdf"" rel=""nofollow noreferrer"">Rabin in 1979</a>.</p>

<p>As far as we know there is no standard covering the signature scheme. The lack of standardization will surely cause interop problems. For example, the code below uses SHA256 to hash the message to be signed, while <a href=""http://github.com/cryptoballot/rsablind"" rel=""nofollow noreferrer"">RSA Blind Signature Scheme for golang</a> uses full domain hashing. Also see <a href=""http://crypto.stackexchange.com/q/54085/10496"">Is there a standard padding/format for RSA Blind Signatures?</a> on Crypto.SE.</p>

<p>You may want to apply a padding function first per <a href=""https://crypto.stackexchange.com/q/12707/10496"">Usability of padding scheme in blinded RSA signature?</a> or <a href=""https://crypto.stackexchange.com/q/5626/10496"">RSA blind signatures in practice</a>.</p>

<hr>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""integer.h""
#include ""nbtheory.h""
#include ""osrng.h""
#include ""rsa.h""
#include ""sha.h""
using namespace CryptoPP;

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using std::cout;
using std::endl;
using std::runtime_error;

int main(int argc, char* argv[])
{
    // Bob artificially small key pair
    AutoSeededRandomPool prng;
    RSA::PrivateKey privKey;

    privKey.GenerateRandomWithKeySize(prng, 64);
    RSA::PublicKey pubKey(privKey);

    // Convenience
    const Integer&amp; n = pubKey.GetModulus();
    const Integer&amp; e = pubKey.GetPublicExponent();
    const Integer&amp; d = privKey.GetPrivateExponent();

    // Print params
    cout &lt;&lt; ""Pub mod: "" &lt;&lt; std::hex &lt;&lt; pubKey.GetModulus() &lt;&lt; endl;
    cout &lt;&lt; ""Pub exp: "" &lt;&lt; std::hex &lt;&lt; e &lt;&lt; endl;
    cout &lt;&lt; ""Priv mod: "" &lt;&lt; std::hex &lt;&lt; privKey.GetModulus() &lt;&lt; endl;
    cout &lt;&lt; ""Priv exp: "" &lt;&lt; std::hex &lt;&lt; d &lt;&lt; endl;

    // For sizing the hashed message buffer. This should be SHA256 size.
    const size_t SIG_SIZE = UnsignedMin(SHA256::BLOCKSIZE, n.ByteCount());

    // Scratch
    SecByteBlock buff1, buff2, buff3;

    // Alice original message to be signed by Bob
    SecByteBlock orig((const byte*)""secret"", 6);
    Integer m(orig.data(), orig.size());
    cout &lt;&lt; ""Message: "" &lt;&lt; std::hex &lt;&lt; m &lt;&lt; endl;

    // Hash message per Rabin (1979)
    buff1.resize(SIG_SIZE);
    SHA256 hash1;
    hash1.CalculateTruncatedDigest(buff1, buff1.size(), orig, orig.size());

    // H(m) as Integer
    Integer hm(buff1.data(), buff1.size());
    cout &lt;&lt; ""H(m): "" &lt;&lt; std::hex &lt;&lt; hm &lt;&lt; endl;

    // Alice blinding
    Integer r;
    do {
        r.Randomize(prng, Integer::One(), n - Integer::One());
    } while (!RelativelyPrime(r, n));

    // Blinding factor
    Integer b = a_exp_b_mod_c(r, e, n);
    cout &lt;&lt; ""Random: "" &lt;&lt; std::hex &lt;&lt; b &lt;&lt; endl;

    // Alice blinded message
    Integer mm = a_times_b_mod_c(hm, b, n);
    cout &lt;&lt; ""Blind msg: "" &lt;&lt; std::hex &lt;&lt; mm &lt;&lt; endl;

    // Bob sign
    Integer ss = privKey.CalculateInverse(prng, mm);
    cout &lt;&lt; ""Blind sign: "" &lt;&lt; ss &lt;&lt; endl;

    // Alice checks s(s'(x)) = x. This is from Chaum's paper
    Integer c = pubKey.ApplyFunction(ss);
    cout &lt;&lt; ""Check sign: "" &lt;&lt; c &lt;&lt; endl;
    if (c != mm)
        throw runtime_error(""Alice cross-check failed"");

    // Alice remove blinding
    Integer s = a_times_b_mod_c(ss, r.InverseMod(n), n);
    cout &lt;&lt; ""Unblind sign: "" &lt;&lt; s &lt;&lt; endl;

    // Eve verifies
    Integer v = pubKey.ApplyFunction(s);    
    cout &lt;&lt; ""Verify: "" &lt;&lt; std::hex &lt;&lt; v &lt;&lt; endl;

    // Convert to a string
    size_t req = v.MinEncodedSize();
    buff2.resize(req);
    v.Encode(&amp;buff2[0], buff2.size());

    // Hash message per Rabin (1979)
    buff3.resize(SIG_SIZE);
    SHA256 hash2;
    hash2.CalculateTruncatedDigest(buff3, buff3.size(), orig, orig.size());

    // Constant time compare
    bool equal = buff2.size() == buff3.size() &amp;&amp; VerifyBufsEqual(
        buff2.data(), buff3.data(), buff3.size());

    if (!equal)
        throw runtime_error(""Eve verified failed"");

    cout &lt;&lt; ""Verified signature"" &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Here is the result of building and running the program:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ blind.cxx ./libcryptopp.a -o blind.exe
$ ./blind.exe
Pub mod: b55dc5e79993680fh
Pub exp: 11h
Priv mod: b55dc5e79993680fh
Priv exp: 1b4fc70ff2e97f1h
Message: 736563726574h
H(m): 2bb80d537b1da3e3h
Random: 72dd6819f0fc5e5fh
Blinded msg: 27a2e2e5e6f4fbfh
Blind sign: 84e7039495bf0570h
Check sign: 27a2e2e5e6f4fbfh
Unblind sign: 61054203e843f380h
Verify: 2bb80d537b1da3e3h
Verified signature
</code></pre>
","259","<rsa><digital-signature><crypto++>","2","2","1","2018-01-26 20:29:27","","0","1","","","","2017-12-17 23:48:37",""
"42176218","type cast CryptoPP::Integer to int","<p>I don't have any experience of Crypto++ library. In my project I need to typecast <code>Integer</code> to <code>int</code>. This is what I am trying:</p>

<pre><code>int low_bound1=8;
int low_bound2=9;
Integer x=1,y=2;
low_bound1=(int)x;
low_bound1=(int)y;
</code></pre>

<p>This is the error I am getting:</p>

<pre><code>error: invalid cast from type 'CryptoPP::Integer' to type 'int'
</code></pre>

<p>Is it possible to do? If yes then how?</p>
","<blockquote>
  <p>Is it possible to do? If yes then how?</p>
</blockquote>

<p>Yes, it <em>may</em> possible to do, but not with a simple C-style cast.</p>

<p>Here is the documentation for the Integer class from the manual: <a href=""http://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow noreferrer"">Integer Class Reference</a>. Under the heading <strong><em>ACCESSORS</em></strong>, there are two methods:</p>

<blockquote>
  <p><code>bool IsConvertableToLong () const</code><br>
  Determines if the Integer is convertable to Long. More...</p>
  
  <p><code>signed long ConvertToLong () const</code><br>
  Convert the Integer to Long. More...</p>
</blockquote>

<p>So you need to do something like:</p>

<pre><code>int low_bound1, low_bound2;
Integer x=1,y=2;

if (x &gt; std::numeric_limits&lt;int&gt;::max() || x &lt; std::numeric_limits&lt;int&gt;::min())
    throw std::out_of_range(""Integer x does not fit int data type"");

if (y &gt; std::numeric_limits&lt;int&gt;::max() || y &lt; std::numeric_limits&lt;int&gt;::min())
    throw std::out_of_range(""Integer y does not fit int data type"");

low_bound1 = static_cast&lt;int&gt;(x.ConvertToLong());
low_bound2 = static_cast&lt;int&gt;(y.ConvertToLong());
</code></pre>
","258","<c++><type-conversion><crypto++>","1","0","1","2017-02-11 15:05:23","","2","","608639","","2017-02-11 14:52:48","2017-02-11 13:07:44",""
"52052787","Why doesn't CMake / include_external_msproject propagate platform argument?","<p>I'm trying to link a Windows application against <a href=""https://github.com/weidai11/Crypto++"" rel=""nofollow noreferrer"">Crypto++</a>. To do this I made the following simple <code>CMakeLists.txt</code>, including the <code>cryptlib.vcxproj</code> project via <a href=""https://cmake.org/cmake/help/v3.8/command/include_external_msproject.html"" rel=""nofollow noreferrer""><code>include_external_msproject</code></a>, specifying Win32 or x64 for <code>PLATFORM</code> depending on build configuration.</p>

<pre><code>cmake_minimum_required( VERSION 3.8)

project(test)

set(CMAKE_CXX_STANDARD 14)

set(SOURCE_FILES main.cpp)

add_executable(${PROJECT_NAME} ${SOURCE_FILES})

if( ${CMAKE_SIZEOF_VOID_P} MATCHES ""8"" )
    set(CRYPTOPP_PLATFORM x64)
    message(STATUS ""Platform: ${CRYPTOPP_PLATFORM}"")
else()
    set(CRYPTOPP_PLATFORM Win32)
endif()

if( ${CMAKE_BUILD_TYPE} MATCHES ""Debug"" )
    set(CRYPTOPP_MODE Debug)
else()
    set(CRYPTOPP_MODE Release)
endif()

include_external_msproject(cryptopp ${CMAKE_CURRENT_LIST_DIR}/cryptopp/cryptlib.vcxproj PLATFORM ${CRYPTOPP_PLATFORM})

add_dependencies(${PROJECT_NAME} cryptopp)
target_link_libraries(${PROJECT_NAME} ${CMAKE_CURRENT_LIST_DIR}/cryptopp/${CRYPTOPP_PLATFORM}/Output/${CRYPTOPP_MODE}/cryptlib.lib)
</code></pre>

<p>To generate the Win32 project I run <code>cmake -G ""Visual Studio 15 2017"" ..</code>, followed by <code>cmake --build . --config Release</code> and all is fine; Crypto++ is built for platform Win32 and the application is linked against it.</p>

<pre><code>cryptlib.vcxproj -&gt; C:\code\Test\cryptopp\Win32\Output\Release\cryptlib.lib
</code></pre>

<p>My problem is that when building for x64, <code>cmake -G ""Visual Studio 15 2017 Win64"" ..</code>, followed by <code>cmake --build . --config Release</code> the Crypto++ project is still built for Win32, naturally resulting in a failed build.</p>

<p>Opening and building the generated x64 project in VS2017 works - Crypto++ is built for x64 with an output file in 
<code>..\cryptopp\x64\Output\Release\cryptlib.lib</code> as expected.</p>

<p>I've tried this with the latest CMake, 3.12.1</p>

<p><strong>Q:</strong> Have I misunderstood how <code>include_external_msproject</code> functions? How do I make the Crypto++ project build for x64 when built outside of Visual Studio?</p>
","<p>This ended up as a <a href=""https://gitlab.kitware.com/cmake/cmake/issues/18308"" rel=""nofollow noreferrer"">bug</a> and is fixed in <a href=""https://gitlab.kitware.com/cmake/cmake/milestones/26"" rel=""nofollow noreferrer"">CMake 3.13.0</a></p>
","254","<cmake><crypto++>","1","0","1","2018-10-13 14:53:16","52794195","1","","608639","","2018-08-28 17:30:53","2018-08-28 07:54:38",""
"34943791","Decrypted image is not same as original image","<p>I just started working on cryptopp library. I have a image buffer and i want to encrypt with some key and then decrypt later but facing issue, decrypted and original images are not same.
I am not sure weather issue in encryption or not could some one help me out of this.</p>

<p>using qt creator</p>

<p>Code:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte ctr[ AES::BLOCKSIZE ];
prng.GenerateBlock( ctr, sizeof(ctr) );

string cipher, encoded, recovered;

QFile file(""original.png"");
if(!file.open(QIODevice::ReadOnly)){
    cout &lt;&lt; ""could not open the file""&lt;&lt; endl;
}

QByteArray buffer = file.readAll();

qDebug()&lt;&lt;""buffer length""&lt;&lt;buffer.length();

file.close();

try
{
    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );

    StringSource ss1( buffer, true,
                      new StreamTransformationFilter( e,
                                                      new StringSink( cipher )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""cipher length ""&lt;&lt;cipher.length();

try
{
    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );
    StringSource ss3( cipher, true,
                      new StreamTransformationFilter( d,
                                                      new StringSink( recovered )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""recovered length ""&lt;&lt;recovered.length();
QFile ouput(""recovered.png"");
if(ouput.open(QIODevice::WriteOnly)){
    ouput.write(recovered.data(), recovered.size());
    ouput.close();
}
</code></pre>

<p>response:</p>

<pre><code>buffer length 538770
cipher length  8
recovered length  8
</code></pre>

<p>why my cipher length is 8 only.</p>
","<p>In your code you are converting the file content to Base64,
encrypting it, decrypting it and saving it to a file (thus saving a the png file as Base64)</p>

<p>You should encrypt the raw file data (and not the Base64 encoded one).</p>

<p><strong>Edit:</strong> After your edit I don't know what fails. Please try the following function, which works for me. Uses <code>FileSource</code> and <code>FileSink</code>, but should work with StringSource and StringSink accordingly.</p>

<pre><code>bool encryptdecrypt(const std::string&amp; filename)
{
    std::string key = ""7D9BB722DA2DC8674E08C3D44AAE976F"";
    byte ctr[ CryptoPP::AES::BLOCKSIZE ];
    std::string cipher;

    try
    {
        CryptoPP::CTR_Mode&lt; CryptoPP::AES &gt;::Encryption e;
        e.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );

        CryptoPP::FileSource( filename.c_str(), true,
            new CryptoPP::StreamTransformationFilter( e,
                new CryptoPP::StringSink( cipher )
            )
        );

    }
    catch( CryptoPP::Exception&amp; e )
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return false;
    }

    try
    {
        CryptoPP::CTR_Mode&lt; CryptoPP::AES &gt;::Decryption d;
        d.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );
        CryptoPP::StringSource( cipher, true,
            new CryptoPP::StreamTransformationFilter( d,
                new CryptoPP::FileSink( ( ""decrypted_"" + filename ).c_str() )
            )
        );

    }
    catch( CryptoPP::Exception&amp; e )
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return false;
    }
    return true;
}
</code></pre>
","249","<c++><qt><crypto++>","1","1","3","2016-01-25 14:32:13","34990118","1","","1868951","","2016-01-25 07:16:44","2016-01-22 09:58:01",""
"34943791","Decrypted image is not same as original image","<p>I just started working on cryptopp library. I have a image buffer and i want to encrypt with some key and then decrypt later but facing issue, decrypted and original images are not same.
I am not sure weather issue in encryption or not could some one help me out of this.</p>

<p>using qt creator</p>

<p>Code:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte ctr[ AES::BLOCKSIZE ];
prng.GenerateBlock( ctr, sizeof(ctr) );

string cipher, encoded, recovered;

QFile file(""original.png"");
if(!file.open(QIODevice::ReadOnly)){
    cout &lt;&lt; ""could not open the file""&lt;&lt; endl;
}

QByteArray buffer = file.readAll();

qDebug()&lt;&lt;""buffer length""&lt;&lt;buffer.length();

file.close();

try
{
    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );

    StringSource ss1( buffer, true,
                      new StreamTransformationFilter( e,
                                                      new StringSink( cipher )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""cipher length ""&lt;&lt;cipher.length();

try
{
    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );
    StringSource ss3( cipher, true,
                      new StreamTransformationFilter( d,
                                                      new StringSink( recovered )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""recovered length ""&lt;&lt;recovered.length();
QFile ouput(""recovered.png"");
if(ouput.open(QIODevice::WriteOnly)){
    ouput.write(recovered.data(), recovered.size());
    ouput.close();
}
</code></pre>

<p>response:</p>

<pre><code>buffer length 538770
cipher length  8
recovered length  8
</code></pre>

<p>why my cipher length is 8 only.</p>
","<blockquote>
<pre><code>QFile ouput(""recovered.png"");
if(ouput.open(QIODevice::WriteOnly)){
    ouput.write(recovered.c_str());
    ouput.close();
}
</code></pre>
</blockquote>

<p>Let me throw mine in the pot.... You are treating binary data as a C-String, which means reading/writing stops at the first NULL character. You should use an overload that takes a pointer and size. Maybe something like:</p>

<pre><code>ouput.write(recovered.data(), recovered.size());
</code></pre>

<hr>

<p><strong><em>(After code edits)</em></strong></p>

<pre><code>QByteArray buffer = file.readAll();
...
StringSource ss1( buffer, true, ...);
</code></pre>

<p>That's probably not producing expected results. Maybe you should try:</p>

<pre><code>QByteArray buffer = file.readAll();
...
StringSource ss1( buffer.data(), buffer.size(), true, ...);
</code></pre>

<p>The above <strong><em><code>StringSource</code></em></strong> overload, with a <strong><em>pointer</em></strong> and <strong><em>size</em></strong>, is the one you should prefer in this case. Its the exact case it was designed for, and it saves the extra copy of <strong><em><code>buffer</code></em></strong>.</p>

<p>You could even use a <strong><em><code>FileSource</code></em></strong> and <strong><em>FileSink`</em></strong> to integrate with Crypto++::</p>

<pre><code>FileSource ifile(""original.png"", true,
                     new StreamTransformationFilter(e,
                         new StringSink( cipher )
                     )
                 );
</code></pre>

<hr>

<p>Also, Barmak is correct about:</p>

<blockquote>
  <p>In your case you call it ctr but it seems to be uninitialized...</p>
</blockquote>

<p>Though it is uninitialized, the same [unknown] value is used for encryption and decryption, so the problem did not show its head. It will show up later, like when you encrypt on one machine and decrypt on another.</p>

<p>You should follow Barmak advice an initialize it. Maybe something like:</p>

<pre><code>byte ctr[16];
OS_GenerateRandomBlock(false, ctr, sizeof(ctr));
</code></pre>

<p><a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator#OS_GenerateRandomBlock"" rel=""nofollow"">OS_GenerateRandomBlock</a> is discussed on Crypto++ wiki at <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">RandomNumberGenerator</a>.</p>

<hr>

<p>You can usually send the counter in the plaintext with the message because its usually considered a public value. But it really depends on your security model.</p>

<p>Be sure to <strong><em>never</em></strong> reuse a security context in counter mode. Each message must be encrypted under a unique security context. The security context is the <strong><em><code>{key,ctr}</code></em></strong> pair.</p>

<hr>

<p>You can also print the counter with:</p>

<pre><code>byte ctr[16];
OS_GenerateRandomBlock(false, ctr, sizeof(ctr));

HexEncoder encoder(new FileSink(cout));

cout &lt;&lt; ""Counter: "";
encoder.Put(ctr, sizeof(ctr));
encoder.MessageEnd();
cout &lt;&lt; endl;
</code></pre>

<p>The code above simply hex-encodes the raw byte array nd then prints it to <strong><em><code>stdout</code></em></strong>.</p>

<hr>

<blockquote>
  <p>(comment) <code>string key = ""7D9BB722DA2DC8674E08C3D44AAE976F"";</code> - You probably want a binary string; not an ASCII string. For Crypto++, see HexDecoder on the Crypto++ wiki. I'm not sure what QT offers for the service. </p>
</blockquote>

<p>Since there's more space here... this is one of the things you could do:</p>

<pre><code>string key, encodedKey = ""7D9BB722DA2DC8674E08C3D44AAE976F"";
StringSource ss(encodedKey, true, new HexDecoder(key));
</code></pre>

<p>After the statements execute, the string <strong><em><code>key</code></em></strong> will be binary data.</p>
","249","<c++><qt><crypto++>","1","2","3","2016-01-25 14:32:13","34990118","1","","1868951","","2016-01-25 07:16:44","2016-01-22 09:58:01",""
"34943791","Decrypted image is not same as original image","<p>I just started working on cryptopp library. I have a image buffer and i want to encrypt with some key and then decrypt later but facing issue, decrypted and original images are not same.
I am not sure weather issue in encryption or not could some one help me out of this.</p>

<p>using qt creator</p>

<p>Code:</p>

<pre><code>AutoSeededRandomPool prng;

SecByteBlock key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );

byte ctr[ AES::BLOCKSIZE ];
prng.GenerateBlock( ctr, sizeof(ctr) );

string cipher, encoded, recovered;

QFile file(""original.png"");
if(!file.open(QIODevice::ReadOnly)){
    cout &lt;&lt; ""could not open the file""&lt;&lt; endl;
}

QByteArray buffer = file.readAll();

qDebug()&lt;&lt;""buffer length""&lt;&lt;buffer.length();

file.close();

try
{
    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );

    StringSource ss1( buffer, true,
                      new StreamTransformationFilter( e,
                                                      new StringSink( cipher )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""cipher length ""&lt;&lt;cipher.length();

try
{
    CTR_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV( (byte*)key.data(), key.size(), ctr );
    StringSource ss3( cipher, true,
                      new StreamTransformationFilter( d,
                                                      new StringSink( recovered )
                                                      )
                      );

}
catch( CryptoPP::Exception&amp; e )
{
    cerr &lt;&lt; e.what() &lt;&lt; endl;
    exit(1);
}

qDebug()&lt;&lt;""recovered length ""&lt;&lt;recovered.length();
QFile ouput(""recovered.png"");
if(ouput.open(QIODevice::WriteOnly)){
    ouput.write(recovered.data(), recovered.size());
    ouput.close();
}
</code></pre>

<p>response:</p>

<pre><code>buffer length 538770
cipher length  8
recovered length  8
</code></pre>

<p>why my cipher length is 8 only.</p>
","<p>I found the issue with QByteArray buffer. i just converted to std::string its working.</p>

<pre><code>QByteArray buffer = file.readAll();

// string
std::string stdString(buffer.data(), buffer.length());

//used stdString instead of buffer in pipeline
StringSource ss1(stdString, true,
                              new StreamTransformationFilter( e,
                                                              new StringSink( cipher )
                                                              )
                              );
</code></pre>
","249","<c++><qt><crypto++>","1","1","3","2016-01-25 14:32:13","34990118","1","","1868951","","2016-01-25 07:16:44","2016-01-22 09:58:01",""
"25764170","Using typedef ClassName< > after class","<p>I'm new in C++ world and I don't understand what's going on when using this structure :</p>

<pre><code>template &lt;typename T&gt;
   class NameClass{
.........

};
typedef NameClass&lt;CryptoPP::AES&gt; CryptAES;
//!Typedef for the AES Encryption\Decryption
typedef NameClass&lt;CryptoPP::Blowfish&gt; CryptBlowFish;
//!Typedef for BlowFish Encryption\Decryption
</code></pre>

<p>Is there an explanation? </p>
","<p>There is very likely also </p>

<p><code>template&lt; classT &gt;</code> or <code>template &lt;typename T&gt;</code> above <code>class NameClass</code> and this means NameClass is a template, parametrised by the type of encryption it uses, by <code>T</code>.</p>

<p>read about templates <a href=""http://en.wikipedia.org/wiki/Template_(C%2B%2B)"" rel=""nofollow"">here</a>.</p>

<p>typedef is a keyword in C++. It's purpose is to abbreviate complexed names. In your example</p>

<pre><code>NameClass&lt;CryptoPP::Blowfish&gt;
</code></pre>

<p>can be used by a shorthand of <code>CryptBlowFish</code></p>

<p>because it was typedefed as </p>

<pre><code>typedef NameClass&lt;CryptoPP::Blowfish&gt; CryptBlowFish;
</code></pre>

<p>before. So</p>

<pre><code>CryptBlowFish cbf;
</code></pre>

<p>is same as </p>

<pre><code>NameClass&lt;CryptoPP::Blowfish&gt; cbf;
</code></pre>

<p><a href=""http://en.wikipedia.org/wiki/Typedef"" rel=""nofollow"">http://en.wikipedia.org/wiki/Typedef</a></p>
","248","<c++><visual-c++><c++11><crypto++>","2","3","2","2014-09-10 11:40:54","25764240","4","","3531447","","2014-09-10 11:40:54","2014-09-10 11:25:17","2014-09-10 19:46:05"
"25764170","Using typedef ClassName< > after class","<p>I'm new in C++ world and I don't understand what's going on when using this structure :</p>

<pre><code>template &lt;typename T&gt;
   class NameClass{
.........

};
typedef NameClass&lt;CryptoPP::AES&gt; CryptAES;
//!Typedef for the AES Encryption\Decryption
typedef NameClass&lt;CryptoPP::Blowfish&gt; CryptBlowFish;
//!Typedef for BlowFish Encryption\Decryption
</code></pre>

<p>Is there an explanation? </p>
","<p>This means that <code>NameClass</code> is a <em>templatised class</em>, i.e. one which is polymorphic in its behaviour dependent on the template argument.</p>

<pre><code>typedef NameClass&lt;CryptoPP::AES&gt; CryptAES;
</code></pre>

<p>In English, the above says ""From now on in this scope, CryptAES is another name for NameClass when instantiated with CryptoPP::AES as its template argument"".</p>
","248","<c++><visual-c++><c++11><crypto++>","2","2","2","2014-09-10 11:40:54","25764240","4","","3531447","","2014-09-10 11:40:54","2014-09-10 11:25:17","2014-09-10 19:46:05"
"34251148","How to use Crypto++'s Secret Sharing class to share memory blob","<p>I am building the protocol to share a random generated <em>n</em> long password between <em>k</em> parties using crypto++ shamir's secret sharing class. The problem is that all examples that I found on the internet about the cryptopp's sss are based on the file sharing but I am not using files to store these passwords. They are rather kept in memory and later send over network.</p>

<p>I found this question on the <a href=""https://groups.google.com/forum/#!topic/cryptopp-users/XEKKLCEFH3Y/"" rel=""nofollow"">crypto++ forum</a> but I was stuck on the same problem as the related question. I cannot figure it out how to overcome the issue with wrongly recovered ls-byte.</p>

<p>Can you please give me some suggestions how to make this work. Thank you</p>
","","245","<c++><password-encryption><crypto++><password-recovery><shared-secret>","2","","0","2015-12-13 23:13:06","","0","0","5663421","","2015-12-13 13:07:14","2015-12-13 12:37:23",""
"51286467","AES implementation using Crypto++","<p>I want to implement AES encryption/decryption in visual studio (C++). I have gone through <a href=""http://programmingknowledgeblog.blogspot.com/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow noreferrer"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment + Running Sample program</a>.</p>

<p>I have followed all the steps mentioned there and try to build the application but i got the LINKER ERRORS while compiling, below link is the reference for ERRORS I'm facing in the application. </p>

<pre><code>https://www.dropbox.com/sh/32ajyx0vc6391q0/AACRYndRpbKynntADFgZUdXYa?dl=0
</code></pre>

<p>Can any one please let me know the solution for this error?</p>

<p>Thanks </p>
","<p>I would advise you to drop cryptopp and use Windows built-in cryptography instead. This way, the major part of the code i.e. the algorithms will be supported by MS, and updated as a part of Windows update.</p>

<p>As a nice side effects it will build faster, the binary will be much smaller, and the required library, Advapi32.lib, is part of Windows SDK i.e. you’ll unlikely have linker issues.</p>

<p><a href=""https://stackoverflow.com/a/29637007/126995"">See this answer</a> for an example how to derive AES key from password. However the code there is less than ideal, instead I usually create simple RAII wrappers like this:</p>

<pre><code>class Context
{
    HCRYPTPROV hProv = 0;
public:
    Context() : hProv( 0 ) {}
    ~Context()
    {
        if( 0 != hProv )
            CryptReleaseContext( hProv, 0 );
    }
    operator HCRYPTPROV () const
    {
        return hProv;
    }
    HRESULT open()
    {
        if( !CryptAcquireContext( &amp;hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) )
            return GetLastHr();
        return S_OK;
    }
};
</code></pre>

<p>And do the same for other HCRYPT* handles I need.</p>

<p>Then see <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptencrypt"" rel=""nofollow noreferrer"">MSDN example code</a> on how to encrypt data with that AES key.</p>
","245","<c++><visual-studio-2010><encryption><aes><crypto++>","0","0","2","2018-07-13 06:15:36","","6","","608639","","2018-07-12 14:35:28","2018-07-11 13:16:30",""
"51286467","AES implementation using Crypto++","<p>I want to implement AES encryption/decryption in visual studio (C++). I have gone through <a href=""http://programmingknowledgeblog.blogspot.com/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow noreferrer"">Compiling and Integrating Crypto++ into the Microsoft Visual C++ Environment + Running Sample program</a>.</p>

<p>I have followed all the steps mentioned there and try to build the application but i got the LINKER ERRORS while compiling, below link is the reference for ERRORS I'm facing in the application. </p>

<pre><code>https://www.dropbox.com/sh/32ajyx0vc6391q0/AACRYndRpbKynntADFgZUdXYa?dl=0
</code></pre>

<p>Can any one please let me know the solution for this error?</p>

<p>Thanks </p>
","<p>I solved this LINKING Errors by changing the CryptoPP version.</p>

<p>Previously I used CryptoPP version (7.0.0) in my visual studio 2010, now i have tried with CryptoPP version (5.6.2).</p>

<p>Now i can able to compile without any errors.</p>

<p>Thanks for your suggestions.</p>
","245","<c++><visual-studio-2010><encryption><aes><crypto++>","0","1","2","2018-07-13 06:15:36","","6","","608639","","2018-07-12 14:35:28","2018-07-11 13:16:30",""
"40557811","Convert byte* {aka unsigned char*}’ to ‘byte [32] {aka unsigned char [32]}","<p>I am using <a href=""https://www.cryptopp.com/wiki/Salsa20"" rel=""nofollow noreferrer"">Crypto++ Salsa20</a> as a part of my project. The above link has an example code in which they define </p>

<pre><code>byte key[32];
</code></pre>

<p>So I have a string of 64 bytes. I got this value from SHA256. Basically they are hexal values. So I believe this can be stored in key.</p>

<pre><code>string hashVal = ""b684f0912266e387eded257b8107b6fc65f0ed97773ecb09078c9a8004d08563"";
</code></pre>

<p>I need to store this value into key[32]. I tried my best to convert the string into key but never got through. </p>

<pre><code>byte *plaintextBytes = (byte *) hashVal.c_str();
OR
byte *plaintextBytes = new byte[hashVal.length()];
key = passphraseBytes;
</code></pre>

<p>Can anyone please help me address this issue. </p>
","<p>Use memcpy:</p>

<pre><code>std::memcpy(key, &amp;hashVal[0], std::min(32, hashVal.size());
</code></pre>

<p>This is assuming you don't need a null terminator.</p>
","244","<c++><c++11><crypto++>","-1","0","1","2016-11-12 04:23:29","","5","","608639","","2016-11-12 04:23:29","2016-11-11 23:29:36",""
"38431256","AES not work properly in StringSource and StringSink functions in Qt","<p>I have using of <strong>Crypto++</strong> library in <strong>Qt</strong> due to encrypt a string with <code>AES</code> method in <code>CBC</code> mode and using of <code>StringSource</code> and <code>StringSink</code> to  define <code>input</code> and <code>output</code> string parameters.</p>

<p>First, i read all bytes from a file (""unicode"" or ""ASCII"" encoding), then set it as the <code>input</code> parameter in <code>StringSource</code> function, then set a parameter as <code>string</code>(data-type) for output (cipher-text). just i want to get a string and encrypt it with ""aes-cbc"" and showing output.</p>

<p>Also, i know <code>FileSource</code> and <code>FileSink</code> are two functions(consist <code>input</code> and <code>output</code> stream parameters) for writing data to files! but i want to read file content as input-string.</p>

<p><strong>My Code :</strong></p>

<pre><code>void Widget::onEncryptButton()
{
    QByteArray key = ""qwertyuiopasdfgh"";
    QByteArray iv = ""wertyuiopasdfghj""
    QByteArray plain;
    string cipher;

    QFile fi(""/home/msi/Desktop/input.txt"");
    QFile fo(""/home/msi/Desktop/output.enc"");

    fi.open(QFile::ReadOnly);
    fo.open(QFile::WriteOnly);
    plain = fi.readAll();

    AESEncryption aese((byte*)key.constData(), AES::DEFAULT_KEYLENGTH);    // default is 16
    CBC_Mode_ExternalCipher::Encryption encryptor(aese, (byte*)iv.constData());
    StringSource(plain, true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));

    QMessageBox::information(this, """", QString(""%1, %2"").arg(strlen(cipher.c_str())).arg(cipher.size()));    // just for viewing cipher length

    fo.write(cipher.c_str());
    fi.close();
    fo.close();
}
</code></pre>

<p>Now i have bellow problems :</p>

<ul>
<li><p>When i read a compact file content(e.g. 900 byte) and set it as input in <code>StringSource</code>, generated cipher will be incomplete (e.g. 320 byte)</p></li>
<li><p>Output of <code>strlen(cipher.c_str())</code> is different by <code>cipher.size()</code> in ""QMessageBox""</p></li>
<li><p>My code working truly When i read some files(""unicode"" or ""ASCII"", ""larg"" or ""little"" size) and sometimes working incorrectly. i dont understand which of the reason caused this problem?</p></li>
<li>Even, i set some input-string directly (not reading from file) and fails again!</li>
</ul>

<p>Regards!</p>
","<p>I could be your <code>plain</code>, if it contains '\0'. Try to pass both, the data and the length:</p>

<pre><code>StringSource((byte*)plain.constData(), plain.size(), true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));
</code></pre>
","242","<c++><qt><aes><crypto++><cbc-mode>","2","1","3","2016-07-18 22:10:57","38432281","1","1","","","","2016-07-18 07:50:58",""
"38431256","AES not work properly in StringSource and StringSink functions in Qt","<p>I have using of <strong>Crypto++</strong> library in <strong>Qt</strong> due to encrypt a string with <code>AES</code> method in <code>CBC</code> mode and using of <code>StringSource</code> and <code>StringSink</code> to  define <code>input</code> and <code>output</code> string parameters.</p>

<p>First, i read all bytes from a file (""unicode"" or ""ASCII"" encoding), then set it as the <code>input</code> parameter in <code>StringSource</code> function, then set a parameter as <code>string</code>(data-type) for output (cipher-text). just i want to get a string and encrypt it with ""aes-cbc"" and showing output.</p>

<p>Also, i know <code>FileSource</code> and <code>FileSink</code> are two functions(consist <code>input</code> and <code>output</code> stream parameters) for writing data to files! but i want to read file content as input-string.</p>

<p><strong>My Code :</strong></p>

<pre><code>void Widget::onEncryptButton()
{
    QByteArray key = ""qwertyuiopasdfgh"";
    QByteArray iv = ""wertyuiopasdfghj""
    QByteArray plain;
    string cipher;

    QFile fi(""/home/msi/Desktop/input.txt"");
    QFile fo(""/home/msi/Desktop/output.enc"");

    fi.open(QFile::ReadOnly);
    fo.open(QFile::WriteOnly);
    plain = fi.readAll();

    AESEncryption aese((byte*)key.constData(), AES::DEFAULT_KEYLENGTH);    // default is 16
    CBC_Mode_ExternalCipher::Encryption encryptor(aese, (byte*)iv.constData());
    StringSource(plain, true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));

    QMessageBox::information(this, """", QString(""%1, %2"").arg(strlen(cipher.c_str())).arg(cipher.size()));    // just for viewing cipher length

    fo.write(cipher.c_str());
    fi.close();
    fo.close();
}
</code></pre>

<p>Now i have bellow problems :</p>

<ul>
<li><p>When i read a compact file content(e.g. 900 byte) and set it as input in <code>StringSource</code>, generated cipher will be incomplete (e.g. 320 byte)</p></li>
<li><p>Output of <code>strlen(cipher.c_str())</code> is different by <code>cipher.size()</code> in ""QMessageBox""</p></li>
<li><p>My code working truly When i read some files(""unicode"" or ""ASCII"", ""larg"" or ""little"" size) and sometimes working incorrectly. i dont understand which of the reason caused this problem?</p></li>
<li>Even, i set some input-string directly (not reading from file) and fails again!</li>
</ul>

<p>Regards!</p>
","<p>I replace bellow statement: </p>

<pre><code>StringSource((byte*)plain.constData(), plain.size(), true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));
</code></pre>

<p>With the bellow :</p>

<pre><code>StringSource(plain, true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));
</code></pre>

<p>Then, i rebuild program again, but problem was still!</p>

<p>I <strike>temporarily</strike> remove all '\' characters from the plaintext and compile again, after that, the output cipher showed truly in ""QMessageBox"" with <code>cipher.size()</code> statement.</p>

<p>then replace </p>

<pre><code>fo.write(cipher.c_str(), cipher.size());
</code></pre>

<p>with : </p>

<pre><code>fo.write(cipher.c_str());
</code></pre>

<p>I do These instructions for encryption and decryption sections.</p>
","242","<c++><qt><aes><crypto++><cbc-mode>","2","0","3","2016-07-18 22:10:57","38432281","1","1","","","","2016-07-18 07:50:58",""
"38431256","AES not work properly in StringSource and StringSink functions in Qt","<p>I have using of <strong>Crypto++</strong> library in <strong>Qt</strong> due to encrypt a string with <code>AES</code> method in <code>CBC</code> mode and using of <code>StringSource</code> and <code>StringSink</code> to  define <code>input</code> and <code>output</code> string parameters.</p>

<p>First, i read all bytes from a file (""unicode"" or ""ASCII"" encoding), then set it as the <code>input</code> parameter in <code>StringSource</code> function, then set a parameter as <code>string</code>(data-type) for output (cipher-text). just i want to get a string and encrypt it with ""aes-cbc"" and showing output.</p>

<p>Also, i know <code>FileSource</code> and <code>FileSink</code> are two functions(consist <code>input</code> and <code>output</code> stream parameters) for writing data to files! but i want to read file content as input-string.</p>

<p><strong>My Code :</strong></p>

<pre><code>void Widget::onEncryptButton()
{
    QByteArray key = ""qwertyuiopasdfgh"";
    QByteArray iv = ""wertyuiopasdfghj""
    QByteArray plain;
    string cipher;

    QFile fi(""/home/msi/Desktop/input.txt"");
    QFile fo(""/home/msi/Desktop/output.enc"");

    fi.open(QFile::ReadOnly);
    fo.open(QFile::WriteOnly);
    plain = fi.readAll();

    AESEncryption aese((byte*)key.constData(), AES::DEFAULT_KEYLENGTH);    // default is 16
    CBC_Mode_ExternalCipher::Encryption encryptor(aese, (byte*)iv.constData());
    StringSource(plain, true, new StreamTransformationFilter(encryptor, new StringSink(cipher)));

    QMessageBox::information(this, """", QString(""%1, %2"").arg(strlen(cipher.c_str())).arg(cipher.size()));    // just for viewing cipher length

    fo.write(cipher.c_str());
    fi.close();
    fo.close();
}
</code></pre>

<p>Now i have bellow problems :</p>

<ul>
<li><p>When i read a compact file content(e.g. 900 byte) and set it as input in <code>StringSource</code>, generated cipher will be incomplete (e.g. 320 byte)</p></li>
<li><p>Output of <code>strlen(cipher.c_str())</code> is different by <code>cipher.size()</code> in ""QMessageBox""</p></li>
<li><p>My code working truly When i read some files(""unicode"" or ""ASCII"", ""larg"" or ""little"" size) and sometimes working incorrectly. i dont understand which of the reason caused this problem?</p></li>
<li>Even, i set some input-string directly (not reading from file) and fails again!</li>
</ul>

<p>Regards!</p>
","<p>I would consider reworking the function:</p>

<pre><code>// Improve this in real life
QByteArray key = ""qwertyuiopasdfgh"";
QByteArray iv = ""wertyuiopasdfghj""

std::string infile(""/home/msi/Desktop/input.txt"");
std::string outfile(""/home/msi/Desktop/output.enc"");

CBC_Mode&lt;AES&gt;::Encryption encryptor(key.constData(), key.size(), iv.constData());
FileSource fs(infile.c_str(), true, new StreamTransformationFilter(encryptor, new FileSink(outfile.c_str())));
</code></pre>

<p>Using the <a href=""http://cryptopp.com/wiki/FileSource"" rel=""nofollow""><code>FileSource</code></a> and <a href=""http://cryptopp.com/wiki/FileSink"" rel=""nofollow""><code>FileSink</code></a> avoids the problems with trying to interpret the data under a character set. It also saves on the extra copies, and its friendlier with Mobile devices and IoT gadgets which don't have a lot of RAM.</p>

<p>You might also consider using an <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow"">Authenticated Encryption mode</a> to ensure both confidentiality and authenticity.</p>
","242","<c++><qt><aes><crypto++><cbc-mode>","2","1","3","2016-07-18 22:10:57","38432281","1","1","","","","2016-07-18 07:50:58",""
"38345805","Garbage from decrypted base64 string","<p>A Qt client generates a RSA key pair, then sends a json string to a Nodejs server, containing a RSA public key and a text to encrypt.
The NodeJs server is sending back a base64 string containing the text encrypted (using node-rsa) with the RSA public key provided by the client.</p>

<p>My decrypt function on the client side is this:</p>

<pre><code>QString Crypto::decrypt(QString b64msg)
{
    //decode the base64 string
    std::string decoded;
    CryptoPP::StringSource ss(b64msg.toStdString(), true,
                           new CryptoPP::Base64Decoder(
                               new CryptoPP::StringSink(decoded)));

    //create a CryptoPP::Integer out of the decoded string
    CryptoPP::Integer encrypted((const byte *)decoded.data(), decoded.size());

    //decrypt using the private key
    CryptoPP::Integer r = privKey.CalculateInverse(rng, encrypted);
    size_t req = r.MinEncodedSize();
    std::string recovered;
    recovered.resize(req);
    r.Encode((byte *)recovered.data(), recovered.size());
    std::cout &lt;&lt; ""Recovered: "" &lt;&lt; recovered &lt;&lt; std::endl;

    return QString::fromStdString(recovered);
}
</code></pre>

<p>I just get garbage out of the decrypt function. I think I'm doing everything fine, what am I missing?</p>

<p>EDIT
here's a more detailed iteration:</p>

<p>the client generated the following keypair:</p>

<pre><code>-----BEGIN RSA PRIVATE KEY-----
MIICWgIBAAKBgQDCe3LEnSuvjc9sERk5JJTnThaBnTPbQSiSr6fi2pOyREKkOyAG
R1DdW1ND96reWkDIrnKE7jw7sTXs/BTKALlXpFdF1V7FRfiHlB3gRsJYpRzo3Odo
XgS/KG/7W9N9H13t+vmi7HSC2EMiqFrpuSJjJm52MjBW8+wmDMDMmpb0bQIBEQKB
gCJSBTHBYg/r2U9OT77KOGUNx7yFJ0TPQ2UuDpFx3dQqKeC/I8TfaJ+IljkrtL3T
sRRbBSaEZPt5oBrDEro8XPEKdV+a4s6EhNgvLWozFsfbOcXhVLJhWbodnnPsJ7P+
pbXHRySTSXBHkRPjnyoJMlEssaCMopiXztJt7A+9YzYFAkEA5PDjgisaRl3St4dM
VBtH987WCu0G5BprfBlcdCt0Cpyg1x/al42/dZIRnJUcXdofW+yfp5+VvIxcOUS1
e5deIwJBANl37zrZGLtUlnvqj3vQpChcBtUabqeYilnUuK1xt8cWRw/xTmeb8c0l
oFc/3ycrInfonhhMtdshIWSXve3NZC8CQQDXeU6YoQmro5klNAuadAd/0bpkotlP
J+yxCM98ZSHr3rV/LQn4DPBup5ga5rFJRcMpVyzZ/5v8wFbMfOcK6NERAkAmYHWC
2wRdSymdZaDZnUolPWqeE7ksonLEjvNp5uQyMRuZZtGZ0Dm6ymeW7SdhQ9jn+9+p
72ti57qZR/RXJD7bAkAyhbtM8rdRcJ1aXRD08Nq1HI1XM3HcblVDssABQMm3BkyP
prD+pxiGBrw59vZ6OeKo+4J6oAZXRazbnv38aBZO
-----END RSA PRIVATE KEY-----

-----BEGIN PUBLIC KEY-----
MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQDCe3LEnSuvjc9sERk5JJTnThaB
nTPbQSiSr6fi2pOyREKkOyAGR1DdW1ND96reWkDIrnKE7jw7sTXs/BTKALlXpFdF
1V7FRfiHlB3gRsJYpRzo3OdoXgS/KG/7W9N9H13t+vmi7HSC2EMiqFrpuSJjJm52
MjBW8+wmDMDMmpb0bQIBEQ==
-----END PUBLIC KEY-----
</code></pre>

<p>Then the client sends a json request to the NodeJs server. The request is in the form</p>

<pre><code>{""command"": ""encrypt"",""phrase"":""TestString"",""pubkey"":&lt;PEM public key&gt;}
</code></pre>

<p>This is the code snippet on the NodeJs side:</p>

<pre><code>[...]
var WebSocketServer = require('ws').Server;
var NodeRSA = require('node-rsa');
[...]
var TCP_PORT = 8081;
var wss = new WebSocketServer({port: TCP_PORT});

wss.on('connection', function connection(socket) {
    socket.on('message', function (data) {
        var request;
        try {
            request = JSON.parse(data);
            console.log(""Request:"");
            console.log(data);
        } catch (e) {
            console.log(""Error parsing message: "" + e);
            socket.send(""json or gtfo"");
            return;
        }
        switch (request.command) {
            case ""encrypt"":
                console.log(""phrase: "" + request.phrase);
                console.log(""pubkey: "" + request.pubkey);
                var keypu = new NodeRSA(request.pubkey);
                var resultB64 = keypu.encrypt(request.phrase, ""base64"", 'utf8');
                socket.send(resultB64);
                [...]
</code></pre>

<p>The ""resultB64"" in this iteration is</p>

<pre><code>wBuWpfelCB9yIOUQ6ZMPMCPJvn+NYfgjywh4Ye7ybYvNqJdf05yqgrqudkwAJT9+VaIIS/KE/38WvGxiTTY5qZm+rlRrY5OBDZzKRRH4iEKp1NFRJXhh9ZtHPRM/2JfVMUYSFdIgyP3CojIUz2dyLfZu7XLn3RYXI29EJEyHxKM=
</code></pre>

<p>As a matter of fact, if I pass the private key too and try to decrypt on the server side, the decryption is successful, so I assume the Nodejs side it fine.</p>

<p>@Kombinator: i noted that on the client side I obtain the exact same (garbage)  result if I substitute this:</p>

<pre><code>std::string decoded;
CryptoPP::StringSource ss(b64msg.toStdString(), true,
                       new CryptoPP::Base64Decoder(
                           new CryptoPP::StringSink(decoded)));
</code></pre>

<p>with its QByteArray equivalent:</p>

<pre><code>std::string decoded;
QByteArray fromB64 = QByteArray::fromBase64(b64msg.toLatin1());
decoded = fromB64.toStdString();
</code></pre>
","<p>You have to use unit test for this problem. First brake down the complex  method with inline by value calls. 
Use std:string only with test values.  On the other side you shoud use QByteArray for base64 stuff. </p>
","242","<node.js><qt><rsa><crypto++>","0","0","1","2016-07-18 22:24:56","","4","","608639","","2016-07-18 22:24:56","2016-07-13 07:59:10",""
"24297359","Crypto++ library gzip issue","<p>I am having an issue with the GZIP class of the Crypto++ library. I am working on a server client app. The client app is written in C++. I encrypt data using the GZIP class as follows: </p>

<pre><code>#include &lt;gzip.h&gt;

Gzip zipper(1);    // 1 is fast, 9 is slow

zipper.Put(pData,dwLen);
zipper.Close();

byte* pCompressed = new byte[zipper.MaxRetrieveable()];
zipper.Get(pCompressed,zipper.MaxRetrieveable());
</code></pre>

<p>The data is hex encoded and then transferred to the PYTHON utilize which decodes and attempts to decompress these GZIP streams as follows: </p>

<pre><code>import gzip
import StringIO
fio = StringIO.StringIO(gzip_data)
f = gzip.GzipFile(fileobj=fio)
f.read()
'test'
f.close()
</code></pre>

<p>And I have also tried the following as: </p>

<pre><code>fh = gzip.open('abc.gz', 'rb')
cdata = fh.read()
fh.close()
</code></pre>

<p>This seems simple enough, but it is not working correctly and gives me errors during the decompression process on the PYTHON end. Is there a separate way to decompress streams vs actual files utilizing the PYTHON module class? </p>

<p>If anyone else has had this issue, any assistance would be greatly appreciated.</p>

<p><strong><em>UPDATE</em></strong></p>

<p>Thank you for your reply jww. Just FYI, I got this to work today by decompressing the received stream, from the C++ software utilizing the CryptoPP library, as follows within the PYTHON client: </p>

<pre><code>compressedstream = StringIO.StringIO(data2)
gzipper = gzip.GzipFile(fileobj=compressedstream)
f = gzipper.read()
</code></pre>

<p>I am not sure exactly why this works. It appears as though you must process/decompress gzip streams and gzip files differently. In any case, the stream decompression method using the PYTHON gzip.GzipFile method works very nicely. </p>
","<p>UPDATE</p>

<p>Thank you for your reply jww. Just FYI, I got this to work today by decompressing the received stream, from the C++ software utilizing the CryptoPP library, as follows within the PYTHON client:</p>

<pre><code>compressedstream = StringIO.StringIO(data2)
gzipper = gzip.GzipFile(fileobj=compressedstream)
f = gzipper.read()
</code></pre>

<p>I am not sure exactly why this works. It appears as though you must process/decompress gzip streams and gzip files differently. In any case, the stream decompression method using the PYTHON gzip.GzipFile method works very nicely. </p>
","240","<gzip><crypto++>","1","0","1","2014-06-21 12:53:30","24341791","3","","3238036","","2014-06-20 02:17:00","2014-06-19 01:18:47",""
"38676354","Not getting same session key after decoding payload under RSA","<p>I am not getting same session key after encoding and decoding it using below functions which uses crypto++ library:</p>

<pre><code>CryptoPP::RSA::PrivateKey RSA_master_privKey;
CryptoPP::RSA::PublicKey  RSA_master_pubKey;

std::string generate_Master_Keys()
{
    std::string rsaParams;
    try {
        CryptoPP::InvertibleRSAFunction parameters;
        RSA_master_privKey = CryptoPP::RSA::PrivateKey(parameters);
        RSA_master_pubKey = CryptoPP::RSA::PublicKey(parameters);
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        b_success = false;
    }
    return rsaParams;
}

PAES_KEY_WITH_IV create_session_key(void)
{
    CryptoPP::AutoSeededX917RNG&lt;CryptoPP::AES&gt; rng;
    PAES_KEY_WITH_IV  aes_info = new AES_KEY_WITH_IV;
    try {
        aes_info-&gt;key.resize(CryptoPP::AES::DEFAULT_KEYLENGTH);
        rng.GenerateBlock(aes_info-&gt;key, aes_info-&gt;key.size());
        aes_info-&gt;iv.resize(CryptoPP::AES::BLOCKSIZE);
        rng.GenerateBlock(&amp;aes_info-&gt;iv[0], aes_info-&gt;iv.size());
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        b_success = false;
    }
    return (aes_info);
}

std::string encrypt_session_key(PAES_KEY_WITH_IV pKey)
{
    std::string ciphered;
    CryptoPP::SecByteBlock block(pKey-&gt;key.size());
    try {
        CryptoPP::RSAES&lt; CryptoPP::OAEP&lt;CryptoPP::SHA&gt; &gt;::Encryptor enc(RSA_master_pubKey);
        enc.Encrypt(rng, pKey-&gt;key, pKey-&gt;key.size(), block);
        ciphered.assign((char *)block.BytePtr(), 192);
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        b_success = false;
    }
    return ciphered;
}

PAES_KEY_WITH_IV decrypt_session_key(std::string &amp; ciphered)
{
    CryptoPP::SecByteBlock rec(ciphered.size());
    CryptoPP::SecByteBlock block((const byte *)ciphered.data(), ciphered.size());
    PAES_KEY_WITH_IV pKey = new AES_KEY_WITH_IV;
    try {
        CryptoPP::RSAES&lt; CryptoPP::OAEP&lt;CryptoPP::SHA&gt; &gt;::Decryptor dec(RSA_master_privKey);
        dec.Decrypt(rng, block, block.size(), rec);

        pKey-&gt;key = rec;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        b_success = false;
    }
    return pKey;
}
</code></pre>

<p>Tailing of 192 bytes are not getting matched with original session key's bytes.</p>

<p>Can some one help me on this ?</p>

<p>Thanks in advance.</p>
","<blockquote>
  <p>I am not getting same session key after encoding and decoding it using below functions</p>
</blockquote>

<p>I think you are close to what you need. There's also an opportunity for improvement in the way you are doing it. I'll show you the improved way, and you can apply it to the existing method as well.</p>

<p>The improved way simply uses <code>FixedMaxPlaintextLength</code>, <code>CiphertextLength</code> and some friends to determine sizes. It also uses a technique from <a href=""https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"" rel=""nofollow"">Integrated Encryption Schemes (IES)</a>.</p>

<p>First, transport the raw seed bytes, and not the <code>{key, iv}</code> pair. Then, when you need the <code>{key, iv}</code> pair, you derive the bytes you need from the seed bytes. Your derivation should include a usage label and a version number.</p>

<p>Second, the open question: how many bytes do you transport as seed bytes. That answer is <code>FixedMaxPlaintextLength()</code> or <code>MaxPreimage()</code> (I don't recall which). That's the size of the plaintext that can be encrypted under the scheme, and it depends on things like the modulus size and the padding scheme.</p>

<p>A lot of the code below is discussed at <a href=""http://cryptopp.com/wiki/RSA_Encryption_Schemes"" rel=""nofollow"">RSA Encryption Schemes</a> and other places on the Crypto++ wiki. But its not readily apparent you need to visit them because you are still learning some of the techniques.</p>

<hr>

<p>The following generates a random seed and encrypts it under the public key.      </p>

<pre><code>RSA_master_pubKey = RSA::PublicKey(parameters);
RSAES&lt; OAEP&lt;SHA&gt; &gt;::Encryptor enc(RSA_master_pubKey);
SecByteBlock seed(enc.FixedMaxPlaintextLength());

AutoSeededX917RNG&lt;AES&gt; rng;
rng.GenerateBlock(seed, seed.size());

SecByteBlock block(enc.CiphertextLength(seed.size())));    
size_t req = enc.Encrypt(rng, seed, seed.size(), block);
block.resize(req);

// Transport block to peer as session seed
</code></pre>

<hr>

<p>When the peer receives the encrypted seed block, they must decrypt it. Here's how to do it.</p>

<pre><code>// Received from peer
SecByteBlock block(...);

RSAES&lt; OAEP&lt;SHA&gt; &gt;::Decryptor dec(RSA_master_privKey);
size_t req = dec.MaxPlaintextLength(block.size());

SecByteBlock seed(req);
DecodingResult result = dec.Decrypt(rng, block, block.size(), seed);
seed.resize(result.isValidCoding ? result.messageLength : 0);
</code></pre>

<p>You could even thrown an exception if <code>result.isValidCoding</code> returns <code>false</code>:</p>

<pre><code>DecodingResult result = dec.Decrypt(rng, block, block.size(), seed);
if (!result.isValidCoding)
    throw Exception(OTHER_ERROR, ""Failed to decrypt seed bytes"");

seed.resize(result.messageLength);
</code></pre>

<hr>

<p>When you want to encrypt or decrypt with AES, you need to derive a key, iv and possibly an hmac key (are you authenticating the data?).</p>

<pre><code>// Random seed from above
SecByteBlock seed;

HKDF&lt;SHA256&gt; kdf;
SecByteBlock aesKey(AES::DEFAULT_KEYLENGTH);
SecByteBlock aesIV(AES::BLOCKSIZE);   

const byte aesLabel[] = ""AES encryption key, version 1"";
kdf.Derive(aesKey, aesKey.size(), seed, seed.size(), NULL, 0, aesLabel, COUNTOF(aesLabel));

const byte ivLabel[] = ""AES initialization vector, version 1"";
kdf.Derive(aesIV, aesIV.size(), seed, seed.size(), NULL, 0, ivLabel, COUNTOF(ivLabel));
</code></pre>

<p><em>IF</em> you authenticate your data, then you can derive an HMAC key with the following. But generally speaking, you should probably use an <a href=""http://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow"">Authenticated Encryption</a> mode of operation:</p>

<pre><code>const byte hmacLabel[] = ""HMAC authentication key, version 1"";
kdf.Derive(hmacKey, hmacKey.size(), seed, seed.size(), NULL, 0, hmacLabel, COUNTOF(hmacLabel));
</code></pre>

<p><a href=""http://cryptopp.com/docs/ref/class_h_k_d_f.html"" rel=""nofollow"">HKDF was added at 5.6.3 or 5.6.4</a>. If you don't have it, then grab <code>hkdf.h</code> from <a href=""http://github.com/weidai11/cryptopp"" rel=""nofollow"">Wei Dai's GitHub</a> (its header-only). By deriving from a base seed with unique labels, you are using a technique called independent derivation.</p>

<p>You add the labels and the version information to avoid gaps like discussed in <a href=""http://homes.cs.washington.edu/~yoshi/papers/WinZip/winzip.pdf"" rel=""nofollow"">Attacking and Repairing the WinZip Encryption Scheme</a>. Also, using the entire <code>FixedMaxPlaintextLength</code> side steps some cryptographic attacks related to message length.</p>

<hr>

<p>You might also want to look at <a href=""https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"" rel=""nofollow"">Integrated Encryption Schemes (IES)</a>. We basically lifted the Key Encapsulation Mechanism (KEM) from IES. There's a Data Encapsulation Mechanism (DEM) that could be lifted, too.</p>

<p>If you are going to borrow the KEM and the DEM, then you may as well use the scheme. For that, see the following on the Crypto++ wiki:</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow"">Elliptic Curve Integrated Encryption Scheme</a></li>
<li><a href=""http://cryptopp.com/wiki/Discrete_Logarithm_Integrated_Encryption_Scheme"" rel=""nofollow"">Discrete Logarithm Integrated Encryption Scheme</a></li>
</ul>

<p>If you use one of the Integrated Encryption Schemes, then you are changing the underlying mathematical problem. RSA is Integer Factorization (<strong><em>IF</em></strong>), while IES is Diffie-Hellman and Discrete Logs (<strong><em>FF</em></strong>).</p>

<p>Using an Integrated Encryption Scheme is a good choice. Its <a href=""http://en.wikipedia.org/wiki/Ciphertext_indistinguishability"" rel=""nofollow"">IND-CCA2</a>, which is a very strong notion of security. I believe it has better security properties than your original scheme.</p>
","239","<c++><encryption><rsa><crypto++>","2","0","1","2016-08-07 17:58:30","38677372","1","","608639","","2016-08-01 11:25:45","2016-07-30 16:54:50",""
"32665800","ECIES Public Key serialization","<p>I'm write Client/Server encrypted program and want to send ECIES public key. For this I must serialize public key to file, read file to byte array, send this byte array. In other side: receive byte array, write it to file, deserialize public key from file. So, I'm written some test project, for try do it separately from great system, and (when all this module will work successfully) just insert it in my project. Code of this project are:</p>

<pre><code>class EncoderRSA
{
    public:
        EncoderRSA();
        void keyGeneration();
        std::string encrypt(std::string plainText);
        std::string decrypt(std::string cypher);
        void setRsaPublicKey(char *publicKeyInCharArray);
        char *getRsaPublicKey();
    private:
        AutoSeededRandomPool prng;  // Pseudo Random Number Generator
        ECIES&lt;ECP&gt;::Decryptor rsaDecryptor;
        ECIES&lt;ECP&gt;::Encryptor rsaEncryptor;
};
</code></pre>

<p>And, strictly speaking, prime (for problem) methods:</p>

<pre><code>char *EncoderRSA::getRsaPublicKey() {
    std::string file = ""publicKey.txt"";

    //Save public key in file
    FileSink sink(file.c_str());
    this-&gt;rsaEncryptor.GetPublicKey().Save(sink);

    //Read file with public key into the buffer
    std::ifstream infile (file.c_str(),std::ifstream::binary);

    if (!infile.is_open()) {
        std::cout &lt;&lt; ""Can't open file to write"" &lt;&lt; std::endl;
        exit(1);
    }

    // get size of file
    infile.seekg (0,infile.end);
    long size = infile.tellg();
    infile.seekg (0);

    // allocate memory for file content
    char* buffer = new char[size];
    infile.read (buffer,size);
    infile.close();

    return buffer;
}

void EncoderRSA::setRsaPublicKey(char *publicKeyInCharArray) {
    std::string file = ""publicKey.txt"";

    int size = strlen(publicKeyInCharArray);

    //Write received public key in file
    std::ofstream outfile (file.c_str(),std::ofstream::binary);

    if (!outfile.is_open()) {
        std::cout &lt;&lt; ""Can't open file to write"" &lt;&lt; std::endl;
        exit(1);
    }

    outfile.write (publicKeyInCharArray,size);
    outfile.close();

    // release dynamically-allocated memory
    delete[] publicKeyInCharArray;

    //Load public key from file
    FileSource source(file.c_str(), true);
    this-&gt;rsaEncryptor.AccessPublicKey().Load(source);
}
</code></pre>

<p>Code of <code>main.cpp</code>:</p>

<pre><code>int main() {
    char *buffer = keysEncoder.getRsaPublicKey();
    cout &lt;&lt; ""buffer: "" &lt;&lt; buffer &lt;&lt; endl;
    //...
    //send buffer
    //receive buffer from other side
    //..
    keysEncoder.setRsaPublicKey(buffer);

    string decoded = keysEncoder.decrypt(cypher);
    cout &lt;&lt; ""decoded: "" &lt;&lt; decoded &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>But it crashed with error:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::BERDecoderErr'
wait(): BER decode error
Aborted (core dumped)

Process returned 134 (0x86)    execution time: 2.891
</code></pre>

<p>Why?</p>
","<p>I removed references to RSA since it looks like you are using ECIES. Good job on that.</p>

<hr>

<blockquote>
  <p>terminate called after throwing an instance of 'CryptoPP::BERDecoderErr'</p>
</blockquote>

<p>Obviously, you need to setup a try/catch:</p>

<pre class=""lang-c++ prettyprint-override""><code>try
{
    ...
}
catch(const BERDecoderErr&amp; ex)
{
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<blockquote>
<pre><code>char *Encoder::getPublicKey() {
    ...
    char* buffer = ...
    return buffer;
}
</code></pre>
</blockquote>

<p>The ASN.1/DER encoding will likely have an embedded NULL, so you can't operate on it using traditional C-strings.</p>

<p>This should probably return a <code>std::string</code> so the output is not truncated at the first NULL character:</p>

<pre class=""lang-c++ prettyprint-override""><code>// get size of file
infile.seekg (0,infile.end);
long size = infile.tellg();
infile.seekg (0);

// allocate memory for file content
string buffer(size, '0');
infile.read (&amp;buffer[0], size);
infile.close();

return buffer;
</code></pre>

<hr>

<p>Another way to perform the read from the file can be found at <a href=""https://stackoverflow.com/q/2602013"">Read whole ASCII file into C++ std::string</a>:</p>

<pre class=""lang-c++ prettyprint-override""><code>std::ifstream infile (file.c_str(), std::ifstream::binary);
std::string buffer((std::istreambuf_iterator&lt;char&gt;(infile)),
                    std::istreambuf_iterator&lt;char&gt;());
</code></pre>

<hr>

<p>Another way is to ensure the <code>NULL</code>'s are not present in the output and input:</p>

<pre class=""lang-c++ prettyprint-override""><code>string Encoder::getPublicKey() {
    string encodedKey;
    HexEncoder sink(new StringSink(encodedKey));
    Encryptor.GetPublicKey().Save(sink);
    return encodedKey;
}
</code></pre>

<p>And:</p>

<pre class=""lang-c++ prettyprint-override""><code>void Encoder::setPublicKey(const string&amp; encodedKey) {
    StringSource source(encodedKey, new HexDecoder());
    Encryptor.AccessPublicKey().Load(source);
}
</code></pre>

<p>The code above uses <code>StringSource</code> and <code>StringSink</code>, so it operates on stuff in-memory. If you <strong><em>really</em></strong> want the on-disk intermediate files, then use a <code>FileSource</code> and <code>FileSink</code>.</p>
","238","<c++><encryption><crypto++><ecies>","4","1","1","2015-09-20 03:01:59","32675008","3","","608639","","2015-09-20 03:01:59","2015-09-19 07:59:27",""
"7999131","How is possible write this makefile?","<p>I have these 3 commands that compile my program:</p>

<ol>
<li>g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""AESBest.d"" -MT""AESBest.d"" -o ""AESBest.o"" ""AESBest.cpp""</li>
<li>g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""main.d"" -MT""main.d"" -o ""main.o"" ""main.cpp""</li>
<li>g++ -L/usr/include/cryptopp -o ""Crypto""  AESBest.o main.o   -lcryptopp -lpthread</li>
</ol>

<p>How is possible to create a makefile considering these 3 commands?</p>

<p>In Eclipse I receive output from the program in the shell, but in my bash, when I compile the bin file called ""Crypto"" and launch it, I have no output in my bash shell.
Why?</p>
","<p>This will work:</p>

<pre><code>all:
  g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""AESBest.d"" -MT""AESBest.d"" -o ""AESBest.o"" ""AESBest.cpp""
  g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""main.d"" -MT""main.d"" -o ""main.o"" ""main.cpp""
  g++ -L/usr/include/cryptopp -o ""Crypto"" AESBest.o main.o -lcryptopp -lpthread
</code></pre>

<p>And you can break it down a little like this:</p>

<pre><code>AESBest.o:
  g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""AESBest.d"" -MT""AESBest.d"" -o ""AESBest.o"" ""AESBest.cpp""

main.o:
  g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF""main.d"" -MT""main.d"" -o ""main.o"" ""main.cpp""

Crypto:
  g++ -L/usr/include/cryptopp -o ""Crypto"" AESBest.o main.o -lcryptopp -lpthread
</code></pre>

<p>And then simplify like this:</p>

<pre><code>AESBest.o main.o: %.o : %.cpp
  g++ -I/usr/include/cryptopp -O0 -g3 -Wall -c -fmessage-length=0 -MMD -MP -MF$*.d -MT$*.d -o $@ $&lt;

Crypto: AESBest.o main.o
  g++ -L/usr/include/cryptopp -o $@ $^ -lcryptopp -lpthread
</code></pre>
","238","<eclipse><makefile><crypto++>","0","2","1","2011-11-03 23:45:24","","1","","","","","2011-11-03 17:18:11",""
"45462728","Delay-load crypto++ cryptopp.dll","<p>The Crypto++ library supports late binding by compiling against <code>cryptlib.lib</code> and <code>cryptopp.lib</code>. This requires to use the <code>cryptopp.dll</code>. When trying to delay-load this dll by <code>/DELAYLOAD:cryptopp.dll</code> this causes a link error that it could not be delay loaded because of required imports.</p>

<p>As example see the following code:</p>

<pre><code>#include &lt;Crypto++/dll.h&gt;
#include &lt;crypto++/base64.h&gt;

bool HexDecode(const std::string&amp; strHex, std::string&amp; strData)
{
    try
    {
        CryptoPP::StringSource(strHex, true,
            new CryptoPP::Base64Decoder(
                new CryptoPP::StringSink(strData)));
    }

    catch(...)
    {
        return false;
    }

    return true;
}
</code></pre>

<p>This causes the following link error:</p>

<pre><code>LINK : fatal error LNK1194: Delay loading ""cryptopp.dll"" not possible because of import of data symbol """"__declspec(dllimport) bool (__cdecl* CryptoPP::g_pAssignIntToInteger)(class type_info const &amp;,void *,void const *)"" (__imp_?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA)"". Link without /DELAYLOAD:cryptopp.dll
</code></pre>

<p>Did anyone already managed to delay load <code>cryptopp.dll</code> successfully?</p>
","<blockquote>
  <p>The Crypto++ library supports late binding by compiling against cryptlib.lib and cryptopp.lib...</p>
</blockquote>

<p>The DLL is a FIPS DLL. The actual purpose of splitting functionality into two separate libraries is to provide the logical module boundary required by FIPS 140-2. The FIPS module boundary is <code>cryptopp.dll</code>.</p>

<p>The FIPS DLL only includes the FIPS algorithms, like AES and RSA. I recommend you avoid the FIPS DLL at all costs. Its a pain to work with. Also see <a href=""https://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">FIPS DLL</a> on the Crypto++ wiki.</p>

<p>If you want a DLL, then write your own wrapper DLL with your own API, and then link to the Crypto++ static library.</p>

<p>In the wrapper DLL case (and since you seem experienced), I highly encourage you to use <a href=""https://github.com/weidai11/cryptopp/blob/master/cryptest.nmake"" rel=""nofollow noreferrer""><code>cryptest.nmake</code></a> as a starting point. If you are familiar with makefiles (I think you are), then you will find it much easier to work with than the <a href=""https://www.cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer"">Visual Studio project files</a>.</p>

<hr>

<blockquote>
  <p>LINK : fatal error LNK1194: Delay loading ""cryptopp.dll"" not possible because of import of data symbol """"__declspec(dllimport) bool (__cdecl* CryptoPP::g_pAssignIntToInteger)(class type_info const &amp;,void *,void const *)"" (__imp_?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA)"". Link without /DELAYLOAD:cryptopp.dll</p>
</blockquote>

<p>This is an interesting question because you have two libraries, and its not clear to me which library the symbol is in. The first library is the FIPS DLL (cryptopp.dll), and it includes AES, RSA, etc. The second library is the Static Lib (cryptlib.lib), and it includes HexEncoder, FileSource, and the other supporting stuff.</p>

<p>I believe <code>g_pAssignIntToInteger</code> should be in the Static Lib (cryptlib.lib) because it was part of <code>AlgorithmParamters</code>. See, for example, <a href=""https://github.com/weidai11/cryptopp/commit/5efb019d8bdc593b3c1a0b57d615b170c7dab02a"" rel=""nofollow noreferrer"">Commit 5efb019d8bdc593b</a>. However, from the error above, it appears to be residing in the FIPS DLL because of the symbol name <code>__imp_?g_pAssignIntToInteger ...</code>.</p>

<p>Now the added wrinkle is, <code>g_pAssignIntToInteger</code> is a function pointer, and compilers won't optimize them away. So the linker never discards <code>Integer</code> related symbols, which is the point of the decoupling.</p>

<p>At <a href=""https://github.com/weidai11/cryptopp/commit/0e55f5ac7d98f3c852ace7b4622f40cfa60b629f"" rel=""nofollow noreferrer"">Commit 0e55f5ac7d98f3c8</a> we removed <code>g_pAssignIntToInteger</code> and added a define <code>CRYPTOPP_NO_ASSIGN_TO_INTEGER</code> to accomplish the task. The define ensures the symbol and unwanted code like <code>Integer</code> code can be discarded.</p>
","236","<c++><dll><crypto++><delay-load>","1","0","1","2017-08-03 11:32:18","","0","","","","","2017-08-02 13:46:52",""
"39895099","std::string.c_str() causes access violation 0xC0000005","<p>I have a problem with crypto++ 5.6.4 (VS2010) exception.code throws an exception in RSaVerifyVector function (in decoder.Put line):</p>

<pre><code> bool RsaVerifyVector(const std::string&amp;  publicKeyStrHex, const std::string&amp; source, const std::vector&lt;char&gt;&amp; sign)
    {
        CryptoPP::HexDecoder decoder;
        decoder.Put( (byte*)publicKeyStrHex.c_str(), publicKeyStrHex.size() );//--&gt;&gt;HERE IT THROWS Exception
        decoder.MessageEnd();

        CryptoPP::RSA::PublicKey publicKey;
        publicKey.Load( decoder );

        // Verifier object
        CryptoPP::RSASS&lt;CryptoPP::PSS, CryptoPP::SHA1&gt;::Verifier verifier( publicKey );

        std::vector&lt;char&gt; rawSignature;
        std::string signStr(utils::GetBeginOf(sign), sign.size());
        utils::FromHexString(utils::string2wstring(signStr), &amp;rawSignature);
        // Verify
        const char * pData = utils::GetBeginOf(source);
        return verifier.VerifyMessage( (const byte*) pData,
            source.size(), (const byte*) utils::GetBeginOf(rawSignature), rawSignature.size() );
    }
</code></pre>

<p>Help me to find a cause of this exception please! Exception attached. Thank you very much.</p>

<p><a href=""https://i.stack.imgur.com/YpbwA.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YpbwA.jpg"" alt=""enter image description here""></a></p>

<p>When exception occurs, after it shows me a cryptlib.h file and the following line of code:</p>

<pre><code>template &lt;class T&gt;
    void GetRequiredParameter(const char *className, const char *name, T &amp;value) const
    {
        if (!GetValue(name, value))
            throw InvalidArgument(std::string(className) + "": missing required parameter '"" + name + ""'"");
    }
</code></pre>
","<p>I remember that several years ago, using VS6, I had to deal with the Cyrillic characters, and in that time I had changed the MS-project settings by adding UNICODE in Preprocessor definition ( Project settings -> C/C++) and in the Tab Link I have added an Entry-point symbol: wWinMainCRTStartup.</p>
","236","<windows><visual-studio-2010><unicode><crypto++>","0","0","1","2016-10-07 00:39:14","","1","","608639","","2016-10-07 00:39:14","2016-10-06 11:43:12",""
"31655566","ASN1 OBJECT_IDENTIFIER decoding","<p>I have the following ASN1 data</p>

<pre><code>Sequence
  Sequence
    ObjectIdentifier
  Sequence
    Sequence
      Integer
      Integer
    Sequence
      Integer
      Integer
</code></pre>

<p>My goal is to get the encoded integer values. My code so far is the following</p>

<pre><code>ByteQueue queue(inputLen);
queue.Put2(input, inputLen, 0, false);

BERSequenceDecoder outer(queue);

BERSequenceDecoder discard(outer); // unnecessary  sequence with object_identifier
BERSequenceDecoder obj(discard,
    CryptoPP::ASNTag::OBJECT_IDENTIFIER | CryptoPP::ASNIdFlag::UNIVERSAL);

BERSequenceDecoder parent(outer); //BER decode error
for(int i = 0; i &lt; 2; i++) {
    BERSequenceDecoder dataSequence(parent);
    Integer i1, i2;

    i1.BERDecode(dataSequence);
    i2.BERDecode(dataSequence);
</code></pre>

<p>Problem is, I don't know how to properly get past the object_identifier part, at least I think that is the problem. I'm getting <code>BER decode error</code> on the 4. decoder object.</p>

<p>Also, am I initializing the ByteQueue correctly? this <code>Put2</code> method doesn't seem like the correct way, but I didn't find any other methods.</p>
","<blockquote>
<pre><code>ByteQueue queue(inputLen);
queue.Put2(input, inputLen, 0, false);
</code></pre>
</blockquote>

<p>You could also do something like:</p>

<pre class=""lang-c++ prettyprint-override""><code>ArraySource as(input, inputLen, false /*pumpAll*/);
as.TransferTo(queue);
</code></pre>

<p>Or, if you just want to copy them:</p>

<pre class=""lang-c++ prettyprint-override""><code>as.CopyTo(queue);
</code></pre>

<hr>

<blockquote>
  <p>Problem is, I don't know how to properly get past the object_identifier part...</p>
</blockquote>

<p>I would probably do something like:</p>

<pre><code>byte b = as.Peek();
if(b == /*some tag*/)
    as.Skip(n);
</code></pre>

<p>Or:</p>

<pre><code>byte b = as.Peek();
if(b == /*some tag*/)
{
    lword length;
    bool definiteLength;

    if(!BERLengthDecode(as, length, definiteLength))
        throw BadParam();

    as.Skip(length);
}
</code></pre>

<p>The source files with the goodies like above is <a href=""http://www.cryptopp.com/docs/ref/asn_8h_source.html"" rel=""nofollow""><code>asn.h</code></a> and <a href=""http://www.cryptopp.com/docs/ref/asn_8cpp_source.html"" rel=""nofollow""><code>asn.cpp</code></a>. The others you might be interested in include <code>BERDecodeOctetString</code> and <code>BERDecodeBitString</code>.</p>
","232","<decoding><asn.1><crypto++>","1","1","1","2015-07-29 10:50:08","31665334","1","","608639","","2015-07-28 00:07:34","2015-07-27 14:15:10",""
"27112099","Setup Crypto++ for Eclipse windows","<p>I downloaded crypto++ 5.6.2 from <a href=""http://cryptopp.com/#download"" rel=""nofollow"">here</a>. I want to install it and start using it on Eclipse on windows. I am a new user of Eclipse and wanted to know steps to start using crypto++ in my project.</p>
","","232","<c++><eclipse><windows><eclipse-cdt><crypto++>","2","","0","2014-11-24 23:52:30","","3","","608639","","2014-11-24 23:52:30","2014-11-24 18:54:47",""
"46561818","CMake throws exception because of undefined reference in CryptoPP","<p>I am getting this error:</p>

<pre><code>CMakeFiles/Athena.dir/Startup/main.cpp.o: In function `CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;::ClonableImpl()':
/home/dev/workspace/Athena/lib/cryptopp/simple.h:26: undefined reference to `CryptoPP::Rijndael::Enc::Enc()'
collect2: error: ld returned 1 exit status
CMakeFiles/Athena.dir/build.make:434: recipe for target 'Athena'
</code></pre>

<p>when I try to link CryptoPP to my programm.</p>

<p>This is my CMakeLists.txt:</p>

<pre><code>cmake_minimum_required(VERSION 3.8)
project(Athena)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pthread -fpermissive -Wno-deprecated -Wno-int-to-pointer-cast -Wno-deprecated-declarations"")

include_directories(lib/SQLiteCpp/include)
add_subdirectory(lib/SQLiteCpp)

include_directories(lib/cryptopp)
add_subdirectory(lib/cryptopp)

include_directories(lib/json/src)
add_subdirectory(lib/json)

set(SOURCE_FILES
    Startup/main.cpp)

add_executable(Athena ${SOURCE_FILES})
target_link_libraries(Athena SQLiteCpp sqlite3 pthread dl cryptopp)
</code></pre>

<p>Here are my includes:</p>

<pre><code>#include ""modes.h"" // For CTR_Mode
#include ""filters.h"" //For StringSource
#include ""aes.h"" // For AES
</code></pre>

<p>I already tried linking cryptopp by find_package, by find_library and I even tried writing a script to download and make cryptopp manually. I am really out of ideas and I´m also pretty sure that it´s not my code (I pasted in an example from the cryptopp wiki).</p>
","<p>Try to</p>

<pre><code>target_link_libraries(Athena SQLiteCpp sqlite3 cryptopp pthread ${CMAKE_DL_LIBS})
</code></pre>

<p>I guess change library ordering might help. Using of <code>${CMAKE_DL_LIBS}</code> instead of <code>dl</code> is not mandatory but it's good practice to use portable CMake definitions.</p>
","231","<c++><cmake><linker><crypto++>","1","0","2","2017-10-05 12:47:28","46585909","1","","7191065","","2017-10-04 09:52:38","2017-10-04 09:47:05",""
"46561818","CMake throws exception because of undefined reference in CryptoPP","<p>I am getting this error:</p>

<pre><code>CMakeFiles/Athena.dir/Startup/main.cpp.o: In function `CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;::ClonableImpl()':
/home/dev/workspace/Athena/lib/cryptopp/simple.h:26: undefined reference to `CryptoPP::Rijndael::Enc::Enc()'
collect2: error: ld returned 1 exit status
CMakeFiles/Athena.dir/build.make:434: recipe for target 'Athena'
</code></pre>

<p>when I try to link CryptoPP to my programm.</p>

<p>This is my CMakeLists.txt:</p>

<pre><code>cmake_minimum_required(VERSION 3.8)
project(Athena)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -pthread -fpermissive -Wno-deprecated -Wno-int-to-pointer-cast -Wno-deprecated-declarations"")

include_directories(lib/SQLiteCpp/include)
add_subdirectory(lib/SQLiteCpp)

include_directories(lib/cryptopp)
add_subdirectory(lib/cryptopp)

include_directories(lib/json/src)
add_subdirectory(lib/json)

set(SOURCE_FILES
    Startup/main.cpp)

add_executable(Athena ${SOURCE_FILES})
target_link_libraries(Athena SQLiteCpp sqlite3 pthread dl cryptopp)
</code></pre>

<p>Here are my includes:</p>

<pre><code>#include ""modes.h"" // For CTR_Mode
#include ""filters.h"" //For StringSource
#include ""aes.h"" // For AES
</code></pre>

<p>I already tried linking cryptopp by find_package, by find_library and I even tried writing a script to download and make cryptopp manually. I am really out of ideas and I´m also pretty sure that it´s not my code (I pasted in an example from the cryptopp wiki).</p>
","<p>Your <code>CMakeLists.txt</code> looks incorrect. You should do two things. First, you should duplicate the exact list of the source files the <code>GNUmakefile</code> uses for a target. Second, you should use the same flags the <code>GNUmakefile</code> uses. You have to run the project's makefile or msbuild files to get those.</p>

<p>You should also consider using <code>ExternalProject_Add</code>; and stop trying to get Cmake to build the library. The library already supplies a Makefile and MSBuild file to build the library on all platforms it supports, so Cmake is superfluous and not needed. There's no reason to have Cmake create build files with incorrect options and flags since we already supply one with the correct options. Also see <a href=""https://stackoverflow.com/q/16842218/608639"">How to use CMake ExternalProject_Add or alternatives in a cross platform way?</a> on Stack Overflow.</p>

<p>After a year of trying to support Cmake in Crypto++, I'm speaking with a lot of experience. Also see <a href=""https://www.cryptopp.com/wiki/CMake"" rel=""nofollow noreferrer"">Cmake</a> on the Crypto++ wiki.</p>

<hr>

<pre><code>CMakeFiles/Athena.dir/Startup/main.cpp.o: In function `CryptoPP::ClonableImpl&lt;CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;, CryptoPP::Rijndael::Enc&gt;::ClonableImpl()':
/home/dev/workspace/Athena/lib/cryptopp/simple.h:26: undefined reference to `CryptoPP::Rijndael::Enc::Enc()'
collect2: error: ld returned 1 exit status
CMakeFiles/Athena.dir/build.make:434: recipe for target 'Athena'
</code></pre>

<p>You should show the command line you used to build the library. This is yet another reason Crypto++ withdrew support for Cmake - it hides necessary information used for troubleshooting, like the command line used to build a source file. It resulted in awful bug reports like this.</p>

<p><code>Rijndael::Enc::Enc()</code> is used to enable code to harden against side channel attacks when unaligned data accesses are in effect. The constructor itself is not used; but its needed for the code path because a few values are set in it.</p>

<p>If you look at <a href=""https://github.com/weidai11/cryptopp/blob/master/rijndael.h"" rel=""nofollow noreferrer""><code>rijndael.h</code></a> you will see the constructor is enabled when the platform is IA-32, ARM or PowerPC. But the source file of interest is really <a href=""https://github.com/weidai11/cryptopp/blob/master/rijndael.cpp"" rel=""nofollow noreferrer""><code>rijndael.cpp</code></a>, around line 1070:</p>

<pre><code>#if CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X32 || CRYPTOPP_BOOL_X86

static inline bool AliasedWithTable(const byte *begin, const byte *end)
{
    ptrdiff_t s0 = uintptr_t(begin)%4096, s1 = uintptr_t(end)%4096;
    ptrdiff_t t0 = uintptr_t(Te)%4096, t1 = (uintptr_t(Te)+sizeof(Te))%4096;
    if (t1 &gt; t0)
        return (s0 &gt;= t0 &amp;&amp; s0 &lt; t1) || (s1 &gt; t0 &amp;&amp; s1 &lt;= t1);
    else
        return (s0 &lt; t1 || s1 &lt;= t1) || (s0 &gt;= t0 || s1 &gt; t0);
}

struct Locals
{
    word32 subkeys[4*12], workspace[8];
    const byte *inBlocks, *inXorBlocks, *outXorBlocks;
    byte *outBlocks;
    size_t inIncrement, inXorIncrement, outXorIncrement, outIncrement;
    size_t regSpill, lengthAndCounterFlag, keysBegin;
};

const size_t s_aliasPageSize = 4096;
const size_t s_aliasBlockSize = 256;
const size_t s_sizeToAllocate = s_aliasPageSize + s_aliasBlockSize + sizeof(Locals);

Rijndael::Enc::Enc() : m_aliasBlock(s_sizeToAllocate) { }

#endif  // CRYPTOPP_BOOL_X64 || CRYPTOPP_BOOL_X32 || CRYPTOPP_BOOL_X86

#if CRYPTOPP_BOOL_ARM32 || CRYPTOPP_BOOL_ARM64 || CRYPTOPP_BOOL_PPC32 || CRYPTOPP_BOOL_PPC64
// Do nothing
Rijndael::Enc::Enc() { }
#endif
</code></pre>

<p>You need to figure out why Cmake is mucking with the defines for <code>CRYPTOPP_BOOL_X86</code>, <code>CRYPTOPP_BOOL_X64</code> and friends. To do that, you need to see the command line, but Cmake hides that from you.</p>

<hr>

<p>Related, we do test C++17 and you should be OK with that flag. However, based on experience this may cause problems: <code>set(CMAKE_CXX_STANDARD 17)</code>. Cmake does not have good C++ support. We could not perform a simple <code>project(cryptopp, CXX)</code>. Also see <a href=""https://stackoverflow.com/q/37931068/608639"">Tell CMake to use C++ compiler for C files coming from CMake?</a>.</p>

<hr>

<p>I'll look into removing the constructor for all builds; and set <code>m_aliasBlock</code> in <code>UncheckedSetKey</code>. That may help with the issue. But its just a band-aid for a bigger engineering problem. The bigger engineering problems created by Cmake is the reason we withdrew support for it.</p>
","231","<c++><cmake><linker><crypto++>","1","1","2","2017-10-05 12:47:28","46585909","1","","7191065","","2017-10-04 09:52:38","2017-10-04 09:47:05",""
"38986900","ECDH shared secret doesn't match in loop, with Crypto++","<pre><code>CryptoPP::OID CURVE = CryptoPP::ASN1::secp256r1();
CryptoPP::AutoSeededRandomPool prng;
std::vector&lt;kpStruct&gt; KPVecRSU;

(loop begin)
kpStruct keyP;
CryptoPP::ECDH &lt; CryptoPP::ECP &gt;::Domain dhA( CURVE );
CryptoPP::SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
dhA.GenerateKeyPair(prng, privA, pubA);
CryptoPP::SecByteBlock sharedA(dhA.AgreedValueLength());
keyP.sharedECDH = sharedA;
KPVecRSU.push_back(keyP);
(loop end)
</code></pre>

<p>I want to create shared secret between 3 units, but this code give me different ones ! any idea please ?</p>
","<blockquote>
  <p>ECDH shared secret doesn't match in loop, with Crypto++</p>
</blockquote>

<p>Each run of the protocol produces a different shared secret because both the client and server are contributing random values during the key agreement. The inherit randomness provides forward secrecy, meaning bad guys cannot recover plain text at a later point in time because the random values were temporary or ephemeral (forgotten after the protocol execution).</p>

<p>In the Crypto++ implementation, the library does not even make a distinction between client and server because there's so much symmetry in the protocol. Protocols with too much symmetry can suffer the Chess Grand-Master attack, where one protocol execution is used to solve another protocol execution (think of it like a man-in-the-middle, where the bad guy is a proxy for both grand-masters). Often, you tweak a parameter on one side or the other to break the symmetry (client uses 14-byte random, server uses 18-byte random).</p>

<p>Other key agreement schemes we are adding <em>do</em> need to make the distinction between client and server, like <a href=""http://github.com/weidai11/cryptopp/tree/hmqv"" rel=""nofollow"">Hashed MQV (HMQV) and Fully Hashed MQV (FHMQV)</a>. <em>Client</em> and <em>Server</em> are called <em>Initiator</em> and <em>Responder</em> in HMQV and FHMQV.</p>

<hr>

<blockquote>
  <p>I want to create shared secret between 3 units, but this code give me different ones.</p>
</blockquote>

<p>This is a different problem. This is known as <em>Group</em> Diffie-Hellman or <em>Multi-party</em> Diffie-Hellman. It has applications in, for example, chat and broadcast of protected content, where users are part of a group or join a group. The trickier part of the problem is how to revoke access to a group when a user leaves the group or is no longer authorized.</p>

<p>Crypto++ does not provide any group DH schemes, as far as I know. You may be able to modify existing sources to do it.</p>

<p>For <em>Group</em> Diffie-Hellman, you need to search <a href=""http://scholar.google.com/scholar?q=group++diffie-hellman"" rel=""nofollow"">Google Scholar for the papers</a>. Pay particular attention to the security attributes of the scheme, like how to join and leave a group (grant and revoke access).</p>
","226","<crypto++><ecdhe>","1","0","1","2016-08-18 02:29:59","39009019","1","","5822013","","2016-08-17 02:09:19","2016-08-17 01:42:23",""
"41686278","""Mutex"" Error when using Cryptopp with Windows Forms","<p><br>
I'm using Visual Studio 2015 <br>
An CLR application and I added a UI windows form <br>
I want include some Crypto++ functions into my Form header file so I add these lines after <code>#pragma once</code></p>

<pre><code>#include &lt;string&gt;
#include ""base64.h""
#include ""rsa.h""
#include ""pem.h""
#include ""osrng.h""
</code></pre>

<p>Windows forms needs to be compiled using /clr <br>
So my project setting enables Common Language Runtime Support (/clr) <br>
But that causes an error when building : </p>

<pre><code>fatal error C1189: #error:  &lt;mutex&gt; is not supported when compiling with /clr or /clr:pure.
</code></pre>

<p>It looks like Cryptopp is including  which is not compatible with /clr <br>
But if I disable /clr by changing it to <code>No Common Language Runtime Support</code> in the settings I get like hundreds of errors because Windows Form header code needs managed code means it needs /clr<br></p>

<p>So any solution so I can use Cryptopp in Windows Forms ?<br><br>
Notice : I don't want use any other library for cryptography <br><br>
Thanks everyone !</p>

<p><strong>UPDATE :</strong> <br>
An example of my program : <br>
Create a normal CLR Application then add an UI windows form, in the begging of form.h file add the lines found above then at any part of code (example in the form load section) add this : <br></p>

<pre><code>string plain = ""Test123"", encoded, cipher;
string pkey = ""..."";
StringSource ss(pkey, true);
RSA::PublicKey publicKey;
PEM_Load(ss, publicKey);
RSAES_OAEP_SHA_Encryptor e(publicKey);

StringSource(plain, true,
    new PK_EncryptorFilter(prng, e,
        new StringSink(cipher)
    ) 
); 
StringSource((byte *)cipher.c_str(), cipher.size(), true,
    new Base64Encoder(
        new StringSink(encoded)
    )
);
</code></pre>
","","226","<c++><winforms><visual-c++><mutex><crypto++>","0","","0","2017-01-17 13:24:15","","6","","2758923","","2017-01-17 13:24:15","2017-01-16 22:48:28",""
"25319787","How to use RabinMillerTest() in CryptoPP?","<p>Can anyone share an example of RabinMillerTest() that works?  My googlefu is sadly lacking.</p>

<p>Here is my test code:</p>

<pre><code>#include ""integer.h""
#include ""nbtheory.h""
#include ""cryptlib.h""
#include ""osrng.h""
#include &lt;iostream&gt;
int main(int argc,char *argv[])
{
    CryptoPP::RandomNumberGenerator rng;
    CryptoPP::Integer a(""123456789"");
    CryptoPP::Integer b;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(a) &lt;&lt; std::endl;
    b=a+CryptoPP::Integer::Two();
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(b) &lt;&lt; std::endl;
    int r=RabinMillerTest(rng,&amp;b,2);
    std::cout &lt;&lt; ""RabinMiller: "" &lt;&lt; r &lt;&lt;std::endl;
}
</code></pre>

<p>Here is the build command:</p>

<pre><code>g++ bignum.cpp -I.  -fpermissive libcryptopp.a
</code></pre>

<p>The only example I could find is here:</p>

<p><a href=""http://www.cryptopp.com/wiki/Diffie-Hellman"" rel=""nofollow"">http://www.cryptopp.com/wiki/Diffie-Hellman</a></p>

<p>My code crashes every time I run it, and one crash was so bad I had to cold boot to recover.  If I remove the call to RabinMillerTest() then it runs fine.  I suspect a problem with C++ syntax is the culprit, but I just don't see it.  Since I can't use it properly, I am currently stripping the guts of the RabinMillerTest() function to use separately.</p>
","<p>You're using the wrong signature for <code>MillerRabinTest</code>. Here's what it is (from <code>nbtheory.h</code>):</p>

<pre><code>CRYPTOPP_DLL bool CRYPTOPP_API RabinMillerTest(RandomNumberGenerator &amp;rng,
                                   const Integer &amp;w, unsigned int rounds);
</code></pre>

<p>Instead of:</p>

<pre><code>int r=RabinMillerTest(rng,&amp;b,2);
</code></pre>

<p>Try:</p>

<pre><code>bool b=RabinMillerTest(rng, b, 2);
</code></pre>

<p>There's also a discussion of Miller-Rabin round counts on the Cryptography Stack Exchange at <a href=""https://crypto.stackexchange.com/questions/17707/trial-divisions-before-miller-rabin-checks"">Trial divisions before Miller-Rabin checks?</a>. It was written with OpenSSL and Crypto++ in mind.</p>
","225","<c++><crypto++>","1","0","2","2014-08-30 00:32:51","","3","","608639","","2014-08-30 00:31:28","2014-08-15 00:55:24",""
"25319787","How to use RabinMillerTest() in CryptoPP?","<p>Can anyone share an example of RabinMillerTest() that works?  My googlefu is sadly lacking.</p>

<p>Here is my test code:</p>

<pre><code>#include ""integer.h""
#include ""nbtheory.h""
#include ""cryptlib.h""
#include ""osrng.h""
#include &lt;iostream&gt;
int main(int argc,char *argv[])
{
    CryptoPP::RandomNumberGenerator rng;
    CryptoPP::Integer a(""123456789"");
    CryptoPP::Integer b;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(a) &lt;&lt; std::endl;
    b=a+CryptoPP::Integer::Two();
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(b) &lt;&lt; std::endl;
    int r=RabinMillerTest(rng,&amp;b,2);
    std::cout &lt;&lt; ""RabinMiller: "" &lt;&lt; r &lt;&lt;std::endl;
}
</code></pre>

<p>Here is the build command:</p>

<pre><code>g++ bignum.cpp -I.  -fpermissive libcryptopp.a
</code></pre>

<p>The only example I could find is here:</p>

<p><a href=""http://www.cryptopp.com/wiki/Diffie-Hellman"" rel=""nofollow"">http://www.cryptopp.com/wiki/Diffie-Hellman</a></p>

<p>My code crashes every time I run it, and one crash was so bad I had to cold boot to recover.  If I remove the call to RabinMillerTest() then it runs fine.  I suspect a problem with C++ syntax is the culprit, but I just don't see it.  Since I can't use it properly, I am currently stripping the guts of the RabinMillerTest() function to use separately.</p>
","<p>This was the answer edited into the question. Adding as a separate answer block. Credit goes to user3920315.</p>

<hr>

<p>UPDATE:  I got it to work.  Here is the working code:</p>

<pre><code>#include ""integer.h""
#include ""nbtheory.h""
#include ""cryptlib.h""
#include ""osrng.h""
#include &lt;iostream&gt;
int main(int argc,char *argv[])
{
    //CryptoPP::RandomNumberGenerator rng;
    CryptoPP::NonblockingRng rng;
    CryptoPP::Integer a(""123456789"");
    CryptoPP::Integer b;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(a) &lt;&lt; std::endl;
    b=a+CryptoPP::Integer::Two();
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; ""is prime: "" &lt;&lt; IsPrime(b) &lt;&lt; std::endl;
    bool r=RabinMillerTest(rng,b,2);
    std::cout &lt;&lt; ""RabinMiller: "" &lt;&lt; r &lt;&lt;std::endl;
}
</code></pre>

<p>I changed the call to <code>RabinMillerTest()</code> but the resulting executable would still crash.</p>

<p>When I changed the random number generator to a class that inherits from <code>RandomNumberGenerator</code>, then it works.</p>
","225","<c++><crypto++>","1","0","2","2014-08-30 00:32:51","","3","","608639","","2014-08-30 00:31:28","2014-08-15 00:55:24",""
"31359903","Invalid ciphertext when performing RSA decryption","<p>I use the following code to encrypt and decrypt a string making use of Crypto++ 5.6.2 library</p>

<pre><code>string to_BER(string spriv,bool b)    
{
    string HEADER, FOOTER;

    if(b)
    {
        HEADER = ""-----BEGIN RSA PRIVATE KEY-----"";
        FOOTER = ""-----END RSA PRIVATE KEY-----"";
    }
    else
    {
        HEADER = ""-----BEGIN PUBLIC KEY-----"";
        FOOTER = ""-----END PUBLIC KEY-----"";
    }

        size_t pos1, pos2;
        pos1 = spriv.find(HEADER);
        if(pos1 == string::npos)
            throw std::runtime_error(""PEM header not found"");

        pos2 = spriv.find(FOOTER, pos1+1);
        if(pos2 == string::npos)
            throw std::runtime_error(""PEM footer not found"");

        // Start position and length
        pos1 = pos1 + HEADER.length();
        pos2 = pos2 - pos1;
        string keystr = spriv.substr(pos1, pos2);

        return keystr;
}

string rsa_encrypt(const string &amp;message, const string &amp;public_key)
{    
    string keystr=to_BER(public_key,false);

    ByteQueue queue;
    Base64Decoder decoder;

    decoder.Attach(new Redirector(queue));
    decoder.Put((const byte*)keystr.data(), keystr.length());
    decoder.MessageEnd();

    RSAES_PKCS1v15_Encryptor e;
    e.AccessKey().Load(queue);

    bool key_ok = e.AccessKey().Validate(rng, 3);
    if(!key_ok)
    {
        printf(""ERROR IN RSA KEY\n"");
        return """";
    }

    string encrypted_data;

    StringSource ss1(message, true,
        new PK_EncryptorFilter(rng, e,
            new StringSink(encrypted_data)
       ) // PK_EncryptorFilter
    ); // StringSource

    return encrypted_data;
}

string rsa_decrypt(const string &amp;message, const string &amp;private_key,bool b_Base64decode)
{
    string keystr=to_BER(private_key,true);

    string decoded=message;

    if(b_Base64decode)
    {
        Base64Decoder decoder;

        decoder.Put( (byte*)message.data(), message.size() );
        decoder.MessageEnd();

        word64 size = decoder.MaxRetrievable();
        if(size &amp;&amp; size &lt;= SIZE_MAX)
        {
            decoded.resize(size);
            decoder.Get((byte*)decoded.data(), decoded.size());
        }
    }  

    RSAES_PKCS1v15_Decryptor pri( rng, 1024 );
    TransparentFilter privSink( new StringSink(keystr) );
    pri.DEREncode( privSink );
    privSink.MessageEnd();            

    string decrypted_data;
    try
    {

    StringSource ss( decoded, true,
            new PK_DecryptorFilter( rng, pri, new StringSink( decrypted_data )));
    }
    catch(Exception *e)
    {
        printf(""ERROR DECRYPTING RSA\n"");
        return """";
    }   

    return decrypted_data;
}
</code></pre>

<p>Then I use this code:</p>

<pre><code>string enc=rsa_encrypt(""hola mundo"",""-----BEGIN PUBLIC KEY----- MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgHIiecdmRAaiTrCbbEOLBPh+fxp2KyGWyMTeWIj56NRk1CFLfBDT6vOWDceFpuTcrAFGR4Np4JLsssqM24F7bZCKv6eQCV8Xjv6GJiGofKEkI4b0zwHHEwq63p+9Rb5jYXlPZ7JIud7Yi96CHbg3foLQzZSSS9oFItGOFF0jDM7lAgMBAAE= -----END PUBLIC KEY-----"");

string aaa=rsa_decrypt(
            /*""YTbXg1K4OlXGY6eaLuVTFZrN4qi1zg83h0PjeLd9F3Ge3gKUHsJpoE3iLv1+Gj/PepM8ehiilb5kphxCdcELjaYH9wwYHMpUZUQSRLQUTnofOboI6nfHaKnnNV28QMguM39q1hm7X1wNc69D8R+CkWLka2rQof+BXt+41ivnMj8="",*/
            enc
            ,""-----BEGIN RSA PRIVATE KEY----- MIICWwIBAAKBgHIiecdmRAaiTrCbbEOLBPh+fxp2KyGWyMTeWIj56NRk1CFLfBDT6vOWDceFpuTcrAFGR4Np4JLsssqM24F7bZCKv6eQCV8Xjv6GJiGofKEkI4b0zwHHEwq63p+9Rb5jYXlPZ7JIud7Yi96CHbg3foLQzZSSS9oFItGOFF0jDM7lAgMBAAECgYBxFL9bVHNprz4PtK3bbc2K9qmv6gxpxx88Dp/hdtm8NfoG0uclNRHALZeRa1Yjwo+Y46zPAwPCDkpGbLC+5S9zfBjtrx/+8zjTyMVb2CcGLfR0H2E/hcCjADXNxs+fmpB3+jyPhgH5ANaTmAXqGXOP56I0Fqo8xCfU/zQELCtzMQJBAN2Kq+9bQW3nKAAJEZqWQlAEjuBQfe1lrvLxc/AgVl9XLWrHre7HSlkyqcFemvqhzlZy1wz0Nv5VpOIGcAKefEMCQQCD4xSbkF1kzZyj8k6P3iUW6ezaK4krOZnpq/wDyOtj0DBAtLt3apyv3BUbe7AH1e8llJ5a8UYVHlsOdRUio+m3AkAB0LYR8wR5OxCn12sughavAyqMifxOKqwhT3sst4cdpuA3ZMV3FGj2jCS58eWBMjw3lx9N+t5MfTUpqPXX/6ZzAkBx9eTXqv3YXYZtb7GMxQI9c3Jy7k1/aS1iaXbA+nrTa5BWSRT30cqEduJSNiVcD/KuAWZ35KWPGATMUEUsAoCvAkEAuVg0OA6L3xJphKEbVYXvTwXrXcoVjjLDnNYjUJuNWrFFjBuNE4whWvdg76Panw3vMhgFc6yVr+VE5XOc7rXPvA== -----END RSA PRIVATE KEY-----""
            ,false
            );
</code></pre>

<p>The problem is that <code>rsa_decrypt</code> fails with a ""invalid ciphertext"" exception that isn't caught with the try/catch code. The program crashes.
I would like to know what is wrong with my code and how can I avoid the program to crash even if the ciphertext is wrong.
I have found similar threads (<a href=""https://stackoverflow.com/questions/1847410/crypto-rsa-and-invalid-ciphertext"">crypto++ RSA and &quot;invalid ciphertext&quot;</a>) but none of the solutions is valid for me: I don't see any problem with a 0 at the end of the string, I check that the keys are valid, I know that private and public keys are from the same key pair and they work with other RSA libraries.</p>

<p>This is the line were it crashes:</p>

<pre><code>StringSource ss( decoded, true,
                new PK_DecryptorFilter( rng, pri, new StringSink( decrypted_data )));
</code></pre>
","<blockquote>
  <p>The problem is that rsa_decrypt fails with a ""invalid ciphertext"" exception</p>
</blockquote>

<p>You create a <strong><em>new</em></strong> private key, and then encode it into <code>keystr</code>:</p>

<pre><code>RSAES_PKCS1v15_Decryptor pri( rng, 1024 );
TransparentFilter privSink( new StringSink(keystr) );
pri.DEREncode( privSink );
</code></pre>

<p>Instead, you should use <code>private_key</code> (and not the new key) and do something like you did in the encryptor:</p>

<pre><code>string keystr=to_BER(private_key,true);

ByteQueue queue;
Base64Decoder decoder;

decoder.Attach(new Redirector(queue));
decoder.Put((const byte*)keystr.data(), keystr.length());
decoder.MessageEnd();

RSAES_PKCS1v15_Decryptor d;
d.AccessKey().Load(queue);
</code></pre>

<hr>

<blockquote>
  <p>... that isn't caught...</p>
</blockquote>

<p>Wrap <strong><em>everything</em></strong> in a try/catch block, and not just the <code>PK_DecryptorFilter</code> call.</p>

<hr>

<p>You can see the difference (or lackof) between the public and private keys with something like:</p>

<pre><code>try {

    string s1(""-----BEGIN PUBLIC KEY-----\n""
              ""MIGeMA0GCSqGSIb3DQEBAQUAA4GMADCBiAKBgHIiecdmRAai""
              ""TrCbbEOLBPh+fxp2KyGWyMTeWIj56NRk1CFLfBDT6vOWDceF""
              ""puTcrAFGR4Np4JLsssqM24F7bZCKv6eQCV8Xjv6GJiGofKEk""
              ""I4b0zwHHEwq63p+9Rb5jYXlPZ7JIud7Yi96CHbg3foLQzZSS""
              ""S9oFItGOFF0jDM7lAgMBAAE=""
              ""\n-----END PUBLIC KEY-----"");
    string s2(""-----BEGIN RSA PRIVATE KEY-----\n""
              ""MIICWwIBAAKBgHIiecdmRAaiTrCbbEOLBPh+fxp2KyGWyMTeWIj""
              ""56NRk1CFLfBDT6vOWDceFpuTcrAFGR4Np4JLsssqM24F7bZCKv6""
              ""eQCV8Xjv6GJiGofKEkI4b0zwHHEwq63p+9Rb5jYXlPZ7JIud7Yi""
              ""96CHbg3foLQzZSSS9oFItGOFF0jDM7lAgMBAAECgYBxFL9bVHNp""
              ""rz4PtK3bbc2K9qmv6gxpxx88Dp/hdtm8NfoG0uclNRHALZeRa1Y""
              ""jwo+Y46zPAwPCDkpGbLC+5S9zfBjtrx/+8zjTyMVb2CcGLfR0H2""
              ""E/hcCjADXNxs+fmpB3+jyPhgH5ANaTmAXqGXOP56I0Fqo8xCfU/""
              ""zQELCtzMQJBAN2Kq+9bQW3nKAAJEZqWQlAEjuBQfe1lrvLxc/Ag""
              ""Vl9XLWrHre7HSlkyqcFemvqhzlZy1wz0Nv5VpOIGcAKefEMCQQC""
              ""D4xSbkF1kzZyj8k6P3iUW6ezaK4krOZnpq/wDyOtj0DBAtLt3ap""
              ""yv3BUbe7AH1e8llJ5a8UYVHlsOdRUio+m3AkAB0LYR8wR5OxCn1""
              ""2sughavAyqMifxOKqwhT3sst4cdpuA3ZMV3FGj2jCS58eWBMjw3""
              ""lx9N+t5MfTUpqPXX/6ZzAkBx9eTXqv3YXYZtb7GMxQI9c3Jy7k1""
              ""/aS1iaXbA+nrTa5BWSRT30cqEduJSNiVcD/KuAWZ35KWPGATMUE""
              ""UsAoCvAkEAuVg0OA6L3xJphKEbVYXvTwXrXcoVjjLDnNYjUJuNW""
              ""rFFjBuNE4whWvdg76Panw3vMhgFc6yVr+VE5XOc7rXPvA==""
              ""\n-----END RSA PRIVATE KEY-----"");

    ArraySource as1(s1, true), as2(s2, true);

    RSA::PublicKey k1;
    RSA::PrivateKey k2;

    PEM_Load(as1, k1);
    PEM_Load(as2, k2);

    AutoSeededRandomPool prng;
    k1.ThrowIfInvalid(prng, 3);
    k2.ThrowIfInvalid(prng, 3);

    Integer i1 = k1.GetModulus() - k2.GetModulus();
    Integer i2 = k1.GetPublicExponent() - k2.GetPublicExponent();

    cout &lt;&lt; i1 &lt;&lt; "" "" &lt;&lt; i2 &lt;&lt; endl;

} catch (const Exception&amp; ex) {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
}
</code></pre>

<hr>

<p>Related, the encapsulation boundaries (<code>-----BEGIN PUBLIC KEY-----</code> and <code>-----END PUBLIC KEY-----</code>) should be on their own lines. Instead of a space, you should use a new line (<code>\n</code>). So something like:</p>

<pre><code>string enc=rsa_encrypt(
    ""hola mundo"",
    ""-----BEGIN PUBLIC KEY-----\nMIGeMA0G...gMBAAE=\n-----END PUBLIC KEY-----""
    );
</code></pre>

<p>And:</p>

<pre><code>string aaa=rsa_decrypt(
    enc,
    ""-----BEGIN RSA PRIVATE KEY-----\nMIICWwIB...7rXPvA==\n-----END RSA PRIVATE KEY-----"",
    false
    );
</code></pre>

<hr>

<p>Related, you should probably use <code>RSAES_OAEP_SHA_Encryptor</code> and <code>RSAES_OAEP_SHA_Decryptor</code>. An aaproachable treatment is available at <a href=""http://blog.cryptographyengineering.com/2012/06/bad-couple-of-years-for-cryptographic.html"" rel=""nofollow"">A bad couple of years for the cryptographic token industry</a>.</p>
","224","<c++><crypto++>","2","1","1","2015-07-12 00:23:39","31360629","1","","-1","","2017-05-23 11:51:48","2015-07-11 17:31:13",""
"39963900","Crypto++ equivalent to PHP mcrypt_encrypt MCRYPT_3DES/MCRYPT_MODE_CBC","<p>I have the following PHP code to encrypt a text using a key:</p>

<pre class=""lang-php prettyprint-override""><code>function des_ed3_crypt($msg, $key) {
   $bytes = array(0,0,0,0,0,0,0,0);
   $iv=implode(array_map('chr', $bytes));

   return mcrypt_encrypt(MCRYPT_3DES, $key, $msg, MCRYPT_MODE_CBC, $iv);
}
</code></pre>

<p>And my corresponding C++ function, using Crypto++ is:</p>

<pre class=""lang-cxx prettyprint-override""><code>std::string des_ed3_crypt(std::string const&amp; msg, std::string const&amp; key)
{
    unsigned char iv[8] = { 0 }; // 0-filled

    CryptoPP::CBC_Mode&lt;CryptoPP::DES_EDE3&gt;::Encryption e;
    e.SetKeyWithIV(reinterpret_cast&lt;unsigned char const*&gt;(key.c_str()),
                   key.size(), iv);

    std::string ret;

    CryptoPP::StringSource(msg, true,
            new CryptoPP::StreamTransformationFilter
                 (e, new CryptoPP::StringSink(ret)));

    return ret;
}
</code></pre>

<p>But they don't return the same encrypted text. I want the change the C++ code to make equivalent to the PHP code, and not the opposite.</p>

<p>For the following key and message:</p>

<pre class=""lang-php prettyprint-override""><code>$key = ""keykeykeykeykeykeykeykey"";
$msg = $key;
</code></pre>

<p>The PHP code returns a cyphertext of 24 bytes (base64 encoded as):</p>

<pre class=""lang-none prettyprint-override""><code>a78URfI6EV8m3sTaDDDrntI8VbjWHiwm
</code></pre>

<p>But C++ returns a cyphertext of 32 bytes, but with a matching prefix of 24-bytes (base64 encoded as):</p>

<pre class=""lang-none prettyprint-override""><code>a78URfI6EV8m3sTaDDDrntI8VbjWHiwm9M15+pzUnuM=
</code></pre>

<p>So, there's some extra bytes in the C++ version which I don't know where do they come from. I think it can be related with the padding scheme, but I don't know the padding scheme used by PHP.</p>
","<p>Effectively, it was the padding. The PHP <code>mcrypt_crypto</code> function applies a zero-padding, so, I only have to specify to <code>cryptopp</code> that I want to apply a zero-padding to the encryption:</p>

<pre><code>std::string des_ed3_crypt(std::string const&amp; msg, std::string const&amp; key)
{
    unsigned char iv[8] = { 0 }; // 0-filled

    CryptoPP::CBC_Mode&lt;CryptoPP::DES_EDE3&gt;::Encryption e;
    e.SetKeyWithIV(reinterpret_cast&lt;unsigned char const*&gt;(key.c_str()),
                   key.size(), iv);

    std::string ret;

    CryptoPP::StringSource(msg, true,
        new CryptoPP::StreamTransformationFilter
            (e, new CryptoPP::StringSink(ret),
             CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme::ZEROS_PADDING));

    return ret;
}
</code></pre>
","221","<php><c++><crypto++><3des>","1","1","1","2016-10-12 20:50:10","39966278","0","","1794803","","2016-10-12 20:50:10","2016-10-10 17:45:12",""
"49079700","DER Encoding Public Key created by cryptopp is different then openssl","<p>I've been trying to create a DER encoded public key using an RSA private key.  The way I normally create it is using the command line:</p>

<pre><code>openssl rsa -pubout -outform DER -in ~/.keys/api_key.pem -out der_pub.der
</code></pre>

<p>When I use CryptoPP to create this file, they are slightly different.  It seems it has an extra section.  The one created by openssl has a little extra section. I'm assuming this is the BIT STRING mentioned in the CryptoPP API. <a href=""https://www.cryptopp.com/docs/ref/class_r_s_a_function.html"" rel=""nofollow noreferrer"">https://www.cryptopp.com/docs/ref/class_r_s_a_function.html</a></p>

<pre><code>void    DEREncodePublicKey (BufferedTransformation &amp;bt) const
encode subjectPublicKey part of subjectPublicKeyInfo, without the BIT STRING header 
</code></pre>

<p>This is what my code looks like:</p>

<pre><code>    ...
    CryptoPP::RSA::PrivateKey rsaPrivate;
    rsaPrivate.BERDecodePrivateKey(queue, false /*paramsPresent*/, queue.MaxRetrievable());

    CryptoPP::ByteQueue bq;
    rsaPrivate.DEREncodePublicKey(bq);
    CryptoPP::FileSink fs1(""cryptopp_pub.der"", true);
    bq.TransferTo(fs1);
</code></pre>
","<blockquote>
  <p><a href=""https://www.cryptopp.com/docs/ref/class_r_s_a_function.html#ab962ade2ef1ddd37fdef57fe7e5e5a40"" rel=""nofollow noreferrer"">CryptoPP::RSA::DEREncodePublicKey</a> encodes subjectPublicKey part of subjectPublicKeyInfo, <em>without the BIT STRING header</em></p>
</blockquote>

<p>Try <code>CryptoPP::RSA::PublicKey::DEREncode</code>. Being careful to apply this to only the <em>public</em> key, as RSA::PrivateKey does overload the DEREncode method.</p>

<p>Here I'm using CryptoPP 8.2</p>

<ol>
<li><p>Load DER encoded private key from disk</p>

<pre class=""lang-cpp prettyprint-override""><code>CryptoPP::RSA::PrivateKey private_key;
{
    CryptoPP::FileSource file{""my.key"", true};
    private_key.BERDecodePrivateKey(file, false, -1);
}
</code></pre></li>
<li><p>Save out DER encoded public key</p>

<pre class=""lang-cpp prettyprint-override""><code>CryptoPP::FileSink sink{""my.pub"", true};
CryptoPP::RSA::PublicKey{private_key}.DEREncode(sink);
</code></pre></li>
</ol>

<p>OpenSSL:</p>

<pre class=""lang-sh prettyprint-override""><code># generate a new RSA private key (DER format)
openssl genrsa | openssl rsa -outform DER -out my.key

# hash/fingerprint the public key
openssl rsa -in my.key -inform DER -pubout -outform DER | openssl sha256
writing RSA key
362945ad4a5f87f27d3db3b4adbacaee0ebc3f778ee2fe76ef4fb09933148372

# compare against hash of our code sample's generated public key
cat my.pub | openssl sha256
362945ad4a5f87f27d3db3b4adbacaee0ebc3f778ee2fe76ef4fb09933148372
</code></pre>

<hr>

<p>As another example; if we want CryptoPP to generate a SHA256 fingerprint:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::string hash_out_str;
{
    CryptoPP::SHA256 sha256;
    CryptoPP::HashFilter filter{
        sha256,
        new CryptoPP::HexEncoder{
            new CryptoPP::StringSink{hash_out_str}
        }
    };
    CryptoPP::RSA::PublicKey{private_key}.DEREncode(filter); // intentionally slice to ensure we aren't exposing a public key
    filter.MessageEnd();
}
std::cout &lt;&lt; hash_out_str &lt;&lt; '\n';
</code></pre>

<p>Outputs:</p>

<pre><code>362945AD4A5F87F27D3DB3B4ADBACAEE0EBC3F778EE2FE76EF4FB09933148372
</code></pre>

<p>i.e., we need to copy/slice to a RSA::PublicKey to invoke the OpenSSL compatible DER encoding method</p>
","219","<crypto++>","0","1","1","2019-04-30 23:27:08","55929877","3","","","","","2018-03-03 01:23:04",""
"8336778","Different programs calling the same function with same input, but having different output?","<p>I am trying to work on s3fs, a FUSE-based file system to backup data in Amazon cloud side. In my implementation, I developed two functions using AES:CBC in crypto++ to encrypt and decrypt data in a file. My problem is, when I use the decrypting function in s3fs to decrypt a txt file X, the result is always wrong in the same location of X but with different results. However, if I call the same function to decrypt file X using another test program, not in s3fs, the result is always correct. My system is Ubuntu with kernel 2.6.32-35, FUSE 2.8.6. I am implementing using C++. Thanks.</p>

<p>PS: The encryption function works both in s3fs program and other test programs because the encryption output of the same source file are the same. Only decryption function in s3fs program yields the wrong output.</p>
","","218","<c++><fuse><crypto++><s3fs>","0","","0","2011-12-01 14:26:39","","2","","982344","","2011-12-01 14:26:39","2011-12-01 05:05:58",""
"35734114","Crypto++ exception calling messageEnd","<p>I use following code to decrypt a file: </p>

<pre><code>FileSource fe(fileUrl.c_str(), false,
                  new AuthenticatedDecryptionFilter(decryptor, new FileSink(
                          std::string(fileUrl).c_str()), CryptoPP::AuthenticatedDecryptionFilter::THROW_EXCEPTION |  CryptoPP::AuthenticatedDecryptionFilter::MAC_AT_END ));

        size_t BLOCK_SIZE = 16384;
    while (remaining &amp;&amp; !fe.SourceExhausted()) {
        const unsigned int req = STDMIN(remaining, BLOCK_SIZE);
        fe.Pump(req);
        fe.Flush(false);

        remaining -= req;
    }
    fe.MessageEnd();
</code></pre>

<p>If i try to do this without the fe.MessageEnd(), my decrypted File is 16 bytes short. So i thought i need to call MessageEnd() to fix this problem.
But if i call MessageEnd() i get Follwing Exception: BufferedTransformation: this object doesn't allow input</p>
","<blockquote>
  <p>if i call MessageEnd() I get Follwing Exception: <strong><em><code>BufferedTransformation: this object doesn't allow input</code></em></strong>...</p>
</blockquote>

<p>Correct. The <code>FileSource</code> is a source, and the message must exist. You can't call <code>Put</code> or <code>Put2</code> on the source to add additional data to the message.</p>

<hr>

<p>I think you have two options to take more control over the signals.</p>

<p><strong><em>First</em></strong></p>

<p>Call <code>Flush</code> on the <code>Source</code>.</p>

<pre class=""lang-c++ prettyprint-override""><code>const int opts = AuthenticatedDecryptionFilter::THROW_EXCEPTION |
    AuthenticatedDecryptionFilter::MAC_AT_END;

FileSource fe(fileUrl.c_str(), false,
    new AuthenticatedDecryptionFilter(decryptor, new FileSink(
        std::string(fileUrl).c_str()), opts));

fe.Flush(true);
</code></pre>

<p>Also see the comments for <code>Flush</code> at <a href=""https://www.cryptopp.com/docs/ref/class_filter.html#ad845deb5113d2bd04d109c05abfd3098"" rel=""nofollow"">Filter::Flush</a> in the manual.</p>

<p><strong><em>Second</em></strong></p>

<p>Stash a pointer to the filter and call <code>MessageEnd</code> on it.</p>

<pre class=""lang-c++ prettyprint-override""><code>const int opts = AuthenticatedDecryptionFilter::THROW_EXCEPTION |
     AuthenticatedDecryptionFilter::MAC_AT_END;
AuthenticatedDecryptionFilter* adf = NULL;

FileSource fe(fileUrl.c_str(), false,
    adf = new AuthenticatedDecryptionFilter(decryptor, new FileSink(
        std::string(fileUrl).c_str()), opts));
adf.MessageEnd();
</code></pre>

<p>This is kind of unusual, so I'm not sure what side effects you will encounter.</p>

<p>Don't delete the pointer. The <code>FileSource</code> will delete it when it goes out of scope at the closing brace.</p>

<hr>

<blockquote>
  <p>... my decrypted file is 16 bytes short...</p>
</blockquote>

<p>In my opinion, this is the problem you should pursue if calling <code>Flush</code> on the <code>Source</code> does not work for you.</p>

<p>Also keep in mind... The output of <strong><em><code>AuthenticatedEncryptionFilter</code></em></strong> is the 2-tuple <strong><em><code>{ciphertext,mac}</code></em></strong>, so you get ciphertext expansion of 16-bytes because of the MAC. Later, when you use <strong><em><code>AuthenticatedDecryptionFilter</code></em></strong>, the mac is removed after verifying it. So the recovered text should be the same size as the plain text, both of which should be 16-bytes less than the cipher text.</p>

<p>The thing I am not clear about is, are things working as expected but you don't realize that's how its supposed to work. Or are you really loosing 16-bytes of recovered text somewhere.</p>
","218","<c++><encryption><crypto++>","1","1","1","2016-03-02 01:49:46","35736976","0","","","","","2016-03-01 21:42:27",""
"17491711","Format-preserving encryption with Crypto++","<p>is it possible to perform FPE with the Crypto++ library?</p>

<p>Thank you</p>
","<blockquote>
  <p>Is it possible to perform FPE with the Crypto++ library?</p>
</blockquote>

<p>Well, it depends on how you define Format Preserving Encryption.</p>

<p>In <a href=""http://www.voltage.com/wp-content/uploads/UCSD_Rogaway_Synopsis_Format_Preserving_Encyption-1.pdf"" rel=""nofollow"">A Synopsis of Format-Preserving Encryption</a>, Phillip Rogaway stated: ""... it is my view that the cryptographic literature already contains good solutions for FPE but that, at least until quite recently, the ideas were scattered about, not widely known, and not cohesively described.""</p>

<p>If you are talking about Bellare, Spies and Rogaway's FFX mode of operation proposed to NIST circa 2010, then the answer is no. Crypto++ does not have FFX mode.</p>
","218","<encryption><crypto++>","0","0","1","2013-10-04 02:59:55","","2","","","","","2013-07-05 14:54:10",""
"27551994","AES decryption 16 bytes of junk in the beginning of decrypted text","<p>I am having a AES encrypted text which was encrypted using Java in a binary file. This is the input i use to decrypt using CryptoPP AES in c++
I am able to decrypt the text with the code. But i get some junk characters in the beginning of the decrypted text. 
I tried removing the first 16 bytes of data in the binary file assuming this would have been the IV. but that is data and not IV in the binary text.</p>

<p>Here is the code i use.</p>

<pre><code>int main(int argc, char* argv[])
{
    try
    {
    string recovered;   

    // Generate Cipher, Key, and CBC
    byte key[ AES::DEFAULT_KEYLENGTH ], iv[ AES::BLOCKSIZE ];
    string sss = ""9F28872C88AC24D0D1333DAAC6600A77"";

    StringSource ss1((const byte*)sss.c_str(), sss.length(), true,
                 new HexDecoder(new CryptoPP::ArraySink(key, AES::DEFAULT_KEYLENGTH)));

    memset( iv, 0x00, AES::BLOCKSIZE );

        string encoded;

        CBC_Mode&lt; AES &gt;::Decryption d;


        d.SetKeyWithIV(key, sizeof(key),iv);

        CryptoPP::FileSource file_source(""DecodedBase64-1.bin"", true,new CryptoPP::StreamTransformationFilter(d,new CryptoPP::StringSink(recovered)));

        cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; endl;

    }
    catch(const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        exit(1);
    }

    /*********************************\
    \*********************************/

    return 0;
}
</code></pre>
","","213","<c++><crypto++>","0","","0","2014-12-19 06:17:31","","2","","608639","","2014-12-19 06:17:31","2014-12-18 17:08:47",""
"25258857","Link errors with AutoSeededRandomPool when using Xcode and libc++","<p>Trying to develop simple c++ stuff in xcode for the first time. I haven't done c++ for a while, nor do I usually use a mac so bear with me if this is trivial.</p>

<p>I have simply grabbed the AutoSeededRandomPool example source from here: <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator#AutoSeededRandomPool"" rel=""nofollow"">http://www.cryptopp.com/wiki/RandomNumberGenerator#AutoSeededRandomPool</a></p>

<p>I used macports to grab libcryptopp +universal (the non universal one didnt work either though), and I have added libcryptopp.a to the 'link binaries with  libraries' build phase for my target.</p>

<p>During the build I get 22 errors, which you can see for yourself here: <a href=""http://i.imgur.com/wIhEQot.jpg"" rel=""nofollow"">http://i.imgur.com/wIhEQot.jpg</a></p>

<p>Using xcode 4.6.2 on oldish Lion OS X macbook pro.</p>

<p>Have I missed something obvious here? Thanks for your help</p>
","<p>You're not using the correct compiler — The project you mention states the requirement is:</p>

<ul>
<li>Xcode 3.2.5,</li>
<li>Xcode 4.0 and GCC 4.2, </li>
<li>targeting Apple iOS</li>
</ul>

<p>...It appears you're using <code>clang++</code></p>

<p><a href=""http://www.cryptopp.com/#platforms"" rel=""nofollow"">http://www.cryptopp.com/#platforms</a></p>

<p>Also this says iOS, not OS X - That could certainly cause some issues as well. Why bother messing with this crypto library anyway? Use Apple's or one that was meant specifically to be used with OS X. It's of course your choice, but it certainly doesn't make it any easier going  this route.</p>
","212","<c++><xcode><macos><crypto++>","1","2","2","2014-08-13 05:08:04","25276500","1","","608639","","2014-08-13 05:08:04","2014-08-12 07:49:03",""
"25258857","Link errors with AutoSeededRandomPool when using Xcode and libc++","<p>Trying to develop simple c++ stuff in xcode for the first time. I haven't done c++ for a while, nor do I usually use a mac so bear with me if this is trivial.</p>

<p>I have simply grabbed the AutoSeededRandomPool example source from here: <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator#AutoSeededRandomPool"" rel=""nofollow"">http://www.cryptopp.com/wiki/RandomNumberGenerator#AutoSeededRandomPool</a></p>

<p>I used macports to grab libcryptopp +universal (the non universal one didnt work either though), and I have added libcryptopp.a to the 'link binaries with  libraries' build phase for my target.</p>

<p>During the build I get 22 errors, which you can see for yourself here: <a href=""http://i.imgur.com/wIhEQot.jpg"" rel=""nofollow"">http://i.imgur.com/wIhEQot.jpg</a></p>

<p>Using xcode 4.6.2 on oldish Lion OS X macbook pro.</p>

<p>Have I missed something obvious here? Thanks for your help</p>
","<p>I have found the source of the problem was linking with the libc++ standard library rather than the more standard libstdc++ library. Xcode and Mac OS X targets were not a problem.</p>

<p>If I link against libstdc++ then the linking errors disappear. For future reference the giveaway seems to be the std::<strong>__1</strong> namespacing visible in the errors, although with hindsight perhaps it should have been obvious that a library ported from linux would most likely be using the libstdc++ library.</p>
","212","<c++><xcode><macos><crypto++>","1","1","2","2014-08-13 05:08:04","25276500","1","","608639","","2014-08-13 05:08:04","2014-08-12 07:49:03",""
"7948610","Put in a string the output of autoseed PNRG in Crypto++","<p>I'm using Cryptopp to generate a random string.
This is the code:</p>

<pre><code>const unsigned int BLOCKSIZE = 16 * 8;
byte pcbScratch[ BLOCKSIZE ];

// Construction
//   Using a ANSI approved Cipher
CryptoPP::AutoSeededX917RNG&lt;CryptoPP::DES_EDE3&gt; rng;

rng.GenerateBlock( pcbScratch, BLOCKSIZE );

// Output
std::cout &lt;&lt; ""The generated random block is:"" &lt;&lt; std::endl;
string str = """";

for( unsigned int i = 0; i &lt; BLOCKSIZE; i++ )
{
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::setbase(16) &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');
    std::cout &lt;&lt; static_cast&lt;unsigned int&gt;( pcbScratch[ i ] ) &lt;&lt; "" "";
    str += pcbScratch[i];
}
std::cout &lt;&lt; std::endl;
std::cout &lt;&lt; str &lt;&lt;std::endl;
</code></pre>

<p>I've put int the code a new var: <code>string str = """"</code>.
Then in the for append for each result, the part of the string.
But my output is dirty! I see only strange ASCII char.
How can I set well the string?</p>

<p>Thank you.</p>
","<p>You will want to some output encoding, e.g.</p>

<ul>
<li>base64</li>
<li>hex </li>
</ul>

<p>because what you are seeing is the raw binary data, interpreted as if it were text. Random characters are the consequence</p>

<p>AFAICT (google) you should be able to use something like this</p>

<pre><code>#include &lt;base64.h&gt;

string base64encoded; 
StringSource(str, true, new Base64Encoder(new StringSink(base64encoded)));
</code></pre>
","212","<c++><prng><crypto++>","2","1","3","2014-04-17 06:13:08","","0","","187543","","2011-10-30 23:27:16","2011-10-30 23:16:28",""
"7948610","Put in a string the output of autoseed PNRG in Crypto++","<p>I'm using Cryptopp to generate a random string.
This is the code:</p>

<pre><code>const unsigned int BLOCKSIZE = 16 * 8;
byte pcbScratch[ BLOCKSIZE ];

// Construction
//   Using a ANSI approved Cipher
CryptoPP::AutoSeededX917RNG&lt;CryptoPP::DES_EDE3&gt; rng;

rng.GenerateBlock( pcbScratch, BLOCKSIZE );

// Output
std::cout &lt;&lt; ""The generated random block is:"" &lt;&lt; std::endl;
string str = """";

for( unsigned int i = 0; i &lt; BLOCKSIZE; i++ )
{
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::setbase(16) &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');
    std::cout &lt;&lt; static_cast&lt;unsigned int&gt;( pcbScratch[ i ] ) &lt;&lt; "" "";
    str += pcbScratch[i];
}
std::cout &lt;&lt; std::endl;
std::cout &lt;&lt; str &lt;&lt;std::endl;
</code></pre>

<p>I've put int the code a new var: <code>string str = """"</code>.
Then in the for append for each result, the part of the string.
But my output is dirty! I see only strange ASCII char.
How can I set well the string?</p>

<p>Thank you.</p>
","<p>Appending arbitrary bytes (chars) to the end of a string is going to result in that containing some non-printable characters:</p>

<p><a href=""http://en.wikipedia.org/wiki/Control_character"" rel=""nofollow"">http://en.wikipedia.org/wiki/Control_character</a></p>

<p>You don't mention what you wanted or expected.  Did you want the string to be the same as what got sent to std::cout?  If so, you can use a stringstream via <code>#include &lt;sstream&gt;</code>:</p>

<pre><code>std::stringstream ss;
for( unsigned int i = 0; i &lt; BLOCKSIZE; i++ )
{
    ss &lt;&lt; ""0x"" &lt;&lt; std::setbase(16) &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');
    ss &lt;&lt; static_cast&lt;unsigned int&gt;(pcbScratch[i]);
}
str = ss.str();
</code></pre>
","212","<c++><prng><crypto++>","2","1","3","2014-04-17 06:13:08","","0","","187543","","2011-10-30 23:27:16","2011-10-30 23:16:28",""
"7948610","Put in a string the output of autoseed PNRG in Crypto++","<p>I'm using Cryptopp to generate a random string.
This is the code:</p>

<pre><code>const unsigned int BLOCKSIZE = 16 * 8;
byte pcbScratch[ BLOCKSIZE ];

// Construction
//   Using a ANSI approved Cipher
CryptoPP::AutoSeededX917RNG&lt;CryptoPP::DES_EDE3&gt; rng;

rng.GenerateBlock( pcbScratch, BLOCKSIZE );

// Output
std::cout &lt;&lt; ""The generated random block is:"" &lt;&lt; std::endl;
string str = """";

for( unsigned int i = 0; i &lt; BLOCKSIZE; i++ )
{
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::setbase(16) &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');
    std::cout &lt;&lt; static_cast&lt;unsigned int&gt;( pcbScratch[ i ] ) &lt;&lt; "" "";
    str += pcbScratch[i];
}
std::cout &lt;&lt; std::endl;
std::cout &lt;&lt; str &lt;&lt;std::endl;
</code></pre>

<p>I've put int the code a new var: <code>string str = """"</code>.
Then in the for append for each result, the part of the string.
But my output is dirty! I see only strange ASCII char.
How can I set well the string?</p>

<p>Thank you.</p>
","<p>You can also use Crypto++'s built in <code>HexEncoder</code>:</p>

<pre><code>std::cout &lt;&lt; ""The generated random block is:"" &lt;&lt; std::endl;
string str = ""0x"";

StringSource ss(pcbScratch, BLOCKSIZE, true,
    new HexEncoder(
        new StringSink(str),
        true,   // uppercase
        2,      // grouping
        "" 0x""   // separator
    ) // HexDecoder
); // StringSource
</code></pre>

<p>The <code>StringSource</code> 'owns' the <code>HexEncoder</code>, so there's no need to call <code>delete</code>.</p>
","212","<c++><prng><crypto++>","2","0","3","2014-04-17 06:13:08","","0","","187543","","2011-10-30 23:27:16","2011-10-30 23:16:28",""
"34048195","Cryptopp fatal signal 11","<p>Here is log1 aplication output:</p>

<pre><code>   :    ... 25 more
W/System.err( 1500): java.lang.ClassNotFoundException: android.graphics.drawable.VectorDrawable
W/System.err( 1500):    at java.lang.Class.classForName(Native Method)
W/System.err( 1500):    at java.lang.Class.forName(Class.java:217)
W/System.err( 1500):    at java.lang.Class.forName(Class.java:172)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.getClass(ExtractStyle.java:388)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.&lt;init&gt;(ExtractStyle.java:94)
W/System.err( 1500):    at org.qtproject.qt5.android.QtActivityDelegate.loadApplication(QtActivityDelegate.java:430)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.loadApplication(QtActivity.java:245)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.startApp(QtActivity.java:655)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.onCreate(QtActivity.java:895)
W/System.err( 1500):    at android.app.Activity.performCreate(Activity.java:5275)
W/System.err( 1500):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1082)
W/System.err( 1500):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2049)
W/System.err( 1500):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2110)
W/System.err( 1500):    at android.app.ActivityThread.access$600(ActivityThread.java:138)
W/System.err( 1500):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1205)
W/System.err( 1500):    at android.os.Handler.dispatchMessage(Handler.java:99)
W/System.err( 1500):    at android.os.Looper.loop(Looper.java:137)
W/System.err( 1500):    at android.app.ActivityThread.main(ActivityThread.java:4950)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:565)
W/System.err( 1500):    at dalvik.system.NativeStart.main(Native Method)
W/System.err( 1500): Caused by: java.lang.NoClassDefFoundError: android/graphics/drawable/VectorDrawable
W/System.err( 1500):    ... 25 more
W/System.err( 1500): Caused by: java.lang.ClassNotFoundException: android.graphics.drawable.VectorDrawable
W/System.err( 1500):    at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:61)
W/System.err( 1500):    at java.lang.ClassLoader.loadClass(ClassLoader.java:501)
W/System.err( 1500):    at java.lang.ClassLoader.loadClass(ClassLoader.java:461)
W/System.err( 1500):    ... 25 more
W/System.err( 1500): java.lang.NoSuchFieldException: View_paddingStart
W/System.err( 1500):    at java.lang.Class.getDeclaredField(Class.java:631)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.getField(ExtractStyle.java:427)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.&lt;init&gt;(ExtractStyle.java:173)
W/System.err( 1500):    at org.qtproject.qt5.android.QtActivityDelegate.loadApplication(QtActivityDelegate.java:430)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.loadApplication(QtActivity.java:245)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.startApp(QtActivity.java:655)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.onCreate(QtActivity.java:895)
W/System.err( 1500):    at android.app.Activity.performCreate(Activity.java:5275)
W/System.err( 1500):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1082)
W/System.err( 1500):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2049)
W/System.err( 1500):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2110)
W/System.err( 1500):    at android.app.ActivityThread.access$600(ActivityThread.java:138)
W/System.err( 1500):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1205)
W/System.err( 1500):    at android.os.Handler.dispatchMessage(Handler.java:99)
W/System.err( 1500):    at android.os.Looper.loop(Looper.java:137)
W/System.err( 1500):    at android.app.ActivityThread.main(ActivityThread.java:4950)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:565)
W/System.err( 1500):    at dalvik.system.NativeStart.main(Native Method)
W/System.err( 1500): java.lang.NoSuchFieldException: View_paddingEnd
W/System.err( 1500):    at java.lang.Class.getDeclaredField(Class.java:631)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.getField(ExtractStyle.java:427)
W/System.err( 1500):    at org.qtproject.qt5.android.ExtractStyle.&lt;init&gt;(ExtractStyle.java:174)
W/System.err( 1500):    at org.qtproject.qt5.android.QtActivityDelegate.loadApplication(QtActivityDelegate.java:430)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.loadApplication(QtActivity.java:245)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.startApp(QtActivity.java:655)
W/System.err( 1500):    at org.qtproject.qt5.android.bindings.QtActivity.onCreate(QtActivity.java:895)
W/System.err( 1500):    at android.app.Activity.performCreate(Activity.java:5275)
W/System.err( 1500):    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1082)
W/System.err( 1500):    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2049)
W/System.err( 1500):    at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2110)
W/System.err( 1500):    at android.app.ActivityThread.access$600(ActivityThread.java:138)
W/System.err( 1500):    at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1205)
W/System.err( 1500):    at android.os.Handler.dispatchMessage(Handler.java:99)
W/System.err( 1500):    at android.os.Looper.loop(Looper.java:137)
W/System.err( 1500):    at android.app.ActivityThread.main(ActivityThread.java:4950)
W/System.err( 1500):    at java.lang.reflect.Method.invokeNative(Native Method)
W/System.err( 1500):    at java.lang.reflect.Method.invoke(Method.java:511)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:798)
W/System.err( 1500):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:565)
W/System.err( 1500):    at dalvik.system.NativeStart.main(Native Method)
D/dalvikvm( 1500): GC_CONCURRENT freed 494K, 14% free 5744K/6663K, paused 81ms+191ms, total 320ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 18ms
W/ResourceType( 1500): Skipping entry 0x10804c7 in package table 0 because it is not complex!
D/dalvikvm( 1500): GC_CONCURRENT freed 462K, 14% free 5843K/6727K, paused 34ms+3ms, total 75ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 18ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 541K, 15% free 5829K/6791K, paused 18ms, total 18ms
D/dalvikvm( 1500): GC_CONCURRENT freed 409K, 13% free 5932K/6791K, paused 55ms+3ms, total 95ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 40ms
D/dalvikvm( 1500): GC_CONCURRENT freed 501K, 14% free 5990K/6919K, paused 67ms+2ms, total 100ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 36ms
D/dalvikvm( 1500): GC_CONCURRENT freed 544K, 15% free 5999K/6983K, paused 2ms+3ms, total 63ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 44ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 477K, 14% free 6032K/6983K, paused 17ms, total 18ms
D/dalvikvm( 1500): GC_CONCURRENT freed 479K, 14% free 6065K/6983K, paused 63ms+2ms, total 106ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 43ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 489K, 14% free 6072K/7047K, paused 19ms, total 20ms
D/dalvikvm( 1500): GC_CONCURRENT freed 438K, 13% free 6137K/7047K, paused 31ms+3ms, total 72ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 43ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 299K, 14% free 6143K/7111K, paused 19ms, total 19ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 30K, 14% free 6156K/7111K, paused 19ms, total 19ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 38K, 14% free 6149K/7111K, paused 19ms, total 19ms
D/dalvikvm( 1500): GC_FOR_ALLOC freed 499K, 14% free 6158K/7111K, paused 20ms, total 21ms
D/dalvikvm( 1500): GC_CONCURRENT freed 531K, 14% free 6138K/7111K, paused 17ms+3ms, total 80ms
D/dalvikvm( 1500): WAIT_FOR_CONCURRENT_GC blocked 63ms
I/Adreno200-EGL( 1500): &lt;qeglDrvAPI_eglInitialize:299&gt;: EGL 1.4 QUALCOMM build: AU_LINUX_ANDROID_JB_REL_2.0.3_RB3.04.01.01.42.006_msm7627a_JB_REL_2.0.3_Merge_release_AU (Merge)
I/Adreno200-EGL( 1500): Build Date: 04/01/13 Mon
I/Adreno200-EGL( 1500): Local Branch:
I/Adreno200-EGL( 1500): Remote Branch: m/jb_rel_2.0.3
I/Adreno200-EGL( 1500): Local Patches: NONE
I/Adreno200-EGL( 1500): Reconstruct Branch: NOTHING
I/Choreographer( 1500): Skipped 31 frames!  The application may be doing too much work on its main thread.
D/libtestAndroid4.so( 1500): (null):0 ((null)): -----------------------------P-8------------------------------------
D/libtestAndroid4.so( 1500): (null):0 ((null)): -----------------------------P-9------------------------------------
W/IInputConnectionWrapper( 1500): getCursorCapsMode on inactive InputConnection
D/libtestAndroid4.so( 1500): (null):0 ((null)): -----------------------------P-2------------------------------------
F/libc    ( 1500): Fatal signal 11 (SIGSEGV) at 0x007a7a76 (code=1), thread 1567 (le.testAndroid4)
I/DEBUG   (  147): pid: 1500, tid: 1567, name: le.testAndroid4  &gt;&gt;&gt; org.qtproject.example.testAndroid4 &lt;&lt;&lt;


""org.qtproject.example.testAndroid4"" died.
</code></pre>

<p>log1 compile output:</p>

<pre><code>Android package built successfully in 29.282 ms.
  -- It can now be run from the selected device/emulator.
  -- File: C:/Users/niki/Documents/build-testAndroid4-Android_for_armeabi_v7a_GCC_4_9_Qt_5_5_1-Release/android-build//bin/QtApp-debug.apk
3064 KB/s (15889430 bytes in 5.064s)
11:15:26: The process ""C:/Qt/5.5/android_armv7/bin/androiddeployqt.exe"" exited normally.
11:15:26: Pulling files necessary for debugging.
11:15:26: Package deploy: Running command ""C:/Users/niki/AppData/Local/Android/android-sdk/platform-tools/adb.exe -s LGOTMS328ac0aa pull /system/bin/sh: readlink: not found C:/Users/niki/Documents/build-testAndroid4-Android_for_armeabi_v7a_GCC_4_9_Qt_5_5_1-Release/app_process"".
11:15:26: Packaging error: Command ""C:/Users/niki/AppData/Local/Android/android-sdk/platform-tools/adb.exe -s LGOTMS328ac0aa pull /system/bin/sh: readlink: not found C:/Users/niki/Documents/build-testAndroid4-Android_for_armeabi_v7a_GCC_4_9_Qt_5_5_1-Release/app_process"" failed.Exit code: 1
11:15:26: Package deploy: Running command ""C:/Users/niki/AppData/Local/Android/android-sdk/platform-tools/adb.exe -s LGOTMS328ac0aa pull /system/lib/libc.so C:/Users/niki/Documents/build-testAndroid4-Android_for_armeabi_v7a_GCC_4_9_Qt_5_5_1-Release/libc.so"".
11:15:26: Elapsed time: 00:53.
</code></pre>

<p>log2 application output:</p>

<pre><code> ...
    I/Adreno200-EGL( 3188): Build Date: 04/01/13 Mon
    I/Adreno200-EGL( 3188): Local Branch:
    I/Adreno200-EGL( 3188): Remote Branch: m/jb_rel_2.0.3
    I/Adreno200-EGL( 3188): Local Patches: NONE
    I/Adreno200-EGL( 3188): Reconstruct Branch: NOTHING
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-8------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-9------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-2------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-3------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-4------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-5------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-10------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-1------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-11------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-12------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-2------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-3------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-4------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-5------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-13------------------------------------
    D/libtestAndroid4.so( 3188): (null):0 ((null)): -----------------------------P-14------------------------------------
    F/libc    ( 3188): Fatal signal 11 (SIGSEGV) at 0xdeadcab1 (code=1), thread 3269 (le.testAndroid4)
    I/DEBUG   (  147): pid: 3188, tid: 3269, name: le.testAndroid4  &gt;&gt;&gt; org.qtproject.example.testAndroid4 &lt;&lt;&lt;
    I/ActivityManager(  457): Process org.qtproject.example.testAndroid4 (pid 3188) has died.


    ""org.qtproject.example.testAndroid4"" died.
</code></pre>

<p>Now the source code:</p>

<p><strong>logindialog.h</strong></p>

<pre><code>#ifndef LOGINDIALOG_H
#define LOGINDIALOG_H

#include &lt;QDialog&gt;
#include &lt;QDebug&gt;
namespace Ui {
class loginDialog;
}

class loginDialog : public QDialog
{
    Q_OBJECT

public:
    explicit loginDialog(QWidget *parent = 0);
    ~loginDialog();
    bool isDecrypted();
    std::string getPassword();

private slots:
    void on_passwordButton_clicked();

private:
    Ui::loginDialog *ui;
    bool decrypted;
    std::string password;
};

#endif // LOGINDIALOG_H
</code></pre>

<p><strong>mainwindow.h</strong></p>

<pre><code>#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &lt;QMainWindow&gt;

#include &lt;fstream&gt; 
//#include &lt;sha.h&gt;
//#include &lt;pwdbased.h&gt;
//#include &lt;osrng.h&gt;
//#include &lt;sstream&gt;
//#include &lt;iomanip&gt;
//#include &lt;cryptlib.h&gt;
//using CryptoPP::Exception;

//#include &lt;hex.h&gt;
//using CryptoPP::HexEncoder;
//using CryptoPP::HexDecoder;

//#include &lt;filters.h&gt;
//using CryptoPP::StringSink;
#include ""logindialog.h""
#include &lt;QMessageBox&gt;
#include &lt;QDebug&gt;
namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();

private slots:    
    void on_pushButton_2_clicked();
    void on_pushButton_clicked();
private:
    Ui::MainWindow *ui;
    bool getEnterPassword(std::string &amp;);
};

#endif // MAINWINDOW_H
</code></pre>

<p><strong>logindialog.cpp</strong></p>

<pre><code>#include ""logindialog.h""
#include ""ui_logindialog.h""

loginDialog::loginDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::loginDialog)
{
    ui-&gt;setupUi(this);
}

loginDialog::~loginDialog()
{
    delete ui;
}

void loginDialog::on_passwordButton_clicked()
{
     qDebug() &lt;&lt; ""-----------------------------P-2------------------------------------"";
    this-&gt;password = ui-&gt;lineEdit-&gt;text().toStdString();
      qDebug() &lt;&lt; ""-----------------------------P-3------------------------------------"";
    this-&gt;decrypted = true; //TODO decrypt the file and if there is exception set as false
       qDebug() &lt;&lt; ""-----------------------------P-4------------------------------------"";
    this-&gt;accept();
        qDebug() &lt;&lt; ""-----------------------------P-5------------------------------------"";
}

bool loginDialog::isDecrypted()
{
    return this-&gt;decrypted;
}

std::string loginDialog::getPassword()
{
    return this-&gt;password;
}
</code></pre>

<p><strong>mainwindow.cpp</strong></p>

<pre><code>#include ""mainwindow.h""
#include ""ui_mainwindow.h""

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::on_pushButton_clicked()
{
    byte ivec[16];
    byte salt[32];

    CryptoPP::OS_GenerateRandomBlock(false, salt, sizeof(salt));
    CryptoPP::OS_GenerateRandomBlock(false, ivec, sizeof(ivec));

    std::string v;

    CryptoPP::HexEncoder hex(new CryptoPP::StringSink(v));
    hex.Put(salt, sizeof(salt));
    hex.MessageEnd();

    QMessageBox::about(this,tr(""Test1""),tr(v.c_str()));
    QMessageBox::about(this,tr(""Test1""),tr(""XXX""));
}

void MainWindow::on_pushButton_2_clicked()
{   
    std::string password;
    if(getEnterPassword(password)==false)
    {
        QMessageBox::about(this,tr(""Failed""),tr(""Password does not match!""));
    }
    else
    {
        QMessageBox::about(this,tr(""Failed""),tr(""Password match!""));
    }
}

bool MainWindow::getEnterPassword(std::string &amp;password)
{
loginDialog passwordWindow;
qDebug() &lt;&lt; ""-----------------------------P-8------------------------------------"";
passwordWindow.setModal(true);
qDebug() &lt;&lt; ""-----------------------------P-9------------------------------------"";
passwordWindow.exec();
qDebug() &lt;&lt; ""-----------------------------P-10------------------------------------"";

qDebug() &lt;&lt; ""-----------------------------P-1------------------------------------"";
loginDialog passwordWindowRe;
qDebug() &lt;&lt; ""-----------------------------P-11------------------------------------"";
passwordWindowRe.setModal(true);
qDebug() &lt;&lt; ""-----------------------------P-12------------------------------------"";
passwordWindowRe.exec();
qDebug() &lt;&lt; ""-----------------------------P-13------------------------------------"";

//qDebug() &lt;&lt; passwordWindow.getPassword().c_str();
//qDebug() &lt;&lt; passwordWindowRe.getPassword().c_str();

qDebug() &lt;&lt; ""-----------------------------P-14------------------------------------"";
if(passwordWindow.getPassword() == passwordWindowRe.getPassword())
{
    qDebug() &lt;&lt; ""-----------------------------P-15------------------------------------"";
    password = passwordWindow.getPassword();
    qDebug() &lt;&lt; ""-----------------------------P-16------------------------------------"";
    return true;
    qDebug() &lt;&lt; ""-----------------------------P-17------------------------------------"";
}
else
{
   qDebug() &lt;&lt; ""-----------------------------P-18------------------------------------"";
   return false;
}
}
</code></pre>

<p>And the most important:
<strong>testAndroid4.pro</strong></p>

<pre><code>#-------------------------------------------------
#
# Project created by QtCreator 2015-12-02T17:56:00
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = testAndroid4
TEMPLATE = app


SOURCES += main.cpp\
        mainwindow.cpp \
    logindialog.cpp

HEADERS  += mainwindow.h \
    logindialog.h

FORMS    += mainwindow.ui \
    logindialog.ui

CONFIG += mobility
MOBILITY = 


INCLUDEPATH += C:\Temp\openssl\OpenSSL-for-Android-Prebuilt\openssl-1.0.2\include\

LIBS += -LC:\Temp\openssl\OpenSSL-for-Android-Prebuilt\openssl-1.0.2\armeabi-v7a\lib -lssl
LIBS += -LC:\Temp\openssl\OpenSSL-for-Android-Prebuilt\openssl-1.0.2\armeabi-v7a\lib -lcrypto


ANDROID_EXTRA_LIBS += C:\Users\niki\Downloads\android-ndk-r10e\sources\cxx-stl\stlport\libs\armeabi-v7a\libstlport_shared.so
ANDROID_EXTRA_LIBS += C:\Temp\cryptopp\cryptopp-5.6.2-android-14\cryptopp-android-14\lib1\libcryptopp.so

INCLUDEPATH += C:\Temp\cryptopp\cryptopp-5.6.2-android-14\cryptopp-android-14\include\cryptopp\

LIBS += -LC:\Users\niki\Downloads\android-ndk-r10e\sources\cxx-stl\stlport\libs\armeabi-v7a -lstlport_shared
LIBS += -LC:\Temp\cryptopp\cryptopp-5.6.2-android-14\cryptopp-android-14\lib1 -lcryptopp



DISTFILES += \
    ../../../../Temp/cryptopp/cryptopp-5.6.2-android-14/cryptopp-android-14/lib1/libcryptopp.so
</code></pre>

<p>When I start the program and press pushButton2 it appears logindialog. When I enter something into it and press logindialog's button the program is dieing. If I comment in .pro file the cryptopp lines the program works properly. If I leave empty the lineEdit and push passwordButton of logindialog, it again ask me about password and I give blank, but again die - see the second log appears(notice the P1,P2,P3... in both logs). I took openssl from <a href=""https://github.com/emileb/OpenSSL-for-Android-Prebuilt"" rel=""nofollow"">this</a> link and criptopp from <a href=""https://github.com/noloader/cryptopp-5.6.2-android-14"" rel=""nofollow"">this</a>. I think the problem is somewhere with cryptopp. How can I increase stack and heap size for qt android? I don't think this is the issue and have read something about ""stack trace debuging"" but don't know how to do it. Never mind, what could be the issue in this case?</p>

<p>After edition:</p>

<p>I have tested it on my android 4.1.2 device LG optimus L1 e410. No matter if I test it on AVD with android 23/14/18/16 -> it is failing. If cryptopp is commented all goes OK. log2 compile output is same as first one with difference in time only.</p>

<p>After edition 2:</p>

<p>Application log for cryptopp usage for pushButton:</p>

<pre><code>I/Adreno200-EGL( 6066): Reconstruct Branch: NOTHING
W/IInputConnectionWrapper( 6066): showStatusIcon on inactive InputConnection
F/libc    ( 6066): Fatal signal 11 (SIGSEGV) at 0x54ff002e (code=1), thread 6156 (le.testAndroid4)
I/DEBUG   (  147): pid: 6066, tid: 6156, name: le.testAndroid4  &gt;&gt;&gt; org.qtproject.example.testAndroid4 &lt;&lt;&lt;
I/ActivityManager(  457): Process org.qtproject.example.testAndroid4 (pid 6066) has died.


""org.qtproject.example.testAndroid4"" died.
</code></pre>

<p>See pushButton in mainwindow.cpp and commented thigs in mainwindow.h(they are not commented really).</p>
","<p>You are manually loading <code>libstlport_shared.so</code>, I suppose it's because it is needed by <code>libcryptopp.so</code>.</p>

<p>By default Qt, uses a STL library (<code>libgnustl_shared.so</code> in my case, you can check this in your android-build\libs\armeabi-v7a folder after compilation) upon compilation and deployment. If your crypto library uses a different one (apparently <code>libstlport_shared.so</code>), loading it manually from the .pro file as you did (<code>ANDROID_EXTRA_LIBS +=</code> , <code>LIB +=</code>) will make the <code>libcryptopp.so</code> loadable, but you'll most likely get a seg fault whenever you'll pass a STL object (<code>std::string</code> for instance) from your code to a crypto function. </p>

<p>Two environments (your code and crypto one) are not using the same STL implementation, so they cannot safely send any STL object to each other without a serious potential segmentation fault (as one will consider objects as created from its own implementation when it was actually created with the other one: objects will most likely have different attributes....it's like forcing a cast between two completely different types).</p>

<p>You can verify this like that:</p>

<pre><code>void MainWindow::on_pushButton_clicked()
{
    byte ivec[16];
    byte salt[32];

    qDebug() &lt;&lt; ""Calling OS_GenerateRandomBlock"";
    CryptoPP::OS_GenerateRandomBlock(false, salt, sizeof(salt));
    qDebug() &lt;&lt; ""Calling OS_GenerateRandomBlock"";
    CryptoPP::OS_GenerateRandomBlock(false, ivec, sizeof(ivec));

    std::string v;

    qDebug() &lt;&lt; ""Passing std::string to CryptoPP::StringSink"";    
    CryptoPP::StringSink* sink = new CryptoPP::StringSink(v);

    qDebug() &lt;&lt; ""Creating HexEncoder"";    
    CryptoPP::HexEncoder hex( sink );

    hex.Put(salt, sizeof(salt));
    hex.MessageEnd();

    QMessageBox::about(this,tr(""Test1""),tr(v.c_str()));
    QMessageBox::about(this,tr(""Test1""),tr(""XXX""));
}
</code></pre>

<p>Please confirm, but I'm pretty sure you'll see ""Passing std::string to CryptoPP::StringSink"" but not ""Creating HexEncoder"".</p>

<p>You should recompile <code>libcryptopp.so</code> to have it use the same STL implmentation as your main program (and cross your finger that the lib will work with that STL implementation).</p>
","212","<c++><qt><android-ndk><openssl><crypto++>","0","2","1","2015-12-03 11:12:27","","6","","5467838","","2015-12-03 10:02:42","2015-12-02 16:42:36",""
"40221938","Crypto++ exception : ""ciphertext length is not a multiple of block size""","<p>I've been trying to encrypt/decrypt a byte array with Crypto++ using AES encryption but I got this exception :</p>

<pre><code>StreamTransformationFilter: ciphertext length is not a multiple of block size
</code></pre>

<p>The thing is that I'm using PKCS padding so this shouldn't happen.</p>

<p>This is the function I'm having trouble with. Could anyone tell me what exactly I am doing wrong ?</p>

<pre><code>void QtAES256::decrypt(const QByteArray&amp; cryptedArray, QByteArray&amp; decryptedArray) const
{
    CBC_Mode&lt;AES&gt;::Decryption cbcDecryption(reinterpret_cast&lt;const byte*&gt;(m_Key.constData()),
                                            m_Key.length(),
                                            reinterpret_cast&lt;const byte*&gt;(m_IV.constData()));

    byte decryptedResult[MAXSIZE];
    ArraySink* arraySink = new ArraySink(decryptedResult, MAXSIZE);

    StreamTransformationFilter stfDecryptor(cbcDecryption,
                                            arraySink,
                                            StreamTransformationFilter::PKCS_PADDING);

    stfDecryptor.Put(reinterpret_cast&lt;const byte*&gt;(cryptedArray.constData()), cryptedArray.length());

    try
    {
        stfDecryptor.MessageEnd();
    }
    catch(InvalidCiphertext &amp;e)
    {
        qDebug() &lt;&lt; e.what();
    }

    decryptedArray = QByteArray(reinterpret_cast&lt;const char*&gt;(decryptedResult), arraySink-&gt;TotalPutLength());

    delete arraySink;
}
</code></pre>
","","211","<qt><encryption><aes><crypto++>","0","","0","2016-10-25 11:09:24","","5","","608639","","2016-10-25 07:07:32","2016-10-24 15:18:00",""
"47956337","Calculate time encryption of AES/CCM in Visual Studio 2017","<p>I am  using the library Crypto++ 5.6.5 and Visual Studio 2017.</p>

<p>How can I calculate the encryption time for AES-CCM?</p>
","<blockquote>
  <p>I would like to know how to calculate the encryption time for AES-CCM.</p>
</blockquote>

<p>The Crypto++ wiki provides an article <a href=""https://www.cryptopp.com/wiki/Benchmarks"" rel=""nofollow noreferrer"">Benchmarks</a>. It provides a lot of details regarding library performance, how throughput is calculated, and it even references the source code where the actual throughput is measured. Believe it or not, a simple call to <code>clock</code> works just fine to measure bulk encryption. Also see <a href=""https://www.cryptopp.com/wiki/Benchmarks#Timing_Loop"" rel=""nofollow noreferrer"">Benchmarks | Timing Loop</a> in the same wiki article.</p>

<p>To benchmark AES/CCM, do something like the following. It is based on the Crypto++ benchmarking code, but it uses a <code>ThreadUserTimer</code> instead of a direct call to <code>clock</code>. <code>ThreadUserTimer</code> works across all OSes and all versions of C++.</p>

<p>You need to dial-in your processor speed at <code>cpuFreq</code>. You <em>should</em> also run <a href=""https://github.com/weidai11/cryptopp/blob/master/TestScripts/governor.sh"" rel=""nofollow noreferrer""><code>./governor.sh perf</code></a> to move the CPU from an idle or C-level sleep state, but you can't because it is a Linux script. You can find it in the <code>TestScript/</code> folder.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""secblock.h""
#include ""hrtimer.h""
#include ""osrng.h""
#include ""modes.h""
#include ""aes.h""
#include ""ccm.h""
#include &lt;iostream&gt;

const double runTimeInSeconds = 3.0;
const double cpuFreq = 2.7*1000*1000*1000;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    SecByteBlock key(16);
    prng.GenerateBlock(key, key.size());

    CCM&lt;AES&gt;::Encryption cipher;
    cipher.SetKeyWithIV(key, key.size(), key);

    const int BUF_SIZE=RoundUpToMultipleOf(2048U,
        dynamic_cast&lt;StreamTransformation&amp;&gt;(cipher).OptimalBlockSize());

    AlignedSecByteBlock buf(BUF_SIZE);
    prng.GenerateBlock(buf, BUF_SIZE);

    double elapsedTimeInSeconds;
    unsigned long i=0, blocks=1;

    ThreadUserTimer timer;
    timer.StartTimer();

    do
    {
        blocks *= 2;
        for (; i&lt;blocks; i++)
            cipher.ProcessString(buf, BUF_SIZE);
        elapsedTimeInSeconds = timer.ElapsedTimeAsDouble();
    }
    while (elapsedTimeInSeconds &lt; runTimeInSeconds);

    const double bytes = static_cast&lt;double&gt;(BUF_SIZE) * blocks;
    const double ghz = cpuFreq / 1000 / 1000 / 1000;
    const double mbs = bytes / 1024 / 1024 / elapsedTimeInSeconds;
    const double cpb = elapsedTimeInSeconds * cpuFreq / bytes;

    std::cout &lt;&lt; cipher.AlgorithmName() &lt;&lt; "" benchmarks..."" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; ghz &lt;&lt; "" GHz cpu frequency"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; cpb &lt;&lt; "" cycles per byte (cpb)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""  "" &lt;&lt; mbs &lt;&lt; "" MiB per second (MiB)"" &lt;&lt; std::endl;
    // std::cout &lt;&lt; ""  "" &lt;&lt; elapsedTimeInSeconds &lt;&lt; "" seconds passed"" &lt;&lt; std::endl;
    // std::cout &lt;&lt; ""  "" &lt;&lt; (word64) bytes &lt;&lt; "" bytes processed""  &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Running it on a Core i5-6400 at 2.7 GHz results in:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ bench.cxx ./libcryptopp.a -o bench.exe
$ ./bench.exe
AES/CCM benchmarks...
  2.7 GHz cpu frequency
  3.00491 cycles per byte (cpb)
  856.904 MiB per second (MiB)
</code></pre>

<hr>

<p>Usually you benchmark a library with CTR mode. For example, all of the <a href=""https://bench.cr.yp.to/supercop.html"" rel=""nofollow noreferrer"">SUPERCOP</a> benchmarks are performed using the mode. You can switch to CTR mode by including <code>""modes.h""</code>, and then:</p>



<pre><code>CTR_Mode&lt;AES&gt;::Encryption cipher;
cipher.SetKeyWithIV(key, key.size(), key);
</code></pre>

<p>Finally, the same test using CTR mode:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./bench.exe
AES/CTR benchmarks...
  2.7 GHz cpu frequency
  0.568922 cycles per byte (cpb)
  4525.97 MiB per second (MiB)
</code></pre>
","206","<c++><visual-c++><benchmarking><crypto++><microbenchmark>","0","2","1","2017-12-25 20:48:15","","4","","224132","","2017-12-25 20:48:15","2017-12-23 21:54:07",""
"51160425","Encrypt a RSA private key and write it to a file using Crypto++","<p>I'm trying to export a RSA private key to a file, after encrypting it using RSA.
So far, I tried to export it with 2 methods :</p>

<pre><code>int main()
{
    AutoSeededRandomPool rnd;
    const std::string publickey_str = 
    ""-----BEGIN PUBLIC KEY-----\n""
    ""rsa public key there\n""
    ""-----END PUBLIC KEY-----"";

    RSA::PublicKey master_publicKey;

    StringSource source(publickey_str, true);
    PEM_Load(source, master_publicKey);

    CryptoPP::RSAES_OAEP_SHA_Encryptor e(master_publicKey);

    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(rnd, 4096);

    RSA::PrivateKey privateKey(params);

    FileSink file(""exported.bin"")

    //Method 1

    FileSink file(""exported.bin"")
    ArraySource export_private_key(privateKey, sizeof(privateKey),true, AuthenticatedEncryptionFilter(e, new Redirector(file))); //can't find a way to convert privateKey to a valid type for ArraySource

    //Method 2
    privateKey.Save( new AuthenticatedEncryptionFilter(e, new Redirector(file))); //doesn't work, as Save() expects BufferedTransformation
</code></pre>

<p>Is there any way to achieve my goal using one of these 2 methods, or do I have to convert my private key to another format (BER or PEM encoding) before applying RSA on it ?</p>

<p>Thanks in advance</p>

<p>P.S: My question is Windows specific, if it matters in any way.</p>
","<p>No.</p>

<p>RSA can only securely encrypt a (much) smaller amount of data than the key size because of the secure padding that is required - in this case OAEP. RSA, like any cipher, encrypts <em>bytes</em>, so changing the key to text certainly won't help. It will also further inflate the key size that needs to be encrypted.</p>

<p>What you can do is to use hybrid encryption: first encrypt with AES in a secure mode of operation with a new random key, then encrypt the AES key using RSA.</p>

<hr>

<p>You may want to think about your security scheme; the RSA encryption is only useful if the RSA decryption key is kept <em>more secure</em> than the RSA key that you are encrypting. Otherwise you've just shifted the problem to the RSA key pair that <em>wraps and unwraps</em> the private key.</p>
","205","<c++><windows><encryption><crypto++>","1","0","1","2018-07-04 00:38:06","","1","","1413395","","2018-07-03 17:53:16","2018-07-03 17:52:37",""
"20732675","Converting from cryptopp::integer to QString","<p>How to convert from cryptopp::integer to QString?</p>

<p>If it's important I work on Mac OS.
I absolutely don't know what to do, only trying to use QCA, but it wasn't good enough!</p>
","<p>Based on your feedback to my comment, it seems that you need three steps.</p>

<p>1) Call the <code>BitCount()</code> method to get the number of bits in the integer.</p>

<p>2) Then, you can get all the bits by using the <code>GetBits()</code> method.</p>

<p>3) Once that is done, you can call use the <code>QString::number() method to get the actual integer into the desired</code>QString` as the return value of the static method.</p>
","205","<c++><qt><qstring><crypto++><qtcore>","0","0","2","2014-02-01 03:45:34","20738130","7","0","2682142","","2013-12-23 06:31:54","2013-12-22 18:35:03",""
"20732675","Converting from cryptopp::integer to QString","<p>How to convert from cryptopp::integer to QString?</p>

<p>If it's important I work on Mac OS.
I absolutely don't know what to do, only trying to use QCA, but it wasn't good enough!</p>
","<blockquote>
  <p>How to convert from cryptopp::integer to QString?</p>
</blockquote>

<p>You could also do something like this:</p>

<pre><code>CryptoPP::Integer i = 1;
i &lt;&lt;= 128;
i--;
i *= 3;

ostringstream oss;
oss &lt;&lt; std::hex &lt;&lt; i;

QString qs(oss.str().c_str());
</code></pre>
","205","<c++><qt><qstring><crypto++><qtcore>","0","1","2","2014-02-01 03:45:34","20738130","7","0","2682142","","2013-12-23 06:31:54","2013-12-22 18:35:03",""
"21280019","Length of ciphertext produced by RSAES_OAEP_Encryptor?","<p>My use of the <code>Crypto++</code> library has gone very well, but I have a small question...</p>

<p>If I use <code>RSAES_OAEP_Encryptor</code> &amp; <code>RSAES_OAEP_Decryptor</code> everything is fine. (I'm using a 2048-bit key from PEM files generated by <code>OpenSSL</code>).</p>

<p>My question is this: Will the length of <code>ciphertext</code> produced by <code>encryptor.Encrypt(...)</code> always equal <code>decryptor.FixedCiphertextLength()</code> or can be be less than that? I only ask as this is in a library used by a number of applications and I need to sanity check parameters.....</p>

<p>BTW. Is there any faster was to encrypt/decrypt using RSA which maintains at least the same level of security provided by OAEP? With a 1024 bit key, on an example test box, averaged over 1000 iterations, I'm finding it takes about 80uS to encode a short string and 1.03mS (12 times longer) to decrypt; with a 2048-bit key encryption takes 190uS and decryption, 4.3mS (22 times longer). I know that RSA decryption is slow, but.... the system is running XP Pro SP3/Xeon E5520 and was compiled with VS2008 with /MD rather than /MT. I can't use a shorter key than 2048-bits for compliance reasons...</p>

<p>Many thanks</p>

<p>Nick</p>
","<blockquote>
  <p>Length of ciphertext produced by RSAES_OAEP_Encryptor?</p>
</blockquote>

<p>In the case of RSA, I believe <code>FixedPlaintextLength()</code> and <code>FixedCiphertextLength()</code> call <code>MaxPreImage()</code> and <code>MaxImage()</code>. <code>MaxPreImage()</code> and <code>MaxImage()</code>, in turn, returns <code>n - 1</code>.</p>

<hr>

<blockquote>
  <p>Will the length of ciphertext produced by encryptor.Encrypt(...) always equal decryptor.FixedCiphertextLength() or can be be less than that?</p>
</blockquote>

<p>It depends on the cryptosystem being used. Usually, its the size of the key that determines if <code>FixedCiphertextLength()</code> holds (and not the size of the plain text). In the case of RSA/OAEP and others like ElGamal, I believe it holds.</p>

<p>I think the class of interest here is the <a href=""http://www.cryptopp.com/docs/ref/class_p_k___crypto_system.html"" rel=""nofollow""><code>PK_CryptoSystem Class Reference</code></a>. Classes like <code>RSAES_OAEP_Encryptor</code> inherit from <code>PK_CryptoSystem</code>, and that's where <code>FixedCiphertextLength()</code> and friends come from.</p>

<hr>

<blockquote>
  <p>With a 1024 bit key, on an example test box, averaged over 1000 iterations, I'm finding it takes about 80uS to encode a short string and 1.03mS (12 times longer) to decrypt; with a 2048-bit key encryption takes 190uS and decryption, 4.3mS (22 times longer)</p>
</blockquote>

<p>This is a different question, but...</p>

<p>In the case of encryption or verification, the public exponent is used. The public exponent is, by default, 65537 (IIRC). That's got a low hamming weight (high density of 0's), so square and multiply exponentiation routines run relatively fast.</p>

<p>On the other hand, decryption and signing use the private exponent, which should have about a normal distribution of 1's and 0's. There's lots of squares and multiplies to perform, and those take extra time.</p>

<p>Taking advantage of those little timing differences is where your side channels come from if you are not careful. If you are not careful, then the NSA will thank you.</p>

<hr>

<blockquote>
  <p>I can't use a shorter key than 2048-bits for compliance reasons</p>
</blockquote>

<p>A 2048-bit modulus is about 10x slower than a 1024-bit modulus. Its why so many folks were reluctant to move from 1024-bit, and why 1024-bit is still kind of preferred.</p>

<p>Peter Gutmann has this to say about it in his Engineering Security book (p. 229):</p>

<blockquote>
  <p>Another example [of broken threat models] occurred with keys in
  certificates, for which browser vendors (in response to NIST
  requirements) forced CAs to switch from 1024-bit to 2048-bit keys,
  with anything still using 1024-bit keys being publicly denounced as
  insecure. As discussed in “Problems” on page 1, the bad guys didn’t
  even notice whether their fraudulent certificates were being signed
  with, or contained, 2048-bit keys or not.</p>
</blockquote>
","202","<rsa><crypto++>","1","1","1","2014-01-25 02:40:17","21345688","0","","1932364","","2014-01-25 02:40:17","2014-01-22 10:17:07",""
"44959926","Encrypting in C# and Decrypting with Crypto++ does not work","<p>Encryption :</p>

<pre><code>    public static byte[] EncryptAES(Message msg)
    {

        byte[] encText; // This will keep the encrypted text
        byte[] encLength; // This will keep the length of the encrypted text
        byte[] finalEncText = null; // This keeps the encLength + encText (#####[encText] / [encLength][encText])

        // Building the plaintext message : 
        string plainText = msg.MessageCode.ToString();

        if (msg.Parameters != null)
            foreach (string parameter in msg.Parameters)
                plainText += parameter;

        // Encrypting the plaintext :
        encText = EncryptAES(plainText);

        string encLen = encText.Length.ToString();
        string fittedEncLen = MessageSender.FitStringIntoSize(encLen, Globals.MESSAGE_LENGTH_LEN); // Fit the length of the encrypted text into a certain size
        encLength = Encoding.ASCII.GetBytes(fittedEncLen); // convert the length into byte[]

        finalEncText = new byte[encLength.Length + encText.Length];
        System.Buffer.BlockCopy(encLength, 0, finalEncText, 0, encLength.Length);
        System.Buffer.BlockCopy(encText, 0, finalEncText, encLength.Length, encText.Length); // Copy the byte arrays into the new byte array


        return finalEncText;
    }

    private static byte[] EncryptAES(string text)
    {
        // This function encrypts a plaintext message using the aes key we have from the server

        if (AesKey == null || IV == null) // If we dont have an aes key / iv, dont encrypt
            return Encoding.ASCII.GetBytes(text);


        byte[] encryptedText;

        try
        {
            Aes aes = Aes.Create();
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.Zeros;
            aes.Key = Encoding.ASCII.GetBytes(AesKey);
            aes.IV = Encoding.ASCII.GetBytes(IV);

            ICryptoTransform cryptor = aes.CreateEncryptor(aes.Key, aes.IV);



            using (MemoryStream memStream = new MemoryStream())
            {
                using (CryptoStream crypotStream = new CryptoStream(memStream, cryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter writerStream = new StreamWriter(crypotStream))
                    {
                        writerStream.Write(text);
                    }
                    encryptedText = memStream.ToArray();
                }
            }

            aes.Dispose();
        }
        catch
        {
            // In case of an error while encrypting, dont encrypt
            encryptedText = Encoding.ASCII.GetBytes(text);
        }
        return encryptedText;
    }
</code></pre>

<p><strong>[The added fittedEncLen is basically a prefix of fixed length of 5 chars, that contains the length of the encrypted message following it, before decrypting the server reads those 5 chars and then it decrypts the encrypted part]</strong></p>

<p>Sending the message to the server [TCPClient] [C#] :</p>

<pre><code>public int Send(Message message)
        {
            /*
             * Encrpyts the message and then sends it to the network stream.
             * 
             * Return code:
             *      0 on success.
             *      -1 on failure.
             */

            byte[] msg = Cryptography.EncryptAES(message); // Encrypt the message
            // Sending message

            try
            {
                this._networkStream.Write(msg, 0, msg.Length);
                this._networkStream.Flush();
            }
            catch
            {
                return -1;
            }
            return 0;
        }
</code></pre>

<p>Receiving [C++] :</p>

<pre><code>wstring Helper::getWideStringPartFromSocket(SOCKET sc, int bytesNum)
{
    // This function reads the message from the socket, using wide string
    std::wstringstream cls;
    cls &lt;&lt; getPartFromSocket(sc, bytesNum, 0);
    return cls.str();
}

char* Helper::getPartFromSocket(SOCKET sc, int bytesNum, int flags)
{
    if (bytesNum == 0)
        return """";

    char* data = new char[bytesNum + 1];
    int res = recv(sc, data, bytesNum, flags);

    if (res == INVALID_SOCKET)
    {
        string s = ""Error while recieving from socket: "";
        s += to_string(sc);
        throw exception(s.c_str());
    }

    data[bytesNum] = 0;

    return data;
}



BufferedString* Helper::makeBufferedString(SOCKET sc)
    {
        /*
            The socket contains &lt;length of encrypted message (unencrypted)&gt; &lt;encrypted message&gt;.

            This function will read the length of the unencrypted message, read 
            the encrypted message, decrypt it, store it in a BufferedString
            object and return the object.

            Length of length number: MESSAGE_LENGTH_LEN.
        */

        int sizeOfMessage = Helper::getIntPartFromSocket(sc, MESSAGE_LENGTH_LEN);
        if (sizeOfMessage == 0)
            return NULL;

        wstring wideString = getWideStringPartFromSocket(sc, sizeOfMessage);
        string decrypted = """";

        if (wideString.length() &lt; sizeOfMessage)
        {
            std::wstringstream cls;
            cls &lt;&lt; wideString;
            cls &lt;&lt; getWideStringPartFromSocket(sc, sizeOfMessage - wideString.length());
            wideString = cls.str();
        }

        SocketEncryptionKeychain* keyChain = SocketEncryptionKeychain::getKeychain(sc);

        if (keyChain != nullptr) // If the socket has a keychain, decrypt the message
            decrypted = Cryptography::decryptAES(wideString, keyChain-&gt;getKey(), keyChain-&gt;getIV()); // Try to decrypt the message
        else // If the keychain is null, just convert the widestring to a string
            decrypted = wideStringToString(wideString);

        return new BufferedString(decrypted);
    }
</code></pre>

<p><strong>SocketEncryptionKeychain basically contains the AES Key and IV for each socket
BufferedString is a class that contains the string, and you can read from it like you read from a socket [its a buffer that once you read from it, what you read is deleted] [basically a string buffer, nothing special]</strong></p>

<p>Decrypting [C++]:</p>

<pre><code>string Cryptography::decryptAES(wstring cipherText, byte aesKey[], byte iv[])
{
    if (aesKey == nullptr || iv == nullptr) // If the key or iv are null, dont decrypt
        return Helper::wideStringToString(cipherText);

    string plaintext;
    try
    {
        // Decrypt :
        byte* cipher = wideStringToByteArray(cipherText); // Convert the wide string to byte*

        CryptoPP::AES::Decryption aesDecryption(aesKey, 32);
        CryptoPP::CBC_Mode_ExternalCipher::Decryption ecbDecryption(aesDecryption, iv);


        CryptoPP::StreamTransformationFilter stfDecryptor(ecbDecryption, new CryptoPP::StringSink(plaintext), StreamTransformationFilter::ZEROS_PADDING);
        stfDecryptor.Put(cipher, cipherText.length());
        stfDecryptor.MessageEnd();

        Helper::safeDelete(cipher);
    }
    catch (CryptoPP::InvalidCiphertext&amp; ex)
    {
        // In case of an error don't decrypt
        plaintext = Helper::wideStringToString(cipherText);
    }

    return plaintext;
}


byte* Cryptography::wideStringToByteArray(wstring text)
{
    // This function translates the wstring into a byte*
    byte* bytes = new byte[text.length()]; // Convert the wstring to byte*
    for (int i = 0; i &lt; text.length(); i++)
    {
        bytes[i] = text[i];
    }
    return bytes;
}
</code></pre>

<p><strong>[Helper::safeDelete is a function that just deletes the pointer and sets it as null]</strong></p>

<p><strong>The decryption only fails once in a while</strong></p>
","<p>You may have other problems, but here's one:</p>

<pre><code>using (CryptoStream crypotStream = new CryptoStream(memStream, cryptor, CryptoStreamMode.Write))
{
    using (StreamWriter writerStream = new StreamWriter(crypotStream))
    {
        writerStream.Write(text);
    }
    encryptedText = memStream.ToArray();
}
</code></pre>

<p>You drained the CryptoStream's output before telling the CryptoStream it was done.  So you've possibly lost up to 16 bytes.</p>

<p>You need to either:</p>

<ul>
<li>call FlushFinalBlock() on <code>crypotStream</code>(sic).</li>
<li>don't call <code>memStream.ToArray()</code> until after the using for the CryptoStream has exited.</li>
</ul>
","201","<c#><sockets><encryption><crypto++>","-1","1","2","2017-07-21 19:16:01","44977622","14","0","1159478","","2017-07-21 19:16:01","2017-07-06 22:37:03",""
"44959926","Encrypting in C# and Decrypting with Crypto++ does not work","<p>Encryption :</p>

<pre><code>    public static byte[] EncryptAES(Message msg)
    {

        byte[] encText; // This will keep the encrypted text
        byte[] encLength; // This will keep the length of the encrypted text
        byte[] finalEncText = null; // This keeps the encLength + encText (#####[encText] / [encLength][encText])

        // Building the plaintext message : 
        string plainText = msg.MessageCode.ToString();

        if (msg.Parameters != null)
            foreach (string parameter in msg.Parameters)
                plainText += parameter;

        // Encrypting the plaintext :
        encText = EncryptAES(plainText);

        string encLen = encText.Length.ToString();
        string fittedEncLen = MessageSender.FitStringIntoSize(encLen, Globals.MESSAGE_LENGTH_LEN); // Fit the length of the encrypted text into a certain size
        encLength = Encoding.ASCII.GetBytes(fittedEncLen); // convert the length into byte[]

        finalEncText = new byte[encLength.Length + encText.Length];
        System.Buffer.BlockCopy(encLength, 0, finalEncText, 0, encLength.Length);
        System.Buffer.BlockCopy(encText, 0, finalEncText, encLength.Length, encText.Length); // Copy the byte arrays into the new byte array


        return finalEncText;
    }

    private static byte[] EncryptAES(string text)
    {
        // This function encrypts a plaintext message using the aes key we have from the server

        if (AesKey == null || IV == null) // If we dont have an aes key / iv, dont encrypt
            return Encoding.ASCII.GetBytes(text);


        byte[] encryptedText;

        try
        {
            Aes aes = Aes.Create();
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.Zeros;
            aes.Key = Encoding.ASCII.GetBytes(AesKey);
            aes.IV = Encoding.ASCII.GetBytes(IV);

            ICryptoTransform cryptor = aes.CreateEncryptor(aes.Key, aes.IV);



            using (MemoryStream memStream = new MemoryStream())
            {
                using (CryptoStream crypotStream = new CryptoStream(memStream, cryptor, CryptoStreamMode.Write))
                {
                    using (StreamWriter writerStream = new StreamWriter(crypotStream))
                    {
                        writerStream.Write(text);
                    }
                    encryptedText = memStream.ToArray();
                }
            }

            aes.Dispose();
        }
        catch
        {
            // In case of an error while encrypting, dont encrypt
            encryptedText = Encoding.ASCII.GetBytes(text);
        }
        return encryptedText;
    }
</code></pre>

<p><strong>[The added fittedEncLen is basically a prefix of fixed length of 5 chars, that contains the length of the encrypted message following it, before decrypting the server reads those 5 chars and then it decrypts the encrypted part]</strong></p>

<p>Sending the message to the server [TCPClient] [C#] :</p>

<pre><code>public int Send(Message message)
        {
            /*
             * Encrpyts the message and then sends it to the network stream.
             * 
             * Return code:
             *      0 on success.
             *      -1 on failure.
             */

            byte[] msg = Cryptography.EncryptAES(message); // Encrypt the message
            // Sending message

            try
            {
                this._networkStream.Write(msg, 0, msg.Length);
                this._networkStream.Flush();
            }
            catch
            {
                return -1;
            }
            return 0;
        }
</code></pre>

<p>Receiving [C++] :</p>

<pre><code>wstring Helper::getWideStringPartFromSocket(SOCKET sc, int bytesNum)
{
    // This function reads the message from the socket, using wide string
    std::wstringstream cls;
    cls &lt;&lt; getPartFromSocket(sc, bytesNum, 0);
    return cls.str();
}

char* Helper::getPartFromSocket(SOCKET sc, int bytesNum, int flags)
{
    if (bytesNum == 0)
        return """";

    char* data = new char[bytesNum + 1];
    int res = recv(sc, data, bytesNum, flags);

    if (res == INVALID_SOCKET)
    {
        string s = ""Error while recieving from socket: "";
        s += to_string(sc);
        throw exception(s.c_str());
    }

    data[bytesNum] = 0;

    return data;
}



BufferedString* Helper::makeBufferedString(SOCKET sc)
    {
        /*
            The socket contains &lt;length of encrypted message (unencrypted)&gt; &lt;encrypted message&gt;.

            This function will read the length of the unencrypted message, read 
            the encrypted message, decrypt it, store it in a BufferedString
            object and return the object.

            Length of length number: MESSAGE_LENGTH_LEN.
        */

        int sizeOfMessage = Helper::getIntPartFromSocket(sc, MESSAGE_LENGTH_LEN);
        if (sizeOfMessage == 0)
            return NULL;

        wstring wideString = getWideStringPartFromSocket(sc, sizeOfMessage);
        string decrypted = """";

        if (wideString.length() &lt; sizeOfMessage)
        {
            std::wstringstream cls;
            cls &lt;&lt; wideString;
            cls &lt;&lt; getWideStringPartFromSocket(sc, sizeOfMessage - wideString.length());
            wideString = cls.str();
        }

        SocketEncryptionKeychain* keyChain = SocketEncryptionKeychain::getKeychain(sc);

        if (keyChain != nullptr) // If the socket has a keychain, decrypt the message
            decrypted = Cryptography::decryptAES(wideString, keyChain-&gt;getKey(), keyChain-&gt;getIV()); // Try to decrypt the message
        else // If the keychain is null, just convert the widestring to a string
            decrypted = wideStringToString(wideString);

        return new BufferedString(decrypted);
    }
</code></pre>

<p><strong>SocketEncryptionKeychain basically contains the AES Key and IV for each socket
BufferedString is a class that contains the string, and you can read from it like you read from a socket [its a buffer that once you read from it, what you read is deleted] [basically a string buffer, nothing special]</strong></p>

<p>Decrypting [C++]:</p>

<pre><code>string Cryptography::decryptAES(wstring cipherText, byte aesKey[], byte iv[])
{
    if (aesKey == nullptr || iv == nullptr) // If the key or iv are null, dont decrypt
        return Helper::wideStringToString(cipherText);

    string plaintext;
    try
    {
        // Decrypt :
        byte* cipher = wideStringToByteArray(cipherText); // Convert the wide string to byte*

        CryptoPP::AES::Decryption aesDecryption(aesKey, 32);
        CryptoPP::CBC_Mode_ExternalCipher::Decryption ecbDecryption(aesDecryption, iv);


        CryptoPP::StreamTransformationFilter stfDecryptor(ecbDecryption, new CryptoPP::StringSink(plaintext), StreamTransformationFilter::ZEROS_PADDING);
        stfDecryptor.Put(cipher, cipherText.length());
        stfDecryptor.MessageEnd();

        Helper::safeDelete(cipher);
    }
    catch (CryptoPP::InvalidCiphertext&amp; ex)
    {
        // In case of an error don't decrypt
        plaintext = Helper::wideStringToString(cipherText);
    }

    return plaintext;
}


byte* Cryptography::wideStringToByteArray(wstring text)
{
    // This function translates the wstring into a byte*
    byte* bytes = new byte[text.length()]; // Convert the wstring to byte*
    for (int i = 0; i &lt; text.length(); i++)
    {
        bytes[i] = text[i];
    }
    return bytes;
}
</code></pre>

<p><strong>[Helper::safeDelete is a function that just deletes the pointer and sets it as null]</strong></p>

<p><strong>The decryption only fails once in a while</strong></p>
","<p>So, the problem was while parsing the char* to wstring in the function </p>

<p>The problem in this function is the way I parse it:</p>

<pre><code>wstring Helper::getWideStringPartFromSocket(SOCKET sc, int bytesNum)
{
    // This function reads the message from the socket, using wide string
    std::wstringstream cls;
    cls &lt;&lt; getPartFromSocket(sc, bytesNum, 0);
    return cls.str();
}
</code></pre>

<p>I used a wstringstream, and the encrypted text can sometimes contain null-terminating character.</p>

<p>So instead of using a wstringstream I used this:</p>

<pre><code>wstring Helper::getWideStringPartFromSocket(SOCKET sc, int bytesNum)
{
    // This function reads the message from the socket, using wide string
    char* readBuffer = getPartFromSocket(sc, bytesNum, 0);

    return wstring(&amp;readBuffer[0], &amp;readBuffer[bytesNum]);
}
</code></pre>

<p>and then it does not cut the message at null-character</p>
","201","<c#><sockets><encryption><crypto++>","-1","1","2","2017-07-21 19:16:01","44977622","14","0","1159478","","2017-07-21 19:16:01","2017-07-06 22:37:03",""
"48889427","Crypto++ unresolved external AssignIntToInteger LNK2001 error","<p>I want create a 32 bit dll from another application using Crypto++ in VS 2013. I can create the 64 bit version but not 32 bit.</p>

<p>The code includes sha.h and hex.h. I have set target platform in cryptest for cryptlib (and to make sure it works to all other projects in there) to 32 bit and I have set the Runtime Library to /MD. I build the projects like that, all is fine.</p>

<p>Then, I created my own project and included the .h-files I said. The target platform is also set to Win32. The Runtime Library is set to /MD. I also tried to set it to /MT (which is the default for cryptest) on both sides.
I included cryptlib.lib in my project over Linker -> All Options -> Additional Dependecies and added the value cryptopp600\Win32\Output\Release\cryptlib.lib</p>

<p>When I try to build my solution I get the error (breaks added for readability):</p>

<pre><code>error LNK2001: unresolved external symbol ""bool __stdcall CryptoPP::AssignIntToInteger(
class type_info const &amp;,void *,void const *)""
(?AssignIntToInteger@CryptoPP@@YG_NABVtype_info@@PAXPBX@Z)
</code></pre>

<p>I know there are numerous sides of linker errors but I set both sides to the same Runtime Library.</p>

<p>I'm clueless so help would be appriciated.</p>
","","195","<c++><visual-c++><dll><linker><crypto++>","0","","0","2018-02-21 23:52:42","","2","","608639","","2018-02-21 23:52:42","2018-02-20 16:04:57",""
"45929722","Storing public keys in database (C++)","<p>I am trying to store the public key (PK) and signature (generated by crypto++ library) to sqlite database. I first encoded the keys as: </p>

<pre><code>pk[node].BEREncode(CryptoPP::StringSink(pkstring).Ref());
</code></pre>

<p>and then store them in the database. But as the PK and signature have special characteres, they are not stored correctly into the database. What I used for storing is:</p>

<pre><code>char * PK = (char*) malloc (BC.trans[l].PK.length()+1);   //use malloc to manually manage the memory 
std::strcpy(PK,BC.trans[l].PK.c_str());
char *zSQL = sqlite3_mprintf(""INSERT INTO BC (PK  VALUES ('%q');"", PK);
rc = sqlite3_exec(db, zSQL, callback, (void*)data, &amp;zErrMsg);// executes the command in sqlite and returns the status (whether stroing was successful or not. 
free(PK);
</code></pre>

<p>The string should be copied to the char, and the issue happens exactly here in copying the content into the char. I think its because the string has special characters. For hash I have the same follow but it works perfectly fine. Only for PK and signature. I used memcpy and strncpy as well. Nothing works for this and still the keys are not stored correctly in the database. </p>

<p>Any thoughts? </p>

<p>I've updated with the full code. Now I can store the PK and its seems to be fine, but when I ask the database to remove a bunch of records, nothing happens. That means something is wrong again.</p>

<hr>

<p>Here is the code: </p>

<pre><code>int Network_Nodes =10;   
int Block_Size=10;        
int BC_lenght=0;           
int Fin_BC_size =50; 

std::vector&lt;CryptoPP::RSA::PrivateKey&gt; prk;
std::vector&lt;CryptoPP::RSA::PublicKey&gt; pk;
std::vector&lt;std::string&gt; prev_t;           
struct Block {

    std::string block_hash;

    std::string block_num;

    struct transactions {
        std::string TransactionID;
        std::string previousTransactionID;
        std::string PK;
        std::string Sign;
    };
    std::vector&lt;transactions&gt; trans;
} BC;

int generatekey()
{    
    for (int i=0;i&lt;Network_Nodes;i++)    
    {
        CryptoPP::AutoSeededRandomPool rng;
        CryptoPP::InvertibleRSAFunction param;
        param.GenerateRandomWithKeySize(rng,3072);
        CryptoPP::RSA::PrivateKey privatekey(param);
        CryptoPP::RSA::PublicKey publickey (param);
        prk.push_back(privatekey);
        pk.push_back(publickey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////


void  initialization()
{    
    for (int i=0;i&lt;=Network_Nodes;i++)
    {
        prev_t.push_back(""NULL"");
    }        

    //Creating database
    sqlite3 *db;
        char *zErrMsg = 0;
        int rc;
        char *sql;
        const char* data = ""Callback function called"";

        /* Open database */
        rc = sqlite3_open(""RemovableBC.db"", &amp;db);
        if( rc ) {
                  fprintf(stderr, ""Can't open database: %s\n"", sqlite3_errmsg(db));
                  return;
               } else {
             //     fprintf(stdout, ""Opened database successfully\n"");
               }


        sql = ""DROP TABLE BC"";
        rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg);

        /* Create a table in the data base to be used for storing data. Create SQL statement */
          sql = ""CREATE TABLE BC(""  \
                ""T_ID          TEXT    ,"" \
                ""P_T_ID           TEXT   ,"" \
                ""PK            BLOB    ,"" \
                ""Signature        BLOB      ,"" \
                ""Block_ID         TEXT       );"";

          /* Execute SQL statement */
          rc = sqlite3_exec(db, sql, callback, 0, &amp;zErrMsg);
          if( rc != SQLITE_OK ){
                   fprintf(stderr, ""SQL error: %s\n"", zErrMsg);
                      sqlite3_free(zErrMsg);
                   } else {
             //         fprintf(stdout, ""Table created successfully\n"");
                   }
          sqlite3_close(db);    
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fill_the_block(std::string block_content)
{        
        const char* data = ""Callback function called"";
        SHA256 hash;
        string digest;
        sqlite3 *db=NULL;
        char *sql;
        char *zErrMsg = 0;
        int rc;
        char sqlStr[2000];
        /* Open database */
        rc = sqlite3_open(""RemovableBC.db"", &amp;db);
           if( rc ) {
                  fprintf(stderr, ""Can't open database: %s\n"", sqlite3_errmsg(db));
                  return;
                  } else {
                  //  fprintf(stdout, ""Opened database successfully\n"");
                 }
         StringSource s(block_content, true, new HashFilter(hash, new HexEncoder(new StringSink(digest))));
         BC.block_hash=digest;
         for (int l=0 ; l&lt;Block_Size ; l++)
               {
                                    char *begin = sqlStr;
                                    char *end = begin + sizeof(sqlStr);
                                    std::fill(begin, end, 0);
                                    char *zSQL = sqlite3_mprintf(""INSERT INTO BC ( T_ID , P_T_ID , PK , Signature , Block_ID ) VALUES ('%q','%q','%q','%q','%q');"", BC.trans[l].TransactionID.c_str() ,BC.trans[l].previousTransactionID.c_str() ,BC.trans[l].PK.c_str() ,BC.trans[l].Sign.c_str(),BC.block_hash.c_str());

                                     rc = sqlite3_exec(db, zSQL, callback, (void*)data, &amp;zErrMsg);

                                   sqlite3_free(zSQL);
                                   if( rc != SQLITE_OK ) {
                                       fprintf(stderr, ""SQL error in populating : %s\n"", zErrMsg);
                                       sqlite3_free(zErrMsg);
                                        } else {       
                 }


                                sqlite3_close(db);          //We close the connection we have with the database
}
///////////////////////////////////////////////////////////////////////////
void populate_bc ()
{        
        int generated_blocks=0;
        int stored_trans_in_block=0;                
        int node=0;                                               
        std::string block_content,trans_cont;                        
        std::string pkstring;  
        std::string signature;
        std::string mes =""This message is going to be singed"";


        while (BC_lenght &lt;=Fin_BC_size )
           {
            if (generated_blocks &lt;= 10){
                 if (node &gt;= Network_Nodes)
                        {
                            node=0; //cout &lt;&lt; ""step 4"" &lt;&lt;endl;
                        }
                 if (stored_trans_in_block &gt;= Block_Size)
                        {
                       cout &lt;&lt; ""block size is ""&lt;&lt; BC_lenght&lt;&lt;endl;
                       fill_the_block(block_content);
                       BC_lenght++;
                       block_content.clear();
                       stored_trans_in_block=0;


                        for(int o=0; o&lt;stored_trans_in_block;o++)
                                                {
                                                    BC.trans[o] = {};
                                                }
                                                 BC.trans = {};
                                                 BC ={};

                        }
                 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                 if (prev_t[node]==""NULL"")
                        {
                          // cout &lt;&lt; ""We are populating on behafe of ""&lt;&lt; node&lt;&lt; endl;
                          trans_cont="""";
                          BC.trans.push_back(Block::transactions());

                          BC.trans[stored_trans_in_block].previousTransactionID =""NULL"";
                        //  byte public_key[] = pk[node];

                          std::string endoced_pub;
                          Base64Encoder pubKeySink(new StringSink(endoced_pub));
                          pk[node].DEREncode(pubKeySink);
                      pk[node].BEREncode(CryptoPP::StringSink(pkstring).Ref());
                          BC.trans[stored_trans_in_block].PK=endoced_pub;

                          CryptoPP::AutoSeededRandomPool rng;
                          CryptoPP::RSASSA_PKCS1v15_SHA_Signer signer(prk[node]);
                          CryptoPP::StringSource ss1(mes, true,
                                                   new CryptoPP::SignerFilter(rng, signer,
                                                                              new CryptoPP::StringSink(signature)
                                                          ) // SignerFilter
                                         ); // StringSource
                      //    cout &lt;&lt; ""step 1"" &lt;&lt;endl;
                          BC.trans[stored_trans_in_block].Sign=signature;
                          trans_cont = ""NULL"" + pkstring + signature;
                          SHA256 hash;
                          string digest;
                          StringSource s(trans_cont, true, new HashFilter(hash, new HexEncoder(new StringSink(digest))));
                      //    cout &lt;&lt; ""step 2"" &lt;&lt;endl;
                          BC.trans[stored_trans_in_block].TransactionID=digest;
                          prev_t[node] =digest;                     // This keeps the previous transaction of each node in an array and thus we can later use to populate the BC
                          block_content+=digest;                    // This is to calculate the ID of the block which is the hash of all TIDs (hash of hash of all trnasctions)
                          node++;
                          stored_trans_in_block++;
                        //  cout &lt;&lt; ""step 3"" &lt;&lt;endl;
                        }//end of  if (prev_t[node]==""NULL"")
                    else
                        {// cout &lt;&lt; ""step 6"" &lt;&lt;endl;
                                  trans_cont="""";
                                  BC.trans.push_back(Block::transactions());

                                  BC.trans[stored_trans_in_block].previousTransactionID =prev_t[node];
                                std::string endoced_pub;
                                                          Base64Encoder pubKeySink(new StringSink(endoced_pub));
                                                          pk[node].DEREncode(pubKeySink);
                                                    //       pubKeySink.MessageEnd();

                              //    pk[node].BEREncode(CryptoPP::StringSink(pkstring).Ref());
                                  BC.trans[stored_trans_in_block].PK = endoced_pub;
                        //      BC.trans[stored_trans_in_block].PK= pk[node];
                                  CryptoPP::AutoSeededRandomPool rng;
                                  CryptoPP::RSASSA_PKCS1v15_SHA_Signer signer(prk[node]);
                                  CryptoPP::StringSource ss1(mes, true,
                                                           new CryptoPP::SignerFilter(rng, signer,
                                                                                      new CryptoPP::StringSink(signature)
                                                                  ) // SignerFilter
                                                 ); // StringSource
                                  BC.trans[stored_trans_in_block].Sign=signature;
                                  trans_cont = prev_t[node] + pkstring + signature;
                                  SHA256 hash;
                                  string digest;
                                  StringSource s(trans_cont, true, new HashFilter(hash, new HexEncoder(new StringSink(digest))));
                                  BC.trans[stored_trans_in_block].TransactionID=digest;
                                  prev_t[node] =digest;                     
                                  block_content+=digest;                    
                                  node++;
                                  stored_trans_in_block++;
                        }

                generated_blocks++;
            }


        else
        {

            generated_blocks=0;

        }
           }

}
//////////////////////////////////////////////////////////////////////////////////////

void remove_node (int i)
{


        std::string search_node;                    //This is the ID of the transaction that we need to search for in the BC,
        sqlite3 *db;

        std::string endoced_pub;
        Base64Encoder pubKeySink(new StringSink(endoced_pub));
         pk[i].DEREncode(pubKeySink);
    //    pubKeySink.MessageEnd();
        char *sql;
        int rc;
        char *zErrMsg = 0;

        const char* data = ""Callback function called"";
        /* Open database */
           rc = sqlite3_open(""RemovableBC.db"", &amp;db);

           if( rc ) {
              fprintf(stderr, ""Can't open database: %s\n"", sqlite3_errmsg(db));
              return;
           } else {
            //  fprintf(stderr, ""Opened database successfully\n"");
           }
         /* Execute SQL statement */
        //   char *zSQL = sqlite3_mprintf(""DELETE from BC"");


            char * Search_NODE = (char*) malloc (endoced_pub.length()+1);
            std::strcpy(Search_NODE,endoced_pub.c_str());
                            std::strcpy(Search_NODE,search_node.c_str());

         //  char *zSQL = sqlite3_mprintf(""DELETE from  BC  where PK = '%q';"", Search_NODE);

                   char *zSQL = sqlite3_mprintf(""UPDATE BC set Signature = null  and PK = null   where PK = '%q';"", endoced_pub.c_str());
                   rc = sqlite3_exec(db, zSQL, callback, (void*)data, &amp;zErrMsg);

cout&lt;&lt; endoced_pub.c_str()&lt;&lt;endl;


           if( rc != SQLITE_OK ) {
              fprintf(stderr, ""SQL error in removing a record: %s\n"", zErrMsg);
              sqlite3_free(zErrMsg);
           } else {
            //  fprintf(stdout, ""Operation done successfully\n"");
           }
           sqlite3_close(db);
           free(Search_NODE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main() {

    auto initial = std::chrono::high_resolution_clock::now();
    generatekey();
    cout &lt;&lt; ""Keys are generated for "" &lt;&lt;Network_Nodes &lt;&lt; ""  nodes..."" &lt;&lt; endl;

    clock_t begin_block_pup = clock();
    initialization();
    cout &lt;&lt; ""Initializing previous transaction vector..."" &lt;&lt; endl;

    //clock_t ti =clock();
    //double time = double (ti)/CLOCKS_PER_SEC;


    clock_t ti2 =clock();
        double time2 = double (ti2)/CLOCKS_PER_SEC;
    //cout &lt;&lt; ""second time is  "" &lt;&lt; done &lt;&lt;endl;
    populate_bc();
    cout &lt;&lt; ""BC has been populated with ""&lt;&lt; BC_lenght &lt;&lt;"" blocks..."" &lt;&lt; endl;
    return 0;
}
</code></pre>
","<p>The problem with your system, is that you need to store the PK data as either a BLOB or encode it into 7 bit ASCII.</p>

<p>Sqlite has some internationalization support, and may convert raw binary data stored as a string into a different form. (e.g. UTF-8 conversion)</p>

<p>So either use a blob as in the answer to this question <a href=""https://stackoverflow.com/questions/18092240/sqlite-blob-insertion-c"">SO : sqlite blob</a>,</p>

<p>or first convert the bytes to 7 bit ascii (e.g. b64 encode), then store the data.</p>

<p>Remembering you would need to b64 decode the results afterwards.</p>
","195","<c++><sqlite><crypto++>","-3","1","1","2017-08-31 18:19:21","","5","1","608639","","2017-08-31 18:19:21","2017-08-29 02:15:00",""
"8777232","Visual Studio Macro","<p>I am getting LNK2001 errors when trying to use Crypto++. The official advice for this is:</p>

<blockquote>
  <p>There are two ways you can deal with this, either change Crypto++ to export those classes, by using the CRYPTOPP_DLL macro, or link with both the DLL export library and a static library that contains the non-DLL classes and functions. The latter can be built by using the ""DLL-Import"" configuration of the cryptlib project.</p>
</blockquote>

<p>It would be preferable to use the first option, and given that I am not experienced in using Visual Studio, I cannot find the location and execution method of the macro.</p>

<p><strong>In short: Where do I find the macro and how do I execute it?</strong></p>

<p>Cheers.</p>
","<blockquote>
  <p>In short: Where do I find the macro and how do I execute it?</p>
</blockquote>

<p>The macro is <code>CRYPTOPP_IMPORTS</code>. You use it when performing dynamic linking on Windows (i.e., the Crypto++ DLL).</p>

<p>You can 'execute' it in one of two ways. First, you can add <code>#include &lt;cryptopp/dll.h&gt;</code> to your <code>stdafx.h</code>. <code>dll.h.</code> defines it, and <code>dll.h</code> must be included before any other Crypto++ defines. Second, add it to your project's preprocessor macros. In either case, <code>CRYPTOPP_IMPORTS</code> will be defined.</p>

<p>I suspect you have a different error, though. You're probably not including the Crypto++ library (for static linking) or Crypto++ import lib (for dynamic linking) in your project.</p>
","194","<visual-studio-2010><visual-c++><crypto++>","0","0","1","2014-04-17 06:28:08","","2","","","","","2012-01-08 11:49:56",""
"52820345","CMake Error: Could NOT find CryptoPP during Artery installation","<p>I'm looking for solution to resolve the problems below. The error messages are generated during Vanetza installation of Artery ITS-G5 V2X system on Window OS. </p>

<p>Platform and tools are:</p>

<ul>
<li>Window 10</li>
<li>MinGw-7.3.0</li>
<li>CMake-3.13.0-rc1</li>
<li>Boost 1.68</li>
<li>Crypto++ -7.0.0</li>
</ul>

<p>The error message:</p>

<pre><code>CMake Error at C:/Program Files (x86)/CMake/share/cmake-3.13/Modules/FindPackageHandleStandardArgs.cmake:137 (message):
  Could NOT find CryptoPP (missing: CryptoPP_INCLUDE_DIR CryptoPP_LIBRARY)
  (Required is at least version ""5.6.1"")

Call Stack (most recent call first):
  C:/Program Files (x86)/CMake/share/cmake-3.13/Modules/FindPackageHandleStandardArgs.cmake:378 (_FPHSA_FAILURE_MESSAGE)
  cmake/FindCryptoPP.cmake:11 (find_package_handle_standard_args)
  CMakeLists.txt:77 (find_package)
</code></pre>

<p>Though I have searched much information related, I could not find the proper solution. </p>

<p>I need your help. Thanks a lot in advance.</p>
","","193","<c++><cmake><crypto++>","0","","0","2018-10-15 16:04:04","","2","","608639","","2018-10-15 16:04:04","2018-10-15 15:45:00",""
"50791822","Crypto++ AES code and undefined symbols on linking","<p>I'm trying to build a cryptopp encryptor (Encryptop.cpp class). Below my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#include &lt;stdexcept&gt;

#include ""cryptlib.h""
#include ""modes.h""
#include ""aes.h""
#include ""filters.h""

#if defined(CRYPTOPP_NO_GLOBAL_BYTE)
  using CryptoPP::byte;
#endif

namespace common {

    Encryptor::Encryptor() {}
    Encryptor::~Encryptor() {}

    std::string Encryptor::encrypt(std::string text)
    {
        byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
        memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
        memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

        std::string ciphertext;

        CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
        CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

        CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
        stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( text.c_str() ), text.length() + 1 );
        stfEncryptor.MessageEnd();

        return ciphertext;
    }

    std::string Encryptor::decrypt(std::string ciphertext)
    {
        byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
        memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
        memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

        CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
        CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

        std::string decryptedtext;

        CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
        stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
        stfDecryptor.MessageEnd();

        return decryptedtext;

    }
}
</code></pre>

<p>I'm getting the following undefined symbols when linking:</p>

<pre><code>/home/myself/dev/common/lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)0, CryptoPP::Rijndael::Enc&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8Rijndael3EncEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
/home/myself/dev/common/lib/libcommon.a(Encryptor.cpp.o): In function `CryptoPP::BlockCipherFinal&lt;(CryptoPP::CipherDir)1, CryptoPP::Rijndael::Dec&gt;::BlockCipherFinal(unsigned char const*, unsigned long)':
Encryptor.cpp:(.text._ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC2EPKhm[_ZN8CryptoPP16BlockCipherFinalILNS_9CipherDirE1ENS_8Rijndael3DecEEC5EPKhm]+0x3b): undefined reference to `CryptoPP::g_nullNameValuePairs'
/home/myself/dev/common/lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP12CBC_ModeBaseE[_ZTVN8CryptoPP12CBC_ModeBaseE]+0x128): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
/home/myself/dev/common/lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP14CipherModeBaseE[_ZTVN8CryptoPP14CipherModeBaseE]+0x100): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
/home/myself/dev/common/lib/libcommon.a(Encryptor.cpp.o):(.rodata._ZTVN8CryptoPP15SymmetricCipherE[_ZTVN8CryptoPP15SymmetricCipherE]+0xe8): undefined reference to `CryptoPP::StreamTransformation::ProcessLastBlock(unsigned char*, unsigned char const*, unsigned long)'
</code></pre>

<p>Am I missing any other libraries (I'm currently linking to libcryptpp), or any missing include file ?</p>

<p>EDIT: 
Installed version of Cryptopp: </p>

<pre><code>$ dpkg-query -l | grep libcrypto
ii  libcrypto++-dev                5.6.1-6+deb8u3                     amd64        General purpose cryptographic library - C++ development
ii  libcrypto++-doc                5.6.1-6+deb8u3                     all          General purpose cryptographic library - documentation
ii  libcrypto++-utils              5.6.1-6+deb8u3                     amd64        General purpose cryptographic library - utilities and data files
ii  libcrypto++9                   5.6.1-6+deb8u3                     amd64        General purpose cryptographic library - shared library
ii  libcrypto++9-dbg               5.6.1-6+deb8u3                     amd64        General purpose cryptographic library - debug symbols
ii  libcryptokit-ocaml             1.9-2                              amd64        cryptographic algorithm library for OCaml - runtime
ii  libcryptokit-ocaml-dev         1.9-2                              amd64        cryptographic algorithm library for OCaml - development
</code></pre>
","","193","<c++><debian><crypto++>","0","","0","2018-07-06 00:50:44","","13","","608639","","2018-07-06 00:50:44","2018-06-11 06:47:02",""
"50643097","LNK2001 unresolved external symbol for SHA3 class members","<p>I am need to calculate SHA3 in my program as well as use AES in my sockets and have decided to use crypto++ library.</p>

<p>I am new to Visual Studio environment with no prior experience on visual studios but have extensively worked on g++ (linux/mingw-w64). One of the third part library I am using recommends Visual Studios (causes linker error when used with g++).</p>

<p>I am getting an linker error.
Error :</p>

<pre><code>LNK2001 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::Update(unsigned char const *,unsigned __int64)"" (?Update@SHA3@CryptoPP@@UEAAXPEBE_K@Z) ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1   

LNK2019 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::Restart(void)"" (?Restart@SHA3@CryptoPP@@UEAAXXZ) referenced in function ""public: __cdecl CryptoPP::SHA3::SHA3(unsigned int)"" (??0SHA3@CryptoPP@@QEAA@I@Z)  ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1   

Error   LNK2001 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::TruncatedFinal(unsigned char *,unsigned __int64)"" (?TruncatedFinal@SHA3@CryptoPP@@UEAAXPEAE_K@Z)   ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1
</code></pre>

<p>The same code works properly in g++(mingw-w64 - I am using dll created in mingw-w64)</p>

<p>OS : Windows 10 Pro 64 bit</p>

<p>Development Environment : Visual Studios 2017</p>

<p>Target : Debug x64</p>

<p>Source :  </p>

<pre><code>#include &lt;sha3.h&gt;
#include &lt;filters.h&gt;
#include &lt;hex.h&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;base64.h&gt;

int main()
{
    CryptoPP::SHA3_512 hash;

    std::cout &lt;&lt; hash.AlgorithmName() &lt;&lt; "" Test."" &lt;&lt; std::endl;

    std::string in = ""The quick brown fox jumps over the lazy dog"";
    std::vector&lt;CryptoPP::byte&gt; out(hash.DigestSize());

    hash.CalculateTruncatedDigest(&amp;out[0], hash.DigestSize(), reinterpret_cast&lt;CryptoPP::byte*&gt;(&amp;in[0]), in.size());

    std::cout &lt;&lt; in &lt;&lt; std::endl;

    std::cout.setf(std::ios::hex, std::ios::basefield);

    for_each(out.begin(), out.end(), [](CryptoPP::byte i) {
        printf(""%x"", i);
    });

    std::cout &lt;&lt; ""Original String : "" &lt;&lt; str &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Kindly advice me how to load (copy) all generated dll in some common folder just like the make install command (facility) in gcc.</p>

<p>Edit :</p>

<p>I have added cryptopp.lib in additional dependencies and added the folder containing both cryptopp.lib and cryptopp.dll in Additional Library Directory. I have added the directory in Path environment variable. I have selected Multi Threaded Debug Dll in Debug x64 configuration during dll generation in cryptolib project.</p>
","<p>You need to link your app against (I believe) <code>cryptopp.lib</code>.  This probably comes in separate versions for 32 bit and 64 bit (I believe the names in the import table differ) so make sure you use the right one.</p>

<p>You can tell Visual Studio to do this via Solution Explorer -> Right-click on project name -> Properties -> Linker -> Input -> Additional Dependencies.  Then just build again.</p>

<p>Your app will need to be able to find the DLL at <em>runtime</em>, not at link time.  If it can't, you will get an error message telling you so when you try to run it.  Copying the DLL to the same directory as the executable is what people usually do (and I hope there's no issue using a DLL created by mingw in Visual Studio).</p>
","188","<c++><visual-studio><crypto++>","1","0","2","2018-06-02 03:42:20","","3","","608639","","2018-06-02 03:42:20","2018-06-01 12:08:05",""
"50643097","LNK2001 unresolved external symbol for SHA3 class members","<p>I am need to calculate SHA3 in my program as well as use AES in my sockets and have decided to use crypto++ library.</p>

<p>I am new to Visual Studio environment with no prior experience on visual studios but have extensively worked on g++ (linux/mingw-w64). One of the third part library I am using recommends Visual Studios (causes linker error when used with g++).</p>

<p>I am getting an linker error.
Error :</p>

<pre><code>LNK2001 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::Update(unsigned char const *,unsigned __int64)"" (?Update@SHA3@CryptoPP@@UEAAXPEBE_K@Z) ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1   

LNK2019 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::Restart(void)"" (?Restart@SHA3@CryptoPP@@UEAAXXZ) referenced in function ""public: __cdecl CryptoPP::SHA3::SHA3(unsigned int)"" (??0SHA3@CryptoPP@@QEAA@I@Z)  ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1   

Error   LNK2001 unresolved external symbol ""public: virtual void __cdecl CryptoPP::SHA3::TruncatedFinal(unsigned char *,unsigned __int64)"" (?TruncatedFinal@SHA3@CryptoPP@@UEAAXPEAE_K@Z)   ConsoleApplication2 C:\Users\Admin\source\repos\ConsoleApplication2\ConsoleApplication2\ConsoleApplication2.obj 1
</code></pre>

<p>The same code works properly in g++(mingw-w64 - I am using dll created in mingw-w64)</p>

<p>OS : Windows 10 Pro 64 bit</p>

<p>Development Environment : Visual Studios 2017</p>

<p>Target : Debug x64</p>

<p>Source :  </p>

<pre><code>#include &lt;sha3.h&gt;
#include &lt;filters.h&gt;
#include &lt;hex.h&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;base64.h&gt;

int main()
{
    CryptoPP::SHA3_512 hash;

    std::cout &lt;&lt; hash.AlgorithmName() &lt;&lt; "" Test."" &lt;&lt; std::endl;

    std::string in = ""The quick brown fox jumps over the lazy dog"";
    std::vector&lt;CryptoPP::byte&gt; out(hash.DigestSize());

    hash.CalculateTruncatedDigest(&amp;out[0], hash.DigestSize(), reinterpret_cast&lt;CryptoPP::byte*&gt;(&amp;in[0]), in.size());

    std::cout &lt;&lt; in &lt;&lt; std::endl;

    std::cout.setf(std::ios::hex, std::ios::basefield);

    for_each(out.begin(), out.end(), [](CryptoPP::byte i) {
        printf(""%x"", i);
    });

    std::cout &lt;&lt; ""Original String : "" &lt;&lt; str &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Kindly advice me how to load (copy) all generated dll in some common folder just like the make install command (facility) in gcc.</p>

<p>Edit :</p>

<p>I have added cryptopp.lib in additional dependencies and added the folder containing both cryptopp.lib and cryptopp.dll in Additional Library Directory. I have added the directory in Path environment variable. I have selected Multi Threaded Debug Dll in Debug x64 configuration during dll generation in cryptolib project.</p>
","<p>Paul Sanders is quite correct, the classes and functions you want to use from the crypto++ DLL must be qualified with <a href=""https://stackoverflow.com/questions/39358641/linking-with-a-dll-compiles-but-causes-a-segfault/39368782#39368782"">_declspec(dllexport) / _declspec(dllimport)</a>.</p>

<p>Some of this has been done already, as described in <a href=""https://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">Crypto++ wiki page for Fips dll</a>. It works thru the preprocessor macro <code>CRYPTOPP_DLL</code>, which is defined in the crypto++ header <code>config.h</code> and used in <code>fips140.h</code>.</p>

<p>There is a problem though - not all the algorithms you want are in FIPS and, as you have found, are not exported for use in a DLL. You could modify other headers to add the DLL export/imports but note that the wiki page suggests : ""If you really need a DLL, then provide a wrapper DLL that links against the static library."". Rather than wrap every component of every crypto++ algorithm you use, it would be more convenient to encapsulate entire operations into a high level class or function which is then exported/imported from your wrapper DLL.</p>

<p>GCC exports everything by default, which is why shared libraries worked for you on Linux.</p>
","188","<c++><visual-studio><crypto++>","1","1","2","2018-06-02 03:42:20","","3","","608639","","2018-06-02 03:42:20","2018-06-01 12:08:05",""
"22110900","Possible reasons a library can't link for a specific architecture?","<p>I've been pulling my hair out trying to link my iOS app with an arm64 library.</p>

<p>The library in question is Crypto++. I've tried both the precompiled fat library that's in the wiki : <a href=""http://www.cryptopp.com/wiki/IOS_(Command_Line)"" rel=""nofollow"">http://www.cryptopp.com/wiki/IOS_(Command_Line)</a>. I've tried compiling the library myself, but I keep getting link errors of the following kind:</p>

<pre><code>  ""std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::__init(char const*, unsigned long, unsigned long)"", referenced from:
      std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; std::__1::operator+&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, char const*) in libcryptopp.a(randpool.o)
      std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; std::__1::operator+&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;, char const*) in libcryptopp.a(modes.o)
</code></pre>

<p>The libcryptopp.a seems to be fine for armv7, but not for arm64 for some reason. If I exclude libcryptopp.a's 64 bit version from the linking process, it gives even more errors.</p>

<p>They both were compiled using -stdlib=libstdc++</p>

<p>What is going on?</p>

<p>(I need arm64 support because of tweak development reasons)</p>

<p><strong>update</strong> sorry all - it turns out it was using the old libcryptopp.a, and not finding the libcryptopp.a properly. The .a was sourced from somewhere else, which has been fixed.</p>
","<blockquote>
  <p>""std::__1::basic_string, std::__1::allocator >::__init(char const*, unsigned long, unsigned long)"", referenced from: ... libcryptopp.a(randpool.o)</p>
</blockquote>

<p>This library has been built, and depends on LLVM's C++ runtime <code>libc++</code>, and <em>not</em> GNU's C++ runtime <code>libstdc++</code>.</p>

<blockquote>
  <p>They both were compiled using -stdlib=libstdc++</p>
</blockquote>

<p>You need to <em>either</em> rebuild <code>libcryptopp.a</code> against <code>libstdc++</code>, <em>or</em> link with <code>-stdlib=libc++</code> (and build the rest of your code against <code>libc++</code> as well).</p>

<hr>

<p>If interested, the <code>__1</code> is an inline namespace used for versioning. See <a href=""https://stackoverflow.com/q/11016220"">What are inline namespaces for?</a> and <a href=""https://stackoverflow.com/q/29293394"">Where does the __1 symbol come from when using LLVM's libc++?</a>.</p>
","184","<c++><ios><linker><static-libraries><crypto++>","2","1","1","2015-03-29 01:52:23","","3","0","277941","","2014-03-02 15:09:47","2014-03-01 06:13:32",""
"35241696","Use of Pipelines to encrypt a file","<p>I have just startet working with crypto++ and i have a question about the piplenes and how to use them to encrypt a file.</p>

<p>I want to use AES to encrypt a file.</p>

<p>1.)Would it be enough to just do:</p>

<pre><code>EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(derived.data(), 16, ivb, ivb.size());
FileSource f(""source"", new AuthenticatedEncryptionFilter(encryptor,new FileSink(""deststination"")));
</code></pre>

<p>2.) If i have a huge input file, will this approach automaticly encrypt the files in blocks?</p>

<p>3.) Would this automaticly create the output file if it is not there?</p>

<p><strong>EDIT:</strong></p>

<p>Ok, i got it to wok with my approch.</p>

<p>The 2.) Question remains and i have a new one:</p>

<p>Can I tell it to skip the first 24 bytes of the file?</p>
","<blockquote>
<pre><code>EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(derived.data(), 16, ivb, ivb.size());
FileSource f(""source"", new AuthenticatedEncryptionFilter(encryptor,new FileSink(""deststination"")));
</code></pre>
</blockquote>

<p>Close. The <code>AuthenticatedEncryptionFilter</code> will be coerced to the <code>bool pumpAll</code> parameter of <code>FileSink</code>. So you need:</p>

<pre><code>FileSource f(""source"", true, new AuthenticatedEncryptionFilter(encryptor,new FileSink(""deststination"")));
</code></pre>

<p>Also see <a href=""http://www.cryptopp.com/wiki/FileSource"" rel=""nofollow"">FileSource</a> on the Crypto++ wiki. And the <a href=""http://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow"">FileSource Class Reference</a> from the manual might be of interest, too.</p>

<hr>

<blockquote>
  <p>If i have a huge input file, will this approach automatically encrypt the files in blocks?</p>
</blockquote>

<p>Yes. Internally, Crypto++ will ""block"" or ""chunk"" the processing in 4096-bytes, IIRC. A recent discussion about it occurred on the mailing list at <a href=""http://groups.google.com/d/msg/cryptopp-users/WezFWb9XQ84/rnHGDTO9CwAJ"" rel=""nofollow"">ios locking up during encryption</a>.</p>

<p>A program that <a href=""http://groups.google.com/d/msg/cryptopp-users/WezFWb9XQ84/NoFUitCrDQAJ"" rel=""nofollow"">allows you to do the blocking</a> is provided in the post. You can use it to throttle the processing, a place to update a progress bar or yield the processor, if needed. Its reproduced below.</p>

<hr>

<blockquote>
  <p>Would this automatically create the output file if it is not there?</p>
</blockquote>

<p>Yes. The <code>FileSource</code> is just a <code>std::ifstream</code> wrapper, while a <code>FileSink</code> is just a <code>std::ofstream</code> wrapper.</p>

<p>Again, here are the wiki pages:</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/FileSource"" rel=""nofollow"">FileSource</a></li>
<li><a href=""http://cryptopp.com/wiki/FileSink"" rel=""nofollow"">FileSink</a></li>
</ul>

<hr>

<blockquote>
  <p>Can I tell it to skip the first 24 bytes of the file?</p>
</blockquote>

<p>Yes. In this case, use <code>bool pumpAll</code> and set it to <code>false</code>. Then do something like:</p>

<pre><code>FileSource fs(""source"", false, new AuthenticatedEncryptionFilter(...));
fs.Skip(24);

size_t remaining = &lt;size of file&gt;;
size_t BLOCK_SIZE = 512;
while(remaining &amp;&amp; !fs.SourceExhausted())
{    
    const unsigned int req = STDMIN(remaining, BLOCK_SIZE);
    fs.Pump(req);
    fs.Flush(false);

    remaining -= req;
}
</code></pre>

<p>Or, you can:</p>

<pre><code>FileSource fs(""source"", false, new AuthenticatedEncryptionFilter(...));
fs.Skip(24);
fs.PumpAll();
</code></pre>

<p>Also see <a href=""http://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow"">FileSource Class Reference</a> in the manual. <code>Skip</code> is part of <code>BufferedTransformation</code>; and <code>PumpAll</code> is part of <code>Source</code>.</p>

<hr>

<p>There are also wiki pages covering EAX mode and the authenticated {en|de}cryption filters. See:</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/Eax_mode"" rel=""nofollow"">EAX Mode</a></li>
<li><a href=""http://cryptopp.com/wiki/AuthenticatedEncryptionFilter"" rel=""nofollow"">AuthenticatedEncryptionFilter</a></li>
<li><a href=""http://cryptopp.com/wiki/AuthenticatedDecryptionFilter"" rel=""nofollow"">AuthenticatedDecryptionFilter</a></li>
</ul>

<p>There's even a page on using a Java-like Init/Update/Final at:</p>

<ul>
<li><a href=""http://cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow"">Init-Update-Final</a></li>
</ul>

<hr>

<p>The program below uses <strong><em><code>CFB_Mode&lt;AES&gt;</code></em></strong>, but its easy enough to swap in another cipher and mode. It also demonstrates how to place objects on the stack and use them in a pipeline rather than creating them on the heap with <strong><em><code>new</code></em></strong>.</p>

<pre><code>int main(int argc, char* argv[])
{
  static const unsigned int BIG_SIZE = 2U * 1024U * 1024U;    
  static const unsigned int BLOCK_SIZE = 4096U;

  try
    {
      SecByteBlock key(32);
      OS_GenerateRandomBlock(false, key.data(), key.size());

      // cout &lt;&lt; ""Key: "";
      // ArraySource as(key.data(), key.size(), true, new HexEncoder(new FileSink(cout)));
      // cout &lt;&lt; endl;

      CFB_Mode&lt;AES&gt;::Encryption enc;
      enc.SetKeyWithIV(key.data(), key.size(), key.data());

      MeterFilter meter;
      StreamTransformationFilter stf(enc);

      FileSource source(""/dev/zero"", false);
      FileSink sink(""zero.enc"");

      source.Attach(new Redirector(stf));
      stf.Attach(new Redirector(meter));
      meter.Attach(new Redirector(sink));    

      unsigned int remaining = BIG_SIZE;
      while(remaining &amp;&amp; !source.SourceExhausted())
      {
        if(remaining % (1024) == 0)
        {
          cout &lt;&lt; ""Processed: "" &lt;&lt; meter.GetTotalBytes() &lt;&lt; endl;    
        }

        const unsigned int req = STDMIN(remaining, BLOCK_SIZE);
        source.Pump(req);
        source.Flush(false);

        remaining -= req;
    }
  }
  catch(const Exception&amp; ex)
  {
    cerr &lt;&lt; ex.what() &lt;&lt; endl;
  }

  return 0;
}
</code></pre>
","184","<c++><encryption><crypto++>","1","1","1","2016-02-08 22:30:09","35249802","1","0","608639","","2016-02-08 22:30:09","2016-02-06 13:40:23",""
"34479894","How can I concatenate two byte* (secblock) with operator 'secblock<T, A>::operator+='","<p>Please little example. I tried use this as in documentation, but I can not understand how to.</p>

<p>Messages:</p>

<pre><code>main.cpp|97|error: no matching function for call to 
   'CryptoPP::SecBlock&lt;unsigned char&gt;::operator+=(CryptoPP::SecBlock&lt;unsigned char&gt;*)'
   secblock.h|568|note: candidate: 
   CryptoPP::SecBlock&lt;T, A&gt;&amp; CryptoPP::SecBlock&lt;T, A&gt;::operator+=(const CryptoPP::SecBlock&lt;T, A&gt;&amp;)
   [with T = unsigned char; A = CryptoPP::AllocatorWithCleanup&lt;unsigned char&gt;]
   secblock.h|568|note:   
   no known conversion for argument 1 from 'CryptoPP::SecBlock&lt;unsigned char&gt;*' 
   to 'const CryptoPP::SecBlock&lt;unsigned char&gt;&amp;'
</code></pre>

<p>My code:</p>

<pre><code>SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160_temp;
  RIPEMD160().CalculateDigest(hash_ripemd160_temp, hash_sha256, 32);

  SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160 = L0_byte;

   hash_ripemd160 = SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (&amp;hash_ripemd160_temp);
</code></pre>

<p>In Docs is as:</p>

<pre><code>SecBlock&lt;byte , AllocatorWithCleanup&lt;byte &gt; &gt;&amp; SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (const SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt; &amp;t)     
Append contents from another SecBlock.

Parameters

t   the other SecBlock

Internally, this SecBlock calls Grow and then copies the new content.

If the memory block is reduced in size, then the unused area is set to 0.
</code></pre>

<p>Definition at line 568 of file secblock.h.</p>
","<p>The easiest way to call an operator function is to just use the operator:</p>

<pre><code>  hash_ripemd160 += hash_ripemd160_temp;
</code></pre>

<p>If you want to call it directly (which I would not recommend) you have to call it like this, since it is a member function:</p>

<pre><code>hash_ripemd160.operator += (hash_ripemd160_temp);
</code></pre>
","182","<c++><crypto++><allocator>","1","1","3","2015-12-28 10:43:54","","1","","5720337","","2015-12-28 10:07:46","2015-12-27 11:18:35",""
"34479894","How can I concatenate two byte* (secblock) with operator 'secblock<T, A>::operator+='","<p>Please little example. I tried use this as in documentation, but I can not understand how to.</p>

<p>Messages:</p>

<pre><code>main.cpp|97|error: no matching function for call to 
   'CryptoPP::SecBlock&lt;unsigned char&gt;::operator+=(CryptoPP::SecBlock&lt;unsigned char&gt;*)'
   secblock.h|568|note: candidate: 
   CryptoPP::SecBlock&lt;T, A&gt;&amp; CryptoPP::SecBlock&lt;T, A&gt;::operator+=(const CryptoPP::SecBlock&lt;T, A&gt;&amp;)
   [with T = unsigned char; A = CryptoPP::AllocatorWithCleanup&lt;unsigned char&gt;]
   secblock.h|568|note:   
   no known conversion for argument 1 from 'CryptoPP::SecBlock&lt;unsigned char&gt;*' 
   to 'const CryptoPP::SecBlock&lt;unsigned char&gt;&amp;'
</code></pre>

<p>My code:</p>

<pre><code>SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160_temp;
  RIPEMD160().CalculateDigest(hash_ripemd160_temp, hash_sha256, 32);

  SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160 = L0_byte;

   hash_ripemd160 = SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (&amp;hash_ripemd160_temp);
</code></pre>

<p>In Docs is as:</p>

<pre><code>SecBlock&lt;byte , AllocatorWithCleanup&lt;byte &gt; &gt;&amp; SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (const SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt; &amp;t)     
Append contents from another SecBlock.

Parameters

t   the other SecBlock

Internally, this SecBlock calls Grow and then copies the new content.

If the memory block is reduced in size, then the unused area is set to 0.
</code></pre>

<p>Definition at line 568 of file secblock.h.</p>
","<blockquote>
  <p>How can I concatenate two byte* (secblock) with <code>operator 'secblock&lt;T, A&gt;::operator+='</code></p>
</blockquote>

<p>Try the following <em>after</em> you pull <a href=""http://github.com/weidai11/cryptopp/commit/605744d8260c6ada033805c13ae0b2646acf18d6"" rel=""nofollow"">commit 605744d8260c6ada</a>. (Or perform a fresh checkout with <code>git clone https://github.com/weidai11/cryptopp.git</code>).</p>

<pre><code>$ cat test.cxx 
#include ""ripemd.h""
#include ""files.h""
#include ""hex.h""
using namespace CryptoPP;

#include &lt;string&gt;
using namespace std;

int main(int argc, char* argv[])
{
  SecByteBlock digest(RIPEMD160::DIGESTSIZE);
  RIPEMD160 hash;

  std::string message(""now is the time for all good men to come to the aide of their country"");
  HexEncoder hexer(new FileSink(cout));

  // RIPEMD-160
  hash.Update((const byte*)message.data(), message.size());
  hash.TruncatedFinal(digest, digest.size());

  cout &lt;&lt; ""RIPEMD-160: "";
  hexer.Put(digest, digest.size());
  cout &lt;&lt; endl;

  // Double it
  digest += digest;

  cout &lt;&lt; ""RIPEMD-160 (x2): "";
  hexer.Put(digest, digest.size());
  cout &lt;&lt; endl;

  return 0;
}
</code></pre>

<hr>

<p>You and Alan uncovered the the typos in the <code>assert</code>. I was not aware the self tests did not exercise the code paths. That's now been fixed, and we opened another issue to address the defect in the engineering process: <a href=""http://github.com/weidai11/cryptopp/issues/93"" rel=""nofollow"">Need a Code Coverage tool added to the Release Process</a>.</p>

<hr>

<p>You also uncovered a nasty little bug in self-concatenation (i.e., <code>digest += digest</code>). It has been been changed to the following to detect it:</p>

<pre><code>SecBlock&lt;T, A&gt;&amp; operator+=(const SecBlock&lt;T, A&gt; &amp;t)
{
    assert((!t.m_ptr &amp;&amp; !t.m_size) || (t.m_ptr &amp;&amp; t.m_size));

    if(t.m_size)
    {
        if(this != &amp;t)  // s += t
        {
            const size_type oldSize = m_size;
            Grow(m_size+t.m_size);
            memcpy_s(m_ptr+oldSize, (m_size-oldSize)*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
        }
        else            // t += t
        {
            SecBlock result(m_size+t.m_size);
            if(m_size) {memcpy_s(result.m_ptr, result.m_size*sizeof(T), m_ptr, m_size*sizeof(T));}
            memcpy_s(result.m_ptr+m_size, (result.m_size-m_size)*sizeof(T), t.m_ptr, t.m_size*sizeof(T));
            swap(result);
        }
    }
    return *this;
}
</code></pre>

<p>Prior to the fix/commit, it looks like it should trigger an <code>InvalidArgument</code> exception under most conditions. However, there are some corner cases on Windows that we are not so sure about which could lead to a silent truncation.</p>

<p>The silent truncation is concerning, and we are debating a Crypto++ 5.6.4 release.</p>
","182","<c++><crypto++><allocator>","1","0","3","2015-12-28 10:43:54","","1","","5720337","","2015-12-28 10:07:46","2015-12-27 11:18:35",""
"34479894","How can I concatenate two byte* (secblock) with operator 'secblock<T, A>::operator+='","<p>Please little example. I tried use this as in documentation, but I can not understand how to.</p>

<p>Messages:</p>

<pre><code>main.cpp|97|error: no matching function for call to 
   'CryptoPP::SecBlock&lt;unsigned char&gt;::operator+=(CryptoPP::SecBlock&lt;unsigned char&gt;*)'
   secblock.h|568|note: candidate: 
   CryptoPP::SecBlock&lt;T, A&gt;&amp; CryptoPP::SecBlock&lt;T, A&gt;::operator+=(const CryptoPP::SecBlock&lt;T, A&gt;&amp;)
   [with T = unsigned char; A = CryptoPP::AllocatorWithCleanup&lt;unsigned char&gt;]
   secblock.h|568|note:   
   no known conversion for argument 1 from 'CryptoPP::SecBlock&lt;unsigned char&gt;*' 
   to 'const CryptoPP::SecBlock&lt;unsigned char&gt;&amp;'
</code></pre>

<p>My code:</p>

<pre><code>SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160_temp;
  RIPEMD160().CalculateDigest(hash_ripemd160_temp, hash_sha256, 32);

  SecBlock&lt;byte, AllocatorWithCleanup&lt;byte&gt; &gt; hash_ripemd160 = L0_byte;

   hash_ripemd160 = SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (&amp;hash_ripemd160_temp);
</code></pre>

<p>In Docs is as:</p>

<pre><code>SecBlock&lt;byte , AllocatorWithCleanup&lt;byte &gt; &gt;&amp; SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (const SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt; &amp;t)     
Append contents from another SecBlock.

Parameters

t   the other SecBlock

Internally, this SecBlock calls Grow and then copies the new content.

If the memory block is reduced in size, then the unused area is set to 0.
</code></pre>

<p>Definition at line 568 of file secblock.h.</p>
","<p>Remove the <code>&amp;</code> before <code>hash_ripemd160_temp</code></p>

<pre><code>hash_ripemd160 = SecBlock&lt; byte , AllocatorWithCleanup&lt;byte &gt; &gt;::operator+= (hash_ripemd160_temp);
</code></pre>

<p>The operator accepts the object, not the pointer.</p>
","182","<c++><crypto++><allocator>","1","0","3","2015-12-28 10:43:54","","1","","5720337","","2015-12-28 10:07:46","2015-12-27 11:18:35",""
"21458041","SHA512 message schedule","<p>I am trying to debug a SHA512 implementation in Verilog,  but I can't find an example message schedule anywhere. I have made a simple C++ program made with Crypto++ but I can't find which variable to debug to see the complete message schedule,  since it's written in assembler. </p>

<p>I need either an example schedule or help to identify the crypto++ schedule </p>
","<p>Include <code>crypto++</code> in your project code, then open <code>sha.h</code> file and add your breakpoints, compile your code with debug, then when your code pause at a breakpoint you'll see whole SHA512 code and you'll be able to debug and see all variables including message schedule. If you add breakpoint in SHA512 function and compile your code with debug, you won't see assembly code, instead, you'll see C++ source code of it and you'll be able to add variables to watch window and check their values.</p>

<p>Also you can press <code>F11</code> while debugging (step-into) to get into hash function, again it won't be assembly, you'll see C++ code of hash function. Then follow code and see SHA message schedule.</p>

<p>As you know in SHA for each round, there is one round constant <code>k[i]</code> and one entry in the message schedule array <code>w[i], 0 ≤ i ≤ 63</code>. Therefore open sha.cpp and you'll see w variable, that's what you need to debug.
Also I have to tell you, SHA code and a lot of parts of <code>Crypto++</code> is written in <code>assembly</code>, so it doesn't matter you are debugging or reading a code, it's written in assembly.
So you can uncomment </p>

<pre><code>""// smaller but slower""
</code></pre>

<p>part in sha.cpp and use C++ code instead of assembly code or simply use another library for SHA which you'll be able to debug easily.</p>
","182","<c++><hash><sha512><crypto++>","0","1","1","2014-01-30 14:01:00","21458433","0","","","","","2014-01-30 13:37:16",""
"31348936","SecByteBlock won't accept string as custom key","<p>I am trying to use a custom key with Crypto++. My program works with a random key, but I am getting a intellisense error when I try to pass <code>SecByteBlock</code> a key.</p>

<p>The reference <a href=""http://www.cryptopp.com/docs/ref/class_sec_block.html"" rel=""nofollow"">here</a>  defines it as <code>SecBlock (const T *t, size_type len)</code> but I have never encountered const T before.</p>

<pre><code>void EncryptFile(string cEncryptionKey, string cFilePath, string cTempFilepath)
    SecByteBlock key_aes(pEncryptionKey, AES::DEFAULT_KEYLENGTH);//giving error
    //SecByteBlock key_aes(ES::DEFAULT_KEYLENGTH); // Generates a random key
</code></pre>
","<p>A <code>SecByteBlock</code> is a typedef for <a href=""http://www.cryptopp.com/docs/ref/class_sec_block.html"" rel=""nofollow""><code>SecBlock&lt; T, A &gt;</code></a> with <code>T = byte</code>. The three constructors are:</p>

<pre><code>SecBlock (size_type size=0)
SecBlock (const SecBlock&lt; T, A &gt; &amp;t)
SecBlock (const T *t, size_type len)
</code></pre>

<p>There is no constructor which you are trying to use. This does not exist:</p>

<pre><code>SecByteBlock (const string&amp; str, size_type size)
</code></pre>

<p>So you only need to:</p>

<pre><code>ASSERT(key.size() == AES::DEFAULT_KEYLENGTH);
SecByteBlock key_aes(reinterpret_cast&lt;const byte*&gt;(key.data()), key.size());
</code></pre>

<p>You may need to perform a <code>static_cast&lt;size_t&gt;(AES::DEFAULT_KEYLENGTH)</code>, but you usually do not have to. If you use <code>-Wextra</code>, <code>-Wsign-conversion</code> or <code>-Wconversion</code>, you may have to.</p>

<hr>

<p>Stepping back to 10,000 feet, you should probably avoid putting the key in a <code>string</code> to begin with.</p>

<p>Create a <code>SecByteBlock</code> with a size (the first constructor above), and read directly into it. Then, pass the <code>SecByteBlock</code> by reference to <code>EncryptFile</code>.</p>

<hr>

<p>Related, we are just about at the point we get a clean compile with <code>-Wall</code>, so you should probably enable it in your project. To use the cleaner sources, you need to <a href=""http://www.cryptopp.com/wiki/SVN"" rel=""nofollow"">checkout from SVN</a> or <a href=""http://www.cryptopp.com/wiki/GitHub_and_Git"" rel=""nofollow"">clone from Git</a>.</p>
","180","<c++><aes><crypto++>","0","2","1","2015-07-11 01:00:34","","1","0","608639","","2015-07-10 22:31:49","2015-07-10 19:34:33",""
"37273408","Crypto++ RSA - Encrypt and sign with the same key pair","<p>I have a program A which needs to send messages to a program B1. The messages must be crypted, and also signed. Which means only B1 can decode, and he must be sure that the message comes from A.</p>

<p>Also, B1 should not be able to encrypt messages and take the role of A towards another instance B2 of the same program.</p>

<p>Theoretically, it should be possible to use a single RSA key pair, with a key for A and a key for B1. Once decoded by B, if the recovered message is validated (such as by a hash function), it must have been sent by A which did not disclose its key to anybody. In that case, both keys are private (which means they have to be exchanged in a secure channel)</p>

<p>1) Is this recommended or is there a strong argument in favor of having separate encryption and signing steps with independent key pairs?</p>

<p>2) Practically, in the Crypto++ library, the <code>PrivateKey</code> class also contains the public key. Is there a way to load a private key only?</p>
","<blockquote>
  <p>Is this recommended or is there a strong argument in favor of having separate encryption and signing steps with independent key pairs?</p>
</blockquote>

<p>This is kind of a broad topic. There are a number of things you can do depending on your threat model and risk posture. You should probably start by researching <a href=""http://www.google.com/search?q=key+management+and+separation"" rel=""nofollow noreferrer"">key management and separation</a>.</p>

<p>Since it appears you have selected RSA, then you might want to take a look at <a href=""https://crypto.stackexchange.com/q/11149/10496"">Bleichenbacher 1998 “Million message attack” on RSA</a> on Crypto.SE and follow its improvements to 30,000 messages (IIRC). This is where your threat models and risk posture factor into things.</p>

<hr>

<blockquote>
  <p>Practically, in the Crypto++ library, the PrivateKey class also contains the public key. Is there a way to load a private key only?</p>
</blockquote>

<p>I think you have a misunderstanding of the keys. The public key cannot be disgorged from the private key.</p>

<p>The public key is the <code>{n,e}</code> pair, and the private key is either <code>{n,e,d}</code> or <code>{n,e,d,p,q,dp,dp,u}</code>. If you remove <code>n</code> and <code>e</code>, then the private key won't work. If you remove <code>e</code> alone, then you need to factor <code>n</code> to recover <code>e</code>. Also see <a href=""https://stackoverflow.com/q/36555930/608639"">RSA function generates public key (e) always to 17</a> on Stack Overflow.</p>
","178","<encryption><rsa><signing><crypto++>","1","1","1","2016-05-19 05:30:09","37314434","9","","2042388","","2016-05-17 10:43:40","2016-05-17 10:21:33",""
"52006356","Crypto++ and garbage at end of string after performing AES decryption","<p>I am integrating Crypto++ into my C++ app and so far it's working, almost. </p>

<p>The encryption works perfect. The output matches what I would expect it to. However, when I go to decrypt, it's adding square characters on the end.</p>

<p>Here is my Encrypt function:</p>

<pre><code>string Encryption::EncryptAES(const string &amp;text, const string &amp;key) {
    string cipher;

    AES::Encryption aes((byte *) key.c_str(), 32);

    ECB_Mode_ExternalCipher::Encryption ecb(aes);

    StreamTransformationFilter encrypt(ecb, new StringSink(cipher), StreamTransformationFilter::ZEROS_PADDING);

    encrypt.Put(reinterpret_cast&lt;const unsigned char *&gt;( text.c_str()), text.length() + 1);
    encrypt.MessageEnd();
    return Base64::Encode(cipher);
}
</code></pre>

<p>Here is my Decrypt function:</p>

<pre><code>string Encryption::DecryptAES(const string &amp;text, const string &amp;key) {
    string decoded;
    Base64::Decode(text, decoded);
    string decrypted;

    AES::Decryption aes((byte *) key.c_str(), 32);
    ECB_Mode_ExternalCipher::Decryption ecb(aes);

    StreamTransformationFilter decrypt(ecb, new StringSink(decrypted), StreamTransformationFilter::ZEROS_PADDING);

    decrypt.Put(reinterpret_cast&lt;const unsigned char *&gt;( decoded.c_str()), decoded.length());
    decrypt.MessageEnd();

    return decrypted;
}
</code></pre>

<p>I'm using the following for the Base64 Encode/Decode:
<a href=""https://gist.github.com/tomykaira/f0fd86b6c73063283afe550bc5d77594"" rel=""nofollow noreferrer"">Base64 Encode/Decode</a></p>

<p>Here is the code I call to encrypt/decrypt:</p>

<pre><code>string encryptedPass = EncryptAES(value, key);
cout &lt;&lt; ""Encrypted Text: "" &lt;&lt; encryptedPass &lt;&lt; endl;

string decryptedPass = DecryptAES(encryptedPass, key);
cout &lt;&lt; ""Decryped Text: "" &lt;&lt; decryptedPass &lt;&lt; endl;
</code></pre>

<p>Here is the output:
<a href=""https://i.stack.imgur.com/W30Fc.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/W30Fc.png"" alt=""enter image description here""></a></p>

<p>When I copy and past the output into Notepad++, it's a bunch of spaces. I have a feeling it deals with the <code>ZEROS_PADDING</code>, but I need that in there to match our other applications that we are using. </p>

<p>I'm not sure how to actually try to fix this. Thoughts?</p>
","<p>Based on the comments I was able to figure out what was at the end of the string. I knew it had to deal with zero padding, but due to being new at C++, I didn't fully understand what was going on. </p>

<p>I ran this to get the ascii value of the character:</p>

<pre><code>for(char&amp; c : s){
    cout &lt;&lt; ""Char:"" &lt;&lt; (int)c &lt;&lt; endl;
}
</code></pre>

<p>This resulted in the following at the end of the string:</p>

<pre><code>Char:0
Char:0
Char:0
Char:0
Char:0
Char:0
</code></pre>

<p>And according to the <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII</a> table it's <code>NUL</code></p>

<p>So, the simple solution for this is to do this:</p>

<pre><code>std::string(value.c_str());
</code></pre>
","177","<c++><encryption><base64><aes><crypto++>","3","1","1","2018-08-25 01:09:25","52007909","6","","608639","","2018-08-25 01:09:25","2018-08-24 14:12:54",""
"51260419","Mismatch detected for 'RuntimeLibrary' in QtCreator with Qt 5.11 and Crypto++","<p>I'm trying to build my project, which combines Qt 5.11 and CryptoPP 7.0.0 .
I also need to build it statically. So I configured Qt with :</p>

<pre><code>configure -release -opensource -platform win32-msvc2017 -static -nomake examples -nomake tests
</code></pre>

<p>This gives me all Qt libs under <code>qt-everywhere-src-5.11.1\build_static\lib</code></p>

<p>QtCreator builds Qt code successfully with this kit, and the generated binary can run without Qt DLLs, so I assume everything is right here.</p>

<p>On the other hand, I picked up CryptoPP sources, opened .sln file, set the /MT flag, then I have a <code>cryptlib.lib</code> under <code>cryptopp700\x64\Output\Release\</code>.</p>

<p>My Crypto++ code builds successfully, and again, generated binary executes without the need of any DLL.</p>

<p>Now I want to compile a code that combine both libraries, I chose QtCreator.
I added these lines to my <code>.pro</code> file :</p>

<pre><code>QMAKE_CXXFLAGS_RELEASE = -MT
CONFIG += static
INCLUDEPATH += $$PWD/../cryptopp700
DEPENDPATH += $$PWD/../cryptopp700
LIBS += $$PWD/../cryptopp700/x64/Output/Release/cryptlib.lib
</code></pre>

<p>QMake ran without error, but, at compile time, I get hundreds of errors like:</p>

<pre><code>LNK 2038 : mismatch detected for 'RuntimeLibrary' : MD_DynamicRelease 
doesn't match with 'MT_StaticRelease' in main.obj
</code></pre>

<p>And this for every Qt .lib file.</p>

<p>The last thing I tried is to modify qmake.conf under <code>qt-everywhere-src-5.11.1\build_static\mkspecs\win32-msvc\qmake.conf</code> by setting :</p>

<pre><code>QMAKE_CFLAGS           += /MT
QMAKE_CXXFLAGS         += /MT
</code></pre>

<p>but that didn't solve anything.
It seems that one of the 2 libraries aren't statically built, but since they are, I don't know where to search now...</p>
","","176","<c++><qt5><qt-creator><crypto++>","0","","0","2018-08-28 00:10:27","","3","","608639","","2018-08-28 00:10:27","2018-07-10 08:22:22",""
"39987047","Garbage at end of file after encryption and decryption","<p>I am trying to encrypt and decrypt a file (a text or whatsoever), so I decided to use the Crypto++. Below is my code.</p>

<p><strong><em>crypt.h</em></strong>:</p>



<pre><code>#ifndef CRYPT_HPP_
# define CRYPT_HPP_

# include &lt;crypto++/aes.h&gt;
# include &lt;crypto++/osrng.h&gt;
# include &lt;crypto++/blowfish.h&gt;
# include &lt;crypto++/eax.h&gt;
# include &lt;crypto++/files.h&gt;
# include &lt;iostream&gt;

using namespace CryptoPP;
using namespace std;

class Crypt
{
  public:
    Crypt() {};
    ~Crypt() {};

    int init();
    int encrypt(const string &amp;file);
    int decrypt(const string &amp;file, int const);

    AutoSeededRandomPool  _randomGenerator;
    SecByteBlock          _aesKey, _aesIV;
};

#endif /* !CRYPT_HPP_ */
</code></pre>

<p><strong><em>crypt.cpp</em></strong>:</p>



<pre><code>int Crypt::init()
{
    try
    {
        _aesKey.New(Blowfish::DEFAULT_KEYLENGTH);
        _aesIV.New(Blowfish::BLOCKSIZE);

        _randomGenerator.GenerateBlock(_aesKey, _aesKey.size());
        _randomGenerator.GenerateBlock(_aesIV, _aesIV.size());
    }
    catch (CryptoPP::Exception &amp;e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return (-1);
    }
    return (0);
}
</code></pre>

<p>The encryption and decryption is performed with:</p>



<pre><code>int Crypt::encrypt(const string &amp;fileToEncrypt)
{
    EAX&lt; Blowfish &gt;::Encryption e1;
    e1.SetKeyWithIV(_aesKey, _aesKey.size(), _aesIV);

    string encryptedFile = ""crypt.txt"";
    FileSource fs1(fileToEncrypt.c_str(), true,
                   new AuthenticatedEncryptionFilter(e1,
                        new FileSink(encryptedFile.c_str())));
    return (0);
}

int Crypt::decrypt(const string &amp;fileToDecrypt)
{
    EAX&lt; Blowfish &gt;::Decryption e1;
    e1.SetKeyWithIV(_aesKey, _aesKey.size(), _aesIV);

    string finalFile = ""decrypt.txt"";
    FileSource fs1(fileToDecrypt.c_str(), true,
                   new AuthenticatedEncryptionFilter(e1,
                        new FileSink(finalFile.c_str())));
    return (0);
}
</code></pre>

<p>The problem is that when I decrypt and get the final file, I actually get the right output PLUS some weird binary stuff. Like this (encrypt then decrypt a Makefile, I skipped to the end as this is the most interesting part) :</p>



<pre><code> fclean: clean
     $(RM) $(NAME)
     $(RM) $(TEST)
     $(RM) -R $(OBJDIR)

 re: fclean all
 �ٌ[�MT̨z���,�o% 
</code></pre>

<p>Did someone already face this problem ? Or can someone help me please ? </p>

<p>Thank you !</p>
","<p>So... I found a solution but this is <strong>NOT</strong> a real valuable one. I only found a little trick to do the job.</p>

<p><strong>Requirement</strong> : You need the size of the file BEFORE it is encrypted.</p>

<p>Here is the decrypt method I modified :</p>

<pre><code> int                     Crypt::decrypt(const string &amp;fileToDecryptName, const string &amp;finalFileName,
                                      int const previousSize) {
  EAX&lt;AES&gt;::Decryption  decryption;
  ofstream              finalFile;
  ifstream              tmpFile;
  std::vector&lt;char&gt;     buffer(previousSize);

  try {
    decryption.SetKeyWithIV(_aesKey, _aesKey.size(), _aesIV);
    FileSource fs1(fileToDecryptName.c_str(), true,
              new AuthenticatedEncryptionFilter(decryption, new FileSink(""tmp"")));
  } catch (Exception &amp;e) {
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    return (-1);
  }

  finalFile.open(finalFileName.c_str());
  tmpFile.open(""tmp"");
  tmpFile.seekg(0, std::ios::beg);
  if (tmpFile.is_open() &amp;&amp; tmpFile.read(buffer.data(), previousSize)) {
    if (finalFile.is_open()) {
      finalFile.write(buffer.data(), previousSize);
    } else {
      finalFile.close();
      tmpFile.close();
      throw CommonError(""Error : the destination file cannot receive the decrypted content."");
    }
  } else {
    finalFile.close();
    tmpFile.close();
    throw CommonError(""Error : decryption cannot be done due to an unexisting or empty file."");
  }
  finalFile.close();
  tmpFile.close();
  return (0);
}
</code></pre>

<p><strong>TL;DR</strong> : I put the decrypted content into a <em>temporary file</em> then I opened it, read its content and copied the data (<strong><em>finalFile.write(buffer.data(), previousSize)</em></strong> actually copy the data until it reaches previousSize characters) into the final file. This is how you can get rid of the garbage at the end of the file.</p>
","175","<c++><encryption><crypto++>","1","-1","1","2016-10-12 11:20:01","","11","","608639","","2016-10-11 22:28:31","2016-10-11 21:28:12",""
"52713870","sha1 hash for std::vector<uint8_t> using crypto++","<p>I have collection of vectors of the type <code>std::vector&lt;uint8_t&gt;</code> and I need to store a hashed value for each individual vector. 
I would like to use crypto++ for this. But I am not sure if it is possible. From what I can tell, I would be able if I made it a <code>std::vector&lt;byte&gt;</code>. However, the examples I have seen also provides the hash value in a <code>std::vector&lt;byte&gt;</code>. So is what I want to do at all possible with crypto++ or do I need to look for another library? If yes, can you provided an example? </p>

<p><em>EDIT:</em> 
Example with byte pointer (<a href=""https://www.cryptopp.com/wiki/User_guide:_cryptlib.h"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/User_guide:_cryptlib.h</a>):</p>

<pre><code>byte const* pbData1 = ...;
byte const* pbData2 = ...
unsigned int nData1Len = ...;
unsigned int nData2Len = ...;
byte abDigest[SHA::DIGESTSIZE];

SHA hash;
hash.Update(pbData1, nData1Len);
hash.Update(pbData2, nData2Len);
hash.Final(abDigest);

// abDigest now contains the hash of pbData1 and pbData2;
// the object 'hash' can now be reused to calculate another digest

...

SHA hash;
hash.Update(pbData1, nData1Len);
hash.Update(pbData2, nData2Len);
if (!hash.Verify(abDigest))
    throw ""abDigest does not contain the right hash"";
</code></pre>
","","175","<c++><crypto++>","1","","0","2018-10-09 06:32:43","","7","","936269","","2018-10-09 06:32:43","2018-10-09 05:25:19",""
"40623607","Cannot pass AutoSeededRandomPool as parameter when using CryptoPP::RSA, error C2729","<p>I am working with implement RSA using Crypto++. I am trying to generate a pair of RSA keys (public and private) to file like this.</p>

<p>The code can run perfect when I put all in <code>main</code>. When I try to split it to a function and pass <code>AutoSeededRandomPool</code> object as parameter like this:</p>

<pre class=""lang-cxx prettyprint-override""><code>int generateKeyToFile(
    AutoSeededRandomPool rnd, 
    string publicKeyFileName, string privateKeyFileName){
    try
    {
        RSA::PrivateKey rsaPrivate;
        rsaPrivate.GenerateRandomWithKeySize(rnd, 3072);

        RSA::PublicKey rsaPublic(rsaPrivate);
        EncodePrivateKey(privateKeyFileName, rsaPrivate);
        EncodePublicKey(publicKeyFileName, rsaPublic);

        cout &lt;&lt; ""Successfully generated and saved RSA keys"" &lt;&lt; endl;
        return 1;
    }

    catch (CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return -1;
    }
}
</code></pre>

<p>When build project, I got the error:</p>

<blockquote>
  <p>error C2719: 'rnd': formal parameter with __declspec(align('8')) won't
  be aligned</p>
</blockquote>

<p>I cannot found a exact Crypto++ related result for this error from Google, but I found some result for <a href=""https://msdn.microsoft.com/en-us/library/373ak2y1.aspx"" rel=""nofollow noreferrer"">error code C2719</a>. Its content:</p>

<blockquote>
  <p>'parameter': formal parameter with __declspec(align('#')) won't be
  aligned</p>
  
  <p>The align __declspec modifier is not permitted on function parameters.
  Function parameter alignment is controlled by the calling convention
  used. For more information, see Calling Conventions.</p>
  
  <p>The following sample generates C2719 and shows how to fix it:</p>

<pre><code>// C2719.cpp  
void func(int __declspec(align(32)) i);   // C2719  
// try the following line instead  
 void func(int i);
</code></pre>
</blockquote>

<p>I didn't get any idea from this apply this ""solution"" to my case yet.</p>

<p>Seem like <code>AutoSeededRandomPool</code> cannot be passed as parameter. Is there someway to work around this?</p>
","<pre class=""lang-cxx prettyprint-override""><code>int generateKeyToFile(
     AutoSeededRandomPool rnd, 
    string publicKeyFileName, string privateKeyFileName){
    ...
}
</code></pre>

<p>Use a reference:</p>

<pre class=""lang-cxx prettyprint-override""><code>int GenerateKeyToFile(
    RandomNumberGenerator&amp; rnd, 
    const string&amp; publicKeyFileName,
    const string&amp; privateKeyFileName)
    {
        ...
    }
</code></pre>

<p>I'm not sure <code>AutoSeededRandomPool</code> is copy constructable. I think things are working as expected because you probably should not copy one. Just pass it by reference or by pointer.</p>
","175","<c++><parameters><crypto++><declspec>","1","1","1","2016-11-16 19:50:34","40640904","0","","608639","","2016-11-16 19:50:34","2016-11-16 03:30:59",""
"43634672","Crypto++ with Omnet++ on Windows","<p>Does anyone use Crypto++ with Omnet++ in Windows. I need help with linking the library and using algorithms like AES in my .cc file in order to encrypt or decrypt exchanged messages.</p>
","<p>To add own libraries to an existing <code>OMNeT++</code> project go to <code>Project</code> | <code>Properties</code> | <code>OMNeT++</code> | <code>Makemeke</code> | select root or src directory | <code>Options</code>, then <code>Custom</code> | <code>Makefrag</code> and write the following lines:</p>

<pre><code>EXTRA_OBJS += -LD:/foo/lib -lcryptopp
CFLAGS += -ID:/foo/include
</code></pre>

<p>where <code>D:/foo/lib</code> and <code>D:/foo/include</code> contain libraries (*.a or *.dll) and headers of <code>Crypto++</code>.</p>
","174","<c++><windows><eclipse><omnet++><crypto++>","0","0","1","2017-04-27 09:15:57","43653569","3","","608639","","2017-04-26 14:10:28","2017-04-26 12:47:19","2017-05-09 23:44:03"
"45821847","Crypto++ and ECC + ChaCha20","<p>I am not very familiar with the library yet.
What I need is what ECIES does but <em>without</em> appending MAC to the message.
I want to choose a curve on which I would perform ECDH.  I need to derive a symmetric key and encrypt data with ChaCha.</p>

<p>I've looked into the Encrypt function in pubkey.h which seems to achieve eveything I want:</p>

<pre><code>void Encrypt(RandomNumberGenerator &amp;rng, const byte *plaintext, size_t plaintextLength, byte *ciphertext, const NameValuePairs &amp;parameters = g_nullNameValuePairs) const
{
    const DL_KeyAgreementAlgorithm&lt;T&gt; &amp;agreeAlg = this-&gt;GetKeyAgreementAlgorithm();
    const DL_KeyDerivationAlgorithm&lt;T&gt; &amp;derivAlg = this-&gt;GetKeyDerivationAlgorithm();
    const DL_SymmetricEncryptionAlgorithm &amp;encAlg = this-&gt;GetSymmetricEncryptionAlgorithm();
    const DL_GroupParameters&lt;T&gt; &amp;params = this-&gt;GetAbstractGroupParameters();
    const DL_PublicKey&lt;T&gt; &amp;key = this-&gt;GetKeyInterface();

    Integer x(rng, Integer::One(), params.GetMaxExponent());
    Element q = params.ExponentiateBase(x);
    params.EncodeElement(true, q, ciphertext);
    unsigned int elementSize = params.GetEncodedElementSize(true);
    ciphertext += elementSize;

    Element z = agreeAlg.AgreeWithEphemeralPrivateKey(params, key.GetPublicPrecomputation(), x);

    SecByteBlock derivedKey(encAlg.GetSymmetricKeyLength(plaintextLength));
    derivAlg.Derive(params, derivedKey, derivedKey.size(), z, q, parameters);

    encAlg.SymmetricEncrypt(rng, derivedKey, plaintext, plaintextLength, ciphertext, parameters);
}
</code></pre>

<p>, <em>but</em> would you advise on how to approach the subject in the most elegant way? I see ECIES is ready to use out-of-the-box. How to approach implementation of such a custom scheme, any example? What I need is a small elegant approach. </p>

<p>In the above <em>Encrypt</em> function I do not see where MAC is appended, yet, this function is used directly for benchmarking ECIES (in BenchMarkEncryption in bench2.cpp) did I miss something?</p>
","","173","<c++><crypto++>","0","","0","2017-08-22 15:34:57","","8","","","","","2017-08-22 15:34:57",""
"47829280","Building and Linking Crypto++ CMake","<p>I am trying to build and link the simplest program in CLion on Linux Mint that uses the Crypto++ Library. I've searched high and low for information on how to tell CMake where my libraries are but I'm having trouble finding relevant information.</p>

<p>What do I need to add to CMake to get this to successfully build, link and run?</p>

<p>Screenshots and Pastebin follows:
    <a href=""https://i.stack.imgur.com/xjobf.png"" rel=""nofollow noreferrer"">Code</a>
    <a href=""https://i.stack.imgur.com/nXf96.png"" rel=""nofollow noreferrer"">CMake File</a></p>
","","170","<c++><intellij-idea><cmake><clion><crypto++>","0","","0","2018-04-17 03:27:32","","7","","","","","2017-12-15 09:26:15",""
"28900187","RSA::PublicKey Load function segfaults ART (Android Runtime)","<p>We have implemented a small wrapper for Cryptopp to exchange keys between iOS and Android(JNI). Shared code works on iOS and pre-ART android devices. Supposedly ART and its garbage collector is a lot stricter now.</p>

<p>It might be important to point out that set private key function succeeds on both Dalvik and ART runtimes.</p>

<p>Code:
--> setting public key :</p>

<pre><code>jboolean *isCopy;
//get bytes from jbytearray
jbyte* ba = (jbyte *)env-&gt;GetByteArrayElements( byteArray, isCopy);

//load bytearray to crypto bytequeue
ByteQueue queue2;

queue2.Put2((byte*)ba, 1000, 0, true);

//build public key
AutoSeededRandomPool rnd;
RSA::PublicKey publicKey;
publicKey.Load(*queue2);  //&lt;-------- CRASH
</code></pre>

<p>--> setting private key</p>

<pre><code>jboolean *isCopy;
jbyte* ba = (jbyte *)env-&gt;GetByteArrayElements( byteArray, isCopy);

//load bytearray to bytequeue
ByteQueue queue2;
queue2.Put2((byte*)ba, 3072, 0, true);

//fill up the key
RSA::PrivateKey privateKey;
privateKey.Load(queue2);
</code></pre>

<p>Stack trace:</p>

<pre><code> backtrace:
     #00 pc 00027e6c  &lt;project_name&gt;/lib/arm/libstlport_shared.so
     #01 pc 00027e79  &lt;project_name&gt;/lib/arm/libstlport_shared.so
     #02 pc 00027efb  &lt;project_name&gt;/lib/arm/libstlport_shared.so (std::terminate()+6)
     #03 pc 000273d3  &lt;project_name&gt;/lib/arm/libstlport_shared.so
     #04 pc 000268c9  &lt;project_name&gt;/lib/arm/libstlport_shared.so
     #05 pc 0002698b  &lt;project_name&gt;/lib/arm/libstlport_shared.so (__cxa_throw+34)
     #06 pc 001b3ce4  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::BERDecodeError()+128)
     #07 pc 001b1598  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::BERGeneralDecoder::Init(unsigned char)+56)
     #08 pc 001b1638  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::BERGeneralDecoder::BERGeneralDecoder(CryptoPP::BufferedTransformation&amp;, unsigned char)+104)
     #09 pc 0027697c  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::Integer::BERDecode(CryptoPP::BufferedTransformation&amp;)+20)
     #10 pc 002aec7c  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::RSAFunction::BERDecodePublicKey(CryptoPP::BufferedTransformation&amp;, bool, unsigned int)+64)
     #11 pc 001b20e0  &lt;project_name&gt;/lib/arm/libcryptopp.so (CryptoPP::X509PublicKey::BERDecode(CryptoPP::BufferedTransformation&amp;)+264)
     #12 pc 00014a0b  &lt;project_name&gt;/lib/arm/libsecurity.so (CryptoPP::ASN1CryptoMaterial&lt;CryptoPP::PublicKey&gt;::Load(CryptoPP::BufferedTransformation&amp;)+6)
</code></pre>

<p>Might be worth mentioning that new (mostly) Google devices (Nexus 4,5,7) use ART by default now.</p>

<p>Please advice!</p>
","<blockquote>
<pre><code>jbyte* ba = (jbyte *)env-&gt;GetByteArrayElements( byteArray, isCopy);
ByteQueue queue; 
queue.Put((byte*)ba, 1000, 0, true);
...
</code></pre>
</blockquote>

<p>And:</p>

<blockquote>
<pre><code>ByteQueue queue;
queue.Put((byte*)ba, 3072, 0, true);
...
</code></pre>
</blockquote>

<p>That is not correct. You can't hardcode the size when the keys are usually a couple hundred bytes.</p>

<p>Here's the code I use to work with the <code>jbyteArray</code>:</p>

<pre><code>if(env &amp;&amp; ba)
{
    ReadByteBuffer buffer(env, ba);

    const byte* _arr = buffer.GetByteArray();
    size_t _len = buffer.GetArrayLen();

    ByteQueue queue;
    queue.Put(_arr, _len);
    ...
}
</code></pre>

<p>And you should wrap it in a <code>try/catch</code> while catching a <code>BERDecodeErr</code> in case its not well formed. It seems to be another problem you are having. See <a href=""http://www.cryptopp.com/docs/ref/class_b_e_r_decode_err.html"" rel=""nofollow"">BERDecodeErr Class Reference</a>.</p>

<hr>

<p>This is not quite correct either (notice the pointer dereference for a stack-based <code>ByteQueue</code>):</p>

<pre><code>ByteQueue queue2;
...
publicKey.Load(*queue2);
</code></pre>

<p>I'm going to write that discrepancy off, but you should ensure the code you are posting is representative of what you are doing.</p>

<hr>

<blockquote>
  <p>Might be worth mentioning that new (mostly) Google devices (Nexus 4,5,7) use ART by default now.</p>
</blockquote>

<p>I have a Nexus 5 for testing, and Crypto++ runs fine :)</p>

<hr>

<p>Here's the class I use for <code>ReadByteBuffer</code>. It handles the release in the destructor.</p>

<pre><code>class ReadByteBuffer
{
public:
    explicit ReadByteBuffer(JNIEnv*&amp; env, jbyteArray&amp; barr)
    : m_env(env), m_arr(barr), m_ptr(NULL), m_len(0)
    {
        if(m_env &amp;&amp; m_arr)
        {
            m_ptr = m_env-&gt;GetByteArrayElements(m_arr, NULL);
            m_len = m_env-&gt;GetArrayLength(m_arr);
        }
    }

    ~ReadByteBuffer()
    {
        if(m_env &amp;&amp; m_arr)
        {
            m_env-&gt;ReleaseByteArrayElements(m_arr, m_ptr, JNI_ABORT);
        }
    }

    const byte* GetByteArray() const {
        return (const byte*) m_ptr;
    }

    size_t GetArrayLen() const {
        if(m_len &lt; 0)
            return 0;
        return (size_t) m_len;
    }

private:
    JNIEnv*&amp; m_env;
    jbyteArray&amp; m_arr;

    jbyte* m_ptr;
    jint m_len;
};
</code></pre>

<p>And here's the class I use for writing. Like its counterpart, <code>WriteByteBuffer</code> handles the commit and the release in the destructor.</p>

<pre><code>class WriteByteBuffer
{
public:
    explicit WriteByteBuffer(JNIEnv*&amp; env, jbyteArray&amp; barr)
    : m_env(env), m_arr(barr), m_ptr(NULL), m_len(0)
    {
        if(m_env &amp;&amp; m_arr)
        {
            m_ptr = m_env-&gt;GetByteArrayElements(m_arr, NULL);
            m_len = m_env-&gt;GetArrayLength(m_arr);
        }
    }

    ~WriteByteBuffer()
    {
        if(m_env &amp;&amp; m_arr)
        {
            m_env-&gt;ReleaseByteArrayElements(m_arr, m_ptr, 0);
        }
    }

    byte* GetByteArray() const {
        return (byte*) m_ptr;
    }

    size_t GetArrayLen() const {
        if(m_len &lt; 0)
            return 0;
        return (size_t) m_len;
    }

private:
    JNIEnv*&amp; m_env;
    jbyteArray&amp; m_arr;

    jbyte* m_ptr;
    jint m_len;
};
</code></pre>
","169","<android><android-ndk><segmentation-fault><android-5.0-lollipop><crypto++>","1","1","1","2015-03-06 22:35:27","","1","","294248","","2015-03-06 19:17:35","2015-03-06 13:49:24",""
"52966938","Crypto++ verify large file signature","<p>I use this code to verify a message with crypto++:</p>

<pre><code>CryptoPP::ECDSA&lt;CryptoPP::ECP, CryptoPP::SHA256&gt;::Verifier verifier(key);
bool result = verifier.VerifyMessage( (const CryptoPP::byte*)message.data(), message.length(), (const CryptoPP::byte*)signature.data(), signature.length() );
</code></pre>

<p>Now I would like to verify a signature I previously created for a file. The file is quite big (GB) and I don't want to load it to memory in one piece (to message variable).</p>

<p>Is there a way crypto++ can verify large file's signature?</p>
","<p>This code does what I need:</p>

<pre><code> CryptoPP::ECDSA&lt;CryptoPP::ECP, CryptoPP::SHA256&gt;::PublicKey key; key.Load(queue);
 CryptoPP::ECDSA&lt;CryptoPP::ECP, CryptoPP::SHA256&gt;::Verifier verifier(key);

 CryptoPP::SignatureVerificationFilter verificationFilter(verifier, NULL, CryptoPP::SignatureVerificationFilter::SIGNATURE_AT_BEGIN);
 CryptoPP::FileSource fileSource( file, false, new CryptoPP::Redirector(verificationFilter));
 CryptoPP::StringSource signatureSource( (const CryptoPP::byte*)signature.data(), signature.length(), false, new CryptoPP::Redirector(verificationFilter));
 signatureSource.Pump(signature.length());
 fileSource.PumpAll();

 return verificationFilter.GetLastResult();
</code></pre>
","169","<c++><crypto++>","1","1","1","2018-10-27 17:28:31","53024518","7","","2509078","","2018-10-25 04:40:04","2018-10-24 10:42:29",""
"33419254","Crypto++ 5.6.3rc5 GenerateBlock Not Implemented","<p>I am trying to derive key from password and want to generate randomly the salt(I dont know what size it should be for SHA-256 and does this matter like the IV in AES256, where it should be 128 bit,give a hint if someone know) with AutoSeededRandomPool but exception is cought </p>

<blockquote>
  <p>RandomNumberGenerator:GenerateBlock Not Implemented</p>
</blockquote>

<p>I am using crypto++ 5.6.3rc5 with QT 5.5.1 and /MD release mode, this may be a bug, or unfinished work of someone.</p>

<pre><code>#include &lt;QCoreApplication&gt;
#include &lt;sha.h&gt;
#include &lt;base64.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;pwdbased.h&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;osrng.h&gt;
using CryptoPP::AutoSeededRandomPool;

#include &lt;iostream&gt;
using std::cout;
using std::cerr;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;cstdlib&gt;
using std::exit;

#include &lt;cryptlib.h&gt;
using CryptoPP::Exception;

#include &lt;hex.h&gt;
using CryptoPP::HexEncoder;
using CryptoPP::HexDecoder;

#include &lt;filters.h&gt;
using CryptoPP::StringSink;

//#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(int argc, char *argv[])
{  

    QCoreApplication a(argc, argv);

    try
    {
        AutoSeededRandomPool rng;
        byte salt[16*8];
        rng.GenerateBlock(salt, 16*8);

        byte password[] =""password"";
        size_t plen = strlen((const char*)password);

        size_t slen = strlen((const char*)salt);

        int c = 1;
        byte derived[32];

        CryptoPP::PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt; pbkdf2;
        pbkdf2.DeriveKey(derived, sizeof(derived), 0, password, plen, salt, slen, c);

        string result;
        HexEncoder encoder(new StringSink(result));

        encoder.Put(derived, sizeof(derived));
        encoder.MessageEnd();

        cout &lt;&lt; ""Derived: "" &lt;&lt; result &lt;&lt; endl;
    }
    catch (const Exception&amp; ex) {
        cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }
    return a.exec();
}
</code></pre>
","<blockquote>
  <p>Crypto++ 5.6.3rc5 GenerateBlock Not Implemented
  ...</p>
</blockquote>

<p>You can read the history on the change at <a href=""https://github.com/weidai11/cryptopp/issues/38"" rel=""nofollow"">Crash in RandomNumberGenerator::GenerateWord32 due to stack recursion</a>. The change was eventually backed out.</p>

<p>It was fixed in RC6, but it has not been announced yet. There's a quasi-pre-RC6 at <a href=""https://sourceforge.net/projects/cryptopp/files/cryptopp/5.6.3/"" rel=""nofollow"">Crypto++ 5.6.3 Files</a>. But as soon as it is announced, then its set in stone and will not be changed.</p>

<p>Right now, RC6 is undergoing minor changes due to Cygwin, MinGW and C++11 on Debian Unstable. The changes are not too bad, but testing them is painful. Some of the scripts take half a day to run under emulated platforms, like S/390x.</p>

<p>If you want to side step the issue and avoid the download of pre-RC6, then you can use one of the following generators. They call <code>GenerateIntoBufferedTransformation</code>:</p>

<ul>
<li><code>AutoSeededX917RNG&lt; AES &gt;</code></li>
<li><code>X917RNG</code></li>
<li><code>RandomPool</code></li>
</ul>

<p>Or, you can use <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator#OS_GenerateRandomBlock"" rel=""nofollow""><code>OS_GenerateRandomBlock</code></a> to draw directly from the OS's pool.</p>

<p>Or, you can remove the code that throws. Open <code>cryptlib.h</code>, find <code>RandomNumberGenerator</code>, remove the <code>#if 0/#endif</code> guarding the old code and delete the throw.</p>

<p>Also see <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">RandomNumberGenerator</a> on the Crypto++ wiki.</p>
","167","<c++><crypto++>","1","1","1","2015-12-10 02:32:19","33506399","1","0","2680216","","2015-12-10 02:32:19","2015-10-29 16:06:19",""
"50192917","Error C2061: syntax error : identifier 'buffer' when compiling algparam.h","<p>I'm having the same error as <a href=""https://stackoverflow.com/q/15203562/608639"">Crypto++ giving a compiler error in algparam.h</a> when compiling a game using Crypto++. The error is:</p>

<pre><code>Error C2061: syntax error : identifier 'buffer' (at line 397)
</code></pre>

<p>Here is the code. It starts on line 390 an ends at line 411.</p>

<pre><code>#if defined(DEBUG_NEW) &amp;&amp; (_MSC_VER &gt;= 1300)
# pragma push_macro(""new"")
# undef new
#endif

    void MoveInto(void *buffer) const
    {
        AlgorithmParametersTemplate&lt;T&gt;* p = new(buffer) AlgorithmParametersTemplate&lt;T&gt;(*this);
        CRYPTOPP_UNUSED(p); // silence warning
    }

#if defined(DEBUG_NEW) &amp;&amp; (_MSC_VER &gt;= 1300)
# pragma pop_macro(""new"")
#endif

protected:
    T m_value;
};

CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate&lt;bool&gt;;
CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate&lt;int&gt;;
CRYPTOPP_DLL_TEMPLATE_CLASS AlgorithmParametersTemplate&lt;ConstByteArrayParameter&gt;;
</code></pre>

<p>What is the problem and how do I fix it?</p>

<hr>

<p>Here are the libraries I use:</p>

<ul>
<li>boost 1.67 (tried 1.63 too)</li>
<li>sqlapi++</li>
<li>camp</li>
<li>mysqlcppconns</li>
</ul>

<p>Here is the error message:</p>

<pre><code>1&gt;c:\local\cryptopp\algparam.h(397): error C2061: syntax error: identifier 'buffer'
1&gt;c:\local\cryptopp\algparam.h(396): note: while compiling class template member function 'void CryptoPP::AlgorithmParametersTemplate&lt;CryptoPP::ConstByteArrayParameter&gt;::MoveInto(void *) const'
1&gt;c:\local\cryptopp\algparam.h(411): note: see reference to class template instantiation 'CryptoPP::AlgorithmParametersTemplate&lt;CryptoPP::ConstByteArrayParameter&gt;' being compiled
</code></pre>
","<p>Here is the function you are having trouble with from <a href=""https://github.com/weidai11/cryptopp/blob/master/algparam.h"" rel=""nofollow noreferrer""><code>algparam.h</code></a>:</p>

<pre><code>395    void MoveInto(void *buffer) const
396    {
397        AlgorithmParametersTemplate&lt;T&gt;* p = new(buffer) AlgorithmParametersTemplate&lt;T&gt;(*this);
398        CRYPTOPP_UNUSED(p);  // silence warning
399    }
</code></pre>

<p>I suspect one of the other libraries you are using is messing with the definition on <code>new</code>.</p>

<p>I believe you need to compile the source file but instead of producing an object file, you need to use either <a href=""https://msdn.microsoft.com/en-us/library/8z9z0bx6.aspx"" rel=""nofollow noreferrer"">/P (Preprocess to a File)</a> or <a href=""https://msdn.microsoft.com/en-us/library/3xkfswhy.aspx"" rel=""nofollow noreferrer"">/E (Preprocess to stdout)</a>. Once the file is processed take a look at the definition of <code>new</code>. From there work back to the library that is changing it.</p>

<p>In the comments you said you also use:</p>

<ul>
<li>boost 1.67 (tried 1.63 too)</li>
<li>sqlapi++</li>
<li>camp</li>
<li>mysqlcppconns</li>
</ul>

<p>Boost does some unusual things at times, and I would suspect boost as the problem.</p>
","165","<c++><boost><compilation><crypto++><mysqlconnection>","1","0","1","2018-05-13 20:03:00","","3","1","608639","","2018-05-13 20:02:35","2018-05-05 18:46:00",""
"6839331","What difference does key length make when signing a file?","<p>I've never taken any classes on encryption or security and I'm trying to teach myself some basics, so forgive me if this is a silly question (don't worry, I'm not working on anything sensitive)</p>

<p>So, I'm playing around with Crypto++ so that I can make a signature of a file to see if the file has been edited by someone other than me. The test application that comes with the library looks like it has options (rs and rv) that do exactly what I want to do in my own program (verify the integrity of the signature of a file). Of course, before doing that I need to generate a public and private key. When doing so with the test application's g option it asks me to specify the key length in bits. What difference does the key length make?</p>
","<p>The key length determines how hard it is for someone to break your cryptography. For digital signatures, that means how hard is it for someone to generate a fake signature.</p>

<p>For RSA a key length of 1024 bits is sufficient for non-sensitive information, but it should only be used for a few years and then replaced with a new key. 2048 bits is stronger and 4096 is stronger still.</p>

<p>For a naive brute-force attacker, adding a single bit to the key length doubles the amount of work they need to do to compromise your key. However, algorithms like RSA do not scale in this way: a 2048-bit RSA key is not 2^1024 times as hard to break as a 1024-bit key (unless the attacker is <strong>really</strong> stupid).</p>

<p>Generally <em>public key</em> algorithms (e.g. RSA) need much larger keys than <em>symmetric key</em> algorithms (e.g. AES) because they rely on different mathematical properties.</p>

<p>For a good primer on cryptography you should check out <a href=""http://www.cs.auckland.ac.nz/~pgut001/tutorial/index.html"" rel=""nofollow"">Peter Gutmann's godzilla crypto tutorial</a>. It's pretty readable and gives you a good overview of how crypto works in its various forms.</p>
","164","<rsa><public-key><private-key><crypto++>","0","2","1","2011-07-27 04:25:00","6839408","0","","","","","2011-07-27 04:07:51",""
"30464974","Passing a key in a SecByteBlock to an algorithm?","<p>I am currently working on a Cryptopp encryption project and would need to pass a key to a Blowfish encryption algorithm.</p>

<p>If I understand correctly I would need to edit these 2 lines:</p>

<pre><code>SecByteBlock key(Blowfish::DEFAULT_KEYLENGTH);
prng.GenerateBlock( key, key.size() );
</code></pre>

<p>My idea would be to pass a string variable (like ekey) here to a SecByteBlock, like so:</p>

<pre><code>SecByteBlock key(ekey.data(), ekey.size());
</code></pre>

<p>But It looks like I'm going the wrong way. 
So, how do I pass a key to the algorithm?</p>
","<p>The various Crypto++ objects in this area (block/stream ciphers and modes) <em>do not</em> take a <code>SecByteBlock</code>. They all take a <code>const byte*</code> and <code>size_t</code>. It comes from <a href=""http://www.cryptopp.com/docs/ref/class_symmetric_cipher.html"" rel=""nofollow""><code>SymmetricCipher</code></a> interface.</p>

<hr>

<blockquote>
  <p>SecByteBlock key(ekey.data(), ekey.size());</p>
</blockquote>

<p>Since you have an <code>ekey</code> with a <code>data</code> and <code>size</code>, you should probably use it directly:</p>

<pre><code>CBC_Mode&lt; Blowfish &gt;::Encryption enc;
enc.SetKeyWithIV(ekey.data(), ekey.size(), iv.data(), iv.size());
</code></pre>

<p><strong><em>If</em></strong> you only have a <code>SecByteBlock</code>, then something like:</p>

<pre><code>SecByteBlock key(...);
CBC_Mode&lt; Blowfish &gt;::Encryption enc;
enc.SetKeyWithIV(key.data(), key.size(), iv.data(), iv.size());
</code></pre>

<p>There's a wiki page on Blowfish at <a href=""http://www.cryptopp.com/wiki/Blowfish"" rel=""nofollow"">Crypto++ - Blowfish</a>.</p>

<p>CBC mode in the example above only provides <em>confidentiality</em>. You should also consider an <a href=""http://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow"">Authenticated Encryption</a> mode to provide <em>confidentiality</em> and <em>authenticity</em> assurances.</p>
","162","<c++><blowfish><crypto++>","1","0","1","2015-05-26 21:20:11","30469121","0","","608639","","2015-05-26 21:11:31","2015-05-26 17:18:10",""
"53199533","Rare crash with Crypto++ pbkdf2::DeriveKey()","<p>I'm using the CryptoPP library to hash some passwords. About 1 in 10 times, it crashes on the DeriveKey line below, with a segfault.</p>

<p>Even when using fixed parameters the crashes still seem random. I'm wondering if perhaps I need a '\0' on the end of my strings. Or maybe the output buffer needs to be zero initialized, or something?</p>

<p>Anyway, here's the code.</p>

<pre><code>#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/algparam.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/pwdbased.h&gt;

int main()
{
CryptoPP::PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt; pbkdf2;

CryptoPP::byte salt[16];

CryptoPP::byte key[32];

/* Hard coded for testing purposes */
Common::podFromHex(""00f8807a289655b2a8e38cda00182a32"", salt);

/* Hard coded for testing purposes */
std::string password = ""a"";

std::cout &lt;&lt; ""Salt: "" &lt;&lt; Common::podToHex(salt) &lt;&lt; std::endl;
std::cout &lt;&lt; ""Salt size: "" &lt;&lt; sizeof(salt) &lt;&lt; std::endl;
std::cout &lt;&lt; ""Password: "" &lt;&lt; password.data() &lt;&lt; std::endl;
std::cout &lt;&lt; ""Password size: "" &lt;&lt; password.size() &lt;&lt; std::endl;

/* Rare segfault on this line */
pbkdf2.DeriveKey(
    key, sizeof(key), 0, (CryptoPP::byte *)password.data(),
    password.size(), salt, sizeof(salt), Constants::PBKDF2_ITERATIONS
);
}
</code></pre>

<p>Everything seems initialized properly - the print statements give me the exact same thing every time: </p>

<pre><code>Salt: 00f8807a289655b2a8e38cda00182a32
Salt size: 16
Password: a
Password size: 1
</code></pre>

<p>Furthermore - the hashed password is usable, when it doesn't segfault. I'm using AES encryption later on, and I can perfectly unencrypt the file, and all the data is as expected.</p>

<p>The source code for derive key can be found here, by the way: <a href=""https://www.cryptopp.com/docs/ref/pwdbased_8h_source.html#l00235"" rel=""nofollow noreferrer"">https://www.cryptopp.com/docs/ref/pwdbased_8h_source.html#l00235</a></p>

<p>Thanks.</p>
","<p>I'm hazarding a guess, but <code>salt</code> is not NULL terminated. The program is probably accessing beyond the 16th element of the <code>salt</code> array:</p>

<pre><code>std::cout &lt;&lt; ""Salt: "" &lt;&lt; Common::podToHex(salt) &lt;&lt; std::endl;
</code></pre>

<hr>

<p>The following executes multiple times without problems. It is your program less the calls to the Common library.</p>

<p>The call to <code>std::memcpy</code> only takes the left-most 16-bytes of the string. It does not do the conversion. (I only wanted to remove the call to Common).</p>

<pre><code>$ cat test.cxx

#include ""cryptlib.h""
#include ""filters.h""
#include ""sha.h""
#include ""hex.h""
#include ""files.h""
#include ""pwdbased.h""

#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main()
{
    using namespace CryptoPP;

    PKCS5_PBKDF2_HMAC&lt;SHA256&gt; pbkdf2;

    byte salt[16], key[32];

    /* Hard coded for testing purposes */
    // Common::podFromHex(""00f8807a289655b2a8e38cda00182a32"", salt);
    std::memcpy(salt, ""00f8807a289655b2a8e38cda00182a32"", 16);

    /* Hard coded for testing purposes */
    std::string password = ""a"";

    // std::cout &lt;&lt; ""Salt: "" &lt;&lt; Common::podToHex(salt) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Salt: "";
    StringSource(salt, sizeof(salt), true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Salt size: "" &lt;&lt; sizeof(salt) &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Password: "" &lt;&lt; password.data() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Password size: "" &lt;&lt; password.size() &lt;&lt; std::endl;

    /* Rare segfault on this line */
    pbkdf2.DeriveKey(
        key, sizeof(key), 0, (byte *)password.data(),
        password.size(), salt, sizeof(salt), 10000 /*Constants::PBKDF2_ITERATIONS*/
    );

    std::cout &lt;&lt; ""Key: "";
    StringSource(key, sizeof(key), true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Compiled and executed with:</p>

<pre><code>$ g++ -DNDEBUG -g2 -O3 test.cxx -o test.exe ./libcryptopp.a
$ ./test.exe
Salt: 30306638383037613238393635356232
Salt size: 16
Password: a
Password size: 1
Key: F88BA6947B802C66F7E7A2BC0099AFD92C81DC293E3CC48C2DA3FA75E27ECE6B
</code></pre>
","161","<c++><crypto++><pbkdf2>","1","3","2","2018-11-13 03:18:55","","4","1","608639","","2018-11-08 05:19:24","2018-11-07 23:36:27",""
"53199533","Rare crash with Crypto++ pbkdf2::DeriveKey()","<p>I'm using the CryptoPP library to hash some passwords. About 1 in 10 times, it crashes on the DeriveKey line below, with a segfault.</p>

<p>Even when using fixed parameters the crashes still seem random. I'm wondering if perhaps I need a '\0' on the end of my strings. Or maybe the output buffer needs to be zero initialized, or something?</p>

<p>Anyway, here's the code.</p>

<pre><code>#include &lt;cryptopp/aes.h&gt;
#include &lt;cryptopp/algparam.h&gt;
#include &lt;cryptopp/filters.h&gt;
#include &lt;cryptopp/modes.h&gt;
#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/pwdbased.h&gt;

int main()
{
CryptoPP::PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt; pbkdf2;

CryptoPP::byte salt[16];

CryptoPP::byte key[32];

/* Hard coded for testing purposes */
Common::podFromHex(""00f8807a289655b2a8e38cda00182a32"", salt);

/* Hard coded for testing purposes */
std::string password = ""a"";

std::cout &lt;&lt; ""Salt: "" &lt;&lt; Common::podToHex(salt) &lt;&lt; std::endl;
std::cout &lt;&lt; ""Salt size: "" &lt;&lt; sizeof(salt) &lt;&lt; std::endl;
std::cout &lt;&lt; ""Password: "" &lt;&lt; password.data() &lt;&lt; std::endl;
std::cout &lt;&lt; ""Password size: "" &lt;&lt; password.size() &lt;&lt; std::endl;

/* Rare segfault on this line */
pbkdf2.DeriveKey(
    key, sizeof(key), 0, (CryptoPP::byte *)password.data(),
    password.size(), salt, sizeof(salt), Constants::PBKDF2_ITERATIONS
);
}
</code></pre>

<p>Everything seems initialized properly - the print statements give me the exact same thing every time: </p>

<pre><code>Salt: 00f8807a289655b2a8e38cda00182a32
Salt size: 16
Password: a
Password size: 1
</code></pre>

<p>Furthermore - the hashed password is usable, when it doesn't segfault. I'm using AES encryption later on, and I can perfectly unencrypt the file, and all the data is as expected.</p>

<p>The source code for derive key can be found here, by the way: <a href=""https://www.cryptopp.com/docs/ref/pwdbased_8h_source.html#l00235"" rel=""nofollow noreferrer"">https://www.cryptopp.com/docs/ref/pwdbased_8h_source.html#l00235</a></p>

<p>Thanks.</p>
","<p>I ended up fixing this. It was not actually due to any of the code listed above, but it was because I was calling a function using this, in a signal handler.</p>

<p>Because this was taking quite a while to run (using 500,000 iterations) it appeared to be crashing here every time, but it was actually not due to this line.</p>

<p>I ended up fixing it flipping a bool flag in the signal handler, and having a separate thread watching that flag. When the flag was set, it called the destructor, which in turn triggered the normal shutdown flow, allowing all my threads to shutdown and save correctly.</p>
","161","<c++><crypto++><pbkdf2>","1","0","2","2018-11-13 03:18:55","","4","1","608639","","2018-11-08 05:19:24","2018-11-07 23:36:27",""
"48420744","FileStore::OpenErr at memory location 0x012FED64","<p>I am using a Crypto++ library for hashing a file. I got the error <em><code>FileStore::OpenErr at memory location 0x012FED64</code></em> at the line:</p>

<pre><code>FileSource file(filename.c_str(), false, new HexEncoder(new StringSink(result)));
</code></pre>

<p>The code is:</p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;iostream&gt;
#include ""..\cryptopp\sha.h""
#include ""..\cryptopp\hex.h""
#include ""..\cryptopp\files.h""
using namespace std;

string hashFile(string filename);

int main() {
    string shahash("""");
    string fileName = ""D:\test.txt"";
    shahash = hashFile(fileName);
    cout &lt;&lt; shahash &lt;&lt; endl;
    return 0;
}

string hashFile(string filename)
{
    string result;
    SHA256 hash;
    FileSource file(filename.c_str(), false, new HexEncoder(new StringSink(result)));

    file.PumpAll();
    return result;
}
</code></pre>

<p>And the detail error is as below:</p>

<pre><code>Exception thrown at 0x764B08B2 in myproject.exe: Microsoft C++ exception: CryptoPP::FileStore::OpenErr at memory location 0x012FED64.
Unhandled exception at 0x764B08B2 in myproject.exe: Microsoft C++ exception: CryptoPP::FileStore::OpenErr at memory location 0x012FED64.

The program '[13128] myproject.exe' has exited with code 0 (0x0).
</code></pre>

<p>The screenshot depicting the error is:</p>

<p><a href=""https://i.stack.imgur.com/0fvUJ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0fvUJ.jpg"" alt=""enter image description here""></a></p>

<p>What could be the possible reason for this kind of error? </p>

<p>Thank you.</p>
","<p>May be check it out programmatically using errno? Add to start of your file:</p>

<pre><code>#include &lt;cerrno&gt; // for errno
#include &lt;cstring&gt; // for strerror
</code></pre>

<p>And then wrap your throwing hashfile call into try:   </p>

<pre><code>try
{
    shahash = hashFile(fileName);
} 
catch(CryptoPP::FileStore::OpenErr const&amp;)
{
    cout &lt;&lt; ""Error: "" &lt;&lt; strerror(errno) &lt;&lt; '\n';
    return 42;    
}
</code></pre>

<p>If nothing did make further failing calls in destructors during stack unwinding then errno tells to cout what was wrong with that file. Also you get rid of your unhandled exception crash.</p>

<p>My guess is that <code>""D:\test.txt""</code> is bad file name and you want <code>""D:\\test.txt""</code></p>
","160","<c++><visual-studio><visual-studio-2017><crypto++>","1","1","2","2018-01-24 13:54:55","48421814","0","","608639","","2018-01-24 13:54:55","2018-01-24 10:55:59",""
"48420744","FileStore::OpenErr at memory location 0x012FED64","<p>I am using a Crypto++ library for hashing a file. I got the error <em><code>FileStore::OpenErr at memory location 0x012FED64</code></em> at the line:</p>

<pre><code>FileSource file(filename.c_str(), false, new HexEncoder(new StringSink(result)));
</code></pre>

<p>The code is:</p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;iostream&gt;
#include ""..\cryptopp\sha.h""
#include ""..\cryptopp\hex.h""
#include ""..\cryptopp\files.h""
using namespace std;

string hashFile(string filename);

int main() {
    string shahash("""");
    string fileName = ""D:\test.txt"";
    shahash = hashFile(fileName);
    cout &lt;&lt; shahash &lt;&lt; endl;
    return 0;
}

string hashFile(string filename)
{
    string result;
    SHA256 hash;
    FileSource file(filename.c_str(), false, new HexEncoder(new StringSink(result)));

    file.PumpAll();
    return result;
}
</code></pre>

<p>And the detail error is as below:</p>

<pre><code>Exception thrown at 0x764B08B2 in myproject.exe: Microsoft C++ exception: CryptoPP::FileStore::OpenErr at memory location 0x012FED64.
Unhandled exception at 0x764B08B2 in myproject.exe: Microsoft C++ exception: CryptoPP::FileStore::OpenErr at memory location 0x012FED64.

The program '[13128] myproject.exe' has exited with code 0 (0x0).
</code></pre>

<p>The screenshot depicting the error is:</p>

<p><a href=""https://i.stack.imgur.com/0fvUJ.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/0fvUJ.jpg"" alt=""enter image description here""></a></p>

<p>What could be the possible reason for this kind of error? </p>

<p>Thank you.</p>
","<pre><code>string fileName = ""D:\test.txt"";
</code></pre>

<p>should be</p>

<pre><code>string fileName = ""D:\\test.txt"";
</code></pre>

<p><code>\t</code> is the tab character. I'm pretty sure you don't want that in your file name.</p>
","160","<c++><visual-studio><visual-studio-2017><crypto++>","1","2","2","2018-01-24 13:54:55","48421814","0","","608639","","2018-01-24 13:54:55","2018-01-24 10:55:59",""
"53362739","Undefined reference for Crypto++ though it is linked and works in other projects","<p>So I am trying to make a wrapper function for generating a hash using Cryptop++
I created this test function: </p>

<pre><code>#include &lt;cryptopp/sha.h&gt;
#include &lt;cryptopp/hex.h&gt;
#include &lt;cryptopp/cryptlib.h&gt;

#include &lt;vector&gt;
#include &lt;cstdint&gt;

#include &lt;string&gt;

#include &lt;iostream&gt;

void test2()
{
    CryptoPP::SHA1 hash;
    CryptoPP::byte digest[CryptoPP::SHA1::DIGESTSIZE];

    std::vector&lt;uint8_t&gt; v;
    for (uint32_t i = 0; i &lt; 1000; ++i)
    {
        v.push_back(i % 9);
    }

    hash.CalculateDigest(digest, v.data(), v.size());

    CryptoPP::HexEncoder encoder;

    std::string output;

    encoder.Attach(new CryptoPP::StringSink(output));
    encoder.Put(digest, sizeof(digest));
    encoder.MessageEnd();

    std::cout &lt;&lt; output &lt;&lt; std::endl;
}
</code></pre>

<p>And compiled it with the following clang++ string:  <code>clang++ main2.cpp -lcryptopp</code>. However, when I use it in my project where the function is defined like this: </p>

<pre><code>template&lt;typename Hash&gt;
std::string get_hash(std::vector&lt;uint8_t&gt; data)
{
Hash hash;

// Intialise a byte ""array"" with space enough for the result
CryptoPP::byte digest[Hash::DIGESTSIZE];

// Create hash for the data
hash.CalculateDigest(digest, data.data(), data.size());

CryptoPP::HexEncoder encoder;
// result will hold the hex representation of the hash
std::string result;

// Tell the Hex encoder that result is the destination
// for its operations
encoder.Attach(new CryptoPP::StringSink(result));
encoder.Put(digest, sizeof(digest));
// As we will not put more in the message we end it
encoder.MessageEnd();

return result;
}
</code></pre>

<p>And call it like this: <code>hash::get_hash&lt;CryptoPP::SHA1&gt;(pair.pivot);</code> with following compiler command: <code>clang++ -std=c++17 -Wall -Werror -Wextra -pthread -pthread -lpqxx -lpq -lcryptopp examples/sql_index_example/sql_index_example.cpp.1.o -o/home/tools/git/alexandria/build/examples/sql_index_example/sql_index_example -Wl-Bstatic -L. -lalexandria -Wl-Bdynamic</code></p>

<p>I get a ton of undefined references to Crypto++, such as: </p>

<pre><code>examples/sql_index_example/sql_index_example.cpp.1.o: In function `alexandria::data::hash::GetHash[abi:cxx11](std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;)':
sql_index_example.cpp:(.text+0x197): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;::StringSinkTemplate(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;&amp;)'
</code></pre>

<p>and I am quite lost as to what actually happens when the simple test works. So hope someone can help. </p>

<p>EDIT: 
Already tried:
<a href=""https://stackoverflow.com/questions/17741613/undefined-reference-to-symbol-even-though-the-library-is-linked"">Undefined reference to symbol, even though the library is linked</a></p>
","<pre><code>clang++ -std=c++17 -Wall -Werror -Wextra -pthread -pthread -lpqxx -lpq -lcryptopp \
examples/sql_index_example/sql_index_example.cpp.1.o -o/home/tools/git/alexandria/
build/examples/sql_index_example/sql_index_example -Wl-Bstatic -L. -lalexandria -Wl-Bdynamic
</code></pre>

<p>And:</p>

<pre><code>examples/sql_index_example/sql_index_example.cpp.1.o: In function `alexandria::data::hash::
GetHash[abi:cxx11](std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;)':
sql_index_example.cpp:(.text+0x197): undefined reference to ...
</code></pre>

<p>To restate what @HolyBlackCat said, <code>-lcryptopp</code> needs to follow <code>sql_index_example.cpp.o</code> because the sql object file needs stuff from the Crypto++ archive. So the compile and link command should probably look something like this:</p>

<pre><code>clang++ -std=c++17 -Wall -Werror -Wextra -pthread -pthread \
  examples/sql_index_example/sql_index_example.cpp.1.o \
  -o /home/tools/git/.../sql_index_example \
  -lpqxx -lpq -lcryptopp -Wl-Bstatic -L. -lalexandria -Wl-Bdynamic
</code></pre>

<p>I would even recommend static linking in this case to avoid (1) the stupid Linux path problems; and (2) the path planting/injection games. So maybe smething like:</p>

<pre><code>clang++ -std=c++17 -Wall -Werror -Wextra -pthread -pthread \
  examples/sql_index_example/sql_index_example.cpp.1.o \
  /usr/local/lib/libcryptopp.a \
  -o /home/tools/git/.../sql_index_example \
  -lpqxx -lpq -Wl-Bstatic -L. -lalexandria -Wl-Bdynamic
</code></pre>

<p>Also see <a href=""https://stackoverflow.com/q/45135/608639"">Why does the order in which libraries are linked sometimes cause errors in GCC?</a></p>

<hr>

<p>You may want to change this signature to take a const reference:</p>

<pre><code>std::string get_hash(const std::vector&lt;uint8_t&gt;&amp; data);
</code></pre>

<p>There's no need for deep copies here. A reference or pointer will do. References cannot be <code>NULL</code> so they are a little easier to work with.</p>

<p>Also see <a href=""https://stackoverflow.com/q/3967177/608639"">When to use const and const reference in function args?</a> <a href=""https://stackoverflow.com/q/2139224/608639"">How to pass objects to functions in C++?</a> has more modern information, including C++11.</p>

<hr>

<p>Regarding this:</p>

<pre><code>HexEncoder encoder;
// result will hold the hex representation of the hash
std::string result;
// Tell the Hex encoder that result is the destination
// for its operations
encoder.Attach(new StringSink(result));
</code></pre>

<p>You can condense it a bit to:</p>

<pre><code>std::string result;
HexEncoder encoder(new StringSink(result));
</code></pre>

<p>Since you are printing to <code>std::cout</code> you could even:</p>

<pre><code>std::string result;
HexEncoder encoder(new FileSink(std::cout));
</code></pre>

<p>And if you want to get really slick, you can both print it and return it:</p>

<pre><code>ChannelSwitch channels;
channels.AddRoute(new FileSink(std::cout));
channels.AddRoute(new StringSink(result));

HexEncoder encoder(new Redirector(channels));
</code></pre>

<p>Now, when you insert data into <code>encoder</code>, it will be hex encoded and then sent to both <code>std::cout</code> and the <code>std::string</code>.</p>

<hr>

<p>And regarding:</p>

<pre><code>std::vector&lt;uint8_t&gt; data;
...

HexEncoder encoder;
encoder.Attach(new CryptoPP::StringSink(result));
encoder.Put(digest, sizeof(digest));
// As we will not put more in the message we end it
encoder.MessageEnd();
</code></pre>

<p>Crypto++ 8.0 will have a <code>VectorSource</code> and <code>VectorSink</code>. You will be able to:</p>

<pre><code>VectorSource(data, true, new HashFilter(hash, 
    new HexEncoder(new StringSink(result))));
return result;
</code></pre>

<p>Also see <a href=""https://github.com/weidai11/cryptopp/pull/730"" rel=""nofollow noreferrer"">Pull Request 730</a>.</p>
","157","<c++><crypto++>","2","1","1","2018-11-22 07:40:50","53425668","2","1","608639","","2018-11-22 07:17:13","2018-11-18 15:53:07","2018-11-22 07:44:30"
"40862297","Crypto++ CTR mode manual implement","<p>I am trying to make CTR manually on top of ECB mode (but still) using Crypto++.
The idea is:</p>

<blockquote>
  <p>For single block: Just use ECB For multiple block, use CTR algorithm
  (AFAIK):</p>

<pre><code>//We have n block of plain data -&gt; M
PlainData M[n];
key;
iv;
char *CTR;
cipher ="""";
for(i = 0; i&lt;n; i++ ){
  if(i ==0){
      CTR = iv;
  }
  ei = encryptECB(CTR + i)
  cipherI = xor(ei, M[i])
  cipher += cipherI;
}
</code></pre>
</blockquote>

<p>//My xor() to XOR two char array</p>

<pre><code>void xor(char  *s1, char* s2, char *&amp; result, int len){

    try{
        int i;
        for (i = 0; i &lt; len; i++){
            int u = s1[i] ^ s2[i];
            result[i] = u;
        }
        result[i] = '\0';
    }
    catch (...){
        cout &lt;&lt; ""Errp"";
    }
}
</code></pre>

<p><strong>Test 1: 100% Crypto++ CTR</strong></p>

<pre><code>string auto_ctr(char * s1, long size){
    CTR_Mode&lt; AES &gt;::Encryption e;
    e.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));
    string cipherZ;
    StringSource s(s1, true,
        new StreamTransformationFilter(e,
        new StringSink(cipherZ), BlockPaddingSchemeDef::BlockPaddingScheme::NO_PADDING
        )
        );
    return cipherZ;
}
</code></pre>

<p><strong>Test 2: Manual CTR based on ECB</strong></p>

<pre><code>string encrypt(char* s1, int size){
    ECB_Mode&lt; AES &gt;::Encryption e;
    e.SetKey(key, size);
    string cipher;
    string s(s1, size);
    StringSource ss1(s, true,
        new StreamTransformationFilter(e,
        new StringSink(cipher), BlockPaddingSchemeDef::BlockPaddingScheme::NO_PADDING
        ) // StreamTransformationFilter
        ); // StringSource
    return cipher;
}

static string manual_ctr(char *plain, long &amp;size){
    int nBlocks = size / BLOCK_SIZE;
    char* encryptBefore = new char[BLOCK_SIZE];
    char *ci = new char[BLOCK_SIZE] ;
    string cipher;
    for (int i = 0; i &lt; nBlocks; i++){
        //If the first loop, CTR = IV
        if (i == 0){
            memcpy(encryptBefore, iv, BLOCK_SIZE);
        }
        encryptBefore[BLOCK_SIZE] = '\0';
        memcpy(encryptBefore, encryptBefore + i, BLOCK_SIZE);


        char *buffer = new char[BLOCK_SIZE];
        memcpy(buffer, &amp;plain[i], BLOCK_SIZE);
        buffer[BLOCK_SIZE] = '\0';
        //Encrypt the CTR
        string e1 = encrypt(encryptBefore, BLOCK_SIZE);
        //Xor it with m[i] =&gt; c[i]
        xor((char*)e1.c_str(), buffer, ci, BLOCK_SIZE);
        //Append to the summary cipher
        /*for (int j = 0; j &lt; BLOCK_SIZE/2; j++){
            SetChar(cipher, ci[j], i*BLOCK_SIZE + j);
        }*/
        cipher += ci;
        //Set the cipher back to iv
        //memcpy(encryptBefore, ci, BLOCK_SIZE);
    }
    return cipher;
}
</code></pre>

<p>And this is Main for testing:</p>

<pre><code>void main(){

    long size = 0;
    char * plain = FileUtil::readAllByte(""some1.txt"", size);
    string auto_result = auto_ctr(plain, size);
    string manual_result = manual_ctr(plain, size);
    getchar();
}
</code></pre>

<p>The auto_result is:</p>

<blockquote>
  <p>""Yž+eÞsÂÙ\bü´\x1a¨Ü_ÙR•L¸Ð€¦å«ÎÍÊ[w®Ÿg\fT½\ý7!p\r^ÍÇ†úP\bîT\x3\x1cZï.s%\x1ei{ÚMˆØ…Pä¾õ\x46\r5\tâýï‚ú\x16ç’Qiæ²\x15š€á^ªê]W
  ÊNqdŒ¥ ˆ†¾j%8.Ìù\x6Þ›ÔÏ’[c\x19""</p>
</blockquote>

<p>The manual_result is: </p>

<blockquote>
  <p>""Yž+eÞsÂÙ\bü´\x1a¨Ü_Ù·\x18ýuù\n\nl\x11Á\x19À†Žaðƒºñ®GäþŽá•\x11ÇYœf+^Q\x1a\x13B³‘QQµºëÑÌåM\""\x12\x115â\x10¿Ô„›s°‰=\x18*\x1c:²IF'n@ŠŠ¾mGÂzõžÀ\x1eÏ\SëYU¼í‘""
  ></p>
</blockquote>

<p>What is the problem with my implement?</p>
","<p>Since your first block seems to be working fine, I've only searched for problems in the management of the counter itself and here is what seems me wrong :</p>

<blockquote>
  <p>memcpy(encryptBefore, encryptBefore + i, BLOCK_SIZE);</p>
</blockquote>

<p>Here you are trying to increment your IV <code>i</code> times, I presume, but this is not what happens, what you do is trying to copy into your <code>encryptBefore</code> pointer the content of the <code>encryptBefore+i</code> pointer spanning over <code>BLOCK_SIZE</code> bytes. This is not at all incrementing the IV, but it works for the first block because then <code>i=0</code>.</p>

<p>What you want to do is actually creating a big integer using <code>CryptoPP::Integer</code> to use as an IV and increment that integer and then convert it into a byte array using the <code>Encode(byte *output, size_t outputLen, Signedness sign=UNSIGNED) const</code> function from the CryptoPP Integer class when you need to use bytes instead of integers. </p>

<p>Ps: when performing i/o operations, I recommend you to use hexadecimal strings, take a look at the <code>CryptoPP::HexEncoder</code> and <code>HexDecoder</code> classes, they both are <a href=""https://www.cryptopp.com/wiki/HexEncoder"" rel=""nofollow"">well documented on CryptoPP wiki</a>. </p>
","156","<crypto++><ecb><ctr-mode>","0","1","1","2016-12-01 13:47:46","40911851","0","","","","","2016-11-29 09:36:10",""
"39166041","Skip'ing on a Source does not work as expected","<p>I use Crypto++ 5.6.3 and iI need the <code>FileSource Skip(...)</code> function. Unfortunately this function does nothing!</p>

<p>Here is a example for this <a href=""https://www.cryptopp.com/wiki/FileSource"" rel=""nofollow"">function</a>.</p>

<pre><code>string filename = ...;
string str;

FileSource file(filename, false, new HexEncoder(new StringSink(str)));
file.Skip(24);
file.PumpAll();
</code></pre>

<p>Can somebody help me?</p>
","<blockquote>
  <p>I use Crypto++ 5.6.3 and iI need the FileSource ""skip(...) function. Unfortunately this function does nothing!</p>
</blockquote>

<p>I was able to duplicate this using strings under Master, 5.6.3, and 5.6.2 on OS X 10.8.5 and Ubuntu 14.04.</p>

<pre class=""lang-cxx prettyprint-override""><code>$ cat test.cxx
#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

#include &lt;filters.h&gt;
#include &lt;hex.h&gt;
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  string str1, str2;
  HexEncoder enc(new StringSink(str1));
  for(unsigned int i=0; i &lt; 32; i++)
    enc.Put((byte)i);
  enc.MessageEnd();

  cout &lt;&lt; ""str1: "" &lt;&lt; str1 &lt;&lt;endl;

  StringSource ss(str1, false, new StringSink(str2));
  ss.Skip(10);
  ss.PumpAll();

  cout &lt;&lt; ""str2: "" &lt;&lt; str2 &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>And:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
str1: 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F
str2: 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F
</code></pre>

<p>Crypto++ 5.6.2 is significant because it was the last version Wei worked on before turning the library over to the community. An issue in 5.6.2 is just a latent bug and we encounter them on occasion, just like any other project. (""Wei"" bugs are actually kind of rare, and they are closer to ""Knuth"" bugs in his <a href=""http://en.wikipedia.org/wiki/Knuth_reward_check"" rel=""nofollow"">Art of Computer Programming</a>).</p>

<p>If its a 5.6.3 and above problem, then it means the community broke it. If the community broke it, then we need to perform a post-mortem and analyze how/why we managed to break something that used to work.</p>

<p>Here's the bug report for the library: <a href=""http://github.com/weidai11/cryptopp/issues/248"" rel=""nofollow"">Issue 248: Skip'ing on a Source does not work</a>. We are trying to determine if its a bug; and if so, then how to proceed.</p>

<hr>

<p><strong><em>EDIT 1</em></strong>: I was able to investigate the issue a little more. You can read the analysis at <a href=""http://github.com/weidai11/cryptopp/issues/248#issuecomment-242890863"" rel=""nofollow"">Comment 242890863</a>. The short of it is, <code>Skip</code> is used to discard bytes on an <em>output buffer</em> (an <code>AttachedTransformation()</code>), so things are <em>somewhat</em> working as expected. However, there's nothing intuitive about <code>Skip</code> <em>not</em> working on the <code>Source</code>, and only working on the attached <code>Filter</code> (<em>q.v.</em>, we're here).</p>

<p>I also asked for some feedback on the mailing list at <a href=""http://groups.google.com/forum/#!topic/cryptopp-users/aZbkJu5gl4g"" rel=""nofollow"">Issue 248: Skip'ing on a Source does not work</a>. DB and WD spotted it right away - its a design issue in the library.</p>

<p>Here's the workaround you can use for the moment. Effectively, you <code>Pump()</code> into a <code>null</code> <code>Filter</code> which discards the input as expected. Then you attach the real filter chain to handle the real processing.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include &lt;string&gt;
#include &lt;iostream&gt;
using namespace std;

#include &lt;filters.h&gt;
#include &lt;hex.h&gt;
using namespace CryptoPP;

int main(int argc, char* argv[])
{
  string str1, str2;
  HexEncoder enc(new StringSink(str1));
  for(unsigned int i=0; i &lt; 32; i++)
    enc.Put((byte)i);
  enc.MessageEnd();

  cout &lt;&lt; ""str1: "" &lt;&lt; str1 &lt;&lt;endl;

  // 'ss' has a NULL AttachedTransformation()
  StringSource ss(str1, false);
  ss.Pump(10);

  // Attach the real filter chain to 'ss'
  ss.Attach(new StringSink(str2));
  ss.PumpAll();

  cout &lt;&lt; ""str2: "" &lt;&lt; str2 &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>It produces the expected output:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe 
str1: 000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F
str2: 05060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F
</code></pre>

<p>In your sample program, I believe the workaround would be:</p>

<pre class=""lang-cxx prettyprint-override""><code>FileSource file(filename, false);
file.Pump(24);

file.Attach(new HexEncoder(new StringSink(str)));
file.PumpAll();
</code></pre>

<hr>

<p><strong><em>EDIT 2</em></strong>: Here's a slightly more verbose way to achieve the work around (thanks DB). It stresses the point that bytes are being discarded. <code>TheBitBucket()</code> is simply a discard filter, and it serves the same purpose as a <code>null</code> <code>AttachedTransformation()</code>.</p>

<pre class=""lang-cxx prettyprint-override""><code>int main(int argc, char* argv[])
{
  string str1, str2;
  HexEncoder enc(new StringSink(str1));
  for(unsigned int i=0; i &lt; 32; i++)
    enc.Put((byte)i);
  enc.MessageEnd();

  cout &lt;&lt; ""str1: "" &lt;&lt; str1 &lt;&lt;endl;

  StringSource ss(str1, false, new Redirector(TheBitBucket()));
  ss.Pump(10);

  ss.Detach(new StringSink(str2));
  ss.PumpAll();

  cout &lt;&lt; ""str2: "" &lt;&lt; str2 &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>There's another subtle difference in the program above: It calls <code>Detach</code>, which free's the former filter chain. If you called <code>Attach</code>, then the former chain would be detached, returned to the caller but not free'd.</p>
","153","<c++><crypto++>","1","1","1","2016-08-28 03:20:36","39176736","2","","608639","","2016-08-27 04:22:42","2016-08-26 12:11:47",""
"44346305","How to use Crypto++ or OpenSSL in XBox One (Durango)","<p>I would like to use Crypto++ or OpenSSL in  XBox One (Durango). XBox One is not UWP. I download GitHub code but it does not support  XBox One compiler. I tried to compile Crypto++ or OpenSSL but they were not successful.</p>

<p>I would like to use md5 / dh / aes / rsa on XBox One.</p>

<p>How do I use Crypto++ or OpenSSL with XBox One?</p>
","","152","<windows><openssl><crypto++><xbox><xbox-one>","0","","0","2017-06-03 19:24:18","","3","","608639","","2017-06-03 19:24:18","2017-06-03 16:45:14",""
"27198801","Libcrypto++ shared libraries missing","<p>I somehow managed to install the <code>libcrypto++</code> library on <code>Ubuntu 14.04</code>. Now, I have a project in <code>Eclipse CDT</code> which I would like to create an executable of and make it independently run on other linux flavors and windows(being ambitious here). </p>

<p>I am using the executable in the <code>Debug</code> folder of eclipse to run my program.</p>

<p>I get the following error when I run try to execute the program on any other machine</p>

<pre><code>error while loading shared libraries: libcrypto++.so
</code></pre>

<p>Can anyone tell me: </p>

<ol>
<li><p>How I can get rid of this error ?</p></li>
<li><p>How can I create a cross platform executable in the Eclipse IDE ?</p></li>
</ol>
","<blockquote>
<pre><code>I get the following error when I run try to execute the program on any other machine

error while loading shared libraries: libcrypto++.so

How I can get rid of this error ?
</code></pre>
</blockquote>

<p>Eclipse is a pain in the butt at times. Effectively, it tries to use the shared object (<code>libcrypto++.so</code>) whether you want it or not.</p>

<p>To work around this, specify <code>libcrypptopp.a</code> as an additional object file. Archives are a collection of object files, so they can be used interchangeably with an object file.</p>

<p>You enter it at <em>Other Objects</em> under <em>C/C++ Build -> Settings -> C++ Linker -> Miscellaneous</em>. You can see a screen capture of where to enter <code>libcrypptopp.a</code> in <a href=""https://stackoverflow.com/a/21919306/608639"">this</a> Stack Overflow answer.</p>

<p>Do <em>not</em> list Crypto++ in the library sections of eclipse.</p>

<hr>

<blockquote>
  <p>How can I create a cross platform executable in the Eclipse IDE ?</p>
</blockquote>

<p>Not sure what you mean, but you will need to compile Crypto++ for each platform you plan on supporting. That includes x86, x64, ARM, ARMv7 and MIPS.</p>
","152","<c++><eclipse><shared-libraries><ubuntu-14.04><crypto++>","1","1","1","2014-12-02 06:07:25","27234238","1","","2156877","","2014-12-01 16:45:16","2014-11-29 04:16:16",""
"50408019","Crypto++ Ed448 unknown oid","<p>I have been trying to generate an Ed448 ECDSA key using crypto++ 7 from debian experimental. My code is as follows:</p>

<pre><code>AutoSeededRandomPool rng;
ECIES&lt;ECP&gt;::Decryptor d(rng, ASN1::curve448());
</code></pre>

<p>I can compile this code without errors, but when it runs, I get the following exception:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::UnknownOID'
  what():  BER decode error: unknown object identifier
</code></pre>

<p>Looking through the interwebs, It appears that curve448 was implemented last version. How can I fix this?</p>
","<blockquote>
  <p>I have been trying to generate an Ed448 ECDSA key... It appears that curve448 was implemented last version.</p>
</blockquote>

<p>We added the OIDs for the 25519 and 448 curves some time ago. They were added to ease testing of curve25519 and ed25519. You can see the OIDs at <a href=""https://github.com/weidai11/cryptopp/blob/master/oids.h"" rel=""nofollow noreferrer""><code>oids.h</code></a>.</p>

<p>They OIDs were added at <a href=""https://github.com/weidai11/cryptopp/commit/7ca5f7d3b53f"" rel=""nofollow noreferrer"">Commit 7ca5f7d3b53f</a> on on Apr 11, 2016, and then subsequently fixed on the same day at <a href=""https://github.com/weidai11/cryptopp/commit/29e9bd2b27a9"" rel=""nofollow noreferrer"">Commit 29e9bd2b27a9</a>. Apr 11, 2016 made them available to Crypto++ 5.6.4.</p>

<hr>

<blockquote>
  <p>I can compile this code without errors, but when it runs, I get the following exception</p>
</blockquote>

<p>You are getting the exception because there are no domain parameters for curve448 in <a href=""https://github.com/weidai11/cryptopp/blob/master/eccrypto.cpp#L457"" rel=""nofollow noreferrer""><code>eccrypto.cpp</code></a>. You are hitting the exception below because <code>it == end</code>.</p>

<pre><code>template &lt;class EC&gt; void DL_GroupParameters_EC&lt;EC&gt;::Initialize(const OID &amp;oid)
{
    const EcRecommendedParameters&lt;EllipticCurve&gt; *begin, *end;
    GetRecommendedParameters(begin, end);
    const EcRecommendedParameters&lt;EllipticCurve&gt; *it = std::lower_bound(begin, end, oid, OIDLessThan());
    if (it == end || it-&gt;oid != oid)
        throw UnknownOID();

    const EcRecommendedParameters&lt;EllipticCurve&gt; &amp;param = *it;
    m_oid = oid;
    ...
}
</code></pre>

<hr>

<p>Here's the back story...</p>

<p>According to curve25519's <a href=""https://cr.yp.to/ecdh.html"" rel=""nofollow noreferrer"">A state-of-the-art Diffie-Hellman function</a>, the source code for the curve is at <a href=""https://bench.cr.yp.to/supercop.html"" rel=""nofollow noreferrer"">SUPERCOP</a>. SUPERCOP is a benchmarking program for cryptographic algorithms.</p>

<p>We have curve25519 and ed25519 on a testing fork. We ripped the implementation from SUPERCOP. SUPERCOP has the optimized reference implementations of curve25519, curve448, and lots of other stuff. Once curve25519 and ed25519 were added we planned on curve448.</p>

<p>We added curve25519 based on Andrew Moon's implementation. That provides <code>x25519</code> and <code>ed25519</code>. Also see <a href=""https://github.com/weidai11/cryptopp/issues/761"" rel=""nofollow noreferrer"">Issue 761</a> (x25519) and <a href=""https://github.com/weidai11/cryptopp/issues/764"" rel=""nofollow noreferrer"">Issue 764</a> (ed25519).</p>

<p>At this point the Crypto++ implementations of curve448 are stalled. I think your options are roll your own based on SUPERCOP, or use a library like <code>libsodium</code>, Botan or OpenSSL.</p>
","152","<crypto++><ecdsa>","1","2","1","2019-02-19 17:10:59","50429065","0","","2670194","","2018-05-18 11:15:47","2018-05-18 09:24:26",""
"32920396","Abstracting include paths and library names with pkg-config?","<p>I'm working with a project that goes by one of two <em>package</em> names, depending on the distribution. On Debian and derivatives, the package name is <strong><em><code>libcrypto++</code></em></strong>. On Fedora and derivates, its called <strong><em><code>libcryptopp</code></em></strong>. (The official project name is Crypto++).</p>

<p>Users write code, and do things like:</p>

<pre><code>#include &lt;crypto++/aes.h&gt;
</code></pre>

<p>And later, they link to the library with <code>-lcrypto++</code>.</p>

<p>Obviously, using ""Debian conventions"" breaks things on Fedora (and vice versa). See, for example, <a href=""https://stackoverflow.com/q/32805772"">How to change the include file path with autotools?</a></p>

<p>I'm trying to determine what can be used to abstract the differences away so the user's code ""just works"".</p>

<p>Can <a href=""http://linux.die.net/man/1/pkg-config"" rel=""nofollow noreferrer""><code>pkg-config files</code></a> be used to handle the differences? If so, then how does it handle the <code>#include &lt;crypto++/...&gt;</code> versus <code>#include &lt;cryptopp/...&gt;</code> found in user code? (I'm especially concerned about header clashes, like OpenSSL and Crypto++ both providing <code>aes.h</code>).</p>

<p>If not, what can we do to help with the issues caused by different names on different platforms?</p>
","<p>There's nothing built-in to the auto-tools that would do this automatically.  It's a fairly unusual need.</p>

<p>There are ways you could get this to work.  Here are a couple:</p>

<ul>
<li><p>Make a symlink in your build tree, with the name you like, pointing to the include tree.  That is, symlink from <code>libcrypto++</code> to <code>/usr/include/libcrytpopp</code>; then use <code>#include &lt;libcrypto++/mumble&gt;</code> in your source.  You can make this symlink from <code>configure</code>.</p></li>
<li><p>Generate a new C macro definition at <code>configure</code> time (see <code>AC_DEFINE</code>) that expands to a string holding the prefix, e.g., <code>""libcryptopp""</code>.  Then use pasting in the <code>#include</code> line to include the proper header.  See <a href=""https://stackoverflow.com/a/6813253/1442050"">this answer</a>.</p></li>
</ul>
","152","<autotools><crypto++><pkg-config>","1","2","2","2016-01-23 18:34:00","","0","","-1","","2017-05-23 12:31:02","2015-10-03 08:17:30",""
"32920396","Abstracting include paths and library names with pkg-config?","<p>I'm working with a project that goes by one of two <em>package</em> names, depending on the distribution. On Debian and derivatives, the package name is <strong><em><code>libcrypto++</code></em></strong>. On Fedora and derivates, its called <strong><em><code>libcryptopp</code></em></strong>. (The official project name is Crypto++).</p>

<p>Users write code, and do things like:</p>

<pre><code>#include &lt;crypto++/aes.h&gt;
</code></pre>

<p>And later, they link to the library with <code>-lcrypto++</code>.</p>

<p>Obviously, using ""Debian conventions"" breaks things on Fedora (and vice versa). See, for example, <a href=""https://stackoverflow.com/q/32805772"">How to change the include file path with autotools?</a></p>

<p>I'm trying to determine what can be used to abstract the differences away so the user's code ""just works"".</p>

<p>Can <a href=""http://linux.die.net/man/1/pkg-config"" rel=""nofollow noreferrer""><code>pkg-config files</code></a> be used to handle the differences? If so, then how does it handle the <code>#include &lt;crypto++/...&gt;</code> versus <code>#include &lt;cryptopp/...&gt;</code> found in user code? (I'm especially concerned about header clashes, like OpenSSL and Crypto++ both providing <code>aes.h</code>).</p>

<p>If not, what can we do to help with the issues caused by different names on different platforms?</p>
","<p>As Tom Tromey said there is nothing to help you much with this by itself. But with the help of the Crypto++ developers you could come up with a more standardized approach to discover this.</p>

<p>The trick is using <code>pkg-config</code> defined variables, and then use Tom's suggested approach of a macro and pasting. Essentially you just need to define the prefix variable in your <code>.pc</code> file:</p>

<pre><code>includepathprefix = libcryptopp
</code></pre>

<p>And then use <code>PKG_CHECK_VAR</code> to read it through.</p>

<pre><code>PKG_CHECK_VAR([CRYPTOPP_PREFIX], [libcrypto++], [includepathprefix])
AC_DEFINE([CRYPTOPP_PREFIX], [$CRYPTOPP_PREFIX],
    [Prefix for crypto++ header files.])
</code></pre>

<p>then you should use string pasting to include the files. It's definitely clunky, but it is slightly less of a shot in the dark.</p>

<p>I wrote more information about <code>PKG_CHECK_VAR</code> on my <a href=""https://autotools.io/pkgconfig/variables.html"" rel=""nofollow"">Autotools Mythbuster</a> if you want to see the full syntax.</p>
","152","<autotools><crypto++><pkg-config>","1","0","2","2016-01-23 18:34:00","","0","","-1","","2017-05-23 12:31:02","2015-10-03 08:17:30",""
"54408731","How to include Crypto++ into a VS Project","<p>I'm working on a Project that utilizes CryptoPP, but I always get Linking Issues when I try to Compile my Code. Now I wanted to ask here If someone knows howto Link it Correctly.</p>

<p>I already tried:</p>

<ul>
<li>Downloading Crypto++</li>
<li>Opening the SLN</li>
<li><p>Building cryptlib</p></li>
<li><p>Moving the cryptlib.lib to my project folder</p></li>
<li>Including the Crypto++ header into my project</li>
<li>Adding the cryptlib.lib to the header files.</li>
</ul>

<p>I expect my project to fully compile and link, without errors and being able to run some AES just for testing.</p>
","<p>The best way is to create a folder named cryptopp inside your project folder (where the .SLN is located) clone or download the source from <a href=""https://github.com/weidai11/cryptopp/tree/34a34967ac560c1801bf3845dbac3ac63c1d4c05"" rel=""nofollow noreferrer"">cryptopp</a> inside the directory.</p>

<p>From <code>[Visual Studio-&gt;Solution Explorer]</code> click on <code>[Solution-&gt;Add-&gt;Existing Project]</code> and select the <code>cryptlib.vcproj</code> file to include in your solution.</p>

<p>You can find an example of a project using cryptopp here <a href=""https://github.com/mrc-g/BitMRC"" rel=""nofollow noreferrer"">https://github.com/mrc-g/BitMRC</a></p>
","150","<c++><windows><visual-studio><crypto++>","0","0","1","2019-01-28 19:34:46","54408952","4","","608639","","2019-01-28 19:27:24","2019-01-28 19:09:50",""
"38915352","Load public key from unsigned char array","<p>I have a public key as an array of bytes from xxd:</p>

<pre class=""lang-cxx prettyprint-override""><code>unsigned char publicKey_txt[] = {
 0x30, 0x82, 0x02, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, .. }; 
</code></pre>

<p>From previous Stack Overflow questions I have a general understanding that in my case a <code>StringSink</code> followed by load should work</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource publicstring(publicKey_txt, true, NULL);
publicKey.Load(publicstring);
</code></pre>

<p>Simply loading from text file works, but when I load from <code>StringSink</code> I get an error:</p>

<pre class=""lang-none prettyprint-override""><code>Error: BER decode error
</code></pre>

<p>How do I load a public key from unsigned char array?</p>
","<p>Found my answer <a href=""https://stackoverflow.com/questions/9869261/load-rsa-pkcs1-private-key-from-memory?rq=1"">from @jww - Load RSA PKCS#1 private key from memory?</a></p>

<p>In my case slight modification instead of SinkSource I use the ArraySource and publicKey_txt_len is size of char array publicKey_txt.</p>

<pre><code>CryptoPP::ArraySource as( publicKey_txt, publicKey_txt_len, true);
publicKey.Load(as);
</code></pre>
","148","<public-key><crypto++>","1","1","1","2016-08-12 22:54:02","38917457","1","","608639","","2016-08-12 22:54:02","2016-08-12 10:08:09",""
"24487084","CryptoPP cannot decode a cipher encrypted with Public key","<p>I am using Cryptopp with Qt, My server sends a Public key to my client, the client encrypts a username with it and sends it (I have tested the cipher is sent properly) but server side i have an error : ""invalid ciphertext"", here is the code from my client :</p>

<pre><code>QByteArray writtendata;
QDataStream streamBytes(&amp;writtendata,QIODevice::WriteOnly);

streamBytes &lt;&lt; quint16(0) &lt;&lt; bytes;
streamBytes.device()-&gt;seek(0);
streamBytes &lt;&lt; (quint16) (bytes.size() - sizeof(quint16));

int     written = socket-&gt;write(writtendata);
std :: cout &lt;&lt; ""sent : "" &lt;&lt; written &lt;&lt; std :: endl ;
</code></pre>

<p>and server side :</p>

<pre><code>        in &gt;&gt; datalenth;
        qDebug() &lt;&lt; ""datalength    : "" &lt;&lt; datalenth;

        if (socket-&gt;bytesAvailable() &lt; datalenth)
            return;
        qDebug() &lt;&lt; ""byte available    : "" &lt;&lt; socket-&gt;bytesAvailable();
        QByteArray read;
        in &gt;&gt; read;
        qDebug() &lt;&lt; ""Read    : "" &lt;&lt; read.size();
        file.write(read);
        file.close();
        ifstream my;
        my.open(""cipher.txt"");

        string str((std::istreambuf_iterator&lt;char&gt;(my)), std::istreambuf_iterator&lt;char&gt;());
        qDebug() &lt;&lt; ""str:  ""&lt;&lt; str.size();
        cout &lt;&lt; str &lt;&lt;endl ;
        string recovered = T-&gt;discryptor(str) ;
        std :: cout &lt;&lt; ""recovered : "" &lt;&lt; recovered &lt;&lt; std :: endl;
        my.close();
</code></pre>

<p>I don't really know where the problem comes from.</p>

<p>Hope that anyone can shed some light on this.</p>
","","148","<c++><encryption><crypto++>","1","","0","2014-06-30 10:06:33","","3","","3779430","","2014-06-30 10:06:33","2014-06-30 09:36:07",""
"44504497","Winsock invalid socket error once include external sources","<p>I am trying to create a server/client communication console, but once i include the external libraries (cryptopp) and debug, it will always terminate due socket invalid error. I have no idea what is going on.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;WS2tcpip.h&gt;
#include &lt;string&gt;

#pragma comment (lib, ""ws2_32.lib"")

#include ""../cryptopp565/sha.h""
using CryptoPP::SHA1;


using namespace std;


int main()
{
//initialize winsock
WSADATA wsData;
WORD ver = MAKEWORD(2, 2);

int wsOk = WSAStartup(ver, &amp;wsData);
if (wsOk != 0)
{
    cerr &lt;&lt; ""Can't Initialize winsock! program terminate."" &lt;&lt; endl;
    return 1;
}

//create a socket 
SOCKET listening = socket(AF_INET, SOCK_STREAM, 0);
if (listening == INVALID_SOCKET)
{
    cerr &lt;&lt; ""Can't create a socket! program terminate."" &lt;&lt; endl;
    return 1;
}

//Promtp to get server port
string server_port_temp;

cout &lt;&lt; ""Enter port : "";
cin &gt;&gt; server_port_temp;

int server_port = stoi(server_port_temp);

//bind the ip address and port to a socket 
sockaddr_in hint;
hint.sin_family = AF_INET;
hint.sin_port = htons(server_port);
hint.sin_addr.S_un.S_addr = INADDR_ANY;

bind(listening, (sockaddr*)&amp;hint, sizeof(hint));

//tell winsock the socket is for listening 
listen(listening, SOMAXCONN);

//wait for connection
sockaddr_in client;
int clientSize = sizeof(client);

SOCKET clientSocket = accept(listening, (sockaddr*)&amp;client, &amp;clientSize);
if (clientSocket == INVALID_SOCKET)
{
    cerr &lt;&lt; ""Invalid socket ! program terminate."" &lt;&lt; endl;
    return 1;
}

char host[NI_MAXHOST];        //client remote name
char service[NI_MAXHOST];     // service (poet client is connect on)

ZeroMemory(host, NI_MAXHOST);
ZeroMemory(service, NI_MAXHOST);

if (getnameinfo((sockaddr*)&amp;client, sizeof(client), host, NI_MAXHOST, service, NI_MAXHOST, 0) == 0)
{
    cout &lt;&lt; host &lt;&lt; "" Connect on port "" &lt;&lt; service &lt;&lt; endl;
}
else
{
    inet_ntop(AF_INET, &amp;client.sin_addr, host, NI_MAXHOST);
    cout &lt;&lt; host &lt;&lt; "" Connected on port "" &lt;&lt; ntohs(client.sin_port) &lt;&lt; endl;
}

//close listening socket
closesocket(listening);

//while loop: communication
char buf[4096];


//communicate ________________
while (true)
{
    ZeroMemory(buf, 4096);

    //wait for client to send data
    int bytesReceived = recv(clientSocket, buf, 4096, 0);
    if (bytesReceived == SOCKET_ERROR)
    {
        cerr &lt;&lt; ""Error in recv(). Program terminate."" &lt;&lt; endl;
        break;
    }

    if (bytesReceived == 0)
    {
        cout &lt;&lt; ""Client disconnected "" &lt;&lt; endl;
        break;
    }

    cout &lt;&lt; string(buf, 0, bytesReceived) &lt;&lt; endl;

    //echo message back to client
    send(clientSocket, buf, bytesReceived + 1, 0);
}

//close the socket
closesocket(clientSocket);

//clean winsock
WSACleanup();

system(""pause"");
return 0;
</code></pre>

<p>}`</p>
","","147","<sockets><winsock><crypto++>","0","","0","2017-06-12 16:36:28","","3","0","","","","2017-06-12 16:36:28",""
"10732926","Crypto++ ""Tee""-style filter","<p>I'm working on processing a data-stream based on some conditions.</p>

<p>Data is read from an input pipe, processed, and pushed down a Crypto++ <code>CBC_Mode&lt;AES&gt;</code> filter ending in a <code>FileSink</code>.</p>

<p>Now, I'd like to ""snoop"" on the data flowing between the encryption and file-store, calculating a checksum. For performance reasons, I want to do this while streaming, re-opening the output file and calculating a hash-sum after is not reasonable for my need.</p>

<p>From what I can see, what's missing for this to work, is some form of ""tee"" filter. Something splitting the data chain into two new chains, one for storing to file, and one chain for the hash-calculation.</p>

<p>Are there such functionality in Crypto++? Can I implement such filter myself, and if so, are there some guidelines or examples on what's needed for a custom Crypto++ filter? Are there some other way to calculate checksum on the fly?</p>
","<blockquote>
  <p>From what I can see, what's missing for this to work, is some form of ""tee"" filter.
  ...
  Are there such functionality in Crypto++? </p>
</blockquote>

<p>Yes, its called a <code>ChannelSwitch</code>. The following is from the <a href=""http://www.cryptopp.com/wiki/ChannelSwitch"" rel=""nofollow"">Crypto++ wiki page on ChannelSwitch</a>, and it follows Wei Dai's use of the class in his test files.</p>

<pre><code>MD5 hashMD5;
HashFilter filterMD5(hashMD5);

SHA1 hashSHA1;
HashFilter filterSHA1(hashSHA1);

std::auto_ptr&lt;ChannelSwitch&gt; channel( new ChannelSwitch );

channel-&gt;AddDefaultRoute(filterMD5);
channel-&gt;AddDefaultRoute(filterSHA1);

StringSource ss( ""abcdefghijklmnopqrstuvwxyz"", true, channel.release());

string digest;
HexEncoder encoder( new StringSink( digest ), true /* uppercase */ ); 

filterMD5.TransferTo( encoder );
cout &lt;&lt; filterMD5.AlgorithmName() &lt;&lt; "": "" &lt;&lt; digest &lt;&lt; endl;
digest.erase();

filterSHA1.TransferTo( encoder );
cout &lt;&lt; filterSHA1.AlgorithmName() &lt;&lt; "": "" &lt;&lt; digest &lt;&lt; endl;
digest.erase();
</code></pre>

<p>Here's the output of the example above:</p>

<pre><code>$ ./cryptopp-test.exe
MD5: C3FCD3D76192E4007DFB496CCA67E13B
SHA-1: 32D10C7B8CF96570CA04CE37F2A19D84240D3A89
</code></pre>

<hr>

<p>Here's another example that uses distinct sinks and might be easier to follow:</p>

<pre><code>byte data[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
string e1, e2, e3;

HexEncoder r1(new StringSink(e1));
Base32Encoder r2(new StringSink(e2));
Base64Encoder r3(new StringSink(e3));

ChannelSwitch chsw;
chsw.AddDefaultRoute(r1);
chsw.AddDefaultRoute(r2);
chsw.AddDefaultRoute(r3);

chsw.Put(data, sizeof(data));
chsw.MessageEnd();

cout &lt;&lt; e1 &lt;&lt; endl;
cout &lt;&lt; e2 &lt;&lt; endl;
cout &lt;&lt; e3 &lt;&lt; endl;
</code></pre>

<p>Here's the output of the example:</p>

<pre><code>$ ./cryptopp-test.exe
0102030405060708090A
AEBAGBAFA2DSSCIK
AQIDBAUGBwgJCg==
</code></pre>
","147","<c++><crypto++>","2","3","1","2013-10-04 05:01:31","19173574","3","","","","","2012-05-24 07:21:47",""
"53051700","Crypto++ AES crashing in release mode using VS2017","<p>I have the following code. A very simple example of encryption and decryption of string ""abcd"". I've tried it with sample from Crypto++ (<a href=""https://www.cryptopp.com/wiki/CBC_mode"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/CBC_mode</a>) and it produces the same exception.</p>

<pre><code>AutoSeededRandomPool rand;

SecByteBlock key(nullptr, AES::MAX_KEYLENGTH);
rand.GenerateBlock(key, key.size());

byte iv[AES::BLOCKSIZE];
rand.GenerateBlock(iv, AES::BLOCKSIZE);

std::string encryptedData;
CBC_Mode&lt;AES&gt;::Encryption cbcEncryption(key, key.size(), iv);

StringSource ss(""abcd"", true,
    new StreamTransformationFilter(cbcEncryption,
        new StringSink(encryptedData)
    )
);

std::string decryptedData;

CBC_Mode&lt;AES&gt;::Decryption cbcDecryption(key, key.size(), iv);

StringSource ss2(encryptedData, true,
    new StreamTransformationFilter(cbcDecryption,
        new StringSink(decryptedData)
    )
);
</code></pre>

<p>The problem is when I build in debug mode, it works fine but when I do it in release mode I get an exception from Crypto++ code (""StreamTransformationFilter: invalid PKCS #7 block padding found"")</p>

<p><a href=""https://i.stack.imgur.com/F3YYV.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F3YYV.png"" alt=""Exception""></a></p>
","<blockquote>
  <p>The problem is when I build in debug mode, it works fine but when I do it in release mode I get an exception from Crypto++ code (""StreamTransformationFilter: invalid PKCS #7 block padding found"") ...</p>
</blockquote>

<p>It appears to be a compiler issue related to global optimizations. Our workaround was to disable global optimizations for the source file <code>rijndael.cpp</code>.</p>

<p>In <code>rijndael.cpp</code> you can add the following around the top of the file to avoid the issue:</p>

<pre class=""lang-cxx prettyprint-override""><code>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1910)
# pragma optimize("""", off)
# pragma optimize(""ts"", on)
#endif
</code></pre>

<p>You can reproduce the issue with the following in <code>rijndael.cpp</code>:</p>

<pre class=""lang-cxx prettyprint-override""><code>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1910)
# pragma optimize("""", off)
# pragma optimize(""g"", on)
#endif
</code></pre>

<p>Also see <a href=""https://github.com/weidai11/cryptopp/commit/f57df06c5e6d"" rel=""nofollow noreferrer"">Commit f57df06c5e6d</a> and <a href=""https://msdn.microsoft.com/en-us/library/chh3fb0k.aspx"" rel=""nofollow noreferrer""><code>pragma optimize</code></a> on MSDN.</p>

<hr>

<p>If your machine has AES-NI but you want to reproduce the issue, then  comment-out the code that assigns <code>g_hasAESNI</code> in <code>cpu.cpp</code>. <code>g_hasAESNI</code> will retain the default value of <code>false</code>.</p>

<pre class=""lang-diff prettyprint-override""><code>--- a/cpu.cpp
+++ b/cpu.cpp
@@ -242,7 +242,7 @@ void DetectX86Features()
        g_hasSSSE3 = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt; 9)) != 0);
        g_hasSSE41 = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt;19)) != 0);
        g_hasSSE42 = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt;20)) != 0);
-       g_hasAESNI = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt;25)) != 0);
+       //g_hasAESNI = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt;25)) != 0);
        g_hasCLMUL = g_hasSSE2 &amp;&amp; ((cpuid1[2] &amp; (1&lt;&lt; 1)) != 0);
</code></pre>
","147","<c++><windows><visual-studio><crypto++>","1","1","1","2018-11-06 04:59:58","53165924","3","","608639","","2018-11-06 04:59:26","2018-10-29 18:29:06",""
"55587649","Integrate Crypto++ in Android using Android.mk?","<p>I want to integrate cryptopp module in my Android application. I tried but can not get any success and also not find any straight forward document or example for android.</p>

<p>Project structure : <a href=""http://prntscr.com/n9g0k9"" rel=""nofollow noreferrer"">http://prntscr.com/n9g0k9</a></p>

<pre><code>apply plugin: 'com.android.application'

apply plugin: 'kotlin-android'

apply plugin: 'kotlin-android-extensions'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId """"
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName ""1.0""
        testInstrumentationRunner ""android.support.test.runner.AndroidJUnitRunner""
        ndk {
            moduleName ""cryptopp""
        }
    }

    sourceSets.main {
        jni.srcDirs = [] // This prevents the auto generation of Android.mk
        jniLibs.srcDir 'src/main/libs' // This is not necessary unless you have precompiled libraries in your project.
    }


    task buildNative(type: Exec, description: 'Compile JNI source via NDK') {
        def ndkDir = android.ndkDirectory
        commandLine ""$ndkDir/ndk-build"",
                '-C', file('src/main/jni').absolutePath, // Change src/main/jni the relative path to your jni source
                '-j', Runtime.runtime.availableProcessors(),
                'all',
                'NDK_DEBUG=1'
    }

    task cleanNative(type: Exec, description: 'Clean JNI object files') {
        def ndkDir = android.ndkDirectory
        commandLine ""$ndkDir/ndk-build"",
                '-C', file('src/main/jni').absolutePath, // Change src/main/jni the relative path to your jni source
                'clean'
    }

    clean.dependsOn 'cleanNative'

    tasks.withType(JavaCompile) {
        compileTask -&gt; compileTask.dependsOn buildNative
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

    /*externalNativeBuild {
        cmake {
            path ""src/main/cpp/CMakeLists.txt""
        }
    }*/
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation ""org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version""
    implementation 'com.android.support:appcompat-v7:28.0.0'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'

    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
</code></pre>

<p>Android.mk</p>

<pre><code>## Android.mk - Android build file for Crypto++. Written and placed in
##              public domain by Jeffrey Walton. Based on Android.mk
##              by Alex Afanasyev (GitHub @cawka),
##              https://github.com/weidai11/cryptopp/pull/3
##
##              The Android make uses GNU Make and is documented at
##              https://developer.android.com/ndk/guides/android_mk
##              The CPU Features library is documented at
##              https://developer.android.com/ndk/guides/cpu-features
##
##              You can create the list of files below with:
##
##                  $ make sources | fold -w74 -s
##

## TODO - We use this line below in the .mk file:
##            LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/..
## The open question is, should we be exporting the path as:
##            LOCAL_EXPORT_C_INCLUDES := $(CRYPTOPP_PATH)

ifeq ($(NDK_LOG),1)
    $(info Crypto++: TARGET_ARCH: $(TARGET_ARCH))
    $(info Crypto++: TARGET_PLATFORM: $(TARGET_PLATFORM))
endif

LOCAL_PATH := $(call my-dir)

#####################################################################
# Adjust CRYPTOPP_PATH to suit your taste, like ../cryptopp-7.1/.
# If CRYPTOPP_PATH is empty then it means the library files and the
# Android files are side-by-side in the same directory. If
# CRYPTOPP_PATH is not empty then must include the trailing slash.
# The trailing slash is needed because CRYPTOPP_PATH is prepended
# to each source file listed in CRYPTOPP_SRC_FILES.

# CRYPTOPP_PATH ?= ../cryptopp/
CRYPTOPP_PATH ?=

ifeq ($(NDK_LOG),1)
  ifeq ($CRYPTOPP_PATH),)
    $(info Crypto++: CRYPTOPP_PATH is empty)
  else
    $(info Crypto++: CRYPTOPP_PATH is $(CRYPTOPP_PATH))
  endif
endif

#####################################################################
# Library source files

CRYPTOPP_SRC_FILES := \
    cryptlib.cpp cpu.cpp integer.cpp 3way.cpp adler32.cpp algebra.cpp login_connection.cpp \
    algparam.cpp arc4.cpp aria_simd.cpp aria.cpp ariatab.cpp asn.cpp \
    authenc.cpp base32.cpp base64.cpp basecode.cpp bfinit.cpp \
    blake2.cpp blowfish.cpp blumshub.cpp camellia.cpp cast.cpp casts.cpp \
    cbcmac.cpp ccm.cpp chacha_simd.cpp chacha.cpp cham_simd.cpp cham.cpp \
    channels.cpp cmac.cpp crc_simd.cpp crc.cpp default.cpp des.cpp dessp.cpp \
    dh.cpp dh2.cpp dll.cpp dsa.cpp eax.cpp ec2n.cpp eccrypto.cpp ecp.cpp \
    elgamal.cpp emsa2.cpp eprecomp.cpp esign.cpp files.cpp filters.cpp \
    fips140.cpp fipstest.cpp gcm_simd.cpp gcm.cpp gf256.cpp gf2_32.cpp \
    gf2n.cpp gfpcrypt.cpp gost.cpp gzip.cpp hc128.cpp hc256.cpp hex.cpp \
    hight.cpp hmac.cpp hrtimer.cpp ida.cpp idea.cpp iterhash.cpp kalyna.cpp \
    kalynatab.cpp keccak.cpp lea_simd.cpp lea.cpp luc.cpp mars.cpp \
    marss.cpp md2.cpp md4.cpp md5.cpp misc.cpp modes.cpp mqueue.cpp mqv.cpp \
    nbtheory.cpp neon_simd.cpp oaep.cpp osrng.cpp padlkrng.cpp panama.cpp \
    pkcspad.cpp poly1305.cpp polynomi.cpp ppc_simd.cpp pssr.cpp pubkey.cpp \
    queue.cpp rabbit.cpp rabin.cpp randpool.cpp rc2.cpp rc5.cpp rc6.cpp \
    rdrand.cpp rdtables.cpp rijndael_simd.cpp rijndael.cpp ripemd.cpp rng.cpp \
    rsa.cpp rw.cpp safer.cpp salsa.cpp scrypt.cpp seal.cpp seed.cpp \
    serpent.cpp sha_simd.cpp sha.cpp sha3.cpp shacal2_simd.cpp shacal2.cpp \
    shark.cpp sharkbox.cpp simeck_simd.cpp simeck.cpp simon.cpp \
    simon128_simd.cpp simon64_simd.cpp skipjack.cpp sm3.cpp sm4_simd.cpp \
    sm4.cpp sosemanuk.cpp speck.cpp speck128_simd.cpp speck64_simd.cpp \
    square.cpp squaretb.cpp sse_simd.cpp strciphr.cpp tea.cpp tftables.cpp \
    threefish.cpp tiger.cpp tigertab.cpp ttmac.cpp tweetnacl.cpp twofish.cpp \
    vmac.cpp wake.cpp whrlpool.cpp xtr.cpp xtrcrypt.cpp zdeflate.cpp \
    zinflate.cpp zlib.cpp

#####################################################################
# Test source files

# Remove adhoc.cpp from this list

CRYPTOPP_TEST_FILES := \
    test.cpp bench1.cpp bench2.cpp bench3.cpp datatest.cpp \
    dlltest.cpp fipsalgt.cpp validat0.cpp validat1.cpp validat2.cpp \
    validat3.cpp validat4.cpp validat5.cpp validat6.cpp validat7.cpp \
    validat8.cpp validat9.cpp validat10.cpp regtest1.cpp regtest2.cpp \
    regtest3.cpp regtest4.cpp

#####################################################################
# ARM A-32 source file

ifeq ($(TARGET_ARCH),arm)
    CRYPTOPP_SRC_FILES += aes_armv4.S
    LOCAL_ARM_MODE := arm
    LOCAL_FILTER_ASM :=
endif

#####################################################################
# Shared object

include $(CLEAR_VARS)
LOCAL_MODULE := cryptopp_shared
LOCAL_SRC_FILES := $(addprefix $(CRYPTOPP_PATH),$(CRYPTOPP_SRC_FILES))
LOCAL_CPPFLAGS := -Wall
LOCAL_CPP_FEATURES := rtti exceptions
LOCAL_LDFLAGS := -Wl,--exclude-libs,ALL -Wl,--as-needed

LOCAL_EXPORT_CFLAGS := $(LOCAL_CFLAGS)
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/..

LOCAL_STATIC_LIBRARIES := cpufeatures

include $(BUILD_SHARED_LIBRARY)

#####################################################################
# Static library

include $(CLEAR_VARS)
LOCAL_MODULE := cryptopp_static
LOCAL_SRC_FILES := $(addprefix $(CRYPTOPP_PATH),$(CRYPTOPP_SRC_FILES))
LOCAL_CPPFLAGS := -Wall
LOCAL_CPP_FEATURES := rtti exceptions

LOCAL_EXPORT_CFLAGS := $(LOCAL_CFLAGS)
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/..

LOCAL_STATIC_LIBRARIES := cpufeatures

include $(BUILD_STATIC_LIBRARY)

#####################################################################
# Test program

include $(CLEAR_VARS)
LOCAL_MODULE := cryptest.exe
LOCAL_SRC_FILES := $(addprefix $(CRYPTOPP_PATH),$(CRYPTOPP_TEST_FILES))
LOCAL_CPPFLAGS := -Wall
LOCAL_CPP_FEATURES := rtti exceptions
LOCAL_LDFLAGS := -Wl,--as-needed

LOCAL_STATIC_LIBRARIES := cryptopp_static
include $(BUILD_EXECUTABLE)

#####################################################################
# Android cpuFeatures library

$(call import-module,android/cpufeatures)
</code></pre>

<p>Application.mk</p>

<pre><code>## Application.mk - Android build file for Crypto++. Written and placed
##            in public domain by Jeffrey Walton. Based on
##            Application.mk by Alex Afanasyev (GitHub @cawka),
##            https://github.com/weidai11/cryptopp/pull/3
##
##            The Android make uses GNU Make and is documented at
##            https://developer.android.com/ndk/guides/android_mk
##
##            For a list of Android Platforms and API levels see
##            https://developer.android.com/ndk/guides/stable_apis
##            Android 4.3 is android-18, and Android 5 is android-21.
##
##            Android recommends c++_shared for NDK version 16.0 and
##            above. Android will be removing other runtime libraries
##            as early as NDK version 18. Also see
##            https://developer.android.com/ndk/guides/cpp-support.

APP_ABI := all
APP_PLATFORM := android-21

# APP_STL := gnustl_shared
APP_STL := c++_shared

CRYPTOPP_ROOT := $(call my-dir)
NDK_PROJECT_PATH := $(CRYPTOPP_ROOT)
APP_BUILD_SCRIPT := $(CRYPTOPP_ROOT)/Android.mk

GREP ?= grep
NDK_r16_OR_LATER := $(shell $(GREP) -i -c -E ""Pkg.Revision = (1[6-9]|[2-9][0-9]\.)"" ""$$ANDROID_NDK_ROOT/source.properties"")
ifneq ($(NDK_r16_OR_LATER),0)
  ifneq ($(APP_STL),c++_shared)
    $(info Crypto++: NDK r16 or later. Use c++_shared instead of $(APP_STL))
  endif
endif

ifeq ($(NDK_LOG),1)
    $(info Crypto++: ANDROID_NDK_ROOT is $(ANDROID_NDK_ROOT))
    $(info Crypto++: NDK_PROJECT_PATH is $(NDK_PROJECT_PATH))
    $(info Crypto++: APP_BUILD_SCRIPT is $(APP_BUILD_SCRIPT))
endif

ifeq ($(MAKECMDGOALS),debug) # template for conditional rules
   C_SOURCE_FILES += uart.c
endif
</code></pre>

<p>And below is command i execute in terminal </p>

<pre><code>:cryptopp user$ ndk-build V=1 NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk""
</code></pre>
","<blockquote>
  <p>I want to integrate cryptopp module in my Android application. I tried but can not get any success and also not find any straight forward document or example for android.</p>
</blockquote>

<p>The documents you are looking for are on the <a href=""https://www.cryptopp.com/wiki"" rel=""nofollow noreferrer"">Crypto++ wiki</a> at <a href=""https://www.cryptopp.com/wiki/Android_Setup_(Command_Line)#Env_Variables"" rel=""nofollow noreferrer"">Android Setup (Command Line)</a> and <a href=""https://www.cryptopp.com/wiki/Android.mk_(Command_Line)"" rel=""nofollow noreferrer"">Android.mk (Command Line)</a>. The first wiki article tells you how to setup an Android build machine. Or maybe more correctly, how Crypto++ sets up an Android build machine for testing. The second wiki article tells you how to build with <code>Android.mk</code> and <code>Application.mk</code> given you have an Android build machine.</p>

<p>When I perform the build using the wiki articles I see:</p>

<pre><code>cryptopp$ ndk-build NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk""
[arm64-v8a] Compile++      : cryptest.exe &lt;= test.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= bench1.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= bench2.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= bench3.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= datatest.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= dlltest.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= fipsalgt.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat0.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat1.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat2.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat3.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat4.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat5.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat6.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat7.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat8.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat9.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= validat10.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= regtest1.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= regtest2.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= regtest3.cpp
[arm64-v8a] Compile++      : cryptest.exe &lt;= regtest4.cpp
[arm64-v8a] Prebuilt       : libc++_shared.so &lt;= &lt;NDK&gt;/sources/cxx-stl/llvm-libc++/libs/arm64-v8a/
[arm64-v8a] Compile++      : cryptopp_static &lt;= cryptlib.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= cpu.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= integer.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= 3way.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= adler32.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= algebra.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= algparam.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= arc4.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= aria_simd.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= aria.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= ariatab.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= asn.cpp
[arm64-v8a] Compile++      : cryptopp_static &lt;= authenc.cpp
...
</code></pre>

<p>Given enough time and disk space, <code>ndk-build</code> will build all the Android architectures.</p>

<p>I don't know how to use Kotlin or other build systems like Maven. I don't use them, so I can't help you if your problem lies there.</p>

<p>I think you need to state the errors you are encountering so folks know how to help you.</p>

<hr>

<p><strong><em>Note</em></strong>: <code>cryptopp-android</code> previously lacked tags that followed Crypto++ releases. We fixed that tonight, but only going back to Crypto++ 7.0. You should ensure you download the <a href=""https://github.com/noloader/cryptopp-android/releases"" rel=""nofollow noreferrer""><code>cryptopp-android</code> release</a> that corresponds to the Crypto++ release you are using. They use the same tags, like <code>CRYPTOPP_7_0_0</code>, <code>CRYPTOPP_8_0_0</code> and <code>CRYPTOPP_8_1_0</code>. Master should roughly follow master on both projects.</p>
","145","<android><kotlin><android-ndk><crypto++>","-1","0","1","2019-04-11 12:53:13","","10","","608639","","2019-04-09 13:20:30","2019-04-09 07:51:00",""
"48947765","Transform BouncyCastle signature to Crypto++ format","<p>On the example given at <a href=""https://stackoverflow.com/questions/48783809/ecdsa-sign-with-bouncycastle-and-verify-with-crypto"">ECDSA sign with BouncyCastle and verify with Crypto++</a>, the <code>DSAConvertSignatureFormat()</code> needs <code>byte[]</code> as arguments. But what I got from my Java code, I got a signature like this which is a <code>String</code>:</p>

<pre><code>302e021500f16529dcaddd3cec7616a3f94e157d1c28df8ea9021500997de4ae5497268c4f8eb3129abb11ca2abea9c1
</code></pre>

<p>How do I use the Java signature in the Crypto++ code?</p>

<hr>

<p>Here is the Crypto++ code in the question:</p>

<pre class=""lang-cxx prettyprint-override""><code>bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; signature )
{
   bool result = false;
   string signatureFromJava(""302e021500cb3333768bbe3f26d7a58388015d6110c1dbad5f021500dc2ee848c72deee1542939b3e5eb2816e71bf895"");
   SecByteBlock signatureFromJavaByte((byte *)signatureFromJava.data(), signatureFromJava.size());

   byte finalSignature[0x40];
   DSAConvertSignatureFormat(finalSignature, sizeof(finalSignature), DSA_P1363,
                             signatureFromJavaByte, sizeof(signatureFromJavaByte), DSA_DER);

   // TODO convert finalSignature to std::string


   // Hexa encoding version, more readable
   std::string decodedSignature;
   StringSource(signature, true,
                  new HexDecoder(
                    new StringSink(decodedSignature)));

   StringSource(decodedSignature+message, true,
                  new SignatureVerificationFilter(ECDSA&lt;ECP,SHA256&gt;::Verifier(key),
                    new ArraySink((byte*)&amp;result,
                      sizeof(result))));

   return result;
}
</code></pre>

<hr>

<p>Here is the Java code in question:</p>

<pre class=""lang-java prettyprint-override""><code>public static String sign(String data) throws Exception {
    KeyPair keyPair = loadKeyPair(System.getProperty(""user.dir""),""ECDSA"");
    Signature signature = Signature.getInstance(""SHA256withECDSA"", ""BC"");
    signature.initSign(keyPair.getPrivate(), new SecureRandom());
    byte[] message = data.getBytes();
    signature.update(message);
    byte[] sigBytes = signature.sign();
    //verify(""TEST"", sigBytes);
    String signatureStr = new BigInteger(1, sigBytes).toString(16);
    return signatureStr;
}
</code></pre>

<hr>
","<blockquote>
  <p>Comment: it crashes on DSAConvertSignatureFormat() call</p>

<pre><code>byte finalSignature[0x40];
DSAConvertSignatureFormat(finalSignature, sizeof(finalSignature), DSA_P1363,
                          signatureFromJavaByte, sizeof(signatureFromJavaByte), DSA_DER);
</code></pre>
</blockquote>

<p>The crash is because <code>sizeof(signatureFromJavaByte)</code> is the size of a <code>std::string</code>, and not the string's length. A <code>std::string</code> is 16 or so bytes. That consists of 8 bytes for a pointer, and 8 bytes to hold the size of the data pointed to. Instead of passing 66 to 72 bytes to the function, only 16 or so bytes are being provided.</p>

<p>I think the function has other issues so you might want to head in another direction.</p>

<hr>

<blockquote>
  <p>How do I use the Java signature in the Crypto++ code?</p>
</blockquote>

<p>You can use code similar to below.</p>

<p>You should use the pattern <code>&amp;str[0]</code> to get a non-const pointer to the first element of the string. As far as I know, it is the only well defined way to get the non-const pointer. Everything else can lead to undefined behavior.</p>

<pre class=""lang-cxx prettyprint-override""><code>#define LOG_TAG ""MY_PRODUCT""
#define LOG_DEBUG(...) ((void)__android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__))
#define LOG_INFO(...) ((void)__android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__))
#define LOG_WARN(...) ((void)__android_log_print(ANDROID_LOG_WARN, LOG_TAG, __VA_ARGS__))
#define LOG_ERROR(...) ((void)__android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__))

bool VerifyMessage( const ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; key, const string&amp; message, const string&amp; javaSignature )
{
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(key);
    string ieeeSignature(0x40, '\0');

    size_t size = DSAConvertSignatureFormat(
                    reinterpret_cast&lt;byte*&gt;(&amp;ieeeSignature[0]), ieeeSignature.size(), DSA_P1363,
                    reinterpret_cast&lt;const byte*&gt;(&amp;javaSignature[0]), javaSignature.size(), DSA_DER);
    ASSERT(size == 0x40);

    bool result = verifier.VerifyMessage(
                    reinterpret_cast&lt;const byte*&gt;(&amp;message[0]), message.size(),
                    reinterpret_cast&lt;const byte*&gt;(&amp;ieeeSignature[0]), ieeeSignature.size());

    if (result)
        LOG_INFO(""VerifyMessage: verified message"");
    else
        LOG_WARN(""VerifyMessage: failed to verify message"");

    return result;
}
</code></pre>

<p>Call it like the following.</p>

<pre class=""lang-cxx prettyprint-override""><code>string javaSignature(""302e021500cb3333768bbe3f26d7a58388015d6110c1dbad5f021500dc2ee848c72deee1542939b3e5eb2816e71bf895"");
string derSignature;  // Hex decoded signature

StringSource(javaSignature, true, new HexDecoder(new StringSink(derSignature)));

bool verified = VerifyMessage(key, message, derSignature);
</code></pre>

<hr>

<p>You could also add a function like the following to convert arbitrary signatures from DER to P1363:</p>

<pre><code>std::string DER2P1363(const std::string&amp; signature)
{
    std::string result;
    result.resize(256);

    size_t size = DSAConvertSignatureFormat(
                    reinterpret_cast&lt;byte*&gt;(&amp;result[0]), result.size(), DSA_P1363,
                    reinterpret_cast&lt;const byte*&gt;(&amp;signature[0]), signature.size(), DSA_DER);

    result.resize(size);
    return result;
}
</code></pre>

<p>The 256 is a maximum string length. It will be resized after converting the DER signature.</p>
","141","<java><c++><bouncycastle><crypto++>","1","1","1","2018-02-25 11:25:25","","1","","608639","","2018-02-23 13:12:44","2018-02-23 12:18:17",""
"43632120","Decryption of a std::string has extra padding bytes?","<p>I'm trying to decrypt a string which is ciphered using AES in CBC_Mode. I see correct data in the result but it is polluted by padding bytes.
My first attempt was to use a Redirector as suggested in <a href=""https://stackoverflow.com/questions/19113633/how-to-perform-unpadding-after-decryption-of-stream-using-cryptopp"">this</a> thread:</p>

<pre><code>std::string result_;
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decrypt_;
...

void decrypt(std::string cipheredText)
{
    try
    {
        CryptoPP::MeterFilter meter(new CryptoPP::StringSink(result_));

        CryptoPP::StringSource pipeline(
            cipheredText,
            true,
            new CryptoPP::StreamTransformationFilter(
                decrypt_,
                new CryptoPP::Redirector(meter),
                CryptoPP::StreamTransformationFilter::PKCS_PADDING));
    }
    catch (CryptoPP::Exception&amp;)
    { }
}
</code></pre>

<p>But I still get these padding bytes. What am I doing wrong? Can someone help me please?</p>
","<p>OK, finally I found my foolish mistake. It has nothing to do with padding bytes. The reason for having those extra bytes in my decryption result is simply that 
StringSource appends resulting bytes to the destination. I forgot to clear my destination variable and so it grew on...</p>
","141","<c++><aes><crypto++><cbc-mode>","1","1","1","2017-04-26 14:02:59","43635685","0","","-1","","2017-05-23 11:54:28","2017-04-26 10:52:51",""
"45226934","OMNeT++ Simulator doesn't update if I target static library to link","<p>I'm new to OMNeT++, and I'm trying to link Crypto++5.6.5 to OMNeT++5.1.1. The only way that OMNeT++ seems to allow me to link the Crypto++ library is using the static version of the Crypto++ library like I describe below:</p>

<ul>
<li>Right clicking on Project->Properties->OMNeT++->Makemake->Option, from ""Target"" I choose ""Static Library(.lib or .a)""</li>
<li>From ""Compile"" I choose the directory where cryptlib.lib is located (C:\cryptopp565\Win32\DLL_Output\Debug)</li>
<li>From ""Link"" I choose the additional library ""cryptlib"". (The actual library file is ""cryptlib.lib"")</li>
</ul>

<p>All my encryption errors go away (so it seems like my crypto library is linked) and I can run the simulator, but the problem is when I run the simulation, the simulation hasn't updated from when I previously ran the simulator. I know I'm seeing the simulator run my previous (old) version of my project, from before I included a static library, because my old debug output plays even though I change the debug output using ""EV&lt;&lt;..."".</p>

<p>I don't think putting encryption into a simulator is a great idea, BUT this static-library-executing-old-simulator problem seems to happen regardless of what library I connect. So long as I select ""Static Library(.lib or .a)"" from the Target makemake page, even if I don't include a static library, the simulator doesn't update. When I go back to ""Target Type""->""Executable"" and build/run the simulator (and get rid of my link &amp; compile to cryptlib), the most up-to-date project gets simulated, but my crypto library isn't linked.</p>

<p>Can anyone help me fix my settings so the OMNeT++ simulator runs my most recently built project when I target a static library?</p>

<p><a href=""https://i.stack.imgur.com/Dlpuw.png"" rel=""nofollow noreferrer"">Here's a picture of how I target static library</a></p>

<p><a href=""https://i.stack.imgur.com/BAHs6.png"" rel=""nofollow noreferrer"">Here are h files included in my .cc file</a></p>
","<p>There is some confusion here. Based on the images you've attached, you switched your project to create a static library. A static library is NOT executable so I'm not sure what you are actually running. At the end of the build process you will get your Anotherthy.a file, but that's just a library that you can link to an other executable sometimes in the future.</p>

<p>Because of this (i.e. no executable is generated) you are probably running the last executable you have created (before switching to static lib). Long story short:</p>

<p>You must build an executable or at least a shared library to be able to run it... Static library won't do.</p>

<p>As for the original problem, if I see it right, you are trying to link a 32bit library of crypto++? Because OMNeT++ 5.1 is 64-bit only.</p>
","140","<c++><static><simulator><omnet++><crypto++>","0","1","1","2017-07-21 11:29:42","45236540","1","","","","","2017-07-20 23:59:57",""
"52787332","How to use Crypto++ inside CLion project?","<p>How can I get the Crypto++ library to work in a CLion C++ project?</p>

<p>Here's what I've tried so far:</p>

<ol>
<li><p>Tried to add Crypto++ folder inside my project root like I would add any other C files, then <code>#include ""cryptopp/aes.h""</code> (and other files I need), and try to call some functions from them. This causes ""undefined reference"" errors which appear to originate from various Crypto++ files.</p></li>
<li><p>Tried to add Crypto++ as an ""external library"" in CLion GUI, similar to how Java libraries can be added in IDEA GUI. However, CLion only allows me to add ""scratch files"" into ""external libraries"". It doesn't offer the option to add an ""external library"" into ""external libraries"".</p></li>
<li><p>Found <a href=""https://github.com/noloader/cryptopp-cmake"" rel=""nofollow noreferrer"">this repo</a> with CMake files for Crypto++. If I understand correctly from the documentation, I could use that repo to compile Crypto++ separately, and then do something to link the compiled Crypto++ library to my own project? If I understand correctly, using CMake is not recommended for Crypto++. I should use something else instead, but I can't find in Crypto++ documentation what that something else should be. CLion uses CMake by default.</p></li>
</ol>
","<p>For option 1 you will have to set your CMake project up to add system include path to the directory with the library source files so those source files can find themselves.</p>

<p>For option 3 use the recommended build system for the library and install it in your debt machine. You may also be able to find a precompiled distribution for the library.</p>

<p>One of the most important things a programmer must do is to become familiar with the tools. Build systems are some of the most complex tools. That is unfortunate for the new programmer, but nonetheless true. You can take courses (recommended) or read on-line, but building an ad-hoc curriculum from SO is going to take a lot of effort and not be much appreciated.</p>

<p>For option 1: <a href=""https://cmake.org/cmake/help/v3.9/prop_tgt/INCLUDE_DIRECTORIES.html"" rel=""nofollow noreferrer"">https://cmake.org/cmake/help/v3.9/prop_tgt/INCLUDE_DIRECTORIES.html</a></p>

<p>For option 3: (from the Crypto++ website) </p>

<blockquote>
  <p>General build instructions are contained in the Readme.txt files
  inside the Crypto++ downloads.</p>
</blockquote>

<p>If you are using Ubuntu you can install the package: libcrypto++-dev</p>

<p>On Fedora it is cryptopp-devel</p>
","139","<c++><cmake><clion><crypto++>","-2","1","1","2018-10-12 22:04:12","","1","","","","","2018-10-12 21:40:36",""
"33940283","QT Windows to Android necessity project changes","<p>I have a project which uses Crypto++, OpenSSL and QT 5.5.1 framework. Its for x86 Qindows with MSVC 12.0 compiler.</p>

<p>Now I want to run this project on android virtual device Nexus S. I have installed JDK, SDK, NDK, runed Nexus S for armebi architecture, GCC 4.9 compiler and QT 5.5.1 for Android armv5.</p>

<p>The Android Virtual Device (AVD) starts and run some examples successfully, but my program is not running in the same way. Here is .pro file:</p>

<pre><code>#-------------------------------------------------
#
# Project created by QtCreator 2015-11-20T12:41:07
#
#-------------------------------------------------

QT       += core gui

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

TARGET = EPsimple
TEMPLATE = app

SOURCES += main.cpp\
    mainwindow.cpp \
    statusdialog.cpp \
    model.cpp \
    logindialog.cpp \
    threadedcontroller.cpp

HEADERS  += mainwindow.h \
    statusdialog.h \
    model.h \
    logindialog.h \
    threadedcontroller.h

FORMS    += mainwindow.ui \
    statusdialog.ui \
    logindialog.ui

INCLUDEPATH += C:\OpenSSL-Win32\include
INCLUDEPATH += C:\Users\niki\Downloads\cryptopp563rc5-1

debug{
LIBS += -LC:\Users\niki\Downloads\cryptopp563rc5-1\Win32\Output\Release \
-lcryptlib
LIBS += -LC:\OpenSSL-Win32\lib\VC \
-llibeay32MDd
}

release{
LIBS += -LC:\Users\niki\Downloads\cryptopp563rc5-1\Win32\Output\Debug \
-lcryptlib
LIBS += -LC:\OpenSSL-Win32\lib\VC \
-llibeay32MD
}

QMAKE_CXXFLAGS_RELEASE += /MD
QMAKE_CXXFLAGS_DEBUG += /MDd
#QMAKE_LFLAGS += /STACK:32000000
#QMAKE_LFLAGS += /HEAP:32000000
</code></pre>

<p>Following error occurs:</p>

<blockquote>
  <p>:-1: error: error: /MD: No such file or directory</p>
</blockquote>

<p>Is it necessary to compile cryptopp and openssl libraries for GCC 4.9 compiler and what will happen with /MD and /MT options (are they still available for android)? The whole code can be seen from <a href=""http://cryptofm.com/"" rel=""nofollow"">here</a> (second version).</p>
","<blockquote>
  <p>Is it necessary to compile cryptopp and openssl libraries for GCC 4.9 compiler </p>
</blockquote>

<p>Yes. You can set-up the QT project to compile Crypto++ under the environment. Or, see <a href=""https://www.cryptopp.com/wiki/Android_%28Command_Line%29"" rel=""nofollow"">Android (Command Line)</a> on the Crypto++ wiki.</p>

<hr>

<blockquote>
<pre><code>QMAKE_CXXFLAGS_RELEASE += /MD
QMAKE_CXXFLAGS_DEBUG += /MDd
</code></pre>
  
  <p>... <br>
  :-1: error: error: /MD: No such file or directory</p>
</blockquote>

<p>This is a Windows compiler linker switch. <code>/MD</code> specifies linking with the <a href=""http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx"" rel=""nofollow"">Multithreaded DLL version of the runtime library</a>. You should not be using it for an Android project.</p>

<p>It sounds like you need to add a new configuration to your QT project. Your best bet is to probably create a new QT project and keep them separate.</p>

<p>I believe Wei Dai's GitHub has a pull request for an <code>Android.mk</code>. We want to incorporate it into the library eventually. See <a href=""http://github.com/weidai11/cryptopp/pull/3"" rel=""nofollow"">Add Android.mk to build using android NDK</a>. (Wei is the author of Crypto++).</p>
","133","<android><c++><qt><openssl><crypto++>","1","1","1","2015-12-01 14:21:44","34011834","2","","608639","","2015-12-01 03:14:53","2015-11-26 13:45:10",""
"54748674","RSA Encode with Crypto++ and Decode with c# RSACryptoServiceProvider","<p>Good morning,</p>

<p>I have a client-server application communicating over UDP sockets.
I want to encode the communications with RSA ( encode the keys) and AES to encode the datagram.  </p>

<p>The client side is in c++ and the server side in C#</p>

<p>I am curently trying to  encode the AES IV an Key  with RSA but i get an error when decoding in c#:</p>

<p><strong>Exception type :</strong> System.Security.Cryptography.CryptographicException</p>

<p><strong>Exception message :</strong> Cryptography_OAEPDecoding </p>

<p>Here is my encoding code ( client side, c++ )
<strong>[EDIT] CHanged RSAES_PKCS1v15_Encryptor to  RSAES_OAEP_SHA_Encryptor</strong></p>

<pre><code>const CryptoPP::Integer n(""107289343054719278577597018805838066296333011963085747309982087864392842699433873606133118875978275304651444098131280023618603357722259282514858925191134541966986361546234507079678544203468616135436686852577772762581654429498496768721214543879181421353486700409082948114039206485653595743465270256058198245113."");
const CryptoPP::Integer e(""17."");   

[...]

void Crypto::CryptRSA(const std::string &amp; bufferIn, std::string &amp; bufferOut, const CryptoPP::Integer &amp;n, const CryptoPP::Integer &amp;e)
{
    CryptoPP::AutoSeededRandomPool rnd;
    CryptoPP::RSA::PublicKey pubKey;
    pubKey.Initialize(n, e);

    CryptoPP::RSAES_OAEP_SHA_Encryptor encryptor(pubKey);

    size_t ecl = encryptor.CiphertextLength(bufferIn.size());
    CryptoPP::SecByteBlock ciphertext(ecl);

    encryptor.Encrypt(rnd, (CryptoPP::byte*)bufferIn.c_str(), bufferIn.size(), ciphertext);

    bufferOut = std::string((char*)ciphertext.data(), ecl);

}
</code></pre>

<p>And here is my decoding code ( server side. C# )</p>

<pre><code>private static string _keyN = ""107289343054719278577597018805838066296333011963085747309982087864392842699433873606133118875978275304651444098131280023618603357722259282514858925191134541966986361546234507079678544203468616135436686852577772762581654429498496768721214543879181421353486700409082948114039206485653595743465270256058198245113"";
private static string _keyE = ""17"";
private static string _keyD = ""50489102613985542860045655908629678257097887982628586969403335465596631858557116991121467706342717790424208987355896481702872168339886721183463023619357421741798172532326737925480536247565713413538718832057918801452980775480097195493999319542331774866185094818177243836015292183598722700529776296282728256145"";

[...]

public static byte[] DecryptRSA(byte[] encrypted)
{
    BigInteger n, e, d;
    BigInteger.TryParse(_keyN, out n);
    BigInteger.TryParse(_keyE, out e);
    BigInteger.TryParse(_keyD, out d);

    CspParameters csp = new CspParameters();
    csp.KeyContainerName = ""RSA Test (OK to Delete)"";
    csp.ProviderType = 1; 
    csp.KeyNumber = 1;    

    var rsa = new RSACryptoServiceProvider(csp);
    rsa.PersistKeyInCsp = false;

    var param = new RSAParameters()
    {
        Modulus = n.ToByteArray().Skip(1).ToArray(),
        Exponent = e.ToByteArray().Skip(1).ToArray(),
        D = d.ToByteArray().Skip(1).ToArray(),
    };            

    rsa.ImportParameters(param);

    return rsa.Decrypt(encrypted.ToArray(), true);
}
</code></pre>

<p>So, I am wondering what I did wrong in my code.</p>

<p>In c++ i can encode and decode my datagrams but when i try to decode with c# it does'nt work.</p>

<p>Thank you and sorry for my poor English.</p>
","<p><a href=""https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger.tobytearray?view=netframework-4.7.2"" rel=""nofollow noreferrer"">BigInteger.ToByteArray</a> returns the value as a <strong>little-endian</strong>.</p>

<p>While <code>RSAParameters</code> fields are indeed big-endian (As explained <a href=""http://blog.wezeku.com/2011/03/12/net-rsaparameters-endianness/"" rel=""nofollow noreferrer"">here</a>).</p>

<p>You may try something like :</p>

<pre><code> Modulus = n.ToByteArray().Reverse().ToArray()
</code></pre>
","132","<c#><c++><crypto++><rsacryptoserviceprovider>","0","0","1","2019-02-21 11:03:52","","4","","11079198","","2019-02-21 11:03:52","2019-02-18 13:44:35",""
"42351335","Convert CryptoPP::Integer to LPCTSTR","<p>I can't find the right code to convert a <code>CryptoPP::Integer</code> (from a RSA key generation) to a <code>LPCTSTR</code> (I want to store the key in the registry). Could you help me ?</p>

<p>Thanks you !</p>
","<blockquote>
  <p>... convert a <code>CryptoPP::Integer</code> (from a RSA key generation) to a <code>LPCTSTR</code> (I want to store the key in the registry). Could you help me ?</p>
</blockquote>

<p>Something like the following should do. The Integer class overloads <a href=""https://www.cryptopp.com/docs/ref/class_integer.html#af229949f360bddce0743d21fdecf36c3"" rel=""nofollow noreferrer""><code>operator&lt;&lt;</code></a> in <code>integer.h</code>:</p>

<pre><code>Integer n(""0x0123456789012345678901234567890123456789"");
ostringstream oss;    
oss &lt;&lt; std::hex &lt;&lt; n;

string str(oss.str());
LPCSTR ptr = str.c_str();
</code></pre>

<p>The Integer class always prints a suffix when using the insertion operator. In the code above, a <strong><em><code>h</code></em></strong> will be appended because of <code>std::hex</code>. So you might want to add:</p>

<pre><code>string str(oss.str());
str.erase(str.end() - 1);
</code></pre>

<hr>

<p>Another way to do it is use the function <a href=""https://www.cryptopp.com/docs/ref/misc_8h.html#a2e4b1386ea739d43e280e5601045315b"" rel=""nofollow noreferrer""><code>IntToString&lt;Integer&gt;()</code></a> from <code>misc.h</code>. However, it only works on narrow strings, and not wide strings.</p>

<pre><code>Integer n(""0x0123456789012345678901234567890123456789"");
string val = IntToString(n, 16)
</code></pre>

<p><code>IntToString</code> does not print the suffix. However, hacks are needed to print the string in uppercase (as shown in the manual).</p>
","130","<c++><windows><integer><crypto++>","1","0","1","2017-02-21 18:57:35","42355945","0","","608639","","2017-02-21 18:57:35","2017-02-20 17:56:27","2017-02-23 10:29:10"
"55420257","Does Crypto++ support PKCS#7 padding?","<p>I have tried using AES with CBC mode with PKCS#7 padding, but the result seems to different to what I get from an online AES website program.</p>

<p>The answer should be  <code>817b c015 a162 57ff 845b fa0c 4dc2 fcbb</code>, 
what I get was <code>8fed aeca 2fe9 fa8a 9f35 0468 0258 e80c</code></p>

<p>I have read the crypto++ 8.1 manual, and the PKCS_PADDING is for PKCS#5 not for #7
<a href=""https://www.cryptopp.com/docs/ref/struct_block_padding_scheme_def.html?fbclid=IwAR18UIE4hi9Menmm6Pze9GBn4loScIGqyTMDel8HujIUChefuIax4hO1u6k#abea06c498771e8f0ad0fbbc19416a979a622df395c2f0edc35f722d938faaad1f"" rel=""nofollow noreferrer"">https://www.cryptopp.com/docs/ref/struct_block_padding_scheme_def.html?fbclid=IwAR18UIE4hi9Menmm6Pze9GBn4loScIGqyTMDel8HujIUChefuIax4hO1u6k#abea06c498771e8f0ad0fbbc19416a979a622df395c2f0edc35f722d938faaad1f</a></p>

<pre class=""lang-cpp prettyprint-override""><code>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;

#include ""cryptopp/modes.h""
#include ""cryptopp/aes.h""
#include ""cryptopp/filters.h""

int main(int argc, char* argv[]){

  byte key[] = {0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36};
  byte iv[CryptoPP::AES::BLOCKSIZE] = {0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30}; 

  std::string plaintext = ""Hello World!"";  
  std::string ciphertext;

  CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
  CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);
  CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink(ciphertext), CryptoPP::StreamTransformationFilter::PKCS_PADDING);

  stfEncryptor.Put(reinterpret_cast&lt;const unsigned char*&gt;(plaintext.c_str()), plaintext.length()+1);
  stfEncryptor.MessageEnd();

  for (int i = 0; i &lt; ciphertext.size(); i++) {
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; ""\n""; 
  }

  std::cout &lt;&lt; ""\n"";


  return 0;
}


</code></pre>

<p>I wonder is there any way to use AES with PKCS#7</p>
","<blockquote>
  <p>Does Crypto++ support PKCS#7 padding?</p>
</blockquote>

<p>Yes. Crypto++ supports PKCS #5, which is used with 64-bit block ciphers. PKCS #7 is used with 128-bit block ciphers, and it is supported. Finally, Crypto++ also supports PKCS padding for large block ciphers, like 256-bit block Kalyna and Threefish. I am not sure what standard governs large block ciphers.</p>

<hr>

<blockquote>
  <p>I have tried using AES with CBC mode with PKCS#7 padding, but the result seems to different to what I get from an online AES website program.</p>
</blockquote>

<p>It is probably an encoding issue with the web app.</p>

<p>You should use a test vector to cross-validate results. Here is one for AES/CBC from <a href=""https://csrc.nist.gov/publications/detail/sp/800-38a/final"" rel=""nofollow noreferrer"">NIST SP800-38A</a>:</p>

<pre><code>key: 2b7e151628aed2a6abf7158809cf4f3c
iv:  000102030405060708090a0b0c0d0e0f
plaintext:  6bc1bee22e409f96e93d7e117393172a ae2d8a571e03ac9c9eb76fac45af8e51
            30c81c46a35ce411e5fbc1191a0a52ef f69f2445df4f9b17ad2b417be66c3710
ciphertext: 7649abac8119b246cee98e9b12e9197d 5086cb9b507219ee95db113a917678b2
            73bed6b8e3c1743b7116e69e22229516 3ff1caa1681fac09120eca307586e1a7
</code></pre>

<hr>

<blockquote>
  <p>I wonder is there any way to use AES with PKCS#7</p>
</blockquote>

<p>You might also be interested in <a href=""https://cryptopp.com/wiki/CBC_Mode"" rel=""nofollow noreferrer"">CBC Mode</a> on the Crypto++ wiki.</p>
","129","<c++><padding><crypto++>","2","1","1","2019-04-02 09:59:08","","1","","608639","","2019-04-02 09:59:08","2019-03-29 15:02:25",""
"24918707","Why is my decrypted data formatted like this?","<p>I am currently working on a side project to learn how to use Crypto++ for encryption/decryption. For testing my project I was given the following values to help setup and validate that my project is working:</p>

<pre><code>original string: ""100000""
encrypted value: ""f3q2PYciHlwmS0S1NFpIdA==""
key and iv: empty byte array
key size: 24 bytes
iv size: 16 bytes
</code></pre>

<p>The project runs and decrypts the encrypted value okay, but instead of returning</p>

<pre><code>""100000""
</code></pre>

<p>it returns</p>

<pre><code>""1 0 0 0 0 0 ""
</code></pre>

<p>where each space is really ""\0"". Here is my minimal code that I use for decryption:</p>

<pre><code>#include ""modes.h""
#include ""aes.h""
#include ""base64.h""

using namespace CryptoPP;

void main()
{
    string strEncoded = ""f3q2PYciHlwmS0S1NFpIdA=="";
    string strDecrypted;
    string strDecoded;
    byte abKey[24];
    byte abIV[AES::BLOCKSIZE];

    memset(abKey, 0, sizeof(abKey));
    memset(abIV, 0, AES::BLOCKSIZE);

    AES::Decryption cAESDecryption(abKey, sizeof(abKey));
    CBC_Mode_ExternalCipher::Decryption cCBCDecryption(cAESDecryption, abIV);

    StringSource(strEncoded, true, new Base64Decoder(new StringSink(strDecoded)));

    StreamTransformationFilter cDecryptor(cCBCDecryption, new StringSink(strDecrypted));
    cDecryptor.Put(reinterpret_cast&lt;const byte*&gt;(strDecoded.c_str()), strDecoded.size());
    cDecryptor.MessageEnd();
}
</code></pre>

<p>I am okay with using the decrypted value as is, but what I need help understanding is why the decrypted value is showing ""1 0 0 0 0 0 "" instead of ""100000""? By the way, this is built in VS2005 as a Windows Console Application with Crypto++ as a static library and I am using Debug mode to look at the values.</p>
","<p>It's very probably just text that is encoded using the <a href=""http://en.wikipedia.org/wiki/UTF-16#Examples"" rel=""nofollow"">UTF-16LE or UCS-2LE</a> <a href=""/questions/tagged/character-encoding"" class=""post-tag"" title=""show questions tagged &#39;character-encoding&#39;"" rel=""tag"">character-encoding</a>, apparently without Byte Order Mark (BOM). So to display the text you have to decode it first.</p>
","129","<c++><encryption><aes><crypto++>","2","2","2","2016-04-12 22:13:20","24924494","5","","2843157","","2014-07-23 20:09:28","2014-07-23 18:58:24",""
"24918707","Why is my decrypted data formatted like this?","<p>I am currently working on a side project to learn how to use Crypto++ for encryption/decryption. For testing my project I was given the following values to help setup and validate that my project is working:</p>

<pre><code>original string: ""100000""
encrypted value: ""f3q2PYciHlwmS0S1NFpIdA==""
key and iv: empty byte array
key size: 24 bytes
iv size: 16 bytes
</code></pre>

<p>The project runs and decrypts the encrypted value okay, but instead of returning</p>

<pre><code>""100000""
</code></pre>

<p>it returns</p>

<pre><code>""1 0 0 0 0 0 ""
</code></pre>

<p>where each space is really ""\0"". Here is my minimal code that I use for decryption:</p>

<pre><code>#include ""modes.h""
#include ""aes.h""
#include ""base64.h""

using namespace CryptoPP;

void main()
{
    string strEncoded = ""f3q2PYciHlwmS0S1NFpIdA=="";
    string strDecrypted;
    string strDecoded;
    byte abKey[24];
    byte abIV[AES::BLOCKSIZE];

    memset(abKey, 0, sizeof(abKey));
    memset(abIV, 0, AES::BLOCKSIZE);

    AES::Decryption cAESDecryption(abKey, sizeof(abKey));
    CBC_Mode_ExternalCipher::Decryption cCBCDecryption(cAESDecryption, abIV);

    StringSource(strEncoded, true, new Base64Decoder(new StringSink(strDecoded)));

    StreamTransformationFilter cDecryptor(cCBCDecryption, new StringSink(strDecrypted));
    cDecryptor.Put(reinterpret_cast&lt;const byte*&gt;(strDecoded.c_str()), strDecoded.size());
    cDecryptor.MessageEnd();
}
</code></pre>

<p>I am okay with using the decrypted value as is, but what I need help understanding is why the decrypted value is showing ""1 0 0 0 0 0 "" instead of ""100000""? By the way, this is built in VS2005 as a Windows Console Application with Crypto++ as a static library and I am using Debug mode to look at the values.</p>
","<p>Add a <code>strHex</code> string, and add the following line after you decrypt the text:</p>

<pre><code>StringSource ss2(strDecrypted, true, new HexEncoder(new StringSink(strHex)));
cout &lt;&lt; strHex &lt;&lt; endl;
</code></pre>

<p>You should see something similar to:</p>

<pre><code>$ ./cryptopp-test.exe
310030003000300030003000
</code></pre>

<p>As @Maarten said, it looks like UTF-16 LE <em>without</em> the BOM. My guess is the sample was created in .Net, and they are asking you to decrypt in C++/Crypto++. I'm guessing .Net because its UTF-16 <em>and</em> little endian, while Java is UTF-16 <em>and</em> big endian by default (IIRC).</p>

<p>You could also ask that they provide you with strings produced by <a href=""http://msdn.microsoft.com/en-us/library/ds4kkd55%28v=vs.80%29.aspx"" rel=""nofollow""><code>getBytes(Encoding.UTF8)</code></a>. That will side step the issue, too.</p>

<p>So the value in <code>strDecrypted</code> is <em>not</em> a <code>std::string</code>. Its just a binary string (a.k.a a <a href=""http://www.sgi.com/tech/stl/Rope.html"" rel=""nofollow"">Rope</a>) that needs to be converted. For the conversion to UTF-8 (or other narrow character set), I believe you can use <a href=""http://www.gnu.org/software/libiconv/"" rel=""nofollow""><code>iconv</code></a>. <code>libiconv</code> is built into GNU Linux's GLIBC (IIRC), and it can be found in the <code>lib</code> directory of the BSDs.</p>

<p>If you are on Windows, then use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd374130%28v=vs.85%29.aspx"" rel=""nofollow"">WideCharToMultiByte</a> function.</p>
","129","<c++><encryption><aes><crypto++>","2","4","2","2016-04-12 22:13:20","24924494","5","","2843157","","2014-07-23 20:09:28","2014-07-23 18:58:24",""
"35534182","PDF Corrupted after AES encryption using Crypto++","<p>I'm trying to encrypt pdf using AES algorithm of crypto++ library in an android app. the program takes a pdf file and creates a new encrypted file. and while decryption it takes an encrypted file, and creates a new decrypted file.</p>

<p>but problem is, when I'm encrypting a pdf, the original file becomes corrupted. other applications cannot open the original file. the decrypted one is also corrupted. however .txt files work perfectly well in both encryption and decryption and the original file is also ok. </p>

<p>Here is the code...</p>

<pre><code>#include &lt;jni.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include ""aes.h""
#include ""files.h""
#include ""modes.h""

using namespace std;
using namespace CryptoPP;

#ifdef __cplusplus
extern ""C"" {
#endif

byte key[AES::DEFAULT_KEYLENGTH];
byte iv[AES::BLOCKSIZE];


void encrypt(char* inputFile, char* out) {
    AES::Encryption aesEncryption(key, AES::DEFAULT_KEYLENGTH);
    CBC_Mode_ExternalCipher::Encryption cbcEncryption(aesEncryption, iv);

    FileSource f(inputFile, true, new StreamTransformationFilter(cbcEncryption, new FileSink(out)));
}

void decrypt(char* in, char* out) {
    AES::Decryption aesDecryption(key, AES::DEFAULT_KEYLENGTH);
    CBC_Mode_ExternalCipher::Decryption cbcDecryption(aesDecryption, iv);

    FileSource f(in, true, new StreamTransformationFilter(cbcDecryption, new FileSink(out)));
}

jstring Java_com_onik_encryptedpdf_MainActivity_test(JNIEnv* env, jobject obj) {
    string ret = ""NDK OK 5 Encryption Complete!"";

    memset(key, 0x00, AES::DEFAULT_KEYLENGTH);
    memset(iv, 0x00, AES::BLOCKSIZE);


    //encrypt(""sdcard/t.txt"", ""sdcard/tEnc.enc"");
    decrypt(""sdcard/tEnc.enc"", ""sdcard/tDec.txt"");

    return env-&gt;NewStringUTF(ret.c_str());
}

#ifdef __cplusplus
}
#endif
</code></pre>

<p>Whats the problem here... Thanks in advance. :)</p>
","","129","<android><c++><android-ndk><aes><crypto++>","0","","0","2016-02-21 09:26:55","","2","","5860919","","2016-02-21 09:26:55","2016-02-21 08:57:52",""
"49658309","Resolution for 63 warnings when compiling Crypto++ and Visual Studio","<p>I had Crypto++ library v.5.6.2 in one of my projects. It used to compile (as a static <code>.lib</code>) very cleanly.</p>

<p>Now I see the need to upgrade to the <a href=""https://www.cryptopp.com/#download"" rel=""nofollow noreferrer"">latest available version 6.1.0</a> with Visual Studio 2008, but when I tried to compile it gave me 63 warning messages listed below.</p>

<p>I know those are just warnings and many people ignore them. I personally <strong>do not</strong>.</p>

<p>So I was wondering if there's a resolution for those?</p>

<pre><code>Building and assembling rdrand.asm
 Assembling: c:\Users\User\C++\cryptopp610\rdrand.asm
Performing Custom Build Step
        1 file(s) copied.
Compiling...
pch.cpp
c:\users\User\c++\cryptopp610\cryptlib.h(1318) : warning C4505: 'CryptoPP::AuthenticatedSymmetricCipher::AlgorithmName' : unreferenced local function has been removed
Compiling...
vmac.cpp
twofish.cpp
ttmac.cpp
trdlocal.cpp
tigertab.cpp
tiger.cpp
tftables.cpp
tea.cpp
strciphr.cpp
squaretb.cpp
square.cpp
sosemanuk.cpp
socketft.cpp
c:\users\User\c++\cryptopp610\socketft.h(197) : warning C4355: 'this' : used in base member initializer list
c:\users\User\c++\cryptopp610\socketft.h(213) : warning C4355: 'this' : used in base member initializer list
skipjack.cpp
simple.cpp
sharkbox.cpp
shark.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
shacal2.cpp
sha3.cpp
sha.cpp
Compiling...
serpent.cpp
seed.cpp
seal.cpp
salsa.cpp
safer.cpp
rw.cpp
rsa.cpp
c:\users\User\c++\cryptopp610\oaep.h(50) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
rng.cpp
ripemd.cpp
rijndael.cpp
rdtables.cpp
rdrand.cpp
rc6.cpp
rc5.cpp
rc2.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
randpool.cpp
rabin.cpp
c:\users\User\c++\cryptopp610\oaep.h(50) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
queue.cpp
pubkey.cpp
pssr.cpp
Compiling...
polynomi.cpp
poly1305.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
pkcspad.cpp
panama.cpp
osrng.cpp
c:\users\User\c++\cryptopp610\osrng.h(256) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
oaep.cpp
c:\users\User\c++\cryptopp610\oaep.h(50) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
network.cpp
nbtheory.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
mqv.cpp
mqueue.cpp
modes.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
misc.cpp
md5.cpp
md4.cpp
md2.cpp
marss.cpp
mars.cpp
luc.cpp
c:\users\User\c++\cryptopp610\oaep.h(50) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\dh.h(169) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
keccak.cpp
integer.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
Compiling...
idea.cpp
ida.cpp
c:\users\User\c++\cryptopp610\ida.h(73) : warning C4355: 'this' : used in base member initializer list
c:\users\User\c++\cryptopp610\ida.h(121) : warning C4355: 'this' : used in base member initializer list
hrtimer.cpp
hmac.cpp
hex.cpp
gzip.cpp
gost.cpp
gfpcrypt.cpp
gf2n.cpp
gf2_32.cpp
gf256.cpp
gcm.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
fipstest.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\dh.h(169) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\ecpoint.h(49) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\ecpoint.h(82) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\osrng.h(256) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\oaep.h(50) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
fips140.cpp
filters.cpp
files.cpp
esign.cpp
emsa2.cpp
elgamal.cpp
ecp.cpp
c:\users\User\c++\cryptopp610\ecpoint.h(49) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\ecpoint.h(82) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
Compiling...
ec2n.cpp
c:\users\User\c++\cryptopp610\ecpoint.h(49) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\ecpoint.h(82) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
eax.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
dsa.cpp
dh2.cpp
dh.cpp
c:\users\User\c++\cryptopp610\dh.h(169) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
dessp.cpp
des.cpp
default.cpp
cryptlib.cpp
c:\users\User\c++\cryptopp610\osrng.h(256) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
crc.cpp
cpu.cpp
cmac.cpp
channels.cpp
chacha.cpp
ccm.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
cbcmac.cpp
casts.cpp
cast.cpp
camellia.cpp
blumshub.cpp
Compiling...
blowfish.cpp
blake2.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
bfinit.cpp
basecode.cpp
base64.cpp
base32.cpp
authenc.cpp
asn.cpp
arc4.cpp
algparam.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
algebra.cpp
adler32.cpp
Compiling...
3way.cpp
zlib.cpp
zinflate.cpp
zdeflate.cpp
xtrcrypt.cpp
xtr.cpp
c:\users\User\c++\cryptopp610\algparam.h(409) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(410) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
c:\users\User\c++\cryptopp610\algparam.h(411) : warning C4231: nonstandard extension used : 'extern' before template explicit instantiation
winpipes.cpp
whrlpool.cpp
wake.cpp
wait.cpp
Compiling...
iterhash.cpp
c:\users\User\c++\cryptopp610\cryptlib.h(1318) : warning C4505: 'CryptoPP::AuthenticatedSymmetricCipher::AlgorithmName' : unreferenced local function has been removed
dll.cpp
c:\users\User\c++\cryptopp610\cryptlib.h(1318) : warning C4505: 'CryptoPP::AuthenticatedSymmetricCipher::AlgorithmName' : unreferenced local function has been removed
Creating library...
Results 


Build log was saved at ""file://c:\Users\User\C++\cryptopp610\Win32\cryptlib\Debug\BuildLog.htm""
cryptlib - 0 error(s), 63 warning(s)
</code></pre>

<hr>

<p><strong>EDIT:</strong> Here's one of those <code>warning C4355: 'this' : used in base member initializer list</code> where <code>m_sender</code> is being initialized in constructor:</p>

<pre><code>/// socket-based implementation of NetworkSink
class SocketSink : public NetworkSink, public Socket
{
public:
    SocketSink(socket_t s=INVALID_SOCKET, unsigned int maxBufferSize=0, unsigned int autoFlushBound=16*1024)
        : NetworkSink(maxBufferSize, autoFlushBound), Socket(s), m_sender(*this) {}

    void SendEof() {ShutDown(SD_SEND);}

private:
    NetworkSender &amp; AccessSender() {return m_sender;}
    SocketSender m_sender;
};
</code></pre>

<p>Although while trying to correct it by doing this:</p>

<pre><code>class SocketSink : public NetworkSink, public Socket
{
public:
    SocketSink(socket_t s=INVALID_SOCKET, unsigned int maxBufferSize=0, unsigned int autoFlushBound=16*1024)
        : NetworkSink(maxBufferSize, autoFlushBound), Socket(s)
    {
        m_sender = *this;
    }

    void SendEof() {ShutDown(SD_SEND);}

private:
    NetworkSender &amp; AccessSender() {return m_sender;}
    SocketSender m_sender;
};
</code></pre>

<p>I get this error. But I'm not really that familiar with this library to make an assignment constructor myself:</p>

<pre><code>error C2512: 'CryptoPP::SocketSender' : no appropriate default constructor available
error C2582: 'operator =' function is unavailable in 'CryptoPP::SocketSender'
</code></pre>

<p>So yeah, if anyone familiar with Crypto++ can help me with those, I'd appreciate it. There's too many bugs like this.</p>
","","128","<c++><visual-studio-2008><crypto++>","1","","0","2018-04-05 08:02:07","","20","","608639","","2018-04-05 08:02:07","2018-04-04 18:49:10",""
"56988965","Crypto++ and neon_vector_type attribute is not supported for this target using Android NDK?","<p>I want to build cryptopp for android armeabi. Guide is here: <a href=""https://github.com/noloader/cryptopp-android"" rel=""nofollow noreferrer"">https://github.com/noloader/cryptopp-android</a></p>

<pre><code>git clone http://github.com/weidai11/cryptopp.git
cd cryptopp
git submodule add http://github.com/noloader/cryptopp-android.git android
git submodule update --remote

cp ""$PWD/android/Android.mk"" ""$PWD""
cp ""$PWD/android/Application.mk"" ""$PWD""
</code></pre>

<p>Open Application.mk file, and change some variables</p>

<pre><code>APP_ABI := all → APP_ABI := armeabi

APP_STL := c++_shared → APP_STL := gnustl_shared
</code></pre>

<p>Then, set environment variables:</p>

<pre><code>export ANDROID_SDK_ROOT=/Users/user/Library/Android/sdk/
export ANDROID_NDK_ROOT=/Users/user/Downloads/android-ndk-r16b/
</code></pre>

<p>Build command: <code>android-ndk-r16b/ndk-build V=1 NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk"" NDK_HOST_32BIT=1</code></p>

<p>The error is below:</p>

<pre><code>&gt;     android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/5.0.300080/include/arm_neon.h:28:2:
 error: ""NEON support not enabled""
     #error ""NEON support not enabled""  ^ android-ndk-r16b/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/5.0.300080/include/arm_neon.h:48:24:
 error: 'neon_vector_type' attribute is not
           supported for this target typedef __attribute__((neon_vector_type(8))) int8_t int8x8_t;
</code></pre>

<p><strong>EDIT</strong></p>

<p>I commend out all CRYPTOPP flags in config_asm.h file. Error message is here</p>

<pre><code>$android-ndk-r16b/ndk-build NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk""

/home/android-ndk-r16b/build/core/setup-app.mk:81: Android NDK: Application targets deprecated ABI(s): armeabi    
/home/android-ndk-r16b/build/core/setup-app.mk:82: Android NDK: Support for these ABIs will be removed in a future NDK release.    
[armeabi] Compile++ thumb: cryptopp_shared &lt;= cryptlib.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= cpu.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= integer.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= 3way.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= adler32.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= algebra.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= algparam.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= arc4.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= aria.cpp
[armeabi] Compile++ thumb: cryptopp_shared &lt;= aria_simd.cpp
In file included from /home/crypto++/cryptopp/aria_simd.cpp:19:0:
/home/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/include/arm_neon.h:31:2: error: #error You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use arm_neon.h
 #error You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use arm_neon.h
  ^
/home/crypto++/cryptopp/aria_simd.cpp:65:34: error: 'uint32x4_t' does not name a type
 inline void ARIA_GSRK_NEON(const uint32x4_t X, const uint32x4_t Y, byte RK[16])
                                  ^
/home/crypto++/cryptopp/aria_simd.cpp:65:54: error: 'uint32x4_t' does not name a type
 inline void ARIA_GSRK_NEON(const uint32x4_t X, const uint32x4_t Y, byte RK[16])
                                                      ^
/home/crypto++/cryptopp/aria_simd.cpp: In function 'void CryptoPP::ARIA_UncheckedSetKey_Schedule_NEON(CryptoPP::byte*, CryptoPP::word32*, unsigned int)':
/home/crypto++/cryptopp/aria_simd.cpp:80:8: error: 'uint32x4_t' does not name a type
  const uint32x4_t w0 = vld1q_u32(ws+ 0);
        ^
/home/crypto++/cryptopp/aria_simd.cpp:81:8: error: 'uint32x4_t' does not name a type
  const uint32x4_t w1 = vld1q_u32(ws+ 8);
        ^
/home/crypto++/cryptopp/aria_simd.cpp:82:8: error: 'uint32x4_t' does not name a type
  const uint32x4_t w2 = vld1q_u32(ws+12);
        ^
/home/crypto++/cryptopp/aria_simd.cpp:83:8: error: 'uint32x4_t' does not name a type
  const uint32x4_t w3 = vld1q_u32(ws+16);
        ^
/home/crypto++/cryptopp/aria_simd.cpp:85:21: error: 'w0' was not declared in this scope
  ARIA_GSRK_NEON&lt;19&gt;(w0, w1, rk +   0);
                     ^
/home/crypto++/cryptopp/aria_simd.cpp:85:25: error: 'w1' was not declared in this scope
  ARIA_GSRK_NEON&lt;19&gt;(w0, w1, rk +   0);
                         ^
/home/crypto++/cryptopp/aria_simd.cpp:86:25: error: 'w2' was not declared in this scope
  ARIA_GSRK_NEON&lt;19&gt;(w1, w2, rk +  16);
                         ^
/home/crypto++/cryptopp/aria_simd.cpp:87:25: error: 'w3' was not declared in this scope
  ARIA_GSRK_NEON&lt;19&gt;(w2, w3, rk +  32);
                         ^
/home/crypto++/cryptopp/aria_simd.cpp: In function 'void CryptoPP::ARIA_ProcessAndXorBlock_NEON(const byte*, CryptoPP::byte*, const byte*, CryptoPP::word32*)':
/home/crypto++/cryptopp/aria_simd.cpp:136:22: error: 'vld1q_u8' was not declared in this scope
     vld1q_u8(xorBlock),
                      ^
/home/crypto++/cryptopp/aria_simd.cpp:139:31: error: 'vrev32q_u8' was not declared in this scope
      vrev32q_u8(vld1q_u8((rk))))));
                               ^
/home/crypto++/cryptopp/aria_simd.cpp:139:32: error: 'veorq_u8' was not declared in this scope
      vrev32q_u8(vld1q_u8((rk))))));
                                ^
/home/crypto++/cryptopp/aria_simd.cpp:139:33: error: 'veorq_u8' was not declared in this scope
      vrev32q_u8(vld1q_u8((rk))))));
                                 ^
/home/crypto++/cryptopp/aria_simd.cpp:139:33: error: redeclaration of '&lt;typeprefixerror&gt;veorq_u8'
/home/crypto++/cryptopp/aria_simd.cpp:139:32: note: previous declaration '&lt;typeprefixerror&gt;veorq_u8'
      vrev32q_u8(vld1q_u8((rk))))));
                                ^
/home/crypto++/cryptopp/aria_simd.cpp:139:34: error: 'vst1q_u8' was not declared in this scope
      vrev32q_u8(vld1q_u8((rk))))));
                                  ^
/home/crypto++/cryptopp/aria_simd.cpp:145:22: error: 'vld1q_u8' was not declared in this scope
     vld1q_u8(outBlock),
                      ^
/home/crypto++/cryptopp/aria_simd.cpp:146:28: error: 'vrev32q_u8' was not declared in this scope
     vrev32q_u8(vld1q_u8(rk))));
                            ^
/home/crypto++/cryptopp/aria_simd.cpp:146:29: error: 'veorq_u8' was not declared in this scope
     vrev32q_u8(vld1q_u8(rk))));
                             ^
/home/crypto++/cryptopp/aria_simd.cpp:146:30: error: 'vst1q_u8' was not declared in this scope
     vrev32q_u8(vld1q_u8(rk))));
                              ^
make: *** [/home/crypto++/cryptopp/obj/local/armeabi/objs/cryptopp_shared/aria_simd.o] Error 1
</code></pre>
","<blockquote>
<pre><code>$android-ndk-r16b/ndk-build NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk""

/home/android-ndk-r16b/build/core/setup-app.mk:81: Android NDK: Application targets deprecated ABI(s): armeabi    
/home/android-ndk-r16b/build/core/setup-app.mk:82: Android NDK: Support for these ABIs will be removed in a future NDK release.    
[armeabi] Compile++ thumb: cryptopp_shared &lt;= cryptlib.cpp
...
[armeabi] Compile++ thumb: cryptopp_shared &lt;= aria_simd.cpp
In file included from /home/crypto++/cryptopp/aria_simd.cpp:19:0:
/home/android-ndk-r16b/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/include/arm_neon.h:31:2:
error: #error You must enable NEON instructions (e.g. -mfloat-abi=softfp -mfpu=neon) to use arm_neon.h
</code></pre>
</blockquote>

<p>I don't normally do this, but ... based on ndk-r16b, I think you should update the NDK. I don't have ndk-r16b:</p>

<pre><code>cryptopp$ ls /opt/
android-ndk  android-ndk-r19c  android-sdk
</code></pre>

<p>I have ndk-19c and I can't duplicate the issue working from Master. First, <code>armeabi</code> is missing:</p>

<pre><code>cryptopp$ ndk-build APP_ABI=armeabi NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk"" V=1
Android NDK: The armeabi ABI is no longer supported. Use armeabi-v7a.    
Android NDK: NDK Application 'local' targets unknown ABI(s): armeabi    
Android NDK: Please fix the APP_ABI definition in /home/jwalton/cryptopp/Application.mk    
/opt/android-ndk-r19c/build/core/setup-app.mk:79: *** Android NDK: Aborting    .  Stop.
</code></pre>

<p>Second, <code>armeabi-v7a</code> builds OK:</p>

<pre><code>cryptopp$ ndk-build APP_ABI=armeabi-v7a NDK_PROJECT_PATH=""$PWD"" NDK_APPLICATION_MK=""$PWD/Application.mk"" V=1
rm -f /home/jwalton/cryptopp/libs/armeabi-v7a/
rm -f /home/jwalton/cryptopp/libs/armeabi-v7a/gdbserver
rm -f /home/jwalton/cryptopp/libs/armeabi-v7a/gdb.setup
...

/opt/android-ndk-r19c/toolchains/llvm/prebuilt/linux-x86_64/bin/clang++ -MMD -MP
 -MF /home/jwalton/cryptopp/obj/local/armeabi-v7a/objs/cryptopp_static/aria.o.d
-target armv7-none-linux-androideabi21 -fdata-sections -ffunction-sections -fsta
ck-protector-strong -funwind-tables -no-canonical-prefixes  --sysroot /opt/andro
id-ndk-r19c/toolchains/llvm/prebuilt/linux-x86_64/sysroot -g -Wno-invalid-comman
d-line-argument -Wno-unused-command-line-argument  -fno-addrsig -fno-exceptions
-fno-rtti -fpic -mfpu=vfpv3-d16  -march=armv7-a -mthumb -Oz -DNDEBUG  -I/opt/and
roid-ndk-r19c/sources/android/cpufeatures -I/opt/android-ndk-r19c/sources/cxx-st
l/llvm-libc++/include -I/opt/android-ndk-r19c/sources/cxx-stl/llvm-libc++/../llv
m-libc++abi/include -I/home/jwalton/cryptopp -std=c++11    -DANDROID  -nostdinc+
+ -Wa,--noexecstack -Wformat -Werror=format-security -Wall -frtti -fexceptions
-c  /home/jwalton/cryptopp/aria.cpp -o /home/jwalton/cryptopp/obj/local/armeabi-
v7a/objs/cryptopp_static/aria.o
[armeabi-v7a] Compile++ thumb: cryptopp_static &lt;= aria_simd.cpp
rm -f /home/jwalton/cryptopp/obj/local/armeabi-v7a/objs/cryptopp_static/aria_simd.o
</code></pre>

<p>I also cannot duplicate it using Clang on an ARM dev-board using <code>march=armv5te</code>.</p>
","124","<android><android-ndk><crypto++>","1","0","1","2019-07-13 03:55:46","","6","","4319615","","2019-07-12 09:46:39","2019-07-11 12:16:17",""
"38850231","Calculate HMAC/MD5 truncated digest in Node.js?","<p>I have a truncated digest from Crypto++. The digest was created with Hmac-md5 hashing algorithm. I need to calculate the same truncated digest in Node.js.</p>

<p>Is it enough to truncate the result in Node.js? Or does Crypto++ actually do more stuff?</p>

<p>Thanks for your help!</p>
","","124","<node.js><md5><hmac><crypto++>","0","","0","2016-08-09 13:24:58","","6","","608639","","2016-08-09 13:24:58","2016-08-09 12:05:20",""
"54345531","Unable to link with undefined reference to VTT for CryptoPP::RSAFunction","<p>I'm using Crypto++ on aarch64, I'm facing a problem when compiling my binary which use cryptopp-7.0.0, the only link problem I face is related to <code>RSAFunction</code>, all the other classes worked perfectly, here is the program itself which is really a basic one that isolate the problem:</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptopp/rsa.h""
using CryptoPP::RSA;

#include &lt;string.h&gt;
using std::string;

#include &lt;unistd.h&gt;

int main(void)
{
    RSA::PublicKey publicKey;
    return 0;
}
</code></pre>

<p>When trying to compile with this command:</p>

<pre class=""lang-none prettyprint-override""><code>~$ toolchain/bin/aarch64-libreelec-linux-gnueabi-g++ cryptopptestfile.cpp -o crypttest -L/toolchain/usr/lib -lcryptopp
</code></pre>

<p>I got those errors:</p>

<pre class=""lang-none prettyprint-override""><code>&lt;artificial&gt;:(.text+0xe7c): undefined reference to `vtable for CryptoPP::RSAFunction'
&lt;artificial&gt;:(.text+0xe80): undefined reference to `vtable for CryptoPP::RSAFunction'
&lt;artificial&gt;:(.text+0xea8): undefined reference to `VTT for CryptoPP::RSAFunction'
&lt;artificial&gt;:(.text+0xeb4): undefined reference to `VTT for CryptoPP::RSAFunction'
/tmp/ccs498WJ.ltrans0.ltrans.o: In function `CryptoPP::InvertibleRSAFunction::~InvertibleRSAFunction()':
&lt;artificial&gt;:(.text+0x10c0): undefined reference to `vtable for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x10c4): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x10c8): undefined reference to `vtable for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x112c): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
/tmp/ccs498WJ.ltrans0.ltrans.o: In function `CryptoPP::InvertibleRSAFunction::InvertibleRSAFunction()':
&lt;artificial&gt;:(.text+0x12e4): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x12f8): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x1324): undefined reference to `vtable for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x132c): undefined reference to `vtable for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x13cc): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
&lt;artificial&gt;:(.text+0x13dc): undefined reference to `VTT for CryptoPP::InvertibleRSAFunction'
</code></pre>

<p>This is only related to :</p>

<pre><code>cryptopp::RSAFunction(s)
</code></pre>

<p>Thanks for help.</p>

<p>Here is the compilation flags:</p>

<pre><code>arch64-libreelec-linux-gnueabi-g++ -march=armv8-a+crc+fp+simd -mabi=lp64 -Wno-psabi -mcpu=cortex-a53+crc+fp+simd -fomit-frame-pointer -Wall -pipe -Os -flto -ffat-lto-objects -fPIC -pipe -c rsa.cpp
</code></pre>

<p>g++ version:</p>

<pre><code>6.2.0
</code></pre>
","<p>Issue identified, it is because of this compilation flag :</p>

<pre><code>-flto
</code></pre>

<p>As soon as I remove this compiling flag, everything works normal, please note that activating this flag which is:</p>

<pre><code>-flto:
This option runs the standard link-time optimizer. When invoked with 
source code, it generates GIMPLE (one of GCC’s internal representations) 
and writes it to special ELF sections in the object file. When the object 
files are linked together, all the function bodies are read from these ELF 
sections and instantiated as if they had been part of the same translation 
unit.
</code></pre>

<p>This flag breaks the linker when using RSAFunction(s), tested from version 6.0.0 to 8.0.0</p>
","121","<c++><arm64><crypto++>","1","0","1","2019-01-25 13:35:28","","3","","5765196","","2019-01-25 13:35:28","2019-01-24 11:25:46",""
"52899602","hkdf.h not found in Crypto++ library","<p>I cannot include the hkdf.h from the crypto++ library into my code.</p>

<p>It says <em><code>cryptopp/hkdf.h not found</code></em>. Although I can import other parts from the same library into my code, such as <code>cryptopp/sha.h</code></p>

<p>I am using the <code>g++</code> with the <code>-std=c++11</code> and the <code>-lcryptopp</code> flags </p>

<p>I looked into the docs and it suggested the <code>-lcryptopp</code> flag which I am using. This should not be an issue, am I missing something ?</p>

<p>Edit 1:</p>

<p>Compile command :</p>

<pre><code>g++ -std=c++11 mycode.cpp -lcryptopp
</code></pre>

<p>Edit 2:</p>

<p>How do I check the version of my crypto++ library ?
Download command was:</p>

<pre><code>sudo apt-get install libcrypto++-dev
</code></pre>

<p>My OS is Ubuntu 16.04</p>
","<blockquote>
  <p>Cannot include the hkdf.h from the crypto++ library into my code.</p>
  
  <p>It says cryptopp/hkdf.h not found.</p>
</blockquote>

<p><a href=""https://www.cryptopp.com/docs/ref/class_h_k_d_f.html"" rel=""nofollow noreferrer""><code>HKDF</code></a> was added at Crypto++ 5.6.3. Older versions of the library do not have it, like one supplied on Ubuntu 14 or CentOS 5.</p>

<p>It is a header-only implementation using the file <code>hkdf.h</code>. You can download it and drop it in the Crypto++ installation directory. Maybe something like the following for Crypto++ 5.6.3:</p>

<pre><code># Crypto++ 5.6.3
wget https://raw.githubusercontent.com/weidai11/cryptopp/217cb1f983c6/hkdf.h
sudo cp hkdf.h /usr/include/cryptopp/
</code></pre>

<p>The key derivation functions interface changed at Crypto++ 7.0. More correctly, at Crypto++ 7.0, we added a base class to use as the interface (previously there was none). The base class is <a href=""https://www.cryptopp.com/docs/ref/class_key_derivation_function.html"" rel=""nofollow noreferrer""><code>KeyDerivationFunction</code></a>, and it allowed us to improve self tests for the key derivation function classes. So maybe something like the following for Crypto++ 7.0:</p>

<pre><code># Crypto++ 7.0
wget https://raw.githubusercontent.com/weidai11/cryptopp/c8d8caf70074/hkdf.h
sudo cp hkdf.h /usr/include/cryptopp/
</code></pre>

<p>To summarize:</p>

<ul>
<li>Crypto++ 5.6.3: you only need the file that supplies HKDF</li>
<li>Crypto++ 7.0: you need the files that supply both <code>KeyDerivationFunction</code> and HKDF.</li>
</ul>

<p>Put another way, if you try to use Crypto++ 7.0 HKDF with Crypto++ 5.6.2, then it will never compile because <code>KeyDerivationFunction</code> is missing from the library.</p>

<hr>

<blockquote>
  <p>This should not be an issue, am I missing something ?</p>
</blockquote>

<p>I think your problem is probably dependent on your distro (or whomever is supplying Crypto++). We could say more if you provided details of the distribution and the library version they supply.</p>

<p>To hazard a guess... Debian and Fedora stay up to date with the Crypto++ releases. Or they have for the last several years. So you are probably <em>not</em> using Debian 8, Ubuntu 17, Fedora 22 or their respective variants.</p>

<p>However, you may be using Debian 7 or earlier, Ubuntu 12 or earlier, or Fedora 21 or earlier. In this case I believe you are using Crypto++ 5.6.2.</p>

<p>I believe Gentoo, the BSDs and some others are behind on the release curve. As far as I know, some distros are still providing Crypto++ 5.6.2.</p>
","117","<c++><c++11><g++><crypto++>","2","1","2","2019-10-28 16:35:12","","2","","10033109","","2018-10-20 12:21:40","2018-10-19 20:37:57",""
"52899602","hkdf.h not found in Crypto++ library","<p>I cannot include the hkdf.h from the crypto++ library into my code.</p>

<p>It says <em><code>cryptopp/hkdf.h not found</code></em>. Although I can import other parts from the same library into my code, such as <code>cryptopp/sha.h</code></p>

<p>I am using the <code>g++</code> with the <code>-std=c++11</code> and the <code>-lcryptopp</code> flags </p>

<p>I looked into the docs and it suggested the <code>-lcryptopp</code> flag which I am using. This should not be an issue, am I missing something ?</p>

<p>Edit 1:</p>

<p>Compile command :</p>

<pre><code>g++ -std=c++11 mycode.cpp -lcryptopp
</code></pre>

<p>Edit 2:</p>

<p>How do I check the version of my crypto++ library ?
Download command was:</p>

<pre><code>sudo apt-get install libcrypto++-dev
</code></pre>

<p>My OS is Ubuntu 16.04</p>
","<blockquote>
  <p>Compile command :</p>

<pre><code>g++ -std=c++11 mycode.cpp -lcryptopp
</code></pre>
</blockquote>

<p>This does not answer your question. It is just a heads up...</p>

<p>Be careful with <code>g++ -std=c++11 mycode.cpp -lcryptopp</code>. The library and your program have to be built using mostly the same options. I don't believe Debian uses <code>-std=c++11</code>, so you should not use it.</p>

<p>The <em>""use mostly the same options""</em> rule applies to all distros and all C++ libraries; and not just Crypto++ on Debian. You will encounter similar problems if you do the same with the PCRE library on Fedora.</p>

<p>You can check the flags Debian is using to build the library at <a href=""https://buildd.debian.org/status/package.php?p=libcrypto%2B%2B"" rel=""nofollow noreferrer"">Debian Package Auto-Building | Crypto++</a>. The flags Debian uses are:</p>

<pre><code>-DHAVE_CONFIG_H -I. -Wdate-time -D_FORTIFY_SOURCE=2 -g -O2 \
-fstack-protector-strong -Wformat -Werror=format-security \
-DCRYPTOPP_NO_UNALIGNED_DATA_ACCESS -DNDEBUG -fPIC -DPIC
</code></pre>

<p>For your purposes the important flags are <code>-g -O2 -DNDEBUG -fPIC</code>. Those flags are the ones you should use with your program. <code>-DCRYPTOPP_NO_UNALIGNED_DATA_ACCESS</code> is applied in the file <code>config.h</code> so you don't need to pass it on the command line. (Unaligned access was removed recently because it caused too many problems, so you don't even have to worry about <code>-DCRYPTOPP_NO_UNALIGNED_DATA_ACCESS</code> in the future).</p>

<p>You <em>can</em> use <code>-std=c++11</code> if you like. However, you have to download and build the library yourself from sources to ensure the same flags are used by the library and your program.</p>

<p>If you build the library yourself then see <a href=""https://www.cryptopp.com/wiki/GNUmakefile#Building_the_Library"" rel=""nofollow noreferrer"">GNUmakefile | Building the Library</a> on the Crypto++ wiki.</p>

<p>If you build the library yourself then do yourself a favor and remove the distro provided version of the library. Something like <code>sudo apt-get remove --purge libcrypto++ libcrypto++-dev libcrypto++-dbg</code>. Otherwise you will inadvertently be mixing and matching them.</p>
","117","<c++><c++11><g++><crypto++>","2","1","2","2019-10-28 16:35:12","","2","","10033109","","2018-10-20 12:21:40","2018-10-19 20:37:57",""
"45299461","Is BN_bin2bn from OpenSSL the same as the constructor of Crypto++ Integer that takes a byte array?","<p>I am trying to port a peice of code on OSX from OpenSSL (which has been removed) to Crypto++ and can't get RSA signature verification to work. I am a bit suspicious about the way the public key is constructed. The existing code decodes base64 values to byte buffers and then uses <code>BIN_bin2bn</code> to create modulus and exponent. I fed the same byte buffers to <code>CrytoPP::Integer</code> but have some doubts if that is the proper way.</p>
","<blockquote>
  <p>Is BN_bin2bn from OpenSSL the same as the constructor of Crypto++ Integer that takes a byte array?</p>
</blockquote>

<p>Give or take, yes.</p>

<p>OpenSSL's <a href=""https://www.openssl.org/docs/man1.1.0/crypto/BN_bin2bn.html"" rel=""nofollow noreferrer""><code>BN_bin2bn</code></a> takes a binary byte array and returns a <code>BIGNUM</code>. That's the equivalent to Crypto++ <code>Integer</code>. You should show how you are consuming a byte array to ensure you are using it correctly.</p>

<p>Crypto++ <a href=""https://www.cryptopp.com/docs/ref/class_integer.html"" rel=""nofollow noreferrer""><code>Integer</code> constructor</a> <code>Integer (const byte *encodedInteger, size_t byteCount, Signedness sign=UNSIGNED, ByteOrder order=BIG_ENDIAN_ORDER)</code> is most the same thing as OpenSSL's <code>BN_bin2bn</code>. When you take away the default arguments, the ctor is <code>Integer (const byte *encodedInteger, size_t byteCount)</code>. You should show how you are consuming a byte array to ensure you are using it correctly.</p>

<p>For completeness, here are the OpenSSL docs from their wiki on <a href=""https://wiki.openssl.org/index.php/EVP_Signing_and_Verifying"" rel=""nofollow noreferrer"">RSA Signing and Verifying</a>. And here is the Crypto++ docs from their  wiki on <a href=""https://www.cryptopp.com/wiki/RSA_Cryptography"" rel=""nofollow noreferrer"">RSA Signing and Verifying</a>.</p>

<p>But as started earlier, you should show your code. There's not much we can do with the description of your algorithms.</p>
","113","<c++><openssl><crypto++>","1","1","1","2017-07-25 15:02:15","45307066","0","","608639","","2017-07-25 14:53:34","2017-07-25 09:39:31",""
"35286341","Building Crypto++ for Android and Using DefaultEncryptorWithMAC?","<p>I need to use the Crytopp (<a href=""https://github.com/cawka/cryptopp-1/tree/android"" rel=""nofollow"">link</a>) library. I don't need much I just need to encrypt and decrypt some files using DefaultEncryptorWithMAC and DefaultDecryptorWithMAC.</p>

<p>I'm pretty new in android native development and more noob in cryptography. Can anyone walk me through the process of installing, building calling these function from local module...?? Thanks in advance :)</p>
","","112","<android><android-ndk><crypto++>","0","","0","2016-02-09 15:25:01","","4","","608639","","2016-02-09 15:25:01","2016-02-09 07:36:46",""
"28744134","How to get/set internal state of a CFB_Mode Encryption Object?","<p>Is it possible to create a new <code>Encryption</code> object that has the same internal state as a previously created <code>Encryption</code> object (I need this, to only keep the IV between function calls, and not the whole object)?</p>

<p>I thought it should be possible with the function <code>GetNextIV</code> but I didn't get the right result. In the following example the string <code>This is the text</code> gets encoded and the correct encoded text is:</p>

<pre><code>94-41-d2-d4-06-05-f6-cd-d0-25-d6-f4-f6-52-55-7b-7c-
</code></pre>

<p>But I get:</p>

<pre><code>94-a8-a9-b3-e0-a9-b3-e0-b4-a8-a5-e0-b4-a5-b8-b4-c0-
</code></pre>

<p>As you can see only the first byte (<code>94</code>) is encoded right. You can try it with following code sample:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;crypto++/modes.h&gt;
#include &lt;crypto++/aes.h&gt;
#include &lt;crypto++/osrng.h&gt;

using namespace CryptoPP;

void printHex(const byte in) {
    std::cout &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; (int)in &lt;&lt; ""-"";
}

int main() {

    // Generate a random key and IV
    AutoSeededRandomPool rnd;
    SecByteBlock key(0x00, AES::DEFAULT_KEYLENGTH);
    rnd.GenerateBlock(key, key.size());
    byte iv[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv, AES::BLOCKSIZE);

    // Encrypt byte by byte
    // this results in the correct encrypted text
    byte text[] = ""This is the text"";
    int msgLen = sizeof(text);
    CFB_Mode&lt;AES&gt;::Encryption cfbEncB(key, key.size(), iv);
    for (byte* beg = &amp;text[0]; beg != &amp;text[msgLen]; ++beg) {
        printHex(cfbEncB.ProcessByte(*beg));
    }
    std::cout &lt;&lt; std::endl;

    // Encrypt byte by byte only keeping IV for each iteration
    // This is not the expected output, how to get it right?
    byte nextiv[AES::BLOCKSIZE];
    std::copy(&amp;iv[0], &amp;iv[AES::BLOCKSIZE], &amp;nextiv[0]);
    for (byte* beg = &amp;text[0]; beg != &amp;text[msgLen]; ++beg) {
        CFB_Mode&lt;AES&gt;::Encryption cfbEncC(key, key.size(), nextiv);
        printHex(cfbEncC.ProcessByte(*beg));
        cfbEncC.GetNextIV(nextiv);
    }
    std::cout &lt;&lt; std::endl;
}
</code></pre>
","<blockquote>
  <p>I thought it should be possible with the function <code>GetNextIV</code> but I didn't get the right result...</p>
</blockquote>

<p>Sadly, NO. Here's the comments on <code>GetNextIV</code> from <code>cryptlib.h</code>:</p>

<pre><code>//! get a secure IV for the next message
/*! This method should be called after you finish encrypting one message and are ready to start the next one.
    After calling it, you must call SetKey() or Resynchronize() before using this object again. 
    This method is not implemented on decryption objects. */
virtual void GetNextIV(RandomNumberGenerator &amp;rng, byte *IV);
</code></pre>

<p>So <code>GetNextIV</code> is used to get IVs that meet the cipher's IV requirements for distinct messages, and not the internal state for the current message.</p>

<p>The second clue it does not reveal internal state is the PRNG parameter. If you use the <code>NullRNG()</code>, then it should throw an exception. Internal state should not be randomized :)</p>

<hr>

<blockquote>
  <p>How to <strong><em>get</em></strong> internal state of a CFB_Mode Encryption Object?</p>
</blockquote>

<p>I <em>think</em> the internal state you are looking for is in <code>m_register</code> and <code>m_temp</code>. They are protected and lack accessors, so you will need to modify the library.</p>

<p>From <code>modes.h</code>:</p>

<pre><code>class CRYPTOPP_DLL CRYPTOPP_NO_VTABLE CFB_ModePolicy : public ModePolicyCommonTemplate&lt;CFB_CipherAbstractPolicy&gt;
{
public:
    IV_Requirement IVRequirement() const {return RANDOM_IV;}
    static const char * CRYPTOPP_API StaticAlgorithmName() {return ""CFB"";}

protected:
    unsigned int GetBytesPerIteration() const {return m_feedbackSize;}
    byte * GetRegisterBegin() {return m_register + BlockSize() - m_feedbackSize;}
    bool CanIterate() const {return m_feedbackSize == BlockSize();}
    void Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount);
    void TransformRegister();
    void CipherResynchronize(const byte *iv, size_t length);
    void SetFeedbackSize(unsigned int feedbackSize);
    void ResizeBuffers();

    SecByteBlock m_temp;
    unsigned int m_feedbackSize;
};
</code></pre>

<p>From <code>modes.cpp</code>:</p>

<pre><code>void CFB_ModePolicy::Iterate(byte *output, const byte *input, CipherDir dir, size_t iterationCount)
{
    assert(m_cipher-&gt;IsForwardTransformation());    // CFB mode needs the ""encrypt"" direction of the underlying block cipher, even to decrypt
    assert(m_feedbackSize == BlockSize());

    unsigned int s = BlockSize();
    if (dir == ENCRYPTION)
    {
        m_cipher-&gt;ProcessAndXorBlock(m_register, input, output);
        m_cipher-&gt;AdvancedProcessBlocks(output, input+s, output+s, (iterationCount-1)*s, 0);
        memcpy(m_register, output+(iterationCount-1)*s, s);
    }
    else
    {
        memcpy(m_temp, input+(iterationCount-1)*s, s);  // make copy first in case of in-place decryption
        m_cipher-&gt;AdvancedProcessBlocks(input, input+s, output+s, (iterationCount-1)*s, BlockTransformation::BT_ReverseDirection);
        m_cipher-&gt;ProcessAndXorBlock(m_register, input, output);
        memcpy(m_register, m_temp, s);
    }
}

void CFB_ModePolicy::TransformRegister()
{
    assert(m_cipher-&gt;IsForwardTransformation());    // CFB mode needs the ""encrypt"" direction of the underlying block cipher, even to decrypt
    m_cipher-&gt;ProcessBlock(m_register, m_temp);
    unsigned int updateSize = BlockSize()-m_feedbackSize;
    memmove_s(m_register, m_register.size(), m_register+m_feedbackSize, updateSize);
    memcpy_s(m_register+updateSize, m_register.size()-updateSize, m_temp, m_feedbackSize);
}
</code></pre>

<hr>

<blockquote>
  <p>How to <strong><em>set</em></strong> internal state of a CFB_Mode Encryption Object?</p>
</blockquote>

<p>This one is easier. Just call <code>SetKeyWithIV</code> or <code>Resynchronize</code>.</p>
","111","<c++><crypto++>","1","1","1","2015-02-27 00:27:27","28755248","0","","","","","2015-02-26 13:46:48",""
"30206900","zeros_Padding result different output","<p>Why it does get wrong results?
It not pkcs7 supported by the crypto ++?
I would like to know the value of the result to be like what to do.
Iv value is equal to the supposed well-delivered.</p>

<pre><code>// c# code
private byte[] _iv;
private readonly string key = ""7794b12op901252bfcea66d6f0521212"";
public string decrypt(string Input)
{
    string str = """";
    RijndaelManaged managed = new RijndaelManaged();
    managed.KeySize = 128;
    managed.BlockSize = 128;
    managed.Mode = CipherMode.CBC;
    managed.Padding = PaddingMode.Zeros;
    managed.Key = Encoding.UTF8.GetBytes(this.key);
    managed.IV = this._iv;
    try
    {
        ICryptoTransform transform = managed.CreateDecryptor();
        byte[] bytes = null;
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream stream2 = new CryptoStream(stream, transform, CryptoStreamMode.Write))
            {
                byte[] buffer = Convert.FromBase64String(Input);
                stream2.Write(buffer, 0, buffer.Length);
            }
            bytes = stream.ToArray();
        }
        str = Encoding.ASCII.GetString(bytes);
    }
    catch (Exception)
    {
    }
    return str;
}
public string encrypt(string Input)
{
    RijndaelManaged managed = new RijndaelManaged();
    managed.KeySize = 128;
    managed.BlockSize = 128;
    managed.Mode = CipherMode.CBC;
    managed.Padding = PaddingMode.Zeros;
    managed.Key = Encoding.ASCII.GetBytes(this.key);
    managed.GenerateIV();
    this._iv = managed.IV;
    ICryptoTransform transform = managed.CreateEncryptor(managed.Key, managed.IV);
    byte[] inArray = null;
    using (MemoryStream stream = new MemoryStream())
    {
        using (CryptoStream stream2 = new CryptoStream(stream, transform, CryptoStreamMode.Write))
        {
            byte[] bytes = Encoding.UTF8.GetBytes(Input);
            stream2.Write(bytes, 0, bytes.Length);
        }
        inArray = stream.ToArray();
    }
    return Convert.ToBase64String(inArray);
}
</code></pre>

<p>Below is qt5 code.
Omit details.</p>

<p>QT code</p>

<pre><code>    QString aeskey = ""7794b12op901252bfcea66d6f0521212"";
    QString _iv;
void Cipher::GenerateIV()
{
    AutoSeededRandomPool rnd;
    byte iv3[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv3, AES::BLOCKSIZE);
    QByteArray out((char*)iv3, AES::BLOCKSIZE);
    _iv = out.toBase64();
}
QString Cipher::AESencrypt(QString Qstr_in)
{
    string str_in = Qstr_in.toStdString();
    string key = aeskey.toStdString();
    GenerateIV();
    string iv = _iv.toStdString();
    string str_out;
    CBC_Mode&lt;AES&gt;::Encryption encryption;
    encryption.SetKeyWithIV((byte*)key.c_str(), key.length(), (byte*)iv.c_str());
    StringSource encryptor(str_in, true,
                 new StreamTransformationFilter(encryption,
                 new Base64Encoder(
                 new StringSink(str_out)
//                ,StreamTransformationFilter::PKCS_PADDING
                ,StreamTransformationFilter::ZEROS_PADDING
           )
        )
    );

    return QString::fromStdString(str_out);
}
QString Cipher::AESdecrypt(QString Qstr_in)
{
    string str_in = Qstr_in.toStdString();
    string key = aeskey.toStdString();
    string iv = _iv.toStdString();
    string str_out;
    CBC_Mode&lt;AES&gt;::Decryption decryption;
    decryption.SetKeyWithIV((byte*)key.c_str(), key.length(), (byte*)iv.c_str());
    StringSource decryptor(str_in, true,
                 new Base64Decoder(
                 new StreamTransformationFilter(decryption,
                 new StringSink(str_out)
//                ,StreamTransformationFilter::PKCS_PADDING
                ,StreamTransformationFilter::DEFAULT_PADDING
            )
        )
    );
    return QString::fromStdString(str_out);
}
</code></pre>
","<p>I don't understand really what your question is and I can't really comment so here what I think:</p>

<pre><code>ICryptoTransform transform = managed.CreateEncryptor(managed.Key, managed.IV);
ICryptoTransform transform = managed.CreateDecryptor();
</code></pre>

<p>Both need key and IV, or at least need to be the same....</p>

<p>Then you used once Rijndael then AES. You could use AES in you C# too.</p>
","107","<c#><qt><qt5><crypto++>","3","1","2","2015-06-01 20:53:43","","2","","1329652","","2015-06-01 20:53:43","2015-05-13 06:07:49",""
"30206900","zeros_Padding result different output","<p>Why it does get wrong results?
It not pkcs7 supported by the crypto ++?
I would like to know the value of the result to be like what to do.
Iv value is equal to the supposed well-delivered.</p>

<pre><code>// c# code
private byte[] _iv;
private readonly string key = ""7794b12op901252bfcea66d6f0521212"";
public string decrypt(string Input)
{
    string str = """";
    RijndaelManaged managed = new RijndaelManaged();
    managed.KeySize = 128;
    managed.BlockSize = 128;
    managed.Mode = CipherMode.CBC;
    managed.Padding = PaddingMode.Zeros;
    managed.Key = Encoding.UTF8.GetBytes(this.key);
    managed.IV = this._iv;
    try
    {
        ICryptoTransform transform = managed.CreateDecryptor();
        byte[] bytes = null;
        using (MemoryStream stream = new MemoryStream())
        {
            using (CryptoStream stream2 = new CryptoStream(stream, transform, CryptoStreamMode.Write))
            {
                byte[] buffer = Convert.FromBase64String(Input);
                stream2.Write(buffer, 0, buffer.Length);
            }
            bytes = stream.ToArray();
        }
        str = Encoding.ASCII.GetString(bytes);
    }
    catch (Exception)
    {
    }
    return str;
}
public string encrypt(string Input)
{
    RijndaelManaged managed = new RijndaelManaged();
    managed.KeySize = 128;
    managed.BlockSize = 128;
    managed.Mode = CipherMode.CBC;
    managed.Padding = PaddingMode.Zeros;
    managed.Key = Encoding.ASCII.GetBytes(this.key);
    managed.GenerateIV();
    this._iv = managed.IV;
    ICryptoTransform transform = managed.CreateEncryptor(managed.Key, managed.IV);
    byte[] inArray = null;
    using (MemoryStream stream = new MemoryStream())
    {
        using (CryptoStream stream2 = new CryptoStream(stream, transform, CryptoStreamMode.Write))
        {
            byte[] bytes = Encoding.UTF8.GetBytes(Input);
            stream2.Write(bytes, 0, bytes.Length);
        }
        inArray = stream.ToArray();
    }
    return Convert.ToBase64String(inArray);
}
</code></pre>

<p>Below is qt5 code.
Omit details.</p>

<p>QT code</p>

<pre><code>    QString aeskey = ""7794b12op901252bfcea66d6f0521212"";
    QString _iv;
void Cipher::GenerateIV()
{
    AutoSeededRandomPool rnd;
    byte iv3[AES::BLOCKSIZE];
    rnd.GenerateBlock(iv3, AES::BLOCKSIZE);
    QByteArray out((char*)iv3, AES::BLOCKSIZE);
    _iv = out.toBase64();
}
QString Cipher::AESencrypt(QString Qstr_in)
{
    string str_in = Qstr_in.toStdString();
    string key = aeskey.toStdString();
    GenerateIV();
    string iv = _iv.toStdString();
    string str_out;
    CBC_Mode&lt;AES&gt;::Encryption encryption;
    encryption.SetKeyWithIV((byte*)key.c_str(), key.length(), (byte*)iv.c_str());
    StringSource encryptor(str_in, true,
                 new StreamTransformationFilter(encryption,
                 new Base64Encoder(
                 new StringSink(str_out)
//                ,StreamTransformationFilter::PKCS_PADDING
                ,StreamTransformationFilter::ZEROS_PADDING
           )
        )
    );

    return QString::fromStdString(str_out);
}
QString Cipher::AESdecrypt(QString Qstr_in)
{
    string str_in = Qstr_in.toStdString();
    string key = aeskey.toStdString();
    string iv = _iv.toStdString();
    string str_out;
    CBC_Mode&lt;AES&gt;::Decryption decryption;
    decryption.SetKeyWithIV((byte*)key.c_str(), key.length(), (byte*)iv.c_str());
    StringSource decryptor(str_in, true,
                 new Base64Decoder(
                 new StreamTransformationFilter(decryption,
                 new StringSink(str_out)
//                ,StreamTransformationFilter::PKCS_PADDING
                ,StreamTransformationFilter::DEFAULT_PADDING
            )
        )
    );
    return QString::fromStdString(str_out);
}
</code></pre>
","<p>A couple things jump out... In C# code, you do this:</p>

<pre><code>private readonly string key = ""7794b12op901252bfcea66d6f0521212"";
...
managed.Key = Encoding.UTF8.GetBytes(this.key);
</code></pre>

<p>In Crypto++ code, you do this:</p>

<pre><code>QString aeskey = ""7794b12op901252bfcea66d6f0521212"";
...
string key = aeskey.toStdString();
</code></pre>

<p>You need to <a href=""http://www.cryptopp.com/wiki/HexDecoder"" rel=""nofollow"">HexDecode</a> the string in Crypto++.</p>

<hr>

<p>Also, <code>GenerateIV</code> Base64 encodes on the Qt side of things:</p>

<pre><code>AutoSeededRandomPool rnd;
byte iv3[AES::BLOCKSIZE];
rnd.GenerateBlock(iv3, AES::BLOCKSIZE);
QByteArray out((char*)iv3, AES::BLOCKSIZE);
_iv = out.toBase64();
</code></pre>

<p>But C# uses a <code>byte[]</code> (presumably <em>not</em> Base64 encoded):</p>

<pre><code>private byte[] _iv;
</code></pre>
","107","<c#><qt><qt5><crypto++>","3","0","2","2015-06-01 20:53:43","","2","","1329652","","2015-06-01 20:53:43","2015-05-13 06:07:49",""
"40970048","Crypto++ DefaultEncryptor/DefaultDecryptor scheme","<p>I am trying to encrypt a file using AES with crypto++. I can see the functions EncryptFile and DecryptFile which use DefaultEncryptorWithMAC/DefaultDecryptorWithMAC from test.cpp in crypto++. </p>

<pre><code>void EncryptFile(const char *in, const char *out, const char *passPhrase)
{   
    FileSource f(in, true, new DefaultEncryptorWithMAC(passPhrase, new FileSink(out)));
}

void DecryptFile(const char *in, const char *out, const char *passPhrase)
{
   FileSource f(in, true, new DefaultDecryptorWithMAC(passPhrase, new FileSink(out)));
}
</code></pre>

<p>However I want to use AES and as far as I understand the default encryption scheme is DES_EDE2. Is there a build in way to handle this? </p>

<p>I don't need a MAC so something similar to the DefaultEncryptor/DefaultDecryptor class pair would be good enough.</p>

<p>Also I would prefere to use a random SecByteBlock instead of a passphrase as the following</p>

<pre><code>// Generate a random key
SecByteBlock key(0x00, AES::DEFAULT_KEYLENGTH);
rnd.GenerateBlock( key, key.size() );
</code></pre>
","<blockquote>
  <p>However I want to use AES and as far as I understand the default encryption scheme is DES_EDE2. Is there a build in way to handle this? </p>
</blockquote>

<p>The project changed the defaults. The commit of interest is <a href=""http://github.com/weidai11/cryptopp/commit/bfbcfeec7ca7a0487978391803496a1d4aada37c"" rel=""nofollow noreferrer"">Commit bfbcfeec7ca7</a>, and the issue of interest is <a href=""https://github.com/weidai11/cryptopp/issues/345"" rel=""nofollow noreferrer"">Issue 345</a>. It will be available in Crypto++ 5.7. 
For those who need the old algorithms, they can use <code>LegacyEncryptor</code>, <code>LegacyDecryptor</code>, <code>LegacyEncryptorWithMAC</code> and <code>LegacyDecryptorWithMAC</code>.</p>

<p>The <code>Mash</code> function was retained to keep things less complicated. If these were new classes, they would have used <code>HKDF</code> to extract and expand the entropy; and used PBKDF to grind over the derived key. Since both old and new needed support, we opted for the single source solution. As far as I know, the mash function meets the security goals.</p>

<p>If you are <em>not</em> using Master, then you can also change the following typedfs in <code>default.h</code> to suit your taste. However, you will need to recompile the library afterwards:</p>

<ul>
<li><code>typedef DES_EDE2 DefaultBlockCipher;</code></li>
<li><code>typedef SHA DefaultHashModule;</code></li>
<li><code>typedef HMAC&lt;DefaultHashModule&gt; DefaultMAC;</code></li>
</ul>
","107","<c++><crypto++>","1","0","1","2016-12-12 23:07:03","","1","","","","","2016-12-05 08:33:29",""
"49912836","Undefined reference to InvertibleRSAFunction and X509PublicKey using Crypto++?","<p>I'm trying to figure out how to generate and use an RSA key with Crypto++. To be precise, I am being asked to:</p>

<blockquote>
  <ol>
  <li><p>You will    implement   secure  communications  between two parties,    Alice   and 
  Bob.
  For   simplicity, the sending of  a   message from    the sender  to  the receiver    will    be  simulated<br>
  through   writing the message into    a   file    by  the sender  and reading the message
  from  the file    by   the    receiver.
  This  assignment  is  designed    to  practice    key distribution,   encryption/decryption,<br>
  and   integrity   protection
  with  secret  key cryptography    and public  key cryptography.</p></li>
  <li><p>Communication   scenario:   Alice (as   a   Client) needs   to  send    messages to Bob (as a   Server).    Alice    and    Bob each    have
  a pair    of   under  the RSA cryptosystem
  (their    key 
  pairs are different), and they    know    each    other’s public  key beforehand
  (the  public  keys    can be   hard   coded   into    the program
  or    read    from    a   file). Step 1:  Set
  up    a   shared  secret  key:    Alice   and Bob set up  a   shared  secret  key using   the following<br>
  method:   Alice   generates
  a random  key k,  encrypts    it  using   Bob’s   public  key with    the RSA 
  algorithm,    and sends   the ciphertext  to  Bob.    Bob receives    the ciphertext  and then    decrypts    it
  to     get    the key k.</p></li>
  </ol>
</blockquote>

<p>So, I've spent a few hours trying to set this up properly, and it seems like I've finally gotten Eclipse to accept the Crypto++ library itself, as it has compiled up to this point. Here is the complete code I have so far:</p>

<pre><code>#include &lt;iostream&gt;
#include ""cryptlib.h""
#include &lt;rsa.h&gt;
#include &lt;osrng.h&gt;
#include &lt;base64.h&gt;
#include &lt;files.h&gt;
using namespace CryptoPP;


int main()
{
    std::cout &lt;&lt; ""!!!Hello World!!!"" &lt;&lt; std::endl; // prints !!!Hello World!!!

     // InvertibleRSAFunction is used directly only because the private key
     // won't actually be used to perform any cryptographic operation;
     // otherwise, an appropriate typedef'ed type from rsa.h would have been used.
     AutoSeededRandomPool rng;
     InvertibleRSAFunction privkey;
     privkey.Initialize(rng, 1024);  &lt;--

     // With the current version of Crypto++, MessageEnd() needs to be called
     // explicitly because Base64Encoder doesn't flush its buffer on destruction.
     Base64Encoder privkeysink(new FileSink(""c:\\privkey.txt""));
     privkey.DEREncode(privkeysink);
     privkeysink.MessageEnd();

     // Suppose we want to store the public key separately,
     // possibly because we will be sending the public key to a third party.
     RSAFunction pubkey(privkey);

     Base64Encoder pubkeysink(new FileSink(""c:\\pubkey.txt""));
     pubkey.DEREncode(pubkeysink); &lt;--
     pubkeysink.MessageEnd();

    return 0;
}
</code></pre>

<p>Some of this I have pulled from here in an attempt to understand exactly how this library works:
<a href=""https://www.cryptopp.com/wiki/User_Guide:_rsa.h"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/User_Guide:_rsa.h</a></p>

<p>(We were given no sort of primer, and I find the site a little confusing)</p>

<p>The current issue I'm having at the moment is that the two lines I've marked with '&lt;--' do not compile. </p>

<p>Specifically:</p>

<pre><code>undefined reference to CryptoPP::InvertibleRSAFunction::Initialize(CryptoPP::RandomNumberGenerator&amp;, unsigned int, CryptoPP::Integer const&amp;)

undefined reference to CryptoPP::X509PublicKey::DEREncode(CryptoPP::BufferedTransformation&amp;) const
</code></pre>

<p>I would ask what I would need to do to make these two compile, but I'm not even sure this sample code even does what I want it to. How would I generate the keys I need for this?</p>
","","106","<c++><eclipse><crypto++>","0","","0","2018-04-20 01:27:38","","12","","608639","","2018-04-20 01:27:38","2018-04-19 04:38:31",""
"35464554","No error when using AuthenticatedEncryptionFilter","<p>I am using Crypto++ to Encrypt and Decrypt a File with the following code:</p>

<pre><code>try {

    EAX&lt;AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(derived.data(), 32, ivb, ivb.size());
    FileSource f(fileUrl.c_str(), false,
                 new AuthenticatedEncryptionFilter(encryptor, new FileSink(
                         std::string(fileUrl).c_str()),  CryptoPP::AuthenticatedDecryptionFilter::THROW_EXCEPTION |  CryptoPP::AuthenticatedDecryptionFilter::MAC_AT_END ));
    std::fstream file(fileUrl, std::ios::binary | std::ios::ate);
    size_t remaining = file.tellg();
    file.close();
    size_t BLOCK_SIZE = 16384;
    while (remaining &amp;&amp; !f.SourceExhausted()) {
        const unsigned int req = STDMIN(remaining, BLOCK_SIZE);
        f.Pump(req);
        f.Flush(false);
        remaining -= req;
    }

} catch (const CryptoPP::Exception&amp; e) {
    cout &lt;&lt; e.GetWhat();
    return 5;
}
</code></pre>

<p>Decryption:</p>

<pre><code>try {

    EAX&lt;AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(derived2.data(), 32, ivb2, ivb2.size());

    FileSource fe(fileUrl.c_str(), false,
                  new AuthenticatedDecryptionFilter(decryptor, new FileSink(
                          std::string(fileUrl).c_str()), CryptoPP::AuthenticatedDecryptionFilter::THROW_EXCEPTION |  CryptoPP::AuthenticatedDecryptionFilter::MAC_AT_END ));

    file.open(fileUrl, std::ios::binary | std::ios::ate);
    size_t remaining = file.tellg();
    remaining -= 3;
    file.close();

    size_t BLOCK_SIZE = 16384;
    while (remaining &amp;&amp; !fe.SourceExhausted()) {
        const unsigned int req = STDMIN(remaining, BLOCK_SIZE);
        fe.Pump(req);
        fe.Flush(false);

        remaining -= req;
    }
} catch (const CryptoPP::Exception&amp; e) {
    cout &lt;&lt; e.GetWhat();
    return 5;
}
</code></pre>

<p>My Problem is, that this Method is not throwing an Error when decrypting no matter what inputs are used. I can modify the encrypted file or use another password or whatever, I only get an incorrectly decrypted file, but no exception.</p>

<p>As far as I have read, the <code>AuthenticatedDecryptionFilter</code> should check for this stuff automatically and throw an exception.</p>

<p>Why is not throwing any exception?</p>
","<blockquote>
  <p>My Problem is, that this Method is not throwing an Error when decrypting no matter what inputs are used. I can modify the encrypted file or use another password or whatever, I only get an incorrectly decrypted file, but no exception...<br>
  <br>
  Why is not throwing any exception?</p>
</blockquote>

<p>The short of it is, <strong><em><code>FileSource file(url.c_str(), false, new AuthenticatedDecryptionFilter...)</code></em></strong> means the message is <strong><em>not</em></strong> <code>Put</code> because <strong><em><code>pumpAll=false</code></em></strong>. Because the message is not <code>Put</code>, <strong><em><code>LastPut</code></em></strong>, which triggers the MAC verification, is not called. You can trigger it with <strong><em><code>MessageEnd</code></em></strong>, but you are not at the end of the message, so that's always going to fail.</p>

<p>I understand what you are trying to do, and the fix is trickier.</p>

<hr>

<p>In the big picture, nearly everything is OK. You are using authenticated encryption and MAC'ing before you consume the data. But I'm wondering if the single or ""one shot"" MAC is the way to approach the problem.</p>

<p>To use the single MAC in this case, you probably want to disgorge decryption from verification. You still want to do them, but you want to do them as separate steps. Before decryption, you will verify the MAC over the entire message (read-only operation, fast). Once the MAC verifies, you then perform decryption (read-write operation, slow). Unfortunately, the library does not offer a separate <strong><em><code>EAX_Mac</code></em></strong> class that you can key, consume the message and then determine if the MAC is good.</p>

<p>Maybe the way to go is to apply a MAC at each block sized data unit, like 4096 or 16384. This is the use case or handling envisioned by folks like Bernstein in the <a href=""https://competitions.cr.yp.to/caesar.html"" rel=""nofollow noreferrer"">CAESAR Competition</a>. The competition is for the next generation of authenticated encryption schemes. Unfortunately, the library does not have a filter set to do it.</p>

<hr>

<p>Applying the MAC on block sized data units through a custom filter is possible, and its an interesting problem in security engineering because each security context must be unique. I think the way to approach it is...</p>

<p>Create a <code>BlockedAuthenticatedEncryptionFilter</code>. Instead of keying the encryptor object:</p>

<pre><code>EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(derived.data(), derived.size(), iv, iv.size());
</code></pre>

<p>key the <code>BlockedAuthenticatedEncryptionFilter</code> instead:</p>

<pre><code>FileSource f(... new BlockedAuthenticatedEncryptionFilter(
    encryptor,
    key.data(), key.size(),
    iv, iv.size(),
    new FileSink(...));
</code></pre>

<p>Now, <code>BlockedAuthenticatedEncryptionFilter</code> will accumulate source data. Whenever a full block is available, it performs the authenticated encryption on the block under the key and iv. That's an encryption under a security context (<strong><em><code>{message,key,iv}</code></em></strong>), so the security context must be changed for the next block or message. That's why the filter is keyed rather than the mode.</p>

<p>To change the security context <strong><em><code>{message,key,iv}</code></em></strong> for the next message, you might be able to do a simple <code>Increment</code> on both the key and iv. That will ensure the security context is unique for each message.</p>

<p>One thing you <strong><em>can't</em></strong> do is call <code>encryptor.GetNextIV()</code> to get the next <em>deterministic</em> iv derived from the cipher's state. That's because, by design, the library does not offer it. This comes up on occasion on the mailing list, but I can't find a sample message at the moment.</p>

<p>However, I'm not sure what troubles <code>next_key = Increment(key)</code> and <code>next_iv = Increment(iv)</code> could cause, so I would need to think about it and research it a bit. I would probably ask about it on the <a href=""https://security.stackexchange.com/"">Security Stack Exchange</a> or the <a href=""https://crypto.stackexchange.com/"">Cryptography Stack Exchange</a>, too.</p>
","106","<c++><encryption><crypto++>","2","2","1","2016-02-17 23:28:11","","1","","608639","","2016-02-17 23:26:10","2016-02-17 18:16:25",""
"29000681","Compiling Old Version of Crypto++, Problems with md5.h and Templates","<p>I am working on getting a piece of legacy software to build with gcc 4.7 on Debian stable (which currently also requires libstdc++5 3.2 for some reason), and currently g++ is hung up on crypto++'s md5.h</p>

<p>My c++ skills are rusty, and I've been staring at this for a couple days now. Does anyone have any ideas on how I can fix this?</p>

<p>The full source of the version of cryto++ I'm using: 
<a href=""http://www.filedropper.com/cryptolegacy"" rel=""nofollow"">http://www.filedropper.com/cryptolegacy</a></p>

<p><strong>the error:</strong></p>

<pre><code>compiling md5.cpp (g++)
compiling md5.cpp (g++)
In file included from md5.cpp:5:0:
md5.h:10:32: error: expected template-name before '&lt;' token
md5.h:10:32: error: expected '{' before '&lt;' token
md5.h:10:32: error: expected unqualified-id before '&lt;' token
md5.cpp:109:1: error: expected '}' at end of input
</code></pre>

<p><strong>md5.h</strong></p>

<pre><code>#ifndef CRYPTOPP_MD5_H
#define CRYPTOPP_MD5_H

#include ""iterhash.h""

NAMESPACE_BEGIN(CryptoPP)

/// &lt;a href=""http://www.weidai.com/scan-mirror/md.html#MD5""&gt;MD5&lt;/a&gt;
/** 128 Bit Hash */
class MD5 : public IteratedHash&lt;word32, false, 64&gt;
{
public:
     enum {DIGESTSIZE = 16};
     MD5() : IteratedHash&lt;word32, false, 64&gt;(DIGESTSIZE) {Init();}
     static void Transform(word32 *digest, const word32 *data);

protected:
    void Init();
    void vTransform(const word32 *data) {Transform(digest, data);}
};

NAMESPACE_END

#endif
</code></pre>
","","106","<c++><templates><inheritance><crypto++>","0","","0","2015-03-12 04:56:43","","11","0","608639","","2015-03-12 04:56:43","2015-03-12 01:59:13",""
"49958622","How do I properly include and link the Crypto++ library in Eclipse?","<p>I've looked at several sources for this, but none of them have solved my problem. I've done includes before in the Java version of Eclipse, but I'm having a lot of trouble with the C++ version.</p>

<p>Here's what I have available. I deleted all the entries I made up to this point. I want to properly include Crypto++ so I can use it.</p>

<p><a href=""https://i.stack.imgur.com/7WnaA.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7WnaA.png"" alt=""enter image description here""></a></p>

<p>I'm not sure what entries to make, or where. The Crypto++ 7.0.0 folder is currently on my desktop.</p>
","","103","<c++><eclipse><crypto++>","1","","0","2018-04-21 17:51:54","","4","","","","","2018-04-21 17:51:54",""
"32617932","How to exchange public keys?","<p>I have Client and Server, and want to have encrypt communication channel between them.
This is some simple code to generate public and private keys:</p>

<pre><code>    RSA::PrivateKey privateKey;
    privateKey.Initialize()

    ///////////////////////////////////////
    // Generate Parameters
    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(this-&gt;rng, 3072);

    ///////////////////////////////////////
    // Generated Parameters
    const Integer&amp; n = params.GetModulus();
    const Integer&amp; p = params.GetPrime1();
    const Integer&amp; q = params.GetPrime2();
    const Integer&amp; d = params.GetPrivateExponent();
    const Integer&amp; e = params.GetPublicExponent();

    params.

    ///////////////////////////////////////
    // Dump
    cout &lt;&lt; ""RSA Parameters:"" &lt;&lt; endl;
    cout &lt;&lt; "" n: "" &lt;&lt; n &lt;&lt; endl;
    cout &lt;&lt; "" p: "" &lt;&lt; p &lt;&lt; endl;
    cout &lt;&lt; "" q: "" &lt;&lt; q &lt;&lt; endl;
    cout &lt;&lt; "" d: "" &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; "" e: "" &lt;&lt; e &lt;&lt; endl;
    cout &lt;&lt; endl;

    ///////////////////////////////////////
    // Create Keys
    RSA::PrivateKey privateKey(params);
    RSA::PublicKey publicKey(params);
</code></pre>

<p>But how I can get client's public key on server side and server's public key on client side? may be exist more simple way than serialize public key in file, send file, receive file on the other side and deserialize it?</p>

<p>Class <code>Chat</code> have <code>DataTransferingInterface</code> instance, which point to <code>Server</code> or <code>Client</code> (it depends on whether the user has selected on the start). 
Some code for understanding:</p>

<p>Class Chat:</p>

<pre><code>class Chat : public OwnerServerInterface, public OwnerClientInterface
    public:
        //a lot of methods
    protected:
        virtual void handshakeServerSide(int clientSocket, void *objectForSaveIn, void *dataToSend);
        virtual void handshakeClientSide(int serverSocket, void *objectForSaveIn, void *dataToSend);
    private:
        DataTransferingInterface* interface;
</code></pre>

<p>In methods <code>handshakeServerSide()</code> and <code>handshakeClientSide()</code> Server's <code>Chat</code> instance and Client's <code>Chat</code> instance make the handshake (data exchanging). In this methods server must send it's own public key, and get the client's public key. But how to do it?</p>
","<p>Follow code is very simple class-wrapper for Crypto++ RSA algorithm:</p>

<p>EncoderRSA.h</p>

<pre><code>class EncoderRSA
{
    public:
        EncoderRSA();
        void keyGeneration();
        void substitutePublicKey(Integer e, Integer n);
        Integer encode(std::string plainText);
        std::string decode(Integer cypher);
        Integer getE();
        Integer getN();
    private:
        AutoSeededRandomPool prng;
        RSA::PublicKey publicKey;   // For encrypt plain text
        RSA::PrivateKey privateKey; // For decrypt plain text
};
</code></pre>

<p>EncoderRSA.cpp</p>

<pre><code>void EncoderRSA::keyGeneration() {
    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(this-&gt;prng, 3072);

    RSA::PrivateKey privateKey(params);
    RSA::PublicKey publicKey(params);

    //because you can't do:    this-&gt;privateKey(params);
    this-&gt;privateKey = privateKey;
    this-&gt;publicKey = publicKey;
}

void EncoderRSA::substitutePublicKey(Integer e, Integer n) {
    this-&gt;publicKey.Initialize(n, e);
}

Integer EncoderRSA::encode(std::string plainText) {
    Integer m((const byte*)plainText.data(), plainText.size());
    Integer c = this-&gt;publicKey.ApplyFunction(m);
    return c;
}

std::string EncoderRSA::decode(Integer cypher) {
    Integer r = this-&gt;privateKey.CalculateInverse(this-&gt;prng, cypher);

    std::string decoded;
    size_t req = r.MinEncodedSize();
    decoded.resize(req);

    r.Encode((byte*)decoded.data(), decoded.size());

    return decoded;
}

Integer EncoderRSA::getE() {
    return this-&gt;publicKey.GetPublicExponent();
}

Integer EncoderRSA::getN() {
    return this-&gt;publicKey.GetModulus();
}
</code></pre>

<p>Server must generate it's own keys (public and private), save it, save it's own public key (if exactly: PublicExponent and PublicModulus) separately (in <code>Integer</code> variables), get public key from Client, replace own public key by Client's public key.</p>

<p>The same about the Client.</p>
","103","<c++><rsa><crypto++>","-1","0","2","2015-09-17 21:06:22","","2","0","608639","","2015-09-17 21:06:22","2015-09-16 20:19:15",""
"32617932","How to exchange public keys?","<p>I have Client and Server, and want to have encrypt communication channel between them.
This is some simple code to generate public and private keys:</p>

<pre><code>    RSA::PrivateKey privateKey;
    privateKey.Initialize()

    ///////////////////////////////////////
    // Generate Parameters
    InvertibleRSAFunction params;
    params.GenerateRandomWithKeySize(this-&gt;rng, 3072);

    ///////////////////////////////////////
    // Generated Parameters
    const Integer&amp; n = params.GetModulus();
    const Integer&amp; p = params.GetPrime1();
    const Integer&amp; q = params.GetPrime2();
    const Integer&amp; d = params.GetPrivateExponent();
    const Integer&amp; e = params.GetPublicExponent();

    params.

    ///////////////////////////////////////
    // Dump
    cout &lt;&lt; ""RSA Parameters:"" &lt;&lt; endl;
    cout &lt;&lt; "" n: "" &lt;&lt; n &lt;&lt; endl;
    cout &lt;&lt; "" p: "" &lt;&lt; p &lt;&lt; endl;
    cout &lt;&lt; "" q: "" &lt;&lt; q &lt;&lt; endl;
    cout &lt;&lt; "" d: "" &lt;&lt; d &lt;&lt; endl;
    cout &lt;&lt; "" e: "" &lt;&lt; e &lt;&lt; endl;
    cout &lt;&lt; endl;

    ///////////////////////////////////////
    // Create Keys
    RSA::PrivateKey privateKey(params);
    RSA::PublicKey publicKey(params);
</code></pre>

<p>But how I can get client's public key on server side and server's public key on client side? may be exist more simple way than serialize public key in file, send file, receive file on the other side and deserialize it?</p>

<p>Class <code>Chat</code> have <code>DataTransferingInterface</code> instance, which point to <code>Server</code> or <code>Client</code> (it depends on whether the user has selected on the start). 
Some code for understanding:</p>

<p>Class Chat:</p>

<pre><code>class Chat : public OwnerServerInterface, public OwnerClientInterface
    public:
        //a lot of methods
    protected:
        virtual void handshakeServerSide(int clientSocket, void *objectForSaveIn, void *dataToSend);
        virtual void handshakeClientSide(int serverSocket, void *objectForSaveIn, void *dataToSend);
    private:
        DataTransferingInterface* interface;
</code></pre>

<p>In methods <code>handshakeServerSide()</code> and <code>handshakeClientSide()</code> Server's <code>Chat</code> instance and Client's <code>Chat</code> instance make the handshake (data exchanging). In this methods server must send it's own public key, and get the client's public key. But how to do it?</p>
","<blockquote>
  <p>... how I can get client's public key on server side and server's public key on client side?</p>
</blockquote>

<p>That is known as the <a href=""https://www.google.com/search?q=key+distribution+problem"" rel=""nofollow noreferrer"">key distribution problem</a>. It may (or may not be) manageable on a small scale, but its a very thorny problem when you scale it up.</p>

<p>The answer(s) depend on your particular instance problem, and that looks like a N-way chat program. There's really too much to the problem to answer on a programming site like Stack Overflow.</p>

<p>Maybe you should read up on the problem, including Multi-party or Group Diffie-Hellman schemes. Also think about what you want to happen when a member leaves a group. Then ask targeted questions on the <a href=""https://security.stackexchange.com/"">Information Security Stack Exchange</a>.</p>
","103","<c++><rsa><crypto++>","-1","1","2","2015-09-17 21:06:22","","2","0","608639","","2015-09-17 21:06:22","2015-09-16 20:19:15",""
"54791882","Crypto++ extra block at the end of encrypted stream in AES-128 CBC mode","<p>I'm trying to encrypt 320 bytes of binary data using AES-128 in CBC mode and store the cipher into a file. The output file should have been of 320 bytes, but I got 336 bytes. Here is my code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;crypto++/aes.h&gt;
#include &lt;crypto++/modes.h&gt;
#include &lt;crypto++/base64.h&gt;
#include &lt;crypto++/sha.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;crypto++/filters.h&gt;
#include &lt;crypto++/files.h&gt;

namespace CryptoPP
{
    using byte = unsigned char;
}

void myAESTest()
{
    std::string password = ""testPassWord"";

    // hash the password string
    // -------------------------------
    CryptoPP::byte key[CryptoPP::AES::DEFAULT_KEYLENGTH], iv[CryptoPP::AES::BLOCKSIZE];
    CryptoPP::byte passHash[CryptoPP::SHA256::DIGESTSIZE];
    CryptoPP::SHA256().CalculateDigest(passHash, (CryptoPP::byte*) password.data(), password.size());
    std::memcpy(key, passHash, CryptoPP::AES::DEFAULT_KEYLENGTH);
    std::memcpy(iv, passHash+CryptoPP::AES::DEFAULT_KEYLENGTH, CryptoPP::AES::BLOCKSIZE);

    // encrypt
    // ---------------------------------
    int chunkSize = 20*CryptoPP::AES::BLOCKSIZE;

    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(key, sizeof(key), iv);

    std::ofstream testOut(""./test.enc"", std::ios::binary);
    CryptoPP::FileSink outSink(testOut);

    CryptoPP::byte message[chunkSize];

    CryptoPP::StreamTransformationFilter stfenc(encryptor, new CryptoPP::Redirector(outSink));

    for(int i = 0; i &lt; chunkSize; i ++)
    {
        message[i] = (CryptoPP::byte)i;
    }

    stfenc.Put(message, chunkSize);
    stfenc.MessageEnd();
    testOut.close();

    // decrypt
    // ------------------------------------
    // Because of some unknown reason increase chuksize by 1 block
    // chunkSize+=16;

    CryptoPP::byte cipher[chunkSize], decrypted[chunkSize];

    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryptor;
    decryptor.SetKeyWithIV(key, sizeof(key), iv);

    std::ifstream inFile(""./test.enc"", std::ios::binary);
    inFile.read((char *)cipher, chunkSize);

    CryptoPP::ArraySink decSink(decrypted, chunkSize);
    CryptoPP::StreamTransformationFilter stfdec(decryptor, new CryptoPP::Redirector(decSink));

    stfdec.Put(cipher, chunkSize);
    stfdec.MessageEnd();
    inFile.close();

    for(int i = 0; i &lt; chunkSize; i++)
    {
        std::cout &lt;&lt; (int)decrypted[i] &lt;&lt; ' ';
    }
    std::cout &lt;&lt; std::endl;
}

int main(int argc, char* argv[]) 
{
    myAESTest();
    return 0;
}
</code></pre>

<p>I'm not able to understand how the last 16 bytes are generated.  If I choose to ignore the last 16 bytes in the decryption, CryptoPP throws <code>CryptoPP::InvalidCiphertext</code> error:</p>

<pre><code>terminate called after throwing an instance of 'CryptoPP::InvalidCiphertext'
  what():  StreamTransformationFilter: invalid PKCS #7 block padding found
</code></pre>
","<blockquote>
  <p>I'm not able to understand how the last 16 bytes are generated. If I choose to ignore the last 16 bytes in the decryption, Crypto++ throws <code>InvalidCiphertext</code> error</p>
</blockquote>

<p>The last 16 bytes are padding. Padding is added by the <code>StreamTransformationFilter</code> filter; see <a href=""https://cryptopp.com/docs/ref/class_stream_transformation_filter.html"" rel=""nofollow noreferrer"">StreamTransformationFilter Class Reference</a> in the manual. Though not obvious, <code>DEFAULT_PADDING</code> is <code>PKCS_PADDING</code> for <code>ECB_Mode</code> and <code>CBC_Mode</code>. It is <code>NO_PADDING</code> for other modes like <code>OFB_Mode</code> and <code>CTR_Mode</code>.</p>

<p>You only need to specify <code>NO_PADDING</code> for both the encryption and decryption filters. However, you have to ensure the plaintext and ciphertext are a multiple of the blocksize, which is 16 for AES. </p>

<p>You can sidestep the blocksize restriction by switching to another mode like <code>CTR_Mode</code>. But then you have to be very careful of key or IV reuse, which may be difficult due to the password derivation scheme you are using.</p>

<p>So instead of:</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption encryptor;
...
StreamTransformationFilter stfenc(encryptor, new Redirector(outSink));
</code></pre>

<p>Use:</p>

<pre><code>CBC_Mode&lt;AES&gt;::Encryption encryptor;
...
StreamTransformationFilter stfenc(encryptor, new Redirector(outSink), NO_PADDING);
</code></pre>

<p>Also see <a href=""https://www.cryptopp.com/wiki/CBC_Mode"" rel=""nofollow noreferrer"">CBC_Mode</a> on the Crypto++ wiki. You might also be interested in <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> on the wiki.</p>

<hr>

<p>For this, you can also:</p>

<pre><code>#ifndef CRYPTOPP_NO_GLOBAL_BYTE
namespace CryptoPP
{
    using byte = unsigned char;
}
#endif
</code></pre>

<p><code>CRYPTOPP_NO_GLOBAL_BYTE</code> is defined after the <a href=""https://www.cryptopp.com/wiki/Std::byte"" rel=""nofollow noreferrer"">C++17 <code>std::byte</code> fixes</a>. If <code>CRYPTOPP_NO_GLOBAL_BYTE</code> is not defined, then <code>byte</code> is in the global namespace (Crypto++ 5.6.5 and earlier). If <code>CRYPTOPP_NO_GLOBAL_BYTE</code> is defined, then <code>byte</code> is in the <code>CryptoPP</code> namespace (Crypto++ 6.0 and later).</p>

<hr>

<p>For this:</p>

<pre><code>std::ofstream testOut(""./test.enc"", std::ios::binary);
FileSink outSink(testOut);
</code></pre>

<p>You can also do:</p>

<pre><code>FileSink outSink(""./test.enc"");
</code></pre>

<hr>

<p>For this:</p>

<pre><code>SHA256().CalculateDigest(passHash, (byte*) password.data(), password.size());
std::memcpy(key, passHash, AES::DEFAULT_KEYLENGTH);
std::memcpy(iv, passHash+AES::DEFAULT_KEYLENGTH, AES::BLOCKSIZE);
</code></pre>

<p>You might consider using <code>HKDF</code> as a derivation function. Use the one password but two different labels to ensure independent derivation. One label might be the string <code>""AES key derivation version 1""</code> and the other label might be <code>""AES iv derivation version 1""</code>.</p>

<p>The label would be used as the <code>info</code> parameter for <code>DeriveKey</code>. You just need to call it twice, once for the key and once for the iv.</p>

<pre><code>unsigned int DeriveKey (byte *derived, size_t derivedLen,
    const byte *secret, size_t secretLen,
    const byte *salt, size_t saltLen,
    const byte *info, size_t infoLen) const
</code></pre>

<p><code>secret</code> is the password. If you have <code>salt</code> then use it. Otherwise HKDF uses a default salt.</p>

<p>Also see <a href=""https://www.cryptopp.com/wiki/HKDF"" rel=""nofollow noreferrer"">HKDF</a> on the Crypto++ wiki.</p>

<hr>

<p>Finally, regarding this:</p>

<blockquote>
  <p>You can sidestep the blocksize restriction by switching to another mode like CTR_Mode. But then you have to be very careful of key or IV reuse, which may be difficult due to the password derivation scheme you are using.</p>
</blockquote>

<p>You might also consider an Integrated Encryption Scheme, like <a href=""https://cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">Elliptic Curve Integrated Encryption Scheme</a>. It is <a href=""https://en.wikipedia.org/wiki/Ciphertext_indistinguishability#IND-CCA2"" rel=""nofollow noreferrer"">IND-CCA2</a>, which is a strong notion of security. Everything you need is packaged into the encryption scheme.</p>

<p>Under ECIES each user gets a public/private keypair. Then, a large random secret is used as a seed for the AES key, iv and mac key. The the plaintext is encrypted and authenticated. Finally, the seed is encrypted under the user's public key. The password is still used, but it is used to decrypt the private key.</p>
","102","<c++><crypto++>","2","1","1","2019-02-25 07:55:56","54793368","0","","2509078","","2019-02-25 07:55:56","2019-02-20 17:11:50",""
"21948353","How to convert a binary byte into a printable numeric value?","<p>I have to convert the CRYPTO++ AES ciphertext of 128 bits into a pribtable numerical string.</p>

<p>I am currently using the following code to do the casting, but <code>bitset</code> is too slow for my case. Does anyone know any efficient way of doing this?</p>

<pre><code>string output = """";
for (std::size_t i = 0; i &lt; 16; ++ i) {
    output += bitset&lt;8&gt;(ciphertext[i]).to_string();
} 
</code></pre>

<p>How to convert a binary byte into a printable numeric value? Thanks a lot!</p>
","<p>I would do</p>

<pre><code>char ct_b[16];
char ct_h[33]; // 2 hex digits per byte + NUL
snprintf(ct_h, 33,
         ""%02x%02x%02x%02x%02x%02x%02x%02x""
         ""%02x%02x%02x%02x%02x%02x%02x%02x"",
         ct_h[ 0], ct_h[ 1], ct_h[ 2], ct_h[ 3],
         ct_h[ 4], ct_h[ 5], ct_h[ 6], ct_h[ 7],
         ct_h[ 8], ct_h[ 9], ct_h[10], ct_h[11],
         ct_h[12], ct_h[13], ct_h[14], ct_h[15]);
</code></pre>

<p>This will certainly be faster than what you have, at the expense of a good bit more repetition.  It does produce hexadecimal rather than binary, but it's very likely that hex is what you really want.</p>

<p>(In case you haven't seen string constant concatenation before: The absence of a comma after the first half of the string constant is intentional.)</p>

<p>(Please tell me you aren't using <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">ECB</a>.)</p>
","99","<c++><bitset><crypto++>","1","0","3","2014-02-23 04:13:05","","2","","608639","","2014-02-23 00:23:01","2014-02-22 01:21:31",""
"21948353","How to convert a binary byte into a printable numeric value?","<p>I have to convert the CRYPTO++ AES ciphertext of 128 bits into a pribtable numerical string.</p>

<p>I am currently using the following code to do the casting, but <code>bitset</code> is too slow for my case. Does anyone know any efficient way of doing this?</p>

<pre><code>string output = """";
for (std::size_t i = 0; i &lt; 16; ++ i) {
    output += bitset&lt;8&gt;(ciphertext[i]).to_string();
} 
</code></pre>

<p>How to convert a binary byte into a printable numeric value? Thanks a lot!</p>
","<p>There are plenty of clever methods to compute a binary string from a number, but it doesn't really matter; Whatever method you use, you can use that method to fill up a table once:</p>

<pre><code>std::string bytes[256];

for (unsigned char c = 0; c&lt;=255; ++c) {
  bytes[c] = bitset&lt;8&gt;(c).to_string();
}
</code></pre>

<p>And then <code>bytes[c]</code> will give you the string for a particular byte.</p>

<hr>

<p>In your post you show four lines of code. Below is what those four lines of code would change to using the above precomputed strings:</p>

<pre><code>string output = """";
for (std::size_t i = 0; i &lt; 16; ++ i) {
    output += bytes[ciphertext[i]];
} 
</code></pre>

<hr>

<p>Also, your code likely involves some allocations during your loop. The best way to avoid those depends entirely on how you use the <code>output</code> string, but at the minimum <code>output.reserve(16*8)</code> can't hurt.</p>
","99","<c++><bitset><crypto++>","1","2","3","2014-02-23 04:13:05","","2","","608639","","2014-02-23 00:23:01","2014-02-22 01:21:31",""
"21948353","How to convert a binary byte into a printable numeric value?","<p>I have to convert the CRYPTO++ AES ciphertext of 128 bits into a pribtable numerical string.</p>

<p>I am currently using the following code to do the casting, but <code>bitset</code> is too slow for my case. Does anyone know any efficient way of doing this?</p>

<pre><code>string output = """";
for (std::size_t i = 0; i &lt; 16; ++ i) {
    output += bitset&lt;8&gt;(ciphertext[i]).to_string();
} 
</code></pre>

<p>How to convert a binary byte into a printable numeric value? Thanks a lot!</p>
","<pre><code>string output = """";
for (std::size_t i = 0; i &lt; 16; ++ i) {
    output += bitset&lt;8&gt;(ciphertext[i]).to_string();
} 
</code></pre>

<p>There's also the Crypto++ source/sink method if you are itnerested:</p>

<pre><code>string output;
ArraySource as(ciphertext, sizeof(ciphertext),
    true /*pump*/,
    new HexEncoder(
        new StringSink(output)
    ) // HexEncoder
); // ArraySource
</code></pre>
","99","<c++><bitset><crypto++>","1","0","3","2014-02-23 04:13:05","","2","","608639","","2014-02-23 00:23:01","2014-02-22 01:21:31",""
"55153308","In-memory unsigned char encryption","<p>I'm trying to create a byte array encryption/decryption for in memory files with <strong>AES256</strong> using <strong>Crypto++</strong>.</p>

<p>I need to encrypt an <strong>unsigned char byte array</strong> and get <strong>encrypted data as unsigned char byte array too!</strong> Same for <strong>Decryption.</strong> </p>

<p>I tried a lot of solutions I found on net but I can't make it work. The output files and lengths are wrong.</p>

<p>How can I make it work?</p>

<hr>

<p><strong>block_aes.h:</strong></p>

<pre><code>const unsigned char original_Data[42] = {
    0x54, 0x48, 0x49, 0x53, 0x20, 0x49, 0x53, 0x20, 0x54, 0x45, 0x53, 0x54,
    0x20, 0x44, 0x41, 0x54, 0x41, 0x20, 0x49, 0x54, 0x20, 0x43, 0x41, 0x4E,
    0x20, 0x42, 0x45, 0x20, 0x41, 0x4E, 0x59, 0x20, 0x46, 0x49, 0x4C, 0x45,
    0x20, 0x44, 0x41, 0x54, 0x41, 0x2E
};

const unsigned char iv[16] = {
    0xAE, 0x50, 0x95, 0xEB, 0xC5, 0x76, 0x20, 0x1A, 0xA4, 0x84, 0xB6, 0xB0,
    0x51, 0x03, 0xEE, 0xE8
};

const unsigned char key[32] = {
    0xDA, 0x1F, 0x84, 0x85, 0xBD, 0x62, 0x2D, 0xB1, 0x45, 0x13, 0x84, 0x20,
    0xCF, 0x02, 0x47, 0xB9, 0x85, 0xEC, 0x78, 0xD7, 0x85, 0xEF, 0x07, 0xD7,
    0xA8, 0x15, 0x11, 0x6E, 0x11, 0xDF, 0xEE, 0x39
};
</code></pre>

<p><strong>block_aes.cpp:</strong></p>

<pre><code>int _tmain(int argc, _TCHAR* argv[])
{
    /// Encrypt
    vector&lt;CryptoPP::byte&gt; cipher;

    CBC_Mode&lt;AES&gt;::Encryption enc;
    enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    cipher.resize(sizeof(original_Data)+AES::BLOCKSIZE);
    ArraySink cs(&amp;cipher[0], cipher.size());

    ArraySource(original_Data,sizeof(original_Data), true,
        new StreamTransformationFilter(enc, new Redirector(cs)));
    cipher.resize(cs.TotalPutLength());

    /// Test
    DWORD tmp;
    HANDLE File_Out = CreateFileA(
        ""Encrypted.File"",
        GENERIC_ALL,
        FILE_SHARE_WRITE,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        &amp;tmp
    );

    WriteFile(File_Out, &amp;cipher, sizeof(cipher), &amp;tmp, NULL);

    /// Decrypt
    vector&lt;CryptoPP::byte&gt; recover;
    CBC_Mode&lt;AES&gt;::Decryption dec;
    dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    recover.resize(cipher.size());
    ArraySink rs(&amp;recover[0], recover.size());

    ArraySource(cipher.data(), cipher.size(), true,
        new StreamTransformationFilter(dec, new Redirector(rs)));

    recover.resize(rs.TotalPutLength());

    /// Test    
    HANDLE File_Out2 = CreateFileA(
        ""Decrypted.File"",
        GENERIC_ALL,
        FILE_SHARE_WRITE,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        &amp;tmp
    );

    WriteFile(File_Out2, &amp;recover, sizeof(recover), &amp;tmp, NULL);
}
</code></pre>
","<p>In your <code>WriteFile</code> call, you write out the contents of the <code>cipher</code> <em>variable</em>, not the contents stored in the vector.  To save the vector you need</p>

<pre><code>WriteFile(File_Out, cipher.data(), cipher.size(), &amp;tmp, NULL);
</code></pre>

<p>And:</p>

<pre><code>WriteFile(File_Out2, recover.data(), recover.size(), &amp;tmp, NULL);
</code></pre>

<p>Since you used the <code>address-of</code> operator, here another way to write it:</p>

<pre><code>WriteFile(File_Out, &amp;cipher[0], cipher.size(), &amp;tmp, NULL);
</code></pre>

<p><code>&amp;cipher[0]</code> is the only way to get a non-const pointer (writable) in C++03 and C++11. (But you don't need it here since the const pointer (readable) works fine).</p>
","98","<c++><windows><encryption><crypto++>","0","1","1","2019-03-16 20:00:52","55154277","1","","107625","","2019-03-16 20:00:52","2019-03-14 00:49:45",""
"40732480","Crypto++ Init-Update-Final get cipher output","<p>In a effort to encrypt large file using Crypto++, I am following ecrypting using Java-like Init-Update-Final <a href=""https://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow noreferrer"">in Crypto++</a>,</p>

<p>The demo code seem to work, everytime the Put is invoked, the output byte is printed to screen:</p>

<pre><code>encoder.Put(buffer, ready);
</code></pre>

<p>But I can't find anyway to get the output of all cipher text. For example </p>

<pre><code>'H' -&gt; print 01 to screen 
'E' -&gt; print A9 to screen 
'L' -&gt; print 5J to screen 
'L' -&gt; print 13 to screen 
'O' -&gt; print 3d to screen ...
</code></pre>

<p>But I can't retrieve the full result to a byte array
01A95J133d...</p>

<p>A question <a href=""https://stackoverflow.com/questions/37777373/encrypt-file-using-file-buffer-loop"">in here</a> related to using Init-Update-Final to encrypt large files but seem like not provided a working solution yet.</p>

<p>This is the full demo code:</p>

<pre><code>enum { ENCRYPT_MODE = 1, DECRYPT_MODE = 2 };
struct JavaAlgorithmParameter
{
    JavaAlgorithmParameter()
        : key(NULL), ksize(0), iv(NULL), vsize(0) {}

    const byte* key;
    size_t ksize;
    const byte* iv;
    size_t vsize;
};

/////////////////////////
/////////////////////////

class JavaCipher
{
public:
    static JavaCipher* getInstance(const std::string&amp; transformation);

    void init(int opmode, const JavaAlgorithmParameter&amp; params);
    size_t update(const byte* in, size_t isize, byte* out, size_t osize);
    size_t final(byte* out, size_t osize);

    std::string getAlgorithm() const;

protected:
    JavaCipher(const std::string&amp; transformation);

private:
    std::string m_transformation;
    member_ptr&lt;SymmetricCipher&gt; m_cipher;
    member_ptr&lt;StreamTransformationFilter&gt; m_filter;
};

/////////////////////////
/////////////////////////

JavaCipher* JavaCipher::getInstance(const std::string&amp; transformation)
{
    return new JavaCipher(transformation);
}

JavaCipher::JavaCipher(const std::string&amp; transformation)
    : m_transformation(transformation) { }

std::string JavaCipher::getAlgorithm() const
{
    return m_transformation;
}

/////////////////////////
/////////////////////////

size_t JavaCipher::final(byte* out, size_t osize)
{
    m_filter.get()-&gt;MessageEnd();

    if (!out || !osize || !m_filter.get()-&gt;AnyRetrievable())
        return 0;

    size_t t = CryptoPP::STDMIN(m_filter.get()-&gt;MaxRetrievable(), (word64)osize);
    t = m_filter.get()-&gt;Get(out, t);
    return t;
}

/////////////////////////
/////////////////////////

size_t JavaCipher::update(const byte* in, size_t isize, byte* out, size_t osize)
{
    if (in &amp;&amp; isize)
        m_filter.get()-&gt;Put(in, isize);

    if (!out || !osize || !m_filter.get()-&gt;AnyRetrievable())
        return 0;

    size_t t = STDMIN(m_filter.get()-&gt;MaxRetrievable(), (word64)osize);
    t = m_filter.get()-&gt;Get(out, t);
    return t;
}

/////////////////////////
/////////////////////////

void JavaCipher::init(int opmode, const JavaAlgorithmParameter&amp; params)
{
    if (m_transformation == ""AES/ECB/PKCSPadding"" &amp;&amp; opmode == ENCRYPT_MODE)
    {
        m_cipher.reset(new ECB_Mode&lt;AES&gt;::Encryption);
        m_cipher.get()-&gt;SetKey(params.key, params.ksize);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::PKCS_PADDING));
    }
    else if (m_transformation == ""AES/ECB/PKCSPadding"" &amp;&amp; opmode == DECRYPT_MODE)
    {
        m_cipher.reset(new ECB_Mode&lt;AES&gt;::Decryption);
        m_cipher.get()-&gt;SetKey(params.key, params.ksize);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::PKCS_PADDING));
    }
    else if (m_transformation == ""AES/CBC/PKCSPadding"" &amp;&amp; opmode == ENCRYPT_MODE)
    {
        m_cipher.reset(new CBC_Mode&lt;AES&gt;::Encryption);
        m_cipher.get()-&gt;SetKeyWithIV(params.key, params.ksize, params.iv);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::PKCS_PADDING));
    }
    else if (m_transformation == ""AES/CBC/PKCSPadding"" &amp;&amp; opmode == DECRYPT_MODE)
    {
        m_cipher.reset(new CBC_Mode&lt;AES&gt;::Decryption);
        m_cipher.get()-&gt;SetKeyWithIV(params.key, params.ksize, params.iv);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::PKCS_PADDING));
    }
    else if (m_transformation == ""AES/CTR/NoPadding"" &amp;&amp; opmode == ENCRYPT_MODE)
    {
        m_cipher.reset(new CTR_Mode&lt;AES&gt;::Encryption);
        m_cipher.get()-&gt;SetKeyWithIV(params.key, params.ksize, params.iv);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::NO_PADDING));
    }
    else if (m_transformation == ""AES/CTR/NoPadding"" &amp;&amp; opmode == DECRYPT_MODE)
    {
        m_cipher.reset(new CTR_Mode&lt;AES&gt;::Decryption);
        m_cipher.get()-&gt;SetKeyWithIV(params.key, params.ksize, params.iv);
        m_filter.reset(new StreamTransformationFilter(*m_cipher.get(), NULL, BlockPaddingSchemeDef::NO_PADDING));
    }
    else
        throw NotImplemented(m_transformation + "" is not implemented"");
}

/////////////////////////
/////////////////////////

int main(int argc, char* argv[])
{
    try
    {
        byte key[32], iv[16];
        OS_GenerateRandomBlock(false, key, COUNTOF(key));
        OS_GenerateRandomBlock(false, iv, COUNTOF(iv));

        HexEncoder encoder(new FileSink(cout));

        JavaAlgorithmParameter params;
        params.key = key;
        params.ksize = COUNTOF(key);
        params.iv = iv;
        params.vsize = COUNTOF(iv);

        //JavaCipher* cipher = JavaCipher::getInstance(""AES/CTR/NoPadding"");
        JavaCipher* cipher = JavaCipher::getInstance(""AES/CBC/PKCSPadding"");
        cipher-&gt;init(ENCRYPT_MODE, params);

        cout &lt;&lt; ""Algorithm: "" &lt;&lt; cipher-&gt;getAlgorithm() &lt;&lt; endl;

        cout &lt;&lt; ""Key: "";
        encoder.Put(key, COUNTOF(key));
        cout &lt;&lt; endl;

        cout &lt;&lt; ""IV: "";
        encoder.Put(iv, COUNTOF(iv));
        cout &lt;&lt; endl;

        char * allText = FileUtil::readAllByte(""1MB.txt"");
        long len = strlen(allText);

        byte buffer[64];

        size_t ready = 0;

        for (unsigned int i = 0; i &lt;= len; i++)
        {
            byte b = allText[i];

            //cout &lt;&lt; ""Put 0x"";
            encoder.Put(b);
            cout &lt;&lt; endl;

            ready = cipher-&gt;update(&amp;b, 1, buffer, COUNTOF(buffer));

            if (ready)
            {
                //cout &lt;&lt; ""Get: "";
                encoder.Put(buffer, ready);
                cout &lt;&lt; endl;
            }
        }

        ready = cipher-&gt;final(NULL, 0);
        if (ready)
        {
            //cout &lt;&lt; ""Final: "";
            encoder.Put(buffer, ready);
            cout &lt;&lt; endl;
        }

        ready = cipher-&gt;final(buffer, COUNTOF(buffer));
        if (ready)
        {
            //cout &lt;&lt; ""Final: "";
            encoder.Put(buffer, ready);
            cout &lt;&lt; endl;
        }

        delete cipher;
        getchar();
    }
    catch (const Exception&amp; ex)
    {
        cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
","<blockquote>
  <p>But I can't find anyway to get the output of all cipher text. For
  example</p>

<pre><code>'H' -&gt; print 01 to screen 
'E' -&gt; print A9 to screen 
'L' -&gt; print 5J to screen 
'L' -&gt; print 13 to screen 
'O' -&gt; print 3d to screen ...
</code></pre>
  
  <p>But I can't retrieve the full result to a byte array 01A95J133d...</p>
</blockquote>

<p>Call <code>cipher::update</code> with no output buffer:</p>

<pre><code>cipher-&gt;update(&amp;b, 1, NULL, 0);
</code></pre>

<p>Then, retrieve the buffer after you call <code>cipher::final</code>:</p>

<pre><code>size_t size = &lt;some appropriately size for the cipher text&gt;;
byte result[size];
cipher-&gt;final(result, size);
</code></pre>

<p>If you are having trouble with <code>&lt;some appropriately size for the cipher text&gt;</code>, then add a new method to the class:</p>

<pre><code>size_t ready() const
{
    return m_filter.get()-&gt;MaxRetrievable();
}
</code></pre>
","97","<crypto++>","0","1","1","2016-11-23 02:48:24","40755191","6","","-1","","2017-05-23 10:33:01","2016-11-22 01:42:57",""
"57023713","fatal error: blake2.h: No such file or directory","<p>I am using RaspberryPi and Crypto++6 is the only available version through apt, I can't include the hash function library blake2, and /usr/include/cryptopp/blake2.h doesnt exist, I tried also to install it manually through github, below how I installed it manually, but still doesn't work and blake.h does not exist in include folder too, what can I do ? thank you in advance !</p>

<p>I was using <code>&lt;crypto++/libname.h&gt;</code> because I am using a Debian based distribution (stretch), but when I tried <code>&lt;cryptopp/blake.h&gt;</code> it works and this is after I installed the library manually, now I got another errors, what should I use crypto++ or cryptopp <br/> </p>

<pre><code>/tmp/ccTmS4UQ.o: In function `main':
test.cpp:(.text+0x24): undefined reference to `CryptoPP::BLAKE2b::BLAKE2b(bool, unsigned int)'
/tmp/ccTmS4UQ.o: In function `CryptoPP::BLAKE2b::~BLAKE2b()':
test.cpp:(.text._ZN8CryptoPP7BLAKE2bD2Ev[_ZN8CryptoPP7BLAKE2bD5Ev]+0x74): undefined reference to `vtable for CryptoPP::BLAKE2b'
test.cpp:(.text._ZN8CryptoPP7BLAKE2bD2Ev[_ZN8CryptoPP7BLAKE2bD5Ev]+0x78): undefined reference to `vtable for CryptoPP::BLAKE2b'
collect2: error: ld returned 1 exit status
</code></pre>

<p>And:</p>

<pre><code>uname -a
Linux raspberrypi 4.19.42-v7+ #1219 SMP Tue May 14 21:20:58 BST 2019 armv7l GNU/Linux

ldconfig -p | grep crypto++
libcrypto++.so.6 (libc6,hard-float) =&gt; /usr/lib/arm-linux-gnueabihf/libcrypto++.so.6
libcrypto++.so (libc6,hard-float) =&gt; /usr/lib/arm-linux-gnueabihf/libcrypto++.so
</code></pre>

<p>And a program:</p>

<pre><code>#include &lt;crypto++/cryptlib.h&gt;
#include &lt;crypto++/blake2.h&gt;

#include &lt;iostream&gt;

int main (int argc, char* argv[])
{
    using namespace CryptoPP;
    BLAKE2b hash;   
    std::cout &lt;&lt; ""Name: "" &lt;&lt; hash.AlgorithmName() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Digest size: "" &lt;&lt; hash.DigestSize() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Block size: "" &lt;&lt; hash.BlockSize() &lt;&lt; std::endl;

    return 0; 
}
</code></pre>
","<p>I have uninstalled the package, and reinstall it manually via github
 <code>sudo git clone https://github.com/weidai11/cryptopp</code>
 <code>cd cryptopp</code>
 <code>sudo make</code>
 <code>sudo make install</code></p>

<p>I get rid of blake2.h missing error, but I got many undefined reference errors e.g <code>(/tmp/cc9AY7g8.o:(.rodata._ZTIN8CryptoPP25MessageAuthenticationCodeE[_ZTIN8CryptoPP25MessageAuthenticationCodeE]+0x18): undefined reference to typeinfo for CryptoPP::HashTransformation)</code></p>

<p>I was complining the example with a shell script as follow :</p>

<pre><code>g++ -lrt -lpthread -lstdc++ -lcrypto -lcryptopp ""$1"" \
      ""$LIBRARY_DIR/arduPiLoRa.o"" \
      ""$ARDUPIAPI_DIR/arduPiUART.o"" \
      ""$ARDUPIAPI_DIR/arduPiUtils.o"" \
      ""$ARDUPIAPI_DIR/arduPiMultiprotocol.o"" \
      ""$ARDUPI_DIR/arduPi.o"" \
      ""$LIBRARY_DIR/ecdh.o"" \
      ""$LIBRARY_DIR/aes.o"" \
      -I""$ARDUPI_DIR"" \
      -I""$ARDUPIAPI_DIR"" \
      -I""$LIBRARY_DIR"" \
      -o ""$1_exe"" 
</code></pre>

<p>but when I compiled it directly using <code>g++ -o blake2 blake2.cpp -lcryptopp</code> the undefined reference errors disappeared, and I succesfully compiled it,</p>

<p>I have changed the shell script, now it finally worked, but I didn't quite undrestand it,</p>

<pre><code>g++ -DNDEBUG -g3 -O2 -Wall -Wextra -lrt -lpthread -lstdc++ -lcrypto -lcryptopp -l:libcryptopp.a ""$1"" \
  ""$LIBRARY_DIR/arduPiLoRa.o"" \
  ""$ARDUPIAPI_DIR/arduPiUART.o"" \
  ""$ARDUPIAPI_DIR/arduPiUtils.o"" \
  ""$ARDUPIAPI_DIR/arduPiMultiprotocol.o"" \
  ""$ARDUPI_DIR/arduPi.o"" \
  ""$LIBRARY_DIR/ecdh.o"" \
  ""$LIBRARY_DIR/aes.o"" \
  -I""$ARDUPI_DIR"" \
  -I""$ARDUPIAPI_DIR"" \
  -I""$LIBRARY_DIR"" \
  -o ""$1_exe"" \
  -l:libcryptopp.a
</code></pre>
","97","<c++><hash><crypto++>","0","0","1","2019-07-17 17:43:26","57047664","7","","608639","","2019-07-17 17:43:26","2019-07-14 00:18:48",""
"55527005","Unable to link Crypto++ Speck algorithm due to undefined references","<p>I'm trying to utilize Crypto++'s Simon and Speck implementations for a research project, but I currently cannot compile and link the example code provided on its wiki page. </p>

<p>Following the instructions from the Crypto++ wiki, I was able to build the library and run all of their test suites to completion. I have also been able to run example AES code from the same wiki. The compilation errors only come when I try to invoke Simon or Speck. </p>

<p>To compile and link the file I am using <code>g++ speck_test.cpp -lcryptopp</code>.</p>

<p>Here is the program provided on the Crypto++ Speck wiki. I added include statements and scope resolutions where I believed necessary.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

#include ""cryptopp/modes.h""
#include ""cryptopp/speck.h""
#include ""cryptopp/filters.h""

int main(int argc, char* argv[]) {
    CryptoPP::SPECK128::Encryption speck;

    std::cout &lt;&lt; ""StaticAlgorithmName: "" &lt;&lt; speck.StaticAlgorithmName() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""AlgorithmName (unkeyed): "" &lt;&lt; speck.AlgorithmName() &lt;&lt; std::endl;

    CryptoPP::byte key[CryptoPP::SPECK128::DEFAULT_KEYLENGTH] = {};
    speck.SetKey(key, sizeof(key));

    std::cout &lt;&lt; ""AlgorithmName (keyed): "" &lt;&lt; speck.AlgorithmName() &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Expected output of this program according to the wiki is</p>

<pre><code>StaticAlgorithmName: SPECK-128
AlgorithmName (unkeyed): SPECK-128
AlgorithmName (keyed): SPECK-128(128)
</code></pre>

<p>however, I am receiving the following error from the compiler:</p>

<pre class=""lang-none prettyprint-override""><code>/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Base::Base()':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2Ev[_ZN8CryptoPP8SPECK1284BaseC5Ev]+0x2c): undefined reference to `vtable for CryptoPP::SPECK128::Base'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2Ev[_ZN8CryptoPP8SPECK1284BaseC5Ev]+0x3a): undefined reference to `vtable for CryptoPP::SPECK128::Base'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2Ev[_ZN8CryptoPP8SPECK1284BaseC5Ev]+0x49): undefined reference to `vtable for CryptoPP::SPECK128::Base'
/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Base::~Base()':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseD2Ev[_ZN8CryptoPP8SPECK1284BaseD5Ev]+0xf): undefined reference to `vtable for CryptoPP::SPECK128::Base'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseD2Ev[_ZN8CryptoPP8SPECK1284BaseD5Ev]+0x1d): undefined reference to `vtable for CryptoPP::SPECK128::Base'
/tmp/ccD02cM7.o:speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseD2Ev[_ZN8CryptoPP8SPECK1284BaseD5Ev]+0x2c): more undefined references to `vtable for CryptoPP::SPECK128::Base' follow
/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Enc::Enc()':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2Ev[_ZN8CryptoPP8SPECK1283EncC5Ev]+0x1b): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2Ev[_ZN8CryptoPP8SPECK1283EncC5Ev]+0x29): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2Ev[_ZN8CryptoPP8SPECK1283EncC5Ev]+0x38): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Enc::~Enc()':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncD2Ev[_ZN8CryptoPP8SPECK1283EncD5Ev]+0xf): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncD2Ev[_ZN8CryptoPP8SPECK1283EncD5Ev]+0x1d): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
/tmp/ccD02cM7.o:speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncD2Ev[_ZN8CryptoPP8SPECK1283EncD5Ev]+0x2c): more undefined references to `vtable for CryptoPP::SPECK128::Enc' follow
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x28): undefined reference to `CryptoPP::SPECK128::Base::AlgorithmProvider[abi:cxx11]() const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x30): undefined reference to `CryptoPP::SPECK128::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x38): undefined reference to `CryptoPP::SPECK128::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x40): undefined reference to `CryptoPP::SPECK128::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0xe0): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x128): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Base::AlgorithmProvider[abi:cxx11]() const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x130): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE[_ZTVN8CryptoPP16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEE]+0x160): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x28): undefined reference to `CryptoPP::SPECK128::Base::AlgorithmProvider[abi:cxx11]() const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x30): undefined reference to `CryptoPP::SPECK128::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x38): undefined reference to `CryptoPP::SPECK128::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x40): undefined reference to `CryptoPP::SPECK128::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0xd8): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Base::UncheckedSetKey(unsigned char const*, unsigned int, CryptoPP::NameValuePairs const&amp;)'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x120): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Base::AlgorithmProvider[abi:cxx11]() const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x128): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Enc::ProcessAndXorBlock(unsigned char const*, unsigned char const*, unsigned char*) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTVN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x158): undefined reference to `non-virtual thunk to CryptoPP::SPECK128::Enc::AdvancedProcessBlocks(unsigned char const*, unsigned char const*, unsigned char*, unsigned long, unsigned int) const'
/tmp/ccD02cM7.o:(.data.rel.ro._ZTIN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE[_ZTIN8CryptoPP12ClonableImplINS_16BlockCipherFinalILNS_9CipherDirE0ENS_8SPECK1283EncEEES4_EE]+0x10): undefined reference to `typeinfo for CryptoPP::SPECK128::Enc'
/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Base::Base(CryptoPP::SPECK128::Base const&amp;)':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2ERKS1_[_ZN8CryptoPP8SPECK1284BaseC5ERKS1_]+0x41): undefined reference to `vtable for CryptoPP::SPECK128::Base'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2ERKS1_[_ZN8CryptoPP8SPECK1284BaseC5ERKS1_]+0x4f): undefined reference to `vtable for CryptoPP::SPECK128::Base'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1284BaseC2ERKS1_[_ZN8CryptoPP8SPECK1284BaseC5ERKS1_]+0x5e): undefined reference to `vtable for CryptoPP::SPECK128::Base'
/tmp/ccD02cM7.o: In function `CryptoPP::SPECK128::Enc::Enc(CryptoPP::SPECK128::Enc const&amp;)':
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2ERKS1_[_ZN8CryptoPP8SPECK1283EncC5ERKS1_]+0x26): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2ERKS1_[_ZN8CryptoPP8SPECK1283EncC5ERKS1_]+0x34): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
speck_test.cpp:(.text._ZN8CryptoPP8SPECK1283EncC2ERKS1_[_ZN8CryptoPP8SPECK1283EncC5ERKS1_]+0x43): undefined reference to `vtable for CryptoPP::SPECK128::Enc'
collect2: error: ld returned 1 exit status
</code></pre>

<p>Any help would be very appreciated!</p>
","<p>As dave pointed out, the error was arose from the compiler being unable to find CryptoPP.</p>

<p>To fix this, I had to set the <code>LD_LIBRARY_PATH</code> environment variable on Ubuntu to include the path to the library. Then, I had to alter my compiler command to compile my file first, then link the library second, i.e. </p>

<p><code>g++ -o test.exe speck_test.cpp -L&lt;path-to-cryptopp&gt; -lcryptopp</code> </p>

<p>rather than </p>

<p><code>g++ -L&lt;path-to-cryptopp&gt; -lcryptopp -o test.exe speck_test.cpp</code>, which was failing. </p>
","96","<c++><linker-errors><crypto++>","1","1","1","2019-04-20 18:37:11","","1","","608639","","2019-04-20 18:37:11","2019-04-05 01:20:11",""
"34300640","How to apply the patch for fully hashed menezes-qu-vanstone (fhmqv) to crypto++ that has been installed from the Ubuntu repository","<p>I want to use Elliptic Curve Diffie-Hellman (ECDH) key exchange protocol for a key agreement process. It is already implemented in crypto++ library and I wanted to utilize it. I have already installed crypto++ (by typing sudo apt-get... command in a terminal) but since traditional ECDH is vulnerable to man-in-the-middle attack.</p>

<p>I want to use fully hashed menezes-qu-vanstone protocol. Although it is implemented for crypto++ it is not in the main stream so I need to patch it. There is an explanation <a href=""https://www.cryptopp.com/wiki/Fully_Hashed_Menezes-Qu-Vanstone"" rel=""nofollow"">here</a> but it is for those who built the library from the source code. </p>

<p>Is there anyone who knows how to apply this patch to crypto++ that has been installed from Ubuntu repository? I am using Ubuntu 15.</p>
","<blockquote>
  <p>but since traditional ECDH is vulnerable to man-in-the-middle attack.</p>
</blockquote>

<p>What others often do is to pair ECDH with a signature scheme. For example, TLS uses ECDH with a scheme like RSA or ECDSA.</p>

<p>I'm not saying you should do it; I'm only letting you know what others are doing.</p>

<hr>

<blockquote>
  <p>it is not in the main stream so I need to patch it...</p>
</blockquote>

<p>We will be adding HMQV and FHMQV at the next release. The next release will be happening in the next couple of months.</p>

<hr>

<blockquote>
  <p>Is there anyone who knows how to apply this patch to crypto++ that has been installed from Ubuntu repository?</p>
</blockquote>

<p>The easiest thing to do would be to probably be to build a new version of the library, and then install it into <code>/usr/local</code>. I presume you know how to download and patch. To build and install:</p>

<pre><code># Crypto++ build directory
...
make static dynamic cryptest.exe
sudo make install PREFIX=/usr/local
</code></pre>

<hr>

<p>You <em>might</em> be able to patch Ubuntu version because FHMQV is mostly a header-only implementation. However, <code>cryptest.exe</code> will <em>not</em> have the validation stuff included. You really need to build the library for it.</p>

<p>Download the patch and perform the following. <code>fhmqv.h</code> is the ""meat and potatoes"" of the patch.</p>

<pre><code>sudo cp fhmqv.h /usr/include/cryptopp
</code></pre>

<p>You also need to add the following to <code>eccrypto.h</code>. Start by opening the file with privileges (i.e., <code>sudo emacs /usr/include/cryptopp/eccrypto.h</code>).</p>

<p>Then, add this to the top of <code>eccrypto.h</code>:</p>

<pre><code>#include ""fhmqv.h""
</code></pre>

<p>And add this to the bottom of <code>eccrypto.h</code>:</p>

<pre><code>//! Fully Hashed Menezes-Qu-Vanstone in GF(p) with key validation,
/*! &lt;a href=""http://eprint.iacr.org/2009/408""&gt;A Secure and Efficient Authenticated DiffieHellman Protocol&lt;/a&gt;
    Note: this is FHMQV, Protocol 5, from page 11; and not FHMQV-C.
*/
template &lt;class EC, class COFACTOR_OPTION = CPP_TYPENAME DL_GroupParameters_EC&lt;EC&gt;::DefaultCofactorOption, class HASH = SHA256&gt;
struct FHMQV
{
    typedef FHMQV_Domain&lt;DL_GroupParameters_EC&lt;EC&gt;, COFACTOR_OPTION, HASH&gt; Domain;
};
</code></pre>

<p>Most of the other stuff in the DIFF file is not needed, like the changes to <code>wait.h</code> and <code>wait.cpp</code>. It was added to address outstanding bugs. The bugs were cleared at Crypto++ 5.6.3.</p>
","96","<linux><ubuntu><patch><crypto++><elliptic-curve>","1","1","1","2015-12-16 06:11:56","34303958","1","","608639","","2015-12-16 04:15:12","2015-12-15 22:27:00",""
"52988269","How to combine two Sources into new one in Crypto++?","<p><strong>Situation</strong></p>

<p>I have two arbitrary sources, lets say a <code>StringSource</code> from a <em>signature</em> and a <code>FileSource</code> from the corresponding <em>signed file</em>. I now want to verify the files signature which is currently performed like this:</p>

<pre><code>bool VerifyFile(const ECDSA&lt;ECP, SHA512&gt;::PublicKey &amp;key,
                const std::string &amp;filename,
                const std::string &amp;signatureString) {
    std::string fileContentString;
    FileSource(filename.c_str(), true,
               new CryptoPP::StringSink(fileContentString));

    bool result = false;
    StringSource(signatureString + fileContentString, true,
                 new SignatureVerificationFilter(
                         ECDSA&lt;ECP, SHA512&gt;::Verifier(key),
                         new ArraySink((byte *) &amp;result, sizeof(result))
                 ) // SignatureVerificationFilter
    );
    return result;
}
</code></pre>

<p><strong>My Problem</strong></p>

<p>I don't want to explicitly extract the file's content to a string, then do a concatenation and verify afterwards.</p>

<p><strong>Question</strong></p>

<p>Is there a way to pass two arbitrary sources where one represents the signature and the other one the signed content (might be a file or a string) to the verification entity?</p>

<p><strong>What I tried so far</strong></p>

<p>I tried <code>Source::TransferAll(...)</code> to a <code>Redirecter</code>, redirecting to <code>SignatureVerificationFilter</code> with no luck.</p>
","<blockquote>
  <p>I have two arbitrary sources, lets say a StringSource from a signature and a FileSource from the corresponding signed file. I now want to verify the files signature ...</p>
</blockquote>

<p>Using multiple sources on the same filter chain can be tricky. I know the library has some baked-in classes for it but I have never liked them. They take multiple input channels and de-multiplexes them into a single channel. You can see them in action in <a href=""https://github.com/weidai11/cryptopp/blob/master/test.cpp"" rel=""nofollow noreferrer""><code>test.cpp</code></a>, functions <code>SecretRecoverFile</code> (around line 650) and <code>InformationRecoverFile</code> (around line 700).</p>

<hr>

<blockquote>
  <p>Is there a way to pass two arbitrary sources where one represents the signature and the other one the signed content (might be a file or a string) to the verification entity?</p>
</blockquote>

<p>Here is how I would handle what you want to do. The example below uses two sources and shares a filter chain. I reduced the complexity by hashing two strings using a <code>HashFilter</code>. Your example uses message, signature, key pairs and <code>SignatureVerificationFilter</code> but it is more complex than needed to show you how to do it.</p>

<p>The example proceeds in four parts:</p>

<ul>
<li><strong><em>Part 0</em></strong> - setup the data. Two 16K ASCII strings are created. One string is also written to a file.</li>
<li><strong><em>Part 1</em></strong> - print the data. <code>Hash(s1)</code>, <code>Hash(s2)</code> and <code>Hash(s1+s2)</code> are printed.</li>
<li><strong><em>Part 2</em></strong> - use two string sources. <code>Hash(s1+s2)</code> is created using two <code>StringSources</code></li>
<li><strong><em>Part 3</em></strong> - use one string source and one file source. <code>Hash(s1+s2)</code> is created using one <code>StringSource</code> and one <code>FileSource</code></li>
</ul>

<p>To state the obvious, the simplified example calculates <code>Hash(s1+s2)</code>. In your context the operation is <code>Verify(key, s1+s2)</code>, where <code>key</code> is the public key, <code>s1</code> is the signature and <code>s2</code> is the contents of the file.</p>

<p><strong><em>Part 0</em></strong> - The data is setup below. It is pretty boring. Notice <code>s3</code> is a concatenation of <code>s1</code> and <code>s2</code>.</p>

<pre><code>std::string s1, s2, s3;
const size_t size = 1024*16+1;

random_string(s1, size);
random_string(s2, size);

s3 = s1 + s2;
</code></pre>

<p><strong><em>Part 1</em></strong> - The data is printed below. The hashes of <code>s1</code>, <code>s2</code> and <code>s3</code> are printed. <code>s3</code> is the important one. <code>s3</code> is what we need to arrive at using two separate sources.</p>

<pre><code>std::string r;
StringSource ss1(s1, true, new HashFilter(hash, new StringSink(r)));

std::cout &lt;&lt; ""s1: "";
hex.Put((const byte*)r.data(), r.size());
std::cout &lt;&lt; std::endl;

r.clear();
StringSource ss2(s2, true, new HashFilter(hash, new StringSink(r)));

std::cout &lt;&lt; ""s2: "";
hex.Put((const byte*)r.data(), r.size());
std::cout &lt;&lt; std::endl;

r.clear();
StringSource ss3(s3, true, new HashFilter(hash, new StringSink(r)));

std::cout &lt;&lt; ""s3: "";
hex.Put((const byte*)r.data(), r.size());
std::cout &lt;&lt; std::endl;
</code></pre>

<p>Output looks like so:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
s1: 45503354F9BC56C9B5B61276375A4C60F83A2F01
s2: 6A3AD5B683DE7CA57F07E8099268A8BC80FA200B
s3: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
...
</code></pre>

<p><strong><em>Part 2</em></strong> - This is where things get interesting. We use two different <code>StringSource</code> to process <code>s1</code> and <code>s2</code> individually.</p>

<pre><code>StringSource ss4(s1, false);
StringSource ss5(s2, false);

HashFilter hf1(hash, new StringSink(r));

ss4.Attach(new Redirector(hf1));
ss4.Pump(LWORD_MAX);
ss4.Detach();

ss5.Attach(new Redirector(hf1));
ss5.Pump(LWORD_MAX);
ss5.Detach();

hf1.MessageEnd();

std::cout &lt;&lt; ""s1 + s2: "";
hex.Put((const byte*)r.data(), r.size());
std::cout &lt;&lt; std::endl;
</code></pre>

<p>It produces the following output:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
s1: 45503354F9BC56C9B5B61276375A4C60F83A2F01
s2: 6A3AD5B683DE7CA57F07E8099268A8BC80FA200B
s3: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
...
</code></pre>

<p>There are several things going on in the code above. First, we dynamically attach and detach the hash filter chain to sources <code>ss4</code> and <code>ss5</code>.</p>

<p>Second, once the filter is attached we use <code>Pump(LWORD_MAX)</code> to pump all the data from the source into the filter chain. We don't use <code>PumpAll()</code> because <code>PumpAll()</code> signals the end of the current message and generates a <code>MessageEnd()</code>. We are processing one message in multiple parts; we are not processing multiple messages. So we want only one <code>MessageEnd()</code> when we determine.</p>

<p>Third, once we are done with the source, we call <code>Detach</code> so <code>StringSource</code> destructors <em>don't</em> cause a spurious <code>MessageEnd()</code> message to enter the filter chain. Again, we are processing one message in multiple parts; we are not processing multiple messages. So we want only one <code>MessageEnd()</code> when we determine.</p>

<p>Fourth, when we are done sending our data into the filter, we call <code>hf.MessageEnd()</code> to tell the filter to process all pending or buffered data. This is when we want the <code>MessageEnd()</code> call, and not before.</p>

<p>Fifth, we call <code>Detach()</code> when done rather than <code>Attach()</code>. <code>Detach()</code> deletes the existing filter chain and avoids memory leaks. <code>Attach()</code> attaches a new chain but does <em>not</em> delete the existing filter or chain. Since we are using a <code>Redirector</code> our <code>HashFilter</code> survives. The <code>HashFilter</code> is eventually cleaned as an automatic stack variable.</p>

<p>As an aside, if <code>ss4.PumpAll()</code> and <code>ss5.PumpAll()</code> were used (or allowed destructors to send <code>MessageEnd()</code> into the filter chain) then you would get a concatenation of <code>Hash(s1)</code> and <code>Hash(s2)</code> because it would look like two different messages to the filter instead of one message over two parts. The code below is wrong:</p>

<pre><code>StringSource ss4(s1, false);
StringSource ss5(s2, false);

HashFilter hf1(hash, new StringSink(r));

ss4.Attach(new Redirector(hf1));
// ss4.Pump(LWORD_MAX);
ss4.PumpAll();  // MessageEnd
ss4.Detach();

ss5.Attach(new Redirector(hf1));
// ss5.Pump(LWORD_MAX);
ss5.PumpAll();  // MessageEnd
ss5.Detach();

// Third MessageEnd
hf1.MessageEnd();
</code></pre>

<p>The incorrect code above produces <code>Hash(s1) || Hash(s2) || Hash(&lt;empty string&gt;)</code>:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
s1: 45503354F9BC56C9B5B61276375A4C60F83A2F01
s2: 6A3AD5B683DE7CA57F07E8099268A8BC80FA200B
s3: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2: 45503354F9BC56C9B5B61276375A4C60F83A2F016A3AD5B683DE7CA57F07E8099268A8BC80FA200BDA39A3EE5E6B4B0D3255BFEF95601890AFD80709
</code></pre>

<p><strong><em>Part 3</em></strong> - This is your use case. We use a <code>StringSource</code> and <code>FileSource</code> to process <code>s1</code> and <code>s2</code> individually. Remember, the string <code>s2</code> was written to a file named <code>test.dat</code>.</p>

<pre><code>StringSource ss6(s1, false);
FileSource fs1(""test.dat"", false);

HashFilter hf2(hash, new StringSink(r));

ss6.Attach(new Redirector(hf2));
ss6.Pump(LWORD_MAX);
ss6.Detach();

fs1.Attach(new Redirector(hf2));
fs1.Pump(LWORD_MAX);
fs1.Detach();

hf2.MessageEnd();

std::cout &lt;&lt; ""s1 + s2 (file): "";
hex.Put((const byte*)r.data(), r.size());
std::cout &lt;&lt; std::endl;
</code></pre>

<p>Here is what running the full example looks like:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
s1: 45503354F9BC56C9B5B61276375A4C60F83A2F01
s2: 6A3AD5B683DE7CA57F07E8099268A8BC80FA200B
s3: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2 (file): BFC1882CEB24697A2B34D7CF8B95604B7109F28D
</code></pre>

<p>Notice <code>s3</code> = <code>s1 + s2</code> = <code>s1 + s2 (file)</code>.</p>

<hr>

<pre><code>$ cat test.cxx

#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""sha.h""
#include ""hex.h""

#include &lt;string&gt;
#include &lt;iostream&gt;

void random_string(std::string&amp; str, size_t len)
{
    const char alphanum[] =
        ""0123456789""
        ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
        ""abcdefghijklmnopqrstuvwxyz"";
    const size_t size = sizeof(alphanum) - 1;

    str.reserve(len);
    for (size_t i = 0; i &lt; len; ++i)
        str.push_back(alphanum[rand() % size]);
}

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    ////////////////////////// Part 0 //////////////////////////

    // Deterministic
    std::srand(0);

    std::string s1, s2, s3, r;
    const size_t size = 1024*16+1;

    random_string(s1, size);
    random_string(s2, size);

    // Concatenate for verification
    s3 = s1 + s2;

    // Write s2 to file
    StringSource(s2, true, new FileSink(""test.dat""));

    // Hashing, resets after use
    SHA1 hash;

    // Printing hex encoded string to std::cout
    HexEncoder hex(new FileSink(std::cout));

    ////////////////////////// Part 1 //////////////////////////

    r.clear();
    StringSource ss1(s1, true, new HashFilter(hash, new StringSink(r)));

    std::cout &lt;&lt; ""s1: "";
    hex.Put((const byte*)r.data(), r.size());
    std::cout &lt;&lt; std::endl;

    r.clear();
    StringSource ss2(s2, true, new HashFilter(hash, new StringSink(r)));

    std::cout &lt;&lt; ""s2: "";
    hex.Put((const byte*)r.data(), r.size());
    std::cout &lt;&lt; std::endl;

    r.clear();
    StringSource ss3(s3, true, new HashFilter(hash, new StringSink(r)));

    std::cout &lt;&lt; ""s3: "";
    hex.Put((const byte*)r.data(), r.size());
    std::cout &lt;&lt; std::endl;

    ////////////////////////// Part 2 //////////////////////////

    r.clear();
    StringSource ss4(s1, false);
    StringSource ss5(s2, false);

    HashFilter hf1(hash, new StringSink(r));

    ss4.Attach(new Redirector(hf1));
    ss4.Pump(LWORD_MAX);
    ss4.Detach();

    ss5.Attach(new Redirector(hf1));
    ss5.Pump(LWORD_MAX);
    ss5.Detach();

    hf1.MessageEnd();

    std::cout &lt;&lt; ""s1 + s2: "";
    hex.Put((const byte*)r.data(), r.size());
    std::cout &lt;&lt; std::endl;

    ////////////////////////// Part 3 //////////////////////////

    r.clear();
    StringSource ss6(s1, false);
    FileSource fs1(""test.dat"", false);

    HashFilter hf2(hash, new StringSink(r));

    ss6.Attach(new Redirector(hf2));
    ss6.Pump(LWORD_MAX);
    ss6.Detach();

    fs1.Attach(new Redirector(hf2));
    fs1.Pump(LWORD_MAX);
    fs1.Detach();

    hf2.MessageEnd();

    std::cout &lt;&lt; ""s1 + s2 (file): "";
    hex.Put((const byte*)r.data(), r.size());
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ test.cxx ./libcryptopp.a -o test.exe
$ ./test.exe
s1: 45503354F9BC56C9B5B61276375A4C60F83A2F01
s2: 6A3AD5B683DE7CA57F07E8099268A8BC80FA200B
s3: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2: BFC1882CEB24697A2B34D7CF8B95604B7109F28D
s1 + s2 (file): BFC1882CEB24697A2B34D7CF8B95604B7109F28D
</code></pre>

<hr>

<p>Here's a class that may ease your pain. It brings together the concepts above in a <code>MultipleSources</code> class. <code>MultipleSources</code> is only a partial implementation of the <code>Source</code> interface, but it should have all the pieces you need.</p>

<pre><code>class MultipleSources
{
public:
    MultipleSources(std::vector&lt;Source*&gt;&amp; source, Filter&amp; filter)
    : m_s(source), m_f(filter)
    {
    }

    void Pump(lword pumpMax, bool messageEnd)
    {
        for (size_t i=0; pumpMax &amp;&amp; i&lt;m_s.size(); ++i)
        {
            lword n = pumpMax;
            m_s[i]-&gt;Attach(new Redirector(m_f));            
            m_s[i]-&gt;Pump2(n);
            m_s[i]-&gt;Detach();
            pumpMax -= n;
        }

        if (messageEnd)
            m_f.MessageEnd();
    }

    void PumpAll()
    {
        for (size_t i=0; i&lt;m_s.size(); ++i)
        {
            m_s[i]-&gt;Attach(new Redirector(m_f));
            m_s[i]-&gt;Pump(LWORD_MAX);
            m_s[i]-&gt;Detach();
        }

        m_f.MessageEnd();
    }

private:
    std::vector&lt;Source*&gt;&amp; m_s;
    Filter &amp;m_f;
};
</code></pre>

<p>You would call it like so:</p>

<pre><code>StringSource ss(s1, false);
FileSource fs(""test.dat"", false);
HashFilter hf(hash, new StringSink(r));

std::vector&lt;Source*&gt; srcs;
srcs.push_back(&amp;ss);
srcs.push_back(&amp;fs);

MultipleSources ms(srcs, hf);
ms.Pump(LWORD_MAX, false);

hf.MessageEnd();
</code></pre>

<p>Or you can use <code>PumpAll</code> and get the same result, but you don't call <code>hf.MessageEnd();</code> in this case because <code>PumpAll</code> signals the end of the message.</p>

<pre><code>MultipleSources ms(srcs, hf);
ms.PumpAll();
</code></pre>
","95","<c++><crypto++><dsa>","4","1","1","2018-10-27 07:30:18","53016357","1","","2509078","","2018-10-26 04:48:02","2018-10-25 11:31:52",""
"56925506","Decrypt an encrypted object to a char[] for memcpy","<p>I am trying to use Crypto++ to encrypt and decrypt an <code>unsigned char</code> object. To date, the encryption is fine. However, I need the final decrypted contents to be saved in a Hex format within a byte array or a char array so that I can hand it off to memcpy properly.</p>

<p>I am using Visual Studio 19 with the latest version of Crypto++.</p>

<pre><code>HexEncoder encoder(new FileSink(cout));
ByteQueue plain, cipher, recover;
unsigned char shellcode[] = ""\xfc\xe8\x89\x00\x00\x00\x60"";
unsigned char enc_shellcode[] =""\x6D\x30\xEB\x18\xF2\x01\x16"";

plain.Put(reinterpret_cast&lt;const byte*&gt;(shellcode), sizeof(shellcode));

//Encryption:
CBC_Mode&lt;AES&gt;::Encryption enc;
enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

StreamTransformationFilter f1(enc, new Redirector(cipher));
plain.CopyTo(f1);
f1.MessageEnd();

cout &lt;&lt; ""Cipher text: "";
cipher.CopyTo(encoder);
encoder.MessageEnd();
cout &lt;&lt; endl;

// Decryption
CBC_Mode&lt;AES&gt;::Decryption dec;
dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

StreamTransformationFilter f2(dec, new Redirector(recover));
cipher.CopyTo(f2);
f2.MessageEnd();

recover.CopyAllTo(encoder);
encoder.MessageEnd();
cout &lt;&lt; endl;

// Allocating memory with EXECUTE writes
void* exec = VirtualAlloc(0, sizeof test, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

// Copying deciphered shellcode into memory as a function
memcpy(exec, /*Decrypted Shellcode..*/, sizeof test);
</code></pre>

<p>I can never get the data back to its original <code>unsigned char</code> in hex form so that I can load the data in memory... I am not very proficient in C++ and I am sure that's fairly object for some of you so this might be a simple fix or not...?</p>
","<blockquote>
  <p>I can never get the data back to its original unsigned char in hex form so that I can load the data in memory...</p>
</blockquote>

<p><code>ByteQueue</code> and <code>MessageQueue</code> are higher level Crypto++ pipeline objects. When <a href=""https://cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">data is flowing from a source to a sink</a> they are a fine choice. But they can be a bit awkward to use when you don't use a sink, like with your <code>memcpy</code>.</p>

<p>Below are two examples of doing what you want to do.</p>

<p>Also note this is not quite correct. The ciphertext size must be a multiple of the blocksize due to CBC mode and PKCS padding. In your case, the encrypted shellcode should be 16 bytes.</p>

<pre><code>const byte enc_shellcode[] =""\x6D\x30\xEB\x18\xF2\x01\x16"";
</code></pre>

<h3>Pipeline</h3>

<p>@zett42 had the right idea - use an <code>ArraySink</code>, and the Crypto++ pipelines will do the <code>memcpy</code> for you. In fact you don't even need <code>plain</code> or <code>recover</code>. So it would look something like below. (I am working on Linux, so I need to fake <code>VirtualAlloc</code>).</p>

<pre><code>$ cat test.cxx
#include ""cryptlib.h""
#include ""filters.h""
#include ""modes.h""
#include ""files.h""
#include ""aes.h""
#include ""hex.h""

#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    HexEncoder encoder(new FileSink(std::cout));
    ByteQueue cipher;

    const byte shellcode[] = ""\xfc\xe8\x89\x00\x00\x00\x60"";       

    const byte key[16] = {1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4};
    const byte  iv[16] = {8,7,6,5, 8,7,6,5, 8,7,6,5, 8,7,6,5};

    //Encryption
    CBC_Mode&lt;AES&gt;::Encryption enc;
    enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    ArraySource plain(shellcode, 7, true);
    StreamTransformationFilter f1(enc, new Redirector(cipher));
    plain.CopyTo(f1);
    f1.MessageEnd();

    std::cout &lt;&lt; ""Cipher text: "";
    cipher.CopyTo(encoder);
    encoder.MessageEnd();
    std::cout &lt;&lt; std::endl;

    // Allocating memory with EXECUTE writes
    // void* exec = VirtualAlloc(0, sizeof test, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // Proxy for VirtualAlloc
    byte x[7];
    void* exec = reinterpret_cast&lt;void*&gt;(x);

    // Decryption
    CBC_Mode&lt;AES&gt;::Decryption dec;
    dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    ArraySink recover(reinterpret_cast&lt;byte*&gt;(exec), 7);
    StreamTransformationFilter f2(dec, new Redirector(recover));
    cipher.CopyTo(f2);
    f2.MessageEnd();

    // Can't use recover.CopyTo() here. ArraySink is not a source;
    // and the internal pointer is at the end of the array, not
    // the beginning of the array.
    std::cout &lt;&lt; ""Recover text: "";
    encoder.Put(reinterpret_cast&lt;byte*&gt;(exec), 7);
    encoder.MessageEnd();
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Running the code produces the output below.</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ test.cxx ./libcryptopp.a -o test.exe
$ ./test.exe
Cipher text: 88BFA35C6ABF2EDF1FDCDC354721C72C
Recover text: FCE88900000060
</code></pre>

<h3>C++ objects</h3>

<p>You can also use C++ objects rather than the Crypto++ <code>ByteQueue</code>. This is a little easier to use.</p>

<pre><code>$ cat test.cxx
#include ""cryptlib.h""
#include ""filters.h""
#include ""osrng.h""
#include ""modes.h""
#include ""files.h""
#include ""aes.h""
#include ""hex.h""

#include &lt;string&gt;
#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    HexEncoder encoder(new FileSink(std::cout));

    // The embedded NULLs mean we need to use this ctor
    const std::string shellcode(""\xfc\xe8\x89\x00\x00\x00\x60"", 7);
    std::string cipher;

    const byte key[16] = {1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4};
    const byte  iv[16] = {8,7,6,5, 8,7,6,5, 8,7,6,5, 8,7,6,5};

    //Encryption
    CBC_Mode&lt;AES&gt;::Encryption enc;
    enc.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    StreamTransformationFilter f1(enc, new StringSink(cipher));
    StringSource(shellcode, true, new Redirector(f1));

    std::cout &lt;&lt; ""Cipher text: "";
    StringSource(cipher, true, new Redirector(encoder));
    std::cout &lt;&lt; std::endl;

    // Allocating memory with EXECUTE writes
    // void* exec = VirtualAlloc(0, sizeof test, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    // Proxy for VirtualAlloc
    byte x[7];
    void* exec = reinterpret_cast&lt;void*&gt;(x);

    // Decryption
    CBC_Mode&lt;AES&gt;::Decryption dec;
    dec.SetKeyWithIV(key, sizeof(key), iv, sizeof(iv));

    ArraySink recover(reinterpret_cast&lt;byte*&gt;(exec), 7);
    StreamTransformationFilter f2(dec, new Redirector(recover));
    StringSource(cipher, true, new Redirector(f2));

    // Can't use recover.CopyTo() here. ArraySink is not a source;
    // and the internal pointer is at the end of the array, not
    // the beginning of the array.
    std::cout &lt;&lt; ""Recover text: "";
    encoder.Put(reinterpret_cast&lt;byte*&gt;(exec), 7);
    encoder.MessageEnd();
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And the same results using <code>std::string</code>:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ test.cxx ./libcryptopp.a -o test.exe
$ ./test.exe
Cipher text: 88BFA35C6ABF2EDF1FDCDC354721C72C
Recover text: FCE8899B7F0000
</code></pre>
","92","<c++><decode><crypto++>","1","0","1","2019-07-14 01:11:44","","14","1","608639","","2019-07-14 01:11:44","2019-07-07 19:37:07",""
"40264656","Custom source for Crypto++","<p>I have made my own custom stream classes for binary I/O. Now I'm trying to make them compatible with Crypto++ library. I have found a <a href=""https://stackoverflow.com/questions/39350337/saving-crypto-objects-to-stdvector"">question</a> that deals with custom sink and implemented my own. Now I need to implement a source. I've searched through the documentation and there seems to be a huge inheritance hierarchy so I can't understand it yet.</p>

<p>Can someone provide an example code?</p>

<p>Here's the part of my stream class:</p>

<pre><code>/// \brief Base class for a binary input stream.
/// \details Binary streams are used for low level unformatted I/O. Built on top
/// of standard streams, this system takes care of endianness and provides
/// convenient &lt;&lt; and &gt;&gt; overloads. This class is designed to mirror
/// std::istream.

class BinaryInputStream : public virtual BinaryStreamBase
{
public:
    /// \brief Returns whether last I/O operation has completed successfully.
    /// \return True if last I/O operation has completed successfully,
    /// false otherwise.
    virtual bool IsGood() const = 0;

    /// \brief Returns whether end-of-file has been reached.
    /// \return True if end-of-file has been reached, false otherwise.
    virtual bool IsEOF() const = 0;

    /// \brief Returns whether recoverable error has occured.
    /// \return True if recoverable error has occured, false otherwise.
    virtual bool IsFail() const = 0;

    /// \brief Returns whether non-recoverable error has occured.
    /// \return True if non-recoverable error has occured, false otherwise.
    virtual bool IsBad() const = 0;

    /// \brief Reads a sequence of bytes from the stream.
    /// \param[in,out] buffer Buffer to write to.
    /// \param[in] size Number of bytes to read.
    /// \return Reference to this stream.
    /// \warning You are responsible for allocating the buffer and ensuring that
    /// it contains enough space to hold the data. If number of bytes to read is
    /// greater than the size of the buffer, the behavior is undefined.
    virtual BinaryInputStream&amp; Read(char* buffer, std::size_t size) = 0;
};
</code></pre>
","<p>I had to look at the source code of crypto++ and copy most of the implementation from <a href=""https://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow""><code>FileSource</code></a> class. The relevant files are <a href=""https://www.cryptopp.com/docs/ref/files_8h_source.html"" rel=""nofollow""><code>files.h</code></a> and <a href=""https://www.cryptopp.com/docs/ref/files_8cpp_source.html"" rel=""nofollow""><code>files.cpp</code></a>.</p>

<p>First, we need to look at the <a href=""https://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow""><code>FileSource</code></a> class. It inherits from <code>SourceTemplate&lt;FileStore&gt;</code>. So we need to examine <a href=""https://www.cryptopp.com/docs/ref/class_file_store.html"" rel=""nofollow""><code>FileStore</code></a> class. It inherits from <code>Store</code>, <code>FilterPutSpaceHelper</code> and <code>NotCopyable</code>. We need to create class which also inherits from these classes.</p>

<p>Our store class must have a default constructor and implement the following virtual functions: <code>TransferTo2</code>, <code>CopyRangeTo2</code> and <code>StoreInitialize</code>. <code>StoreInitialize</code> can be private.</p>

<p>Finally, our source class needs only constructors and if you look at <a href=""https://www.cryptopp.com/docs/ref/files_8h_source.html"" rel=""nofollow""><code>files.h</code></a>, <a href=""https://www.cryptopp.com/docs/ref/class_file_source.html"" rel=""nofollow""><code>FileSource</code></a> is implemented entirely in a header file.</p>

<p>The full implementation code is confined to <a href=""https://www.cryptopp.com/docs/ref/files_8h_source.html"" rel=""nofollow""><code>files.h</code></a> and <a href=""https://www.cryptopp.com/docs/ref/files_8cpp_source.html"" rel=""nofollow""><code>files.cpp</code></a> so there's no need to copy it in this answer.</p>
","91","<c++><crypto++>","0","0","1","2016-10-29 19:40:16","40322901","2","","3624760","","2016-10-26 14:44:07","2016-10-26 14:14:00",""
"33242428","Declaring variables of same type and reusing them","<p>I have the following scenario and was wondering if there is a good solution for it.  </p>

<p>I am using <a href=""http://www.cryptopp.com/"" rel=""nofollow"">Crypto++</a> and declare the following:</p>

<pre><code>if (_HashType == SHA1)
{
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf;
    pbkdf.DeriveKey(...)
}
else if (_HashType == SHA256)
{
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt; pbkdf;
    pbkdf.DeriveKey(...)
}
else if (_HashType == SHA384)
{
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA384&gt; pbkdf;
    pbkdf.DeriveKey(...)
}
else if (_HashType == SHA512)
{
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA512&gt; pbkdf;
    pbkdf.DeriveKey(...)
}
</code></pre>

<p>what I would like to do is something like this:</p>

<pre><code>PKCS5_PBKDF2_HMAC&lt;?&gt; pbkdf;     
if (_HashType == SHA1)
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt; pbkdf;
else if (_HashType == SHA256)
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt; pbkdf;
else if (_HashType == SHA384)
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA384&gt; pbkdf;
else if (_HashType == SHA512)
    PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA512&gt; pbkdf;

pbkdf.DeriveKey(...)    
</code></pre>

<p>Any advice?</p>
","<p>The common base class for <code>PKCS5_PBKDF2_HMAC&lt;&gt;</code> is <a href=""http://www.cryptopp.com/docs/ref/class_password_based_key_derivation_function.html"" rel=""nofollow""><code>PasswordBasedKeyDerivationFunction</code></a>, so what you can do is:</p>

<pre><code>PasswordBasedKeyDerivationFunction* pbkdf;     
if (_HashType == SHA1)
    pbkdf = new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt;();
else if (_HashType == SHA256)
    pbkdf = new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt;();
else if (_HashType == SHA384)
    pbkdf = new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA384&gt;();
else if (_HashType == SHA512)
    pbkdf = PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA512&gt;();

pbkdf-&gt;DeriveKey(...)    

//...
delete pbkdf;
</code></pre>

<p>If you are using C++11 or later, you can use smart pointers and don't have to worry about memory management:</p>

<pre><code>std::unique_ptr&lt;PasswordBasedKeyDerivationFunction&gt; pbkdf;     

if (_HashType == SHA1)
    pbkdf.reset(new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA1&gt;());
else if (_HashType == SHA256)
    pbkdf.reset(new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA256&gt;());
else if (_HashType == SHA384)
    pbkdf.reset(new PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA384&gt;());
else if (_HashType == SHA512)
    pbkdf.reset(PKCS5_PBKDF2_HMAC&lt;CryptoPP::SHA512&gt;());

pbkdf-&gt;DeriveKey(...)
</code></pre>
","90","<c++><crypto++>","2","2","1","2015-10-21 16:41:22","33242529","4","","608639","","2015-10-21 16:41:22","2015-10-20 16:54:45",""
"57151890","Hash output as BYTE instead of std::string?","<p>My question/problem might be a bit newbie regarding this field, but I cannot find any solution or clear explanation to achieve what I want.</p>

<h3>The problem</h3>

<p>I must store and use the hash values as BYTE instead of STRING because of the size. ( it causes me troubles in other areas )</p>

<p>The function generates an MD5 hash for a file, used on windows OS.</p>

<h3>Current code</h3>

<pre><code>std::string MD5Checksum(const path &amp;file)
{
    std::string result;
    try
    {
        CryptoPP::Weak::MD5 md5;

        CryptoPP::HashFilter f5(md5, new CryptoPP::HexEncoder(new CryptoPP::StringSink(result)));

        CryptoPP::ChannelSwitch cs;
        cs.AddDefaultRoute(f5);

        CryptoPP::FileSource ss(file.string().c_str(), true /*pumpAll*/, new CryptoPP::Redirector(cs));
    }
    catch (CryptoPP::Exception const&amp; exception)
    {
      // 
    }

    return result;
}
</code></pre>

<h3>What I tested</h3>

<pre><code>std::string MD5Checksum(const path &amp;file)
{
    std::string result;
    try
    {
        CryptoPP::Weak::MD5 md5;

        CryptoPP::HashFilter f5(md5, new CryptoPP::HexEncoder(new CryptoPP::StringSink(result)));

        CryptoPP::ChannelSwitch cs;
        cs.AddDefaultRoute(f5);

        CryptoPP::FileSource ss(file.string().c_str(), true /*pumpAll*/, new CryptoPP::Redirector(cs));
    }
    catch (CryptoPP::Exception const&amp; exception)
    {
        //
    }

    string decoded;
    CryptoPP::StringSource ss(result, true /*pumpAll*/, new CryptoPP::StringSink(decoded));
    const BYTE* data = reinterpret_cast&lt;const BYTE*&gt;(decoded.data());
    printf(L""sizeof result: %d, sizeof data: %d""), sizeof(result), sizeof(data));

    return result;
}
</code></pre>

<p>This seems to achieve the desired result, because the size of result string is 40 and the size of data is 8 which is a massive reduction in size for me.</p>

<p>However I do not see this as a good solution and I am pretty sure that there must but an easier and cleaner way of doing this.</p>

<p>Any examples are much appreciated.</p>
","<blockquote>
  <p>I must store and use the hash values as BYTE instead of STRING because of the size...</p>
</blockquote>

<p>You are almost there.</p>

<p>Both <code>StringSource</code> and <code>ArraySink</code> can handle <code>byte</code> arrays. You just need to use alternate constuctors. Also see <a href=""https://www.cryptopp.com/wiki/StringSource"" rel=""nofollow noreferrer""><code>StringSource</code></a> and <a href=""https://www.cryptopp.com/wiki/ArraySink"" rel=""nofollow noreferrer""><code>ArraySink</code></a> on the Crypto++ wiki.</p>

<p>I would modify the code similar to the following. I'm using C++11 so I don't have <code>std::path</code>:</p>

<pre><code>$ cat test.cxx
#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""hex.h""

#define CRYPTOPP_ENABLE_NAMESPACE_WEAK 1
#include ""md5.h""

#include &lt;iostream&gt;

#if defined(CRYPTOPP_NO_GLOBAL_BYTE)
using CryptoPP::byte;
#endif

bool MD5Checksum(const std::string &amp;file, byte* digest, size_t size)
{
    using namespace CryptoPP;

    try
    {
        Weak::MD5 md5;
        FileSource(file.c_str(), true /*pumpAll*/,
            new HashFilter(md5, new ArraySink(digest, size)));
    }
    catch (Exception const&amp; exception)
    {
        return false;
    }

    return true;
}

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    std::string filename = (argc &gt;= 2 ? argv[1] : ""./cryptlib.h"");
    byte digest[Weak::MD5::DIGESTSIZE];

    if (MD5Checksum(filename, digest, sizeof(digest)))
    {
        std::cout &lt;&lt; ""Filename: "" &lt;&lt; filename &lt;&lt; std::endl;
        std::cout &lt;&lt; ""Digest: "";
        StringSource(digest, sizeof(digest), true, new HexEncoder(new FileSink(std::cout)));
        std::cout &lt;&lt; std::endl;
    }
    else
    {
        std::cerr &lt;&lt; ""Failed to calculate digest of "" &lt;&lt; filename &lt;&lt; std::endl;
        std::exit(1);
    }

    return 0;
}
</code></pre>

<p>And then compile. I'm working from the <code>cryptopp/</code> directory in my home directory:</p>

<pre><code>$ g++ ./test.cxx ./libcryptopp.a -o test.exe
$
</code></pre>

<p>And finally:</p>

<pre><code>$ ./test.exe
Filename: ./cryptlib.h
Digest: 626047BC8770BE942B26B3AD6CBD3781
</code></pre>

<p>In the code above, here are the sources and sinks wrapping the byte array:</p>

<pre><code>StringSource(digest, sizeof(digest) ...);
ArraySink(digest, size);
</code></pre>

<hr>

<p>If you were storing into a <code>std::string</code> like in <a href=""https://stackoverflow.com/q/29467707/608639"">How to easily apply Crypto++ hash functions?</a>, here are the sources and sinks wrapping the <code>std::string</code>. They are different constructors.</p>

<pre><code>std::string digest;
...

StringSource(digest, ...);
StringSink(digest);
</code></pre>
","90","<c++><crypto++>","2","2","1","2019-07-23 01:10:19","57152292","8","","1968","","2019-07-22 18:42:08","2019-07-22 18:34:34",""
"40217062","How to use crypto++ code in web","<p>I downloaded a sample code in crypto++ library. I tested that code and it returns a group of HEX code as a result. I want to send users id as a encrypted text to browser. When I get request for viewing particular user details I need to decrypt the request text and find the user id and process the data of that user and send the response to browser. But When I use the following code I get chipper text as group of HEX values. I want this chipper text as like SHA value around 20 to 25 length of string. How can I change the chipper text like SHA value.</p>

<pre><code> //Key and IV setup
    //AES encryption uses a secret key of a variable length (128-bit, 196-bit or 256-   
    //bit). This key is secretly exchanged between two parties before communication   
    //begins. DEFAULT_KEYLENGTH= 16 bytes
    byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );

    //
    // String and Sink setup
    //
    std::string plaintext = ""Now is the time for all good men to come to the aide..."";
    std::string ciphertext;
    std::string decryptedtext;

    //
    // Dump Plain Text
    //
    std::cout &lt;&lt; ""Plain Text ("" &lt;&lt; plaintext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;
    std::cout &lt;&lt; plaintext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Create Cipher Text
    //
    CryptoPP::AES::Encryption aesEncryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Encryption cbcEncryption( aesEncryption, iv );

    CryptoPP::StreamTransformationFilter stfEncryptor(cbcEncryption, new CryptoPP::StringSink( ciphertext ) );
    stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
    stfEncryptor.MessageEnd();

    //
    // Dump Cipher Text
    //
    std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

    for( int i = 0; i &lt; ciphertext.size(); i++ ) {

        std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
    }

    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;

    //
    // Decrypt
    //
    CryptoPP::AES::Decryption aesDecryption(key, CryptoPP::AES::DEFAULT_KEYLENGTH);
    CryptoPP::CBC_Mode_ExternalCipher::Decryption cbcDecryption( aesDecryption, iv );

    CryptoPP::StreamTransformationFilter stfDecryptor(cbcDecryption, new CryptoPP::StringSink( decryptedtext ) );
    stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
    stfDecryptor.MessageEnd();

    //
    // Dump Decrypted Text
    //
    std::cout &lt;&lt; ""Decrypted Text: "" &lt;&lt; std::endl;
    std::cout &lt;&lt; decryptedtext;
    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
</code></pre>

<p>Output:</p>

<pre><code>Plain Text (55 bytes)
Now is the time for all good men to come to the aide...

Cipher Text (64 bytes)
0x7f 0xf8 0xb3 0xea 0x8a 0x2 0xb3 0x7a 0x3d 0x28 0x66 0x9c 0x97 0x13 0xa7 0xb3 0xf 0xa2 0x50 0x25 0x80 0xd5 0xd2 0x32 0xce 0xe8 0xa 0x57 0x33 0xef 0x70 0xff 0x48 0xe9 0xe8 0x4 0x98 0xa9 0x4 0xc2 0x5e 0xa7 0xb0 0x40 0x43 0xa1 0xfc 0x23 0xb1 0xa1 0xeb 0x1e 0xb2 0xf6 0x97 0x62 0x70 0xa1 0x81 0xca 0x6e 0x78 0x80 0x90 

Decrypted Text: 
Now is the time for all good men to come to the aide...
</code></pre>

<p>But I want chipper text as,</p>

<pre><code>kdHkekdKLI!kdheGHWewqef 
</code></pre>
","<blockquote>
  <p>But I want chipper text as <code>kdHkekdKLI!kdheGHWewqef</code></p>
</blockquote>

<p>I think you want either a <a href=""http://cryptopp.com/wiki/Base64Encoder"" rel=""nofollow"">Base64Encoder</a> or <a href=""http://cryptopp.com/wiki/Base64URLEncoder"" rel=""nofollow"">Base64URLEncoder</a>. Its not clear to me which alphabet you want since they are very similar.</p>

<p>You can change the following:</p>

<pre><code>std::cout &lt;&lt; ""Cipher Text ("" &lt;&lt; ciphertext.size() &lt;&lt; "" bytes)"" &lt;&lt; std::endl;

for( int i = 0; i &lt; ciphertext.size(); i++ )
{
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; (0xFF &amp; static_cast&lt;byte&gt;(ciphertext[i])) &lt;&lt; "" "";
}
</code></pre>

<p>To something like the following using a <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Pipeline</a>. A pipeline allows data to flow from a source to a sink.</p>

<pre><code>std::string encoded;
StringSource ss(ciphertext, true, new Base64Encoder(new StringSink(encoded)));
</code></pre>

<p>You can also do it manually with <code>Put</code> and <code>Get</code>, which is more C-ish. Under the hood, this is what the pipeline does for you (with some hand waiving):</p>

<pre><code>std::string encoded;
Base64Encoder encoder;

encoder.Put((const byte*)ciphertext.data(), ciphertext.size());
encoder.MessageEnd();

size_t ready = encoder.MaxRetrievable();
if (ready)
{
    encoded.resize(ready);
    encoder.Get((byte*)&amp;encoded[0], ready);
}

std::cout &lt;&lt; encoded &lt;&lt; std::endl;
</code></pre>

<p>Finally, you can perform the base64 encoding in the <code>StreamTransformationFilter</code> pipeline with the following:</p>

<pre><code>StreamTransformationFilter stfEncryptor(cbcEncryption, new Base64Encoder(new StringSink(ciphertext)));
</code></pre>
","88","<encryption><crypto++>","1","1","1","2017-02-17 21:14:49","40250356","0","","","","","2016-10-24 11:18:26",""
"34991975","Decrypting portions of AES encrypted file","<p>For my C++ application, I have looked at Crypto++. Seems simple enough to encrypt some content and save it in a file. It also seems simple enough to decrypt the whole file. However, our requirement is that we cannot decrypt the whole file at once. I need to decrypt portions of the file on the fly as requested by the caller. Essentially, I need to implement the following pseudo methods:</p>

<pre><code>  int openFile(const char* aesFile); // returns a handle
  long read(int handle, long pos, int size, byte* buffer); 
</code></pre>

<p>How can I achieve this? Is there something in Crypto++ or some other library that is readily available to do this? Regards.</p>
","<blockquote>
  <p>How can I achieve this? Is there something in Crypto++ ...</p>
</blockquote>

<p>I think you need two things. First, you need a <strong><em>seekable</em></strong> cipher mode of operation. <a href=""http://www.cryptopp.com/wiki/CTR_Mode"" rel=""nofollow"">Counter mode (CTR)</a> will probably work for that. You can check if a cipher is seekable using <a href=""http://www.cryptopp.com/docs/ref/class_stream_transformation.html#a3aa2d47acbd55ed7e82a0519497f1cf7"" rel=""nofollow"">IsRandomAccess()</a>. Its inherited from <a href=""http://www.cryptopp.com/docs/ref/class_stream_transformation.html"" rel=""nofollow"">StreamTransfoormation Class</a>.</p>

<p>In counter mode (and other seekable modes), be careful to ensure you still have authenticity assurances. This can be tricky. Also see <a href=""http://cryptopp.com/wiki/Authenticated_encryption"" rel=""nofollow"">Authenticated Encryption</a> on the <a href=""https://cryptopp.com/wiki/"" rel=""nofollow"">Crypto++ wiki</a>.</p>

<p>Second, probably you need to <strong><em>avoid</em></strong> the streaming interface, and you need to use <strong><em><code>Put</code></em></strong> and <strong><em><code>Get</code></em></strong>. <strong><em><code>Put</code></em></strong> and <strong><em><code>Get</code></em></strong> are just C-like class functions present on every Crypto++ <strong><em><code>BufferedTransformation</code></em></strong> class.</p>

<p>Most examples of <strong><em><code>Put</code></em></strong> and <strong><em><code>Get</code></em></strong> are rather trivial. However, a more substantial one recently made an appearance on the <a href=""https://cryptopp.com/wiki/"" rel=""nofollow"">Crypto++ wiki</a> at <a href=""http://www.cryptopp.com/wiki/Init-Update-Final"" rel=""nofollow"">Init-Update-Final</a>. Though its more substantial, its not more complex because its a simple concept.</p>

<hr>

<blockquote>
  <p>... or some other library that is readily available to do this?</p>
</blockquote>

<p>Well, that's a choice you have to make. If C++ and security libraries are your only library requirements, then you can also check out <a href=""http://botan.randombit.net/"" rel=""nofollow"">Jack Lloyd's Botan</a>.</p>
","88","<c++><crypto++>","1","2","1","2016-01-26 00:09:10","35004842","1","","","","","2016-01-25 11:54:30",""
"56271308","Elliptic Curve Point Addition and Multiplication in Crypto++","<p>How to use the point addition and multiplication functions in elliptic curve using Crypto++ library?</p>

<p>I've tried the following code where <code>Basepoint</code> and <code>point</code> are the points on the elliptic curve.</p>

<pre><code>const ECP::Point&amp; ECP::Add(&amp;Basepoint, &amp;point);

ECP::Point&amp; result = ECP::Add(Basepoint, point);

const int result = ECP::Point ECP::Add(&amp;Basepoint, &amp;point);
</code></pre>

<p>It results in:</p>

<blockquote>
  <p>ERROR: E0245 a nonstatic member reference must be relative to a
  specific object</p>
</blockquote>
","<p>in</p>

<blockquote>
  <p>ECP::Point&amp; result = ECP::Add(Basepoint, point);</p>
</blockquote>

<p>you call <code>ECP::Add</code> as a static member of ECP, the error indicates there is no static <em>Add</em> , you need to apply it to an instance of ECP</p>

<p>When I look at the <a href=""https://www.cryptopp.com/docs/ref/class_e_c_p.html"" rel=""nofollow noreferrer"">documentation</a> I only see</p>

<blockquote>
  <p>const Point &amp; Add (const Point &amp;P, const Point &amp;Q) const</p>
</blockquote>

<p>which is not static</p>

<p>Also </p>

<blockquote>
  <p>const ECP::Point&amp; ECP::Add(&amp;Basepoint, &amp;point);</p>
  
  <p>const int result = ECP::Point ECP::Add(&amp;Basepoint, &amp;point);</p>
</blockquote>

<p>are an invalid forms. </p>

<p>Even having just <code>ECP::Add(&amp;Basepoint, &amp;point);</code> is also wrong because the operation is not static and because the arguments are pointers to <em>Point</em> incompatible with the operation parameters. Probably you have to look at what a reference is in C++ documentation/tutorial</p>

<p>A valid code can be </p>

<pre><code>ECP ecp;
Point basepoint;
Point point;

// set ecp, basepoint and point to be the ones you want

const Point &amp; r1 = ecp.Add(basepoint, point); // do not copy the result
Point r2 = ecp.Add(basepoint, point); // copy result in non const to be able to modify it later etc
</code></pre>
","86","<c++><crypto++><elliptic-curve>","-1","1","1","2019-05-23 09:22:51","56271643","2","","608639","","2019-05-23 09:22:51","2019-05-23 08:42:07",""
"49477520","Hashing a string containing the NUL character in C++ using crypto++","<p>In C++ (C++11 to be precise), I would like to get the HMAC SHA512 hash of a string containing the NUL character (the ASCII character that has all eight of its bits set to 0).</p>

<p>Using crypto++, so far my approach has been as follows:</p>

<pre><code>std::string message(""My\0Message"",2+1+7);

std::string key_base64 = ""MYSECRETKEY"";
std::string key;
StringSource ss(key_base64, true, new Base64Decoder(new StringSink(key)));

std::string mac, encoded;

HMAC&lt; SHA512 &gt; hmac((byte*)key.c_str(), key.length());

StringSource(message,
             true,
             new HashFilter(hmac, new StringSink(mac))                                                                                                           
             ); // StringSource                                                                                                                                                

encoded.clear();
StringSource(mac,
           true,
           new Base64Encoder(new StringSink(encoded), false) // Base64Encoder. Pass argument 'false' to prevent insertion of line breaks                                       
           ); // StringSource                                                                                                                                                  

std::cout &lt;&lt; ""Hashed message (Base64): "" &lt;&lt; encoded &lt;&lt; std::endl;
</code></pre>

<p>This doesn't work properly when a NUL character is included as in the <code>message</code> string above.</p>

<p>The base64 encoded version of the hash (variable <code>mac</code>) I get is</p>

<pre><code>bXmQCkzhzq3J81vInF6IRtxXyd+mN8TRh8e3qHThJ+/RYVcgRkFZ9iStKnNaVsGgco/nisUeRpT3m388UR/BMg==
</code></pre>

<p>instead of the expected</p>

<pre><code>hUk4PX3mnqs943JnMR+ptW6f8+enIUGBd4x7sUA+Ug2squOFVF6ZdiCewSBDlGAwNuWf+9Uh0AqUkQV1vMNHxg==
</code></pre>

<p><strong>EDIT</strong></p>

<p>The expected output can be obtained from the Bash command line as follows:</p>

<pre><code>hex_encoded_secret=$(echo -n ""MYSECRETKEY"" | base64 --decode | xxd -p | tr '\n' ' ' | tr -d '[:space:]')
echo -ne ""My\0Message"" | openssl dgst -sha512 -mac HMAC -macopt hexkey:""${hex_encoded_secret}"" -binary | base64 | tr -d '\n'
</code></pre>

<p>This generates the expected output as given above.</p>
","<blockquote>
  <p>This doesn't work properly when a NUL character is included as in the message string above.</p>
</blockquote>

<p>The constructor you used should be OK because the machinery uses <code>std::string::size()</code>, and not <code>std::string::c_str()</code> to determine length. I suspect something else is not quite correct, like a character encoding issue.</p>

<p>You are using the <code>std::string</code> constructor of <code>StringSource</code>. The second constructor of <code>StringSource</code> takes a binary string. You might have better luck with it in your production code:</p>

<pre class=""lang-cxx prettyprint-override""><code>StringSource(reinterpret_cast&lt;const byte*&gt;(&amp;message[0]),
         message.size(),
         true,
         new HashFilter(hmac, new StringSink(mac))              
         ); // StringSource
</code></pre>

<p>Also see <a href=""https://www.cryptopp.com/wiki/StringSource"" rel=""nofollow noreferrer""><code>StringSource</code></a> on the Crypto++ wiki.</p>
","85","<c++><string><hash><crypto++><nul>","2","0","1","2018-03-25 20:43:16","","5","","7437148","","2018-03-25 20:43:16","2018-03-25 15:30:18",""
"45530233","Can't delete file after encrypting content with FileSource","<p>I'm trying to encrypt a file using AES EAX mode and CryptoPP library.
Here is the main() content:</p>

<pre><code>SecByteBlock key(AES::MAX_KEYLENGTH);
rnd.GenerateBlock(key, key.size());
ArraySource as(key.begin(), key.size(), true, new FileSink(""key.bin""));

SecByteBlock iv(AES::BLOCKSIZE);
rnd.GenerateBlock(iv, AES::BLOCKSIZE);

EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

FileSink file(""image.jpg.enc"");

ArraySource write_iv(iv, iv.size(), true, new Redirector(file));

FileSource write_ciphertext(""image.jpg"", true, new AuthenticatedEncryptionFilter(encryptor, new Redirector(file)));

const int delete_file = std::remove(""image.jpg"");
std::cout &lt;&lt; delete_file &lt;&lt; std::endl;
std::cout &lt;&lt; ""Error code is:"" &lt;&lt; GetLastError();

return 0;
</code></pre>

<p>The encryption part ends successfully,however,removing the original file (image.jpg) fails.The output I get is:</p>

<pre><code>Error code is:32
</code></pre>

<p>Which is an <code>ERROR_SHARING_VIOLATION</code>, meaning that ""The process cannot access the file because it is being used by another process.""
My question is : How can I close the file after the <code>Filesource</code> line,to be able to delete the file after ? With a classic <code>ifstream</code> ,it would be <code>file.close()</code>, but how can i do it with Crypto++ ?</p>
","<p>I'm not familiar with <code>crypto++</code> but if they're following the RAII pattern then triggering the <code>~FileSource</code> destructor should be sufficient to close the handle of the file.</p>

<p>In C++ you would use an anonymous scope to define the lifetime of an automatic variable. Anonymous scopes are defined using curly braces without any keywords:</p>

<pre><code>using namespace std;
...
encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

// begin an anonymous scope:
{

    FileSink    file             ( ""image.jpg.enc"" );
    ArraySource write_iv         ( iv, iv.size(), true, new Redirector( file ) );
    FileSource  write_ciphertext ( ""image.jpg"", true, new AuthenticatedEncryptionFilter( encryptor, new Redirector( file ) ) );        
}
// end the scope, causing all objects declared within to have their destructors called

const int delete_file = remove(""image.jpg"");
cout &lt;&lt; delete_file &lt;&lt; endl;
cout &lt;&lt; ""Error code is:"" &lt;&lt; GetLastError();
...
</code></pre>

<p>BTW, I noticed you use <code>new</code> without <code>delete</code>. I believe you can make those argument objects also automatic, like so:</p>

<pre><code>using namespace std;
...
encryptor.SetKeyWithIV(key, key.size(), iv, iv.size());

// begin an anonymous scope:
{       
    FileSink                      file            ( ""image.jpg.enc"" );
    Redirector                    write_redir     ( file );
    ArraySource                   write_iv        ( iv, iv.size(), true, &amp;write_redir );
    AuthenticatedEncryptionFilter filter          ( encryptor, &amp;write_redir )
    FileSource                    write_ciphertext( ""image.jpg"", true, &amp;filter );
}
// end the scope, causing all objects declared within to have their destructors called

const int delete_file = remove(""image.jpg"");
cout &lt;&lt; delete_file &lt;&lt; endl;
cout &lt;&lt; ""Error code is:"" &lt;&lt; GetLastError();
...
</code></pre>
","82","<c++><windows><encryption><crypto++>","1","2","1","2017-08-06 15:07:52","45530274","3","","608639","","2017-08-06 15:07:52","2017-08-06 08:44:51",""
"56465807","AES/CCM Encryption and Plaintext Length Exceeds Maximum Message Length","<p>I am trying to perform an encryption and decryption in Crypto++ library using AES128 cipher with CCM mode of operation. I have a problem when I try to encrypt string longer than 16777215 bytes.</p>

<p>My code:</p>

<pre><code>const int TAG_SIZE = 8;
CCM&lt; AES, TAG_SIZE &gt;::Encryption e;
CCM&lt; AES, TAG_SIZE &gt;::Decryption d;

e.SetKeyWithIV( key, sizeof(key), iv, sizeof(iv) );
e.SpecifyDataLengths( 0, plain.size(), 0 );

//Encryption
StringSource ss1(
  plain,
  true,
  new AuthenticatedEncryptionFilter(
    e,
    new StringSink(cipher)
   )
);

d.SetKeyWithIV( key, sizeof(key), iv, sizeof(iv) );
d.SpecifyDataLengths( 0, plain.size(), 0 );

//Decryption
AuthenticatedDecryptionFilter df( d,
  new StringSink(recovered)
);
StringSource ss2(
  cipher,
  true,
  new Redirector(df)
);
</code></pre>

<p>When I try to encrypt/decrypt a plaintext which is size of a CD (737280000), I get the following error:</p>

<blockquote>
  <p>""terminate called after throwing an instance of 'CryptoPP::InvalidArgument'
    what():  AES/CCM: message length 737280000 exceeds the maximum of 16777215""</p>
</blockquote>

<p>My question is, how do I encrypt/decrypt a plaintext which is longer than 16777215 bytes?</p>
","<blockquote>
  <p>My question is, how do I encrypt/decrypt a plaintext which is longer than 16777215 bytes?</p>
</blockquote>

<p>CCM mode is specified in NIST <a href=""https://csrc.nist.gov/publications/detail/sp/800-38c/final"" rel=""nofollow noreferrer"">SP800-38c</a>. Section A.1, Length Requirements, discusses maximum plain text under a security context. A security context is the <em>{key, iv}</em> combination (with some hand waiving).</p>

<p>I believe you have three choices. First, you can increase the length of the IV. The larger the iv, the more plain text you can encrypt. The max iv length is 13 so it does not scale up forever.</p>

<p>Second, you have to re-key or change the iv before you hit the maximum plain text under the context. You can find the maximum plain text length using <a href=""https://github.com/weidai11/cryptopp/blob/master/ccm.h"" rel=""nofollow noreferrer""><code>MaxMessageLength()</code></a>. Crypto++ tracks the number of bytes processed via <a href=""https://github.com/weidai11/cryptopp/blob/master/authenc.h"" rel=""nofollow noreferrer""><code>m_totalMessageLength</code></a>, but it is not exposed to user programs. You will have to track it yourself.</p>

<p>Third, you can change algorithms. An algorithm like <a href=""https://www.cryptopp.com/wiki/ChaCha20Poly1305"" rel=""nofollow noreferrer"">ChaCha20Poly1305</a> allows you to encrypt 2^38-1 64-byte blocks. That is just under 2^44 bytes or about 256 GB. You should be safe with ChaCha20Poly1305.</p>

<hr>

<p>Crypto++ tells you the maximum number of bytes via <a href=""https://github.com/weidai11/cryptopp/blob/master/ccm.h"" rel=""nofollow noreferrer""><code>MaxMessageLength()</code></a>. In the case of CCM it is based on the iv length, and tracked through <code>m_L</code> in the code below.</p>

<pre><code>lword MaxMessageLength() const
    {return m_L&lt;8 ? (W64LIT(1)&lt;&lt;(8*m_L))-1 : W64LIT(0)-1;}
</code></pre>

<p><code>MaxMessageLength()</code> is used in <a href=""https://github.com/weidai11/cryptopp/blob/master/authenc.cpp"" rel=""nofollow noreferrer""><code>authenc.cpp</code></a>. <code>ProcessData()</code> throws an exception when the limit is hit:</p>

<pre><code>if (m_state &gt;= State_IVSet &amp;&amp; length &gt; MaxMessageLength()-m_totalMessageLength)
    throw InvalidArgument(AlgorithmName() + "": message length exceeds maximum"");
m_totalMessageLength += length;
</code></pre>

<hr>

<pre><code>const int TAG_SIZE = 8;
CCM&lt; AES, TAG_SIZE &gt;::Encryption e;
CCM&lt; AES, TAG_SIZE &gt;::Decryption d;
</code></pre>

<p>Your tag size is a tad bit on the small side. You might want to use the maximum size, if your protocol allows it.</p>

<hr>

<p>I recommend you switch algorithms. CCM is a bastard mode that got standardized in the early 2000's through some Wireless Working Group. Then, NIST adopted it because it was already standardized.</p>

<p>At the time CCM was standardized there were better <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> modes available, like CWC, OCB, EAX and GCM. Unfortunately the damage was done. And now you have algorithms like Bernstein's ChaChaPoly1305.</p>

<p>You might also want to checkout <a href=""https://www.cryptopp.com/wiki/AEAD_Comparison"" rel=""nofollow noreferrer"">AEAD Comparison</a> on the Crypto++ wiki. The comparison shows CCM is about the worst of the authenticated encryption modes.</p>
","82","<c++><encryption><crypto++>","2","3","1","2019-06-07 04:43:31","56466366","0","","608639","","2019-06-05 18:53:20","2019-06-05 18:04:24",""
"23400966","What is a good way to compare data before encryption and after decryption","<p>I am running a lot of algorithms from Crypto++. I am Encrypting, then decrypting like this:</p>

<pre><code>int main(int argc, char* argv[]) {
    AutoSeededRandomPool prng_blowfish;

    SecByteBlock key_blowfish(Blowfish::DEFAULT_KEYLENGTH);
    prng_blowfish.GenerateBlock( key_blowfish, key_blowfish.size() );

    byte iv_blowfish[ Blowfish::BLOCKSIZE ];
    prng_blowfish.GenerateBlock( iv_blowfish, sizeof(iv_blowfish) );

    string ifilename = ""sample_files/1MB.jpg"";
    string cipher = ""1MB.enc"";
    string rfilename = ""r1MB.jpg"";

    try {

    EAX&lt; Blowfish &gt;::Encryption e_blowfish;
    e_blowfish.SetKeyWithIV( key_blowfish, key_blowfish.size(), iv_blowfish, sizeof(iv_blowfish) );

    std::ifstream ifile(ifilename.c_str(), ios::binary);
    std::ifstream::pos_type size = ifile.seekg(0, std::ios_base::end).tellg();
    ifile.seekg(0, std::ios_base::beg);

    FileSource fs1( ifilename.c_str(), true, new AuthenticatedEncryptionFilter( e_blowfish, new FileSink(cipher.c_str()) ) );

    EAX&lt; Blowfish &gt;::Decryption d_blowfish;
    d_blowfish.SetKeyWithIV( key_blowfish, key_blowfish.size(), iv_blowfish, sizeof(iv_blowfish) );

    FileSource fs2( cipher.c_str(), true, new AuthenticatedDecryptionFilter( d_blowfish, new StringSink( rfilename ), AuthenticatedDecryptionFilter::THROW_EXCEPTION ) ); 

    } catch (const Exception&amp; ex) {
        cerr &lt;&lt; ex.what() &lt;&lt; endl;
    }

   return 0;
}
</code></pre>

<p>I need to make sure that everything is working properly. I would like to compare the file that is being read in from before it is encrypted to the file after it has been decrypted so  that I know everything is working properly. Can somebody create an example of how I would be able to do this?</p>
","<p>It is unfortunately not possible to check if your encryption routines are properly implemented or not by just looking at the output. There are few pitfalls you can - and should - check, though:</p>

<ul>
<li>Encrypt an all zero file and see if there are any discernible patterns. ECB shows repeating blocks there.</li>
<li>Encrypt the same file twice. The ciphertext should <em>not</em> have any visible similarity. If they are the same then you probably use the same IV or nonce multiple times.</li>
<li>Basically the same problem as above: Without any outside knowledge (package counter, etc.) the ciphertext will always be longer than the plaintext, because of an IV or nonce that has to be transmitted alongside.</li>
<li>If you are using authenticated encryption (as after skimming your code I believe you do) change a byte and verify that it indeed results in an error message.</li>
</ul>

<p>But as I've said above these are only negative criteria. A lot of other errors will not show in such a way. For example if you use the current time as an entropy source for your key you will see the exact same behaviour as with proper entropy.</p>
","81","<encryption><file-io><compare><crypto++>","0","0","1","2014-05-01 08:16:39","","3","","2662279","","2014-05-01 02:03:48","2014-05-01 01:54:45",""
"45876843","Downloading a encrypted file then decrypting it, the decryption always fails","<p>I'm having the weirdest problem and it's had me stumped for a while now. I'm using cryptopp to decrypt a file downloaded from a website. For some reason, the decryption is coming out wrong every single time, yet when I decrypt it from a file or a buffer in the program, it works perfectly. </p>

<p>Here is how I initially encrypted it. After encryption I put it on the site.</p>

<pre><code>const byte b_key[ ] = { '1', '0', 'F', 'D', 'F', '6', 'B', 'D', '6', 'A', '3', '8', 'A', '1', '9', 'A', '7', '5', 'A', 'F', '5', '0', 'D', 'B', 'C', '7', '0', 'A', 'A', '4', '5', '2' };
const byte b_iv[ ] = { 'A', '7', '0', 'B', '6', 'C', '6', '3', 'F', '4', 'C', 'D', 'E', '0', '9', '2' };

CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption tmp ( b_key, 32, b_iv );
tmp.ProcessData ( &amp;img[ 0 ], pBuffer, dwFileSize );
</code></pre>

<p>Here is the writefunction</p>

<pre><code>struct MemoryInfo
{
    std::vector&lt; byte &gt; buffer;
};



static size_t WriteMemoryCallback ( void *contents, size_t size, size_t nmemb, void *userp )
{
    size_t real_size = size * nmemb;
    MemoryInfo *mem = static_cast&lt; MemoryInfo * &gt;( userp );

    mem-&gt;buffer.resize ( mem-&gt;buffer.size () + real_size );
    memcpy ( &amp;mem-&gt;buffer[ mem-&gt;buffer.size () - real_size ], static_cast&lt; byte* &gt;( contents ), real_size );

    return real_size;
}
</code></pre>

<p>then heres how i decrypt it. </p>

<pre><code>std::vector&lt; byte &gt; img ( mem.buffer.size () );
CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Decryption tmp ( b_key, CryptoPP::AES::MAX_KEYLENGTH, b_iv );
tmp.ProcessData ( &amp;img[ 0 ], static_cast&lt; byte* &gt;( mem.buffer.data () ), mem.buffer.size () );
</code></pre>

<p>Not sure what I'm doing wrong here, I can't really go to cryptopp's website, at the moment everything is just a blank page or tells me I don't have access.</p>

<p>I appreciate any help, thanks.</p>
","","78","<c++><libcurl><crypto++>","1","","0","2017-08-25 07:59:06","","7","","","","","2017-08-25 07:59:06",""
"33979956","Encoding/decoding fails on Linux","<p>I am looking for a bit of help with my encode/decode functions on cross platforms. Currently the code works across windows OS's but fails on linux. Currently it is untested on Mac.</p>



<pre class=""lang-c++ prettyprint-override""><code>void tradingDialog::on_SaveKeys_clicked()
{
    // Encryption properties store iv and password information
    EncryptionProperties props;

    // Generate a 256 bit random IV from 4 separate 64 bit numbers
    props.iv = crypto_random();
    props.iv2 = crypto_random();
    props.iv3 = crypto_random();
    props.iv4 = crypto_random();

    // What cipher function do we require?
    props.cipher = Algorithm::AES;

    // Qstring to string
    string password = ui-&gt;PasswordInput-&gt;text().toUtf8().constData();
    // the password used for encryption / decryption
    props.password = string(password);

    /*==========  The main cryptostreampp usage  ==========*/
    boost::filesystem::path pathAPI = GetDataDir() / ""APIcache.txt"";
    // Create a stream in output mode to create a brand new file called apicache.txt
    //CryptoStreamPP stream(pathAPI.string(), props, std::ios::out | std::ios::binary | std::ios::trunc);
    CryptoStreamPP stream(pathAPI.string(), props, std::ios::out | std::ios::binary | std::ios::trunc);

    // ------------------------------------------------------
    // NOTE:
    // After creating the stream, there will be a short pause
    // as the key stream is initialized. This accounts for
    // one million iterations of PBKDF2
    // ------------------------------------------------------

    // write to the stream as you would a normal fstream. Normally
    // you would write a buffer of char data. In this example,
    // we write a string which is basically the same thing.
    // Stream operator support to be properly added in future.

    // qstrings to utf8, add to byteArray and convert to const char for stream
    const QByteArray byteArray = (ui-&gt;ApiKeyInput-&gt;text().toUtf8() + ui-&gt;SecretKeyInput-&gt;text().toUtf8());
    const char *API = byteArray.constData();

    stream.write(API, 64);

    // make sure stream is flushed before closing it
    stream.flush();
    stream.close();
}

void tradingDialog::on_LoadKeys_clicked()
{
    // Encryption properties store iv and password information
    EncryptionProperties props;

    // Generate a 256 bit random IV from 4 separate 64 bit numbers
    props.iv = crypto_random();
    props.iv2 = crypto_random();
    props.iv3 = crypto_random();
    props.iv4 = crypto_random();

    // What cipher function do we require?
    props.cipher = Algorithm::AES;

    // Qstring to string
    string password = ui-&gt;PasswordInput-&gt;text().toUtf8().constData();
    // the password used for encryption / decryption
    props.password = string(password);

    boost::filesystem::path pathAPI = GetDataDir() / ""APIcache.txt"";
    // Create a stream in input mode to open a file named APIcache.txt
    CryptoStreamPP stream(pathAPI.string(), props, std::ios::in | std::ios::binary);

    // Read in a buffer of data
    {
        QString Key = """";
        stream.seekg(0);
        char buffer[33];
        stream.read(buffer, 32);
        buffer[32] = '\0';

        // Should print out ""api key 32 digit""
        Key = buffer;
        ui-&gt;ApiKeyInput-&gt;setText(Key);
    }

    stream.flush();

    // now seek to digit 32 and read in api secret
    {
        QString Secret = """";
        stream.seekg(32);
        char buffer[33];
        stream.read(buffer, 32);
        buffer[32] = '\0';

        // Should print out ""api secret 32 digit""
        Secret = buffer;
        ui-&gt;SecretKeyInput-&gt;setText(Secret);
    }

    stream.flush();
    stream.close();

}
</code></pre>



<p>When printing ""password"" and ""API"" in ""on_SaveKeys_clicked()"". Both are correct.</p>

<p>When printing ""password"" in ""on_LoadKeys_clicked()"" it is correct.</p>

<p>When printing ""Key"" in ""on_LoadKeys_clicked()"" it is incorrect.</p>

<p>When printing ""Secret"" in ""on_LoadKeys_clicked()"" it is incorrect.</p>

<p>CryptoStreamPP can be found at <a href=""https://github.com/benhj/CryptoStreamPP/tree/master/cryptostreampp"" rel=""nofollow"">https://github.com/benhj/CryptoStreamPP/tree/master/cryptostreampp</a></p>
","","78","<c++><linux><crypto++>","0","","0","2015-12-01 03:25:09","","2","","608639","","2015-12-01 03:25:09","2015-11-29 06:12:06",""
"12246948","Does Crypto++ support TOFB-I?","<p>I'm developing a C++ application to decrypt the data encrypted by someone else with TOFB-I (TDEA Output Feedback - Interleaved).
To do this I'm using the Crypto++ library. </p>

<p>Unfortunately, the result of the decryption doesn't seem to work: the first byte is decrypted correctly, the rest is just meaningless data.
I've double checked with the Linux command line tool OpenSSL and get exactly the same result.
So I'm inclined to believe that I'm applying a decryption algorithm with wrong feedback, so that the first IV works fine but something goes wrong with the feedbacks.</p>

<p>My question is: how do I apply the interleaved variant of the DES_OFB mode?<br>
Couldn't find anything about this either in the Crypto++ or in the OpenSSL documentation.</p>
","<p>Apparently Crypto++ (and also OpenSSL) doesn't support TOFB-I operation mode:<br>
<a href=""http://csrc.nist.gov/groups/STM/cavp/documents/des/tripledesval.html"" rel=""nofollow"">http://csrc.nist.gov/groups/STM/cavp/documents/des/tripledesval.html</a></p>

<p>Actually, according to the above link no implementation has been validated yet as conforming to TOFB-I!</p>

<p>So I guess I'll need to implement my own TOFB-I algo.</p>
","78","<c++><des><crypto++>","1","1","1","2012-09-04 13:48:44","12264920","1","","","","","2012-09-03 11:28:30",""
"33686939","Unable to change compiler in Crypto++ GNUmakefile","<p>I'm trying to compile cryptopp with gcc49 on FreeBSD 10.x, however no matter how I instruct the Makefile to compile with g++49/gcc49, my attempts are ignored and it always compiles with c++. </p>

<p>I can't see at the moment where the compiler is defined in Makefile.</p>

<p>What I tried:</p>

<pre><code>ifeq ($(CXX),gcc)   # for some reason CXX is gcc on cygwin 1.1.4
CXX = g++49
endif
</code></pre>

<p>So I'd like the almighty of someone here to instruct it to compile with gcc49 (or g++49?) instead. Thanks!</p>

<p>Makefile:</p>

<pre><code>CXXFLAGS = -DNDEBUG -g -O2
#CXXFLAGS = -g
# -fPIC is supported. Please report any breakage of -fPIC as a bug.
# CXXFLAGS += -fPIC
# the following options reduce code size, but breaks link or makes link very slow on some systems
# CXXFLAGS += -ffunction-sections -fdata-sections
# LDFLAGS += -Wl,--gc-sections

ARFLAGS = -cr   # ar needs the dash on OpenBSD
RANLIB = ranlib
CP = cp
MKDIR = mkdir
EGREP = egrep
UNAME = $(shell uname)
ISX86 = $(shell uname -m | $(EGREP) -c ""i.86|x86|i86|amd64"")

# Default prefix for make install
ifeq ($(PREFIX),)
PREFIX = ..
endif

ifeq ($(CXX),gcc)   # for some reason CXX is gcc on cygwin 1.1.4
CXX = g++49
endif

ifeq ($(ISX86),1)

GCC42_OR_LATER = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c ""^gcc version (4.[2-9]|[5-9])"")
INTEL_COMPILER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\)"")
ICC111_OR_LATER = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""\(ICC\) ([2-9][0-9]|1[2-9]|11\.[1-9])"")
IS_SUN_CC = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun"")
GAS210_OR_LATER = $(shell echo """" | $(AS) -v 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.[1-9][0-9]|[3-9])"")
GAS217_OR_LATER = $(shell echo """" | $(AS) -v 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.1[7-9]|2\.[2-9]|[3-9])"")
GAS219_OR_LATER = $(shell echo """" | $(AS) -v 2&gt;&amp;1 | $(EGREP) -c ""GNU assembler version (2\.19|2\.[2-9]|[3-9])"")
ISMINGW = $(shell $(CXX) --version 2&gt;&amp;1 | $(EGREP) -c ""mingw"")

ifneq ($(GCC42_OR_LATER),0)
ifeq ($(UNAME),Darwin)
CXXFLAGS += -arch x86_64 -arch i386
else
CXXFLAGS += -march=native
endif
endif

ifneq ($(INTEL_COMPILER),0)
CXXFLAGS += -wd68 -wd186 -wd279 -wd327
ifeq ($(ICC111_OR_LATER),0)
# ""internal error: backend signals"" occurs on some x86 inline assembly with ICC 9 and some x64 inline assembly with ICC 11.0
# if you want to use Crypto++'s assembly code with ICC, try enabling it on individual files
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
endif
endif

ifeq ($(GAS210_OR_LATER),0) # .intel_syntax wasn't supported until GNU assembler 2.10
CXXFLAGS += -DCRYPTOPP_DISABLE_ASM
else
ifeq ($(GAS217_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_SSSE3
else
ifeq ($(GAS219_OR_LATER),0)
CXXFLAGS += -DCRYPTOPP_DISABLE_AESNI
endif
endif
ifeq ($(UNAME),SunOS)
CXXFLAGS += -Wa,--divide    # allow use of ""/"" operator
endif
endif

ifeq ($(ISMINGW),1)
LDLIBS += -lws2_32
endif

endif   # ISX86

ifeq ($(UNAME),)    # for DJGPP, where uname doesn't exist
CXXFLAGS += -mbnu210
else
CXXFLAGS += -pipe
endif

ifeq ($(UNAME),Linux)
LDFLAGS += -pthread
ifneq ($(shell uname -i | $(EGREP) -c ""(_64|d64)""),0)
M32OR64 = -m64
endif
endif

ifeq ($(UNAME),Darwin)
AR = libtool
ARFLAGS = -static -o
CXX = c++
IS_GCC2 = $(shell $(CXX) -v 2&gt;&amp;1 | $(EGREP) -c gcc-932)
ifeq ($(IS_GCC2),1)
CXXFLAGS += -fno-coalesce-templates -fno-coalesce-static-vtables
LDLIBS += -lstdc++
LDFLAGS += -flat_namespace -undefined suppress -m
endif
endif

ifeq ($(UNAME),SunOS)
LDLIBS += -lnsl -lsocket
M32OR64 = -m$(shell isainfo -b)
endif

ifneq ($(IS_SUN_CC),0)  # override flags for CC Sun C++ compiler
CXXFLAGS = -DNDEBUG -O -g0 -native -template=no%extdef $(M32OR64)
LDFLAGS =
AR = $(CXX)
ARFLAGS = -xar -o
RANLIB = true
SUN_CC10_BUGGY = $(shell $(CXX) -V 2&gt;&amp;1 | $(EGREP) -c ""CC: Sun .* 5\.10 .* (2009|2010/0[1-4])"")
ifneq ($(SUN_CC10_BUGGY),0)
# -DCRYPTOPP_INCLUDE_VECTOR_CC is needed for Sun Studio 12u1 Sun C++ 5.10 SunOS_i386 128229-02 2009/09/21 and was fixed in May 2010
# remove it if you get ""already had a body defined"" errors in vector.cc
CXXFLAGS += -DCRYPTOPP_INCLUDE_VECTOR_CC
endif
endif

SRCS = $(wildcard *.cpp)
ifeq ($(SRCS),)             # workaround wildcard function bug in GNU Make 3.77
SRCS = $(shell echo *.cpp)
endif

OBJS = $(SRCS:.cpp=.o)
# test.o needs to be after bench.o for cygwin 1.1.4 (possible ld bug?)
TESTOBJS = bench.o bench2.o test.o validat1.o validat2.o validat3.o adhoc.o datatest.o regtest.o fipsalgt.o dlltest.o
LIBOBJS = $(filter-out $(TESTOBJS),$(OBJS))

DLLSRCS = algebra.cpp algparam.cpp asn.cpp basecode.cpp cbcmac.cpp channels.cpp cryptlib.cpp des.cpp dessp.cpp dh.cpp dll.cpp dsa.cpp ec2n.cpp eccrypto.cpp ecp.cpp eprecomp.cpp files.cpp filters.cpp fips140.cpp fipstest.cpp gf2n.cpp gfpcrypt.cpp hex.cpp hmac.cpp integer.cpp iterhash.cpp misc.cpp modes.cpp modexppc.cpp mqueue.cpp nbtheory.cpp oaep.cpp osrng.cpp pch.cpp pkcspad.cpp pubkey.cpp queue.cpp randpool.cpp rdtables.cpp rijndael.cpp rng.cpp rsa.cpp sha.cpp simple.cpp skipjack.cpp strciphr.cpp trdlocal.cpp
DLLOBJS = $(DLLSRCS:.cpp=.export.o)
LIBIMPORTOBJS = $(LIBOBJS:.o=.import.o)
TESTIMPORTOBJS = $(TESTOBJS:.o=.import.o)
DLLTESTOBJS = dlltest.dllonly.o

all: cryptest.exe

test: cryptest.exe
    ./cryptest.exe v

clean:
    $(RM) cryptest.exe libcryptopp.a $(LIBOBJS) $(TESTOBJS) cryptopp.dll libcryptopp.dll.a libcryptopp.import.a cryptest.import.exe dlltest.exe $(DLLOBJS) $(LIBIMPORTOBJS) $(TESTIMPORTOBJS) $(DLLTESTOBJS)

install:
    $(MKDIR) -p $(PREFIX)/include/cryptopp $(PREFIX)/lib $(PREFIX)/bin
    $(CP) *.h $(PREFIX)/include/cryptopp
    $(CP) *.a $(PREFIX)/lib
    $(CP) *.so $(PREFIX)/lib
    $(CP) *.exe $(PREFIX)/bin

libcryptopp.a: $(LIBOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBOBJS)
    $(RANLIB) $@

libcryptopp.so: $(LIBOBJS)
    $(CXX) -shared -o $@ $(LIBOBJS)

cryptest.exe: libcryptopp.a $(TESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTOBJS) -L. -lcryptopp $(LDFLAGS) $(LDLIBS)

nolib: $(OBJS)      # makes it faster to test changes
    $(CXX) -o ct $(CXXFLAGS) $(OBJS) $(LDFLAGS) $(LDLIBS)

dll: cryptest.import.exe dlltest.exe

cryptopp.dll: $(DLLOBJS)
    $(CXX) -shared -o $@ $(CXXFLAGS) $(DLLOBJS) $(LDFLAGS) $(LDLIBS) -Wl,--out-implib=libcryptopp.dll.a

libcryptopp.import.a: $(LIBIMPORTOBJS)
    $(AR) $(ARFLAGS) $@ $(LIBIMPORTOBJS)
    $(RANLIB) $@

cryptest.import.exe: cryptopp.dll libcryptopp.import.a $(TESTIMPORTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(TESTIMPORTOBJS) -L. -lcryptopp.dll -lcryptopp.import $(LDFLAGS) $(LDLIBS)

dlltest.exe: cryptopp.dll $(DLLTESTOBJS)
    $(CXX) -o $@ $(CXXFLAGS) $(DLLTESTOBJS) -L. -lcryptopp.dll $(LDFLAGS) $(LDLIBS)

adhoc.cpp: adhoc.cpp.proto
ifeq ($(wildcard adhoc.cpp),)
    cp adhoc.cpp.proto adhoc.cpp
else
    touch adhoc.cpp
endif

%.dllonly.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_DLL_ONLY -c $&lt; -o $@

%.import.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_IMPORTS -c $&lt; -o $@

%.export.o : %.cpp
    $(CXX) $(CXXFLAGS) -DCRYPTOPP_EXPORTS -c $&lt; -o $@

%.o : %.cpp
    $(CXX) $(CXXFLAGS) -c $&lt;
</code></pre>
","<blockquote>
<pre><code>ifeq ($(CXX),gcc)   # for some reason CXX is gcc on cygwin 1.1.4
CXX = g++49
endif
</code></pre>
</blockquote>

<p>If I recall correctly, <code>CXX</code> is <code>g++</code> or <code>c++</code> on the BSDs, so you will never enter the <code>ifeq</code> block.</p>

<p>The easiest thing to do would probably be:</p>

<pre><code># GNUmakefile
CXXFLAGS = -DNDEBUG -g -O2 -fPIC
CXX=g++49
...
</code></pre>

<hr>

<p>It looks like you are using Crypto++ 5.6.2 or less because of this line:</p>

<pre><code>CXXFLAGS = -DNDEBUG -g -O2
</code></pre>

<p>5.6.3 and above works harder at honoring user's preferences. For example, in <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile"" rel=""nofollow"">5.6.3 GNUmakefile</a> (which is being tested for release):</p>

<pre><code># Base CXXFLAGS used if the user did not specify them
CXXFLAGS ?= -DNDEBUG -g2 -O2
</code></pre>

<p>The next-easiest thing to do would be to grab the <a href=""https://github.com/weidai11/cryptopp/blob/master/GNUmakefile"" rel=""nofollow"">5.6.3 GNUmakefile</a>, and then peform the following (<code>g++49</code> must be on-path):</p>

<pre><code>export CXX=g++49
make
</code></pre>

<p>I can assure you that works on 5.6.3 because I made the changes to facilitate testing under different compilers. You can also tweak <code>CXXFLAGS</code>:</p>

<pre><code>export CXX=/opt/intel/bin/icpc
export CXXFLAGS=""-DNDEBUG -g2 -O3 -wd68 -wd186""
make
</code></pre>

<hr>

<p>5.6.3 should be available in a couple of weeks. We are finishing up the mitigations for a <a href=""https://scan.coverity.com/projects/cryptopp"" rel=""nofollow"">Coverity scan/analysis</a>. Once they are mitigated, we have to perform a final round or <a href=""https://cryptopp.com/wiki/Release_Testing"" rel=""nofollow"">Release Testing</a>.</p>
","78","<compilation><crypto++>","1","0","1","2015-11-14 22:37:22","33714217","0","","608639","","2015-11-14 22:37:22","2015-11-13 06:15:04",""
"49495570","Cannot verify signature using C-style function calls","<p>The following prints FAIL and I cannot understand why:</p>

<pre><code>#include &lt;cryptopp/eccrypto.h&gt;
#include &lt;cryptopp/oids.h&gt;
#include &lt;cryptopp/osrng.h&gt;
#include &lt;iostream&gt;
using namespace std;
using namespace CryptoPP;
int main() {
    AutoSeededRandomPool prng;
    ECDSA&lt;ECP, SHA256&gt;::PrivateKey private_key;
    ECDSA&lt;ECP, SHA256&gt;::PublicKey public_key;
    private_key.Initialize( prng, ASN1::secp160r1() );
    private_key.MakePublicKey(public_key);
    ECDSA&lt;ECP, SHA256&gt;::Signer signer(private_key);
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(public_key);
    signer.AccessKey().Initialize(prng, ASN1::secp160r1());
    string signature(signer.MaxSignatureLength(), 0);
    string message = ""asdf"";
    auto signature_length = signer.SignMessage(
        prng, (const byte*)message.data(),
        message.size(), (byte*)signature.data());
    signature.resize(signature_length);
    bool verified = verifier.VerifyMessage(
        (const byte*)message.data(), message.size(),
        (const byte*)signature.data(), signature.size());
    if (verified)
        cout &lt;&lt; ""PASS"" &lt;&lt; endl;
    else
        cout &lt;&lt; ""FAIL"" &lt;&lt; endl;
}
</code></pre>

<p>It follows the instructions in crypto++ wiki: <a href=""https://www.cryptopp.com/wiki/ECDSA#Message_Signing"" rel=""nofollow noreferrer"">https://www.cryptopp.com/wiki/ECDSA#Message_Signing</a> and verifies with a public key derived from the private used to sign the same message. Should I switch to filters?</p>
","<blockquote>
  <p>The following prints FAIL and I cannot understand why:</p>
</blockquote>

<p>You are close. Looking at the wiki page there are a few problems. First, this is undefined behavior (it has been fixed on the wiki):</p>

<pre><code>auto signature_length = signer.SignMessage(
    prng, (const byte*)message.data(),
    message.size(), (byte*)signature.data());
</code></pre>

<p>To get the non-const pointer you need this instead (but it is not the cause of your issue):</p>

<pre><code>auto signature_length = signer.SignMessage(
    prng, (const byte*)&amp;message[0],
    message.size(), (byte*)&amp;signature[0]);
</code></pre>

<p>Second, when you call <code>Initialize</code> twice you whack the old configuration. ""Whack"" means you generate new parameters. Effectively you overwrote the other private key:</p>

<pre><code>private_key.Initialize( prng, ASN1::secp160r1() );
...
signer.AccessKey().Initialize(prng, ASN1::secp160r1());
</code></pre>

<p>It is not readily apparent, but the <code>Initialize</code> that takes a <code>prng</code> generates a new key. You want an <code>Initialize</code> that <em>does not</em> take a <code>prng</code>:</p>

<pre><code>private_key.Initialize( prng, ASN1::secp160r1() );
...
signer.AccessKey().Initialize(private_key);
</code></pre>

<p>Third, the page is not clear how to move between Signers/Verifiers and PublicKey/PrivateKey. Here are some other ways to do it for illustration purposes:</p>

<pre><code>cryptopp $ cat test.cxx
#include ""eccrypto.h""
#include ""oids.h""
#include ""osrng.h""
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier;

    signer.AccessKey().Initialize(prng, ASN1::secp160r1());
    signer.AccessKey().MakePublicKey(verifier.AccessKey());

    std::string signature(signer.MaxSignatureLength(), 0);
    std::string message = ""asdf"";

    auto signature_length = signer.SignMessage(
        prng, (const byte*)&amp;message[0],
        message.size(), (byte*)&amp;signature[0]);
    signature.resize(signature_length);

    bool verified = verifier.VerifyMessage(
        (const byte*)&amp;message[0], message.size(),
        (const byte*)&amp;signature[0], signature.size());

    if (verified)
        std::cout &lt;&lt; ""PASS"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""FAIL"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>I'm working from Crypto++ directory so the includes and command line are a little different:</p>

<pre class=""lang-none prettyprint-override""><code>cryptopp$ g++ -I . test.cxx ./libcryptopp.a -o test.exe
cryptopp$ ./test.exe
PASS
</code></pre>

<hr>

<p>If you want to use both Signers/Verifiers and PublicKey/PrivateKey then try something like:</p>

<pre><code>cryptopp$ cat test.cxx
#include ""eccrypto.h""
#include ""oids.h""
#include ""osrng.h""
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier;

    ECDSA&lt;ECP, SHA256&gt;::PrivateKey&amp; sKey = signer.AccessKey();
    sKey.Initialize(prng, ASN1::secp160r1());
    ECDSA&lt;ECP, SHA256&gt;::PublicKey&amp; pKey = verifier.AccessKey();
    sKey.MakePublicKey(pKey);

    std::string signature(signer.MaxSignatureLength(), 0);
    std::string message = ""asdf"";

    auto signature_length = signer.SignMessage(
        prng, (const byte*)&amp;message[0],
        message.size(), (byte*)&amp;signature[0]);
    signature.resize(signature_length);

    bool verified = verifier.VerifyMessage(
        (const byte*)&amp;message[0], message.size(),
        (const byte*)&amp;signature[0], signature.size());

    if (verified)
        std::cout &lt;&lt; ""PASS"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""FAIL"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<hr>

<p>This looks a little unusual:</p>

<pre><code>ECDSA&lt;ECP, SHA256&gt;::Signer signer;
...
signer.AccessKey().Initialize(prng, ASN1::secp160r1());
</code></pre>

<p>Typically you use <code>{secp160r1, SHA1}</code> or <code>{secp256k1, SHA256}</code>. That maintains the <a href=""https://www.cryptopp.com/wiki/Security_Level"" rel=""nofollow noreferrer"">Security Levels</a> of the system as a whole. When you use <code>{secp160r1, SHA256}</code> you are reducing the security level to about 80-bits because of <code>secp160r1</code>.</p>
","76","<c++><crypto++><ecdsa>","-1","0","1","2018-03-27 16:29:08","49498017","4","","","","","2018-03-26 15:48:30",""
"45502847","""program has stopped working"" when encrypting data in EAX mode","<p>I'm trying to encrypt a file using EAX mode, and then write the encrypted file on the disk, with the iv:</p>

<pre><code>//generate key
SecByteBlock key(AES::DEFAULT_KEYLENGTH);
rnd.GenerateBlock(key, key.size());

//generate iv
byte iv[AES::BLOCKSIZE];
rnd.GenerateBlock(iv, AES::BLOCKSIZE);
HexEncoder encoder(new FileSink(std::cout));

std::cout &lt;&lt; ""Key: "";
encoder.Put(key, key.size());
encoder.MessageEnd();
std::cout &lt;&lt; std::endl;

std::cout &lt;&lt; ""IV: "";
encoder.Put(iv, sizeof(iv));
encoder.MessageEnd();
std::cout &lt;&lt; std::endl;

EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

std::cout &lt;&lt; ""EAX set"" &lt;&lt; std::endl;

FileSink file(""iv_plus_message.enc"");
std::cout &lt;&lt; ""file created"" &lt;&lt; std::endl;

ArraySource write_iv(iv, sizeof(iv), true, new Redirector(file));
std::cout &lt;&lt; ""iv written to file"" &lt;&lt; std::endl;

StringSource write_ciphertext(plaintext, true,  //at this level,the executable stops working
    new StreamTransformationFilter(encryptor,
        new Redirector(file)));
std::cout &lt;&lt; ""end"" &lt;&lt; std::endl;
</code></pre>

<p>When I compile and execute this code, I get <em><code>.exe has stopped working</code></em>. The last thing printed is <em><code>iv written to file</code></em>, so the problem would be when it tries to encrypt the plaintext and append it to the file.</p>

<p>What is wrong with the code and how do I fix it?</p>
","<blockquote>
  <p>at this level,the executable stops working</p>
</blockquote>

<p>You should catch your exceptions. Wrap your program in a <a href=""https://stackoverflow.com/q/14866791/608639""><code>try</code> and <code>catch</code> block</a>, and you will see the information below.</p>

<pre class=""lang-none prettyprint-override""><code>terminate called after throwing an instance of 'CryptoPP::InvalidArgument'
  what():  StreamTransformationFilter: please use AuthenticatedEncryptionFilter and
AuthenticatedDecryptionFilter for AuthenticatedSymmetricCipher
Aborted (core dumped)
</code></pre>

<p>The <a href=""https://www.cryptopp.com/wiki/EAX_Mode"" rel=""nofollow noreferrer"">documentation for EAX</a> told you to use <code>AuthenticatedEncryptionFilter</code> and <code>AuthenticatedDecryptionFilter</code>.</p>

<hr>

<p>In the future, please provide a working <code>main</code>, and please remove the unneeded cruft. In the code you showed neither <code>fin</code> nor <code>open_file</code> was needed but I spent time converting it because it was causing compile errors.</p>

<p>This worked for me:</p>

<pre class=""lang-c++ prettyprint-override""><code>$ cat test.cxx

#include &lt;iostream&gt;
#include &lt;string&gt;

#include ""filters.h""
#include ""osrng.h""
#include ""files.h""
#include ""aes.h""
#include ""hex.h""
#include ""eax.h""
using namespace CryptoPP;

int main(int argc, char* argv[])
{
    try
    {
        AutoSeededRandomPool prng;

        SecByteBlock key(AES::DEFAULT_KEYLENGTH);
        prng.GenerateBlock(key, key.size());

        byte iv[AES::BLOCKSIZE];
        prng.GenerateBlock(iv, AES::BLOCKSIZE);

        HexEncoder encoder(new FileSink(std::cout));

        std::cout &lt;&lt; ""Key: "";
        encoder.Put(key, key.size());
        encoder.MessageEnd();
        std::cout &lt;&lt; std::endl;

        std::cout &lt;&lt; ""IV: "";
        encoder.Put(iv, sizeof(iv));
        encoder.MessageEnd();
        std::cout &lt;&lt; std::endl;

        EAX&lt;AES&gt;::Encryption encryptor;
        encryptor.SetKeyWithIV(key, key.size(), iv, sizeof(iv));

        std::cout &lt;&lt; ""EAX set"" &lt;&lt; std::endl;

        FileSink file(""iv_plus_message.enc"");
        std::cout &lt;&lt; ""file created"" &lt;&lt; std::endl;

        ArraySource write_iv(iv, sizeof(iv), true, new Redirector(file));
        std::cout &lt;&lt; ""iv written to file"" &lt;&lt; std::endl;

        std::string message = ""Now is the time for all good men to come to the aid of their country"";
        StringSource write_ciphertext(message, true,  //at this level,the executable stops working
            new AuthenticatedEncryptionFilter(encryptor,
                new Redirector(file)));
        std::cout &lt;&lt; ""end"" &lt;&lt; std::endl;
    }
    catch(const Exception&amp; ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}
</code></pre>

<p>And:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ -Wall test.cxx ./libcryptopp.a -o test.exe

$ ./test.exe
Key: 7DBBFEB8461B0D7019CBDC228790DD72
IV: C2638D0A874F674C02249BEF9ED96C5A
EAX set
file created
iv written to file
end

$ od -t x1 -An iv_plus_message.enc
 c2 63 8d 0a 87 4f 67 4c 02 24 9b ef 9e d9 6c 5a
 a7 e6 67 5d 76 60 99 dc 85 89 a8 ec 62 6c 40 4a
 00 d8 e8 c1 67 d8 92 99 5d 92 44 a3 ea 34 36 69
 ea 01 75 e4 03 7c 82 bf e2 90 77 cc d1 56 37 71
 31 d7 62 f7 b3 5f a9 3b f3 be 09 2d d4 b2 a5 99
 1d f6 85 34 93 d2 2e 71 60 be 53 96 dc 33 c3 92
 31 43 6a e9
</code></pre>

<hr>

<p>If you  want to encrypt a file, then change this:</p>

<pre class=""lang-c++ prettyprint-override""><code>std::string message = ""Now is the time for all good men to come to the aid of their country"";
StringSource write_ciphertext(message, true,
    new AuthenticatedEncryptionFilter(encryptor,
        new Redirector(file)));
</code></pre>

<p>To something like the below. Below, I encrypt the test program <code>test.cxx</code> because its handy. I think this was your <code>fin</code> or <code>open_file</code> that was not being used.</p>

<pre class=""lang-c++ prettyprint-override""><code>FileSource write_ciphertext(""test.cxx"", true,
    new AuthenticatedEncryptionFilter(encryptor,
        new Redirector(file)));
</code></pre>

<p>Then:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ -Wall test.cxx ./libcryptopp.a -o test.exe

$ ./test.exe
Key: 5FF94A36F677278A1A11F1AD95BE5F63
IV: 3120DDC6B08C60B080EEC01842023755
EAX set
file created
iv written to file
end

$ od -t x1 -An iv_plus_message.enc
 31 20 dd c6 b0 8c 60 b0 80 ee c0 18 42 02 37 55
 60 df 11 42 2b b1 24 d7 27 4a e0 ca ef 40 c0 ce
 87 29 97 7a d9 0c 40 91 61 da 74 2a 75 82 1a b8
 8b 76 2d 8c 15 98 31 69 a2 7e ac c4 da 83 e3 c5
 e7 1d 62 ab d5 6a 62 43 9a 19 f2 ed e7 a3 06 16
 d0 68 b7 55 a9 d7 4d fb 0d f0 d4 9c f4 01 0f 4f
 fd 78 ab d4 98 10 66 04 f7 a9 e3 b2 60 d9 09 0a
 ff fe a1 fa 22 17 6a bf 75 d8 11 d6 b9 1c c7 f6
 4c ac ef 2f 94 9f da d7 3d 4a 03 e0 61 58 41 0f
 64 01 1d ab a5 ab b7 b4 97 19 d7 41 82 52 df 8e
 89 de f8 ea 6f c7 c5 b8 97 0b 2f 1e f0 d5 e8 b8
 0b ef ce ba 13 d5 e9 db fa 59 76 a8 8c 22 b6 61
 6a 79 31 50 a8 69 3f ef 80 2d fc 0a 0b f9 b0 d4
 09 09 c1 7e 60 44 aa ec 1b 43 c0 be 4d ef 12 22
 1c 1c ad e3 a9 86 26 e6 84 e0 e1 9a 96 8c 21 2d
 5e b8 5d af 61 07 c8 3b 1a 31 5b a5 1e d5 e7 ad
 74 e2 3f 2f a2 f8 48 da db 8a 23 41 c6 e5 51 68
 7f e3 ad a0 e9 3b 47 58 9c 83 05 d6 17 87 58 eb
 e5 08 02 13 42 fa c5 77 1f 97 29 fc 94 db ff 8d
 15 83 63 cc e2 20 80 42 ae 43 62 05 5a a1 7f 1c
 47 ad c8 63 9d 70 d8 00 41 a4 31 18 df 25 db 73
 8c b2 47 78 29 31 61 3a 6f 16 af f6 64 e6 1a 79
 79 cb d4 39 7a 82 cc b7 b5 de d5 17 e7 7a 06 17
 a9 47 62 dc b8 17 39 11 e1 1d 00 58 d0 79 d6 1f
 a0 20 31 0e d9 a4 c0 42 78 3d 2f 9b 5b 09 43 6e
 c5 2e 57 f0 00 ac 76 1e 50 ff c7 60 72 68 e9 0b
 83 07 49 cc 52 64 ed 7f 6a ab 6d c8 d2 e3 d3 e0
 ca 64 3a 9b 7d 38 bb c1 e6 57 62 59 23 bf 63 ed
 06 a9 e2 55 dd 97 46 69 ec b4 b5 0e 3c 48 b6 25
 3a fc 5d 6f 1b 7d fc 6f 6a 1b e8 4d 74 b5 e0 72
 c6 18 d1 c6 ee 3d 92 e0 c2 b1 e8 06 78 de 36 f5
 c4 2a bc 01 bf e5 f9 51 3d fb f7 ec 7a af 71 00
 09 48 1f 19 9d 30 85 6d e4 97 b6 5c c4 ec 90 8b
 9f 56 19 ce 11 56 33 0f 1f e5 3a 78 fe 22 29 32
 8f 64 43 71 7f 70 44 d0 2e 6c 7c f0 0b da 70 86
 68 a9 b6 07 21 94 18 70 1e bc 6a 1c 99 a8 31 33
 ae 1e ce 4b 7e 1b 3b b2 bf 2d bf fa 7f 0f 05 1d
 0b a4 e1 7f b0 8b fd 31 c5 5c 69 d2 05 46 48 39
 36 cc cb 48 4e 5d 8b 10 53 ac bd 14 af 9b ea e4
 a4 73 75 61 12 d1 46 af 6b eb a9 70 4c 5d 37 8a
 ce ca 31 ec b1 67 2c 14 b7 54 10 a2 d3 d1 2e 5a
 30 99 ba 9c 9c e6 b9 e9 c9 a6 d7 51 83 48 7c 95
 6e 05 58 3b d7 28 9c b8 0f 3a 44 5a f4 e4 92 c9
 bf a6 f1 e7 dc 4e 66 9e f0 9b 94 0b 11 a8 46 ab
 fc e4 16 07 ca 26 d9 fd 10 57 32 85 82 b9 3c a6
 0d 21 9a 70 12 43 71 ee e2 75 f6 e5 07 94 dc c0
 cf de 63 79 a6 b8 5d 5e 82 f7 39 e1 84 68 76 c5
 c4 49 65 ce ea 9a d9 71 34 ef 74 ec 5c 94 c8 ae
 1d 8e 8c 1e ee 62 9b e0 0c 6f 91 50 8b 23 61 93
 6f 50 d1 a6 07 76 95 94 7a ea 94 b5 92 d3 d4 6d
 58 26 55 75 41 1c 4e 46 60 06 ee e5 36 8f 46 99
 3f 96 c9 dd 36 38 7e eb 6b 6d 43 7e e5 4e 03 d3
 e3 c0 33 cc a7 f5 91 91 8c 8d 5a 39 0f d6 84 a7
 0a c7 53 79 9b a7 96 e9 68 3f c7 71 e2 cc 6a 0a
 fe ae 58 32 1d 92 83 89 d1 bc 81 d7 f5 17 c9 f0
 6e 6c b5 12 dd f3 76 b2 5c a2 29 19 9b 77 ae 1c
 b6 8c b4 8e 64 31 bf ad 84 08 44 7c d5 ca ab af
 fb 78 29 c4 d2 98 a5 3b c2 29 af 83 27 1e 84 40
 48 f9 2c 9b a9 58 0a e3 b8 fe e1 77 14 70 dc fd
 83 d9 84 d8 03 13 d6 c5 cf 9a f1 ab d7 8f 5f 5f
 ee 1e 93 6c cd e5 d5 42 95 62 53 7e 6f 5c b7 44
 09 e1 2f 7d 3b b2 76 71 b9 3c 3a ea 7d e5 f4 d0
 f1 c0 ed be 45 a7 0f a7 de 9f 42 c6 0d b3 27 dc
 11 a0 e3 9c 1b 1f 09 72 7c 79 fe 54 2e 10 2c 1b
 6a fb 19 17 04 e6 1a 1d 6f 5e 36 43 f3 12 75 34
 4b e0 10 85 ed fa 63 7d ea 8a 2e 88 7e 25 40 d9
 6b 38 05 38 02 85 c5 3c 2f 93 d9 ff b2 e2 a1 f3
 fc 59 61 91 f5 19 40 8c a0 a1 f1 68 76 21 aa b2
 b7 2d 81 3d 31 c8 e6 1b d6 d7 37 2c 3d b2 a5 84
 42 d1 32 41 37 dd b6 86 4b 89 ac af 34 bf 66 5d
 7f bc 98 0a 25 f4 c2 14 b0 2f 99 21 70 04 59 f9
 ae f9 ae c9 2a ee 15 d3 89 24 47 0d 53 0c c8 d3
 71 c0 df e5 28 10 08 59 11 b4 1b bf c1 a1 44 74
 82 76 07 d7 31 e4 cd 62 5a a4 49 42 0e d2 c6 77
 aa b8 86 86 62 f2 d1 5b 9a 99 e6 60 3a ff c1 83
 97 ae 4f 2f 5a 47 e1 2b 87 84 00 a8 56 0c f9 e4
 a0 00 39 17 c6 d7 99 0e 3b 4f 0e 19 ba cc 7c d7
 de ab c8 a1 63 ef 65 6b 9c d2 55 fb b1 5c fa 04
 1a 6a 7e 03 30 9b ee a1 6f 9d 17 55 2a d1 cf 65
 eb 34 10 e0 4b 27 41 71 63 3b dd 57 7f a1 eb a2
 14 56 d0 d8 fc 33 06 57 9a 30 a5 d6 70 7e d0 70
 57 1d f2 ae d2 b8 67 82 77 ca 99 0f 8a b4 6f cd
 94 88 1a 0d 39 34 61 aa f9 0d e8 be ff 54 89 f0
 58 30 f1 e8 93 a2 10 83 c5 ce 28 81 d8 ec 10 4a
 68 9d d2 f3 a6 f6 32 5d da 18 aa 31 57 bb 57 6b
 c3 c2 4f 52 f8 f4 8e 97 88 e6 d9 f3 f1 2c a4 b2
 78 eb 6c 30 1e b8 99 b2 b8 41 fb fa b8 8e 21 3f
 45 2d 8f 80 b4 4b 6e b2 15 94 22 4d 1e 00 42 b8
 ab 37 42 19 4e 42 31 f9 55 fa 04 3d 83 a8 e2 1a
 92 00 a2 c4 9d ed 26 c1 6b 85 89 ec 01 cd 43 c8
 e6 00 6a 50 96 c3 1a 40 35 03 93 89 02 99 a7 64
 bd 0c 2d e6 80 b3 65 c5 af 43 0b 7c 88 ca 4a 82
 e3 76 d6 2c e3 8f 79 d9 bf e7 c6 31 26 6c bc 6f
 34 93 cc 61 b5 6f 07 58 84 ee 44 e8 a5 61 7b 52
 30 93 1d 2c dd 5c ad 93 ce e4 bc ba 19 49 ac 4a
 e5 5b 98 d1 aa a0 bf 8d a6 ef fc 43 d5 49 f6 6d
 1a 58 47 2c fa c4 7f b0 f0 01 21 29 02 cf 7f ae
 99 fc ca 90 e9 ae 53 3e 0d e7 8a da f4 1f 03 f7
 4c 19 69 8f 4b 19 84 6a b4 39 a9 73 44 49 bc ee
 f1 53 8e 63 d8 3a e5 09
</code></pre>
","76","<c++><exception-handling><try-catch><crypto++>","0","0","1","2017-08-05 07:51:28","","0","","608639","","2017-08-04 19:30:58","2017-08-04 09:15:50",""
"53643251","Crypto++ AES does not match standard fips197","<p>I'm writing a class which based on crypto++ library. 
This class a simple way for the encode and decode data using AES algorithm.
Here my code:</p>

<pre><code>class AESEncryption
{
public:
    static std::string decrypt(const std::string&amp; data, const std::string&amp; password);
    static std::string encrypt(const std::string&amp; data, const std::string&amp; password);
};
std::string AESEncryption::encrypt(const std::string&amp; data, const std::string&amp; password)
{
    std::vector&lt;CryptoPP::byte&gt; key(password.begin(), password.end());
    std::string result;
    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Encryption encryption;
    encryption.SetKey(key.data(), key.size());
    CryptoPP::StringSource(data, true, new CryptoPP::StreamTransformationFilter(encryption, new CryptoPP::StringSink(result)));

    return result;
}

std::string AESEncryption::decrypt(const std::string&amp; data, const std::string&amp; password)
{
    std::vector&lt;CryptoPP::byte&gt; key(password.begin(), password.end());
    std::string result;
    CryptoPP::ECB_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;
    decryption.SetKey(key.data(), key.size());
    CryptoPP::StringSource(data, true, new CryptoPP::StreamTransformationFilter(decryption, new CryptoPP::StringSink(result)));
    return result;
}
</code></pre>

<p>I began testing my class using samples from standard <a href=""https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf"" rel=""nofollow noreferrer"">fips197</a> (page 46)</p>

<p>Here my test code:</p>

<pre><code>namespace
{
    QByteArray key(QByteArray::fromHex(""000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F""));
    QByteArray plainText(QByteArray::fromHex(""00112233445566778899AABBCCDDEEFF""));
    QByteArray result(QByteArray::fromHex(""8EA2B7CA516745BFEAFC49904B496089""));
}

TEST(AESEncrypt, Valid)
{
    std::string key_str(key.begin(), key.end());
    std::string paintText_str(plainText.begin(), plainText.end());
    std::string expected_result(result.begin(), result.end());
    auto result = AESEncryption::encrypt(paintText_str, key_str);
    EXPECT_EQ(result, expected_result);
    auto decrypt = AESEncryption::decrypt(result, key_str);
    EXPECT_EQ(decrypt, paintText_str);
}
</code></pre>

<p>And I got the next result:</p>

<pre><code>Expected equality of these values:
  result
    Which is: ""\x8E\xA2\xB7\xCAQgE\xBF\xEA\xFCI\x90KI`\x89\x9F;u\x4\x92o\x8B\xD3n1\x18\xE9\x3\xA4\xCDJ""
  expected_result
    Which is: ""\x8E\xA2\xB7\xCAQgE\xBF\xEA\xFCI\x90KI`\x89""
</code></pre>

<p>I got useless data: </p>

<pre><code>\x9F;u\x4\x92o\x8B\xD3n1\x18\xE9\x3\xA4\xCDJ
</code></pre>

<p>How to fix it? What can I do which it encryption matches standard?</p>
","<blockquote>
<pre><code>Expected equality of these values:
  result
    Which is: ""\x8E\xA2\xB7\xCAQgE\xBF\xEA\xFCI\x90KI`\x89\x9F;u\x4\x92o\x8B\xD3n1\x18\xE9\x3\xA4\xCDJ""
  expected_result
    Which is: ""\x8E\xA2\xB7\xCAQgE\xBF\xEA\xFCI\x90KI`\x89""
</code></pre>
  
  <p>How to fix it? What can I do which it encryption matches standard?</p>
</blockquote>

<p>The FIPS 197 ECB mode tests are provided without padding. However, the code below uses PKCS padding which will add an additional 16-bytes due to the padding:</p>

<pre><code>StringSource(data, true, new StreamTransformationFilter(encryption, new StringSink(result)));
</code></pre>

<p>More correctly, ECB mode uses <code>DEFAULT_PADDING</code> by default, which is <code>PKCS_PADDING</code> for ECB mode and CBC mode. I think you should use <a href=""https://www.cryptopp.com/docs/ref/struct_block_padding_scheme_def.html"" rel=""nofollow noreferrer""><code>NO_PADDING</code></a> instead:</p>

<pre><code>StringSource(data, true, new StreamTransformationFilter(encryption, new StringSink(result), NO_PADDING));
</code></pre>

<p>Also see the docs for <a href=""https://www.cryptopp.com/docs/ref/class_stream_transformation_filter.html"" rel=""nofollow noreferrer""><code>StreamTransformationFilter</code></a>. This is what is happening with the filter you are using:</p>

<pre><code>StreamTransformationFilter (
    StreamTransformation &amp;c,
    BufferedTransformation *attachment=NULL,
    BlockPaddingScheme padding=DEFAULT_PADDING)
</code></pre>

<hr>

<p>Regarding <em>""Crypto++ AES does not match standard fips197""</em>, you can use the following to test the library with the FIPS 197 test vectors (in addition to SP800-38):</p>

<pre><code>$ ./cryptest.exe tv aes
Using seed: 1544068124

Testing SymmetricCipher algorithm AES/ECB.
....
Testing SymmetricCipher algorithm AES/CBC.
........
Testing SymmetricCipher algorithm AES/CFB.
.......
Testing SymmetricCipher algorithm AES/OFB.
....
Testing SymmetricCipher algorithm AES/CTR.
.............
</code></pre>
","75","<c++><aes><crypto++>","0","3","1","2018-12-06 04:33:35","53644337","1","","","","","2018-12-06 01:22:20",""
"40601847","Gargage redundancy character at the end of original text when decrypt using Crypto++","<p>I am using Crypto++, CTR mode, to encrypt and decrypt text in C++. Everything seem to worked 99%. Ecrypting success, decrypting is give back the original text too, but I given some extra random garbage redundancy text like 'ð', at the end of the decrypted text. This extra part is random generated each time I run the code. Is there something wrong in my code?</p>

<p><br />
Encrypt a string to a string</p>

<pre><code>string  encryptString(string plain, byte key[], int sizeKey, byte iv[], int sizeIV){
    string cipher;
    try{
        CTR_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true,
            new StreamTransformationFilter(e,
                new StringSink(cipher)
                ) 
            ); 

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return cipher;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return NULL;
    }
}
</code></pre>

<p>Decrypt a ciphered string to a string</p>

<pre><code>string  decryptString(string cipher, byte key[], int sizeKey, byte iv[], int sizeIV){
    string reco ="""";
    try{
        CTR_Mode&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        StringSource s(cipher, true,
            new StreamTransformationFilter(d,
                new StringSink(reco)
                ) 
            ); 

    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    }
    return reco;

}
</code></pre>

<p>Wrap encryptString function above.</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long &amp;len){
    string cipher = encryptString(plainText, key, sizeKey, iv, sizeIV);
    len = cipher.size() + 1;
    char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0'; // don't forget the terminating 0
    return writable;
 }
</code></pre>

<p>Wrap decryptString function above.</p>

<pre><code>char* decrypt(char * cipher,  byte key[], int sizeKey, byte iv[], int sizeIV, long len){
    string ss(cipher, len);
    long lengSS = ss.length();
    string recovered = decryptString(ss, key, sizeKey, iv, sizeIV);
    char * writable = new char[recovered.size() + 1];
    std::copy(recovered.begin(), recovered.end(), writable);
    writable[recovered.size()] = '\0'; // don't forget the terminating 0
    return writable;
}
</code></pre>

<p>My test script is simple. Read the some.txt content (""I love you""), write it to s1.txt to check if the reading is right. Encrypt, decrypt, then write the recovered text to another file (d1.txt).</p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    byte key[AES::DEFAULT_KEYLENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8', '1', '2', '3', '4', '5', '6', '7', '8' };
    //prng.GenerateBlock(key, sizeof(key));

    byte iv[AES::BLOCKSIZE] = { '8', '7', '6', '5', '4', '3', '2', '1', '8', '7', '6', '5', '4', '3', '2', '1' };
    prng.GenerateBlock(iv, sizeof(iv));
    long size = 0;
    char * s1 = FileUtil::readAllByte(""some.txt"");
    //Result: s1.txt content is ""I love you""

    long len = 0;
    char* result1 = encrypt(s1, key, sizeof(key), iv, sizeof(iv), len);
    //Result: result1 is a bunch of ciphered characters

    cout &lt;&lt; ""desc"" &lt;&lt; endl;
    char* recovered1 = decrypt(result1, key, sizeof(key), iv, sizeof(iv), len);
    //Result: recovered1=""I love youð"". Generally, it has form of ""I love youX""
    //X can be any garbage chatacter, and each time I run the code, X is one different
    //character.
}
</code></pre>

<p>According to the accept answer, Solution is: updated my encrypt() like this:</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long &amp;len){
    string cipher = encryptString(plainText, key, sizeKey, iv, sizeIV);
    FileUtil::writeFile(""ss1.txt"", cipher, cipher.length());
    len = cipher.size() ;
     char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0'; // don't forget the terminating 0
    FileUtil::writeFile(""w1.txt"",writable, len);

    return writable;
}
</code></pre>

<p>Just allocate writeable's length = cipher's length. Set the terminator at <code>writeble[len]</code></p>
","<p>That tends to happen when you have things like buffer overruns and unterminated strings.  If we look at your <code>encrypt</code> function we see a buffer overrun:</p>

<pre><code>len = cipher.size() + 1;
char * writable = new  char[len];
std::copy(cipher.begin(), cipher.end(), writable);
writable[len] = '\0';
</code></pre>

<p>See here you allocated <code>len</code> bytes, where <code>len</code> is one larger than <code>cipher</code>.  But when you terminate the string, you are using <code>len</code> to index which is out-of-bounds.</p>

<p>You should either use <code>len-1</code> or <code>cipher.size()</code> for the terminator index.</p>
","72","<c++><encryption><crypto++>","0","2","2","2016-11-15 12:43:48","40601935","0","","2874409","","2016-11-15 04:24:49","2016-11-15 04:06:56",""
"40601847","Gargage redundancy character at the end of original text when decrypt using Crypto++","<p>I am using Crypto++, CTR mode, to encrypt and decrypt text in C++. Everything seem to worked 99%. Ecrypting success, decrypting is give back the original text too, but I given some extra random garbage redundancy text like 'ð', at the end of the decrypted text. This extra part is random generated each time I run the code. Is there something wrong in my code?</p>

<p><br />
Encrypt a string to a string</p>

<pre><code>string  encryptString(string plain, byte key[], int sizeKey, byte iv[], int sizeIV){
    string cipher;
    try{
        CTR_Mode&lt; AES &gt;::Encryption e;
        e.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        // The StreamTransformationFilter removes
        //  padding as required.
        StringSource s(plain, true,
            new StreamTransformationFilter(e,
                new StringSink(cipher)
                ) 
            ); 

#if 0
        StreamTransformationFilter filter(e);
        filter.Put((const byte*)plain.data(), plain.size());
        filter.MessageEnd();

        const size_t ret = filter.MaxRetrievable();
        cipher.resize(ret);
        filter.Get((byte*)cipher.data(), cipher.size());
#endif
        return cipher;
    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
        return NULL;
    }
}
</code></pre>

<p>Decrypt a ciphered string to a string</p>

<pre><code>string  decryptString(string cipher, byte key[], int sizeKey, byte iv[], int sizeIV){
    string reco ="""";
    try{
        CTR_Mode&lt; AES &gt;::Decryption d;
        d.SetKeyWithIV(key, sizeKey, iv, sizeIV);

        StringSource s(cipher, true,
            new StreamTransformationFilter(d,
                new StringSink(reco)
                ) 
            ); 

    }
    catch (const CryptoPP::Exception&amp; e)
    {
        cerr &lt;&lt; e.what() &lt;&lt; endl;
    }
    return reco;

}
</code></pre>

<p>Wrap encryptString function above.</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long &amp;len){
    string cipher = encryptString(plainText, key, sizeKey, iv, sizeIV);
    len = cipher.size() + 1;
    char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0'; // don't forget the terminating 0
    return writable;
 }
</code></pre>

<p>Wrap decryptString function above.</p>

<pre><code>char* decrypt(char * cipher,  byte key[], int sizeKey, byte iv[], int sizeIV, long len){
    string ss(cipher, len);
    long lengSS = ss.length();
    string recovered = decryptString(ss, key, sizeKey, iv, sizeIV);
    char * writable = new char[recovered.size() + 1];
    std::copy(recovered.begin(), recovered.end(), writable);
    writable[recovered.size()] = '\0'; // don't forget the terminating 0
    return writable;
}
</code></pre>

<p>My test script is simple. Read the some.txt content (""I love you""), write it to s1.txt to check if the reading is right. Encrypt, decrypt, then write the recovered text to another file (d1.txt).</p>

<pre><code>int main(int argc, char* argv[])
{
    AutoSeededRandomPool prng;

    byte key[AES::DEFAULT_KEYLENGTH] = { '1', '2', '3', '4', '5', '6', '7', '8', '1', '2', '3', '4', '5', '6', '7', '8' };
    //prng.GenerateBlock(key, sizeof(key));

    byte iv[AES::BLOCKSIZE] = { '8', '7', '6', '5', '4', '3', '2', '1', '8', '7', '6', '5', '4', '3', '2', '1' };
    prng.GenerateBlock(iv, sizeof(iv));
    long size = 0;
    char * s1 = FileUtil::readAllByte(""some.txt"");
    //Result: s1.txt content is ""I love you""

    long len = 0;
    char* result1 = encrypt(s1, key, sizeof(key), iv, sizeof(iv), len);
    //Result: result1 is a bunch of ciphered characters

    cout &lt;&lt; ""desc"" &lt;&lt; endl;
    char* recovered1 = decrypt(result1, key, sizeof(key), iv, sizeof(iv), len);
    //Result: recovered1=""I love youð"". Generally, it has form of ""I love youX""
    //X can be any garbage chatacter, and each time I run the code, X is one different
    //character.
}
</code></pre>

<p>According to the accept answer, Solution is: updated my encrypt() like this:</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long &amp;len){
    string cipher = encryptString(plainText, key, sizeKey, iv, sizeIV);
    FileUtil::writeFile(""ss1.txt"", cipher, cipher.length());
    len = cipher.size() ;
     char * writable = new  char[len];
    std::copy(cipher.begin(), cipher.end(), writable);
    writable[len] = '\0'; // don't forget the terminating 0
    FileUtil::writeFile(""w1.txt"",writable, len);

    return writable;
}
</code></pre>

<p>Just allocate writeable's length = cipher's length. Set the terminator at <code>writeble[len]</code></p>
","<blockquote>
<pre><code>char* encrypt(char * plainText, ... );
char* decrypt(char * cipher, ... );
</code></pre>
</blockquote>

<p>You can also avoid <code>encryptString</code> and <code>decryptString</code> and the extra copy. I'll show you the <code>encrypt</code>, the <code>decrypt</code> is similar.</p>

<pre><code>char* encrypt(char * plainText, byte key[], int sizeKey, byte iv[], int sizeIV, long &amp;len)
{
    const unsigned long plainTextLen = len; len = 0;
    const unsigned long extraLen = plainTextLen+16;

    ArraySource source(plainText, plainTextLen, false);
    unique_ptr&lt;char[]&gt; writable(new char[extraLen]);
    ArraySink sink(writable, extraLen);

    CTR_Mode&lt; AES &gt;::Encryption enc;
    enc.SetKeyWithIV(key, sizeKey, iv, sizeIV);

    source.Detach(new StreamTransformationFilter(enc, new Redirector(sink)));
    source.PumpAll();

    len = sink.TotalPutLength();
    return writable.release();
}
</code></pre>

<p>I did not compile and run it, so you will have to clear the compiler issues in the code above. They should all be minor, like conversions and casts.</p>

<p>You usually don't need to worry about the <code>NULL</code>; just use the <code>ptr</code> and <code>len</code>. You can create a <code>std::string</code> from the decrypted ciphertext with <code>string recovered = string(ptr, len);</code>. <code>std::string</code> will produce a <code>NULL</code> when needed, but its usually not needed.</p>

<p><code>Detach</code> is <em>not</em> a typo. You use it to <code>Attach</code> a new filter and <code>delete</code> a previous filter. You use it to avoid memory leaks.</p>
","72","<c++><encryption><crypto++>","0","0","2","2016-11-15 12:43:48","40601935","0","","2874409","","2016-11-15 04:24:49","2016-11-15 04:06:56",""
"57872901","How to get signature length from signature body in Crypto++ ECDSA","<p>I use Crypto++ (libcrypto++ 1.11) to embed JWT in my application. I made methods to sign and verify messages with <code>CryptoPP::ECDSA&lt;CryptoPP::ECP, CryptoPP::SHA256&gt;</code> algorithm (with <code>secp256r1</code> curve). Tokens for verification can come from the outer world, so I need to verify token contents (textual data) signature knowing the public key.</p>

<p>The problem is that Crypto++ can cause SegFault on invalid signatures, which gives me a lot of pain in my web server.</p>

<p>I hoped that signatures in BER format (default serialization format in the library) have fixed length, so all I need is to compare the length of signature with some constant. However, I found out larger contents enables larger signatures, so a deeper approach is needed.</p>

<pre><code>bool ES256Verifier::Verify(const std::string&amp; data,
                           const std::string&amp; signature) {
    bool result = false;
    try {
      CryptoPP::StringSource ss(
          signature + data, true,
          new CryptoPP::SignatureVerificationFilter(
              verifier_,
              new CryptoPP::ArraySink((byte*)&amp;result, sizeof(result))));
    } catch (const CryptoPP::BERDecodeErr&amp; err) {
      LOG_WARNING() &lt;&lt; ""Signature `"" &lt;&lt; signature &lt;&lt; ""` has invalid (non-BER) format"";
    } catch (const CryptoPP::Exception&amp; ex) {
      LOG_WARNING() &lt;&lt; ""Signature verification has failed: "" &lt;&lt; ex.what();
    }
    return result;
}
</code></pre>

<p>Verifier <code>verifier_</code> is initialized correctly (and verifies tokens successfully apart from SegFaults), but given <code>data = """"</code> and <code>signature = """"</code>, for example, I always get SegFault:</p>

<pre><code>__memmove_avx_unaligned_erms 0x00007fb4b9da6b38
CryptoPP::ArraySink::Put2(unsigned char const*, unsigned long, int, bool) 0x00007fb4ba414fb2
CryptoPP::BufferedTransformation::ChannelPut2(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool) 0x00007fb4ba3acedc
CryptoPP::StringStore::CopyRangeTo2(CryptoPP::BufferedTransformation&amp;, unsigned long long&amp;, unsigned long long, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) const 0x00007fb4ba414e02
CryptoPP::BufferedTransformation::Peek(unsigned char*, unsigned long) const 0x00007fb4ba3ad74a
CryptoPP::Integer::Decode(CryptoPP::BufferedTransformation&amp;, unsigned long, CryptoPP::Integer::Signedness) 0x00007fb4ba45885c
CryptoPP::Integer::Decode(unsigned char const*, unsigned long, CryptoPP::Integer::Signedness) 0x00007fb4ba458c16
CryptoPP::DL_VerifierBase&lt;CryptoPP::ECPPoint&gt;::InputSignature pubkey.h:1560
CryptoPP::SignatureVerificationFilter::LastPut(unsigned char const*, unsigned long) 0x00007fb4ba4159a0
CryptoPP::FilterWithBufferedInput::PutMaybeModifiable(unsigned char*, unsigned long, int, bool, bool) 0x00007fb4ba418107
CryptoPP::BufferedTransformation::ChannelPut2(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, unsigned char const*, unsigned long, int, bool) 0x00007fb4ba3acedc
CryptoPP::BufferedTransformation::TransferMessagesTo2(CryptoPP::BufferedTransformation&amp;, unsigned int&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) 0x00007fb4ba3ad8fa
CryptoPP::BufferedTransformation::TransferAllTo2(CryptoPP::BufferedTransformation&amp;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;, bool) 0x00007fb4ba3adb21
CryptoPP::SourceTemplate&lt;CryptoPP::StringStore&gt;::PumpAll2 filters.h:1238
CryptoPP::Source::PumpAll filters.h:1182
CryptoPP::Source::SourceInitialize filters.h:1215
CryptoPP::StringSource::StringSource filters.h:1271
jwt::signature::algorithm::ES256Verifier::Verify es256_verifier.cpp:40
ES256_SignatureTest_Test::TestBody es256_test.cpp:29
...
</code></pre>

<p>So, is there a way to look at the data and signature and decide if this particular combination is going to cause SegFault due to invalid signature length?</p>
","<p>Here's some sample code to determine the signature length using the Field Element, Signer and Verifier. The first output prints the element length and <code>r||s</code> length because <code>r||s</code> is the signature in P1363 format.</p>

<p>The second and third output just print the result of <code>SignatureLength()</code>. Your program should reject a signature shorter than <code>SignatureLength()</code>. There is no sense in even trying to verify a short signature since it is no good.</p>

<p><em>Note well</em>: this only work for the <code>DL_*</code> signature schemes (based on discrete logs). It does not apply to <code>TF_*</code> signature schemes (based on trapdoor functions).</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""osrng.h""
#include ""oids.h""

#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;

    ///// Element
    DL_GroupParameters_EC&lt;ECP&gt; params(ASN1::secp256r1());

    unsigned int elemLength = params.GetCurve().GetField().MaxElementByteLength();
    std::cout &lt;&lt; ""Element length: "" &lt;&lt; elemLength &lt;&lt; std::endl;
    std::cout &lt;&lt; ""r||s length: "" &lt;&lt; 2*elemLength &lt;&lt; std::endl;

    ///// Signer
    ECDSA&lt;ECP, SHA256&gt;::Signer signer;
    signer.AccessKey().Initialize(prng, params);

    unsigned int signerLength = signer.SignatureLength();
    std::cout &lt;&lt; ""Signer signature length: "" &lt;&lt; signerLength &lt;&lt; std::endl;

    ///// Verifier
    ECDSA&lt;ECP, SHA256&gt;::Verifier verifier(signer);

    unsigned int verifierLength = verifier.SignatureLength();
    std::cout &lt;&lt; ""Verifier signature length: "" &lt;&lt; verifierLength &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Running the program results in the following.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Element length: 32
r||s length: 64
Signer signature length: 64
Verifier signature length: 64
</code></pre>

<p>And if you switch curves to <code>ASN1::secp521r1()</code>, then running the program results in the following.</p>

<pre class=""lang-none prettyprint-override""><code>$ ./test.exe
Element length: 66
r||s length: 132
Signer signature length: 132
Verifier signature length: 132
</code></pre>
","69","<c++><crypto++><ecdsa>","1","1","1","2019-10-07 02:52:16","57949305","5","","3995009","","2019-09-10 14:46:33","2019-09-10 14:24:31",""
"42148025","Converting Node.js HMAC to C++","<p>Ive been working on a project, and as part of it I need to convert the Node.js code </p>

<pre><code>var hash = crypto.createHmac('sha512', key).update(text).digest('hex');
</code></pre>

<p>to C++. I've decided to use Crypto++, leading to the following code:</p>

<pre><code>//Creating the key from an integer instead of a string or byte array
char bytes[sizeof key];
std::copy(static_cast&lt;const char*&gt;(static_cast&lt;const void*&gt;(&amp;key)),
    static_cast&lt;const char*&gt;(static_cast&lt;const void*&gt;(&amp;key)) + sizeof key,
    bytes);
SecByteBlock key(bytes, sizeof(bytes));

//Create HMAC using server seed as key and client seed as message
HMAC&lt; SHA512 &gt; hmac(key, key.size());
string plain = ""HMAC Test"";
string mac, encoded;

StringSource ss2(text, true, new HashFilter(hmac, new StringSink(mac)) /* HashFilter*/);
</code></pre>

<p>Are these two code blocks equivalent? I'm much more familiar with JS so I'm not certain the C++ code is entirely correct in function.</p>
","","68","<c++><node.js><hmac><crypto++>","1","","0","2017-02-09 22:24:22","","2","","","","","2017-02-09 22:24:22",""
"29078685","Does a filter / StringSink allocated with new require a delete?","<p>Consider the code line:</p>

<pre><code>StringSource( cipher ,
              true   ,
              new PK_DecryptorFilter( rng       ,
                                      decrypter ,
                                      new StringSink( plainText ) ) );
</code></pre>

<p>The filter and the <code>StringSink</code> object get created using <code>new</code> now I'm curious whether I'm responsible for deleting those as I'm unsure how I would do that since I would need the pointers to these objects.</p>

<p>When looking at the test projects I can't seem to find a delete so I'm guessing these objects automatically get deleted once their job is fulfillled.</p>

<p>But since documentations can be wrong I figured I'd make sure.</p>
","<p>Looking at the <a href=""http://www.cryptopp.com/docs/ref/filters_8h_source.html"" rel=""nofollow"">header</a> and <a href=""http://www.cryptopp.com/docs/ref/filters_8cpp_source.html"" rel=""nofollow"">source</a> for those classes, both of them end up assigning their attachment to a <code>member_ptr</code> which deals with the deletion automatically. You shouldn't delete them yourself, just let the library handle it.</p>
","68","<c++><new-operator><crypto++><delete-operator>","1","2","2","2015-03-23 04:06:45","29078864","1","","","","","2015-03-16 14:00:09",""
"29078685","Does a filter / StringSink allocated with new require a delete?","<p>Consider the code line:</p>

<pre><code>StringSource( cipher ,
              true   ,
              new PK_DecryptorFilter( rng       ,
                                      decrypter ,
                                      new StringSink( plainText ) ) );
</code></pre>

<p>The filter and the <code>StringSink</code> object get created using <code>new</code> now I'm curious whether I'm responsible for deleting those as I'm unsure how I would do that since I would need the pointers to these objects.</p>

<p>When looking at the test projects I can't seem to find a delete so I'm guessing these objects automatically get deleted once their job is fulfillled.</p>

<p>But since documentations can be wrong I figured I'd make sure.</p>
","<blockquote>
  <p>Does a filter / StringSink allocated with new require a delete?</p>
</blockquote>

<p>In the case you provided, the answer is NO. You don't need to delete it. From <code>Readme.txt</code> under <em>Important Usage Notes</em>:</p>

<blockquote>
  <ol>
  <li>If a constructor for A takes a pointer to an object B (except primitive types such as int and char), then A owns B and will delete B
  at A's destruction.  If a constructor for A takes a reference to an
  object B, then the caller retains ownership of B and should not
  destroy it until A no longer needs it. </li>
  </ol>
</blockquote>

<p>Also see the Crypto++ wiki page on <a href=""http://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Pipelining</a>. Its a higher level design perspective, and object ownership is a detail of it.</p>

<hr>

<p>There's a second important note listed in the <code>Readme.txt</code>. Here it is:</p>

<blockquote>
  <ol start=""2"">
  <li>Crypto++ is thread safe at the class level. This means you can use Crypto++ safely in a multithreaded application, but you must provide
  synchronization when multiple threads access a common Crypto++ object.</li>
  </ol>
</blockquote>
","68","<c++><new-operator><crypto++><delete-operator>","1","0","2","2015-03-23 04:06:45","29078864","1","","","","","2015-03-16 14:00:09",""
"36940255","Determine use of CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE at runtime","<p>We are using Crypto++ 5.6.3 and compiling with g++ on CentOS 6. Is it possible to determine at runtime if our application has linked with a libcryptopp that was built with <code>CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE</code> as <code>1</code> or <code>0</code>?</p>

<p>Thank you</p>
","<blockquote>
  <p>Is it possible to determine at runtime if our application has linked with a libcryptopp that was built with CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE as 1 or 0?</p>
</blockquote>

<p>No, its not. As a matter of fact, you won't even be able to tell if you are using AES-NI or the software implementation.</p>

<p>There's been some talk about stashing <code>CXXFLAGS</code> away for future use like this (and printing them from the <code>cryptest.exe</code> program), but its very low priority. So low there's been no bug report on it to stage the work.</p>

<p><strong><em>EDIT</em></strong>: now open on the Crypto++ mailing list: <a href=""http://groups.google.com/forum/#!topic/cryptopp-users/VxTTf9sT8Wk"" rel=""nofollow"">GNUmakefile and 'make flag' recipe</a>.</p>

<hr>

<p>The Crypto++ test suite prints a value for the macro. It comes from <a href=""http://github.com/weidai11/cryptopp/blob/master/validat1.cpp#L311"" rel=""nofollow"">validat1.cpp</a>, around line 310:</p>

<pre><code>cout &lt;&lt; ""AESNI_INTRINSICS == "" &lt;&lt; CRYPTOPP_BOOL_AESNI_INTRINSICS_AVAILABLE &lt;&lt; endl;
</code></pre>

<p>But as I think you are aware, the library build settings and your build settings could be different.</p>

<hr>

<p>It also noteworthy that Crypto++ uses a makefile, while distros often build using Autotools. The distros select their own flags, and they may be different from the Crypto++ makefile. When using the distro, you may be able to check a <code>*.pc</code> file or similar.</p>

<p>Related, we test on CentOS 5 through CentOS 7. CentOS 5 is a nice machine because its got GCC 4.1, and that version of GCC kind of particular about some things. For example, it cannot consume <code>-march=native</code>.</p>
","68","<linux><crypto++>","1","0","1","2016-04-30 00:05:57","36942324","0","","608639","","2016-04-29 15:41:57","2016-04-29 13:56:15",""
"58436989","Reason for the signature of Crypto++ PKCS5_PBKDF2_HMAC class?","<p>In the Crypto++ manual for <a href=""https://www.cryptopp.com/docs/ref/class_p_k_c_s5___p_b_k_d_f2___h_m_a_c.html"" rel=""nofollow noreferrer"">PKCS5_PBKDF2_HMAC</a> there are two signatures of DeriveKey.</p>

<p>First:</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen, const byte *secret, size_t secretLen, const NameValuePairs &amp;params=g_nullNameValuePairs) const
</code></pre>

<p>Second:</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen, byte purpose, const byte *secret, size_t secretLen, const byte *salt, size_t saltLen, unsigned int iterations, double timeInSeconds=0) const
</code></pre>

<p>I would like to understand the purpose of the last parameter in the first signature. 
<code>NameValuePairs &amp;params=g_nullNameValuePairs</code>.</p>

<p>Unfortunately in the documentation I did not find an usage example.
Generally, my aim is to replace the calls of the second function with nullptr salts to first  but at the same time I need to send  <code>unsigned int iterations, double timeInSecond</code>.</p>
","<p>For your fist case, this signature is part of the <a href=""https://cryptopp.com/docs/ref/class_key_derivation_function.html"" rel=""nofollow noreferrer""><code>KeyDerivationFunction</code></a> interface. Nearly all KDF's derive from it. The only KDF that does not derive from it is <code>P1363_KDF2</code>, which is used as a mask generation function in padding schemes.</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen,
                   const byte *secret, size_t secretLen,
                   const NameValuePairs &amp;params=g_nullNameValuePairs) const
</code></pre>

<p>This signature was selected because the essence of a KDF is to takes a seed or secret, and output derived keying material. Other parameters, like usage, iteration count or memory cost, are value added parameters.</p>

<p>The <code>NameValuePairs</code> allow passing of arbitrary parameters. It is needed because KDF parameters vary wildly. For example, early PBKDF often use a single ""usage"" octet and ""iteration count"" in its derivation; while Scrypt uses ""memory hardness"" or ""cost"" in its derivation. With <code>NameValuePairs</code> those varying parameters can be passed through a consistent interface.</p>

<p>The <code>KeyDerivationFunction</code> class also provides a few helpers, like <code>MinDerivedKeyLength</code>, <code>MaxDerivedKeyLength</code>, <code>GetValidDerivedLength</code> and <code>IsValidDerivedLength</code>. <code>GetValidDerivedLength</code> is a virtual function, and all derived classes must implement it.</p>

<p>For your second case, this signature is more specialized. It is retained because it was present in the early days of Crypto++. It handles several old KDFs like <code>P1363_KDF2</code>, <code>PKCS12_PBKDF</code>, <code>PKCS5_PBKDF2_HMAC</code>, but fails to handle newer KDFs, like Argon, HKDF and Scrypt.</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen,
                   byte purpose,
                   const byte *secret, size_t secretLen,
                   const byte *salt, size_t saltLen,
                   unsigned int iterations, double timeInSeconds=0) const
</code></pre>

<p>If we wanted to handle modern KDFs, then the newer signature with more parameters would look something like:</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen,
                   byte purpose,
                   const byte *secret, size_t secretLen,
                   const byte *salt, size_t saltLen,
                   const byte *pepper, size_t pepperLen,  // additional data
                   const byte *info, size_t infoLen,      // additional data
                   word32 iterations,
                   word32 version,           // Argon2
                   word32 type,              // Argon2
                   word32 rho,               // Argon2
                   word64 memsize,           // Argon2
                   word64 cost,              // Scrypt
                   word64 blockSize,         // Scrypt
                   word64 parallelization    // Scrypt
                   double timeInSeconds=0 ) const
</code></pre>

<p>As you can see, this is getting out of hand quickly.</p>

<p>So what we now do is, use the <code>KeyDerivationFunction</code> interface and pass parameters through <code>NameValuePairs</code>:</p>

<pre><code>std::string pass(""password""), salt(""NaCl"");
word64 cost=1024, blockSize=8, parallelization=16;

AlgorithmParameters params = MakeParameters(""Cost"", cost)
    (""BlockSize"", blockSize)(""Parallelization"", parallelization)
    (""Salt"", ConstByteArrayParameter((const byte*)&amp;salt[0], salt.size()));

SecByteBlock derived(64);
scrypt.DeriveKey(derived, derived.size(), ConstBytePtr(pass), BytePtrSize(pass), params);
</code></pre>

<p>However, nothing forbids a derived class like HKDF or Scrypt from providing a overloaded <code>DeriveKey</code> that only accepts its exact parameters, and that is what HKDF, Scrypt and other KDFs do.</p>

<p>Here is Scrypt's overload. These are the exact parameters used in <code>DeriveKey</code>:</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen,
                   const byte *secret, size_t secretLen,
                   const byte *salt, size_t saltLen, 
                   word64 cost=2, word64 blockSize=8,
                   word64 parallelization=1) const
</code></pre>

<p>And here is HKDF's overloaded <code>DeriveKey</code>. These are the exact parameters used in its derivation function:</p>

<pre><code>size_t  DeriveKey (byte *derived, size_t derivedLen, 
                   const byte *secret, size_t secretLen,
                   const byte *salt, size_t saltLen,
                   const byte *info, size_t infoLen) const
</code></pre>

<hr>

<p>Note the new <code>KeyDerivationFunction</code> interface with the <code>NameValuePair</code> was added at Crypto++ 6.2 under Issue 610:</p>

<ul>
<li><a href=""https://github.com/weidai11/cryptopp/issues/610"" rel=""nofollow noreferrer"">Issue 610</a></li>
</ul>

<p>Here is some more reading from the Crypto++ wiki:</p>

<ul>
<li><a href=""https://www.cryptopp.com/wiki/KeyDerivationFunction"" rel=""nofollow noreferrer"">KeyDerivationFunction</a></li>
<li><a href=""https://www.cryptopp.com/wiki/NameValuePairs"" rel=""nofollow noreferrer"">NameValuePairs</a></li>
<li><a href=""https://www.cryptopp.com/wiki/P1363_KDF2"" rel=""nofollow noreferrer"">P1363_KDF2</a></li>
<li><a href=""https://www.cryptopp.com/wiki/PKCS12_PBKDF"" rel=""nofollow noreferrer"">PKCS12_PBKDF</a></li>
<li><a href=""https://www.cryptopp.com/wiki/PKCS5_PBKDF1"" rel=""nofollow noreferrer"">PKCS5_PBKDF1</a></li>
<li><a href=""https://www.cryptopp.com/wiki/PKCS5_PBKDF2_HMAC"" rel=""nofollow noreferrer"">PKCS5_PBKDF2_HMAC</a></li>
<li><a href=""https://www.cryptopp.com/wiki/HKDF"" rel=""nofollow noreferrer"">HKDF</a>, <a href=""https://www.cryptopp.com/wiki/Scrypt"" rel=""nofollow noreferrer"">Scrypt</a></li>
</ul>
","68","<c++><interface><crypto++>","1","0","1","2019-10-20 09:03:12","58449058","2","","608639","","2019-10-18 10:56:57","2019-10-17 16:22:20",""
"49541666","Build issue with Crypto++ 5.6.5 using Linux command line g++","<p>I'm trying to run this example utilizing Crypto++library, and I downloaded/stored Crypto++ in <code>/home/thirdparty/cryptopp</code>. However, when run the following command line:</p>

<pre class=""lang-none prettyprint-override""><code>g++ -I/home/thirdParty channelSwitch.cpp -L/home/thirParty -o test-cs.exe
</code></pre>

<p>Can someone help check what is the problem?</p>

<pre class=""lang-none prettyprint-override""><code>/tmp/ccPnCG56.o: In function `main':
channelSwitch.cpp:(.text+0x178): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
channelSwitch.cpp:(.text+0x21b): undefined reference to `CryptoPP::DEFAULT_CHANNEL'
channelSwitch.cpp:(.text+0x221): undefined reference to `CryptoPP::DEFAULT_CHANNEL'
channelSwitch.cpp:(.text+0x237): undefined reference to `CryptoPP::HashFilter::HashFilter(CryptoPP::HashTransformation&amp;, CryptoPP::BufferedTransformation*, bool, int, std::string const&amp;, std::string const&amp;)'
channelSwitch.cpp:(.text+0x292): undefined reference to `CryptoPP::StringSinkTemplate&lt;std::string&gt;::StringSinkTemplate(std::string&amp;)'
channelSwitch.cpp:(.text+0x31d): undefined reference to `CryptoPP::DEFAULT_CHANNEL'
channelSwitch.cpp:(.text+0x323): undefined reference to `CryptoPP::DEFAULT_CHANNEL'
channelSwitch.cpp:(.text+0x339): undefined reference to `CryptoPP::HashFilter::HashFilter(CryptoPP::HashTransformation&amp;, CryptoPP::BufferedTransformation*, bool, int, std::string const&amp;, std::string const&amp;)'
...
collect2: error: ld returned 1 exit status
</code></pre>

<p>The complete source code for <code>channelSwitch.cpp</code> is: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cryptopp/channels.h&gt; 
#include &lt;cryptopp/filters.h&gt; 
#include &lt;cryptopp/sha.h&gt; 
#include &lt;cryptopp/hex.h&gt;

int main(int argc, char *argv[]) {
std::string message = ""Now is the time for all good men to come to the aide of their country"";

// Allow user to override default message from command line arg.
if(argc == 2 &amp;&amp; argv[1] != NULL) 
    message = std::string(argv[1]);

// Set hash variables
std::string s1, s2, s3, s4;
CryptoPP::SHA1 sha1; CryptoPP::SHA224 sha224; CryptoPP::SHA256 sha256; CryptoPP::SHA512 sha512;

// Run hash functions
CryptoPP::HashFilter f1(sha1, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s1)));
CryptoPP::HashFilter f2(sha224, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s2)));
CryptoPP::HashFilter f3(sha256, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s3)));
CryptoPP::HashFilter f4(sha512, new CryptoPP::HexEncoder(new CryptoPP::StringSink(s4)));

// Set route to default
CryptoPP::ChannelSwitch cs;
cs.AddDefaultRoute(f1);
cs.AddDefaultRoute(f2);
cs.AddDefaultRoute(f3);
cs.AddDefaultRoute(f4);

CryptoPP::StringSource ss(message, true /*pumpAll*/, new CryptoPP::Redirector(cs));

std::cout &lt;&lt; ""Message: "" &lt;&lt; message &lt;&lt; std::endl;
std::cout &lt;&lt; ""SHA-1: "" &lt;&lt; s1 &lt;&lt; std::endl;
std::cout &lt;&lt; ""SHA-224: "" &lt;&lt; s2 &lt;&lt; std::endl;
std::cout &lt;&lt; ""SHA-256: "" &lt;&lt; s3 &lt;&lt; std::endl;
std::cout &lt;&lt; ""SHA-512: "" &lt;&lt; s4 &lt;&lt; std::endl;
return 0;
}
</code></pre>

<p>Environment information:</p>

<pre class=""lang-none prettyprint-override""><code>$ gcc --version
gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)
</code></pre>
","<p>I know what the problem is. should make install first. Thanks!</p>
","65","<c++><g++><crypto++>","1","0","1","2018-03-30 05:04:12","","2","","608639","","2018-03-30 05:04:12","2018-03-28 18:27:39",""
"56945847","StreamTransformationFilter: invalid PKCS #7 block padding found using AES decryption","<p>I am trying to perform AES decryption using the <code>crypto++</code> library. I have an encrypted file whose first 8 bytes are the filelength, subsequent 16 bytes are the initialization vector, and the remaining data is the data of interest. I also have a string representation of my key (which I hash using SHA256)</p>

<p>I get the following error when trying to perform AES decryption:
<code>StreamTransformationFilter: invalid PKCS #7 block padding found</code></p>

<p>I am using the following c++ code:</p>

<pre><code>std::string keyStr = ""my_key"";
std::string infilePath = ""my/file/path"";


CryptoPP::SHA256 hash;
unsigned char digest[CryptoPP::SHA256::DIGESTSIZE];

hash.CalculateDigest( digest, reinterpret_cast&lt;const unsigned char*&gt;(&amp;keyStr[0]), keyStr.length() );
auto key = CryptoPP::SecByteBlock(digest, CryptoPP::SHA256::DIGESTSIZE);

std::ifstream fin(infilePath, std::ifstream::binary);

// First 8 bytes is the file size
std::vector&lt;char&gt; fileSizeVec(8);
fin.read(fileSizeVec.data(), fileSizeVec.size());

// Read the next 16 bytes to get the initialization vector
std::vector&lt;char&gt; ivBuffer(16);
fin.read(ivBuffer.data(), ivBuffer.size());
CryptoPP::SecByteBlock iv(reinterpret_cast&lt;const unsigned char*&gt;(ivBuffer.data()), ivBuffer.size());

// Create a CBC decryptor
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;
decryption.SetKeyWithIV(key, sizeof(key), iv);

CryptoPP::StreamTransformationFilter decryptor(decryption);

std::vector&lt;char&gt; buffer(CHUNK_SIZE, 0);

while(fin.read(buffer.data(), buffer.size())) {
    CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), buffer.size());
    decryptor.Put(tmp, tmp.size());
        }

decryptor.MessageEnd();
size_t retSize = decryptor.MaxRetrievable();

std::vector&lt;char&gt; decryptedBuff;
decryptedBuff.resize(retSize);

decryptor.Get(reinterpret_cast&lt;CryptoPP::byte*&gt;(decryptedBuff.data()), decryptedBuff.size());
</code></pre>

<p>I am not sure what is giving me the error. I am working off the following python code. When I run the python code with the same input file, it successfully decrypts the file. </p>

<pre><code>def decrypt_file(in_filename, out_filename=None):
    key = hashlib.sha256(PASSWORD).digest()
    """"""loads and returns the embedded model""""""
    chunksize = 24 * 1024
    if not out_filename:
        out_filename = os.path.splitext(in_filename)[0]

    with open(in_filename, 'rb') as infile:
        # get the initial 8 bytes with file size
        tmp = infile.read(8)
        iv = infile.read(16)
        decryptor = AES.new(key, AES.MODE_CBC, iv)
        string = b''
        # with open(out_filename, 'wb') as outfile:
        while True:
            chunk = infile.read(chunksize)
            if len(chunk) == 0:
                break
            string += decryptor.decrypt(chunk)
    return string
</code></pre>

<p>In addition to solving the error, I would also love some general c++ coding feedback on how I can improve. </p>

<p>Thanks in advance!</p>

<p><strong>Edit:</strong>
It looks like I wasn't reading the input file all the way to the end (as the length of the last chunk is smaller than <code>CHUNK_SIZE</code>). The following code now reads the entire file, however I still get the same issue. I have also confirmed that the <code>IV</code> and <code>key</code> match exactly that produced from the python code.</p>

<pre><code> // Get the length of the file in bytes
fin.seekg (0, fin.end);
size_t fileLen = fin.tellg();
fin.seekg (0, fin.beg);

std::vector&lt;char&gt; buffer(CHUNK_SIZE, 0);
size_t readSize = CHUNK_SIZE;

while(fin.read(buffer.data(), readSize)) {
     CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), CHUNK_SIZE);
     decryptor.Put(tmp, tmp.size());

      std::fill(buffer.begin(), buffer.end(), 0);

      size_t bytesReamining = fileLen - fin.tellg();
      readSize = CHUNK_SIZE &lt; bytesReamining ? CHUNK_SIZE : bytesReamining;

       if (!readSize)
            break;
        }
}
</code></pre>

<p>Note that I have tried this line as both <code>CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), CHUNK_SIZE);</code>
and <code>CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), readSize);</code> (Using <code>CHUNK_SIZE</code> pads with <code>0</code>)</p>
","<p>Looks like the issue had to do with padding. I instead switched to using a <code>StringSource</code>, which only worked once I specified <code>CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme::ZEROS_PADDING</code> as an argument for <code>StreamTransformationFilter</code></p>

<p>Here is the working code for anyone that is interested:</p>

<pre><code>    void Crypto::decryptFileAES(CryptoPP::SecByteBlock key, std::string infilePath) {
        std::ifstream fin(infilePath, std::ifstream::binary);

        // Get the length of the file in bytes
        fin.seekg (0, fin.end);
        size_t fileLen = fin.tellg();
        fin.seekg (0, fin.beg);

        // First 8 bytes is the file size
        std::vector&lt;char&gt; fileSizeVec(8);
        fin.read(fileSizeVec.data(), fileSizeVec.size());

        // Read the first 16 bytes to get the initialization vector
        std::vector&lt;char&gt; ivBuffer(16);
        fin.read(ivBuffer.data(), ivBuffer.size());
        CryptoPP::SecByteBlock iv(reinterpret_cast&lt;const unsigned char*&gt;(ivBuffer.data()), ivBuffer.size());

        // Create a CBC decryptor
        CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;
        decryption.SetKeyWithIV(key, sizeof(key), iv);

        size_t bytesReamining = fileLen - fin.tellg();
        std::vector&lt;char&gt; buffer(bytesReamining);

        if(!fin.read(buffer.data(), bytesReamining)) {
            throw std::runtime_error(""Unable to read file"");
        }

        std::string decryptedText;

        CryptoPP::StringSource ss(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), buffer.size(), true,
                new CryptoPP::StreamTransformationFilter(decryption,
                        new CryptoPP::StringSink(decryptedText), CryptoPP::BlockPaddingSchemeDef::BlockPaddingScheme::ZEROS_PADDING));

        std::cout &lt;&lt; decryptedText &lt;&lt; std::endl;
    }
</code></pre>
","65","<c++><encryption><aes><crypto++>","1","0","2","2019-07-10 23:16:56","56979555","1","","4943329","","2019-07-09 18:46:19","2019-07-09 05:25:46",""
"56945847","StreamTransformationFilter: invalid PKCS #7 block padding found using AES decryption","<p>I am trying to perform AES decryption using the <code>crypto++</code> library. I have an encrypted file whose first 8 bytes are the filelength, subsequent 16 bytes are the initialization vector, and the remaining data is the data of interest. I also have a string representation of my key (which I hash using SHA256)</p>

<p>I get the following error when trying to perform AES decryption:
<code>StreamTransformationFilter: invalid PKCS #7 block padding found</code></p>

<p>I am using the following c++ code:</p>

<pre><code>std::string keyStr = ""my_key"";
std::string infilePath = ""my/file/path"";


CryptoPP::SHA256 hash;
unsigned char digest[CryptoPP::SHA256::DIGESTSIZE];

hash.CalculateDigest( digest, reinterpret_cast&lt;const unsigned char*&gt;(&amp;keyStr[0]), keyStr.length() );
auto key = CryptoPP::SecByteBlock(digest, CryptoPP::SHA256::DIGESTSIZE);

std::ifstream fin(infilePath, std::ifstream::binary);

// First 8 bytes is the file size
std::vector&lt;char&gt; fileSizeVec(8);
fin.read(fileSizeVec.data(), fileSizeVec.size());

// Read the next 16 bytes to get the initialization vector
std::vector&lt;char&gt; ivBuffer(16);
fin.read(ivBuffer.data(), ivBuffer.size());
CryptoPP::SecByteBlock iv(reinterpret_cast&lt;const unsigned char*&gt;(ivBuffer.data()), ivBuffer.size());

// Create a CBC decryptor
CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Decryption decryption;
decryption.SetKeyWithIV(key, sizeof(key), iv);

CryptoPP::StreamTransformationFilter decryptor(decryption);

std::vector&lt;char&gt; buffer(CHUNK_SIZE, 0);

while(fin.read(buffer.data(), buffer.size())) {
    CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), buffer.size());
    decryptor.Put(tmp, tmp.size());
        }

decryptor.MessageEnd();
size_t retSize = decryptor.MaxRetrievable();

std::vector&lt;char&gt; decryptedBuff;
decryptedBuff.resize(retSize);

decryptor.Get(reinterpret_cast&lt;CryptoPP::byte*&gt;(decryptedBuff.data()), decryptedBuff.size());
</code></pre>

<p>I am not sure what is giving me the error. I am working off the following python code. When I run the python code with the same input file, it successfully decrypts the file. </p>

<pre><code>def decrypt_file(in_filename, out_filename=None):
    key = hashlib.sha256(PASSWORD).digest()
    """"""loads and returns the embedded model""""""
    chunksize = 24 * 1024
    if not out_filename:
        out_filename = os.path.splitext(in_filename)[0]

    with open(in_filename, 'rb') as infile:
        # get the initial 8 bytes with file size
        tmp = infile.read(8)
        iv = infile.read(16)
        decryptor = AES.new(key, AES.MODE_CBC, iv)
        string = b''
        # with open(out_filename, 'wb') as outfile:
        while True:
            chunk = infile.read(chunksize)
            if len(chunk) == 0:
                break
            string += decryptor.decrypt(chunk)
    return string
</code></pre>

<p>In addition to solving the error, I would also love some general c++ coding feedback on how I can improve. </p>

<p>Thanks in advance!</p>

<p><strong>Edit:</strong>
It looks like I wasn't reading the input file all the way to the end (as the length of the last chunk is smaller than <code>CHUNK_SIZE</code>). The following code now reads the entire file, however I still get the same issue. I have also confirmed that the <code>IV</code> and <code>key</code> match exactly that produced from the python code.</p>

<pre><code> // Get the length of the file in bytes
fin.seekg (0, fin.end);
size_t fileLen = fin.tellg();
fin.seekg (0, fin.beg);

std::vector&lt;char&gt; buffer(CHUNK_SIZE, 0);
size_t readSize = CHUNK_SIZE;

while(fin.read(buffer.data(), readSize)) {
     CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), CHUNK_SIZE);
     decryptor.Put(tmp, tmp.size());

      std::fill(buffer.begin(), buffer.end(), 0);

      size_t bytesReamining = fileLen - fin.tellg();
      readSize = CHUNK_SIZE &lt; bytesReamining ? CHUNK_SIZE : bytesReamining;

       if (!readSize)
            break;
        }
}
</code></pre>

<p>Note that I have tried this line as both <code>CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), CHUNK_SIZE);</code>
and <code>CryptoPP::SecByteBlock tmp(reinterpret_cast&lt;const unsigned char*&gt;(buffer.data()), readSize);</code> (Using <code>CHUNK_SIZE</code> pads with <code>0</code>)</p>
","<blockquote>
  <p>I have an encrypted file whose first 8 bytes are the filelength, subsequent 16 bytes are the initialization vector, and the remaining data is the data of interest...</p>
</blockquote>

<p>I think I'll just cut to the chase and show you an easier way to do things with the Crypto++ library. The key and iv are hard-coded to simplify the code. The derivation is not needed for the example. By the way, if Python has it, you should consider using <a href=""https://www.cryptopp.com/wiki/HKDF"" rel=""nofollow noreferrer"">HKDF</a> for derivation of the AES key and iv. HKDF has provable security properties.</p>

<p>Crypto++ handles the chunking for you. You don't need to explicitly perform it; see <a href=""https://www.cryptopp.com/wiki/Pumping_Data"" rel=""nofollow noreferrer"">Pumping Data</a> on the Crypto++ wiki.</p>

<p>I believe the Python code has a potential padding oracle present due to the use of CBC mode without a MAC. You might consider adding a MAC or using an <a href=""https://www.cryptopp.com/wiki/Authenticated_Encryption"" rel=""nofollow noreferrer"">Authenticated Encryption</a> mode of operation.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""filters.h""
#include ""osrng.h""
#include ""modes.h""
#include ""files.h""
#include ""aes.h""
#include ""hex.h""

#include &lt;string&gt;
#include &lt;iostream&gt;

const std::string infilePath = ""test.dat"";

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    const byte key[16] = {
        1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4
    };
    const byte iv[16] = {
        8,7,6,5, 8,7,6,5, 8,7,6,5, 8,7,6,5
    };
    const byte data[] = // 70 characters
        ""Now is the time for all good men to come to the aide of their country."";

    HexEncoder encoder(new FileSink(std::cout));
    std::string message;

    // Show parameters
    {        
        std::cout &lt;&lt; ""Key: "";
        StringSource(key, 16, true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;

        std::cout &lt;&lt; ""IV: "";
        StringSource(iv, 16, true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;

        std::cout &lt;&lt; ""Data: "";
        StringSource(data, 70, true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;
    }

    // Write sample data
    {
        FileSink outFile(infilePath.c_str());
        word64 length = 8+16+70;

        outFile.PutWord64(length, BIG_ENDIAN_ORDER);
        outFile.Put(iv, 16);

        CBC_Mode&lt;AES&gt;::Encryption enc;
        enc.SetKeyWithIV(key, 16, iv, 16);

        StringSource(data, 70, true, new StreamTransformationFilter(enc, new Redirector(outFile)));
    }

    // Read sample data
    {
        FileSource inFile(infilePath.c_str(), true /*pumpAll*/);

        word64 read, l;
        read = inFile.GetWord64(l, BIG_ENDIAN_ORDER);
        if (read != 8)
            throw std::runtime_error(""Failed to read length"");

        SecByteBlock v(16);
        read = inFile.Get(v, 16);
        if (read != 16)
            throw std::runtime_error(""Failed to read iv"");

        CBC_Mode&lt;AES&gt;::Decryption dec;
        dec.SetKeyWithIV(key, 16, v, 16);

        SecByteBlock d(l-8-16);
        StreamTransformationFilter f(dec, new ArraySink(d, d.size()));
        inFile.CopyTo(f);
        f.MessageEnd();

        std::cout &lt;&lt; ""Key: "";
        StringSource(key, 16, true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;

        std::cout &lt;&lt; ""IV: "";
        StringSource(v, 16, true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;

        std::cout &lt;&lt; ""Data: "";
        StringSource(d, d.size(), true, new Redirector(encoder));
        std::cout &lt;&lt; std::endl;

        message.assign(reinterpret_cast&lt;const char*&gt;(d.data()), d.size());
    }

    std::cout &lt;&lt; ""Message: "";
    std::cout &lt;&lt; message &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Running the program results in:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ test.cxx ./libcryptopp.a -o test.exe
$ ./test.exe
Key: 01020304010203040102030401020304
IV: 08070605080706050807060508070605
Data: 4E6F77206973207468652074696D6520666F7220616C6C20676F6F64206D656E20746F2063
6F6D6520746F207468652061696465206F6620746865697220636F756E7472792E

Key: 01020304010203040102030401020304
IV: 08070605080706050807060508070605
Data: 4E6F77206973207468652074696D6520666F7220616C6C20676F6F64206D656E20746F2063
6F6D6520746F207468652061696465206F6620746865697220636F756E7472792E

Message: Now is the time for all good men to come to the aide of their country.
</code></pre>

<hr>

<p>Prior to this Stack Overflow question, the Crypto++ library did not provide <code>PutWord64</code> and <code>GetWord64</code>. Interop with libraries like Python is important to the project, so they were added at <a href=""https://github.com/weidai11/cryptopp/commit/6d69043403a9"" rel=""nofollow noreferrer"">Commit 6d69043403a9</a> and <a href=""https://github.com/weidai11/cryptopp/commit/8260dd1e81c3"" rel=""nofollow noreferrer"">Commit 8260dd1e81c3</a>. They will be part of the Crypto++ 8.3 release.</p>

<p>If you are working with Crypto++ 8.2 or below, you can perform the 64-bit read with the following code.</p>

<pre><code>word64 length;
word32 h, l;

inFile.GetWord32(h, BIG_ENDIAN_ORDER);
inFile.GetWord32(l, BIG_ENDIAN_ORDER);

length = ((word64)h &lt;&lt; 32) | l;
</code></pre>

<hr>

<p>Here is the data file used for this example.</p>

<pre class=""lang-none prettyprint-override""><code>$ hexdump -C test.dat
00000000  00 00 00 00 00 00 00 5e  08 07 06 05 08 07 06 05  |.......^........|
00000010  08 07 06 05 08 07 06 05  b0 82 79 ee a6 d8 8a 0e  |..........y.....|
00000020  a6 b3 a4 7e 63 bd 9a bc  0e e4 b6 be 3e eb 36 64  |...~c.......&gt;.6d|
00000030  72 cd ba 91 8d e0 d3 c5  cd 64 ae c0 51 de a7 c9  |r........d..Q...|
00000040  1e a8 81 6d c0 d5 42 2a  17 5a 19 62 1e 9c ab fd  |...m..B*.Z.b....|
00000050  21 3d b0 8f e2 b3 7a d4  08 8d ec 00 e0 1e 5e 78  |!=....z.......^x|
00000060  56 6d f5 3e 8c 5f fe 54                           |Vm.&gt;._.T|
</code></pre>
","65","<c++><encryption><aes><crypto++>","1","1","2","2019-07-10 23:16:56","56979555","1","","4943329","","2019-07-09 18:46:19","2019-07-09 05:25:46",""
"29949471","Cannot kill Qt thread with CryptoPP FileSink running in the thread run method","<p>I have a UI app in C++ and QT5.4, Im using CryptoPP 5.6.2 to encrypt files. I ran into the following problem:</p>

<ol>
<li><p>When the Encrypt button is hit, a new thread is started based on <a href=""https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/"" rel=""nofollow"">this tutorial</a>.</p>

<pre><code>// new thread
CryptoWorkerThread = new QThread;
this-&gt;worker = new CryptoWorker(fileName.c_str(), newFileName.c_str(), key, keyLength, iv);
this-&gt;worker-&gt;moveToThread(CryptoWorkerThread);
connect(worker, SIGNAL(error(QString)), this, SLOT(errorString(QString)));
connect(CryptoWorkerThread, SIGNAL(started()), worker, SLOT(process()));
connect(worker, SIGNAL(finished()), CryptoWorkerThread, SLOT(quit()));
connect(worker, SIGNAL(finished()), this, SLOT(on_CryptoWorker_finished()));
connect(worker, SIGNAL(finished()), worker, SLOT(deleteLater()));
connect(CryptoWorkerThread, SIGNAL(finished()), CryptoWorkerThread, SLOT(deleteLater()));
CryptoWorkerThread-&gt;start();
</code></pre></li>
<li><p>I store pointer to the thread and worker in the mainwindow class (parent of the encrypt button and thus the slot)</p>

<p>Worker Class:</p>

<pre><code>class CryptoWorker : public QObject {
    Q_OBJECT
public:
    CryptoWorker(const char* sourceFileName, const char* destFileName, const byte * key, int keyLength, const byte * iv);
    ~CryptoWorker();

    const char* sourceFileName;
    const char* destFileName;

    public slots:
    void process();

signals:
    void finished();
    void error(QString err);

private:
    // add your variables here
    const byte* key;
    const byte* iv;
    int keyLength;
};

CryptoWorker::CryptoWorker(const char* sourceFileName, const char* destFileName, const byte * key, int keyLength, const byte * iv){
    this-&gt;sourceFileName = sourceFileName;
    this-&gt;destFileName = destFileName;
    this-&gt;key = key;
    this-&gt;keyLength = keyLength;
    this-&gt;iv = iv;
}

CryptoWorker::~CryptoWorker(){

}

void CryptoWorker::process(){

    CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption encryptor(key, keyLength, iv);


    CryptoPP::FileSource(sourceFileName, true,
        new CryptoPP::StreamTransformationFilter(
            encryptor,
            new CryptoPP::FileSink(destFileName),
            CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
        ),
        true // StreamTransformationFilter
    ); // FileSource

    emit finished();

    return;
}
</code></pre></li>
</ol>

<p>Now, when the thread is run and I am encrypting file A to file B on the fly, using this function:</p>

<pre><code>CryptoPP::FileSource(sourceFileName, true,
        new CryptoPP::StreamTransformationFilter(
            encryptor,
            new CryptoPP::FileSink(destFileName),
            CryptoPP::BlockPaddingSchemeDef::PKCS_PADDING
        ),
        true // StreamTransformationFilter
); // FileSource
</code></pre>

<p>But, the thread is stuck until the file finishes encoding and writing, which can take few minutes. I have no way to kill the thread, as there is no place to put an <code>isAlive()</code> check.</p>

<p>I am trying to find a solution that will allow me to use FileSource, FileSink (speed compared to fstream or file or qfile is amazing) and also let me cancel the operation at some point.</p>

<p>I solved progress monitoring by adding another thread that checks size of the new being created encrypted file B, but it would be cool to have control over the bytes that are being written at a given moment (so that I can check <code>isAlive()</code> and increment data counters).</p>

<p>At this point I am stuck and cannot find a solution. Please help.</p>
","<p>You could try passing <code>false</code> to second parameter (<code>pumpAll</code>) of <code>FileSource</code> constructor and doing the work in a loop in chunks using <code>Pump</code> method - this should allow to check <code>isAlive</code> and increment the counters. </p>
","64","<c++><multithreading><qt><encryption><crypto++>","1","1","1","2015-04-29 16:47:27","29949819","1","","1486275","","2015-04-29 16:47:27","2015-04-29 16:28:07",""
"42221820","How to change sink in Crypto++","<p>I'm using Crypto++ to decrypt a file, so I use <code>FileSource</code> as my source but I want to be able to change sink, so I can achieve something like following:</p>

<pre><code>std::string temp;
FileSource file(""/path/to/file"", false, new StringSink(temp));
file.Pump(14);
if (temp != ""File Signature"")
    return false;
//change file's sink to new CTR_Mode&lt;AES&gt;::Decryption(meta_key, 32, meta_iv, new StringSink(metainfo))
file.Pump(256);
/* use metainfo */
//change file's sink to new CTR_Mode&lt;AES&gt;::Decryption(key, 32, iv, new StringSink(decoded))
while(!file.SourceExhausted())
{
    file.Pump(512);
    std::cout &lt;&lt; decoded;
}
</code></pre>

<p>How can I achieve this?</p>
","<blockquote>
  <p>How to change sink in Crypto++?</p>
</blockquote>

<p>A Sink is just a Filter that has no attached transformation. To change a sink, you just change the attached filter of the predecessor or parent object. The tricky part is getting access to a filter that's two or three deep in the filter chain.</p>

<p>Use something like the following. Filters have two methods for attaching filters: <code>Attach</code> and <code>Detach</code>. They both attach a new filter to the object; but <code>Attach</code> returns the old filter while <code>Detach</code> free's it.</p>

<p>The other oddity is the <code>Redirector</code>. You can use it to break ownership in a chain. Its kind of needed for the <code>StreamTransformationFilter filter</code>. The stack based allocation will be free'd as a local variable, so you don't want it free'd as part of a chain, too.</p>

<pre><code>FileSource file(""/path/to/file"", false, new StringSink(temp));
file.Pump(14);
if (temp != ""File Signature"")
    return false;

CTR_Mode&lt;AES&gt;::Decryption decryptor;
StreamTransformationFilter filter(decryptor);

// Detach StringSink(temp), Attach StreamTransformationFilter(decryptor)
file.Detach(new Redirector(filter));

// Set Key and IV
decryptor.SetKeyWithIV(meta_key, 32, meta_iv);

// Detach nothing, Attach StringSink(metainfo)
filter.Detach(new StringSink(metainfo));

// FileSource → decryptor → metainfo
file.Pump(256);

// Set Key and IV
decryptor.SetKeyWithIV(key, 32, iv);

// Detach StringSink(metainfo), Attach StringSink(decoded)
filter.Detach(new StringSink(decoded)); 

while(!file.SourceExhausted())
{
    // FileSource → decryptor → decoded
    file.Pump(512);
    std::cout &lt;&lt; decoded;
}
</code></pre>

<hr>

<p>Here's another way to do it without the <code>Redirector</code>. It stashes away a pointer to the <code>StreamTransformationFilter</code>:</p>

<pre><code>FileSource file(""/path/to/file"", false, new StringSink(temp));
file.Pump(14);
if (temp != ""File Signature"")
    return false;

CTR_Mode&lt;AES&gt;::Decryption decryptor;
StreamTransformationFilter* filter = NULL;

// Detach StringSink(temp), Attach StreamTransformationFilter(decryptor)
file.Detach(filter = new StreamTransformationFilter(decryptor));

// Set Key and IV
decryptor.SetKeyWithIV(meta_key, 32, meta_iv);

// Detach nothing, Attach StringSink(metainfo)
filter-&gt;Detach(new StringSink(metainfo)); 

// FileSource → decryptor → metainfo
file.Pump(256);

// Set Key and IV
decryptor.SetKeyWithIV(key, 32, iv);

// Detach StringSink(metainfo), Attach StringSink(decoded)
filter-&gt;Detach(new StringSink(decoded)); 

while(!file.SourceExhausted())
{
    // FileSource → decryptor → decoded
    file.Pump(512);
    std::cout &lt;&lt; decoded;
}
</code></pre>

<hr>

<p>You might be interested in <a href=""https://www.cryptopp.com/wiki/Pipelining"" rel=""nofollow noreferrer"">Pipelining</a> on the Crypto++ wiki. Also of interest might be <a href=""https://www.cryptopp.com/docs/ref/class_buffered_transformation.html"" rel=""nofollow noreferrer"">BufferedTransformation</a>, which is the base class used for pipelining.</p>
","61","<c++><crypto++>","2","1","1","2017-02-14 18:54:58","42232376","0","","608639","","2017-02-14 16:46:50","2017-02-14 09:03:55",""
"56859488","Re-encrypting the encrypted data file generates a decrypted output","<p>I wrote the encryption function using Crypto++ library, function behaves correctly when a file encryption is done for the first time. If the same encrypted file is passed again for encryption, generates the output which includes encrypted and decrypted data.</p>

<pre><code>bool EncryptDataFile(const char* inputFile, const char* outputFile)
{
  try
  {
    std::vector&lt;byte&gt; key = HexDecoding(PASSCODE);
    std::vector&lt;byte&gt; iv = HexDecoding(INITIALIZATION_VECTOR);

    GCM&lt;AES&gt;::Encryption encryptor;
    encryptor.SetKeyWithIV(key.data(), key.size(), iv.data(), iv.size());

    FileSource fs(inputFile, true,
        new AuthenticatedEncryptionFilter(encryptor,
            new FileSink(outputFile), false, TAG_SIZE));
  }

  catch(...)
  {
    return false;
  }

  return true;
}
</code></pre>

<p>Input.txt:</p>

<pre><code>Privacy and Security
</code></pre>

<p>Output1.txt - first time encryption output:</p>

<pre><code>{)ªei ?ñìCzN[hç&amp;Ää€|Ùrñ½…
Ä
</code></pre>

<p>Input ""Output1.txt"", Output ""Output2.txt"" - second time encryption:</p>

<pre><code>Privacy and Security]®Ÿwþñ úeS„£Fpä40WL ,ÈR¯M 
</code></pre>

<p>It has revealed the original data. An not sure what is missing here.</p>
","<blockquote>
  <p>If the same encrypted file is passed again for encryption, generates the output which includes encrypted and decrypted data.</p>
</blockquote>

<p>If I am parsing things correctly, you are saying <code>m ≅ Enc(Enc(m))</code> instead of <code>c = Enc(Enc(m))</code> in your encryption scheme. This is one of the reasons why you should avoid designing your own scheme.</p>

<p>This can happen in several scenarios, like with a stream cipher or block cipher in counter mode when re-using a key and iv.</p>

<p>You should using a different security context for each message or encryption operation. With some hand waiving, that means change the key or iv for each message or encryption operation.</p>

<hr>

<blockquote>
<pre><code>std::vector&lt;byte&gt; key = HexDecoding(PASSCODE);
std::vector&lt;byte&gt; iv = HexDecoding(INITIALIZATION_VECTOR);
</code></pre>
</blockquote>

<p>This is likely your problem. You need to use a different security context for each message or encryption operation.</p>

<hr>

<p>Here is how you fix it. You use a key derivation function to derive different security parameters for each encryption. In the code below, the 32-byte key is divided into two 16-byte keys. The same applies to the iv. The first encryption uses <code>key+0</code> and <code>iv+0</code>; and the second encryption uses <code>key+16</code> and <code>iv+16</code>.</p>

<pre class=""lang-cxx prettyprint-override""><code>cryptopp$ cat test.cxx
#include ""cryptlib.h""
#include ""filters.h""
#include ""files.h""
#include ""aes.h""
#include ""gcm.h""
#include ""hex.h""
#include ""hkdf.h""
#include ""sha.h""

#include &lt;string&gt;
#include &lt;iostream&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    std::string password = ""super secret password"";
    SecByteBlock key(32), iv(32);

    HKDF&lt;SHA256&gt; hkdf;
    hkdf.DeriveKey(key, key.size(),
                   (const byte*)password.data(), password.size(),
                   NULL, 0,  // salt
                   (const byte*)""key derivation"", 14);

    hkdf.DeriveKey(iv, iv.size(),
                   (const byte*)password.data(), password.size(),
                   NULL, 0,  // salt
                   (const byte*)""iv derivation"", 13);


    std::string m = ""Yoda said, Do or do not. There is no try."";
    std::string c1, c2;

    GCM&lt;AES&gt;::Encryption encryptor;

    encryptor.SetKeyWithIV(key, 16, iv, 16);
    StringSource(m, true, new AuthenticatedEncryptionFilter(
                 encryptor, new StringSink(c1)));

    encryptor.SetKeyWithIV(key+16, 16, iv+16, 16);
    StringSource(c1, true, new AuthenticatedEncryptionFilter(
                 encryptor, new StringSink(c2)));    

    std::cout &lt;&lt; ""Hex(m):"" &lt;&lt; std::endl;
    StringSource(m, true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Hex(Enc(m)):"" &lt;&lt; std::endl;
    StringSource(c1, true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Hex(Enc(Enc(m))):"" &lt;&lt; std::endl;
    StringSource(c2, true, new HexEncoder(new FileSink(std::cout)));
    std::cout &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Here is a run of the program:</p>

<pre class=""lang-none prettyprint-override""><code>cryptopp$ ./test.exe
Hex(m):
596F646120736169642C20446F206F7220646F206E6F742E205468657265206973206E6F20747279
2E
Hex(Enc(m)):
D4A9063DE7400E90627DE90D16346DC5A99740C55F6FEE092A99071F55F1BDB25A72B7422126CCC4
09B5B5C0076E39EBF7256D5DC3151A738D
Hex(Enc(Enc(m))):
83A459F2D4A1627624AF162590465AC705C8AC0F4D915E4A4A9D300156C5F9E042CAA47903353F0A
A1FAE408D5747DD223AC4F9AEF3C320EEF7E79E08AB2C6FBEAE7A3A5B4978C45C7
</code></pre>

<hr>

<p>I think your scheme has some additional problems. For example, if you encrypt the message <em>""Attack at dawn!""</em> multiple times, then you get the same ciphertext on each run. It is leaking information, and it lacks ciphertext indistinguishability.</p>

<p>I think you should avoid your scheme, and use an <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Integrated_Encryption_Scheme"" rel=""nofollow noreferrer"">Elliptic Curve Integrated Encryption Scheme (ECIES)</a>. It avoids most of the latent problems in your scheme, and achieves <a href=""https://en.wikipedia.org/wiki/IND-CCA2"" rel=""nofollow noreferrer"">IND-CCA2</a>.</p>

<p>The downside to ECIES is, you have to manage a public/private keypair. It is not a big downside, though. You are already managing a password and iv, so changing from a password to a private key is not much more work.</p>
","60","<c++><aes><crypto++>","1","0","1","2019-07-04 19:07:47","56862081","1","","608639","","2019-07-04 00:53:16","2019-07-02 20:15:58",""
"38543961","""unknown: this object doesn't support multiple channels"" during encryption","<p>I am getting <em>""unknown: this object doesn't support multiple channels""</em> exception during file encryption. I am able to generate session key but it can not be used to encrypt file.</p>

<p>The following is my code snippet for file encryption:</p>

<pre class=""lang-cpp prettyprint-override""><code>void enc_file_EAX(PAES_KEY_WITH_IV key, const char *in_file, const char *out_file)
{

    try {
        CryptoPP::EAX&lt;CryptoPP::AES&gt;::Encryption encryptor;
        encryptor.SetKeyWithIV(key-&gt;key, key-&gt;key.size(), key-&gt;iv);
        CryptoPP::FileSource f(in_file, true,
                     new CryptoPP::AuthenticatedEncryptionFilter(encryptor,
                        new CryptoPP::FileSink(
                             std::string(in_file).c_str()),
                             CryptoPP::AuthenticatedDecryptionFilter::THROW_EXCEPTION |
                             CryptoPP::AuthenticatedDecryptionFilter::MAC_AT_END ));
        std::fstream file(out_file, std::ios::binary | std::ios::ate);
        size_t remaining = file.tellg();
        file.close();
        size_t BLOCK_SIZE = 16384;
        while (remaining &amp;&amp; !f.SourceExhausted()) {
            const unsigned int req = std::min(remaining, BLOCK_SIZE);
            f.Pump(req);
            f.Flush(false);
            remaining -= req;
        }

    } catch (const CryptoPP::Exception&amp; e) {
        std::cout &lt;&lt; e.GetWhat() &lt;&lt; std::endl;
        return;
    }
}
</code></pre>

<p>Can someone help me on this ? What is going wrong here ?</p>

<p>Thanks in advance.</p>
","<pre><code>EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(key-&gt;key, key-&gt;key.size(), key-&gt;iv);
FileSource f(in_file, true,
        new AuthenticatedEncryptionFilter(encryptor,
            new FileSink(
                std::string(in_file).c_str()),
            AuthenticatedDecryptionFilter::THROW_EXCEPTION |
            AuthenticatedDecryptionFilter::MAC_AT_END ));
</code></pre>

<p>You are mixing and matching encryption and decryption gear in the same object pipeline. You should probably fix that first.</p>

<p>Looking at <a href=""http://www.cryptopp.com/wiki/AuthenticatedEncryptionFilter"" rel=""nofollow"">AuthenticatedEncryptionFilter</a>, the <code>THROW_EXCEPTION | MAC_AT_END</code> flags  are probably being coerced into the <code>putAAD</code> flag:</p>

<pre><code>AuthenticatedEncryptionFilter(AuthenticatedSymmetricCipher &amp;c,
    BufferedTransformation *attachment = NULL, bool putAAD=false,
    int truncatedDigestSize=-1, const std::string &amp;macChannel=DEFAULT_CHANNEL,
    BlockPaddingScheme padding=DEFAULT_PADDING);
</code></pre>

<p>I seem to recall you need to avoid the <a href=""http://cryptopp.com/wiki/Pipelining"" rel=""nofollow"">Pipelines</a> if you want to add AAD. The pipe only allows inputting data on <code>DEFAULT_CHANNEL</code>, which provides AE (but no AAD). Also see <a href=""https://cryptopp.com/wiki/Eax_mode#AEAD"" rel=""nofollow"">EAX Mode | AEAD example</a> on the Crypto++ wiki.</p>

<hr>

<p>Your use of <code>FileSink</code> and <code>FileSource</code> does not quite look right. I'm not sure how this is going to behave:</p>

<pre><code>FileSource f(in_file, true, ...
    new FileSink(std::string(in_file).c_str()), ...);
</code></pre>

<p>You should probably use <code>in_file.c_str()</code> for the file name:</p>

<pre><code>FileSource f(in_file.c_str(), ...);
</code></pre>

<p>You should also probably use a different file for the sink:</p>

<pre><code>FileSource f(out_file.c_str(), ...);
</code></pre>

<hr>

<p><strong><em>EDIT</em></strong> (from the comments):</p>

<blockquote>
  <p>No , we don't want to add pipeline, we just want to use DEFAULT_CHANNEL for inputting data. And given example is for text input. I want to use same function for file inputting. Can you elaborate more on this?</p>
</blockquote>

<p>In this case, try:</p>

<pre><code>EAX&lt;AES&gt;::Encryption encryptor;
encryptor.SetKeyWithIV(key-&gt;key, key-&gt;key.size(), key-&gt;iv);
FileSource f(in_file.c_str(), true,
        new AuthenticatedEncryptionFilter(encryptor,
            new FileSink(out_file.c_str()));
</code></pre>

<p>That should input text for confidentiality and integrity (AE). It will avoid text with confidentiality only (AEAD).</p>

<p>Also see <a href=""http://www.cryptopp.com/wiki/EAX_Mode"" rel=""nofollow"">EAX Mode</a> on the Crypto++ wiki. It has three or four examples with both AE and AEAD.</p>
","59","<encryption><pipeline><encryption-symmetric><crypto++>","1","0","1","2016-07-27 17:31:29","38593750","0","","608639","","2016-07-26 15:18:02","2016-07-23 16:28:54",""
"50668010","AES encrypt/decrypt take in all the plaintext","<p>I'm doing this assignment and i came across this problem where if i input a sentence, eg: ""Hello my name is Adam"", it will only encrypt ""Hello"".. But when i assign the sentence to the plaintext, I get a full encrypted/decrypted sentence.</p>

<pre><code>AutoSeededRandomPool rnd;

// Generate a random key
SecByteBlock key(0x00, AES::DEFAULT_KEYLENGTH);
rnd.GenerateBlock( key, key.size() );

// Generate a random IV
SecByteBlock iv(AES::BLOCKSIZE);
rnd.GenerateBlock(iv, iv.size());

// Read phrase
std::string plaintext;
cin &gt;&gt; plaintext;

std::string ciphertext;
std::string decryptedtext;

// encrypt
CTR_Mode&lt;AES&gt;::Encryption cfbEncryption(key, key.size(), iv);
CryptoPP::StreamTransformationFilter stfEncryptor(cfbEncryption, new CryptoPP::StringSink( ciphertext ) );
stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
stfEncryptor.MessageEnd();

cout &lt;&lt; ciphertext &lt;&lt; endl;

// decrypt
CTR_Mode&lt;AES&gt;::Decryption cfbDecryption(key, key.size(), iv);
CryptoPP::StreamTransformationFilter stfDecryptor(cfbDecryption, new CryptoPP::StringSink( decryptedtext ) );
stfDecryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( ciphertext.c_str() ), ciphertext.size() );
stfDecryptor.MessageEnd();

cout &lt;&lt; decryptedtext &lt;&lt; endl;
</code></pre>

<p>Can someone explain..? I don't quite understand how this works... I need user input for this assignment. Is there a way where i can have user input and get the full encrypted sentence?</p>
","<p>Instead of <code>cin &gt;&gt; plaintext</code>, try <code>std::getline(cin, plaintext)</code>.</p>

<p><code>operator&gt;&gt;</code> in this context will read until the next whitespace, which in this case is the space character after ""Hello"". On the other hand, <code>std::getline</code> will read until the specified delimiter; here we are using the default delimiter which is <code>\n</code>, so it will read the entire line.</p>
","58","<c++><aes><crypto++>","1","3","1","2018-06-04 02:04:34","","2","","608639","","2018-06-04 02:04:34","2018-06-03 15:27:50",""
"40954891","Trouble Verifying Message RSA Signature Scheme Over Sockets","<p>Im trying to send signed messaged from my server over a socket to a client. I am having trouble verifying the messages. I have tried the filtered and non filtered way based off of the code examples provided on the wiki. I have tried nearly everything I could find on Google but i'm stummped.</p>

<p>How can I do this signature verification scheme over sockets? I left everything I have been trying commented out just to show what I have been trying to do.</p>

<pre><code>   SERVER:

   try
   {
      AutoSeededRandomPool rng;
      stringstream ss;
      string signature;

//      byte* signature = new byte[tdata-&gt;signer.MaxSignatureLength()];
//      if( NULL == signature )
//      {
//         throw Exception(Exception::OTHER_ERROR, ""Invalid Signature"");
//      }
//
//      size_t length = tdata-&gt;signer.SignMessage( rng, (const byte*) sendBuf.c_str(),
//          sendBuf.length(), signature );
      //string signature;
//    byte* message = (byte*) sendBuf.c_str();
//    SecByteBlock signature(tdata-&gt;signer.MaxSignatureLength(sendBuf.size()));
//
//    size_t signatureLen = tdata-&gt;signer.SignMessageWithRecovery(rng, message,
//             sendBuf.size(), NULL, 0, signature);
//
//    cout &lt;&lt; ""Signature Length: "" &lt;&lt; signatureLen &lt;&lt; endl;
//    ss &lt;&lt; signatureLen;
//    string len = ss.str();
//    string send;
//    send = (char*)signature.data();
//    send += "" "" + len;
      StringSource(sendBuf, true,
               new SignerFilter(rng, tdata-&gt;signer, new StringSink(signature),
                        true // putMessage
                        )// SignerFilter
                        );// StringSource

//    cout &lt;&lt; ""Signature: "" &lt;&lt; std::hex &lt;&lt; signature &lt;&lt; endl;
//    // Encode the message as an Integer
//    m = Integer((const byte *) sendBuf.c_str(), sendBuf.size());
//
//    //Encrypt
//    c = tdata-&gt;privateKey.CalculateInverse(rng, m);
//
//    //Turn the encrypted value into a string
//    ss &lt;&lt; c;
//    sendBuf = ss.str();
//    ss.str("""");
//    ss.clear();
//    cout &lt;&lt; ""Cipher Sent: "" &lt;&lt; sendBuf &lt;&lt; endl;

      tdata-&gt;sockSource.Send((byte*)signature.c_str(), sizeof(signature));
</code></pre>

<p>And here is the client</p>

<pre><code>   CLIENT:

   string signature, recovered;
   stringstream ss("""");
   AutoSeededRandomPool rng;
   byte byteBuf[ 1000 ];

   try
   {
      // Retrieve message from socket
      cout &lt;&lt; ""Waiting for reply from server..."" &lt;&lt; endl;
      sockServer.Receive(byteBuf, sizeof(byteBuf));

      ss &lt;&lt; byteBuf;
      string signature = ss.str();
      ss.str("""");
      ss.clear();

//    byte sig[2048];
//    bool result = verifier.VerifyMessage( (const byte*)message.c_str(),
//        message.length(), sig, 2048 );
//
//    if( true == result )
//    {
//        cout &lt;&lt; ""Message Verified"" &lt;&lt; endl;
//    }
//    else
//    {
//        cout &lt;&lt; ""Message Verification Failed"" &lt;&lt; endl;
//    }
//    cout &lt;&lt; endl &lt;&lt; std::hex &lt;&lt; ""Cipher Received: "" &lt;&lt; byteBuf &lt;&lt; endl;
//
//    SecByteBlock recovered(
//             verifier.MaxRecoverableLengthFromSignatureLength(length));
//
//    DecodingResult result = verifier.RecoverMessage(recovered, NULL, 0,
//             byteBuf, length);
//
//    if ( !result.isValidCoding )
//    {
//       throw Exception(Exception::OTHER_ERROR, ""Invalid Signature"");
//    }
//
//    ////////////////////////////////////////////////
//    // Use recovered message
//    size_t recoveredLen = result.messageLength;
//
//    assert(
//             0
//                      == memcmp(byteBuf, (const byte* )recovered,
//                               std::min(sizeof(byteBuf), recoveredLen)));

//     Convert message to a string
//    StringSource ss1(byteBuf, sizeof(byteBuf), true,
//             new StringSink(temp));
//
//    ss &lt;&lt; byteBuf;
//    signature = ss.str();
//    ss.str("""");
//    ss.clear();
//
//    cout &lt;&lt; ""Signature received: "" &lt;&lt; std::hex &lt;&lt; signature &lt;&lt; endl;
//
      StringSource(signature, true,
               new SignatureVerificationFilter(verifier,
                        new StringSink(recovered),
                        SignatureVerificationFilter::THROW_EXCEPTION
                                 | SignatureVerificationFilter::PUT_MESSAGE) // SignatureVerificationFilter
                                 );// StringSource

      cout &lt;&lt; ""Verified signature on message"" &lt;&lt; endl;
      return recovered;
//    return recovered;

//    //Convert the string to an Integer so we can calculate the inverse
//    c = Integer(recBuf.c_str());
//    r = serverKey.ApplyFunction(c);
//    cout &lt;&lt; ""r: "" &lt;&lt; r &lt;&lt; endl;
//
//    // Recover the original message
//    size_t req = r.MinEncodedSize();
//    recovered.resize(req);
//    r.Encode((byte *) recovered.data(), recovered.size());
//    cout &lt;&lt; ""Recovered: "" &lt;&lt; recovered &lt;&lt; endl;

   }
   catch ( Exception&amp; e )
   {
      cerr &lt;&lt; ""caught Exception..."" &lt;&lt; endl;
      cerr &lt;&lt; e.what() &lt;&lt; endl;
      sockServer.ShutDown(SHUT_RDWR);
      return """";
   }
</code></pre>
","<pre><code>string signature;

// ...

tdata-&gt;sockSource.Send((byte*)signature.c_str(), sizeof(signature));
</code></pre>

<p>A <code>std::string</code> is a relatively small class. My <code>std::string</code>s are 32 bytes long. So, my <code>sizeof(signature)</code> is 32.</p>

<p>Your <code>sizeof(signature)</code> is probably the same. And, as you know <code>sizeof</code> is a compile-time constant. It's going to be 32, or 16, or whatever, whether or not the string contains a few bytes, or a few megabytes.</p>

<p>What you should be doing is using <code>signature.size()</code> to determine the number of bytes to write.</p>

<p>Additionally, it's not clear what socket API library you're using, but with most APIs you are not guaranteed to successfully send the requested number of bytes. The request to send a given number of bytes will typically return how many bytes were written, which could be less, in which case you are required to try again. The same thing is true for reading from a socket. You have to know, in advance, how many bytes you expect to receive, and if you read fewer bytes, you have to keep reading.</p>

<p>It's likely that you must check the return value from <code>Send()</code> and <code>Receive()</code>, and take the appropriate action.</p>
","57","<c++><sockets><rsa><digital-signature><crypto++>","0","1","1","2016-12-04 03:20:00","40954944","1","","5156199","","2016-12-04 03:20:00","2016-12-04 02:58:03",""
"46166823","Export Public Key parameters from Crypto++ ELGamalKeys","<p>I am using CryptoPP and trying to export the steps of each encryption/decryption so I can learn how ElGamal works.</p>

<p>I have been trying to learn ElGamal encryption by way of this site:</p>

<p><a href=""https://cryptographyacademy.com/elgamal/"" rel=""nofollow noreferrer"">https://cryptographyacademy.com/elgamal/</a></p>

<p>I am able to find the SubgroupOrder, SubgroupGenerator, and Modulus of an ElGamalKeys::PublicKey, but I am unable to find the 3rd parameter of the PublicKey which is computed using Alice's private exponent. According to the site:</p>

<pre><code> Next Alice chooses the secret key sk=a between 1 and p−1 and computes A=g^a mod p

Alice then publish the public key pk=(p,g,A).
</code></pre>

<p>How do I access the A parameter from the PublicKey explicitly?</p>
","","57","<c++><encryption><crypto++>","1","","0","2017-09-12 13:34:05","","3","","229072","","2017-09-12 13:34:05","2017-09-12 02:04:24",""
"32439736","Load/Export RandomNumber","<p>In the frame of an home-made <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Diffie-Hellman"" rel=""nofollow""><code>ECDHE</code></a> application, both the client and the server have to send a randomly generated numbers (rng), in order to build later the <code>MasterSecret</code> during the handshake (TLS-like)...</p>

<p>With <a href=""http://www.cryptopp.com/"" rel=""nofollow"">crypto++</a>, it's easy to create these numbers, thanks to :</p>

<pre><code>AutoSeededRandomPool rng;
</code></pre>

<p>My problem is 1) <strong>to export them</strong> to a string or equivalent, and 2) <strong>to load them</strong> from a string.</p>

<p>I must put these numbers within a frame, and nor the <a href=""http://www.cryptopp.com/docs/ref/class_auto_seeded_random_pool.html"" rel=""nofollow"">Class definition</a>, nor the <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">examples</a> precise that.</p>

<p>On the web I haven't been able to find Save/Load examples (like the ones for <code>RSA::PublicKeys</code>).</p>

<p>Apparently I'm the first to want this, as their <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">examples</a> generate the client and the server <em>in the same program</em>, and thus don't need to transmit the numbers.</p>

<p>And, as part of this handshake, I also try to do the same with curvesID...</p>
","<p>This question was a misunderstanding from my part, so I'll explain it, in case of anyone having the same interrogations. It's largely inspired from the <a href=""http://www.cryptopp.com/wiki/RandomNumberGenerator"" rel=""nofollow"">crypto++ wiki</a>...</p>

<p>There are 2 distinct objects : </p>

<pre><code>AutoSeededRandomPool prng;

prng.GenerateBlock( scratch, scratch.size() );
</code></pre>

<p><code>AutoSeededRandomPool prng;</code> is the generator of random numbers (that will be auto-seeded)</p>

<p><code>prng.GenerateBlock</code> is the command that will extract bits from this random number to build the <code>std::string scratch</code> of the desired length.</p>

<p>And as the scratch is a string, we can do what we want with it, to use it anywhere... So please refer to the <strong>string</strong> import/export.</p>
","56","<c++><ssl><crypto++><diffie-hellman>","0","0","1","2015-09-08 11:52:54","32457123","4","","3494633","","2015-09-07 14:40:59","2015-09-07 13:19:36",""
"36368715","Static Library linked Program VS Source Code Compiled program huge size difference","<p>I have a library (Crypto++) its almost 50MB in total when the library is compiled.</p>

<p>I took the source code of Crypto++ and only added the source files of the algorithms that I am going to use on my application.
I then created the application and decided to compile Crypto++ as a static library and linked it to a cloned version of the same project.</p>

<p>So now I have 2 projects:</p>

<p>Project 1: Has only the necessary source files to compile and use only the algorithms I need AES,SHA256,etc.</p>

<p>Project 2: Has only the header files and the Crypto++ linked static lib.</p>

<p>Now, When I compile both projects, I was supposed (or I always thought) to see that both exes have the same size since the linker will only link the source I am using in Project 2 into the exe, basically It would link exactly the same files that I am using on Project 1.
But this is not the case, I see a huge difference of Project 1 vs Project 2...
The project that uses the static library is 6.2 times bigger than the project that was compiled with the source code.(Both compiled in Release mode)</p>

<p>Project 1 (source) size: 210kb
Project 2 (static lib) size: 1,303kb</p>

<p>Why is this? I always though the linker was supposed to only use what I'm referencing on my code. Is this just a linker inefficiency?</p>

<p>Can some one enlighten me?</p>
","<p>The linker will only use what it referenced. The behavior that you are observing is a direct result of the fact that the entire crypto library is built as one object. The linker has no choice but to include the whole thing. The linker could do what you are expecting if you had the source code for library and built it along side your project. </p>
","54","<c++><static><size><crypto++>","1","0","2","2016-04-02 17:25:42","","0","","","","","2016-04-02 03:08:44",""
"36368715","Static Library linked Program VS Source Code Compiled program huge size difference","<p>I have a library (Crypto++) its almost 50MB in total when the library is compiled.</p>

<p>I took the source code of Crypto++ and only added the source files of the algorithms that I am going to use on my application.
I then created the application and decided to compile Crypto++ as a static library and linked it to a cloned version of the same project.</p>

<p>So now I have 2 projects:</p>

<p>Project 1: Has only the necessary source files to compile and use only the algorithms I need AES,SHA256,etc.</p>

<p>Project 2: Has only the header files and the Crypto++ linked static lib.</p>

<p>Now, When I compile both projects, I was supposed (or I always thought) to see that both exes have the same size since the linker will only link the source I am using in Project 2 into the exe, basically It would link exactly the same files that I am using on Project 1.
But this is not the case, I see a huge difference of Project 1 vs Project 2...
The project that uses the static library is 6.2 times bigger than the project that was compiled with the source code.(Both compiled in Release mode)</p>

<p>Project 1 (source) size: 210kb
Project 2 (static lib) size: 1,303kb</p>

<p>Why is this? I always though the linker was supposed to only use what I'm referencing on my code. Is this just a linker inefficiency?</p>

<p>Can some one enlighten me?</p>
","<blockquote>
  <p>I have a library (Crypto++) its almost 50MB in total when the library is compiled....</p>
</blockquote>

<p>Yes, the static library carries around all the symbols. Nothing can be discarded because it may be needed.</p>

<p>It also carries around debug information if you used <code>-g</code>. Some optimization flags will affect it too. For example <code>-Os</code> minimizes for code size.</p>

<hr>

<blockquote>
  <p>The project that uses the static library is 6.2 times bigger than the project that was compiled with the source code. Why is this?</p>
</blockquote>

<p>We need to see your program, and your compiler and linker switches to better explain what's going on. Based on these numbers, I'm guessing some dead code stripping is occurring, but not as much as you expect:</p>

<blockquote>
  <p>Project 1 (source) size: 210kb Project 2 (static lib) size: 1,303kb</p>
</blockquote>

<hr>

<blockquote>
  <p>I always though the linker was supposed to only use what I'm referencing on my code. Is this just a linker inefficiency?</p>
</blockquote>

<p>When building the Crypto++ library, use the <code>make lean</code> recipe. It adds function sections (<code>-ffunction-sections</code>) and data sections (<code>-fdata-sections</code>) so the linker can do a better job at discarding unused code and data. Also see <a href=""http://www.cryptopp.com/wiki/GNUmakefile#Makefile_Targets"" rel=""nofollow"">GNUmakefile | Makefile Targets</a> on the Crypto++ wiki.</p>

<p>When you link your application use the appropriate linker switch. With GCC/LD, that would be <code>-Wl,--gc-sections</code>. Under Apple/DYLD, that would be <code>-Wl,-dead_strip</code>.</p>

<hr>

<p>You can also strip debug symbols, which will reduce the binary size even further. Its not clear to me if your built with symbols or stripped them afterwards.</p>

<p>If you strip and discard the symbols altogether, then the stack traces will be mostly useless. If you retain the symbols in an offline file, then you might be able to make sense of a stack trace. Also see <a href=""http://www.cryptopp.com/wiki/Debug_Symbols"" rel=""nofollow"">Debug Symbols</a> on the Crypto++ wiki.</p>

<hr>

<p>Here are the results from investigating the <code>lean</code> target for users. Also see <a href=""http://groups.google.com/d/msg/cryptopp-users/SaORS7dHSZ0/xBcCGs5cEQAJ"" rel=""nofollow"">'make lean' target?</a> on the Crypto++ user group.</p>

<p><strong><em>Test program</em></strong>:</p>

<pre class=""lang-c++ prettyprint-override""><code>int main( int, char** ) {

  Integer j(""100000000000000000000000000000000"");
  j %= 1999;

  cout &lt;&lt; ""j: "" &lt;&lt; j &lt;&lt; endl;

  return 0;
}
</code></pre>

<p><strong><em>Lean</em></strong> (library built with <code>make lean</code>, program linked with <code>-Wl,--gc-sections</code>):</p>

<pre class=""lang-none prettyprint-override""><code>$ ls -l integer.exe
-rwx------  1 jwalton  staff  162012 Jan  4 13:00 integer.exe
</code></pre>

<p><strong><em>Normal</em></strong> (library built with <code>make</code>, no special linker switches):</p>

<pre class=""lang-none prettyprint-override""><code>$ ls -l integer.exe
-rwx------  1 jwalton  staff  2636952 Jan  4 13:02 integer.exe
</code></pre>

<hr>

<p>The <code>lean</code> target was added after Crypto++ 5.6.3 was released. You will need to fetch the code from Master if you want it:</p>

<pre class=""lang-none prettyprint-override""><code>git clone https://github.com/weidai11/cryptopp.git cryptopp
</code></pre>

<p>Or, you can apply the patch below to the GNUmakefile by hand from <a href=""http://github.com/weidai11/cryptopp/commit/9696b9e5e79ff18a30956467497e757562e26310"" rel=""nofollow"">Commit 9696b9e5e79ff18a</a>. Add it around line 270 or so:</p>

<pre class=""lang-none prettyprint-override""><code>+# Dead code stripping. Issue 'make lean'.
+ifeq ($(findstring lean,$(MAKECMDGOALS)),lean)
+ifeq ($(findstring -ffunction-sections,$(CXXFLAGS)),)
+CXXFLAGS += -ffunction-sections
+endif # CXXFLAGS
+ifeq ($(findstring -fdata-sections,$(CXXFLAGS)),)
+CXXFLAGS += -fdata-sections
+endif # CXXFLAGS
+ifneq ($(IS_DARWIN),0)
+ifeq ($(findstring -Wl,-dead_strip,$(LDFLAGS)),)
+LDFLAGS += -Wl,-dead_strip
+endif # CXXFLAGS
+else # BSD, Linux and Unix
+ifeq ($(findstring -Wl,--gc-sections,$(LDFLAGS)),)
+LDFLAGS += -Wl,--gc-sections
+endif # LDFLAGS
+endif # MAKECMDGOALS
+endif # Dead code stripping
</code></pre>

<p>And the following where the recipes are:</p>

<pre><code>+.PHONY: lean
+lean: libcryptopp.a cryptest.exe
+
</code></pre>
","54","<c++><static><size><crypto++>","1","0","2","2016-04-02 17:25:42","","0","","","","","2016-04-02 03:08:44",""
"14083667","Example of encrypting one AES block needed","<blockquote>
  <p><strong>Possible Duplicate:</strong><br>
  <a href=""https://stackoverflow.com/questions/11082432/encrypt-decrypt-single-block-with-aes-and-crypto"">encrypt-decrypt single block with AES and Crypto++</a>  </p>
</blockquote>



<p>I have a homework that involves implementing two operation modes of AES, but the problem is that I don't know how to encrypt a single AES block. As in, I don't know how to use Crypto++'s implementation of AES in isolation. Everywhere I looked I could only find code snippets that use the library's operation modes, and even though I know that's how it's supposed to be used, I would like to actually do it myself for the assignment. Can anyone please help with some C++ code example?</p>
","","54","<c++><aes><crypto++>","0","","0","2012-12-30 05:48:21","","2","","-1","","2017-05-23 10:24:46","2012-12-29 16:33:06","2012-12-29 21:48:14"
"57667739","Crypto++ CRC32 linker errór","<p>I tried to compile an application to encrypt some files, but I have a problem when I try to compile. Everything looks good, but I don't know why I get this error.</p>

<p>My error is:</p>

<pre><code>Error LNK2001 unresolved external symbol ""public: __thiscall CryptoPP::CRC32::CRC32(void)"" (??0CRC32@CryptoPP@@QAE@XZ)  FoxFs   C:\Users\lazar\Desktop\eph2_live_src\Sources\X_thirdparty_src\FoxFS\FoxFS\FoxFS\ArchiveWriter.obj   1   
</code></pre>

<p>And my code/line with problems as well: </p>

<pre><code>CryptoPP::CRC32 crc;
crc.CalculateDigest(reinterpret_cast&lt;unsigned char*&gt;(&amp;index), reinterpret_cast&lt;const unsigned char*&gt;(fname.c_str()), fname.length());
</code></pre>

<p>My full code:</p>

<pre><code>#include ""ArchiveWriter.h""
#include ""../src/config.h""

#include ""../cryptopp/modes.h""
#include ""../cryptopp/aes.h""
#include ""../cryptopp/crc.h""
#include ""../cryptopp/osrng.h""
#include &lt;boost/crc.hpp&gt;

#pragma comment( lib, ""cryptopp.lib"" )

ArchiveWriter::ArchiveWriter()
{
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
    keys = INVALID_HANDLE_VALUE;
    file = INVALID_HANDLE_VALUE;
#else
    keys = -1;
    file = -1;
#endif
}
ArchiveWriter::~ArchiveWriter() { close(); }

bool ArchiveWriter::create(const char* filename, const char* keyfile)
{
    close();
    CryptoPP::AutoSeededRandomPool rng;
    unsigned char key[32], iv[32];
    FoxFS::TArchiveHeader header;
    header.magic = FOXFS_MAGIC;
    rng.GenerateBlock(header.key, 32);
    rng.GenerateBlock(header.iv, 32);
    rng.GenerateBlock(key, 32);
    rng.GenerateBlock(iv, 32);
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
    if (keyfile)
    {
        keys = CreateFileA(keyfile, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
        if (keys == INVALID_HANDLE_VALUE)
        {
            return false;
        }
    }
    file = CreateFileA(filename, GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
    if (file == INVALID_HANDLE_VALUE)
    {
        if (keys != INVALID_HANDLE_VALUE)
        {
            CloseHandle(keys);
            keys = INVALID_HANDLE_VALUE;
        }
        return false;
    }

    DWORD dwWritten;
    WriteFile(file, &amp;header, sizeof(header), &amp;dwWritten, 0);
    if (keys != INVALID_HANDLE_VALUE)
    {
        // write magic number?
        WriteFile(keys, key, 32, &amp;dwWritten, 0);
        WriteFile(keys, iv, 32, &amp;dwWritten, 0);

        for (int i = 0; i &lt; 4; ++i)
        {
            reinterpret_cast&lt;unsigned long long*&gt;(this-&gt;key)[i] = reinterpret_cast&lt;unsigned long long*&gt;(key)[i] ^ reinterpret_cast&lt;unsigned long long*&gt;(header.key)[i];
            reinterpret_cast&lt;unsigned long long*&gt;(this-&gt;iv)[i] = reinterpret_cast&lt;unsigned long long*&gt;(iv)[i] ^ reinterpret_cast&lt;unsigned long long*&gt;(header.iv)[i];
        }
    }
    else
    {
        memcpy(this-&gt;key, header.key, 32);
        memcpy(this-&gt;iv, header.iv, 32);
    }
#else
    if (keyfile)
    {
        keys = ::open(keyfile, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
        if (keys == -1)
        {
            return false;
        }
    }
    file = ::open(filename, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
    if (file == -1)
    {
        if (keys != -1)
        {
            ::close(keys);
            keys = -1;
        }
        return false;
    }

    write(file, &amp;header, sizeof(header));
    if (keys != -1)
    {
        // write magic number?
        write(keys, key, 32);
        write(keys, iv, 32);

        for (int i = 0; i &lt; 4; ++i)
        {
            reinterpret_cast&lt;unsigned long long*&gt;(this-&gt;key)[i] = reinterpret_cast&lt;unsigned long long*&gt;(key)[i] ^ reinterpret_cast&lt;unsigned long long*&gt;(header.key)[i];
            reinterpret_cast&lt;unsigned long long*&gt;(this-&gt;iv)[i] = reinterpret_cast&lt;unsigned long long*&gt;(iv)[i] ^ reinterpret_cast&lt;unsigned long long*&gt;(header.iv)[i];
        }
    }
    else
    {
        memcpy(this-&gt;key, header.key, 32);
        memcpy(this-&gt;iv, header.iv, 32);
    }
#endif
    return true;
}
void ArchiveWriter::close()
{
#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
    if (keys != INVALID_HANDLE_VALUE)
    {
        CloseHandle(keys);
        keys = INVALID_HANDLE_VALUE;
    }
    if (file != INVALID_HANDLE_VALUE)
    {
        CloseHandle(file);
        file = INVALID_HANDLE_VALUE;
    }
#else
    if (keys != -1)
    {
        ::close(keys);
        keys = -1;
    }
    if (file != -1)
    {
        ::close(file);
        file = -1;
    }
#endif
}

bool ArchiveWriter::add(const char* filename, unsigned int decompressed, unsigned int compressed, unsigned int hash, const void* data)
{
    unsigned int index = 0;
    std::string fname = filename;
    transform(fname.begin(), fname.end(), fname.begin(), tolower);
    for (int i = 0; i &lt; fname.length(); ++i)
    {
        if (fname[i] == '\\')
        {
            fname[i] = '/';
        }
    }

    CryptoPP::CRC32 crc;
    crc.CalculateDigest(reinterpret_cast&lt;unsigned char*&gt;(&amp;index), reinterpret_cast&lt;const unsigned char*&gt;(fname.c_str()), fname.length());

    unsigned short namelen = strlen(filename);
    FoxFS::TArchiveEntry entry;
    entry.decompressed = decompressed;
    entry.hash = hash;
    entry.offset = sizeof(entry);
    entry.size = compressed;
    entry.name = index;

    std::string fn = filename;
    transform(fn.begin(), fn.end(), fn.begin(), tolower);
    for (int i = 0; i &lt; fn.length(); ++i)
    {
        if (fn[i] == '\\')
        {
            fn[i] = '/';
        }
    }

    CryptoPP::CFB_Mode&lt;CryptoPP::AES&gt;::Encryption encoder(this-&gt;key, 32, this-&gt;iv);
    encoder.ProcessData(const_cast&lt;unsigned char*&gt;(reinterpret_cast&lt;const unsigned char*&gt;(data)), reinterpret_cast&lt;const unsigned char*&gt;(data), compressed);

#if defined(_WIN32) || defined(_WIN64) || defined(WIN32) || defined(WIN64)
    DWORD dwWritten;
    WriteFile(keys, &amp;namelen, sizeof(namelen), &amp;dwWritten, 0);
    WriteFile(keys, filename, namelen, &amp;dwWritten, 0);
    WriteFile(keys, &amp;hash, sizeof(hash), &amp;dwWritten, 0);

    LARGE_INTEGER m, p;
    m.QuadPart = 0;
    SetFilePointerEx(file, m, &amp;p, FILE_CURRENT);

    entry.offset += p.QuadPart;

    WriteFile(file, &amp;entry, sizeof(entry), &amp;dwWritten, 0);
    WriteFile(file, data, compressed, &amp;dwWritten, 0);
#else
    write(keys, &amp;namelen, sizeof(namelen));
    write(keys, filename, namelen);
    write(keys, &amp;hash, sizeof(hash));

    entry.offset += lseek(file, 0, SEEK_CUR);

    write(file, &amp;entry, sizeof(entry));
    write(file, data, compressed);
#endif
    return true;
}
</code></pre>

<p>If remove the <code>Cryptopp::CRC32 crc</code> and next layer, my building works.</p>
","<blockquote>
<pre><code>#include ""../cryptopp/crc.h""
...

#pragma comment( lib, ""cryptopp.lib"" )
</code></pre>
</blockquote>

<p>On Windows the static library name is <code>cryptlib.lib</code>. <code>cryptopp.lib</code> was used for the FIPS DLL, but you are probably not using it. Also see <a href=""https://www.cryptopp.com/wiki/Visual_Studio"" rel=""nofollow noreferrer"">Visual Studio</a> and <a href=""https://www.cryptopp.com/wiki/FIPS_DLL"" rel=""nofollow noreferrer"">FIPS DLL</a> on the Crypto++ wiki.</p>

<p>Runtime linker settings usually gives folks some trouble. Be sure to visit <a href=""https://www.cryptopp.com/wiki/Visual_Studio#Runtime_Linking"" rel=""nofollow noreferrer"">Runtime Linking</a> on the Crypto++ wiki, too.</p>

<p>You may have other problems, but we need to see the compile and link commands you are using along with the errors. I suspect you need to add an <a href=""https://stackoverflow.com/q/4445418/608639"">Additional Linker Path</a> so <code>cryptlib.lib</code> is found, but I need to see your commands and the errors.</p>
","52","<c++><windows><linker-errors><crc><crypto++>","1","0","1","2019-08-27 16:38:51","","3","","608639","","2019-08-27 13:10:28","2019-08-27 04:38:05",""
"42546924","Array parameter getting decayed","<p>I am trying to pass 2 byte arrays to a file encryption function I wrote. However, when I do both arrays are truncated to size 8 (from size 16) thus causing the function to not work properly. I am not sure what I am doing wrong here since the function parameters are simply pointing to the byte arrays. 
</p>

<pre><code>   CryptoPP::AutoSeededRandomPool prng;
   //Key generation
   byte key[AES::DEFAULT_KEYLENGTH];
   prng.GenerateBlock(key, sizeof(key));
   //IV generation
   byte iv[AES::BLOCKSIZE];
   prng.GenerateBlock(iv, sizeof(iv));



   //print key
   encoded.clear();
   StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

   //print iv
   encoded.clear();
   StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
   cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
   cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;

   //See function below
   encrypt_file(inFile, outFile, key, iv, err); 

   inFile.close();
   outFile.close();
</code></pre>

<p>Once in this function the bytes arrays are truncated for some reason</p>

<h2>Encrypt_file</h2>

<pre class=""lang-cpp prettyprint-override""><code>    bool encrypt_file(std::ifstream&amp; inFile,
       std::ofstream&amp; outFile,
       const byte* key, const byte* iv,
       std::string&amp; errMsg)
    {
       std::string encoded;
       //print key
       encoded.clear();
       StringSource(key, sizeof(key), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""key: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of key: "" &lt;&lt; sizeof(key) &lt;&lt; endl;

       //print iv
       encoded.clear();
       StringSource(iv, sizeof(iv), true, new HexEncoder(new StringSink(encoded)));
       cout &lt;&lt; ""iv: "" &lt;&lt; encoded &lt;&lt; endl;
       cout &lt;&lt; ""Size of iv: "" &lt;&lt; sizeof(iv) &lt;&lt; endl;
       try {
          CryptoPP::CBC_Mode&lt;CryptoPP::AES&gt;::Encryption e;
          e.SetKeyWithIV(key, sizeof(key), iv);
          CryptoPP::FileSource(inFile, true, new CryptoPP::StreamTransformationFilter(e, new CryptoPP::FileSink(outFile)));
          inFile.close();
          outFile.close();
       }
       catch (CryptoPP::Exception&amp; e) {
          errMsg = e.GetWhat();
          return false;
       }
       return true;
    }
</code></pre>

<h2>Output:</h2>

<pre><code>key: 6574D7BDFD0DD3BC59CD3846D4A196A8
Size of key: 16
iv: 1B4ED692F91A32246B41F63F6B8C6EAA
Size of iv: 16
key: 6574D7BDFD0DD3BC
Size of key: 8
iv: 1B4ED692F91A3224
Size of iv: 8
</code></pre>
","","50","<c++><arrays><pointers><crypto++>","0","","0","2017-03-02 05:59:09","","3","","608639","","2017-03-02 05:59:09","2017-03-02 04:32:57",""
"55416976","How to evaluate the time spent on digital signing using Omnet++ and Crypto++?","<p>I am doing a simulation in Omnet++ using the Crypto++ encryption library. I made an adaptation of Tic-Toc13 to send a message and digitally sign it (with the Crypto++ library). My interest is to evaluate the time it would take to complete this whole procedure, but the simulator does not take into account the processing time and the digital signature of the message. What do I need to do to make Omnet++ take this time into consideration? Thanks.</p>

<p>Code to sign the message:</p>

<pre><code>  string message(""MESSAGE TO SIGN"");
  //sign the message
  auto signature(RsaSignString(keys.privateKey, message));

  msg-&gt;setMessage0(message.c_str());
  msg-&gt;setSign0(signature.c_str());
</code></pre>

<p>Code to verify the message sign:</p>

<pre><code>    if (RsaVerifyString(keys.publicKey, ttmsg-&gt;getMessage0(), ttmsg-&gt;getSign0())) {
      cout &lt;&lt; ""Signatue OK!"" &lt;&lt; endl;
    } else {
      cout &lt;&lt; ""Signatue NOT OK!"" &lt;&lt; endl;
    }
</code></pre>
","","48","<c++><time><omnet++><crypto++>","0","","0","2019-04-02 01:27:30","","5","","608639","","2019-04-02 01:27:30","2019-03-29 11:59:19",""
"34277709","How to forward file content to StringSink with Crypto++?","<p><br>
I'm using some test code for Crypto++ just to get used to it.<br>
There's a function:  </p>

<pre><code>void DecryptFile(const char *in, const char *out, const char *passPhrase)
{
    FileSource f(in, true, new DefaultDecryptorWithMAC(passPhrase, new FileSink(out)));
}
</code></pre>

<p>where <code>DecryptFile</code> is <code>#define DecryptFile DecryptFileW</code> (I'm on Windows).</p>

<p>So, file deciphering is called via <code>DecryptFile(name_f.c_str(), ""decrypted_alphabet.txt"", cpass);</code><br>
If <code>cpass</code> is correct, then the contents of <code>name_f.c_str()</code> file is written to <code>decrypted_alphabet.txt</code>.</p>

<p><strong>Now the problem</strong>: I can't find the way to forward file contents to <code>StringSink</code> rather than to a file! I tried manually calling this:</p>

<pre><code>string out;
FileSource (in, true, new DefaultDecryptorWithMAC(cpass, new StringSink(out)));
</code></pre>

<p>but this returns some crappy characters like <code>ъ!$</code> or <code>5(#</code> (every time new). Maybe I can't explain my problem properly, so, here's piece of code, where I try to crack a 4-digit protected txt file: <a href=""http://pastebin.com/FJng91Y6"" rel=""nofollow"">http://pastebin.com/FJng91Y6</a></p>
","<blockquote>
  <p>How to forward file content to StringSink with Crypto++?<br>
  ...<br>
  Now the problem: I can't find the way to forward file contents to
  StringSink rather than to a file! I tried manually calling this:</p>

<pre><code>string out;
FileSource (in, true, new DefaultDecryptorWithMAC(cpass, new StringSink(out)));
</code></pre>
</blockquote>

<p>This is working as expected.</p>

<hr>

<blockquote>
  <p>but this returns some crappy characters like ъ!$ or 5(# (every time new). Maybe I can't explain my problem properly, so, here's piece of code, where I try to crack a 4-digit protected txt file</p>
</blockquote>

<p>Yes, that sounds about right (if I am reading it correctly). You are generating collisions on the 4-digit passcode. To avoid the collisions, you need a longer passphrase.</p>

<hr>

<p>Maybe you should finish enumerating the combinations rather than stopping the processing on the first match:</p>

<pre><code>if (strlen(cpass) &gt; 0){
    printf(""Alphabet password is: %s\n"", cpass);
    return;
}
</code></pre>

<p>Collect all the potential decryption, and then further analyze them looking for a ""good"" decryption. Maybe you should save them to a file using the PIN:</p>

<ul>
<li>decrypt.1234</li>
<li>decrypt.4287</li>
<li>decrypt.6862</li>
<li>decrypt.8946</li>
</ul>
","46","<crypto++>","2","1","1","2015-12-16 04:11:44","34303748","0","","","","","2015-12-14 22:21:33",""
"58493934","How to sign a file via Crypto++ and RSA","<p>I'm trying to sign a file with my private key using the following function:</p>

<pre><code>void Signer::SignFile(const std::string&amp; file)
{
    RSASS&lt;PSSR, Whirlpool&gt;::Signer signer(rsaPrivate);

    // Encrypt and write
    FileSource ss1(file.c_str(), true,
        new SignerFilter(rng, signer,
                new FileSink(file.c_str(), true)
            , true));
}
</code></pre>

<p>As an outcome my target file gets overwritten with the signature. Why does that happen? Obviously I'd like to append it to the file, that's why I also added an extra ""true"" parameter for the ""putMessage"".</p>
","<blockquote>
<pre><code>FileSource ss1(file.c_str(), true,
    new SignerFilter(rng, signer,
        new FileSink(file.c_str(), true), true));
</code></pre>
</blockquote>

<p>I [personally] have never seen someone use the same file as a source and sink. Usually the file data and signature are separate like with a detached signature.</p>

<p>It looks like one file/two streams is implementation defined: <a href=""https://stackoverflow.com/q/25983180/608639"">C++ read and write to same file using different streams</a>. I guess you should expect seemingly random results on different platforms.</p>

<blockquote>
  <p>As an outcome my target file gets overwritten with the signature. Why does that happen?</p>
</blockquote>

<p>The <code>FileSink</code> opens with <code>std::ios_base::tunc</code>. Also see <a href=""https://cryptopp.com/wiki/FileSink"" rel=""nofollow noreferrer"">FileSink</a> on the Crypto++ wiki.</p>

<p>You should probably do something like this. It saves the signature to an intermediate <code>ByteQueue</code>, and then writes the queue to the file once the file is closed.</p>

<pre class=""lang-cxx prettyprint-override""><code>#include ""cryptlib.h""
#include ""filters.h""
#include ""osrng.h""
#include ""files.h""
#include ""pssr.h""
#include ""rsa.h""
#include ""whrlpool.h""

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;
    std::string fname(""test.bin"");

    ///// Create test message /////
    {
    std::string msg(""Yoda said, Do or do not. There is no try."");
    std::ofstream out(fname.c_str());
    out.write(msg.data(), msg.size());
    }

    ///// Generate a key /////
    RSASS&lt;PSSR, Whirlpool&gt;::Signer signer;
    signer.AccessKey().GenerateRandomWithKeySize(prng, 2048);

    ///// Sign the message /////
    ByteQueue queue;
    {
    FileSource source(fname.c_str(), true,
        new SignerFilter(prng, signer,
            new Redirector(queue)));
    }

    ///// Append the signature /////
    {
    std::ofstream out(fname.c_str(), std::ios_base::out | std::ios_base::binary | std::ios_base::app);
    queue.TransferTo(FileSink(out).Ref());
    }

    ///// Create a verifier /////
    RSASS&lt;PSSR, Whirlpool&gt;::Verifier verifier(signer);

    ///// Verify the message /////
    {
    FileSource source(fname.c_str(), true,
        new SignatureVerificationFilter(verifier, NULLPTR,
            SignatureVerificationFilter::THROW_EXCEPTION));
    }

    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>It does not crash and it appends the message as expected:</p>

<pre><code>$ ./test.exe
Verified signature on message

$ hexdump -C test.bin
00000000  59 6f 64 61 20 73 61 69  64 2c 20 44 6f 20 6f 72  |Yoda said, Do or|
00000010  20 64 6f 20 6e 6f 74 2e  20 54 68 65 72 65 20 69  | do not. There i|
00000020  73 20 6e 6f 20 74 72 79  2e 19 f2 1c 8f f9 cb 2f  |s no try......./|
00000030  f2 38 9f a8 3b a9 0b 8b  62 25 56 a8 ea 81 7e 60  |.8..;...b%V...~`|
00000040  22 55 38 ce 79 7f 32 95  a5 1a 75 c1 80 ad b2 c2  |""U8.y.2...u.....|
00000050  6f ce a5 f7 bd 4b d3 3f  e4 b3 69 00 21 60 d7 09  |o....K.?..i.!`..|
00000060  a8 71 9b 5f 41 d6 66 b1  80 f1 de 00 26 19 34 01  |.q._A.f.....&amp;.4.|
00000070  b3 65 1b 78 e2 32 71 be  bc 07 25 78 36 6b 56 4e  |.e.x.2q...%x6kVN|
00000080  26 4e 12 9e a8 bb 72 86  ee 0d 70 b2 f1 bd a3 2c  |&amp;N....r...p....,|
00000090  14 fd 12 61 35 98 4a 80  9f ee 3c 31 d3 70 26 0f  |...a5.J...&lt;1.p&amp;.|
000000a0  73 a0 5d 36 ef 96 56 65  f8 ac 3a fb 44 c3 04 76  |s.]6..Ve..:.D..v|
000000b0  e5 2f ae 92 84 be 40 34  f6 4b b8 84 aa bd 67 74  |./....@4.K....gt|
000000c0  05 43 91 d2 e6 b1 50 dd  6d 64 47 cc 3e 3c 3a 9d  |.C....P.mdG.&gt;&lt;:.|
000000d0  67 ff 4f 38 c1 a5 a6 d5  92 45 bc 2d ff 96 30 3a  |g.O8.....E.-..0:|
000000e0  1d 3a 42 4f 8c 13 2d 4c  3f e9 ad 08 a6 b3 5e fa  |.:BO..-L?.....^.|
000000f0  46 08 24 17 43 ce ed ec  f7 1a 38 62 e7 bf 42 93  |F.$.C.....8b..B.|
00000100  84 44 b6 05 22 9e e3 bd  80 a6 08 b0 34 d0 a4 89  |.D.."".......4...|
00000110  78 48 20 7f 7b 33 1c 51  9d 48 b5 b7 f7 de 2f dd  |xH .{3.Q.H..../.|
00000120  d7 74 7b af 04 cd 92 fc  1c                       |.t{......|
</code></pre>

<hr>

<p>I was not able to get this to work. I'm pretty sure it is a dead end.</p>

<pre class=""lang-cxx prettyprint-override""><code>std::fstream inout(fname.c_str(), std::ios_base::in | std::ios_base::out | std::ios_base::binary | std::ios_base::app);
FileSource fs(inout, true,
    new SignerFilter(prng, signer,
        new FileSink(inout), true));
</code></pre>

<hr>

<blockquote>
  <p>Obviously I'd like to append it to the file, that's why ...</p>
</blockquote>

<p>Also, because you are using PSSR, you don't need the original message. PSSR is <em>""probabilistic signature scheme with recovery""</em>. The message is include in the signature with a mask function.</p>

<p>You would need the original message with a SSA scheme. SSA is <em>""signature scheme with appendix""</em>. In a SSA scheme you need to provide both the original message and the signature.</p>

<hr>

<p>(From the comments) Here is an example that uses a Signature Scheme with Appendix (SSA). It also uses <code>std::iftream</code> and <code>std::ofstream</code> directly so <code>FileSource</code> and <code>FileSink</code> work as you expect. <code>std::ofstream</code> includes <code>std::ios_base::app</code> so the signature is appended.</p>

<pre class=""lang-cpp prettyprint-override""><code>#include ""cryptlib.h""
#include ""filters.h""
#include ""osrng.h""
#include ""files.h""
#include ""oaep.h""
#include ""rsa.h""
#include ""sha.h""

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;
    AutoSeededRandomPool prng;
    std::string fname(""test.bin"");

    ///// Create test message /////
    {
    std::string msg(""Yoda said, Do or do not. There is no try."");
    std::ofstream out(fname.c_str());
    out.write(msg.data(), msg.size());
    }

    ///// Generate a key /////
    RSASS&lt;PKCS1v15, SHA256&gt;::Signer signer;
    signer.AccessKey().GenerateRandomWithKeySize(prng, 2048);

    {
    ///// Create fstreams for input and output /////
    std::ifstream fin(fname.c_str(), std::ios_base::in | std::ios_base::binary);
    std::ofstream fout(fname.c_str(), std::ios_base::out | std::ios_base::binary | std::ios_base::app);

    ///// Sign the message /////
    FileSource source(fin, true,
        new SignerFilter(prng, signer,
            new FileSink(fout)));
    }

    ///// Create a verifier /////
    RSASS&lt;PKCS1v15, SHA256&gt;::Verifier verifier(signer);

    ///// Verify the message /////
    {
    FileSource source(fname.c_str(), true,
        new SignatureVerificationFilter(verifier, NULLPTR,
            SignatureVerificationFilter::THROW_EXCEPTION));
    }

    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>And then:</p>

<pre><code>$ ./test.exe
Verified signature on message

$ hexdump -C test.bin
00000000  59 6f 64 61 20 73 61 69  64 2c 20 44 6f 20 6f 72  |Yoda said, Do or|
00000010  20 64 6f 20 6e 6f 74 2e  20 54 68 65 72 65 20 69  | do not. There i|
00000020  73 20 6e 6f 20 74 72 79  2e c7 b3 6f 84 1d fd bf  |s no try...o....|
00000030  c7 c8 38 7c 89 b1 f3 42  ee 5e f8 10 de a8 01 7f  |..8|...B.^......|
00000040  7f a5 24 3d 27 7e 55 16  bc 80 8b 21 21 75 3d ed  |..$='~U....!!u=.|
00000050  41 05 84 b1 3d bf d3 ae  3a 2f a8 81 7a e7 e4 ae  |A...=...:/..z...|
00000060  50 d7 9b 25 04 17 a6 a3  1d 12 e2 8e cd 7a 02 42  |P..%.........z.B|
00000070  91 c0 d7 fc 43 09 94 a2  66 d9 67 95 55 5e dc 8c  |....C...f.g.U^..|
00000080  eb bc 20 af e8 5c d4 63  05 d4 2c 48 57 6d f1 fe  |.. ..\.c..,HWm..|
00000090  26 16 80 c3 41 11 58 8e  8d b0 cb 48 95 b9 ed 94  |&amp;...A.X....H....|
000000a0  84 cc 86 0f a4 7e a3 6a  ff 0d 0d 24 17 82 13 94  |.....~.j...$....|
000000b0  54 cb 8a ca 04 1e 65 18  c3 ab a2 3f 4d 44 de 42  |T.....e....?MD.B|
000000c0  32 07 29 e4 95 83 cc ff  39 85 08 bf d5 61 46 db  |2.).....9....aF.|
000000d0  e0 96 d6 69 25 b9 ce 1e  3e bc 63 81 e5 16 bd 12  |...i%...&gt;.c.....|
000000e0  a0 78 02 19 60 96 80 36  7d a5 79 be 0f 45 54 f4  |.x..`..6}.y..ET.|
000000f0  92 af f0 d8 74 65 7d 45  98 c7 bb 7f 6e 9b e3 cd  |....te}E....n...|
00000100  c0 60 91 0f 78 aa 7c 77  a7 f5 4e 7d 6e ed e1 4c  |.`..x.|w..N}n..L|
00000110  8e 5e 96 ac cd 30 16 e0  2d be 9e 2d 68 d4 25 46  |.^...0..-..-h.%F|
00000120  86 77 87 be 68 ef 06 26  55                       |.w..h..&amp;U|

</code></pre>
","45","<c++><visual-c++><crypto++>","1","1","1","2019-10-22 09:32:36","58495217","1","","608639","","2019-10-21 23:29:33","2019-10-21 20:48:33",""
"54042024","Can't load 64bit crypto++ library. Wrong path","<p>I use in project the crypto++ library. It works fine.
When I try to add 64bit version I got the error:</p>

<pre><code>   Caused by: java.lang.UnsatisfiedLinkError: dlopen failed: library ""D:/AndroidStudioProjects/Proj/app/src/main/obj/local/arm64-v8a/libcryptopp.so"" not found
W/System.err:     at java.lang.Runtime.loadLibrary0(Runtime.java:1016)
W/System.err:     at java.lang.System.loadLibrary(System.java:1657)
</code></pre>

<p>To use 64bit version cryptopp I built this one for arm64-v8a arch.
Then I run ndk-build with make-files:
<strong>Android.mk:</strong></p>

<pre><code>LOCAL_PATH:= $(call my-dir)

include $(CLEAR_VARS)

LOCAL_MODULE := cryptopp
LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libcryptopp.so
LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include
include $(PREBUILT_SHARED_LIBRARY)
</code></pre>

<p><strong>Application.mk:</strong></p>

<pre><code>APP_ABI := arm64-v8a
APP_CPPFLAGS += -fexceptions -frtti
APP_STL := stlport_shared
</code></pre>

<p>After I run app on device. I had error above. Why the system search library in wrong path ""<code>D:/AndroidStudioProjects/Proj/app/src/main/obj/local/arm64-v8a/libcryptopp.so</code>""? It is path from my computer.</p>
","","42","<android><android-ndk><crypto++>","1","","0","2019-01-07 13:46:01","","3","","8034839","","2019-01-07 13:46:01","2019-01-04 15:39:56","2019-03-29 15:04:07"
"58348681","How to use Crypto++ to create a license key manager (generator and checker)?","<p>I would like to know how most of the software developers create their own licensing key system.</p>

<p>I would like to create my own one for my software application.</p>

<p>I believe it is something related to cryptography.</p>

<p>As I am already using <strong>Crypto++</strong> library in my application for <strong>MD5</strong> and <strong>SHA1</strong> hashing, I would be happy and thankful if someone with expertise explain to me how to do it.</p>

<p><strong>NB:</strong> I mainly use <strong>C++</strong> in my coding.</p>

<p>Also, I need it to be related to a hardware number obtained from a USB connected SIM card in the format of <strong>123456789</strong>, so the end-user will only send me that number and I will send him back the license key.</p>

<p>TIA.</p>
","","42","<c++><crypto++><license-key>","0","","0","2019-10-11 21:47:32","","3","","12132883","","2019-10-11 21:47:32","2019-10-11 21:30:05",""
"58123211","Crypto++ : CFB_Mode_ExternalCipher not working","<p>This is how the code look likes. Is there anything wrong with this.
The recover text does not match.</p>

<pre><code>AES::Encryption aes1(key, key.size());
CFB_Mode_ExternalCipher::Encryption cfbEncryption(aes1, iv);
AES::Decryption aes2(key, key.size());
CFB_Mode_ExternalCipher::Decryption cfbDecryption(aes2, iv);

ArraySink cipherSink(cipher, data_size);
ArraySource ss1(plain, data_size, true, new StreamTransformationFilter(cfbEncryption, new Redirector(cipherSink)));

ArraySink recoverSink(recover, data_size);
ArraySource ss2(cipher, data_size, true, new StreamTransformationFilter(cfbDecryption, new Redirector(recoverSink)));
</code></pre>
","<p>When using CTR Mode External Cipher in transformation, encryption is used for decryption as well.</p>

<p><a href=""https://www.codeproject.com/Articles/21877/Applied-Crypto-Block-Ciphers"" rel=""nofollow noreferrer"">https://www.codeproject.com/Articles/21877/Applied-Crypto-Block-Ciphers</a></p>
","41","<c++><encryption><aes><crypto++><cfb-mode>","1","1","1","2019-09-26 22:26:01","58125486","0","","","","","2019-09-26 19:03:23",""
"50800941","Client send message but Server dont receive message until client ends program","<pre><code>    do{

        /// send msgs
        cout &lt;&lt; ""Client: "";
        cin.getline(clientMSG, 1024, '\n');

        if(strcmp(clientMSG, ""quit"") == 0){

            StringSource msgEncryptor(clientMSG, true, new StreamTransformationFilter(encrypt, new StringSink(encryptMSG)));
            StringSource encryptEncode(encryptMSG, true, new HexEncoder(new StringSink(encodeMSG)));

            memset(clientSEND, '\0', 3000);
            copy(encodeMSG.begin(), encodeMSG.end(), clientSEND);

            send(sock, clientSEND, strlen(clientSEND), 0);

            break;
        }

        StringSource msgEncryptor(clientMSG, true, new StreamTransformationFilter(encrypt, new StringSink(encryptMSG)));
        StringSource encryptEncode(encryptMSG, true, new HexEncoder(new StringSink(encodeMSG)));

        memset(clientSEND, '\0', 3000);
        copy(encodeMSG.begin(), encodeMSG.end(), clientSEND);

        send(sock, clientSEND, strlen(clientSEND), 0);

        /** ------------------------------------------------ **/

        /// receive msgs
        memset(clientRECV, '\0', 3000);
        valread = read(sock, clientRECV, 3000);

        StringSource encryptDecode(clientRECV, true, new HexDecoder(new StringSink(decodeMSG)));
        StringSource msgDecryptor(decodeMSG, true, new StreamTransformationFilter(decrypt, new StringSink(decryptMSG)));

        cout &lt;&lt; ""Server: "" &lt;&lt; decryptMSG &lt;&lt; endl;





    }while(1);
</code></pre>

<p>Above is the client program</p>

<pre><code>do{

        /// receive msgs

        memset(serverRECV, '\0', 3000);
        valread = read(new_socket, serverRECV, 3000);

        StringSource encryptDecode(serverRECV, true, new HexDecoder(new StringSink(decodeMSG)));
        StringSource msgDecryptor(decodeMSG, true, new StreamTransformationFilter(decrypt, new StringSink(decryptMSG)));

        if(decryptMSG == ""quit""){
            cout &lt;&lt; ""Client disconnected!"" &lt;&lt; endl;
            break;
        }

        cout &lt;&lt; ""Client: "" &lt;&lt; decryptMSG &lt;&lt; endl;

        /** ------------------------------------------------------------------------ **/

        /// send msgs

        cout &lt;&lt; ""Server: "";
        cin.getline(serverMSG, 1024, '\n');

        if(strcmp(serverMSG, ""quit"") == 0){
            StringSource msgEncryptor(serverMSG, true, new StreamTransformationFilter(encrypt, new StringSink(encryptMSG)));
            StringSource encryptEncode(encryptMSG, true, new HexEncoder(new StringSink(encodeMSG)));

            memset(serverSEND, '\0', 3000);
            copy(encodeMSG.begin(), encodeMSG.end(), serverSEND);

            send(new_socket, serverSEND, strlen(serverSEND), 0);

            break;
        }

        StringSource msgEncryptor(serverMSG, true, new StreamTransformationFilter(encrypt, new StringSink(encryptMSG)));
        StringSource encryptEncode(encryptMSG, true, new HexEncoder(new StringSink(encodeMSG)));

        memset(serverSEND, '\0', 3000);
        copy(encodeMSG.begin(), encodeMSG.end(), serverSEND);

        send(new_socket, serverSEND, strlen(serverSEND), 0);

        cin.clear();
        memset(serverMSG, '\0', 3000);
    }while(1);
</code></pre>

<p>this one is the server.</p>

<p>I'm trying to code some socket program and i suddenly faced this issue where when the client sends a message, the server doesn't display it until i force end the program. </p>

<p>The program is supposed to start with the client entering a message then encrypting the message and sending it to the server. Then, the server will decrypt it and display the message. But i don't understand why is it not displaying the message only when i end the program it displays...</p>

<p>Am i using the wrong way of send/read? I'm pretty sure it's not the encrypt/decrypt problem because i see the message at the server side when i end the program at the client side.</p>
","<p>I assume you didn't setup your socket as non-blocking, but that line on server-side :</p>

<pre><code>valread = read(new_socket, serverRECV, 3000);
</code></pre>

<p>... is trying to read 3000 bytes from the socket. The read() function blocks the current thread until all data have been read from the descriptor. Closing the program aborts read() and the rest of the code is executed at this time.</p>

<p>With your code, make sure that the client sends 3000 bytes if you wish your server to process it.</p>

<p>If you wish to perform non-blocking read, you should set your socket accordingly :</p>

<pre><code>int flags = fcntl(new_socket, F_GETFL, 0);
fcntl(new_socket, F_SETFL, flags | O_NONBLOCK);
</code></pre>

<p>Beware, thought, that you'll need to check a lot of return values for read(), and create a a logic where you read from the socket until you received the correct amount of bytes.</p>
","41","<c++><aes><crypto++>","-1","0","1","2018-11-11 04:56:35","","2","","","","","2018-06-11 15:12:15",""
"58509738","ERROR: ASSERTION FAILED while using Crypto++ function","<p>I'm writing the following code using the Crypto++ library for elliptic curve cryptography. My test program gives an assertion failed error when I assign the value to the variables loop1 and loop2 more than 7 or 8, else it executes fine. The error comes inside the if statement where Z[i][j] is assigned the value.</p>

<p>Also, when I execute the code without assigning the Z[i][j] in the if statement it executes fine. I'm not able to understand why I'm facing this error. Can someone please help in this issue? </p>

<pre><code>ECP::Point Z[loop1][loop2];

for (int i = 0; i &lt; loop1; i++)
{
    for (int j = 0; j &lt; loop2; j++)
    {
        if (r[i][j] &lt; 0)
        {
            Pr = r[i][j] + v[i][j];
            Z[i][j] = group.GetCurve().ScalarMultiply(ng, -Pr);
        }
        else
        {
            Z[i][j] = group.GetCurve().ScalarMultiply(g, r[i][j] + v[i][j]);
        }
    }
}
</code></pre>
","","40","<c++><visual-studio><crypto++><elliptic-curve>","-1","","0","2019-10-22 19:03:43","","2","","608639","","2019-10-22 19:03:43","2019-10-22 17:44:28",""
"54476322","Getting Link errors when crypto++ lib used in my MFC application","<p>I am trying to encrypt some files using crypto++. I have found a useful article.
<a href=""http://programmingknowledgeblog.blogspot.com/2013/04/compiling-and-integrating-crypto-into.html"" rel=""nofollow noreferrer"">http://programmingknowledgeblog.blogspot.com/2013/04/compiling-and-integrating-crypto-into.html</a></p>

<p>I have created a sample project as in the tutorial. It works fine. Then I have tried to use the same in my MFC application. I have linked the cryptlib.lib correctly in project properties. But I am getting lot of LINK errors.</p>

<p><a href=""https://i.stack.imgur.com/uIrbn.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/uIrbn.png"" alt=""enter image description here""></a> </p>

<p>I have tried by changing the <strong>Runtime Library</strong> to <strong>Multi-threaded Debug (/MTd)</strong> and <strong>Use of MFC</strong> as <strong>Use MFC in a Shared DLL</strong>. Thanks in advance.</p>
","","39","<encryption><mfc><aes><linker-errors><crypto++>","0","","0","2019-02-01 09:15:38","","2","","","","","2019-02-01 09:15:38",""
"31325260","GCM with queues","<p>I'm looking to encrypt a file scattered with (custom) start/end markers using AES/GCM, such that the output file contains plain text and encrypted sections as needed.  Crypto++ library seems to be a good candidate.  I can think of various ways to do it, but I am hazy on the most appropriate.</p>

<p>My shot in the dark:</p>

<ol>
<li>Setup a FileSource/Sink pipeline with no pumping</li>
<li>Loop

<ul>
<li>Write/put plain data to sink/ofstream</li>
<li>Place MessageEnd() after start and before end markers</li>
<li>Pump message</li>
</ul></li>
</ol>

<p>I'm not sure if it makes sense, or exactly how for that matter, to make use of IsolatedInitiliaze with ValueNames()?  Any help is much appreciated.</p>
","","38","<c++><file-io><crypto++>","0","","0","2015-07-09 18:17:42","","4","","","","","2015-07-09 18:17:42",""
"44171975","Some functions use new to allocate memory but no free memory? Will lead to memory leak?","<p>Using Crypto++, example is :</p>

<pre><code>StreamTransformationFilter stfEncryptor(cbcEncryption, new StringSink( ciphertext ) );
stfEncryptor.Put( reinterpret_cast&lt;const unsigned char*&gt;( plaintext.c_str() ), plaintext.length() + 1 );
stfEncryptor.MessageEnd();
</code></pre>

<p>Why use new to allocate memory but no free memory? Will it lead to memory leak? </p>
","","37","<c++><memory-leaks><crypto++>","0","","0","2017-05-25 04:47:19","","2","","608639","","2017-05-25 04:47:19","2017-05-25 03:50:52","2017-05-25 04:56:05"
"58740447","Confusion regarding scope resolution operator","<p>I am trying to create a program that run chacha encryption. However, I kept getting this problem </p>

<blockquote>
  <p>‘ChaCha’ has not been declared</p>
</blockquote>

<p>I tried to change the code from</p>

<pre><code>CryptoPP::ChaCha::Encryption
</code></pre>

<p>to</p>

<pre><code>CryptoPP::ChaCha20::Encryption
</code></pre>

<p>but doing that gave me a long list of error.</p>

<p>I also tried using the example code from cryptopp website, but I got the same problem regarding 'ChaCha' has not been declared.</p>

<pre><code>    // Encryption object
    ChaCha::Encryption enc;    
    enc.SetKeyWithIV(key, key.size(), iv, iv.size());
</code></pre>

<p>Here's the compiling error</p>

<blockquote>
  <p>testingchacha.cpp:38:5: error: ‘ChaCha’ has not been declared
  ChaCha::Encryption enc;</p>
</blockquote>
","<p>You are using an old version of the library.</p>

<p>The name changed from <code>ChaCha20</code> to <code>ChaCha</code>, see commit <a href=""https://github.com/weidai11/cryptopp/commit/e2be0cdecce71940682219c067d871c5477a6418#diff-0984eb0851e6ecb84db1cf11faf2a92aL74"" rel=""nofollow noreferrer"">here</a>.</p>

<p>You need at least version 8.1, see also <a href=""https://github.com/weidai11/cryptopp/issues/807#issuecomment-463413636"" rel=""nofollow noreferrer"">this issue on github</a>.</p>

<p>Update the library and if you are getting a long list of errors when using the correct name, then you should probably ask about that instead.</p>
","35","<c++><crypto++>","0","0","1","2019-11-07 01:07:48","58740566","1","1","","","","2019-11-07 00:47:57",""
"58338993","Application crashes when signing message with Crypto++ ECDSA under Xcode?","<p>I am performing ECDSA signing on Mac OS with Crypto++. The command line is OK, but under Xcode <code>EXC_BAD_ACCESS</code> error occurs on signing message.</p>

<p>The tests in <code>cryptest.exe</code> from the command line passes. <code>cryptest.exe</code> is the library's validation program.</p>

<p>I have tried to build the library using clang++ and libc++, and build it with XCode, all have this issue.</p>

<pre><code>clang++ -DNDEBUG -g2 -O2 -stdlib=libc++ -DCRYPTOPP_DISABLE_MIXED_ASM -fPIC -pthread -pipe -c 
</code></pre>

<p>Here is the code.</p>

<pre><code>AutoSeededRandomPool prng;

ECDSA&lt;ECP, SHA256&gt;::PrivateKey k1;   
k1.Initialize( prng, ASN1::secp256r1() );

ECDSA&lt;ECP, SHA256&gt;::PublicKey pKey;
k1.MakePublicKey( pKey );

const ECP::Point&amp; q = pKey.GetPublicElement();    
const Integer&amp; qx = q.x;
const Integer&amp; qy = q.y;

std::cout &lt;&lt; ""x: "" &lt;&lt; std::hex &lt;&lt; qx &lt;&lt; std::endl;    
std::cout &lt;&lt; ""y: "" &lt;&lt; std::hex &lt;&lt; qy &lt;&lt; std::endl;

const Integer&amp; x = k1.GetPrivateExponent();
std::cout &lt;&lt; ""K1: "" &lt;&lt; std::hex &lt;&lt; x &lt;&lt; std::endl;

ByteQueue queue;
k1.Save(queue);

ECDSA&lt;ECP, SHA256&gt;::Signer signer(k1);

std::string message = ""Do or do not. There is no try."";
size_t siglen = signer.MaxSignatureLength();
std::string signature(siglen, 0x00);

siglen = signer.SignMessage( prng, (const byte*)&amp;message[0], message.size(), (byte*)&amp;signature[0] );
signature.resize(siglen);
</code></pre>

<p>I'm attaching stack trace below:</p>

<pre><code>* thread #1: tid = 0x15fc20, 0x00007fff910a9d26 libsystem_platform.dylib`_platform_bzero$VARIANT$Merom + 22, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)
  frame #0: 0x00007fff910a9d26 libsystem_platform.dylib`_platform_bzero$VARIANT$Merom + 22  
* frame #1: 0x00000001000ccc23 testCrypto`CryptoPP::DL_SignatureMessageEncodingMethod_DSA::ComputeMessageRepresentative(this=&lt;unavailable&gt;, rng=&lt;unavailable&gt;, recoverableMessage=&lt;unavailable&gt;,   
  recoverableMessageLength=&lt;unavailable&gt;, hash=0x0000000104e7df30, hashIdentifier=&lt;unavailable&gt;, messageEmpty=false, representative=0x0000000000000000, representativeBitLength=&lt;unavailable&gt;) const + 83 at gfpcrypt.cpp:96  
  frame #2: 0x0000000100019ae8 testCrypto`CryptoPP::DL_VerifierBase&lt;CryptoPP::EC2NPoint&gt;::VerifyAndRestart(this=0x00007fff5fbfdab8, messageAccumulator=0x0000000104e7de40) const + 568 at pubkey.h:1693 
  frame #3: 0x0000000100034c1e testCrypto`CryptoPP::PK_Verifier::VerifyMessage(this=0x00007fff5fbfdab8, message=&lt;unavailable&gt;, messageLen=&lt;unavailable&gt;, signature=&lt;unavailable&gt;, signatureLen=&lt;unavailable&gt;) const + 94 at cryptlib.cpp:942
  frame #4: 0x000000010000464a testCrypto`ValidateECDSA() + 2762 at main.cpp:257
  frame #5: 0x0000000100004a35 testCrypto`main(argc=1, argv=0x00007fff5fbff9e0) + 53 at main.cpp:272
  frame #6: 0x00007fff8fec95c9 libdyld.dylib`start + 1
</code></pre>
","<p>I use Xcode to build the project to create a library, then can call the library without errors.</p>
","35","<xcode><macos><crypto++><ecdsa>","1","0","1","2019-10-21 08:48:05","","4","","608639","","2019-10-16 10:59:46","2019-10-11 10:08:59",""
"58321151","Why Crypto++ SecByteBlock subscripting works","<p>I'm trying to understand why following code using Crypto++ SecByteBlock works:</p>

<pre><code>SecByteBlock block(10);
std::cout &lt;&lt; block[3];
</code></pre>

<p>It's like <code>SecByteBlock</code> has an subscript (<code>operator[]</code>) but I can't find it (version 8.2.0, but not present in older versions too). I'm compiling with C++14. Any ideas?</p>
","<p>That type has a <a href=""https://www.cryptopp.com/docs/ref/class_sec_block.html#ab7b3f34a0d3670f8f1358bbd72c74716"" rel=""nofollow noreferrer"">conversion</a> to (const) <code>byte *</code>, which is then used as a basis for indexing.</p>
","35","<c++><operator-overloading><crypto++>","2","1","1","2019-10-19 22:55:04","58321274","0","","608639","","2019-10-19 22:55:04","2019-10-10 10:46:47",""
"58482869","What is the correct way to use ECDSA in Crypto++","<p>When I verify a signature using ECDSA verifier in Crypto++, if the public key is incorrect the method just crash the application. Should I try catch the exception? What is the best way to handle this?</p>

<p>Thanks!</p>
","<blockquote>
  <p>... should I try catch the exception? What is the best way to handle this?</p>
</blockquote>

<p>It depends on how you want to do it. I think there are three options.</p>

<p>The information below is from <a href=""https://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">Elliptic Curve Digital Signature Algorithm</a> and <a href=""https://www.cryptopp.com/wiki/SignatureVerificationFilter"" rel=""nofollow noreferrer"">SignatureVerificationFilter</a> on the Crypto++ wiki.</p>

<p>First, you can catch the <code>SignatureVerificationFailed</code> exception if you like:</p>

<pre class=""lang-cpp prettyprint-override""><code>try
{
    DSA::Verifier verifier(publicKey);
    StringSource ss2(message+signature, true,
        new SignatureVerificationFilter(
            verifier, NULL, THROW_EXCEPTION
            /* SIGNATURE_AT_END */
       )
    );

    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
}
catch (SignatureVerificationFailed&amp; ex)
{
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
}
</code></pre>

<p>Second, you can get the result as a boolean value. Notice lack of <code>THROW_EXCEPTION</code>:</p>

<pre class=""lang-cpp prettyprint-override""><code>bool result = false;
StringSource ss(message+signature, true,
    new SignatureVerificationFilter(
        verifier,
        new ArraySink(
            (byte*)&amp;result, sizeof(result)),
        PUT_RESULT | SIGNATURE_AT_END
   )
);

if(result)
    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
else
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
</code></pre>

<p>Third, you can forgo pipelines and just call <code>VerifyMessage</code> on the <code>Verifier</code> object:</p>

<pre class=""lang-cpp prettyprint-override""><code>bool result = verifier.VerifyMessage(ConstBytePtr(message), BytePtrSize(message), ConstBytePtr(signature), BytePtrSize(signature));
if(result)
    std::cout &lt;&lt; ""Verified signature on message"" &lt;&lt; std::endl;
else
    std::cerr &lt;&lt; ""Failed to verify signature on message"" &lt;&lt; std::endl;
</code></pre>
","34","<c++><crypto++><ecdsa>","1","0","1","2019-10-21 16:28:37","58486296","1","","608639","","2019-10-21 12:27:42","2019-10-21 08:54:46",""
"57023312","ECDSA using SecByteBlock key pairs","<p>I have implemented <code>ECDH</code>, and both private and public are of type <code>SecByteBlock</code>, now I am trying to implement <code>ECDSA</code> with <code>SHA256</code> using these keys.</p>

<p>Assuming that <code>pubA</code> and <code>privA</code> are already generated and there are <code>SecByteBlock</code> instances, how can I use them in ECDSA?</p>

<p>Thank you in advance!</p>

<pre><code>OID CURVE = secp256r1();
AutoSeededX917RNG&lt;AES&gt; rng;

// Elliptic Curve Diffie-Hellman
ECDH &lt; ECP &gt;::Domain dhA( CURVE );

SecByteBlock privA(dhA.PrivateKeyLength()), pubA(dhA.PublicKeyLength());
dhA.GenerateKeyPair(rng, privA, pubA);

// Elliptic Curve Digital Signature Algorithm
ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
DL_GroupParameters_EC&lt;ECP&gt; params(ASN1::secp256k1());

privateKey.Initialize(rng, params);        

// Generating private key
ECIES&lt;ECP&gt;::PrivateKey privateKey;
privateKey.Initialize(rng, ASN1::secp160r1());

// Generating matching public key
ECIES&lt;ECP&gt;::PublicKey publicKey;
privateKey.MakePublicKey(publicKey);

ECDSA&lt;ECP&gt;::Signer signer(privateKey);

ECDSA&lt;ECP&gt;::Verifier verifier(publicKey);
</code></pre>
","<p>I don't think this is a good idea. You should use the <code>ECDSA</code> class to create the keys. However, here it is.</p>

<pre><code>#include ""cryptlib.h""
#include ""eccrypto.h""
#include ""secblock.h""
#include ""filters.h""
#include ""integer.h""
#include ""osrng.h""
#include ""files.h""
#include ""oids.h""
#include ""sha.h""

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

int main(int argc, char* argv[])
{
    using namespace CryptoPP;

    try
    {
        const OID CURVE = ASN1::secp256r1();
        AutoSeededRandomPool prng;

        ECDH &lt;ECP&gt;::Domain dh(CURVE);

        SecByteBlock privA(dh.PrivateKeyLength()), pubA(dh.PublicKeyLength());
        dh.GenerateKeyPair(prng, privA, pubA);

        const Integer x(privA.begin(), privA.size());

        ECDSA&lt;ECP, SHA256&gt;::PrivateKey privateKey;
        privateKey.Initialize(CURVE, x);

        bool valid = privateKey.Validate(prng, 3);
        if (valid == false)
            throw std::runtime_error(""Private key is not valid ECDSA key"");

        std::cout &lt;&lt; ""Private key is valid ECDSA key"" &lt;&lt; std::endl;
    }
    catch (const std::runtime_error&amp; ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;
        std::exit(1);
    }

    return 0;
}
</code></pre>

<p>And:</p>

<pre><code>cryptopp$ g++ test.cxx ./libcryptopp.a -o test.exe
cryptopp$ ./test.exe
Private key is valid ECDSA key
</code></pre>

<p>More information is at <a href=""https://cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow noreferrer"">Elliptic Curve Digital Signature Algorithm</a> on the Crypto++ wiki.</p>
","32","<c++><crypto++>","-1","0","1","2019-07-14 06:22:15","57025068","1","","608639","","2019-07-14 01:02:19","2019-07-13 22:37:03",""
"55959865","Passing Boost path vector items to Crypto++ FileSource function","<p>Trying to build a program that scans a directory and generates MD5 hash for each file. Using boost and crypto++ in C++14</p>

<p>Struggling to get my head around the path vectors and passing the individual items to the crypto++ FileSource function.</p>

<p>See examples below with a fixed path. If anyone could let me know how to convert the directory elements to a type that is accepted by the FileSource function in the for loop that would be great.</p>

<pre><code>if (exists(p)) {                                             
  if (is_regular_file(p)) {     
    cout &lt;&lt; ""Please enter base path of directory only."" &lt;&lt; endl;
  }
  else if (is_directory(p)){           
    cout &lt;&lt; ""Scanning "" &lt;&lt; p &lt;&lt; endl;

    typedef vector&lt;path&gt; vec;
    vec v;

    copy(directory_iterator(p), directory_iterator(), back_inserter(v));
    sort(v.begin(), v.end());

    for (vec::const_iterator it (v.begin()); it != v.end(); ++it)
      {
        string result;
        Weak::MD5 hash;
        FileSource(""/home/howard/Documents/projects/copy_project/MultiCopy/main.cpp"", true, new HashFilter(hash, new HexEncoder(new StringSink(result), false)));
        cout &lt;&lt; ""   "" &lt;&lt; *it &lt;&lt; "" : ""  &lt;&lt; result &lt;&lt; endl;
      }
</code></pre>

<p>This works as expected, prints out the following: </p>

<pre><code>Scanning ""/home/howard/Documents/projects/copy_project/""
   ""/home/howard/Documents/projects/copy_project/MultiCopy"" : e4e336e768990b515a573dc5f60e5b8b
   ""/home/howard/Documents/projects/copy_project/cryptopp_example"" : e4e336e768990b515a573dc5f60e5b8b
   ""/home/howard/Documents/projects/copy_project/md5_example"" : e4e336e768990b515a573dc5f60e5b8b
   ""/home/howard/Documents/projects/copy_project/md5_from_file"" : e4e336e768990b515a573dc5f60e5b8b
   ""/home/howard/Documents/projects/copy_project/scan_dir"" : e4e336e768990b515a573dc5f60e5b8b
</code></pre>

<p>Tried below, but this does not work.</p>

<pre><code>FileSource(*it, true, new HashFilter(hash, new HexEncoder(new StringSink(result), false)));
</code></pre>
","","29","<c++><boost><crypto++>","1","","0","2019-05-02 20:42:18","","4","","1364007","","2019-05-02 20:42:18","2019-05-02 20:33:37","2019-05-02 21:22:47"
"39594989","Using crypto++ library with MSVS 2013","<p>I've downloaded Crypto++ library which contains cryptopp.dll and cryptopp.lib files. But I don't know how to use them in my project. I've tried to add cryptopp.lib to linker and cryptopp.dll to exe file directory but it didn't helped. There's my code:</p>

<pre><code>#include ""stdafx.h""

#pragma comment(lib, ""cryptopp.lib)

using namespace CryptoPP;

int _tmain(int argc, _TCHAR* argv[])
{
    return 0;
}
</code></pre>

<p>And it gives me this error:</p>

<pre><code>error C2871: 'CryptoPP' : a namespace with this name does not exist
</code></pre>

<p>What I have to do to be able to use this library?</p>
","","27","<c++><visual-studio-2013><static-libraries><header-files><crypto++>","0","","0","2016-09-20 15:01:48","","2","","608639","","2016-09-20 15:01:48","2016-09-20 13:07:38","2016-09-20 15:01:59"
"58414050","Concatenate IV and Data in Base64 string using Crypto++?","<p>I needed to encrypt a string to AES/CBC. In order to be able to uncrypt it later I have to store the IV in the final result which must be a base64 string.</p>

<p>I manage to do that using this <a href=""https://stackoverflow.com/a/42820221/393984"">answer</a> and the Crypto++ samples : </p>

<pre><code>std::string String::AESEncryptString(std::string str, std::string key)
{
    std::string encoded;
    std::string b64Result = """";

    AutoSeededRandomPool prng;

    unsigned char iv[AES::BLOCKSIZE];
    prng.GenerateBlock(iv, sizeof(iv));

    StringSink output(encoded);

    // Put the IV at the begining of the output
    StringSource(iv, sizeof(iv), true,
        new Redirector(output)
    );

    try {
        CBC_Mode&lt;AES&gt;::Encryption encryptor((unsigned char *)key.c_str(), key.length(), iv);

        StringSource s(str, true, 
            new StreamTransformationFilter(encryptor, 
                new Redirector(output), StreamTransformationFilter::PKCS_PADDING
            )
        );

        // Convert to b64
        StringSource (encoded, true,
            new Base64Encoder(
                new StringSink(b64Result),
                false // do not append a newline
            )
        );

        return b64Result;
    } catch (const Exception&amp; e) {
        return """";
    }
}
</code></pre>

<p>To decrypt the base64 string I extract the IV first then decrypt the rest of the datas : </p>

<pre><code>std::string String::AESDecryptString(std::string str, std::string key)
{
    unsigned char iv[AES::BLOCKSIZE];

    std::string b64decoded;
    std::string decoded;

    try {
        StringSource(str, true,
            new Base64Decoder(
                new StringSink(b64decoded)
            )
        );

        StringSource ss(b64decoded, false);

        // Get the IV
        ArraySink ivSink(iv, sizeof(iv));
        ss.Attach(new Redirector(ivSink));
        ss.Pump(AES::BLOCKSIZE);


        CBC_Mode&lt;AES&gt;::Decryption decryptor((unsigned char *)key.c_str(), key.length(), iv);


        ByteQueue queue;
        ss.Detach(
            new StreamTransformationFilter(decryptor,
                new Redirector(queue)
            )
        );
        ss.PumpAll(); // Pump remainder bytes

        StringSink decodedSink(decoded);
        queue.TransferTo(decodedSink);
        return decoded;
    }
    catch (const Exception&amp; e) {
        return """";
    }
}
</code></pre>

<p>Everything is working fine, but as I'm just discovering Crypto++ and the pipelining paradigm, I feel that I may have done too many steps to achieve what I want.</p>

<p>Is there more concise or more efficient way of doing that ?</p>
","","25","<encryption><base64><aes><crypto++><cbc-mode>","2","","0","2019-10-17 00:36:08","","1","","608639","","2019-10-17 00:36:08","2019-10-16 13:05:35",""
"55736126","How to assign a std::string key value to the SecByteBlock","<p>I am using crypto++ AES to encrypt and decrypt.</p>

<p>I have the key stored as string type in database for some reason.</p>

<p>How do I assign this key to the AES SecByteBlock key or initialize the AES key with this value instead of some random generated blocks.</p>

<pre><code>std::string key_fromDB = ""12dfre314?//1afsfa"";
AutoSeededRandomPool prng;
byte iv[ AES::BLOCKSIZE ];
prng.GenerateBlock( iv, sizeof(iv) );
SecByteBlock temp_key(AES::DEFAULT_KEYLENGTH);
prng.GenerateBlock( temp_key, temp_key.size() );

try 
{
    CBC_Mode&lt; AES &gt;::Decryption d;
    d.SetKeyWithIV(temp_key , temp_key.size(), iv );

    // The StreamTransformationFilter removes
    //  padding as required.
    StringSource ss( cipher, true,
        new StreamTransformationFilter( d,
            new StringSink( recovered )
        ) // StreamTransformationFilter
    ); // StringSource

    std::cout &lt;&lt; ""recovered text: "" &lt;&lt; recovered &lt;&lt; std::endl;
}
catch ( const CryptoPP::Exception&amp; e)
{
    std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
}
</code></pre>
","","25","<c++><crypto++>","1","","0","2019-04-18 01:46:32","","2","","608639","","2019-04-18 01:46:32","2019-04-17 21:19:09","2019-04-17 23:56:03"
post_link,title,body_question,body_answer,viewcount,tags,score,score_answer,answercount,LastActivityDate,AcceptedAnswerId,CommentCount,FavoriteCount,LastEditorUserId,LastEditorDisplayName,LastEditDate,CreationDate,ClosedDate
"3208160","How to generate an HMAC in Java equivalent to a Python example?","<p>I'm looking at implementing an app getting <a href=""http://apiwiki.twitter.com/Authentication"" rel=""noreferrer"">Twitter authorization via Oauth</a> in Java. The first step is <a href=""http://apiwiki.twitter.com/Twitter-REST-API-Method%3A-oauth-request_token"" rel=""noreferrer"">getting a request token</a>. Here is a <a href=""http://github.com/tav/tweetapp/blob/master/standalone/twitter_oauth_handler.py"" rel=""noreferrer"">Python example</a> for app engine. </p>

<p>To test my code, I am running Python and checking output with Java. Here is an example of Python generating a Hash-Based Message Authentication Code (HMAC):</p>

<pre><code>#!/usr/bin/python

from hashlib import sha1
from hmac import new as hmac

key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50""
message = ""foo""

print ""%s"" % hmac(key, message, sha1).digest().encode('base64')[:-1]
</code></pre>

<p>Output:</p>

<pre><code>$ ./foo.py
+3h2gpjf4xcynjCGU5lbdMBwGOc=
</code></pre>

<p>How does one replicate this example in Java?</p>

<p>I've seen an <a href=""http://exampledepot.8waytrips.com/egs/javax.crypto/GenMac.html"" rel=""noreferrer"">example of HMAC</a> in Java:</p>

<pre><code>try {
    // Generate a key for the HMAC-MD5 keyed-hashing algorithm; see RFC 2104
    // In practice, you would save this key.
    KeyGenerator keyGen = KeyGenerator.getInstance(""HmacMD5"");
    SecretKey key = keyGen.generateKey();

    // Create a MAC object using HMAC-MD5 and initialize with key
    Mac mac = Mac.getInstance(key.getAlgorithm());
    mac.init(key);

    String str = ""This message will be digested"";

    // Encode the string into bytes using utf-8 and digest it
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] digest = mac.doFinal(utf8);

    // If desired, convert the digest into a string
    String digestB64 = new sun.misc.BASE64Encoder().encode(digest);
} catch (InvalidKeyException e) {
} catch (NoSuchAlgorithmException e) {
} catch (UnsupportedEncodingException e) {
}
</code></pre>

<p>It uses <a href=""http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/javax/crypto/Mac.html"" rel=""noreferrer"">javax.crypto.Mac</a>, all good. However, the <a href=""http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/javax/crypto/SecretKey.html"" rel=""noreferrer"">SecretKey</a> constructors take bytes and an algorithm. </p>

<p>What's the algorithm in the Python example? How can one create a Java secret key without an algorithm?</p>
","<p>HmacSHA1 seems to be the algorithm name you need:</p>

<pre><code>SecretKeySpec keySpec = new SecretKeySpec(
        ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50"".getBytes(),
        ""HmacSHA1"");

Mac mac = Mac.getInstance(""HmacSHA1"");
mac.init(keySpec);
byte[] result = mac.doFinal(""foo"".getBytes());

BASE64Encoder encoder = new BASE64Encoder();
System.out.println(encoder.encode(result));
</code></pre>

<p>produces:</p>

<pre><code>+3h2gpjf4xcynjCGU5lbdMBwGOc=
</code></pre>

<p>Note that I've used <code>sun.misc.BASE64Encoder</code> for a quick implementation here, but you should probably use something that doesn't depend on the Sun JRE. <a href=""http://commons.apache.org/codec/apidocs/org/apache/commons/codec/binary/Base64.html"" rel=""noreferrer"">The base64-encoder in Commons Codec</a> would be a better choice, for example.</p>
","51938","<java><oauth><sha1><hmac><cryptoapi>","50","68","2","2015-11-12 08:45:51","3208472","0","19","5299236","","2015-11-12 08:45:51","2010-07-08 21:31:20",""
"3208160","How to generate an HMAC in Java equivalent to a Python example?","<p>I'm looking at implementing an app getting <a href=""http://apiwiki.twitter.com/Authentication"" rel=""noreferrer"">Twitter authorization via Oauth</a> in Java. The first step is <a href=""http://apiwiki.twitter.com/Twitter-REST-API-Method%3A-oauth-request_token"" rel=""noreferrer"">getting a request token</a>. Here is a <a href=""http://github.com/tav/tweetapp/blob/master/standalone/twitter_oauth_handler.py"" rel=""noreferrer"">Python example</a> for app engine. </p>

<p>To test my code, I am running Python and checking output with Java. Here is an example of Python generating a Hash-Based Message Authentication Code (HMAC):</p>

<pre><code>#!/usr/bin/python

from hashlib import sha1
from hmac import new as hmac

key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50""
message = ""foo""

print ""%s"" % hmac(key, message, sha1).digest().encode('base64')[:-1]
</code></pre>

<p>Output:</p>

<pre><code>$ ./foo.py
+3h2gpjf4xcynjCGU5lbdMBwGOc=
</code></pre>

<p>How does one replicate this example in Java?</p>

<p>I've seen an <a href=""http://exampledepot.8waytrips.com/egs/javax.crypto/GenMac.html"" rel=""noreferrer"">example of HMAC</a> in Java:</p>

<pre><code>try {
    // Generate a key for the HMAC-MD5 keyed-hashing algorithm; see RFC 2104
    // In practice, you would save this key.
    KeyGenerator keyGen = KeyGenerator.getInstance(""HmacMD5"");
    SecretKey key = keyGen.generateKey();

    // Create a MAC object using HMAC-MD5 and initialize with key
    Mac mac = Mac.getInstance(key.getAlgorithm());
    mac.init(key);

    String str = ""This message will be digested"";

    // Encode the string into bytes using utf-8 and digest it
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] digest = mac.doFinal(utf8);

    // If desired, convert the digest into a string
    String digestB64 = new sun.misc.BASE64Encoder().encode(digest);
} catch (InvalidKeyException e) {
} catch (NoSuchAlgorithmException e) {
} catch (UnsupportedEncodingException e) {
}
</code></pre>

<p>It uses <a href=""http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/javax/crypto/Mac.html"" rel=""noreferrer"">javax.crypto.Mac</a>, all good. However, the <a href=""http://download.oracle.com/docs/cd/E17409_01/javase/6/docs/api/javax/crypto/SecretKey.html"" rel=""noreferrer"">SecretKey</a> constructors take bytes and an algorithm. </p>

<p>What's the algorithm in the Python example? How can one create a Java secret key without an algorithm?</p>
","<p>A minor thing but if you are looking for an equivalent to hmac(key,message) then by default the python library will use the MD5 algorithm, so you need to use the HmacMD5 algorithm in Java.</p>

<p>I mention this because I had this exact problem and found this answer which was helpful, but I missed the part where a digest method was passed in to hmac() and thus went down a rabbit hole. Hopefully this answer will prevent others doing the same in the future.</p>

<p>e.g. in Python REPL</p>

<pre><code>&gt;&gt;&gt; import hmac
&gt;&gt;&gt; hmac.new(""keyValueGoesHere"", ""secretMessageToHash"").hexdigest()
'1a7bb3687962c9e26b2d4c2b833b2bf2'
</code></pre>

<p>This is equivalent to the Java method:</p>

<pre><code>import org.apache.commons.codec.binary.Hex;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class HashingUtility {
    public static String HMAC_MD5_encode(String key, String message) throws Exception {

        SecretKeySpec keySpec = new SecretKeySpec(
                key.getBytes(),
                ""HmacMD5"");

        Mac mac = Mac.getInstance(""HmacMD5"");
        mac.init(keySpec);
        byte[] rawHmac = mac.doFinal(message.getBytes());

        return Hex.encodeHexString(rawHmac);
    }
}
</code></pre>

<p>Note that in my example I'm doing the equivalent of .hexdigest()</p>
","51938","<java><oauth><sha1><hmac><cryptoapi>","50","21","2","2015-11-12 08:45:51","3208472","0","19","5299236","","2015-11-12 08:45:51","2010-07-08 21:31:20",""
"4796590","Window C/C++ Crypto API Examples and tips","<p>I'm asking this question because I've spent the best part of a day trawling through msdn docs and other opaque sources for simple straightforward guidelines on how to get started with the Windows C/C++ Crypto API.</p>

<p>What I'd like to see is some example code, typical include paths, linking guidelines, etc, anything useful really. I know this is an imprecise question but I reckon imprecise answers are better none at all.</p>

<p>I'll get the ball rolling with my own meager findings...</p>
","<p>The msdn docs are here: <a href=""http://msdn.microsoft.com/en-us/library/aa380252.aspx"">http://msdn.microsoft.com/en-us/library/aa380252.aspx</a></p>

<p>This is the main include file: <code>#include &lt;wincrypt.h&gt;</code></p>

<p>The cryptography bits are included as part of the <a href=""http://msdn.microsoft.com/en-us/windows/bb980924"">Windows SDK</a>, which is typically installed in <code>%PROGRAMFILES(x86)%\Microsoft SDKs\Windows\SDKVERSION</code> (e.g., <code>C:\Program Files\Microsoft SDKs\Windows\v6.0A</code>). The headers are typically in <code>%WINDOWSSDK%\Include</code>, and the related libraries are in <code>%WINDOWSSDK%\Lib</code>.</p>

<p>You must link to the cryptography libraries explicitly. Assuming you're in Visual Studio, you can add the reference by right clicking on the C++ project, choosing properties, and selecting Configuration Properties -> Linker on the treeview at left. You can then specify <code>crypt32.lib</code> in the input field on the right.</p>

<p>Alternately, (assuming you're using msvc++) add </p>

<pre><code>#pragma comment(lib, ""crypt32.lib"")
</code></pre>

<p>to your source.</p>
","41431","<c++><c><windows><cryptoapi><mscapi>","24","13","3","2019-04-14 17:06:48","4807830","3","19","608639","","2015-06-09 02:46:33","2011-01-25 17:07:10",""
"4796590","Window C/C++ Crypto API Examples and tips","<p>I'm asking this question because I've spent the best part of a day trawling through msdn docs and other opaque sources for simple straightforward guidelines on how to get started with the Windows C/C++ Crypto API.</p>

<p>What I'd like to see is some example code, typical include paths, linking guidelines, etc, anything useful really. I know this is an imprecise question but I reckon imprecise answers are better none at all.</p>

<p>I'll get the ball rolling with my own meager findings...</p>
","<p>Here's a bunch of examples I've found....</p>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382363%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">Example C Program: Listing the Certificates in a Store</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382375%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">Example C Program: Using CryptAcquireContext</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382359%28v=VS.85%29.aspx"" rel=""nofollow noreferrer"">Example C Program: Enumerating CSP Providers and Provider Types</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382035%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">Example C Code for Opening Certificate Stores</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382367%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">Example C Program: Sending and Receiving a Signed and Encrypted Message</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/aa382371%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">Example C Program: Signing a Hash and Verifying the Hash Signature</a></li>
</ul>

<p>MSDN has these examples scattered around the <a href=""http://msdn.microsoft.com/en-us/library/aa380252.aspx"" rel=""nofollow noreferrer"">docs</a></p>

<p>This <a href=""http://web.archive.org/web/20170212022801/https://etutorials.org/Programming/secure+programming/"" rel=""nofollow noreferrer"">website</a> provides a good overview of the concepts along with cross-platform examples</p>
","41431","<c++><c><windows><cryptoapi><mscapi>","24","26","3","2019-04-14 17:06:48","4807830","3","19","608639","","2015-06-09 02:46:33","2011-01-25 17:07:10",""
"4796590","Window C/C++ Crypto API Examples and tips","<p>I'm asking this question because I've spent the best part of a day trawling through msdn docs and other opaque sources for simple straightforward guidelines on how to get started with the Windows C/C++ Crypto API.</p>

<p>What I'd like to see is some example code, typical include paths, linking guidelines, etc, anything useful really. I know this is an imprecise question but I reckon imprecise answers are better none at all.</p>

<p>I'll get the ball rolling with my own meager findings...</p>
","<p>There is also a lengthy example <strong>""<a href=""http://www.codeproject.com/Articles/11578/Encryption-using-the-Win32-Crypto-API"" rel=""noreferrer"">Encryption using the Win32 Crypto API</a>""</strong> over at the Code Project.</p>
","41431","<c++><c><windows><cryptoapi><mscapi>","24","6","3","2019-04-14 17:06:48","4807830","3","19","608639","","2015-06-09 02:46:33","2011-01-25 17:07:10",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<p>The best place to start is Documentation/crytpo in the kernel sources. dm-crypt is one of the many components that probably uses the kernel crypto API and you can refer to it to get an idea about usage.</p>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","1","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<p>There are a couple of places in the kernel which use the crypto module: the eCryptfs file system (linux/fs/ecryptfs/) and the 802.11 wireless stack (linux/drivers/staging/rtl8187se/ieee80211/). Both of these use AES, but you may be able to extrapolate what you find there to MD5.</p>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","6","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<blockquote>
  <p>how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
</blockquote>

<p>Example of hashing data using a two-element scatterlist:</p>

<pre>struct crypto_hash *tfm = crypto_alloc_hash(""sha1"", 0, CRYPTO_ALG_ASYNC);
if (tfm == NULL)
    fail;
char *output_buf = kmalloc(crypto_hash_digestsize(tfm), GFP_KERNEL);
if (output_buf == NULL)
    fail;
struct scatterlist sg[2];
struct hash_desc desc = {.tfm = tfm};
ret = crypto_hash_init(&desc);
if (ret != 0)
    fail;
sg_init_table(sg, ARRAY_SIZE(sg));
sg_set_buf(&sg[0], ""Hello"", 5);
sg_set_buf(&sg[1], "" World"", 6);
ret = crypto_hash_digest(&desc, sg, 11, output_buf);
if (ret != 0)
    fail;</pre>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","1","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<p>Another good example is from the 2.6.18 kernel source in security/seclvl.c</p>

<p>Note: You can change CRYPTO_TFM_REQ_MAY_SLEEP if needed</p>

<pre><code>static int
plaintext_to_sha1(unsigned char *hash, const char *plaintext, unsigned int len)
{
  struct crypto_tfm *tfm;
  struct scatterlist sg;
  if (len &gt; PAGE_SIZE) {
    seclvl_printk(0, KERN_ERR, ""Plaintext password too large (%d ""
            ""characters).  Largest possible is %lu ""
            ""bytes.\n"", len, PAGE_SIZE);
    return -EINVAL;
  }
  tfm = crypto_alloc_tfm(""sha1"", CRYPTO_TFM_REQ_MAY_SLEEP);
  if (tfm == NULL) {
    seclvl_printk(0, KERN_ERR,
            ""Failed to load transform for SHA1\n"");
    return -EINVAL;
  }
  sg_init_one(&amp;sg, (u8 *)plaintext, len);
  crypto_digest_init(tfm);
  crypto_digest_update(tfm, &amp;sg, 1);
  crypto_digest_final(tfm, hash);
  crypto_free_tfm(tfm);
  return 0;
}
</code></pre>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","6","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/crypto.h&gt;
#include &lt;linux/err.h&gt;
#include &lt;linux/scatterlist.h&gt;

#define SHA1_LENGTH     20

static int __init sha1_init(void)
{
    struct scatterlist sg;
    struct crypto_hash *tfm;
    struct hash_desc desc;
    unsigned char output[SHA1_LENGTH];
    unsigned char buf[10];
    int i;

    printk(KERN_INFO ""sha1: %s\n"", __FUNCTION__);

    memset(buf, 'A', 10);
    memset(output, 0x00, SHA1_LENGTH);

    tfm = crypto_alloc_hash(""sha1"", 0, CRYPTO_ALG_ASYNC);

    desc.tfm = tfm;
    desc.flags = 0;

    sg_init_one(&amp;sg, buf, 10);
    crypto_hash_init(&amp;desc);

    crypto_hash_update(&amp;desc, &amp;sg, 10);
    crypto_hash_final(&amp;desc, output);

    for (i = 0; i &lt; 20; i++) {
        printk(KERN_ERR ""%d-%d\n"", output[i], i);
    }

    crypto_free_hash(tfm);

    return 0;
}

static void __exit sha1_exit(void)
{
    printk(KERN_INFO ""sha1: %s\n"", __FUNCTION__);
}

module_init(sha1_init);
module_exit(sha1_exit);

MODULE_LICENSE(""Dual MIT/GPL"");
MODULE_AUTHOR(""Me"");
</code></pre>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","11","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<p>One critical note: </p>

<p>Never compare the return value of <code>crypto_alloc_hash</code> function to NULL for detecting the failure. </p>

<p>Steps:</p>

<p>Always use <code>IS_ERR</code> function for this purpose. Comparing to <code>NULL</code> does not capture the error, hence you get segmentation faults later on. </p>

<p>If IS_ERR returns fail, you possibly have a missing crypto algorithm compiled into your kernel image (or as a module). Make sure you have selected the appropriate crypto algo. form <code>make menuconfig</code>.</p>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","1","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"3869028","how to use CryptoAPI in the linux kernel 2.6","<p>I have been looking for some time but have not found anywhere near sufficient documentation / examples on how to use the CryptoAPI that comes with linux in the creation of syscalls / in kernel land.</p>

<p>If anyone knows of a good source please let me know, I would like to know how to do SHA1 / MD5 and Blowfish / AES within the kernel space only.</p>
","<p><strong>Cryptodev-linux</strong></p>

<p><a href=""https://github.com/cryptodev-linux/cryptodev-linux"" rel=""nofollow noreferrer"">https://github.com/cryptodev-linux/cryptodev-linux</a></p>

<p>It is a kernel module that exposes the kernel crypto API to userspace through <code>/dev/crypto</code> .</p>

<p>SHA calculation example: <a href=""https://github.com/cryptodev-linux/cryptodev-linux/blob/da730106c2558c8e0c8e1b1b1812d32ef9574ab7/examples/sha.c"" rel=""nofollow noreferrer"">https://github.com/cryptodev-linux/cryptodev-linux/blob/da730106c2558c8e0c8e1b1b1812d32ef9574ab7/examples/sha.c</a></p>

<p>As others have mentioned, the kernel does not seem to expose the crypto API to userspace itself, which is a shame since the kernel can already use native hardware accelerated crypto functions internally.</p>

<p>Crypto operations cryptodev supports: <a href=""https://github.com/nmav/cryptodev-linux/blob/383922cabeea7dca354415e8c590f8e932f4d7a8/crypto/cryptodev.h"" rel=""nofollow noreferrer"">https://github.com/nmav/cryptodev-linux/blob/383922cabeea7dca354415e8c590f8e932f4d7a8/crypto/cryptodev.h</a></p>

<p>Crypto operations Linux x86 supports: <a href=""https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/crypto?id=refs/tags/v4.0"" rel=""nofollow noreferrer"">https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/crypto?id=refs/tags/v4.0</a></p>
","18585","<linux-kernel><kernel><kernel-module><cryptoapi>","10","2","7","2017-04-17 09:40:43","3876665","0","7","","","","2010-10-06 01:58:48",""
"34812897","How to suppress ""An application is requesting access to a protected item"" popup","<p>I'm getting a pop-up when trying to use a certificate to decrypt data.
I'm creating a self-signed certificate, and I'm using it to encrypt some data, but I'm getting the following confirmation pop-up when trying to decrypt the data:</p>

<p><img src=""https://i.stack.imgur.com/10M1o.png"" alt=""CryptoAPI popup""></p>

<p>How can I programatically grant access to use the certificate? </p>
","<p>I believe the issue is that the certificate's private key has <em>""strong protection""</em> enabled. </p>

<p><a href=""https://i.stack.imgur.com/3oTkK.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/3oTkK.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>Enable strong private key protection. You will be prompted every time the private key is used by an application if you enable this option.</p>
</blockquote>

<p>Any attempt to use the private key causes Windows to display the warning. </p>

<p>You have to re-import the certificate without the <strong>Strong private key protection</strong> option enabled.</p>

<h2>Group policy that does the same</h2>

<p>It's also possible a system wide group policy is in effect:</p>

<ul>
<li>secpol.msc   

<ul>
<li>Security Settings

<ul>
<li>Local Policies

<ul>
<li>Security Options

<ul>
<li>System Cryptography: Force strong key protection for user keys stored on the computer</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<blockquote>
  <p>System Cryptography: Force strong key protection for user keys stored
  on the computer</p>
  
  <p>This security setting determines if users' private keys require a
  password to be used.</p>
  
  <p>The options are:</p>
  
  <p>User input is not required when new keys are stored and used User is
  prompted when the key is first used User must enter a password each
  time they use a key For more information, see Public key
  infrastructure.</p>
  
  <p>Default: This policy is not defined.</p>
</blockquote>

<p>If that group policy security option is set, you have to disable it.</p>

<h2>Bonus Reading</h2>

<ul>
<li>MSDN Blog: <a href=""http://blogs.technet.com/b/pki/archive/2009/06/17/what-is-a-strong-key-protection-in-windows.aspx"" rel=""noreferrer"">What is a strong key protection in Windows?</a> <em>(<a href=""http://archive.is/tBelj"" rel=""noreferrer"">archive</a>)</em></li>
<li>Technet GP reference: <a href=""https://technet.microsoft.com/en-us/library/jj852211.aspx"" rel=""noreferrer"">System cryptography: Force strong key protection for user keys stored on the computer</a> <em>(<a href=""http://archive.is/iRS91"" rel=""noreferrer"">archive</a>)</em></li>
</ul>

<p>tl;dr: You cannot programatically bypass a security boundary</p>
","10152","<c#><security><model-view-controller><encryption><cryptoapi>","5","11","2","2019-10-19 01:07:50","34820811","0","1","15754","","2016-01-15 14:28:37","2016-01-15 14:10:19",""
"34812897","How to suppress ""An application is requesting access to a protected item"" popup","<p>I'm getting a pop-up when trying to use a certificate to decrypt data.
I'm creating a self-signed certificate, and I'm using it to encrypt some data, but I'm getting the following confirmation pop-up when trying to decrypt the data:</p>

<p><img src=""https://i.stack.imgur.com/10M1o.png"" alt=""CryptoAPI popup""></p>

<p>How can I programatically grant access to use the certificate? </p>
","<p>I know it's a very niche case, but in my case I've installed the .pfx certificate with the ""Enable strong private key protection"" checkbox (see screenshot).</p>

<p>If this is done - then no policies will help you remove the prompts. I had to reinstall the certificate without this checkbox marked. Don't ask me why I marked it in the first place.</p>

<p><a href=""https://i.stack.imgur.com/jaoNh.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/jaoNh.png"" alt=""enter image description here""></a></p>
","10152","<c#><security><model-view-controller><encryption><cryptoapi>","5","1","2","2019-10-19 01:07:50","34820811","0","1","15754","","2016-01-15 14:28:37","2016-01-15 14:10:19",""
"37522654","linking with openssl lib statically","<p>I've build openssl manually (static libraries) following <a href=""http://developer.covenanteyes.com/building-openssl-for-visual-studio/"" rel=""noreferrer"">this guide</a>  now when I try to link my MFC test app with libeay32.lib I get following errors:</p>

<pre><code>1&gt;Linking...
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertFreeCertificateContext@4 referenced in function _capi_free_key
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertGetCertificateContextProperty@16 referenced in function _capi_get_prov_info
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertOpenStore@20 referenced in function _capi_open_store
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertFindCertificateInStore@24 referenced in function _capi_find_cert
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertEnumCertificatesInStore@8 referenced in function _capi_find_cert
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertCloseStore@8 referenced in function _capi_find_key
1&gt;libeay32.lib(e_capi.obj) : error LNK2019: unresolved external symbol __imp__CertDuplicateCertificateContext@4 referenced in function _capi_load_ssl_client_cert
</code></pre>

<p>Any advice? Thanks in advance.</p>

<p>EDIT:
I’ve used OpenSSL 1.0.1t source code and Visual Studio 2008 command prompt for building 32 bit static libraries (I had no success with 1.0.2h version). My test app works fine when linking dynamically but I want to be able to link with static lib’s.  I’m using OpenSSL for  EVP Symmetric Encryption and Decryption</p>
","<blockquote>
  <p>when I try to link my MFC test app with libeay32.lib I get following errors...</p>
</blockquote>

<p>You need to configure with <code>enable-capieng</code>. Also see <a href=""http://wiki.openssl.org/index.php/Compilation_and_Installation"" rel=""noreferrer"">Compilation and Installation</a> on the OpenSSL wiki and <a href=""http://openssl.6102.n7.nabble.com/How-to-use-CAPI-engine-in-OpenSSL-1-0-0a-td11611.html"" rel=""noreferrer"">How to use CAPI engine in OpenSSL</a> mailing list archive.</p>

<blockquote>
<pre><code>error LNK2019: unresolved external symbol __imp__CertFreeCertificateContext@4 referenced in function _capi_free_key 
...
</code></pre>
</blockquote>

<p>Once configured properly, you need to link against Windows' <code>crypt32.lib</code> library. See, for example, <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376075%28v=vs.85%29.aspx"" rel=""noreferrer"">CertFreeCertificateContext functions</a>. On Windows, it should be enough to add the following to your MSVC source file:</p>

<pre><code>#pragma comment (lib, ""crypt32"");
</code></pre>
","9547","<windows><visual-c++><openssl><cryptoapi>","12","25","1","2016-05-30 12:25:08","37524406","0","1","2050867","","2016-05-30 12:25:08","2016-05-30 09:53:24",""
"11507961","MS CryptoAPI - Machine Keystore with Error 0x80090016 (NTE_BAD_KEYSET) with certreq created keys","<h1>Summary</h1>

<p>I create a PKCS#10 CSR with <a href=""http://technet.microsoft.com/en-us/library/cc736326%28v=ws.10%29.aspx"" rel=""nofollow""><code>certreq</code></a> and have set the option <code>Exportable=TRUE</code>. This successfully creates a key under the location <code>REQUEST</code>. I also have a valid certificate with key in <code>MY</code>. If I try to access any one of them the CryptoAPI reports error code <code>0x80090016</code>.</p>

<p>Running under different access rights could not solve this problem so far.</p>

<h1>Goal</h1>

<p>My goal is to get both the keys in <code>MY</code> and <code>REQUEST</code>. If I call <code>CryptAcquireContextA()</code> on any of those, it fails.</p>

<h1>System</h1>

<p>Windows 7 x64</p>

<h1>Sample Source Code</h1>

<p>My complete code looks like this:</p>

<pre><code>hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, ""REQUEST"");
pCert = CertFindCertificateInStore(hStore, X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_STR_A, ""CERTIFICATE_SUBJECT"", NULL);

CertGetCertificateContextProperty(pCert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &amp;len);
pinfo = (CRYPT_KEY_PROV_INFO *) malloc(len);
CertGetCertificateContextProperty(pCert, CERT_KEY_PROV_INFO_PROP_ID, pinfo, &amp;len);

provname = wide_to_asc(pinfo-&gt;pwszProvName);
contname = wide_to_asc(pinfo-&gt;pwszContainerName);

if(!CryptAcquireContextA(&amp;hCryptProv, contname, provname, pinfo-&gt;dwProvType, 0)) {
    err = GetLastError();
    fprintf(stderr, ""Error: 0x%x\n"", err);
}
CryptGetUserKey(hCryptProv, pinfo-&gt;dwKeySpec, &amp;hUserkey);
</code></pre>

<p>This code is mostly copied from the <em>OpenSSL capi engine</em>. Since the engine failed, I created the smallest possible code to search the error.</p>

<h1>The error</h1>

<p>If I run this, it fails with the output <code>Error: 0x80090016</code>. This means one of three things according to <a href=""http://support.microsoft.com/kb/238187"" rel=""nofollow"">Microsoft</a>:</p>

<ul>
<li>Key container does not exist.</li>
<li>You do not have access to the key container.</li>
<li>The Protected Storage Service is not running.</li>
</ul>

<h1>What have I done so far?</h1>

<ul>
<li>Started service ""Protected Storage""</li>
<li>Verified container exists with MMC &amp; Certificate Snap-In for <code>Local Computer</code></li>
<li>Ran the same code on the User store in user context - it worked</li>
</ul>

<h2>File System Permissions</h2>

<p>After some googling, I tried to change permissions on the file system. I found the files by looking at the <code>contname</code> variable of my code and searching for the file. I changed permissions on them (more accurate, I changed permissions on the parent folder). While this fixed the issue for <code>MY</code>, it seems I cannot change it for <code>REQUEST</code>.</p>

<p>One note here is that my container for <code>MY</code> seems to be here:</p>

<pre><code>%APPDATA%\Microsoft\Crypto\RSA\S-1-5-21-1650336054-1974872081-316617838-545102
</code></pre>

<p>For <code>REQUEST</code> I found it under a different address:</p>

<pre><code>%ALLUSERSPROFILE%\Microsoft\Crypto\RSA\MachineKeys
</code></pre>

<p>I am not sure on the workings here so I cannot explain why it would put them in different locations (one being user centric, the other one a system folder). The <code>MY</code> store was created with a regular administrator prompt and the command <code>certreq -new inf_file.inf cert-csr.csr</code> and after I received my certificate, I issued <code>certreq -accept cert.pem</code>. Then I created a new csr with the same command.</p>

<h2>Different privilege levels</h2>

<p>I tried to execute my program with the following privileges:</p>

<ul>
<li>my local user account</li>
<li>admin prompt (cmd->start as administrator)</li>
<li>nt authority\system (<code>whoami</code> output)</li>
</ul>

<p>To recieve a service prompt, I executed <code>psexec.exe –ids cmd.exe</code> according to a tip from <a href=""http://www.maas360.com/maasters/forums/laptop-management/show/177/starting-a-process-in-system-context"" rel=""nofollow"">MaaSters Center</a></p>

<h1>Final words</h1>

<p>Any help or guidance on how to further narrow this problem down will be greatly appreciated. </p>
","<p>I was finally able to solve this problem and it is a lot simpler than I thought. I was sure that I would receive an unambiguous container name and don't need to be more specific but <code>CryptAcquireContext</code> actually requires me to pass a flag <code>CRYPT_MACHINE_KEYSET</code>.</p>

<p>So my function call has to look like this:</p>

<pre><code>CryptAcquireContextA(&amp;hCryptProv, contname, provname, pinfo-&gt;dwProvType, CRYPT_MACHINE_KEYSET)
</code></pre>

<p>Unfortunately this is not supported by the OpenSSL engine, so you would have to alter it yourself in the engine.</p>
","7306","<c><openssl><cryptoapi>","1","1","2","2016-07-19 20:48:44","11612485","0","","1326104","","2012-07-20 09:49:39","2012-07-16 15:55:04",""
"11507961","MS CryptoAPI - Machine Keystore with Error 0x80090016 (NTE_BAD_KEYSET) with certreq created keys","<h1>Summary</h1>

<p>I create a PKCS#10 CSR with <a href=""http://technet.microsoft.com/en-us/library/cc736326%28v=ws.10%29.aspx"" rel=""nofollow""><code>certreq</code></a> and have set the option <code>Exportable=TRUE</code>. This successfully creates a key under the location <code>REQUEST</code>. I also have a valid certificate with key in <code>MY</code>. If I try to access any one of them the CryptoAPI reports error code <code>0x80090016</code>.</p>

<p>Running under different access rights could not solve this problem so far.</p>

<h1>Goal</h1>

<p>My goal is to get both the keys in <code>MY</code> and <code>REQUEST</code>. If I call <code>CryptAcquireContextA()</code> on any of those, it fails.</p>

<h1>System</h1>

<p>Windows 7 x64</p>

<h1>Sample Source Code</h1>

<p>My complete code looks like this:</p>

<pre><code>hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_A, 0, 0, CERT_SYSTEM_STORE_LOCAL_MACHINE, ""REQUEST"");
pCert = CertFindCertificateInStore(hStore, X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_STR_A, ""CERTIFICATE_SUBJECT"", NULL);

CertGetCertificateContextProperty(pCert, CERT_KEY_PROV_INFO_PROP_ID, NULL, &amp;len);
pinfo = (CRYPT_KEY_PROV_INFO *) malloc(len);
CertGetCertificateContextProperty(pCert, CERT_KEY_PROV_INFO_PROP_ID, pinfo, &amp;len);

provname = wide_to_asc(pinfo-&gt;pwszProvName);
contname = wide_to_asc(pinfo-&gt;pwszContainerName);

if(!CryptAcquireContextA(&amp;hCryptProv, contname, provname, pinfo-&gt;dwProvType, 0)) {
    err = GetLastError();
    fprintf(stderr, ""Error: 0x%x\n"", err);
}
CryptGetUserKey(hCryptProv, pinfo-&gt;dwKeySpec, &amp;hUserkey);
</code></pre>

<p>This code is mostly copied from the <em>OpenSSL capi engine</em>. Since the engine failed, I created the smallest possible code to search the error.</p>

<h1>The error</h1>

<p>If I run this, it fails with the output <code>Error: 0x80090016</code>. This means one of three things according to <a href=""http://support.microsoft.com/kb/238187"" rel=""nofollow"">Microsoft</a>:</p>

<ul>
<li>Key container does not exist.</li>
<li>You do not have access to the key container.</li>
<li>The Protected Storage Service is not running.</li>
</ul>

<h1>What have I done so far?</h1>

<ul>
<li>Started service ""Protected Storage""</li>
<li>Verified container exists with MMC &amp; Certificate Snap-In for <code>Local Computer</code></li>
<li>Ran the same code on the User store in user context - it worked</li>
</ul>

<h2>File System Permissions</h2>

<p>After some googling, I tried to change permissions on the file system. I found the files by looking at the <code>contname</code> variable of my code and searching for the file. I changed permissions on them (more accurate, I changed permissions on the parent folder). While this fixed the issue for <code>MY</code>, it seems I cannot change it for <code>REQUEST</code>.</p>

<p>One note here is that my container for <code>MY</code> seems to be here:</p>

<pre><code>%APPDATA%\Microsoft\Crypto\RSA\S-1-5-21-1650336054-1974872081-316617838-545102
</code></pre>

<p>For <code>REQUEST</code> I found it under a different address:</p>

<pre><code>%ALLUSERSPROFILE%\Microsoft\Crypto\RSA\MachineKeys
</code></pre>

<p>I am not sure on the workings here so I cannot explain why it would put them in different locations (one being user centric, the other one a system folder). The <code>MY</code> store was created with a regular administrator prompt and the command <code>certreq -new inf_file.inf cert-csr.csr</code> and after I received my certificate, I issued <code>certreq -accept cert.pem</code>. Then I created a new csr with the same command.</p>

<h2>Different privilege levels</h2>

<p>I tried to execute my program with the following privileges:</p>

<ul>
<li>my local user account</li>
<li>admin prompt (cmd->start as administrator)</li>
<li>nt authority\system (<code>whoami</code> output)</li>
</ul>

<p>To recieve a service prompt, I executed <code>psexec.exe –ids cmd.exe</code> according to a tip from <a href=""http://www.maas360.com/maasters/forums/laptop-management/show/177/starting-a-process-in-system-context"" rel=""nofollow"">MaaSters Center</a></p>

<h1>Final words</h1>

<p>Any help or guidance on how to further narrow this problem down will be greatly appreciated. </p>
","<p>See MSDN: ""A key container created without this flag by a user that is not an administrator can be accessed only by the user creating the key container and the local system account.""</p>

<p>Complete details here: <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx</a></p>
","7306","<c><openssl><cryptoapi>","1","0","2","2016-07-19 20:48:44","11612485","0","","1326104","","2012-07-20 09:49:39","2012-07-16 15:55:04",""
"16911632","Java File Encryption","<p>I'm trying to write a simple program to encrypt and decrypt files using the AES algortihm. I haven't problems with encryption, but decryption..</p>

<pre><code>public static void main(String[] args) throws NoSuchAlgorithmException, FileNotFoundException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {

    // Инициализация секретных ключей
    KeyGenerator keyGenS = KeyGenerator.getInstance(""AES"");
    keyGenS.init(128);
    SecretKey sKey1 = keyGenS.generateKey();
    SecretKey sKey2 = keyGenS.generateKey();
    // Перевод секретных ключей в строку и запись в файл
    String key1 = SecretKeyToString(sKey1);
    String key2 = SecretKeyToString(sKey2);

    spreader.write(fileName1, key1);
    spreader.write(fileName2, key2);
    spreader.write(fileNameS1, key1);
    spreader.write(fileNameS2, key2);


    // Чтение секретных ключей из файла и перевод обратно в тип SecretKey
    key1 = spreader.read(fileName1);
    System.out.println(""Секретный ключ 1го пользователя: "" +key1);


    SecretKey seansKey1=getKeyInstance(key1);

    key2 = spreader.read(fileName2);
    System.out.println(""Секретный ключ 2го пользователя: "" +key2);

    SecretKey seansKey2=getKeyInstance(key2);


    //инициализация и зашифрование сеансового ключа с помощью секретных
    Cipher aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.ENCRYPT_MODE,seansKey1);

    KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
    keyGen.init(128);
    SecretKey secretKey = keyGen.generateKey();

    String stringsecretKey = SecretKeyToString(secretKey);
    byte[] byteKey = stringsecretKey.getBytes();
    byte[] byteCipherKey1 = aesCipher.doFinal(byteKey); 
    String encryptedKey = new BASE64Encoder().encode(byteCipherKey1);
    System.out.println(""Зашифрованный сеансовый ключ с помощью секретного ключа 1: "" +encryptedKey);





    aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.ENCRYPT_MODE,SeansKey2);


     byteKey = etringsecretKey.getBytes();
     byte[] byteCipherKey2 = aesCipher.doFinal(byteKey); 
     encryptedKey = new BASE64Encoder().encode(byteCipherKey2);
    System.out.println(""Зашифрованный сеансовый ключ с помощью секретного ключа 2: "" +encryptedKey);
    spreader.write(fileNameEK2, encryptedKey);

    //Чтение данных из файла
    String text =spreader.read(fileName);
    System.out.println(text);

    // Зашифрование данных


            aesCipher.init(Cipher.ENCRYPT_MODE,secretKey); // константная переменная

            byte[] byteText = text.getBytes();
            byte[] byteCipherText = aesCipher.doFinal(byteText); 
            encryptedText = new BASE64Encoder().encode(byteCipherText);
            System.out.println(""Зашифрованный текст: "" +encryptedText);

            spreader.write(fileNameOK, encryptedText);





}
</code></pre>

<p>Here's the decryption part:</p>

<pre><code>public static void main(String[] args) throws NoSuchAlgorithmException, FileNotFoundException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException {

    String encryptedText = user.read(fileNameOK);
    String key1 = user.read(fileName1);
    String key2 = user.read(fileName2);
    String encryptedSeanceKey1 = user.read(fileNameEK1);
    String encryptedSeanceKey2 = user.read(fileNameEK2);




    SecretKey secretKey1=getKeyInstance(key1);
    SecretKey secretKey2=getKeyInstance(key2);



    Cipher aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.DECRYPT_MODE,secretKey1,aesCipher.getParameters());




    //byte[] byteKey = encryptedSeanceKey1.getBytes();

       byte[] byteDecryptedKey = aesCipher.doFinal(encryptedSeanceKey1.getBytes());
       String decryptedKey1 = new String(byteDecryptedKey);
       System.out.println(""Расшифрованный сеансовый ключ с помощью секретного ключа 1: "" +decryptedKey1);

    aesCipher.init(Cipher.DECRYPT_MODE,secretKey2,aesCipher.getParameters());




    byte[] byteKey2 = encryptedSeanceKey2.getBytes();
        byteDecryptedKey = aesCipher.doFinal(byteKey2); 
        String decryptedKey2 = new String(byteDecryptedKey);
       System.out.println(""Расшифрованный сеансовый ключ с помощью секретного ключа 2: "" +decryptedKey2);





        // Расшифрование данных
        aesCipher.init(Cipher.DECRYPT_MODE,getKeyInstance(decryptedKey1),aesCipher.getParameters());

         byte[] byteText = encryptedText.getBytes();

        byte[] byteDecryptedText = aesCipher.doFinal(byteText);
        decryptedText = new String(byteDecryptedText);
        System.out.println("" Расшифрованный текст "" +decryptedText);



}
</code></pre>

<p>}</p>

<p>Now the problem is the decryption part is: Input length must be multiple of 16 when decrypting with padded cipher</p>

<p>I know that a mistake that I incorrectly keep a session key and bytes are lost. But how I can correctly do it?</p>
","<p>There is a little bit of confusion in your code, maybe because some method you called are missing, or maybe because you are using your keys to encrypt...your keys(!!!)<br>
Let's try to encrypt and decrypt the easy way, removing all the stuff that is not strictly needed in your code (like encode your key and save it to a file, and then restore the key without decoding it, etc..).  </p>

<p>Let's take a look at the following simplified code based on your:</p>

<pre><code>    KeyGenerator keyGenS = KeyGenerator.getInstance(""AES"");
    keyGenS.init(128);
    SecretKey sKey1 = keyGenS.generateKey();

    Cipher aesCipher = Cipher.getInstance(""AES"");
    aesCipher.init(Cipher.ENCRYPT_MODE,sKey1);

    byte[] byteText = ""Insert here whatever you want to crypt"".getBytes();

    byte[] byteCipherText = aesCipher.doFinal(byteText);
</code></pre>

<p>We have generated our key with KeyGenerator, and then we have initialized our Cipher instance with that key. At this point we simply call <code>doFinal()</code> passing the plainText we want to encrypt.<br>
That's all for the encryption part. Of course you can save your keys and <code>byteCipherText</code> to a file if you want, but all the other staff is (at least) useless. </p>

<p>The decryption part is easy as the encryption. The logic is the same.
If you saved your key on a file, just read it into a <code>byte[]</code>, and use it for initialize your cipher instance. Something like this:</p>

<pre><code>    aesCipher.init(Cipher.DECRYPT_MODE, sKey1);
    byte[] plainText = aesCipher.doFinal(byteCipherText);
</code></pre>

<p>If you put all the above code into a <code>main()</code> and run it, you should have into <code>plainText</code> the same text as in <code>byteText</code>.<br>
You can verify it with a </p>

<pre><code>    System.out.println(new String(plainText));
</code></pre>

<p>Try to start from here, then add all other things you may need.<br>
Hope this helps.<br>
Regards</p>
","7163","<java><encryption><cryptoapi>","2","7","1","2013-06-04 08:20:43","16912933","2","3","2450578","","2013-06-04 07:16:42","2013-06-04 07:01:25",""
"4728650","How to import machine certificate into the Personal certificate store associated with a Windows service?","<p>I am reposting <a href=""http://social.msdn.microsoft.com/Forums/en/vcgeneral/thread/17cc6cf4-c01b-4819-9b40-8511ce25060e"" rel=""nofollow noreferrer"">my question</a> from the MSDN forums here.</p>

<p>This problem has to do with importing a certificate into the personal certificate store associated with a windows service.</p>

<p>The name of my machine is <strong>il-mark-lap</strong> (the machine is pingable by this name).</p>

<p>The process:</p>

<p><strong>1.</strong> There is a self signed authority certificate, let us call it <strong>NCCA</strong>. Its private key lives on another machine, let us refer it by <strong>dev-profiler</strong>.</p>

<pre><code>dev-profiler&gt; makecert -n ""CN=NCCA"" -sr localmachine -ss root -a sha1 -cy authority -r -sv NCCA.pvk NCCA.cer
</code></pre>

<p><strong>2.</strong> The <strong>il-mark-lap</strong> machine certificate is created on <strong>dev-profiler</strong> and imported to the <strong>LocalComputer\My</strong> certificate store on <strong>il-mark-lap</strong>. Note, that the authority certificate (<strong>NCCA</strong>) has to be moved to <strong>LocalComputer\Root</strong> certificate store, but since I do not know how to move, I use the export-delete-import sequence.</p>

<pre><code>dev-profiler&gt; makecert -n ""CN=il-mark-lap"" -sr CurrentUser -ss My -cy end -pe -sky exchange -a sha1 -is Root -ir LocalMachine -in NCCA
dev-profiler&gt; certutil -user -exportpfx -p 123 il-mark-lap il-mark-lap.pfx
dev-profiler&gt; certutil -user -delstore My il-mark-lap

il-mark-lap&gt; cscript CStore.vbs import -l LM -s My -e il-mark-lap.pfx 123
il-mark-lap&gt; cscript CStore.vbs export -l LM -s My -subject NCCA NCCA.cer
il-mark-lap&gt; cscript CStore.vbs delete -noprompt -l LM -subject NCCA My
il-mark-lap&gt; cscript CStore.vbs import -l LM -s Root NCCA.cer
</code></pre>

<p><strong>3.</strong> The <strong>il-mark-lap</strong> machine certificate is copied from <strong>LocalComputer\My</strong> certificate store into <strong>MSMQ\My</strong> certificate store (Message Queuing service Personal certificate store). Again, I do not know how to copy, so I use the export-import sequence.</p>

<pre><code>il-mark-lap&gt; cscript CStore.vbs export -l LM -s My -subject il-mark-lap tmp.pfx
il-mark-lap&gt; ImportPfxIntoSrvCertStore MSMQ tmp.pfx 123
</code></pre>

<p>Where ImportPfxIntoSrvCertStore is my program written in C++ to import the given PFX into the Personal certificate store of the given service, MSMQ in my case.</p>

<p>Omitting all the error handling, the relevant  C++ code is this:</p>

<pre><code>CSafeHandle pfxFileHandle(::CreateFile(wszPfxFilePath, FILE_READ_DATA, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, 0));
CSafeHandle pfxFileMapping(::CreateFileMapping(pfxFileHandle, 0, PAGE_READONLY, 0, 0, 0));
CSafeMapViewOfFile pfxFileBuffer(::MapViewOfFile(pfxFileMapping, FILE_MAP_READ, 0, 0, 0));

CRYPT_DATA_BLOB blob;
blob.cbData = ::GetFileSize(pfxFileHandle, 0);
blob.pbData = LPBYTE(LPVOID(pfxFileBuffer));

CSafeCertStoreHandle pfxStore(::PFXImportCertStore(&amp;blob, wszPassword, CRYPT_MACHINE_KEYSET | CRYPT_EXPORTABLE));
CSafeCertStoreHandle serviceStore(::CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_SERVICES, wszCertificateStoreName));

PCCERT_CONTEXT pctx = NULL;
while (NULL != (pctx = ::CertEnumCertificatesInStore(pfxStore, pctx)))
{
 ::CertAddCertificateContextToStore(serviceStore, pctx, CERT_STORE_ADD_REPLACE_EXISTING, NULL);
}
</code></pre>

<p>Ignore the <code>CSafeXXXHandle</code> and <code>CSafeMapViewOfFile</code> classes, these are simple handle/buffer holders, releasing the respective handle/buffer in the destructor (""resource acquisition is initialization"" design pattern).</p>

<p>Anyway, the <code>PFXImportCertStore</code> API fails with the message <strong>An error occurred during encode or decode operation</strong>. If I call the <code>PFXIsPFXBlob</code> API, it returns FALSE.</p>

<p>Here is the Locals debugger view at the start of the code:</p>

<pre><code>+        wszPfxFilePath    0x00774e0c ""tmp.pfx""    const wchar_t *
+        wszCertificateStoreName    0x002cf7f4 ""MSMQ\My""    const wchar_t *
+        wszPassword    0x00774e1c ""123""    const wchar_t *
</code></pre>

<p>So, all the parameters seem to be correct.</p>

<p>I have no idea what is wrong. The PFX file being imported is absolutely correct, because it is imported flawlessly using the MMC console.</p>

<p>Incidentally, I have based my code on the example found in this article - <a href=""http://www.codeguru.com/Cpp/I-N/internet/security/article.php/c6211"" rel=""nofollow noreferrer"">http://www.codeguru.com/Cpp/I-N/internet/security/article.php/c6211</a></p>

<h2>Edit</h2>

<p>I would like to emphasize that I need a non interactive procedure to copy the machine certificate from LocalComputer\My to MSMQ\My.</p>
","<p>Instead of using a program I would try to use the certificate store mmc plugin:</p>

<ul>
<li>Start <code>mmc.exe</code>, this will give you the MMC in authoring mode.</li>
<li>Click File -> Add/remove Snap-in</li>
<li>Find and double-click ""Certificates"". This will pop up a dialog where you can select which certificate storage you want to administer.</li>
<li>I think ""Service Account"" is the appropriate selection for you here</li>
<li>Click next</li>
<li>Select local if you are on il-mark-lap already, otherwise select ""Another computer"". AFAIK, you will have to be logged in with a domain administrator account for this to work though.</li>
<li>Click next</li>
<li>Select your service</li>
<li>click finish.</li>
</ul>

<p>At this point you should already be able to access the certificate storage for your service. If you want to do this more often then I suggest you do this as well:</p>

<ul>
<li>Right-click ""Certificates"" in the tree and select ""New Window from Here""</li>
<li>Switch back to the console root window and close it</li>
<li>Save your work of art to a .msc file</li>
</ul>

<h2>Edit</h2>

<p>Before you save, select ""Certificates"" from the tree, and then View -> Options. Here you can select to see the ""Physical Certificate stores"" if you like.</p>
","6749","<windows><certificate><ssl-certificate><cryptoapi>","1","1","1","2018-10-09 22:04:29","","1","","472495","","2018-09-04 21:58:55","2011-01-18 20:25:26",""
"15832846","Digital Signature SunMSCAPI provider & MS Crypto API","<p>I want to sign file with the <code>SunMSCAPI</code> provider. As public key and signatures needs to be imported using MS Crypto API.</p>

<p>Generally generating signatures with <code>SHA1withRSA</code>, ends up with big-endian to little-endian (byte order) conversion.</p>

<pre><code>//generate keystore with java keytool
$Keytool -genkey -alias tsign -keystore c:\test\tsignjks.p12 - keyalg rsa -storetype  pkcs12
</code></pre>

<p>In Java application:</p>

<pre><code>//for signing and getting keystore, assuming windows certificate is installed
..ks = KeyStore.getInstance(""Windows-MY"",""SunMSCAPI""); 
PrivateKey priv = ks.getKey(""tsign"",password); 
Signature rsa = Signature.getInstance(""SHA1withRSA"",""SunMSCAPI""); 
rsa.initSign(priv);
.. 
rsa.update(buffer, 0, len);
..
byte[] realSig = rsa.sign();

//for writing public key for ms crypto api or exporting it from windows certificate store
Certificate cert = ks.getCertificate(""tsign"");
byte[] encodedCert = cert.getEncoded();
FileOutputStream certfos = new FileOutputStream(""tsigncer.cer"");
certfos.write(encodedCert);

//for writing signatures for ms crypto api
FileOutputStream sigfos = new FileOutputStream(targetPath + ""/""
                + signatureName);
sigfos.write(realSig);
</code></pre>

<p>I believe that <code>SunMSCAPI</code> can resolve my problem, but I don't know when i import public key using MS Crypto API, It never import at at first stage (unless i change big endian to little endian byte order) below is my code for crypto API.</p>

<pre><code>LPCSTR file = ""tsigncer.cer"";
//LPCSTR file = ""omsign.p12"";
BOOL crypt_res = FALSE;

HCRYPTPROV crypt_prov_hndl = NULL;
 crypt_res = CryptAcquireContext(&amp;crypt_prov_hndl, NULL, NULL, PROV_RSA_FULL, 0/*CRYPT_NEWKEYSET*/);
//crypt_res = CryptAcquireContext(&amp;crypt_prov_hndl, NULL, NULL, PROV_DSS, CRYPT_VERIFYCONTEXT/*CRYPT_NEWKEYSET*/);

    if (!crypt_res) {
        HRESULT decode_hr = __HRESULT_FROM_WIN32(GetLastError());
        return decode_hr;
    }

    // Load key file
    HANDLE fileHandle = CreateFile(file, // name of the write
                       GENERIC_READ,          // open for writing
                       0,                      // do not share
                       NULL,                   // default security
                       OPEN_EXISTING,             // create new file only
                       FILE_ATTRIBUTE_NORMAL,  // normal file
                       NULL);                  // no attr. template

    if (fileHandle == INVALID_HANDLE_VALUE)
    {
        DWORD d = GetLastError();
        return -1;
    }

    BYTE buffer[2056];
    DWORD fileSize = 0;
    DWORD fileSizeResult = GetFileSize(fileHandle, &amp;fileSize);

    DWORD numBytesRead = 0;
    BOOL fileLoadResult = ReadFile(fileHandle, (PVOID)buffer, fileSizeResult, &amp;numBytesRead, NULL);

    // Import key
    BOOL result = ImportKey(crypt_prov_hndl, (LPBYTE)buffer, numBytesRead);
//result is always false..
</code></pre>
","<p>If you work with MSCAPI, it is assumed that you've added your key to the Microsoft Certificate store. You can check if the key is present by going to ""Internet Properties"" > ""Content"" > ""Certificates"" which gives you a list of certificates that are available. If your certificate isn't there, you can't use it. If it's there, you need this code:</p>

<pre><code>SunMSCAPI providerMSCAPI = new SunMSCAPI();
Security.addProvider(providerMSCAPI);
KeyStore ks = KeyStore.getInstance(""Windows-MY"");
ks.load(null, null);
</code></pre>

<p>From there on, the code is pretty standard. Please consult <a href=""http://itextpdf.com/book/digitalsignatures"">my book on digital signatures</a> for more info (the book is free).</p>

<p><strong>IMPORTANT ADDITION:</strong> I forgot to mention that SunMSCAPI isn't present in the 64-bit version of Java 6 (I don't know about Java 7). You can fix this by installing the 32-bit version.</p>
","6587","<java><rsa><digital-signature><cryptoapi><mscapi>","4","5","1","2013-04-05 17:29:14","15834393","0","2","1729133","","2013-04-05 17:29:14","2013-04-05 11:32:09",""
"4495247","MS Crypto API behavior on Windows XP vs Vista/7","<p>I'm trying to understand how to get a public key imported from PEM format (sample included in the code below) across XP, Vista and Windows 7.  The sample code will import the key on both XP and Windows Vista/7, but not the same way.</p>

<p>On Windows XP, the string <strong>""(Prototype)""</strong> is required in the cryptographic provider's name, and allows the call to CryptImportPublicKeyInfo to pass.  </p>

<p>On Windows 7, the <strong>""(Prototype)""</strong> provider is apparently present, but does not support the call to CryptImportPublicKeyInfo, which is confusing.</p>

<p>What might a correct implementation look like between these operating systems?  Is it necessary to detect XP and request the name with <strong>""(Prototype)""</strong>, and without it for other operating systems?  Is it possible that that will still fail on some XP systems?</p>

<p>Or, is there a way to detect this confusing behavior and select whichever cryptographic provider will support the necessary call?</p>

<p><em>Output on Windows 7:</em></p>

<pre><code>ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo success.
     SUCCESS.
ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo FAILED****.
</code></pre>

<p><em>Output on Windows XP:</em></p>

<pre><code>ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo FAILED****.
ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo success.
     SUCCESS.
</code></pre>

<p>C++ source code which produces that output: (requires crypt32.lib)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;

bool windowsAcquireProviderContext(HCRYPTPROV *pHandleProv, LPCTSTR pProviderName);
bool analyzeCryptographicSupport(LPCTSTR pProviderName);

int _tmain(int argc, _TCHAR* argv[])
{
    analyzeCryptographicSupport(MS_ENH_RSA_AES_PROV);
    analyzeCryptographicSupport(L""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"");
    return 0;
}

bool windowsAcquireProviderContext(HCRYPTPROV *pHandleProv, LPCTSTR pProviderName) {
    WCHAR *pContainerName = L""blah blah blah"";
    if(!CryptAcquireContext(pHandleProv, pContainerName, pProviderName, PROV_RSA_AES, CRYPT_SILENT)) {
        if(GetLastError() == NTE_BAD_KEYSET) {
            if(CryptAcquireContext(pHandleProv, pContainerName, pProviderName, PROV_RSA_AES, CRYPT_NEWKEYSET|CRYPT_SILENT)) {
                return true;
            }
        } 
    }
    return true;
}

LPCWSTR pwszPemPublicKey = 
    L""-----BEGIN PUBLIC KEY-----\r\n""
    L""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC6GUVcbn92bahlwOskKi8XkG9q\r\n""
    L""Vq863+C4cOWC6HzJojc011pJFFIBu8/pG1EI8FZJdBmTrFaJTriYw1/SpbOH0QqE\r\n""
    L""eHanT8qWn+S5m9xgDJoWTBJKcnu3OHOvJJU3c8jOHQQnRWLfghJH4vnwStdiwUUY\r\n""
    L""SMWpwuHObsNelGBgEQIDAQAB\r\n""
    L""-----END PUBLIC KEY-----\r\n"";
int pemPublicKeySize = wcslen(pwszPemPublicKey);

bool analyzeCryptographicSupport(LPCTSTR pProviderName) {

    printf(""ANALYZING CRYPTOGRAPHIC SUPPORT FOR:\r\n"");
    wprintf(L""\t \""%s\""\r\n"", pProviderName);

    HCRYPTPROV hProv;
    if(!windowsAcquireProviderContext(&amp;hProv, pProviderName)) {
        wprintf(L""\t CryptAcquireContext FAILED.\r\n"");
        return false;
    }
    wprintf(L""\t CryptAcquireContext success.\r\n"");

    DWORD blobSize;

    if(!CryptStringToBinary(pwszPemPublicKey, pemPublicKeySize, CRYPT_STRING_BASE64_ANY,  NULL, &amp;blobSize, NULL, NULL)) {
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptStringToBinary.1 FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptAcquireContext.1 success.\r\n"");

    BYTE *pBlob = (BYTE *)malloc(blobSize);

    if(!CryptStringToBinary(pwszPemPublicKey, pemPublicKeySize, CRYPT_STRING_BASE64_ANY,  pBlob, &amp;blobSize, NULL, NULL)) {
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptStringToBinary.2 FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptStringToBinary.2 success.\r\n"");

    CERT_PUBLIC_KEY_INFO *publicKeyInfo;
    DWORD publicKeyInfoLen;
    HCRYPTKEY hPublicKey;

    if(!CryptDecodeObjectEx(X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pBlob, blobSize, CRYPT_DECODE_ALLOC_FLAG, NULL, &amp;publicKeyInfo, &amp;publicKeyInfoLen)) {
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptDecodeObjectEx FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptDecodeObjectEx success.\r\n"");

    if(!CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, publicKeyInfo, &amp;hPublicKey)) {
        LocalFree(publicKeyInfo);
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptImportPublicKeyInfo FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptImportPublicKeyInfo success.\r\n"");

    CryptDestroyKey(hPublicKey);
    LocalFree(publicKeyInfo);
    free(pBlob);
    CryptReleaseContext(hProv, 0);

    wprintf(L""\t SUCCESS.\r\n"");
    return true;
}
</code></pre>
","<p>I think I remember reading somewhere that Microsoft goofed up on the name and it requires ""(Prototype)"" to be present on XP and absent on Vista and above.  I think you will have to detect the platform at runtime and use the appropriate string.</p>
","6567","<c++><windows-xp><cryptoapi><mscapi>","9","0","2","2015-06-09 02:47:42","4523302","0","2","608639","","2015-06-09 02:47:42","2010-12-21 00:20:15",""
"4495247","MS Crypto API behavior on Windows XP vs Vista/7","<p>I'm trying to understand how to get a public key imported from PEM format (sample included in the code below) across XP, Vista and Windows 7.  The sample code will import the key on both XP and Windows Vista/7, but not the same way.</p>

<p>On Windows XP, the string <strong>""(Prototype)""</strong> is required in the cryptographic provider's name, and allows the call to CryptImportPublicKeyInfo to pass.  </p>

<p>On Windows 7, the <strong>""(Prototype)""</strong> provider is apparently present, but does not support the call to CryptImportPublicKeyInfo, which is confusing.</p>

<p>What might a correct implementation look like between these operating systems?  Is it necessary to detect XP and request the name with <strong>""(Prototype)""</strong>, and without it for other operating systems?  Is it possible that that will still fail on some XP systems?</p>

<p>Or, is there a way to detect this confusing behavior and select whichever cryptographic provider will support the necessary call?</p>

<p><em>Output on Windows 7:</em></p>

<pre><code>ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo success.
     SUCCESS.
ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo FAILED****.
</code></pre>

<p><em>Output on Windows XP:</em></p>

<pre><code>ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo FAILED****.
ANALYZING CRYPTOGRAPHIC SUPPORT FOR:
     ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""
     CryptAcquireContext success.
     CryptAcquireContext.1 success.
     CryptStringToBinary.2 success.
     CryptDecodeObjectEx success.
     CryptImportPublicKeyInfo success.
     SUCCESS.
</code></pre>

<p>C++ source code which produces that output: (requires crypt32.lib)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;

bool windowsAcquireProviderContext(HCRYPTPROV *pHandleProv, LPCTSTR pProviderName);
bool analyzeCryptographicSupport(LPCTSTR pProviderName);

int _tmain(int argc, _TCHAR* argv[])
{
    analyzeCryptographicSupport(MS_ENH_RSA_AES_PROV);
    analyzeCryptographicSupport(L""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"");
    return 0;
}

bool windowsAcquireProviderContext(HCRYPTPROV *pHandleProv, LPCTSTR pProviderName) {
    WCHAR *pContainerName = L""blah blah blah"";
    if(!CryptAcquireContext(pHandleProv, pContainerName, pProviderName, PROV_RSA_AES, CRYPT_SILENT)) {
        if(GetLastError() == NTE_BAD_KEYSET) {
            if(CryptAcquireContext(pHandleProv, pContainerName, pProviderName, PROV_RSA_AES, CRYPT_NEWKEYSET|CRYPT_SILENT)) {
                return true;
            }
        } 
    }
    return true;
}

LPCWSTR pwszPemPublicKey = 
    L""-----BEGIN PUBLIC KEY-----\r\n""
    L""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC6GUVcbn92bahlwOskKi8XkG9q\r\n""
    L""Vq863+C4cOWC6HzJojc011pJFFIBu8/pG1EI8FZJdBmTrFaJTriYw1/SpbOH0QqE\r\n""
    L""eHanT8qWn+S5m9xgDJoWTBJKcnu3OHOvJJU3c8jOHQQnRWLfghJH4vnwStdiwUUY\r\n""
    L""SMWpwuHObsNelGBgEQIDAQAB\r\n""
    L""-----END PUBLIC KEY-----\r\n"";
int pemPublicKeySize = wcslen(pwszPemPublicKey);

bool analyzeCryptographicSupport(LPCTSTR pProviderName) {

    printf(""ANALYZING CRYPTOGRAPHIC SUPPORT FOR:\r\n"");
    wprintf(L""\t \""%s\""\r\n"", pProviderName);

    HCRYPTPROV hProv;
    if(!windowsAcquireProviderContext(&amp;hProv, pProviderName)) {
        wprintf(L""\t CryptAcquireContext FAILED.\r\n"");
        return false;
    }
    wprintf(L""\t CryptAcquireContext success.\r\n"");

    DWORD blobSize;

    if(!CryptStringToBinary(pwszPemPublicKey, pemPublicKeySize, CRYPT_STRING_BASE64_ANY,  NULL, &amp;blobSize, NULL, NULL)) {
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptStringToBinary.1 FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptAcquireContext.1 success.\r\n"");

    BYTE *pBlob = (BYTE *)malloc(blobSize);

    if(!CryptStringToBinary(pwszPemPublicKey, pemPublicKeySize, CRYPT_STRING_BASE64_ANY,  pBlob, &amp;blobSize, NULL, NULL)) {
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptStringToBinary.2 FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptStringToBinary.2 success.\r\n"");

    CERT_PUBLIC_KEY_INFO *publicKeyInfo;
    DWORD publicKeyInfoLen;
    HCRYPTKEY hPublicKey;

    if(!CryptDecodeObjectEx(X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pBlob, blobSize, CRYPT_DECODE_ALLOC_FLAG, NULL, &amp;publicKeyInfo, &amp;publicKeyInfoLen)) {
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptDecodeObjectEx FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptDecodeObjectEx success.\r\n"");

    if(!CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, publicKeyInfo, &amp;hPublicKey)) {
        LocalFree(publicKeyInfo);
        free(pBlob);
        CryptReleaseContext(hProv, 0);
        wprintf(L""\t CryptImportPublicKeyInfo FAILED****.\r\n"");
        return false;
    }
    wprintf(L""\t CryptImportPublicKeyInfo success.\r\n"");

    CryptDestroyKey(hPublicKey);
    LocalFree(publicKeyInfo);
    free(pBlob);
    CryptReleaseContext(hProv, 0);

    wprintf(L""\t SUCCESS.\r\n"");
    return true;
}
</code></pre>
","<p>The reason of the problem which you describes is very easy: <strong>Microsoft renamed AES Cryptographic Provider</strong> from </p>

<ul>
<li><code>""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""</code> in Windows XP to </li>
<li><code>""Microsoft Enhanced RSA and AES Cryptographic Provider""</code> in the later versions of the operation systems. </li>
</ul>

<p>In <code>WinCrypt.h</code> are defined the corresponding constants as <code>MS_ENH_RSA_AES_PROV</code> and <code>MS_ENH_RSA_AES_PROV_XP</code> which you can use.</p>

<p>If you don't want to test the version of the operation system you can just use <a href=""http://msdn.microsoft.com/en-us/library/aa379886%28VS.85%29.aspx"">CryptAcquireContext</a> with <code>NULL</code> as <code>pszProvider</code> (and continue to use <code>PROV_RSA_AES</code> as the <code>dwProvType</code>). In your code you can include <code>analyzeCryptographicSupport(NULL);</code>.</p>

<p>You can also examine the ""Name"" value of the registry key</p>

<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\Defaults\Provider Types\Type 024
</code></pre>

<p>to see the name of the default <code>PROV_RSA_AES</code> provider. </p>
","6567","<c++><windows-xp><cryptoapi><mscapi>","9","10","2","2015-06-09 02:47:42","4523302","0","2","608639","","2015-06-09 02:47:42","2010-12-21 00:20:15",""
"17382176","Microsoft's cryptoAPI ""Microsoft Enhanced RSA and AES Cryptographic Provider"" selection doesn't working on win7","<p>I want to use AES 256 bit enncrytion for data and it is provided by ""MS_ENH_RSA_AES_PROV"" .For that When I tried running below code with 
pszProviderName=TEXT(""MS_ENH_RSA_AES_PROV"") 
as 3rd parameter of CryptAcquireContext, I get output something like Error number 80090019 .This error code means ""The requested provider does not exist"". </p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;Wincrypt.h&gt;

#pragma comment(lib, ""crypt32.lib"")

void main(void) 
{ 
    // Handle for the cryptographic provider context.
    HCRYPTPROV hCryptProv;

    // The name of the container.
    LPCTSTR pszContainerName = TEXT(""MyFilter_Container"");

    // The name of the provider
    LPCTSTR pszProviderName = TEXT(""MS_ENH_RSA_AES_PROV"");

    // Begin processing. Attempt to acquire a context
    if(CryptAcquireContext(
        &amp;hCryptProv,
        pszContainerName,
        pszProviderName,
        PROV_RSA_FULL,
        0))
    {
        _tprintf(TEXT(""A crypto context acquired""));

        // Release the CSP.
        if(hCryptProv)
        {
            if(!(CryptReleaseContext(hCryptProv, 0)))
            {
                 _tprintf(TEXT(""Error during CryptReleaseContext.""));
            }
        }
    }
    else
    {
        _tprintf(TEXT(""An error occurred in the program. \n""));
        _tprintf(TEXT(""Error number %x.\n""), GetLastError());
        exit(1); 
    }
}
</code></pre>

<p>And if I use 
pszProviderName=TEXT(""Microsoft Enhanced RSA and AES Cryptographic Provider""), 
it gives Error number 0x8009001b which means ""The provider type specified by dwProvType does not match the provider type found and that this error can only occur when pszProviderName specifies an actual CSP name"".Above error numbers are specified in CryptAcquireContext documentation at msdn. I am not getting why this is happening. If this parameter is Null that means default CSP to use, in that case everything works fine. I am using windows7. Is this CSP not available or some other reason is there?Please somebody help.Thanks in adv. </p>
","<p>I'm not sure if this is exactly what you need but by following <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886%28v=vs.85%29.aspx"" rel=""nofollow"">the example on MSDN</a>, you can make your code succeed by making two changes.</p>

<p>First, <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380243%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN says</a> that <code>MS_ENH_RSA_AES_PROV</code> was named differently on Windows XP and should be used with a provider type of <code>PROV_RSA_AES</code> rather than <code>PROV_RSA_FULL</code> as in your code.</p>

<p>Second, trap the initial error and repeat the acquire operation for the situation where you have to create a new key container.</p>

<p>The following is your original code adapted according to the MSDN example, and works fine on my Windows 8 system:</p>

<pre><code>int _tmain(int argc, _TCHAR* argv[])
{
    // Handle for the cryptographic provider context.
    HCRYPTPROV hCryptProv;

    // The name of the container.
    LPCTSTR pszContainerName = TEXT(""MyFilter_Container"");

    // Begin processing. Attempt to acquire a context
    if(CryptAcquireContext(
        &amp;hCryptProv,
        pszContainerName,
        MS_ENH_RSA_AES_PROV,
        PROV_RSA_AES,
        0))
    {
        _tprintf(TEXT(""A crypto context acquired""));

        // Release the CSP.
        if(hCryptProv)
        {
            if(!(CryptReleaseContext(hCryptProv, 0)))
            {
                _tprintf(TEXT(""Error during CryptReleaseContext.""));
            }
        }
    }
    else
    {
        DWORD dwError = GetLastError();
        if (dwError == NTE_BAD_KEYSET)
        {
            if(CryptAcquireContext(
                &amp;hCryptProv,
                pszContainerName,
                MS_ENH_RSA_AES_PROV,
                PROV_RSA_AES,
                CRYPT_NEWKEYSET))
            {
                _tprintf(TEXT(""A crypto context acquired""));

                // Release the CSP.
                if(hCryptProv)
                {
                    if(!(CryptReleaseContext(hCryptProv, 0)))
                    {
                        _tprintf(TEXT(""Error during CryptReleaseContext.""));
                    }
                }
            }
            else
            {
                _tprintf(TEXT(""Unable to create a new key container. \n""));
                _tprintf(TEXT(""Error number %x.\n""), dwError);
                exit(1); 
            }
        }
        else
        {
            _tprintf(TEXT(""An error occurred in the program. \n""));
            _tprintf(TEXT(""Error number %x.\n""), dwError);
            exit(1); 
        }
    }

    return 0;
}
</code></pre>

<p>Once you have success, you can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380196%28v=vs.85%29.aspx"" rel=""nofollow""><code>CryptGetProvParam</code></a> to find the provider used, which on my system gives   </p>

<p><code>Microsoft Enhanced RSA and AES Cryptographic Provider</code>   </p>
","6535","<visual-c++><encryption><aes><cryptoapi><mscapi>","2","2","1","2015-06-09 02:47:06","17387988","3","","608639","","2015-06-09 02:47:06","2013-06-29 16:13:31",""
"15945218","CryptoAPI AcquireContext fails to retrieve key container","<p>I am porting an old VB6 application to .NET and I am having an issue since yesterday afternoon with some CryptoAPI calls. </p>

<p>In particular I can't retrieve a key container which is already defined. I use the <code>CryptAcquireContext()</code> function. I use some test code where I create the container. Then If I go to <code>C:\Users...\Roaming\Microsoft\Crypto\RSA\Machine Keys\</code> I can see a file created with my defined container name inside so I assume it's created successfully. </p>

<p>A subsequent call to try creating the same container verifies that assumption because I get the win32 error that the keyset is already defined. </p>

<p>Anyway on my next code call where I try to retrieve the container I already created I get the windows error that the keyset is not defined. </p>

<blockquote>
  <p>Error : -2146893799 (80090019)    The keyset is not defined. </p>
</blockquote>

<p>Any ideas?</p>

<p>Here's a code example : </p>

<pre><code>public const uint PROV_RSA_FULL = 1;
public const uint CRYPT_NEWKEYSET = 0x00000008;
public const uint CRYPT_MACHINE_KEYSET = 0x00000020;
const string MS_DEF_PROV = ""Microsoft Base Cryptographic Provider v1.0"";

[DllImport(""advapi32.dll"", SetLastError = true)]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool CryptAcquireContext(out IntPtr phProv, string pszContainer, string pszProvider, uint dwProvType, uint dwFlags);

public static void CreateContainer()
{
        IntPtr hCryptProv;
        int error;
        if (!CryptAcquireContext(out hCryptProv, ""new"", MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET))
        {
            error = Marshal.GetLastWin32Error();
        }

        if (!CryptAcquireContext(out hCryptProv, ""new"", MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
        {
            error = Marshal.GetLastWin32Error();
        }
}
</code></pre>
","<p>You are creating key container for that user, but trying to get it from machine-based storage. To fix the problem you need either change <code>CRYPT_MACHINE_KEYSET</code> to 0 or when creating keyset use <code>CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET</code> according to your needs.</p>

<blockquote>
  <p>By default, keys and key containers are stored as user keys. For Base Providers, this means that user key containers are stored in the user's profile. A key container created without this flag by an administrator can be accessed only by the user creating the key container and a user with administration privileges.</p>
</blockquote>

<p>For details, please check the links below.</p>

<p><a href=""http://support.microsoft.com/kb/238187"" rel=""nofollow noreferrer"">CryptAcquireContext() use and troubleshooting</a></p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">CryptAcquireContext function</a></p>
","6111","<c#><.net><cryptoapi>","2","5","1","2018-01-10 09:23:24","15946651","2","","352640","","2018-01-10 09:23:24","2013-04-11 09:27:14",""
"1525658","Decryption with AES and CryptoAPI? When you know the KEY/SALT","<p>Okay so i have a packed a proprietary binary format. That is basically a loose packing of several different raster datasets. Anyways in the past just reading this and unpacking was an easy task. But now in the next version the raster xml data is now to be encrypted using AES-256(Not my choice nor do we have a choice). </p>

<p>Now we basically were sent the AES Key along with the SALT they are using so we can modify our unpackager. </p>

<p>NOTE THESE ARE NOT THE KEYS JUST AN EXAMPLE:</p>

<p>They are each 63 byte long ASCII characters:</p>

<pre><code>Key: ""QS;x||COdn'YQ@vs-`X\/xf}6T7Fe)[qnr^U*HkLv(yF~n~E23DwA5^#-YK|]v.""
Salt: ""|$-3C]IWo%g6,!K~FvL0Fy`1s&amp;N&lt;|1fg24Eg#{)lO=o;xXY6o%ux42AvB][j#/&amp;""
</code></pre>

<p>We basically want to use the C++ CryptoAPI to decrypt this(I also am the only programmer here this week, and this is going live tomorrow. Not our fault). I've looked around for a simple tutorial of implementing this. Unfortunately i cannot even find a tutorial where they have both the salt and key separately. Basically all i have really right now is a small function that takes in an array of BYTE. Along with its length. How can i do this?</p>

<p>I've spent most of the morning trying to make heads/tails of the cryptoAPI. But its not going well period :(</p>

<p>EDIT</p>

<p>So i asked for how they encrypt it. They use C#, and use RijndaelManaged, which from my knowledge is not equivalent to AES. </p>

<p>EDIT2</p>

<p>Okay finally got exactly what was going on, and they sent us the wrong keys.</p>

<p>They are doing the following:</p>

<p>Padding = PKCS7
CipherMode = CBC
The Key is defined as a set of 32 Bytes in hex.
The IV is defined as a set of 32 bytes in hex too.</p>

<p>They took away the salt when i asked them.</p>

<p>How hard is it to set these things in CryptoAPI using the wincrypt.h header file.?</p>
","<p>AES-256 uses 256 bit keys. Ideally, each key in your system should be equally likely. A 63 byte string would be 504 bits. You first need to figure out how the string of 63 characters needs to be converted to 256 bits (The sample ones you gave are not base64 encoded). Next, ""salt"" isn't an intrinsic part of AES. You might be referring to either an initialization vector (IV) in Cipher-Block-Chaining mode or you could be referring to somehow updating the key. </p>

<p>If I were to guess, I'm assuming that by ""SALT"" you mean IV and specifically CBC mode. </p>

<p>You will need to know all of this when using CAPI functions (e.g. <a href=""http://msdn.microsoft.com/en-us/library/aa378195%28VS.85%29.aspx"" rel=""nofollow noreferrer"">decrypt</a>).</p>

<p>If all of this sounds confusing, then it might be best to change your design so that you don't have to worry about getting all of this right. Crypto is hard. One bad step could invalidate all the security. Consider looking at <a href=""http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html?showComment=1254448126873#c7933132611242458392"" rel=""nofollow noreferrer"">this comment</a> on my <a href=""http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html"" rel=""nofollow noreferrer"">Stick Figure Guide to AES</a>.</p>

<p><strong>UPDATE</strong>: You can <a href=""http://www.codeproject.com/KB/security/WinAES.aspx"" rel=""nofollow noreferrer"">look at this for a rough starting</a> point for C++ CAPI. You'll need a 64 character hex string to get 256 bits ( 256 bits / (4 bits / char) == 64 chars). You can convert the chars to bits yourself. </p>

<p>Again, I must caution that playing fast and loose with IV's and keys can have disastrous consequences. I've studied AES/Rijndael in depth down to the math and gate level and have even written my own implementation. However, in my production code, I stick to using a well-tested TLS implementation if at all possible for data in transit. Even for data at rest, it'd be better to use a <a href=""http://www.moserware.com/2009/09/stick-figure-guide-to-advanced.html?showComment=1254448126873#c7933132611242458392"" rel=""nofollow noreferrer"">higher level library</a>.</p>
","5686","<c++><rijndaelmanaged><cryptoapi>","3","5","2","2010-01-24 19:39:14","1525803","2","2","95573","","2010-01-24 19:39:14","2009-10-06 13:38:45",""
"1525658","Decryption with AES and CryptoAPI? When you know the KEY/SALT","<p>Okay so i have a packed a proprietary binary format. That is basically a loose packing of several different raster datasets. Anyways in the past just reading this and unpacking was an easy task. But now in the next version the raster xml data is now to be encrypted using AES-256(Not my choice nor do we have a choice). </p>

<p>Now we basically were sent the AES Key along with the SALT they are using so we can modify our unpackager. </p>

<p>NOTE THESE ARE NOT THE KEYS JUST AN EXAMPLE:</p>

<p>They are each 63 byte long ASCII characters:</p>

<pre><code>Key: ""QS;x||COdn'YQ@vs-`X\/xf}6T7Fe)[qnr^U*HkLv(yF~n~E23DwA5^#-YK|]v.""
Salt: ""|$-3C]IWo%g6,!K~FvL0Fy`1s&amp;N&lt;|1fg24Eg#{)lO=o;xXY6o%ux42AvB][j#/&amp;""
</code></pre>

<p>We basically want to use the C++ CryptoAPI to decrypt this(I also am the only programmer here this week, and this is going live tomorrow. Not our fault). I've looked around for a simple tutorial of implementing this. Unfortunately i cannot even find a tutorial where they have both the salt and key separately. Basically all i have really right now is a small function that takes in an array of BYTE. Along with its length. How can i do this?</p>

<p>I've spent most of the morning trying to make heads/tails of the cryptoAPI. But its not going well period :(</p>

<p>EDIT</p>

<p>So i asked for how they encrypt it. They use C#, and use RijndaelManaged, which from my knowledge is not equivalent to AES. </p>

<p>EDIT2</p>

<p>Okay finally got exactly what was going on, and they sent us the wrong keys.</p>

<p>They are doing the following:</p>

<p>Padding = PKCS7
CipherMode = CBC
The Key is defined as a set of 32 Bytes in hex.
The IV is defined as a set of 32 bytes in hex too.</p>

<p>They took away the salt when i asked them.</p>

<p>How hard is it to set these things in CryptoAPI using the wincrypt.h header file.?</p>
","<p>Rijndael is the algorithm name for <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""nofollow noreferrer"">AES</a></p>
","5686","<c++><rijndaelmanaged><cryptoapi>","3","-5","2","2010-01-24 19:39:14","1525803","2","2","95573","","2010-01-24 19:39:14","2009-10-06 13:38:45",""
"18761993","Steps to include timestamp in PDF signature","<p>Good day,</p>

<p>I'm trying to embedded timestamp information into a pdf signature so that adobe will report to me that the signature was timestamp. Currently, all I've achieved is that Adobe reports that ""The signature includes an embedded timestamp but it could not be verified"" and when you view the Date/Time properties it says that the ""Timestamp Authority"" s not available and the ""Show Certificate"" is greyed out.</p>

<p>Obviously, I am doing something wrong in constructing my PKCS#7 message. But I don't now what.
Can someone please help me by describing the steps I need to take so that my signature will be timestamped? Or suggest a tool that can help me find the problem?</p>

<p>I'm using Crypto API. The steps I follow currently is as follows:</p>

<ol>
<li>Create a digest of the pdf data using the <em>CryptHashMessage</em> function (SHA256).</li>
<li>Send this digest to the TSA using the <em>CryptRetrieveTimeStamp</em> function. I've set the *TIMESTAMP_DONT_HASH_DATA* flag so that the digest won't be hashed again.</li>
<li>The repsonse from the TSA is added to a *CRYPT_SIGN_MESSAGE_PARA* structure as an unauthenticated attribute and the signing time is added as an authenticated attribute.</li>
<li>Then I use the <em>CryptSignMessage</em> function to sign the original data which uses the above structure.</li>
</ol>

<p>How can I check that the data is correct so that adobe can show me that the signature has been timestamped?</p>

<p>Regards,
Magda</p>
","<p><strong>In a nutshell: You are time stamping the wrong data, see the bottom of the answer.</strong></p>

<p>Major differences between your signature and Adobe's signature:</p>

<ol>
<li><p>Adobe's signature contains a signed revocation information attribute; this attribute does not contains any actual revocation information. </p>

<p><em>As this attribute is optional, it should not be relevant here.</em></p></li>
<li><p>Your signature contains a signed signing time attribute. </p>

<p><em>As you also have a time stamp embedded, a signing time is not necessary but it is not forbidden, either.</em></p></li>
<li><p>Your signature has a signatureAlgorithm value of 1.2.840.113549.1.1.1, i.e. <strong>RSA encryption</strong> while Adobe's is 1.2.840.113549.1.1.11, i.e. <strong>sha256WithRSAEncryption</strong></p>

<p><em>Here Adobe's choice definitively is the better one but Adobe Reader seems to ignore the deficiency in your signature: After all, it says that the document had not been changed since signing.</em></p></li>
<li><p>In your signature the time stamp stamps the hash of the PDF document, i.e. the same as in the signature's signed messageDigest attribute while in Adobe's signature the time stamp stamps a different one.</p>

<p><em>BANG. This is the problem. Admittedly you'd said it in your original question but it didn't catch my eye:</em></p>

<ol>
<li><p>Create a digest of the pdf data using the CryptHashMessage function (SHA256).</p></li>
<li><p>Send this digest to the TSA using the CryptRetrieveTimeStamp function. I've set the *TIMESTAMP_DONT_HASH_DATA* flag so that the digest won't be hashed again.</p></li>
</ol>

<p><em>This is wrong! The time stamp is added as an unsigned attribute, according to spec:</em></p>

<blockquote>
  <p>Time stamp information as an unsigned attribute (PDF 1.6): The timestamp token shall conform to RFC 3161 and shall be computed and embedded into the PKCS#7 object as described in Appendix A of RFC 3161.</p>
  
  <p><em>(section 12.8.3.3.1 of <a href=""http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf"">ISO 32000-1</a>)</em></p>
</blockquote>

<p><em>And RFC 3161 states:</em></p>

<blockquote>
  <p>The value of messageImprint field within TimeStampToken shall be a hash of the value of signature field within SignerInfo for the signedData being time-stamped.</p>
  
  <p><em>(Appendix A of <a href=""http://tools.ietf.org/html/rfc3161"">RFC 3161</a>)</em></p>
</blockquote>

<p><em>Thus, <strong>you are time stamping the wrong hash!</strong> Adobe correctly expects you to time stamp the signature. So you should first create a regular signature, then look up its signature value, hash &amp; time stamp that value, and then add that time stamp to the signature container signer info as unsigned time stamp attribute.</em></p>

<p><em>Unfortunately I don't know the Windows Crypto API well enough to explain how to do that; I'm more at home in the Java crypto api.</em></p></li>
</ol>
","5396","<pdf><digital-signature><cryptoapi><trusted-timestamp>","4","7","2","2019-10-15 06:17:31","","3","3","","","","2013-09-12 10:39:51",""
"18761993","Steps to include timestamp in PDF signature","<p>Good day,</p>

<p>I'm trying to embedded timestamp information into a pdf signature so that adobe will report to me that the signature was timestamp. Currently, all I've achieved is that Adobe reports that ""The signature includes an embedded timestamp but it could not be verified"" and when you view the Date/Time properties it says that the ""Timestamp Authority"" s not available and the ""Show Certificate"" is greyed out.</p>

<p>Obviously, I am doing something wrong in constructing my PKCS#7 message. But I don't now what.
Can someone please help me by describing the steps I need to take so that my signature will be timestamped? Or suggest a tool that can help me find the problem?</p>

<p>I'm using Crypto API. The steps I follow currently is as follows:</p>

<ol>
<li>Create a digest of the pdf data using the <em>CryptHashMessage</em> function (SHA256).</li>
<li>Send this digest to the TSA using the <em>CryptRetrieveTimeStamp</em> function. I've set the *TIMESTAMP_DONT_HASH_DATA* flag so that the digest won't be hashed again.</li>
<li>The repsonse from the TSA is added to a *CRYPT_SIGN_MESSAGE_PARA* structure as an unauthenticated attribute and the signing time is added as an authenticated attribute.</li>
<li>Then I use the <em>CryptSignMessage</em> function to sign the original data which uses the above structure.</li>
</ol>

<p>How can I check that the data is correct so that adobe can show me that the signature has been timestamped?</p>

<p>Regards,
Magda</p>
","<p>Timestamping is not done correctly.
Check my <a href=""https://www.codeproject.com/articles/1114232/cplusplus-mime-a-simple-single-header-parser-an"" rel=""nofollow noreferrer"">mime library</a>. You need to add an unauthenticated field with oID   ""1.2.840.113549.1.9.16.2.14"".</p>
","5396","<pdf><digital-signature><cryptoapi><trusted-timestamp>","4","0","2","2019-10-15 06:17:31","","3","3","","","","2013-09-12 10:39:51",""
"18808391","Using AES encryption with binary FileStream, read + write","<p>I've hacked up some other code I've found thanks to SO.  I'm not getting any errors when writing my encrypted data to disk, but I get an ""index of bounds"" error inside the RijndaelManaged class when reading data back.</p>

<p>This is my class I'm using to create a read and write stream wrapped with AES encryption (this is my actual salt, but I'll be sure to change it before release):</p>

<pre><code>public class Crypto
{
    private static byte[] _salt = Encoding.ASCII.GetBytes(""42kb$2fs$@#GE$^%gdhf;!M807c5o666"");

    public static Stream CreateCryptoStreamAESWrite(string sharedSecret, Stream stream)
    {
        if (string.IsNullOrEmpty(sharedSecret))
            throw new ArgumentNullException(""sharedSecret"");

        // generate the key from the shared secret and the salt
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, _salt);

        // Create a RijndaelManaged object
        RijndaelManaged aesAlg = new RijndaelManaged();
        aesAlg.Key = key.GetBytes(aesAlg.KeySize / 8);

        // Create a decryptor to perform the stream transform.
        ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

        // prepend the IV
        stream.Write(BitConverter.GetBytes(aesAlg.IV.Length), 0, sizeof(int));
        stream.Write(aesAlg.IV, 0, aesAlg.IV.Length);

        CryptoStream csEncrypt = new CryptoStream(stream, encryptor, CryptoStreamMode.Write);
        return csEncrypt;
    }

    public static Stream CreateCryptoStreamAESRead(string sharedSecret, Stream stream)
    {
        if (string.IsNullOrEmpty(sharedSecret))
            throw new ArgumentNullException(""sharedSecret"");

        // generate the key from the shared secret and the salt
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, _salt);

        // Create a RijndaelManaged object
        // with the specified key and IV.
        RijndaelManaged aesAlg = new RijndaelManaged();
        aesAlg.Key = key.GetBytes(aesAlg.KeySize / 8);

        // Get the initialization vector from the encrypted stream
        aesAlg.IV = ReadByteArray(stream);

        // Create a decrytor to perform the stream transform.
        ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);
        CryptoStream csDecrypt = new CryptoStream(stream, decryptor, CryptoStreamMode.Read);
        return csDecrypt;
    }

    private static byte[] ReadByteArray(Stream s)
    {
        byte[] rawLength = new byte[sizeof(int)];
        if (s.Read(rawLength, 0, rawLength.Length) != rawLength.Length)
            throw new SystemException(""Stream did not contain properly formatted byte array"");

        byte[] buffer = new byte[BitConverter.ToInt32(rawLength, 0)];
        if (s.Read(buffer, 0, buffer.Length) != buffer.Length)
            throw new SystemException(""Did not read byte array properly"");

        return buffer;
    }
}
</code></pre>

<p>Here is some test usage code I wrote:</p>

<pre><code>        FileStream fs = new FileStream(""c:\\temp\\test.dat"", FileMode.Create, FileAccess.ReadWrite, FileShare.None);
        Stream cs = Crypto.CreateCryptoStreamAESWrite(""test"", fs);
        BinaryWriter bw = new BinaryWriter(cs);
        bw.Write(""test"");
        cs.Flush();
        fs.Close();
        fs = new FileStream(""c:\\temp\\test.dat"", FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        cs = Crypto.CreateCryptoStreamAESRead(""test"", fs);
        BinaryReader br = new BinaryReader(cs);
        string test = br.ReadString();
        if (test != ""test"")
            throw new Exception(""Your Kungfu is not good!"");
        fs.Close();
</code></pre>

<p>This is the error I get on the br.ReadString() line:</p>

<pre><code>System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at System.Security.Cryptography.RijndaelManagedTransform.DecryptData(Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount, Byte[]&amp; outputBuffer, Int32 out
putOffset, PaddingMode paddingMode, Boolean fLast)
   at System.Security.Cryptography.RijndaelManagedTransform.TransformFinalBlock(
Byte[] inputBuffer, Int32 inputOffset, Int32 inputCount)
   at System.Security.Cryptography.CryptoStream.Read(Byte[] buffer, Int32 offset, Int32 count)
   at System.IO.Stream.ReadByte()
   at System.IO.BinaryReader.ReadByte()
</code></pre>
","<p>Looks like I needed to call <code>Close</code> on my Crypto stream.  I was calling <code>Flush</code>, but not Close.  I replaced cs.Flush() with cs.Close() and now it is working.</p>

<p>Hopefully someone can at least learn from the example code in my question, although I imagine there is an easier way to just read/write AES encrypted streams (to/from file or otherwise).</p>
","5292","<c#><.net><encryption><cryptoapi>","1","1","1","2013-09-15 11:27:11","18811835","0","2","1042232","","2013-09-15 11:20:49","2013-09-15 02:32:19",""
"3753539","How do I force makecert to output the private key to a file (not the Crypto store)?","<p>I want to generate a key pair for use within my applications, but exporting them manually from the mmc is a pain.</p>

<p>How can I use commandline parameters, or otherwise end up with a private certificate that resides on the hard drive, suitable for later distribution?</p>
","<p>Have a look at this article: <a href=""http://msdn.microsoft.com/en-us/library/bfsktky3%28VS.80%29.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/bfsktky3%28VS.80%29.aspx</a></p>

<p>Specifically, use the <code>-sv</code> option to save the private key to a file.</p>
","4785","<certificate><ssl-certificate><cryptoapi><private-key><makecert>","3","2","1","2010-09-20 16:49:52","3753604","0","","","","","2010-09-20 16:43:16",""
"8266581","Why does my CryptDecrypt fail with error code 0x80090005 (NTE_BAD_DATA)?","<p>I wrote this piece of code to decrypt a given cipher using a given key and iv. It works fine until CryptDecrypt which returns false and GetLastError() returns 0x80090005 (which should be NTE_BAD_DATA).</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

struct AesKey
{
    BLOBHEADER Header;
    DWORD dwKeyLength;
    BYTE cbKey[16];

        AesKey()
    {
        ZeroMemory(this, sizeof(*this));
        Header.bType = PLAINTEXTKEYBLOB;
        Header.bVersion = CUR_BLOB_VERSION;
        Header.reserved = 0;
        Header.aiKeyAlg = CALG_AES_128;
        dwKeyLength = 16;
    }
};

void AesDecrypt(unsigned char *output, unsigned char *input, int inLen, unsigned char *key, unsigned char *iv, int &amp;plainSize)
{
    HCRYPTPROV provider;
    AesKey rawKey;
    HCRYPTKEY cKey;

    BOOL hr = CryptAcquireContext(&amp;provider, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0);
    if (hr == FALSE)
        throw ""Unable to acquire AES Context"";

    for (int i = 0; i &lt; 16; i++)
        rawKey.cbKey[i] = key[i];

    hr = CryptImportKey(provider, (BYTE *) &amp;rawKey, sizeof(AesKey), NULL, 0, &amp;cKey);
    if (hr == FALSE)
        throw ""Unable to import given key"";

    hr = CryptSetKeyParam(cKey, KP_IV, (BYTE *) iv, 0);
    if (hr == FALSE)
        throw ""Unable to set IV"";

    DWORD dwMode = CRYPT_MODE_CBC;
    hr = CryptSetKeyParam(cKey, KP_MODE, (BYTE*) &amp;dwMode, 0);
    if (hr == FALSE)
        throw ""Unable to set mode"";

    memcpy(output, input, inLen);

    DWORD d = (DWORD) inLen;
    hr = CryptDecrypt(cKey, NULL, TRUE, 0, output, &amp;d);
    if (hr == FALSE)
    {
        int err = GetLastError();
        throw ""Error during Decryption"";
    }

    plainSize = d;
}
</code></pre>

<p>If you have any idea, please share :)</p>

<p>Thanks in advance...</p>
","","4659","<c++><windows><cryptoapi>","3","","0","2011-11-25 08:49:01","","6","","","","","2011-11-25 08:49:01",""
"2683867","Invalid algorithm specified on Windows 2003 Server only","<p>I am decoding a file using the following method:</p>

<pre><code>string outFileName = zfoFileName.Replace("".zfo"", ""_tmp.zfo"");
FileStream inFile = null;
FileStream outFile = null;
inFile = File.Open(zfoFileName, FileMode.Open);
outFile = File.Create(outFileName);
LargeCMS.CMS cms = new LargeCMS.CMS();
cms.Decode(inFile, outFile);
</code></pre>

<p>This is working fine on my Win 7 dev machine, but on a Windows 2003 server production machine it fails with the following exception:</p>

<p>Exception: System.Exception: CryptMsgUpdate error #-2146893816 ---> System.ComponentModel.Win32Exception: Invalid algorithm specified --- End of inner exception stack trace --- at LargeCMS.CMS.Decode(FileStream inFile, FileStream outFile) </p>

<p>Here are the classes below which I call to do the decoding, if needed I can upload a sample file for decoding, its just strange it works on Win 7, and not on Win2k3 server:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace LargeCMS
{
    class CMS
    {
        // File stream to use in callback function
        private FileStream m_callbackFile;

        // Streaming callback function for encoding
        private Boolean StreamOutputCallback(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal)
        {
            // Write all bytes to encoded file
            Byte[] bytes = new Byte[cbData];
            Marshal.Copy(pbData, bytes, 0, cbData);
            m_callbackFile.Write(bytes, 0, cbData);

            if (fFinal)
            {
                // This is the last piece. Close the file
                m_callbackFile.Flush();
                m_callbackFile.Close();
                m_callbackFile = null;
            }

            return true;
        }



        // Decode CMS with streaming to support large data
        public void Decode(FileStream inFile, FileStream outFile)
        {
            // Variables
            Win32.CMSG_STREAM_INFO StreamInfo;
            Win32.CERT_CONTEXT SignerCertContext;

            BinaryReader stream = null;
            GCHandle gchandle = new GCHandle();

            IntPtr hMsg = IntPtr.Zero;
            IntPtr pSignerCertInfo = IntPtr.Zero;
            IntPtr pSignerCertContext = IntPtr.Zero;
            IntPtr pbPtr = IntPtr.Zero;
            IntPtr hStore = IntPtr.Zero;
            Byte[] pbData;
            Boolean bResult = false;
            int dwFileSize;
            int dwRemaining;
            int dwSize;
            int cbSignerCertInfo;

            try
            {
                // Get data to decode
                dwFileSize = (int)inFile.Length;
                stream = new BinaryReader(inFile);
                pbData = stream.ReadBytes(dwFileSize);

                // Prepare stream for decoded info
                m_callbackFile = outFile;

                // Populate Stream Info struct
                StreamInfo = new Win32.CMSG_STREAM_INFO();
                StreamInfo.cbContent = dwFileSize;
                StreamInfo.pfnStreamOutput = new Win32.StreamOutputCallbackDelegate(StreamOutputCallback);

                // Open message to decode
                hMsg = Win32.CryptMsgOpenToDecode(
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    0,
                    0,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    ref StreamInfo
                );
                if (hMsg.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CryptMsgOpenToDecode error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Process the whole message
                gchandle = GCHandle.Alloc(pbData, GCHandleType.Pinned);
                pbPtr = gchandle.AddrOfPinnedObject();
                dwRemaining = dwFileSize;
                dwSize = (dwFileSize &lt; 1024 * 1000 * 100) ? dwFileSize : 1024 * 1000 * 100;
                while (dwRemaining &gt; 0)
                {
                    // Update message piece by piece     
                    bResult = Win32.CryptMsgUpdate(
                        hMsg,
                        pbPtr,
                        dwSize,
                        (dwRemaining &lt;= dwSize) ? true : false
                    );
                    if (!bResult)
                    {
                        throw new Exception(""CryptMsgUpdate error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                    }

                    // Move to the next piece
                    pbPtr = new IntPtr(pbPtr.ToInt64() + dwSize);
                    dwRemaining -= dwSize;
                    if (dwRemaining &lt; dwSize)
                    {
                        dwSize = dwRemaining;
                    }
                }

                // Get signer certificate info
                cbSignerCertInfo = 0;
                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    IntPtr.Zero,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                pSignerCertInfo = Marshal.AllocHGlobal(cbSignerCertInfo);

                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    pSignerCertInfo,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Open a cert store in memory with the certs from the message
                hStore = Win32.CertOpenStore(
                    Win32.CERT_STORE_PROV_MSG,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    IntPtr.Zero,
                    0,
                    hMsg
                );
                if (hStore.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertOpenStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Find the signer's cert in the store
                pSignerCertContext = Win32.CertGetSubjectCertificateFromStore(
                    hStore,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    pSignerCertInfo
                );
                if (pSignerCertContext.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertGetSubjectCertificateFromStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Set message for verifying
                SignerCertContext = (Win32.CERT_CONTEXT)Marshal.PtrToStructure(pSignerCertContext, typeof(Win32.CERT_CONTEXT));
                bResult = Win32.CryptMsgControl(
                    hMsg,
                    0,
                    Win32.CMSG_CTRL_VERIFY_SIGNATURE,
                    SignerCertContext.pCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgControl error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }
            }
            finally
            {
                // Clean up
                if (gchandle.IsAllocated)
                {
                    gchandle.Free();
                }
                if (!pSignerCertContext.Equals(IntPtr.Zero))
                {
                    Win32.CertFreeCertificateContext(pSignerCertContext);
                }
                if (!pSignerCertInfo.Equals(IntPtr.Zero))
                {
                    Marshal.FreeHGlobal(pSignerCertInfo);
                }
                if (!hStore.Equals(IntPtr.Zero))
                {
                    Win32.CertCloseStore(hStore, Win32.CERT_CLOSE_STORE_FORCE_FLAG);
                }
                if (stream != null)
                {
                    stream.Close();
                }
                if (m_callbackFile != null)
                {
                    m_callbackFile.Close();
                }
                if (!hMsg.Equals(IntPtr.Zero))
                {
                    Win32.CryptMsgClose(hMsg);
                }
            }
        }
    }
}
</code></pre>

<p>and </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.ComponentModel;
using System.Security.Cryptography;

namespace LargeCMS
{
    class Win32
    {
        #region ""CONSTS""

        public const int X509_ASN_ENCODING = 0x00000001;
        public const int PKCS_7_ASN_ENCODING = 0x00010000;
        public const int CMSG_SIGNED = 2;
        public const int CMSG_DETACHED_FLAG = 0x00000004;
        public const int AT_KEYEXCHANGE = 1;
        public const int AT_SIGNATURE = 2;
        public const String szOID_OIWSEC_sha1 = ""1.3.14.3.2.26"";
        public const int CMSG_CTRL_VERIFY_SIGNATURE = 1;
        public const int CMSG_CERT_PARAM = 12;
        public const int CMSG_SIGNER_CERT_INFO_PARAM = 7;
        public const int CERT_STORE_PROV_MSG = 1;
        public const int CERT_CLOSE_STORE_FORCE_FLAG = 1;

        #endregion

        #region ""STRUCTS""

        [StructLayout(LayoutKind.Sequential)]
        public struct CRYPT_ALGORITHM_IDENTIFIER
        {
            public String pszObjId;
            BLOB Parameters;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_ID
        {
            public int dwIdChoice;
            public BLOB IssuerSerialNumberOrKeyIdOrHashId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNER_ENCODE_INFO
        {
            public int cbSize;
            public IntPtr pCertInfo;
            public IntPtr hCryptProvOrhNCryptKey;
            public int dwKeySpec;
            public CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
            public IntPtr pvHashAuxInfo;
            public int cAuthAttr;
            public IntPtr rgAuthAttr;
            public int cUnauthAttr;
            public IntPtr rgUnauthAttr;
            public CERT_ID SignerId;
            public CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
            public IntPtr pvHashEncryptionAuxInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_CONTEXT
        {
            public int dwCertEncodingType;
            public IntPtr pbCertEncoded;
            public int cbCertEncoded;
            public IntPtr pCertInfo;
            public IntPtr hCertStore;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BLOB
        {
            public int cbData;
            public IntPtr pbData;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNED_ENCODE_INFO
        {
            public int cbSize;
            public int cSigners;
            public IntPtr rgSigners;
            public int cCertEncoded;
            public IntPtr rgCertEncoded;
            public int cCrlEncoded;
            public IntPtr rgCrlEncoded;
            public int cAttrCertEncoded;
            public IntPtr rgAttrCertEncoded;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_STREAM_INFO
        {
            public int cbContent;
            public StreamOutputCallbackDelegate pfnStreamOutput;
            public IntPtr pvArg;
        }

        #endregion

        #region ""DELEGATES""

        public delegate Boolean StreamOutputCallbackDelegate(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal);

        #endregion

        #region ""API""

        [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern Boolean CryptAcquireContext(
          ref IntPtr hProv,
          String pszContainer,
          String pszProvider,
          int dwProvType,
          int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToEncode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            ref CMSG_SIGNED_ENCODE_INFO pvMsgEncodeInfo,
            String pszInnerContentObjID,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToDecode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            IntPtr hCryptProv,
            IntPtr pRecipientInfo,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgClose(
            IntPtr hCryptMsg
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            Byte[] pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            IntPtr pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgGetParam(
            IntPtr hCryptMsg,
            int dwParamType,
            int dwIndex,
            IntPtr pvData,
            ref int pcbData
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgControl(
            IntPtr hCryptMsg,
            int dwFlags,
            int dwCtrlType,
            IntPtr pvCtrlPara
        );

        [DllImport(""advapi32.dll"", SetLastError = true)]
        public static extern Boolean CryptReleaseContext(
            IntPtr hProv,
            int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCreateCertificateContext(
            int dwCertEncodingType,
            IntPtr pbCertEncoded,
            int cbCertEncoded
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CertFreeCertificateContext(
            IntPtr pCertContext
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertOpenStore(
            int lpszStoreProvider,
            int dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            int dwFlags,
            IntPtr pvPara
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertGetSubjectCertificateFromStore(
            IntPtr hCertStore,
            int dwCertEncodingType,
            IntPtr pCertId
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCloseStore(
            IntPtr hCertStore,
            int dwFlags
        );

        #endregion
    }
}
</code></pre>
","<p>Could it be that the CSP you use aren't installed on your Win2003? I remember reading that XP before SP3 had some problems with SHA-2 or something, and XP and Win2003 are more or less the same basic OS I think.</p>

<p>I think you can see what's installed on the following registry key<br>
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography\Defaults</p>

<p>Maybe you can compare between your machines.</p>
","4582","<c#><cryptoapi>","2","3","3","2010-04-28 07:36:19","2714625","4","1","41543","","2010-04-26 16:15:14","2010-04-21 14:35:14",""
"2683867","Invalid algorithm specified on Windows 2003 Server only","<p>I am decoding a file using the following method:</p>

<pre><code>string outFileName = zfoFileName.Replace("".zfo"", ""_tmp.zfo"");
FileStream inFile = null;
FileStream outFile = null;
inFile = File.Open(zfoFileName, FileMode.Open);
outFile = File.Create(outFileName);
LargeCMS.CMS cms = new LargeCMS.CMS();
cms.Decode(inFile, outFile);
</code></pre>

<p>This is working fine on my Win 7 dev machine, but on a Windows 2003 server production machine it fails with the following exception:</p>

<p>Exception: System.Exception: CryptMsgUpdate error #-2146893816 ---> System.ComponentModel.Win32Exception: Invalid algorithm specified --- End of inner exception stack trace --- at LargeCMS.CMS.Decode(FileStream inFile, FileStream outFile) </p>

<p>Here are the classes below which I call to do the decoding, if needed I can upload a sample file for decoding, its just strange it works on Win 7, and not on Win2k3 server:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace LargeCMS
{
    class CMS
    {
        // File stream to use in callback function
        private FileStream m_callbackFile;

        // Streaming callback function for encoding
        private Boolean StreamOutputCallback(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal)
        {
            // Write all bytes to encoded file
            Byte[] bytes = new Byte[cbData];
            Marshal.Copy(pbData, bytes, 0, cbData);
            m_callbackFile.Write(bytes, 0, cbData);

            if (fFinal)
            {
                // This is the last piece. Close the file
                m_callbackFile.Flush();
                m_callbackFile.Close();
                m_callbackFile = null;
            }

            return true;
        }



        // Decode CMS with streaming to support large data
        public void Decode(FileStream inFile, FileStream outFile)
        {
            // Variables
            Win32.CMSG_STREAM_INFO StreamInfo;
            Win32.CERT_CONTEXT SignerCertContext;

            BinaryReader stream = null;
            GCHandle gchandle = new GCHandle();

            IntPtr hMsg = IntPtr.Zero;
            IntPtr pSignerCertInfo = IntPtr.Zero;
            IntPtr pSignerCertContext = IntPtr.Zero;
            IntPtr pbPtr = IntPtr.Zero;
            IntPtr hStore = IntPtr.Zero;
            Byte[] pbData;
            Boolean bResult = false;
            int dwFileSize;
            int dwRemaining;
            int dwSize;
            int cbSignerCertInfo;

            try
            {
                // Get data to decode
                dwFileSize = (int)inFile.Length;
                stream = new BinaryReader(inFile);
                pbData = stream.ReadBytes(dwFileSize);

                // Prepare stream for decoded info
                m_callbackFile = outFile;

                // Populate Stream Info struct
                StreamInfo = new Win32.CMSG_STREAM_INFO();
                StreamInfo.cbContent = dwFileSize;
                StreamInfo.pfnStreamOutput = new Win32.StreamOutputCallbackDelegate(StreamOutputCallback);

                // Open message to decode
                hMsg = Win32.CryptMsgOpenToDecode(
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    0,
                    0,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    ref StreamInfo
                );
                if (hMsg.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CryptMsgOpenToDecode error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Process the whole message
                gchandle = GCHandle.Alloc(pbData, GCHandleType.Pinned);
                pbPtr = gchandle.AddrOfPinnedObject();
                dwRemaining = dwFileSize;
                dwSize = (dwFileSize &lt; 1024 * 1000 * 100) ? dwFileSize : 1024 * 1000 * 100;
                while (dwRemaining &gt; 0)
                {
                    // Update message piece by piece     
                    bResult = Win32.CryptMsgUpdate(
                        hMsg,
                        pbPtr,
                        dwSize,
                        (dwRemaining &lt;= dwSize) ? true : false
                    );
                    if (!bResult)
                    {
                        throw new Exception(""CryptMsgUpdate error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                    }

                    // Move to the next piece
                    pbPtr = new IntPtr(pbPtr.ToInt64() + dwSize);
                    dwRemaining -= dwSize;
                    if (dwRemaining &lt; dwSize)
                    {
                        dwSize = dwRemaining;
                    }
                }

                // Get signer certificate info
                cbSignerCertInfo = 0;
                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    IntPtr.Zero,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                pSignerCertInfo = Marshal.AllocHGlobal(cbSignerCertInfo);

                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    pSignerCertInfo,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Open a cert store in memory with the certs from the message
                hStore = Win32.CertOpenStore(
                    Win32.CERT_STORE_PROV_MSG,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    IntPtr.Zero,
                    0,
                    hMsg
                );
                if (hStore.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertOpenStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Find the signer's cert in the store
                pSignerCertContext = Win32.CertGetSubjectCertificateFromStore(
                    hStore,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    pSignerCertInfo
                );
                if (pSignerCertContext.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertGetSubjectCertificateFromStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Set message for verifying
                SignerCertContext = (Win32.CERT_CONTEXT)Marshal.PtrToStructure(pSignerCertContext, typeof(Win32.CERT_CONTEXT));
                bResult = Win32.CryptMsgControl(
                    hMsg,
                    0,
                    Win32.CMSG_CTRL_VERIFY_SIGNATURE,
                    SignerCertContext.pCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgControl error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }
            }
            finally
            {
                // Clean up
                if (gchandle.IsAllocated)
                {
                    gchandle.Free();
                }
                if (!pSignerCertContext.Equals(IntPtr.Zero))
                {
                    Win32.CertFreeCertificateContext(pSignerCertContext);
                }
                if (!pSignerCertInfo.Equals(IntPtr.Zero))
                {
                    Marshal.FreeHGlobal(pSignerCertInfo);
                }
                if (!hStore.Equals(IntPtr.Zero))
                {
                    Win32.CertCloseStore(hStore, Win32.CERT_CLOSE_STORE_FORCE_FLAG);
                }
                if (stream != null)
                {
                    stream.Close();
                }
                if (m_callbackFile != null)
                {
                    m_callbackFile.Close();
                }
                if (!hMsg.Equals(IntPtr.Zero))
                {
                    Win32.CryptMsgClose(hMsg);
                }
            }
        }
    }
}
</code></pre>

<p>and </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.ComponentModel;
using System.Security.Cryptography;

namespace LargeCMS
{
    class Win32
    {
        #region ""CONSTS""

        public const int X509_ASN_ENCODING = 0x00000001;
        public const int PKCS_7_ASN_ENCODING = 0x00010000;
        public const int CMSG_SIGNED = 2;
        public const int CMSG_DETACHED_FLAG = 0x00000004;
        public const int AT_KEYEXCHANGE = 1;
        public const int AT_SIGNATURE = 2;
        public const String szOID_OIWSEC_sha1 = ""1.3.14.3.2.26"";
        public const int CMSG_CTRL_VERIFY_SIGNATURE = 1;
        public const int CMSG_CERT_PARAM = 12;
        public const int CMSG_SIGNER_CERT_INFO_PARAM = 7;
        public const int CERT_STORE_PROV_MSG = 1;
        public const int CERT_CLOSE_STORE_FORCE_FLAG = 1;

        #endregion

        #region ""STRUCTS""

        [StructLayout(LayoutKind.Sequential)]
        public struct CRYPT_ALGORITHM_IDENTIFIER
        {
            public String pszObjId;
            BLOB Parameters;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_ID
        {
            public int dwIdChoice;
            public BLOB IssuerSerialNumberOrKeyIdOrHashId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNER_ENCODE_INFO
        {
            public int cbSize;
            public IntPtr pCertInfo;
            public IntPtr hCryptProvOrhNCryptKey;
            public int dwKeySpec;
            public CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
            public IntPtr pvHashAuxInfo;
            public int cAuthAttr;
            public IntPtr rgAuthAttr;
            public int cUnauthAttr;
            public IntPtr rgUnauthAttr;
            public CERT_ID SignerId;
            public CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
            public IntPtr pvHashEncryptionAuxInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_CONTEXT
        {
            public int dwCertEncodingType;
            public IntPtr pbCertEncoded;
            public int cbCertEncoded;
            public IntPtr pCertInfo;
            public IntPtr hCertStore;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BLOB
        {
            public int cbData;
            public IntPtr pbData;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNED_ENCODE_INFO
        {
            public int cbSize;
            public int cSigners;
            public IntPtr rgSigners;
            public int cCertEncoded;
            public IntPtr rgCertEncoded;
            public int cCrlEncoded;
            public IntPtr rgCrlEncoded;
            public int cAttrCertEncoded;
            public IntPtr rgAttrCertEncoded;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_STREAM_INFO
        {
            public int cbContent;
            public StreamOutputCallbackDelegate pfnStreamOutput;
            public IntPtr pvArg;
        }

        #endregion

        #region ""DELEGATES""

        public delegate Boolean StreamOutputCallbackDelegate(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal);

        #endregion

        #region ""API""

        [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern Boolean CryptAcquireContext(
          ref IntPtr hProv,
          String pszContainer,
          String pszProvider,
          int dwProvType,
          int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToEncode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            ref CMSG_SIGNED_ENCODE_INFO pvMsgEncodeInfo,
            String pszInnerContentObjID,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToDecode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            IntPtr hCryptProv,
            IntPtr pRecipientInfo,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgClose(
            IntPtr hCryptMsg
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            Byte[] pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            IntPtr pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgGetParam(
            IntPtr hCryptMsg,
            int dwParamType,
            int dwIndex,
            IntPtr pvData,
            ref int pcbData
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgControl(
            IntPtr hCryptMsg,
            int dwFlags,
            int dwCtrlType,
            IntPtr pvCtrlPara
        );

        [DllImport(""advapi32.dll"", SetLastError = true)]
        public static extern Boolean CryptReleaseContext(
            IntPtr hProv,
            int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCreateCertificateContext(
            int dwCertEncodingType,
            IntPtr pbCertEncoded,
            int cbCertEncoded
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CertFreeCertificateContext(
            IntPtr pCertContext
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertOpenStore(
            int lpszStoreProvider,
            int dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            int dwFlags,
            IntPtr pvPara
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertGetSubjectCertificateFromStore(
            IntPtr hCertStore,
            int dwCertEncodingType,
            IntPtr pCertId
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCloseStore(
            IntPtr hCertStore,
            int dwFlags
        );

        #endregion
    }
}
</code></pre>
","<p>Can you give more information about your environment. First of all: which Service Pack has Windows 2003 Server. There is for example a bug ""Default Diffie-Hellman SChannel Certificate Selection on Web Enrollment Page Causes Error: 0x80090008 - NTE_BAD_ALGID"" which are fixed in SP3 <a href=""http://support.microsoft.com/kb/324953/en"" rel=""nofollow noreferrer"">http://support.microsoft.com/kb/324953/en</a>. If it is not your problem, you should place the certificate and a binary file with the test message somewhere on web and post URL here. Then one will be able to reproduce and test the problem.</p>

<p>I suppose, to fix your problem (if the last Service Pack is installed on the Windows Server 2003) one will be have to change some properties of the certificate with which the message are signed.</p>

<p>I don't think, by the way that you certificate use SHA-2 algorithms (SHA-256, SHA-384 and SHA-512). If you do use this one and have the last Service pack installed, then it can be needed to use explicitly ""Microsoft Enhanced RSA and AES Cryptographic Provider""  (or ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"" as it's called on Windows XP SP3) or PROV_RSA_AES or MS_ENH_RSA_AES_PROV instead of default PROV_RSA_FULL provider. (see, for example, <a href=""http://blogs.msdn.com/alejacma/archive/2009/01/23/sha-2-support-on-windows-xp.aspx"" rel=""nofollow noreferrer"">http://blogs.msdn.com/alejacma/archive/2009/01/23/sha-2-support-on-windows-xp.aspx</a>)</p>

<p><strong>Updated 1:</strong>
After receiving your test file the problem is more clear. First of all a good news. <strong>Your program works correct!</strong> It works without any problem on my test Windows 2003 server with SP2. <strong>So we have administrative problem and not a software development.</strong> I recommend you to test the program on another Windows 2003 Server. On this server you can reinstall SP2 and then go to Microsoft Updates and install all updates.</p>

<p>By the way you have no problems with SHA256 or other SHA-2 algorithms. You use in your example a standard 1.2.840.113549.1.1.5 sha1RSA algorithm.</p>

<p>Now about your program. I read detailed your code and understand exactly what you do. You receive an PKCS#7 signed message which contain a text tile (an XML file) inside. How I understand your example come from <a href=""http://blogs.msdn.com/alejacma/archive/2010/04/09/how-to-call-cryptmsg-api-in-streaming-mode-c.aspx"" rel=""nofollow noreferrer"">http://blogs.msdn.com/alejacma/archive/2010/04/09/how-to-call-cryptmsg-api-in-streaming-mode-c.aspx</a> which describes problem with decrypting of files larger as 100MB (see also <a href=""http://blogs.msdn.com/alejacma/archive/2010/03/17/asn1-value-too-large-error-when-calling-signedcms-computesignature.aspx"" rel=""nofollow noreferrer"">http://blogs.msdn.com/alejacma/archive/2010/03/17/asn1-value-too-large-error-when-calling-signedcms-computesignature.aspx</a>). If you not have this case, I recommend you to use .NET cryptographic functions from System.Security.Cryptography.Pkcs namespace. If you do have large data, you current code is OK. The only something suspected place is reading of input file. I don't read <strong>stream.ReadBytes()</strong> call. I would be use better memory mapped files instead of loading a huge file in memory. To do this in native code you can use code like following</p>

<pre><code>DWORD MapFileInMemory (IN LPCWSTR pszFileName,
                       OUT PBYTE *ppbyFile, OUT PDWORD pdwFileSizeLow, OUT PDWORD pdwFileSizeHigh)
{
    HANDLE hFile = INVALID_HANDLE_VALUE, hFileMapping = NULL;
    DWORD  dwStatus = (DWORD)E_UNEXPECTED;

    __try {
        // Open the input file to be encrypted or decrypted
        hFile = CreateFileW (pszFileName, FILE_READ_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            dwStatus = GetLastError();
            __leave;
        }

        *pdwFileSizeLow = GetFileSize (hFile, pdwFileSizeHigh);
        if (*pdwFileSizeLow == INVALID_FILE_SIZE){
            dwStatus = GetLastError();
            __leave;
        }

        hFileMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (!hFileMapping){
            dwStatus = GetLastError();
            __leave;
        }

        *ppbyFile = (PBYTE) MapViewOfFile (hFileMapping, FILE_MAP_READ, 0, 0, 0);
        if (*ppbyFile == NULL) {
            dwStatus = GetLastError();
            __leave;
        }

        dwStatus = NO_ERROR;
    }
    __finally {
        if (hFileMapping)
            CloseHandle (hFileMapping);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle (hFile);
    }

    return dwStatus;
}

BOOL UnmapFileFromMemory (LPCVOID lpBaseAddress)
{
    return UnmapViewOfFile (lpBaseAddress);
}
</code></pre>

<p>Writing of the corresponding .NET code would be not a problem. Using Memory Mapped Files create only a virtual address mapping to the file, data will be read only if you access to the corresponding part of data.</p>

<p>One more remark. The part of you code, where you verify the message is not full. What you have to do is the verifying of the certificate with which the message signed. If you use native <em>CryptoAPI</em>, you can do this with respect of <code>CertGetCertificateChain()</code>. Only then you will be sure, that the certificate and all it's parent are valid. You should also verify with respect of <code>CertVerifyCertificateChainPolicy()</code> that the certificate chain allow usage of the certificate for signing of messages.</p>

<p>Current code by the way works without error messages, but the Issuer of the certificate with which the message are signed is ""CN=PostSignum Qualified CA, O=""Ceská pošta, s.p. [IC 47114983]"", C=CZ"" and inside your message the certificated is not exist. You can use for example <code>certutil.exe -dump 31602.zfo</code> to see details:</p>

<pre><code>Missing Issuer: CN=PostSignum Qualified CA, O=""Ceská pošta, s.p. [IC 47114983]"", C=CZ
  Issuer: CN=PostSignum Qualified CA, O=""Ceská pošta, s.p. [IC 47114983]"", C=CZ
  NotBefore: 03.12.2009 11:23
  NotAfter: 03.12.2010 10:33
  Subject: SERIALNUMBER=S7464, CN=Informacní systém datových schránek - zkušební prostredí, O=""Ceská pošta, s.p. [IC 47114983]"", C=CZ
  Serial: 04d3c5
  SubjectAltName: RFC822 Name=postsignum@cpost.cz, Other Name:Description=13 00
  59 c7 20 ba 70 b1 e6 93 ea c4 83 4b 3c 1e 35 dc b9 15 f5 ff
A certificate chain could not be built to a trusted root authority. 0x800b010a (-2146762486)
</code></pre>

<p>Probably you don't want interpret any signed message as valid. Verification of the certificate is mandatory. Moreover in a lot of scenarios it would be good to define the range of origins from which Issuer you want to allow a signed messages as an input. Think about this.</p>

<p><strong>Updated 2:</strong> You are right in new 331879.zfo file you really use sha256RSA (1.2.840.113549.1.1.11) for signature. Try to install <a href=""http://support.microsoft.com/kb/968730/en"" rel=""nofollow noreferrer"">http://support.microsoft.com/kb/968730/en</a> which I fond on<br>
<a href=""http://thehotfixshare.net/board/index.php?showtopic=12629&amp;hl=968730"" rel=""nofollow noreferrer"">http://thehotfixshare.net/board/index.php?showtopic=12629&amp;hl=968730</a>.
It is a digitally signed file. So I it must be safe. To be absolutely sure you can receive this fix from Microsoft. I hope this fix will solve you problem.</p>

<p><strong>Updated 3</strong>: I thought a little more about your code example. It seems to me, that to receive the best implementation you should implement the whole code of the message decoding as unmanaged (native) code. So you will not spend any additional time for marshaling between native and managed code during decoding of large data. This native code you should place inside a DLL and export a function which you can use inside you main managed code.</p>

<p>One more remark about using memory mapped filed. Usage of memory mapped filed <strong>is mostly optimized way access any file</strong> in Windows for both reading and writing. One thing which you must to know is memory usage. If you look at Task Manager for used memory you can see that a program used memory mapped file technique can use very large memory. It is not a problem at all. <strong>This memory is not a physical memory and not a paged memory from the paging file</strong>. A virtual addressed will be mapped directly to the file which you mapped in memory. So paging of data will be done with respect of the file data itself. No additional parts of the paging file of operation system are needed. This I/O from the file is much optimized and implemented with respect of corresponding embedded processor features.</p>

<p><strong>End solution</strong>: Because I could not stop thinking about this problem I had to solve it. Here is the solution which full based on what I already written before.</p>

<ul>
<li>You install the patch KB968730 (see <a href=""http://support.microsoft.com/kb/968730/en"" rel=""nofollow noreferrer"">http://support.microsoft.com/kb/968730/en</a>) on the Windows Server with Service Pack 2. The patch can be downloaded from <a href=""http://thehotfixshare.net/board/index.php?showtopic=12629&amp;hl=968730"" rel=""nofollow noreferrer"">http://thehotfixshare.net/board/index.php?showtopic=12629&amp;hl=968730</a>.</li>
<li>Add following lines in the class Win32:</li>
</ul>

<pre><code>public const int PROV_RSA_AES = 24;
public const String MS_ENH_RSA_AES_PROV =
    ""Microsoft Enhanced RSA and AES Cryptographic Provider"";
public const String MS_ENH_RSA_AES_PROV_XP =
    ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)"";
public const int CRYPT_VERIFYCONTEXT = unchecked((int)0xF0000000U);</code></pre>

<pre><code>[StructLayout (LayoutKind.Sequential)]
    public struct OSVERSIONINFOEX {
        public int dwOSVersionInfoSize;
        public int dwMajorVersion;
        public int dwMinorVersion;
        public int dwBuildNumber;
        public int dwPlatformId;
        [MarshalAs (UnmanagedType.ByValTStr, SizeConst = 128)]
        public string szCSDVersion;
        public short wServicePackMajor;
        public short wServicePackMinor;
        public short wSuiteMask;
        public byte wProductType;
        public byte wReserved;
    }</code></pre>

<pre><code>[DllImport (""kernel32.dll"")]
public static extern bool GetVersionEx (ref OSVERSIONINFOEX osVersionInfo);</code></pre>

<ul>
<li>Modify <code>public void Decode(FileStream inFile, FileStream outFile)</code> to use explicitly RSA and AES Cryptographic Provider on Windows Server 2003 or XP</li>
</ul>

<pre><code>// insert next line before of try block like after this line
IntPtr hStore = IntPtr.Zero;
IntPtr hProv = IntPtr.Zero;

//...
// insert Windows versions test before CryptMsgOpenToDecode like after this line
StreamInfo.pfnStreamOutput = new Win32.StreamOutputCallbackDelegate(StreamOutputCallback);

Win32.OSVERSIONINFOEX osVersionInfo = new Win32.OSVERSIONINFOEX ();
osVersionInfo.dwOSVersionInfoSize = Marshal.SizeOf (typeof (Win32.OSVERSIONINFOEX));
if (Win32.GetVersionEx (ref osVersionInfo)) {
    Console.WriteLine (""dwMajorVersion={0}, dwMinorVersion={1}, wProductType={2}"",
        osVersionInfo.dwMajorVersion, osVersionInfo.dwMinorVersion, osVersionInfo.wProductType);
    if (osVersionInfo.dwMajorVersion == 5 &&
        (osVersionInfo.dwMinorVersion == 2 || osVersionInfo.dwMinorVersion == 1)) {
        // Windows 2003 or XP
        string provider = Win32.MS_ENH_RSA_AES_PROV;
        if (osVersionInfo.dwMajorVersion == 5 && osVersionInfo.dwMinorVersion == 1)
            provider = Win32.MS_ENH_RSA_AES_PROV_XP;
        Win32.CryptAcquireContext (ref hProv, null, provider,
            Win32.PROV_RSA_AES, Win32.CRYPT_VERIFYCONTEXT);
    }
}

// Open message to decode
hMsg = Win32.CryptMsgOpenToDecode(
    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
    0,
    0,
    hProv,
    IntPtr.Zero,
    ref StreamInfo
);</code></pre>

<ul>
<li>after decoding close handle with respect of CryptReleaseContext function
<code><pre>//...
// insert CryptReleaseContext somewhere inside of finally block like after this line
if (!hMsg.Equals(IntPtr.Zero))
{
Win32.CryptMsgClose(hMsg);
}
if (hProv != IntPtr.Zero)
Win32.CryptReleaseContext (hProv, 0);</code></pre></li>
</ul>

<p>Now the program works with data signed with SHA-2 algorithms (like 331879.zfo signed with 1.2.840.113549.1.1.11 sha256RSA)</p>

<p>I recommend you don't forget about memory mapped files. If you use .NET 4.0 you can use new .NET framework classes (see <a href=""http://msdn.microsoft.com/en-us/library/dd997372%28v=VS.100%29.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/dd997372%28v=VS.100%29.aspx</a>).</p>
","4582","<c#><cryptoapi>","2","3","3","2010-04-28 07:36:19","2714625","4","1","41543","","2010-04-26 16:15:14","2010-04-21 14:35:14",""
"2683867","Invalid algorithm specified on Windows 2003 Server only","<p>I am decoding a file using the following method:</p>

<pre><code>string outFileName = zfoFileName.Replace("".zfo"", ""_tmp.zfo"");
FileStream inFile = null;
FileStream outFile = null;
inFile = File.Open(zfoFileName, FileMode.Open);
outFile = File.Create(outFileName);
LargeCMS.CMS cms = new LargeCMS.CMS();
cms.Decode(inFile, outFile);
</code></pre>

<p>This is working fine on my Win 7 dev machine, but on a Windows 2003 server production machine it fails with the following exception:</p>

<p>Exception: System.Exception: CryptMsgUpdate error #-2146893816 ---> System.ComponentModel.Win32Exception: Invalid algorithm specified --- End of inner exception stack trace --- at LargeCMS.CMS.Decode(FileStream inFile, FileStream outFile) </p>

<p>Here are the classes below which I call to do the decoding, if needed I can upload a sample file for decoding, its just strange it works on Win 7, and not on Win2k3 server:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Runtime.InteropServices;
using System.ComponentModel;

namespace LargeCMS
{
    class CMS
    {
        // File stream to use in callback function
        private FileStream m_callbackFile;

        // Streaming callback function for encoding
        private Boolean StreamOutputCallback(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal)
        {
            // Write all bytes to encoded file
            Byte[] bytes = new Byte[cbData];
            Marshal.Copy(pbData, bytes, 0, cbData);
            m_callbackFile.Write(bytes, 0, cbData);

            if (fFinal)
            {
                // This is the last piece. Close the file
                m_callbackFile.Flush();
                m_callbackFile.Close();
                m_callbackFile = null;
            }

            return true;
        }



        // Decode CMS with streaming to support large data
        public void Decode(FileStream inFile, FileStream outFile)
        {
            // Variables
            Win32.CMSG_STREAM_INFO StreamInfo;
            Win32.CERT_CONTEXT SignerCertContext;

            BinaryReader stream = null;
            GCHandle gchandle = new GCHandle();

            IntPtr hMsg = IntPtr.Zero;
            IntPtr pSignerCertInfo = IntPtr.Zero;
            IntPtr pSignerCertContext = IntPtr.Zero;
            IntPtr pbPtr = IntPtr.Zero;
            IntPtr hStore = IntPtr.Zero;
            Byte[] pbData;
            Boolean bResult = false;
            int dwFileSize;
            int dwRemaining;
            int dwSize;
            int cbSignerCertInfo;

            try
            {
                // Get data to decode
                dwFileSize = (int)inFile.Length;
                stream = new BinaryReader(inFile);
                pbData = stream.ReadBytes(dwFileSize);

                // Prepare stream for decoded info
                m_callbackFile = outFile;

                // Populate Stream Info struct
                StreamInfo = new Win32.CMSG_STREAM_INFO();
                StreamInfo.cbContent = dwFileSize;
                StreamInfo.pfnStreamOutput = new Win32.StreamOutputCallbackDelegate(StreamOutputCallback);

                // Open message to decode
                hMsg = Win32.CryptMsgOpenToDecode(
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    0,
                    0,
                    IntPtr.Zero,
                    IntPtr.Zero,
                    ref StreamInfo
                );
                if (hMsg.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CryptMsgOpenToDecode error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Process the whole message
                gchandle = GCHandle.Alloc(pbData, GCHandleType.Pinned);
                pbPtr = gchandle.AddrOfPinnedObject();
                dwRemaining = dwFileSize;
                dwSize = (dwFileSize &lt; 1024 * 1000 * 100) ? dwFileSize : 1024 * 1000 * 100;
                while (dwRemaining &gt; 0)
                {
                    // Update message piece by piece     
                    bResult = Win32.CryptMsgUpdate(
                        hMsg,
                        pbPtr,
                        dwSize,
                        (dwRemaining &lt;= dwSize) ? true : false
                    );
                    if (!bResult)
                    {
                        throw new Exception(""CryptMsgUpdate error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                    }

                    // Move to the next piece
                    pbPtr = new IntPtr(pbPtr.ToInt64() + dwSize);
                    dwRemaining -= dwSize;
                    if (dwRemaining &lt; dwSize)
                    {
                        dwSize = dwRemaining;
                    }
                }

                // Get signer certificate info
                cbSignerCertInfo = 0;
                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    IntPtr.Zero,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                pSignerCertInfo = Marshal.AllocHGlobal(cbSignerCertInfo);

                bResult = Win32.CryptMsgGetParam(
                    hMsg,
                    Win32.CMSG_SIGNER_CERT_INFO_PARAM,
                    0,
                    pSignerCertInfo,
                    ref cbSignerCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgGetParam error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Open a cert store in memory with the certs from the message
                hStore = Win32.CertOpenStore(
                    Win32.CERT_STORE_PROV_MSG,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    IntPtr.Zero,
                    0,
                    hMsg
                );
                if (hStore.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertOpenStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Find the signer's cert in the store
                pSignerCertContext = Win32.CertGetSubjectCertificateFromStore(
                    hStore,
                    Win32.X509_ASN_ENCODING | Win32.PKCS_7_ASN_ENCODING,
                    pSignerCertInfo
                );
                if (pSignerCertContext.Equals(IntPtr.Zero))
                {
                    throw new Exception(""CertGetSubjectCertificateFromStore error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }

                // Set message for verifying
                SignerCertContext = (Win32.CERT_CONTEXT)Marshal.PtrToStructure(pSignerCertContext, typeof(Win32.CERT_CONTEXT));
                bResult = Win32.CryptMsgControl(
                    hMsg,
                    0,
                    Win32.CMSG_CTRL_VERIFY_SIGNATURE,
                    SignerCertContext.pCertInfo
                );
                if (!bResult)
                {
                    throw new Exception(""CryptMsgControl error #"" + Marshal.GetLastWin32Error().ToString(), new Win32Exception(Marshal.GetLastWin32Error()));
                }
            }
            finally
            {
                // Clean up
                if (gchandle.IsAllocated)
                {
                    gchandle.Free();
                }
                if (!pSignerCertContext.Equals(IntPtr.Zero))
                {
                    Win32.CertFreeCertificateContext(pSignerCertContext);
                }
                if (!pSignerCertInfo.Equals(IntPtr.Zero))
                {
                    Marshal.FreeHGlobal(pSignerCertInfo);
                }
                if (!hStore.Equals(IntPtr.Zero))
                {
                    Win32.CertCloseStore(hStore, Win32.CERT_CLOSE_STORE_FORCE_FLAG);
                }
                if (stream != null)
                {
                    stream.Close();
                }
                if (m_callbackFile != null)
                {
                    m_callbackFile.Close();
                }
                if (!hMsg.Equals(IntPtr.Zero))
                {
                    Win32.CryptMsgClose(hMsg);
                }
            }
        }
    }
}
</code></pre>

<p>and </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.ComponentModel;
using System.Security.Cryptography;

namespace LargeCMS
{
    class Win32
    {
        #region ""CONSTS""

        public const int X509_ASN_ENCODING = 0x00000001;
        public const int PKCS_7_ASN_ENCODING = 0x00010000;
        public const int CMSG_SIGNED = 2;
        public const int CMSG_DETACHED_FLAG = 0x00000004;
        public const int AT_KEYEXCHANGE = 1;
        public const int AT_SIGNATURE = 2;
        public const String szOID_OIWSEC_sha1 = ""1.3.14.3.2.26"";
        public const int CMSG_CTRL_VERIFY_SIGNATURE = 1;
        public const int CMSG_CERT_PARAM = 12;
        public const int CMSG_SIGNER_CERT_INFO_PARAM = 7;
        public const int CERT_STORE_PROV_MSG = 1;
        public const int CERT_CLOSE_STORE_FORCE_FLAG = 1;

        #endregion

        #region ""STRUCTS""

        [StructLayout(LayoutKind.Sequential)]
        public struct CRYPT_ALGORITHM_IDENTIFIER
        {
            public String pszObjId;
            BLOB Parameters;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_ID
        {
            public int dwIdChoice;
            public BLOB IssuerSerialNumberOrKeyIdOrHashId;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNER_ENCODE_INFO
        {
            public int cbSize;
            public IntPtr pCertInfo;
            public IntPtr hCryptProvOrhNCryptKey;
            public int dwKeySpec;
            public CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
            public IntPtr pvHashAuxInfo;
            public int cAuthAttr;
            public IntPtr rgAuthAttr;
            public int cUnauthAttr;
            public IntPtr rgUnauthAttr;
            public CERT_ID SignerId;
            public CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
            public IntPtr pvHashEncryptionAuxInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CERT_CONTEXT
        {
            public int dwCertEncodingType;
            public IntPtr pbCertEncoded;
            public int cbCertEncoded;
            public IntPtr pCertInfo;
            public IntPtr hCertStore;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct BLOB
        {
            public int cbData;
            public IntPtr pbData;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_SIGNED_ENCODE_INFO
        {
            public int cbSize;
            public int cSigners;
            public IntPtr rgSigners;
            public int cCertEncoded;
            public IntPtr rgCertEncoded;
            public int cCrlEncoded;
            public IntPtr rgCrlEncoded;
            public int cAttrCertEncoded;
            public IntPtr rgAttrCertEncoded;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CMSG_STREAM_INFO
        {
            public int cbContent;
            public StreamOutputCallbackDelegate pfnStreamOutput;
            public IntPtr pvArg;
        }

        #endregion

        #region ""DELEGATES""

        public delegate Boolean StreamOutputCallbackDelegate(IntPtr pvArg, IntPtr pbData, int cbData, Boolean fFinal);

        #endregion

        #region ""API""

        [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
        public static extern Boolean CryptAcquireContext(
          ref IntPtr hProv,
          String pszContainer,
          String pszProvider,
          int dwProvType,
          int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToEncode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            ref CMSG_SIGNED_ENCODE_INFO pvMsgEncodeInfo,
            String pszInnerContentObjID,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CryptMsgOpenToDecode(
            int dwMsgEncodingType,
            int dwFlags,
            int dwMsgType,
            IntPtr hCryptProv,
            IntPtr pRecipientInfo,
            ref CMSG_STREAM_INFO pStreamInfo
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgClose(
            IntPtr hCryptMsg
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            Byte[] pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgUpdate(
            IntPtr hCryptMsg,
            IntPtr pbData,
            int cbData,
            Boolean fFinal
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgGetParam(
            IntPtr hCryptMsg,
            int dwParamType,
            int dwIndex,
            IntPtr pvData,
            ref int pcbData
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CryptMsgControl(
            IntPtr hCryptMsg,
            int dwFlags,
            int dwCtrlType,
            IntPtr pvCtrlPara
        );

        [DllImport(""advapi32.dll"", SetLastError = true)]
        public static extern Boolean CryptReleaseContext(
            IntPtr hProv,
            int dwFlags
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCreateCertificateContext(
            int dwCertEncodingType,
            IntPtr pbCertEncoded,
            int cbCertEncoded
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern Boolean CertFreeCertificateContext(
            IntPtr pCertContext
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertOpenStore(
            int lpszStoreProvider,
            int dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            int dwFlags,
            IntPtr pvPara
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertGetSubjectCertificateFromStore(
            IntPtr hCertStore,
            int dwCertEncodingType,
            IntPtr pCertId
        );

        [DllImport(""Crypt32.dll"", SetLastError = true)]
        public static extern IntPtr CertCloseStore(
            IntPtr hCertStore,
            int dwFlags
        );

        #endregion
    }
}
</code></pre>
","<p>MD5 and other legacy/broken cryptographic algorithms can be disabled by group policy (needed for US Government use).</p>
","4582","<c#><cryptoapi>","2","1","3","2010-04-28 07:36:19","2714625","4","1","41543","","2010-04-26 16:15:14","2010-04-21 14:35:14",""
"25722592","Sign and decrypt data using private keys located on a HSM","<p>I have a task to sign and decrypt data, but the private keys are located at a HSM ( Luna SA, / Safenet ). I installed all the client software and connected the Luna SA CSP to the test servers.</p>

<p>Using the PKCS#11 functions provided, I am able to list and export the public keys on the HSM as <code>PCCERT_CONTEXT</code> (<code>CertCreateCertificateContext</code>). When I try to acquire the private key (using CryptoAPI function <code>CryptAcquireCertificatePrivateKey</code>), I receive an error code <code>CRYPT_E_NO_KEY_PROPERTY</code>.</p>

<p>I am probably missing the link between the certificate data and the CSP/HSM. Has anybody done something similar and can give any hints?</p>

<h3>EDIT</h3>

<hr>

<p>I sucessfully created CER files from all the keys located on the HSM.
When i know use <code>signtool.exe</code> (<a href=""http://msdn.microsoft.com/en-us/library/8s9b9yaz(v=vs.110).aspx"" rel=""nofollow noreferrer"">the one that ships with Microsoft Plattform SDK</a>) i am able to sign a dll with a key on the HSM (the tool wizard lets me choose key container, key spec, ...). I tried to use the information the tool shows me and set the private key</p>

<pre><code>bool LinkPrivateKey(PCCERT_CONTEXT cert)
{
    CRYPT_KEY_PROV_INFO cryptKeyProvInfo;
    memset(&amp;cryptKeyProvInfo, 0, sizeof(cryptKeyProvInfo));
    cryptKeyProvInfo.pwszContainerName = L""MSS"";
    cryptKeyProvInfo.pwszProvName = L""Luna Cryptographic Services for Microsoft Windows"";
    cryptKeyProvInfo.dwProvType = PROV_RSA_FULL;
    cryptKeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET; // CERT_SET_KEY_CONTEXT_PROP_ID | CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    cryptKeyProvInfo.cProvParam = 0;
    cryptKeyProvInfo.dwKeySpec = AT_SIGNATURE;

    return CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;cryptKeyProvInfo) != FALSE;
}
</code></pre>

<p>but CryptAcquirePrivateKey still gives me the same error. I believe I am missing only a small bit here, since the signtool is able to access the private key </p>

<p><img src=""https://i.stack.imgur.com/0EdaB.png"" alt=""enter image description here""></p>

<h3>Edit2</h3>

<hr>

<p>The screnshot shows KEYEXCHANGE but I chose SIGNATURE</p>

<h3>Edit3</h3>

<hr>

<p>I changed the <code>LinkPrivateKey</code>function a little bit, now it works</p>

<pre><code>bool LinkPrivateKey(PCCERT_CONTEXT cert)
{
    CRYPT_KEY_PROV_INFO cryptKeyProvInfo;
    memset(&amp;cryptKeyProvInfo, 0, sizeof(cryptKeyProvInfo));
    cryptKeyProvInfo.pwszContainerName = L""MSS"";
    cryptKeyProvInfo.pwszProvName = L""Luna Cryptographic Services for Microsoft Windows"";
    cryptKeyProvInfo.dwProvType = PROV_RSA_FULL;
    cryptKeyProvInfo.dwFlags = 1; // CERT_SET_KEY_CONTEXT_PROP_ID | CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    cryptKeyProvInfo.dwKeySpec = AT_SIGNATURE;

    return CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;cryptKeyProvInfo) != FALSE;
}
</code></pre>
","<p>I don't have any experience with Luna but this worked well for nCiper HSM:</p>

<pre><code>certutil -repairstore -csp ""nCipher Enhanced Cryptographic Provider"" My &lt;serial number of certificate&gt;
</code></pre>

<p>where ""nCipher Enhanced Cryptographic Provider"" is the name of CSP that comes with HSM.</p>

<p>Serial number of certificate can be obtained using this command:</p>

<pre><code>certutil -store My
</code></pre>

<p>It will print all certificates in Local_Machine\My store. The serial number will be between bunch of ====== like <code>================ Certificate 5 ================</code>. It will also parse information about the certificates like serial number, subject etc. and it will run encrypt/decrypt test to verify usability of the certificate.</p>

<p>After you repair the binding you can use this (second) command to verify that it went well. Don't be fooled by output of the first command, I have never seen it put out anything other than success.</p>

<p>You can find more information about usage of certutil <a href=""http://technet.microsoft.com/en-us/library/cc732443.aspx#BKMK_repairstore"" rel=""nofollow"">here</a>.</p>
","4350","<encryption><digital-signature><cryptoapi><rsacryptoserviceprovider><hsm>","2","1","2","2014-09-08 15:43:20","25728044","4","4","282144","","2014-09-08 15:38:39","2014-09-08 10:50:50",""
"25722592","Sign and decrypt data using private keys located on a HSM","<p>I have a task to sign and decrypt data, but the private keys are located at a HSM ( Luna SA, / Safenet ). I installed all the client software and connected the Luna SA CSP to the test servers.</p>

<p>Using the PKCS#11 functions provided, I am able to list and export the public keys on the HSM as <code>PCCERT_CONTEXT</code> (<code>CertCreateCertificateContext</code>). When I try to acquire the private key (using CryptoAPI function <code>CryptAcquireCertificatePrivateKey</code>), I receive an error code <code>CRYPT_E_NO_KEY_PROPERTY</code>.</p>

<p>I am probably missing the link between the certificate data and the CSP/HSM. Has anybody done something similar and can give any hints?</p>

<h3>EDIT</h3>

<hr>

<p>I sucessfully created CER files from all the keys located on the HSM.
When i know use <code>signtool.exe</code> (<a href=""http://msdn.microsoft.com/en-us/library/8s9b9yaz(v=vs.110).aspx"" rel=""nofollow noreferrer"">the one that ships with Microsoft Plattform SDK</a>) i am able to sign a dll with a key on the HSM (the tool wizard lets me choose key container, key spec, ...). I tried to use the information the tool shows me and set the private key</p>

<pre><code>bool LinkPrivateKey(PCCERT_CONTEXT cert)
{
    CRYPT_KEY_PROV_INFO cryptKeyProvInfo;
    memset(&amp;cryptKeyProvInfo, 0, sizeof(cryptKeyProvInfo));
    cryptKeyProvInfo.pwszContainerName = L""MSS"";
    cryptKeyProvInfo.pwszProvName = L""Luna Cryptographic Services for Microsoft Windows"";
    cryptKeyProvInfo.dwProvType = PROV_RSA_FULL;
    cryptKeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET; // CERT_SET_KEY_CONTEXT_PROP_ID | CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    cryptKeyProvInfo.cProvParam = 0;
    cryptKeyProvInfo.dwKeySpec = AT_SIGNATURE;

    return CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;cryptKeyProvInfo) != FALSE;
}
</code></pre>

<p>but CryptAcquirePrivateKey still gives me the same error. I believe I am missing only a small bit here, since the signtool is able to access the private key </p>

<p><img src=""https://i.stack.imgur.com/0EdaB.png"" alt=""enter image description here""></p>

<h3>Edit2</h3>

<hr>

<p>The screnshot shows KEYEXCHANGE but I chose SIGNATURE</p>

<h3>Edit3</h3>

<hr>

<p>I changed the <code>LinkPrivateKey</code>function a little bit, now it works</p>

<pre><code>bool LinkPrivateKey(PCCERT_CONTEXT cert)
{
    CRYPT_KEY_PROV_INFO cryptKeyProvInfo;
    memset(&amp;cryptKeyProvInfo, 0, sizeof(cryptKeyProvInfo));
    cryptKeyProvInfo.pwszContainerName = L""MSS"";
    cryptKeyProvInfo.pwszProvName = L""Luna Cryptographic Services for Microsoft Windows"";
    cryptKeyProvInfo.dwProvType = PROV_RSA_FULL;
    cryptKeyProvInfo.dwFlags = 1; // CERT_SET_KEY_CONTEXT_PROP_ID | CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    cryptKeyProvInfo.dwKeySpec = AT_SIGNATURE;

    return CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;cryptKeyProvInfo) != FALSE;
}
</code></pre>
","<p>As stated in my post, I can link the private key using</p>

<p>I changed the LinkPrivateKeyfunction a little bit, now it works</p>

<pre><code>bool LinkPrivateKey(PCCERT_CONTEXT cert)
{
    CRYPT_KEY_PROV_INFO cryptKeyProvInfo;
    memset(&amp;cryptKeyProvInfo, 0, sizeof(cryptKeyProvInfo));
    cryptKeyProvInfo.pwszContainerName = L""MSS"";
    cryptKeyProvInfo.pwszProvName = L""Luna Cryptographic Services for Microsoft Windows"";
    cryptKeyProvInfo.dwProvType = PROV_RSA_FULL;
    cryptKeyProvInfo.dwFlags = 1; // CERT_SET_KEY_CONTEXT_PROP_ID | CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    cryptKeyProvInfo.dwKeySpec = AT_SIGNATURE;

    return CertSetCertificateContextProperty(cert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;cryptKeyProvInfo) != FALSE;
}
</code></pre>

<p>YOu have to replace <code>L""MSS""</code>with the key container defined on you server.
LunSA provides the tool <code>keymap.exe</code> that is insatlled along with the LunaCSP to get the container names.</p>
","4350","<encryption><digital-signature><cryptoapi><rsacryptoserviceprovider><hsm>","2","1","2","2014-09-08 15:43:20","25728044","4","4","282144","","2014-09-08 15:38:39","2014-09-08 10:50:50",""
"749654","Associate private key to certificate for PFXExportCertStoreEx","<p>I'm trying to export certificate to pfx file. Here's what I do (simplified):</p>

<pre><code>h = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, NULL, CERT_STORE_CREATE_NEW_FLAG, NULL); 
p = CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                  CertBlob.pbData, CertBlob.cbData);
CertSetCertificateContextProperty(p, CERT_KEY_PROV_HANDLE_PROP_ID, 0, &amp;hPrivKey);
CertAddCertificateContextToStore(h, p, CERT_STORE_ADD_ALWAYS, NULL);
PFXExportCertStoreEx(h, &amp;SomeBlob, L"""", NULL, EXPORT_PRIVATE_KEYS);
</code></pre>

<p>PFX created, no private key exported. Anyone ever exported private key to pfx? What's the proper way to attach private key to certificate so that it could be exported?</p>
","<p>Apparently, <code>CertSetCertificateContextProperty(p, CERT_KEY_PROV_HANDLE_PROP_ID ...)</code></p>

<p>is not good. Need to do this instead:</p>

<pre><code>CRYPT_KEY_PROV_INFO kpi;
ZeroMemory( &amp; kpi, sizeof(kpi) );
kpi.pwszContainerName = ""my-container-name"";
kpi.dwProvType = PROV_RSA_FULL;
kpi.dwKeySpec = AT_KEYEXCHANGE;
kpi.dwFlags = CRYPT_MACHINE_KEYSET;
CertSetCertificateContextProperty( pCert, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp; kpi);
</code></pre>

<p>It's critical that provider name and other crap match the information that was used to generate actual key. It's not needed to set provider handle or any of that stuff. It also must be done before <code>CertAddCertificateContextToStore</code>. </p>

<p>This is the only way that I found to attach private key to a certificate.</p>
","4318","<cryptoapi><pfx>","3","4","2","2015-03-01 10:15:03","753213","0","2","33837","","2009-12-19 12:27:48","2009-04-14 22:56:31",""
"749654","Associate private key to certificate for PFXExportCertStoreEx","<p>I'm trying to export certificate to pfx file. Here's what I do (simplified):</p>

<pre><code>h = CertOpenStore(CERT_STORE_PROV_MEMORY, 0, NULL, CERT_STORE_CREATE_NEW_FLAG, NULL); 
p = CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                  CertBlob.pbData, CertBlob.cbData);
CertSetCertificateContextProperty(p, CERT_KEY_PROV_HANDLE_PROP_ID, 0, &amp;hPrivKey);
CertAddCertificateContextToStore(h, p, CERT_STORE_ADD_ALWAYS, NULL);
PFXExportCertStoreEx(h, &amp;SomeBlob, L"""", NULL, EXPORT_PRIVATE_KEYS);
</code></pre>

<p>PFX created, no private key exported. Anyone ever exported private key to pfx? What's the proper way to attach private key to certificate so that it could be exported?</p>
","<p><strong>For the posterity:</strong></p>

<p>The problem is related to the <code>CertAddCertificateContextToStore</code> call.
Indeed, it does not copy the  <code>CERT_KEY_PROV_HANDLE_PROP_ID</code> property to the next context. (this fact is noted in the remark)</p>

<p><strong>Solution:</strong></p>

<p>Fill the last parameter with a handle to the new context and copy the property from the old context to the next one.</p>
","4318","<cryptoapi><pfx>","3","0","2","2015-03-01 10:15:03","753213","0","2","33837","","2009-12-19 12:27:48","2009-04-14 22:56:31",""
"23568114","Converting text to image in Java","<p>I am writing code for a Visual Cryptography project in Java. We want to create two share images for a random token (alphanumeric string), so that when the two images are overlayed the token will be revealed. 
Now - even before the visual crypto part kicks in, I am trying to figure a way to convert this alphanumeric token into an image, and don't know where to start. Any suggestions? Thanks!</p>
","<p>I would start by creating a <a href=""http://docs.oracle.com/javase/7/docs/api/java/awt/image/BufferedImage.html"" rel=""nofollow"">BufferedImage</a> object, acquiring its <a href=""http://docs.oracle.com/javase/7/docs/api/java/awt/Graphics.html"" rel=""nofollow"">Graphics</a> context, calling <code>Graphics.drawString()</code> to turn your token into image data, then writing the <code>BufferedImage</code> to disk.</p>
","4273","<java><graphics2d><cryptoapi>","2","0","3","2014-05-09 15:31:17","23568375","1","","","","","2014-05-09 15:12:44",""
"23568114","Converting text to image in Java","<p>I am writing code for a Visual Cryptography project in Java. We want to create two share images for a random token (alphanumeric string), so that when the two images are overlayed the token will be revealed. 
Now - even before the visual crypto part kicks in, I am trying to figure a way to convert this alphanumeric token into an image, and don't know where to start. Any suggestions? Thanks!</p>
","<pre><code>public class TextToGraphicConverter {



  public static void main(String[] args) throws Exception {
        BufferedImage image = new TextToGraphicConverter().convertTextToGraphic(""my text"", new Font(""Arial"", Font.PLAIN, 18));
        //write BufferedImage to file
        ImageIO.write(image, ""png"", new File(""path-to-file.png""));
    }

    public BufferedImage convertTextToGraphic(String text, Font font) {

        BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = img.createGraphics();

        g2d.setFont(font);
        FontMetrics fm = g2d.getFontMetrics();
        int width = fm.stringWidth(text);
        int height = fm.getHeight();
        g2d.dispose();

        img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

        g2d = img.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
        g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
        g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);
        g2d.setFont(font);
        fm = g2d.getFontMetrics();
        g2d.setColor(Color.BLACK);
        g2d.drawString(text, 0, fm.getAscent());
        g2d.dispose();
        return img;
    }
}
</code></pre>
","4273","<java><graphics2d><cryptoapi>","2","2","3","2014-05-09 15:31:17","23568375","1","","","","","2014-05-09 15:12:44",""
"23568114","Converting text to image in Java","<p>I am writing code for a Visual Cryptography project in Java. We want to create two share images for a random token (alphanumeric string), so that when the two images are overlayed the token will be revealed. 
Now - even before the visual crypto part kicks in, I am trying to figure a way to convert this alphanumeric token into an image, and don't know where to start. Any suggestions? Thanks!</p>
","<p>I wouldn't know too much but at a guess i would approach it like this:</p>

<pre><code>String string=""something"";
Byte[] byteArray=string.getbytes();

//split the byte array into two one for each image. probably want something different than what i did.
int count=0
Byte[] bytes1=new Bytes[byteArray.length];
Byte[] bytes2=new Bytes[byteArray.length];
for(Byte b:byteArray){
bytes1[count]=b*0.2;

bytes2[count]=b*0.8;
count++;
}
//init images
BufferedImage img1 = new BufferedImage(bytes1.length, 1,BufferedImage.TYPE_INT_RGB);
BufferedImage img2 = new BufferedImage(bytes1.length, 1,BufferedImage.TYPE_INT_RGB);


//put bytes into pixels as int
int count=0;
for(Byte b: bytes1){
img1.setRGB(0, count, (int)b);
count++;}

count=0;
for(Byte b: bytes2){
img2.setRGB(0, count, (int)b);
count++;
}
</code></pre>

<p>then get the two images pixels parse the rgb value back into byte and and reverse your separation process, to decode.</p>
","4273","<java><graphics2d><cryptoapi>","2","0","3","2014-05-09 15:31:17","23568375","1","","","","","2014-05-09 15:12:44",""
"21645022","Signing a document using MS cryptoAPI with Delphi","<p>I have tried to find some complete examples in Delphi of how to sign a piece of data using the Microsoft CryptoAPI. Online I find mostly snippets and pseudo-code, but no concrete examples of how to do this.</p>

<p>From what I understand, having spent a day hunting for code and info, you can create a hash of a document/file based on a public key (either if you self-generate a pair, or provided by a certificate on the keychain). This hash is then encoded into the encrypted output file (container section) and can be verified and decoded by the receiver holding the private key.</p>

<p>If a Delphi example doesnt exist, are there any free commanline programs I can use to sign a file/document?</p>

<p>I have found code for MD5/SHA1 hashing and also one that encrypts a file using a password string (deriving a hash from a keypar generated on the fly). But sadly no signing of a stream or a file.
The closest match on google is an older product by Turbopower (LockBox) but I have no idea if the generated output is compatible with MS cryptoAPI (?)</p>

<p><strong>Update:</strong> This is something along the lines of what I am looking for, but written in C:
<a href=""http://blogs.msdn.com/b/alejacma/archive/2008/01/23/how-to-sign-and-verify-with-cryptoapi-and-a-user-certificate.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/alejacma/archive/2008/01/23/how-to-sign-and-verify-with-cryptoapi-and-a-user-certificate.aspx</a></p>

<p>Also, when you downgrade a question - be good enough to describe why you do so. It is a perfectly valid question for Delphi regarding something you face in larger, corporate applications.</p>
","<p>I know it's bad form to actually answere your own question, but since there seem to be little ""hands on"" examples for this under Delphi, I decided to post what I found here to help others.</p>

<p>Security, certificates and signatures is a massive and complex topic which requires serious study, so forgive me for the simplicity of this post. It is only meant to point people in the right direction.</p>

<p><strong>Signing XML, what does it mean?</strong></p>

<p>In very simple, hands-on terms this is what happens:</p>

<ul>
<li>You generate a HASH of your XML document (MD5 for instance, or
SHA1)</li>
<li>You encrypt this HASH using the private key, either generated
by yourself or provided/derived by your certificate</li>
<li>A new XML node (<a href=""http://www.w3.org/Signature/"" rel=""nofollow"">DSIG</a> signature) is inserted into the document which contains the encrypted hash (and more)</li>
</ul>

<p>In order to verify that an XML document has not been tampered with, the reader must use the public key to decode the HASH value. So the reader-software must generate a hash of the same document (minus the appended XML) and compare that to the (decrypted) value embedded in the document. If these match, then we know the document is intact. And it will only match if you use a valid key to decrypt the appended hash.</p>

<p>Since this is tedious work (and it includes quite a few steps, like looking up providers in the keystore [in my case] and much, much more) I ended up buying ready-made VCL components from ELDOS (SecureBlackBox) which saved me a lot of time.</p>

<p><strong>External references</strong></p>

<ul>
<li><a href=""https://www.eldos.com/sbb/desc-xml.php"" rel=""nofollow"">ELDOS XMLBlackBox</a> </li>
<li><a href=""http://www.xml.com/pub/a/2001/08/08/xmldsig.html"" rel=""nofollow"">XML DSIG Documentation</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/ms229745%28v=vs.110%29.aspx"" rel=""nofollow"">MSDN C# example for signing XML</a></li>
</ul>
","4030","<delphi><certificate><cryptoapi><mscapi>","2","4","1","2015-06-09 02:48:54","21726546","8","","608639","","2015-06-09 02:48:54","2014-02-08 10:46:13",""
"4926276","CryptoAPI: Using CryptVerifySignature to verify a signature from openssl with public key","<p>I am trying to port the <a href=""http://www.aquaticmac.com/"" rel=""nofollow"">AquaticPrime</a> framework for Mac to Windows.</p>

<p>On the Mac, it uses the opensll library, and I try to understand how to port this to Windows, where I have to use the CryptoAPI, I guess.</p>

<p>I mainly need the code for validation of the generated signature with a given public key.</p>

<p>Here's how verification is done with openssl:</p>

<ol>
<li>inputs: license data, public key and signature, both 128 bytes long.</li>
<li>A SHA1 digest is calculated from the license data.</li>
<li>A RSA context is set up with the public key data</li>
<li>RSA_public_decrypt() is called, given the RSA key and the signature, which returns a 20 byte long SHA1 digest - is this digest equal the one from step 2, the signature is valid.</li>
</ol>

<p>So, how do I do this with CryptoAPI? I've gotten this far:</p>

<ol>
<li>Start with CryptAcquireContext(ctx, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)</li>
<li>Use CryptImportKey with the help of <a href=""http://web.archive.org/web/20110426084248/http://msdn.microsoft.com/en-us/library/aa387459%28v=vs.85%29.aspx"" rel=""nofollow"">this</a> posting, with pubexp=3 and bitlen=1024. That all works, i.e. I get no errors, and I looked at the binary data to verify that it matches what the MSDN article shows.</li>
<li>Create a SHA1 digest from the license data. I've retrieved the resulting 20 byte hash value and see that it matches what I get with openssl on the Mac.</li>
</ol>

<p>At this point, I call:</p>

<pre><code>CryptVerifySignature (hashHdl, sig, sigLen, keyHdl, 0, 0)
</code></pre>

<p>This fails with error code ERROR_INVALID_PARAMETER.</p>

<p>The odd thing is that when I first accidentally had stored a twice as large public key into the PUBLICKEYBLOB structure, I received a NTE_BAD_SIGNATURE error instead. This might suggest that now the public key I am passing is correct.</p>

<p>Why the ERROR_INVALID_PARAMETER error now, then? I've verified that the hash value is correct, and the key appears to be accepted, too. And the ""sig"" parameter is just a pointer to the 128 bytes of the signature, and sigLen is 128.</p>

<p>So, what am I missing here?</p>
","<p>Compile and link the OpenSSL libCrypto statically. It can be done, I've seen this at a former employer.</p>
","3824","<openssl><rsa><cryptoapi><aquaticprime>","8","-3","2","2013-12-26 21:18:31","4935891","2","2","43615","","2013-12-26 21:18:31","2011-02-07 20:38:16",""
"4926276","CryptoAPI: Using CryptVerifySignature to verify a signature from openssl with public key","<p>I am trying to port the <a href=""http://www.aquaticmac.com/"" rel=""nofollow"">AquaticPrime</a> framework for Mac to Windows.</p>

<p>On the Mac, it uses the opensll library, and I try to understand how to port this to Windows, where I have to use the CryptoAPI, I guess.</p>

<p>I mainly need the code for validation of the generated signature with a given public key.</p>

<p>Here's how verification is done with openssl:</p>

<ol>
<li>inputs: license data, public key and signature, both 128 bytes long.</li>
<li>A SHA1 digest is calculated from the license data.</li>
<li>A RSA context is set up with the public key data</li>
<li>RSA_public_decrypt() is called, given the RSA key and the signature, which returns a 20 byte long SHA1 digest - is this digest equal the one from step 2, the signature is valid.</li>
</ol>

<p>So, how do I do this with CryptoAPI? I've gotten this far:</p>

<ol>
<li>Start with CryptAcquireContext(ctx, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)</li>
<li>Use CryptImportKey with the help of <a href=""http://web.archive.org/web/20110426084248/http://msdn.microsoft.com/en-us/library/aa387459%28v=vs.85%29.aspx"" rel=""nofollow"">this</a> posting, with pubexp=3 and bitlen=1024. That all works, i.e. I get no errors, and I looked at the binary data to verify that it matches what the MSDN article shows.</li>
<li>Create a SHA1 digest from the license data. I've retrieved the resulting 20 byte hash value and see that it matches what I get with openssl on the Mac.</li>
</ol>

<p>At this point, I call:</p>

<pre><code>CryptVerifySignature (hashHdl, sig, sigLen, keyHdl, 0, 0)
</code></pre>

<p>This fails with error code ERROR_INVALID_PARAMETER.</p>

<p>The odd thing is that when I first accidentally had stored a twice as large public key into the PUBLICKEYBLOB structure, I received a NTE_BAD_SIGNATURE error instead. This might suggest that now the public key I am passing is correct.</p>

<p>Why the ERROR_INVALID_PARAMETER error now, then? I've verified that the hash value is correct, and the key appears to be accepted, too. And the ""sig"" parameter is just a pointer to the 128 bytes of the signature, and sigLen is 128.</p>

<p>So, what am I missing here?</p>
","<p>OK, I solved the problem after lots of trial-and-error.</p>

<p>Both the signature and the public key data, when in their pure byte string form, need to be reversed, i.e. first byte to last position, and so on.
Then the above works.</p>
","3824","<openssl><rsa><cryptoapi><aquaticprime>","8","9","2","2013-12-26 21:18:31","4935891","2","2","43615","","2013-12-26 21:18:31","2011-02-07 20:38:16",""
"13896007","java - get key from byte array","<p>I have a java program that encrypts file content with a random-generated key.
That key is encrpyted with RSA and saved into a text file.</p>

<p>Now, I have a java program that given the file and the keystore where the RSA key is stored, needs to first decrypt the encryped key and then with the key to decrypt the file.</p>

<p>Here's what I have so far:</p>

<pre><code>// Fetch the other public key and decrypt the file encryption key
java.security.cert.Certificate cert2 = keystore.getCertificate(""keyForSeckeyDecrypt"");
Key secKeyPublicKey = cert2.getPublicKey();
Cipher cipher = Cipher.getInstance(secKeyPublicKey.getAlgorithm());
cipher.init(Cipher.DECRYPT_MODE, secKeyPublicKey);
keyFileFis = new FileInputStream(keyFile);
byte[] encryptedKey = new byte[128];
keyFileFis.read(encryptedKey);
byte[] realFileKey = cipher.doFinal(encryptedKey, 0, encryptedKey.length);
Key realKey = //  THE PROBLEM!!!;
keyFileFis.close();
</code></pre>

<p>In short, I get the encrypted key from the key text file and decrypt it, now I have the decrypted key as a byte array, how would I make it a Key variable again?</p>

<p>I've generated the key this way:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
Key secKey = keyGen.generateKey();
cipher.init(Cipher.ENCRYPT_MODE, secKey);
</code></pre>

<p>And encrypted it this way:</p>

<pre><code>KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
kpg.initialize(1024);
KeyPair kp = kpg.genKeyPair();
PrivateKey privateKey = kp.getPrivate();
Cipher keyCipher = Cipher.getInstance(""RSA"");
keyCipher.init(Cipher.ENCRYPT_MODE, privateKey);
byte[] encryptedKey = keyCipher.doFinal(secKey.getEncoded());
FileOutputStream keyStream = new FileOutputStream(""key.txt"");
keyStream.write(encryptedKey);
keyStream.close();
</code></pre>
","<p>I haven't tried it but from clicking through the API <a href=""http://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/SecretKeySpec.html"" rel=""nofollow"">SecretKeySpec</a> could be what you are looking for.</p>

<pre><code>SecretKeySpec(byte[] key, String algorithm)
</code></pre>

<blockquote>
  <p>It can be used to construct a SecretKey from a byte array, without having to go through a (provider-based) SecretKeyFactory.</p>
  
  <p>This class is only useful for raw secret keys that can be represented as a byte array and have no key parameters associated with them, e.g., DES or Triple DES keys.</p>
</blockquote>
","3747","<java><public-key><cryptoapi>","0","1","2","2012-12-16 13:47:08","","4","4","204390","","2012-12-16 13:47:08","2012-12-15 20:40:26",""
"13896007","java - get key from byte array","<p>I have a java program that encrypts file content with a random-generated key.
That key is encrpyted with RSA and saved into a text file.</p>

<p>Now, I have a java program that given the file and the keystore where the RSA key is stored, needs to first decrypt the encryped key and then with the key to decrypt the file.</p>

<p>Here's what I have so far:</p>

<pre><code>// Fetch the other public key and decrypt the file encryption key
java.security.cert.Certificate cert2 = keystore.getCertificate(""keyForSeckeyDecrypt"");
Key secKeyPublicKey = cert2.getPublicKey();
Cipher cipher = Cipher.getInstance(secKeyPublicKey.getAlgorithm());
cipher.init(Cipher.DECRYPT_MODE, secKeyPublicKey);
keyFileFis = new FileInputStream(keyFile);
byte[] encryptedKey = new byte[128];
keyFileFis.read(encryptedKey);
byte[] realFileKey = cipher.doFinal(encryptedKey, 0, encryptedKey.length);
Key realKey = //  THE PROBLEM!!!;
keyFileFis.close();
</code></pre>

<p>In short, I get the encrypted key from the key text file and decrypt it, now I have the decrypted key as a byte array, how would I make it a Key variable again?</p>

<p>I've generated the key this way:</p>

<pre><code>Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
Key secKey = keyGen.generateKey();
cipher.init(Cipher.ENCRYPT_MODE, secKey);
</code></pre>

<p>And encrypted it this way:</p>

<pre><code>KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
kpg.initialize(1024);
KeyPair kp = kpg.genKeyPair();
PrivateKey privateKey = kp.getPrivate();
Cipher keyCipher = Cipher.getInstance(""RSA"");
keyCipher.init(Cipher.ENCRYPT_MODE, privateKey);
byte[] encryptedKey = keyCipher.doFinal(secKey.getEncoded());
FileOutputStream keyStream = new FileOutputStream(""key.txt"");
keyStream.write(encryptedKey);
keyStream.close();
</code></pre>
","<p>If I get it right, this should work..</p>

<pre><code>Key privateKey = keyStore.getKey(""youralias"", ""password"".toCharArray());
PublicKey publicKey = keyStore.getCertificate(""youralias"").getPublicKey();

KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
Key secKey = keyGen.generateKey();

Cipher keyCipher = Cipher.getInstance(""RSA"");
keyCipher.init(Cipher.ENCRYPT_MODE, privateKey);
byte[] encryptedKey = keyCipher.doFinal(secKey.getEncoded());

// Write &amp; Read to/from file!

Cipher decryptCipher = Cipher.getInstance(""RSA"");
decryptCipher.init(Cipher.DECRYPT_MODE, publicKey);
byte[] decryptedKey = decryptCipher.doFinal(encryptedKey);

boolean equals = Arrays.equals(secKey.getEncoded(), new SecretKeySpec(decryptedKey, ""AES"").getEncoded());
System.out.println(equals?""Successfull!"":""Failed!"");
</code></pre>
","3747","<java><public-key><cryptoapi>","0","0","2","2012-12-16 13:47:08","","4","4","204390","","2012-12-16 13:47:08","2012-12-15 20:40:26",""
"9794745","MS CryptoAPI doesn't work on Windows XP with CryptAcquireContext()","<p>I wrote some code using the Microsoft CryptoAPI to calculate a SHA-1 and got the compiled exe working on Windows 7, Win Server 2008, Win Server 2003.  However, when I run it under Windows XP SP3, it does not work.  </p>

<p>I narrowed down the failure to the <code>CryptAcquireContext()</code> call.</p>

<p>I did notice that <a href=""https://stackoverflow.com/a/4523302"">a previous post</a> talked about the XP faulty naming of ""<em>… (Prototype)</em>"" and it must be accounted for by using a WinXP specific macro MS_ENH_RSA_AES_PROV_XP.  </p>

<p>I did the XP specific code modifications and it still doesn't work.  (The <code>bResult</code> returns 0 false on Win XP, all other platforms <code>bResult</code> returns 1 true.)</p>

<p>I checked the MS_ENH_RSA_AES_PROV_XP with the actual key+string values I see in regedit.exe so everything looks like it's set up to work but no success.</p>

<p>Have I overlooked something to make it work on Windows XP?</p>

<p>I've pasted shortest possible example to illustrate the issue.  I used VS2010 C++.</p>

<pre><code>// based on examples from http://msdn.microsoft.com/en-us/library/ms867086.aspx

#include ""windows.h""
#include ""wincrypt.h""
#include &lt;iostream&gt;
#include &lt;iomanip&gt;  // for setw()

void main()
{
    BOOL bResult;
    HCRYPTPROV hProv;

    // Attempt to acquire a handle to the default key container.
    bResult = CryptAcquireContext(
        &amp;hProv,            // Variable to hold returned handle.
        NULL,              // Use default key container.
        MS_DEF_PROV,       // Use default CSP.
        PROV_RSA_FULL,     // Type of provider to acquire.
        0);                // No special action.
    std::cout &lt;&lt; ""line:  "" &lt;&lt; std::setw(4) &lt;&lt; __LINE__ &lt;&lt; "";  "" &lt;&lt; ""bResult = "" &lt;&lt; bResult &lt;&lt; std::endl;

    if (! bResult) {        // try Windows XP provider name
        bResult = CryptAcquireContext(
            &amp;hProv,            // Variable to hold returned handle.
            NULL,              // Use default key container.
            MS_ENH_RSA_AES_PROV_XP,  // Windows XP specific instead of using default CSP.
            PROV_RSA_AES,     // Type of provider to acquire.
            0);                // No special action.
        std::cout &lt;&lt; ""line:  "" &lt;&lt; std::setw(4) &lt;&lt; __LINE__ &lt;&lt; "";  "" &lt;&lt; ""bResult = "" &lt;&lt; bResult &lt;&lt; std::endl;
    }

    if (bResult)
        CryptReleaseContext(hProv, 0);
}
</code></pre>

<p>Windows 7 success:
<img src=""https://i.stack.imgur.com/TUxSG.png"" alt=""enter image description here""></p>

<p>Windows XP failure:
<img src=""https://i.stack.imgur.com/J6u8b.png"" alt=""enter image description here""></p>
","<p>In your CryptAcquireContext code, it appears you are missing the parameter to get a context without a specific container set.  You need to pass the CRYPT_VERIFYCONTEXT option in CryptAcquireContext.</p>

<p>Windows 7 might be working around this.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx</a></p>

<p>For further diagnosis, the results of GetLastError() would be requisite.</p>
","3716","<c++><visual-studio-2010><sha1><cryptoapi><mscapi>","3","5","1","2015-06-09 02:54:47","9794821","0","1","-1","","2017-05-23 12:19:46","2012-03-20 20:52:57",""
"7618301","Can I get public/private key pair from a key container in smartcard?","<p>Can I get the public/private key pair from a key container inside a smartcard using PKCS #11 or CryptoAPI?</p>
","<p>I'm no expert in this, but I think the whole point of a smartcard is that you can't extract the private key.  You send the data to the card instead, and let it do the crypto operations on its own processor.</p>
","3583","<c++><smartcard><cryptoapi><private-key><pkcs#11>","3","6","2","2011-10-20 13:36:43","","0","1","220643","","2011-10-20 13:36:43","2011-10-01 05:03:49",""
"7618301","Can I get public/private key pair from a key container in smartcard?","<p>Can I get the public/private key pair from a key container inside a smartcard using PKCS #11 or CryptoAPI?</p>
","<p>It depends. Both CryptoAPI (well the CSP for the smart card) and PKCS#11 allows you to have <em>exportable</em> key pairs. However it's common to use <strong>non</strong> exportable private keys to use the smart card strength to its full potential.</p>

<p>So if you're writing an application it becomes your choice. Otherwise someone else already made that choice for you ;-)</p>
","3583","<c++><smartcard><cryptoapi><private-key><pkcs#11>","3","5","2","2011-10-20 13:36:43","","0","1","220643","","2011-10-20 13:36:43","2011-10-01 05:03:49",""
"1050187","CryptGetProvParam PP_ENUMCONTAINERS shows me only default certificate on smart card","<p>I have Gemalto.NET Smart Card.<br>
I imported 2 certificates into it using Gemalto tools, which use <a href=""http://www.sconnect.com/"" rel=""nofollow noreferrer"">sconnect</a> (which as I suspect use Crypto API to do it when used in IE).</p>

<p>When I run </p>

<pre><code>certutil -key -csp ""Microsoft Base Smart Card Crypto Provider""
</code></pre>

<p>I have following result</p>

<blockquote>
  <p>Microsoft Base Smart Card Crypto
  Provider:<br>
  7c168bc3-dc1d-a627-c218-cd45729b42cb
  [Default Container]
      AT_KEYEXCHANGE</p>
  
  <p>badd537a-a377-431b-cbc9-8699dbe15e0e
      AT_KEYEXCHANGE</p>
  
  <p>LoadKeys returned Key does not exist.
  0x8009000d (-2146893811) CertUtil:
  -key command completed successfully.</p>
</blockquote>

<p>Now I want to find those keys in my C# program. To do it I wrote following method that should return all keys on specific smart card.</p>

<pre><code>static List&lt;string&gt; EnumerateContainers(string card)
{
    var list = new List&lt;string&gt;();
    var provider = IntPtr.Zero;
    if (!CryptAcquireContext(ref provider, @""\\.\"" + card + @""\"", ""Microsoft Base Smart Card Crypto Provider"", 1, CspProviderFlags.UseMachineKeyStore))
        Debug.WriteLine(""no context for "" + card);

    uint bufferSize = 4096;
    var container = new StringBuilder((int)bufferSize);
    uint flags = CRYPT_FIRST;
    while(CryptGetProvParam(provider, PP_ENUMCONTAINERS, container, ref bufferSize, flags))
    {
        list.Add(container.ToString());
        flags = 0;
    }
    return list;
}
</code></pre>

<p>But my method find only the key 7c168bc3-dc1d-a627-c218-cd45729b42cb which is the default one.
<strong>What should I do to find all keys/containers stored on the smart card ??</strong></p>

<p>And Later</p>

<p><strong>How can I delete those keys and import new one using C#?</strong></p>
","<p>I've come across the same problem and have seen similiar posts on the web but finally I've found the answer... by checking the error code! </p>

<p>The reason is that pcbData's value is changed by the implementation being called (to reflect length of the returned data) and must be set to buffer's size before each call.</p>

<p>Checking <code>GetLastError</code> after the failure shows error 234 which is exactly that!</p>

<p>Actually it seems to be a propagation of a bug in code sample from ""Extending .NET Cryptography with CAPICOM and P/Invoke"" (<a href=""http://msdn.microsoft.com/en-us/library/ms867087.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/ms867087.aspx</a>)</p>

<pre><code>dwFlags=CRYPT_FIRST;  //required initalization
StringBuilder sb = new StringBuilder(BUFFSIZE);
while (Win32.CryptGetProvParam(hProv, enumflags, sb, ref pcbData, dwFlags)) 
{
    dwFlags=0;            //required to continue entire enumeration
    containernames.Add(sb.ToString());
}
</code></pre>

<p>where there is <code>pcbData = BUFFSIZE;</code> missing inside the loop.</p>
","3514","<c#><smartcard><cryptoapi>","1","1","1","2015-12-20 19:40:41","","0","","33837","","2009-12-19 12:10:23","2009-06-26 17:07:18",""
"9496239","Extracting all values of a subject attribute in a certificate","<p>I'm currently using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376086%28v=vs.85%29.aspx"" rel=""nofollow""><code>CertGetNameString</code></a> to extract the values for each subject attribute like so:</p>

<pre class=""lang-cpp prettyprint-override""><code>CertGetNameString(pCertificate,
                  CERT_NAME_ATTR_TYPE,
                  0,
                  szOID_ORGANIZATIONAL_UNIT_NAME,
                  buf,
                  _countof(buf));
</code></pre>

<p>However some certificates I've found have multiple values for the organizational unit name (OU) and <code>CertGetNameString</code> can only read the first. For instance this is the subject of an Adobe certificate:</p>

<pre class=""lang-none prettyprint-override""><code>CN = Adobe Systems, Incorporated
OU = Acrobat Engineering
OU = Digital ID Class 3 - Microsoft Software Validation v2
O = Adobe Systems, Incorporated
L = San Jose
S = California
C = US
</code></pre>

<p>How can I read all values for the OU (and other) attribute(s) using CryptoAPI?</p>
","<p>Ok, found the solution. The correct API to use is <code>CertNameToStr</code>, like so:</p>

<pre class=""lang-cpp prettyprint-override""><code>    CertNameToStr(X509_ASN_ENCODING,
                  &amp;pCertificate-&gt;pCertInfo-&gt;Subject,
                  CERT_X500_NAME_STR,
                  buf,
                  _countof(buf));
</code></pre>

<p>It will return a string such as:</p>

<pre class=""lang-none prettyprint-override""><code>C=US, S=California, L=San Jose, O=""Adobe Systems, Incorporated"", OU=Digital ID Class 3 - Microsoft Software Validation v2, OU=Acrobat Engineering, CN=""Adobe Systems, Incorporated""
</code></pre>

<p>Which can then be parsed if individual attribute values are required.</p>
","3201","<c++><windows><winapi><certificate><cryptoapi>","5","16","1","2016-02-10 08:36:30","9498520","0","3","5811","","2016-02-10 08:34:34","2012-02-29 09:07:49",""
"15616396","Need help to find certificate by Subject name (X500 format, CERT_X500_NAME_STR) using CertFindCertificateInStore()?","<p>A client application has to access certificate from Windows certificate store. The search 
input is the subject name in X500 string format as below.</p>

<pre><code>""C=CH, S=Aargau, L=Baden, O=Test, OU=FF, CN= Test Root""
</code></pre>

<p>An exact match is required (not substring match using  CERT_FIND_SUBJECT_STR). 
For this i do the following</p>

<pre><code>CERT_NAME_BLOB subjectname = {0};

/*convert the input X500 string to encoded subject name*/
bRet = CertStrToNameA(X509_ASN_ENCODING, ""C=CH, S=Aargau, L=Baden, O=Test, OU=S1, CN= Test Root"", CERT_X500_NAME_STR, NULL, NULL, &amp;size, NULL);
  if(TRUE == bRet)
  {
     subjectname.pbData  = (BYTE*)malloc(size);
     subjectname.cbData = size;

     bRet = CertStrToNameA(X509_ASN_ENCODING , ""C=CH, S=Aargau, L=Baden, O=Test, OU=S1, CN=Test Root"", CERT_X500_NAME_STR, NULL, subjectname.pbData, &amp;subjectname.cbData, NULL);
     if(TRUE == bRet)
     {
          capiCertificate = CertFindCertificateInStore(hStore, X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_NAME, &amp;subjectname, NULL);
         if (NULL == capiCertificate)
         {
            errorcode = GetLastError();
            ret = CA_CERT_NOT_FOUND;
         }
     }
  }
</code></pre>

<p>The problem is that CertFindCertificateInStore always return NULL pointer. I have been debugging, but could not find out what is going wrong here.</p>

<p>Any suggestions will be very helpful.</p>
","<p>In case anyone is looking for an answer to this question, i am posting how i could do it, incase it is useful</p>

<pre><code>static PCCERT_CONTEXT
FindCertificate(
    const HCERTSTORE hStore,
    const char* CertSearchString)
{
    PCCERT_CONTEXT capiCertificate = NULL;
    DWORD dType = CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG;
    char certname [MAX_SIZE_CERT_NAME] = {0};

    for(;;)
    {
        capiCertificate = CertEnumCertificatesInStore(hStore, capiCertificate);
        if (NULL == capiCertificate)
        {
            break;
        }

        if (FALSE == 
            CertGetNameStringA(capiCertificate, CERT_NAME_RDN_TYPE,
                0, &amp;dType, certname, MAX_SIZE_CERT_NAME))
        {
            CertFreeCertificateContext(capiCertificate);
            capiCertificate = NULL;
            break;
        }

        if ((0 == strncmp(certname, CertSearchString, MAX_SIZE_CERT_NAME)) &amp;&amp;
            (capiCertificate-&gt;dwCertEncodingType == X509_ASN_ENCODING))
        {
            break;
        }
    }
    return capiCertificate;
}
</code></pre>
","3185","<windows><certificate><cryptoapi>","6","7","1","2015-10-02 02:11:19","17231188","2","1","","","","2013-03-25 13:39:57",""
"2928006","Using an SHA1 with Microsoft CAPI","<p>I have an SHA1 hash and I need to sign it. The CryptSignHash() method requires a HCRYPTHASH handle for signing. I create it and as I have the actual hash value already then set it:</p>

<pre><code>CryptCreateHash(cryptoProvider, CALG_SHA1, 0, 0, &amp;hash);
CryptSetHashParam(hash, HP_HASHVAL, hashBytes, 0);
</code></pre>

<p>The hashBytes is an array of 20 bytes.</p>

<p>However the problem is that the signature produced from this HCRYPTHASH handle is incorrect. I traced the problem down to the fact that CAPI actually doesn't use all 20 bytes from my hashBytes array. For some reason it thinks that SHA1 is only 4 bytes.</p>

<p>To verify this I wrote this small program:</p>

<pre><code>HCRYPTPROV cryptoProvider;
CryptAcquireContext(&amp;cryptoProvider, NULL, NULL, PROV_RSA_FULL, 0);

HCRYPTHASH hash;
HCRYPTKEY keyForHash;
CryptCreateHash(cryptoProvider, CALG_SHA1, keyForHash, 0, &amp;hash);

DWORD hashLength;
CryptGetHashParam(hash, HP_HASHSIZE, NULL, &amp;hashLength, 0);
printf(""hashLength: %d\n"", hashLength);
</code></pre>

<p>And this prints out hashLength: 4 !</p>

<p>Can anyone explain what I am doing wrong or why Microsoft CAPI thinks that SHA1 is 4 bytes (32 bits) instead of 20 bytes (160 bits).</p>
","<p>I don't think you can use <code>CryptCreateHash</code> in that way. From <a href=""http://msdn.microsoft.com/en-us/library/aa379908%28v=VS.85%29.aspx"" rel=""nofollow noreferrer"">MSDN</a>: </p>

<blockquote>
  <p>""The CryptCreateHash function
  initiates the hashing of a stream of
  data.""</p>
</blockquote>

<p>In other words, it looks like you can't instantiate a hash context in any way other than empty (and then by having it hash your input data).</p>

<p>How do you have the hash at present - a byte array? If so you probably just want to sign that array; I'd look into <code>CryptSignMessage</code> or <code>CryptSignMessageWithKey</code> as likely to do the job.</p>

<p>(I'm guessing, but what you're seeing may be explained by the output hash length not being set up until after the hash context has done some work.)</p>
","3145","<c><cryptoapi>","4","1","2","2010-06-08 19:34:51","","0","","15168","","2010-05-30 07:15:26","2010-05-28 09:49:38",""
"2928006","Using an SHA1 with Microsoft CAPI","<p>I have an SHA1 hash and I need to sign it. The CryptSignHash() method requires a HCRYPTHASH handle for signing. I create it and as I have the actual hash value already then set it:</p>

<pre><code>CryptCreateHash(cryptoProvider, CALG_SHA1, 0, 0, &amp;hash);
CryptSetHashParam(hash, HP_HASHVAL, hashBytes, 0);
</code></pre>

<p>The hashBytes is an array of 20 bytes.</p>

<p>However the problem is that the signature produced from this HCRYPTHASH handle is incorrect. I traced the problem down to the fact that CAPI actually doesn't use all 20 bytes from my hashBytes array. For some reason it thinks that SHA1 is only 4 bytes.</p>

<p>To verify this I wrote this small program:</p>

<pre><code>HCRYPTPROV cryptoProvider;
CryptAcquireContext(&amp;cryptoProvider, NULL, NULL, PROV_RSA_FULL, 0);

HCRYPTHASH hash;
HCRYPTKEY keyForHash;
CryptCreateHash(cryptoProvider, CALG_SHA1, keyForHash, 0, &amp;hash);

DWORD hashLength;
CryptGetHashParam(hash, HP_HASHSIZE, NULL, &amp;hashLength, 0);
printf(""hashLength: %d\n"", hashLength);
</code></pre>

<p>And this prints out hashLength: 4 !</p>

<p>Can anyone explain what I am doing wrong or why Microsoft CAPI thinks that SHA1 is 4 bytes (32 bits) instead of 20 bytes (160 bits).</p>
","<p>There are a small error in your code. Instead of </p>

<pre><code>DWORD hashLength;
CryptGetHashParam(hash, HP_HASHSIZE, NULL, &amp;hashLength, 0);
printf(""hashLength: %d\n"", hashLength);
</code></pre>

<p>you should use</p>

<pre><code>DWORD hashLength, hashSize;
hashLength = sizeof(DWORD)
CryptGetHashParam(hash, HP_HASHSIZE, (PBYTE)&amp;hashSize, &amp;hashLength, 0);
printf(""hashSize: %d\n"", hashSize);
</code></pre>

<p>then you will receive 20 as expected.</p>

<p>The Usage of <code>CryptSignHash</code> after <code>CryptSetHashParam</code> must also work. See remark at the end of the description of <code>CryptSetHashParam</code> function at <a href=""http://msdn.microsoft.com/en-us/library/aa380270(VS.85).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/aa380270(VS.85).aspx</a>. I suppose you just made the same error as with <code>CryptGetHashParam(..., HP_HASHSIZE, ...)</code> during retrieving of the result of signing. Compare your code with the code from the description of <code>CryptSignHash</code> function <a href=""http://msdn.microsoft.com/en-us/library/aa380280(VS.85).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/aa380280(VS.85).aspx</a>.</p>
","3145","<c><cryptoapi>","4","2","2","2010-06-08 19:34:51","","0","","15168","","2010-05-30 07:15:26","2010-05-28 09:49:38",""
"5802611","How to correctly encode DH parameters using BouncyCastle in Java?","<p>I am trying to reproduce the output of ""openssl dhparam -out dh1024.pem 1024"" command programatically in Java. The code snippet is following:-</p>

<pre><code>            DHParametersGenerator generator = new DHParametersGenerator();
            generator.init(1024, 0, new SecureRandom());
            DHParameters params = generator.generateParameters();
            // Generator G is set as random in params, but it has to be 2 to conform to openssl
            DHParameters realParams = new DHParameters(params.getP(), BigInteger.valueOf(2));

            byte[] p = realParams.getP().toByteArray();
            byte[] g = realParams.getG().toByteArray();
            byte[] l = new byte[(byte) realParams.getL()];
            byte[] pgl = new byte[p.length+g.length+l.length];

            System.arraycopy(p, 0, pgl, 0, p.length);
            System.arraycopy(g, 0, pgl, p.length, g.length);
            System.arraycopy(l, 0, pgl, p.length+g.length, l.length);
</code></pre>

<p>So basically I am concatenating the values of P,G and L parameters in a byte array ""pgl"" and then saving it in a file using the PEMWriter class from BC. But when I try to use it via openssl, I get the following error:-</p>

<blockquote>
  <p>Cannot load DH parameters from
  /etc/openvpn/easy-rsa/keys/dh1024.pem:
  error:0D07207B:asn1 encoding
  routines:ASN1_get_object:header too
  long: error:0D068066:asn1 encoding
  routines:ASN1_CHECK_TLEN:bad object
  header: error:0D07803A:asn1 encoding
  routines:ASN1_ITEM_EX_D2I:nested asn1
  error: error:0906700D:PEM
  routines:PEM_ASN1_read_bio:ASN1 lib</p>
</blockquote>

<p>.... which leads me to believe that I am encoding the DH Parameters wrongly, but I cannot find anywhere the correct way to encode this. Can anyone help me in this? I've been bouncing my head against the castle wall fro many days now but to no avail .... please help :( </p>
","<p>Here is an example. Note that you cannot set the certainty argument to 0 in <code>generator.init()</code> or you won't get a prime! Most of this code I figured out just by looking at the Bouncycastle source code, for example look at the PEMWriter class.</p>

<pre><code>import java.math.BigInteger;
import java.security.SecureRandom;

import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.DERInteger;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.crypto.generators.DHParametersGenerator;
import org.bouncycastle.crypto.params.DHParameters;
import org.bouncycastle.util.encoders.Base64;

public class OpenSSLDHParamClone
{

    public static void main(String[] args) throws Exception
    {
        DHParametersGenerator generator = new DHParametersGenerator();
        generator.init(1024, 80, new SecureRandom());
        DHParameters params = generator.generateParameters();
        // Generator G is set as random in params, but it has to be 2 to conform to openssl
        DHParameters realParams = new DHParameters(params.getP(), BigInteger.valueOf(2));
        ASN1EncodableVector seq = new ASN1EncodableVector();
        seq.add(new DERInteger(realParams.getP()));
        seq.add(new DERInteger(realParams.getG()));
        byte [] derEncoded = new DERSequence(seq).getDEREncoded();
        System.out.println(""-----BEGIN DH PARAMETERS-----"");
        String b64Encoded = new String(Base64.encode(derEncoded), ""US-ASCII"");
        while (b64Encoded.length() &gt; 0) {
            int subStringLength = Math.min(64, b64Encoded.length());
            System.out.println(b64Encoded.substring(0, subStringLength));
            b64Encoded = b64Encoded.substring(subStringLength);
        }
        System.out.println(""-----END DH PARAMETERS-----"");
    }
}
</code></pre>
","3079","<java><security><bouncycastle><cryptoapi>","0","2","2","2011-05-07 14:01:02","5826356","1","1","","","","2011-04-27 10:28:17",""
"5802611","How to correctly encode DH parameters using BouncyCastle in Java?","<p>I am trying to reproduce the output of ""openssl dhparam -out dh1024.pem 1024"" command programatically in Java. The code snippet is following:-</p>

<pre><code>            DHParametersGenerator generator = new DHParametersGenerator();
            generator.init(1024, 0, new SecureRandom());
            DHParameters params = generator.generateParameters();
            // Generator G is set as random in params, but it has to be 2 to conform to openssl
            DHParameters realParams = new DHParameters(params.getP(), BigInteger.valueOf(2));

            byte[] p = realParams.getP().toByteArray();
            byte[] g = realParams.getG().toByteArray();
            byte[] l = new byte[(byte) realParams.getL()];
            byte[] pgl = new byte[p.length+g.length+l.length];

            System.arraycopy(p, 0, pgl, 0, p.length);
            System.arraycopy(g, 0, pgl, p.length, g.length);
            System.arraycopy(l, 0, pgl, p.length+g.length, l.length);
</code></pre>

<p>So basically I am concatenating the values of P,G and L parameters in a byte array ""pgl"" and then saving it in a file using the PEMWriter class from BC. But when I try to use it via openssl, I get the following error:-</p>

<blockquote>
  <p>Cannot load DH parameters from
  /etc/openvpn/easy-rsa/keys/dh1024.pem:
  error:0D07207B:asn1 encoding
  routines:ASN1_get_object:header too
  long: error:0D068066:asn1 encoding
  routines:ASN1_CHECK_TLEN:bad object
  header: error:0D07803A:asn1 encoding
  routines:ASN1_ITEM_EX_D2I:nested asn1
  error: error:0906700D:PEM
  routines:PEM_ASN1_read_bio:ASN1 lib</p>
</blockquote>

<p>.... which leads me to believe that I am encoding the DH Parameters wrongly, but I cannot find anywhere the correct way to encode this. Can anyone help me in this? I've been bouncing my head against the castle wall fro many days now but to no avail .... please help :( </p>
","<p>Thanks GregS, your solution works but I eventually solved it using standard Java plus PemWriter from BC, although you cannot set the Generator G = 2 with this approach, but its still works both with openssl and Java, which was my initial purpose anyway :)</p>

<pre><code>import java.io.FileWriter;
import java.io.IOException;
import java.security.AlgorithmParameterGenerator;
import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemWriter;

public class DHCredentials {

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException, IOException 
        {
        DHCredentials dhc = new DHCredentials();
        System.out.println(""This may take a long time ..."");

        dhc.saveDHParams(""C:\\xxxDH.txt"", dhc.genDHParams());

        System.out.println(""Done"");
    }

    public byte[] genDHParams() throws IOException
    {
        AlgorithmParameterGenerator paramGen = null;
        try 
        {
            paramGen = AlgorithmParameterGenerator.getInstance(""DH"");
            paramGen.init(1024, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        AlgorithmParameters params = paramGen.generateParameters();
        return params.getEncoded();
    }

    public void saveDHParams(String filePath, byte[] DEREncodedDHParams)
    {
        PemWriter pemWrt;

        try {
            pemWrt = new PemWriter(new FileWriter(filePath));
            pemWrt.writeObject(new PemObject(""DH PARAMETERS"", DEREncodedDHParams));
            pemWrt.flush();
            pemWrt.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
","3079","<java><security><bouncycastle><cryptoapi>","0","3","2","2011-05-07 14:01:02","5826356","1","1","","","","2011-04-27 10:28:17",""
"693974","Crypto API <-> .NET RSA interoperability","<p>I have a unmanaged application that is generates an RC4 encryption key using Crypto API. This unmanaged application encrypts some data using this RC4 key. There is also a client side unmanaged application that uses this RC4 key to decrypt information. </p>

<p>However, for this client app we're sending a session key -> the RC4 key encrytped using an RSA public key that was generated at the client side(SIMPLEBLOB). The generation of the encrypted session key used to be done using unmanaged code but now that has to be converted to C# because there is a requirement to run this code from a web application under partial trust.</p>

<p>Key is generated using</p>

<pre><code>CryptGenKey(hProv, CALG_RC4, KEY_LENGTH | CRYPT_EXPORTABLE, &amp;hKey);
</code></pre>

<p>It is exported into the file system using</p>

<pre><code>CryptExportKey(hKey, 0, OPAQUEKEYBLOB, 0, lpBuffer, &amp;nSize);
</code></pre>

<p>(note I was able to export the the plain text key using this article 
<a href=""http://www.codeproject.com/KB/security/plaintextsessionkey.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/security/plaintextsessionkey.aspx</a>)</p>

<p>Client public key is created using </p>

<pre><code>CryptGetUserKey(hProv, AT_KEYEXCHANGE, &amp;hKeyPair);
</code></pre>

<p>Client public key is exported using</p>

<pre><code>CryptExportKey(hKeyPair, 0, PUBLICKEYBLOB, 0, lpData, &amp;nSize);
</code></pre>

<p>Session Key is created at the server side using</p>

<ol>
<li><p>client public key is imported using </p>

<p>CryptImportKey(hProv, lpData, nSize, NULL, 0, &amp;hPublicKey</p></li>
<li><p>Session Key is generated by encryting the RC4 using the client public key to generate a SIMPLEBLOB format</p>

<p>CryptExportKey(hKey, hPublicKey, SIMPLEBLOB, 0, lpData, &amp;nSize);</p></li>
</ol>

<p>Now my requirement is to have the above steps (step 1 &amp; 2) in a managed version and here is what i am doing :</p>

<p>//Read the plain text key data that was extracted using the code project article
    byte[] keyMaterial = File.ReadAllBytes(@""C:\keyMaterial.txt""); </p>

<p>// Import the client public key</p>

<pre><code>CspParameters cspParams = new CspParameters();
            cspParams.KeyContainerName = ""Container Name"";
            cspParams.KeyNumber = (int)KeyNumber.Exchange;
            cspParams.ProviderType = 1;
            cspParams.ProviderName = ""Microsoft Enhanced Cryptographic Provider v1.0"";
            cspParams.Flags = CspProviderFlags.UseMachineKeyStore;

            RSACryptoServiceProvider rsaClient = new RSACryptoServiceProvider(cspParams);   
            rsaClient.ImportCspBlob(File.ReadAllBytes(@""C:\client.key""));

//Generate a SIMPLEBLOB session key
byte[] session = GetRC4SessionBlobFromKey(keyMaterial, rsaClient);



//Encrypt a key using public key and write it in a SIMPLEBLOB format
public byte[] GetRC4SessionBlobFromKey(byte[] keyData, RSACryptoServiceProvider publicKey)
        {  
            using(MemoryStream ms = new MemoryStream())  
            using(BinaryWriter w = new BinaryWriter(ms))
            {   
                w.Write((byte) 0x01); // SIMPLEBLOB    
                w.Write((byte) 0x02); // Version 2    
                w.Write((byte) 0x00); // Reserved    
                w.Write((byte) 0x00); // Reserved    
                w.Write(0x00006801);  // ALG_ID = RC4 for the encrypted key.
                w.Write(0x0000a400);  // CALG_RSA_KEYX    

                w.Write(publicKey.Encrypt(keyData, false));
                w.Flush();

                return ms.ToArray();  
            }
        }
</code></pre>

<p>This generates the same size of data as its unmanaged version but it doesn't generate the correct SIMPLEBLOB session key as when diong step 1 and 2 of the unmanaged version. What am I doing wrong in this code?</p>
","<p>I'm a novice here but I just read in MSDN docs the following:</p>

<p><strong>Interoperation with the Microsoft Cryptographic API (CAPI)</strong></p>

<p><strong>Unlike the RSA implementation in unmanaged CAPI, the RSACryptoServiceProvider class reverses the order of an encrypted array of bytes after encryption and before decryption. By default, data encrypted by the RSACryptoServiceProvider class cannot be decrypted by the CAPI CryptDecrypt function and data encrypted by the CAPI CryptEncrypt method cannot be decrypted by the RSACryptoServiceProvider class.</strong></p>

<p><em><strong>If you do not compensate for the reverse ordering when interoperating between APIs, the RSACryptoServiceProvider class throws a CryptographicException.</em></strong></p>

<p>Could this be the problem?</p>
","3032","<c#><rsa><cryptoapi>","0","2","1","2011-01-09 23:15:05","","0","","","","","2009-03-29 01:55:59",""
"16905142","Private key security in windows certificate store","<p>When I import a public/private pair into windows certificate store, Windows does not require any password of any kind to encrypt the keys.</p>

<p>From that I conclude that if it is a user's store, it uses the user's password (or probably the user's hashed password) to encrypt the private key, and, if it is the local machine store, it is probably some kind of hardware-based key to encrypt the private key.</p>

<p>Did I get it right???</p>

<p>And if I did, what is the point of non-exportable keys if I can decrypt the keys???</p>

<p>And last question - If I got it right up to here, what are the alternatives?</p>
","<p>As ""SLanks"" link explains, the private keys are encrypted with the user's password or the machines's password (depends on the location of the keys in the store).</p>

<p>Therefore, anyone who can log to the machine can obtain to this user's keys and anyone who has access to the machine can obtain keys stored for the local machine.</p>
","2979","<windows><security><certificate><private-key><cryptoapi>","3","2","1","2013-06-09 13:15:27","17009971","1","","","","","2013-06-03 20:18:57",""
"23525241","How to access a url that requires a SafeNet eToken certificate using Java","<p>Good afternoon,</p>

<p>I have a SafeNet 5100 eToken already with a valid certificate in it that I use to access a web application from my company that requires it.</p>

<p>When I try to access the web application using a web browser (like chrome) everything works fine and I have no problem. A dialog from SafeNet opens up, I put in my password and I am able to access the site.</p>

<p>What I'm trying to do now is to access this web application through a java program (I'm programming it using the IDE eclipse) and couldn't find how to do this. Is there any API from SafeNet to do this or any online tutorials?</p>

<p>I was looking at this thread <a href=""https://stackoverflow.com/questions/13320685/how-to-use-microsoft-crypto-api-with-usb-dongle-following-pkcs11/13647517#13647517"">how to use Microsoft Crypto API with USB Dongle following PKCS#11</a>, but couldn't understand how this <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380252%28v=vs.85%29.aspx#csp_functions"" rel=""nofollow noreferrer"">CryptoAPI CSP</a> works. Any help is appreciated.</p>

<p>Thank you</p>
","<p>I am not SafeNet expert. You may try SAML assertions to login to safeNet. Java has OpenSAML API for generating SAML assertion.</p>
","2935","<java><cryptoapi><client-certificates><e-token>","1","0","2","2016-11-14 10:23:29","23688976","0","5","-1","","2017-05-23 12:13:40","2014-05-07 18:15:20",""
"23525241","How to access a url that requires a SafeNet eToken certificate using Java","<p>Good afternoon,</p>

<p>I have a SafeNet 5100 eToken already with a valid certificate in it that I use to access a web application from my company that requires it.</p>

<p>When I try to access the web application using a web browser (like chrome) everything works fine and I have no problem. A dialog from SafeNet opens up, I put in my password and I am able to access the site.</p>

<p>What I'm trying to do now is to access this web application through a java program (I'm programming it using the IDE eclipse) and couldn't find how to do this. Is there any API from SafeNet to do this or any online tutorials?</p>

<p>I was looking at this thread <a href=""https://stackoverflow.com/questions/13320685/how-to-use-microsoft-crypto-api-with-usb-dongle-following-pkcs11/13647517#13647517"">how to use Microsoft Crypto API with USB Dongle following PKCS#11</a>, but couldn't understand how this <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380252%28v=vs.85%29.aspx#csp_functions"" rel=""nofollow noreferrer"">CryptoAPI CSP</a> works. Any help is appreciated.</p>

<p>Thank you</p>
","<p>I found out how to do this thanks to these two threads:</p>

<p><a href=""https://stackoverflow.com/questions/23665092/how-to-get-keystore-from-usb-token-in-java"">How to get KeyStore from usb token in Java</a><br>
<a href=""https://stackoverflow.com/questions/8247115/java-keytool-with-opensc-pkcs11-provider-only-works-with-debug-option-enabled"">java keytool with opensc pkcs#11 provider only works with debug option enabled</a></p>

<p>And this website:</p>

<p><a href=""http://prenninger.com/wp/pdf-signing-using-etoken-in-java-en"" rel=""nofollow noreferrer"">Pdf Signing Using eToken in java</a></p>

<p>First, if the website has a certificate java doesn't trust by default you have to create a trustStore and load it to java's System properties. you can see how to do it in here:</p>

<p><a href=""http://docs.oracle.com/cd/E19509-01/820-3503/ggfgo/index.html"" rel=""nofollow noreferrer"">Oracle - Generating a KeyStore and TrustStore (using keytool)</a></p>

<p>Than you have to find where the PKCS#11 library used for your smartCard/eToken is installed in your computer, in mine it is in ""C:\Windows\System32\eTPKCS11.dll"". Then create a .cfg file like this:</p>

<pre><code>name=SafeNet
library=C:\Windows\System32\eTPKCS11.dll
slot=4
</code></pre>

<p>Where you give it a name and the path to your PKCS#11 library. Slot is the slot where your eToken/SmartCard is connected (you don't need to set this if you don't want).</p>

<p>Now my code looks like this:</p>

<pre><code>System.setProperty(""javax.net.ssl.trustStore"", ""cfgFiles/trustedHttpsCertificates.truestore"");
System.setProperty(""javax.net.ssl.trustStoreType"", ""jks"");
System.setProperty(""javax.net.ssl.trustStorePassword"", ""oiadad"");

Provider newProvider = new SunPKCS11(""cfgFiles/etpkcs11.cfg"");
Security.addProvider(newProvider);

try {
    KeyStore keyStore = KeyStore.getInstance(""PKCS11"");
    keyStore.load(null, """".toCharArray());

    KeyManagerFactory keyFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    keyFactory.init(keyStore,null);

    SSLContext sslContext = SSLContext.getInstance(""SSL"", ""SunJSSE"");
    sslContext.init(keyFactory.getKeyManagers(), null, null);
    sslSocketFactory = sslContext.getSocketFactory();

} catch (KeyStoreException e) {
    e.printStackTrace();
} catch (NoSuchAlgorithmException e) {
    e.printStackTrace();
} catch (CertificateException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
} catch (NoSuchProviderException e) {
    e.printStackTrace();
} catch (UnrecoverableKeyException e1) {
    e1.printStackTrace();
} catch (KeyManagementException e1) {
    e1.printStackTrace();
}
</code></pre>

<p>I first tell java where to look for my trustStore. Then I pass the path to my cfg file, create a provider with it and tell security that this new provider exists.</p>

<p>After this I initialize and load a PKCS11 KeyStore giving it a blank password (could pass my real password if I wanted, but this way a SafeNet pop window shows up and asks me for my password).</p>

<p>Then I instantiate a KeyManagerFactory and a SSLSocketFactory. This is the last step to using your eToken to be able to access multi-factor authentication https urls.</p>

<p>Now there's just one more trick to access a protected https website, you have to give the HttpsURLConnection the new SSLSocketFactory. You can do it like this:</p>

<pre><code>try {
    HttpsURLConnection conn = (HttpsURLConnection)new URL(&lt;your-https-url-here&gt;).openConnection();
    conn.setRequestMethod(""GET"");
    conn.setDoInput(true);
    conn.setSSLSocketFactory(sslSocketFactory);

    int responseCode = conn.getResponseCode();
    System.out.println(""RESPONSE: "" + responseCode);

    InputStream inputstream = conn.getInputStream();
    InputStreamReader inputstreamreader = new InputStreamReader(inputstream);
    BufferedReader bufferedreader = new BufferedReader(inputstreamreader);

    String line = null;
    String htmlResponse = """";

    while ((line = bufferedreader.readLine()) != null) {
        htmlResponse += line + ""\n"";
        //System.out.println(""html: "" + line);
    }
} catch (ProtocolException e) {
    e.printStackTrace();
} catch (MalformedURLException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<p>I hope this helps anyone having problems with eTokens or SmartCards.</p>
","2935","<java><cryptoapi><client-certificates><e-token>","1","2","2","2016-11-14 10:23:29","23688976","0","5","-1","","2017-05-23 12:13:40","2014-05-07 18:15:20",""
"14553610","Is it possible for one process to inject code into another without administrative privileges?","<p>The <a href=""http://msdn.microsoft.com/en-us/library/aa380262%28v=vs.85%29.aspx"" rel=""noreferrer""><code>CryptProtectMemory</code></a> API in the DPAPI allows you to pass the <code>CRYPTPROTECTMEMORY_SAME_PROCESS</code> flag, which prevents other processes from decrypting the memory. One way around this would be to use <code>OpenProcess</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code> to inject code into the target process and have it call <code>CryptUnprotectMemory</code>, thus decrypting the memory and leaking it to the other process.</p>

<p>Assuming both processes are running under the context of the same limited privilege user (i.e. not an administrator) on Windows Vista or later, is this still possible? I was under the impression that process memory write operations were denied to limited users, regardless of the process ACL, but I may be wrong.</p>
","<p>Windows respects the process ACL, and by default, this allows access to the user the process is running as as well as to the local system account and the user's logon session SID.  Administrators can bypass this ACL using SeDebugPrivilege.</p>

<p>Otherwise, you would need to be an administrator in order to debug your own code.</p>

<p>You can change the process ACL, but since normally (IIRC) the current user is the process owner I'm not certain whether or not you can prevent another process in the current user context from changing it back.  Also, since it is likely that the processes are running on the same desktop, you would be subject to <a href=""http://en.wikipedia.org/wiki/Shatter_attack"" rel=""nofollow noreferrer"">shatter attacks</a> anyway.</p>
","2903","<windows><security><winapi><cryptoapi><dpapi>","5","2","2","2017-04-14 22:13:19","14554076","4","1","","","","2013-01-27 23:44:07",""
"14553610","Is it possible for one process to inject code into another without administrative privileges?","<p>The <a href=""http://msdn.microsoft.com/en-us/library/aa380262%28v=vs.85%29.aspx"" rel=""noreferrer""><code>CryptProtectMemory</code></a> API in the DPAPI allows you to pass the <code>CRYPTPROTECTMEMORY_SAME_PROCESS</code> flag, which prevents other processes from decrypting the memory. One way around this would be to use <code>OpenProcess</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code> to inject code into the target process and have it call <code>CryptUnprotectMemory</code>, thus decrypting the memory and leaking it to the other process.</p>

<p>Assuming both processes are running under the context of the same limited privilege user (i.e. not an administrator) on Windows Vista or later, is this still possible? I was under the impression that process memory write operations were denied to limited users, regardless of the process ACL, but I may be wrong.</p>
","<p>You don't describe the exact scenario in which you need to use code injection. If ope process running without administrative rights create another process with respect of <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms682425%28v=vs.85%29.aspx"" rel=""nofollow"">CreateProcess</a> for example one get handle on the new process with all rights <code>PROCESS_ALL_ACCESS</code> (<code>hProcess</code> of <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms684873%28v=vs.85%29.aspx"" rel=""nofollow"">PROCESS_INFORMATION</a>). You can read <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx"" rel=""nofollow"">here</a> for example the following</p>

<blockquote>
  <p>The handle returned by the <code>CreateProcess</code> function has
  <strong>PROCESS_ALL_ACCESS</strong> access to the process object.</p>
</blockquote>

<p>So one should just hold the handler returned from <code>CreateProcess</code> and don't close it till you need to have full access to the child process. In the way you will have PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights required to call <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx"" rel=""nofollow"">CreateRemoteThread</a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms681674%28v=vs.85%29.aspx"" rel=""nofollow"">WriteProcessMemory</a>.</p>

<p>So the answer on your question will be: ""Yes, it's possible under some additional conditions"".</p>
","2903","<windows><security><winapi><cryptoapi><dpapi>","5","2","2","2017-04-14 22:13:19","14554076","4","1","","","","2013-01-27 23:44:07",""
"10317494","Accessing MS CryptoAPI with java","<p>I was trying to make good use of the <a href=""http://en.wikipedia.org/wiki/Microsoft_CryptoAPI"" rel=""nofollow noreferrer"">MS CAPI</a>, and stumped into a great mischief... The SunMSCapi provider only, hmm, provides, per lack of better word, at least for signature, the following algorithms:    </p>

<ul>
<li>MD2withRSA</li>
<li>MD5withRSA</li>
<li>SHA1withRSA    </li>
</ul>

<p>And I am not eager to make use of algorithms such <strong><code>GOST3411withECGOST3410</code></strong>, or <strong><code>RIPEMD128withRSA</code></strong>, that BouncyCastle makes use, but it would be nice, and in this particular case, quite important if not essential, to be able to sign in, at least, the <strong><code>SHA256withRSA</code></strong> algorithm... (the 512 and so on and ECDSA encryption, would be a big plus, but i don't expect that much).</p>

<p>I am trying to find an alternative, but only found <a href=""http://pheox.com/products/jcapi/"" rel=""nofollow noreferrer"">this wrapper</a>, which looks fine, but I have to dig it a little more.</p>

<p>Does anyone knows another way, wrapper or provider to access mscapi (cryptoapi)?</p>

<hr>

<p>Related:</p>

<ul>
<li><p>SunMSCapi doc:<br>
<a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunMSCAPI"" rel=""nofollow noreferrer"">http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunMSCAPI</a></p></li>
<li><p>Request for <strong><code>SHA256withRSA</code></strong>:<br>
<a href=""http://bugs.sun.com/view_bug.do?bug_id=6753664"" rel=""nofollow noreferrer"">http://bugs.sun.com/view_bug.do?bug_id=6753664</a></p></li>
</ul>
","<p>Take a look at <a href=""https://community.emc.com/community/edn/rsashare"" rel=""nofollow"">RSA bsafe share</a> which supports RSA with SHA-256.</p>
","2859","<java><sha256><cryptoapi><mscapi>","8","1","2","2015-06-09 03:09:16","","5","2","608639","","2015-06-09 03:09:16","2012-04-25 14:11:26",""
"10317494","Accessing MS CryptoAPI with java","<p>I was trying to make good use of the <a href=""http://en.wikipedia.org/wiki/Microsoft_CryptoAPI"" rel=""nofollow noreferrer"">MS CAPI</a>, and stumped into a great mischief... The SunMSCapi provider only, hmm, provides, per lack of better word, at least for signature, the following algorithms:    </p>

<ul>
<li>MD2withRSA</li>
<li>MD5withRSA</li>
<li>SHA1withRSA    </li>
</ul>

<p>And I am not eager to make use of algorithms such <strong><code>GOST3411withECGOST3410</code></strong>, or <strong><code>RIPEMD128withRSA</code></strong>, that BouncyCastle makes use, but it would be nice, and in this particular case, quite important if not essential, to be able to sign in, at least, the <strong><code>SHA256withRSA</code></strong> algorithm... (the 512 and so on and ECDSA encryption, would be a big plus, but i don't expect that much).</p>

<p>I am trying to find an alternative, but only found <a href=""http://pheox.com/products/jcapi/"" rel=""nofollow noreferrer"">this wrapper</a>, which looks fine, but I have to dig it a little more.</p>

<p>Does anyone knows another way, wrapper or provider to access mscapi (cryptoapi)?</p>

<hr>

<p>Related:</p>

<ul>
<li><p>SunMSCapi doc:<br>
<a href=""http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunMSCAPI"" rel=""nofollow noreferrer"">http://docs.oracle.com/javase/6/docs/technotes/guides/security/SunProviders.html#SunMSCAPI</a></p></li>
<li><p>Request for <strong><code>SHA256withRSA</code></strong>:<br>
<a href=""http://bugs.sun.com/view_bug.do?bug_id=6753664"" rel=""nofollow noreferrer"">http://bugs.sun.com/view_bug.do?bug_id=6753664</a></p></li>
</ul>
","<p>Java is cross platform, if you choose SunMSCapi, you can only run on windows with JDK 6+, and if want SHA256withRSA, you need run on JDK7+, it is there.
check code <a href=""http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/security/mscapi/RSASignature.java#RSASignature.SHA256"" rel=""nofollow"">RSASignature.SHA256</a></p>
","2859","<java><sha256><cryptoapi><mscapi>","8","1","2","2015-06-09 03:09:16","","5","2","608639","","2015-06-09 03:09:16","2012-04-25 14:11:26",""
"2378060","How do I sign my certificate using the root certificate","<p>I am using certificate based authentication between my server and client. I have generated Root Certificate. My client at the time of installation will generate a new Certificate and use the Root Certificate to sign it. I need to use Windows API. Cannot use any windows tools like makecert.</p>

<p>Till now I have been able to Install the Root certificate in store. Below code</p>

<pre><code>X509Certificate2 ^ certificate = gcnew X509Certificate2(""C:\\rootcert.pfx"",""test123"");
X509Store ^ store = gcnew X509Store( ""teststore"",StoreLocation::CurrentUser );
store-&gt;Open( OpenFlags::ReadWrite );
store-&gt;Add( certificate );
store-&gt;Close();
</code></pre>

<p>Then open the installed root certificate to get the context</p>

<pre><code>GetRootCertKeyInfo(){
  HCERTSTORE hCertStore;
  PCCERT_CONTEXT pSignerCertContext=NULL;
  DWORD dwSize = NULL; 
  CRYPT_KEY_PROV_INFO* pKeyInfo = NULL; 
  DWORD dwKeySpec;
  if ( !( hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL,  CERT_SYSTEM_STORE_CURRENT_USER,L""teststore"")))
  {
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
  }
  pSignerCertContext = CertFindCertificateInStore(hCertStore,MY_ENCODING_TYPE,0,CERT_FIND_ANY,NULL,NULL);

if(NULL == pSignerCertContext)
{
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
}

if(!(CertGetCertificateContextProperty( pSignerCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &amp;dwSize))) 
{ 
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
} 

if(pKeyInfo) 
   free(pKeyInfo); 
if(!(pKeyInfo = (CRYPT_KEY_PROV_INFO*)malloc(dwSize))) 
{ 
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
} 


if(!(CertGetCertificateContextProperty( pSignerCertContext, CERT_KEY_PROV_INFO_PROP_ID, pKeyInfo, &amp;dwSize))) 
{    
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
}
return pKeyInfo;
}
</code></pre>

<p>Then finally created the certificate and signed with the pKeyInfo</p>

<pre><code>    // Acquire key container
if (!CryptAcquireContext(&amp;hCryptProv, _T(""trykeycon""), NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
{
  _tprintf(_T(""Error 0x%x\n""), GetLastError());

  // Try to create a new key container
  _tprintf(_T(""CryptAcquireContext... ""));
  if (!CryptAcquireContext(&amp;hCryptProv, _T(""trykeycon""), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET))
  {
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
    return 0;
  }
  else 
  {
    _tprintf(_T(""Success\n""));
  }
}
else
{
  _tprintf(_T(""Success\n""));
}

// Generate new key pair
_tprintf(_T(""CryptGenKey... ""));
if (!CryptGenKey(hCryptProv, AT_SIGNATURE, 0x08000000 /*RSA-2048-BIT_KEY*/, &amp;hKey))
{
  _tprintf(_T(""Error 0x%x\n""), GetLastError());
  return 0;
}
else
{
  _tprintf(_T(""Success\n""));
}
//some code
    CERT_NAME_BLOB SubjectIssuerBlob;
memset(&amp;SubjectIssuerBlob, 0, sizeof(SubjectIssuerBlob));
SubjectIssuerBlob.cbData = cbEncoded;
SubjectIssuerBlob.pbData = pbEncoded;

// Prepare algorithm structure for self-signed certificate
CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
memset(&amp;SignatureAlgorithm, 0, sizeof(SignatureAlgorithm));
SignatureAlgorithm.pszObjId = szOID_RSA_SHA1RSA;

// Prepare Expiration date for self-signed certificate
SYSTEMTIME EndTime;
GetSystemTime(&amp;EndTime);
EndTime.wYear += 5;

// Create self-signed certificate
_tprintf(_T(""CertCreateSelfSignCertificate... ""));

CRYPT_KEY_PROV_INFO* aKeyInfo;
aKeyInfo = GetRootCertKeyInfo();
pCertContext = CertCreateSelfSignCertificate(NULL, &amp;SubjectIssuerBlob, 0, aKeyInfo, &amp;SignatureAlgorithm, 0, &amp;EndTime, 0);
</code></pre>

<p>With the above code I am able to create the certificate but it does not looks be signed by the root certificate. I am unable to figure what I did is right or not..
Any help with be greatly appreciated..</p>

<p>Thanks
Asif</p>
","<p>I don't think a self-signed certificate is what you need here.  You want to create a new ""client"" certificate that is signed by your ""root"" certificate, correct?  I think you need to use CryptSignAndEncodeCertificate to do this.</p>
","2824","<c++><windows><cryptoapi>","1","1","2","2010-06-18 01:00:20","","1","0","265143","","2010-03-04 09:25:34","2010-03-04 09:24:20",""
"2378060","How do I sign my certificate using the root certificate","<p>I am using certificate based authentication between my server and client. I have generated Root Certificate. My client at the time of installation will generate a new Certificate and use the Root Certificate to sign it. I need to use Windows API. Cannot use any windows tools like makecert.</p>

<p>Till now I have been able to Install the Root certificate in store. Below code</p>

<pre><code>X509Certificate2 ^ certificate = gcnew X509Certificate2(""C:\\rootcert.pfx"",""test123"");
X509Store ^ store = gcnew X509Store( ""teststore"",StoreLocation::CurrentUser );
store-&gt;Open( OpenFlags::ReadWrite );
store-&gt;Add( certificate );
store-&gt;Close();
</code></pre>

<p>Then open the installed root certificate to get the context</p>

<pre><code>GetRootCertKeyInfo(){
  HCERTSTORE hCertStore;
  PCCERT_CONTEXT pSignerCertContext=NULL;
  DWORD dwSize = NULL; 
  CRYPT_KEY_PROV_INFO* pKeyInfo = NULL; 
  DWORD dwKeySpec;
  if ( !( hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL,  CERT_SYSTEM_STORE_CURRENT_USER,L""teststore"")))
  {
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
  }
  pSignerCertContext = CertFindCertificateInStore(hCertStore,MY_ENCODING_TYPE,0,CERT_FIND_ANY,NULL,NULL);

if(NULL == pSignerCertContext)
{
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
}

if(!(CertGetCertificateContextProperty( pSignerCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &amp;dwSize))) 
{ 
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
} 

if(pKeyInfo) 
   free(pKeyInfo); 
if(!(pKeyInfo = (CRYPT_KEY_PROV_INFO*)malloc(dwSize))) 
{ 
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
} 


if(!(CertGetCertificateContextProperty( pSignerCertContext, CERT_KEY_PROV_INFO_PROP_ID, pKeyInfo, &amp;dwSize))) 
{    
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
}
return pKeyInfo;
}
</code></pre>

<p>Then finally created the certificate and signed with the pKeyInfo</p>

<pre><code>    // Acquire key container
if (!CryptAcquireContext(&amp;hCryptProv, _T(""trykeycon""), NULL, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET)) 
{
  _tprintf(_T(""Error 0x%x\n""), GetLastError());

  // Try to create a new key container
  _tprintf(_T(""CryptAcquireContext... ""));
  if (!CryptAcquireContext(&amp;hCryptProv, _T(""trykeycon""), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET))
  {
    _tprintf(_T(""Error 0x%x\n""), GetLastError());
    return 0;
  }
  else 
  {
    _tprintf(_T(""Success\n""));
  }
}
else
{
  _tprintf(_T(""Success\n""));
}

// Generate new key pair
_tprintf(_T(""CryptGenKey... ""));
if (!CryptGenKey(hCryptProv, AT_SIGNATURE, 0x08000000 /*RSA-2048-BIT_KEY*/, &amp;hKey))
{
  _tprintf(_T(""Error 0x%x\n""), GetLastError());
  return 0;
}
else
{
  _tprintf(_T(""Success\n""));
}
//some code
    CERT_NAME_BLOB SubjectIssuerBlob;
memset(&amp;SubjectIssuerBlob, 0, sizeof(SubjectIssuerBlob));
SubjectIssuerBlob.cbData = cbEncoded;
SubjectIssuerBlob.pbData = pbEncoded;

// Prepare algorithm structure for self-signed certificate
CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
memset(&amp;SignatureAlgorithm, 0, sizeof(SignatureAlgorithm));
SignatureAlgorithm.pszObjId = szOID_RSA_SHA1RSA;

// Prepare Expiration date for self-signed certificate
SYSTEMTIME EndTime;
GetSystemTime(&amp;EndTime);
EndTime.wYear += 5;

// Create self-signed certificate
_tprintf(_T(""CertCreateSelfSignCertificate... ""));

CRYPT_KEY_PROV_INFO* aKeyInfo;
aKeyInfo = GetRootCertKeyInfo();
pCertContext = CertCreateSelfSignCertificate(NULL, &amp;SubjectIssuerBlob, 0, aKeyInfo, &amp;SignatureAlgorithm, 0, &amp;EndTime, 0);
</code></pre>

<p>With the above code I am able to create the certificate but it does not looks be signed by the root certificate. I am unable to figure what I did is right or not..
Any help with be greatly appreciated..</p>

<p>Thanks
Asif</p>
","<p>First of all some years ago I wrote some product which contain also the full code what you asked for: creating of a new certificate and signing it with respect of other root certificate. This code use only <em>Microsoft CryptoAPI</em>. But before I give you detailed answer or post some code I want to know, whether your problem is actual: your question is one and half months old.</p>

<p>In general to do what you want, one should not use <code>CertCreateSelfSignCertificate()</code> function, but create a certificate with respect of other CryptoAPIs. <code>CertCreateSelfSignCertificate()</code> function can only be used to create and to sign a self-signed certificate. It can not sign a certificate with other certificate which you created. Moreover <code>CertCreateSelfSignCertificate()</code> function have (or at least had some years before) a hard restriction to the length of created private key. Thus one have to make the same things which <code>CertCreateSelfSignCertificate()</code> function do manually. The last API in the chain of API what one do is <code>CryptSignAndEncodeCertificate()</code> like wrote in another answer Luke on your question.</p>

<p>Moreover I have a large suspect, that for your purpose creating a certificate chain is not correct way. If you need to do this only for authentication, you don't need create a certificate on the client side. It seems to me, that it will be enough working with singed messages. One use certificates instead of key pair is cases where you need features like key revocation or key restriction for usage for some purpose only (for example only for code signing and not for data encryption).</p>

<p>If you really needs implement certificated based authentication, then at least you have to create a certificate of the client computer, send it to the server computer and sing client certificate on the server computer, because only server computer could hold a private key of root certificate.</p>

<p>It can be also that you can implement your requirement with respect of the <em>Certificate Enrollment API</em>? It will be not exactly what you asked for, but it can solve your main problem.</p>

<p><strong>Answer on additional questions (comments)</strong>:
Either I don't understand the construct which you plan to realize as ""2 way authentication"" or the concept is wrong.</p>

<ol>
<li>I don't understand how and when you plan transport root client certificate from all clients to server. </li>
<li>You want to sign client certificate with clients root CA, so you have to hold on the client the private key of the client's root CA certificate (!!!???).</li>
<li>If server don't have any verified information about the client like its root CA certificate, than you can not really use client certificate for client's authorization. Any client with a certificate will be ""authorized"".</li>
<li>With the standard SSL without client certificate you can be sure that you communicate all the time with the same client. So if you don't solve the problem of clients root CA transport to the server you will be not able to achieve more security as in the standard (without client certificate) SSL.</li>
<li>What you wrote seems like you try not to use a standard communication protocol between server and client. Instead of that you try to introduce a new own protocol. It is <strong>VERY</strong> dangerous! If you not a cryptography expert, you will realize a protocol which <strong>only looks like safe</strong> and not be so. ""SMALL"" problems like holding of private key and safe transport of public key from client to server or back are very important cryptographic subjects. There are different cryptographic protocols to solve there. So don't try to implement something new in this area!</li>
<li>Think one more about why you really want use client certificate. Are you really implement client authentication with the way? In standard SSL, for example, one can be sure that one communicate all time with the same client and use for this only a random nonces and a symmetric key generated for the session. Do you want generate a certificate per client or per session?</li>
</ol>

<p>I can write more my questions. If you implement his own certificate based communication protocol I have large problems to give my recommendation before I understand you concept.</p>
","2824","<c++><windows><cryptoapi>","1","1","2","2010-06-18 01:00:20","","1","0","265143","","2010-03-04 09:25:34","2010-03-04 09:24:20",""
"9718533","How to use Windows Crypto API to create rsa-sha1 signature for XMLDSIG","<p>Assume a XMLDSig document SignedInfo as follow:</p>

<pre><code>&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;
  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;
  &lt;Reference URI=""#object""&gt;
    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;
    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;
  &lt;/Reference&gt;
&lt;/SignedInfo&gt;
</code></pre>

<p>The SHA1 of the above SignedInfo node is</p>

<pre><code>5a c8 ef ab 04 5a 9a 46 fe 00 1a c5 8c 25 36 46 ff 88 dc 6a
</code></pre>

<p>To generate the SignatureValue in Windows CryptoAPI, I run this:</p>

<pre><code>var hProv: HCRYPTPROV;
    hHash: HCRYPTHASH;
    hKey: HCRYPTKEY;
    s: string;
    B, bSign: TBytes;
    bPrefix, bPubKeyModulus, bExp: TBytes;
    iFFLen, iPos, iSize, iHashSize: Cardinal;
    PubKey: TRsaPubKey;
begin
  s := '&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;' + #$0A +
       '  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;' + #$0A +
       '  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;' + #$0A +
       '  &lt;Reference URI=""#object""&gt;' + #$0A +
       '    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;' + #$0A +
       '    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;' + #$0A +
       '  &lt;/Reference&gt;' + #$0A +
       '&lt;/SignedInfo&gt;';

  B := TEncoding.ANSI.GetBytes(s);

  {get context for crypt default provider}
  Win32Check(CryptAcquireContext(hProv, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));
  try
    Win32Check(CryptGenKey(hProv, AT_SIGNATURE, RSA1024BIT_KEY or CRYPT_EXPORTABLE or ALG_SID_RSA_PKCS, hKey));

    {create hash-object (SHA algorithm)}
    Win32Check(CryptCreateHash(hProv, CALG_SHA1, 0, 0, hHash));

    Win32Check(CryptHashData(hHash, @B[0], Length(B), 0));

    // Obtain hash size
    iSize := SizeOf(iSize);
    SetLength(B, iSize);
    Win32Check(CryptGetHashParam(hHash, HP_HASHSIZE, @B[0], iSize, 0));
    Move(B[0], iSize, iSize);

    // obtain hash value
    SetLength(B, iSize);
    Win32Check(CryptGetHashParam(hHash, HP_HASHVAL, @B[0], iSize, 0));

    Print('Hex: ' + ToHex(B));
    Print('Base64: ' + ToBase64(B));

    // Signature of Hash
    Win32Check(CryptSignHash(hHash, AT_SIGNATURE, nil, 0, nil, iSize));
    SetLength(bSign, iSize);
    Win32Check(CryptSignHash(hHash, AT_SIGNATURE, nil, 0, @bSign[0], iSize));

    Print;
    Print('Signature: ');
    Print(ToBase64(Reverse(bSign)));

    // Public key
    Win32Check(CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, nil, iSize));

    SetLength(B, iSize);
    Win32Check(CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, @B[0], iSize));

    Print;
    Print('Public Key: ');
    Print(ToHexASCII(B));

    Move(B[SizeOf(TPublicKeyStruc)], PubKey, SizeOf(PubKey));

    // Public key: Get Modulus
    SetLength(bPubKeyModulus, PubKey.bitlen div 8);
    Move(B[SizeOf(TPublicKeyStruc) + SizeOf(TRsaPubKey)], bPubKeyModulus[0], Length(bPubKeyModulus));
    Print;
    Print('Modulus: ');
    Print(ToHex(bPubKeyModulus));
    Print;
    Print(ToBase64(bPubKeyModulus));

    // Public key: Get Exponent
    Print;
    Print('Exponent: ');
    Print(IntToStr(PubKey.pubexp));
    SetLength(bExp, SizeOf(PubKey.pubexp));
    Move(PubKey.pubexp, bExp[0], Length(bExp));
    while bExp[Length(bExp) - 1] = 0 do
      SetLength(bExp, Length(bExp) - 1);
    Print('Base64: ' + ToBase64(bExp));

    Print;
    if CryptVerifySignature(hHash, @bSign[0], Length(bSign), hKey, nil, 0) then
      Print('signature verified')
    else
      RaiseLastOSError;

    Win32Check(CryptDestroyKey(hKey));

    {destroy hash-object}
    Win32Check(CryptDestroyHash(hHash));
  finally
    {release the context for crypt default provider}
    Win32Check(CryptReleaseContext(hProv, 0));
  end;
end;
</code></pre>

<p>I am able to generate a signature and verify it using CryptoAPI that I am not sure if I am performing according to XMLDSig specification.</p>

<p>To further verify if I am doing it right, I try the online verifier: <a href=""http://www.aleksey.com/xmlsec/xmldsig-verifier.html"" rel=""nofollow"">http://www.aleksey.com/xmlsec/xmldsig-verifier.html</a></p>

<p>I replace the modulus and SignatureValue of the following XMLDSig document and verify it with the online verifier:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;
  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;
  &lt;Reference URI=""#object""&gt;
    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;
    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;
  &lt;/Reference&gt;
&lt;/SignedInfo&gt;
&lt;SignatureValue&gt;nihUFQg4mDhLgecvhIcKb9Gz8VRTOlw+adiZOBBXgK4JodEe5aFfCqm8WcRIT8GLLXSk8PsUP4//SsKqUBQkpotcAqQAhtz2v9kCWdoUDnAOtFZkd/CnsZ1sge0ndha40wWDV+nOWyJxkYgicvB8POYtSmldLLepPGMz+J7/Uws=&lt;/SignatureValue&gt;
&lt;KeyInfo&gt;
  &lt;KeyValue&gt;
    &lt;RSAKeyValue&gt;&lt;Modulus&gt;4IlzOY3Y9fXoh3Y5f06wBbtTg94Pt6vcfcd1KQ0FLm0S36aGJtTSb6pYKfyX7PqCUQ8wgL6xUJ5GRPEsu9gyz8ZobwfZsGCsvu40CWoT9fcFBZPfXro1Vtlh/xl/yYHm+Gzqh0Bw76xtLHSfLfpVOrmZdwKmSFKMTvNXOFd0V18=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;
  &lt;/KeyValue&gt;
&lt;/KeyInfo&gt;
&lt;Object xmlns=""http://www.w3.org/2000/09/xmldsig#"" Id=""object""&gt;some text
  with spaces and CR-LF.&lt;/Object&gt;
&lt;/Signature&gt;
</code></pre>

<p>And obviously it fail.</p>

<p>I think I didn't generate the signature value correctly.</p>
","<p>If you really need to verify XMLDSig document in native code and not in .NET I would recommend you to use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms757845%28v=vs.85%29.aspx"" rel=""nofollow"">MSXML 5.0</a>. See <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms759168%28v=vs.85%29.aspx"" rel=""nofollow"">the code example</a> to verify signature and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms754582%28v=vs.85%29.aspx"" rel=""nofollow"">another one</a> to create the signature.</p>
","2803","<xml><cryptoapi><xml-signature>","0","1","2","2012-03-16 03:20:21","9731366","0","","","","","2012-03-15 11:13:07",""
"9718533","How to use Windows Crypto API to create rsa-sha1 signature for XMLDSIG","<p>Assume a XMLDSig document SignedInfo as follow:</p>

<pre><code>&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;
  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;
  &lt;Reference URI=""#object""&gt;
    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;
    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;
  &lt;/Reference&gt;
&lt;/SignedInfo&gt;
</code></pre>

<p>The SHA1 of the above SignedInfo node is</p>

<pre><code>5a c8 ef ab 04 5a 9a 46 fe 00 1a c5 8c 25 36 46 ff 88 dc 6a
</code></pre>

<p>To generate the SignatureValue in Windows CryptoAPI, I run this:</p>

<pre><code>var hProv: HCRYPTPROV;
    hHash: HCRYPTHASH;
    hKey: HCRYPTKEY;
    s: string;
    B, bSign: TBytes;
    bPrefix, bPubKeyModulus, bExp: TBytes;
    iFFLen, iPos, iSize, iHashSize: Cardinal;
    PubKey: TRsaPubKey;
begin
  s := '&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;' + #$0A +
       '  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;' + #$0A +
       '  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;' + #$0A +
       '  &lt;Reference URI=""#object""&gt;' + #$0A +
       '    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;' + #$0A +
       '    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;' + #$0A +
       '  &lt;/Reference&gt;' + #$0A +
       '&lt;/SignedInfo&gt;';

  B := TEncoding.ANSI.GetBytes(s);

  {get context for crypt default provider}
  Win32Check(CryptAcquireContext(hProv, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));
  try
    Win32Check(CryptGenKey(hProv, AT_SIGNATURE, RSA1024BIT_KEY or CRYPT_EXPORTABLE or ALG_SID_RSA_PKCS, hKey));

    {create hash-object (SHA algorithm)}
    Win32Check(CryptCreateHash(hProv, CALG_SHA1, 0, 0, hHash));

    Win32Check(CryptHashData(hHash, @B[0], Length(B), 0));

    // Obtain hash size
    iSize := SizeOf(iSize);
    SetLength(B, iSize);
    Win32Check(CryptGetHashParam(hHash, HP_HASHSIZE, @B[0], iSize, 0));
    Move(B[0], iSize, iSize);

    // obtain hash value
    SetLength(B, iSize);
    Win32Check(CryptGetHashParam(hHash, HP_HASHVAL, @B[0], iSize, 0));

    Print('Hex: ' + ToHex(B));
    Print('Base64: ' + ToBase64(B));

    // Signature of Hash
    Win32Check(CryptSignHash(hHash, AT_SIGNATURE, nil, 0, nil, iSize));
    SetLength(bSign, iSize);
    Win32Check(CryptSignHash(hHash, AT_SIGNATURE, nil, 0, @bSign[0], iSize));

    Print;
    Print('Signature: ');
    Print(ToBase64(Reverse(bSign)));

    // Public key
    Win32Check(CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, nil, iSize));

    SetLength(B, iSize);
    Win32Check(CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, @B[0], iSize));

    Print;
    Print('Public Key: ');
    Print(ToHexASCII(B));

    Move(B[SizeOf(TPublicKeyStruc)], PubKey, SizeOf(PubKey));

    // Public key: Get Modulus
    SetLength(bPubKeyModulus, PubKey.bitlen div 8);
    Move(B[SizeOf(TPublicKeyStruc) + SizeOf(TRsaPubKey)], bPubKeyModulus[0], Length(bPubKeyModulus));
    Print;
    Print('Modulus: ');
    Print(ToHex(bPubKeyModulus));
    Print;
    Print(ToBase64(bPubKeyModulus));

    // Public key: Get Exponent
    Print;
    Print('Exponent: ');
    Print(IntToStr(PubKey.pubexp));
    SetLength(bExp, SizeOf(PubKey.pubexp));
    Move(PubKey.pubexp, bExp[0], Length(bExp));
    while bExp[Length(bExp) - 1] = 0 do
      SetLength(bExp, Length(bExp) - 1);
    Print('Base64: ' + ToBase64(bExp));

    Print;
    if CryptVerifySignature(hHash, @bSign[0], Length(bSign), hKey, nil, 0) then
      Print('signature verified')
    else
      RaiseLastOSError;

    Win32Check(CryptDestroyKey(hKey));

    {destroy hash-object}
    Win32Check(CryptDestroyHash(hHash));
  finally
    {release the context for crypt default provider}
    Win32Check(CryptReleaseContext(hProv, 0));
  end;
end;
</code></pre>

<p>I am able to generate a signature and verify it using CryptoAPI that I am not sure if I am performing according to XMLDSig specification.</p>

<p>To further verify if I am doing it right, I try the online verifier: <a href=""http://www.aleksey.com/xmlsec/xmldsig-verifier.html"" rel=""nofollow"">http://www.aleksey.com/xmlsec/xmldsig-verifier.html</a></p>

<p>I replace the modulus and SignatureValue of the following XMLDSig document and verify it with the online verifier:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;Signature xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
&lt;SignedInfo xmlns=""http://www.w3.org/2000/09/xmldsig#""&gt;
  &lt;CanonicalizationMethod Algorithm=""http://www.w3.org/TR/2001/REC-xml-c14n-20010315""&gt;&lt;/CanonicalizationMethod&gt;
  &lt;SignatureMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#rsa-sha1""&gt;&lt;/SignatureMethod&gt;
  &lt;Reference URI=""#object""&gt;
    &lt;DigestMethod Algorithm=""http://www.w3.org/2000/09/xmldsig#sha1""&gt;&lt;/DigestMethod&gt;
    &lt;DigestValue&gt;OPnpF/ZNLDxJ/I+1F3iHhlmSwgo=&lt;/DigestValue&gt;
  &lt;/Reference&gt;
&lt;/SignedInfo&gt;
&lt;SignatureValue&gt;nihUFQg4mDhLgecvhIcKb9Gz8VRTOlw+adiZOBBXgK4JodEe5aFfCqm8WcRIT8GLLXSk8PsUP4//SsKqUBQkpotcAqQAhtz2v9kCWdoUDnAOtFZkd/CnsZ1sge0ndha40wWDV+nOWyJxkYgicvB8POYtSmldLLepPGMz+J7/Uws=&lt;/SignatureValue&gt;
&lt;KeyInfo&gt;
  &lt;KeyValue&gt;
    &lt;RSAKeyValue&gt;&lt;Modulus&gt;4IlzOY3Y9fXoh3Y5f06wBbtTg94Pt6vcfcd1KQ0FLm0S36aGJtTSb6pYKfyX7PqCUQ8wgL6xUJ5GRPEsu9gyz8ZobwfZsGCsvu40CWoT9fcFBZPfXro1Vtlh/xl/yYHm+Gzqh0Bw76xtLHSfLfpVOrmZdwKmSFKMTvNXOFd0V18=&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;
  &lt;/KeyValue&gt;
&lt;/KeyInfo&gt;
&lt;Object xmlns=""http://www.w3.org/2000/09/xmldsig#"" Id=""object""&gt;some text
  with spaces and CR-LF.&lt;/Object&gt;
&lt;/Signature&gt;
</code></pre>

<p>And obviously it fail.</p>

<p>I think I didn't generate the signature value correctly.</p>
","<p>I got it work finally.  It was the endian problem at last.  Microsoft CryptoAPI present modulus and signature value in Little Endian bit string.  While the XMLDSIG specification presents in Big Endian bit string.</p>

<p>After obtaining modulus and signature value from CryptoAPI functions, just convert it to Big Endian bit string by reversing the bytes orders:</p>

<pre><code>function Reverse(A: TBytes): TBytes;
var B: Byte;
    i: integer;
begin
  SetLength(Result, Length(A));
  i := Length(A) - 1;
  for B in A do begin
    Result[i] := B;
    Dec(i);
  end;
end;

Print(ToBase64(reverse(bSign)));
Print(ToBase64(reverse(bPubKeyModulus)));
</code></pre>
","2803","<xml><cryptoapi><xml-signature>","0","1","2","2012-03-16 03:20:21","9731366","0","","","","","2012-03-15 11:13:07",""
"12120862","Extracting modulus and exponent from public key using Openssl and C++","<p>So I'm currently studying how networking works. I've got a bunch of packets from wireshark which I have already copied in buffers(only the content, without header. Wireshark->Follow TPC Stream->C arrays). I can understand the protocol but in the 3rd packet it requires a key exchange. After some googling I found that I need RSA encryption. It sends me a public key + token. And I shoud return encrypted shared key(just generated) and encrypted token which I received earlier. </p>

<p>RSA_key needs exponent and modulus, So my question is: How can I create RSA_key object from single char[] buffer(the public key).</p>

<p>NOTE:I'm posting here after long time googling. I may not be using the right keywords because I'm not english speaker. I could find threads asking this with php only. 
The most useful (I think) link I found is <a href=""http://www.techper.net/2012/06/01/converting-rsa-public-key-modulus-and-exponent-into-pem-file/"" rel=""nofollow"">http://www.techper.net/2012/06/01/converting-rsa-public-key-modulus-and-exponent-into-pem-file/</a></p>

<p>Thanks.</p>

<p>P.S. I'm sniffing minecraft and simulating client side(I choosed it because its popular game and I knew I will find resources on the web if I get stuck). However my question is exacly <strong>how to get modulus and exponent from a public key</strong> with format: <a href=""http://pastebin.com/J9ddhgW5"" rel=""nofollow"">http://pastebin.com/J9ddhgW5</a> (thats the bytes representing the public key)</p>

<p>Ohh I forgot, first column is the byte position, second column is the byte value typecasted to int, 3th column is again value but (int)(unsigned char) so I can see if its +127, 4th colums is the hex representation of the value and the last column is character based on ascii table(if its visible character).</p>
","<p>The data you posted is an ASN.1 encoded (DER) RSA public key:</p>

<pre><code>$ openssl ssl rsa -inform der -pubin -text &lt; 12120862.key 
Public-Key: (1024 bit)
Modulus:
    00:81:1f:1d:00:7e:d0:c7:e2:2f:31:3d:0d:f0:a8:
    ab:c1:ea:66:ba:af:1d:a4:eb:b3:fd:51:58:1c:1d:
    81:ae:f0:99:9e:5c:26:67:b5:41:14:28:79:c0:29:
    e5:56:96:06:b7:4b:a0:c9:7f:41:46:9a:7e:85:10:
    a0:91:ea:58:bd:78:78:6d:3c:07:2a:3d:61:f3:ed:
    42:8b:1e:dc:6d:2d:21:41:7a:e8:15:51:0d:75:84:
    be:20:8c:76:43:8b:4b:67:6b:49:09:e9:20:a1:11:
    53:a0:d9:30:b1:c2:27:a6:09:e1:56:36:ed:7e:9b:
    23:e2:df:5b:bd:c5:66:ca:c5
Exponent: 65537 (0x10001)
writing RSA key
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCBHx0AftDH4i8xPQ3wqKvB6ma6
rx2k67P9UVgcHYGu8JmeXCZntUEUKHnAKeVWlga3S6DJf0FGmn6FEKCR6li9eHht
PAcqPWHz7UKLHtxtLSFBeugVUQ11hL4gjHZDi0tna0kJ6SChEVOg2TCxwiemCeFW
Nu1+myPi31u9xWbKxQIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>In OpenSSL, you can use the <code>d2i_RSA_PUBKEY</code> function to get a public key from an ASN.1-encoded file (like this one).</p>
","2797","<c++><cryptoapi>","1","1","1","2012-08-26 06:05:51","12127943","1","1","1624322","","2012-08-26 05:39:26","2012-08-25 09:41:15",""
"28118169","Invalid AES Key length:39bytes","<p>I am new to java. I am doing encryption and decryption of video files. When I provide a key of small length it works fine without any error. If I gave key of greater length it throws error.</p>

<pre><code>private static void doCrypto(int cipherMode, String key, File inputFile,
        File outputFile) throws CryptoException {
    try {    
        Key secretKey = new SecretKeySpec(key.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(cipherMode, secretKey);         
        FileInputStream inputStream = new FileInputStream(inputFile);

        byte[] inputBytes = new byte[(int) inputFile.length()];
        inputStream.read(inputBytes);

        byte[] outputBytes = cipher.doFinal(inputBytes);

        FileOutputStream outputStream = new FileOutputStream(outputFile);
        outputStream.write(outputBytes);            
        inputStream.close();
        outputStream.close();

    } catch(NoSuchPaddingException|NoSuchAlgorithmException|InvalidKeyException | BadPaddingException| IllegalBlockSizeException | IOException ex) {
        throw new CryptoException(""Error encrypting/decrypting file"",ex);
    }
</code></pre>

<p>I am getting the error caused by: <code>java.security.InvalidKeyException: Invalid AES key length: 39 bytes</code></p>

<p>Please help me to fix the error in the below code</p>
","<p>You need to use a specific key with a supported length, which means your key has to be either</p>

<ul>
<li>128 bit</li>
<li>192 bit</li>
<li>256 bit</li>
<li>...</li>
</ul>

<p>long. Yours is (see the error message) only 39 byte long.</p>

<p>So you need to convert the <code>String</code> (key) (or better <code>hash</code> the key before) into an array of <code>byte</code> and take the first n (where n is one of the values above) <code>byte</code> out of it.</p>

<pre><code>import java.security.*;

byte[] bytesOfMessage = key.getBytes(""UTF-8"");
MessageDigest md = MessageDigest.getInstance(""SHA-256"");
byte[] b = md.digest(bytesOfMessage); //Returns the SHA 256 hash and converts it into byte
// Continue with your code
Key secretKey = new SecretKeySpec(b , ""AES"");
...
</code></pre>
","2739","<java><aes><cryptoapi>","1","0","1","2015-01-23 21:39:58","28118288","0","","562139","","2015-01-23 20:38:39","2015-01-23 20:25:25",""
"441194","Does Microsoft Provides a PKCS #11 provider that connects to its own MS CryptoAPI?","<p>I'm looking to run some tests using the PKCS #11 interface and was wondering if Microsoft provided a software based implementation the provides PKCS #11 functionality?</p>

<p>Rather then waiting for a HSM to arrive and be properly configured I'd rather get started on testing interaction with the interface now.</p>
","<p>Microsoft does not. Microsoft has rejected PKCS11 in favor of the smart card minidriver/base smart card CSP. However, you can get smart cards with PKCS11 support from many vendors that will allow you to test code. Some even have ""softtokens"" that emulate a smart card. Note that most smartcards are quite limited as to what they support relative to a full HSM.</p>
","2714","<cryptoapi><pkcs#11><mscapi>","5","7","2","2019-07-30 12:05:53","1878463","0","","608639","","2015-06-09 03:10:25","2009-01-13 22:55:01",""
"441194","Does Microsoft Provides a PKCS #11 provider that connects to its own MS CryptoAPI?","<p>I'm looking to run some tests using the PKCS #11 interface and was wondering if Microsoft provided a software based implementation the provides PKCS #11 functionality?</p>

<p>Rather then waiting for a HSM to arrive and be properly configured I'd rather get started on testing interaction with the interface now.</p>
","<p>It´s not provided by Microsoft but you can use third parties implementations, for example:</p>

<ul>
<li><a href=""https://github.com/risacher/p11-capi"" rel=""nofollow noreferrer"">p11-capi</a></li>
<li><a href=""https://github.com/PeculiarVentures/pvpkcs11"" rel=""nofollow noreferrer"">pvpkcs11</a></li>
</ul>
","2714","<cryptoapi><pkcs#11><mscapi>","5","0","2","2019-07-30 12:05:53","1878463","0","","608639","","2015-06-09 03:10:25","2009-01-13 22:55:01",""
"14790930","How to export certificate from Windows certificate store via CryptoAPI as Base64 string","<p>i've got following C# code for doing what i asked for in subject:</p>

<pre><code>public static void ExportCertificatesToFile(string FileName)
{
    stringBuilder builder = new StringBuilder();

    X509Store storeMy = new X509Store(StoreName.My);
    storeMy.Open(OpenFlags.ReadOnly);

    foreach (X509Certificate2 cert in storeMy.Certificates)
    {
        builder.AppendLine(""-----BEGIN CERTIFICATE-----"");   
              builder.AppendLine(Convert.ToBase64String(cert.Export(X509ContentType.Cert),  Base64FormattingOptions.InsertLineBreaks));
        builder.AppendLine(""-----END CERTIFICATE-----"");
    }

    storeMy.Close();

    File.WriteAllText(FileName, builder.ToString());
}
</code></pre>

<p>Exactly that i want to archieve with Delphi using CryptoAPI (JwaWinCrypt.pas)
I've tried following code:</p>

<pre><code>procedure TForm1.Button1Click(Sender: TObject);
var
  hStore: HCERTSTORE;
  CertContext: PCertContext;
  pszString: PAnsiChar;
  pchString: Cardinal;
begin
  hStore := CertOpenSystemStore(0, PChar('MY'));

  try
    CertContext := CertEnumCertificatesInStore(hStore, nil);
    while CertContext &lt;&gt; nil do
    begin
      pszString := '';
      pchString := 0;
      CryptBinaryToString(CertContext.pbCertEncoded, CertContext.cbCertEncoded,  CRYPT_STRING_BASE64, pszString, pchString);

      ShowMessage(StrPas(pszString));

      CertContext := CertEnumCertificatesInStore(hStore, CertContext);
    end;
  finally
    CertCloseStore(hStore, 0);
  end;
end;
</code></pre>

<p>Problem is that ShowMessage shows nothing, the string is empty.
Has someone an idea what i do wrong?</p>
","<p>The documentation for <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/aa379887.aspx"" rel=""nofollow""><code>CryptBinaryToString</code></a> says this about the <code>pszString</code> parameter.</p>

<blockquote>
  <p>A pointer to a buffer that receives the converted string. To calculate the number of characters that must be allocated to hold the returned string, set this parameter to NULL. The function will place the required number of characters, including the terminating NULL character, in the value pointed to by pcchString.</p>
</blockquote>

<p>You are obliged to allocate the buffer so that the API function can populate it. You are failing to do so. In order to proceed you must read the documentation carefully and abide by the requirements of the API.</p>

<p>So you need to call the function like this:</p>

<pre><code>szString: AnsiString;
....
chString := 0;
CryptBinaryToString(CertContext.pbCertEncoded, CertContext.cbCertEncoded,  
    CRYPT_STRING_BASE64, nil, chString);
SetLength(szString, chString-1);
CryptBinaryToString(CertContext.pbCertEncoded, CertContext.cbCertEncoded,  
    CRYPT_STRING_BASE64, PAnsiChar(szString), chString);
</code></pre>

<p>You should also check the return value of <code>CryptBinaryToString</code> to detect failures. I omitted that for brevity.</p>

<p>I'm also assuming that yours is an ANSI Delphi. I assumed that because you used <code>PAnsiChar</code>.</p>
","2713","<delphi><certificate><cryptoapi>","2","1","1","2013-02-09 20:33:04","14791276","1","","","","","2013-02-09 19:57:39",""
"7776656","How to get Serial number of certificate in hex format string using cryptoapi?","<p>How to get Serial number of certificate in hex format string using cryptoapi ?
I have try using </p>

<pre><code>LPTSTR pszSerial = NULL;
    DWORD cbSerial = 0;
    CryptBinaryToString(pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData,pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData,CRYPT_STRING_HEX,NULL,&amp;cbSerial);
    pszSerial = new TCHAR[cbSerial];
    CryptBinaryToString(pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData,pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData,CRYPT_STRING_HEX,pszSerial,&amp;cbSerial);
</code></pre>

<p>But the result not what i want, i can get serial number but it reversed.</p>
","<p>The following snippet shows how to reverse the certificate serial number.</p>

<pre><code>for( int i = 0 ; i &lt; pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData ; i ++ )
{
    CertSerialNo[i] = *( pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData 
                            + pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData - i - 1 ) ;
}
</code></pre>
","2682","<c++><cryptoapi>","0","0","2","2015-09-02 11:16:25","","0","","","","","2011-10-15 08:17:11",""
"7776656","How to get Serial number of certificate in hex format string using cryptoapi?","<p>How to get Serial number of certificate in hex format string using cryptoapi ?
I have try using </p>

<pre><code>LPTSTR pszSerial = NULL;
    DWORD cbSerial = 0;
    CryptBinaryToString(pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData,pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData,CRYPT_STRING_HEX,NULL,&amp;cbSerial);
    pszSerial = new TCHAR[cbSerial];
    CryptBinaryToString(pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData,pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData,CRYPT_STRING_HEX,pszSerial,&amp;cbSerial);
</code></pre>

<p>But the result not what i want, i can get serial number but it reversed.</p>
","<p>I know it's 4 years after question was asked, but I get this page many times when I was looking for this issue solution - so perhaps I'm not the only person and my answer will help somebody ;)</p>

<p>I found information, that <strong>serial number is reversed in struct <code>_CERT_INFO</code></strong>, so bytes from <code>certInfo.SerialNumber.pbData</code> should be reversed. Moreover, you should take only <code>certInfo.SerialNumber.cbData</code> bytes (<code>cbData</code> is length of serial number). It's important, because when I was trying to use whole <code>pbData</code>, I was getting many rubbish bytes. </p>

<p>When I have reversed bytes, I convert them to hex. And thats all ;)</p>

<p>My code:</p>

<pre><code>unsigned char* pbData = pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData;
int cbData = pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData;

std::string serial((char*)pbData);
std::string serialSubstring = serial.substr(0,cbData);
std::reverse(serialSubstring.begin(), serialSubstring.end());
String snInHex(string_to_hex(serialSubstring).c_str());
//now snInHex contains serial number in hexadecimal string
</code></pre>

<p><strong>Extra feature - <code>serial number</code> as number!</strong> When you need serial number as data (for example, to create <code>xades</code> file):</p>

<pre><code>unsigned int sNumber;
std::stringstream ss;
ss &lt;&lt; std::hex &lt;&lt; snInHex.c_str();
ss &gt;&gt; sNumber;
//now serial number is stored as number in sNumber
</code></pre>

<p><strong>Edit</strong></p>

<p><code>string_to_hec</code> function was taken from here: <a href=""https://stackoverflow.com/questions/3381614/c-convert-string-to-hexadecimal-and-vice-versa"">C++ convert string to hexadecimal and vice versa</a></p>
","2682","<c++><cryptoapi>","0","2","2","2015-09-02 11:16:25","","0","","","","","2011-10-15 08:17:11",""
"34623247","CertCreateCertificateContext returns CRYPT_E_ASN1_BADTAG / 8009310b","<p>I realize this is a very similar post to others (e.g. <a href=""https://stackoverflow.com/questions/19388261/asn1-bad-tag-value-met-when-using-certcreatecertificatecontext-with-wincrypt"">this one</a>), but there are details missing from the posts which might be significant for my case.</p>

<p>To start with, here's my simplified program:</p>

<pre><code>#include ""stdafx.h""
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;

int _tmain(int argc, _TCHAR* argv[])
{
    // usage: CertExtract certpath

    char keyFile[] = ""C:\\Certificates\\public.crt"";
    BYTE lp[65536];

    SECURITY_ATTRIBUTES sa;
    HANDLE hKeyFile;
    DWORD bytes;

    PCCERT_CONTEXT  certContext;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = FALSE;

    hKeyFile = CreateFile(keyFile, GENERIC_READ, FILE_SHARE_READ, &amp;sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hKeyFile) {

        if (ReadFile(hKeyFile, lp, GetFileSize(hKeyFile, NULL), &amp;bytes, NULL) &amp;&amp; bytes &gt; 0) {

            certContext = CertCreateCertificateContext(X509_ASN_ENCODING, lp, bytes);

            if (certContext) {

                printf(""yay!"");

                CertFreeCertificateContext(certContext);
            }
            else {
                printf(""Could not convert certificate to internal form\n"");
            }
        }
        else {
            printf(""Failed to read key file: %s\n"", keyFile);
        }
    }
    else {
        printf(""Failed to open key file: %s\n"", keyFile);
    }

    CloseHandle(hKeyFile);


    return 0;
}
</code></pre>

<p>In order to create the certificate, I used the following steps with OpenSSL:</p>

<pre><code>C:\Certificates&gt;openssl genrsa -out private.key 1024
Loading 'screen' into random state - done
Generating RSA private key, 1024 bit long modulus
......................................++++++
................++++++
e is 65537 (0x10001)

C:\Certificates&gt;openssl req -new -key private.key -out public.csr
Loading 'screen' into random state - done

C:\Certificates&gt;copy private.key private.key.org
        1 file(s) copied.

C:\Certificates&gt;openssl rsa -in private.key.org -out private.key
writing RSA key

C:\Certificates&gt;openssl x509 -req -days 365 -in public.csr -signkey private.key -ou
t public.crt
Loading 'screen' into random state - done
Signature ok
subject=/CN=My Signing Cert
Getting Private key
</code></pre>

<p>with the following conf file:</p>

<pre><code>RANDFILE        = .rnd

[ req ]
distinguished_name     = req_distinguished_name
prompt                 = no

[ req_distinguished_name ]
commonName             = My Signing Cert
</code></pre>

<p>The certificate file looks like:</p>

<pre><code>-----BEGIN CERTIFICATE-----
MIIBqzCCARQCCQDUJyWk0OxlRTANBgkqhkiG9w0BAQUFADAaMRgwFgYDVQQDDA9N
eSBTaWduaW5nIENlcnQwHhcNMTYwMTA1MjIzODU5WhcNMTcwMTA0MjIzODU5WjAa
MRgwFgYDVQQDDA9NeSBTaWduaW5nIENlcnQwgZ8wDQYJKoZIhvcNAQEBBQADgY0A
MIGJAoGBAJobIhfSSMLEPeG9SOBelWHo4hjKXe8dT6cllPr6QXdXe2VNLh9fxVlx
spVGFQwjlF3OHYnmSQnY3m2b5wlFNYVuHvy8rUsZWOF4drSbiqWKh0TuJ+4MBeGq
EormTJ+kiGqNm5IVRrTu9OV8f0XQTGV1pxHircQxsGhxY5w0QTjjAgMBAAEwDQYJ
KoZIhvcNAQEFBQADgYEAedqjKfMyIFC8nUbJ6t/Y8D+fJFwCcdwojUFizr78FEwA
IZSas1b1bXSkA+QEooW7pYdBAfzNuD3WfZAIZpqFlr4rPNIqHzYa0OIdDPwzQQLa
3zPKqjj6QeTWEi5/ArzO+sTVv4m3Og3GQjMChb8H/GxsWdbComPVP82DTUet+ZU=
-----END CERTIFICATE-----
</code></pre>

<p>Converting the PEM-encoding to hex allows me to identify the parts of the certificate:</p>

<pre><code>30 SEQUENCE             //Certificate
(82 01 AB) 

   30 SEQUENCE          //tbsCertificate
   (82   01   14) 

      02 INTEGER        //serialNumber  
      (09)  
         00   D4   27   25   A4   D0   EC   65   45 

      30 SEQUENCE       //signature
      (0D) 

         06 OBJECT IDENTIFIER
         (09)  
         2A   86   48   86   F7   0D   01   01   05

         05 NULL 
         (00)

      30 SEQUENCE       //issuer
      (1A) 

         31 SET
         (18) 

            30 SEQUENCE
            (16) 

               06 OBJECT IDENTIFIER
               (03)  
               55   04   03

               0C UTF8String
               (0F)  
                  4D  79   20   53   69   67   6E   69   6E   67   20   43   65   72   74

      30 SEQUENCE       //validity
      (1E) 
         17 UTCTime
         (0D)  
            31   36   30   31   30   35   32   32   33   38   35   39   5A

         17 UTCTime
         (0D)  
            31   37   30   31   30   34   32   32   33   38   35   39   5A

      30 SEQUENCE       //subjectName
      (1A) 

         31 SET
         (18) 

            30 SEQUENCE
            (16) 
               06 OBJECT IDENTIFIER
               (03)  
                  55   04   03

               0C UTF8String
               (0F)  
                  4D   79   20   53   69  67   6E   69   6E   67   20   43   65   72   74

      30 SEQUENCE       //subjectPublicKeyInfo
      (81   9F) 
         30 SEQUENCE    //algorithmId
         (0D) 
            06 OBJECT IDENTIFIER    //algorithm
            (09)  
               2A   86   48   86   F7   0D   01   01   01

            05 NULL
            (00)

         03 BIT STRING   //subjectPublicKey
         (81   8D)  
            [00] //padding bits
            30 SEQUENCE  //RSAPublicKey
            (81   89)   

               02 INTEGER  //modulus
               (81   81)   
                  00   9A   1B   22   17   D2   48   C2   C4   3D  E1   BD   48   E0   5E   95   61   E8   E2   18   CA   5D   EF   1D   4F   A7  25   94   FA   FA   41   77   57   7B   65   4D   2E   1F   5F   C5   59   71  B2   95   46   15   0C   23   94   5D   CE   1D   89   E6   49   09   D8   DE  6D   9B   E7   09   45   35   85   6E   1E   FC   BC   AD   4B   19   58   E1  78   76   B4   9B   8A   A5   8A   87   44   EE   27   EE   0C   05   E1   AA  12   8A   E6   4C   9F   A4   88   6A   8D   9B   92   15   46   B4   EE   F4  E5   7C   7F   45   D0   4C   65   75   A7   11   E2   AD   C4   31   B0   68  71   63   9C   34   41   38   E3   02   03   01   00   01

   30 SEQUENCE             //signatureAlgorithm
   (0D) 
      06 OBJECT IDENTIFIER
      (09) 
         2A   86   48   86   F7   0D   01   01   05

      05 NULL
      (00)

   03 BIT STRING           //signatureValue
   (81   81)  
      [00] //padding bits
      79  DA   A3   29   F3   32   20   50   BC   9D   46   C9   EA   DF   D8   F0   3F   9F   24   5C   02   71   DC   28   8D   41   62   CE   BE   FC   14   4C   00   21   94   9A   B3   56   F5   6D   74   A4   03   E4   04   A2   85   BB   A5   87   41   01   FC   CD   B8   3D   D6   7D   90   08   66   9A   85   96   BE   2B   3C   D2   2A   1F   36   1A   D0   E2   1D   0C   FC   33   41   02   DA   DF   33   CA   AA   38   FA   41   E4   D6   12   2E   7F   02   BC   CE   FA   C4   D5   BF   89   B7   3A   0D   C6   42   33   02   85   BF   07   FC   6C   6C   59   D6   C2   A2   63   D5   3F   CD   83   4D   47   AD   F9   95
</code></pre>

<p>which appears to conform to the <a href=""https://tools.ietf.org/html/rfc5912#section-14"" rel=""nofollow noreferrer"">X.509 specs</a> (as I would expect it to):</p>

<pre><code>Certificate ::= {
   tbsCertificate TBSCertificate,
   signatureAlgorithm AlgorithmIdentifier,
   signatureValue BIT STRING
}

TBSCertificate ::= SEQUENCE {   
   version [0] Version DEFAULT v1,  &lt;-- what does this mean?
   serialNumber INTEGER,
   signature AlgorithmIdentifier,
   issuer Name,
   validity Validity,
   subjectName Name,
   subjectPublicKeyInfo SubjectPublicKeyInfo
   ...
}
</code></pre>

<p>with the lone exception of the version part, which isn't clear to me whether it is optional or not (though it never seems to be added with certificates I create with OpenSSL).</p>

<p>I can open the certificate to import into a certificate store (and can successfully import to a store), so I don't think anything is specifically wrong with the file/encoding.</p>

<p>When I reach the call to CertCreateCertificateContext, my lp buffer looks like:</p>

<pre><code>-----BEGIN CERTIFICATE-----\nMIIBqzCCARQCCQDUJyWk0OxlRTANBgkqhkiG9w0BAQUFADAaMRgwFgYDVQQDDA9N\neSBTaWduaW5nIENlcnQwHhcNMTYwMTA1MjIzODU5WhcNMTcwMTA0MjIzODU5WjAa\nMRgwFgYDVQQDDA9NeSBTaWduaW5nIENlcnQwgZ8wDQ...
</code></pre>

<p>and bytes = 639 -- which is the file size.</p>

<p>I've tried adding logic to strip out the certificate comments, but <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd743310%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">examples</a> of importing a certificate in this manner don't indicate that should be necessary.</p>

<p>I've tried setting the dwCertEncodingType to X509_ASN_ENCODING | PKCS_7_ASN_ENCODING and PKCS_7_ASN_ENCODING out of desperation (though I don't believe I am using PKCS#7 encoding here...a little fuzzy on that).</p>

<p>Does anyone have any suggestions on what I might be doing incorrectly here? I appreciate it.</p>
","<p>I figured out my issue. CertCreateCertificateContext is expecting the binary ASN.1 data, not the PEM-encoded certificate I created with openssl. I figured this out by using a Microsoft certificate generation tool and testing that certificate out:</p>

<pre><code>C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin&gt;makecert.exe -n ""CN=Test Signing Cert"" -b 0
1/06/2016 -e 01/06/2017 -len 1024 -r C:\Certificates\public_v2.crt
Succeeded
</code></pre>

<p>looking at the file in a hex editor, it looked precisely like the ASN.1 binary data. next, I used the Copy to File feature from the certificate viewer that launches when you double-click a certificate to copy my original public.crt file to a DER encoded binary X.509 (.CER) file and verified that my program began to work (that is, the CertCreateCertificateContext was now happy).</p>

<p>so, in case someone else is bumping up against the same issue I was having, here is a complete solution to importing a PEM-encoded certificate from a file into memory for use with the Crypto API:</p>

<pre><code>#include ""stdafx.h""
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;

#define LF 0x0A

int _tmain(int argc, _TCHAR* argv[])
{
    char keyFile[] = ""C:\\Certificates\\public.crt"";
    BYTE lp[65536];

    SECURITY_ATTRIBUTES sa;
    HANDLE hKeyFile;
    DWORD bytes;

    PCCERT_CONTEXT  certContext;
    BYTE *p;
    DWORD flags;

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = FALSE;

    hKeyFile = CreateFile(keyFile, GENERIC_READ, FILE_SHARE_READ, &amp;sa, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hKeyFile) {

        if (ReadFile(hKeyFile, lp, GetFileSize(hKeyFile, NULL), &amp;bytes, NULL) &amp;&amp; bytes &gt; 0) {

            p = lp + bytes;
            if (CryptStringToBinary((char *)lp, p - lp, CRYPT_STRING_BASE64_ANY, p, &amp;bytes, NULL, &amp;flags) &amp;&amp; bytes &gt; 0) {

                certContext = CertCreateCertificateContext(X509_ASN_ENCODING, p, bytes);

                if (certContext) {

                    printf(""yay!"");

                    CertFreeCertificateContext(certContext);
                }
                else {
                    printf(""Could not convert certificate to internal form\n"");
                }
            }
            else {
                printf(""Failed to convert from PEM"");
            }
        }
        else {
            printf(""Failed to read key file: %s\n"", keyFile);
        }
    }
    else {
        printf(""Failed to open key file: %s\n"", keyFile);
    }

    CloseHandle(hKeyFile);


    return 0;
}
</code></pre>

<p>Note:</p>

<p>because I'm lazy, I decode the PEM encoding to binary in the same BYTE array I used to load the file into -- for this simple test, it was expedient, but if you're looking to implement this sort of thing for real, I wouldn't recommend it</p>
","2642","<windows><winapi><encryption><certificate><cryptoapi>","3","3","1","2016-01-06 21:22:44","34643021","1","1","-1","","2017-05-23 12:09:53","2016-01-05 23:40:50",""
"6512373","How can I use MSCAPI inside an applet to load a keystore","<p>I have an applet that allows users to sign documents using their personal certificates.  The applet is already signed, but when it tries to load their keystore, I get an access denied error related to sunMSCAPI.  It's being caused by the following lines of code:</p>

<pre><code>store = KeyStore.getInstance(""Windows-MY"");
store.load(null, null);
</code></pre>

<p>From what I understand of applet signing, there are no additional steps after the signing process that I need to jump through (editing policy files and such).  I tried wrapping all the applet functionality within:</p>

<pre><code>AccessController.doPrivileged(new PrivilegedAction() {
  public Object run() {
    etc...
</code></pre>

<p>But that didn't help.  I've rooted around and found some comments on various forums that sunMSCAPI is only available in JDK 6...which I've got.  I'm running out of ideas, and any help would be appreciated.</p>

<p>For potential aid, here's the stack trace of the access denied error:</p>

<pre><code>java.security.AccessControlException: access denied (java.security.SecurityPermission authProvider.SunMSCAPI)
    at java.security.AccessControlContext.checkPermission(Unknown Source)
    at java.security.AccessController.checkPermission(Unknown Source)
    at java.lang.SecurityManager.checkPermission(Unknown Source)
    at sun.security.mscapi.KeyStore.engineLoad(KeyStore.java:736)
    at sun.security.mscapi.KeyStore$MY.engineLoad(KeyStore.java:43)
    at java.security.KeyStore.load(Unknown Source)
    at com.bloop.signature.PKCS11.loadKeyStore(PKCS11.java:42)
    at com.bloop.signature.PKCS11.sign(PKCS11.java:29)
    at com.bloop.signature.applet.SignApplet.signDocument(SignApplet.java:103)
    at com.bloop.signature.applet.SignApplet.access$200(SignApplet.java:19)
    at com.bloop.signature.applet.SignApplet$1.run(SignApplet.java:64)
    at java.lang.Thread.run(Unknown Source)
</code></pre>
","<p>It seems that the keystore I was using to sign the applet was invalid somehow.  I generated a new one, signed with it, cleared the java cache, and everything started working nicely.</p>

<p>For completeness sake, here's the command I ran to generate the new store:</p>

<pre><code>keytool -genkey -alias keyPair -keyalg RSA -validity 500 -keystore myKeyStore -keypass &lt;password&gt; -storepass &lt;password&gt; -dname ""&lt;CN,OU,O,L,ST,C details&gt;""
</code></pre>

<p>If anyone else ever has this problem, hopefully the above helps.</p>
","2613","<java><applet><digital-signature><cryptoapi>","1","1","1","2011-06-29 18:26:21","6525445","0","1","","","","2011-06-28 19:57:43",""
"8909090","The SYSTEM account cannot access the certificate store","<p>Why the SYSTEM account is not able to access the user's certificate store?</p>

<p>At the same time the SYSTEM account is able to read the certificate (through the CSP dll) from the smart card and put it in the certificate store (CSP is being used by <strong>winlogon.exe</strong> in this case, so I guess the winlogon.exe has some magic inside).</p>

<p>For example, calling <code>CertOpenSystemStore( NULL, L""MY"" )</code> under system account will succeed, but <code>CertFindCertificateInStore()</code> will not find anything, because it looks like the store is empty. When I log on, the <code>CertFindCertificateInStore()</code> will find the requested certificate.</p>
","<p>Every user has a different MY Store, So If you are able to find something in USER A login My Store, you might not be able to get that from User 2.
Try using MMC for accessing Certificate Stores of other users and service accounts.</p>
","2607","<windows><certificate><cryptoapi><rsacryptoserviceprovider>","0","1","2","2016-02-10 08:57:28","","1","1","321731","","2014-05-02 11:55:15","2012-01-18 11:11:12",""
"8909090","The SYSTEM account cannot access the certificate store","<p>Why the SYSTEM account is not able to access the user's certificate store?</p>

<p>At the same time the SYSTEM account is able to read the certificate (through the CSP dll) from the smart card and put it in the certificate store (CSP is being used by <strong>winlogon.exe</strong> in this case, so I guess the winlogon.exe has some magic inside).</p>

<p>For example, calling <code>CertOpenSystemStore( NULL, L""MY"" )</code> under system account will succeed, but <code>CertFindCertificateInStore()</code> will not find anything, because it looks like the store is empty. When I log on, the <code>CertFindCertificateInStore()</code> will find the requested certificate.</p>
","<p>Either you need to put the relevant certificates in the SYSTEM cert store or you need to impersonate the user whose store you wish to access. Impersonation can be done in multiple ways, I would suggest start looking at <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376391%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a>.</p>
","2607","<windows><certificate><cryptoapi><rsacryptoserviceprovider>","0","0","2","2016-02-10 08:57:28","","1","1","321731","","2014-05-02 11:55:15","2012-01-18 11:11:12",""
"16775911","Converting private key in windows store to PEM (for OpenSSL)","<p>I want to get a private key from windows store and convert it to PEM in order to use it in OpenSSL.
I've been looking for a way to do that for a few hours!</p>

<ul>
<li>I use CertFindCertificateInStore() to get CERT_CONTEXT (which I know it contains the private key using the search parameter).</li>
<li>Next, I used CryptAcquireCertificatePrivateKey() to get HCRYPTPROV (just because of the name of the function).</li>
<li>Now, I use CryptGetUserKey() to get HCRYPTKEY (just because it sounds right...?!)</li>
</ul>

<p>But now I'm stuck again.</p>

<p>I think this is security by obscurity done by Microsoft to make sure we will never be able to get private keys.</p>
","<p>First two are fine. But you need to use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379932%28v=vs.85%29.aspx"" rel=""nofollow"">CryptExportPKCS8</a>. It will export the private key to a buffer in PKCS #8 DER encoded form. From PKCS #8, you can get it into X509 structure of OpenSSL (by using d2i functions and memory buffer as input in BIO structures).</p>

<p>However, if the private key is marked as non-exportable, this function will fail.</p>

<p>Only use you can do is to sign the data using such private key.</p>
","2603","<c++><security><openssl><cryptoapi>","1","0","2","2013-05-28 13:46:25","16783702","0","1","324827","","2013-05-27 15:16:23","2013-05-27 15:04:23",""
"16775911","Converting private key in windows store to PEM (for OpenSSL)","<p>I want to get a private key from windows store and convert it to PEM in order to use it in OpenSSL.
I've been looking for a way to do that for a few hours!</p>

<ul>
<li>I use CertFindCertificateInStore() to get CERT_CONTEXT (which I know it contains the private key using the search parameter).</li>
<li>Next, I used CryptAcquireCertificatePrivateKey() to get HCRYPTPROV (just because of the name of the function).</li>
<li>Now, I use CryptGetUserKey() to get HCRYPTKEY (just because it sounds right...?!)</li>
</ul>

<p>But now I'm stuck again.</p>

<p>I think this is security by obscurity done by Microsoft to make sure we will never be able to get private keys.</p>
","<p>I'm leaving the answer as it is (after all without dbasic I would've been stuck :-)), but I have more to add:</p>

<p>CryptExportPKCS8() end of support ended with XP/2003, so we have to use PFXExportCertStoreEx() , however this function exports the WHOLE store. So, in order to export just one certificate you need to use a memory store.</p>

<p>Check out this example on how to do that:
<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382037(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa382037(v=vs.85).aspx</a></p>

<p>Insert the certificate you want into the memory store, and then use PFXExportCertStoreEx() to export what you need.</p>
","2603","<c++><security><openssl><cryptoapi>","1","2","2","2013-05-28 13:46:25","16783702","0","1","324827","","2013-05-27 15:16:23","2013-05-27 15:04:23",""
"3175623","CryptStringToBinary not working with a NULL terminated string. Why?","<p>does anyone know why this code is not working?</p>

<pre><code> #include ""stdafx.h""
#include &lt;windows.h&gt;
#include &lt;WinCrypt.h&gt;


int _tmain(int argc, _TCHAR* argv[])
{
wchar_t *bin = TEXT(""ProductID:1233===&gt;55555"");
BYTE out2[1000];
DWORD olen;
olen = 1000;

if (CryptStringToBinary(bin, 0, 1, out2, &amp;olen, 0, 0) == 0)
{
    wprintf(TEXT(""Failure\n""));
}
else
{
//wprintf(TEXT(""rn%s\n""),out2);
    wprintf(TEXT(""Success\n""));
}
system(""pause"");
    return 0;
}
</code></pre>

<p>Thank you very much in advance!</p>

<p>Tom</p>
","<p>Because you specified a length (parameter 2) of 0?</p>

<p><strong>Edit:</strong> Just to clarify our eventual solution in the comments below, the code in the original question (since edited) contained two errors:</p>

<ol>
<li>It was calling <code>CryptBinaryToString</code> instead of <code>CryptStringToBinary</code>.  Since it's invalid to pass a 0 in the second parameter to <code>CryptBinaryToString</code>, the function was failing.</li>
<li>It was passing 1 in the third parameter (dwFlags), which is interpreted as <code>CRYPT_STRING_BASE64</code>.  Since the string to encrypt wasn't in base 64 (it contained invalid characters such as ':'), the function was failing.  In general, passing a raw value instead of using an existing definition (e.g., <code>CRYPT_STRING_BASE64</code>) is not a good idea.</li>
</ol>
","2592","<windows><cryptoapi>","0","1","1","2010-07-04 23:52:24","3175643","1","","383192","","2010-07-04 18:43:27","2010-07-04 17:53:55",""
"1627045","C# encryption, C++ decryption. Final few bytes failing on decryption","<p>My apologies for the length of the code I'm about to list.</p>

<p>I need to encrypt the contents of an xml file on the C# end of my code, and decrypt it in C++.  I'm using RC2, with <code>RC2CryptoServiceProvider</code> and <code>CryptoStream</code> on the C# side, with <code>Wincrypt</code> on the C++ side.  Encryption <em>seems</em> to be working fine, it looks like such: </p>

<pre><code>public static byte[] EncryptString(byte[] input, string password)
{
    PasswordDeriveBytes pderiver = new PasswordDeriveBytes(password, null);
    byte[] ivZeros = new byte[8];
    byte[] pbeKey = pderiver.CryptDeriveKey(""RC2"", ""MD5"", 128, ivZeros);

    RC2CryptoServiceProvider RC2 = new RC2CryptoServiceProvider();

    byte[] IV = new byte[8];
    ICryptoTransform encryptor = RC2.CreateEncryptor(pbeKey, IV);

    MemoryStream msEncrypt = new MemoryStream();
    CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
    csEncrypt.Write(input, 0, input.Length);
    csEncrypt.FlushFinalBlock();

    return msEncrypt.ToArray();
}
</code></pre>

<p>MY decryption code <em>almost</em> works perfectly.  It is missing the final two characters of the file, and instead spitting out garbage characters.  I have tried null-terminating the decrypted string, but no dice.  It is as follows:</p>

<pre><code>char* FileReader::DecryptMyFile(char *input, char *password, int size, int originalSize) 
{
UNREFERENCED_PARAMETER(password);
HCRYPTPROV provider = NULL;
if(CryptAcquireContext(&amp;provider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))
{
    printf(""Context acquired."");
}
else
{
    if (GetLastError() == NTE_BAD_KEYSET)
    {
        if(CryptAcquireContext(&amp;provider, 0, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
        {
            printf(""new key made."");
        }
        else
        {
            printf(""Could not acquire context."");
        }
    }
    else
    {
        DWORD check = GetLastError();
        UNREFERENCED_PARAMETER(check);
        printf(""Could not acquire context."");
    }
}

HCRYPTKEY key = NULL;
HCRYPTHASH hash = NULL;
if(CryptCreateHash(provider, CALG_MD5, 0, 0, &amp;hash))
{
    printf(""empty hash created."");
}

if(CryptHashData(hash, (BYTE *)password, strlen(password), 0))
{
    printf(""data buffer is added to hash."");
}

HCRYPTHASH duphash = NULL;
CryptDuplicateHash(hash, 0, 0, &amp;duphash);
BYTE *mydata = new BYTE[512];
DWORD mydatasize = 512;
CryptGetHashParam(hash, HP_HASHVAL, mydata, &amp;mydatasize, 0);

BYTE *mydata2 = new BYTE[512]; //these duplicates were made to test my hash.
DWORD mydatasize2 = 512;  
CryptGetHashParam(duphash, HP_HASHVAL, mydata2, &amp;mydatasize2, 0); 

if(CryptDeriveKey(provider, CALG_RC2, hash, 0, &amp;key)) 
{
    printf(""key derived.""); 
}

DWORD dwKeyLength = 128;
if(CryptSetKeyParam(key, KP_EFFECTIVE_KEYLEN, reinterpret_cast&lt;BYTE*&gt;(&amp;dwKeyLength), 0))
{
    printf(""CryptSetKeyParam success"");
}

BYTE IV[8] = {0,0,0,0,0,0,0,0};
if(CryptSetKeyParam(key, KP_IV, IV, 0))
{
    printf(""CryptSetKeyParam worked"");
}

DWORD dwCount = size;
BYTE *somebytes = new BYTE[dwCount + 1];

memcpy(somebytes, input, dwCount);

if(CryptDecrypt(key,0, true, 0, somebytes, &amp;dwCount))
{
    printf(""CryptDecrypt succeeded."");
}
else
{
    if(GetLastError() == NTE_BAD_DATA)
    {
        printf(""NTE_BAD_DATA"");
    }
    printf(""CryptDecrypt failed."");
    DWORD testest = NULL;
    testest = GetLastError();
    testest = 3;
}
somebytes[originalSize] = '\0';

    return (char *)somebytes;
}
</code></pre>

<p>The resulting xml file should end with <code>&lt;/LudoData&gt;</code>.  Currently, it ends with <code>&lt;/LudoDat[funny looking s]b</code></p>

<p>Why might this be?  How can I stop this?  I'm terribly confused as to why this is occurring. Since I am null-terminating the decryption and still getting a problem only on the final characters, I don't believe that the decryption is the problem (although I would love to be wrong).  Is it possible that my encryption is having troubles when finishing the encryption of the file?   </p>

<p>Upon returning from CryptDecrypt, dwCount is equal to size, which is 11296.  Meanwhile, originalSize is equal to 11290.</p>
","<p>Shouldn't you be doing just the following</p>

<pre><code>DWORD dwCount = size;
BYTE *somebytes = new BYTE[dwCount];

memcpy(somebytes, input, dwCount);
</code></pre>

<p>before calling <code>CryptDecrypt</code>? Why do you need to add a null character when <code>CryptDecrypt</code> already takes the number of bytes as it's final argument? I suspect that's what's breaking things as you've changed the input by clobbering the character at position <code>originalSize - 1</code>.</p>

<p><strong>Edit:</strong></p>

<p>Which is bigger, <code>originalSize</code> or <code>size</code>? Since <code>CryptDecrypt</code> re-uses the array it must be dimensioned with the bigger of the two. BTW, why do you think you need the extra one in the dimension?</p>
","2591","<c#><c++><encryption><cryptoapi>","1","1","3","2012-11-28 23:29:51","","4","","33837","","2009-12-19 12:26:09","2009-10-26 20:07:35",""
"1627045","C# encryption, C++ decryption. Final few bytes failing on decryption","<p>My apologies for the length of the code I'm about to list.</p>

<p>I need to encrypt the contents of an xml file on the C# end of my code, and decrypt it in C++.  I'm using RC2, with <code>RC2CryptoServiceProvider</code> and <code>CryptoStream</code> on the C# side, with <code>Wincrypt</code> on the C++ side.  Encryption <em>seems</em> to be working fine, it looks like such: </p>

<pre><code>public static byte[] EncryptString(byte[] input, string password)
{
    PasswordDeriveBytes pderiver = new PasswordDeriveBytes(password, null);
    byte[] ivZeros = new byte[8];
    byte[] pbeKey = pderiver.CryptDeriveKey(""RC2"", ""MD5"", 128, ivZeros);

    RC2CryptoServiceProvider RC2 = new RC2CryptoServiceProvider();

    byte[] IV = new byte[8];
    ICryptoTransform encryptor = RC2.CreateEncryptor(pbeKey, IV);

    MemoryStream msEncrypt = new MemoryStream();
    CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
    csEncrypt.Write(input, 0, input.Length);
    csEncrypt.FlushFinalBlock();

    return msEncrypt.ToArray();
}
</code></pre>

<p>MY decryption code <em>almost</em> works perfectly.  It is missing the final two characters of the file, and instead spitting out garbage characters.  I have tried null-terminating the decrypted string, but no dice.  It is as follows:</p>

<pre><code>char* FileReader::DecryptMyFile(char *input, char *password, int size, int originalSize) 
{
UNREFERENCED_PARAMETER(password);
HCRYPTPROV provider = NULL;
if(CryptAcquireContext(&amp;provider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))
{
    printf(""Context acquired."");
}
else
{
    if (GetLastError() == NTE_BAD_KEYSET)
    {
        if(CryptAcquireContext(&amp;provider, 0, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
        {
            printf(""new key made."");
        }
        else
        {
            printf(""Could not acquire context."");
        }
    }
    else
    {
        DWORD check = GetLastError();
        UNREFERENCED_PARAMETER(check);
        printf(""Could not acquire context."");
    }
}

HCRYPTKEY key = NULL;
HCRYPTHASH hash = NULL;
if(CryptCreateHash(provider, CALG_MD5, 0, 0, &amp;hash))
{
    printf(""empty hash created."");
}

if(CryptHashData(hash, (BYTE *)password, strlen(password), 0))
{
    printf(""data buffer is added to hash."");
}

HCRYPTHASH duphash = NULL;
CryptDuplicateHash(hash, 0, 0, &amp;duphash);
BYTE *mydata = new BYTE[512];
DWORD mydatasize = 512;
CryptGetHashParam(hash, HP_HASHVAL, mydata, &amp;mydatasize, 0);

BYTE *mydata2 = new BYTE[512]; //these duplicates were made to test my hash.
DWORD mydatasize2 = 512;  
CryptGetHashParam(duphash, HP_HASHVAL, mydata2, &amp;mydatasize2, 0); 

if(CryptDeriveKey(provider, CALG_RC2, hash, 0, &amp;key)) 
{
    printf(""key derived.""); 
}

DWORD dwKeyLength = 128;
if(CryptSetKeyParam(key, KP_EFFECTIVE_KEYLEN, reinterpret_cast&lt;BYTE*&gt;(&amp;dwKeyLength), 0))
{
    printf(""CryptSetKeyParam success"");
}

BYTE IV[8] = {0,0,0,0,0,0,0,0};
if(CryptSetKeyParam(key, KP_IV, IV, 0))
{
    printf(""CryptSetKeyParam worked"");
}

DWORD dwCount = size;
BYTE *somebytes = new BYTE[dwCount + 1];

memcpy(somebytes, input, dwCount);

if(CryptDecrypt(key,0, true, 0, somebytes, &amp;dwCount))
{
    printf(""CryptDecrypt succeeded."");
}
else
{
    if(GetLastError() == NTE_BAD_DATA)
    {
        printf(""NTE_BAD_DATA"");
    }
    printf(""CryptDecrypt failed."");
    DWORD testest = NULL;
    testest = GetLastError();
    testest = 3;
}
somebytes[originalSize] = '\0';

    return (char *)somebytes;
}
</code></pre>

<p>The resulting xml file should end with <code>&lt;/LudoData&gt;</code>.  Currently, it ends with <code>&lt;/LudoDat[funny looking s]b</code></p>

<p>Why might this be?  How can I stop this?  I'm terribly confused as to why this is occurring. Since I am null-terminating the decryption and still getting a problem only on the final characters, I don't believe that the decryption is the problem (although I would love to be wrong).  Is it possible that my encryption is having troubles when finishing the encryption of the file?   </p>

<p>Upon returning from CryptDecrypt, dwCount is equal to size, which is 11296.  Meanwhile, originalSize is equal to 11290.</p>
","<p>This line is your problem (before the call to <code>CryptDecrypt</code>):</p>

<pre><code>somebytes[originalSize - 1] = '\0';
</code></pre>

<p>It is overwriting part of the encrypted padding in the last block with a zero, which is causing the last block to decrypt to rubbish.  Just remove the line - the ciphertext isn't nul-terminated anyway (it almost certainly contains plenty of embedded nuls), the length parameter is used by the decryption routine to know how much data there is.</p>

<p>Oh, and... RC2? Seriously?</p>
","2591","<c#><c++><encryption><cryptoapi>","1","3","3","2012-11-28 23:29:51","","4","","33837","","2009-12-19 12:26:09","2009-10-26 20:07:35",""
"1627045","C# encryption, C++ decryption. Final few bytes failing on decryption","<p>My apologies for the length of the code I'm about to list.</p>

<p>I need to encrypt the contents of an xml file on the C# end of my code, and decrypt it in C++.  I'm using RC2, with <code>RC2CryptoServiceProvider</code> and <code>CryptoStream</code> on the C# side, with <code>Wincrypt</code> on the C++ side.  Encryption <em>seems</em> to be working fine, it looks like such: </p>

<pre><code>public static byte[] EncryptString(byte[] input, string password)
{
    PasswordDeriveBytes pderiver = new PasswordDeriveBytes(password, null);
    byte[] ivZeros = new byte[8];
    byte[] pbeKey = pderiver.CryptDeriveKey(""RC2"", ""MD5"", 128, ivZeros);

    RC2CryptoServiceProvider RC2 = new RC2CryptoServiceProvider();

    byte[] IV = new byte[8];
    ICryptoTransform encryptor = RC2.CreateEncryptor(pbeKey, IV);

    MemoryStream msEncrypt = new MemoryStream();
    CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write);
    csEncrypt.Write(input, 0, input.Length);
    csEncrypt.FlushFinalBlock();

    return msEncrypt.ToArray();
}
</code></pre>

<p>MY decryption code <em>almost</em> works perfectly.  It is missing the final two characters of the file, and instead spitting out garbage characters.  I have tried null-terminating the decrypted string, but no dice.  It is as follows:</p>

<pre><code>char* FileReader::DecryptMyFile(char *input, char *password, int size, int originalSize) 
{
UNREFERENCED_PARAMETER(password);
HCRYPTPROV provider = NULL;
if(CryptAcquireContext(&amp;provider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))
{
    printf(""Context acquired."");
}
else
{
    if (GetLastError() == NTE_BAD_KEYSET)
    {
        if(CryptAcquireContext(&amp;provider, 0, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
        {
            printf(""new key made."");
        }
        else
        {
            printf(""Could not acquire context."");
        }
    }
    else
    {
        DWORD check = GetLastError();
        UNREFERENCED_PARAMETER(check);
        printf(""Could not acquire context."");
    }
}

HCRYPTKEY key = NULL;
HCRYPTHASH hash = NULL;
if(CryptCreateHash(provider, CALG_MD5, 0, 0, &amp;hash))
{
    printf(""empty hash created."");
}

if(CryptHashData(hash, (BYTE *)password, strlen(password), 0))
{
    printf(""data buffer is added to hash."");
}

HCRYPTHASH duphash = NULL;
CryptDuplicateHash(hash, 0, 0, &amp;duphash);
BYTE *mydata = new BYTE[512];
DWORD mydatasize = 512;
CryptGetHashParam(hash, HP_HASHVAL, mydata, &amp;mydatasize, 0);

BYTE *mydata2 = new BYTE[512]; //these duplicates were made to test my hash.
DWORD mydatasize2 = 512;  
CryptGetHashParam(duphash, HP_HASHVAL, mydata2, &amp;mydatasize2, 0); 

if(CryptDeriveKey(provider, CALG_RC2, hash, 0, &amp;key)) 
{
    printf(""key derived.""); 
}

DWORD dwKeyLength = 128;
if(CryptSetKeyParam(key, KP_EFFECTIVE_KEYLEN, reinterpret_cast&lt;BYTE*&gt;(&amp;dwKeyLength), 0))
{
    printf(""CryptSetKeyParam success"");
}

BYTE IV[8] = {0,0,0,0,0,0,0,0};
if(CryptSetKeyParam(key, KP_IV, IV, 0))
{
    printf(""CryptSetKeyParam worked"");
}

DWORD dwCount = size;
BYTE *somebytes = new BYTE[dwCount + 1];

memcpy(somebytes, input, dwCount);

if(CryptDecrypt(key,0, true, 0, somebytes, &amp;dwCount))
{
    printf(""CryptDecrypt succeeded."");
}
else
{
    if(GetLastError() == NTE_BAD_DATA)
    {
        printf(""NTE_BAD_DATA"");
    }
    printf(""CryptDecrypt failed."");
    DWORD testest = NULL;
    testest = GetLastError();
    testest = 3;
}
somebytes[originalSize] = '\0';

    return (char *)somebytes;
}
</code></pre>

<p>The resulting xml file should end with <code>&lt;/LudoData&gt;</code>.  Currently, it ends with <code>&lt;/LudoDat[funny looking s]b</code></p>

<p>Why might this be?  How can I stop this?  I'm terribly confused as to why this is occurring. Since I am null-terminating the decryption and still getting a problem only on the final characters, I don't believe that the decryption is the problem (although I would love to be wrong).  Is it possible that my encryption is having troubles when finishing the encryption of the file?   </p>

<p>Upon returning from CryptDecrypt, dwCount is equal to size, which is 11296.  Meanwhile, originalSize is equal to 11290.</p>
","<p>after you finish writing to the <code>CryptoStream</code> you need to flush <code>FileStream</code> then <code>finalflush</code> the <code>CryptoStream</code>. After that close the <code>CryptoStream</code> first and the <code>FileStream</code> last. If you don't, all the original bytes whether from a MemoryStream/FileStream may not get written causing missing bytes. If the <code>FileStream.Position</code> does not equal <code>FileStream.Length</code> when you are done then <code>FileStream.Length-FileStream.Position = missing bytes</code>. So now when you try to get the decrypted data (Lord forbid by Serialization which will fail on you in that case), you will not get all the data back.</p>
","2591","<c#><c++><encryption><cryptoapi>","1","0","3","2012-11-28 23:29:51","","4","","33837","","2009-12-19 12:26:09","2009-10-26 20:07:35",""
"4866672","Converting between Windows CryptoAPI and OpenSSL x509 formats","<p>I have a <a href=""http://msdn.microsoft.com/en-us/library/aa377189%28VS.85%29.aspx"" rel=""nofollow"">CERT_CONTEXT</a> structure which I've extracted from a smart card on Windows via the CryptoAPI. I need to convert this structure into a DER encoded byte array which is consistent with OpenSSL. The closest match I've got so far is via <a href=""http://msdn.microsoft.com/en-us/library/aa379921%28v=vs.85%29.aspx"" rel=""nofollow"">CryptEncodeObject</a> using X509_ASN_ENCODING and the X509_CERT_TO_BE_SIGNED modifier which takes the <a href=""http://msdn.microsoft.com/en-us/library/aa377200%28v=vs.85%29.aspx"" rel=""nofollow"">CERT_INFO</a> structure as input.</p>

<p>The problem is that it doesn't match with the output produced by the OpenSSL <a href=""http://www.openssl.org/docs/crypto/d2i_X509.html"" rel=""nofollow"">i2d_X509</a> function. Using a 2048 bit x509 certificate as input, OpenSSL produces 1789 bytes of encoded output whilst the Windows CryptoAPI produces 1638 bytes of encoded output.</p>

<p>The only option left that I can see is to create an X509 cert on the fly using the values from the <a href=""http://msdn.microsoft.com/en-us/library/aa377189%28VS.85%29.aspx"" rel=""nofollow"">CERT_CONTEXT</a> structure and the encode the resulting object directly with the <a href=""http://www.openssl.org/docs/crypto/d2i_X509.html"" rel=""nofollow"">i2d_X509</a> function. The only problem with this is that I can't extract the private key from the smart card, so this may cause problems with the x509 cert creation routines. </p>

<p>If anyone can provide any insight/advice/tips into these matters, I'd be much obliged.</p>
","<p>DER encoded certificate can be obtained from (ctx->pbCertEncoded, ctx->cbCertEncoded) buffer where ctx is a PCCERT_CONTEXT object. Still you won't be able to recover the private key.</p>
","2569","<c++><openssl><cryptoapi><x509><asn.1>","4","6","1","2011-02-01 19:13:12","4866922","0","1","","","","2011-02-01 18:49:18",""
"22147895","Is it possible to do a HMAC with wincrypt?","<p>I've been trying to perform a straight forward SHA256 HMAC using wincrypt/cryptoapi/Cryptography API: Next Generation (CNG) and i'm really struggling. My target is Windows 8.</p>

<p>I can not find the correct methods or find any examples anywhere. I am looking to do the following in C/C++, that is demonstrated in C# below</p>

<pre><code>        HMAC hashMaker = new HMACSHA256(Encoding.ASCII.GetBytes(""SecretKey""));
        byte[] hash = hashMaker.ComputeHash(Encoding.ASCII.GetBytes(""&lt;SomeXmlData /&gt;""));
        string hashStr = BitConverter.ToString(hash);
</code></pre>

<p>it returns the hash: B2-42-48-67-5A-B8-03-87-5B-00-D7-8C-65-5A-AE-B7-92-E3-F9-27-40-C1-01-A5-37-74-E1-65-51-9F-F6-6A.</p>

<p>Has anybody succeeded to perform a straight forward HMAC using the cryptoapi?</p>
","<p>Thank you for the information Mgetz. I never knew about the BCrypt set of methods. It is a lot easier for HMAC than CryptHashData of the wincrypt/cryptoapi. From the example of using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376217%28v=vs.85%29.aspx"" rel=""noreferrer"" title=""hashing using SHA256"">hashing using SHA256</a>   I was able to create the HMAC code. You only need to add <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375479%28v=vs.85%29.aspx"" rel=""noreferrer"" title=""Flag"">BCRYPT_ALG_HANDLE_HMAC_FLAG</a> to the last parameter of BCryptOpenAlgorithmProvider and include the key in the call to <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375383%28v=vs.85%29.aspx"" rel=""noreferrer"">BCryptCreateHash</a>.</p>

<p>This is the completed code:</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;bcrypt.h&gt;
#pragma comment(lib, ""bcrypt.lib"") 
#define NT_SUCCESS(Status)          (((NTSTATUS)(Status)) &gt;= 0)

#define STATUS_UNSUCCESSFUL         ((NTSTATUS)0xC0000001L)

void __cdecl wmain(
    int                      argc,
    __in_ecount(argc) LPWSTR *wargv)
{
    BCRYPT_ALG_HANDLE       hAlg = NULL;
    BCRYPT_HASH_HANDLE      hHash = NULL;
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
    DWORD                   cbData = 0,
        cbHash = 0,
        cbHashObject = 0;
    PBYTE                   pbHashObject = NULL;
    PBYTE                   pbHash = NULL;
    CONST BYTE key[] = { ""SecretKey"" };
    CONST BYTE message[] = { ""&lt;SomeXmlData /&gt;"" };

    //open an algorithm handle
    if (!NT_SUCCESS(status = BCryptOpenAlgorithmProvider(
        &amp;hAlg,
        BCRYPT_SHA256_ALGORITHM,
        NULL,
        BCRYPT_ALG_HANDLE_HMAC_FLAG)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptOpenAlgorithmProvider\n"", status);
        goto Cleanup;
    }

    //calculate the size of the buffer to hold the hash object
    if (!NT_SUCCESS(status = BCryptGetProperty(
        hAlg,
        BCRYPT_OBJECT_LENGTH,
        (PBYTE)&amp;cbHashObject,
        sizeof(DWORD),
        &amp;cbData,
        0)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    //allocate the hash object on the heap
    pbHashObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHashObject);
    if (NULL == pbHashObject)
    {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    //calculate the length of the hash
    if (!NT_SUCCESS(status = BCryptGetProperty(
        hAlg,
        BCRYPT_HASH_LENGTH,
        (PBYTE)&amp;cbHash,
        sizeof(DWORD),
        &amp;cbData,
        0)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptGetProperty\n"", status);
        goto Cleanup;
    }

    //allocate the hash buffer on the heap
    pbHash = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHash);
    if (NULL == pbHash)
    {
        wprintf(L""**** memory allocation failed\n"");
        goto Cleanup;
    }

    //create a hash
    if (!NT_SUCCESS(status = BCryptCreateHash(
        hAlg,
        &amp;hHash,
        pbHashObject,
        cbHashObject,
        (PBYTE)key,
        sizeof(key)-1,
        0)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptCreateHash\n"", status);
        goto Cleanup;
    }

    //hash some data
    if (!NT_SUCCESS(status = BCryptHashData(
        hHash,
        (PBYTE)message,
        sizeof(message)-1,
        0)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptHashData\n"", status);
        goto Cleanup;
    }

    //close the hash
    if (!NT_SUCCESS(status = BCryptFinishHash(
        hHash,
        pbHash,
        cbHash,
        0)))
    {
        wprintf(L""**** Error 0x%x returned by BCryptFinishHash\n"", status);
        goto Cleanup;
    }

    printf(""The hash is:  "");
    for (DWORD i = 0; i &lt; cbHash; i++)
    {
        printf(""%2.2X-"", pbHash[i]);
    }


Cleanup:

    if (hAlg)
    {
        BCryptCloseAlgorithmProvider(hAlg, 0);
    }

    if (hHash)
    {
        BCryptDestroyHash(hHash);
    }

    if (pbHashObject)
    {
        HeapFree(GetProcessHeap(), 0, pbHashObject);
    }

    if (pbHash)
    {
        HeapFree(GetProcessHeap(), 0, pbHash);
    }
};
</code></pre>
","2540","<c++><c><winapi><hmac><cryptoapi>","2","6","1","2014-03-03 19:36:44","22155681","2","","","","","2014-03-03 13:19:47",""
"27864909","Setting PIN prompt in Smart Card Crypto Provider's dialog box","<p>I want to change the text that shows when invoking CryptoApi operation that requires smart card PIN. Current prompt is pretty generic (and in system's language), ""Please enter your authentication PIN"":</p>

<p><img src=""https://i.stack.imgur.com/ek3fG.png"" alt=""enter image description here""></p>

<p>This dialog shows when calling <code>CryptSignMessage</code> in COM object, but the call is made from C# WPF desktop app (.NET 4.5). How can I customize the dialog? I've found <code>PP_PIN_PROMPT_STRING</code> parameter for <code>CryptSetProvParam</code> function, but the function requires <code>HCRYPTPROV</code> and I don't have that handle. All I have is reader's name and signing certificate. Just can't wrap my head around it.</p>

<p>Is it possible to customize PIN dialog from either C++ or C# (preferably C#)?</p>
","<p>I believe the following should work.  As I don't have anything setup to test collecting the information I can't verify.</p>

<pre><code>[DllImport(""advapi32.dll"", SetLastError = true, CharSet = CharSet.Auto)]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool CryptAcquireContext(out IntPtr phProv, string pszContainer, string pszProvider, uint dwProvType, uint dwFlags);

[DllImport(""advapi32.dll"", SetLastError = true, CharSet = CharSet.Auto)]
[return: MarshalAs(UnmanagedType.Bool)]
static extern bool CryptSetProvParam(IntPtr hProv, uint dwParam, [In] byte[] pbData, uint dwFlags);

[DllImport(""advapi32.dll"")]
[return: MarshalAs(UnmanagedType.Bool)]
public static extern bool CryptReleaseContext(IntPtr hProv, uint dwFlags);

const string MS_DEF_PROV = ""Microsoft Base Cryptographic Provider v1.0"";
const uint NTE_BAD_KEYSET = 0x80090016;
const uint PROV_RSA_FULL = 1;
const uint CRYPT_VERIFYCONTEXT = 0xF0000000;
const uint CRYPT_NEWKEYSET = 0x00000008;
const uint PP_PIN_PROMPT_STRING = 0x2C;

public unsafe void SetPinText(string text)
{
    byte[] data = Encoding.UTF8.GetBytes(text);

    IntPtr hCryptProv;

    try
    {
        if (!CryptAcquireContext(out hCryptProv, null, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            if (Marshal.GetLastWin32Error() == NTE_BAD_KEYSET)
            {
                if (!CryptAcquireContext(out hCryptProv, null, null, PROV_RSA_FULL, CRYPT_NEWKEYSET))
                    throw new Exception(""Unable to acquire crypt context."");
            }
            else
            {
                throw new Exception(""Unable to acquire crypt context."");
            }
        }

        if (!CryptSetProvParam(hCryptProv, PP_PIN_PROMPT_STRING, DataColumn, 0))
            throw new Exception(""Unable to set prompt string."");
    }
    finally
    {
        if (hCryptProv != IntPtr.Zero)
        {
            CryptReleaseContext(hCryptProv, 0);
        }
    }
}
</code></pre>
","2498","<c#><c++><windows><cryptoapi>","2","1","1","2015-01-20 22:06:11","","3","","395718","","2015-01-13 09:23:29","2015-01-09 16:25:33",""
"16443253","Get the X509 data from a PFX certificate using CryptoAPI","<p>Good day. Stackoverflow has helped me many times before, but I am a bit stuck on this one and hope that someone can give me some pointers.</p>

<p>Background: I need to pass X509 data of a certificate to Adobe's SDK CertListCab in order to sign the PDF using my Acrobat plugin api.</p>

<p>My question is how can I get the X509 data from a PFX certificate using CryptoAPI?</p>

<p>I've doing the following:</p>

<ul>
<li><p>Converting my PFX certificate to a in-memory store.</p>

<p><code>CRYPT_DATA_BLOB data;</code></p></li>
<li><p>Open file and populate data.</p>

<blockquote>
<pre><code>FILE *fIn = fopen(""C:\\certificate\\MyPfx.pfx"", ""rb"")
    fseek(fIn, 0, SEEK_END);
    data.cbData = ftell(fIn);
    fseek(fIn, 0, SEEK_SET);
    data.pbData = (BYTE *)malloc(data.cbData);
    fread(data.pbData, 1, data.cbData, fIn);
    fclose(fIn);
</code></pre>
  
  <p><code>HCERTSTORE hCertStore = PFXImportCertStore(&amp;data, L""password"", 0);</code></p>
</blockquote></li>
<li><p>Find the certificate. There is only one.</p>

<blockquote>
  <p><code>PCCERT_CONTEXT hContext = CertFindCertificateInStore
              (hCertStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0, CERT_FIND_ANY, NULL, NULL);</code></p>
</blockquote></li>
<li><p>Get the public key information for the certificate.</p>

<blockquote>
  <p><code>BOOL bFreeHandle;
      HCRYPTPROV hProv; 
      DWORD dwKeySpec; 
      HCRYPTKEY hCertPubKey;</code> 
  <code>CryptAcquireCertificatePrivateKey
              (hContext, 0, NULL, &amp;hProv, &amp;dwKeySpec, &amp;bFreeHandle);</code></p>
  
  <p><code>CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
              &amp;hContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;hCertPubKey));</code></p>
</blockquote></li>
<li><p>Now I try to make space for the X509 data.</p>

<blockquote>
  <p><code>DWORD dwX509Len;</code>
  <code>BYTE *x509Data;</code>
  <code>CryptGetKeyParam(hCertPubKey,KP_CERTIFICATE,NULL,&amp;dwX509Len,0);</code></p>
  
  <p><code>x509Data = (BYTE*)malloc(dwX509Len);</code></p>
</blockquote></li>
<li><p>I pass in my buffer.</p>

<blockquote>
  <p><code>CryptGetKeyParam(hCertPubKey,KP_CERTIFICATE,x509Data,&amp;dwX509Len,0);</code></p>
</blockquote></li>
</ul>

<p>When I run my program I receive the error for CryptGetKeyParam:</p>

<blockquote>
  <p>NTE_BAD_TYPE : The dwParam parameter specifies an unknown value number.</p>
</blockquote>

<p>According to the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379949(v=vs.85).aspx"">docs</a>:</p>

<blockquote>
  <p>KP_CERTIFICATE : pbData is the address of a buffer that receives the X.509 certificate that has been encoded by using Distinguished Encoding Rules (DER). The public key in the certificate must match the corresponding signature or exchange key.</p>
</blockquote>

<p>Am I doing something wrong? Is there another way to obtain the x509 data?
Any help would be appreciated.</p>

<p>Regards,
Magda</p>
","<p>Looks like I've over-complicated the issue.</p>

<pre><code>hContext-&gt;pbCertEncoded
hContext-&gt;cbCertEncoded
</code></pre>

<p>Will give me the data I want.</p>

<p>Still don't understand why using <code>KP_CERTIFICATE</code> did not retrieve the X509 data...</p>
","2449","<c++><x509><cryptoapi><pfx>","6","3","1","2013-05-09 09:33:00","","0","2","2362457","","2013-05-08 18:14:12","2013-05-08 14:26:14",""
"64258","Encrypt/Decrypt across machines is a no-no","<p>I'm using an identical call to ""CryptUnprotectData"" (exposed from Crypt32.dll) between XP and Vista. Works fine in XP. I get the following exception when I run in Vista:</p>

<pre><code>""Decryption failed. Key not valid for use in specified state.""
</code></pre>

<p>As expected, the versions of crypt32.dll are different between XP and Vista (w/XP actually having the more recent, possibly as a result of SP3 or some other update).</p>

<p>More specifically, I'm encrypting data, putting it in the registry, then reading and decrypting using ""CryptUnprotectData"". UAC is turned off.</p>

<p>Anyone seen this one before?</p>
","<p>The <a href=""http://msdn.microsoft.com/en-us/library/aa380882.aspx"" rel=""nofollow noreferrer"">CryptUnprotectData function</a> documentation states that it usually only works when the user has the same logon credentials as the encrypter.</p>

<p>This suggests to me that maybe the key is tied to the user's current token. Since you mention Vista, this makes me think UAC and restricted tokens.</p>

<p>Can you show us some code? Can you give us more information about what you're doing with the data -- i.e. are you moving it between processes, or users, or computers?</p>
","2417","<encryption><windows-vista><cryptoapi>","3","4","2","2013-01-11 15:20:25","64301","1","","411022","Lars Truijens","2013-01-11 15:20:25","2008-09-15 16:06:03",""
"64258","Encrypt/Decrypt across machines is a no-no","<p>I'm using an identical call to ""CryptUnprotectData"" (exposed from Crypt32.dll) between XP and Vista. Works fine in XP. I get the following exception when I run in Vista:</p>

<pre><code>""Decryption failed. Key not valid for use in specified state.""
</code></pre>

<p>As expected, the versions of crypt32.dll are different between XP and Vista (w/XP actually having the more recent, possibly as a result of SP3 or some other update).</p>

<p>More specifically, I'm encrypting data, putting it in the registry, then reading and decrypting using ""CryptUnprotectData"". UAC is turned off.</p>

<p>Anyone seen this one before?</p>
","<p>Nice. Hopefully this is my bone-head move of the week! ;-)</p>

<blockquote>
  <p>This suggests to me that maybe the key
  is tied to the user's current token.</p>
</blockquote>

<p>That was it. Turns out I was using encrypted data from another machine (the XP one) and trying to decrypt on the Vista machine.</p>

<p>As the MSDN documentation states:</p>

<blockquote>
  <p>Usually, only a user with the same
  logon credentials as the encrypter can
  decrypt the data. In addition, <strong>the
  encryption and decryption must be done
  on the same computer.</strong></p>
</blockquote>

<p>Once I re-encrypted the data on the Vista machine, decryption works as expected.</p>

<p>Thanks.</p>
","2417","<encryption><windows-vista><cryptoapi>","3","1","2","2013-01-11 15:20:25","64301","1","","411022","Lars Truijens","2013-01-11 15:20:25","2008-09-15 16:06:03",""
"4793583","Implement Windows CryptoAPI CryptDeriveKey Using OpenSSL APIs","<p>I have a CryptoAPI code to encrypt\ decrypt given data using AES-128 and a key derived from a password using SHA-256.</p>

<p>How can I write an OpenSSL equivalent implementation so I would be able to encrypt data with it, then decrypt it with CryptoAPI and vice versa?</p>

<p>Trying to use EVP_BytesToKey with EVP_aes_128_cbc() and EVP_sha256() didn’t work “as is”. 
(By ""doesn't work"" I mean - can't decrypt CryptoAPI's generated encrypted data and vice versa. This does work for decrypt OpenSSL's encrypted data).</p>

<p>Any idea or good reference?</p>

<p>Thank you in advance.</p>

<p>Here is the Windows CryptoAPI code:</p>

<pre><code>// Get the handle to the default provider. 
      if(CryptAcquireContext(
                   &amp;hCryptProv, 
                   NULL, 
                   MS_ENH_RSA_AES_PROV, 
                   PROV_RSA_AES, 
                   CRYPT_VERIFYCONTEXT))
          {
                   _tprintf(
                             TEXT(""A cryptographic provider has been acquired. \n""));
          }
          else
          {
                   goto Exit_PrepareCAPI;
          }
          // Create a hash object. 
          if(!CryptCreateHash(
                   hCryptProv, 
                   HASH_ALGORITHM, 
                   0, 
                   0, 
                   &amp;hHash))
          {
                   goto Exit_PrepareCAPI;
          }
          // Hash in the password data. 
          if(!CryptHashData(
                   hHash, 
                   (BYTE*) strPassword.c_str(),
                   strPassword.length(),
                   (DWORD)0)) 
          {
                   goto Exit_PrepareCAPI;
          }
          // Derive a session key from the hash object. 
          if(!CryptDeriveKey(
                   hCryptProv, 
                   ENCRYPT_ALGORITHM, 
                   hHash, 
                    0x00800000 /*128 bit*/, 
                   &amp;hKey))
          { 
                   goto Exit_PrepareCAPI;
          }
          DWORD cryptMode = CRYPT_MODE_CBC;

          if(!CryptSetKeyParam(
                   hKey, 
                   KP_MODE, 
                   (BYTE*)&amp;cryptMode, 
                   0))
          { 
                   goto Exit_PrepareCAPI;
          }

                   if(!CryptGetHashParam(
                   hHash,
                   HP_HASHSIZE,
                   (BYTE *)&amp;dwHashLen,
                   &amp;dwHashLenSize,
                   0))
          {
                   goto Exit_PrepareCAPI;
          }

          pbHash = new BYTE[dwHashLen];

          if(!CryptGetHashParam(
                   hHash,
                   HP_HASHVAL,
                   pbHash,
                   &amp;dwHashLen,
                   0))
          {
                   goto Exit_PrepareCAPI;
          }

          SecureZeroMemory( ivBuff, sizeof(ivBuff) );

          for(DWORD i = 16, j = 0 ; i &lt; dwHashLen ; i++, j++)
          {
                   ivBuff[j] = pbHash[i];
          }

          if(!CryptSetKeyParam(
                   hKey, 
                   KP_IV, 
                   ivBuff, 
                   0))
          { 
                   goto Exit_PrepareCAPI;
          }
          //
          // Read the data into pre-allocated pbBuffer
          //
// Encrypt data.           if(!CryptEncrypt(
                    hKey, 
                    NULL, 
                    fEOF,
                    0, 
                    pbBuffer, 
                    &amp;dwCount, 
                    dwBufferLen))
{ 
                    goto Exit_MyEncryptFile;
          } 
Exit_MyEncryptFile:
          // Cleanup allocated objects
</code></pre>
","<p>After all, this code worked:</p>

<pre><code>int generateKey(const string&amp; strSecter)
{    
SHA256_CTX sha256Ctx;
unsigned char hash[SHA256_DIGEST_LENGTH];
SecureZeroMemory(hash, sizeof hash);
SHA256_Init(&amp;sha256Ctx);
SHA256_Update(&amp;sha256Ctx, strSecter.c_str(), strSecter.length());
SHA256_Final(hash, &amp;sha256Ctx);
memcpy(Key, hash, AES_BLOCK_SIZE);
memcpy(IV, hash + AES_BLOCK_SIZE, AES_BLOCK_SIZE);

return 0;
}
</code></pre>

<p>Hope this will help someone.</p>
","2392","<c><encryption><cross-platform><openssl><cryptoapi>","4","3","1","2011-03-15 15:38:51","5314134","0","0","213615","","2011-01-25 13:33:05","2011-01-25 12:38:08",""
"29785054","CryptDecrypt fails with NT_BAD_DATA (0x80090005)","<p>The following code by Alejandro Magencio generate key pairs, encrypts and decrypts files with the Microsoft CryptoAPI works well, but only for files smaller than the key:
<a href=""http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx</a></p>

<p>I am trying to extend this code in order to encrypt and decrypt larger files.</p>

<p>Here is the complete listing as far as I got. It encrypts but on the second time in the decrypt loop I get a bad data error.</p>

<p>Any help will be greatly appreciated and I promise to post the full working code. </p>

<p>Thanks in advance!</p>

<pre><code>/*
    EncryptDecrypt.c

    This program was compiled on Windows 7 64-bit with Visual Studio 2013 Desktop Express. To run:

    EncryptDecrypt.exe k C:\temp\myprivate.key C:\temp\mypublic.key

    EncryptDecrypt.exe e C:\temp\myprivate.key C:\temp\todo.txt C:\temp\done.txt

    EncryptDecrypt.exe d C:\temp\mypublic.key C:\temp\done.txt C:\temp\redone.txt  
*/
#include ""stdio.h""
#include ""conio.h""
#include ""windows.h""
#include ""wincrypt.h""
#include ""tchar.h""

#define ENCRYPTEDLENGTH (128)
#define MAXSIZE (128 - 11) // size of chunk we can use for this program

// FUNCTIONS
int Keys(_TCHAR* strPublicKeyFile, _TCHAR* strPrivateKeyFile);
int Encrypt(_TCHAR* strPublicKeyFile, _TCHAR* strPlainFile, _TCHAR* strEncryptedFile);
int Decrypt(_TCHAR* strPrivateKeyFile, _TCHAR* strEncryptedFile, _TCHAR* strPlainFile);

// Main
int _tmain(int argc, _TCHAR* argv[])
{
    int iResult = 0;

    if ((argc == 4) &amp;&amp; (_tcscmp(argv[1], _T(""k"")) == 0))
    {
        // Generate a new key pair
        iResult = Keys(argv[2], argv[3]);
    }
    else if ((argc == 5) &amp;&amp; (_tcscmp(argv[1], _T(""e"")) == 0))
    {
        // Encrypt
        iResult = Encrypt(argv[2], argv[3], argv[4]);
    }
    else if ((argc == 5) &amp;&amp; (_tcscmp(argv[1], _T(""d"")) == 0))
    {
        // Decrypt
        iResult = Decrypt(argv[2], argv[3], argv[4]);
    }
else
 {
        // Show usage
        _tprintf(_T(""Usage:\n""));
        _tprintf(_T(""   - New key pair: EncryptDecrypt k public_key_file private_key_file\n""));
        _tprintf(_T(""   - Encrypt:      EncryptDecrypt e public_key_file plain_file encrypted_file\n""));
        _tprintf(_T(""   - Decrypt:      EncryptDecrypt d private_key_file encrypted_file plain_file\n""));
        iResult = 1;
    }

    _tprintf(_T(""\n&lt;&lt; Press any key to continue &gt;&gt;\n""));
    _getch();

    return iResult;
}
// End of Main

// Keys
int Keys(_TCHAR* strPublicKeyFile, _TCHAR* strPrivateKeyFile)
 {
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwPublicKeyLen = 0;
    DWORD dwPrivateKeyLen = 0;
    BYTE* pbPublicKey = NULL;
    BYTE* pbPrivateKey = NULL;
    HANDLE hPublicKeyFile = NULL;
    HANDLE hPrivateKeyFile = NULL;
    DWORD lpNumberOfBytesWritten = 0;

    __try
    {
        // Acquire access to key container
        _tprintf(_T(""CryptAcquireContext...\n""));
        if (!CryptAcquireContext(&amp;hCryptProv, _T(""ACMEENCRYPT.EncryptDecrypt""), NULL, PROV_RSA_FULL, 0))
        {
            // Error
            _tprintf(_T(""(ref 12) CryptAcquireContext error 0x%x\n""), GetLastError());

            // Try to create a new key container
            if (!CryptAcquireContext(&amp;hCryptProv, _T(""ACMEENCRYPT.EncryptDecrypt""), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
            {
                // Error
                _tprintf(_T(""(ref 13) CryptAcquireContext error 0x%x\n""), GetLastError());
                return 1;
            }
        }

        // Generate new key pair
        _tprintf(_T(""CryptGenKey...\n""));
        if (!CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_ARCHIVABLE, &amp;hKey))
        {
            // Error
            _tprintf(_T(""CryptGenKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get public key size
        _tprintf(_T(""CryptExportKey...\n""));
        if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwPublicKeyLen))
        {
            // Error
            _tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a buffer for the public key
        _tprintf(_T(""malloc...\n""));
        if (!(pbPublicKey = (BYTE *)malloc(dwPublicKeyLen)))
        {
            // Error
            _tprintf(_T(""(ref 29) malloc error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get public key
        _tprintf(_T(""CryptExportKey...\n""));
        if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbPublicKey, &amp;dwPublicKeyLen))
        {
            // Error
            _tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get private key size
        _tprintf(_T(""CryptExportKey...\n""));
        if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwPrivateKeyLen))
        {
            // Error
            _tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a buffer for the private key
        _tprintf(_T(""malloc...\n""));
        if (!(pbPrivateKey = (BYTE *)malloc(dwPrivateKeyLen)))
    {
            // Error
        _tprintf(_T(""(ref 30) malloc error 0x%x\n""), GetLastError());
        return 1;
    }

        // Get private key
        _tprintf(_T(""CryptExportKey...\n""));
        if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, pbPrivateKey, &amp;dwPrivateKeyLen))
        {
            // Error
            _tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a file to save the public key
        _tprintf(_T(""CreateFile...\n""));
        if ((hPublicKeyFile = CreateFile(
            strPublicKeyFile,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 21) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Write the public key to the file
        _tprintf(_T(""WriteFile...\n""));
        if (!WriteFile(
            hPublicKeyFile,
            (LPCVOID)pbPublicKey,
            dwPublicKeyLen,
            &amp;lpNumberOfBytesWritten,
            NULL
            ))
        {
            // Error
            _tprintf(_T(""(ref 51) WriteFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a file to save the private key
        _tprintf(_T(""CreateFile...\n""));
        if ((hPrivateKeyFile = CreateFile(
            strPrivateKeyFile,
            GENERIC_WRITE,
            0,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 22) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Write the private key to the file
        _tprintf(_T(""WriteFile...\n""));
        if (!WriteFile(
            hPrivateKeyFile,
            (LPCVOID)pbPrivateKey,
            dwPrivateKeyLen,
            &amp;lpNumberOfBytesWritten,
            NULL
            ))
        {
            // Error
            _tprintf(_T(""(ref 52) WriteFile error 0x%x\n""), GetLastError());
            return 1;
        }

        return 0;
    }
    __finally
    {
        // Clean up       
        if (!pbPublicKey) {
            _tprintf(_T(""free...\n""));
            free(pbPublicKey);
        }
        if (!pbPrivateKey) {
            _tprintf(_T(""free...\n""));
            free(pbPrivateKey);
        }
        if (hPublicKeyFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPublicKeyFile);
        }
        if (hPrivateKeyFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPrivateKeyFile);
        }
        if (hKey) {
            _tprintf(_T(""CryptDestroyKey...\n""));
            CryptDestroyKey(hKey);
        }
        if (hCryptProv) {
            _tprintf(_T(""CryptReleaseContext...\n""));
            CryptReleaseContext(hCryptProv, 0);
        }
    }
}
// End of Keys

// Encrypt
int Encrypt(_TCHAR* strPublicKeyFile, _TCHAR* strPlainFile, _TCHAR* strEncryptedFile)
{
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwPublicKeyLen = 0;
    DWORD dwDataLen = 0;
    DWORD dwEncryptedLen = 0;
    DWORD myloopcount = 0;
    DWORD mymodulus = 0;
    DWORD i = 0;
    DWORD myencryptedlength = 0;
    DWORD mymaxsize = MAXSIZE;
    BYTE* pbPublicKey = NULL;
    BYTE* pbData = NULL;
    BYTE* pbEncData = NULL;
    HANDLE hPublicKeyFile = NULL;
    HANDLE hEncryptedFile = NULL;
    HANDLE hPlainFile = NULL;
    DWORD lpNumberOfBytesWritten = 0;

    __try
    {
        // Acquire access to key container
        _tprintf(_T(""CryptAcquireContext...\n""));
        if (!CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            // Error
            _tprintf(_T(""(ref 9) CryptAcquireContext error 0x%x\n""), GetLastError());
            return 1;
        }

        // Open public key file
        _tprintf(_T(""CreateFile...\n""));
        if ((hPublicKeyFile = CreateFile(
            strPublicKeyFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 14) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get file size
        _tprintf(_T(""GetFileSize...\n""));
        if ((dwPublicKeyLen = GetFileSize(hPublicKeyFile, NULL)) == INVALID_FILE_SIZE)
        {
            // Error
            _tprintf(_T(""(ref 43) GetFileSize error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a buffer for the public key
        _tprintf(_T(""malloc...\n""));
        if (!(pbPublicKey = (BYTE *)malloc(dwPublicKeyLen)))
        {
            // Error
            _tprintf(_T(""(ref 22) malloc error 0x%x\n""), GetLastError());
            return 1;
        }

        // Read public key
        _tprintf(_T(""ReadFile...\n""));
        if (!ReadFile(hPublicKeyFile, pbPublicKey, dwPublicKeyLen, &amp;dwPublicKeyLen, NULL))
        {
            // Error
            _tprintf(_T(""(ref 31) ReadFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Import public key
        _tprintf(_T(""CryptImportKey...\n""));
        if (!CryptImportKey(hCryptProv, pbPublicKey, dwPublicKeyLen, 0, 0, &amp;hKey))
        {
            // Error
            _tprintf(_T(""(ref 38) CryptImportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Open plain text file
        _tprintf(_T(""CreateFile...\n""));
        if ((hPlainFile = CreateFile(
            strPlainFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 15) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get file size
        _tprintf(_T(""GetFileSize...\n""));
        if ((dwDataLen = GetFileSize(hPlainFile, NULL)) == INVALID_FILE_SIZE)
        {
            // Error
            _tprintf(_T(""(ref 40) GetFileSize error 0x%x\n""), GetLastError());
            return 1;
        }

        _tprintf(_T(""my data length is %d\n""), dwDataLen);
        _tprintf(_T(""my max size is %d\n""), MAXSIZE);

        // Get length for encrypted data
        if (!CryptEncrypt(hKey, NULL, TRUE, 0, NULL, &amp;dwEncryptedLen, 0))
        {
            // Error
            _tprintf(_T(""(ref 1) CryptEncrypt error 0x%x\n""), GetLastError());
            return 1;
        }

        if (dwDataLen &lt; MAXSIZE)
        {
            // as before... Just one run through.

            // BEGIN OLD BLOCK
            // Create a buffer for the plain text
            _tprintf(_T(""malloc...\n""));
            if (!(pbData = (BYTE *)malloc(dwDataLen)))
            {
                // Error
                _tprintf(_T(""(ref 23) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            // Read plain text
            _tprintf(_T(""ReadFile...\n""));
            if (!ReadFile(hPlainFile, pbData, dwDataLen, &amp;dwDataLen, NULL))
            {
                // Error
                _tprintf(_T(""(ref 32) ReadFile error 0x%x\n""), GetLastError());
                return 1;
            }

            // Next line: dwEncryptedLen is the length of key! Ergo, when decrypting
            //  use 128 instead of MAXSIZE:
            _tprintf(_T(""My encrypted length is %d\n""), dwEncryptedLen); 

            // Create a buffer for encrypted data
            _tprintf(_T(""realloc...\n""));
            if (!(pbData = (BYTE *)realloc(pbData, dwEncryptedLen)))
            {
                // Error
                _tprintf(_T(""(ref 24) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            // Encrypt data
            if (!CryptEncrypt(hKey, NULL, TRUE, 0, pbData, &amp;dwDataLen, dwEncryptedLen))
            {
                // Error
                _tprintf(_T(""(ref 2) CryptEncrypt error 0x%x\n""), GetLastError());
                return 1;
            }

            // Create a file to save the encrypted data
            _tprintf(_T(""CreateFile...\n""));
            if ((hEncryptedFile = CreateFile(
                strEncryptedFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,          // will truncate if already existing
                FILE_ATTRIBUTE_NORMAL,
                NULL
                )) == INVALID_HANDLE_VALUE)
            {
                // Error
                _tprintf(_T(""(ref 16) CreateFile error 0x%x\n""), GetLastError());
                return 1;
            }

            // Write the public key to the file
            _tprintf(_T(""WriteFile...\n""));
            if (!WriteFile(
                hEncryptedFile,
                (LPCVOID)pbData,
                dwDataLen,
                &amp;lpNumberOfBytesWritten,
                NULL
                ))
            {
                // Error
                _tprintf(_T(""(ref 47) WriteFile error 0x%x\n""), GetLastError());
                return 1;
            }
            // END OLD BLOCK
            return 0;
        }
        else
        {
            // File is bigger than key.

            // Figure out how many times we will need to loop.
            myloopcount = (DWORD)(dwDataLen / MAXSIZE);
            _tprintf(_T(""Loop counter is %d\n""), myloopcount);

            mymodulus = dwDataLen % MAXSIZE;
            _tprintf(_T(""Remainder is %d\n""), mymodulus);

            if (mymodulus == 0) // no remainder
            {
                myloopcount -= 1; // decrement by one
            }

            // Create a file to save the encrypted data with append flag.
            // The parameter for appending data to a file is FILE_APPEND_DATA in the CreateFile function. 
            // Ref: http://msdn.microsoft.com/en-us/library/windows/desktop/aa363778(v=vs.85).aspx
            _tprintf(_T(""CreateFile...\n""));
            if ((hEncryptedFile = CreateFile(
                strEncryptedFile,  // if you hardcode a filename here, use syntax: _T(""C:\\temp\\append.txt""),
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_APPEND_DATA,
                NULL
                )) == INVALID_HANDLE_VALUE)
            {
                // Error
                _tprintf(_T(""(ref 17) CreateFile error saving the encrypted data 0x%x\n""), GetLastError());
                return 1;
            }

            // Create a buffer for the plain text
            _tprintf(_T(""malloc...\n""));
            pbData = NULL;
            if (!(pbData = (BYTE *)malloc(MAXSIZE)))
            {
                // Error
                _tprintf(_T(""(ref 25) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            _tprintf(_T(""malloc...\n""));
            pbEncData = NULL;
            if (!(pbEncData = (BYTE *)malloc(ENCRYPTEDLENGTH)))
            {
                // Error
                _tprintf(_T(""(ref 53) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            for (i = 0; i &lt; myloopcount; i++)
            {
                // ref https://msdn.microsoft.com/en-us/library/windows/desktop/aa365541(v=vs.85).aspx
                if (i &gt; 0)
                {
                    SetFilePointer(
                        hPlainFile,     //     HANDLE hFile,
                        MAXSIZE,        //    LONG lDistanceToMove,
                        NULL,           //  PLONG lpDistanceToMoveHigh,
                        FILE_CURRENT
                        );
                }

                mymaxsize = MAXSIZE;

                // Read plain text
                _tprintf(_T(""ReadFile...\n""));
                if (!ReadFile(hPlainFile, pbData, mymaxsize, &amp;mymaxsize, NULL))
                {
                    // Error
                    _tprintf(_T(""(ref 33) ReadFile error 0x%x\n""), GetLastError());
                    return 1;
                }

                // Encrypt data
                if (!CryptEncrypt(hKey, NULL, FALSE, 0, pbEncData, &amp;mymaxsize, dwEncryptedLen))
                {
                    // Error
                    _tprintf(_T(""(ref 4) CryptEncrypt error in loop number %i 0x%x\n""),i, GetLastError());
                    return 1;
                }

                _tprintf(_T(""WriteFile...\n""));
                if (!WriteFile(
                    hEncryptedFile,
                    (LPCVOID)pbEncData,
                    dwDataLen,
                    &amp;lpNumberOfBytesWritten,
                    NULL
                    ))
                {
                    // Error
                    _tprintf(_T(""(ref 48) WriteFile error, i is %d 0x%x\n""), i, GetLastError());
                    return 1;
                }
            } // end for loop

            SetFilePointer(
                hPlainFile,     //     HANDLE hFile,
                MAXSIZE,        //     LONG lDistanceToMove,
                NULL,           //     PLONG lpDistanceToMoveHigh,
                FILE_CURRENT    
                );

            mymaxsize = MAXSIZE;

            if (mymodulus == 0)
            {
                _tprintf(_T(""ReadFile...\n""));
                if (!ReadFile(hPlainFile, pbData, mymaxsize, &amp;mymaxsize, NULL))
                {
                    // Error
                    _tprintf(_T(""(ref 34) ReadFile error 0x%x\n""), GetLastError());
                    return 1;
                }

                // Encrypt data; last chunk must have TRUE flag when encrypting.
                if (!CryptEncrypt(hKey, NULL, TRUE, 0, pbEncData, &amp;dwDataLen, dwEncryptedLen))
                {
                    // Error
                    _tprintf(_T(""(ref 6) CryptEncrypt error 0x%x\n""), GetLastError());
                    return 1;
                }
            }
            else
            {
                _tprintf(_T(""ReadFile...\n""));
                if (!ReadFile(hPlainFile, pbData, mymodulus, &amp;mymodulus, NULL))
                {
                    // Error
                    _tprintf(_T(""(ref 35) ReadFile error 0x%x\n""), GetLastError());
                    return 1;
                }

                // Encrypt data
                if (!CryptEncrypt(hKey, NULL, TRUE, 0, pbEncData, &amp;mymodulus, dwEncryptedLen))
                {
                    // Error
                    _tprintf(_T(""(ref 8) CryptEncrypt error 0x%x\n""), GetLastError());
                    return 1;
                }
            }

            // Finish writing.
            _tprintf(_T(""WriteFile...\n""));
            if (!WriteFile(
                hEncryptedFile,
                (LPCVOID)pbEncData,
                dwDataLen,
                &amp;lpNumberOfBytesWritten,
                NULL
                ))
            {
                // Error
                _tprintf(_T(""(ref 49) WriteFile error 0x%x\n""), GetLastError());
                return 1;
            }
        }
        return 0;
    }
    __finally
    {
        // Clean up
        if (!pbPublicKey) {
            _tprintf(_T(""free...\n""));
            free(pbPublicKey);
        }
        if (!pbData) {
            _tprintf(_T(""free...\n""));
            free(pbData);
        }
        if (hPublicKeyFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPublicKeyFile);
        }
        if (hPlainFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPlainFile);
        }
        if (hEncryptedFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hEncryptedFile);
        }
        if (hKey) {
            _tprintf(_T(""CryptDestroyKey...\n""));
        CryptDestroyKey(hKey);
        }
        if (hCryptProv) {
            _tprintf(_T(""CryptReleaseContext...\n""));
            CryptReleaseContext(hCryptProv, 0);
        }
    }
}
// End of Encrypt

// Decrypt
int Decrypt(_TCHAR* strPrivateKeyFile, _TCHAR* strEncryptedFile, _TCHAR* strPlainFile)
{
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwPrivateKeyLen = 0;
    DWORD dwDataLen = 0;
    DWORD myloopcount = 0;
    DWORD mymodulus = 0;
    DWORD i = 0;
    DWORD mysize = 0;
    BYTE* pbPrivateKey = NULL;
    BYTE* pbData = NULL;
    BYTE* pbEncData = NULL;
    HANDLE hPrivateKeyFile = NULL;
    HANDLE hEncryptedFile = NULL;
    HANDLE hPlainFile = NULL;
    DWORD lpNumberOfBytesWritten = 0;

    __try
    {
        // Acquire access to key container
        _tprintf(_T(""CryptAcquireContext...\n""));
        if (!CryptAcquireContext(&amp;hCryptProv, _T(""ACMEENCRYPT.EncryptDecrypt""), NULL, PROV_RSA_FULL, 0))
        {
            // Error
            _tprintf(_T(""(ref 10) CryptAcquireContext error 0x%x\n""), GetLastError());

            // Try to create a new key container
            if (!CryptAcquireContext(&amp;hCryptProv, _T(""ACMEENCRYPT.EncryptDecrypt""), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
            {
                // Error
                _tprintf(_T(""(ref 11) CryptAcquireContext error 0x%x\n""), GetLastError());
                return 1;
            }
        }

        // Open private key file
        _tprintf(_T(""CreateFile...\n""));
        if ((hPrivateKeyFile = CreateFile(
            strPrivateKeyFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 18) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get file size
        _tprintf(_T(""GetFileSize...\n""));
        if ((dwPrivateKeyLen = GetFileSize(hPrivateKeyFile, NULL)) == INVALID_FILE_SIZE)
        {
            // Error
            _tprintf(_T(""(ref 41) GetFileSize error 0x%x\n""), GetLastError());
            return 1;
        }

        // Create a buffer for the private key
        _tprintf(_T(""malloc...\n""));
        if (!(pbPrivateKey = (BYTE *)malloc(dwPrivateKeyLen)))
        {
            // Error
            _tprintf(_T(""(ref 27) malloc error 0x%x\n""), GetLastError());
            return 1;
        }

        // Read private key
        _tprintf(_T(""ReadFile...\n""));
        if (!ReadFile(hPrivateKeyFile, pbPrivateKey, dwPrivateKeyLen, &amp;dwPrivateKeyLen, NULL))
        {
            // Error
            _tprintf(_T(""(ref 36) ReadFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Import private key
        _tprintf(_T(""CryptImportKey...\n""));
        if (!CryptImportKey(hCryptProv, pbPrivateKey, dwPrivateKeyLen, 0, 0, &amp;hKey))
        {
            // Error
            _tprintf(_T(""(ref 39) CryptImportKey error 0x%x\n""), GetLastError());
            return 1;
        }

        // Open encrypted file
        _tprintf(_T(""CreateFile...\n""));
        if ((hEncryptedFile = CreateFile(
            strEncryptedFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
            )) == INVALID_HANDLE_VALUE)
        {
            // Error
            _tprintf(_T(""(ref 19) CreateFile error 0x%x\n""), GetLastError());
            return 1;
        }

        // Get file size
        _tprintf(_T(""GetFileSize...\n""));
        if ((dwDataLen = GetFileSize(hEncryptedFile, NULL)) == INVALID_FILE_SIZE)
        {
            // Error
            _tprintf(_T(""(ref 42) GetFileSize error 0x%x\n""), GetLastError());
            return 1;
        }

        if (dwDataLen == ENCRYPTEDLENGTH)
        {
            // Create a buffer for the encrypted data
            _tprintf(_T(""malloc...\n""));
            if (!(pbData = (BYTE *)malloc(dwDataLen)))
            {
                // Error
                _tprintf(_T(""(ref 28) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            // Read encrypted data
            _tprintf(_T(""ReadFile...\n""));
            if (!ReadFile(hEncryptedFile, pbData, dwDataLen, &amp;dwDataLen, NULL))
            {
                // Error
                _tprintf(_T(""(ref 37) ReadFile error 0x%x\n""), GetLastError());
                return 1;
            }

            if (!CryptDecrypt(hKey, NULL, TRUE, 0, pbData, &amp;dwDataLen))
            {
                // Error
                _tprintf(_T(""(ref 54) CryptDecrypt error 0x%x\n""), GetLastError());
                return 1;
            }

            // Create a file to save the plain text
            _tprintf(_T(""CreateFile...\n""));
            if ((hPlainFile = CreateFile(
                strPlainFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                )) == INVALID_HANDLE_VALUE)
            {
                // Error
                _tprintf(_T(""(ref 20) CreateFile error 0x%x\n""), GetLastError());
                return 1;
            }

            // Write the plain text the file
            _tprintf(_T(""WriteFile...\n""));
            if (!WriteFile(
                hPlainFile,
                (LPCVOID)pbData,
                dwDataLen,
                &amp;lpNumberOfBytesWritten,
                NULL
                ))
            {
                // Error
                _tprintf(_T(""(ref 50) WriteFile error 0x%x\n""), GetLastError());
                return 1;
            }
        }
        else
        {
            // encrypted file is bigger than 128 bytes
            // Figure out how many times we will need to loop.
            myloopcount = (DWORD)(dwDataLen / ENCRYPTEDLENGTH);
            _tprintf(_T(""Loop counter is %d\n""), myloopcount);

            mymodulus = dwDataLen % ENCRYPTEDLENGTH;
            _tprintf(_T(""Remainder is %d\n""), mymodulus);

            if (mymodulus == 0) // no remainder
            {
                myloopcount -= 1; // decrement by one
            }

            // Create a file to save the plain text
            _tprintf(_T(""CreateFile...\n""));
            if ((hPlainFile = CreateFile(
                strPlainFile,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_APPEND_DATA,
                NULL
                )) == INVALID_HANDLE_VALUE)
            {
                // Error
                _tprintf(_T(""(ref 55) CreateFile error 0x%x\n""), GetLastError());
                return 1;
            }

            // Create a buffer for the encrypted data
            _tprintf(_T(""malloc...\n""));
            if (!(pbData = (BYTE *)malloc(ENCRYPTEDLENGTH)))
            {
                // Error
                _tprintf(_T(""(ref 56) malloc error 0x%x\n""), GetLastError());
                return 1;
            }

            for (i = 0; i &lt; myloopcount; i++)
            {
                // ref https://msdn.microsoft.com/en-us/library/windows/desktop/aa365541(v=vs.85).aspx
                if (i &gt; 0)
                {
                    SetFilePointer(
                        hEncryptedFile,     //  HANDLE hFile,
                        ENCRYPTEDLENGTH,    //  LONG lDistanceToMove,
                        NULL,               //  PLONG lpDistanceToMoveHigh,
                        FILE_CURRENT
                        );
                }

                mysize = ENCRYPTEDLENGTH;

                // Read encrypted data
                _tprintf(_T(""ReadFile...\n""));
                if (!ReadFile(hEncryptedFile, pbData, mysize, &amp;mysize, NULL))
                {
                    // Error
                    _tprintf(_T(""(ref 37) ReadFile error 0x%x\n""), GetLastError());
                    return 1;
                }

                if (!CryptDecrypt(hKey, NULL, FALSE, 0, pbData, &amp;mysize))
                {
                    // Error
                    _tprintf(_T(""(ref 54) CryptDecrypt error in loop number %d 0x%x\n""),i, GetLastError());
                    return 1;
                }

                // Write the plain text the file
                _tprintf(_T(""WriteFile...\n""));
                if (!WriteFile(
                    hPlainFile,
                    (LPCVOID)pbData,
                    dwDataLen,
                    &amp;lpNumberOfBytesWritten,
                    NULL
                    ))
                {
                    // Error
                    _tprintf(_T(""(ref 50) WriteFile error 0x%x\n""), GetLastError());
                    return 1;
                }
            } // end for loop

            SetFilePointer(
                hEncryptedFile,     //     HANDLE hFile,
                ENCRYPTEDLENGTH,        //     LONG lDistanceToMove,
                NULL,           //     PLONG lpDistanceToMoveHigh,
                FILE_CURRENT    //  DWORD dwMoveMethod, with FILE_CURRENT it's more efficient, not forced 
                //  to do (i * MAXSIZE) for second parameter size
                );

            mysize = ENCRYPTEDLENGTH;

            // Read encrypted data
            _tprintf(_T(""ReadFile...\n""));
            if (!ReadFile(hEncryptedFile, pbData, mysize, &amp;mysize, NULL))
            {
                // Error
                _tprintf(_T(""(ref 37) ReadFile error 0x%x\n""), GetLastError());
                return 1;
            }

            if (!CryptDecrypt(hKey, NULL, TRUE, 0, pbData, &amp;mysize))
            {
                // Error
                _tprintf(_T(""(ref 54) CryptDecrypt error 0x%x\n""), GetLastError());
                return 1;
            }

            // Write the plain text the file
            _tprintf(_T(""WriteFile...\n""));
            if (!WriteFile(
                hPlainFile,
                (LPCVOID)pbData,
                dwDataLen,
                &amp;lpNumberOfBytesWritten,
                NULL
                ))
            {
                // Error
                _tprintf(_T(""(ref 50) WriteFile error 0x%x\n""), GetLastError());
                return 1;
            }
        }

        return 0;
    }
    __finally
    {
        // Clean up       
        if (!pbPrivateKey) {
            _tprintf(_T(""free...\n""));
            free(pbPrivateKey);
        }
        if (!pbData) {
            _tprintf(_T(""free...\n""));
            free(pbData);
        }
        if (hPrivateKeyFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPrivateKeyFile);
        }
        if (hEncryptedFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hEncryptedFile);
        }
        if (hPlainFile) {
            _tprintf(_T(""CloseHandle...\n""));
            CloseHandle(hPlainFile);
        }
        if (hKey) {
            _tprintf(_T(""CryptDestroyKey...\n""));
            CryptDestroyKey(hKey);
        }
        if (hCryptProv) {
            _tprintf(_T(""CryptReleaseContext...\n""));
            CryptReleaseContext(hCryptProv, 0);
        }
    }
}
// End of Decrypt
</code></pre>
","<p>Yes; in general you cannot use RSA to encrypt data larger than the key size in a single pass, the limit is infact slightly shorter than the key size, depending on padding.</p>

<p>To encrypt larger amounts of data you would typically use a hybrid approach whereby you generate a symmetric key (say AES) and use that to encrypt your data.</p>

<p>You can then use your RSA public key to encrypt the AES key, combine it with the ciphertext and you have a blob that requires the private key to decrypt.</p>
","2349","<c><winapi><encryption><cryptoapi>","0","1","1","2015-04-22 10:36:44","","4","","","","","2015-04-21 23:35:21",""
"27396474","How export symetric AES key cryptoapi","<p>I have some problem. I need generate and export symmetric key with use CryptoAPI. </p>

<pre><code>     if(CryptAcquireContext(&amp;hCryptProv_AES, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES,  0))
    {
        _tprintf(
            TEXT(""A cryptographic provider has been acquired. \n""));
    }
    else
    {
            DWORD d = GetLastError();
            std::cout&lt;&lt;"""";
            return -1;
    }

    if (!CryptGenKey(hCryptProv_AES,CALG_AES_256,CRYPT_EXPORTABLE,&amp;hSessionKey_AES))
        {
            DWORD d = GetLastError();
            std::cout&lt;&lt;"""";
            return -1;
        }
    else 
    {
        std::cout&lt;&lt;""OK"";
    }

    // Export key
   BYTE keybuf[ 1024 ], buffer[ 1024 ];
   DWORD i, keylen = sizeof( buffer );

    struct ekb
   {
       PUBLICKEYSTRUC  hdr;
       ALG_ID                 algId;
       BYTE                    key[1];
   } *encKey = (struct ekb *)buffer;

    bool bbb = CryptExportKey(hSessionKey_AES, NULL, SIMPLEBLOB, 0, (BYTE *)encKey, &amp;keylen);
    DWORD f = GetLastError();
</code></pre>

<p>but don't can take AES key.
How I can fix this trouble, please help. How I can get AES key??</p>

<p>UPDATE
For example I use next code and can get public RSA key.</p>

<pre><code>char * base_txt = ""Test text"";
    char * enc_text = """";


     if(CryptAcquireContext(&amp;hCryptProv_RSA, NULL, MS_ENHANCED_PROV , PROV_RSA_FULL,  0))
    {
        _tprintf(
            TEXT(""A cryptographic provider has been acquired. \n""));
    }
    else
    {
            DWORD d = GetLastError();
            std::cout&lt;&lt;"""";
            return -1;
    }

    if (!CryptGenKey(hCryptProv_RSA,AT_KEYEXCHANGE,1024&lt;&lt;16,&amp;hSessionKey))
        {
            DWORD d = GetLastError();
            std::cout&lt;&lt;"""";
            return -1;
        }

    RSAPubKey1024 key; 
    DWORD dwLen=sizeof(RSAPubKey1024);



    // Export key
    bool bb = CryptExportKey(hSessionKey,NULL,PUBLICKEYBLOB,0,(BYTE *)&amp;key,&amp;dwLen);
</code></pre>

<p><strong>UPDATE 2</strong>
After export I import key and try encrypt and decrypt</p>

<pre><code>HCRYPTPROV hCryptProv_AES22;
    if (CryptAcquireContext(&amp;hCryptProv_AES22, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))
    {
        printf(""A cryptographic provider has been acquired.\r\n"");
    }
    else
    {
        DWORD d = GetLastError();
        return -1;
    }
    int iii =  CryptImportKey(hCryptProv_AES22,(BYTE *)&amp;exportKey_AES,keylen,NULL,NULL,&amp;hSessionKey_AES2);

    if(CryptSetKeyParam(hSessionKey_AES2,KP_IV, exportKey_AES, 0))
    {
        BYTE encryptedMessage[1024];
        const char * message = ""Decryption Works -- using multiple blocks"";
        BYTE messageLen = (BYTE)strlen(message);
        memcpy(encryptedMessage, message, messageLen);
        DWORD encryptedMessageLen = messageLen;
        CryptEncrypt(hSessionKey_AES2, NULL, TRUE, 0, encryptedMessage, &amp;encryptedMessageLen, sizeof(encryptedMessage));    
        CryptDecrypt(hSessionKey_AES2,NULL,TRUE,0,encryptedMessage, &amp;encryptedMessageLen);

    }
</code></pre>
","<p><code>CryptExportKey</code> has a limitation. It <strong>requires</strong> to export non-public keys in encrypted form. When you export public part or RSA key pair, it is OK to make the 2nd <code>CryptExportKey</code> parameter <code>NULL</code> and export key in unencrypted form. However, you can not do the same for symmetric key that <strong>must</strong> specify non-null <code>hExpKey</code> parameter.
If you specify <code>hExpKey</code> parameter, your code works, see example:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;cstdio&gt;

int main(int argc, char *argv[])
{
    // Create AES key
    HCRYPTPROV hCryptProv_AES;
    if (CryptAcquireContext(&amp;hCryptProv_AES, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))
    {
        printf(""A cryptographic provider has been acquired.\r\n"");
    }
    else
    {
        DWORD d = GetLastError();
        return -1;
    }
    HCRYPTKEY hSessionKey_AES;
    if (!CryptGenKey(hCryptProv_AES, CALG_AES_256, CRYPT_EXPORTABLE, &amp;hSessionKey_AES))
    {
        DWORD d = GetLastError();
        return -1;
    }
    // Create RSA key to encrypt AES one
    HCRYPTKEY hSessionKey;
    if (!CryptGenKey(hCryptProv_AES, AT_KEYEXCHANGE, 1024 &lt;&lt; 16, &amp;hSessionKey))
    {
        DWORD d = GetLastError();
        return -1;
    }
    // Export key
    DWORD keylen;
    BOOL ok = CryptExportKey(hSessionKey_AES, hSessionKey, SIMPLEBLOB, 0, NULL, &amp;keylen);
    if (ok == FALSE)
    {
        DWORD d = GetLastError();
        return -1;
    }
    BYTE *encKey = (BYTE *)malloc(keylen);
    ok = CryptExportKey(hSessionKey_AES, hSessionKey, SIMPLEBLOB, 0, encKey, &amp;keylen);
    if (ok == FALSE)
    {
        DWORD d = GetLastError();
        return -1;
    }
    else
        printf(""A cryptographic key export succeeded.\r\n"");
    return 0;
}
</code></pre>

<p>If you want to do key exchange (lets say, if you want that Alice send to Bob her AES key), you have to do following steps:</p>

<ol>
<li>Bob generates RSA key and sends its public part to Alice. See, Bob starts, not Alice!</li>
<li>Bob sends his key public part to Alice.</li>
<li>Alice generates AES key.</li>
<li>Alice encrypts AES key with Bob's public key.</li>
<li>Alice sends the AES key to Bob.</li>
<li>Bob uses his private key to decrypt AES key (i. e. import it with <code>CryptImportKey</code>). When you import the key, you set <code>hPubKey</code> parameter to non-NULL value, actually you set it to Bob's key handle, otherwise import will fail, because the AES key in encrypted.</li>
</ol>
","2340","<c++><encryption><aes><cryptoapi>","1","3","1","2014-12-10 10:03:14","27397116","2","1","4344752","","2014-12-10 10:03:14","2014-12-10 08:38:10",""
"1531701","cryptoapi windows 7 support","<p>Microsoft has introduced cryptography next generation <a href=""http://msdn.microsoft.com/en-us/library/aa376210%28VS.85%29.aspx"" rel=""nofollow noreferrer"">(CNG)</a> from Vista and server 2008 onwards. But my question is to know <strong>whether Microsoft supports the old <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380255%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">MS CAPI</a> (say for eg. in windows 2003 and windows xp) in Windows 7 and Server 2008</strong>.</p>

<p>Thanks</p>

<p>Raj</p>
","<p>Do you mean if Windows 7 and Windows Server 2008 CryptoAPI is backwards compatible with older versions of CryptoAPI then yes.</p>

<p>All new CNG functionality is of course not.</p>
","2283","<windows><windows-7><windows-server-2008><cryptoapi><mscapi>","0","1","2","2015-06-09 02:50:29","1531940","0","","608639","","2015-06-09 02:50:29","2009-10-07 13:39:07",""
"1531701","cryptoapi windows 7 support","<p>Microsoft has introduced cryptography next generation <a href=""http://msdn.microsoft.com/en-us/library/aa376210%28VS.85%29.aspx"" rel=""nofollow noreferrer"">(CNG)</a> from Vista and server 2008 onwards. But my question is to know <strong>whether Microsoft supports the old <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380255%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">MS CAPI</a> (say for eg. in windows 2003 and windows xp) in Windows 7 and Server 2008</strong>.</p>

<p>Thanks</p>

<p>Raj</p>
","<p>Yes. Windows 7 provides both APIs: CNG and CAPI.</p>

<p>Nevertheless, just try with verfy context:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;Wincrypt.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    HCRYPTPROV hCryptProv = NULL;  
    if(CryptAcquireContext(&amp;hCryptProv,NULL,NULL,PROV_RSA_FULL,CRYPT_VERIFYCONTEXT))                     
    {
        printf(""CryptoAPI working\n\n"");
        exit(0);    
    }else
    {
        printf(""Error 0x%.8x"",GetLastError());
        exit(1);
    }
}
</code></pre>
","2283","<windows><windows-7><windows-server-2008><cryptoapi><mscapi>","0","1","2","2015-06-09 02:50:29","1531940","0","","608639","","2015-06-09 02:50:29","2009-10-07 13:39:07",""
"43656951","AES-128 encryption using WinCrypt","<p>I need to encrypt strings under AES-128 for my C/C++ app making use of WinCrypt.</p>

<p>Just for understanding how the whole thing works, I have written a program to encrypt a 16 byte string with a 16 byte AES key (128 bits) but it is not working as expected (and the MSDN examples are not helping).</p>

<p>My main problem is with the call to CryptEncrypt, I may not have clear how to use the parameters:</p>

<ul>
<li>*pbData</li>
<li>*pdwDataLen</li>
<li>dwBufLen</li>
</ul>

<p>Here is my code:</p>

<pre><code>#include &lt;windows.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;wincrypt.h&gt;
#define ENCRYPT_ALGORITHM CALG_AES_128

int main()
{

  HCRYPTPROV hCryptProv;
  HCRYPTKEY hKey;

//---------------------------------------------------------------
// Get the handle to the provider.
if(CryptAcquireContext(
    &amp;hCryptProv, 
    NULL, 
    NULL, //MS_ENH_RSA_AES_PROV
    PROV_RSA_AES, 
    0))
{
    printf(""A cryptographic provider has been acquired. \n"");
}
else
{
    printf(""Error during CryptAcquireContext!\n"");
    exit(1);
}


//---------------------------------------------------------------
//  Create a random session key. 

 if(CryptGenKey(
          hCryptProv, 
          ENCRYPT_ALGORITHM, 
          CRYPT_EXPORTABLE, //KEYLENGTH | CRYPT_EXPORTABLE, 
          &amp;hKey))
 {
         printf(""A session key has been created.\n"");
 } 
 else
 {
          printf(""Error during CryptGenKey.\n""); 
          exit(1);
 }
}

char text_test [] = ""abcdabcdabcdabcd"";
   DWORD text_len = strlen(text_test);

   printf(""PlainText: %s\n"",text_test);
   printf(""Buf Len: %d\n"",text_len);

   if (!CryptEncrypt(hKey,
                    NULL,  // hHash = no hash
                    1,  // Final
                    0,     // dwFlags
                    &amp;text_test, //*pbData
                    &amp;text_len,  //*pdwDataLen
                    32)) {      //dwBufLen
     printf(""Encryption failed\n"");
   }

   printf(""CipherText: %s\n"",text_test);
   printf(""Len: %d\n"",text_len);

   if (!CryptDecrypt(hKey,
                    NULL,  // hHash = no hash
                    1,  // Final
                    0,     // dwFlags
                    &amp;text_test,
                    &amp;text_len)) {
     printf(""Decryption failed\n"");
   }

   printf(""PlainText: %s\n"",text_test);
   printf(""Len: %d\n"",text_len);
.
.
.
CryptDestroyKey(hKey)
.
.
CryptReleaseContext(hCryptProv, 0)
.
</code></pre>

<p>The output in the cmd is:</p>

<p><a href=""https://i.stack.imgur.com/lhTIS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lhTIS.png"" alt=""enter image description here""></a></p>

<p>Can anyone explain me why the decrypted string is longer and which is the correct use of that three parameters of CryptEncrypt? I set the last value to 32 because after some trial and error that was the only value which made this stuff work. Help please and thank you in advance!</p>
","<p>I am new to crytography too, but this code from <a href=""https://stackoverflow.com/questions/7985744/simple-aes-encryption-using-winapi"">here</a> might have your solution:</p>

<pre><code>  // This acts as both the length of bytes to be encoded (on input) and the
  // number of bytes used in the resulting encrypted data (on output).
  DWORD length = kAesBytes128;
  if (!CryptEncrypt(hKey,
                    NULL,  // hHash = no hash
                    true,  // Final
                    0,     // dwFlags
                    reinterpret_cast&lt;BYTE*&gt;(encrypted-&gt;data()),
                    &amp;length,
                    encrypted-&gt;length())) {
    throw std::runtime_error(""Encryption failed"");
  }

  // See comment above.
  encrypted-&gt;chop(length - kAesBytes128);
</code></pre>

<p>Or i might have some working from a similar project code using Crypto++</p>
","2215","<c++><c><aes><cryptoapi><wincrypt>","-1","1","2","2017-09-05 15:55:03","43658750","2","","","","","2017-04-27 11:50:17",""
"43656951","AES-128 encryption using WinCrypt","<p>I need to encrypt strings under AES-128 for my C/C++ app making use of WinCrypt.</p>

<p>Just for understanding how the whole thing works, I have written a program to encrypt a 16 byte string with a 16 byte AES key (128 bits) but it is not working as expected (and the MSDN examples are not helping).</p>

<p>My main problem is with the call to CryptEncrypt, I may not have clear how to use the parameters:</p>

<ul>
<li>*pbData</li>
<li>*pdwDataLen</li>
<li>dwBufLen</li>
</ul>

<p>Here is my code:</p>

<pre><code>#include &lt;windows.h&gt; 
#include &lt;stdio.h&gt;
#include &lt;wincrypt.h&gt;
#define ENCRYPT_ALGORITHM CALG_AES_128

int main()
{

  HCRYPTPROV hCryptProv;
  HCRYPTKEY hKey;

//---------------------------------------------------------------
// Get the handle to the provider.
if(CryptAcquireContext(
    &amp;hCryptProv, 
    NULL, 
    NULL, //MS_ENH_RSA_AES_PROV
    PROV_RSA_AES, 
    0))
{
    printf(""A cryptographic provider has been acquired. \n"");
}
else
{
    printf(""Error during CryptAcquireContext!\n"");
    exit(1);
}


//---------------------------------------------------------------
//  Create a random session key. 

 if(CryptGenKey(
          hCryptProv, 
          ENCRYPT_ALGORITHM, 
          CRYPT_EXPORTABLE, //KEYLENGTH | CRYPT_EXPORTABLE, 
          &amp;hKey))
 {
         printf(""A session key has been created.\n"");
 } 
 else
 {
          printf(""Error during CryptGenKey.\n""); 
          exit(1);
 }
}

char text_test [] = ""abcdabcdabcdabcd"";
   DWORD text_len = strlen(text_test);

   printf(""PlainText: %s\n"",text_test);
   printf(""Buf Len: %d\n"",text_len);

   if (!CryptEncrypt(hKey,
                    NULL,  // hHash = no hash
                    1,  // Final
                    0,     // dwFlags
                    &amp;text_test, //*pbData
                    &amp;text_len,  //*pdwDataLen
                    32)) {      //dwBufLen
     printf(""Encryption failed\n"");
   }

   printf(""CipherText: %s\n"",text_test);
   printf(""Len: %d\n"",text_len);

   if (!CryptDecrypt(hKey,
                    NULL,  // hHash = no hash
                    1,  // Final
                    0,     // dwFlags
                    &amp;text_test,
                    &amp;text_len)) {
     printf(""Decryption failed\n"");
   }

   printf(""PlainText: %s\n"",text_test);
   printf(""Len: %d\n"",text_len);
.
.
.
CryptDestroyKey(hKey)
.
.
CryptReleaseContext(hCryptProv, 0)
.
</code></pre>

<p>The output in the cmd is:</p>

<p><a href=""https://i.stack.imgur.com/lhTIS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/lhTIS.png"" alt=""enter image description here""></a></p>

<p>Can anyone explain me why the decrypted string is longer and which is the correct use of that three parameters of CryptEncrypt? I set the last value to 32 because after some trial and error that was the only value which made this stuff work. Help please and thank you in advance!</p>
","<p>It's padding. By default, you'll get an equal amount of padding inserted as the bytes you encrypt. Ignore the last 16 bytes. The first 16 bytes are what you want.</p>
","2215","<c++><c><aes><cryptoapi><wincrypt>","-1","0","2","2017-09-05 15:55:03","43658750","2","","","","","2017-04-27 11:50:17",""
"16718285","How to use the Windows CryptoAPI from Python?","<p>I am looking at using the Windows CryptoAPI from Python, but I can't find any existing modules for it - the win32crypt module that comes as part of the win32all suite only exposes a couple of high level functions that are of no use to me.</p>

<p>Are there any existing modules that wrap the CryptoAPI?  Searching PyPi has come up with zip.   Failing that example code on calling the API from ctypes, cython etc would be useful.</p>
","<p>This : 
<a href=""https://stackoverflow.com/questions/252417/how-can-i-use-a-dll-from-python"">How can I use a DLL file from Python?</a> 
+ Getting the addresses of the functions you need from Crypt32.dll should work.</p>
","2195","<python><windows><cryptoapi>","2","1","1","2013-08-26 10:49:10","","2","0","","","","2013-05-23 15:41:31",""
"17793606","Tracing CSP calls within Windows Crypto API","<p>I am working on Private Key archival with a Windows Server 2008 R2 Certificate Authority. On the client side, I am interested in knowing which Crypto API function calls are made by the windows processes when the client requests for an archival enabled certificate. In particular, my focus is to track the function calls listed here, <a href=""http://msdn.microsoft.com/en-us/library/aa922849.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa922849.aspx</a> , present in Advapi32.dll .</p>

<p>I have tried out the windbg/cdb script here ( <a href=""http://blogs.msdn.com/b/alejacma/archive/2007/10/31/cryptoapi-tracer.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/alejacma/archive/2007/10/31/cryptoapi-tracer.aspx</a> ). I attached it to mmc.exe while making a certificate request but I couldn't detect any CSP calls being made during the process. I also tried requesting certificate through certreq.exe but windbg couldn't trace any CSP calls. I have also tried other forms of tracing as mentioned in the stackoverflow thread titled ""Monitoring application calls to DLL""</p>

<p>Please tell me which windows process/service I need to attach to, in order to find how these calls are being made. Is it possible to trace whenever a function call is made, irrespective of which process makes it?</p>

<p>Any suggestions on how to trace these CSP calls are most welcome!</p>
","<p>advapi32.dll used to contain cryptography implementation some time ago, but now this functionality has been moved to cryptsp.dll. Windows team sometimes moves implementation of public methods from one DLL into another. See more examples on this in <a href=""http://blogs.msdn.com/b/oldnewthing/archive/2006/07/19/671238.aspx"" rel=""nofollow"">The Old New Thing Blog</a>. Advapi32.dll simply calls into corresponding functions in cryptsp.dll. </p>

<p>Apparently certificate APIs in mmc that you were trying to debug are calling directly into cryptsp.dll. Example from a call stack on Windows 8:</p>

<pre><code>0:000&gt; k
Child-SP          RetAddr           Call Site
00000000`0059c278 000007fd`6c1b7d8b CRYPTSP!CryptAcquireContextA
00000000`0059c280 000007fd`6c1ace66 CRYPT32!I_CryptGetDefaultCryptProv+0xbc
00000000`0059c2d0 000007fd`6c1ae1b3 CRYPT32!FastCreateCtlElement+0x4a6
00000000`0059c4e0 000007fd`6c1a248a CRYPT32!CreateCtlElement+0x23
00000000`0059c530 000007fd`6c1a2297 CRYPT32!CreateStoreElement+0x139
00000000`0059c610 000007fd`6c1abaa4 CRYPT32!LoadStoreElement+0x244
00000000`0059c6f0 000007fd`6c1a2c76 CRYPT32!OpenFromRegistry+0x39e
00000000`0059c950 000007fd`6c1a2e7c CRYPT32!OpenAllFromRegistryEx+0x96
00000000`0059c9d0 000007fd`6c1a394b CRYPT32!I_CertDllOpenRegStoreProv+0xfc
00000000`0059ca20 000007fd`6c196926 CRYPT32!I_CertDllOpenSystemRegistryStoreProvW+0x28b
00000000`0059cb20 000007fd`6c1a3b72 CRYPT32!CertOpenStore+0x296
00000000`0059cba0 000007fd`6c1a3dc2 CRYPT32!OpenPhysicalStoreCallback+0xc2
00000000`0059cc70 000007fd`6c1a4512 CRYPT32!EnumPhysicalStore+0x648
00000000`0059ce00 000007fd`6c196926 CRYPT32!I_CertDllOpenSystemStoreProvW+0x162
00000000`0059cee0 000007fd`6c1a3b72 CRYPT32!CertOpenStore+0x296
00000000`0059cf60 000007fd`6c1a3dc2 CRYPT32!OpenPhysicalStoreCallback+0xc2
00000000`0059d030 000007fd`6c1a4512 CRYPT32!EnumPhysicalStore+0x648
00000000`0059d1c0 000007fd`6c196926 CRYPT32!I_CertDllOpenSystemStoreProvW+0x162
00000000`0059d2a0 000007fd`47371a27 CRYPT32!CertOpenStore+0x296
00000000`0059d320 000007fd`47363611 certmgr!CCertStore::GetStoreHandle+0xc7
</code></pre>

<p>Notice, advapi32.dll is not even present in the call stack.</p>

<p>So the solution for you would be to put breakpoints directly on the functions in cryptsp.dll. E.g.:</p>

<pre><code>&gt; bu CRYPTSP!CryptAcquireContextW
&gt; bu CRYPTSP!CryptAcquireContextA
&gt; bu CRYPTSP!CryptDecrypt
&gt; ... and so on ...
&gt; g
</code></pre>
","2164","<windows><windbg><cryptoapi><mscapi>","2","1","1","2015-06-09 03:06:24","17825167","1","","608639","","2015-06-09 03:06:24","2013-07-22 17:21:08",""
"1557710","WinHttp: How to use a temporary certificate store?","<p>I have a C++ application that makes a HTTPS connection to one of our servers.
In my ideal world, I would like the following to occur:</p>

<ol>
<li>App Starts</li>
<li>App makes Windows trust the server's root CA (no GUI please, just system calls)</li>
<li>App talks to server, does its work, etc.</li>
<li>App makes windows forget about the server's root CA</li>
<li>done</li>
</ol>

<p>I do <em>NOT</em> want this root CA to necessarily be trusted by other apps. Therefore I don't want to install the cert system-wide.
I also would like it if the user did not need Admin privileges.</p>

<p>My initial plan was to create an in-memory (CERT_STORE_PROV_MEMORY) store, add my cert to that, then add that in-memory store to the system store using CertAddStoreToCollection.</p>

<p>While all the CryptoAPI function calls succeed, WinHttp does not like it.</p>

<p>Here is the skeleton of what I'm doing - perhaps someone knows a trick?
Or perhaps this is wrong-headed in the first place?</p>

<pre><code>hMemStore = CertOpenStore(CERT_STORE_PROV_MEMORY, ...);
pCert = CertCreateCertificateContext(..., pCertBytes, ...);
CertAddCertificateContextToStore(hMemStore, pCert, ...);
hRootStore = CertOpenSystemStore(NULL, ""ROOT"");
CertAddStoreToCollection(hRootStore, hMemStore, ...);

// Then later on...
WinHttpSendRequest(...)
</code></pre>

<p>A few notes:</p>

<ul>
<li>Everything works when I use WinHttp's SECURITY_FLAG_IGNORE_UNKNOWN_CA, so I'm fairly sure this really is the issue.</li>
<li>I have already seen <a href=""https://stackoverflow.com/questions/656706/installing-root-ca-cert-via-code-on-win32"">this SO question</a> - it is close, but does not address the issue of making the cert only <em>temporarily</em> trusted, while the app runs.</li>
</ul>

<p>Thanks!</p>
","<p>Since you don't want other applications to trust this cert, you need to do part of the certificate validation yourself. Disable the CA check with the option SECURITY_FLAG_IGNORE_UNKNOWN_CA and then get the call back for connecting to the server WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER. In that callback fetch the cert with WINHTTP_OPTION_SERVER_CERT_CONTEXT and do your validation. Cancel/Close the request if it's not who you want, continue the request if it's correct.</p>
","2162","<c><cryptoapi><winhttp>","3","2","1","2009-12-07 16:00:03","","0","1","-1","","2017-05-23 12:29:55","2009-10-13 00:47:37",""
"13320685","how to use Microsoft Crypto API with USB Dongle following PKCS#11","<p>I have safenet authentication usb token which was given by a company and they told me they have digital public key certificate inside. They gave me a password and a software by which i can see that it can detect certificate inside. Now i need to access this token's certificate and then i need to use signing , encryption and decryption using my development code. But the company didn't gave me any sdk so i have to do everything by C++ Microsoft CryptoAPI. I searched on google but i am not sure if i am on right direction </p>

<p>this code doesn't give me correct handle for the usb stored certificate</p>

<pre><code>        // Attempt to acquire a handle to the default key container.
        bResult = CryptAcquireContext(
                    &amp;hProv,            // Variable to hold returned handle.
                    NULL,              // Use default key container.
                    MS_DEF_PROV,       // Use default CSP.
                    PROV_RSA_FULL,     // Type of provider to acquire.
        0);             
</code></pre>

<p>i thought it should give any default connected certificate either its on smart card or token.    I tried MS_SCARD_PROV as well in thought if it will give me access through usb token but it seems like its just for the smart card not for token.</p>

<p>I am desperate to complete this task please guide me or show me correct tutorial if you experts know any. Or suggest me what should be done for such kind of task.. </p>
","<p>you will be using both PKCS#11 and CryptoAPI functionalities.</p>

<p>PKCS#11 will be primarily used to talk to the hardware token. Every hardware vendor would have implemented a PKCS#11 interface for their hardware token. If your's is etoken,then safenet has one. Also safenet will have their <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380252%28v=vs.85%29.aspx#csp_functions"" rel=""nofollow"">CryptoAPI CSP</a> that you can use to talk to the token.</p>

<p>CryptoAPI provides rich functionality to handle certificates that are present with in the token.</p>
","2157","<c++><token><pki><cryptoapi><mscapi>","2","1","1","2015-06-11 15:38:14","13647517","0","","1118488","","2015-06-11 15:38:14","2012-11-10 09:02:33",""
"5033841","CryptoAPI: How to verify a DSA signature from OpenSSL or Java using CryptVerifySignature","<p>I would like to be able to verify an OpenSSL-generated DSA signature using the Microsoft CryptoAPI.</p>

<p>Consider that you have the following inputs:</p>

<ul>
<li>an existing DSA public key:</li>
<li>the data to be verified</li>
<li>a binary signature</li>
</ul>

<p>The signature has already been converted from Base64 into a series of 48 bytes.</p>
","<p>Without good knowledge of the CryptoAPI, this is much more difficult that it should be.</p>

<p>The major stumbling blocks were:</p>

<ul>
<li>Decode the X509 DSA public key using CryptStringToBinaryA and CryptDecodeObjectEx</li>
<li>Convert the DSA signature format
<ul>
<li>OpenSSL's DSA_sign produces a DSA signature in the ASN.1 DER format</li>
<li>CryptoAPI's CryptVerifySignature expects the DSA signature in the P1363 format</li>
</ul></li>
</ul>

<p>Here's a rough sample of how I finally solved the problem:</p>

<pre><code>const char* pubKey =  ""MIIBtjCCASsGByqGSM44BAEwggEeAoGBANW/k8nYREKtRMvIShnJTSAwxF33haU4""
                      .....
                      ""/FEGAibbOp31rjq9UfaJ2t06eN0t0B+DP1hjz/MfpGtPOxHqF3dQnDRa3ot1FSTP"";

bool verify(const unsigned char* msgData, unsigned int msgLength, const unsigned char* signature, unsigned int signatureLength)
{
    HCRYPTPROV hCryptProv;
    if (!CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_DSS, CRYPT_VERIFYCONTEXT))
    {
        return false;
    }

    bool result = false;

    unsigned char derPubKey[2048];
    DWORD  derPubKeyLen = 2048;
    CERT_PUBLIC_KEY_INFO *publicKeyInfo = NULL;
    DWORD  publicKeyInfoLen = 0;

    if ( CryptStringToBinaryA( pubKey, strlen(pubKey), CRYPT_STRING_BASE64, derPubKey, &amp;derPubKeyLen, NULL, NULL ) &amp;&amp;
         CryptDecodeObjectEx( X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, derPubKey, derPubKeyLen, 
                              CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;publicKeyInfo, &amp;publicKeyInfoLen ) )
    {
        HCRYPTKEY hPubKey;
        if (CryptImportPublicKeyInfo(hCryptProv, X509_ASN_ENCODING, publicKeyInfo, &amp;hPubKey))
        {
            HCRYPTHASH hHash;
            if (CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &amp;hHash))
            {
                CryptHashData(hHash, msgData, msgLength, 0);

                BYTE* dsaSignature = NULL;
                DWORD dsaSignatureLen = 0;
                if (CryptDecodeObjectEx( X509_ASN_ENCODING, X509_DSS_SIGNATURE, signature, signatureLength,
                                         CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;dsaSignature, &amp;dsaSignatureLen ) )
                {
                    if (CryptVerifySignature(hHash, dsaSignature, dsaSignatureLen, hPubKey, NULL, 0))
                    {
                        result = true;
                    }
                    LocalFree(dsaSignature);
                }

                CryptDestroyHash(hHash);
            }
            CryptDestroyKey(hPubKey);
        }
        LocalFree(publicKeyInfo);
    }
    CryptReleaseContext(hCryptProv, 0);
    return result;
}
</code></pre>
","2098","<openssl><digital-signature><cryptoapi>","1","5","2","2013-08-14 19:53:22","5033850","0","","","","","2011-02-17 19:51:52",""
"5033841","CryptoAPI: How to verify a DSA signature from OpenSSL or Java using CryptVerifySignature","<p>I would like to be able to verify an OpenSSL-generated DSA signature using the Microsoft CryptoAPI.</p>

<p>Consider that you have the following inputs:</p>

<ul>
<li>an existing DSA public key:</li>
<li>the data to be verified</li>
<li>a binary signature</li>
</ul>

<p>The signature has already been converted from Base64 into a series of 48 bytes.</p>
","<p>Just a note, Microsoft's crypto API doesn't support DSA key lengths greater than 1024. CryptImportPublicKeyInfo() will fail with NTE_BAD_DATA.</p>
","2098","<openssl><digital-signature><cryptoapi>","1","2","2","2013-08-14 19:53:22","5033850","0","","","","","2011-02-17 19:51:52",""
"44299096","Create CSR(Certificate Signing Request) using javascript at client side","<p>I want to create CSR(Certificate Signing Request) using javascript at client side using any browser(IE, Firefox, Chrome etc).</p>

<p>I have google it and found some js belows like PKIJS and WEB API Crypto and HTML KEYGEN Tag.</p>

<p><a href=""https://pkijs.org/"" rel=""nofollow noreferrer"">https://pkijs.org/</a></p>

<p><a href=""https://developer.mozilla.org/en/docs/Web/API/SubtleCrypto"" rel=""nofollow noreferrer"">https://developer.mozilla.org/en/docs/Web/API/SubtleCrypto</a></p>

<p>But not able to find some relavant resources or example to generate CSR using javascript at client side.</p>

<p>It will be much appreciated if anyone can help me ..</p>
","<p>Here is a sample using PKIjs to generate a CSR - csrhelp.peculiarventures.com</p>
","2097","<x509certificate><pki><cryptoapi><digital-certificate><csr>","0","2","1","2017-06-06 05:22:16","44381907","0","","","","","2017-06-01 05:22:12",""
"10807029","CryptoApi: Export a certificate without the private key?","<p>I have generated a self signed certificate using the <code>CertCreateSelfSignCertificate</code> function. This yields a PCCERT_CONTEXT.</p>

<p>How can I export the certificate stored in the PCCERT_CONTEXT variable with only the public key? I want to do this, to send it to other parties in the network, so these are able to encrypt messages using the public key.</p>

<p>I thought this was a straight forward option, but it isnt.</p>
","<p>Looks like you will need to first <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376009%28v=vs.85%29.aspx"" rel=""nofollow"">put</a> the certificate into a certificate store and then export it using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387313%28v=vs.85%29.aspx"" rel=""nofollow"">PFXExportCertStoreEx</a> passing dwFlags of 0 (i.e. not setting EXPORT_PRIVATE_KEYS).  </p>

<p>P.S. nothing is ever straight forward when dealing with cryptography libraries, be it CryptAPI, JSSE, OpenSSL... it's always a nightmare.</p>
","2001","<c><security><winapi><rsa><cryptoapi>","2","1","2","2012-12-14 02:50:21","","0","1","","","","2012-05-29 21:33:47",""
"10807029","CryptoApi: Export a certificate without the private key?","<p>I have generated a self signed certificate using the <code>CertCreateSelfSignCertificate</code> function. This yields a PCCERT_CONTEXT.</p>

<p>How can I export the certificate stored in the PCCERT_CONTEXT variable with only the public key? I want to do this, to send it to other parties in the network, so these are able to encrypt messages using the public key.</p>

<p>I thought this was a straight forward option, but it isnt.</p>
","<p>No need for a pfx.</p>

<p>The certificate is present inside the structure <strong>CERT_CONTEXT</strong> : just save the content of the buffer pointed by the member <strong>pbCertEncoded</strong> and whose length is the value of the member <strong>cbCertEncoded</strong>.</p>

<p>Moreover, the public key from this certificate is directly present in the <strong>CERT_CONTEXT</strong> structure : <strong>pCertInfo->SubjectPublicKeyInfo</strong>. For example, you can import it using <strong>CryptImportPublicKeyInfo</strong> and then call <strong>CryptEncrypt</strong> to encrypt data.</p>

<p>With these two options, you have all what is needed to start encrypting messages. Of course, the private key must be kept safe to be able to decrypt encrypted data.</p>
","2001","<c><security><winapi><rsa><cryptoapi>","2","3","2","2012-12-14 02:50:21","","0","1","","","","2012-05-29 21:33:47",""
"34324466","Crypto API RSA public key can decrypt data, is not asymmetric as expected","<p>The problem I am encountering is that I am able to decrypt data using the same RSA 2048-bit public key that was used to encrypt the data. It seems to me that this defeats the entire purpose of encrypting the data in the first place, if a public key can decrypt it. The only thing I can consider at this time is that I'm generating symmetric key exchange pairs when I think I'm generating asymmetric pairs.</p>

<p>The end-user purpose of this is to use it later for transmitting user credentials to be authenticated when using an application away from the office, when I am unable to use their cached credentials from their workstations on the domain. I would theoretically be able to then decrypt these credentials using <strong>only</strong> the private key. </p>

<p>I have produced a simple test class and code to reproduce my problem. The steps I'm taking are as follows:</p>

<ol>
<li>Acquire a context to Microsoft Enhanced Cryptographic Provider v1.0</li>
<li>Generate a public / private key pair.</li>
<li>Export the public and private key BLOBs to separate files.</li>
<li>Load up the public key and encrypt some simple text.</li>
<li>Attempt to decrypt the same encrypted text using the public key (I expected it to fail here except for when I'm using the private key - yet both work).</li>
</ol>

<p>TestEncryptDecrypt helper class: TestEncryptDecrypt.h</p>

<pre><code>#pragma once
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

class TestEncryptDecrypt
{
public:
    TestEncryptDecrypt()
    {
    }
    ~TestEncryptDecrypt()
    {
        if (hKey != NULL)
            CryptDestroyKey(hKey);

        if (hProvider != NULL)
            CryptReleaseContext(hProvider, 0);
    }

    BOOL InitializeProvider(LPCTSTR pszProvider, DWORD dwProvType)
    {
        if (hProvider != NULL)
        {
            if (!CryptReleaseContext(hProvider, 0))
                return 0;
        }

        return CryptAcquireContext(&amp;hProvider, NULL, pszProvider, dwProvType, 0);
    }

    BOOL Generate2048BitKeys(ALG_ID Algid)
    {
        DWORD dwFlags = (0x800 &lt;&lt; 16) | CRYPT_EXPORTABLE;
        return CryptGenKey(hProvider, Algid, dwFlags, &amp;hKey);
    }

    VOID ExportPrivatePublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    VOID ExportPublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    BOOL ImportKey(LPTSTR lpFileName)
    {
        if (hProvider == NULL)
            return 0;

        if (hKey != NULL)
            CryptDestroyKey(hKey);

        LPBYTE lpKeyContent = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpKeyContent, &amp;dwDataLen);
        BOOL importResult = CryptImportKey(hProvider, lpKeyContent, dwDataLen, 0, 0, &amp;hKey);

        delete[] lpKeyContent;

        return importResult;
    }

    BOOL EncryptDataWriteToFile(LPTSTR lpSimpleDataToEncrypt, LPTSTR lpFileName)
    {
        DWORD SimpleDataToEncryptLength = _tcslen(lpSimpleDataToEncrypt)*sizeof(TCHAR);
        DWORD BufferLength = SimpleDataToEncryptLength * 10;
        BYTE *EncryptedBuffer = new BYTE[BufferLength];
        SecureZeroMemory(EncryptedBuffer, BufferLength);
        CopyMemory(EncryptedBuffer, lpSimpleDataToEncrypt, SimpleDataToEncryptLength);

        BOOL cryptResult = CryptEncrypt(hKey, NULL, TRUE, 0, EncryptedBuffer, &amp;SimpleDataToEncryptLength, BufferLength);
        DWORD dwGetLastError = GetLastError();

        WriteBytesFile(lpFileName, EncryptedBuffer, SimpleDataToEncryptLength);

        delete[] EncryptedBuffer;

        return cryptResult;
    }

    BOOL DecryptDataFromFile(LPBYTE *lpDecryptedData, LPTSTR lpFileName, DWORD *dwDecryptedLen)
    {
        if (hKey == NULL)
            return 0;

        LPBYTE lpEncryptedData = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpEncryptedData, &amp;dwDataLen);
        BOOL decryptResult = CryptDecrypt(hKey, NULL, TRUE, 0, lpEncryptedData, &amp;dwDataLen);
        *dwDecryptedLen = dwDataLen;
        //WriteBytesFile(L""decryptedtest.txt"", lpEncryptedData, dwDataLen);
        *lpDecryptedData = new BYTE[dwDataLen + 1];
        SecureZeroMemory(*lpDecryptedData, dwDataLen + 1);
        CopyMemory(*lpDecryptedData, lpEncryptedData, dwDataLen);

        delete[]lpEncryptedData;

        return decryptResult;
    }

    VOID WriteBytesFile(LPTSTR lpFileName, BYTE *content, DWORD dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ | GENERIC_WRITE, 0x7, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwBytesWritten = 0;
        WriteFile(hFile, content, dwDataLen, &amp;dwBytesWritten, NULL);
        CloseHandle(hFile);
    }

private:
    HCRYPTPROV hProvider = NULL;
    HCRYPTKEY hKey = NULL;

    VOID ReadBytesFile(LPTSTR lpFileName, BYTE **content, DWORD *dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ, 0x7, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwFileLength = 0;
        DWORD dwBytesToRead = GetFileSize(hFile, NULL);
        DWORD dwBytesRead = 0;

        *content = new BYTE[dwBytesToRead + 1];
        SecureZeroMemory(*content, dwBytesToRead + 1);

        ReadFile(hFile, *content, dwBytesToRead, &amp;dwBytesRead, NULL);

        *dwDataLen = dwBytesRead;

        CloseHandle(hFile);
    }
};
</code></pre>

<p>Test Code: Main .cpp file</p>

<pre><code>#include ""stdafx.h""
#include ""TestEncryptDecrypt.h""
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

int main()
{
    TestEncryptDecrypt *edc = new TestEncryptDecrypt();
    //Initialize the provider
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);

    //Generate a 2048-bit asymmetric key pair
    edc-&gt;Generate2048BitKeys(CALG_RSA_KEYX);

    //Export the private / public key pair
    edc-&gt;ExportPrivatePublicKey(L""privpubkey.txt"");

    //Export only the public key
    edc-&gt;ExportPublicKey(L""pubkey.txt"");

    //Import the public key (destroys the private/public key pair already set)
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Encrypt and write some test data to file
    edc-&gt;EncryptDataWriteToFile(TEXT(""Hello World!ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""), L""encrypteddata.txt"");

    //Decrypt the data from file using the same public key (this should fail but it doesn't)
    DWORD dwDataLen = 0;
    LPBYTE lpDecryptedData = NULL;
    edc-&gt;DecryptDataFromFile(&amp;lpDecryptedData, L""encrypteddata.txt"", &amp;dwDataLen);

    //Write the supposedly decrypted data to another file
    edc-&gt;WriteBytesFile(L""decrypteddata.txt"", lpDecryptedData, dwDataLen);

    //Clear data
    delete[] lpDecryptedData;
    delete edc;

    return 0;
}
</code></pre>

<p>Unfortunately I don't get the opportunity to work with C++ very often so you may notice some problems. Feel free to constructively criticize.</p>

<p>Does anyone know why I am able to decrypt data using the same public key?
My goal is to be able to irreversibly encrypt something on the client side where it can only be decrypted on the server, where the private key will hide. </p>

<p><strong>Edit:</strong>
I had considered that the hKey wasn't being destroyed properly by the ImportKey method, so I wrote this test case instead (same results - public key can encrypt and decrypt the data):</p>

<pre><code>// CPPTests.cpp : Defines the entry point for the console application.
//

#include ""stdafx.h""
#include ""TestEncryptDecrypt.h""
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

int main()
{
    TestEncryptDecrypt *edc = new TestEncryptDecrypt();
    //Initialize the provider
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);

    //Generate a 2048-bit asymmetric key pair
    edc-&gt;Generate2048BitKeys(CALG_RSA_KEYX);

    //Export the private / public key pair
    edc-&gt;ExportPrivatePublicKey(L""privpubkey.txt"");

    //Export only the public key
    edc-&gt;ExportPublicKey(L""pubkey.txt"");

    //Destroy everything and load up only the public key to write some encrypted data
    delete edc;
    edc = new TestEncryptDecrypt();
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Encrypt and write some test data to file
    edc-&gt;EncryptDataWriteToFile(TEXT(""Hello World!ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""), L""encrypteddata.txt"");

    //Destroy everything and load up only the public key to read some encrypted data
    delete edc;
    edc = new TestEncryptDecrypt();
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Decrypt the data from file using the same public key (this should fail but it doesn't)
    DWORD dwDataLen = 0;
    LPBYTE lpDecryptedData = NULL;
    edc-&gt;DecryptDataFromFile(&amp;lpDecryptedData, L""encrypteddata.txt"", &amp;dwDataLen);

    //Write the supposedly decrypted data to another file
    edc-&gt;WriteBytesFile(L""decrypteddata.txt"", lpDecryptedData, dwDataLen);

    //Clear data
    delete[] lpDecryptedData;
    delete edc;

    return 0;
}
</code></pre>
","<p>The problem is that for some reason Crypto API, using the Microsoft Enhanced Provider w/ RSA, produces symmetrical keys. I am unable to get it to produce asymmetrical keys. The algorithm will, however, work with asymmetrical keys. So this is good news for us. This means to get this to work we only have to generate keys. You could also export these from self signed certificates, use your companies CA, etc.</p>

<p>To solve this I produced a public/private key pair using OpenSSL. I compiled OpenSSL for Windows just for fun then ran the following statements to get myself a pair of unencrypted public/private key files:</p>

<ol>
<li><p>openssl genpkey -out private2.pem -outform PEM -des3 -algorithm RSA -pkeyopt rsa_keygen_bits:2048</p>

<p>or</p>

<p>openssl genrsa -des3 -out private.pem 2048</p></li>
<li><p>openssl rsa -in private.pem -outform PEM -pubout -out public.pem</p></li>
<li>openssl rsa -in private.pem -outform PEM -out private_unencrypted.pem</li>
</ol>

<p>Once I had those I added 2 new functions to my test helper class, ImportPublicKey and ImportPrivateKey. These will only import PEM files without a passphrase. I don't consider that much of a security threat, considering the public is public and the private should hide on a secure server somewhere, perhaps encoded with a hash.</p>

<p>TestEncryptDecrypt.h</p>

<pre><code>#pragma once
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

class TestEncryptDecrypt
{
public:
    TestEncryptDecrypt()
    {
    }
    ~TestEncryptDecrypt()
    {
        if (hKey != NULL)
            CryptDestroyKey(hKey);

        if (hProvider != NULL)
            CryptReleaseContext(hProvider, 0);
    }

    BOOL InitializeProvider(LPCTSTR pszProvider, DWORD dwProvType)
    {
        if (hProvider != NULL)
        {
            if (!CryptReleaseContext(hProvider, 0))
                return 0;
        }

        return CryptAcquireContext(&amp;hProvider, NULL, pszProvider, dwProvType, CRYPT_VERIFYCONTEXT);
    }

    BOOL Generate2048BitKeys(ALG_ID Algid)
    {
        DWORD dwFlags = (0x800 &lt;&lt; 16) | CRYPT_EXPORTABLE;
        return CryptGenKey(hProvider, Algid, dwFlags, &amp;hKey);
    }

    VOID ExportPrivatePublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    VOID ExportPublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    BOOL ImportKey(LPTSTR lpFileName)
    {
        if (hProvider == NULL)
            return 0;

        if (hKey != NULL)
            CryptDestroyKey(hKey);

        LPBYTE lpKeyContent = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpKeyContent, &amp;dwDataLen);
        BOOL importResult = CryptImportKey(hProvider, lpKeyContent, dwDataLen, 0, 0, &amp;hKey);

        delete[] lpKeyContent;

        return importResult;
    }

    BOOL ImportPublicKey(LPTSTR lpFileName)
    {
        //If a context doesn't exist acquire one
        if (hProvider == NULL)
        {
            BOOL result = CryptAcquireContext(&amp;hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
            if (!result)
                return result;
        }

        if (hKey != NULL)
            CryptDestroyKey(hKey);

        //Load the PEM 
        LPBYTE PublicBytes = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;PublicBytes, &amp;dwDataLen);

        //Convert to Unicode
        int PublicPEMSize = MultiByteToWideChar(CP_ACP, 0, (LPCCH)PublicBytes, -1, NULL, 0);
        TCHAR *PublicPEM = new TCHAR[PublicPEMSize];
        MultiByteToWideChar(CP_ACP, 0, (LPCCH)PublicBytes, -1, PublicPEM, PublicPEMSize);
        delete[]PublicBytes;

        //Convert PEM to DER
        LPBYTE PublicDER = NULL;
        DWORD dwPublicDERLen = 0;

        BOOL result = CryptStringToBinary(PublicPEM, 0, CRYPT_STRING_BASE64HEADER, NULL, &amp;dwPublicDERLen, NULL, NULL);
        if (!result)
            return result;

        PublicDER = new BYTE[dwPublicDERLen];
        result = CryptStringToBinary(PublicPEM, 0, CRYPT_STRING_BASE64HEADER, PublicDER, &amp;dwPublicDERLen, NULL, NULL);
        if (!result)
            return result;

        delete[] PublicPEM;

        //Decode the object into a public key info struct
        CERT_PUBLIC_KEY_INFO *PublicKeyInfo = NULL;
        DWORD dwPublicKeyInfoLen = 0;

        result = CryptDecodeObjectEx(X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, PublicDER, dwPublicDERLen, CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;PublicKeyInfo, &amp;dwPublicKeyInfoLen);
        if (!result)
            return result;

        //Import the public key
        result = CryptImportPublicKeyInfo(hProvider, X509_ASN_ENCODING, PublicKeyInfo, &amp;hKey);
        if (!result)
            return result;


        //cleanup
        delete[] PublicDER;
        LocalFree(PublicKeyInfo);

        return result;
    }

    BOOL ImportPrivateKey(LPTSTR lpFileName)
    {
        //If a context doesn't exist acquire one
        if (hProvider == NULL)
        {
            BOOL result = CryptAcquireContext(&amp;hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
            if (!result)
                return result;
        }

        if (hKey != NULL)
            CryptDestroyKey(hKey);

        //Load the PEM 
        LPBYTE PrivateBytes = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;PrivateBytes, &amp;dwDataLen);

        //Convert to Unicode
        int PrivatePEMSize = MultiByteToWideChar(CP_ACP, 0, (LPCCH)PrivateBytes, -1, NULL, 0);
        TCHAR *PrivatePEM = new TCHAR[PrivatePEMSize];
        MultiByteToWideChar(CP_ACP, 0, (LPCCH)PrivateBytes, -1, PrivatePEM, PrivatePEMSize);
        delete[]PrivateBytes;

        //Convert PEM to DER
        LPBYTE PrivateDER = NULL;
        DWORD dwPrivateDERLen = 0;

        BOOL result = CryptStringToBinary(PrivatePEM, 0, CRYPT_STRING_BASE64HEADER, NULL, &amp;dwPrivateDERLen, NULL, NULL);
        if (!result)
            return result;

        PrivateDER = new BYTE[dwPrivateDERLen];
        result = CryptStringToBinary(PrivatePEM, 0, CRYPT_STRING_BASE64HEADER, PrivateDER, &amp;dwPrivateDERLen, NULL, NULL);
        if (!result)
            return result;

        delete[] PrivatePEM;

        //Decode the object into a private key info struct
        BYTE *PrivateKeyInfo = NULL;
        DWORD dwPrivateKeyInfoLen = 0;

        result = CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, PrivateDER, dwPrivateDERLen, 0, NULL, NULL, &amp;dwPrivateKeyInfoLen);
        if (!result)
            return result;

        PrivateKeyInfo = new BYTE[dwPrivateKeyInfoLen];

        result = CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, PrivateDER, dwPrivateDERLen, 0, NULL, PrivateKeyInfo, &amp;dwPrivateKeyInfoLen);
        if (!result)
            return result;



        //Import the private key
        result = CryptImportKey(hProvider, PrivateKeyInfo, dwPrivateKeyInfoLen, NULL, 0, &amp;hKey);
        if (!result)
            return result;


        //cleanup
        delete[] PrivateDER;
        delete[] PrivateKeyInfo;

        return result;
    }

    BOOL EncryptDataWriteToFile(LPTSTR lpSimpleDataToEncrypt, LPTSTR lpFileName)
    {
        DWORD SimpleDataToEncryptLength = _tcslen(lpSimpleDataToEncrypt)*sizeof(TCHAR);
        DWORD BufferLength = SimpleDataToEncryptLength * 10;
        BYTE *EncryptedBuffer = new BYTE[BufferLength];
        SecureZeroMemory(EncryptedBuffer, BufferLength);
        CopyMemory(EncryptedBuffer, lpSimpleDataToEncrypt, SimpleDataToEncryptLength);

        BOOL cryptResult = CryptEncrypt(hKey, NULL, TRUE, 0, EncryptedBuffer, &amp;SimpleDataToEncryptLength, BufferLength);
        DWORD dwGetLastError = GetLastError();

        WriteBytesFile(lpFileName, EncryptedBuffer, SimpleDataToEncryptLength);

        delete[] EncryptedBuffer;

        return cryptResult;
    }

    BOOL DecryptDataFromFile(LPBYTE *lpDecryptedData, LPTSTR lpFileName, DWORD *dwDecryptedLen)
    {
        if (hKey == NULL)
            return 0;

        LPBYTE lpEncryptedData = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpEncryptedData, &amp;dwDataLen);
        BOOL decryptResult = CryptDecrypt(hKey, NULL, TRUE, 0, lpEncryptedData, &amp;dwDataLen);
        *dwDecryptedLen = dwDataLen;
        //WriteBytesFile(L""decryptedtest.txt"", lpEncryptedData, dwDataLen);
        *lpDecryptedData = new BYTE[dwDataLen + 1];
        SecureZeroMemory(*lpDecryptedData, dwDataLen + 1);
        CopyMemory(*lpDecryptedData, lpEncryptedData, dwDataLen);

        delete[]lpEncryptedData;

        return decryptResult;
    }

    VOID WriteBytesFile(LPTSTR lpFileName, BYTE *content, DWORD dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ | GENERIC_WRITE, 0x7, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwBytesWritten = 0;
        WriteFile(hFile, content, dwDataLen, &amp;dwBytesWritten, NULL);
        CloseHandle(hFile);
    }

private:
    HCRYPTPROV hProvider = NULL;
    HCRYPTKEY hKey = NULL;

    VOID ReadBytesFile(LPTSTR lpFileName, BYTE **content, DWORD *dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ, 0x7, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwFileLength = 0;
        DWORD dwBytesToRead = GetFileSize(hFile, NULL);
        DWORD dwBytesRead = 0;

        *content = new BYTE[dwBytesToRead + 1];
        SecureZeroMemory(*content, dwBytesToRead + 1);

        ReadFile(hFile, *content, dwBytesToRead, &amp;dwBytesRead, NULL);

        *dwDataLen = dwBytesRead;

        CloseHandle(hFile);
    }
};
</code></pre>

<p>And here's the test, providing proof that it cannot decrypt using the public key but instead the private key .pem:</p>

<pre><code>int main()
{
    TestEncryptDecrypt *edc = new TestEncryptDecrypt();
    edc-&gt;ImportPublicKey(L""public.pem"");
    edc-&gt;EncryptDataWriteToFile(L""Hello world! hahahahah"", L""encrypted.txt"");

    LPBYTE decodedData = NULL; DWORD decodedLen = 0;
    BOOL result = edc-&gt;DecryptDataFromFile(&amp;decodedData, L""encrypted.txt"", &amp;decodedLen);
    if (result == 1)
        OutputDebugString(L""We were able to decrypt from a public key! That's not good."");

    result = edc-&gt;ImportPrivateKey(L""private_unencrypted.pem"");
    result = edc-&gt;DecryptDataFromFile(&amp;decodedData, L""encrypted.txt"", &amp;decodedLen);
    edc-&gt;WriteBytesFile(L""decrypted.txt"", decodedData, decodedLen);
    return 0;
}
</code></pre>
","1975","<c++><encryption><rsa><public-key><cryptoapi>","4","0","2","2019-08-27 08:08:51","44112149","5","1","3870427","","2015-12-17 00:53:42","2015-12-17 00:06:51",""
"34324466","Crypto API RSA public key can decrypt data, is not asymmetric as expected","<p>The problem I am encountering is that I am able to decrypt data using the same RSA 2048-bit public key that was used to encrypt the data. It seems to me that this defeats the entire purpose of encrypting the data in the first place, if a public key can decrypt it. The only thing I can consider at this time is that I'm generating symmetric key exchange pairs when I think I'm generating asymmetric pairs.</p>

<p>The end-user purpose of this is to use it later for transmitting user credentials to be authenticated when using an application away from the office, when I am unable to use their cached credentials from their workstations on the domain. I would theoretically be able to then decrypt these credentials using <strong>only</strong> the private key. </p>

<p>I have produced a simple test class and code to reproduce my problem. The steps I'm taking are as follows:</p>

<ol>
<li>Acquire a context to Microsoft Enhanced Cryptographic Provider v1.0</li>
<li>Generate a public / private key pair.</li>
<li>Export the public and private key BLOBs to separate files.</li>
<li>Load up the public key and encrypt some simple text.</li>
<li>Attempt to decrypt the same encrypted text using the public key (I expected it to fail here except for when I'm using the private key - yet both work).</li>
</ol>

<p>TestEncryptDecrypt helper class: TestEncryptDecrypt.h</p>

<pre><code>#pragma once
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

class TestEncryptDecrypt
{
public:
    TestEncryptDecrypt()
    {
    }
    ~TestEncryptDecrypt()
    {
        if (hKey != NULL)
            CryptDestroyKey(hKey);

        if (hProvider != NULL)
            CryptReleaseContext(hProvider, 0);
    }

    BOOL InitializeProvider(LPCTSTR pszProvider, DWORD dwProvType)
    {
        if (hProvider != NULL)
        {
            if (!CryptReleaseContext(hProvider, 0))
                return 0;
        }

        return CryptAcquireContext(&amp;hProvider, NULL, pszProvider, dwProvType, 0);
    }

    BOOL Generate2048BitKeys(ALG_ID Algid)
    {
        DWORD dwFlags = (0x800 &lt;&lt; 16) | CRYPT_EXPORTABLE;
        return CryptGenKey(hProvider, Algid, dwFlags, &amp;hKey);
    }

    VOID ExportPrivatePublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    VOID ExportPublicKey(LPTSTR lpFileName)
    {
        if (hKey == NULL)
            return;

        DWORD dwDataLen = 0;
        BOOL exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwDataLen);
        LPBYTE lpKeyBlob = (LPBYTE)malloc(dwDataLen);
        exportResult = CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, lpKeyBlob, &amp;dwDataLen);
        WriteBytesFile(lpFileName, lpKeyBlob, dwDataLen);
        free(lpKeyBlob);
    }

    BOOL ImportKey(LPTSTR lpFileName)
    {
        if (hProvider == NULL)
            return 0;

        if (hKey != NULL)
            CryptDestroyKey(hKey);

        LPBYTE lpKeyContent = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpKeyContent, &amp;dwDataLen);
        BOOL importResult = CryptImportKey(hProvider, lpKeyContent, dwDataLen, 0, 0, &amp;hKey);

        delete[] lpKeyContent;

        return importResult;
    }

    BOOL EncryptDataWriteToFile(LPTSTR lpSimpleDataToEncrypt, LPTSTR lpFileName)
    {
        DWORD SimpleDataToEncryptLength = _tcslen(lpSimpleDataToEncrypt)*sizeof(TCHAR);
        DWORD BufferLength = SimpleDataToEncryptLength * 10;
        BYTE *EncryptedBuffer = new BYTE[BufferLength];
        SecureZeroMemory(EncryptedBuffer, BufferLength);
        CopyMemory(EncryptedBuffer, lpSimpleDataToEncrypt, SimpleDataToEncryptLength);

        BOOL cryptResult = CryptEncrypt(hKey, NULL, TRUE, 0, EncryptedBuffer, &amp;SimpleDataToEncryptLength, BufferLength);
        DWORD dwGetLastError = GetLastError();

        WriteBytesFile(lpFileName, EncryptedBuffer, SimpleDataToEncryptLength);

        delete[] EncryptedBuffer;

        return cryptResult;
    }

    BOOL DecryptDataFromFile(LPBYTE *lpDecryptedData, LPTSTR lpFileName, DWORD *dwDecryptedLen)
    {
        if (hKey == NULL)
            return 0;

        LPBYTE lpEncryptedData = NULL;
        DWORD dwDataLen = 0;
        ReadBytesFile(lpFileName, &amp;lpEncryptedData, &amp;dwDataLen);
        BOOL decryptResult = CryptDecrypt(hKey, NULL, TRUE, 0, lpEncryptedData, &amp;dwDataLen);
        *dwDecryptedLen = dwDataLen;
        //WriteBytesFile(L""decryptedtest.txt"", lpEncryptedData, dwDataLen);
        *lpDecryptedData = new BYTE[dwDataLen + 1];
        SecureZeroMemory(*lpDecryptedData, dwDataLen + 1);
        CopyMemory(*lpDecryptedData, lpEncryptedData, dwDataLen);

        delete[]lpEncryptedData;

        return decryptResult;
    }

    VOID WriteBytesFile(LPTSTR lpFileName, BYTE *content, DWORD dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ | GENERIC_WRITE, 0x7, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwBytesWritten = 0;
        WriteFile(hFile, content, dwDataLen, &amp;dwBytesWritten, NULL);
        CloseHandle(hFile);
    }

private:
    HCRYPTPROV hProvider = NULL;
    HCRYPTKEY hKey = NULL;

    VOID ReadBytesFile(LPTSTR lpFileName, BYTE **content, DWORD *dwDataLen)
    {
        HANDLE hFile = CreateFile(lpFileName, GENERIC_READ, 0x7, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        DWORD dwFileLength = 0;
        DWORD dwBytesToRead = GetFileSize(hFile, NULL);
        DWORD dwBytesRead = 0;

        *content = new BYTE[dwBytesToRead + 1];
        SecureZeroMemory(*content, dwBytesToRead + 1);

        ReadFile(hFile, *content, dwBytesToRead, &amp;dwBytesRead, NULL);

        *dwDataLen = dwBytesRead;

        CloseHandle(hFile);
    }
};
</code></pre>

<p>Test Code: Main .cpp file</p>

<pre><code>#include ""stdafx.h""
#include ""TestEncryptDecrypt.h""
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

int main()
{
    TestEncryptDecrypt *edc = new TestEncryptDecrypt();
    //Initialize the provider
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);

    //Generate a 2048-bit asymmetric key pair
    edc-&gt;Generate2048BitKeys(CALG_RSA_KEYX);

    //Export the private / public key pair
    edc-&gt;ExportPrivatePublicKey(L""privpubkey.txt"");

    //Export only the public key
    edc-&gt;ExportPublicKey(L""pubkey.txt"");

    //Import the public key (destroys the private/public key pair already set)
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Encrypt and write some test data to file
    edc-&gt;EncryptDataWriteToFile(TEXT(""Hello World!ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""), L""encrypteddata.txt"");

    //Decrypt the data from file using the same public key (this should fail but it doesn't)
    DWORD dwDataLen = 0;
    LPBYTE lpDecryptedData = NULL;
    edc-&gt;DecryptDataFromFile(&amp;lpDecryptedData, L""encrypteddata.txt"", &amp;dwDataLen);

    //Write the supposedly decrypted data to another file
    edc-&gt;WriteBytesFile(L""decrypteddata.txt"", lpDecryptedData, dwDataLen);

    //Clear data
    delete[] lpDecryptedData;
    delete edc;

    return 0;
}
</code></pre>

<p>Unfortunately I don't get the opportunity to work with C++ very often so you may notice some problems. Feel free to constructively criticize.</p>

<p>Does anyone know why I am able to decrypt data using the same public key?
My goal is to be able to irreversibly encrypt something on the client side where it can only be decrypted on the server, where the private key will hide. </p>

<p><strong>Edit:</strong>
I had considered that the hKey wasn't being destroyed properly by the ImportKey method, so I wrote this test case instead (same results - public key can encrypt and decrypt the data):</p>

<pre><code>// CPPTests.cpp : Defines the entry point for the console application.
//

#include ""stdafx.h""
#include ""TestEncryptDecrypt.h""
#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

int main()
{
    TestEncryptDecrypt *edc = new TestEncryptDecrypt();
    //Initialize the provider
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);

    //Generate a 2048-bit asymmetric key pair
    edc-&gt;Generate2048BitKeys(CALG_RSA_KEYX);

    //Export the private / public key pair
    edc-&gt;ExportPrivatePublicKey(L""privpubkey.txt"");

    //Export only the public key
    edc-&gt;ExportPublicKey(L""pubkey.txt"");

    //Destroy everything and load up only the public key to write some encrypted data
    delete edc;
    edc = new TestEncryptDecrypt();
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Encrypt and write some test data to file
    edc-&gt;EncryptDataWriteToFile(TEXT(""Hello World!ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz""), L""encrypteddata.txt"");

    //Destroy everything and load up only the public key to read some encrypted data
    delete edc;
    edc = new TestEncryptDecrypt();
    edc-&gt;InitializeProvider(MS_ENHANCED_PROV, PROV_RSA_FULL);
    edc-&gt;ImportKey(L""pubkey.txt"");

    //Decrypt the data from file using the same public key (this should fail but it doesn't)
    DWORD dwDataLen = 0;
    LPBYTE lpDecryptedData = NULL;
    edc-&gt;DecryptDataFromFile(&amp;lpDecryptedData, L""encrypteddata.txt"", &amp;dwDataLen);

    //Write the supposedly decrypted data to another file
    edc-&gt;WriteBytesFile(L""decrypteddata.txt"", lpDecryptedData, dwDataLen);

    //Clear data
    delete[] lpDecryptedData;
    delete edc;

    return 0;
}
</code></pre>
","<p><strong>This API is deprecated <a href=""https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptacquirecontexta"" rel=""nofollow noreferrer"">according to Microsoft</a>, so if you came here looking for a native cryptography API, you may want to look elsewhere.</strong></p>

<p>After some fighting with the same problem I realized where the error was.</p>

<p>In your first code you were acquiring your context with the last flag set to zero:</p>

<pre><code>CryptAcquireContext(&amp;hProvider, NULL, pszProvider, dwProvType, 0);
</code></pre>

<p>But in your solution you changed it into CRYPT_VERIFYCONTEXT.</p>

<pre><code>CryptAcquireContext(&amp;hProvider, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
</code></pre>

<p>You solved your problem by changing this flag, not by importing the keys from OpenSSL. I am pretty sure that if you test this in your initial code, it will work as expected.</p>

<p>This CRYPT_VERIFYCONTEXT flag is responsible for not allowing a key to achieve persistence in the system, a persistence which turned the public RSA able to encrypt and decrypt.</p>
","1975","<c++><encryption><rsa><public-key><cryptoapi>","4","3","2","2019-08-27 08:08:51","44112149","5","1","3870427","","2015-12-17 00:53:42","2015-12-17 00:06:51",""
"34549899","SSL Connection, Windows Certificate Store and CAPI engine","<p>I am creating an <code>SSL</code> connection using OpenSSL API. As we know in a SSL handshake, series of Certificate Authentication occurs for Server or Client. Now for client certificate authentication, the client's certificate and associated private key are stored in <code>Windows Certificate Store</code>.</p>

<p>This certificate with <code>private key</code> is imported into the store after combining them into a <code>pfx</code> format and then that <code>pfx</code> file is imported to the windows Cert store. Now while importing this pfx file using <code>mmc</code> snap-in it asks whether we want to make the private key <code>exportable</code> or not. Now OpenSSL comes into picture for making SSL connection.</p>

<p>For that we have to create <code>SSL_CTX</code> object in which all the connection related properties are loaded. Now for loading private key from windows certificate store into <code>SSL_CTX</code> object, i have marked that private key <code>exportable</code> that i am exporting the key using <code>Crypto API</code>. But I think marking a private key exportable does not make any sense, it's a security breach.</p>

<p>Since private key will always be marked <code>Non-Exportable</code> so, is there any method or API of OpenSSL, etc that can directly read and load private key from windows cert store into SST_CTX object for making a SSL connection.</p>

<p>I know definitely there is some way for this to work but i am not getting it.
I have searched a lot for this but not got the required thing.</p>

<p><strong><em>Summarized Question</em></strong>: The Certificate Store holds many certificates and associated private keys. How are the certificates and private keys accessed when making an SSL connection ?</p>

<p><strong><em>EDIT</em></strong> : I have gone through an openssl engine API called </p>

<pre><code> `EVP_PKEY *ENGINE_load_private_key(ENGINE *e, const char *key_id,
      UI_METHOD *ui_method, void *callback_data);`
</code></pre>

<p>Now how can i get this <code>key_id</code> of the private key and also i think this api internally called crypto api <code>CryptExportKey</code> and this api fails if private key is marked <code>non-exportable</code>. </p>
","","1921","<ssl><openssl><private-key><cryptoapi><certificate-store>","3","","0","2018-02-22 16:43:24","","12","1","608639","","2016-01-03 14:13:36","2015-12-31 17:49:39",""
"7551942","Getting certificate chain to a private root","<p>I'm trying to verify that the certificate from a signature chains back to a particular root certificate, which is <em>not</em> trusted by Windows (it's a private certificate for the app).</p>

<p>My current attempt to do this involves creating a chaining engine which only trusts the specific certificate I want as the root, so that no other chains can be generated.</p>

<pre><code>HCERTSTORE hPrivateRootStore = CertOpenStore(CERT_STORE_PROV_FILENAME, dwEncoding,
    NULL, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG,
    _T(""C:\\Test\\PrivateRoot.cer""));
CERT_CHAIN_ENGINE_CONFIG config;
memset(&amp;config, 0, sizeof(config));
config.cbSize = sizeof(config);
config.hRestrictedTrust = hPrivateRootStore;
config.dwFlags = CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL | CERT_CHAIN_ENABLE_SHARE_STORE;
HCERTCHAINENGINE hEngine;
CertCreateCertificateChainEngine(&amp;config, &amp;hEngine);
CERT_CHAIN_PARA params;
memset(&amp;params, 0, sizeof(params));
params.cbSize = sizeof(params);
PCCERT_CHAIN_CONTEXT chains = NULL;
if (CertGetCertificateChain(hEngine, pCertContext, NULL, hStore, &amp;params,
    0, NULL, &amp;chains))
   ...
</code></pre>

<p>(error checking omitted for clarity; <code>pCertContext</code> and <code>hStore</code> came from <code>CryptQueryObject</code> extracting the signature and related certificates from a signed binary file.)</p>

<p>Unfortunately, this doesn't seem to work; despite using a custom chaining engine it still seems to be searching the OS store, and either doesn't find a chain or finds one to a different root (which is trusted by the OS).  I can only get the chain I want by adding my private root certificate to the OS trusted store.</p>

<p>I've also tried setting <code>config.hRestrictedOther</code> to an empty memory store, since the docs suggest that having <code>hRestrictedTrust</code> non-NULL will bring in the system stores again, but that doesn't make any difference.</p>

<p>Is there something I'm missing, or a better way to do this?</p>

<p><strong>Edit</strong>: just to give a bit more context, I'm trying to do something similar to the driver signing certificates, where the signing certificate chains back to two different roots: one standard CA root trusted by the OS and one internal root (which in drivers is also trusted by the OS but in my case will only be trusted by my app).  The cross occurs somewhere mid-way up the ""main"" chain; there could potentially be a number of different files all signed with different ""real"" CAs but still chained back to my internal certificate.</p>
","<p><strike>I've found a half-baked workaround now; it's a little ugly but it does kinda work.  I got the basic idea from <a href=""http://src.chromium.org/viewvc/chrome/trunk/src/net/base/test_root_certs_win.cc?view=markup&amp;pathrev=69351"" rel=""nofollow"">Chromium's test suite</a>; it involves installing a hook into Crypt32 such that when it tries to open the system stores to build the chain it gets my custom store instead, containing only my desired certificate.</strike></p>

<p><strike>The good is that this seems to force <code>CertGetCertificateChain</code> to go ""past"" the real CA certificate and chain all the way to my custom certificate, instead of stopping at the CA certificate (which is what it usually does when that is trusted).</strike></p>

<p><strike>The bad is that it doesn't seem to stop it from building chains to and trusting any other CA certificate.  I can work around that by explicitly verifying that the root of the chain is the certificate I wanted, but it's less than ideal, and I'm not sure if there are situations which will trip it up.</strike></p>

<p><strike>Still looking for any better solutions; I'm definitely getting the impression that I'm taking the wrong path somewhere.</strike></p>

<p>Ok, new plan.  I'm now just walking the chain manually (since I know that all of the certificates I care about will be in the <code>hStore</code> extracted from the signed .exe), with basic structure like this:</p>

<ul>
<li>Use <code>WinVerifyTrust</code> to do basic ""is it not tampered"" authentication.</li>
<li>Use <code>CryptQueryObject</code> to obtain certificate store <code>hStore</code> from the .exe</li>
<li>Use <code>CryptMsgGetParam</code> and <code>CertFindCertificateInStore</code> to find the signing certificate from <code>hStore</code>.</li>
<li>Starting from the signing certificate, use <code>CertFindCertificateInStore</code> with <code>CERT_FIND_SUBJECT_NAME</code> in a loop to find the potential issuer certificates; keep walking back until I hit a self-signed certificate or find my desired root (checking for a match via <code>CertComparePublicKeyInfo</code>).</li>
<li>Abandon a particular branch if <code>CertVerifySubjectCertificateContext</code> says that the signatures don't match.</li>
</ul>

<p>Seems cleaner than the previous approaches I was trying.  Thoughts/comments/alternatives?</p>

<p>(Something which in some ways does seem to make more sense would be to add an additional custom countersignature [similar to the timestamping] instead of trying to chain certificates like this, but I can't find any information on doing that, or what the pros/cons are.)</p>
","1911","<c++><winapi><certificate><x509><cryptoapi>","3","2","1","2011-09-27 06:43:19","7563625","3","","43534","","2011-09-26 08:49:37","2011-09-26 07:41:01",""
"14838123","Error importing public key using cryptoapi CryptImportKey","<p>I want to import public key blob to a CSP. but error occurred.</p>

<pre><code>BYTE pbData[] ={0xEB,0x2A,0x38,0x56,0x86,0x61,0x88,0x7F,0xA1,0x80,0xBD,0xDB,0x5C,0xAB,0xD5,0xF2,0x1C,0x7B,0xFD,0x59,0xC0,0x90,0xCB,0x2D,0x24,0x5A,0x87,0xAC,0x25,0x30,0x62,0x88,0x27,0x29,0x29,0x3E,0x55,0x06,0x35,0x05,0x08,0xE7,0xF9,0xAA,0x3B,0xB7,0x7F,0x43,0x33,0x23,0x14,0x90,0xF9,0x15,0xF6,0xD6,0x3C,0x55,0xFE,0x2F,0x08,0xA4,0x9B,0x35,0x3F,0x44,0x4A,0xD3,0x99,0x3C,0xAC,0xC0,0x2D,0xB7,0x84,0xAB,0xBB,0x8E,0x42,0xA9,0xB1,0xBB,0xFF,0xFB,0x38,0xBE,0x18,0xD7,0x8E,0x87,0xA0,0xE4,0x1B,0x9B,0x8F,0x73,0xA9,0x28,0xEE,0x0C,0xCE,0xE1,0xF6,0x73,0x98,0x84,0xB9,0x77,0x7E,0x4F,0xE9,0xE8,0x8A,0x1B,0xBE,0x49,0x59,0x27,0xAC,0x4A,0x79,0x9B,0x31,0x81,0xD6,0x44,0x24,0x43};
USHORT modulusLengthInBytes = sizeof(pbData);
HCRYPTKEY hPublicKey;
DWORD keyBlobLength = sizeof(BLOBHEADER)+sizeof(RSAPUBKEY)+modulusLengthInBytes;
BYTE* keyBlob = (BYTE*)malloc(keyBlobLength);
BLOBHEADER* blobheader = (BLOBHEADER*) keyBlob;
blobheader-&gt;bType    = PUBLICKEYBLOB;
blobheader-&gt;bVersion = CUR_BLOB_VERSION;
blobheader-&gt;reserved = 0;
blobheader-&gt;aiKeyAlg = CALG_RSA_KEYX;
RSAPUBKEY* rsapubkey = (RSAPUBKEY*)keyBlob + sizeof(BLOBHEADER);
rsapubkey-&gt;magic     = 0x31415352;
rsapubkey-&gt;bitlen    = modulusLengthInBytes*8;
rsapubkey-&gt;pubexp    = 65537;         // Or whatever your public exponent is.
BYTE* modulus = keyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
memcpy(modulus, pbData, modulusLengthInBytes);
bRet = CryptImportKey(hProv, keyBlob, keyBlobLength, 0, 0, &amp;hPublicKey);
if (!bRet)
{
    dwRet = GetLastError();
}
</code></pre>

<p><code>CryptImportKey</code> return 0 and <code>dwRet</code> is 0x80090004(NTE_BAD_LEN). I am very sure the length is correct. but still same error occurred.</p>
","<pre><code>RSAPUBKEY* rsapubkey = (RSAPUBKEY*)keyBlob + sizeof(BLOBHEADER);
</code></pre>

<p>should instead read </p>

<pre><code>RSAPUBKEY* rsapubkey = (RSAPUBKEY*) (keyBlob + sizeof(BLOBHEADER));
</code></pre>
","1906","<c><winapi><rsa><public-key-encryption><cryptoapi>","3","2","1","2013-05-23 10:41:17","","0","1","","","","2013-02-12 17:19:51",""
"1528917","Decrypting data files with wincrypt. Having trouble. Example shows CBase64Utils?","<p>I need to decrypt some data files with wincrypt and examples are few and far between online.  The most solid example I've found is <a href=""http://74.125.95.132/search?q=cache:rj7_i0FkcOgJ:www.experts-exchange.com/Programming/System/Windows_Programming/MFC/Q_21682415.html&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=ca&amp;client=firefox-a"" rel=""nofollow noreferrer"">here</a>.  However, this is using all sorts of types I cannot seem to find information about (CBase64Utils, CString, etc).</p>

<p>I am reading the final solution, trying to understand the process, and have come to this:</p>

<pre><code>// 5. Determine the LENGTH of the BUFFER to hold the corresponding cyphertext.
            CBase64Utils bu;
            int ipszSourceLen = strlen(pszSource);
            char *pszSource2 = bu.Decode(pszSource, &amp;ipszSourceLen);

            DWORD   dwSourceLen = strlen(pszSource2);      // Get the length of the input string.
            DWORD   dwDataLen = dwSourceLen;
            BYTE*   pTarget = NULL;
            DWORD   dwCryptDataLen = dwDataLen;
            CryptEncrypt(hKey, 0, TRUE, 0, NULL, &amp;dwCryptDataLen, dwDataLen);
</code></pre>

<p>This is pure chinese to me.  Can anybody make sense of it and hopefully clear some muddy waters?  Thanks</p>
","<p>The code you linked is horrible. It appears the fellow wrote his encrypt method, and then subsequently wrote his decrypt method simply by copying and pasting the first method and making a few changes (yet leaving a ton of code left over from the encryption process). I wouldn't be surprised if it works, it's just that it wastes time and space doing useless work left over from encryption (plus the comments are all backwards).</p>

<p>As wincrypt is a Microsoft library, there are plenty of examples <a href=""http://msdn.microsoft.com/en-us/library/aa388162(VS.85).aspx"" rel=""nofollow noreferrer"">over at the MSDN</a>. As MSDN samples are (usually) well-written and well-commented, they should be much easier to understand, so I would recommend you look at them instead.</p>
","1857","<c++><cstring><cryptoapi>","0","0","1","2009-12-19 12:27:11","1529010","1","","33837","","2009-12-19 12:27:11","2009-10-07 00:38:00",""
"14689294","Windows Crypto Api bad length","<p>I found a simple unit for generating a RSA KeyPair and encrypting / decrypting. It works fine on small strings but on larger text I get error : Bad Length.</p>

<p>What could be the cause , here is the unit, the unit wcrypt2 you can download <a href=""http://stuff.irsoft.de/CryptoAPI2.zip"" rel=""nofollow"">here</a></p>

<p>Tested on Delphi 2010</p>

<pre><code>unit Crypt_RSA;

interface

uses
  Windows, Classes, SysUtils, WCrypt2;

function RSAGenerateKeys(var PrivateKey, PublicKey: String): Boolean;
function RSAEncrypt(Source, Key: String): String;
function RSADecrypt(Source, Key: String): String;

implementation

function RSAGenerateKeys(var PrivateKey, PublicKey: String): Boolean;
const
  RSA1024BIT_KEY = $04000000;

var
  RSA: HCRYPTPROV;
  HKeyPair: HCRYPTKEY;
  Pair: TStringStream;
  buflen: DWORD;

  function SetKey(BlobDef: Cardinal; var Key: String): Boolean;
  begin
    Result := Bool(CryptExportKey(HKeyPair, 0, BlobDef, 0, nil, @buflen));
    if Result then
    begin
      Pair.SetSize(buflen);
      Result := Bool(CryptExportKey(HKeyPair, 0, BlobDef, 0, PByte(Pair.Memory), @buflen));
    end;

    Key := Pair.ReadString(buflen);
    Pair.Seek(0, soBeginning);
  end;

begin
  Pair := TStringStream.Create;

  Result := Bool(CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));
  if Result then
    Result := Bool(CryptGenKey(RSA, AT_KEYEXCHANGE, RSA1024BIT_KEY or CRYPT_EXPORTABLE, @HKeyPair));

  if Result then
    Result := SetKey(PRIVATEKEYBLOB, PrivateKey);
  if Result then
    Result := SetKey(PUBLICKEYBLOB, PublicKey);

  CryptDestroyKey(HKeyPair);
  CryptReleaseContext(RSA, 0);
  FreeAndNil(Pair);
end;

function RSAEncrypt(Source, Key: String): String;
var
  KeyPair: TStringStream;
  RSA: HCRYPTPROV;
  HPair: HCRYPTKEY;
  DDataSize, EDataSize: DWORD;

begin
  Result := '';
  KeyPair := TStringStream.Create(Key);
  if CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) then
  try
    if CryptImportKey(RSA, PByte(KeyPair.Memory), KeyPair.Size, 0, 0, @HPair) then
    try
      EDataSize := SizeOf(Source);
      if CryptEncrypt(HPair, 0, true, 0, nil, @EDataSize, 0) then
      begin
        Result := Source;
        SetLength(Result, EDataSize);
        DDataSize := Length(Source) * SizeOf(Char);
        if not(CryptEncrypt(HPair, 0, True, 0, PByte(PChar(Result)), @DDataSize, EDataSize)) then
          Result := '';
      end;
    finally
      CryptDestroyKey(HPair);
    end;
  finally
  CryptReleaseContext(RSA, 0);
  end;
  FreeAndNil(KeyPair);
end;

function RSADecrypt(Source, Key: String): String;
var
  KeyPair: TStringStream;
  RSA: HCRYPTPROV;
  HPair: HCRYPTKEY;
  EDataSize: DWORD;

begin
  KeyPair := TStringStream.Create(Key);
  Result := '';
  if CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) then
  try
    if CryptImportKey(RSA, PByte(KeyPair.Memory), KeyPair.Size, 0, 0, @HPair) then
    try
      Result := Source;
      EDataSize := Length(Result);
      if not Bool(CryptDecrypt(HPair, 0, True, 0, PByte(PChar(Result)), @EDataSize)) then
        EDataSize := 0;
      SetLength(Result, EDataSize div SizeOf(Char));
    finally
      CryptDestroyKey(HPair);
    end;
  finally
    CryptReleaseContext(RSA, 0);
  end;
  FreeAndNil(KeyPair);
end;

end.
</code></pre>
","<p>C# in a Nutshell says that plaintext much longer than 1/2 the key size will cause an error.  It's likely the same for most languages for security purposes.  For longer messages, use RSA to pass a key for symmetrical encryption such as AES.</p>
","1818","<delphi><cryptoapi>","0","0","2","2017-12-27 12:52:12","14689566","0","","","","","2013-02-04 14:53:12",""
"14689294","Windows Crypto Api bad length","<p>I found a simple unit for generating a RSA KeyPair and encrypting / decrypting. It works fine on small strings but on larger text I get error : Bad Length.</p>

<p>What could be the cause , here is the unit, the unit wcrypt2 you can download <a href=""http://stuff.irsoft.de/CryptoAPI2.zip"" rel=""nofollow"">here</a></p>

<p>Tested on Delphi 2010</p>

<pre><code>unit Crypt_RSA;

interface

uses
  Windows, Classes, SysUtils, WCrypt2;

function RSAGenerateKeys(var PrivateKey, PublicKey: String): Boolean;
function RSAEncrypt(Source, Key: String): String;
function RSADecrypt(Source, Key: String): String;

implementation

function RSAGenerateKeys(var PrivateKey, PublicKey: String): Boolean;
const
  RSA1024BIT_KEY = $04000000;

var
  RSA: HCRYPTPROV;
  HKeyPair: HCRYPTKEY;
  Pair: TStringStream;
  buflen: DWORD;

  function SetKey(BlobDef: Cardinal; var Key: String): Boolean;
  begin
    Result := Bool(CryptExportKey(HKeyPair, 0, BlobDef, 0, nil, @buflen));
    if Result then
    begin
      Pair.SetSize(buflen);
      Result := Bool(CryptExportKey(HKeyPair, 0, BlobDef, 0, PByte(Pair.Memory), @buflen));
    end;

    Key := Pair.ReadString(buflen);
    Pair.Seek(0, soBeginning);
  end;

begin
  Pair := TStringStream.Create;

  Result := Bool(CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));
  if Result then
    Result := Bool(CryptGenKey(RSA, AT_KEYEXCHANGE, RSA1024BIT_KEY or CRYPT_EXPORTABLE, @HKeyPair));

  if Result then
    Result := SetKey(PRIVATEKEYBLOB, PrivateKey);
  if Result then
    Result := SetKey(PUBLICKEYBLOB, PublicKey);

  CryptDestroyKey(HKeyPair);
  CryptReleaseContext(RSA, 0);
  FreeAndNil(Pair);
end;

function RSAEncrypt(Source, Key: String): String;
var
  KeyPair: TStringStream;
  RSA: HCRYPTPROV;
  HPair: HCRYPTKEY;
  DDataSize, EDataSize: DWORD;

begin
  Result := '';
  KeyPair := TStringStream.Create(Key);
  if CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) then
  try
    if CryptImportKey(RSA, PByte(KeyPair.Memory), KeyPair.Size, 0, 0, @HPair) then
    try
      EDataSize := SizeOf(Source);
      if CryptEncrypt(HPair, 0, true, 0, nil, @EDataSize, 0) then
      begin
        Result := Source;
        SetLength(Result, EDataSize);
        DDataSize := Length(Source) * SizeOf(Char);
        if not(CryptEncrypt(HPair, 0, True, 0, PByte(PChar(Result)), @DDataSize, EDataSize)) then
          Result := '';
      end;
    finally
      CryptDestroyKey(HPair);
    end;
  finally
  CryptReleaseContext(RSA, 0);
  end;
  FreeAndNil(KeyPair);
end;

function RSADecrypt(Source, Key: String): String;
var
  KeyPair: TStringStream;
  RSA: HCRYPTPROV;
  HPair: HCRYPTKEY;
  EDataSize: DWORD;

begin
  KeyPair := TStringStream.Create(Key);
  Result := '';
  if CryptAcquireContext(@RSA, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) then
  try
    if CryptImportKey(RSA, PByte(KeyPair.Memory), KeyPair.Size, 0, 0, @HPair) then
    try
      Result := Source;
      EDataSize := Length(Result);
      if not Bool(CryptDecrypt(HPair, 0, True, 0, PByte(PChar(Result)), @EDataSize)) then
        EDataSize := 0;
      SetLength(Result, EDataSize div SizeOf(Char));
    finally
      CryptDestroyKey(HPair);
    end;
  finally
    CryptReleaseContext(RSA, 0);
  end;
  FreeAndNil(KeyPair);
end;

end.
</code></pre>
","<p>Asymmetric encryption limits the data to less than the key size, there is padding such as OAEP which is 42 bytes.</p>

<p>If you must have asymmetric encryption, that is need a key pair, use hybrid encryption which is essentially what https does. See <a href=""https://en.wikipedia.org/wiki/Hybrid_cryptosystem"" rel=""nofollow noreferrer"">Hybrid cryptosystem</a>.</p>

<p>For Hybrid  encryption basically you create a random symmetric encryption key, encrypt the symmetric key with an asymmetric encryption, encrypt the data with the symmetric key and package the two encryptions together.</p>

<p>Why don't you want symmetric encryption? It is much faster and handles essentially any data size? AES is the encryption workhorse.</p>
","1818","<delphi><cryptoapi>","0","0","2","2017-12-27 12:52:12","14689566","0","","","","","2013-02-04 14:53:12",""
"34838400","Using CAPI engine with openssl","<p>To load the capi engine dynamically, the following code is used:</p>

<pre><code>EVP_PKEY *key = NULL;
ENGINE_load_builtin_engines();
ENGINE *engine = ENGINE_by_id(""dynamic"");
ENGINE_ctrl_cmd_string(engine, ""SO_PATH"", ""./capi.dll"", 0); 
ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0); 
ENGINE_init(engine);
</code></pre>

<p>While debugging I checked, <code>ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0)</code> is failing. So what could be the reason for this?</p>

<p>I have not build openssl for using <code>capi</code>, I am using default <code>capi.dll</code> that came with openssl.
Should I build the openssl again with capi enabled in openssl.cfg file, or is there something else I am doing wrong?</p>
","<p>I had basically the same issue using <code>capi.dll</code> on the command line:</p>

<pre><code>openssl engine dynamic -t -pre SO_PATH:./capi.dll -pre LOAD -post list_csps
</code></pre>

<p>After lot of trial and error, I found that the DLL I was using was a dummy! It basically contained a bind_engine function that always returned 0 (which means failure). Using a CAPI DLL that was natively compiled under Windows it worked.</p>
","1783","<openssl><cryptoapi>","0","0","3","2017-11-01 15:16:29","","1","","6388243","","2017-11-01 13:31:57","2016-01-17 12:39:30",""
"34838400","Using CAPI engine with openssl","<p>To load the capi engine dynamically, the following code is used:</p>

<pre><code>EVP_PKEY *key = NULL;
ENGINE_load_builtin_engines();
ENGINE *engine = ENGINE_by_id(""dynamic"");
ENGINE_ctrl_cmd_string(engine, ""SO_PATH"", ""./capi.dll"", 0); 
ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0); 
ENGINE_init(engine);
</code></pre>

<p>While debugging I checked, <code>ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0)</code> is failing. So what could be the reason for this?</p>

<p>I have not build openssl for using <code>capi</code>, I am using default <code>capi.dll</code> that came with openssl.
Should I build the openssl again with capi enabled in openssl.cfg file, or is there something else I am doing wrong?</p>
","<p>Another (pretty obscure) reason why engine loading may fail is that the library itself requires another library, which is not found. In this case, one simply gets the generic <code>No such file or directory</code> error (although the path of the library, e.g., <code>./capi.dll</code>, is correct). </p>

<p>To check if this is the problem, try </p>

<pre><code>ldd ./capi.dll
</code></pre>

<p>or</p>

<pre><code>cygcheck ./capi.dll
</code></pre>

<p>and if so, copy the missing library dependencies (e.g., <code>libeay32.dll</code>) to the current directory.</p>
","1783","<openssl><cryptoapi>","0","0","3","2017-11-01 15:16:29","","1","","6388243","","2017-11-01 13:31:57","2016-01-17 12:39:30",""
"34838400","Using CAPI engine with openssl","<p>To load the capi engine dynamically, the following code is used:</p>

<pre><code>EVP_PKEY *key = NULL;
ENGINE_load_builtin_engines();
ENGINE *engine = ENGINE_by_id(""dynamic"");
ENGINE_ctrl_cmd_string(engine, ""SO_PATH"", ""./capi.dll"", 0); 
ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0); 
ENGINE_init(engine);
</code></pre>

<p>While debugging I checked, <code>ENGINE_ctrl_cmd_string(engine, ""LOAD"", NULL, 0)</code> is failing. So what could be the reason for this?</p>

<p>I have not build openssl for using <code>capi</code>, I am using default <code>capi.dll</code> that came with openssl.
Should I build the openssl again with capi enabled in openssl.cfg file, or is there something else I am doing wrong?</p>
","<p>I spent time trying to find the capi.dll only to realize it was already compiled into the Windows openssl components.</p>

<p>From the command line:</p>

<pre><code>openssl engine capi
</code></pre>
","1783","<openssl><cryptoapi>","0","-1","3","2017-11-01 15:16:29","","1","","6388243","","2017-11-01 13:31:57","2016-01-17 12:39:30",""
"8597893","Using CryptHashData On Very Large Input","<p>I am trying to MD5 hash user-supplied data (a file) using The Crypto functions in AdvApi32. All is well and good unless the file is very large (hundreds of MB. or larger) in which case I eventually get an OutOfMemory exception.</p>

<p>I figured that the solution would be to make repeated calls to <code>CryptHashData</code> using the same <code>HashObject</code> and processing only (for example) 4096 bytes at a time.</p>

<p>This appears to work, but the returned hash is incorrect.</p>

<pre><code>Function HashFile(File As FolderItem) As String
  Declare Function CryptAcquireContextW Lib ""AdvApi32"" (ByRef provider as Integer, container as Integer, providerName as WString, _
  providerType as Integer, flags as Integer) as Boolean
  Declare Sub CryptDestroyHash Lib ""AdvApi32"" (hashHandle as Integer )
  Declare Function CryptCreateHash Lib ""AdvApi32"" (provider as Integer, algorithm as Integer, key as Integer, flags as Integer, _
  ByRef hashHandle as Integer) as Boolean
  Declare Function CryptHashData Lib ""AdvApi32"" (hashHandle as Integer, data as Ptr, length as Integer, flags as Integer) as Boolean
  Declare Function CryptGetHashParam Lib ""AdvApi32"" (hashHandle as Integer, type as Integer, value as Ptr, ByRef length as Integer, _
  flags as Integer) as Boolean

  Const HP_HASHVAL = &amp;h0002
  Const HP_HASHSIZE = &amp;h0004
  Const MS_DEF_PROV = ""Microsoft Base Cryptographic Provider v1.0""
  Const PROV_RSA_FULL = 1
  Const CRYPT_NEWKEYSET = &amp;h00000008
  Const CALG_MD5 = &amp;h00008003

  Dim provider As Integer
  Dim hashHandle As Integer

  If Not CryptAcquireContextW(provider, 0, MS_DEF_PROV, PROV_RSA_FULL, 0) Then
    If Not CryptAcquireContextW(provider, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET) Then
      Raise New RuntimeException
    End If
  End If

  If Not CryptCreateHash(provider, CALG_MD5, 0, 0, hashHandle) Then
    Raise New RuntimeException
  End If

  Dim dataPtr As New MemoryBlock(4096)
  Dim bs As BinaryStream
  bs = bs.Open(File)
  dataPtr.StringValue(0, 4096) = bs.Read(4096)

  Do
    If CryptHashData(hashHandle, dataPtr, dataPtr.Size, 0) Then
      dataPtr = New MemoryBlock(4096)
      dataPtr.StringValue(0, 4095) = bs.Read(4096)
    End If
  Loop Until bs.EOF

  Dim size as Integer = 4
  Dim toss As New MemoryBlock(4)
  If Not CryptGetHashParam(hashHandle, HP_HASHSIZE, toss, size, 0) Then
    Raise New RuntimeException
  End If

  size = toss.UInt32Value(0)

  Dim hashValue As New MemoryBlock(size)
  If Not CryptGetHashParam(hashHandle, HP_HASHVAL, hashValue, size, 0) Then
    Raise New RuntimeException
  End If
  CryptDestroyHash(hashHandle)

  //Convert binary to hex
  Dim hexvalue As Integer
  Dim hexedInt As String
  Dim src As String = hashValue.StringValue(0, hashValue.Size)
  For i As Integer = 1 To LenB(src)
    hexvalue = AscB(MidB(src, i, 1))
    hexedInt = hexedInt + RightB(""00"" + Hex(hexvalue), 2)
  next

  Return LeftB(hexedInt, LenB(hexedInt))

End Function
</code></pre>

<p>What am I doing wrong here? The output I get is consistent, but wrong.</p>
","<p>Did you check <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382380%28v=vs.85%29.aspx"" rel=""nofollow"">that msdn example</a> on C++ ?
Very similar answer to your question.</p>
","1766","<winapi><cryptoapi><realbasic>","0","0","2","2013-04-27 21:01:31","","3","","600511","","2011-12-22 01:20:29","2011-12-21 23:54:25",""
"8597893","Using CryptHashData On Very Large Input","<p>I am trying to MD5 hash user-supplied data (a file) using The Crypto functions in AdvApi32. All is well and good unless the file is very large (hundreds of MB. or larger) in which case I eventually get an OutOfMemory exception.</p>

<p>I figured that the solution would be to make repeated calls to <code>CryptHashData</code> using the same <code>HashObject</code> and processing only (for example) 4096 bytes at a time.</p>

<p>This appears to work, but the returned hash is incorrect.</p>

<pre><code>Function HashFile(File As FolderItem) As String
  Declare Function CryptAcquireContextW Lib ""AdvApi32"" (ByRef provider as Integer, container as Integer, providerName as WString, _
  providerType as Integer, flags as Integer) as Boolean
  Declare Sub CryptDestroyHash Lib ""AdvApi32"" (hashHandle as Integer )
  Declare Function CryptCreateHash Lib ""AdvApi32"" (provider as Integer, algorithm as Integer, key as Integer, flags as Integer, _
  ByRef hashHandle as Integer) as Boolean
  Declare Function CryptHashData Lib ""AdvApi32"" (hashHandle as Integer, data as Ptr, length as Integer, flags as Integer) as Boolean
  Declare Function CryptGetHashParam Lib ""AdvApi32"" (hashHandle as Integer, type as Integer, value as Ptr, ByRef length as Integer, _
  flags as Integer) as Boolean

  Const HP_HASHVAL = &amp;h0002
  Const HP_HASHSIZE = &amp;h0004
  Const MS_DEF_PROV = ""Microsoft Base Cryptographic Provider v1.0""
  Const PROV_RSA_FULL = 1
  Const CRYPT_NEWKEYSET = &amp;h00000008
  Const CALG_MD5 = &amp;h00008003

  Dim provider As Integer
  Dim hashHandle As Integer

  If Not CryptAcquireContextW(provider, 0, MS_DEF_PROV, PROV_RSA_FULL, 0) Then
    If Not CryptAcquireContextW(provider, 0, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET) Then
      Raise New RuntimeException
    End If
  End If

  If Not CryptCreateHash(provider, CALG_MD5, 0, 0, hashHandle) Then
    Raise New RuntimeException
  End If

  Dim dataPtr As New MemoryBlock(4096)
  Dim bs As BinaryStream
  bs = bs.Open(File)
  dataPtr.StringValue(0, 4096) = bs.Read(4096)

  Do
    If CryptHashData(hashHandle, dataPtr, dataPtr.Size, 0) Then
      dataPtr = New MemoryBlock(4096)
      dataPtr.StringValue(0, 4095) = bs.Read(4096)
    End If
  Loop Until bs.EOF

  Dim size as Integer = 4
  Dim toss As New MemoryBlock(4)
  If Not CryptGetHashParam(hashHandle, HP_HASHSIZE, toss, size, 0) Then
    Raise New RuntimeException
  End If

  size = toss.UInt32Value(0)

  Dim hashValue As New MemoryBlock(size)
  If Not CryptGetHashParam(hashHandle, HP_HASHVAL, hashValue, size, 0) Then
    Raise New RuntimeException
  End If
  CryptDestroyHash(hashHandle)

  //Convert binary to hex
  Dim hexvalue As Integer
  Dim hexedInt As String
  Dim src As String = hashValue.StringValue(0, hashValue.Size)
  For i As Integer = 1 To LenB(src)
    hexvalue = AscB(MidB(src, i, 1))
    hexedInt = hexedInt + RightB(""00"" + Hex(hexvalue), 2)
  next

  Return LeftB(hexedInt, LenB(hexedInt))

End Function
</code></pre>

<p>What am I doing wrong here? The output I get is consistent, but wrong.</p>
","<p>I think the problem is that since you read the data in blocks of 4096 bytes - when the data is not a multiple of 4096 you endup including unwanted trailing 0's or possibly garbage values. Try <code>bs.Read(1)</code> instead of <code>bs.Read(4096)</code> in the loop: <code>Loop Until bs.EOF</code> in-order to test if correct hash is being calculated now. If successful adjust your loop to tackle the remainder (%4096) bytes separately.</p>
","1766","<winapi><cryptoapi><realbasic>","0","0","2","2013-04-27 21:01:31","","3","","600511","","2011-12-22 01:20:29","2011-12-21 23:54:25",""
"5365965","Pinvoking adwapi.dll - cryptDecrypt and cryptEncrypt functions, weird problem","<p>I am observing wierd behaviour of this function, the string that I want to encrypt contains 14 bytes, if I use the function to send lenght of buffer = 14, it fails (""an internal error"" - very descriptive and most helpful error code), but it works when the buffer length (and the buffer itself) is 128 bytes large.</p>

<p>I overcame this problem by making a size 128 byte array and I copied the 14 bytes from the plain text (that I wish to encrypt),</p>

<p>When I decrypt those bytes, I must once again give the function the whole 128 byte array (which now has every byte encrypted, even the ones from #13-#127 (which I guess is to be expected)). Luckily for me the first 14 bytes get decrypted as they should, the rest is gibberish.</p>

<p>I would like to know why the encrypt method fails if the incoming buffer isnt 128 byte large, and also why decrypt function also requires a 128 byte array, is it some padding thing? </p>

<p>This is how I call the encrypt function:</p>

<pre><code>System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();  // encoding type
byte[] buff = new byte[128];     // this is my buffer array, instantiated and initiated
string String2Encrypt = ""Testing"";      // this is the string I need encrypted
byte[] tempo = encoding.GetBytes(String2Encrypt);   // getting bytes from string
Buffer.BlockCopy(tempo, 0, buff, 0, tempo.Length);    // copying the small array into the large one
uint inputlength = Convert.ToUInt32(tempo.Length);   // getting the size of the small array 


bool DidIt = UnsafeNativeMethods.CryptEncrypt(MyKey, IntPtr.Zero, 1, 0, buff, ref inputlength, outputdatalength);     // calling the function
</code></pre>

<p>// in this case, the MyKey is pointer to a crypto key, 2nd argument is null, 3rd is ""true"" (no more data), no flags, buffer byte array  (128), Testing.Length in this case it is 7, 128</p>

<p>This is how I decrypt it:</p>

<pre><code>IntPtr UserKeyLocal = MyUserKey;     // taking an argument (MyUserKey) and ""filling"" the local variable, not really relevant
byte[] dataCopy = new byte[buff.Length];   // init and insta the datacopy array (128 byte)
Buffer.BlockCopy(buff, 0, dataCopy, 0, (int)buff.Length);   // copying the argument array into a local version (I used this for testing to go around another problem), irrelevant
uint locinputlength = inputlength;  // another argument made local
bool DidIT = UnsafeNativeMethods.CryptDecrypt(UserKeyLocal, IntPtr.Zero, true, 0, dataCopy, ref locinputlength);     // calling the function
</code></pre>

<p>The result would look like this:
Testing?R????7?q?????$??uj??m%?b??e?a?74p?)?n9??w?R*O)E?<code>i?+?</code>>[?S???}Ct?n?&amp;??b?P!?u1??%?JQ???/?mP?5wB????</p>

<p>Its almost working as intended but I need to be able to get ONLY the ""Testing"" part of the string without using tricks like substringing.</p>

<p>What I am trying to do (maybe there is an alternative way) is this; I have a binary (file) that has in it ""Testing"" encrypted by a public key I got from a certificate which I exported form a SmartCard. 
I need to verify (decrypt) this file by using my SmartCard (I am using its propriety CSP) with the private key. As you can see, it ALMOST works.</p>

<p>Thanks in advance.</p>
","<p>I think the reason the buffer must be 128 bytes is that a block cipher is being used.  In that case, the buffer length must be a multiple of the block size.  With a block ciper, the buffer may need to be larger than the size of the data anyway, so that the encrypted or decrypted data can be written to it (length(encrypted) != length(plaintext)).</p>

<p>After you call CryptDecrypt, the parameter <code>pdwDataLen</code> (<code>locInputLength</code> in your code) will contain the length of the actual data that was decrypted.  If you take only the first <code>locInputLength</code> bytes of <code>dataCopy</code>, does it give you what you need?</p>

<p>References:
<a href=""http://msdn.microsoft.com/en-us/library/aa379913(VS.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa379913(VS.85).aspx</a>
http://msdn.microsoft.com/en-us/library/aa379924(VS.85).aspx</p>
","1744","<c#><pinvoke><smartcard><cryptoapi>","0","2","2","2011-09-14 12:12:25","","1","","256196","","2011-09-14 12:12:25","2011-03-20 00:40:40",""
"5365965","Pinvoking adwapi.dll - cryptDecrypt and cryptEncrypt functions, weird problem","<p>I am observing wierd behaviour of this function, the string that I want to encrypt contains 14 bytes, if I use the function to send lenght of buffer = 14, it fails (""an internal error"" - very descriptive and most helpful error code), but it works when the buffer length (and the buffer itself) is 128 bytes large.</p>

<p>I overcame this problem by making a size 128 byte array and I copied the 14 bytes from the plain text (that I wish to encrypt),</p>

<p>When I decrypt those bytes, I must once again give the function the whole 128 byte array (which now has every byte encrypted, even the ones from #13-#127 (which I guess is to be expected)). Luckily for me the first 14 bytes get decrypted as they should, the rest is gibberish.</p>

<p>I would like to know why the encrypt method fails if the incoming buffer isnt 128 byte large, and also why decrypt function also requires a 128 byte array, is it some padding thing? </p>

<p>This is how I call the encrypt function:</p>

<pre><code>System.Text.ASCIIEncoding encoding = new System.Text.ASCIIEncoding();  // encoding type
byte[] buff = new byte[128];     // this is my buffer array, instantiated and initiated
string String2Encrypt = ""Testing"";      // this is the string I need encrypted
byte[] tempo = encoding.GetBytes(String2Encrypt);   // getting bytes from string
Buffer.BlockCopy(tempo, 0, buff, 0, tempo.Length);    // copying the small array into the large one
uint inputlength = Convert.ToUInt32(tempo.Length);   // getting the size of the small array 


bool DidIt = UnsafeNativeMethods.CryptEncrypt(MyKey, IntPtr.Zero, 1, 0, buff, ref inputlength, outputdatalength);     // calling the function
</code></pre>

<p>// in this case, the MyKey is pointer to a crypto key, 2nd argument is null, 3rd is ""true"" (no more data), no flags, buffer byte array  (128), Testing.Length in this case it is 7, 128</p>

<p>This is how I decrypt it:</p>

<pre><code>IntPtr UserKeyLocal = MyUserKey;     // taking an argument (MyUserKey) and ""filling"" the local variable, not really relevant
byte[] dataCopy = new byte[buff.Length];   // init and insta the datacopy array (128 byte)
Buffer.BlockCopy(buff, 0, dataCopy, 0, (int)buff.Length);   // copying the argument array into a local version (I used this for testing to go around another problem), irrelevant
uint locinputlength = inputlength;  // another argument made local
bool DidIT = UnsafeNativeMethods.CryptDecrypt(UserKeyLocal, IntPtr.Zero, true, 0, dataCopy, ref locinputlength);     // calling the function
</code></pre>

<p>The result would look like this:
Testing?R????7?q?????$??uj??m%?b??e?a?74p?)?n9??w?R*O)E?<code>i?+?</code>>[?S???}Ct?n?&amp;??b?P!?u1??%?JQ???/?mP?5wB????</p>

<p>Its almost working as intended but I need to be able to get ONLY the ""Testing"" part of the string without using tricks like substringing.</p>

<p>What I am trying to do (maybe there is an alternative way) is this; I have a binary (file) that has in it ""Testing"" encrypted by a public key I got from a certificate which I exported form a SmartCard. 
I need to verify (decrypt) this file by using my SmartCard (I am using its propriety CSP) with the private key. As you can see, it ALMOST works.</p>

<p>Thanks in advance.</p>
","<p>Yup, that did it! easy as pie!</p>

<pre><code>            byte[] buffer = new byte[locinputlength];
            Buffer.BlockCopy(dataCopy, 0, buffer, 0, (int)locinputlength);
            return buffer;
</code></pre>

<p>One of those things you just dont ""see"" until you step back a little and look at the thing from a slightly different perspective ;)</p>
","1744","<c#><pinvoke><smartcard><cryptoapi>","0","0","2","2011-09-14 12:12:25","","1","","256196","","2011-09-14 12:12:25","2011-03-20 00:40:40",""
"6429251","VS2010 - Structure change in CryptoAPI - v7.0A Vs v6.0A - WinCrypt.h","<p>In <code>C:\Program Files\Microsoft SDKs\Windows\v7.0A\Include\WinCrypt.h</code>, the definition for <code>CERT_CHAIN_ENGINE_CONFIG</code> is </p>

<pre><code>typedef struct _CERT_CHAIN_ENGINE_CONFIG {

    DWORD       cbSize;
    HCERTSTORE  hRestrictedRoot;
    HCERTSTORE  hRestrictedTrust;
    HCERTSTORE  hRestrictedOther;
    DWORD       cAdditionalStore;
    HCERTSTORE* rghAdditionalStore;
    DWORD       dwFlags;
    DWORD       dwUrlRetrievalTimeout;      // milliseconds
    DWORD       MaximumCachedCertificates;
    DWORD       CycleDetectionModulus;

*#if (NTDDI_VERSION &gt;= NTDDI_WIN7)
    HCERTSTORE  hExclusiveRoot;
    HCERTSTORE  hExclusiveTrustedPeople;
#endif*

} CERT_CHAIN_ENGINE_CONFIG, *PCERT_CHAIN_ENGINE_CONFIG;
</code></pre>

<p>I am using visual studio 2010 in an XP sp3 machine, in which case, i expect that the following  two members in the above structure gets greyed out. But this is not happening,</p>

<pre><code>#if (NTDDI_VERSION &gt;= NTDDI_WIN7)
    HCERTSTORE  hExclusiveRoot;
    HCERTSTORE  hExclusiveTrustedPeople;
#endif
</code></pre>

<p><code>NTDDI_VERSION</code> in-turn is defined in <code>sdkddkver.h</code> as follows, and <code>_WIN32_WINNT</code> somehow takes the value of <code>NTDDI_WIN7</code> which in my case is incorrect as mine is a XP SP3 machine.</p>

<pre><code>#if !defined(_WIN32_WINNT) &amp;&amp; !defined(_CHICAGO_)
#define  _WIN32_WINNT   0x0601
#endif
#ifndef NTDDI_VERSION
#ifdef _WIN32_WINNT
// set NTDDI_VERSION based on _WIN32_WINNT
#define NTDDI_VERSION   NTDDI_VERSION_FROM_WIN32_WINNT(_WIN32_WINNT)
#else
#define NTDDI_VERSION   0x06010000
#endif
#endif
</code></pre>

<p>The above two members of the structure <code>CERT_CHAIN_ENGINE_CONFIG</code> in question is not present in  <code>C:\Program Files\Microsoft SDKs\Windows\v6.0A\Include\WinCrypt.h</code>But my 2010 visual studio project automatically pulls in the header and lib files from <code>C:\Program Files\Microsoft SDKs\Windows\v7.0A\Include\WinCrypt.h</code> Because of the conflicting structures, i am getting <code>parameter is incorrect</code></p>

<p>Please advise how i can over come this issue?</p>

<p>Should i have to install visual studio 2010 sp1?</p>

<p>I <a href=""http://translate.googleusercontent.com/translate_c?hl=en&amp;prev=/search?q=NTDDI_WIN7%2bCertCreateCertificateChainEngine&amp;hl=en&amp;client=firefox-a&amp;hs=QX3&amp;rls=org.mozilla:en-GB:official&amp;prmd=ivns&amp;rurl=translate.google.co.uk&amp;sl=ja&amp;u=http://techwing.wordpress.com/2010/07/06/cryptoapi-%25E3%2581%25AE-cert_chain_engine_config-%25E6%25A7%258B%25E9%2580%25A0%25E4%25BD%2593-%25E3%2581%25AE-windows-7-windows-server-2008-r2-%25E3%2581%25A7%25E3%2581%25AE%25E6%258B%25A1%25E5%25BC%25B5/&amp;usg=ALkJrhjCHAya-NYcIBtn7oExiRr3QPHIIA"" rel=""noreferrer"">found one reference in the web</a> where it says initialising the structure will resolve the issue, but it will not, as the two parameters in question will not be greyed out and will be taken in while building.</p>

<p><strong>UPDATE1:</strong></p>

<p>Settings of my project:</p>

<p><img src=""https://i.stack.imgur.com/2Tujs.jpg"" alt=""enter image description here"">
$(VCInstalDir) - >C:\Program Files\Microsoft Visual Studio 10.0\VC</p>

<p>$(WindowsSdkDir) ->C:\Program Files\Microsoft SDKs\Windows\v7.0A</p>

<p>$(FrameworkSdkDir) ->C:\Program Files\Microsoft SDKs\Windows\v7.0A</p>

<p>Library file settings,</p>

<pre><code>$(VCInstallDir)lib
$(VCInstallDir)atlmfc\lib
$(WindowsSdkDir)lib
$(FrameworkSDKDir)\lib
</code></pre>

<p><strong>UPDATE 2:</strong>
My preprocessor definitions are</p>

<pre><code>WIN32;_DEBUG;_WINDOWS;_USRDLL;MY_DLL_EXPORTS;%(PreprocessorDefinitions)
</code></pre>

<p>%(PreprocessorDefinitions) inherited values as follows</p>

<pre><code>_WINDLL
_MBCS
</code></pre>

<p>Thanks</p>
","<blockquote>
  <p>the value of NTDDI_WIN7 which in my case is incorrect as mine is a XP SP3 machine.</p>
</blockquote>

<p>As I understand it, the variables are initialized according to what system you are targeting, not what system you are compiling the code on. So you need to look at your project settings and see, what is your target platform, what headers are referenced etc. . </p>
","1742","<c++><visual-studio-2010><visual-c++><certificate><cryptoapi>","7","4","2","2011-07-01 14:28:42","6549295","0","","119535","","2011-06-23 14:22:18","2011-06-21 17:12:43",""
"6429251","VS2010 - Structure change in CryptoAPI - v7.0A Vs v6.0A - WinCrypt.h","<p>In <code>C:\Program Files\Microsoft SDKs\Windows\v7.0A\Include\WinCrypt.h</code>, the definition for <code>CERT_CHAIN_ENGINE_CONFIG</code> is </p>

<pre><code>typedef struct _CERT_CHAIN_ENGINE_CONFIG {

    DWORD       cbSize;
    HCERTSTORE  hRestrictedRoot;
    HCERTSTORE  hRestrictedTrust;
    HCERTSTORE  hRestrictedOther;
    DWORD       cAdditionalStore;
    HCERTSTORE* rghAdditionalStore;
    DWORD       dwFlags;
    DWORD       dwUrlRetrievalTimeout;      // milliseconds
    DWORD       MaximumCachedCertificates;
    DWORD       CycleDetectionModulus;

*#if (NTDDI_VERSION &gt;= NTDDI_WIN7)
    HCERTSTORE  hExclusiveRoot;
    HCERTSTORE  hExclusiveTrustedPeople;
#endif*

} CERT_CHAIN_ENGINE_CONFIG, *PCERT_CHAIN_ENGINE_CONFIG;
</code></pre>

<p>I am using visual studio 2010 in an XP sp3 machine, in which case, i expect that the following  two members in the above structure gets greyed out. But this is not happening,</p>

<pre><code>#if (NTDDI_VERSION &gt;= NTDDI_WIN7)
    HCERTSTORE  hExclusiveRoot;
    HCERTSTORE  hExclusiveTrustedPeople;
#endif
</code></pre>

<p><code>NTDDI_VERSION</code> in-turn is defined in <code>sdkddkver.h</code> as follows, and <code>_WIN32_WINNT</code> somehow takes the value of <code>NTDDI_WIN7</code> which in my case is incorrect as mine is a XP SP3 machine.</p>

<pre><code>#if !defined(_WIN32_WINNT) &amp;&amp; !defined(_CHICAGO_)
#define  _WIN32_WINNT   0x0601
#endif
#ifndef NTDDI_VERSION
#ifdef _WIN32_WINNT
// set NTDDI_VERSION based on _WIN32_WINNT
#define NTDDI_VERSION   NTDDI_VERSION_FROM_WIN32_WINNT(_WIN32_WINNT)
#else
#define NTDDI_VERSION   0x06010000
#endif
#endif
</code></pre>

<p>The above two members of the structure <code>CERT_CHAIN_ENGINE_CONFIG</code> in question is not present in  <code>C:\Program Files\Microsoft SDKs\Windows\v6.0A\Include\WinCrypt.h</code>But my 2010 visual studio project automatically pulls in the header and lib files from <code>C:\Program Files\Microsoft SDKs\Windows\v7.0A\Include\WinCrypt.h</code> Because of the conflicting structures, i am getting <code>parameter is incorrect</code></p>

<p>Please advise how i can over come this issue?</p>

<p>Should i have to install visual studio 2010 sp1?</p>

<p>I <a href=""http://translate.googleusercontent.com/translate_c?hl=en&amp;prev=/search?q=NTDDI_WIN7%2bCertCreateCertificateChainEngine&amp;hl=en&amp;client=firefox-a&amp;hs=QX3&amp;rls=org.mozilla:en-GB:official&amp;prmd=ivns&amp;rurl=translate.google.co.uk&amp;sl=ja&amp;u=http://techwing.wordpress.com/2010/07/06/cryptoapi-%25E3%2581%25AE-cert_chain_engine_config-%25E6%25A7%258B%25E9%2580%25A0%25E4%25BD%2593-%25E3%2581%25AE-windows-7-windows-server-2008-r2-%25E3%2581%25A7%25E3%2581%25AE%25E6%258B%25A1%25E5%25BC%25B5/&amp;usg=ALkJrhjCHAya-NYcIBtn7oExiRr3QPHIIA"" rel=""noreferrer"">found one reference in the web</a> where it says initialising the structure will resolve the issue, but it will not, as the two parameters in question will not be greyed out and will be taken in while building.</p>

<p><strong>UPDATE1:</strong></p>

<p>Settings of my project:</p>

<p><img src=""https://i.stack.imgur.com/2Tujs.jpg"" alt=""enter image description here"">
$(VCInstalDir) - >C:\Program Files\Microsoft Visual Studio 10.0\VC</p>

<p>$(WindowsSdkDir) ->C:\Program Files\Microsoft SDKs\Windows\v7.0A</p>

<p>$(FrameworkSdkDir) ->C:\Program Files\Microsoft SDKs\Windows\v7.0A</p>

<p>Library file settings,</p>

<pre><code>$(VCInstallDir)lib
$(VCInstallDir)atlmfc\lib
$(WindowsSdkDir)lib
$(FrameworkSDKDir)\lib
</code></pre>

<p><strong>UPDATE 2:</strong>
My preprocessor definitions are</p>

<pre><code>WIN32;_DEBUG;_WINDOWS;_USRDLL;MY_DLL_EXPORTS;%(PreprocessorDefinitions)
</code></pre>

<p>%(PreprocessorDefinitions) inherited values as follows</p>

<pre><code>_WINDLL
_MBCS
</code></pre>

<p>Thanks</p>
","<p>The problem which you have can be very easy explained. If you use v7.0A or v7.1 you are able to compile your project so that it will run under Windows 7. So the default value for the <code>_WIN32_WINNT</code> is <code>0x0601</code>.</p>

<p>If you want co compile the program so that it will run on Windows XP you can <a href=""http://msdn.microsoft.com/en-US/library/6sehtctf.aspx"" rel=""nofollow"">define WINVER and _WIN32_WINNT explicitly</a>. Typically one do this in the settings of the Visual Studio project inside of the preprocessor definitions. If you will do this the corresponding part of <code>CERT_CHAIN_ENGINE_CONFIG</code> structure will be displayed gray like you as want.</p>

<p>In the most cases and in the case of <code>CERT_CHAIN_ENGINE_CONFIG</code> it is not really needed. The Windows API are designed mostly so, that you will have no problems in the usage of <code>CERT_CHAIN_ENGINE_CONFIG</code> defined for Windows 7 in case of the start of the program on Windows XP. If you do define </p>

<pre><code>#define WINVER 0x0500
#define _WIN32_WINNT 0x0500
</code></pre>

<p>(or <code>0x0501</code> instead of <code>0x0500</code>) you will be able to run your program in the Windows 7, but you will be not able to use the <code>hExclusiveRoot</code> and the <code>hExclusiveTrustedPeople</code> members. The reason is the <code>cbSize</code> field which you should initialize as <code>sizeof(CERT_CHAIN_ENGINE_CONFIG)</code>. It gives for the <a href=""http://msdn.microsoft.com/en-us/library/aa376032.aspx"" rel=""nofollow"">CertCreateCertificateChainEngine</a> function enough information about the size of the input structure <code>CERT_CHAIN_ENGINE_CONFIG</code>. In case of small value of <code>cbSize</code>, the last <code>HCERTSTORE</code> members <code>hExclusiveRoot</code> and <code>hExclusiveTrustedPeople</code> will be just not used.</p>
","1742","<c++><visual-studio-2010><visual-c++><certificate><cryptoapi>","7","4","2","2011-07-01 14:28:42","6549295","0","","119535","","2011-06-23 14:22:18","2011-06-21 17:12:43",""
"23657238","CryptEncrypt fails with NTE_BAD_LEN","<p>I need to encrypt message with X.509 RSA public key. I successfully imported 1024-bit public key in DER format, but my program fails with message longer than about 110 bytes. I'm calling <code>CryptEncrypt</code> function with <code>pbData</code> set to NULL, because I need to calculate size of output buffer first.</p>

<p>This is the source code:</p>

<p><img src=""https://i.imgur.com/bYlGp3M.png"" alt=""screenshot""></p>

<p>Plain text version of the same:
<code></p>

<pre><code>bool CCrypt::RSAEncrypt() {
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY  hKey = NULL;

    if (CryptAcquireContext(&amp;hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
        CParam *pubKey = coreData.local.overlay-&gt;getItem(3);

        // Decode the binary key blob in DER format into a CERT_PUBLIC_KEY_INFO
        CERT_PUBLIC_KEY_INFO* publicKeyInfo = NULL;
        DWORD publicKeyInfoSize;
        if (CryptDecodeObjectEx(
            X509_ASN_ENCODING,
            X509_PUBLIC_KEY_INFO,
            (LPBYTE) pubKey-&gt;getVal(),
            pubKey-&gt;getLength(),
            CRYPT_DECODE_ALLOC_FLAG/* | CRYPT_DECODE_NOCOPY_FLAG*/,
            NULL,   // TODO: Pass a CRYPT_DECODE_PARA to use own heap management to allocate memory
            &amp;publicKeyInfo,
            &amp;publicKeyInfoSize
        )) {
            // Import the public using the context
            if (CryptImportPublicKeyInfo(
                hProv,
                X509_ASN_ENCODING,
                publicKeyInfo,
                &amp;hKey
            )) {
                // Get the size of a key
                DWORD dwBlockLen = NULL;
                DWORD dwValLen = sizeof(DWORD);
                if (CryptGetKeyParam(hKey, KP_BLOCKLEN, (LPBYTE) &amp;dwBlockLen, &amp;dwValLen, 0)) {
                    dwBlockLen = (dwBlockLen + 7) / 8;  // Transform to bytes legth
                    BYTE msg[] = ""Lorem ipsum dolor sit .... [3000+ characters here]"";
                    DWORD dwMsgLen = I(str)-&gt;lengthA((LPSTR) msg);
                    //dwMsgLen = 110;
                    DBG(C_INFO, ""CryptGetKeyParam succeed. dwMsgLen: %d, dwBlockLen: %d"", dwMsgLen, dwBlockLen);
                    // pbData [in, out] set to NULL to calculate actual size of a buffer required
                    if (CryptEncrypt(hKey, 0, TRUE, CRYPT_OAEP, NULL, &amp;dwMsgLen, 0)) {
                        DBG(C_INFO, ""CryptEncrypt succeed. dwMsgLen: %d"", dwMsgLen);
                        // TODO: Fails here

                    } else {
                        DBG(C_ERROR, ""CryptEncrypt error."");
                    }
                } else {
                    DBG(C_ERROR, ""CryptGetKeyParam error."");
                }
                CryptDestroyKey(hKey);
            }
            LocalFree(publicKeyInfo);
        }
        CWA(advapi32, CryptReleaseContext)(hProv, 0);
    }

    return false;
}
</code></pre>

<p></code></p>

<p>Output from my debugger:
<code></p>

<pre><code>[16:08:14] TC=1093889010, PID=25484(0x638C), TID=26340(0x66E4), LE=0(0x0), F=CCrypt::RSAEncrypt, FL=d:\c\source\client\../common/Crypt.cpp (62)
INFO: CryptGetKeyParam succeed. dwMsgLen: 2175, dwBlockLen: 128

[16:08:14] TC=1093889010, PID=25484(0x638C), TID=26340(0x66E4), LE=2148073476(0x80090004), F=CCrypt::RSAEncrypt, FL=d:\c\source\client\../common/Crypt.cpp (69)
ERROR: CryptEncrypt error.
</code></pre>

<p></code></p>

<p>As you can see, this function fails at CryptEncrypt with error NTE_BAD_LEN (0x80090004). However when I manually set <code>dwMsgLen</code> to 110 [see line 61], it works correctly. When I set this variable to 120, it fails.</p>

<p>Can someone tell me where the problem can be?</p>
","","1724","<winapi><rsa><public-key-encryption><cryptoapi><x509>","1","","0","2014-05-14 14:16:22","","4","","","","","2014-05-14 14:16:22",""
"12260833","How do I export a HCRYPTKEY or PRIVATEKEYBLOB to a PFX file","<p>I have a previously generated RSA private signing key, which is stored as a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379931%28v=vs.85%29.aspx"" rel=""nofollow"">PRIVATEKEYBLOB</a>. I am trying to move this into a new certificate for better management of the key. How do I take this blob and turn it into a .pfx certificate?</p>

<p>I have a HCRYPTPROV (uses MS_ENHANCED_PROV and PROV_RSA_FULL).
I can get a HCRYPTKEY from CryptImportKey.</p>

<p>PFXExportCertStoreEx seems to be the function to export it to a PFX blob (which I'm assuming I would then write to a file), but I don't understand how to get the key into it.</p>
","<p>If I correctly understand your problem you have the certificate and the corresponding private key as data blobs and both are <strong>separately</strong>. If you work with CryptoAPI it's important to understand that the API are mostly oriented on the working with certificates stored in <em>certificate stores</em> and private keys stored in <em>key containers</em>. The function like <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387313%28v=vs.85%29.aspx"" rel=""nofollow"">PFXExportCertStoreEx</a> follows the approach and allows you to export all certificates from one certificate store to the data blob which can be just saved as a file with .PFX extension.</p>

<p>So what you can do is the following:</p>

<ol>
<li>Create temporary certificate store by usage <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376559%28v=vs.85%29.aspx"" rel=""nofollow"">CertOpenStore</a> with <code>CERT_STORE_PROV_MEMORY</code> parameter.</li>
<li>Place to certificate blob to the store using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376015%28v=vs.85%29.aspx"" rel=""nofollow"">CertAddEncodedCertificateToStore</a> function.</li>
<li>Create new key container using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886%28v=vs.85%29.aspx"" rel=""nofollow"">CryptAcquireContext</a> with <code>CRYPT_NEWKEYSET</code> option. You should give some unique name to the container (see <code>pszContainer</code> parameter of the function).</li>
<li>Import the information from the <code>PRIVATEKEYBLOB</code>, which you currently have, to the key container with respect of <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380207%28v=vs.85%29.aspx"" rel=""nofollow"">CryptImportKey</a> function.</li>
<li>Bind the certificate from the certificate store to the key container. To do this you should use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376573%28v=vs.85%29.aspx"" rel=""nofollow"">CertSetCertificateContextProperty</a> to set <code>CERT_KEY_PROV_INFO_PROP_ID</code> which is so named <em>extended property</em> of the certificate. It's important to understand that extended properties are not the part of 
X.509 specification. Extended properties allows you to store some <em>additional information associated with the certificate</em> in the certificate store (not in the certificate itself). In case of <code>CERT_KEY_PROV_INFO_PROP_ID</code> you can store full information (<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa381420%28v=vs.85%29.aspx"" rel=""nofollow"">CRYPT_KEY_PROV_INFO</a>) described the key container.</li>
<li>Now one can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387313%28v=vs.85%29.aspx"" rel=""nofollow"">PFXExportCertStoreEx</a> to export the temporary certificate store (which holds only one certificate and has the link to the key container) to the memory blob and then save the memory blob in the .PFX file.</li>
<li>You should delete the key container created at the step 3. To do this you need to open key container using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886%28v=vs.85%29.aspx"" rel=""nofollow"">CryptAcquireContext</a> with the <code>CRYPT_DELETEKEYSET</code> option.</li>
</ol>
","1701","<certificate><cryptoapi>","4","2","1","2012-09-18 10:55:50","","0","1","1708","","2012-09-18 10:55:50","2012-09-04 09:46:37",""
"8272822","Error with CryptDecrypt winapi function?","<p>i have write simple program to load a public key generated by openssl to decrypt a string encrypted by private key of the public key. But I don't know why I fail at</p>

<pre><code>b = CryptDecrypt(hKey,NULL,FALSE,0,pbEncrypt,&amp;cbEncrypt);
</code></pre>

<p>And i get error ""8009000D
NTE_NO_KEY
Key does not exist."". Can someone explain this to me ?</p>

<pre><code>void DecodeString() 
{

    CHAR* publicKey = 
        ""-----BEGIN PUBLIC KEY-----""
        ""MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv+yyzdZaqcE7qOOZ8pyN""
        ""o1n3PS2U/ewT2gGSQeixP+VixQGrxnssT3zlbeUND8CVX+tZGwkcIZZD09Rkx9vh""
        ""z7vLUFD7dngupo/aL6pfehb95citD31DUswc9BTJjQySpSSG6zWDSBJMELDYaCa4""
        ""MIU7odoCg2EbQBwRWX7upWiR+shyxnPYklY8ZUpVCtIdHXmPO5eMaI1elftqNw1N""
        ""n/Id4pFFif11Lmny3s3ADfItuyMfTwU6jwgsPaoqrX5FCnurlAVl/mcfpMVpsPju""
        ""XWw2IlvZP5SkTW4G6V+Bt+xDI6SW3dvMi6gJngHLUKekbhZxcFWuv3hus8ojpo+I""
        ""mwIDAQAB""
        ""-----END PUBLIC KEY-----"";

    BYTE* derPubKey;
    DWORD derPubKeyLen;
    BOOL b = CryptStringToBinaryA(publicKey, 0, CRYPT_STRING_BASE64HEADER, NULL, &amp;derPubKeyLen, NULL, NULL);
    DWORD error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    derPubKey = new BYTE[derPubKeyLen];
    b = CryptStringToBinaryA(publicKey, 0, CRYPT_STRING_BASE64HEADER, derPubKey, &amp;derPubKeyLen, NULL, NULL);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    CERT_PUBLIC_KEY_INFO *publicKeyInfo;
    DWORD publicKeyInfoLen;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    b = CryptDecodeObjectEx(X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, derPubKey, derPubKeyLen, CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;publicKeyInfo, &amp;publicKeyInfoLen);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    b = CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    b = CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING, publicKeyInfo, &amp;hKey);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    //same test decrypt
    CHAR* sameTest = ""nJZ6MN6MIrpbLQiRvfLFIHHzneQBe2rucaKSykXeHgf8Zth5FNPZPdiPhWcHq0/K""
        ""KgRHv2ON+gPyFbjsdDl2cixPgNGXs1FfI/RvkH+Icn+6rYq5uPBM5oQVriyiWI9/""
        ""QiC56LP0ooouqLg9e2U5zJmC/ftCODkFyL748Fx3godXzDl1mNB7bx/Ua6Z93KeB""
        ""OgNvYZH3tcZZYlgoX4GVf4ocO0aZ8pQjEB8p9hMWfIDRCIckDAncy21tHDmWDqZ4""
        ""H7CZjbdNyaiWe5Cr6+CYs25+r3AdIlXOKWuphgbckKDHh4r7nMX0AX+iHXGjCgkM""
        ""iwi4yz7wF+Ow/CcGHkAMTQ=="";

    BYTE* pbEncrypt = 0;
    DWORD cbEncrypt = 0;
    b = CryptStringToBinaryA(sameTest, 0, CRYPT_STRING_BASE64, NULL, &amp;cbEncrypt, NULL, NULL);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    pbEncrypt = new BYTE[cbEncrypt];
    printf(""%s\n"",(CHAR*)pbEncrypt);
    b = CryptStringToBinaryA(sameTest, 0, CRYPT_STRING_BASE64, pbEncrypt, &amp;cbEncrypt, NULL, NULL);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    printf(""%s\n"",(CHAR*)pbEncrypt);
    b = CryptDecrypt(hKey,NULL,FALSE,0,pbEncrypt,&amp;cbEncrypt);
    error = GetLastError();
    _ASSERT(error == 0);
    _ASSERT(b == TRUE);
    printf(""%s\n"",(CHAR*)pbEncrypt);
}
</code></pre>
","<p>You can't use the public key to decrypt something encrypted with the private key. The public key is used only for encryption, while the private key can be used only for decryption.</p>

<p>From <a href=""http://en.wikipedia.org/wiki/Asymmetric_key_algorithm"" rel=""nofollow"">Wikipedia</a>:</p>

<blockquote>
  <p>[...] The distinguishing technique used in public-key cryptography is
  the use of asymmetric key algorithms, where the key used to encrypt a
  message is not the same as the key used to decrypt it. Each user has a
  pair of cryptographic keys - a public encryption key and a private
  decryption key. The publicly available encrypting-key is widely
  distributed, while the private decrypting-key is known only to the
  recipient. Messages are encrypted with the recipient's public key, and
  can be decrypted only with the corresponding private key.[...]</p>
</blockquote>
","1628","<c++><cryptoapi>","0","3","1","2012-10-16 11:40:10","","0","","","","","2011-11-25 18:05:36",""
"6760778","How we can verify openssl digital signature in C++ & windows API","<p>Using openssl I have created signed document on server, 
kindly refer below commands for it. </p>

<p>------Create private key.</p>

<pre><code>openssl pkcs12 -in ""D:\Cummins Issues\XML  Encryption\mycredentialsandkey2010.pfx""  -nodes -nocerts -out ""D:\privatekey.pem"" -nodes
</code></pre>

<p>------Create public key.</p>

<pre><code>openssl rsa -in ""D:\privatekey.pem"" -pubout -out ""D:\rsapublickey.pem""
</code></pre>

<p>------Create signed document.</p>

<pre><code>openssl dgst -sha1 -sign ""D:\privatekey.pem"" -out ""D:\ProductInformation_xml.cipher"" ""D:\ProductInformation.xml""
</code></pre>

<p>Now I can verify the digital signature using opensll like below</p>

<p>---Verify</p>

<pre><code>openssl dgst -sha1 -verify ""D:\rsapublickey.pem"" -signature ""D:\ProductInformation_xml.cipher"" ""D:\ProductInformation.xml""
</code></pre>

<p>But I need to verify digital signature using C++ &amp; Windows API in client application (without openssl library or source code). I know using public  key &amp; hash we can verify the digital signature.  Kindly provide me pseudo code or windows API ASAP.</p>

<p>Any help is appreciated.</p>
","<p>Why can't you use libssl? That's the obvious route to go down. The algorithms themselves are <a href=""http://en.wikipedia.org/wiki/RSA"" rel=""nofollow"">RSA</a> and <a href=""http://en.wikipedia.org/wiki/SHA-1"" rel=""nofollow"">SHA1</a> although you really shouldn't try to roll your own.</p>

<p>Googling for ""microsoft ssl library"" yields nothing but a multitude of vulnerabilities. No, really!</p>
","1623","<c++><visual-c++><digital-signature><cryptoapi>","1","0","2","2011-07-20 17:13:52","","1","","853776","","2011-07-20 12:57:16","2011-07-20 10:55:49",""
"6760778","How we can verify openssl digital signature in C++ & windows API","<p>Using openssl I have created signed document on server, 
kindly refer below commands for it. </p>

<p>------Create private key.</p>

<pre><code>openssl pkcs12 -in ""D:\Cummins Issues\XML  Encryption\mycredentialsandkey2010.pfx""  -nodes -nocerts -out ""D:\privatekey.pem"" -nodes
</code></pre>

<p>------Create public key.</p>

<pre><code>openssl rsa -in ""D:\privatekey.pem"" -pubout -out ""D:\rsapublickey.pem""
</code></pre>

<p>------Create signed document.</p>

<pre><code>openssl dgst -sha1 -sign ""D:\privatekey.pem"" -out ""D:\ProductInformation_xml.cipher"" ""D:\ProductInformation.xml""
</code></pre>

<p>Now I can verify the digital signature using opensll like below</p>

<p>---Verify</p>

<pre><code>openssl dgst -sha1 -verify ""D:\rsapublickey.pem"" -signature ""D:\ProductInformation_xml.cipher"" ""D:\ProductInformation.xml""
</code></pre>

<p>But I need to verify digital signature using C++ &amp; Windows API in client application (without openssl library or source code). I know using public  key &amp; hash we can verify the digital signature.  Kindly provide me pseudo code or windows API ASAP.</p>

<p>Any help is appreciated.</p>
","<p>CryptoAPI from Microsoft will allow you to sign and verify data. </p>

<p>You should note that Microsoft has introduced <a href=""http://msdn.microsoft.com/en-us/library/aa376210%28v=vs.85%29.aspx"" rel=""nofollow"">CNG</a> from Windows vista onwards. So evaluate your requirements.</p>

<p>You can find sample source for signing and verification from <a href=""http://msdn.microsoft.com/en-us/library/aa387761%28v=VS.85%29.aspx"" rel=""nofollow"">MSDN</a> using CryptoAPI</p>
","1623","<c++><visual-c++><digital-signature><cryptoapi>","1","0","2","2011-07-20 17:13:52","","1","","853776","","2011-07-20 12:57:16","2011-07-20 10:55:49",""
"533803","Microsoft CryptoAPI Book","<p>I need to write my own SSL socket (CSocket ansestor) with server side certificate validation using Microsoft CryptoAPI. </p>

<p>Can you tell me which book will help me (or any other user friendly source of information)?</p>
","<p>I recommend <a href=""https://rads.stackoverflow.com/amzn/click/com/0201615983"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">SSL and TLS</a> by <a href=""http://www.rtfm.com/"" rel=""nofollow noreferrer"">Eric Rescorla</a> (author of <a href=""http://ssldump.sourceforge.net/"" rel=""nofollow noreferrer"">ssldump</a>) to get a really good understanding of SSL.  It provides a great introduction to the protocol and the problems it solves, with the option to go as deep as you want into the details.</p>

<p>I would also strongly recommend <em>not</em> writing your own implementation unless you <strong>really</strong> have to.</p>
","1604","<windows><sockets><ssl><cryptoapi><mscapi>","2","1","3","2015-06-09 02:47:24","3466338","0","2","608639","Mr Potato Head","2015-06-09 02:47:24","2009-02-10 19:29:43","2012-05-22 19:49:43"
"533803","Microsoft CryptoAPI Book","<p>I need to write my own SSL socket (CSocket ansestor) with server side certificate validation using Microsoft CryptoAPI. </p>

<p>Can you tell me which book will help me (or any other user friendly source of information)?</p>
","<p>This pointer might also help, although it is not a book.
<a href=""http://msdn.microsoft.com/en-us/library/aa380255.aspx"" rel=""nofollow noreferrer"">CAPI</a></p>
","1604","<windows><sockets><ssl><cryptoapi><mscapi>","2","2","3","2015-06-09 02:47:24","3466338","0","2","608639","Mr Potato Head","2015-06-09 02:47:24","2009-02-10 19:29:43","2012-05-22 19:49:43"
"533803","Microsoft CryptoAPI Book","<p>I need to write my own SSL socket (CSocket ansestor) with server side certificate validation using Microsoft CryptoAPI. </p>

<p>Can you tell me which book will help me (or any other user friendly source of information)?</p>
","<p>Library <a href=""http://www.codeproject.com/KB/IP/sslsocket.aspx"" rel=""nofollow noreferrer"">CSslSocket - SSL/TLS enabled CSocket</a></p>

<p>and how it works <a href=""http://msdn.microsoft.com/en-us/library/aa374782%28VS.85%29.aspx"" rel=""nofollow noreferrer"">Creating a Secure Connection Using Schannel</a></p>
","1604","<windows><sockets><ssl><cryptoapi><mscapi>","2","1","3","2015-06-09 02:47:24","3466338","0","2","608639","Mr Potato Head","2015-06-09 02:47:24","2009-02-10 19:29:43","2012-05-22 19:49:43"
"22230018","Limit intended purposes of newly created self signed certificate","<p>I'm creating a self signed certificate using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376039"" rel=""nofollow"">CertCreateSelfSignCertificate</a>. This works and I can encrypt/sign/decrypt/verify data with it.</p>

<p>I would like to limit the intended purposes of the certificate, but I always end up with a certificate that has ""&lt;All&gt;"" intended purposes enabled. This is the code I'm using to prepare the <code>pExtensions</code> parameter to the <code>CertCreateSelfSignCertificate</code> call:</p>

<pre><code>BYTE key_usage_value = CERT_DATA_ENCIPHERMENT_KEY_USAGE | 
    CERT_DIGITAL_SIGNATURE_KEY_USAGE;
CERT_KEY_USAGE_RESTRICTION_INFO key_usage = {
    0, NULL,
    { sizeof(key_usage_value), &amp;key_usage_value }
};

auto key_usage_data = EncodeObject(szOID_KEY_USAGE_RESTRICTION, &amp;key_usage);

CERT_EXTENSION extension[] = {
    { szOID_KEY_USAGE_RESTRICTION, TRUE, { 
        key_usage_data.size(), key_usage_data.data() 
    } }
};

CERT_EXTENSIONS extensions = {
    elemsof(extension),
    extension
};
</code></pre>

<p><code>EncodeObject</code> simply calls <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379921"" rel=""nofollow"">CryptEncodeObject</a> and returns the result as a <code>std::vector</code>.</p>

<p>I have not found much documentation on this so I'm not actually sure this is what I'm supposed to do. Can anyone point out to me what I'm doing wrong?</p>
","<p>I guess the Extended Key Usage of your certificate is beeing build empty, that means that all purposes are allowed, if you want to limit those, you will need to define them including the specific OIDs of each one, for instance, A certificate capable only for:</p>

<p>Smartcardlogon, Digital Signature and Non-Repudiation </p>

<p>will have <strong>Extended Key Usage</strong> field filled with</p>

<pre><code>1.3.6.1.4.1.311.20.2.2
2.5.29.37.3
2.5.29.37
</code></pre>

<p>Hope it helps</p>
","1601","<windows><certificate><cryptoapi>","1","3","2","2014-03-24 15:29:51","22492124","0","","321731","","2014-03-16 16:16:37","2014-03-06 16:17:25",""
"22230018","Limit intended purposes of newly created self signed certificate","<p>I'm creating a self signed certificate using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376039"" rel=""nofollow"">CertCreateSelfSignCertificate</a>. This works and I can encrypt/sign/decrypt/verify data with it.</p>

<p>I would like to limit the intended purposes of the certificate, but I always end up with a certificate that has ""&lt;All&gt;"" intended purposes enabled. This is the code I'm using to prepare the <code>pExtensions</code> parameter to the <code>CertCreateSelfSignCertificate</code> call:</p>

<pre><code>BYTE key_usage_value = CERT_DATA_ENCIPHERMENT_KEY_USAGE | 
    CERT_DIGITAL_SIGNATURE_KEY_USAGE;
CERT_KEY_USAGE_RESTRICTION_INFO key_usage = {
    0, NULL,
    { sizeof(key_usage_value), &amp;key_usage_value }
};

auto key_usage_data = EncodeObject(szOID_KEY_USAGE_RESTRICTION, &amp;key_usage);

CERT_EXTENSION extension[] = {
    { szOID_KEY_USAGE_RESTRICTION, TRUE, { 
        key_usage_data.size(), key_usage_data.data() 
    } }
};

CERT_EXTENSIONS extensions = {
    elemsof(extension),
    extension
};
</code></pre>

<p><code>EncodeObject</code> simply calls <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379921"" rel=""nofollow"">CryptEncodeObject</a> and returns the result as a <code>std::vector</code>.</p>

<p>I have not found much documentation on this so I'm not actually sure this is what I'm supposed to do. Can anyone point out to me what I'm doing wrong?</p>
","<p>After looking into <code>szOID_ENHANCED_KEY_USAGE</code> according to srbob's answer I managed to change the key usage field. </p>

<p>Here is the (simplified) code I'm using to create the extensions on the certificate, again, this is the code I'm using to prepare the <code>pExtensions</code> parameter to the <code>CertCreateSelfSignCertificate</code> call:</p>

<pre><code>BYTE key_usage_value = CERT_DATA_ENCIPHERMENT_KEY_USAGE |
       CERT_DIGITAL_SIGNATURE_KEY_USAGE;
CERT_KEY_USAGE_RESTRICTION_INFO key_usage = {
    0, NULL,
    { sizeof(key_usage_value), &amp;key_usage_value }
};
auto key_usage_data = EncodeObject(szOID_KEY_USAGE_RESTRICTION, &amp;key_usage);

LPSTR enh_usage_value[] = { szOID_KP_DOCUMENT_SIGNING };
CERT_ENHKEY_USAGE enh_usage = {
    elemsof(enh_usage_value),
    enh_usage_value
};
auto enh_usage_data = EncodeObject(szOID_ENHANCED_KEY_USAGE, &amp;enh_usage);

CERT_EXTENSION extension[] = {
    { szOID_KEY_USAGE_RESTRICTION, TRUE, { 
        key_usage_data.size(), key_usage_data.data() } },
    { szOID_ENHANCED_KEY_USAGE, TRUE, { 
        enh_usage_data.size(), enh_usage_data.data() } },
};

CERT_EXTENSIONS extensions = {
    elemsof(extension),
    extension
};
</code></pre>

<p>Note that the code above still adds the <code>szOID_KEY_USAGE_RESTRICTION</code> extension as well.</p>
","1601","<windows><certificate><cryptoapi>","1","1","2","2014-03-24 15:29:51","22492124","0","","321731","","2014-03-16 16:16:37","2014-03-06 16:17:25",""
"21454545","PKCS #7 encryptedDigest decryption and validation using Windows Crypto API and C++","<h3>Intro</h3>

<p>I am trying to perform the following operation to check certificate's <strong>SignedData.SignerInfo.encryptedDigest</strong>:<br/></p>

<pre><code>1) Read
SignedData.contentInfo +
SignedData.SignerInfo.authenticatedAttributes

2) Calculate Hash of contentInfo and authenticatedAttributes
using SignedData.digestAlgorithm

3) Read SignerInfo.encryptedDigest and certificate's PUBLIC key

4) Decrypt encryptedDigest using the acquired key
(it is the problem, and the question is about this)

5) Compare decryptedDigest's hash
with hash of contentInfo and authenticatedAttributes (STEP 2)
</code></pre>

<h3>The problem</h3>

<p>I tried a different ways to RSA-decrypt <strong>encryptedDigest</strong> with certificate's <strong>public key</strong> using <strong>Windows Crypto API</strong>, but each of them brings to error.<br/>
<br/></p>

<h3>Attempt #1 to solve</h3>

<p>Tried to use <strong>CryptDecrypt</strong><br/>
Result: error <strong>2148073485</strong> (Key does not exist)<br/>
Please see the failing code below (sample #1).<br/>
Brief search tells, that the API doesn't allow to use <strong>public key</strong> for <strong>decryption</strong>.<br/>
If it is wrong, please give me a hint how to do it.</p>

<h3>Attempt #2 to solve</h3>

<p>Tried to use <strong>CryptVerifySignature</strong><br/>
Result: error <strong>87</strong> (The parameter is incorrect)<br/>
Please see the failing code below (sample #2).<br/>
Tried to change the code in a several ways, but still could not find out the reason of invalid parameter error returning<br/>
What's wrong in the sample #2 ?</p>

<h3>Other</h3>

<p>I don't need a high-level functions, which perform a lot of other operations besides the required RSA decryption due to performance requirements.<br/>
It is also not desirable to use OpenSSL or other crypto libraries</p>

<h3>Code Sample #1 (CryptDecrypt)</h3>

<pre><code>// certPublicKey = certContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.pbData[.cbData]
const size_t StructSize = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + certPublicKey.size();
boost::scoped_array&lt;uint8_t&gt; arr(new uint8_t[StructSize]);
BLOBHEADER* pHeader = (BLOBHEADER*)&amp;arr[0];
pHeader-&gt;bType = PUBLICKEYBLOB;
pHeader-&gt;bVersion = CUR_BLOB_VERSION;
pHeader-&gt;reserved = 0;
pHeader-&gt;aiKeyAlg = CALG_RSA_KEYX;

RSAPUBKEY* pPubKey = (RSAPUBKEY*)&amp;arr[sizeof(BLOBHEADER)];
pPubKey-&gt;magic = 0x31415352;
pPubKey-&gt;bitlen = certPublicKey.size() * 8;
pPubKey-&gt;pubexp = 65537; // ?? is it correct for RSA ?

uint8_t* pKeyData = &amp;arr[sizeof(BLOBHEADER) + sizeof(RSAPUBKEY)];
memcpy(pKeyData, &amp;certPublicKey[0], certPublicKey.size());

HCRYPTKEY hKey;
BOOL res = CryptImportKey(g_hProv, (const BYTE*)&amp;arr[0], StructSize, NULL, 0, &amp;hKey);
PRINT_RES(""CryptImportKey"", res);
if (res)
{
    blob_t decryptedData = encryptedText;
    DWORD decryptedLength = encryptedText.size();
    res = CryptDecrypt(hKey, NULL, TRUE, 0, decryptedData.data(), &amp;decryptedLength);
    PRINT_RES(""CryptDecrypt"", res); // err = 2148073485 (Key does not exist)
    if (res)
    {
        ...
    }

    res = CryptDestroyKey(hKey);
    PRINT_RES(""CryptDestroyKey"", res);
}
</code></pre>

<h3>Code Sample #2 (CryptVerifySignature)</h3>

<pre><code>// hashInput = SignedData.contentInfo + SignedData.SignerInfo[0].authenticatedAttributes
HCRYPTHASH hHash;
blob_t hashValue;

BOOL res = CryptCreateHash(g_hProv, CALG_SHA1, NULL, 0, &amp;hHash);
PRINT_RES(""CryptCreateHash"", res);

if (res)
{
    res = CryptHashData(hHash, hashInput.data(), hashInput.size(), 0);
    PRINT_RES(""CryptHashData"", res);

    PCCERT_CONTEXT certContext = CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, certData.data(), certData.size());
    PRINT_RES(""CertCreateCertificateContext"", certContext ? TRUE : FALSE);
    if (certContext)
    {
        HCRYPTKEY hCertPubKey;
        res = CryptImportPublicKeyInfo(g_hProv, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, &amp;certContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;hCertPubKey);
        PRINT_RES(""CryptImportPublicKeyInfo"", res);
        if (res)
        {
            res = CryptVerifySignatureA(hHash, encryptedText.data(), encryptedText.size(), hCertPubKey, NULL, 0);
            PRINT_RES(""CryptVerifySignature"", res); // err = 87 (The parameter is incorrect)

            res = CryptDestroyKey(hCertPubKey);
            PRINT_RES(""CryptDestroyKey"", res);
        }

        CertFreeCertificateContext(certContext);
    }
}
</code></pre>
","<p>The <code>encryptedDigest</code> contains a signature, you don't decrypt it but verify the signature, so your second avenue of <code>CryptVerifySignature</code> is the promising one.</p>

<p>There could be multiple things that can go wrong here, for example you don't really tell us anything about the certificate. Please follow <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382050%28v=vs.85%29.aspx"" rel=""nofollow"">Example C Program: Encoding and Decoding a Countersigned Message</a> on MSDN where you would be interested in <code>CryptVerifyMessageSignature</code> in step #2,</p>

<pre><code>...
// From the recipient's point of view, the following code 
// completes these steps: 
//     1.  Decodes the message
//     2.  Verifies the signature on the message
//     3.  Adds a countersignature to the signed message
//
...
</code></pre>

<p>towards the second part of the example.</p>
","1592","<c++><windows><encryption><cryptoapi>","2","0","1","2014-01-30 11:26:35","","0","","","","","2014-01-30 10:59:49",""
"1529208","Invalid Algorithm Specified CryptoAPI","<p>I am trying to decrypt something using 128BIT AES Decryption. When i attempt to calling CryptDecrypt i get an Error stating ""Invalid Algorithm Specified"". I get the same problem when using the library posted here: <a href=""http://www.codeproject.com/KB/security/WinAES.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/security/WinAES.aspx</a></p>

<p>What can cause this error?</p>

<p>I am using CryptoAPI along on vista64bit with visual studio 2008. I checked in the registry and the AES library is there...</p>

<p>EDIT</p>

<pre><code>BYTE*&amp; encryptedData /*  get data length */
HCRYPTPROV cryptoHandle = NULL;
HCRYPTKEY aesKeyHandle = NULL;

hr = InitWinCrypt(cryptoHandle);
if(FAILED(hr))
{
    return hr;
}

AesKeyOffering aesKey = { {PLAINTEXTKEYBLOB, CUR_BLOB_VERSION, 0, CALG_AES_128}, 16, { 0xFF, 0x00, 0xFF, 0x1C, 0x1D, 0x1E, 0x03, 0x04, 0x05, 0x0F, 0x20, 0x21, 0xAD, 0xAF, 0xA4, 0x04 }};

if(CryptImportKey(cryptoHandle, (CONST BYTE*)&amp;aesKey, sizeof(AesKeyOffering), NULL, 0, &amp;aesKeyHandle) == FALSE)
{
    // DO error

    return HRESULT_FROM_WIN32(GetLastError());
}

if(CryptSetKeyParam(aesKeyHandle, KP_IV, { 0xFF, 0x00, 0xFF, 0x1C, 0x1D, 0x1E, 0x03, 0x04, 0x05, 0x0F, 0x20, 0x21, 0xAD, 0xAF, 0xA4, 0x04 } , 0) == FALSE)
{
    return HRESULT_FROM_WIN32(GetLastError());
}

BYTE blah2 = CRYPT_MODE_CBC;
// set block mode
if(CryptSetKeyParam(aesKeyHandle, KP_MODE, &amp;blah2, 0) == FALSE)
{
    // 

    return HRESULT_FROM_WIN32(GetLastError());
}

DWORD lol = dataLength / 16 + 1;
DWORD lol2 = lol * 16;
if(CryptDecrypt(aesKeyHandle, 0, TRUE, 0, encryptedData, &amp;lol2) == FALSE)
{
    return HRESULT_FROM_WIN32(GetLastError());
}
</code></pre>

<p>InitWinCrypt function</p>

<pre><code>    if(!CryptAcquireContextW(&amp;cryptoHandle, NULL, L""Microsoft Enhanced RSA and AES Cryptographic Provider"", PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
{
    if(!CryptAcquireContextW(&amp;cryptoHandle, NULL, L""Microsoft Enhanced RSA and AES Cryptographic Provider"", PROV_RSA_AES, 0))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        return S_OK;
    }
}
return S_OK;
</code></pre>

<p>AesOffering struct:</p>

<pre><code>struct AesKeyOffering
{
    BLOBHEADER m_Header;
    DWORD m_KeyLength;
    BYTE Key[16];
};
</code></pre>

<p>EDIT2</p>

<p>After rebooting my computer, and remvoing the CBC chunk. I am now getting Bad Data Errors. The data decrypts fine in C#. But i need to do this using wincrypt.</p>
","<p>Are you passing <code>cryptoHandle</code> by reference to <code>InitWithCrypt</code>? If not, your code</p>

<pre><code>if(!CryptAcquireContextW(&amp;cryptoHandle, ...
</code></pre>

<p>would only modify <code>InitWinCrypt</code>'s copy of <code>cryptoHandle</code>.</p>

<hr>

<p><strong>EDIT:</strong> Given that it does, try getting rid of the <code>CryptSetKeyParam</code> call which sets <code>CRYPT_MODE_CBC</code></p>
","1566","<c++><aes><cryptoapi>","1","1","1","2009-12-19 12:26:54","1529290","3","","33837","","2009-12-19 12:26:54","2009-10-07 02:34:30",""
"8057677","Using the Crypto API in the Linux Kernel on a file","<p>I have been trying to use the crypto api in the linux kernel, what i need to do is sha a file that is being opened.  I am using the LSM to catch those file opens.  </p>

<p>What I have so far is creating a struct crypto_shash using</p>

<pre><code>struct crypto_shash *tfm;
struct shash_desc desc;
tfm = crypto_alloc_shash(""sha1"", 0, CRYPTO_ALG_ASYNC);
</code></pre>

<p>and i assume i am supposed to init it after that using </p>

<pre><code>desc.tfm = tfm;
desc.flags = 0;

err = crypto_shash_init(&amp;desc);
</code></pre>

<p>that all works fine, but then i want to use </p>

<pre><code>crypto_shash_digest(&amp;desc, ??, ??, sha_hash);
</code></pre>

<p>and i realize that it expects a scatterlist as its second argument and the length of that scatter list as the third argument.  What i cant figure out is how I am supposed to load the file into a scatterlist in order to give it to the crypto system.</p>

<p>I have done quite a bit of reading but have thus far been unable to find any details about getting a files contents loaded into a scatterlist. So any pointers in the right direction would be appreciated.</p>

<p>Thanks</p>
","<p>I have done something similar some time ago. The only difference is that I calculated a hash of ELF sections.</p>

<ol>
<li>Probably your desc.flags should be CRYPTO_TFM_REQ_MAY_SLEEP until you have really good reason to prevent crypto operation from blocking.</li>
<li>Are you sure you didn't confuse <a href=""http://lxr.free-electrons.com/source/crypto/shash.c#L172"" rel=""nofollow"">crypto_shash_digest</a> with <a href=""http://lxr.free-electrons.com/source/include/linux/crypto.h#L1199"" rel=""nofollow"">crypto_hash_digest</a>? Because crypto_*<em>s</em>*hash_digest() receives a pointer to data as its 3rd argument. If it's not true for you, what linux kenrel version are you talking about?</li>
</ol>
","1562","<linux-kernel><cryptoapi>","1","2","1","2011-11-08 23:24:38","8058449","0","","","","","2011-11-08 22:01:41",""
"19861961","Cryptoapi sign/verify not working on Windows 8.1","<p>We have an application that signs and verifies messages with SHA1 hashes using CryptoApi. It has worked perfectly for many years under WindowsXP up to Windows 8. It no longer works on Windows 8.1. CryptSignHash fails with error code 87 (Invalid Parameter). CryptVerifySignature does not fail but returns NTE_BAD_SIGNATURE (for valid signatures created on Windows 8). We have tested everything we can .. it works on Windows 8 and below, fails on Windows 8.1.</p>

<p>Do you have any ideas on how to debug this further? 
We exported the imported public and private keys again and verified that they are correct.
We skipped using 'our' keys and generated new keys -> signing fails also with error 87
We generated new keys and encrypted/decrypted a message with them using RSA_FULL and DES -> no problem, works as expected. 
We checked the version of the RSA_FULL provider. It is 2.0 on both Windows 8 and Windows 8.1.
We tried explicitly specifying the provider name: Microsoft Base Cryptographic Provider v1.0 </p>

<p>Does signing work for any of you on Windows 8.1.? </p>

<p>Is there anything else that is new on Windows 8.1. that could prevent signing from working? 
Has something changed with respect to the providers or algorithms that we should know? </p>

<p>The application is written in Delphi, uses approximately the following flow: </p>

<pre><code>//Setup crypto provider 
CryptAcquireContext(@fhCryptProv, nil, nil,  cptRSAFull, [ccVerify, ccMachineKeySet]); 

//Create a hash structure
CryptCreateHash( fProvider.GetProviderHandle, chtSHA1, 0, 0, @fhHash);

//Import the private key for signing
CryptImportKey( fProvider.GetProviderHandle, @buff[0], len, 0, CRYPT_EXPORTABLE, @fKey);

//Hash the message
CryptHashData(fhHash, @aPlainText[1], length(aPlainText) * 2, 0);

//Sign the message
CryptSignHash(fhHash, AT_SIGNATURE, nil, CRYPT_NOHASHOID OR CRYPT_X931_FORMAT, @buff, @len);
</code></pre>
","<p>CryptSignHash fails on Windows 8.1 when CRYPT_X931_FORMAT flag is set. This looks like a Windows 8.1. bug. </p>

<p>This bug can be reproduced by running the MSDN Sample Code from the url below, using CALG_SHA1 instead of CALG_MD5 for hashing and setting the flags in CryptSignHash to  CRYPT_NOHASHOID | CRYPT_X931_FORMAT; leaving the flags at 0 or just at CRYPT_NOHASHOID works on the systems I tested with. </p>

<p>I never had any problems with these flags on WindowsXP to Windows 8.0 systems. </p>

<p>MSDN Sample code URL: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382371%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa382371%28v=vs.85%29.aspx</a></p>
","1551","<windows><windows-8.1><cryptoapi><mscapi>","4","1","1","2015-06-09 03:01:20","","0","1","608639","","2015-06-09 03:01:20","2013-11-08 14:54:24",""
"8758505","two different hash values for same string","<p>I need to compare hash values of two strings. 
I use string ""template"" for testing.
But I got different hash values for this string so it is always not the same.
I use CryptoApi and MD4</p>

<pre><code>int _tmain(int argc, _TCHAR* argv[])
{
    std::hash_map&lt;int,int&gt; table;
    HCRYPTPROV hProv1,hProv2;
    BYTE *pbBuffer1=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen1=strlen((char*)pbBuffer1)+1;
    HCRYPTHASH hHash1,hHash2;
    //first hash
    CryptAcquireContext(&amp;hProv1,NULL,NULL,PROV_RSA_AES,0);
    CryptCreateHash(hProv1,CALG_MD4,0,0,&amp;hHash1);
    CryptHashData(hHash1,pbBuffer1,dwBufferLen1,0);
    /*---------*/
    BYTE *pbBuffer2=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen2=strlen((char*)pbBuffer2)+1;
    //second hash
    CryptAcquireContext(&amp;hProv2,NULL,NULL,PROV_RSA_AES,0);  
    CryptCreateHash(hProv2,CALG_MD4,0,0,&amp;hHash2);
    CryptHashData(hHash2,pbBuffer2,dwBufferLen2,0);
    if (hHash1==hHash2)
        printf(""The Same\n"");
    else printf(""Not same\n"");
    /*---------*/
    std::cout&lt;&lt;hHash1&lt;&lt;std::endl;
    std::cout&lt;&lt;hHash2&lt;&lt;std::endl;
    if (hProv1)
        CryptReleaseContext(hProv1,0);
    if (hProv2)
        CryptReleaseContext(hProv2,0);
    system(""pause"");
    return 0;
} 
</code></pre>

<p>For example hash value in hHash1</p>

<pre><code>691136
</code></pre>

<p>Hash value in hHash2</p>

<pre><code>691216
</code></pre>
","<p><code>HCRPTHASH</code> is a <code>ULONG_PTR</code> typedef, as per <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382465%28v=vs.85%29.aspx"" rel=""nofollow"">here</a>. That means it's a pointer:</p>

<blockquote>
  <p>The <code>HCRYPTHASH</code> data type is used to represent <em>handles</em> to hash objects. These handles indicate to the CSP module which hash is being used in a particular operation. The CSP module does not enable direct manipulation of the hash values. Instead, the user manipulates the hash values through the hash handle.</p>
  
  <p><code>typedef ULONG_PTR HCRYPTHASH;</code></p>
</blockquote>

<p>Comparing pointers with <code>==</code> is about as productive as nailing jelly (or jello to US citizens) to a tree, or trying to train a cat :-)</p>

<p>The values you're seeing as your ""hashes"" are actually the pointers, 80 bytes apart (since they are pointers to two different memory blocks).</p>

<p>In order to get the <em>actual hash</em> from the handle, you need something like the following, which prints the hex digits:</p>

<pre><code>CHAR hexDigits[] = ""0123456789abcdef"";
BYTE md4Hash[MD4LEN];
DWORD cbHash = MD4LEN;
if (CryptGetHashParam (hHash1, HP_HASHVAL, md4Hash, &amp;cbHash, 0)) {
    printf(""MD4 hash is: "");
    for (DWORD i = 0; i &lt; cbHash; i++) {
        printf (""%c%c"", hexDigits[md4Hash[i] &gt;&gt; 4], hexDigits[md4Hash[i] &amp; 0xf]);
    }
    printf(""\n"");
} else {
    DWORD dwStatus = GetLastError();
    printf (""CryptGetHashParam failed with code %d\n"", dwStatus); 
}
</code></pre>

<p>For comparing the two hash values, you can do:</p>

<pre><code>BYTE md4Hash1[MD4LEN], md4Hash2[MD4LEN];
DWORD cbHash1 = MD4LEN, cbHash2 = MD4LEN;

CryptGetHashParam (hHash1, HP_HASHVAL, md4Hash1, &amp;cbHash1, 0);
CryptGetHashParam (hHash2, HP_HASHVAL, md4Hash2, &amp;cbHash2, 0);

if ((cbHash1 == cbHash2) &amp;&amp;
    (memcmp (md4Hash1, md4Hash2, cbHash1) == 0))
{
    // they are equal.
}
</code></pre>
","1535","<c++><cryptoapi>","1","4","3","2013-08-26 10:28:10","8758694","2","","25324","","2012-01-06 13:28:40","2012-01-06 13:26:56",""
"8758505","two different hash values for same string","<p>I need to compare hash values of two strings. 
I use string ""template"" for testing.
But I got different hash values for this string so it is always not the same.
I use CryptoApi and MD4</p>

<pre><code>int _tmain(int argc, _TCHAR* argv[])
{
    std::hash_map&lt;int,int&gt; table;
    HCRYPTPROV hProv1,hProv2;
    BYTE *pbBuffer1=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen1=strlen((char*)pbBuffer1)+1;
    HCRYPTHASH hHash1,hHash2;
    //first hash
    CryptAcquireContext(&amp;hProv1,NULL,NULL,PROV_RSA_AES,0);
    CryptCreateHash(hProv1,CALG_MD4,0,0,&amp;hHash1);
    CryptHashData(hHash1,pbBuffer1,dwBufferLen1,0);
    /*---------*/
    BYTE *pbBuffer2=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen2=strlen((char*)pbBuffer2)+1;
    //second hash
    CryptAcquireContext(&amp;hProv2,NULL,NULL,PROV_RSA_AES,0);  
    CryptCreateHash(hProv2,CALG_MD4,0,0,&amp;hHash2);
    CryptHashData(hHash2,pbBuffer2,dwBufferLen2,0);
    if (hHash1==hHash2)
        printf(""The Same\n"");
    else printf(""Not same\n"");
    /*---------*/
    std::cout&lt;&lt;hHash1&lt;&lt;std::endl;
    std::cout&lt;&lt;hHash2&lt;&lt;std::endl;
    if (hProv1)
        CryptReleaseContext(hProv1,0);
    if (hProv2)
        CryptReleaseContext(hProv2,0);
    system(""pause"");
    return 0;
} 
</code></pre>

<p>For example hash value in hHash1</p>

<pre><code>691136
</code></pre>

<p>Hash value in hHash2</p>

<pre><code>691216
</code></pre>
","<p>hHash1 and hHash2 are not the hash codes, but handles.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379908(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa379908(v=vs.85).aspx</a></p>
","1535","<c++><cryptoapi>","1","2","3","2013-08-26 10:28:10","8758694","2","","25324","","2012-01-06 13:28:40","2012-01-06 13:26:56",""
"8758505","two different hash values for same string","<p>I need to compare hash values of two strings. 
I use string ""template"" for testing.
But I got different hash values for this string so it is always not the same.
I use CryptoApi and MD4</p>

<pre><code>int _tmain(int argc, _TCHAR* argv[])
{
    std::hash_map&lt;int,int&gt; table;
    HCRYPTPROV hProv1,hProv2;
    BYTE *pbBuffer1=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen1=strlen((char*)pbBuffer1)+1;
    HCRYPTHASH hHash1,hHash2;
    //first hash
    CryptAcquireContext(&amp;hProv1,NULL,NULL,PROV_RSA_AES,0);
    CryptCreateHash(hProv1,CALG_MD4,0,0,&amp;hHash1);
    CryptHashData(hHash1,pbBuffer1,dwBufferLen1,0);
    /*---------*/
    BYTE *pbBuffer2=(BYTE*)""template"";//data to hash
    DWORD dwBufferLen2=strlen((char*)pbBuffer2)+1;
    //second hash
    CryptAcquireContext(&amp;hProv2,NULL,NULL,PROV_RSA_AES,0);  
    CryptCreateHash(hProv2,CALG_MD4,0,0,&amp;hHash2);
    CryptHashData(hHash2,pbBuffer2,dwBufferLen2,0);
    if (hHash1==hHash2)
        printf(""The Same\n"");
    else printf(""Not same\n"");
    /*---------*/
    std::cout&lt;&lt;hHash1&lt;&lt;std::endl;
    std::cout&lt;&lt;hHash2&lt;&lt;std::endl;
    if (hProv1)
        CryptReleaseContext(hProv1,0);
    if (hProv2)
        CryptReleaseContext(hProv2,0);
    system(""pause"");
    return 0;
} 
</code></pre>

<p>For example hash value in hHash1</p>

<pre><code>691136
</code></pre>

<p>Hash value in hHash2</p>

<pre><code>691216
</code></pre>
","<p>As the other answers have noted, <code>hHash1</code> and <code>hHash2</code> are opaque handles &mdash; comparing them is pointless, as that's akin to comparing the addresses of two different objects that have the same value.</p>

<p>Use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379947%28v=vs.85%29.aspx"" rel=""nofollow""><code>CryptGetHashParam</code></a> to get the hash values and compare those instead:</p>

<blockquote>
  <p>The <code>CryptGetHashParam</code> function retrieves data that governs the operations of a hash object. <strong>The actual hash value can be retrieved by using this function.</strong></p>
</blockquote>
","1535","<c++><cryptoapi>","1","1","3","2013-08-26 10:28:10","8758694","2","","25324","","2012-01-06 13:28:40","2012-01-06 13:26:56",""
"9478164","How to get certificate from pkcs7 file","<p>I have a pkcs#7 file with included signers certificate, CA certificate, CRL. Now, to verify signature from this file I get the certificate from it. I try to do:</p>

<pre><code>HANDLE hFile; 
if(!(hFile = CreateFile(L""c:\\users\\timur\\desktop\\sign_pkcs7.sig"",
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL)))
{
    printf(""Error opening file %d\n"", GetLastError());
}

HCERTSTORE hPkcsStore = 0;
if(!(hPkcsStore = CertOpenStore(
                    CERT_STORE_PROV_PKCS7,
                    MY_TYPE,
                    NULL,
                    CERT_STORE_OPEN_EXISTING_FLAG,
                    hFile)))
{
    printf(""Cert not found in pkcs7 store error %d.\n"",GetLastError());
}
</code></pre>

<p>But while calling CertOpenStore program fails with <strong>Access violation reading location 0x0000001c.</strong></p>
","<p>You can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380264%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">CryptQueryObject</a> to open the P7B file or files in many other formats (the code will be the same as <a href=""https://stackoverflow.com/a/7282440/315935"">here</a>).</p>
","1532","<c++><cryptoapi><pkcs#7>","0","1","1","2012-03-03 11:31:22","","0","","","","","2012-02-28 07:46:51",""
"18628127","CryptImportKey return ""Bad Version of provider."" error","<p>i crate a certificate and private key file by makecert.exe
with below command</p>

<p>makecert.exe -n ""CN=test"" -pe -ss my -sr LocalMachine -sky exchange -m 96 -a sha1 -len 2048 -r test.cer -sv test.pvk</p>

<p>and i have a test.pvk file</p>

<p>now i want use private key in my program </p>

<p>CryptImportKey function return ""Bad Version of provider."" error  </p>

<pre><code>#include ""stdafx.h""
#include ""windows.h""
#include ""tchar.h""

#include &lt;wincrypt.h&gt;
#include &lt;cryptuiapi.h&gt;

#pragma comment (lib, ""crypt32.lib"")
#pragma comment (lib, ""cryptui.lib"")

int _tmain(int argc, _TCHAR* argv[])
{   
    HANDLE hPrivateKeyFile; 

    HCRYPTPROV hCryptProv;
    HCRYPTKEY hKey;

    BYTE* pbPublicKey ;
    BYTE* pbPrivateKey;

    DWORD dwPublicKeyLen ;
    DWORD dwPrivateKeyLen;

    WCHAR* strFileName=L""test.pvk"";

    // Open private key file    
    if ((hPrivateKeyFile = CreateFile(strFileName,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL)) == INVALID_HANDLE_VALUE)
    {         
          printf((""CreateFile error 0x%x\n"")); exit(0);       
    }

    // Get file size    
    if ((dwPrivateKeyLen = GetFileSize(hPrivateKeyFile, NULL)) == INVALID_FILE_SIZE)
    {   
          printf((""GetFileSize error 0x%x\n"")); exit(0);               
    }

    // Create a buffer for the private key  
    if (!(pbPrivateKey = (BYTE *)malloc(dwPrivateKeyLen)))
    {         
          printf((""malloc error 0x%x\n""));  exit(0);          
    }

    // Read private key 
    if (!ReadFile(hPrivateKeyFile, pbPrivateKey, dwPrivateKeyLen, &amp;dwPrivateKeyLen, NULL))
    {         
          printf((""ReadFile error 0x%x\n"")); exit(0);          
    }

    if (!CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) 
    {          
          printf((""CryptAcquireContext error 0x%x\n"")); exit(0);      
    }

    // Import private key   
    if (!CryptImportKey(hCryptProv, pbPrivateKey, dwPrivateKeyLen, 0, CRYPT_EXPORTABLE, &amp;hKey))
    {         
          printf((""CryptImportKey error 0x%x\n""));  
          DWORD lastError=GetLastError();//Bad Version of provider.
          exit(0);              
    }


    return 0;
}
</code></pre>
","<ul>
<li><p>In CryptAcquireContext, change the last parameter to CRYPT_NEWKEYSET|CRYPT_VERIFYCONTEXT</p></li>
<li><p>Check the return value of hCryptProv.  It should be non-szero.  CryptAcquireContext can return TRUE and at the same time set hCryptProv to zero.</p></li>
</ul>
","1514","<c++><rsa><cryptoapi>","0","0","1","2013-09-05 05:20:05","","2","","","","","2013-09-05 05:03:46",""
"25536217","Certificate not being signed properly","<p>I am creating some self-signed certificates through C# using p/invoked CryptoAPI calls for use in an application.  I am assigning the correct information to a CERT_INFO structure, getting the public key by using CryptExportPublicKey.  When I encrypt the certificate with CryptSignAndEncryptCertificate, the resulting value looks to be correct, but when testing with openssl -verify, I receive the following errors:</p>

<pre><code>6704:error:0407006A:rsa routines:RSA_padding_check_PKCS1_type_1:block type is not 01:.\crypto\rsa\rsa_pk1.c:100:
6704:error:04067072:rsa routines:RSA_EAY_PUBLIC_DECRYPT:padding check failed:.\crypto\rsa\rsa_eay.c:721:
6704:error:0D0C5006:asn1 encoding routines:ASN1_item_verify:EVP lib:.\crypto\asn1\a_verify.c:221:
</code></pre>

<p>When checking the certificate in the CSR decoder at <a href=""http://certlogik.com/decoder/"" rel=""nofollow"">http://certlogik.com/decoder/</a>, the modulus field of the public key information has a leading 00 byte that is not there when examining the public key with KeyPal.  Can anyone tell me what I need to do to fix this error?</p>
","<p>For anyone who's interested:</p>

<p>The CERT_INFO structure that is passed into CryptSignAndEncodeCertificate contains a SubjectPublicKeyInfo field that is a CERT_PUBLIC_KEY_INFO structure.  I was originally attempting to take the pointer received from CryptExportPublicKeyInfo and assign it to SubjectPublicKeyInfo via Marshal.PtrToStructure.  As it turns out, Marshal.PtrToSTructure just causes SubjectPublicKeyInfo to point to the same memory location as the returned pointer.  When the pointer is freed, the memory is invalidated and SubjectPublicKeyInfo is left in an undetermined state.  The way to get around it is to create a new structure and then assign this new structure to SubjectPublicKeyInfo.  This causes the values from the new structure to be copied to SubjectPublicKeyInfo so its memory location is never invalidated.  Or at least that's the nearest I can figure.  If anyone has a better explanation, I'd love to hear it.</p>
","1500","<c#><ssl><certificate><pinvoke><cryptoapi>","1","0","1","2014-08-28 16:04:04","","4","1","608639","","2014-08-28 15:39:48","2014-08-27 20:17:31",""
"12714948","How to encrypt data using a certificate?","<p>How do i encrypt data using a <em>""certificate""</em> in the Microsoft Crypto API?</p>

<hr>

<p>i know how to encrypt data with the Microsoft Crypto API using AES encryption:</p>

<pre><code>keyBlob.hdr.bType := PLAINTEXTKEYBLOB;
keyBlob.hdr.bVersion := CUR_BLOB_VERSION;
keyBlob.hdr.reserved := 0;
keyBlob.hdr.aiKeyAlg := CALG_AES_128;
keyBlob.cbKeySize := 16;
Move(data[0], keyBlob.key[0], 16);


/*
   Set ProviderName to either
   providerName = ""Microsoft Enhanced RSA and AES Cryptographic Provider""
   providerName = ""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""  //Windows XP and earlier
*/
MS_ENH_RSA_AES_PROV_W: WideString = 'Microsoft Enhanced RSA and AES Cryptographic Provider';
providerName := MS_ENH_RSA_AES_PROV_W;

CryptAcquireContextW(provider, nil, PWideChar(providerName), PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
CryptImportKey(provider, PByte(@keyBlob), sizeof(keyBlob), 0, 0, importedKey);

mode := CRYPT_MODE_CBC;
CryptSetKeyParam(importedKey, KP_MODE, @mode, 0);

//CryptEncrypt encrypts in-place. Copy stuff to be encrypted into new byte buffer
utf8PlainText := TCrypt.WideStringToUTF8(szPlainText);
dataLen := Length(utf8PlainText);
bufferLen := dataLen+16; //allocate a buffer larger than we need to hold the data we want to encrypt
SetLength(data, bufferLen);
Move(utf8PlainText[1], data[0], dataLen);

if not CryptEncrypt(importedKey, 0, True, 0, @data[0], {var}dataLen, bufferLen) then
begin
   le := GetLastError;
   if le = ERROR_MORE_DATA  then
   begin
      /*
         If the buffer allocated for pbData is not large enough to hold the encrypted data,
         GetLastError returns ERROR_MORE_DATA and stores the required buffer size,
         in bytes, in the DWORD value pointed to by pdwDataLen.
      */
      bufferLen := dataLen;
      SetLength(data, bufferLen);
      CryptEncrypt(importedKey, 0, True, 0, @data[0], {var}dataLen, bufferLen);
   end;
   CryptDestroyKey(importedKey);
   CryptReleaseContext(provider, 0);
end;
</code></pre>

<p>Now i need to do the same thing, except rather than symmetric encryption i need to use a public-key to encrypt, and a private key to decrypt.</p>

<hr>

<p><strong>Note</strong>: It took 3 days to come up with those 15 lines of code for symmetric encryption. i'm hoping someone can same me from a week of banging my head against a wall, and i end up going down the wrong path thinking that i have to install <strong>OpenSSL</strong>. Even worse, if i try to call <a href=""https://stackoverflow.com/questions/11972829/how-to-call-use-net-rijndaelmanaged-from-native-com""><strong>COM Objects</strong></a> <a href=""https://stackoverflow.com/questions/11977806/how-to-pass-safearray-to-com-object-through-idispatch#comment15974534_11977806"">from native code</a></p>

<p><strong>Note</strong>: i only included the code example as a way to fill-up the question with irrelavent junk. Some people vote to close a question if it only contains one line.</p>
","<p>Microsoft Crypto API contain high-level functions for asymmetric encryption and decryption with certificates. Look at <code>CryptEncryptessage</code> and <code>CryptDecryptMessage</code>.</p>

<p>In decryption case your CERT_CONTEXT must have a <code>CERT_KEY_PROV_INFO_PROP_ID</code> property.</p>

<p>I can give you an examples of usage:</p>

<pre><code>const wchar_t message[] = L""This is a simple test message."";
PCCERT_CONTEXT hCert = NULL;
HCERTSTORE hStore = NULL;

static bool openCertStoreMY(CDialog *parent)
{
    if(!hStore)
    {
        hStore = CertOpenSystemStore(NULL, L""MY"");

        if(!hStore)
        {
            parent-&gt;MessageBox(L""Cannot open \""MY\"""", L""Error"", MB_ICONERROR);
            return false;
        }
    }

    return true;
}

void CTestDlg::OnEncryptClicked()
{
    if(!hCert)
    {
        if(!openCertStoreMY(this))
            return;

        hCert = CryptUIDlgSelectCertificateFromStore(hStore, GetSafeHwnd(), NULL, NULL, 0, 0, 0);

        if(!hCert)
            return;
    }

    CRYPT_ENCRYPT_MESSAGE_PARA params;
    memset(&amp;params, 0, sizeof(CRYPT_ENCRYPT_MESSAGE_PARA));
    params.cbSize = sizeof(CRYPT_ENCRYPT_MESSAGE_PARA);
    params.dwMsgEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    params.ContentEncryptionAlgorithm.pszObjId = ""2.16.840.1.101.3.4.1.2""; //AES128

    DWORD msz;
    DWORD cbMsg = sizeof(message);
    const BYTE *pbMsg = (PBYTE)message;
    if(!CryptEncryptMessage(&amp;params, 1, &amp;hCert, pbMsg, cbMsg, NULL, &amp;msz))
        return;

    PBYTE outBuf = new BYTE[msz];
    if(CryptEncryptMessage(&amp;params, 1, &amp;hCert, pbMsg, cbMsg, outBuf, &amp;msz))
    {
        FILE *fil = _wfopen(filename, L""wb"");
        if(fil)
        {
            fwrite(outBuf, 1, msz, fil);
            fclose(fil);
            MessageBox(L""Complete"");
        }
        else
            MessageBox(L""Cannot open file"", L""Error"", MB_ICONERROR);
    }

    delete [] outBuf;
}

void CTestDlg::OnDecryptClicked()
{
    if(!openCertStoreMY(this))
        return;

    CRYPT_DECRYPT_MESSAGE_PARA params;
    params.cbSize = sizeof(CRYPT_DECRYPT_MESSAGE_PARA);
    params.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    params.cCertStore = 1;
    params.rghCertStore = &amp;hStore;
    params.dwFlags = 0;

    DWORD cbMsg;
    PBYTE pbMsg;

    FILE *fil = _wfopen(filename, L""rb"");
    if(fil)
    {
        fseek(fil, 0 ,2);
        cbMsg = ftell(fil);
        fseek(fil, 0, 0);
        pbMsg = new BYTE[cbMsg];

        fread(pbMsg, 1, cbMsg, fil);
        fclose(fil);
    } else {
        MessageBox(L""Cannot open file"", L""Error"", MB_ICONERROR);
        return;
    }

    DWORD msz;
    if(!CryptDecryptMessage(&amp;params, pbMsg, cbMsg, NULL, &amp;msz, NULL))
    {
        delete [] pbMsg;
        return;
    }

    PBYTE outBuf = new BYTE[msz];
    if(CryptDecryptMessage(&amp;params, pbMsg, cbMsg, outBuf, &amp;msz, NULL))
        MessageBox((LPCWSTR)outBuf);

    delete [] pbMsg;
    delete [] outBuf;
}
</code></pre>
","1484","<public-key-encryption><certificate><cryptoapi>","1","4","1","2012-10-05 15:28:26","","0","1","-1","","2017-05-23 11:44:56","2012-10-03 18:53:16",""
"7775806","How to obtain Provider name of a CSP from PCCERT_CONTEXT?","<p>I have been try to get a provider name from PCCERT_CONTEXT because in my current project i must have load all certificate from smart card into my program. And in the future I have to deal with those certificate with some task like renewal certificate, delete certificate. But I have  problem, I must to map CSP name and provider name with CryptAcquireContext to executive. And I currently confused how to archive this, can anyone have some guide to help me resolve this problem.
I have try CertGetCertificateContextProperty with dwPropId is CERT_KEY_PROV_INFO_PROP_ID but i can not get CRYPT_KEY_PROV_INFO.</p>
","<p>If I have understood you correctly, the following snippet shows how to extract the key provider information from a certificate.  </p>

<pre><code>void trace(char* message, DWORD errorCode)
{
    cout &lt;&lt; message &lt;&lt; errorCode;
}

std::wstring Test_CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext)
{
    DWORD dwSize = 0;    
    BOOL bIsSuccess = CertGetCertificateContextProperty(pCertContext, 
                                                        CERT_KEY_PROV_INFO_PROP_ID,
                                                        NULL,
                                                        &amp;dwSize);
    if (!bIsSuccess)
    {
        trace(""CertGetCertificateContextProperty failed with error: "", GetLastError());
        return L"""";
    }

    PCRYPT_KEY_PROV_INFO pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)LocalAlloc(LMEM_ZEROINIT, dwSize);
    if (pKeyProvInfo == NULL)
    {
        trace(""LocalAlloc failed with error:"", GetLastError());
        return L"""";
    }

    bIsSuccess = CertGetCertificateContextProperty(pCertContext, 
                                                   CERT_KEY_PROV_INFO_PROP_ID,
                                                   pKeyProvInfo,
                                                   &amp;dwSize);

    std::wstring provName;
    if (bIsSuccess)
    {
        provName = pKeyProvInfo-&gt;pwszProvName;
    }

    LocalFree(pKeyProvInfo);

    return provName;
}
</code></pre>
","1480","<c++><cryptoapi>","1","2","1","2016-11-15 17:33:17","","0","1","","","","2011-10-15 04:47:37",""
"13434493","CryptExportKey: how to export private key from PKCS#12 store?","<p>I need to export public and private RSA key from certificate, stored in <code>PKCS#12</code> format, on Windows.</p>

<p>I can open certificate store with <code>CertOpenStore()</code>, then find certificate with <code>CertFindCertificateInStore()</code> and acquire private key with <code>CryptAcquireCertificatePrivateKey()</code>. </p>

<p>It works Ok. Then I extract user key with <code>CryptGetUserKey()</code> It works too.</p>

<p>But <code>CryptExportKey()</code> with blob type <code>PRIVATEKEYBLOB</code> fails.
<code>CryptSetKeyParam()</code> with <code>KP_PERMISSIONS</code> and set permission <code>CRYPT_EXPORT</code> also fails.</p>

<p>How could I get all RSA key pair parameters in such case?</p>

<p>All examples use <code>CryptGenKey()</code> to create and THEN export key, but I need to export existing key pair to simple binary form.</p>
","<p>Found solution: if use more specific <code>PFXImportCertStore()</code> to open PKCS#12 file instead of generic <code>CertOpenStore()</code> with <code>CERT_STORE_PROV_PKCS12</code> store provider, it accepts flag <code>CRYPT_EXPORTABLE</code> and key could be exported with <code>CryptExportKey()</code>.</p>
","1467","<winapi><cryptoapi>","2","0","1","2017-06-21 07:22:08","13438840","0","1","1832501","","2012-11-17 20:35:28","2012-11-17 20:26:56",""
"34917512","“System.Security.Cryptography.CryptographicException: Keyset does not exist” when reading private key from remote machine","<p>I am trying to decrypt some data using a certificate private key. It all works fine when the certificate is installed on the local machine (I am using a self signed certificate for testing and I have the private key for the certificate) but When I try to access the private key from a remote machine using the same code, I get the ""Keyset does not exist"" exception.</p>

<p>I am using a console application for testing, and I have made sure that my id have read permissions on the private key on the remote server. Here is the sample code I am using:</p>

<pre><code>var store = new X509Store(@""\\server1\My"", StoreLocation.LocalMachine);
store.Open(OpenFlags.ReadOnly);
var result = store.Certificates.Find(X509FindType.FindBySubjectName, ""server1.test.com"", false);
var certificate = result[0];
store.Close();

//This succeeds from both local and remote server
var rsaPublic = (RSACryptoServiceProvider)certificate.PublicKey.Key;

//This succeeds from local, but fails from remote server
var rsaPrivate = (RSACryptoServiceProvider)certificate.PrivateKey;
</code></pre>

<p>Here is the exception call stack</p>

<pre><code>Unhandled Exception: System.Security.Cryptography.CryptographicException: Keyset does not exist

   at System.Security.Cryptography.Utils.CreateProvHandle(CspParameters parameters, Boolean randomKeyContainer)
   at System.Security.Cryptography.Utils.GetKeyPairHelper(CspAlgorithmType keyType, CspParameters parameters, Boolean randomKeyContainer, Int32 dwKeySize, SafeProvHandle&amp; safeProvHandle, SafeKeyHandle&amp; safeKeyHandle)
   at System.Security.Cryptography.RSACryptoServiceProvider.GetKeyPair()
   at System.Security.Cryptography.RSACryptoServiceProvider..ctor(Int32 dwKeySize, CspParameters parameters, Boolean useDefaultKeySize)
   at System.Security.Cryptography.X509Certificates.X509Certificate2.get_PrivateKey()
   at RsaPoc.Program.Main(String[] args)
</code></pre>

<p>I have found a <a href=""https://stackoverflow.com/questions/21989024/system-security-cryptography-cryptographicexception-keyset-does-not-exist-whe"">similar</a> unanswered question on SO, but it is using un-managed code, whereas I am using the managed API, but both seems to be having the same root cause.</p>
","<p>We contacted Microsoft support for a solution and here is the response that we got:</p>

<ol>
<li><p>Why is the private key not available when the code is executed on server2?<br>
A: This is actually by design.  Certificate stores are different from private key storage.  While you can enumerate certificates remotely, private keys cannot be accessed remotely.  </p></li>
<li><p>Can this issue be fixed by giving the user extra privileges or by changes in group policy settings? 
A: No.  This doesn’t involve privileges or permission to the file.  </p></li>
<li><p>If not both of the above then can you suggest the suitable solution?<br>
A: 1. You can install the certificate on all machines so each one has a copy of the private key.<br>
            2. You can create a roaming domain user.  A roaming certificate is the only situation where private keys can be roamed between machines.
                 Roaming profiles are located on a server, when the user logs on, a temporary copy of the profile (including private key) is created.<br>
             3. Use a third party cryptographic provider.  There are some cryptographic providers that do allow remote private key access and cryptographic operations.</p></li>
</ol>
","1446","<c#><ssl-certificate><x509certificate><private-key><cryptoapi>","0","0","1","2016-02-01 07:11:27","35124801","0","","-1","","2017-05-23 11:59:15","2016-01-21 07:14:10",""
"16015408","Digital signature made in C# does not verify in C++","<p>I have a C# application which digitally signs data using RSA. The code is as follows:</p>

<pre><code>RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
rsa.ImportCspBlob(privateKeyBlob);

SHA1 sha1 = new SHA1CryptoServiceProvider();
sha1.ComputeHash(myData);

byte[] signature = rsa.SignHash(sha1.Hash, CryptoConfig.MapNameToOID(""SHA1""));
</code></pre>

<p>I cannot verify the signature in C++. The code is as follows:</p>

<pre><code>HCRYPTPROV cryptProvider;
CryptAcquireContext(&amp;cryptProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
// PROV_RSA_SIG does not work

HCRYPTKEY publicKey;
CryptImportKey(cryptProvider, publicKeyBlob, publicKeyBlobLength, 0, 0, &amp;publicKey);

HCRYPTHASH hash;
CryptCreateHash(cryptProvider, CALG_SHA1, 0, 0, &amp;hash);
CryptHashData(hash, myData, myDataLength, 0);

BOOL isSigOk = CryptVerifySignature(hash, signature, signatureLength, publicKey, NULL, CRYPT_NOHASHOID);
</code></pre>

<p>The verification returns 0, <code>GetLastError()</code> returns 2148073478 ""Invalid signature"". The hashes are the same. I tried it with and without the <code>CRYPT_NOHASHOID</code> flag.</p>

<p>I tried signing the data in C++ (just to compare the results). I removed the <code>CRYPT_VERIFYCONTEXT</code> flag. But importing the private key BLOB fails with 1008 ""An attempt was made to reference a token that does not exist"". Generating a new key fails with the same error.</p>
","<p>After an exhausting byte by byte inspection, I got it working. There were two problems in the C# application.</p>

<p>1) I used <code>new RSACryptoServiceProvider(RsaKeySize)</code> to generate a key pair. The problem is that this generates a key pair for key exchange, not for signing. C# doesn't mind, but it caused trouble in the C++ program. The correct way for generating a key pair is:</p>

<pre><code>CspParameters parameters = new CspParameters();
parameters.KeyNumber = (int)KeyNumber.Signature;

RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(RsaKeySize, parameters);
</code></pre>

<p>2) The <code>RSACryptoServiceProvider</code> reverses its output (signatures, encrypted data). It is mentioned in the <a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.aspx#remarksToggle"" rel=""nofollow"">documentation</a>. So you need to <code>Array.Reverse()</code> the computed signature before saving it.</p>
","1441","<c#><c++><rsa><digital-signature><cryptoapi>","3","3","1","2013-04-16 14:53:59","16040288","0","2","","","","2013-04-15 12:41:23",""
"7968730","about encryption and decryption using Crypto++ library","<p>Can anyone please give a sample code for encryption and decryption of a text file using Crypto++ library..
Thanks in advance</p>
","<p>There's an example on Code Project of encrypting log files with Crypto++. Hope this helps.</p>

<p><a href=""http://www.codeproject.com/KB/files/logit.aspx"" rel=""nofollow"">http://www.codeproject.com/KB/files/logit.aspx</a></p>
","1440","<c++><encryption><cryptoapi>","-1","1","1","2011-11-01 16:52:47","","3","","639654","","2011-11-01 15:51:43","2011-11-01 15:24:28",""
"37717931","How to export a password-protected private key using MS CryptoAPI?","<p>Using Microsoft CryptoAPI, I've generated a new RSA key pair, and am now trying to export the private key to a PKCS#8 encrypted (password-protected) PEM file.</p>

<p>I first investigated CryptExportPKCS8() and CryptExportPKCS8Ex(), but the former doesn't support encrypting the key, and the latter is <a href=""http://microsoft.public.platformsdk.security.narkive.com/7sfErwMZ/where-is-cryptexportpkcs8ex#post5"" rel=""nofollow"">not exported by crypt32.dll</a>. MSDN says that both functions have been deprecated anyway.</p>

<p>My current attempt is to pass a session key derived from the password to CryptExportKey():</p>

<pre><code>HCRYPTPROV provider;
BOOL result = CryptAcquireContext(&amp;provider, CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_SILENT);
HCRYPTKEY keyPair;
result = CryptGenKey(provider, CALG_RSA_KEYX, (2048 &lt;&lt; 16) | CRYPT_EXPORTABLE, &amp;keyPair);

HCRYPTHASH hash;
result = CryptCreateHash(provider, CALG_SHA1, 0, 0, &amp;hash);
const char *password = ""password"";
result = CryptHashData(hash, (const BYTE *)password, strlen(password), 0);
HCRYPTKEY sessionKey;
result = CryptDeriveKey(provider, CALG_3DES, hash, CRYPT_EXPORTABLE, &amp;sessionKey);

DWORD blobSize;
result = CryptExportKey(keyPair, sessionKey, PRIVATEKEYBLOB, 0, NULL, &amp;blobSize);
BYTE *blobBytes = new BYTE[blobSize];
result = CryptExportKey(keyPair, sessionKey, PRIVATEKEYBLOB, 0, blobBytes, &amp;blobSize);

DWORD derSize;
// This throws ""First-chance exception ... Access violation reading ..."" and returns FALSE
result = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, blobBytes, 0, NULL, NULL, &amp;derSize);
// error is 3221225477 (0xC0000005)
DWORD error = GetLastError();
BYTE *derBytes = new BYTE[derSize];
result = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, blobBytes, 0, NULL, derBytes, &amp;derSize);

// ... CryptBinaryToString() to convert to PEM

// ... Write PEM to file
</code></pre>

<p>All calls succeed up until the commented CryptEncodeObjectEx().</p>

<p>If I don't pass the session key to CryptExportKey() then I can successfully use CryptEncodeObjectEx() to encode the private key, but obviously it is then plain-text.</p>

<p>How can I export a password-protected private key? Is there something wrong with the way I derive the session key? Is PKCS_RSA_PRIVATE_KEY the wrong encoding type?</p>

<p>I've been testing in Visual Studio 2013 on Windows 7.</p>
","<p>PKCS_RSA_PRIVATE_KEY used only when private key blob not encrypted. when it encrypted you must use PKCS_ENCRYPTED_PRIVATE_KEY_INFO. example of working code </p>

<pre><code>BOOL expKey(PCSTR password)
{
    BOOL fOk = FALSE;
    HCRYPTPROV hProv;
    if (CryptAcquireContext(&amp;hProv, 0, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        HCRYPTKEY hKey, hExpKey;
        HCRYPTHASH hHash;

        BOOL f = FALSE;

        if (CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash))
        {
            if (CryptHashData(hHash, (PBYTE)password, (ULONG)strlen(password), 0))
            {
                f = CryptDeriveKey(hProv, CALG_3DES, hHash, 0, &amp;hExpKey);
            }
            CryptDestroyHash(hHash);
        }

        if (f)
        {
            if (CryptGenKey(hProv, CALG_RSA_KEYX, RSA1024BIT_KEY*2|CRYPT_EXPORTABLE, &amp;hKey))
            {
                CRYPT_ENCRYPTED_PRIVATE_KEY_INFO cepki = {{ szOID_RSA_DES_EDE3_CBC}};
                if (
                    CryptExportKey(hKey, hExpKey, PRIVATEKEYBLOB, 0, 0, &amp;cepki.EncryptedPrivateKey.cbData) &amp;&amp;
                    CryptExportKey(hKey, hExpKey, PRIVATEKEYBLOB, 0, cepki.EncryptedPrivateKey.pbData = (PBYTE)alloca(cepki.EncryptedPrivateKey.cbData), &amp;cepki.EncryptedPrivateKey.cbData)
                    )
                {
                    ULONG cb;
                    PVOID pvEncoded;
                    if (CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_ENCRYPTED_PRIVATE_KEY_INFO, &amp;cepki, CRYPT_ENCODE_ALLOC_FLAG, 0, &amp;pvEncoded, &amp;(cb = sizeof(PVOID))))
                    {
                        fOk = TRUE;
                        LocalFree(pvEncoded);
                    }
                }
            }
            CryptDestroyKey(hExpKey);
        }
        CryptReleaseContext(hProv, 0);
    }

    return fOk;
}
</code></pre>
","1425","<c++><winapi><encryption><cryptoapi>","1","0","1","2016-06-09 08:47:28","","0","","","","","2016-06-09 05:58:09",""
"10354053","Ciphertext-Policy Attribute-Based Encryption toolkit ""make"" error with libgmp","<p>I am getting the following error when trying to ""make"" the cpabe-0.11 <a href=""http://acsc.cs.utexas.edu/cpabe/"" rel=""nofollow"">toolkit/library</a> on Ubuntu 12.04 (64 bit). All the required libraries, including libgmp, are installed correctly in the system.</p>

<pre><code>/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/4.6.1/../../../../lib/libpbc.so: undefined reference to symbol '__gmpz_clear'
/usr/bin/ld: note: '__gmpz_clear' is defined in DSO /usr/lib/libgmp.so.3 so try adding it to the linker command line
/usr/lib/libgmp.so.3: could not read symbols: Invalid operation
collect2: ld returned 1 exit status
make: *** [cpabe-setup] Error 1
</code></pre>
","<p>So I solved this at last. Basically I was getting the error bcz for some reason the libgmp was not linking in the make (that's what the error is saying). But when I checked the Makefile created by running ./configure, it said:-</p>

<pre><code>...blah blah blah ...
LDFLAGS = -O3 -Wall \
        -lglib-2.0   \
        -Wl,-rpath /usr/local/lib -lgmp \
        -Wl,-rpath /usr/local/lib -lpbc \
        -lbswabe \
        -lcrypto -lcrypto
... blah blah blah ...
</code></pre>

<p>As you can see, libgmp is mentioned in the LDFLAGS. So much confusion ensued. After a while just on a whim, it tried the following modification to the Makefile:-</p>

<pre><code>LDFLAGS = -O3 -Wall \
        -lglib-2.0   \
        -Wl,-rpath /usr/local/lib -lgmp \
        -Wl,-rpath /usr/local/lib -lpbc \
        -lbswabe \
        -lcrypto -lcrypto \
        -lgmp
</code></pre>

<p>So now, for some weird reason it compiles fine.</p>
","1408","<linux><makefile><cryptoapi>","1","2","1","2012-04-30 12:28:51","10383723","0","","","","","2012-04-27 16:05:52",""
"19997750","CryptEncrypt/CryptDecrypt WinAPI functions fail when called from vb.net","<p>Any help with the following greatly appreciated.....</p>

<p>I have some C++ code I've inherited which decrypts certain structures/byte arrays; I've been trying to write a test program in VB.net which exactly mimics the C++ decryption routine using the same functions, ie. using the WinAPI Crypto calls; in testing, CryptAcquireContext, CryptCreateHash, CryptHashData and CryptDeriveKey all succeed; </p>

<p>However, both the CryptEncrypt and CryptDecrypt functions fail with the Invalid Parameter error, even in the most simple scenario; </p>

<p>(I am aware of the System.Security.Cryptography namespace...and I will resort to this...but the C++ code includes structures with unions, and for testing, it seemed better to try the WinAPI route first)</p>

<p>the sample code is below...I am on Win7x64 sp1, vs 2010 sp1...</p>

<pre><code>Private Sub cmdTest(sender As System.Object, e As System.EventArgs) Handles cmdtest.Click

    Dim hCrypt As IntPtr
    Dim hSecretHash, hUserHash As IntPtr
    Dim hSecretKey As IntPtr
    Dim success As Boolean


    If CryptAcquireContext(hCrypt, vbNullString, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) Then

        'create hash
        success = CryptCreateHash(hCrypt, CALG_MD5, 0, 0, hSecretHash)

        'hash stage 1
        success = CryptHashData(hSecretHash, Encoding.ASCII.GetBytes(""yyyyyy""), ""xxxxxx"".length, 0)
        success = CryptHashData(hSecretHash, Encoding.ASCII.GetBytes(""yyyyyy""), ""yyyyyy"".length, 0)

        'derive key
        success = CryptDeriveKey(hCrypt, CALG_RC4, hSecretHash, 0, hSecretKey)

        Dim newb(127) As Byte
        Dim teststring As String = ""Testing""    
        Dim testbytes() As Byte = Encoding.ASCII.GetBytes(teststring)   
        Buffer.BlockCopy(testbytes, 0, newb, 0, testbytes.Length)

    Dim inputlength As UShort = Convert.ToUInt16(testbytes.Length)
        Dim newblength As UShort = CUShort(newb.Length)
        Dim bufferlength As UShort = newblength


    '---------------BOTH THESE FAIL (all above OK)
        success = CryptEncrypt(hSecretKey, 0, True, 0, newb, newblength, inputlength)
        success = CryptDecrypt(hSecretKey, 0, True, 0, newb, newblength)
    '--------------------------------------------


        'Destroy the user keycode
        CryptDestroyHash(hUserHash)

        'Destroy the secret key
        CryptDestroyKey(hSecretKey)
        CryptDestroyHash(hSecretHash)

        'Release the provider
        CryptReleaseContext(hCrypt, 0)

    End If

End Sub

Public Const ALG_CLASS_DATA_ENCRYPT As Int32 = 24576
Public Const ALG_CLASS_HASH As Int32 = 32768
Public Const ALG_TYPE_ANY As Int32 = 0
Public Const ALG_SID_RC4 As Int32 = 1
Public Const ALG_SID_RC2 As Int32 = 2
Public Const ALG_SID_MD5 As Int32 = 3
Public Const ALG_SID_SHA1 As Int32 = 4
Public Const ALG_SID_MAC As Int32 = 5
Public Const ALG_SID_HMAC As Int32 = 9
Public Const ALG_TYPE_BLOCK As Int32 = 1536
Public Const ALG_TYPE_STREAM As Int32 = 2048

Public Const CALG_MD5 As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_MD5
Public Const CALG_RC2 As Int32 = ALG_CLASS_DATA_ENCRYPT + ALG_TYPE_BLOCK + ALG_SID_RC2
Public Const CALG_RC4 As Int32 = ALG_CLASS_DATA_ENCRYPT + ALG_TYPE_STREAM + ALG_SID_RC4
Public Const CALG_SHA1 As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_SHA1
Public Const CALG_MAC As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_MAC
Public Const CALG_HMAC As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_HMAC

Public Const PROV_RSA_FULL As Int32 = &amp;H1
Public Const CRYPT_VERIFYCONTEXT As Int32 = &amp;HF0000000

Public Const HP_ALGID As Int32 = 1
Public Const HP_HASHVAL As Int32 = 2
Public Const HP_HASHSIZE As Int32 = 4
Public Const HP_HMAC_INFO As Int32 = 5

Public Const MS_DEF_PROV As String = ""Microsoft Base Cryptographic Provider v1.0""

'Imported Functions:
&lt;DllImport(""advapi32.dll"", CharSet:=CharSet.Auto, SetLastError:=True)&gt; _
    Public Shared Function CryptAcquireContext( _
        ByRef hProv As IntPtr, _
        ByVal pszContainer As String, _
        ByVal pszProvider As String, _
        ByVal dwProvType As Int32, _
        ByVal dwFlags As Int32 _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt;
    Public Shared Function CryptEncrypt( _
        ByVal hKey As IntPtr, _
        ByVal hHash As IntPtr, _
        ByVal Final As Boolean, _
        ByVal dwFlags As UShort, _
        pbData() As Byte, _
        pdwDataLen As UShort, _
        ByVal dwBufLen As UShort) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True, CharSet:=CharSet.Unicode)&gt;
    Public Shared Function CryptDecrypt( _
        ByVal hKey As IntPtr, _
        ByVal hHash As IntPtr, _
        ByVal Final As Boolean, _
        ByVal dwFlags As UShort, _
        pbData() As Byte, _
        pdwDataLen As UShort _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptCreateHash( _
        ByVal hProv As IntPtr, _
        ByVal Algid As Int32, _
        ByVal hKey As IntPtr, _
        ByVal dwFlags As Int32, _
        ByRef phHash As IntPtr _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptDestroyHash( _
        ByVal hHash As IntPtr _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptHashData( _
        ByVal hHash As IntPtr, _
        ByVal pbData() As Byte, _
        ByVal dwDataLen As Int32, _
        ByVal dwFlags As Int32 _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", setlasterror:=True)&gt; _
    Public Shared Function CryptDeriveKey( _
        ByVal hProv As IntPtr, _
        ByVal Algid As Integer, _
        ByVal hBaseData As IntPtr, _
        ByVal dwflags As Integer, _
        ByRef phKey As IntPtr) As &lt;MarshalAs(UnmanagedType.Bool)&gt; Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptDestroyKey( _
        ByVal hKey As IntPtr _
    ) As Boolean
    End Function
</code></pre>
","<p>The Final parameter of CryptEncrypt is a BOOL, which is a 32-bit int.  Try changing the parameter to Final as int32,or use MarshalAs(UnmanagedType.Bool)</p>
","1385","<vb.net><winapi><pinvoke><cryptoapi>","0","0","2","2013-11-21 13:57:00","","1","","","","","2013-11-15 09:31:50",""
"19997750","CryptEncrypt/CryptDecrypt WinAPI functions fail when called from vb.net","<p>Any help with the following greatly appreciated.....</p>

<p>I have some C++ code I've inherited which decrypts certain structures/byte arrays; I've been trying to write a test program in VB.net which exactly mimics the C++ decryption routine using the same functions, ie. using the WinAPI Crypto calls; in testing, CryptAcquireContext, CryptCreateHash, CryptHashData and CryptDeriveKey all succeed; </p>

<p>However, both the CryptEncrypt and CryptDecrypt functions fail with the Invalid Parameter error, even in the most simple scenario; </p>

<p>(I am aware of the System.Security.Cryptography namespace...and I will resort to this...but the C++ code includes structures with unions, and for testing, it seemed better to try the WinAPI route first)</p>

<p>the sample code is below...I am on Win7x64 sp1, vs 2010 sp1...</p>

<pre><code>Private Sub cmdTest(sender As System.Object, e As System.EventArgs) Handles cmdtest.Click

    Dim hCrypt As IntPtr
    Dim hSecretHash, hUserHash As IntPtr
    Dim hSecretKey As IntPtr
    Dim success As Boolean


    If CryptAcquireContext(hCrypt, vbNullString, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) Then

        'create hash
        success = CryptCreateHash(hCrypt, CALG_MD5, 0, 0, hSecretHash)

        'hash stage 1
        success = CryptHashData(hSecretHash, Encoding.ASCII.GetBytes(""yyyyyy""), ""xxxxxx"".length, 0)
        success = CryptHashData(hSecretHash, Encoding.ASCII.GetBytes(""yyyyyy""), ""yyyyyy"".length, 0)

        'derive key
        success = CryptDeriveKey(hCrypt, CALG_RC4, hSecretHash, 0, hSecretKey)

        Dim newb(127) As Byte
        Dim teststring As String = ""Testing""    
        Dim testbytes() As Byte = Encoding.ASCII.GetBytes(teststring)   
        Buffer.BlockCopy(testbytes, 0, newb, 0, testbytes.Length)

    Dim inputlength As UShort = Convert.ToUInt16(testbytes.Length)
        Dim newblength As UShort = CUShort(newb.Length)
        Dim bufferlength As UShort = newblength


    '---------------BOTH THESE FAIL (all above OK)
        success = CryptEncrypt(hSecretKey, 0, True, 0, newb, newblength, inputlength)
        success = CryptDecrypt(hSecretKey, 0, True, 0, newb, newblength)
    '--------------------------------------------


        'Destroy the user keycode
        CryptDestroyHash(hUserHash)

        'Destroy the secret key
        CryptDestroyKey(hSecretKey)
        CryptDestroyHash(hSecretHash)

        'Release the provider
        CryptReleaseContext(hCrypt, 0)

    End If

End Sub

Public Const ALG_CLASS_DATA_ENCRYPT As Int32 = 24576
Public Const ALG_CLASS_HASH As Int32 = 32768
Public Const ALG_TYPE_ANY As Int32 = 0
Public Const ALG_SID_RC4 As Int32 = 1
Public Const ALG_SID_RC2 As Int32 = 2
Public Const ALG_SID_MD5 As Int32 = 3
Public Const ALG_SID_SHA1 As Int32 = 4
Public Const ALG_SID_MAC As Int32 = 5
Public Const ALG_SID_HMAC As Int32 = 9
Public Const ALG_TYPE_BLOCK As Int32 = 1536
Public Const ALG_TYPE_STREAM As Int32 = 2048

Public Const CALG_MD5 As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_MD5
Public Const CALG_RC2 As Int32 = ALG_CLASS_DATA_ENCRYPT + ALG_TYPE_BLOCK + ALG_SID_RC2
Public Const CALG_RC4 As Int32 = ALG_CLASS_DATA_ENCRYPT + ALG_TYPE_STREAM + ALG_SID_RC4
Public Const CALG_SHA1 As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_SHA1
Public Const CALG_MAC As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_MAC
Public Const CALG_HMAC As Int32 = ALG_CLASS_HASH + ALG_TYPE_ANY + ALG_SID_HMAC

Public Const PROV_RSA_FULL As Int32 = &amp;H1
Public Const CRYPT_VERIFYCONTEXT As Int32 = &amp;HF0000000

Public Const HP_ALGID As Int32 = 1
Public Const HP_HASHVAL As Int32 = 2
Public Const HP_HASHSIZE As Int32 = 4
Public Const HP_HMAC_INFO As Int32 = 5

Public Const MS_DEF_PROV As String = ""Microsoft Base Cryptographic Provider v1.0""

'Imported Functions:
&lt;DllImport(""advapi32.dll"", CharSet:=CharSet.Auto, SetLastError:=True)&gt; _
    Public Shared Function CryptAcquireContext( _
        ByRef hProv As IntPtr, _
        ByVal pszContainer As String, _
        ByVal pszProvider As String, _
        ByVal dwProvType As Int32, _
        ByVal dwFlags As Int32 _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt;
    Public Shared Function CryptEncrypt( _
        ByVal hKey As IntPtr, _
        ByVal hHash As IntPtr, _
        ByVal Final As Boolean, _
        ByVal dwFlags As UShort, _
        pbData() As Byte, _
        pdwDataLen As UShort, _
        ByVal dwBufLen As UShort) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True, CharSet:=CharSet.Unicode)&gt;
    Public Shared Function CryptDecrypt( _
        ByVal hKey As IntPtr, _
        ByVal hHash As IntPtr, _
        ByVal Final As Boolean, _
        ByVal dwFlags As UShort, _
        pbData() As Byte, _
        pdwDataLen As UShort _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptCreateHash( _
        ByVal hProv As IntPtr, _
        ByVal Algid As Int32, _
        ByVal hKey As IntPtr, _
        ByVal dwFlags As Int32, _
        ByRef phHash As IntPtr _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptDestroyHash( _
        ByVal hHash As IntPtr _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptHashData( _
        ByVal hHash As IntPtr, _
        ByVal pbData() As Byte, _
        ByVal dwDataLen As Int32, _
        ByVal dwFlags As Int32 _
    ) As Boolean
    End Function

&lt;DllImport(""advapi32.dll"", setlasterror:=True)&gt; _
    Public Shared Function CryptDeriveKey( _
        ByVal hProv As IntPtr, _
        ByVal Algid As Integer, _
        ByVal hBaseData As IntPtr, _
        ByVal dwflags As Integer, _
        ByRef phKey As IntPtr) As &lt;MarshalAs(UnmanagedType.Bool)&gt; Boolean
    End Function

&lt;DllImport(""advapi32.dll"", SetLastError:=True)&gt; _
    Public Shared Function CryptDestroyKey( _
        ByVal hKey As IntPtr _
    ) As Boolean
    End Function
</code></pre>
","<p>Could be more things, but immediately <code>ByVal dwFlags As UShort</code> looks off to me.  </p>

<p>The msdn lists that parameter as:</p>

<pre><code>DWORD dwFlags,
</code></pre>

<p>A DWORD is 4 bytes, so would be an Int32 or Integer (in VB.NET)</p>
","1385","<vb.net><winapi><pinvoke><cryptoapi>","0","0","2","2013-11-21 13:57:00","","1","","","","","2013-11-15 09:31:50",""
"36074001","Detect availability of Linux kernel's AF_ALG sockets for userland crypto?","<p>The Linux kernel added a user space API to its crypto functions at 2.6 via a new new socket family <em><code>AF_ALG</code></em>. Also see <a href=""http://lwn.net/Articles/410536/"" rel=""nofollow"">crypto: af_alg - User-space interface for Crypto API</a> on LWN.</p>

<p>I'm working with Gentoo, and it requires one to configure and build the kernel. It appears the default settings omit <em><code>AF_ALG</code></em>, so I'm [currently] working with a kernel that lacks the support. OpenSSL 1.1.0 has an Engine interface into the crypto API. Its failing its self tests due to lack of support for <em><code>AF_ALG</code></em>.</p>

<p>I'd like to know how to detect availability of <em><code>AF_ALG</code></em> at both compile time and runtime. I have not found a way to detect availability at compile time. I think we can use <em><code>alg_get_type</code></em> to detect runtime availability, but I'm not certain.</p>

<p>How can I determine availability of <em><code>AF_ALG</code></em> at compile time and at runtime?</p>

<hr>

<p>The <a href=""http://man7.org/linux/man-pages/man2/socket.2.html"" rel=""nofollow""><code>socket(2)</code></a> man pages has this to say: <em>""Some socket types may not be implemented by all protocol families.""</em> But it does not discuss how to detect availability.</p>

<p>The kernel docs cover the API in <a href=""http://www.kernel.org/doc/htmldocs/crypto-API/User.html"" rel=""nofollow"">Chapter 4. User Space Interface</a>, but it does not appear to discuss how to detect availability.</p>

<hr>

<p>For completeness, it looks like the following kernel configuration parameters need to be set for Gentoo (from Marek Vašut's <a href=""https://events.linuxfoundation.org/sites/events/files/slides/lcj-2014-crypto-user.pdf"" rel=""nofollow"">Utilizing the crypto accelerators</a>):</p>

<ul>
<li><code>CONFIG_CRYPTO_USER_API=m</code></li>
<li><code>CONFIG_CRYPTO_USER_API_HASH=m</code></li>
<li><code>CONFIG_CRYPTO_USER_API_SKCIPHER=m</code></li>
</ul>
","<p>I think I can answer some of the second question, runtime availability, with the following:</p>

<pre><code>int ret = socket(AF_ALG, SOCK_SEQPACKET, 0);
if (ret != -1)
  close(ret);

int supported = ret != -1;
</code></pre>
","1364","<c><sockets><linux-kernel><cryptoapi>","2","1","2","2019-03-22 01:16:47","49884026","2","","608639","","2016-03-18 04:43:15","2016-03-18 00:18:54",""
"36074001","Detect availability of Linux kernel's AF_ALG sockets for userland crypto?","<p>The Linux kernel added a user space API to its crypto functions at 2.6 via a new new socket family <em><code>AF_ALG</code></em>. Also see <a href=""http://lwn.net/Articles/410536/"" rel=""nofollow"">crypto: af_alg - User-space interface for Crypto API</a> on LWN.</p>

<p>I'm working with Gentoo, and it requires one to configure and build the kernel. It appears the default settings omit <em><code>AF_ALG</code></em>, so I'm [currently] working with a kernel that lacks the support. OpenSSL 1.1.0 has an Engine interface into the crypto API. Its failing its self tests due to lack of support for <em><code>AF_ALG</code></em>.</p>

<p>I'd like to know how to detect availability of <em><code>AF_ALG</code></em> at both compile time and runtime. I have not found a way to detect availability at compile time. I think we can use <em><code>alg_get_type</code></em> to detect runtime availability, but I'm not certain.</p>

<p>How can I determine availability of <em><code>AF_ALG</code></em> at compile time and at runtime?</p>

<hr>

<p>The <a href=""http://man7.org/linux/man-pages/man2/socket.2.html"" rel=""nofollow""><code>socket(2)</code></a> man pages has this to say: <em>""Some socket types may not be implemented by all protocol families.""</em> But it does not discuss how to detect availability.</p>

<p>The kernel docs cover the API in <a href=""http://www.kernel.org/doc/htmldocs/crypto-API/User.html"" rel=""nofollow"">Chapter 4. User Space Interface</a>, but it does not appear to discuss how to detect availability.</p>

<hr>

<p>For completeness, it looks like the following kernel configuration parameters need to be set for Gentoo (from Marek Vašut's <a href=""https://events.linuxfoundation.org/sites/events/files/slides/lcj-2014-crypto-user.pdf"" rel=""nofollow"">Utilizing the crypto accelerators</a>):</p>

<ul>
<li><code>CONFIG_CRYPTO_USER_API=m</code></li>
<li><code>CONFIG_CRYPTO_USER_API_HASH=m</code></li>
<li><code>CONFIG_CRYPTO_USER_API_SKCIPHER=m</code></li>
</ul>
","<p>I'd say the only way to detect at compile time is to write a separate program that will do a runtime check for AF_ALG sockets and create a header file with a define such as <code>#define AF_ALG_AVAILABLE</code>.</p>

<p>Expanding on your answer to the second question, you may want to make sure errno holds <code>EAFNOSUPPORT</code>. Otherwise, another error, such as being out of file descriptors, will make your program falsely believe that AF_ALG is not supported, which could be bad if you are checking for AF_ALG at compile time using my method.</p>

<p>Checking at compile time:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/if_alg.h&gt;

int main(){
    //Alternatively you can set the path to argv[1]
    FILE *f = fopen(""/path/to/output/file"", ""w"");
    if(f == NULL){
        //Handle error
    }
    int sockfd = socket(AF_ALG, SOCK_SEQPACKET, 0);
    if(sockfd == -1){
        if(errno == EAFNOSUPPORT){
            //Unavailable, put whatever you want here
            fprintf(f, ""#define AF_ALG_UNAVAILABLE\n"");
        } else {
            //Unable to detect for some other error
        }
    } else { //AF_ALG is available
        fprintf(f, ""#define AF_ALG_AVAILABLE\n"");
    }
    close(sockfd);
    fclose(f);
    return 0;
}
</code></pre>

<p>Then just compile and run that in your makefile, and you will find your header file where you put it. Then you can simply select what code to use using <code>#ifdef AF_ALG_AVAILABLE</code>.</p>
","1364","<c><sockets><linux-kernel><cryptoapi>","2","1","2","2019-03-22 01:16:47","49884026","2","","608639","","2016-03-18 04:43:15","2016-03-18 00:18:54",""
"15899094","MD5-SHA1 hash using CryptoAPI","<p>I have requirement of signing a data using MD5-SHA1 hash (MD5 hash and SHA1 hash of the data are combined and then signed).</p>

<p>Primary requirement:</p>

<p>MD5-SHA1 hash is provided by OpenSSL in some way that is not exposed. This hash is complete.</p>

<p>Now my requirement is to sign this hash using Crypto API without hashing (only signing is required, not hashing again). Why CryptoAPI, not OpenSSL? Because, I am dealing with a certificate with non-exportable private key. Its private key can only be used by CryptoAPI, not by OpenSSL.</p>

<p>This scenario is from SSL handshake where send Client verify part (under the case of non-exportable private key) to my layer and is trying to sign the data using CryptoAPI.</p>

<p>Also, I would like to know about other ways of making the use of non-exportable private key certificates using OpenSSL.</p>
","<p>By using CALG_SSL3_SHAMD5 in CryptCreateHash and after that calling CryptSetHashParam and then calling the CryptSignHash did the job for me.</p>

<p>Let me detailed out the requirement:
1. Generally, I gave private key using EVP_PKEY to OpenSSL function so that it can do the signing part. I used to extract the private key from Windows Certificate store (when key is marked as exportable). But in one scenario, private key is not marked as exportable and I was not able to get private key to EVP_PKEY. So, I did modification to OpenSSL code on the case when private key is not available, then the signing part is implemented using CryptoAPI (since CryptoAPI allows the signing using such non-exportable key).</p>

<p>So, in my case, data is completely hashed by OpenSSL (using md5-sha1 hash). Only thing left for me is to do signing.</p>

<p>So, following steps (under signing part) did the job:</p>

<pre><code>1. Created hash using Certificate key handle provider and use CALG_SSL3_SHAMD5 algorithm.
2. Using CryptSetHashParam, I set the initial hash value
3. Signed the hash using CryptSignHash.
4. After that, reverse the bytes order (as OpenSSL signature is Big endian mentioned [here][1] which I found after lots of experimenting).
</code></pre>

<p>Rest of code of OpenSSL seems happy with this signature.</p>
","1357","<openssl><cryptoapi>","0","0","1","2013-04-13 16:27:39","15990078","2","","","","","2013-04-09 10:07:18",""
"11787811","Convert OpenSSL key to CryptoAPI","<p>I have spent quite a bit of time on Google searching for the answer to this. I have found several pieces of code describing solutions but most are in C, .NET, or Java. My case is VB6.</p>

<p>I have a pretty straightforward RSA1 application: sign some data (in ""appA"" with private key), then validate signature (in ""appB"" with public key, this is the VB6 app). Right now everything is running fine via the CryptoAPI library.</p>

<p>The ""appA"" signature portion needs to be moved to a unix server and carried out by OpenSSL (preferably). The problem is converting the key format from PEM to the PublicKeyBlob that CryptoAPI expects.</p>

<p>I have tried to port <a href=""https://stackoverflow.com/questions/1231178/load-an-x509-pem-file-into-windows-cryptoapi"">this C code</a> to VB. CryptStringToBinary succeeds but CryptDecodeObjectEx just hangs then crashes VB.</p>

<p>I haven't been able to find any documentation showing this use in VB. I'm not sure that it's possible even. I'm hoping someone may be able to shed some light on this. I have also tried the CryptDecodeObject (sans ""Ex"") function hoping that the lack of all the structures needed would solve the issue... but same problem.</p>

<p>My test key was generated by OpenSSL using openssl_pkey_new</p>
","<p>Thee only things I can think of is check to make sure your declarations are right and to debug/print out the paramaters you are passing and verify they are correct.</p>

<pre><code>Declare Function CryptDecodeObject lib ""crypt32"" (ByVal dwCertEncodingType As Long, ByVal lpszStructType As String, ByVal pbEncoded As String, ByVal cbEncoded As Long, ByVal dwFlags As Long, pvStructInfo As Any, ByRef pcbStructInfo As Long) As Long`

Declare Function CryptDecodeObjectEx lib ""crypt32"" (ByVal dwCertEncodingType As Long, ByVal lpszStructType As String, ByVal pbEncoded As String, ByVal cbEncoded As Long, ByVal dwFlags As Long, ByRef pDecodePara As PCRYPT_DECODE_PARA, pvStructInfo As Any, ByRef pcbStructInfo As Long) As Long
</code></pre>

<p>There is always a way or a workaround, vb6 is still coughing blood after verification, just write a c++ stub dll that does work and call it from vb6.</p>
","1342","<openssl><rsa><cryptoapi>","1","0","2","2012-08-09 16:29:29","","0","","-1","","2017-05-23 10:34:38","2012-08-03 00:45:33",""
"11787811","Convert OpenSSL key to CryptoAPI","<p>I have spent quite a bit of time on Google searching for the answer to this. I have found several pieces of code describing solutions but most are in C, .NET, or Java. My case is VB6.</p>

<p>I have a pretty straightforward RSA1 application: sign some data (in ""appA"" with private key), then validate signature (in ""appB"" with public key, this is the VB6 app). Right now everything is running fine via the CryptoAPI library.</p>

<p>The ""appA"" signature portion needs to be moved to a unix server and carried out by OpenSSL (preferably). The problem is converting the key format from PEM to the PublicKeyBlob that CryptoAPI expects.</p>

<p>I have tried to port <a href=""https://stackoverflow.com/questions/1231178/load-an-x509-pem-file-into-windows-cryptoapi"">this C code</a> to VB. CryptStringToBinary succeeds but CryptDecodeObjectEx just hangs then crashes VB.</p>

<p>I haven't been able to find any documentation showing this use in VB. I'm not sure that it's possible even. I'm hoping someone may be able to shed some light on this. I have also tried the CryptDecodeObject (sans ""Ex"") function hoping that the lack of all the structures needed would solve the issue... but same problem.</p>

<p>My test key was generated by OpenSSL using openssl_pkey_new</p>
","<p>Well, I found a problem with one of my structures (didn't declare a byte array member as an array) and I'm no longer having crash issues. I'm still not having any success with CryptDecodeObject however. The code below is what I'm working with. GetLastErr just returns 0 (not much help). If anyone has a thought on where I may be going wrong, please let me know!</p>

<pre><code>Dim iFile As Integer
Dim sPEM As String, sDER As String
Dim lenPEM As Long, lenDER As Long
Dim publicKeyInfo As CERT_PUBLIC_KEY_INFO
Dim publicKeyInfoLen As Long


iFile = FreeFile
Open app.Path &amp; ""\publickey.txt"" For Binary As iFile
sPEM = Space(LOF(iFile))
Get #iFile, , sPEM
Close iFile

lenPEM = Len(sPEM)

' Determine buffer length required for the DER string
CryptStringToBinary sPEM, lenPEM, CRYPT_STRING_BASE64HEADER, 0, lenDER, 0, 0
sDER = Space(lenDER)

' Do conversion to binary
If Not CryptStringToBinary(sPEM, lenPEM, CRYPT_STRING_BASE64HEADER, sDER, lenDER, 0, 0) Then
    Debug.Print sDER
Else
    MsgBox ""CryptStringToBinary Error "" &amp; GetLastError
    Exit Sub
End If

' Do conversion to blob
If Not CryptDecodeObject(X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, sDER, lenDER, 0, publicKeyInfo, publicKeyInfoLen) Then
    MsgBox ""CryptDecodeObject Error: "" &amp; GetLastError
    Exit Sub
End If
</code></pre>

<p>I can post all the function and type declarations if anyone thinks it will help, I believe they are correct. </p>

<p>Here is the public key as generated by OpenSSL:</p>

<p>-----BEGIN PUBLIC KEY-----
MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANWhFRxt/ZF56uGO7GsbvevmX42//thm
JdseUwQNot/ihXCPRadf0SPYbtHS6/JA92pCX7NxfgYNoYlOFb0IYYcCAwEAAQ==
-----END PUBLIC KEY-----</p>
","1342","<openssl><rsa><cryptoapi>","1","0","2","2012-08-09 16:29:29","","0","","-1","","2017-05-23 10:34:38","2012-08-03 00:45:33",""
"13991337","Why does CryptAcquireContext return ERROR_ACCESS_DENIED when called from a process started via WMI?","<p>I have an executable which calls <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886%28v=vs.85%29.aspx"" rel=""nofollow"">CryptAcquireContext</a> with CRYPT_NEWKEYSET:</p>

<pre><code>BOOL b_result;
HCRYPTPROV prov;

b_result = CryptAcquireContext(&amp;prov, L""testcontext6"", MS_DEF_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET);

if(!b_result) {
    int err = GetLastError();
    fprintf(stderr, ""Error acquiring context: %#x\n"", err);
    return 1;
}
return 0;
</code></pre>

<p>If I run this locally, it works fine. If I run it via WMI as follows, it returns error 0x5 (ERROR_ACCESS_DENIED):</p>

<pre><code>using (var processClass = new ManagementClass(m_scope, new ManagementPath(""Win32_Process""), new ObjectGetOptions()))
{
    var inParams = processClass.GetMethodParameters(""Create"");
    inParams[""commandLine""] = @""cmd.exe /c C:\CppTest.exe 2&gt;C:\test.log"";
    var outParams = processClass.InvokeMethod(""Create"", inParams, null);
    return outParams[""ProcessId""];
}
</code></pre>

<p>It seems that the environment under WMI is somehow more restrictive, which stops the new key container being created. Any suggestions for why this might be, and how to work around it?</p>
","<p>The environment under Win32_Process.CreateProcess forbids the use of interactive operations. and it turns out that using CryptAcquireContext to access user-specific (rather than machine-wide) key containers doesn't work in non-interactive environments (see <a href=""http://social.msdn.microsoft.com/Forums/uk/clr/thread/2033c171-0809-4e14-aa50-1b9287389cb3"" rel=""nofollow"">http://social.msdn.microsoft.com/Forums/uk/clr/thread/2033c171-0809-4e14-aa50-1b9287389cb3</a>, for example). </p>
","1295","<c++><wmi><cryptoapi>","0","1","1","2012-12-27 11:11:48","14053718","7","","","","","2012-12-21 13:47:54",""
"1796137","Convert Windows CryptoAPI PRIVATE KEY BLOB to bouncy castle RsaPrivateCrtKeyParameters","<p>Is there any way (similar to FromCapiPrivateKeyBlob in Mono) to convert a Windows CryptoAPI PRIVATE KEY BLOB to RsaPrivateCrtKeyParameters used by Bouncy Castle?</p>
","<p>Have a look at the Org.BouncyCastle.Security.DotNetUtilities class to see what is there in the way of conversions.</p>

<p>I will look at adding methods for interop with CryptoAPI blobs.</p>
","1290","<c#><.net><bouncycastle><cryptoapi>","1","1","1","2010-02-02 12:29:38","","0","","33837","","2009-12-19 12:22:06","2009-11-25 10:51:54",""
"10756601","Certificate Friendly Name","<p>I am attempting to set the friendly name on a certificate when I store that certificate on a machine with the following code:</p>

<pre><code>CRYPT_DATA_BLOB fName = {_tcslen(FriendlyName) * sizeof(TCHAR), FriendlyName};
CertSetCertificateContextProperty(certContext, CERT_FRIENDLY_NAME_PROP_ID, 0, &amp;fName));
</code></pre>

<p>Where, obviously, FriendlyName is an LPWSTR pointing to the friendly name and certContext is the valid certificate context from saving the certificate in the store.  The function works correctly and the name is written into the certificate.  However, when I view it in the certificate snap-in, the last letter of the name is truncated.  I have tried adding one to the length of the name and that ends up cutting the name in half.  I have checked FriendlyName and the length to ensure they are correct and they are.  If I change FriendlyName to an LPSTR, it shows up as Kanjii characters.  In an example provided by Microsoft, they do the following:</p>

<pre><code>BYTE *pName = (BYTE *)""Temp Name."";
CRYPT_DATA_BLOB  Friendly_Name_Blob={32,pName};
</code></pre>

<p>I have no idea where they get the 32 from, nor do they provide an explanation that I can find.  When I use 32, it again truncates the name.  Any idea what I'm doing wrong and how to correct it?</p>
","<p>To set <code>CERT_FRIENDLY_NAME_PROP_ID</code> property using <a href=""http://preview.library.microsoft.com/en-us/library/aa376573%28v=vs.85%29.aspx"" rel=""nofollow"">CertSetCertificateContextProperty</a> you need first initialize <code>CRYPT_DATA_BLOB</code> and then use it as the last parameter of <code>CertSetCertificateContextProperty</code>. The code could be about the following:</p>

<pre><code>LPWSTR pszFriendlyName = L""My test friendly name"";
CRYPT_DATA_BLOB cryptBlob;
BOOL bResult;

cryptBlob.cbData = (lstrlenW(pszFriendlyName) + 1)*sizeof(WCHAR);
cryptBlob.pbData = (PBYTE)pszFriendlyName;

// pCertContext should be set before
bResult = CertSetCertificateContextProperty (pCertContext,
                                             CERT_FRIENDLY_NAME_PROP_ID,
                                             0, (LPVOID)&amp;cryptBlob);
if (!bResult) {
    // error
}
</code></pre>
","1290","<c++><certificate><cryptoapi>","1","1","1","2012-05-29 08:59:30","","0","","","","","2012-05-25 14:51:50",""
"7593900","How to get information about key container through certificate public key in CryptoAPI?","<p>In C# I can do this by using </p>

<pre><code>public static CspKeyContainerInfo GetKeyConatinerInformation(X509Certificate2 certificate)
{
   if (certificate == null)
      throw new ArgumentNullException(""certificate"");

   ICspAsymmetricAlgorithm key = certificate.PublicKey.Key as ICspAsymmetricAlgorithm;
      if (key == null)
         throw new InvalidOperationException(""Unknown key type"");

   return key.CspKeyContainerInfo;
}
</code></pre>

<p>I want to know how can i get this by using C++ and lib CryptoAPI </p>
","<p><a href=""http://www.idrix.fr/Root/Samples/pfx_parse.cpp"" rel=""nofollow noreferrer"">Here</a> is a program written by Mounir IDRASSI. This will provide you with the information you are looking for.</p>

<p>Also look for the related answer <a href=""https://stackoverflow.com/questions/6443642/how-to-get-container-name-for-pfx-key/6446601#6446601"">here</a>.</p>
","1273","<c++><cryptoapi>","1","1","1","2011-09-29 15:05:34","7599122","0","","187543","","2011-09-29 12:13:22","2011-09-29 07:30:33",""
"15141691","CryptDecryptMessage failing","<p>I have been trying to write some code to use the Microsoft CryptoAPI.  The goal is very simple: encrypt and then decrypt a string.  I seem to have it almost working, but the very last call to CryptDecryptMessage fails.</p>

<p>So, I am able to successfully encrypt my string.  When I then take the encrypted binary string and try to decrypt it, everything works except the last call to CryptDecryptMessage .  The decryption code I am using is below.</p>

<p>As the code stands, the first call to CryptDecryptMessage, to get the required size of the output buffer, succeeds, BUT it always returns a size equal to the cleartext string size plus 6.  I then size up my output buffer, and the next call to CryptDecryptMessage fails (return value is zero, <code>dwSizeRequired</code> gets set to zero, nothing is put in the output buffer, and <code>GetLastError</code> returns NTE_BAD_KEY).</p>

<p>On the other hand, if I uncomment the <code>#define TESTING_INCORRECT</code> line, the behaviour is slightly different.  The first call to CryptDecryptMessage succeeds.  Its return value is zero, but <code>GetLastError</code> returns <code>ERROR_MORE_DATA</code>, which one would expect, and most importantly <code>dwSizeRequired</code> is set with the size of the original cleartext string that was encoded.  I then allocate and call CryptDecryptMessage the second time, it fails again as above.</p>

<p>Lastly, I do have the private certificate key in my keystore.</p>

<p>Does anyone have any idea what is wrong here?????  Thanks.</p>

<pre><code>void decrypt(std::string&amp; sClearTextString , const std::vector&lt;T_Byte&gt;&amp; sEncryptedBinaryString, const std::string&amp; sKey)
{
    BOOL bResult;

    HCRYPTPROV hProv;
    bResult = CryptAcquireContext( &amp;hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, 0); 
    CHECK_CRYPT_ERR( !bResult , ""Unable to find crypto context"");

    HCERTSTORE hStore(NULL);
    const char* const pcKey = sKey.empty()? ""MY"" : sKey.c_str();
    hStore = CertOpenSystemStore( 0, pcKey);
    CHECK_CRYPT_ERR( hStore==NULL, ""unable to open certificate store."");

    HCERTSTORE CertStoreArray[] = {hStore};

    CRYPT_DECRYPT_MESSAGE_PARA  DecryptParams;
    DWORD  DecryptParamsSize = sizeof(DecryptParams);
    memset(&amp;DecryptParams, 0, DecryptParamsSize);
    DecryptParams.cbSize = DecryptParamsSize;
    DecryptParams.dwMsgAndCertEncodingType = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
    DecryptParams.cCertStore = sizeof(CertStoreArray)/sizeof(HCERTSTORE);
    DecryptParams.rghCertStore = CertStoreArray;

    const BYTE* const pbContent = &amp;sEncryptedBinaryString[0];
    DWORD dwSize = STATICCAST&lt;DWORD&gt;(sEncryptedBinaryString.size());
    DWORD dwSizeRequired = 0;

    BYTE* pbOutBuffer = NULL;
//#define TESTING_INCORRECT
#ifdef TESTING_INCORRECT
    std::string sDummyBuffer(2,'\0');
    pbOutBuffer = (BYTE*)(&amp;sDummyBuffer[0]);
#endif

    // Get required buffer size.
    bResult = CryptDecryptMessage( &amp;DecryptParams, pbContent, dwSize, pbOutBuffer, &amp;dwSizeRequired, NULL);
    CHECK_CRYPT_ERR( !bResult &amp;&amp; ERROR_MORE_DATA != GetLastError() , ""Unable to get buffer length"");

    //Allocate buffer
    sClearTextString.clear();
    sClearTextString.resize(dwSizeRequired+1,0);
    pbOutBuffer = (BYTE*)(&amp;sClearTextString[0]);

    //Now actually decryt
    bResult = CryptDecryptMessage( &amp;DecryptParams, pbContent, dwSize, pbOutBuffer, &amp;dwSizeRequired, NULL);
    CHECK_CRYPT_ERR( !bResult , ""Unable to decrypt"");

    CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
    CryptReleaseContext(hProv, 0);
}
</code></pre>
","<p>I would investigate the keys being used. The return code of 2148073475 actually translates to 0x80090003, which is NTE_BAD_KEY. GetLastError of 234 is ERR_MORE_DATA, which indicates an undersized buffer. </p>

<p>I <em>think</em> the problem lies in the expectation that the first call to CryptDecryptMessage will receive NULL as the pointer to pbDecrypted because its a sizing call, but as its non-null with the comment removed, it gives the 234 result thinking its trying to decrypt something that's <em>already</em> been sized. </p>

<p>If the presumption that the receipt buffer on the sizing (first) call should be null is correct, then that leads me to suggest that the key(s) may be suspect in some way per the NTE_BAD_KEY error code.</p>

<p>Hope that stirs some helpful thought for you.</p>
","1256","<cryptoapi>","0","2","1","2013-02-28 18:22:36","15142802","1","","1082063","","2013-02-28 17:48:46","2013-02-28 17:18:24",""
"29153790","How do I generate a SHA256withRSA signature with the Windows CryptoAPI?","<p>I need to sign some data with the SHA256withRSA algorithm (RSASSA-PKCS1-V1_5-SIGN with SHA-256 hash function) in Windows, and I'm having some validation errors. I was wondering if anyone has experience trying to do it.</p>

<p>The summary of what I'm doing:</p>

<pre><code>CryptAcquireContextW with MS_ENH_RSA_AES_PROV and PROV_RSA_AES
CryptImportKey after running CryptStringToBinary on a pem and applying to that CryptDecodeObjectEx with PKCS_RSA_PRIVATE_KEY
CryptCreateHash with CALG_SHA_256
CryptHashData and CryptSignHash using AT_KEYEXCHANGE to use the imported key (AT_SIGNATURE didn't work)
</code></pre>

<p>If you want the detailed version, it's here:</p>

<p>Create a CSP</p>

<pre><code>WCHAR const container[] = L""ContainerName"";
HCRYPTPROV provider;
CryptAcquireContextW(
    &amp;provider,
    container,
    MS_ENH_RSA_AES_PROV,
    PROV_RSA_AES,
    0));
</code></pre>

<p>Import my private key</p>

<pre><code>char const key_string[] = ""-----BEGIN RSA PRIVATE KEY-----""
                          ""&lt;base64 encoded key&gt;""
                          ""-----END RSA PRIVATE KEY-----"";
DWORD key_bytes_size;
BYTE* key_bytes;
CryptStringToBinaryA(
    key_string,
    0,
    CRYPT_STRING_BASE64HEADER,
    nullptr, &amp;key_bytes_size,
    nullptr, nullptr);
key_bytes = new BYTE[key_bytes_size];
CryptStringToBinaryA(
    key_string,
    0,
    CRYPT_STRING_BASE64HEADER,
    key_bytes, &amp;key_bytes_size,
    nullptr, nullptr);

DWORD key_blob_size;
BYTE* key_blob;
CryptDecodeObjectEx(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    PKCS_RSA_PRIVATE_KEY,
    key_bytes, key_bytes_size,
    0, nullptr, 
    nullptr, &amp;key_blob_size);
key_blob = new BYTE[key_blob_size];
CryptDecodeObjectEx(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    PKCS_RSA_PRIVATE_KEY,
    key_bytes, key_bytes_size,
    0, nullptr, 
    key_blob, &amp;key_blob_size);

HCRYPTKEY key_handle;
CryptImportKey(
    provider,  // The one I created before
    key_blob, key_blob_size, 
    nullptr, 0,
    &amp;key_handle);
</code></pre>

<p>(I hate that the API is so verbose, especially the two-step dance to ask for a length and then fill the buffer)
Once I've done this, I then hash and sign my data:</p>

<pre><code>char const data[] = ""Stuff to sign"";
HCRYPTHASH hash_handle;
CryptCreateHash(provider, CALG_SHA_256, 0, 0, &amp;hash_handle);

DWORD data_length = std::strlen(data);
CryptHashData(
    hash_handle,
    reinterpret_cast&lt;const BYTE*&gt;(data), data_length,
    0); 

DWORD signature_size;
BYTE* signature;
CryptSignHash(
    hash_handle,
    AT_KEYEXCHANGE,  // AT_SIGNATURE didn't work
    nullptr, 0,
    nullptr, signature_size);
signature = new BYTE[signature_size];
CryptSignHash(
    hash_handle,
    AT_KEYEXCHANGE,  // AT_SIGNATURE didn't work
    nullptr, 0,
    signature, signature_size);
</code></pre>

<p>Will this produce the kind of signature I want? Should I set different parameters for the AcquireContext call?</p>
","","1249","<c++><windows><cryptoapi>","2","","0","2016-09-27 22:20:32","","10","1","","","","2015-03-19 19:56:19",""
"7711960","CryptoAPI and XMLDSIG c, c++, delphi","<p>I'm trying to sign a xml document (http://www.w3.org/TR/xmldsig-core/) with an enveloped signature, I managed to calculate the signed info part but I'm struggling to get a meaningful result from the cryptoapi, unfortunately I have to stick to the crypto api (no external libs, no XmlXec). The signature method is rsa-sha1, the digest method is sha1.
Do you please have any working example of the construction of a xml signature in c, c++ or delphi?</p>
","<p>There is an article in the MSDN about XML signatures:
<a href=""http://msdn.microsoft.com/en-us/library/ms757845(v=VS.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/ms757845(v=VS.85).aspx</a></p>
","1213","<c++><c><delphi><cryptoapi>","2","0","1","2011-10-10 12:01:36","7712428","0","","246408","","2011-10-10 11:27:52","2011-10-10 11:13:02",""
"13001779","ASN1 formatted public key for CryptVerifyMessageSignatureWithKey?","<p>I´m trying to build a Sign/Decode pair of functions using Cripto API in C++.</p>

<p>The signing process seems to be ok, but I am having a problem getting the decode part to work.
Since I am not relying on certificates, I am using CryptSignMessageWithKey and CryptVerifyMessageSignatureWithKey. The call to CryptVerifyMessageSignatureWithKey, however, is returning a CRYPT_E_ASN1_BADTAG error. Looking for the problem on internet I found one or two discussions on similar topics, but I could not gather some solution from them.</p>

<p>All my code is Crypto API-based. The relevant (I think) parts of it are:</p>

<pre><code>CryptAcquireContext(&amp;hCryptProv, cryptContainerName, MS_ENHANCED_PROV, PROV_RSA_FULL, 0);

...

CryptGetUserKey(hCryptProv, AT_SIGNATURE, &amp;hKey);

...

CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbKeyBlob, &amp;dwKeyBlobLen);

...

sigParams.cbSize = sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA);
sigParams.dwMsgEncodingType = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
sigParams.hCryptProv = NULL;

publicKeyInfo.Algorithm.pszObjId = szOID_RSA_RC4;
publicKeyInfo.Algorithm.Parameters.cbData = 0;
publicKeyInfo.Algorithm.Parameters.pbData = NULL;
publicKeyInfo.PublicKey.pbData = pbKeyBlob;
publicKeyInfo.PublicKey.cbData = dwKeyBlobLen;
publicKeyInfo.PublicKey.cUnusedBits = 0;

...

// ***** ERROR: CRYPT_E_ASN1_BADTAG
CryptVerifyMessageSignatureWithKey(&amp;sigParams, &amp;publicKeyInfo, pbBuffer, dwCount, decodedBlob, &amp;dwCount);
</code></pre>

<p>Should I transform somehow the public key I got from CryptExportKey to ASN1, and store it in publicKeyInfo.PublicKey.pbData? If it is so, how do I do that?</p>

<p>What is the point I am missing here?</p>

<p>regards, and thanks in advance,
Dan</p>
","<p>Problem solved by preparing <code>CERT_PUBLIC_KEY_INFO</code> with <code>CryptExportPublicKeyInfo</code>, as suggested by Andrew7Webb in <a href=""http://social.msdn.microsoft.com/Forums/en-US/windowssecurity/thread/b4d1eb0e-d4c1-46f0-80f4-8110a0e26be9"" rel=""nofollow"">http://social.msdn.microsoft.com/Forums/en-US/windowssecurity/thread/b4d1eb0e-d4c1-46f0-80f4-8110a0e26be9</a>. </p>
","1213","<cryptoapi><asn.1>","1","0","1","2013-10-29 07:37:37","","1","","","","","2012-10-21 20:17:43",""
"23177753","Decrypt RSA from Windows Crypto API with OpenSSL/PHP Crypto Libs","<p>I've developed a C application with a component that Encrypts a small plaintext with an RSA 2048 key. The encryption is done using the Windows Enhanced crypto api. It seems to work perfectly and outputs a 128 byte Ciphertext to file.</p>

<p>I have no idea what sort of cryptographic form the Ciphertext is in (Whether it's padded, encoding etc) (I'm just importing the public key and encryptiong with it (No extra settings))</p>

<p>Anyway I need to be able to decrypt the Ciphertext back to plaintext using the private key with a php script.</p>

<p>I've tried using openssl over command line during testing but I got a data greater than mod len error.</p>

<p>Are there any transformations I need to do with the Ciphertext before trying to decrypt it or any settings I need to specify with the openssl_private_decrypt. (I currently have the private key in pem format but I can convert it to many more formats)</p>

<p>Also any suggestions for other php libraries that might be more effective for this than openssl would be appreciated.</p>

<p>Thanks.</p>
","<p>If you want to decrypt the data using OpenSSL, reverse the data byte by byte. This is because OpenSSL considers them as big endian.</p>

<p>This <a href=""https://stackoverflow.com/questions/15899094/md5-sha1-hash-using-cryptoapi"">question</a> may help you. I faced similar problem for calculating hash. When I reversed the byte order, it works perfectly in OpenSSL. So, this might help you.</p>
","1185","<php><winapi><encryption><openssl><cryptoapi>","0","1","1","2014-04-21 03:30:51","","2","","","","","2014-04-20 02:21:36",""
"20912418","Can not import RSA keys generated with php openssl to windows CryptoAPI","<p>have problems importing keys generated with php openssl to CryptoAPI</p>

<p>I successfully create key pair in php, crypt/decrypt a string with it - no problems</p>

<pre><code>&lt;?php
$privateKey = openssl_pkey_new(array(
    'private_key_bits' =&gt; 1024,
    'private_key_type' =&gt; OPENSSL_KEYTYPE_RSA));

openssl_pkey_export($privateKey, $s);

$info = openssl_pkey_get_details($privateKey);
$public = openssl_pkey_get_public($info['key']);
$private = openssl_pkey_get_private($s);

$s = '';
$s1 = '';
openssl_public_encrypt('bla bla bla', $s, $public);
openssl_private_decrypt($s, $s1, $private);
echo('$s.'&lt;br&gt;'.$s1);
?&gt;
</code></pre>

<p>Then I wrote a program in Delphi which should import private and public keys into CryptoAPI. I found some example private RSA key in internet and it imports with my code perfectly, but when I try to import a key generated with my php code it fails on <strong>CryptDecodeObjectEx</strong> function with <strong>""asn1 bad tag value met""</strong> error. Keys are quite similar except that php generates slightly longer key than I found in internet example, though they are both 1024 bits...</p>

<pre><code>php generated key (does not work):
priv_key: string = 
    'MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAN/NfimL4/8Pmp7+' +
    'j299I7yaT6SpF1jwrFlwlLLjDibehqjBOcao+CaLK8Se+hysqZGGwr2walUprGxG' +
    'Z5hnfCQCOchbTs5CiXnBCIX1aPKaRMx/SX3b4moT+wnkLrGOnHnUM+2c+jqZUjdh' +
    '06hwlv1LCVcCtTW9NWU3Qi3G+r9bAgMBAAECgYBjjuSK0uJP+r8L764bKI4XPoYj' +
    'd90dAaOJ/h0IHx2SiPdaZuqux0fszYhg5V/aFa0xQcOr4qjKzckYOZGoKJD+FtCq' +
    'bNBEg1eZsKWYVJvTO8N2H0Lx4VSCiG7PjiqLGFfsmXZDXLPXhzsuCOUACmfcVoqh' +
    'NlXOEAKtaTZI+uAakQJBAPB8sIQN7xTgCQcP2F8IbWR3VRAlnr4LWZQ5k96uxWjC' +
    'wC6R8c7NnvUj+Fzs3XMXR8e3aTRme9OyHAWy7ReO+scCQQDuPUjBXXxuYGQq4ho5' +
    'Pq4QEtHNKECDNDtKBaLvr9r7aXYOfMM/XiXqFqHAZqcrTRtMXD1sUhg4o+vIYkrg' +
    '5qLNAkEA6+Z0RGVitAh78ohxh+89V4LTV05/5A5AJe1BBvxLu1LmsAgLuf/rwK4z' +
    'L/xN0lrw15EryvII34VkhZaZijV/+wJAfX52xrTSCOppmVVE7wafdgQT0/fyE6r9' +
    '2D4j2BJQTcL91x/NUaHsYuTNC6aHRH33dT/ZcyfDboKafxGX0+RpuQJBAMdPGszm' +
    'JYhD9F8kz+Q9R04iuwupLxUU6Q60yVVZxRDBQ7OLxBQwrHa2WQ0TA8WC73TMNaph' +
    'VN4ayHJHK8shjt0=';

example key (works fine and it is shorter than php key):
priv_key: string =
    'MIICXAIBAAKBgQCf6YAJOSBYPve1jpYDzq+w++8YVoATI/YCi/RKZaQk+l2ZfoUQ' +
    'g0qrYrfkzeoOa/qd5VLjTTvHEgwXnlDXMfo+vSgxosUxDOZXMTBqJGOViv5K2QBv' +
    'k8A1wi4k8tuo/7OWya29HvcfavUk3YXaV2YFe8V6ssaZjNcVWmDdjqNkXwIDAQAB' +
    'AoGALrd+ijNAOcebglT3ioE1XpUbUpbir7TPyAqvAZUUESF7er41jY9tnwgmBRgL' +
    'Cs+M1dgLERCdKBkjozrDDzswifFQmq6PrmYrBkFFqCoLJwepSYdWnK1gbZ/d43rR' +
    '2sXzSGZngscx0CxO7KZ7xUkwENGd3+lKXV7J6/vgzJ4XnkECQQDTP6zWKT7YDckk' +
    'We04hbhHyBuNOW068NgUUvoZdBewerR74MJx6nz28Tp+DeNvc0EveiQxsEnbV8u+' +
    'NRkX5y0xAkEAwcnEAGBn5kJd6SpU0ALA9XEpUv7tHTAGQYgCRbfTT59hhOq6I22A' +
    'ivjOCNG9c6E7EB2kcPVGuCpYUhy7XBIGjwJAK5lavKCqncDKoLwGn8HJdNcyCIWv' +
    'q5iFoDw37gTt1ricg2yx9PzmabkDz3xiUmBBNeFJkw/FToXiQRGIakyGIQJAJIem' +
    'PPPvYgZssYFbT4LVYO8d/Rk1FWVyKHQ9CWtnmADRXz7oK7l+m7PfEuaGsf9YpOcR' +
    'koGJ/TluQLxNzUNQnQJBAImwr/yYFenIx3HQ6UX/fCt6qpGDv0VfOLyR64MNeegx' +
    'o7DhNxHbFkIGzk4lKhMKcHKDrawZbdJtS9ie2geSwVQ=';
</code></pre>

<p>Code in Delphi which imports key:</p>

<pre><code>var
  dwBufferLen, cbKeyBlob, i: longword;
  pbBuffer, pbKeyBlob: pointer;
  hProv: HCRYPTPROV;
  hKey: HCRYPTKEY;
begin
  hProv := 0;
  hKey := 0;

  // convert key string to a binary
  if not(CryptStringToBinary(PWideChar(priv_key), 0, 1, nil, @dwBufferLen, nil, nil)) then
    exit;

  GetMem(pbBuffer, dwBufferLen);
  if not(CryptStringToBinary(PWideChar(priv_key), 0, 1, pbBuffer, @dwBufferLen, nil, nil)) then
    exit;

  // convert binary to a key blob
  if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
     PKCS_RSA_PRIVATE_KEY, pbBuffer, dwBufferLen, 0, nil, nil, @cbKeyBlob)) then
    begin
      // first key generates error here
      ShowMessage(SysErrorMessage(GetLastError));
      exit;
    end;

  GetMem(pbKeyBlob, cbKeyBlob);
  if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
     PKCS_RSA_PRIVATE_KEY, pbBuffer, dwBufferLen, 0, nil, pbKeyBlob, @cbKeyBlob)) then
    exit;

  if not(CryptAcquireContext(@hProv, nil, MS_ENHANCED_PROV, PROV_RSA_FULL,
     CRYPT_VERIFYCONTEXT)) then
    exit;

  if not(CryptImportKey(hProv, pbKeyBlob, cbKeyBlob, 0, 0, @hKey)) then
    exit;

  //...

  if hKey &lt;&gt; 0 then
    CryptDestroyKey(hKey);
  if hProv &lt;&gt; 0 then
    CryptReleaseContext(hProv, 0); 
end;
</code></pre>
","<p>I found a solution.<br>
PHP generates keys with extra fields in ASN.1 format compare to CryptoAPI keys.<br><br>
1. I decoded base64 key into a binary file with help of this tool: <a href=""http://www.opinionatedgeek.com/dotnet/tools/Base64Decode/Default.aspx"" rel=""nofollow"">base64 decoder</a><br><br>
2. Then I just cut from this file first 26 bytes to the next header sequence starting from something like: ""30 xx xx"" and saved it.<br><br>
3. And encoded this file back to base64 with: <a href=""http://www.opinionatedgeek.com/dotnet/tools/Base64Encode/Default.aspx"" rel=""nofollow"">base64 encoder</a></p>

<p>Now I can import public and private keys into CryptoAPI without problems with next code:</p>

<pre><code>// key types
const
  PKCS_RSA_PRIVATE_KEY = LPCSTR(43);
  PKCS_RSA_PUBLIC_KEY = LPCSTR(19);

function ImportKey(hProv: HCRYPTPROV; KeyType: pointer; key: string): hKey;
var
  BuffSize, BlobSize: longword;
  buff, blob: pointer;
begin
  result := 0;
  buff := nil;
  blob := nil;

  try
    if not(CryptStringToBinary(PWideChar(key), 0, 1, nil, @BuffSize, nil, nil)) then
      exit;

    GetMem(buff, BuffSize);
    if not(CryptStringToBinary(PWideChar(key), 0, 1, buff, @BuffSize, nil, nil)) then
      exit;

    if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
       KeyType, buff, BuffSize, 0, nil, nil, @BlobSize)) then
      exit;

    GetMem(blob, BlobSize);
    if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
       KeyType, buff, BuffSize, 0, nil, blob, @BlobSize)) then
      exit;

    if not(CryptImportKey(hProv, blob, BlobSize, 0, 0, @result)) then
      exit;

  finally
    if buff &lt;&gt; nil then
      FreeMem(buff);
    if blob &lt;&gt; nil then
      FreeMem(blob);
  end;
end;
</code></pre>
","1183","<php><delphi><encryption><openssl><cryptoapi>","1","1","2","2014-05-23 20:04:00","20937930","2","","","","","2014-01-03 20:47:28",""
"20912418","Can not import RSA keys generated with php openssl to windows CryptoAPI","<p>have problems importing keys generated with php openssl to CryptoAPI</p>

<p>I successfully create key pair in php, crypt/decrypt a string with it - no problems</p>

<pre><code>&lt;?php
$privateKey = openssl_pkey_new(array(
    'private_key_bits' =&gt; 1024,
    'private_key_type' =&gt; OPENSSL_KEYTYPE_RSA));

openssl_pkey_export($privateKey, $s);

$info = openssl_pkey_get_details($privateKey);
$public = openssl_pkey_get_public($info['key']);
$private = openssl_pkey_get_private($s);

$s = '';
$s1 = '';
openssl_public_encrypt('bla bla bla', $s, $public);
openssl_private_decrypt($s, $s1, $private);
echo('$s.'&lt;br&gt;'.$s1);
?&gt;
</code></pre>

<p>Then I wrote a program in Delphi which should import private and public keys into CryptoAPI. I found some example private RSA key in internet and it imports with my code perfectly, but when I try to import a key generated with my php code it fails on <strong>CryptDecodeObjectEx</strong> function with <strong>""asn1 bad tag value met""</strong> error. Keys are quite similar except that php generates slightly longer key than I found in internet example, though they are both 1024 bits...</p>

<pre><code>php generated key (does not work):
priv_key: string = 
    'MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAN/NfimL4/8Pmp7+' +
    'j299I7yaT6SpF1jwrFlwlLLjDibehqjBOcao+CaLK8Se+hysqZGGwr2walUprGxG' +
    'Z5hnfCQCOchbTs5CiXnBCIX1aPKaRMx/SX3b4moT+wnkLrGOnHnUM+2c+jqZUjdh' +
    '06hwlv1LCVcCtTW9NWU3Qi3G+r9bAgMBAAECgYBjjuSK0uJP+r8L764bKI4XPoYj' +
    'd90dAaOJ/h0IHx2SiPdaZuqux0fszYhg5V/aFa0xQcOr4qjKzckYOZGoKJD+FtCq' +
    'bNBEg1eZsKWYVJvTO8N2H0Lx4VSCiG7PjiqLGFfsmXZDXLPXhzsuCOUACmfcVoqh' +
    'NlXOEAKtaTZI+uAakQJBAPB8sIQN7xTgCQcP2F8IbWR3VRAlnr4LWZQ5k96uxWjC' +
    'wC6R8c7NnvUj+Fzs3XMXR8e3aTRme9OyHAWy7ReO+scCQQDuPUjBXXxuYGQq4ho5' +
    'Pq4QEtHNKECDNDtKBaLvr9r7aXYOfMM/XiXqFqHAZqcrTRtMXD1sUhg4o+vIYkrg' +
    '5qLNAkEA6+Z0RGVitAh78ohxh+89V4LTV05/5A5AJe1BBvxLu1LmsAgLuf/rwK4z' +
    'L/xN0lrw15EryvII34VkhZaZijV/+wJAfX52xrTSCOppmVVE7wafdgQT0/fyE6r9' +
    '2D4j2BJQTcL91x/NUaHsYuTNC6aHRH33dT/ZcyfDboKafxGX0+RpuQJBAMdPGszm' +
    'JYhD9F8kz+Q9R04iuwupLxUU6Q60yVVZxRDBQ7OLxBQwrHa2WQ0TA8WC73TMNaph' +
    'VN4ayHJHK8shjt0=';

example key (works fine and it is shorter than php key):
priv_key: string =
    'MIICXAIBAAKBgQCf6YAJOSBYPve1jpYDzq+w++8YVoATI/YCi/RKZaQk+l2ZfoUQ' +
    'g0qrYrfkzeoOa/qd5VLjTTvHEgwXnlDXMfo+vSgxosUxDOZXMTBqJGOViv5K2QBv' +
    'k8A1wi4k8tuo/7OWya29HvcfavUk3YXaV2YFe8V6ssaZjNcVWmDdjqNkXwIDAQAB' +
    'AoGALrd+ijNAOcebglT3ioE1XpUbUpbir7TPyAqvAZUUESF7er41jY9tnwgmBRgL' +
    'Cs+M1dgLERCdKBkjozrDDzswifFQmq6PrmYrBkFFqCoLJwepSYdWnK1gbZ/d43rR' +
    '2sXzSGZngscx0CxO7KZ7xUkwENGd3+lKXV7J6/vgzJ4XnkECQQDTP6zWKT7YDckk' +
    'We04hbhHyBuNOW068NgUUvoZdBewerR74MJx6nz28Tp+DeNvc0EveiQxsEnbV8u+' +
    'NRkX5y0xAkEAwcnEAGBn5kJd6SpU0ALA9XEpUv7tHTAGQYgCRbfTT59hhOq6I22A' +
    'ivjOCNG9c6E7EB2kcPVGuCpYUhy7XBIGjwJAK5lavKCqncDKoLwGn8HJdNcyCIWv' +
    'q5iFoDw37gTt1ricg2yx9PzmabkDz3xiUmBBNeFJkw/FToXiQRGIakyGIQJAJIem' +
    'PPPvYgZssYFbT4LVYO8d/Rk1FWVyKHQ9CWtnmADRXz7oK7l+m7PfEuaGsf9YpOcR' +
    'koGJ/TluQLxNzUNQnQJBAImwr/yYFenIx3HQ6UX/fCt6qpGDv0VfOLyR64MNeegx' +
    'o7DhNxHbFkIGzk4lKhMKcHKDrawZbdJtS9ie2geSwVQ=';
</code></pre>

<p>Code in Delphi which imports key:</p>

<pre><code>var
  dwBufferLen, cbKeyBlob, i: longword;
  pbBuffer, pbKeyBlob: pointer;
  hProv: HCRYPTPROV;
  hKey: HCRYPTKEY;
begin
  hProv := 0;
  hKey := 0;

  // convert key string to a binary
  if not(CryptStringToBinary(PWideChar(priv_key), 0, 1, nil, @dwBufferLen, nil, nil)) then
    exit;

  GetMem(pbBuffer, dwBufferLen);
  if not(CryptStringToBinary(PWideChar(priv_key), 0, 1, pbBuffer, @dwBufferLen, nil, nil)) then
    exit;

  // convert binary to a key blob
  if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
     PKCS_RSA_PRIVATE_KEY, pbBuffer, dwBufferLen, 0, nil, nil, @cbKeyBlob)) then
    begin
      // first key generates error here
      ShowMessage(SysErrorMessage(GetLastError));
      exit;
    end;

  GetMem(pbKeyBlob, cbKeyBlob);
  if not(CryptDecodeObjectEx(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
     PKCS_RSA_PRIVATE_KEY, pbBuffer, dwBufferLen, 0, nil, pbKeyBlob, @cbKeyBlob)) then
    exit;

  if not(CryptAcquireContext(@hProv, nil, MS_ENHANCED_PROV, PROV_RSA_FULL,
     CRYPT_VERIFYCONTEXT)) then
    exit;

  if not(CryptImportKey(hProv, pbKeyBlob, cbKeyBlob, 0, 0, @hKey)) then
    exit;

  //...

  if hKey &lt;&gt; 0 then
    CryptDestroyKey(hKey);
  if hProv &lt;&gt; 0 then
    CryptReleaseContext(hProv, 0); 
end;
</code></pre>
","<p>I encountered a similar situation where I was generating keys using PHP5's openssl API, and importing them using Windows CryptoAPI, except I'm using C++.</p>

<p>The 26 byte offset fixed importing private keys for me, but I found the offset for public keys to be 24 bytes. As Mike K. pointed out, you need to offset until the next header sequence, I found that the first two bytes of the sequence will be ""30 82"".  So if you run into a situation where 24 bytes or 26 bytes doesn't work, check out the key in a hex editor and look for those bytes.</p>

<p>Here is the code I had success with:</p>

<pre><code>DWORD PEMToPublicKeyBlob(char* keyData, DWORD keyDataLen, BYTE** publicKeyBlob, DWORD* length)
{
    DWORD ret = ERROR_SUCCESS;
    wchar_t message[256];

    BYTE* der = NULL;
    DWORD derLen = 0;

    unsigned int offset = 0;
    // if the header is this, and not -----BEGIN RSA PUBLIC KEY----- the key was created on the webserver
    if(strstr(keyData, ""-----BEGIN PUBLIC KEY-----"" ))
        offset = 24;        // php puts 24 extra bytes in the header that screws up the import

    // Convert from PEM format to DER format
    // get length
    if (!CryptStringToBinaryA(keyData, keyDataLen, CRYPT_STRING_ANY, NULL, &amp;derLen, NULL, NULL))
    {
        ret = GetLastError();
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: CryptStringToBinaryA(len) failed %u"", ret);
        writeToLog(message);
        goto out;
    }

    der = new BYTE[derLen];
    if(!der)
    {
        ret = ERROR_NOT_ENOUGH_MEMORY;
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: der blob allocation failed %u"", ret);
        writeToLog(message);
        goto out;
    }
    if (!CryptStringToBinaryA(keyData, keyDataLen, CRYPT_STRING_ANY, der, &amp;derLen, NULL, NULL))
    {
        ret = GetLastError();
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: CryptStringToBinaryA failed %u"", ret);
        writeToLog(message);
        goto out;
    }

    // Decode from DER format to PUBLICKEYBLOB
    // get length
    *length = 0;
    if (!CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                                der + offset, derLen - offset, 0, NULL, NULL, length))
    {
        ret = GetLastError();
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: CryptDecodeObjectEx(len) failed %u"", ret);
        writeToLog(message);
        goto out;
    }

    *publicKeyBlob = new BYTE[*length];
    if(!*publicKeyBlob)
    {
        ret = ERROR_NOT_ENOUGH_MEMORY;
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: publickey blob allocation failed %u"", ret);
        writeToLog(message);
        goto out;
    }

    if (!CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB,
                                der + offset, derLen - offset, 0, NULL, *publicKeyBlob, length))
    {
        ret = GetLastError();
        swprintf_s(message, 256, L""PEMToPublicKeyBlob: CryptDecodeObjectEx failed %u"", ret);
        writeToLog(message);
        goto out;
    }
out:
    if(der) delete[] der;
    return ret;
}
</code></pre>

<p>The code for importing private keys is pretty much the same except you specify PKCS_RSA_PRIVATE_KEY instead of RSA_CSP_PUBLICKEYBLOB.</p>
","1183","<php><delphi><encryption><openssl><cryptoapi>","1","1","2","2014-05-23 20:04:00","20937930","2","","","","","2014-01-03 20:47:28",""
"29257068","Openssl and Windows CryptoAPI compatibility issue","<p>I have problem in encrypted communication between windows application and server app. Client app is running at Windows, written in C and uses CryptoAPI. Server application uses PHP and Openssl extension. As cipher algorithm AES-256-CBC was chosen. Using the same algorithm Openssl and CryptoAPI produces different results. The same problem I had with RC2-CBC algorithm. This online tool <a href=""http://asecuritysite.com/Encryption/openssl"" rel=""nofollow"">http://asecuritysite.com/Encryption/openssl</a> generates the same result as openssl, so I conclude that bug in C code.</p>

<p>PHP code:</p>

<pre><code>&lt;?php
//$flag = OPENSSL_RAW_DATA;
$flag = false;
//this string will encode
$dataString = 'some data string';
$pass = ""1234567812345678"";
$method = ""aes-256-cbc"";

$iv = ""Zievrs8NZievrs8N"";
echo ""original:\n"";
var_dump($dataString);
$encryptedMessage = openssl_encrypt($dataString, $method, $pass, $flag, $iv);
echo ""after encrypt:\n"";
var_dump($encryptedMessage);
echo ""vector:\n"";
var_dump($iv);
$decryptedMessage = openssl_decrypt($encryptedMessage, $method, $pass, $flag, $iv);
echo ""after decrypt:\n"";
var_dump($decryptedMessage);
</code></pre>

<p>Output:</p>

<pre><code>original:
string(16) ""some data string""
after encrypt:
string(44) ""9O8UAaRRCfneeRbRCeiYi9nOM8F2KA6gtkAsvPliUdA=""
vector:
string(16) ""Zievrs8NZievrs8N""
after decrypt:
string(16) ""some data string""
</code></pre>

<p>C code:</p>

<pre><code>BOOL SetKey(BYTE* szKey, DWORD dwKeySize, HCRYPTPROV* m_hProv, HCRYPTHASH* m_hHash, HCRYPTKEY* m_hKey)
{
    BOOL m_fOK= TRUE;
    if (*m_hProv == 0) {
        m_fOK = CryptAcquireContextA(m_hProv, NULL, 
            NULL, //MS_DEF_PROV_A, 
            PROV_RSA_AES, 
            CRYPT_VERIFYCONTEXT 
        );
    }
    if (m_fOK &amp;&amp; (*m_hHash != 0)) {
        m_fOK = CryptDestroyHash(*m_hHash); 
        m_hHash = 0;
    }
    if (m_fOK &amp;&amp; (*m_hHash == 0)) {
        m_fOK = CryptCreateHash(*m_hProv, CALG_SHA_256, 0, 0, m_hHash);
    }
    if (m_fOK) {
        m_fOK = CryptHashData(*m_hHash, (BYTE*)szKey, dwKeySize, 0);
    }
    if (m_fOK) {
        m_fOK = CryptDeriveKey(*m_hProv, CALG_AES_256, *m_hHash, CRYPT_EXPORTABLE | CRYPT_NO_SALT, m_hKey);
    }
    if (m_fOK) {
        DWORD mode = CRYPT_MODE_CBC;
        m_fOK = CryptSetKeyParam(*m_hKey, KP_MODE, (BYTE*)&amp;mode, 0);
    }
    if (m_fOK) {
        BYTE iv[] = {'Z','i','e','v','r','s','8','N','Z','i','e','v','r','s','8','N',0};
        m_fOK = CryptSetKeyParam(*m_hKey, KP_IV, (BYTE*)iv, 0);
    }

    return m_fOK;
}

BOOL EncryptDecrypt(BYTE* pData, BYTE** pRes, DWORD* dwDataLen, BYTE* pKey, DWORD dwKeySize, BOOL fEncrypt)
{
    HCRYPTPROV m_hProv = 0;
    HCRYPTHASH m_hHash = 0;
    HCRYPTKEY  m_hKey  = 0;

    BOOL m_fOK= TRUE;
    m_fOK = SetKey(pKey, dwKeySize, &amp;m_hProv, &amp;m_hHash, &amp;m_hKey);
    if (fEncrypt) {
        DWORD dwTotalBufferSize = 0;
        DWORD dwNewLen = *dwDataLen;
        if((m_fOK = CryptEncrypt(m_hKey, 0, TRUE, 0, NULL, &amp;dwNewLen, dwTotalBufferSize))) {
            *pRes = (BYTE*)malloc(dwNewLen);
            memcpy(*pRes, pData, *dwDataLen);
            dwTotalBufferSize = dwNewLen;
            if(!(m_fOK = CryptEncrypt(m_hKey, 0, TRUE, 0, *pRes, dwDataLen, dwTotalBufferSize))) {
                free(*pRes);
                *pRes = NULL;
                *dwDataLen = 0;
            }
        }
    }
    else  {
        *pRes = (BYTE*)malloc(*dwDataLen);
        memcpy(*pRes, pData, *dwDataLen);
        if(!(m_fOK = CryptDecrypt(m_hKey, 0, TRUE, 0, *pRes, dwDataLen))) {
            DWORD err = GetLastError();
            char msg[100];
            wsprintfA(msg, ""err = %d\n"", err);
            OutputDebugStringA(msg);
            free(*pRes);
            *pRes = NULL;
            *dwDataLen = 0;
        }
    }

    if (m_hKey)  CryptDestroyKey(m_hKey); 
    if (m_hHash) CryptDestroyHash(m_hHash); 
    if (m_hProv) CryptReleaseContext(m_hProv, 0); 

    return m_fOK;
}

void main() {
    const char* data = ""some data string"";
    BYTE* res = NULL;
    DWORD len = strlen(data);
    EncryptDecrypt((BYTE*)data, &amp;res, &amp;len, (BYTE*)""1234567812345678"", 16, TRUE);
    size_t len_en = 0;
    char* base64 = base64_encode(res, len, &amp;len_en);
    printf(""base64 = %s\n"", base64);
}
</code></pre>

<p>Output:</p>

<pre><code>base64 = miFMwk4/ZwjMLsnV4Po9UdWxix32TrK5BcSgSKYr384=
</code></pre>
","<p>Encrypted output is different. It means that key which is ultimately used is different or data is different. But data is same, hence key must be different.</p>

<p>It means in the process of key generation, something is different. It might be possible that OpenSSL may be using some other key deriving function which is not visible here. Try to use some standard algorithm for key generation. Instead of hashing, try not to use hash.</p>
","1171","<php><c><openssl><cryptoapi><mismatch>","0","0","2","2015-03-27 16:20:02","29272138","3","","","","","2015-03-25 13:28:42",""
"29257068","Openssl and Windows CryptoAPI compatibility issue","<p>I have problem in encrypted communication between windows application and server app. Client app is running at Windows, written in C and uses CryptoAPI. Server application uses PHP and Openssl extension. As cipher algorithm AES-256-CBC was chosen. Using the same algorithm Openssl and CryptoAPI produces different results. The same problem I had with RC2-CBC algorithm. This online tool <a href=""http://asecuritysite.com/Encryption/openssl"" rel=""nofollow"">http://asecuritysite.com/Encryption/openssl</a> generates the same result as openssl, so I conclude that bug in C code.</p>

<p>PHP code:</p>

<pre><code>&lt;?php
//$flag = OPENSSL_RAW_DATA;
$flag = false;
//this string will encode
$dataString = 'some data string';
$pass = ""1234567812345678"";
$method = ""aes-256-cbc"";

$iv = ""Zievrs8NZievrs8N"";
echo ""original:\n"";
var_dump($dataString);
$encryptedMessage = openssl_encrypt($dataString, $method, $pass, $flag, $iv);
echo ""after encrypt:\n"";
var_dump($encryptedMessage);
echo ""vector:\n"";
var_dump($iv);
$decryptedMessage = openssl_decrypt($encryptedMessage, $method, $pass, $flag, $iv);
echo ""after decrypt:\n"";
var_dump($decryptedMessage);
</code></pre>

<p>Output:</p>

<pre><code>original:
string(16) ""some data string""
after encrypt:
string(44) ""9O8UAaRRCfneeRbRCeiYi9nOM8F2KA6gtkAsvPliUdA=""
vector:
string(16) ""Zievrs8NZievrs8N""
after decrypt:
string(16) ""some data string""
</code></pre>

<p>C code:</p>

<pre><code>BOOL SetKey(BYTE* szKey, DWORD dwKeySize, HCRYPTPROV* m_hProv, HCRYPTHASH* m_hHash, HCRYPTKEY* m_hKey)
{
    BOOL m_fOK= TRUE;
    if (*m_hProv == 0) {
        m_fOK = CryptAcquireContextA(m_hProv, NULL, 
            NULL, //MS_DEF_PROV_A, 
            PROV_RSA_AES, 
            CRYPT_VERIFYCONTEXT 
        );
    }
    if (m_fOK &amp;&amp; (*m_hHash != 0)) {
        m_fOK = CryptDestroyHash(*m_hHash); 
        m_hHash = 0;
    }
    if (m_fOK &amp;&amp; (*m_hHash == 0)) {
        m_fOK = CryptCreateHash(*m_hProv, CALG_SHA_256, 0, 0, m_hHash);
    }
    if (m_fOK) {
        m_fOK = CryptHashData(*m_hHash, (BYTE*)szKey, dwKeySize, 0);
    }
    if (m_fOK) {
        m_fOK = CryptDeriveKey(*m_hProv, CALG_AES_256, *m_hHash, CRYPT_EXPORTABLE | CRYPT_NO_SALT, m_hKey);
    }
    if (m_fOK) {
        DWORD mode = CRYPT_MODE_CBC;
        m_fOK = CryptSetKeyParam(*m_hKey, KP_MODE, (BYTE*)&amp;mode, 0);
    }
    if (m_fOK) {
        BYTE iv[] = {'Z','i','e','v','r','s','8','N','Z','i','e','v','r','s','8','N',0};
        m_fOK = CryptSetKeyParam(*m_hKey, KP_IV, (BYTE*)iv, 0);
    }

    return m_fOK;
}

BOOL EncryptDecrypt(BYTE* pData, BYTE** pRes, DWORD* dwDataLen, BYTE* pKey, DWORD dwKeySize, BOOL fEncrypt)
{
    HCRYPTPROV m_hProv = 0;
    HCRYPTHASH m_hHash = 0;
    HCRYPTKEY  m_hKey  = 0;

    BOOL m_fOK= TRUE;
    m_fOK = SetKey(pKey, dwKeySize, &amp;m_hProv, &amp;m_hHash, &amp;m_hKey);
    if (fEncrypt) {
        DWORD dwTotalBufferSize = 0;
        DWORD dwNewLen = *dwDataLen;
        if((m_fOK = CryptEncrypt(m_hKey, 0, TRUE, 0, NULL, &amp;dwNewLen, dwTotalBufferSize))) {
            *pRes = (BYTE*)malloc(dwNewLen);
            memcpy(*pRes, pData, *dwDataLen);
            dwTotalBufferSize = dwNewLen;
            if(!(m_fOK = CryptEncrypt(m_hKey, 0, TRUE, 0, *pRes, dwDataLen, dwTotalBufferSize))) {
                free(*pRes);
                *pRes = NULL;
                *dwDataLen = 0;
            }
        }
    }
    else  {
        *pRes = (BYTE*)malloc(*dwDataLen);
        memcpy(*pRes, pData, *dwDataLen);
        if(!(m_fOK = CryptDecrypt(m_hKey, 0, TRUE, 0, *pRes, dwDataLen))) {
            DWORD err = GetLastError();
            char msg[100];
            wsprintfA(msg, ""err = %d\n"", err);
            OutputDebugStringA(msg);
            free(*pRes);
            *pRes = NULL;
            *dwDataLen = 0;
        }
    }

    if (m_hKey)  CryptDestroyKey(m_hKey); 
    if (m_hHash) CryptDestroyHash(m_hHash); 
    if (m_hProv) CryptReleaseContext(m_hProv, 0); 

    return m_fOK;
}

void main() {
    const char* data = ""some data string"";
    BYTE* res = NULL;
    DWORD len = strlen(data);
    EncryptDecrypt((BYTE*)data, &amp;res, &amp;len, (BYTE*)""1234567812345678"", 16, TRUE);
    size_t len_en = 0;
    char* base64 = base64_encode(res, len, &amp;len_en);
    printf(""base64 = %s\n"", base64);
}
</code></pre>

<p>Output:</p>

<pre><code>base64 = miFMwk4/ZwjMLsnV4Po9UdWxix32TrK5BcSgSKYr384=
</code></pre>
","<p>I finally got proper results from CryptoAPI by importing key as PLAINTEXTBLOB.</p>

<p>Here is not final, but workable fixes to SetKey function.</p>

<pre><code>#include &lt;WinCrypt.h&gt;

typedef struct {
  BLOBHEADER hdr;
  DWORD      dwKeySize;
  BYTE       rgbKeyData[16];
} PLAINTEXTKEYBLOB_t;

BOOL SetKey(BYTE* szKey, DWORD dwKeySize, HCRYPTPROV* m_hProv, HCRYPTHASH* m_hHash, HCRYPTKEY* m_hKey)
{
    BOOL m_fOK= TRUE;
    if (*m_hProv == 0) {
        m_fOK = CryptAcquireContextW(m_hProv, NULL, 
            MS_ENH_RSA_AES_PROV, //MS_DEF_PROV_A, 
            PROV_RSA_AES, 
            CRYPT_NEWKEYSET | CRYPT_VERIFYCONTEXT 
        );
    }
    if (m_fOK &amp;&amp; (*m_hHash != 0)) {
        m_fOK = CryptDestroyHash(*m_hHash); 
        m_hHash = 0;
    }

    if(m_fOK) {
        BYTE key[] = {0x06, 0xa9, 0x21, 0x40, 0x36, 0xb8, 0xa1, 0x5b, 0x51, 0x2e, 0x03, 0xd5, 0x34, 0x12, 0x00, 0x06};

        PLAINTEXTKEYBLOB_t blob;
        blob.hdr.bType = PLAINTEXTKEYBLOB;
        blob.hdr.bVersion = 2;
        blob.hdr.reserved = 0;
        blob.hdr.aiKeyAlg = CALG_AES_128;
        blob.dwKeySize = 16;
        for(int i=0; i&lt;16; i++) {
            //blob.rgbKeyData[16-1-i] = key[i];
            blob.rgbKeyData[i] = key[i];
        }
        m_fOK = CryptImportKey(*m_hProv, (BYTE*)&amp;blob, sizeof(PLAINTEXTKEYBLOB_t), 0, NULL, m_hKey);
    }

    if (m_fOK) {
        DWORD mode = CRYPT_MODE_CBC;
        m_fOK = CryptSetKeyParam(*m_hKey, KP_MODE, (BYTE*)&amp;mode, 0);
    }
    if (m_fOK) {
        DWORD mode = 0;
        DWORD dwDataLen = sizeof(mode);
        m_fOK = CryptGetKeyParam(*m_hKey, KP_PADDING, (BYTE*)&amp;mode, &amp;dwDataLen, 0);
        mode = 0;
        //m_fOK = CryptSetKeyParam(*m_hKey, KP_PADDING, (BYTE*)&amp;mode, 0);
    }
    if (m_fOK) {
        BYTE iv[] = {0x3d, 0xaf, 0xba, 0x42, 0x9d, 0x9e, 0xb4, 0x30, 0xb4, 0x22, 0xda, 0x80, 0x2c, 0x9f, 0xac, 0x41};
        m_fOK = CryptSetKeyParam(*m_hKey, KP_IV, (BYTE*)iv, 0);
    }

    return m_fOK;
}
</code></pre>
","1171","<php><c><openssl><cryptoapi><mismatch>","0","0","2","2015-03-27 16:20:02","29272138","3","","","","","2015-03-25 13:28:42",""
"25609064","AES/Rijndael in C++ Microsoft CryptoAPI","<p>How can I convert the following cryptography code (VB.NET 4.0) to the C++ equivalent one, using Microsoft CryptoAPI (CryptDeriveKey, BCrypt[...] functions, CryptAcquireContext, etc.)? (I haven't found a single article on the Internet describing AES using Microsoft CryptoAPI...)</p>

<pre><code>Dim Key(31) As Byte
Dim IV(15) As Byte

Array.Copy(SomeByteArray, IV, 16)
Array.Copy((New SHA512Managed).ComputeHash(SomeByteArray), Key, 32)

Using AESEncr As New RijndaelManaged() With {.Padding = PaddingMode.ISO10126}

    FinalEncrypted = AESEncr.CreateEncryptor(Key, IV).TransformFinalBlock(AnotherByteArray, 0, AnotherByteArray.GetLength(0))

End Using
</code></pre>

<p>and the decrypting one:</p>

<pre><code>Dim Key(31) As Byte
Dim IV(15) As Byte

Array.Copy(SomeByteArray, IV, 16)
Array.Copy((New SHA512Managed).ComputeHash(SomeByteArray), Key, 32)

Using AESEncr As New RijndaelManaged() With {.Padding = PaddingMode.ISO10126}

    FinalDecrypted = AESEncr.CreateDecryptor(Key, IV).TransformFinalBlock(FinalEncrypted, 0, FinalEncrypted.GetLength(0))

End Using
</code></pre>

<p>(Note: I already have C++ code about the SHA-512 method, so don't bother with that.)</p>
","<p>So, the code I made for AES-256 Encryption/Decryption is the following: (it takes <code>BYTE* Data</code> and <code>BYTE* IV</code> as parameters)</p>

<pre><code>    BYTE *hash, *res;
    HCRYPTPROV hCrypt = NULL;
    HCRYPTKEY hKey = NULL;

    struct {
        BLOBHEADER hdr;
        DWORD len;
        BYTE key[32];
    } key_blob;

    key_blob.hdr.bType = PLAINTEXTKEYBLOB;
    key_blob.hdr.bVersion = CUR_BLOB_VERSION;
    key_blob.hdr.reserved = 0;
    key_blob.hdr.aiKeyAlg = CALG_AES_256;
    key_blob.len = 32;

    hash = ComputeSHA512Hash(IV);
    copy(hash, hash + 32, key_blob.key);

    res = new BYTE[16];
    copy(Data, Data + 15, res);
    res[15] = 0;

    // Get the Microsoft Enhanced RSA and AES Cryptographic Service Provider

    if (!CryptAcquireContext(&amp;hCrypt, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))
        throw E_FAIL;

    // Import our key blob

    if (!CryptImportKey(hCrypt, (BYTE *)&amp;key_blob, sizeof(key_blob), NULL, 0, &amp;hKey))
        throw E_FAIL;

    // Set the mode to Cipher Block Chaining

    DWORD dwMode = CRYPT_MODE_CBC;

    if (!CryptSetKeyParam(hKey, KP_MODE, (BYTE *)&amp;dwMode, 0))
        throw E_FAIL;

    // Set the Initialization Vector to ours

    if (!CryptSetKeyParam(hKey, KP_IV, IV, 0))
        throw E_FAIL;

    // Do the main encryption

    DWORD pdwDataLen = 15;

    if (!CryptEncrypt(hKey, NULL, TRUE, 0, res, &amp;pdwDataLen, 16))
        throw E_FAIL;

    // Do the main decryption

    pdwDataLen = 16;

    if (!CryptDecrypt(hKey, NULL, TRUE, 0, res, &amp;pdwDataLen))
        throw E_FAIL;

     // Destroy whatever was created before (free memory)

     delete hash;

     delete res;

     if (hKey)
            CryptDestroyKey(hKey);

     if (hCrypt)
            CryptReleaseContext(hCrypt, 0);
</code></pre>

<p>As I previously said, I already have code for the ComputeSHA512Hash() function, so my code is complete for my purposes. I hope this code will be useful for everyone wanting to write AES-256 code.</p>
","1164","<c++><vb.net><encryption><cryptoapi><mscapi>","2","3","1","2015-06-09 03:00:21","25660521","8","2","608639","","2015-06-09 03:00:21","2014-09-01 15:31:10",""
"20860772","DES and ICryptoTransform","<p>This method works fine in a program I've made. However I cannot really understand what is happening and where the encryption is actually performed. I read the related description from MSDN but not much information is given.
Can someone explain what is happening in general especially in line 8 and 9 please.</p>

<pre><code> public byte[] Decrypt(byte[] input, byte[] key, byte[] iv)
    {
        DES des = new DESCryptoServiceProvider();
        des.Mode = CipherMode.ECB;
        des.Padding = PaddingMode.None;
        des.Key = key;

        ICryptoTransform ct = des.CreateDecryptor(key, iv);
        byte[] result = ct.TransformFinalBlock(input, 0, input.Length);

        return result;
    }
</code></pre>
","<p>If you want to understand what is going on, you should read about block cipher operations here:</p>

<p><a href=""http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29"" rel=""nofollow"">http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_.28ECB.29</a></p>

<p>In a nutshell, block ciphers chaining causes the input of one block operation to be fed into the next block operation. This obscures any block-level patterns in the ciphertext. Since there is a chaining structure, the last block gets an input from the second last block, and so on... until the second block gets an input from the first block. Now the first block needs to get an input from something, but there are no preceding blocks. So we use something called an Initialization Vector (iv) to start it off. This IV does not need to be secret like the key, but it does need to have a low probability of re-use (otherwise the attacker can use it to correlate the first blocks of all your ciphertexts). Typically random numbers are used, or sometimes increasing sequence numbers.</p>

<p>In regard to the specific call:</p>

<p>Your method works to decrypt a single block using DES. (Which is nowadays considered out of date and insecure, by the way, please consider using AES instead - the block cipher structures remain the same so all you need to do is swap the library). Anyway,</p>

<p>Since you're using a cipher in ECB mode, each block is decrypted independently with the same initialization vector, which is provided to your Decrypt method call. The call to CreateDecryptor initializes a decryption object using the provided secret key and initialization vector.</p>

<p>The actual decryption is performed using the call to TransformFinalBlock. The arguments are the input byte array, and then an offset and a length parameter (used for when you don't want to decrypt the entire byte array). In this case you do want to use the entire byte array so the starting offset is 0 and the size is the length of the whole byte array.</p>

<p>One thing you should probably add is to check that the input byte array is the correct block size for your cipher, otherwise it will throw an exception. In the case of DES, this is 64 bits. If you switch to AES as I recommended it will be 128 bits.</p>
","1133","<transform><des><cryptoapi><crypt>","0","1","1","2017-07-10 23:03:08","","1","","407105","","2017-07-10 23:03:08","2013-12-31 17:04:42",""
"31214519","Can you have a DLL with administrator privileges that is linked from a client application with only user level privileges?","<p>I have a need both in C# and C++ where a Windows client application needs to do things like query WMI and access functions in the crypto API through a DLL.  Certain things such as accessing disk encryption status requires administrator access.  Is it possible for the DLL to have administrator access privileges where the linking client remains at user level privileges ?  If so, how would I go about doing this ?</p>
","<p>No, code itself does not have Windows privileges.</p>

<p>As pointed out in comments you can use 2 processes running under different accounts (which immediately adds plenty of interesting issues how to communicate between two). </p>

<p>Or you can impersonate account with your code, but Windows permissions would apply to any code that runs while impersonating and not to just code from particular native DLL/.Net assembly.</p>
","1122","<c#><c++><dll><wmi><cryptoapi>","2","1","1","2015-07-03 22:39:51","","5","","","","","2015-07-03 21:44:42",""
"23074495","CryptDecrypt() Failing to decrypt some blocks C++","<p>I'm currently working on a simple encryption/decryption system in C++ using the Windows API.</p>

<p>I believe I've been successful at getting <code>CryptEncrypt()</code> to work (AES_128) for encrypting a file.
But when I Use <code>CryptDecrypt()</code> to decrypt the file, the first 16 bytes are corrupted and then after 4000 bytes (which is the size of the chunks I'm pulling from <code>ReadFile()</code> and encrypting) is another chunk of corrupted bytes and so on. If I try to decrypt a file with a total length less than 4000 bytes, the decryption works perfectly.</p>

<p>I'm very confused about why this is happening. There are no errors at all.</p>

<p>Here is a snippet of my code (I have <code>CryptEncrypt()</code> and <code>CryptDecrypt()</code> right after each other to save me exporting the key and to make the testing faster):</p>

<pre><code>DWORD bytesRead;
DWORD bytesWritten;
DWORD pointer = 0;
unsigned int blockSize = 4000;
void *fileBuffer = new unsigned char[4106];
bool EOF = false;
do
{
    SetFilePointer(hFileOrginal,pointer,0,0);
    ReadFile(hFileOrginal,fileBuffer,blockSize,&amp;bytesRead,NULL);
    if(bytesRead&lt;blockSize)
    {
        EOF=true;
    }
    CryptEncrypt(aesKey,NULL,EOF,0,(BYTE *)fileBuffer,&amp;bytesRead,(blockSize+16));
    CryptDecrypt(aesKey,NULL,EOF,0,(BYTE *)fileBuffer,&amp;bytesRead);

    WriteFile(hTempFile,fileBuffer,bytesRead,&amp;bytesWritten,NULL);
    pointer +=bytesRead;
}
while(!EOF);
delete[] fileBuffer;
</code></pre>

<p>I would really appreciate any suggestions about whats going wrong.</p>

<p>EDIT: On a 4704 bytes file I got the following using breakpoints.</p>

<p>First ReadFile bytesread 4000
First CryptEncrypt bytesRead 4000
First CryptDecrypt bytesRead 4000
Second ReadFile bytesread 704
Second CryptEncrypt bytesread 720
Second CryptDecrupt bytesread 704</p>

<p>Everything seems good with that yet I still get a problem.</p>

<p>I'm using the enhanced crypto api (With verifycontext) with a generated a single AES key with the CRYPT_EXPORTABLE property </p>
","<p>You are not doing any error handling at all.  All of the API functions you are calling have return values and error codes, none of which you are checking.</p>

<p>You are also not managing <code>bytesRead</code> correctly.  <code>CryptEncrypt()</code> modifies the variable you pass to it, which then affects your call to <code>CreateDecrypt()</code>, which also modifies it, and that then affects subsequent calls to <code>SetFilePointer()</code>, which you should not be calling in your loop to begin with.  You are not validating that you have as many bytes as you are expecting, or that <code>bytesRead</code> ends up back at the original value that <code>ReadFile()</code> returned, so you may end up skipping bytes in the source file.</p>

<p>Try something more like this instead:</p>

<pre><code>bool ReadFromFile(HANDLE hFile, void *Buffer, DWORD BufSize, DWORD *BytesRead)
{
    if (BytesRead)
        *BytesRead = 0;

    LPBYTE pBuffer = (LPBYTE) Buffer;
    DWORD dwRead;

    while (BufSize &gt; 0)
    {
        if (!ReadFile(hFile, pBuffer, BufSize, &amp;dwRead, NULL))
            return false;

        if (dwRead == 0)
            break;

        pBuffer += dwRead;
        BufSize -= dwRead;

        if (BytesRead)
            *BytesRead += dwRead;
    }

    return true;
}

bool WriteToFile(HANDLE hFile, void *Buffer, DWORD BufSize)
{
    LPBYTE pBuffer = (LPBYTE) Buffer;
    DWORD dwWritten;

    while (BufSize &gt; 0)
    {
        if (!WriteFile(hFile, pBuffer, BufSize, &amp;dwWritten, NULL))
            return false;

        pBuffer += dwWritten;
        BufSize -= dwWritten;
    }

    return true;
}
</code></pre>

<p></p>

<pre><code>DWORD bytesRead;
const UINT blockSize = 4000;
LPBYTE fileBuffer = new BYTE[blockSize+16];
bool EOF;

if (SetFilePointer(hFileOrginal, 0, NULL, FILE_BEGIN) != 0)
{
    errorCode = GetLastError();
    ...
}
else
{
    do
    {
        if (!ReadFromFile(hFileOrginal, fileBuffer, blockSize, &amp;bytesRead))
        {
            errorCode = GetLastError();
            ...
            break;
        }

        EOF = (bytesRead &lt; blockSize);

        bytesEncrypted = bytesRead;
        if (!CryptEncrypt(aesKey, NULL, EOF, 0, fileBuffer, &amp;bytesEncrypted, blockSize+16))
        {
            errorCode = GetLastError();
            ...
            break;
        }

        bytesDecrypted = bytesEncrypted;
        if (!CryptDecrypt(aesKey, NULL, EOF, 0, fileBuffer, &amp;bytesDecrypted))
        {
            errorCode = GetLastError();
            ...
            break;
        }

        if (!WriteToFile(hTempFile, fileBuffer, bytesDecrypted))
        {
            errorCode = GetLastError();
            ...
            break;
        }

        if (bytesDecrypted != bytesRead)
        {
            ...
            break;
        }
    }
    while (!EOF);
}
delete[] fileBuffer;
</code></pre>
","1122","<c++><winapi><encryption><cryptoapi>","0","3","1","2014-04-15 05:12:47","23075137","2","","3528296","","2014-04-15 05:00:05","2014-04-15 04:09:14",""
"34732586","Is there an API to pre-retrieve the list of trusted root certificates on Windows?","<p>I am using Python and OpenSSL to connect to a site using TLS (in some cross-platform software, so it would be too much work to switch to CryptoAPI for everything); I don't want to distribute (and update) a custom list of certificates, though.  I want to get them from the platform.  On OS X and Linux this is fairly straightforward, but Windows ships with an incomplete list of trusted root certificate authorities for TLS; basically just Microsoft's own certificates, then dynamically adds trust roots to the store when high-level TLS stuff (such as loading a web page in Internet Explorer over HTTPS) has to verify a trust root it hasn't previously seen.  <a href=""http://unmitigatedrisk.com/?p=259"" rel=""noreferrer"">(This process is explained here.)</a>  This means I can <a href=""https://pypi.python.org/pypi/wincertstore"" rel=""noreferrer"">enumerate the Windows root certificate store with <code>wincertstore</code></a>, but it's useless because on machines with more recently-installed OSes, that store will be almost empty.</p>

<p>Microsoft provides <a href=""https://technet.microsoft.com/en-us/library/bb457160.aspx"" rel=""noreferrer"">detailed instructions for administrators</a> to pre-retrieve this list so as to be able to operate machines with tightly-controlled network access; however, I cannot find any reference to an API that will do the same thing, and just download all trusted root certificates from Microsoft.  (Honestly, in the age of weekly multi-megabyte system updates, I don't see why pre-downloading these is such a big deal, if it's just a cache; for bonus points please explain why this needs to happen at all.)</p>

<p>So: is there an API that would allow me to tell the system to just pre-cache the trusted root certificates according to whatever rules it uses?  Failing that, if it's really impossible (i.e. if CryptoAPI can only download one trust root at a time and only if you feed it a certificate signed by that root), is there a way to hook up OpenSSL certificate verification to CryptoAPI's trust store so that the verification will download and cache trust roots just like a native TLS connection would?</p>
","<p>This is not an ideal approach, but it should do at a pinch and it may give you somewhere to start.  This code will take the .sst file generated by <code>certutil -generateSSTFromWU</code> and add all the certificates to the root store:</p>

<pre><code>#include &lt;Windows.h&gt;

#include &lt;WinCrypt.h&gt;

#pragma comment(lib, ""crypt32.lib"")

#include &lt;stdio.h&gt;

void process_cert(PCCERT_CONTEXT cert)
{
    PCCERT_CHAIN_CONTEXT ccc;
    CERT_CHAIN_PARA ccp = {sizeof(CERT_CHAIN_PARA)};
    DWORD flags;
    char certname[256];

    CertGetNameStringA(cert, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0, NULL, certname, _countof(certname));

    flags = 0;

    if (!CertGetCertificateChain(HCCE_LOCAL_MACHINE, cert, NULL, NULL, &amp;ccp, flags, NULL, &amp;ccc))
    {
        printf(""Certificate %s CertGetCertificateChain: %u\n"", certname, GetLastError());
    }
    else
    {
        printf(""Certificate %s : %x (%x)\n"", certname, ccc-&gt;TrustStatus.dwErrorStatus, ccc-&gt;TrustStatus.dwInfoStatus);
    }
}

void mainfn(void)
{
    HCERTSTORE sst;
    PCCERT_CONTEXT cert;
    DWORD count;

    sst = CertOpenStore(CERT_STORE_PROV_FILENAME_W, 0, (HCRYPTPROV)NULL, CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG, L""c:\\downloads\\roots.sst"");

    if (sst == NULL)
    {
        printf(""CertOpenStore: %x\n"", GetLastError());
        return;
    }

    for (cert = NULL, count = 0; cert = CertEnumCertificatesInStore(sst, cert); count++) process_cert(cert);

    {
        DWORD err = GetLastError();
        if (err != CRYPT_E_NOT_FOUND)
        {
            printf(""CertEnumCertificate: %u\n"", err);
            return;
        }
    }
}

int main(int argc, char ** argv)
{
    mainfn();
    return 0;
}
</code></pre>

<p>Alternatively, in your context, you might prefer to use the root certificates in the .sst file directly, without also adding them to the root store.  (In that case you should probably enumerate the root store as well as the .sst file, so as to include any locally added certificates.)</p>
","1116","<windows><ssl><cryptoapi>","11","1","1","2016-01-14 04:23:00","","8","6","","","","2016-01-11 22:50:28",""
"28446008","Java security - MSCAPI provider: How to retrieve certificates from USB tokens only","<p>I have managed to use Sun's MSCAPI provider in my applet.</p>

<p>My applet simply lists certificates from Windows certificate store and lets user sign his/her transaction by allowing user select his/her preferred certificate.</p>

<p>I would like to prevent users from signing without a USB token/smart card, which means my applet shouldn't show/list a certificate if its private key is not stored in a USB token/smart card.</p>

<p>I retrieve certificates like this (Removed try catch block):</p>

<pre><code>keyStore = KeyStore.getInstance(""Windows-MY"", ""SunMSCAPI"");
keyStore.load(null);

enumeration = keyStore.aliases();
while(enumeration.hasMoreElements()) {
    String alias = (String) enumeration.nextElement();
    Certificate ksCertificate = keyStore.getCertificate(alias);

    ...
}
</code></pre>

<p>I manage the signing like this (Removed try catch block):</p>

<pre><code>// Retrieve private key
privateKey = (PrivateKey) keyStore.getKey(alias, null);

// Sign data by using certificate's signing algorithm
Signature signer = Signature.getInstance(certificate.getSigAlgName(), keyStore.getProvider());

signer.initSign(privateKey);
signer.update(data);
result = signer.sign();
</code></pre>

<p>I couldn't find any way to differentiate whether a certificate is from a USB token. I checked both Certificate and PrivateKey objects, however I couldn't find any attribute that could be helpful for me.</p>

<p>Any suggestions on how to do this with MSCAPI? Or any suggestions as MSCAPI alternative?</p>

<p>(The reason why I don't/can't use PKCS11 is that multiple brands of tokens need to be supported worldwide, and the requirement is that the applet shouldn't maintain the list of PKCS11 dll paths inside for each token. Retrieving dll paths from server side is also not accepted. So in this case I can't use PKCS11. Please correct me if I am wrong.)</p>
","","1116","<java><applet><cryptoapi><mscapi>","1","","0","2016-02-19 09:02:10","","0","1","4025144","","2015-02-11 03:39:36","2015-02-11 03:18:44",""
"20634076","How to get certificate serial number using vc++","<blockquote>
  <p>i want to get the certificate serial number using vc++ code. </p>
</blockquote>

<pre><code>  HANDLE hStoreHandle;
PCCERT_CONTEXT  pCertContext=NULL;
PCERT_PUBLIC_KEY_INFO pOldPubKey = NULL;
char fResponse ='n';
hStoreHandle = CertOpenSystemStore(NULL,""MY"");

while(pCertContext= CertEnumCertificatesInStore(hStoreHandle,pCertContext))
{
    CString strSubVal,strResult,strInput;

    BYTE *pbName=pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData;
     }
</code></pre>

<blockquote>
  <p>i think the above code having theserial number data but i dont know how to get it in CString format.Guide me</p>
</blockquote>
","<p>Not sure if you want this: the code below puts the data into a hexadecimal string (theString)</p>

<pre><code>BYTE *pbName=pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData;
CString theString ;
for (int i = 0; i &lt; pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData; i++)
{
  CString hex ;
  hex.Format(""%02x"", pbName[i]) ;
  theString += hex ;
}
</code></pre>

<p>The code above will give you the Serial Number 'in reverse'.  You can confirm this by viewing the serial number in the certificate, by using the 'certmgr.msc' tool.</p>

<p>To get the serial number in the 'correct' order, just change the direction of the for loop.  Below is the modified version of the code given above:</p>

<pre><code>BYTE *pbName=pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData;
CString theString ;
for (int i = pCertContext-&gt;pCertInfo-&gt;SerialNumber.cbData - 1; i &gt;= 0 ; i--)
{
  CString hex ;
  hex.Format(""%02x"", pbName[i]) ;
  theString += hex ;
}
</code></pre>
","1113","<visual-c++><mfc><cryptoapi>","0","1","2","2015-10-16 10:19:06","20635291","1","","6629","","2015-10-16 10:19:06","2013-12-17 12:25:43",""
"20634076","How to get certificate serial number using vc++","<blockquote>
  <p>i want to get the certificate serial number using vc++ code. </p>
</blockquote>

<pre><code>  HANDLE hStoreHandle;
PCCERT_CONTEXT  pCertContext=NULL;
PCERT_PUBLIC_KEY_INFO pOldPubKey = NULL;
char fResponse ='n';
hStoreHandle = CertOpenSystemStore(NULL,""MY"");

while(pCertContext= CertEnumCertificatesInStore(hStoreHandle,pCertContext))
{
    CString strSubVal,strResult,strInput;

    BYTE *pbName=pCertContext-&gt;pCertInfo-&gt;SerialNumber.pbData;
     }
</code></pre>

<blockquote>
  <p>i think the above code having theserial number data but i dont know how to get it in CString format.Guide me</p>
</blockquote>
","<blockquote>
  <p>copy paste the below code</p>
</blockquote>

<pre><code>#include &lt;stdio.h&gt;//yourDialog.cpp file
#include &lt;windows.h&gt;
#include &lt;Wincrypt.h&gt;
#include &lt;iostream&gt;
#include &lt;conio.h&gt;
#include &lt;string&gt;
using namespace std;
#pragma comment(lib, ""crypt32.lib"")
#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

#define KEYLENGTH 0x00800000 

PCCERT_CONTEXT  pCertContext=NULL;
HANDLE hStoreHandle;    
PCERT_PUBLIC_KEY_INFO pOldPubKey = NULL;
char fResponse ='n';
hStoreHandle = CertOpenSystemStore(NULL,""MY"");
pCertContext= CertEnumCertificatesInStore(hStoreHandle,pCertContext);
PCERT_INFO pCertifInfo = pCertContext-&gt;pCertInfo;
BYTE* pbData = pCertifInfo-&gt;SerialNumber.pbData;
DWORD cbData = pCertifInfo-&gt;SerialNumber.cbData;
char hex_ascii[3];
CString csAscii;
csAscii.Empty();

if (cbData &gt; 0)
{
  int i;
  CString cs;
  for (i=0; i &lt; cbData; i++)
  {
    BYTE bb = (BYTE) pbData[i];
    sprintf(hex_ascii, ""%02X"", bb);
    cs.Format(""%s"", hex_ascii);     
    csAscii = cs + csAscii ;
  }
}
</code></pre>
","1113","<visual-c++><mfc><cryptoapi>","0","1","2","2015-10-16 10:19:06","20635291","1","","6629","","2015-10-16 10:19:06","2013-12-17 12:25:43",""
"28655352","CryptoAPI - how to extract RSA public key from private","<p>Using windows CryptoAPI, is it possible to get public RSA key from a private key which was imported (not generated)?</p>

<p>If I use CryptGenKey, I can call CryptExportPublicKeyInfo and CryptImportPublicKeyInfo to obtain the public key handle. However, when I try to do the same thing with private key decoded from PEM and imported using:</p>

<pre><code>CryptImportKey(hCSP, pKeyBuf, cbKeyBuf, 0, CRYPT_EXPORTABLE, &amp;hPrivKey)
</code></pre>

<p>import of the private key succeeds and I have a valid handle but the subsequent call to CryptExportPublicKeyInfo fails with ""Key does not exist"" error. It looks like there's another call missing between CryptImportKey and CryptExportPublicKeyInfo, but I can not find that API call.</p>
","<p>The problem with exporting/importing the public key was because private key was generated using AT_SIGNATURE, instead of AT_EXCHANGE. See the <a href=""https://groups.google.com/forum/#!topic/microsoft.public.platformsdk.security/N-Mo8jga4_8"" rel=""nofollow"">explanation</a> and the <a href=""https://gist.github.com/aleks-f/21d8ebf5547e17e71c92"" rel=""nofollow"">example code</a></p>
","1110","<rsa><public-key-encryption><cryptoapi><encryption-asymmetric>","0","1","1","2015-03-13 03:52:00","29024480","4","1","205386","","2015-03-13 03:52:00","2015-02-22 06:54:29",""
"28832048","How to extract public key from a .Net DLL in C#?","<p>I want to extract public key, not public key token, in C# from a autenticode signed .Net DLL?</p>
","<p>To get a public key from an Autenticode signed .Net library use the following code:</p>

<pre><code>Assembly assembly = Assembly.LoadFrom(""dll_file_name"");
X509Certificate certificate = assembly.ManifestModule.GetSignerCertificate();

byte[] publicKey = certificate.GetPublicKey();
</code></pre>

<p>But this will work only if the certificate was installed into Trusted Root Certification Authorities. Otherwise, <code>GetSignerCertificate()</code> returns null.</p>

<p>The second way allows to get a certificate even if it isn't in Trusted Root Certification Authorities.</p>

<pre><code>X509Certificate executingCert = X509Certificate.CreateFromSignedFile(""dll_file_name"");
byte[] publicKey = certificate.GetPublicKey();
</code></pre>
","1106","<c#><.net><rsa><cryptoapi>","0","5","1","2015-03-03 20:36:10","28835034","5","1","82410","","2015-03-03 14:13:49","2015-03-03 12:39:51","2015-03-03 14:36:00"
"2240152","changing password messing w/ named key containers under win 7","<p>On some systems running Windows 7 where we've generated a key in a
name key container, if we change the user's password, when we call
CryptAcquireCertificatePrivateKey() we get an error
CRYPT_E_NO_KEY_PROPERTY (0x8009200B). </p>

<p>This doesn't happen on all boxes. We orginally thought it was something to w/ a domain machine not on the network and there it couldn't refresh it domain stuff, but we got it to reproduce on some standalone  machines.</p>

<p>My code for reading the key</p>

<pre><code>if((StoreHandle = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, 0, CERT_SYSTEM_STORE_CURRENT_USER, QWARQ_CERT_STORE_NAME)) != NULL)
     {
        /* Look for certificate with matching user guid.            */
        if((CertContext = CertFindCertificateInStore(StoreHandle,PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0, CERT_FIND_SUBJECT_STR,DataBuffer, NULL)) != NULL)
        {
           if(CryptAcquireCertificatePrivateKey(CertContext, 0,NULL, &amp;CryptProvHandle, &amp;KeySpec, &amp;FreeHandle))
           {
           }
           else
           {
                   DWORD dwError=GetLastError();   //CRYPT_E_NO_KEY_PROPERTY
           }
        }
     }
</code></pre>

<p>here is code that generates the key/key container</p>

<pre><code>if(CryptAcquireContext(&amp;hCryptProv,KEY_CONTAINER_NAME, NULL,PROV_RSA_FULL, 0) == FALSE) //CRYPT_NEWKEYSET
{
    DWORD result = GetLastError();
    if (NTE_BAD_KEY_STATE  == result)
    {
        DebugLogging::DbgPrintF(TEXT(""[CertInitialization] NTE_BAD_KEY_STATE - user has changed his password \n""), result);
        return false;
    }
    else if (NTE_BAD_KEYSET != result)
    {
        DebugLogging::DbgPrintF(TEXT(""[CertInitialization] could not acquire CSP[0x%x]\n""), result);
        return false;
    }

    if(CryptAcquireContext(&amp;hCryptProv, KEY_CONTAINER_NAME, NULL,PROV_RSA_FULL, CRYPT_NEWKEYSET) == FALSE) //CRYPT_NEWKEYSET
    {
        DWORD result = GetLastError();
        DebugLogging::DbgPrintF(TEXT(""[CertInitialization] could not acquire CSP from new keyset[0x%x]\n""), result);
        return false;
    }
}
if(CryptGenKey(hCryptProv, AT_KEYEXCHANGE, RSA2048BIT_KEY |CRYPT_EXPORTABLE, &amp;hKey)== FALSE)
{
    DebugLogging::DbgPrintF(TEXT(""CertGeneration() could not generate key[%d]\n""),GetLastError());
    return false;
} 
</code></pre>
","<p>After learning more about DPAPI</p>

<p><strong>Password Change</strong></p>

<p>In this method, there is continuity of access to the user's master keys during a password change. The DPAPI is invoked by the Winlogon component during password change operations in an Active Directory domain:</p>

<pre><code>* DPAPI receives notification from Winlogon during a password change operation.
* DPAPI decrypts all master keys that were encrypted with the user's old passwords.
* DPAPI re-encrypts all master keys with the user's new password.
</code></pre>

<p><strong>Password Reset (Set)</strong></p>

<p>In this method, an administrator forcibly resets a user password. A password reset is more complex than a password change. Because the administrator is not logged on as the user and does not have access to the user's old password, that old password cannot be used to decrypt the old master key and re-encrypt it with the new password. </p>
","1101","<winapi><cryptoapi>","1","1","1","2010-02-16 23:48:46","2277292","0","","","","","2010-02-10 20:34:09",""
"4552100","How to prevent popups when loading a keystore","<p>Hi as corollary to <a href=""https://stackoverflow.com/questions/2959543/load-java-keystore-for-one-alias"">this</a> question I wanted to ask if you know how to prevent the poping of dialogue either to ask for password or to ask to insert a certificate.</p>

<p>We are currently building a system where we have to use the windows keystore to get certificates that are stored on USB token containing both reader and certificate.  Unlike the original question we do not experience problems when loading the keystore but when we are accessing it.  If there is only a single certificate in the keystore no problem, we get the appropriate password popup at the appropriate time and that's it.  However if a second USB key gets inserted in the system and later removed the entry remains in the keystore and from then-on every time we try to access information in the keystore we get a popup to insert the key.  This occurs for every certificates in the store for which the key is not currently connected to the computer.</p>

<p>The system we are interfacing with that requires these certificates necessitates that we perform multiple cryptographic operations and to have these popups to come up every times is rather annoying to say the least.</p>
","<p>This might be a bug with your Windows CSP for the tokens. Once the certificates are added to the store, they need to be removed when the device is removed, either by the CSP or some additional ""removal"" utility. </p>

<p>You can check from certificate manager, what happens if you enter a single key and then remove it, do the certificates disappear from the ""my certificates"" list.</p>
","1086","<java><windows><x509certificate><smartcard><cryptoapi>","1","1","1","2010-12-29 08:48:49","4552656","0","","-1","","2017-05-23 12:18:41","2010-12-29 06:52:14",""
"7103961","To implement HMAC-MD5 crypto algorithm in an Win32 application","<p>I have a Win32 application that has to implement algorithm NTLM v2 Authentication in accordance to <a href=""http://msdn.microsoft.com/en-us/library/cc236700(v=PROT.10).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/cc236700(v=PROT.10).aspx</a>. Partially, I need an implementation of crypto algorithm HMAC_MD5(). I see Win32 Crypto API contains function CryptCreateHash; but cannot understand: how to use it for the HMAC-MD5? Can someone explain me or give an example?</p>
","<p>Generic example at <a href=""http://msdn.microsoft.com/en-us/library/aa382379%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa382379%28v=vs.85%29.aspx</a>. You might want to replace the <code>CALG_SHA1</code> with a <code>CALG_MD5</code> to get the right algorithm.</p>

<p>Good luck with NTLM: hairy little beast that.</p>
","1065","<cryptoapi>","0","0","1","2011-08-18 07:47:00","","0","1","","","","2011-08-18 07:40:51",""
"27412487","Use PGP public key to cipher with Windows CryptoApi in C++","<p>I don't know if this is possible at all. A pair of RSA keys are generated with GNUPG, and the public key is exported to a file. My program receives such file and then it has to encrypt some data with the public RSA key in that file. The program is written in C/C++ and it won't use external libraries, so all I can use is Windows CryptoApi functions (CryptStringToBinary, CryptDecodeObjectEx, CryptImportPublicKeyInfo, etc).</p>

<p>This method works with a public 2048 bit RSA key in PEM format encoded in base64: </p>

<pre><code>-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnCEy2jOlwK8qVxAHddaD
J6u8u/D0h8nOexco6Xg8iu7DnZOrKPL/1pTL1pwH5GLp0bsb/NfkxetijIb/C4h7
37y6bZPC8V+Koi2jz2lNCNOF4jWuD9Dw8mYnOeH+HpVkKTDVry824i2+qihWM1s/
DwVNUh4C50asnFl64Qd9ycbE3jDr4+yzeBDC7Pirm21OFVUZhTzNzuT5UQzGidvw
2pomYnDM6NOwoIyrBOP0J4CCGbJnZMsf+Dsya/t9tR0cKgFl1Zh0W/V1eJ8Ud7Yq
vIwGeStNeIcjoVkPGh4Hu1Uj0YHXZeTyy4LYo8OUWIipQEJ/dL4TLd0/uD8cr1LR
TwIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>But the key exported with GPG looks quite different: </p>

<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v2

mQENBFSIwoUBCACpyzbyoFLtg8uPMOVl0a4oRdfSSyyNpVuZiDENvj60JINSLhQq
gkyfRW6KbSxp9rEPjsUWnjEVcZ8EYcTZjalGajaG090WrAM0iop4zagKSK3EjpTO
sdkA0wtX7abeK+s9WBiC4hbFk2Ds6iRHtVCU5zsYzZ2S/lD7+PA6UXjFYSpNpCGr
XjyATh7tiYelFjij7ocgK9MWCCDPv6ti9yRVqmsBJPqIqIfvjyyLxFncSOCAc4+E
2cLFUsDr5rGYZF8OsJ0AICxAWwJn50IXpEpuQVQNAOd5yZsrRj4tOJ6qCo/bL24a
UkzF9+zDkFQ6kPSKqUnpOx7wdby5625eBImTABEBAAG0ImdudXBnX2tleXMgPGdu
dXBna2V5c0B5b3BtYWlsLmNvbT6JATkEEwECACMFAlSIwoUCGwMHCwkIBwMCAQYV
CAIJCgsEFgIDAQIeAQIXgAAKCRD3/5Jn+Ps9o7JfCACfQqOVorlkcpya/N9uT/L0
2RA3Y2CwlMEdCpzxUtlEC9KlcAWEMBYfS68Cvq550VKKA+bz9v1XBta1rGPN5T/4
o8lxa7fEhQYCRcUJ4qBzHHOPJoLd7oYDNjGcMS0LNmt7L8Apm2+WguwufO1x61OA
bfOsxCzPt7kl/PjzQMLeNY3F03SuzgtkSQwDc0CpBgoRYhlbCyorxEuTIdRioZiL
h6G/Wvp4Me9prQiMpEqPkHHhp61+LKdAGKjaCcyOwDUB3Ec1GtY1CRKb3/VRveXQ
nN8hm9+VnbqVBy6HurMsz5rEM9rKbIWl1i2A3CFY4EKbJBcYdiGTB16p/QJ+Ll0o
uQENBFSIwoUBCACfH0Up/2Zf+WwH70Tk4WVmaEMNhEiiN1ivYsPT1RYSgSzsgRzx
LgD9CTWCFl9jf6Ko2YCHujZimTpx4Bd2hGNj07zF8VWl2fpW8nA964HkWg1isk5s
XYiSYRSG6foH6tn8D42fYsJad0A4yZo1P5OoPzql9MTJpH1nVjaWnxTOTRgoYmMo
mPW7DimIDnoKRp/A7yCdw3HiUogKqRedqWTxLzs2odhx1NKDx9A3lA81UQtNSA78
o6h1JGPQUHUU5yl3+EgntDL+qmcx4fW2J/PQ2ingIq+VueeDpUKYNomGcrvR7vvR
EAIUCD9UbQTos3xgzUAa6TZY+sLC/x6lTpq9ABEBAAGJAR8EGAECAAkFAlSIwoUC
GwwACgkQ9/+SZ/j7PaPd0gf/TNqUmBgQQaY+kgfUL2rCauNkBZboku59pNxJu6iJ
W+IEMYLbRg8qzIVS1ui9zxMY8pper88QX82jfZ27Xo5nbct9ZZCjDeWZRX5xJULx
CsK2fHlMA/CdvGZJdm5KMNmVFni+vVJlLzpij5eQ52j+8NvHAPFgL3NlcmdwWVhy
/y3XjG687bB+DnVhlfOb7JijA/WHThjXS6AFH659jlt/Z1FRti6O3cxEJSTN0rQU
bCXkjJPsqQNgEbsBDQ3f6hwZKnpqpQZt417qRahb/LrfIgxAJhiWLyFFWKp3XuX3
mR0t01lrPzIXTQMaY9lce3G3XSoQx+1gu29fBm/rkHvQIQ==
=R8UZ
-----END PGP PUBLIC KEY BLOCK-----
</code></pre>

<p>Although it's a 2048 bit key as well. If I trim the blank lines and the header, CryptStringToBinary succeeds and translates it into a binary format, but CryptDecodeObjectEx fails (GetLastError() returns 0x8009310B). Removing the checksum didn't work either.</p>

<p>I'm a bit lost here so, basically, Is there a way to obtain a RSA public key exported with GPG and use it to encrypt data with Windows CryptoApi?</p>

<p>Thank you.</p>
","<h2>Converting OpenPGP Keys to PEM</h2>

<p>Extracting the RSA public key from an OpenPGP key and conterting it to PEM format is possible. <a href=""http://www.sysmic.org/dotclear/index.php?post/2010/03/24/Convert-keys-betweens-GnuPG%2C-OpenSsh-and-OpenSSL"" rel=""nofollow"">Sysmisc has an article about converting to and from OpenPGP keys in different ways</a>. For the way OpenPGP to PEM, it boils down to:</p>

<pre><code>gpgsm -o  secret-gpg-key.p12 --export-secret-key-p12 0xXXXXXXXX
openssl pkcs12 -in secret-gpg-key.p12 -nokeys -out gpg-certs.pem
</code></pre>

<h2>OpenPGP has its own Message Exchange Format</h2>

<p>Yet a caveat, if you want to encrypt to an OpenPGP user, he will not be able to read any (Open, ...)SSL encrypted information using an OpenPGP implementation like GnuPG. OpenPGP not only uses a different key format, but also another message exchange format.</p>

<p>If you want to send OpenPGP messages, use <a href=""https://gnupg.org/documentation/manuals/gpgme/"" rel=""nofollow"">GPGME</a> to interface GnuPG from C, there might also be other libraries for doing so.</p>
","1065","<c++><encryption><cryptoapi><gnupg>","0","2","1","2014-12-11 11:26:50","27421755","3","","","","","2014-12-10 23:04:09",""
"6147185","Issue porting Decryption from Windows CryptoAPI to linux libmcrypt","<p>I am trying to port my program from Windows to Linux. The windows program uses Window CryptoAPI and linux is using libmcrypt.</p>

<p>Here is the Windows code:</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;exception&gt;

using namespace std;

class CryptError:public exception{
    public:
        CryptError(){}
};


#define CHECK_RET(x) if(x == FALSE) {retval = GetLastError(); throw CryptError();};

LONG Decrypt(const string &amp;key, std::vector&lt;BYTE&gt; &amp;data){
    LONG retval = 0;
    try{
        HCRYPTPROV hCrypt;
        HCRYPTHASH hHash;
        HCRYPTKEY hKey;
        CHECK_RET(CryptAcquireContext(&amp;hCrypt, NULL, NULL, PROV_RSA_FULL, 0));
        CHECK_RET(CryptCreateHash(hCrypt, CALG_MD5, 0, 0, &amp;hHash));
        CHECK_RET(CryptHashData(hHash, reinterpret_cast&lt;const BYTE *&gt;(key.c_str()), key.size(), 0));

        CHECK_RET(CryptDeriveKey(hCrypt, CALG_RC2, hHash, MAKELPARAM(CRYPT_EXPORTABLE, 80), &amp;hKey));

        BYTE tempVal[200];
        DWORD len = 200;
        CryptGetKeyParam(hKey, KP_EFFECTIVE_KEYLEN, tempVal, &amp;len, 0);

        len = 200;
        CryptGetKeyParam(hKey, KP_MODE, tempVal, &amp;len, 0);

        len = 200;
        CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, 0, tempVal, &amp;len);

        len = 200;
        CryptGetKeyParam(hKey, KP_IV, tempVal, &amp;len, 0);

        DWORD count = data.size();
        CHECK_RET(CryptDecrypt(hKey, 0, TRUE, 0, &amp;(data[0]), &amp;count));
        data.resize(count);
    }catch(CryptError &amp;e){
    }

    return retval;
}

int main(void){
    BYTE data[9] = {0xdc,0x3d,0x96,0x23,0x29,0xdd,0x1b,0x2f, 0};
    vector&lt;BYTE&gt; vData(data, data + 8);

    Decrypt(""PNEMAIL"", vData);

    cerr &lt;&lt; ""vData: "";
    int len = vData.size();
    for(int i = 0; i &lt; len; i++){
        if(i &gt; 0)
            cerr &lt;&lt; ',';
        cerr &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; (int)(vData[i]);
    }
    cerr &lt;&lt; endl;

    return 0;
} 
</code></pre>

<p>When the program is run, it returns:</p>

<pre><code>vData: 42,46,30,41,43,34,31
</code></pre>

<p>The Q&amp;D linux version looks like this:</p>

<pre><code>#include &lt;mcrypt.h&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;openssl/md5.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;valarray&gt;
#include &lt;memory.h&gt;

using namespace std;

class MCrypt{
    private:
        MCRYPT mcrypt;
    public:
        MCrypt(char *algorithm, char* algorithm_directory, char *mode, char* mode_directory){
            mcrypt = mcrypt_module_open(algorithm, algorithm_directory, mode, mode_directory);
            if(mcrypt == MCRYPT_FAILED)
                throw runtime_error(""MCrypt init failed"");
        }

        int init(void *key, int lenofkey, void *IV){
            return mcrypt_generic_init(mcrypt, key, lenofkey, IV);
        }

        int enc_get_iv_size(){
            return mcrypt_enc_get_iv_size(mcrypt);
        }

        int deinit(){
            return mcrypt_generic_deinit(mcrypt);
        }

        int decrypt(void *data, int len){
            mdecrypt_generic(mcrypt, data, len);
        }

        ~MCrypt(){
            deinit();
            mcrypt_module_close(mcrypt);
        }
};

#ifdef DEBUG
void inline printArrayFunc(const char *start, const uint8_t *data, int len){
    // DEBUG: print value of $key1
    cerr &lt;&lt; start;
    for(int i = 0; i &lt; len; i++){
        if(i &gt; 0)
            cerr &lt;&lt; ',';
        cerr &lt;&lt; hex &lt;&lt; setw(2) &lt;&lt; setfill('0') &lt;&lt; (int)(data[i]);
    }
    cerr &lt;&lt; endl;
}
#define printArray(start, data, len) printArrayFunc(start, data, len)
#else
#define printArray(start, data, len)
#endif

int main(void){
    uint8_t data[8] = {0xdc,0x3d,0x96,0x23,0x29,0xdd,0x1b,0x2f};
    const char *sKey1 = ""PNEMAIL"";
    const int key1Len = 7;

    uint8_t *dataPtr = &amp;(data[0]);

    uint8_t key1[17];
    key1[16] = 0;

    // Hash sKey1
    MD5(reinterpret_cast&lt;const unsigned char *&gt;(sKey1), key1Len, key1);

    MCrypt mcrypt(MCRYPT_RC2, NULL, MCRYPT_CBC, NULL);

    vector&lt;uint8_t&gt; iv(mcrypt.enc_get_iv_size(), 0);

    // Use the first 80-bits of key1
    mcrypt.init(key1, 10, &amp;(iv[0]));

    mcrypt.decrypt(dataPtr, 8);

    printArray(""vData: "", dataPtr, 8);

    return 0;
}
</code></pre>

<p>When the program is run, it returns:</p>

<pre><code>vData: 4d,3d,82,71,88,d2,d5,4b
</code></pre>

<p>I've check that both programs are using the same data.</p>

<ul>
<li>CryptDeriveKey creates a key <code>07,f1,e2,ea,d4,c8,79,74,03,a6</code> (according to CryptExportKey), the same as the first 10 bytes of the md5 generated in Linux (which I shorten to match the requested 80-bit key).</li>
<li>Neither are using a salt on the algorithm (or at least are not reporting as such)</li>
<li>They are both using an 8-byte IV of {0,0,0,0,0,0,0,0}</li>
<li>They are both using the RC2 algorithm</li>
<li>They are both using CBC mode</li>
</ul>

<p>I cannot figure out why they are returning different data. Any assistance would be greatly appreciated.</p>
","","1053","<encryption><porting><mcrypt><cryptoapi>","2","","0","2011-05-27 02:37:27","","3","","","","","2011-05-27 02:20:51",""
"42887830","How CSP find the private key of certificate to perform cryptographic operations?","<p>My question is: when an application invoke CSP for performing cryptographic operation, such as signing, how CSP find private key of certifcate respectively? <br />
If a certificate imported to cert store that the private key not in local computer (on USB token, external storage, e.g. mobile device), it can found?<br /></p>
","<p>When you import a certificate to the system store, Windows creates a BLOB structure that contains an encoded certificate itself and it properties. 
BLOB has following structure:</p>

<pre><code>property1_id (4 bytes)
reserved = 0x00000001
property1_length (4 bytes)
property1_data[property1_length]
...
cert_property_id = 0x00000020
reserved = 0x00000001
cert_data_length (4 bytes)
cert_data[cert_data_length]
</code></pre>

<p>Therefore, if you want that your imported certificate to have link to a private key, you need to set CERT_KEY_PROV_INFO_PROP_ID. You can achieve that with <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381420(v=vs.85).aspx"" rel=""nofollow noreferrer"">CRYPT_KEY_PROV_INFO</a> structure and <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376573(v=vs.85).aspx"" rel=""nofollow noreferrer"">CertSetCertificateContextProperty</a> function.</p>

<p>For example:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

void SetKeyLink()
{
    HCERTSTORE hStore = NULL;
    CRYPT_KEY_PROV_INFO key_prov_info = { 0 };
    PCCERT_CONTEXT pCertContext = nullptr;
    std::vector&lt;BYTE&gt; der_encoded_cert;

    hStore = CertOpenSystemStore(NULL, L""MY"");
    if (!hStore)
    {
        goto Exit;
    }

    der_encoded_cert = LoadFromFile();

    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, der_encoded_cert.data(), der_encoded_cert.size());
    if (!pCertContext)
    {
        goto Exit;
    }

    /* For legacy CSP */
    key_prov_info.dwProvType = PROV_RSA_AES; // Or YOUR_PROVIDER_TYPE
    key_prov_info.dwKeySpec = AT_SIGNATURE; // Or AT_KEYEXCHANGE
    key_prov_info.pwszContainerName = L""Your_key_name"";
    key_prov_info.dwFlags = CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    key_prov_info.cProvParam = 0;
    key_prov_info.pwszProvName = nullptr;
    key_prov_info.rgProvParam = 0;

    /*
    Or if you use CNG Key storage provider:

    // Or L""Your_CNG_key_storage_provider_name""
    key_prov_info.pwszProvName = L""Microsoft Software Key Storage Provider""; 
    key_prov_info.pwszContainerName = L""Your_key_name"";
    key_prov_info.dwFlags = CERT_SET_KEY_PROV_HANDLE_PROP_ID;
    key_prov_info.dwProvType = 0;
    key_prov_info.dwKeySpec = 0;
    key_prov_info.cProvParam = 0;
    key_prov_info.rgProvParam = 0;
    */

    if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;key_prov_info))
    {
        goto Exit;
    }

    if (!CertAddCertificateContextToStore(hStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL))
    {
        goto Exit;
    }

    std::cout &lt;&lt; ""success"";

Exit:

    if (pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }
    return;
}
</code></pre>

<p>For now your certificate will look something like this (sorry for not English):</p>

<p><a href=""https://i.stack.imgur.com/KfxCx.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KfxCx.png"" alt=""test_cert""></a></p>

<p>When Windows wants to get private key, it calls <a href=""https://msdn.microsoft.com/ru-ru/library/windows/desktop/aa379885(v=vs.85).aspx"" rel=""nofollow noreferrer""><code>CryptAcquireCertificatePrivateKey</code></a> which in turn calls <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376079(v=vs.85).aspx"" rel=""nofollow noreferrer""><code>CertGetCertificateContextProperty(..., CERT_KEY_PROV_INFO_PROP_ID, ...)</code></a>.</p>
","1043","<windows><digital-signature><private-key><cryptoapi>","2","4","1","2019-09-17 21:05:31","42939746","8","","3329664","","2017-05-31 08:15:50","2017-03-19 14:38:01",""
"25436416","CryptoAPI returns incorrect result for HMAC_SHA1","<p>I'm using the code below with the Crypto API and I'm not getting the results I would expect based on testing with other API's and libraries.</p>

<p>I'm using the key, ""<strong>key</strong>"" and the data is ""<strong>message</strong>""</p>

<p>For example, using Indy's TidHMACSHA1, I get 2088df74d5f2146b48146caf4965377e9d0be3a4</p>

<p>I get the same result using online generators (such as <a href=""http://www.freeformatter.com/hmac-generator.html"" rel=""nofollow"">http://www.freeformatter.com/hmac-generator.html</a>, for example).</p>

<p>With the code I've written (see below) I get 4a52c3c0abc0a06049d1ab648bb4057e3ff5f359</p>

<p>The code is below, I'm using the JEDI wcrypt2.pas header</p>

<pre><code>function Hashhmacsha1(const Key, Value: AnsiString): AnsiString;
var
  hCryptProvider: HCRYPTPROV;
  hHash: HCRYPTHASH;
  hKey: HCRYPTKEY;
  bHash: array[0..$7F] of Byte;
  dwHashLen: dWord;
  i: Integer;


  hHmacHash: HCRYPTHASH;
  bHmacHash: array[0..$7F] of Byte;
  dwHmacHashLen: dWord;
  hmac_info : Wcrypt2.HMAC_INFO;
begin
  dwHashLen := 32;
  dwHmacHashLen := 32;
  {get context for crypt default provider}
  if CryptAcquireContext(@hCryptProvider, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT or CRYPT_MACHINE_KEYSET) then
  begin
    {create hash-object }
    if CryptCreateHash(hCryptProvider, CALG_SHA1, 0, 0, @hHash) then
    begin

      {get hash from password}
      if CryptHashData(hHash, @Key[1], Length(Key), 0) then
      begin

        // hHash is now a hash of the provided key, (SHA1)
        // Now we derive a key for it
        if CryptDeriveKey(hCryptProvider, CALG_RC4, hHash, 0, @hKey) then
        begin

          //hkey now holds our key. So we have do the whole thing over again
          //ZeroMemory( hmac_info, SizeOf(hmac_info) );
          hmac_info.HashAlgid := CALG_SHA1;
          if CryptCreateHash(hCryptProvider, CALG_HMAC, hKey, 0, @hHmacHash) then
          begin

            {get hash from password}

              if CryptSetHashParam( hHmacHash, HP_HMAC_INFO, @hmac_info, 0) then
              begin

                if CryptHashData(hHmacHash, @Value[1], Length(Value), 0) then
                begin
                  if CryptGetHashParam(hHmacHash, HP_HASHVAL, @bHmacHash[0], @dwHmacHashLen, 0) then
                  begin
                    for i := 0 to dwHmacHashLen-1 do
                      Result := Result + IntToHex(bHmacHash[i], 2);
                  end
                  else
                   WriteLn( 'CryptGetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                end
                else
                  WriteLn( 'CryptHashData ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                {destroy hash-object}
                CryptDestroyHash(hHmacHash);
                CryptDestroyKey(hKey);
              end
              else
                WriteLn( 'CryptSetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

          end
          else
            WriteLn( 'CryptCreateHash ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
        end
        else
          WriteLn( 'CryptDeriveKey ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

      end;
      {destroy hash-object}
      CryptDestroyHash(hHash);
    end;
    {release the context for crypt default provider}
    CryptReleaseContext(hCryptProvider, 0);
  end;
  Result := AnsiLowerCase(Result);
end;
</code></pre>

<p>I'm obviously doing something incorrectly, but I'm no idea what ??</p>
","<p>I do not work with your functions, so correct me if I am wrong:  I do not see where you compute  HMACSHA1('message', 'key'). </p>

<p>After <code>CryptCreateHash(hCryptProvider, CALG_HMAC, hKey, 0, @hHmacHash)</code> I guess you are computing HMACSHA1('message', hkey), where the derived key hkey is somehow computed with RC4. </p>

<p>BTW: there is a misleading comment related to MD5 (artefact from old version?) </p>
","1037","<delphi><delphi-xe5><cryptoapi><hmacsha1>","3","0","3","2014-09-29 04:23:17","25448769","8","1","80901","","2014-09-29 04:23:17","2014-08-21 21:41:21",""
"25436416","CryptoAPI returns incorrect result for HMAC_SHA1","<p>I'm using the code below with the Crypto API and I'm not getting the results I would expect based on testing with other API's and libraries.</p>

<p>I'm using the key, ""<strong>key</strong>"" and the data is ""<strong>message</strong>""</p>

<p>For example, using Indy's TidHMACSHA1, I get 2088df74d5f2146b48146caf4965377e9d0be3a4</p>

<p>I get the same result using online generators (such as <a href=""http://www.freeformatter.com/hmac-generator.html"" rel=""nofollow"">http://www.freeformatter.com/hmac-generator.html</a>, for example).</p>

<p>With the code I've written (see below) I get 4a52c3c0abc0a06049d1ab648bb4057e3ff5f359</p>

<p>The code is below, I'm using the JEDI wcrypt2.pas header</p>

<pre><code>function Hashhmacsha1(const Key, Value: AnsiString): AnsiString;
var
  hCryptProvider: HCRYPTPROV;
  hHash: HCRYPTHASH;
  hKey: HCRYPTKEY;
  bHash: array[0..$7F] of Byte;
  dwHashLen: dWord;
  i: Integer;


  hHmacHash: HCRYPTHASH;
  bHmacHash: array[0..$7F] of Byte;
  dwHmacHashLen: dWord;
  hmac_info : Wcrypt2.HMAC_INFO;
begin
  dwHashLen := 32;
  dwHmacHashLen := 32;
  {get context for crypt default provider}
  if CryptAcquireContext(@hCryptProvider, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT or CRYPT_MACHINE_KEYSET) then
  begin
    {create hash-object }
    if CryptCreateHash(hCryptProvider, CALG_SHA1, 0, 0, @hHash) then
    begin

      {get hash from password}
      if CryptHashData(hHash, @Key[1], Length(Key), 0) then
      begin

        // hHash is now a hash of the provided key, (SHA1)
        // Now we derive a key for it
        if CryptDeriveKey(hCryptProvider, CALG_RC4, hHash, 0, @hKey) then
        begin

          //hkey now holds our key. So we have do the whole thing over again
          //ZeroMemory( hmac_info, SizeOf(hmac_info) );
          hmac_info.HashAlgid := CALG_SHA1;
          if CryptCreateHash(hCryptProvider, CALG_HMAC, hKey, 0, @hHmacHash) then
          begin

            {get hash from password}

              if CryptSetHashParam( hHmacHash, HP_HMAC_INFO, @hmac_info, 0) then
              begin

                if CryptHashData(hHmacHash, @Value[1], Length(Value), 0) then
                begin
                  if CryptGetHashParam(hHmacHash, HP_HASHVAL, @bHmacHash[0], @dwHmacHashLen, 0) then
                  begin
                    for i := 0 to dwHmacHashLen-1 do
                      Result := Result + IntToHex(bHmacHash[i], 2);
                  end
                  else
                   WriteLn( 'CryptGetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                end
                else
                  WriteLn( 'CryptHashData ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                {destroy hash-object}
                CryptDestroyHash(hHmacHash);
                CryptDestroyKey(hKey);
              end
              else
                WriteLn( 'CryptSetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

          end
          else
            WriteLn( 'CryptCreateHash ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
        end
        else
          WriteLn( 'CryptDeriveKey ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

      end;
      {destroy hash-object}
      CryptDestroyHash(hHash);
    end;
    {release the context for crypt default provider}
    CryptReleaseContext(hCryptProvider, 0);
  end;
  Result := AnsiLowerCase(Result);
end;
</code></pre>

<p>I'm obviously doing something incorrectly, but I'm no idea what ??</p>
","<p>So I found a solution, which when generating an HMAC_SHA1 for the data ""message"" with the key ""key"" generates the expected hash of 2088df74d5f2146b48146caf4965377e9d0be3a4</p>

<p>As you can see, this code uses <code>CryptImportKey</code> instead of <code>CryptDeriveKey</code>, which seems to resolve the issue. It seems that using CryptDeriveKey is actually generating an HMAC_SHA1 hash using the data ""message"" and the SHA1 Hash of the key ""key"" encoded as RC4 instead of the plaintext key as initially thought.</p>

<p>The code works for keys upto 16 characters in length, any larger and only uses the first 16 characters anyway. I'm posting a second quesiton to enquire about that!!</p>

<p>Code is posted below.</p>

<pre><code>function Hashhmacsha1(const Key, Value: AnsiString): AnsiString;
const
  KEY_LEN_MAX = 16;
var
  hCryptProvider: HCRYPTPROV;
  hHash: HCRYPTHASH;
  hKey: HCRYPTKEY;
  bHash: array[0..$7F] of Byte;
  dwHashLen: dWord;
  i: Integer;

  hPubKey : HCRYPTKey;
  hHmacHash: HCRYPTHASH;
  bHmacHash: array[0..$7F] of Byte;
  dwHmacHashLen: dWord;
  hmac_info : Wcrypt2.HMAC_INFO;

  keyBlob: record
    keyHeader: BLOBHEADER;
    keySize: DWORD;
    keyData: array[0..KEY_LEN_MAX-1] of Byte;
  end;
  keyLen : INTEGER;
begin
  dwHashLen := 32;
  dwHmacHashLen := 32;
  {get context for crypt default provider}
  if CryptAcquireContext(@hCryptProvider, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) then
  begin
    {create hash-object MD5}
    if CryptCreateHash(hCryptProvider, CALG_SHA1, 0, 0, @hHash) then
    begin

      {get hash from password}
      if CryptHashData(hHash, PByte(Key), Length(Key), 0) then
      begin

        // hHash is now a hash of the provided key, (SHA1)
        // Now we derive a key for it
        hPubKey := 0;

        FillChar(keyBlob, SizeOf(keyBlob), 0);
        keyBlob.keyHeader.bType := PLAINTEXTKEYBLOB;
        keyBlob.keyHeader.bVersion := CUR_BLOB_VERSION;
        keyBlob.keyHeader.aiKeyAlg := CALG_RC4;
        KeyBlob.keySize := KEY_LEN_MAX;

        if(Length(key) &lt; (KEY_LEN_MAX))then
          KeyLen := Length(key)
        else
          KeyLen := KEY_LEN_MAX;
        Move(Key[1], KeyBlob.keyData[0], KeyLen );

        if CryptImportKey(hCryptProvider, @keyBlob, SizeOf(KeyBlob), hPubKey, 0, @hKey) then
        begin

          //hkey now holds our key. So we have do the whole thing over again
          ZeroMemory( @hmac_info, SizeOf(hmac_info) );
          hmac_info.HashAlgid := CALG_SHA1;
          if CryptCreateHash(hCryptProvider, CALG_HMAC, hKey, 0, @hHmacHash) then
          begin
              if CryptSetHashParam( hHmacHash, HP_HMAC_INFO, @hmac_info, 0) then
              begin

                if CryptHashData(hHmacHash, @Value[1], Length(Value), 0) then
                begin
                  if CryptGetHashParam(hHmacHash, HP_HASHVAL, @bHmacHash[0], @dwHmacHashLen, 0) then
                  begin
                    for i := 0 to dwHmacHashLen-1 do
                      Result := Result + IntToHex(bHmacHash[i], 2);
                  end
                  else
                   WriteLn( 'CryptGetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                end
                else
                  WriteLn( 'CryptHashData ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                {destroy hash-object}
                CryptDestroyHash(hHmacHash);
                CryptDestroyKey(hKey);
              end
              else
                WriteLn( 'CryptSetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

          end
          else
            WriteLn( 'CryptCreateHash ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
        end
        else
          WriteLn( 'CryptDeriveKey ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

      end;
      {destroy hash-object}
      CryptDestroyHash(hHash);
    end;
    {release the context for crypt default provider}
    CryptReleaseContext(hCryptProvider, 0);
  end;
  Result := AnsiLowerCase(Result);
end;
</code></pre>
","1037","<delphi><delphi-xe5><cryptoapi><hmacsha1>","3","2","3","2014-09-29 04:23:17","25448769","8","1","80901","","2014-09-29 04:23:17","2014-08-21 21:41:21",""
"25436416","CryptoAPI returns incorrect result for HMAC_SHA1","<p>I'm using the code below with the Crypto API and I'm not getting the results I would expect based on testing with other API's and libraries.</p>

<p>I'm using the key, ""<strong>key</strong>"" and the data is ""<strong>message</strong>""</p>

<p>For example, using Indy's TidHMACSHA1, I get 2088df74d5f2146b48146caf4965377e9d0be3a4</p>

<p>I get the same result using online generators (such as <a href=""http://www.freeformatter.com/hmac-generator.html"" rel=""nofollow"">http://www.freeformatter.com/hmac-generator.html</a>, for example).</p>

<p>With the code I've written (see below) I get 4a52c3c0abc0a06049d1ab648bb4057e3ff5f359</p>

<p>The code is below, I'm using the JEDI wcrypt2.pas header</p>

<pre><code>function Hashhmacsha1(const Key, Value: AnsiString): AnsiString;
var
  hCryptProvider: HCRYPTPROV;
  hHash: HCRYPTHASH;
  hKey: HCRYPTKEY;
  bHash: array[0..$7F] of Byte;
  dwHashLen: dWord;
  i: Integer;


  hHmacHash: HCRYPTHASH;
  bHmacHash: array[0..$7F] of Byte;
  dwHmacHashLen: dWord;
  hmac_info : Wcrypt2.HMAC_INFO;
begin
  dwHashLen := 32;
  dwHmacHashLen := 32;
  {get context for crypt default provider}
  if CryptAcquireContext(@hCryptProvider, nil, nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT or CRYPT_MACHINE_KEYSET) then
  begin
    {create hash-object }
    if CryptCreateHash(hCryptProvider, CALG_SHA1, 0, 0, @hHash) then
    begin

      {get hash from password}
      if CryptHashData(hHash, @Key[1], Length(Key), 0) then
      begin

        // hHash is now a hash of the provided key, (SHA1)
        // Now we derive a key for it
        if CryptDeriveKey(hCryptProvider, CALG_RC4, hHash, 0, @hKey) then
        begin

          //hkey now holds our key. So we have do the whole thing over again
          //ZeroMemory( hmac_info, SizeOf(hmac_info) );
          hmac_info.HashAlgid := CALG_SHA1;
          if CryptCreateHash(hCryptProvider, CALG_HMAC, hKey, 0, @hHmacHash) then
          begin

            {get hash from password}

              if CryptSetHashParam( hHmacHash, HP_HMAC_INFO, @hmac_info, 0) then
              begin

                if CryptHashData(hHmacHash, @Value[1], Length(Value), 0) then
                begin
                  if CryptGetHashParam(hHmacHash, HP_HASHVAL, @bHmacHash[0], @dwHmacHashLen, 0) then
                  begin
                    for i := 0 to dwHmacHashLen-1 do
                      Result := Result + IntToHex(bHmacHash[i], 2);
                  end
                  else
                   WriteLn( 'CryptGetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                end
                else
                  WriteLn( 'CryptHashData ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
                {destroy hash-object}
                CryptDestroyHash(hHmacHash);
                CryptDestroyKey(hKey);
              end
              else
                WriteLn( 'CryptSetHashParam ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

          end
          else
            WriteLn( 'CryptCreateHash ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;
        end
        else
          WriteLn( 'CryptDeriveKey ERROR --&gt; ' + SysErrorMessage(GetLastError)) ;

      end;
      {destroy hash-object}
      CryptDestroyHash(hHash);
    end;
    {release the context for crypt default provider}
    CryptReleaseContext(hCryptProvider, 0);
  end;
  Result := AnsiLowerCase(Result);
end;
</code></pre>

<p>I'm obviously doing something incorrectly, but I'm no idea what ??</p>
","<p>I was able to get the correct result for keys longer than 16 bytes by using OpenSLL. Instead of about 10 Win32 Crypt calls, it was done in three: init, HMAC, and cleanup.</p>
","1037","<delphi><delphi-xe5><cryptoapi><hmacsha1>","3","1","3","2014-09-29 04:23:17","25448769","8","1","80901","","2014-09-29 04:23:17","2014-08-21 21:41:21",""
"12538524","Certificate context from system store always has an invalid pbCertEncoded pointer","<p>I'm trying to use CertEnumCertificatesInStore() in the CryptoAPI to iterate through all the root certificates and encode them into PEM files for use with OpenSSL. I've found a few examples of this so it seems to be possible, however, the PCCERT_CONTEXT I get back for each certificate has an invalid pointer for pbCertEncoded and cbCertEncoded (buffer size) is always 0, but I do not feel this should be the case as examples use the encoded buffer to convert the certificate into other formats. Has anyone else run into this issue of getting an empty buffer or can see a step i'm missing?</p>

<p>I've verified I am actually getting the certificates with the CryptUIDlgViewContext() function. I feel like I'm missing something very basic. Basic code below:</p>

<pre><code>HCERTSTORE hStore = CertOpenSystemStore(NULL, L""ROOT"");

for ( PCCERT_CONTEXT pCertContext = CertEnumCertificatesInStore(hStore, NULL); pCertContext != NULL; pCertContext = CertEnumCertificatesInStore(hStore, pCertContext) )
    {

        // This shows the certificates fine
        CryptUIDlgViewContext(CERT_STORE_CERTIFICATE_CONTEXT,  pCertContext, NULL, NULL, 0, NULL)

        // but
        // pCertContext-&gt;pbCertEncoded is a Bad Ptr and
        // pCertContext-&gt;cbCertEncoded is always 0

        // If i try
        TCHAR *OutString = NULL;
        DWORD Size = 0;
        DWORD lastError;
        BOOL success = CryptBinaryToString(pCertContext-&gt;pbCertEncoded, pCertContext-&gt;cbCertEncoded, CRYPT_STRING_BASE64,OutString, &amp;Size); 

        if( !success )
        {
            // I get a invalid parameter error here.
            lastError = GetLastError();
        }        
    }
</code></pre>
","<p>The encoded buffer does not get filled out when compiled in 64-bit. Compiling in 32 bit seems to solve this problem.</p>
","1037","<c++><windows><ssl-certificate><cryptoapi>","2","0","1","2012-09-25 16:42:37","","3","0","1490203","","2012-09-24 18:50:09","2012-09-21 21:39:12",""
"517628","P/Invoking CryptImportKey and marshaling structs","<p>I'm trying to P/Invoke into CryptImportKey from C# to set a known key before encrypting data that will be decrypted in a C++ Win32 service at some point.  I have the method signature for the P/Invoke and that all works fine but i can't get it to accept my key blob.  The C++ structs are in comments below and my C# ones for marshaling are underneath.</p>

<pre><code>        // typedef struct _PUBLICKEYSTRUC 
    // {
    //    BYTE bType;  
    //    BYTE bVersion;  
    //    WORD reserved;  
    //    ALG_ID aiKeyAlg;
    // } BLOBHEADER, PUBLICKEYSTRUC;
    [StructLayout(LayoutKind.Sequential)]
    public struct PUBLICKEYSTRUC
    {
        public Byte bType;
        public Byte bVersion;
        public Int16 reserved;
        public Int32 aiKeyAlg;
    }

    //typedef struct __KEYBLOB 
    //{
    //    BLOBHEADER hdr;
    //    DWORD cbKeySize;
    //    BYTE* rgbKeyData;
    //} KEYBLOB;

    [StructLayout(LayoutKind.Sequential)]
    public struct KEYBLOB
    {
        public PUBLICKEYSTRUC hdr;
        public Int16 cbKeySize;
        public Byte[] rgbKeyData;
    }
</code></pre>

<p>I then use:</p>

<pre><code>        int len = (Marshal.SizeOf(typeof(PUBLICKEYSTRUC) + Marshal.SizeOf(typeof(KEYBLOB)) + KeySize;
        byte[] arr = new byte[len];
        IntPtr ptr = Marshal.AllocHGlobal(len);
    Marshal.StructureToPtr(keyBlob, ptr, true);
    Marshal.Copy(ptr, arr, 0,len);
        Marshal.FreeHGlobal(ptr);
</code></pre>

<p>To get in to a byte array to pass to CryptImportKey but it never seems to take the key with it and when I encrypt with it I get different cipher text time suggesting it's not using my key.</p>

<p>EDIT:</p>

<p>The key blob stuff is from the C++ code I have that can successfully encrypt and decrypt the data.  I think you maybe have a point about the header being included twice but the main problem I have is the value of the Byte[] rgbKeyData is not being put in to the byte array arr.</p>
","<p><a href=""http://blogs.msdn.com/alejacma/archive/2007/11/23/p-invoking-cryptoapi-in-net-c-version.aspx"" rel=""nofollow noreferrer"">Here</a> is a list of structs / imports, which look quite promising. Haven't tested it by myself, though.</p>

<p><strong>Edit:</strong><br>
When you compute the size of your blob: could it be you're actually counting the header twice? Besides, how did you derive the declaration of your KEYBLOB structure?</p>
","1030","<c#><pinvoke><cryptoapi>","0","0","2","2016-01-09 14:42:30","","0","0","3563993","DotNetWill","2016-01-09 14:42:30","2009-02-05 19:52:39",""
"517628","P/Invoking CryptImportKey and marshaling structs","<p>I'm trying to P/Invoke into CryptImportKey from C# to set a known key before encrypting data that will be decrypted in a C++ Win32 service at some point.  I have the method signature for the P/Invoke and that all works fine but i can't get it to accept my key blob.  The C++ structs are in comments below and my C# ones for marshaling are underneath.</p>

<pre><code>        // typedef struct _PUBLICKEYSTRUC 
    // {
    //    BYTE bType;  
    //    BYTE bVersion;  
    //    WORD reserved;  
    //    ALG_ID aiKeyAlg;
    // } BLOBHEADER, PUBLICKEYSTRUC;
    [StructLayout(LayoutKind.Sequential)]
    public struct PUBLICKEYSTRUC
    {
        public Byte bType;
        public Byte bVersion;
        public Int16 reserved;
        public Int32 aiKeyAlg;
    }

    //typedef struct __KEYBLOB 
    //{
    //    BLOBHEADER hdr;
    //    DWORD cbKeySize;
    //    BYTE* rgbKeyData;
    //} KEYBLOB;

    [StructLayout(LayoutKind.Sequential)]
    public struct KEYBLOB
    {
        public PUBLICKEYSTRUC hdr;
        public Int16 cbKeySize;
        public Byte[] rgbKeyData;
    }
</code></pre>

<p>I then use:</p>

<pre><code>        int len = (Marshal.SizeOf(typeof(PUBLICKEYSTRUC) + Marshal.SizeOf(typeof(KEYBLOB)) + KeySize;
        byte[] arr = new byte[len];
        IntPtr ptr = Marshal.AllocHGlobal(len);
    Marshal.StructureToPtr(keyBlob, ptr, true);
    Marshal.Copy(ptr, arr, 0,len);
        Marshal.FreeHGlobal(ptr);
</code></pre>

<p>To get in to a byte array to pass to CryptImportKey but it never seems to take the key with it and when I encrypt with it I get different cipher text time suggesting it's not using my key.</p>

<p>EDIT:</p>

<p>The key blob stuff is from the C++ code I have that can successfully encrypt and decrypt the data.  I think you maybe have a point about the header being included twice but the main problem I have is the value of the Byte[] rgbKeyData is not being put in to the byte array arr.</p>
","<p>On the other hand, why are you even bothering with all this P/Invoke stuff here? The .NET Framework has built-in classes to do all this for you.  </p>

<p>Assuming you're using RSA encryption, the RSACryptoServiceProvider class provides an ImportParameters method that accepts a RSAParameters object.<br>
Clean, simple, and the right way to do it.  </p>

<p>Is there any reason you can't use this?</p>
","1030","<c#><pinvoke><cryptoapi>","0","0","2","2016-01-09 14:42:30","","0","0","3563993","DotNetWill","2016-01-09 14:42:30","2009-02-05 19:52:39",""
"14661612","Login with CryptoAPI on a USB Token","<p>Is there a way to login on a usb toke (iKey 4000) using CryptoAPI ? (Juts ot be clear, it's not about login with the token but on it) I know I can do that using Pkcs11. I need that in order to avoid the login dialog that is shown by the authentication client provided at the first operation that access the token.</p>

<p>Thanks in advance,
Jacques</p>
","<p>Can This token be used with CryptoAPI (Microsoft Base Smart Card Crypto Provider) ? If no, the ""smart card minidriver"" is missing for this token and you are not able to deal anything with them through CryptoAPI.</p>

<p>Otherwise, you need to acquire context of any key container on this token and use <code>CryptSetProvParam</code> function with parameter <code>PP_KEYEXCHANGE_PIN</code> or <code>PP_SIGNATURE_PIN</code>.</p>

<p>Note, that logging into the smart card or token in one application may not lead to ""logged in"" state for other applications.</p>
","1004","<login><cryptoapi><e-token>","1","0","2","2013-02-04 17:13:57","","0","","","","","2013-02-02 11:52:52",""
"14661612","Login with CryptoAPI on a USB Token","<p>Is there a way to login on a usb toke (iKey 4000) using CryptoAPI ? (Juts ot be clear, it's not about login with the token but on it) I know I can do that using Pkcs11. I need that in order to avoid the login dialog that is shown by the authentication client provided at the first operation that access the token.</p>

<p>Thanks in advance,
Jacques</p>
","<p>Well, trying to address your issues:</p>

<p>No idea if It can be used with Microsoft Base Smart Card Crypto Provider, and there will be no other application using it, so it being stuck with this service is ok.</p>

<p>Your suggestion worked but I had to use PP_ADMIN_PIN instead of PP_KEYEXCHANGE_PIN or PP_SIGNATURE_PIN.</p>

<p>Thanks.</p>
","1004","<login><cryptoapi><e-token>","1","0","2","2013-02-04 17:13:57","","0","","","","","2013-02-02 11:52:52",""
"23824389","Importing pfx/p12 file into smartcard c#","<p>Is there a way to Import a <code>.p12/pfx</code> file to Smartcard programmatically? I know it works via <code>certutil</code>:</p>

<pre><code>certutil -user -p ""pw"" -csp ""csp"" -importpfx path
</code></pre>

<p>I am using ""Microsoft Base Smart Card Crypto Provider""</p>

<p>Via certutil it is working thus I am sure it also should using c# (maybe CRYPTOAPI)...I just don´t want to use kind of (starting cmd adding the ""Import string""): </p>

<pre><code>System.Diagnostics.Process process = new System.Diagnostics.Process();
System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;  
startInfo.FileName = ""cmd.exe"";            
startInfo.Arguments = strCmdText;           
process.StartInfo = startInfo;            
process.Start();
</code></pre>

<p>to Import the pfx! </p>

<p>But I have no clue how this could work programmatically in c#. Any help will be appreciated.</p>
","<p>You can import a PFX/P12 file into a smart card using C# by combining the use of the class X509Certificate2 that provides parsing of the PFX/P12 file and P/Invoking CryptoAPI functions in order to perform the actual import.</p>

<p>I have implemented this in a C# console program that replicate certutil import functionality. You can get its source code from <a href=""http://www.idrix.fr/Root/Samples/PfxImporter.cs"" rel=""nofollow"">http://www.idrix.fr/Root/Samples/PfxImporter.cs</a> .</p>

<p>I also implemented this in C++ if anyone is interested. Here is the source : <a href=""http://www.idrix.fr/Root/Samples/PfxImporter.cpp"" rel=""nofollow"">http://www.idrix.fr/Root/Samples/PfxImporter.cpp</a> .</p>

<p>Last point: As documented in the smart card minidriver specification, two registry keys must be modified to permit the import operation using the MS Base CSP  :</p>

<ol>
<li>HKLM\SOFTWARE\Microsoft\Cryptography\Defaults\Provider\Microsoft Base Smart Card Crypto Provider\ <strong>AllowPrivateExchangeKeyImport</strong> = DWORD:0x01</li>
<li>HKLM\SOFTWARE\Microsoft\Cryptography\Defaults\Provider\Microsoft Base Smart Card Crypto Provider\ <strong>AllowPrivateSignatureKeyImport</strong> = DWORD:0x01</li>
</ol>
","985","<c#><certificate><smartcard><cryptoapi>","0","1","1","2014-09-29 07:09:29","26094282","3","0","3406465","","2014-05-28 07:05:33","2014-05-23 08:27:00",""
"4816610","Porting Microsoft CryptoAPI to Mac OS","<p>I have a windows application (Visual Studio is used) that uses
Microsoft CryptoAPI. Now it is required to develop a Mac OS X
application, that is capable to read data, encrypted by the WinApp,
and encrypt data on Mac OS X, that will be decrypted by the WinApp.
Encryption/decription in the WinApp initialized in the such way:</p>

<pre><code>::CryptAcquireContext(&amp;m_hCryptProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
::CryptCreateHash(m_hCryptProv, CALG_MD5, 0, 0, &amp;m_hCryptHash);
::CryptHashData(m_hCryptHash, pbtPSW, dwPSWLen, 0);
::CryptDeriveKey(m_hCryptProv, CALG_RC4, m_hCryptHash, 0, &amp;m_hCryptKey);
</code></pre>

<p>And for encryption/decription the following is used:</p>

<pre><code>::CryptEncrypt(m_hCryptKey, 0, TRUE, 0, pBuf, &amp;dwCnt, dwLen);
::CryptDecrypt(m_hCryptKey, 0, TRUE, 0, pBuf, &amp;dwCnt);
</code></pre>

<p>As I understand, I need to find a library that implements MD5
hashing plus RC4 encoding/decoding. It seems that there are a
number of such libraries. For example: matrixSSL, OpenSSL. But
using of the libraries for my puproses is not obvious (especially
taking into account, that I am not familiar with Sequrity/Crypting
APIs). Could somebody recommend a particular ciphering library? May
be there are code examples for my task?</p>

<p>ADDITION:</p>

<p>It seems the main problem is that I need a portable analog of the ::CryptDeriveKey, that is compatible with Microsoft version (i.e. generates the same key). Does anybody know a such one? Or an algorithm of creating a key by the ::CryptDeriveKey?</p>
","<p>I would recommend taking a look at the CyaSSL embedded SSL library. It supports the current standards up to TLS 1.2 and is very portable across operating systems. In particular, CyaSSL includes the CTaoCrypt cryptographic library which should let you perform the crypto operations you're looking for.</p>

<p>Some helpful documentation links for CyaSSL:<br/></p>

<p>CTaoCrypt Usage Reference: <a href=""http://yassl.com/yaSSL/Docs_CTaoCrypt_Usage_Reference.html"" rel=""nofollow"">http://yassl.com/yaSSL/Docs_CTaoCrypt_Usage_Reference.html</a><br/>
CyaSSL Docs Page: <a href=""http://yassl.com/yaSSL/Docs.html"" rel=""nofollow"">http://yassl.com/yaSSL/Docs.html</a><br/></p>

<p>If you download CyaSSL, you'll find a Visual Studio project file to take a look at as well.</p>

<p>Regards,<br/>
Chris</p>
","984","<macos><cryptoapi>","0","1","1","2015-11-10 00:34:50","4831424","3","","1505120","","2015-11-10 00:34:50","2011-01-27 13:00:26",""
"50445252","ECDSA signing in c# verify in c","<p>I'm trying to sign data in C#, using ECDSA algorithm (this part looks OK) and to verify signature in C using Windows crypto API. </p>

<p>Signature part:</p>

<pre><code>CngKeyCreationParameters keyCreationParameters = new CngKeyCreationParameters();
keyCreationParameters.ExportPolicy = CngExportPolicies.AllowPlaintextExport;
keyCreationParameters.KeyUsage = CngKeyUsages.Signing;

CngKey key = CngKey.Create(CngAlgorithm.ECDsaP256, null, keyCreationParameters);

ECDsaCng dsa = new ECDsaCng(key); //dsa = Digital Signature Algorithm
byte[] privateKey = dsa.Key.Export(CngKeyBlobFormat.EccPrivateBlob);
File.WriteAllText(""privatekey.txt"", String.Join("","", privateKey));


byte[] publicKey = dsa.Key.Export(CngKeyBlobFormat.EccPublicBlob);
File.WriteAllText(""publicKey.txt"", String.Join("","", publicKey));


CngKey importedKey = CngKey.Import(File.ReadAllText(""privatekey.txt"").Split(',').Select(m =&gt; byte.Parse(m)).ToArray(), CngKeyBlobFormat.EccPrivateBlob);
ECDsaCng importedDSA = new ECDsaCng(importedKey); //dsa = Digital Signature Algorithm
byte[] signed = dsa.SignData(new byte[] { 1, 2, 3, 4, 5 });
File.WriteAllText(""signed.txt"", String.Join("","", signed));
</code></pre>

<p>At this point I'm able to create a signature key and export it to a byte buffer in a file. </p>

<p>Problems come when I'm trying to import this public key in C using windows crypto API. </p>

<pre><code>BYTE KeyBlob[] = { // public key exported by above c# code
    69,67,83,49,32,0,0,0,227,146,138,255,218,235,122,141,44,110,211,95,59,227,226,163,81,188,242,115,60,171,46,141,221,117,169,139,42,143,67,85,144,242,232,188,22,158,230,15,110,6,214,252,252,242,224,241,110,186,1,244,176,65,88,184,94,19,98,174,158,7,154,152
};

int _tmain()
{
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    DWORD dwBlobLen;
    BYTE* pbKeyBlob;

    if (!CryptAcquireContext(
        &amp;hProv,
        NULL,
        MS_ENHANCED_PROV,
        PROV_RSA_FULL,
        CRYPT_VERIFYCONTEXT))
    {
        printf("" Error in AcquireContext 0x%08x \n"", GetLastError());
        return 1;
    }

    if (!CryptImportKey(
        hProv,
        KeyBlob,
        sizeof(DesKeyBlob),
        0,
        CRYPT_EXPORTABLE,
        &amp;hKey))
    {
        printf(""Error 0x%08x in importing the key \n"",
            GetLastError());
    }
</code></pre>

<p>which returns </p>

<blockquote>
  <p>Error 0x80090007 in importing the key</p>
</blockquote>

<p>which is (believing winerror.h) : </p>

<pre><code>//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
// Bad Version of provider.
//
#define NTE_BAD_VER                      _HRESULT_TYPEDEF_(0x80090007L)
</code></pre>

<p>What do I do wrong?</p>
","<p>Thanks to this wonderful website I just found : <a href=""https://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/ECDsaCng.cs,f2a745a1429f12af"" rel=""nofollow noreferrer"">referencesouce.microsoft.com</a>, I've been able to disassemble what the C# API does when verifying a signature and importing a key. </p>

<p>Apparently I need ncrypt/bcrypt, and signature is verified against a hash, and not the data itself:</p>

<pre><code>public bool VerifyData(Stream data, byte[] signature) {
            if (data == null) {
                throw new ArgumentNullException(""data"");
            }
            if (signature == null) {
                throw new ArgumentNullException(""signature"");
            }

            using (BCryptHashAlgorithm hashAlgorithm = new BCryptHashAlgorithm(HashAlgorithm, BCryptNative.ProviderName.MicrosoftPrimitiveProvider)) {
                hashAlgorithm.HashStream(data);
                byte[] hashValue = hashAlgorithm.HashFinal();

                return VerifyHash(hashValue, signature);
            }
        }

        [SecuritySafeCritical]
        public override bool VerifyHash(byte[] hash, byte[] signature) {
            if (hash == null) {
                throw new ArgumentNullException(""hash"");
            }
            if (signature == null) {
                throw new ArgumentNullException(""signature"");
            }

            // We need to get the raw key handle to verify the signature. Asserting here is safe since verifiation
            // is not a protected operation, and we do not expose the handle to the user code.
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Assert();

            // This looks odd, but Key.Handle is really a duplicate so we need to dispose it
            using (SafeNCryptKeyHandle keyHandle = Key.Handle) {
                CodeAccessPermission.RevertAssert();

                return NCryptNative.VerifySignature(keyHandle, hash, signature);
            }
        }
</code></pre>

<p>Here is a native solution, for whoever needs that: </p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;stdio.h&gt;

char key[72] = { 69,67,83,49,32,0,0,0,227,146,138,255,218,235,122,141,44,110,211,95,59,227,226,163,81,188,242,115,60,171,46,141,221,117,169,139,42,143,67,85,144,242,232,188,22,158,230,15,110,6,214,252,252,242,224,241,110,186,1,244,176,65,88,184,94,19,98,174,158,7,154,152 };
char sign[64] = { 165,50,54,149,14,175,128,54,21,30,129,165,137,203,45,123,180,121,118,20,15,61,253,186,65,129,21,26,54,84,40,205,103,254,108,34,126,205,116,183,44,189,5,180,28,119,228,70,127,116,227,248,232,144,53,226,185,251,217,179,148,88,208,152 };
char message[] = { 1, 2, 3, 4, 5 };

BOOL crypt_init(char* key, unsigned long key_len)
{
    HCRYPTPROV    hProv = NULL;

    BCRYPT_ALG_HANDLE       hHashAlg = NULL, hSignAlg = NULL;
    BCRYPT_HASH_HANDLE      hHash = NULL;
    PBYTE                   pbHash = NULL;
    PBYTE                   pbHashObject = NULL;
    DWORD                   cbHashObject = 0,
                            cbHash = 0,
                            cbData = 0;

    NTSTATUS status;

    if (ERROR_SUCCESS != NCryptOpenStorageProvider(&amp;hProv, NULL, 0)) {
        printf(""CryptAcquireContext failed - err=0x%x.\n"", GetLastError());
        return FALSE;
    }

    NCRYPT_KEY_HANDLE keyHandle;

    if (ERROR_SUCCESS != NCryptImportKey(hProv, NULL, BCRYPT_ECCPUBLIC_BLOB, NULL, &amp;keyHandle, (PBYTE)key, 72, 0)) {
        printf(""CryptAcquireContext failed - err=0x%x.\n"", GetLastError());
        return FALSE;
    }

    if (!BCRYPT_SUCCESS(status = BCryptOpenAlgorithmProvider(
        &amp;hHashAlg,
        BCRYPT_SHA256_ALGORITHM,
        NULL,
        0)))
    {
        printf(""BCryptOpenAlgorithmProvider failed - err=0x%x.\n"", status);
        return false;
    }

    if(!BCRYPT_SUCCESS(status = BCryptGetProperty(hHashAlg, BCRYPT_OBJECT_LENGTH, (PBYTE)&amp;cbHashObject, sizeof(DWORD), &amp;cbData, 0))) {
        printf(""BCryptGetProperty failed - err=0x%x.\n"", status);
        return FALSE;
    }

    pbHashObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHashObject);
    if (NULL == pbHashObject) {
        printf(""memory allocation failed\n"");
        return FALSE;
    }

    if (!BCRYPT_SUCCESS(status = BCryptGetProperty(hHashAlg, BCRYPT_HASH_LENGTH, (PBYTE)&amp;cbHash, sizeof(DWORD), &amp;cbData, 0))) {
        printf(""BCryptGetProperty failed - err=0x%x.\n"", status);
        return FALSE;
    }

    pbHash = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHash);
    if (NULL == pbHash)
    {
        printf(""memory allocation failed\n"");
        return FALSE;
    }

    if (!BCRYPT_SUCCESS(status = BCryptCreateHash(hHashAlg, &amp;hHash, pbHashObject, cbHashObject, NULL, 0, 0)))
    {
        printf(""BCryptCreateHash failed - err=0x%x.\n"", status);
        return FALSE;
    }

    if (!BCRYPT_SUCCESS(status = BCryptHashData(hHash, (PBYTE)message, sizeof(message), 0)))
    {
        printf(""BCryptHashData failed - err=0x%x.\n"", status);
        return FALSE;
    }

    if (!BCRYPT_SUCCESS(status = BCryptFinishHash(hHash, pbHash, cbHash, 0)))
    {
        printf(""BCryptFinishHash failed - err=0x%x.\n"", status);
        return FALSE;
    }

    if(ERROR_SUCCESS != NCryptVerifySignature(keyHandle, NULL, pbHash, cbHash, (PBYTE) sign, sizeof(sign), 0)) {
        printf(""BCryptVerifySignature failed - err=0x%x.\n"", status);
        return FALSE;
    }


    return TRUE;
}

int main() {
    crypt_init(key, 72);
}
</code></pre>
","983","<c#><c><signing><cryptoapi><dsa>","2","1","1","2018-05-21 12:03:52","50447287","0","","1669370","","2018-05-21 09:49:11","2018-05-21 08:58:51",""
"14541142","how to pass the string to this MD5 program.?","<p>am trying to implement an application that uses an MD5 hash underneath, i have acquired the MD5 hash program from the internet, but i don't know how to pass the string from my program ( my program written in C) to the program that calculate the MD5 hash.</p>

<p>this is the main of the program that calculate the MD5 hash..</p>

<pre><code>//
// MD5 Hashing Example - Using Windows Crypto API
//
// by Napalm @ NetCore2K
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include ""winmd5.h""
HCRYPTPROV hCryptProv;

int main(int argc, char *argv[])
{
    int i;
    CryptStartup();
    if(argc &gt; 1){
        MD5Context ctx;
        MD5Init(&amp;ctx);
        MD5Update(&amp;ctx, (unsigned char *)argv[1], strlen(argv[1]));
        MD5Final(&amp;ctx);
        for(i = 0; i &lt; 16; i++)
            printf(""%02x"", ctx.digest[i]);
        printf(""\n"");
    }else
        printf(""Usage: %s &lt;string&gt;\n"", argv[0]);
    CryptCleanup();
    return 0;
}
</code></pre>

<p>this is the header file content..</p>

<pre><code>//
// MD5 Hashing Example - Using Windows Crypto API
//
// by Napalm @ NetCore2K
//
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
extern HCRYPTPROV hCryptProv;

void PrintMD5(const char *);

typedef struct {

unsigned char digest[16];
unsigned long hHash;
} MD5Context;
BOOL CryptStartup()
{


if(CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET) == 0){
    if(GetLastError() == NTE_EXISTS){
    if(CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0) == 0){
            return FALSE;
        }   
    }
    else return FALSE;
}
return TRUE;
}
void CryptCleanup()
{
if(hCryptProv) CryptReleaseContext(hCryptProv, 0);
hCryptProv = NULL;
}
void inline MD5Init(MD5Context *ctx)
{ 
CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &amp;ctx-&gt;hHash);
}
void inline MD5Update(MD5Context *ctx, unsigned char const *buf, unsigned len)
{
CryptHashData(ctx-&gt;hHash, buf, len, 0);
}
void inline MD5Final(MD5Context *ctx)
{
DWORD dwCount = 16;
CryptGetHashParam(ctx-&gt;hHash, HP_HASHVAL, ctx-&gt;digest, &amp;dwCount, 0);
if(ctx-&gt;hHash) CryptDestroyHash(ctx-&gt;hHash);
ctx-&gt;hHash = 0;
}
void PrintMD5(const char *s)
{
MD5Context ctx;
MD5Init(&amp;ctx);
MD5Update(&amp;ctx, (const unsigned char *)s, strlen(s));
MD5Final(&amp;ctx);

int i;
for (i = 0; i &lt; 16; i++) {
    printf(""%02x"", ctx.hHash[i]);
}

printf(""\n"");
 }
</code></pre>

<p>how should i call this Main(), and how to pass the String to it and get the result.?
thanks in advance.</p>

<p>Regards</p>
","<p>You don't call <code>main()</code> again. You rather use this program as an example to write a separate function, like this:</p>

<pre><code>void PrintMD5(const char *s)
{
    MD5Context ctx;
    MD5Init(&amp;ctx);
    MD5Update(&amp;ctx, (const unsigned char *)s, strlen(s));
    MD5Final(&amp;ctx);

    int i;
    for (i = 0; i &lt; 16; i++) {
        printf(""%02x"", ctx.digest[i]);
    }

    printf(""\n"");
}
</code></pre>

<p>Then you can call this from your own program like:</p>

<pre><code>PrintMD5(""FooBarHelloWorld42"");
</code></pre>
","982","<c><md5><argument-passing><cryptoapi>","0","0","1","2013-01-26 20:49:22","14541171","1","","1949131","","2013-01-26 20:49:22","2013-01-26 20:14:22",""
"29112039","CryptSignHash Error 2148073494 ""Keyset does not exist""?","<p>I'm using a strange language called CA-Visual Objects. I am trying to verify a hash signature I have created in C#. But on calling the CryptSignHash function I get the error code 2148073494 which I believe maps to ""Keyset does not exist"".</p>

<pre><code>CryptAcquireContext( @hCryptProvider, NULL_PTR, NULL_PTR, PROV_RSA_FULL, 0) //returns true
CryptCreateHash(hCryptProvider, CALG_SHA1, 0, 0, @hHash) //returns true
CryptHashData(hHash, pData, dwDataLen, 0) //returns true
CryptImportKey(hCryptProvider, pKeyBlob, cbKeyBlob, 0, 0, @hKey) //returns true
CryptSignHashA(hHash, AT_SIGNATURE, null, 0, NULL, @dwSignLen) //returns false with error code 2148073494 
</code></pre>

<p>I am not very familiar with this API, can someone tell me what ""Keyset"" doesn't exist exactly? Is it the AT_SIGNATURE? or something else?</p>

<p>This is the C# code to sign the data:</p>

<pre><code> private static void CreateSigningKey()
    {
        CspParameters p = new CspParameters();
        p.KeyNumber = (int)KeyNumber.Signature;

        using (RSACryptoServiceProvider rsaCreateSigningKey = new RSACryptoServiceProvider(2048, p))
        {
            rsaCreateSigningKey.PersistKeyInCsp = false;
            var parameters = rsaCreateSigningKey.ExportParameters(false);
            byte[] ex = parameters.Exponent;
            byte[] mod = parameters.Modulus;
            File.WriteAllBytes(publicSigningKeyPathMod, mod);
            File.WriteAllBytes(publicSigningKeyPathExp, ex);
            File.WriteAllText(privateSigningKeyPath, rsaCreateSigningKey.ToXmlString(true));
        }
    }


private static string Sign(byte[] plainBytes)
    {
        string signatureText;

        CspParameters parameters = new CspParameters();
        parameters.KeyNumber = (int) KeyNumber.Signature;

        using (RSACryptoServiceProvider rsaSign = new RSACryptoServiceProvider(2048)) //signing with private sign key
        {
            rsaSign.PersistKeyInCsp = false;
            rsaSign.FromXmlString(File.ReadAllText(privateSigningKeyPath)); //private sign key is held here at BP

            SHA1Managed hash = new SHA1Managed();
            byte[] hashByte = hash.ComputeHash(plainBytes);

            RSAPKCS1SignatureFormatter signFormatter = new RSAPKCS1SignatureFormatter(rsaSign);
            signFormatter.SetHashAlgorithm(""SHA1"");
            byte[] signature = signFormatter.CreateSignature(hashByte);

            signatureText = Convert.ToBase64String(signature);
        }
        return signatureText;
    }
</code></pre>
","","973","<c#><hash><rsa><cryptoapi>","2","","0","2015-03-18 00:15:08","","0","","","","","2015-03-18 00:15:08",""
"16335428","HMAC-MD5 with CryptoApi","<p>I have adopted the <a href=""http://msdn.microsoft.com/en-us/library/aa382379%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">SHA1 HMAC example</a> from Microsoft's website and modified it according to this <a href=""https://stackoverflow.com/questions/7103961/to-implement-hmac-md5-crypto-algorithm-in-an-win32-application"">stack-overflow post</a> and some other suggestions on the Internet, however I am unable to produce correct values.</p>

<p>Basically I just replaced SHA1 with MD5 CALG_SHA1 -> CALG_MD5.</p>

<p>Does anyone have a working example?</p>

<p>Does it matter what algo is used for CryptDeriveKey() for the password (RC2 or RC4)?</p>

<p>Thanks!</p>

<p><strong>Edit:</strong>
Found working code <a href=""http://masm32.com/board/index.php?topic=1612.0"" rel=""nofollow noreferrer"">here</a></p>
","<p>Your values are different from examples cause you use different keys:
Example values can be obtained using Linux <code>openssl dgst -md5 -hmac key &lt; input</code> command. This command uses key <em>as is</em> if its length smaller than MD5 hash block length (64 bytes) otherwise its uses MD5(key) as key and not key derived using CryptDeriveKey(RC4, MD5(key)) like in your implementation.</p>
","924","<c><windows><winapi><cryptoapi>","2","1","1","2013-05-07 12:12:00","","3","1","-1","","2017-05-23 12:15:19","2013-05-02 10:11:16",""
"2452470","Javascript digital signatures","<p>To create a digital signature with the client certificate in javascript, there was a function: crypto.signtext() that doesn't work anymore</p>

<p>What is the easiest way to do this now?</p>
","<p><a href=""https://developer.mozilla.org/en/JavaScript_crypto#Signing_text"" rel=""nofollow noreferrer"">It hasn't gone away</a>, it's just you have to spell it with a capital <code>T</code>. And still being Netscape/Mozilla/Firefox-only, it's of limited usefulness.</p>
","884","<javascript><encryption><cryptoapi>","3","1","2","2017-01-09 17:10:57","","0","","","","","2010-03-16 06:16:55",""
"2452470","Javascript digital signatures","<p>To create a digital signature with the client certificate in javascript, there was a function: crypto.signtext() that doesn't work anymore</p>

<p>What is the easiest way to do this now?</p>
","<p>For me, the best solution is to use a browser extension like <a href=""https://webpki.lacunasoftware.com"" rel=""nofollow noreferrer"">WebPKI</a></p>
","884","<javascript><encryption><cryptoapi>","3","0","2","2017-01-09 17:10:57","","0","","","","","2010-03-16 06:16:55",""
"46837740","Restore RSA private key by modulus, public and private exponents using Java Security","<p>I'm trying to find Java (native or BouncyCastle provider) implementation for generating a RSA private key in PKCS#1 using given params {e,n,d}.</p>

<p>There is <a href=""http://www.ams.org/notices/199902/boneh.pdf"" rel=""nofollow noreferrer"">paper</a> by Dan Boneh that describes an algorithm for doing so. The solution is available in PyCrypto (Python), as well as there is a standalone <a href=""http://rsaconverter.sourceforge.net/"" rel=""nofollow noreferrer"">utility</a> posted by Mounir IDRASSI that converts RSA keys between the SFM format (n,e,d) and CRT format (p,q,dp,dq,u), and the other way around. However I was not able to find anything ready to use for Java.</p>

<p>Update: I found such implementation at <a href=""https://github.com/martinpaljak/RSAKeyConverter/blob/master/src/opensc/RSAKeyConverter.java"" rel=""nofollow noreferrer"">https://github.com/martinpaljak/RSAKeyConverter/blob/master/src/opensc/RSAKeyConverter.java</a></p>
","<p>I provided some code in <a href=""https://stackoverflow.com/a/43147199/238704"">this</a> answer which I will reproduce here:</p>

<pre class=""lang-java prettyprint-override""><code>/**
 * Find a factor of n by following the algorithm outlined in Handbook of Applied Cryptography, section
 * 8.2.2(i). See http://cacr.uwaterloo.ca/hac/about/chap8.pdf.
 *
 */

private static BigInteger findFactor(BigInteger e, BigInteger d, BigInteger n) {
    BigInteger edMinus1 = e.multiply(d).subtract(BigInteger.ONE);
    int s = edMinus1.getLowestSetBit();
    BigInteger t = edMinus1.shiftRight(s);

    for (int aInt = 2; true; aInt++) {
        BigInteger aPow = BigInteger.valueOf(aInt).modPow(t, n);
        for (int i = 1; i &lt;= s; i++) {
            if (aPow.equals(BigInteger.ONE)) {
                break;
            }
            if (aPow.equals(n.subtract(BigInteger.ONE))) {
                break;
            }
            BigInteger aPowSquared = aPow.multiply(aPow).mod(n);
            if (aPowSquared.equals(BigInteger.ONE)) {
                return aPow.subtract(BigInteger.ONE).gcd(n);
            }
            aPow = aPowSquared;
        }
    }

}

public static RSAPrivateCrtKey createCrtKey(RSAPublicKey rsaPub, RSAPrivateKey rsaPriv) throws NoSuchAlgorithmException, InvalidKeySpecException {

    BigInteger e = rsaPub.getPublicExponent();
    BigInteger d = rsaPriv.getPrivateExponent();
    BigInteger n = rsaPub.getModulus();
    BigInteger p = findFactor(e, d, n);
    BigInteger q = n.divide(p);
    if (p.compareTo(q) &gt; 1) {
        BigInteger t = p;
        p = q;
        q = t;
    }
    BigInteger exp1 = d.mod(p.subtract(BigInteger.ONE));
    BigInteger exp2 = d.mod(q.subtract(BigInteger.ONE));
    BigInteger coeff = q.modInverse(p);
    RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, exp1, exp2, coeff);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return (RSAPrivateCrtKey) kf.generatePrivate(keySpec);

}
</code></pre>
","881","<rsa><private-key><cryptoapi><java-security>","2","3","1","2017-10-20 16:04:10","46841131","2","2","1741733","","2017-10-20 16:04:10","2017-10-19 19:45:14",""
"18116689","How do i get Certificate Trust List on windows7 using CryptoAPI","<p>I want to get the CTL(Certificate Trust List)on Windows7 using Crypto API,i use the CertFindCTLInStore function,but it always return false;the GetLastError() function returns -2146885682,i don't know where i did wrong.
the code is follow:</p>

<p>hCertStore = CertOpenSystemStore(
        NULL,
        pszStoreName);</p>

<pre><code>if(NULL != hCertStore)
{
    char buffer[8*1024];
    memset(buffer,0,sizeof(buffer));
    PCCTL_CONTEXT pCTL = CertCreateCTLContext(
                         X509_ASN_ENCODING|PKCS_7_ASN_ENCODING,
                         (const BYTE*)buffer,
                         sizeof(buffer));
    CTL_FIND_USAGE_PARA usagePara;
    //first
    pCTL =  CertFindCTLInStore(
            hCertStore, 
            X509_ASN_ENCODING|PKCS_7_ASN_ENCODING,
            0,
            CTL_FIND_ANY,
            NULL,
            NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }


    //Second 
    CRYPT_HASH_BLOB cryBlob;
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_SHA1_HASH,
        &amp;cryBlob, 
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }


    //third
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_MD5_HASH,
        &amp;cryBlob, 
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }

    //fourth
    CTL_FIND_USAGE_PARA ctlPara;
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_USAGE,
        &amp;ctlPara,
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }


    //fifth
    CTL_FIND_USAGE_PARA ctlPara2;
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_SAME_USAGE_FLAG,
        &amp;ctlPara2, 
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }


    //six
    CTL_CONTEXT ctlText;
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_EXISTING,
        &amp;ctlText, 
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }

    //seven
    CTL_FIND_SUBJECT_PARA ctlSubPara;
    pCTL =  CertFindCTLInStore(
        hCertStore, 
        X509_ASN_ENCODING|PKCS_7_ASN_ENCODING, 
        0,
        CTL_FIND_SUBJECT,
        &amp;ctlSubPara, 
        NULL);

    if (NULL != pCTL)
    {
        printf(""Find a CTL\n"");
    }
    else
    {
        printf(""Error Code :%d\n"",GetLastError());
    }
</code></pre>
","<p>I bet you are not getting -2146885682 but -2146885628, aka 0x80092004 aka <code>CRYPT_E_NOT_FOUND</code>. Quite simply, there are no CTLs in the store.</p>
","874","<c++><windows><certificate><cryptoapi>","1","0","1","2013-08-08 04:11:01","","0","1","","","","2013-08-08 01:48:42",""
"19293651","CryptoAPI's SignerTimeStampEx2 using PInvoke","<p>I'm trying to use CryptoAPI from C# code to add SHA256 timestamps to signed assemblies. Here is the code I'm using:</p>

<pre><code>Signer.TimestampSignedAssembly(""MyAssembly.exe"", ""http://tsa.starfieldtech.com"");
</code></pre>

<p>Signer class:</p>

<pre><code>public static class Signer
{
    [StructLayoutAttribute(LayoutKind.Sequential)]
    struct SIGNER_SUBJECT_INFO
    {
        public uint cbSize;
        public IntPtr pdwIndex;
        public uint dwSubjectChoice;
        public SubjectChoiceUnion Union1;
        [StructLayoutAttribute(LayoutKind.Explicit)]
        internal struct SubjectChoiceUnion
        {
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerFileInfo;
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerBlobInfo;
        }
    }

    [StructLayoutAttribute(LayoutKind.Sequential)]
    struct SIGNER_FILE_INFO
    {
        public uint cbSize;
        public IntPtr pwszFileName;
        public IntPtr hFile;
    }

    [DllImport(""Mssign32.dll"", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int SignerTimeStampEx2(
        uint dwFlags,               // DWORD
        IntPtr pSubjectInfo,        // SIGNER_SUBJECT_INFO
        string pwszHttpTimeStamp,   // LPCWSTR
        uint dwAlgId,               // ALG_ID
        IntPtr psRequest,           // PCRYPT_ATTRIBUTES
        IntPtr pSipData,            // LPVOID 
        out IntPtr ppSignerContext  // SIGNER_CONTEXT
        );

    public static void TimestampSignedAssembly(string appPath, string tsaServer)
    {
        if (tsaServer == null) throw new ArgumentNullException(""tsaServer"");

        var pSubjectInfo = IntPtr.Zero;            
        try
        {                
            pSubjectInfo = CreateSignerSubjectInfo(appPath);
            TimestampSignedAssembly(pSubjectInfo, tsaServer);
        }
        finally
        {                
            if (pSubjectInfo != IntPtr.Zero)
            {
                Marshal.DestroyStructure(pSubjectInfo, typeof(SIGNER_SUBJECT_INFO));
            }                
        }
    }

    private static IntPtr CreateSignerSubjectInfo(string pathToAssembly)
    {
        var info = new SIGNER_SUBJECT_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_SUBJECT_INFO)),
            pdwIndex = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)))
        };
        var index = 0;
        Marshal.StructureToPtr(index, info.pdwIndex, false);

        info.dwSubjectChoice = 0x1; //SIGNER_SUBJECT_FILE
        var assemblyFilePtr = Marshal.StringToHGlobalUni(pathToAssembly);

        var fileInfo = new SIGNER_FILE_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_FILE_INFO)),
            pwszFileName = assemblyFilePtr,
            hFile = IntPtr.Zero
        };

        info.Union1 = new SIGNER_SUBJECT_INFO.SubjectChoiceUnion
        {
            pSignerFileInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SIGNER_FILE_INFO)))
        };

        Marshal.StructureToPtr(fileInfo, info.Union1.pSignerFileInfo, false);

        IntPtr pSubjectInfo = Marshal.AllocHGlobal(Marshal.SizeOf(info));
        Marshal.StructureToPtr(info, pSubjectInfo, false);

        return pSubjectInfo;
    }

    /* 
        Here CryptoAPI function SignerTimeStampEx2 called.
    */
    private static void TimestampSignedAssembly(IntPtr pSubjectInfo, string tsaServer)
    {            
        IntPtr context;
        var hResult = SignerTimeStampEx2(
            0x1,            // I have not found anywhere what value should have this parameter!
            pSubjectInfo,   
            tsaServer,      
            0x0000800c,     // 256 bit SHA hashing algorithm. This value taken form here: http://msdn.microsoft.com/en-us/library/windows/desktop/aa375549(v=vs.85).aspx
            IntPtr.Zero,    
            IntPtr.Zero,
            out context
            );

        if (hResult != 0)
        {
            throw new Exception(string.Format(""Error occured when adding timestamp - Error code: 0x{0:X}"", hResult));
        }
    }
}   
</code></pre>

<p>Despite the fact that I pass to SignerTimeStampEx2 function an argument (dwAlgId), indicating that it is necessary to add SHA256 timestamp (0x0000800c), SHA1 timestamp is always generated. </p>

<p>Has anyone encountered with this problem? What I'm doing wrong? What values should I set for <em>dwFlags</em> and <em>dwAlgId</em> parameters? </p>

<p>Thanks in advance!</p>
","<p>dwFlags needs to be SIGNER_TIMESTAMP_RFC3161 (2).  The reason you get an access violation is that SignerTimeStampEx2() is <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd418879(v=vs.85).aspx"" rel=""noreferrer"">documented</a> incorrectly.  It expects the algorithm as a PCSTR rather than a DWORD.  If you pass 0x800C it'll try to dereference that as a pointer, leading to the AV.  So replace ALG_ID dwAlgId in the function declaration with PCSTR pszTimeStampAlgorithmOid.  Pass szOID_NIST_sha256 to it, which should be defined as ""2.16.840.1.101.3.4.2.1"".</p>

<p>SignerTimeStampEx3() is also incorrectly incorrectly <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/hh968156(v=vs.85).aspx"" rel=""noreferrer"">documented</a>.  pszTimeStampAlgorithmOid should be declared as PCSTR rather than as PCWSTR.</p>

<p>In my experience, code signing and time stamping are more reliable if you specify both the file name and an open Win32 file handle in the SIGNER_FILE_INFO structure.</p>

<p>Whether you will actually get an SHA-256 time stamp also depends on the time stamping service you're using.  <a href=""http://tsa.starfieldtech.com"" rel=""noreferrer"">http://tsa.starfieldtech.com</a>, <a href=""http://timestamp.globalsign.com/"" rel=""noreferrer"">http://timestamp.globalsign.com/</a> and <a href=""http://timestamp.comodoca.com/rfc3161"" rel=""noreferrer"">http://timestamp.comodoca.com/rfc3161</a> issue SHA-256 timestamps.  Other services may issue SHA-1 time stamps even when requesting an SHA-256 time stamp. </p>
","872","<c#><timestamp><pinvoke><sha256><cryptoapi>","3","6","2","2017-03-01 13:07:47","34367072","4","","","","","2013-10-10 10:46:10",""
"19293651","CryptoAPI's SignerTimeStampEx2 using PInvoke","<p>I'm trying to use CryptoAPI from C# code to add SHA256 timestamps to signed assemblies. Here is the code I'm using:</p>

<pre><code>Signer.TimestampSignedAssembly(""MyAssembly.exe"", ""http://tsa.starfieldtech.com"");
</code></pre>

<p>Signer class:</p>

<pre><code>public static class Signer
{
    [StructLayoutAttribute(LayoutKind.Sequential)]
    struct SIGNER_SUBJECT_INFO
    {
        public uint cbSize;
        public IntPtr pdwIndex;
        public uint dwSubjectChoice;
        public SubjectChoiceUnion Union1;
        [StructLayoutAttribute(LayoutKind.Explicit)]
        internal struct SubjectChoiceUnion
        {
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerFileInfo;
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerBlobInfo;
        }
    }

    [StructLayoutAttribute(LayoutKind.Sequential)]
    struct SIGNER_FILE_INFO
    {
        public uint cbSize;
        public IntPtr pwszFileName;
        public IntPtr hFile;
    }

    [DllImport(""Mssign32.dll"", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int SignerTimeStampEx2(
        uint dwFlags,               // DWORD
        IntPtr pSubjectInfo,        // SIGNER_SUBJECT_INFO
        string pwszHttpTimeStamp,   // LPCWSTR
        uint dwAlgId,               // ALG_ID
        IntPtr psRequest,           // PCRYPT_ATTRIBUTES
        IntPtr pSipData,            // LPVOID 
        out IntPtr ppSignerContext  // SIGNER_CONTEXT
        );

    public static void TimestampSignedAssembly(string appPath, string tsaServer)
    {
        if (tsaServer == null) throw new ArgumentNullException(""tsaServer"");

        var pSubjectInfo = IntPtr.Zero;            
        try
        {                
            pSubjectInfo = CreateSignerSubjectInfo(appPath);
            TimestampSignedAssembly(pSubjectInfo, tsaServer);
        }
        finally
        {                
            if (pSubjectInfo != IntPtr.Zero)
            {
                Marshal.DestroyStructure(pSubjectInfo, typeof(SIGNER_SUBJECT_INFO));
            }                
        }
    }

    private static IntPtr CreateSignerSubjectInfo(string pathToAssembly)
    {
        var info = new SIGNER_SUBJECT_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_SUBJECT_INFO)),
            pdwIndex = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)))
        };
        var index = 0;
        Marshal.StructureToPtr(index, info.pdwIndex, false);

        info.dwSubjectChoice = 0x1; //SIGNER_SUBJECT_FILE
        var assemblyFilePtr = Marshal.StringToHGlobalUni(pathToAssembly);

        var fileInfo = new SIGNER_FILE_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_FILE_INFO)),
            pwszFileName = assemblyFilePtr,
            hFile = IntPtr.Zero
        };

        info.Union1 = new SIGNER_SUBJECT_INFO.SubjectChoiceUnion
        {
            pSignerFileInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SIGNER_FILE_INFO)))
        };

        Marshal.StructureToPtr(fileInfo, info.Union1.pSignerFileInfo, false);

        IntPtr pSubjectInfo = Marshal.AllocHGlobal(Marshal.SizeOf(info));
        Marshal.StructureToPtr(info, pSubjectInfo, false);

        return pSubjectInfo;
    }

    /* 
        Here CryptoAPI function SignerTimeStampEx2 called.
    */
    private static void TimestampSignedAssembly(IntPtr pSubjectInfo, string tsaServer)
    {            
        IntPtr context;
        var hResult = SignerTimeStampEx2(
            0x1,            // I have not found anywhere what value should have this parameter!
            pSubjectInfo,   
            tsaServer,      
            0x0000800c,     // 256 bit SHA hashing algorithm. This value taken form here: http://msdn.microsoft.com/en-us/library/windows/desktop/aa375549(v=vs.85).aspx
            IntPtr.Zero,    
            IntPtr.Zero,
            out context
            );

        if (hResult != 0)
        {
            throw new Exception(string.Format(""Error occured when adding timestamp - Error code: 0x{0:X}"", hResult));
        }
    }
}   
</code></pre>

<p>Despite the fact that I pass to SignerTimeStampEx2 function an argument (dwAlgId), indicating that it is necessary to add SHA256 timestamp (0x0000800c), SHA1 timestamp is always generated. </p>

<p>Has anyone encountered with this problem? What I'm doing wrong? What values should I set for <em>dwFlags</em> and <em>dwAlgId</em> parameters? </p>

<p>Thanks in advance!</p>
","<p>I got it working finally. Here is the complete code of the Timestamper class:</p>

<pre class=""lang-cs prettyprint-override""><code>public static class Timestamper
{
    [StructLayout(LayoutKind.Sequential)]
    struct SIGNER_SUBJECT_INFO
    {
        public uint cbSize;
        public IntPtr pdwIndex;
        public uint dwSubjectChoice;
        public SubjectChoiceUnion Union1;
        [StructLayoutAttribute(LayoutKind.Explicit)]
        internal struct SubjectChoiceUnion
        {
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerFileInfo;
            [FieldOffsetAttribute(0)]
            public IntPtr pSignerBlobInfo;
        }
    }

    [StructLayoutAttribute(LayoutKind.Sequential)]
    struct SIGNER_FILE_INFO
    {
        public uint cbSize;
        public IntPtr pwszFileName;
        public IntPtr hFile;
    }

    [DllImport(""Mssign32.dll"", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern int SignerTimeStampEx2(
        uint dwFlags,                    // DWORD
        IntPtr pSubjectInfo,             // SIGNER_SUBJECT_INFO
        string pwszHttpTimeStamp,        // LPCWSTR
        IntPtr pszTimeStampAlgorithmOid, // PCSTR
        IntPtr psRequest,                // PCRYPT_ATTRIBUTES
        IntPtr pSipData,                 // LPVOID 
        out IntPtr ppSignerContext       // SIGNER_CONTEXT
     );

    public static void TimestampSignedAssembly(string appPath, string tsaServer)
    {
        if (tsaServer == null) throw new ArgumentNullException(""tsaServer"");

        IntPtr pSubjectInfo = IntPtr.Zero;
        try
        {
            pSubjectInfo = CreateSignerSubjectInfo(appPath);
            TimestampSignedAssembly(pSubjectInfo, tsaServer);
        }
        finally
        {
            if (pSubjectInfo != IntPtr.Zero)
            {
                Marshal.DestroyStructure(pSubjectInfo, typeof(SIGNER_SUBJECT_INFO));
            }
        }
    }

    private static IntPtr CreateSignerSubjectInfo(string pathToAssembly)
    {
        SIGNER_SUBJECT_INFO info = new SIGNER_SUBJECT_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_SUBJECT_INFO)),
            pdwIndex = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(uint)))
        };

        int index = 0;
        Marshal.StructureToPtr(index, info.pdwIndex, false);

        info.dwSubjectChoice = 0x1; //SIGNER_SUBJECT_FILE
        IntPtr assemblyFilePtr = Marshal.StringToHGlobalUni(pathToAssembly);

        SIGNER_FILE_INFO fileInfo = new SIGNER_FILE_INFO
        {
            cbSize = (uint)Marshal.SizeOf(typeof(SIGNER_FILE_INFO)),
            pwszFileName = assemblyFilePtr,
            hFile = IntPtr.Zero
        };

        info.Union1 = new SIGNER_SUBJECT_INFO.SubjectChoiceUnion
        {
            pSignerFileInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SIGNER_FILE_INFO)))
        };

        Marshal.StructureToPtr(fileInfo, info.Union1.pSignerFileInfo, false);

        IntPtr pSubjectInfo = Marshal.AllocHGlobal(Marshal.SizeOf(info));
        Marshal.StructureToPtr(info, pSubjectInfo, false);

        return pSubjectInfo;
    }

    /* 
        Here CryptoAPI function SignerTimeStampEx2 called.
    */
    private static void TimestampSignedAssembly(IntPtr pSubjectInfo, string tsaServer)
    {
        IntPtr context;
        int hResult = SignerTimeStampEx2(
            0x2, // SIGNER_TIMESTAMP_RFC3161
            pSubjectInfo,
            tsaServer,
            Marshal.StringToHGlobalAnsi(""2.16.840.1.101.3.4.2.1""), // szOID_NIST_sha256 constant, SHA256 hashing algorithm.
            IntPtr.Zero,
            IntPtr.Zero,
            out context
         );

        if (hResult != 0)
        {
            throw new Exception(string.Format(""Error occured when adding timestamp - Error code: 0x{0:X}"", hResult));
        }
    }
}
</code></pre>

<p>Usage example:</p>

<pre><code>Timestamper.TimestampSignedAssembly(""Assembly.exe"", ""http://timestamp.comodoca.com/?td=sha256"");
</code></pre>
","872","<c#><timestamp><pinvoke><sha256><cryptoapi>","3","0","2","2017-03-01 13:07:47","34367072","4","","","","","2013-10-10 10:46:10",""
"18629958","Decrypting string with Microsoft Crypto API with C#","<p>So at my workplace, I have a .NET based web application, that has to pick up an encrypted parameter in a querystring. </p>

<p>Those supplying the encrypted string is an external contractor and they prefer (almost demand. cant change contractors though, the higher ups decide that stuff...), to use Microsoft's Crypto API to encrypt the string. </p>

<p>Well, fair enough, AFAIK I can decrypt that with C#, but after endless searching I am still at a loss on how it works.</p>

<p>That means I cant even supply example code, and I am stuck in this bind until I can decrypt this string.</p>

<p>What I have is:</p>

<p>I have the common password they encrypt with and I have to use to decrypt it with.</p>

<p>Encryption settings are: ""CALC_AES_128"" hash: ""CALC_MD5"". The string is encrypted, then hashed.</p>

<p>So I want to unhash it, and decrypt it.</p>

<p>I know its a lot to ask but how do I go about it?</p>
","<p>Your external contractor doesn't know what he is talking about.</p>

<p>Hashes are used as a trap door function, a way to recognize something without been told what that thing IS. It is a digital fingerprint. The way a CRYPTOGRAPHICALLY SECURE hash is made, means even given the hash and the algorithm it is difficult to create an object that matches the fingerprint.</p>

<p>AES is a non-deterministic cypher. The non-determinisism comes from the Initialization Vector, which is meant to be a random number each time (not hard coded from a die roll, ahem Sony). This means for all intents and purposes, the output of AES is pure random (unless you have the key). Good cyphers are all designed to produce data that is statistically random (thus there is little data to form an attack from).</p>

<p>So by feeding data into a function that creates random data, then putting it into a trap door function, you have produce something that is truly difficult to decode (difficult in this sense is mathematically, you actually need more energy than exist in the universe to compute this).</p>

<p>As for how to send data across in a secure manner (secure as in against prying eyes on an unsecure network) in the query string? There is a well known protocol that .net supports that does this very well. Its called HTTPS.</p>
","871","<c#><asp.net><encryption><cryptoapi><mscapi>","0","1","1","2015-06-09 02:50:59","18630439","13","","608639","","2015-06-09 02:50:59","2013-09-05 07:11:00",""
"19505091","Dynamically create Cipher using configuration: What parameters are necessary?","<p>Java uses the <code>Cipher</code> class as an abstraction to the specific cipher implementations. In my project, I mainly use symmetric block ciphers (AES, Twofish, 3DES, ...) and I'm looking for a way to dynamically create/initialize any possible symmetric block ciphers (using an XML configuration), because I'd like to make encryption configurable.</p>

<p><em>Example:</em> <code>&lt;transformer type=""cipher"" cipher=""AES/GCM/NoPadding"" keysize=""256"" iv=""true"" unlimitedstrength=""true"" /&gt;</code></p>

<p>will be translated to:</p>

<pre><code>// Create secretKey using 'keysize' ...

if (encryption.isUnlimitedCrypto()) {
    Encryption.enableUnlimitedCrypto();
}

Cipher cipher = Cipher.getInstance(encryption.getCipherStr(), Encryption.PROVIDER);

if (encryption.isIvNeeded()) {
    byte[] iv = ... 
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));
}
else {
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
}
</code></pre>

<p>My question ist: <strong>What parameters are necessary to instantiate any symmetric block cipher in Java?</strong></p>

<p><em>Parameters (already identified):</em></p>

<ul>
<li>Cipher String: String for Cipher.getInstance(..), e.g. AES/CBC/PKCSPadding </li>
<li>Key size: Size of the key for the key generation (or the PBE key derivation function)</li>
<li>IV needed: Indicates whether an IV is needed, e.g. ""true"" for CBC and GCM mode, but not for ECB</li>
<li>IV size: Indicates the size of the IV (right now I assume IV size = key size, correct?)</li>
<li>Unlimited strength needed: Indicates whether enabling the unlimited strength policy files is necessary</li>
<li><em>Others?</em></li>
</ul>

<p><em>Original source/project:</em></p>

<ul>
<li>Implementation: <a href=""https://github.com/binwiederhier/syncany/blob/e3d11300b34c133d01431d6e041b4eb39b6bec33/src/org/syncany/chunk/CipherTransformer.java"" rel=""nofollow"">https://github.com/binwiederhier/syncany/blob/e3d11300b34c133d01431d6e041b4eb39b6bec33/src/org/syncany/chunk/CipherTransformer.java</a></li>
<li>Desired Usage in Tests: <a href=""https://github.com/binwiederhier/syncany/blob/e3d11300b34c133d01431d6e041b4eb39b6bec33/tests/org/syncany/tests/config/EncryptionTest.java#L114"" rel=""nofollow"">https://github.com/binwiederhier/syncany/blob/e3d11300b34c133d01431d6e041b4eb39b6bec33/tests/org/syncany/tests/config/EncryptionTest.java#L114</a></li>
</ul>
","<p>All modes other than <code>ECB</code> require an IV. The IV will always be equal to the block size of the cipher (16 bytes for AES, 8 bytes for 3DES). <code>ECB</code> mode is insecure when encrypting more than 1 block of plaintext with the same key, and should not be allowed if you want confidentiality to be ensured. </p>

<p>The algorithm used will dictate what key size is required. AES, for example, requires 128, 192, or 256 Unlimited strength policies need to be installed for 192 and 256 if using Java's standard crypto API. The unlimited strength policy is not something you can toggle with code, it has to be installed in the end users JRE.</p>

<p>If you care about securing data in transit (and this project has real security needs), I can not urge you strongly enough to use SSL/TLS for this instead. Creating a secure crypto system is difficult to do, and bulk encryption (i.e. symmetric ciphers like AES, 3DES) are not enough by themselves to ensure security. You also need a cryptographically strong source of random data, a safe key exchange process and integrity verification. Confidentially is difficult to provide without also ensuring integrity which is generally provided by using MAC functions. There are all pitfalls to avoid when implementing a secure crypto system like making sure you use different keys for cipher and MAC, verifying MACs correctly so as not to create a timing attack vector, using a proper random generator, ensuring integrity so as not to create a padding oracle, etc.</p>

<p>As you can see there are a lot of moving parts to protecting transmitted data, and doing it from scratch can lead to vulnerabilities introduced by incorrectly chosen or misconfigured crypto primitives. This is why TLS is often recommended.</p>

<p>Below is an example of an anonymous (no authentication) TLS session established by two sockets. This example is not secure because neither of the parties authenticates the other, however confidentiality and integrity are established. The reason I'm using this insecure cipher suite in the example is it is easy to demonstrate TLS usage without getting in to keystores and truststores (used for the authentication part)</p>

<p>The cipher suite being used is <code>TLS_ECDH_anon_WITH_AES_128_CBC_SHA</code>, which is not normally enabled by default, because of the aforementioned lack of authentication. Below I break down this cipher suite</p>

<ul>
<li>TLS - This cipher suite was introduced by the TLS standard.</li>
<li>ECDH_anon - Eliptic Cuve Diffie-Hellman algorithm is used for key agreement, however the key agreement is not authenticated.</li>
<li>AES_128_CBC - Advanced Encryption Standard with a 128-bit key length in Cipher Block Chaining mode is used for bulk encryption.</li>
<li>SHA - Secure Hash Algorithm is used to ensure integrity of the encrypted data.</li>
</ul>

<p>Example follows.</p>

<pre><code>package com.stackoverflow._19505091;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLServerSocket;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;

public class AnonTLSExample {

    public static void main(String[] args) throws Exception {

        /* No certs for this example so we are using ECDH_anon exchange. */
        String[] cipherSuites = {""TLS_ECDH_anon_WITH_AES_128_CBC_SHA""};
        SSLContext sslContext = SSLContext.getInstance(""TLSv1.2"");

        /* No certificates, use default secure random source.
         * If we were using authentication (and you should in a real
         * system), this is where we would load 
         * keystores and truststores. */
        sslContext.init(null, null, null);

        /* Create server socket. */
        SSLServerSocket ss = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket(12345);
        ss.setEnabledCipherSuites(cipherSuites);

        /*
         * Normally when authentication is used only the client authenticates
         * the server. If you want the server to also authenticate the client
         * set this to true. This will establish bidirectional trust in the session.
         */
        ss.setWantClientAuth(false);

        /* Start server thread. */
        new Thread(new Server(ss), ""ServerThread"").start();

        /* Create client socket. */
        SSLSocket s = (SSLSocket) sslContext.getSocketFactory().createSocket();
        s.setEnabledCipherSuites(cipherSuites);

        /* Connect to server. */
        System.out.println(""Client: Connecting..."");
        s.connect(new InetSocketAddress(""127.0.0.1"", 12345));
        System.out.println(""Client: Connected"");

        /* Print out some TLS info for this connection. */
        SSLSession session = s.getSession();
        System.out.println(""Client: Session secured with P: "" + session.getProtocol() + "" CS: "" + session.getCipherSuite());

        /* Send the secret message. */
        DataOutputStream dos = new DataOutputStream(s.getOutputStream());
        String message = ""Secret Message."";
        System.out.println(""Client: Sending: "" + message);
        dos.writeUTF(message);

        /* Wait for server to close stream. */
        System.out.println(""Client: Waiting for server to close..."");
        s.getInputStream().read();

        /* Close client socket. */
        s.close();
        System.out.println(""Client: Done."");
    }


}

class Server implements Runnable {

    private final ServerSocket ss;

    public Server(ServerSocket ss){
        this.ss = ss;
    }

    @Override
    public void run() {
        try{
         /* Wait for client to connect. */
         System.out.println(""Server: Waiting for connection..."");
         Socket s = ss.accept();
         System.out.println(""Server: Connected."");

         /* Read secret message. */
         DataInputStream dis = new DataInputStream(s.getInputStream());
         String message = dis.readUTF();
         System.out.println(""Server: Received Message: "" + message);

         /* Close our sockets. */
         s.close();
         ss.close();
         System.out.println(""Server: Done."");
        }catch(Exception e){
            e.printStackTrace();
        }

    }
}
</code></pre>
","861","<java><encryption><cryptoapi>","2","2","1","2013-10-22 03:23:58","","1","3","","","","2013-10-21 21:28:41",""
"18567239","Crypto API - CryptRetrieveTimeStamp","<p>Good day,</p>

<p>Can someone please help me using the Crypto Api function, CryptRetrieveTimeStamp?
I successfully use CryptSignMessage to sign my message and now I want to timestamp the data at a TSA, but CryptRetrieveTimeStamp always return *TRUST_E_TIME_STAMP* error.</p>

<p>My function looks as follows, <em>pbMessage</em> and <em>cbMessage</em> are the data and size received from CryptSignMessage:</p>

<pre><code>PCRYPT_TIMESTAMP_CONTEXT tcontext = NULL;
HCERTSTORE hStore = NULL;


fReturn = CryptRetrieveTimeStamp(widestr.c_str(),
       TIMESTAMP_NO_AUTH_RETRIEVAL, 
       0, 
       szOID_RSA_MD5, 
       NULL, 
       (const BYTE*)pbMessage, 
       cbMessage, 
       &amp;tcontext, 
       NULL, 
       &amp;hStore);
</code></pre>

<p>I know the error means: <em>The time stamp signer and or certificate could not be verified or is malformed</em>. But I have no idea what or how to solve this error?</p>

<p>Any help/hints would be appreciated.
Thanks,
Magda</p>
","<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd433803%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN</a> - </p>

<blockquote>
  <p>The <code>CryptRetrieveTimeStamp</code> function encodes a time stamp request and
  retrieves the time stamp token from a location specified by a URL to a
  Time Stamping Authority (TSA).</p>
</blockquote>

<p>Most likely you didn't provide the valid TSA in first parameter, which is - </p>

<blockquote>
  <p><code>wszUrl</code> [in]</p>
  
  <p>A pointer to a null-terminated wide character string that contains the URL of the TSA to which to send the request.</p>
</blockquote>

<p><strong>Edit</strong> - The suggested solution is to change time stamping authority.</p>
","861","<c++><cryptoapi><trusted-timestamp>","0","0","3","2016-08-04 21:16:50","18658166","0","","","","","2013-09-02 06:56:08",""
"18567239","Crypto API - CryptRetrieveTimeStamp","<p>Good day,</p>

<p>Can someone please help me using the Crypto Api function, CryptRetrieveTimeStamp?
I successfully use CryptSignMessage to sign my message and now I want to timestamp the data at a TSA, but CryptRetrieveTimeStamp always return *TRUST_E_TIME_STAMP* error.</p>

<p>My function looks as follows, <em>pbMessage</em> and <em>cbMessage</em> are the data and size received from CryptSignMessage:</p>

<pre><code>PCRYPT_TIMESTAMP_CONTEXT tcontext = NULL;
HCERTSTORE hStore = NULL;


fReturn = CryptRetrieveTimeStamp(widestr.c_str(),
       TIMESTAMP_NO_AUTH_RETRIEVAL, 
       0, 
       szOID_RSA_MD5, 
       NULL, 
       (const BYTE*)pbMessage, 
       cbMessage, 
       &amp;tcontext, 
       NULL, 
       &amp;hStore);
</code></pre>

<p>I know the error means: <em>The time stamp signer and or certificate could not be verified or is malformed</em>. But I have no idea what or how to solve this error?</p>

<p>Any help/hints would be appreciated.
Thanks,
Magda</p>
","<p>Viewing the request/response through wireshark gave better insight into the problem.</p>

<p>The TSA is a valid TSA, but the encoding was wrong. Changing *szOID_RSA_MD5* to *szOID_NIST_sha256* solved my problem.</p>
","861","<c++><cryptoapi><trusted-timestamp>","0","1","3","2016-08-04 21:16:50","18658166","0","","","","","2013-09-02 06:56:08",""
"18567239","Crypto API - CryptRetrieveTimeStamp","<p>Good day,</p>

<p>Can someone please help me using the Crypto Api function, CryptRetrieveTimeStamp?
I successfully use CryptSignMessage to sign my message and now I want to timestamp the data at a TSA, but CryptRetrieveTimeStamp always return *TRUST_E_TIME_STAMP* error.</p>

<p>My function looks as follows, <em>pbMessage</em> and <em>cbMessage</em> are the data and size received from CryptSignMessage:</p>

<pre><code>PCRYPT_TIMESTAMP_CONTEXT tcontext = NULL;
HCERTSTORE hStore = NULL;


fReturn = CryptRetrieveTimeStamp(widestr.c_str(),
       TIMESTAMP_NO_AUTH_RETRIEVAL, 
       0, 
       szOID_RSA_MD5, 
       NULL, 
       (const BYTE*)pbMessage, 
       cbMessage, 
       &amp;tcontext, 
       NULL, 
       &amp;hStore);
</code></pre>

<p>I know the error means: <em>The time stamp signer and or certificate could not be verified or is malformed</em>. But I have no idea what or how to solve this error?</p>

<p>Any help/hints would be appreciated.
Thanks,
Magda</p>
","<p>The problem with the timestamp retrieval is that it is not compatible with OpenSSL... Not related to your question though.</p>
","861","<c++><cryptoapi><trusted-timestamp>","0","0","3","2016-08-04 21:16:50","18658166","0","","","","","2013-09-02 06:56:08",""
"20628951","Decrypt using a non-exportable private key with CryptoAPI","<p>I created RSA key pair in windows key store.</p>

<p>I encrypted data (a symmetric key) successfully:</p>

<pre><code>HCERTSTORE hstore = ::CertOpenSystemStore(NULL, L""TestStore"");
PCCERT_CONTEXT pctxt = ::CertFindCertificateInStore(hstore, X509_ASN_ENCODING, NULL, 

CERT_FIND_SUBJECT_STR, L""My Test Keys"", NULL);

HCRYPTPROV hprovider = NULL;
if(!::CryptAcquireContext(&amp;hprovider,
            NULL,
            MS_ENHANCED_PROV,
            PROV_RSA_FULL,
                    NULL/*CRYPT_NEWKEYSET*/))
{
   DWORD err = ::GetLastError();
   return 0;
}

HCRYPTKEY hkey = NULL;
if(!::CryptImportPublicKeyInfo(hprovider, 
                X509_ASN_ENCODING,
                &amp;pctxt-&gt;pCertInfo-&gt;SubjectPublicKeyInfo,
                &amp;hkey
                ))
{
   return 0;
}
</code></pre>

<p>Now I used CryptEncrypt() with HCRYPTKEY.</p>

<hr>

<p>Next I want to decrypt the data with the private key, but it is not exportable. All the examples I've seen include importing of the keys. </p>

<p>How can I decrypt the data without exporting the key?</p>
","<p>Well, I'm not an expert in RSA/Microsoft store, but I think I get what you're trying to do here. You're doing it a bit backwards. You're using the public key to encrypt and the private do decrypt. So the assumption is that you'd have the private key since that is what you used to generate the public key.</p>

<p>So, let's see... to decrypt the data you need a key, right? So you can (a) encrypt the data with the public key and then find a way to export the private key, but then you'd be using something akin to private key encryption and you'd be better off using blowfish anyway, or (b) encrypt the data using your private key so that you can share the public key to decrypt. Remember CryptImportPublicKeyInfo returns a handle to it: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380209(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa380209(v=vs.85).aspx</a></p>

<p>So what I'm saying is that you already have your answer. It's there when you say you have a symmetric key. Either you'll use the same public key to decrypt or it will be a simple transformation: <a href=""http://en.wikipedia.org/wiki/Symmetric-key_algorithm"" rel=""nofollow"">http://en.wikipedia.org/wiki/Symmetric-key_algorithm</a></p>
","850","<c++><encryption><keystore><cryptoapi>","5","0","1","2014-01-16 20:59:39","","0","0","493122","","2013-12-17 10:09:16","2013-12-17 08:08:12",""
"3576912","Get access to specific ADPU functions from cryptoApi or CAPICOM using 3rd party CSP","<p>I have tried for the last 2 months without success and I think it's time I ask here.</p>

<p>I have a <strong>smart card</strong> and got a <strong>CSP from my client</strong>.
I have documents that describe <strong>APDU commands</strong> that I can (and know how to) run.</p>

<p>I need to save small files (data) to the card like name, address, photo etc.
And later on save certificates.</p>

<p>In the documentation I read that you have to do do external authentication to later use secure messaging to access the files on the card.
I have an error somewhere in the mutual authentication algorithm (requires calculating a MAC, DES, TRIPPLE DES etc and i have tried for weeks to get it working...)
I know how to do everything on the card except for functions that require mutual authentication.</p>

<p><strong>I looked at the functions provided by the CSP and don't see any external authentication</strong> there. The only place i saw non APDU level external auth was in ""Windows Smart Card Minidriver Specification"" where i see functions like: CardAuthenticateEx.
But i dont know how to call them (which dll they are in).
Should these functions be in the CSP?</p>

<p><strong>Is it a wrong approach to go low level with APDU commands when i have the CSP.
Should I instead use CryptoAPI or CAPICOM?</strong> If so then <strong>how can i external authenticate and use files if there are no (or i can't find) functions that would write to a file.</strong> (again all these functions are in the ""Windows Smart Card Minidriver Specification"".</p>
","<p>Many smartcards follow the Global Platform specification, which (depending on the installed applets on the card and how they are configured) may require a security handshake before communicating with the card.</p>

<p>If you need to write files to the card, you will NOT be using the CSP. The CSP supports OS level cryptographic interactions by re-routing certain crypto calls to the card's processor. To write to a file on the card, you'll be sending APDUs to the card that perform the following functions:</p>

<ul>
<li>Authenticate with the card</li>
<li>(optionally) Select an applet/cardlet
using the AID (applet ID) </li>
<li>Select a directory</li>
<li>Select a file </li>
<li>Write data to the file</li>
</ul>

<p>My company makes a plugin for IE and Firefox browsers that helps with this, it includes handshake functions for global platform, and we have a ""sandbox"" form on our site that lets you test your scripts for card interactions.</p>

<p>Check out <a href=""https://cardboss.cometway.com"" rel=""nofollow"">https://cardboss.cometway.com</a> for more information.</p>
","842","<smartcard><cryptoapi><capicom><apdu>","0","1","1","2010-09-24 21:31:16","3791154","0","","","","","2010-08-26 15:54:32",""
"28803639","Encrypt private key with DES-EDE3-CBC","<p>I need to encrypt private RSA key using MS CryptoAPI to satisfy this header (generated IV will be different but that is irrelevant for the question):</p>

<pre><code>Proc-Type: 4,ENCRYPTED
DEK-Info: DES-EDE3-CBC,E7AE93C9E49184EA
</code></pre>

<p>I'm not sure if the following procedure does the right thing (memory allocation and error checking omitted for brevity):</p>

<pre><code>HCRYPTKEY  hSecretKey = 0;
HCRYPTHASH hHash = 0;
CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash);
CryptHashData(hHash, (LPBYTE)pwd, pwdSize, 0);
CryptDeriveKey(hProv, CALG_3DES, hHash, 0, &amp;hSecretKey);

DWORD dwMode = CRYPT_MODE_CBC;
CryptSetKeyParam(hSecretKey, KP_MODE, (LPBYTE)&amp;dwMode, 0);

DWORD dwBlockLen = 0;
DWORD dwDataLen = sizeof(dwBlockLen);
CryptGetKeyParam(hSecretKey, KP_BLOCKLEN, (LPBYTE)&amp;dwBlockLen, &amp;dwDataLen, 0);
dwBlockLen /= 8;

LPBYTE pbTemp;
CryptGenRandom(hProvider, dwBlockLen, pbTemp);
CryptSetKeyParam(hKey, KP_IV, pbTemp, 0);
CryptEncrypt(hSecretKey, NULL, TRUE, 0, pData, &amp;plainSize, dataSize);
</code></pre>

<p>I'm unsure about EDE3 part - I can't find any reference in CryptoAPI documentation about it; will the above code satisfy the aforementioned header for the encrypted key?</p>
","","828","<security><encryption><rsa><cryptoapi>","1","","0","2015-03-02 13:53:57","","2","1","205386","","2015-03-02 13:53:57","2015-03-02 06:10:51",""
"32983031","encrypting a large file by cryptoapi in C++","<p>I am using CryptoApi to encrypt a file (asymmetric encryption). Everywthing is ok but when the file is large, it can not encrypt it. I searched and found that I must encrypt block by block. Except for the last block the <code>Final</code> flag in <code>CryptEncrypt</code> function must be false.</p>

<p>I know all of above conception but I dont know how I can to implement them. I mean I dont know how read, encrypt and write block by block.
Can you give me a real code example.</p>

<p>Update:</p>

<p>I used the code of this website: <a href=""http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx</a></p>
","<p>Try something like:</p>

<pre><code>final_flag &lt;- false
repeat
  this_block &lt;- read_next_block(file)
  if (is_EoF(file)) {final_flag &lt;- true }
  encrypt(this_block, final_flag)
until (final_flag == true)
</code></pre>

<p>I don't know enough about the C++ file system handling to write a working check for the end of a file, but there should be one in there somethere.</p>
","822","<c++><file><encryption><cryptoapi>","0","0","2","2015-10-08 04:20:54","33006567","2","","3864147","","2015-10-07 03:05:15","2015-10-07 02:53:30",""
"32983031","encrypting a large file by cryptoapi in C++","<p>I am using CryptoApi to encrypt a file (asymmetric encryption). Everywthing is ok but when the file is large, it can not encrypt it. I searched and found that I must encrypt block by block. Except for the last block the <code>Final</code> flag in <code>CryptEncrypt</code> function must be false.</p>

<p>I know all of above conception but I dont know how I can to implement them. I mean I dont know how read, encrypt and write block by block.
Can you give me a real code example.</p>

<p>Update:</p>

<p>I used the code of this website: <a href=""http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx"" rel=""nofollow"">http://blogs.msdn.com/b/alejacma/archive/2008/01/28/how-to-generate-key-pairs-encrypt-and-decrypt-data-with-cryptoapi.aspx</a></p>
","<p>I am writing this solution for programmers who will have this problem in the future:</p>

<p>In this link has been shown how to encrypt large file (block by block):</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382358%28v=vs.85%29.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa382358%28v=vs.85%29.aspx</a></p>

<p>Note: Somethings must be change when you want to use the above code</p>

<p>1) In encryption, block size must be set to 128 - 11 ( <code>DWORD dwBlockLen = 128 - 11</code> )</p>

<p>2) In decryption, block size must be set to 128 ( <code>DWORD dwBlockLen = 128</code> )</p>

<p>Both tested in win 7.</p>
","822","<c++><file><encryption><cryptoapi>","0","1","2","2015-10-08 04:20:54","33006567","2","","3864147","","2015-10-07 03:05:15","2015-10-07 02:53:30",""
"2814043","EMail Signing (Outlook) Using Smartcard Minidriver [Windows]","<p>I'm developing a Smart card Minidriver and I'm trying to Sign an Email using Outlook 2007.
I have implemented all of the necessary functions in the minidriver.</p>

<p>I'm able to create a ""Smartcard User"" certificate and save it and it's private key on the smartcard (using Microsoft Certificate Services via the Minidriver).</p>

<ul>
<li><p>When I try to sign an EMail via
Outlook I'm getting Error Message
(Internal Error), the last call to the minidriver is for ReadFile with ""cmapfile""</p></li>
<li><p>When I try to sign
an EMail via Outlook with a
difference non-smartcard certificate
it's work fine. </p></li>
<li>When I try to sign a
Data using CryptoAPI (based on Windows SDK Sample) it's working
fine.</li>
</ul>

<p>I'm using Windows 7.</p>

<p>someone got any idea how to debug this issue? </p>

<p>I tried to enable the CAPI2 eventlog, it don't give me any good information.</p>
","<p>The problem was that the CP_CARD_PIN_INFO property in <strong>CardGetProperty</strong>
its field <strong>dwChangePermission</strong> was set to 0 and the valid values are 1-8</p>
","819","<outlook><smartcard><cryptoapi>","0","0","1","2010-08-18 21:23:03","3516826","0","","","","","2010-05-11 20:01:42",""
"9232328","How to sign and encrypt hash with c# given only a keystore","<p>I'm using a keystore that was created using vc 6.0 and the cryptoAPI. The keystore contains all the exchange/signature keys. So i can use the public keys just fine to encrypt data using RSA but when it comes time to sign or decrypt the data I cant seem to find how to decrypt using the private key. </p>

<p>I've seen lots of sites using 
rsa = (RSACryptoServiceProvider)cert.PrivateKey;</p>

<p>but in my keystore when i look at the certs all of the private keys do not exist. </p>

<p>// this is how i setup the store </p>

<pre><code>public cryptTest(string storeName)
{
    store = new X509Store(storeName);
    this.storename = storename;
}
</code></pre>

<p>// this is how i get the certificate from the store</p>

<pre><code>public X509Certificate2 getCertificate(string ID, certType ct)
{
    if (store == null)
    {
        return null;
    }
    store.Open(OpenFlags.ReadOnly);
    foreach (X509Certificate2 cert in store.Certificates)
    {
        if ((ct == certType.exchange &amp;&amp; cert.Subject.Contains(""Exchange"")) ||
            (ct == certType.signature &amp;&amp; cert.Subject.Contains(""Signature"")))
        {
            if (cert.Subject.Contains(ID)) // if the ID match
            {
                // todo check date etc ! is cert still valid if not delete etc. 
                store.Close();
                return cert;
            }
        }
    }
    store.Close();
    return null;
}
</code></pre>

<p>but then in the certs they never have a private key, so how could i possibly decrypt or sign using the certs in the keystore ? </p>

<p>Thanks a million ! </p>
","<p>I think the <a href=""http://msdn.microsoft.com/en-us/library/ms867080.aspx"" rel=""nofollow"">EncryptTo/DecryptTo: Encryption in .NET with CryptoAPI Certificate Stores</a> article on MSDN should have the answers you need.</p>
","815","<c#><rsa><cryptoapi><private-key>","2","0","1","2012-02-10 23:05:38","","0","","","","","2012-02-10 17:47:18",""
"40506143","CryptographicException, provider type does not match registered value, when using iTextSharp and RSA and AES csp","<p>I want to make a <code>PADES</code> signature a PDF using <code>SHA-256</code> as hash algorithm. I'm using the following code:</p>

<pre><code>public static byte[] Sign(
    byte[] pdfIn,
    X509Certificate2 cert,
    string reason,
    string hashAlgorithm = DigestAlgorithms.SHA1
    )
{
    using (var reader = new PdfReader(pdfIn))
    using (var pdfOut = new MemoryStream())
    {
        var stamper = PdfAStamper.CreateSignature(reader, pdfOut, '\0');

        var appearance = stamper.SignatureAppearance;
        appearance.Reason = reason;          

        var parser = new X509.X509CertificateParser();
        var chain = new X509.X509Certificate[] { 
            parser.ReadCertificate(cert.RawData)
        };

        var signature = new X509Certificate2Signature(cert, hashAlgorithm);

        MakeSignature.SignDetached(
            appearance,
            signature,
            chain,
            null,
            null,
            null,
            0,
            CryptoStandard.CADES
            );
        return pdfOut.ToArray();          
    }
}
</code></pre>

<p>I'm importing a certificate with <code>certutil</code>. If I use the following command and <code>SHA-1</code> as hashAlgorithm, it works properly:</p>

<pre><code>certutil -f -user -p PASSWORD -importpfx CERT_NAME.pfx
</code></pre>

<p>But if I select a csp with <code>SHA-256</code> capabilities, I get a <code>CryptographicException, provider type does not match registered value</code>. The import is made through:</p>

<pre><code>certutil -f -user -p PASSWORD -csp ""Microsoft Enhanced RSA and AES Cryptographic Provider"" -importpfx CERT_NAME.pfx
</code></pre>

<p>The exception is:</p>

<pre><code>Result Message: System.Security.Cryptography.CryptographicException : provider type does not match registered value
Result StackTrace:  
in System.Security.Cryptography.Utils.CreateProvHandle(CspParameters parameters, Boolean randomKeyContainer)
   in System.Security.Cryptography.Utils.GetKeyPairHelper(CspAlgorithmType keyType, CspParameters parameters, Boolean randomKeyContainer, Int32 dwKeySize, SafeProvHandle&amp; safeProvHandle, SafeKeyHandle&amp; safeKeyHandle)
   in System.Security.Cryptography.RSACryptoServiceProvider.GetKeyPair()
   in System.Security.Cryptography.RSACryptoServiceProvider..ctor(Int32 dwKeySize, CspParameters parameters, Boolean useDefaultKeySize)
   in System.Security.Cryptography.X509Certificates.X509Certificate2.get_PrivateKey()
   in iTextSharp.text.pdf.security.X509Certificate2Signature..ctor(X509Certificate2 certificate, String hashAlgorithm)
   in PdfCommon.Pdf.Sign(Byte[] pdfIn, X509Certificate2 cert, String reason, String hashAlgorithm) in c:\Projects\svn\playground\trunk\PdfCommon\Pdf.cs:line 46
   in PdfCommon.Tests.Pdf_test.Should_sign_a_pdf_with_pades_basic_profile() in c:\Projects\svn\playground\trunk\PdfCommon.Tests\Pdf_test.cs:line 54
</code></pre>

<p>The exception is thrown when retrieving the private key. I can reproduce the exception by accessing to <code>cert.PrivateKey</code>.</p>
","<p>I eventually solved it by using <code>RSACryptoServiceProvider</code> to retrieve the private key:</p>

<pre><code>    public static byte[] Sign(
        byte[] pdfIn,
        X509Certificate2 cert,
        string reason = """",
        string hashAlgorithm = DigestAlgorithms.SHA256
        )
    {
        using (var reader = new PdfReader(pdfIn))
        using (var pdfOut = new MemoryStream())
        using (var rsa = (RSACryptoServiceProvider)cert.PrivateKey)
        {
            var stamper = PdfAStamper.CreateSignature(reader, pdfOut, '\0');

            var appearance = stamper.SignatureAppearance;
            appearance.Reason = reason;

            var signature = new PrivateKeySignature(
                DotNetUtilities.GetRsaKeyPair(rsa).Private,
                hashAlgorithm);

            var parser = new X509.X509CertificateParser();
            var chain = new X509.X509Certificate[] { 
            parser.ReadCertificate(cert.RawData)
            };

            MakeSignature.SignDetached(
                appearance,
                signature,
                chain,
                null,
                null,
                null,
                0,
                CryptoStandard.CADES
                );

            return pdfOut.ToArray();
        }
    }
</code></pre>
","810","<c#><itext><sign><cryptoapi>","2","1","1","2016-11-17 12:08:42","40654508","0","","2660176","","2016-11-17 12:04:55","2016-11-09 11:41:04",""
"20992760","Understanding BCryptSignHash output signature","<p>I have signed a hash value in windows using <em>BCryptSignHash</em> with ECDSA algorithm. The output signature buffer is of length 64 bytes. I also generated the public and private key blobs using <em>BCryptGenerateKeyPair</em> function (BCRYPT_ECDSA_P256_ALGORITHM algorithm) with which i signed the hash.</p>

<p>I have to verify this signature with this key pair in linux. I am able to decipher the public-private key pair that got generated, using the link ""<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx</a>"" and able to use the same in linux.</p>

<p>The 64-byte signature generated should ideally be signature pair (r,s) (<a href=""http://en.wikipedia.org/wiki/Elliptic_Curve_DSA"" rel=""nofollow"">http://en.wikipedia.org/wiki/Elliptic_Curve_DSA</a>).</p>

<p>Is there a way to understand the 64-bytes signature generated so that i can map the signature blob contents to (r,s) pair in linux and verify it?</p>

<p>Or is there a simpler way to verify the generated signature in linux?</p>

<p>Thanks,
F</p>
","<blockquote>
  <p>Is there a way to understand the 64-bytes signature generated so that I can map the signature blob contents to (r,s) pair in linux and verify it?</p>
</blockquote>

<p>The <code>r</code> and <code>s</code> are in P1363 format, which is simply a concatenation of <code>r</code> and <code>s</code> in a 2's compliment format. That is, the signature is simply <code>r || s</code>.</p>

<p>You need to know the hash to use this format. For example, SHA1 will create a <code>r</code> of 20 bytes and an <code>s</code> of 20 bytes. If <code>r</code> or <code>s</code> is ""too short"", then it is padded on the left with 0's.</p>

<p>Java and OpenPGP are different than P1363. Java and OpenPGP use an ASN.1 encoding:</p>

<pre><code>SEQUENCE ::= {
  r INTEGER,
  s INTEGER
}
</code></pre>

<p>Depending what library you use on Linux, you may have to convert between the formats. <a href=""http://www.codeproject.com/Articles/25590/Cryptographic-Interoperability-Digital-Signatures"" rel=""nofollow"">Cryptographic Interoperability: Digital Signatures</a> gives examples of signing and verifying using a few different libraries.</p>

<hr>

<blockquote>
  <p>Or is there a simpler way to verify the generated signature in linux?</p>
</blockquote>

<p>Try <a href=""http://www.cryptopp.com"" rel=""nofollow"">Crypto++</a>. I believe Microsoft and Crypto++ uses the same signature format, so you won't need to convert. See <a href=""http://www.cryptopp.com/wiki/Elliptic_Curve_Digital_Signature_Algorithm"" rel=""nofollow"">Elliptic Curve Digital Signature Algorithm</a> for details.</p>
","803","<linux><cryptoapi><ecdsa><cng>","1","2","1","2014-06-10 12:18:33","21048027","0","","","","","2014-01-08 10:20:42",""
"7345326","Implementation for EVP_CipherInit_ex / EVP_CipherUpdate / EVP_CipherFinal_ex","<p>I am using OpenSSL and <code>libcrypto</code> for encryption. I would like to ask where can I find these methods. I need them because i would like to add these methods in my code. I just want the .h and .cc or .c files. appreciate</p>
","<p>Here is detailed information on how to compile the openssl library yourself:
<a href=""http://www.ski-epic.com/2007_notes_on_openssl/index.html"" rel=""nofollow"">http://www.ski-epic.com/2007_notes_on_openssl/index.html</a></p>

<p>You can download the source code from here:
<a href=""http://www.openssl.org/"" rel=""nofollow"">http://www.openssl.org/</a></p>

<p>Simply search the code for implementations of the functions you are referring to, and copy/paste. Make sure the library's license allows you to do this, though.</p>
","788","<c++><ubuntu><openssl><cryptoapi>","0","2","1","2017-05-17 17:42:45","7345416","1","","608639","","2017-05-17 17:42:45","2011-09-08 08:38:44",""
"32210675","How to Sign an EXE with Additional Certificates using CryptoAPI and SignerSign","<p>I'm trying to build a tool that will mass sign a bunch of files based on Kernel-Mode Code Signing requirements.  I know that signtool can take an additional certificate for cross-signatures trust via the /ac argument, but have not been able to figure out how to do the same using SignerSign or SignerSignEx.  I've even spied on signtool's API calls, and mirroring them does not seems to produce the same affect.</p>

<p>Be aware, signtool or other command-line utilities cannot be used for this purpose due to project constraints.</p>

<p>Is there any documentation or examples on how to accomplish this?</p>
","<p>Okay, after working on this for awhile, I've finally figured our how to do signing with a cross certificate.  First, you will need four, or five depending on your version of signtool, certificates that are embedded in the signtool EXE's resources under the <code>CERTIFICATE</code> resource type, they all start with <code>MS</code>.  Now I made my version pull all certificates from files so the following example pseudo code will explain how to do this.  It's not purely the CryptoAPI calls, but does explain the basic process used by signtool.  All certificate usage validation has also been left out for simplicity.</p>

<hr>

<pre><code>// inputs: string pfx_file_path, string cross_cert_file_path, string password, string file_to_sign

Certificate_Store signer_collection = CertOpenStore(CERT_STORE_PROV_COLLECTION, 0, NULL, CERT_STORE_CREATE_NEW_FLAG, NULL);
Certificate_Store signer_store = CertOpenStore(CERT_STORE_PROV_MEMORY, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, NULL,
    CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG | CERT_STORE_READONLY_FLAG, NULL);

File pfx_file = File::open(pifx_file_path, GENERIC_READ, OPEN_EXISTING);
File_Mapping&lt;BYTE&gt; pfx_mapping = File_Mapping&lt;BYTE&gt;::map(pfx_file);

CRYPT_DATA_BLOB pfx_blob = { pfx_mapping.size(), pfx_mapping.data() };
Certificate_Store signer_pfx = PFXImportCertStore(&amp;pfx_blob, password, CRYPT_USER_KEYSET);

// CertEnumCertificatesInStore
for (Certificate certificate: signer_pfx) {
    signer_store.add(certificate); // CertAddCertificateContextToStore
}

signer_collection.add(signer_store); // CertAddStoreToCollection

Certificate signer;
for (Certificate certificate: signer_collection) {
    // Assumes first certificate is the signer, need better validation.
    signer = CertDuplicateCertificateContext(certificate);
    break;
}

if (signer != NULL) {
    throw NoSginerException();
}

Certificate_Store additional_collection;
if (cross_cert_file_path != NULL) {
    Certificate_Store cross_collection;
    Certificate_Store cross_store;

    Certificate cross_certificate = Certificate::load(cross_cert_file_path);
    // CryptQueryObject(CERT_QUERY_OBJECT_FILE, cross_cert_file_path, 
    //  CERT_QUERY_CONTENT_FLAG_CERT, CERT_QUERY_FORMAT_FLAG_ALL,
    //  0, NULL, NULL, NULL, NULL, NULL, &amp;cross_certificate);

    cross_collection = CertOpenStore(CERT_STORE_PROV_COLLECTION, 0, NULL, CERT_STORE_CREATE_NEW_FLAG, NULL);
    cross_collection.add(signer_collection);

    cross_store = CertOpenStore(CERT_STORE_PROV_MEMORY, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, NULL,
        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG | CERT_STORE_READONLY_FLAG, NULL);
    cross_store.add(cross_certificate);
    cross_collection.add(cross_store);

    Certificate_Store ms_root_store = CertOpenStore(sz_CERT_STORE_PROV_MEMORY, 0, NULL,
        CERT_STORE_CREATE_NEW_FLAG | CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, NULL);
    // This is where the embedded certificates from the MS Code Validation roots are collectioned.
    for (Resource resource: Program_Resources::resources_under(""CERTIFICATE"")) { // EnumResourceNames, Find/Load/Lock|Resource
        Certificate certificate = Certificate::from_blob(resource.size(), resource.data());
        // CERT_BLOB blob = { resource.size(), resources.data() };
        // CryptQueryObject(CERT_QUERY_OBJECT_BLOB, &amp;blob, 
        //  CERT_QUERY_CONTENT_FLAG_CERT | CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT,
        //  CERT_QUERY_FORMAT_FLAG_ALL, 0, NULL, NULL, NULL, NULL, NULL,
        //  &amp;certificate);
        ms_root_store.add(certificate);
    }

    cross_collection.add(certificate);

    static const DWORD CHAIN_FLAGS = CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING |
        CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS |
        CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    static const CERT_CHAIN_PARA CHAIN_PARAMS = { sizeof(CERT_CHAIN_PARA) };
    Certificate_Chain chain = Certificate_Chain::get(HCCE_LOCAL_MACHINE, signer, NULL,
        cross_collection, &amp;CHAIN_PARAMS, CHAIN_FLAGS, NULL);
    // CertGetCertificateChain(HCCE_LOCAL_MACHINE, signer, NULL,
    //  cross_collection, &amp;CHAIN_PARAMS, CHAIN_FLAGS, NULL, &amp;chain);

    Certificate_Store additional_store = CertOpenStore(CERT_STORE_PROV_MEMORY,
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, NULL, CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
        CERT_STORE_READONLY_FLAG, NULL);
    for (DWORD l = 0; l != chain-&gt;cLowerQualityChainContext; ++l) {
        PCCERT_CHAIN_CONTEXT low_chain = pChain-&gt;rgpLowerQualityChainContext[l];
        for (DWORD c = 0; c != low_chain-&gt;cChain; ++c) {
            PCERT_SIMPLE_CHAIN simple_chain = low_chain-&gt;rgpChain[c];
            for (DWORD e = 0; e != simple_chain-&gt;cElement; ++e) {
                PCERT_CHAIN_ELEMENT element = simple_chain-&gt;rgpElement[e];
                additional_store.add(element-&gt;pCertContext);
            }
        }
    }

    additional_collection = CertOpenStore(CERT_STORE_PROV_COLLECTION, 0, NULL, CERT_STORE_CREATE_NEW_FLAG, NULL);
    additional_collection.add(additional_store);
}

SIGNER_FILE_INFO file_info = { sizeof(SIGNER_FILE_INFO) };
file_info.pwszFileName = file_to_sign;

DWORD index = 0;
SIGNER_SUBJECT_INFO subject_info = { sizeof(SIGNER_SUBJECT_INFO) };
subject_info.pdwIndex = &amp;index;
subject_info.dwSubjectChoice = SIGNER_SUBJECT_FILE;
subject_info.pSignerFileInfo = &amp;file_info;

SIGNER_CERT_STORE_INFO store_info = { sizeof(SIGNER_CERT_STORE_INFO) };
store_info.dwCertPolicy = SIGNER_CERT_POLICY_STORE;
store_info.pSigningCert = signer;
store_info.hCertStore = additional_collection;

SIGNER_CERT cert_info = { sizeof(SIGNER_CERT) };
cert_info.dwCertChoice = SIGNER_CERT_STORE;
cert_info.pCertStoreInfo = &amp;store_info;

SIGNER_ATTR_AUTHCODE authcode_attr = { sizeof(SIGNER_ATTR_AUTHCODE) };

SIGNER_SIGNATURE_INFO signature_info = { sizeof(SIGNER_SIGNATURE_INFO) };
signature_info.algidHash = CALG_SHA;
signature_info.dwAttrChoice = SIGNER_AUTHCODE_ATTR;
signature_info.pAttrAuthcode = &amp;authcode_attr;

SIGNER_PROVIDER_INFO provider_info = { sizeof(SIGNER_PROVIDER_INFO) };
provider_info.pwszProviderName = L"""";
provider_info.dwPvkChoice = PVK_TYPE_KEYCONTAINER;
provider_info.pwszKeyContainer = L"""";

HRESULT hr = SignerSign(&amp;subject_info, &amp;cert_info, &amp;signature_info, &amp;provider_info, NULL, NULL, NULL);
</code></pre>
","782","<c++><windows><winapi><cryptoapi><signtool>","2","1","1","2015-08-26 13:31:44","32227878","0","2","","","","2015-08-25 17:43:30",""
"18447538","Adding Response from TSA to CRYPT_SIGN_MESSAGE_PARA for CryptSignMessage (c++, Crypto Api)","<p>I'm struggling how must I add the response from a TSA server to my CryptSignMessage?</p>

<p>Using PKCS#7. I currently have my message digest and I successfully sign it with CryptSignMessage from crypto api. Like so: </p>

<pre><code>// Initialize the signature structure.
CRYPT_SIGN_MESSAGE_PARA  SigParams;
SigParams.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
SigParams.dwMsgEncodingType = MY_ENCODING_TYPE;
SigParams.pSigningCert = hContext;
SigParams.HashAlgorithm.pszObjId = szOID_RSA_SHA1RSA;
SigParams.HashAlgorithm.Parameters.cbData = NULL;
SigParams.cMsgCert = 1;
SigParams.rgpMsgCert = &amp;hContext;
SigParams.dwInnerContentType = 0;
SigParams.cMsgCrl = 0;
SigParams.cUnauthAttr = 0;
SigParams.dwFlags = 0;
SigParams.pvHashAuxInfo = NULL;
SigParams.cAuthAttr = 0;
SigParams.rgAuthAttr = NULL;

// First, get the size of the signed BLOB.
if(CryptSignMessage(
    &amp;SigParams,
    FALSE,
    1,
    MessageArray,
    MessageSizeArray,
    NULL,
    &amp;cbSignedMessageBlob))
{
    printf(""%d bytes needed for the encoded BLOB."", cbSignedMessageBlob);
}
else
{
    MyHandleError();
    fReturn = false;
    exit_SignMessage();
}

// Allocate memory for the signed BLOB.
if(!(pbSignedMessageBlob = 
   (BYTE*)malloc(cbSignedMessageBlob)))
{
    MyHandleError();
    exit_SignMessage();
}

// Get the signed message BLOB.
if(CryptSignMessage(
      &amp;SigParams,
      TRUE,
      1,
      MessageArray,
      MessageSizeArray,
      pbSignedMessageBlob,
      &amp;cbSignedMessageBlob))
{
    printf(""The message was signed successfully. \n"");


    // pbSignedMessageBlob now contains the signed BLOB.
    fReturn = true;
}
else
{
    MyHandleError();
    fReturn = false;
    exit_SignMessage();
}
</code></pre>

<p>Now I want to use a TSA server to timestamp my digest, but I'm not really sure how to include this. Say I have a rfc3161 TimeStamp request; I send this to my TSA and I receive a rfc3161 TimeStamp response (probably using libcurl). How should incorporate the response into my SigParams? Must I extract the TimeStampToken and then store that as an unauthenticated counter signature? Something like:</p>

<pre><code>CRYPT_ATTR_BLOB cablob[1];
CRYPT_ATTRIBUTE ca[1];    
cablob[0].cbData = tstResponseSize; 
cablob[0].pbData = tstResponse; // the response from TSA

ca[0].pszObjId = ""1.2.840.113549.9.6""; // object identifier for counter signature
ca[0].cValue = 1;
ca[0].rgValue = cablob;
</code></pre>

<p>And then set the SigParams:</p>

<pre><code>SigParams.cUnauthAtt = 1;
SigParams.rgUnauthAttr = ca;
</code></pre>

<p>Any advice would be greatly appreciated.
Thanks,
Magda</p>
","<p>I struggled with this for a couple of days.  There are not that many examples out there, so here is my solution.  Hope it helps :)</p>

<pre><code>HCRYPTMSG hMsg = ::CryptMsgOpenToDecode(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, CMSG_DETACHED_FLAG, 0, NULL, NULL, NULL);
    if (NULL == hMsg)
    {
        throw std::exception(""Failed to open messsage to decode"");
    }

    if (!::CryptMsgUpdate(hMsg, signedData.pbData, signedData.cbData, TRUE))
    {
        throw std::exception(""Failed to add signature block to message"");
    }

    //get the digest from the signature
    PCRYPT_TIMESTAMP_CONTEXT pTsContext = NULL;
    DWORD encDigestSize = 0;
    if (::CryptMsgGetParam(hMsg, CMSG_ENCRYPTED_DIGEST, 0, NULL, &amp;encDigestSize))
    {
        std::unique_ptr&lt;BYTE&gt; pEncDigest(new BYTE[encDigestSize]);
        if (::CryptMsgGetParam(hMsg, CMSG_ENCRYPTED_DIGEST, 0, pEncDigest.get(), &amp;encDigestSize))
        {
            //get timestamp 
            if (::CryptRetrieveTimeStamp(L""http://sha256timestamp.ws.symantec.com/sha256/timestamp"",
                TIMESTAMP_NO_AUTH_RETRIEVAL,
                0, //timeout?????
                szOID_NIST_sha256,
                NULL,
                pEncDigest.get(),
                encDigestSize,
                &amp;pTsContext,
                NULL,
                NULL))
            {

                CRYPT_ATTR_BLOB cryptBlob = {};
                cryptBlob.cbData = pTsContext-&gt;cbEncoded;
                cryptBlob.pbData = pTsContext-&gt;pbEncoded;

                CRYPT_ATTRIBUTE cryptAttribute = {};
                cryptAttribute.pszObjId = ""1.2.840.113549.1.9.16.2.14""; //id-smime-aa-timeStampToken
                cryptAttribute.cValue = 1;
                cryptAttribute.rgValue = &amp;cryptBlob;

                DWORD encodedAttributeSize = 0;
                std::unique_ptr&lt;BYTE&gt; encodedAttribute;
                if (::CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_ATTRIBUTE, &amp;cryptAttribute, NULL, &amp;encodedAttributeSize))
                {
                    encodedAttribute.reset(new BYTE[encodedAttributeSize]);
                    if (::CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_ATTRIBUTE, &amp;cryptAttribute, encodedAttribute.get(), &amp;encodedAttributeSize))
                    {
                        CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA unauthenticatedParam = { 0 };
                        unauthenticatedParam.cbSize = sizeof(unauthenticatedParam);
                        unauthenticatedParam.dwSignerIndex = 0; //only have 1 cert
                        unauthenticatedParam.blob.cbData = encodedAttributeSize;
                        unauthenticatedParam.blob.pbData = encodedAttribute.get();

                        if (::CryptMsgControl(hMsg, 0, CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR, &amp;unauthenticatedParam))
                        {
                            DWORD encodedMessageLength = 0;
                            if (::CryptMsgGetParam(hMsg, CMSG_ENCODED_MESSAGE, 0, NULL, &amp;encodedMessageLength))
                            {
                                std::unique_ptr&lt;BYTE&gt; pData(new BYTE[encodedMessageLength]);
                                if (::CryptMsgGetParam(hMsg, CMSG_ENCODED_MESSAGE, 0, pData.get(), &amp;encodedMessageLength))
                                {
                                    //save pData/encodedMessageLength here to file
                                }
                            }
                        }

                    }
                }


            }
        }
    }


    if (NULL != pTsContext)
    {
        ::CryptMemFree(pTsContext);
    }

    if (NULL != hMsg)
    {
        ::CryptMsgClose(hMsg);
    }
</code></pre>
","780","<c++><cryptoapi><trusted-timestamp>","4","1","1","2018-01-31 09:50:19","","1","1","","","","2013-08-26 15:21:44",""
"44996810","Exporting PFX file from windows certificates store","<p>Our application uses OpenSSL for securing communication between client device and server. The certificates are generated by customers CA and we had to upload server certificate and private key to Windows OS based machine.</p>

<p>Until now we guide our customers to save a PEM files which include server certificate and private key at specific directory on server file system and our application upload it from there. Lately, we were asked by customer to read a PFX certificate from local windows certificate store.</p>

<p>I can think of 2 options which both combines use of CAPI library for exporting the PFX file from WCS (according to friendly name), serializing it and then uploading it using OpenSSL API.</p>

<p>The first option save it as temporary file on server file system then read as before with OpenSSL API.</p>

<p>The 2nd option uses memory i.e. pass pointers instead of using temporary file.</p>

<p>My team spent a lot of time searching the web (mainly Stack Overflow) and trying code snippets but didn't found working solution. I understood that the private key should be exportable marked during importing the file to WCS.</p>

<p>When I tried below code for simple exporting certificate and saving it to file (first half of option #1 based on MS example code) it writes only one character to file.</p>

<p>What do I miss here? Do I need to reformat certificate?</p>

<p>Any Idea of what is wrong and what is the right way to do it?</p>

<p>Can the private key be extract this way?</p>

<p>Thanks in advance for any comment</p>

<pre><code>//-----------------------------------------

#pragma comment(lib, ""crypt32.lib"")

#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;Wincrypt.h&gt;
#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
void MyHandleError(char *s);

void main(void)
{
//-------------------------------------------------------------------
// Declare and initialize variables.
HCERTSTORE         hSystemStore;
PCCERT_CONTEXT     pCertContext = NULL;
Char pszStoreName[256] = ""root"";
char               pszNameString[256] = ""CARootTest""; 
BYTE              pbElement[3000];
DWORD              cbElement;
//-------------------------------------------------------------------
// Open a system certificate store.
if(hSystemStore = CertOpenSystemStore(
    0,
    pszStoreName))
{
  printf(""The %s system store is open. Continue.\n"", pszStoreName );
}
else
{
  MyHandleError(""The first system store did not open."");
}
//-------------------------------------------------------------------
// Get a certificate that has the desired friendly name. 
if(pCertContext=CertFindCertificateInStore(
      hSystemStore,
      MY_ENCODING_TYPE,             // Use X509_ASN_ENCODING
      0,                            // No dwFlags needed 
      CERT_NAME_FRIENDLY_DISPLAY_TYPE,        // Find a certificate
      pszNameString, // The Unicode string to be found
                                    // in a certificate's subject
      NULL))                        // NULL for the first call 
{
  printf(""The %s certificate was found. \n"", pszNameString);
}
else
{
   MyHandleError(""Could not find the %s certificate."");
}
//-------------------------------------------------------------------
// Find out how much memory to allocate for the serialized element.

if(CertSerializeCertificateStoreElement(
    pCertContext,      // The existing certificate.
    0,                 // Accept default for dwFlags, 
    NULL,              // NULL for the first function call.
    &amp;cbElement))       // Address where the length of the 
                       // serialized element will be placed.
{
     printf(""The length of the serialized string is %d.\n"",
         cbElement);
}
else
{
     MyHandleError(""Finding the length of the serialized ""
         ""element failed."");
}
//-------------------------------------------------------------------
// Allocate memory for the serialized element.

if(pbElement = (BYTE*)malloc(cbElement+1))
{
     printf(""Memory has been allocated. Continue.\n"");
}
else
{
     MyHandleError(""The allocation of memory failed."");
}
//-------------------------------------------------------------------
// Create the serialized element from a certificate context.

if(CertSerializeCertificateStoreElement(
    pCertContext,        // The certificate context source for the 
                         // serialized element.
    0,                   // dwFlags. Accept the default.
    pbElement,           // A pointer to where the new element will
                         // be stored.
    &amp;cbElement))         // The length of the serialized element,
{
     printf(""The encoded element has been serialized. \n"");
}
else
{
     MyHandleError(""The element could not be serialized."");
}
//-------------------------------------------------------------------
//  pbElement could be written to a file ??

FILE *fp;
errno_t err;
if ((err = fopen_s(&amp;fp, ""cert.p12"", ""wb"")) != 0)
    printf(""File was not opened\n"");
else
    fprintf(fp, ""%s"", pbElement);
fclose(fp);

//-------------------------------------------------------------------
// Free memory.

free(pbElement);
CertCloseStore(hSystemStore,0);
printf(""The program ran without error to the end.\n"");
} // End of main

//-------------------------------------------------------------------
void MyHandleError(char *s)
{
    fprintf(stderr,""An error occurred in running the program. \n"");
    fprintf(stderr,""%s\n"",s);
    fprintf(stderr, ""Error number %x.\n"", GetLastError());
    fprintf(stderr, ""Program terminating. \n"");
    exit(1);
} // End of MyHandleError
</code></pre>
","","778","<c++><windows><openssl><ssl-certificate><cryptoapi>","1","","0","2017-07-09 23:38:08","","6","","608639","","2017-07-09 23:38:08","2017-07-09 13:14:45",""
"10807539","Is CryptEncrypt() thread-safe?","<p>Microsoft <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379924.aspx"" rel=""nofollow"">says</a>:</p>

<blockquote>
  <p>The <code>CryptEncrypt</code> function is not guaranteed to be thread safe and may return incorrect results if invoked simultaneously by multiple callers.</p>
</blockquote>

<p>Does this mean that the function modifies global data?<br>
Or does it simply mean that you can't use the same hash/key simultaneously?</p>

<p>(In other words, is the comment below correct?)</p>
","<p>I believe it means that you cannot fork several processes at the same time to use it because the function uses shared address space. It has access to the memory of all the threads and therefore will give you unexpected results. This should only be a problem with multi-threading if your application is doing that.</p>
","778","<winapi><thread-safety><cryptoapi>","0","0","2","2012-05-29 22:50:08","10807684","0","","","","","2012-05-29 22:21:15",""
"10807539","Is CryptEncrypt() thread-safe?","<p>Microsoft <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379924.aspx"" rel=""nofollow"">says</a>:</p>

<blockquote>
  <p>The <code>CryptEncrypt</code> function is not guaranteed to be thread safe and may return incorrect results if invoked simultaneously by multiple callers.</p>
</blockquote>

<p>Does this mean that the function modifies global data?<br>
Or does it simply mean that you can't use the same hash/key simultaneously?</p>

<p>(In other words, is the comment below correct?)</p>
","<p>It means what it means: the function is <em>not guaranteed to be thread-safe</em>. <strike>It probably has an internal static (or global) state, but that's an implementation detail.</p>

<p>Whether you use or not the same hash or key is irrelevant.</strike></p>

<hr>

<p>Edit after comment: according to <a href=""http://msdn.microsoft.com/en-us/library/Aa388149.aspx"" rel=""nofollow"">this MSDN page</a>, CryptoApi key handles are not thread safe because of the internal key state:</p>

<blockquote>
  <p>Most algorithms and modes require that data be decrypted in the same order that it was encrypted. This is a difficult task in a multithreaded environment because use of a critical section will not address the ordering issue. If you are using a block cipher (that is, RC2, DES, or 3DES) in ECB cipher mode, then this issue is not a factor because the internal key state does not change. However, ECB is not the default cipher mode. CBC is the default cipher mode. With CBC cipher mode, the internal key state does change. </p>
</blockquote>

<p>So after all, it <em>would</em> seem reasonable to think that you can indeed use <code>CryptEncrypt</code> on several threads if they don't share the same key. This is merely a guess, though.</p>
","778","<winapi><thread-safety><cryptoapi>","0","1","2","2012-05-29 22:50:08","10807684","0","","","","","2012-05-29 22:21:15",""
"12238225","Accessing PKCS12 stored certificate","<p>I'm exploring a case where the stored certificate must be extracted for using with OpenSSL's (C++ application). It is imported to Local Computer\Personal store, and had contained a password-protected private key.</p>

<p>What will be available to me via MS CryptoAPI?</p>

<p>What I want to is to either retrieve the original certificate, or its private key in either password-protected or unprotected form. Is it possible? Or CryptoAPI isn't intended for providing certificate copies and I shall use its functions instead of using OpenSSL?</p>
","<p><strong>What I want to is to either retrieve the original certificate, or its private key in either password-protected or unprotected form. Is it possible?</strong></p>

<p>Yes, you can export your PFX from certificate store using cryptoAPI with  <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387311%28v=vs.85%29.aspx"" rel=""nofollow""><code>PFXExportCertStore</code></a></p>
","770","<cryptoapi><pkcs#12><mscapi>","1","1","1","2015-06-09 17:43:53","12245673","0","","1118488","","2015-06-09 17:43:53","2012-09-02 17:34:06",""
"26010060","CryptGetUserKey function fails with no errors","<p>I've been playing around with <code>CryptoAPI</code> and everything was fine. </p>

<p>I've imported <code>.PFX</code> to the certificate store, got context, got <code>CSP</code> handle. Every function I've been using I've checked for the mistakes with <code>GetLastError</code> function. But when I'd called <code>CryptGetUserKey</code> with three arguments which are <code>hCryptProv</code>, <code>dwKeySpec</code> and pointer to <code>UserKey</code>, I got an error, but <code>GetLastError</code> call didn't show me anything but a random value like <code>2148073485</code> that means nothing I suppose. </p>

<p>How can I find out what is wrong? </p>

<p>OS - Windows 7 32b HP;</p>

<p>Programming language - C++;</p>

<p>IDE - MSVS2013 Ultimate. </p>
","<blockquote>
  <p>GetLastError call didn't show me anything but a random value like 2148073485 that means nothing I suppose.</p>
</blockquote>

<p>You fail WINAPI forever. It took me like five seconds to launch Calc.exe and convert it to hex: <code>8009000D</code>, which looks like a perfectly valid error HRESULT.</p>

<hr>

<p>Let's take some time to analyze it a bit more:</p>

<ul>
<li>8 is ERROR.</li>
<li>9 is not 7, meaning it's not a regular Win32 error. A search in Visual C++ headers tells me 9 is FACILITY_SSPI.</li>
<li>If I search 8009000D in Visual C++ headers, I get this line:
<code>#define NTE_NO_KEY _HRESULT_TYPEDEF_(0x8009000DL)</code> There, you have it, it's your error: NTE_NO_KEY.</li>
<li>MSDN is <a href=""http://msdn.microsoft.com/en-us/library/aa915314.aspx"" rel=""nofollow noreferrer"">rather unhelpful</a>, but Google shows some other questions about the NTE_NO_KEY error, such as <a href=""https://stackoverflow.com/questions/8272822/error-with-cryptdecrypt-winapi-function"">this</a>.</li>
</ul>
","768","<winapi><visual-c++><cryptoapi>","-2","1","1","2015-09-17 07:40:14","","1","","1478482","","2015-09-17 07:40:14","2014-09-24 06:30:54",""
"48021569","How can I get transaction fee through Coinbase API?","<p>How to get a transaction fee before sending transaction through coinbase API?</p>

<p>Or how to set a transaction fee for a transaction through coinbase API?</p>
","<p>The Coinbase ""fee"" is the difference between the buy and the sell rate. At the moment It works out to about 1.8%. This is the overall fee, with the miner fees included. </p>

<p>You can query the difference between <code>https://api.coinbase.com/v2/prices/BTC-USD/buy</code> and <code>https://api.coinbase.com/v2/prices/BTC-USD/sell</code></p>
","761","<bitcoin><cryptoapi><coinbase-api>","3","1","1","2018-01-07 22:25:11","","7","","","","","2017-12-29 11:02:35",""
"34800666","CAPI AES: Why does CryptSetKeyParam returns NTE_BAD_DATA (0x80090005)","<p>I am trying to encrypt/decrypt data using AES 128 bit with zero padding. I can encrypt/decrypt fine if I don't attempt to futz with the padding mode (defaults to PKCS5_PADDING), so the following snippet of code is to show where things are breaking down:</p>

<pre><code>// sanity check -- is key configured how I expect?
CryptGetKeyParam(hKey, KP_KEYLEN, temp, &amp;tempSz, 0);
CryptGetKeyParam(hKey, KP_ALGID, temp, &amp;tempSz, 0);
CryptGetKeyParam(hKey, KP_MODE, temp, &amp;tempSz, 0);
CryptGetKeyParam(hKey, KP_PADDING, temp, &amp;tempSz, 0);
// force padding to zero padding
DWORD padding = ZERO_PADDING;
CryptSetKeyParam(hKey, KP_PADDING, (PBYTE)&amp;padding, 0);
</code></pre>

<p>each of the queries operates without issue with values: 128, 0x0000660e (CALG_AES_128), 1 (CRYPT_MODE_CBC) and 1 (PKCS5_PADDING) -- that is the default state.</p>

<p>then I attempt to set the padding to ZERO_PADDING (3) and the function returns FALSE with a last error of NTE_BAD_DATA. I tried, for giggles, to set it to PKCS5_PADDING -- no error. RANDOM_PADDING: error.</p>

<p>searching the interwebs as I might, I cannot find any documentation to suggest why changing the padding should fail (not even a note saying only PKCS5_PADDING is allowed for certain key algorithms).</p>

<p>does anyone have any advice?</p>
","<p>The cryptographic service providers provided by Microsoft only support <code>PKCS5_PADDING</code>.</p>

<p>See <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380272(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380272(v=vs.85).aspx</a> for reference; search for <code>KP_PADDING</code>.</p>
","743","<winapi><encryption><aes><padding><cryptoapi>","0","2","1","2016-01-15 00:30:14","34802368","3","","1454825","","2016-01-15 00:00:40","2016-01-14 22:05:10",""
"19265802","Generate session key based on PUBLICKEYBLOB / PRIVATEKEYBLOB","<p>My code looks like this, I traced each undefined method here to the functions called with relevant arguments included.</p>

<p>I have a hard time wrapping my head around the API. So what I have here is that I can generate public/private keys, and I can generate <strong>a</strong> session key, but how can I generate a session key based on the public key?
What am I missing/assuming (wrong) here?</p>

<pre><code>

void Crypto::GenerateKeyPair( Buffer& publicKey, Buffer& privateKey ) throw(WinError)
{
    /* CryptAcquireContext ( PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) */
    CryptContext context = CryptoProviders::NewContext(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    /* CryptGenKey( AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &key) */
    CryptKey key = context.GenerateKeyExchangePair(); 
    /* CryptExportKey( PUBLICKEYBLOB, pPub); */
    key.ExportPublicKey(publicKey);
    /* CryptExportKey( PRIVATEKEYBLOB, pPriv); */
    key.ExportPrivateKey(privateKey);
}


void Crypto::GenerateSessionKey( Buffer& sessionKey ) throw(WinError)
{
    /* CryptAcquireContext ( PROV_RSA_FULL, 0 ) */
    CryptContext context = CryptoProviders::NewContext(PROV_RSA_FULL, 0);
    /* CryptGenKey( CALG_RC4, CRYPT_EXPORTABLE ) */
    /* CryptGetUserKey( AT_KEYEXCHANGE ) */
    /* CryptExportKey( SIMPLEBLOB ) */
    context.GenerateSessionKey(sessionKey);
}

void Crypto::EncryptData( const Buffer& publicKey, const Buffer& plaintext, Buffer& encrypted )
{
    /* CryptAcquireContext ( PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) */
    CryptContext hProvider(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    /* CryptImportKey( 0 ) */
    CryptKey key = hProvider.ImportKey(publicKey);
    /* CryptEncrypt() */
    key.Encrypt(plaintext, encrypted);

}

void Crypto::DecryptData( const Buffer& privateKey, const Buffer& encrypted, Buffer& plaintext )
{
    /* CryptAcquireContext ( PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) */
    CryptContext hProvider(PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
    /* CryptImportKey( 0 ) */
    CryptKey key = hProvider.ImportKey(privateKey);
    /* CryptDecrypt() */
    key.Decrypt(encrypted, plaintext);
}
</code></pre>
","<p>Session key is a <strong>symmetric key</strong> (meaning same key used for encryption and decryption). It is EXCHANGED with the other node secretly <em>using</em> asymmetric key pair (public and private keys).</p>

<p>So you <em>do not generate session key</em> from public key, rather you come up with a session key on your own (or better yet negotiate through some protocol as pointed out in comment e.g. D-H key exchange) and <strong>encrypt that using the other node's public key and send</strong>. So only the other side can discover the session key because ONLY it can decrypt data using its private key.</p>

<p>Reading <a href=""http://en.wikipedia.org/wiki/Session_key"" rel=""nofollow"">reasons for using session keys</a> would help</p>
","742","<c++><windows><winapi><cryptoapi>","1","1","1","2013-10-10 13:35:25","19266026","1","","57085","","2013-10-09 07:41:04","2013-10-09 07:34:45","2013-10-09 17:44:56"
"49456678","Delphi mutual authentication","<p>I use the WinINet library to connect to a website.</p>

<p>Using the Internet Explorer (Win10) it works and shows me the message to select the certificate to use.</p>

<p>This is the delphi code I call:</p>

<pre><code>FUNCTION TRAD.lastOrganization(): Integer;
VAR
  js:TlkJSONobject;
  ws: TlkJSONstring;
  url, resp: String;
  count,statusCodeLen, bodyCodeLen: Cardinal;
  header,tmp: String;
  buffer, body: String;
  statusCode: ARRAY [0 .. 1024] OF Char;
  bodyCode: ARRAY [0 .. 1024] OF Char;
  UrlHandle: HINTERNET;
BEGIN
  buffer := '00000000000000000000';
  url := contextUrl + '/rest/organization/count';
  UrlHandle := InternetOpenUrl(NetHandle, PChar(url), nil, 0, INTERNET_FLAG_RELOAD, 0);
  IF NOT ASSIGNED(UrlHandle) THEN
    SHOWMESSAGE('Unable to read the amount of Organization using the URL ' + url + ': ' +  SysErrorMessage(GetLastError));
  statusCodeLen := Length(statusCode);
  bodyCodeLen := Length(bodyCode);
  count := 0;
  IF HttpQueryInfo(UrlHandle, HTTP_QUERY_STATUS_CODE, @statusCode[0], statusCodeLen, count) THEN
  BEGIN
    buffer := statusCode;
    IF buffer &lt;&gt; '200' THEN
    BEGIN
      ShowMessage('While read amount of Organization I got a status code ' + buffer + ' but 200 was expected.');
      EXIT;
    END;
  END;

  count := 0;
  body := '';
  REPEAT
    FillChar(bodyCode, bodyCodeLen, 0);
    IF NOT InternetReadFile(UrlHandle, @bodyCode[0], bodyCodeLen, count) THEN
    BEGIN
      ShowMessage('Problem on reading from response stream while read the amount of Organization using the URL ' + url + '.');
      EXIT;
    END;
    IF count &gt; 0 THEN
    BEGIN
      tmp := bodyCode;
      body := body + LeftStr(tmp, count);
    END;
  UNTIL count = 0;

  InternetCloseHandle(UrlHandle);
  Result := strtoint(body);
END;
</code></pre>

<p>If I call the method, I get this message:</p>

<p><a href=""https://i.stack.imgur.com/Bgz79.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Bgz79.png"" alt=""enter image description here""></a></p>

<p>Buuut, using the Edge-Browser I have to specify a certificate, and it works just great.</p>

<p><a href=""https://i.stack.imgur.com/FjDik.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/FjDik.png"" alt=""enter image description here""></a></p>

<h2>Question</h2>

<p>How to specify the certificate?</p>

<h2>Edit (new informations):</h2>

<p>If I change the code to</p>

<pre><code>FUNCTION TRAD.lastOrganization(): Integer;
VAR
  js:TlkJSONobject;
  ws: TlkJSONstring;
  url, resp: String;
  count,statusCodeLen, bodyCodeLen: Cardinal;
  header,tmp: String;
  buffer, body: String;
  statusCode: ARRAY [0 .. 1024] OF Char;
  bodyCode: ARRAY [0 .. 1024] OF Char;
  UrlHandle: HINTERNET;
BEGIN
  buffer := '00000000000000000000';
  url := contextUrl + '/rest/organization/count';
  UrlHandle := InternetOpenUrl(NetHandle, PChar(url), nil, 0, INTERNET_FLAG_RELOAD, 0);
  IF NOT ASSIGNED(UrlHandle) THEN
    raiseLastOSError();
</code></pre>

<p>It shows: <a href=""https://i.stack.imgur.com/BtnOu.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/BtnOu.png"" alt=""enter image description here""></a></p>
","<p>Using WinHTTP (You can do the same with WinInetHTTP) you can set the certificate like this via ActiveX :</p>

<pre><code>// Instantiate a WinHttpRequest object.
var HttpReq = new ActiveXObject(""WinHttp.WinHttpRequest.5.1"");

// Open an HTTP connection.
HttpReq.Open(""GET"", ""https://www.fabrikam.com/"", false);

// Select a client certificate.
HttpReq.SetClientCertificate(
            ""LOCAL_MACHINE\\Personal\\My Middle-Tier Certificate"");

// Send the HTTP Request.
HttpReq.Send();
</code></pre>

<p>So that easy with ActiveX but it's not really what you want (i gave you the example as illustration). So with the windows API, WinHTTP enables you to select and send a certificate from a local certificate store. The following code example shows how to open a certificate store and locate a certificate based on subject name after the ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED error has been returned.</p>

<pre><code>if( !WinHttpReceiveResponse( hRequest, NULL ) )
  {
    if( GetLastError( ) == ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED )
    {
      //MY is the store the certificate is in.
      hMyStore = CertOpenSystemStore( 0, TEXT(""MY"") );
      if( hMyStore )
      {
        pCertContext = CertFindCertificateInStore( hMyStore,
             X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
             0,
             CERT_FIND_SUBJECT_STR,
             (LPVOID) szCertName, //Subject string in the certificate.
             NULL );
        if( pCertContext )
        {
          WinHttpSetOption( hRequest, 
                            WINHTTP_OPTION_CLIENT_CERT_CONTEXT,
                            (LPVOID) pCertContext, 
                            sizeof(CERT_CONTEXT) );
          CertFreeCertificateContext( pCertContext );
        }
        CertCloseStore( hMyStore, 0 );

        // NOTE: Application should now resend the request.
      }
    }
  }
</code></pre>
","727","<delphi><microsoft-edge><cryptoapi><mutual-authentication>","18","2","2","2018-04-22 09:14:54","49950017","19","2","843943","","2018-03-26 14:03:51","2018-03-23 18:57:57",""
"49456678","Delphi mutual authentication","<p>I use the WinINet library to connect to a website.</p>

<p>Using the Internet Explorer (Win10) it works and shows me the message to select the certificate to use.</p>

<p>This is the delphi code I call:</p>

<pre><code>FUNCTION TRAD.lastOrganization(): Integer;
VAR
  js:TlkJSONobject;
  ws: TlkJSONstring;
  url, resp: String;
  count,statusCodeLen, bodyCodeLen: Cardinal;
  header,tmp: String;
  buffer, body: String;
  statusCode: ARRAY [0 .. 1024] OF Char;
  bodyCode: ARRAY [0 .. 1024] OF Char;
  UrlHandle: HINTERNET;
BEGIN
  buffer := '00000000000000000000';
  url := contextUrl + '/rest/organization/count';
  UrlHandle := InternetOpenUrl(NetHandle, PChar(url), nil, 0, INTERNET_FLAG_RELOAD, 0);
  IF NOT ASSIGNED(UrlHandle) THEN
    SHOWMESSAGE('Unable to read the amount of Organization using the URL ' + url + ': ' +  SysErrorMessage(GetLastError));
  statusCodeLen := Length(statusCode);
  bodyCodeLen := Length(bodyCode);
  count := 0;
  IF HttpQueryInfo(UrlHandle, HTTP_QUERY_STATUS_CODE, @statusCode[0], statusCodeLen, count) THEN
  BEGIN
    buffer := statusCode;
    IF buffer &lt;&gt; '200' THEN
    BEGIN
      ShowMessage('While read amount of Organization I got a status code ' + buffer + ' but 200 was expected.');
      EXIT;
    END;
  END;

  count := 0;
  body := '';
  REPEAT
    FillChar(bodyCode, bodyCodeLen, 0);
    IF NOT InternetReadFile(UrlHandle, @bodyCode[0], bodyCodeLen, count) THEN
    BEGIN
      ShowMessage('Problem on reading from response stream while read the amount of Organization using the URL ' + url + '.');
      EXIT;
    END;
    IF count &gt; 0 THEN
    BEGIN
      tmp := bodyCode;
      body := body + LeftStr(tmp, count);
    END;
  UNTIL count = 0;

  InternetCloseHandle(UrlHandle);
  Result := strtoint(body);
END;
</code></pre>

<p>If I call the method, I get this message:</p>

<p><a href=""https://i.stack.imgur.com/Bgz79.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/Bgz79.png"" alt=""enter image description here""></a></p>

<p>Buuut, using the Edge-Browser I have to specify a certificate, and it works just great.</p>

<p><a href=""https://i.stack.imgur.com/FjDik.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/FjDik.png"" alt=""enter image description here""></a></p>

<h2>Question</h2>

<p>How to specify the certificate?</p>

<h2>Edit (new informations):</h2>

<p>If I change the code to</p>

<pre><code>FUNCTION TRAD.lastOrganization(): Integer;
VAR
  js:TlkJSONobject;
  ws: TlkJSONstring;
  url, resp: String;
  count,statusCodeLen, bodyCodeLen: Cardinal;
  header,tmp: String;
  buffer, body: String;
  statusCode: ARRAY [0 .. 1024] OF Char;
  bodyCode: ARRAY [0 .. 1024] OF Char;
  UrlHandle: HINTERNET;
BEGIN
  buffer := '00000000000000000000';
  url := contextUrl + '/rest/organization/count';
  UrlHandle := InternetOpenUrl(NetHandle, PChar(url), nil, 0, INTERNET_FLAG_RELOAD, 0);
  IF NOT ASSIGNED(UrlHandle) THEN
    raiseLastOSError();
</code></pre>

<p>It shows: <a href=""https://i.stack.imgur.com/BtnOu.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/BtnOu.png"" alt=""enter image description here""></a></p>
","<p>Consider the use of <a href=""https://msdn.microsoft.com/es-es/library/windows/desktop/aa384694(v=vs.85).aspx"" rel=""nofollow noreferrer"">InternetErrorDlg</a></p>

<p><strong>Code example:</strong></p>

<pre><code>function WebSiteConnect(const UserAgent: string; const Server: string; const Resource: string;): string;
var
  hInet: HINTERNET;
  hConn: HINTERNET;
  hReq:  HINTERNET;
  dwLastError:DWORD;

  nilptr:Pointer;
  dwRetVal:DWORD;

  bLoop: boolean;
  port:Integer;
begin
  hInet := InternetOpen(PChar(UserAgent), INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0);
  if hInet = nil then exit;
  hConn := InternetConnect(hInet, PChar(Server), INTERNET_DEFAULT_HTTPS_PORT, nil, nil, INTERNET_SERVICE_HTTP, 0, 0);
  if hConn = nil then
  begin
    InternetCloseHandle(hInet);
    exit;
  end;
  hReq := HttpOpenRequest(hConn, 'GET', PChar(Resource), 'HTTP/1.0', nil, nil, INTERNET_FLAG_SECURE, 0);
  if hReq = nil then
  Begin
    InternetCloseHandle(hConn);
    InternetCloseHandle(hInet);
    exit;
  end;

  bLoop := true;
  while bLoop do
  begin
    if HttpSendRequest(hReq, nil, 0, nil, 0) then
      dwLastError := ERROR_SUCCESS
    else
      dwLastError:= GetLastError();

    if dwLastError = ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED then
    begin
      dwRetVal:= InternetErrorDlg(application.handle, hReq, dwLastError,
      FLAGS_ERROR_UI_FILTER_FOR_ERRORS or
      FLAGS_ERROR_UI_FLAGS_GENERATE_DATA or
      FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS,
      nilptr );

      if dwRetVal = ERROR_INTERNET_FORCE_RETRY then
        continue
      else  // CANCEL button
      begin
        InternetCloseHandle(hReq);
        InternetCloseHandle(hConn);
        InternetCloseHandle(hInet);
        exit;
      end;
    end
    else
      bLoop := false;
  end;
  Result:= ...
end;
</code></pre>
","727","<delphi><microsoft-edge><cryptoapi><mutual-authentication>","18","4","2","2018-04-22 09:14:54","49950017","19","2","843943","","2018-03-26 14:03:51","2018-03-23 18:57:57",""
"18367542","cryptdecrypt succeeds with NTE_BAD_DATA","<p>I'm attempting to encrypt/decrypt a single buffer using the CryptoAPI.</p>

<p>I've been successful in encrypting/decrypting a key and Importing/Exporting the key BLOB. I've also (only in the apparent sense) been successful with the Encryption (only) of data. </p>

<p>The following code sucessfully Encrypts the data. On decryption, it successfully decrypts the data, but reports ""NTE_BAD_DATA"".</p>

<p>globals in header:</p>

<pre><code>HCRYPTPROV cryptprov;
HCRYPTKEY pubenckey;
HCRYPTKEY cryptprivkey;
LPVOID keystore;
</code></pre>

<p>Creating a session key:</p>

<pre><code>DWORD ret = 0;
ZeroMemory(&amp;cryptprov,sizeof(cryptprov));
CString cwinver(""Windows 7"";);
string winver = cwinver.GetBuffer();
wstring provname;
wstring contname = L""Container"";
if (winver.compare(""Windows XP"") == 0) { provname.assign(L""Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)""); } else { provname.assign(L""Microsoft Enhanced RSA and AES Cryptographic Provider""); }

ret = CryptAcquireContextW(&amp;cryptprov,contname.c_str(),provname.c_str(),PROV_RSA_AES,CRYPT_SILENT);
if (ret == FALSE) { ret = CryptAcquireContextW(&amp;cryptprov,contname.c_str(),provname.c_str(),PROV_RSA_AES,CRYPT_SILENT|CRYPT_NEWKEYSET); }
if (ret == FALSE) {
    return -1;
}
HCRYPTHASH hashobj;
CStringW cpass(""testpass"");
wstring pass = cpass.GetBuffer();
ret = CryptCreateHash(cryptprov,CALG_MD5,NULL,NULL,&amp;hashobj);
if (ret == FALSE) {
    return -1;
}
ret = CryptHashData(hashobj,(LPBYTE)pass.c_str(),pass.size(),0);
if (ret == FALSE) {
    return -1;
}

ret = CryptDeriveKey(cryptprov,CALG_AES_256,hashobj,0x01000000|CRYPT_EXPORTABLE,&amp;cryptprivkey);
if (ret == FALSE) {
    return -1;
}
CryptDestroyHash(hashobj);
return ret;
</code></pre>

<p>Generating a key, exporting the blob, encrypting it with the session key, and writing to file:</p>

<pre><code>DWORD ret = 0;
int buflen;

ret = CryptGenKey(cryptprov,CALG_AES_256,0x01000000|CRYPT_EXPORTABLE,&amp;pubenckey);
if (ret == FALSE) {
    return -1;
}
DWORD count;
ret = CryptExportKey(pubenckey,0,PLAINTEXTKEYBLOB,0,NULL,&amp;count);
if (ret == FALSE) {
    return -1;
}
buflen = count + 100;
keystore = VirtualAlloc(NULL,buflen,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
ret = CryptExportKey(pubenckey,0,PLAINTEXTKEYBLOB,0,(BYTE *)keystore,&amp;count);
if (ret == FALSE) {
    return -1;
}
DWORD origkeyblocksize = count;
ret = CryptEncrypt(cryptprivkey,NULL,TRUE,0,NULL,&amp;count,buflen);
if (ret == FALSE) {
    return -1;
}
ret = CryptEncrypt(cryptprivkey,NULL,TRUE,0,(BYTE *)keystore,&amp;count,buflen);
if (ret == FALSE) {
    return -1;
}
memcpy((void *)((LONG)keystore+count),(void *)&amp;origkeyblocksize,4);
string filen = ""C:\\testenc.enc"";
if (filen.compare("""") != 0) {
    HANDLE fileh = CreateFile(filen.c_str(),GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    if (fileh != INVALID_HANDLE_VALUE) {
        ret = WriteFile(fileh, keystore, count+4, &amp;count, NULL);
    } else { ret = -1; }
    CloseHandle(fileh);
} else { ret = -1; }
if (ret != -1 &amp;&amp; ret != FALSE) { ret = (LONG)keystore; }
return ret;
</code></pre>

<p>Another application reads the file and imports the key:</p>

<pre><code>DWORD ret = 0;
DWORD datalen;
DWORD bufsize = 0;
DWORD origkeysize = 0;

string filen = ""c:\\testenc.enc"";
if (filen.compare("""") != 0) {
    HANDLE fileh = CreateFile(filen.c_str(),GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (fileh != INVALID_HANDLE_VALUE) {
        DWORD fsize = GetFileSize(fileh,0);
        bufsize = fsize-4;
        keystore = VirtualAlloc(NULL,bufsize,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
        ret = ReadFile(fileh, keystore, fsize-4, &amp;datalen, NULL);
        ret = ReadFile(fileh, &amp;origkeysize, 4, &amp;datalen, NULL);
        CloseHandle(fileh);
        if (ret == FALSE) { ret = -1; }
    } else { ret = -1; }
} else { ret = -1; }
if (ret == FALSE || ret == -1) {
    return -1;
}
datalen = bufsize;
ret = CryptDecrypt(cryptprivkey,NULL,TRUE,0,(BYTE *)keystore,&amp;datalen);
if (ret == FALSE) {
    return -1;
}
ret = CryptImportKey(cryptprov,(BYTE *)keystore,origkeysize,0,0,&amp;pubenckey);
if (ret == FALSE) { ret = -1; } else { ret = (LONG)keystore; }
return ret;
</code></pre>

<p>Encryption of buffer (buffer pointer is passed in as a LONG and the first twelve bytes are used for encrypted/unencrypted data lengths):</p>

<pre><code>DWORD ret = 0;
DWORD buflen;
DWORD count;
memcpy((void *)&amp;count,(void *)((LONG)passedbufferptr),4);
count-=12;

buflen = count + 32;
ret = CryptEncrypt(pubenckey,NULL,TRUE,0,NULL,&amp;count,buflen);
if (ret == FALSE) {
    return -1;
}

ret = CryptEncrypt(pubenckey,NULL,TRUE,0,(BYTE *)((LONG)passedbufferptr+12),&amp;count,buflen);
if (ret == FALSE) {
    return -1;
}
memcpy((void *)((LONG)passedbufferptr+8),(void *)&amp;count,4);

return ret;
</code></pre>

<p>Decryption of data:</p>

<pre><code>DWORD ret = 0;
DWORD count;
memcpy((void *)&amp;count,(void *)((LONG)passedbufferptr+8),4);

ret = CryptDecrypt(pubenckey,NULL,TRUE,0,(BYTE *)((LONG)passedbufferptr+12),&amp;count);
if (ret == FALSE) {
    return GetLastError();
}

return ret;
</code></pre>

<p>The last code block consistently returns -2146893819 (NTE_BAD_DATA). Upon inspection of the buffer, however, it is decrypted.</p>

<p>It is important to note, that I pass in buffers with data amounts that are multiples of 32, and that doesn't change the result.</p>

<p>Thanks for any help you may have!</p>
","","725","<encryption><aes><rsa><cryptoapi>","1","","0","2014-09-29 21:46:02","","0","","2602387","","2013-08-22 17:05:22","2013-08-21 20:56:39",""
"1591070","CryptEncrypt() API","<p>is it normal to get the junk bytes at end of buffer when this function returns?</p>
","<p>If you're using a block cipher, it's normal for the output to be padded to a multiple of the block size. With a stream cipher, the result will normally be exactly the same length as the input.</p>
","724","<winapi><cryptoapi>","1","2","1","2009-10-19 20:54:12","1591098","0","","","","","2009-10-19 20:49:20",""
"32933411","CryptoAPI RSA: CryptDecrypt decrypts only at the first time, other calls return NTE_BAD_DATA","<p>I have write the programm which encrypts/decrypts memory buffer of custom length. Ecryption ends well; but my decryption code decrypts data only one time at any buffer position, wich corresponds to the block entries. Decryption of the other blocks ends up with NTE_BAD_DATA.</p>

<p>Do you have any suggestions why is this happening?</p>

<p>Here is my encryption code:</p>

<pre><code>void CWinRSA::FinishEncrypt(const char* pcbRawData, const size_t nDataSize, char** ppcbEcrData, size_t&amp; rnEcrSize) const
{
    if (m_hProvider == NULL)
    {
        throw (""Cannot encrypt data with wrong provider!!"");
    }

    if (m_hKey == NULL)
    {
        throw (""Cannot encrypt data with a wrong key!!"");
    }

    size_t nBlockLength = GetBlockLength();
    size_t nPaddingSize = nBlockLength - 11;

    size_t nRemain = nDataSize % nBlockLength;
    size_t nBlockProcess = (nDataSize / nPaddingSize + (nRemain != 0 ? 1 : 0));

    size_t nResultSize = nBlockProcess * nBlockLength;

    (*ppcbEcrData) = new char[nResultSize];

    DWORD dwBufferLength = nBlockLength;
    DWORD dwDataLength;

    for (int iBlock = 0; iBlock &lt; nBlockProcess - 1; iBlock++)
    {
        memcpy((*ppcbEcrData) + (iBlock * nBlockLength),
            pcbRawData + (iBlock * nPaddingSize), nPaddingSize);

        dwDataLength = nPaddingSize;

        if (!CryptEncrypt(m_hKey, NULL, FALSE, 0,
            (BYTE*)((*ppcbEcrData) + (iBlock * nBlockLength)),
            &amp;dwDataLength, dwBufferLength))
        {
            throw (""Cannot encrypt data!!"");
        }
    }

    memcpy((*ppcbEcrData) + ((nBlockProcess - 1) * nBlockLength),
        pcbRawData + ((nBlockProcess - 1) * nPaddingSize), (nRemain ? nRemain : nPaddingSize));

    dwDataLength = (nRemain ? nRemain : nPaddingSize);

    if (!CryptEncrypt(m_hKey, NULL, TRUE, 0,
        (BYTE*)((*ppcbEcrData) + ((nBlockProcess - 1) * nBlockLength)),
        &amp;dwDataLength, dwBufferLength))
    {
        throw (""Cannot encrypt data!!"");
    }

    rnEcrSize = nResultSize;
}
</code></pre>

<p>the decryption:</p>

<pre><code>void CWinRSA::FinishDecrypt(const char* pcbRawData, const size_t nDataSize, char** ppcbDecData, size_t&amp; rnDecSize) const
{
    if (m_hProvider == NULL)
    {
        throw (""Cannot decrypt data with wrong provider!!"");
    }

    if (m_hKey == NULL)
    {
        throw (""Cannot decrypt data with a wrong key!!"");
    }

    size_t nBlockLength = GetBlockLength();

    if ((nDataSize % nBlockLength) != 0)
    {
        throw (""Cannot decrypt data!! Probably data is corrupted!!"");
    }

    size_t nPaddingSize = nBlockLength - 11;
    size_t nBlockProcess = nDataSize / nBlockLength;

    size_t nResultSize = nBlockProcess * nPaddingSize;

    (*ppcbDecData) = new char[nResultSize];

    DWORD dwDataLength;

    char* pcbComputeResult = new char[nBlockLength];

    for (int iBlock = 0; iBlock &lt; nBlockProcess - 1; iBlock++)
    {
        memcpy(pcbComputeResult, pcbRawData + (iBlock * nBlockLength), nBlockLength);

        if (!CryptDecrypt(m_hKey, NULL, FALSE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
        {
            throw (""Cannot decrypt data!!"");
        }

        memcpy((*ppcbDecData) + (iBlock * nPaddingSize), pcbComputeResult, nPaddingSize);
    }

    memcpy(pcbComputeResult, pcbRawData + ((nBlockProcess - 1) * nBlockLength), nBlockLength);

    if (!CryptDecrypt(m_hKey, NULL, TRUE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
    {
        DWORD dwError = GetLastError();

        throw (""Cannot decrypt data!!"");
    }

    memcpy((*ppcbDecData) + ((nBlockProcess - 1) * nPaddingSize), pcbComputeResult, nPaddingSize);

    rnDecSize = ((nBlockProcess - 1) * nPaddingSize) + dwDataLength;

    delete[] pcbComputeResult;
    pcbComputeResult = NULL;
}
</code></pre>
","<p>RSA isn't meant to be used that way.  It really isn't a block cipher (or a stream cipher, for that matter).    Its my understanding that it really doesn't have any cryptological use except for a single ""short"" message, so it doesn't surprise me that the library fails after one decrypt from a key.</p>

<p>If you need to protect an arbitrary size of data, use RSA to exchange a symmetric key for a stream or block cipher (like AES).</p>
","719","<c++><encryption><cryptoapi>","1","1","2","2019-09-26 14:33:37","32937065","0","2","5348281","","2019-09-26 14:33:37","2015-10-04 12:22:44",""
"32933411","CryptoAPI RSA: CryptDecrypt decrypts only at the first time, other calls return NTE_BAD_DATA","<p>I have write the programm which encrypts/decrypts memory buffer of custom length. Ecryption ends well; but my decryption code decrypts data only one time at any buffer position, wich corresponds to the block entries. Decryption of the other blocks ends up with NTE_BAD_DATA.</p>

<p>Do you have any suggestions why is this happening?</p>

<p>Here is my encryption code:</p>

<pre><code>void CWinRSA::FinishEncrypt(const char* pcbRawData, const size_t nDataSize, char** ppcbEcrData, size_t&amp; rnEcrSize) const
{
    if (m_hProvider == NULL)
    {
        throw (""Cannot encrypt data with wrong provider!!"");
    }

    if (m_hKey == NULL)
    {
        throw (""Cannot encrypt data with a wrong key!!"");
    }

    size_t nBlockLength = GetBlockLength();
    size_t nPaddingSize = nBlockLength - 11;

    size_t nRemain = nDataSize % nBlockLength;
    size_t nBlockProcess = (nDataSize / nPaddingSize + (nRemain != 0 ? 1 : 0));

    size_t nResultSize = nBlockProcess * nBlockLength;

    (*ppcbEcrData) = new char[nResultSize];

    DWORD dwBufferLength = nBlockLength;
    DWORD dwDataLength;

    for (int iBlock = 0; iBlock &lt; nBlockProcess - 1; iBlock++)
    {
        memcpy((*ppcbEcrData) + (iBlock * nBlockLength),
            pcbRawData + (iBlock * nPaddingSize), nPaddingSize);

        dwDataLength = nPaddingSize;

        if (!CryptEncrypt(m_hKey, NULL, FALSE, 0,
            (BYTE*)((*ppcbEcrData) + (iBlock * nBlockLength)),
            &amp;dwDataLength, dwBufferLength))
        {
            throw (""Cannot encrypt data!!"");
        }
    }

    memcpy((*ppcbEcrData) + ((nBlockProcess - 1) * nBlockLength),
        pcbRawData + ((nBlockProcess - 1) * nPaddingSize), (nRemain ? nRemain : nPaddingSize));

    dwDataLength = (nRemain ? nRemain : nPaddingSize);

    if (!CryptEncrypt(m_hKey, NULL, TRUE, 0,
        (BYTE*)((*ppcbEcrData) + ((nBlockProcess - 1) * nBlockLength)),
        &amp;dwDataLength, dwBufferLength))
    {
        throw (""Cannot encrypt data!!"");
    }

    rnEcrSize = nResultSize;
}
</code></pre>

<p>the decryption:</p>

<pre><code>void CWinRSA::FinishDecrypt(const char* pcbRawData, const size_t nDataSize, char** ppcbDecData, size_t&amp; rnDecSize) const
{
    if (m_hProvider == NULL)
    {
        throw (""Cannot decrypt data with wrong provider!!"");
    }

    if (m_hKey == NULL)
    {
        throw (""Cannot decrypt data with a wrong key!!"");
    }

    size_t nBlockLength = GetBlockLength();

    if ((nDataSize % nBlockLength) != 0)
    {
        throw (""Cannot decrypt data!! Probably data is corrupted!!"");
    }

    size_t nPaddingSize = nBlockLength - 11;
    size_t nBlockProcess = nDataSize / nBlockLength;

    size_t nResultSize = nBlockProcess * nPaddingSize;

    (*ppcbDecData) = new char[nResultSize];

    DWORD dwDataLength;

    char* pcbComputeResult = new char[nBlockLength];

    for (int iBlock = 0; iBlock &lt; nBlockProcess - 1; iBlock++)
    {
        memcpy(pcbComputeResult, pcbRawData + (iBlock * nBlockLength), nBlockLength);

        if (!CryptDecrypt(m_hKey, NULL, FALSE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
        {
            throw (""Cannot decrypt data!!"");
        }

        memcpy((*ppcbDecData) + (iBlock * nPaddingSize), pcbComputeResult, nPaddingSize);
    }

    memcpy(pcbComputeResult, pcbRawData + ((nBlockProcess - 1) * nBlockLength), nBlockLength);

    if (!CryptDecrypt(m_hKey, NULL, TRUE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
    {
        DWORD dwError = GetLastError();

        throw (""Cannot decrypt data!!"");
    }

    memcpy((*ppcbDecData) + ((nBlockProcess - 1) * nPaddingSize), pcbComputeResult, nPaddingSize);

    rnDecSize = ((nBlockProcess - 1) * nPaddingSize) + dwDataLength;

    delete[] pcbComputeResult;
    pcbComputeResult = NULL;
}
</code></pre>
","<p>I have found an answer. I must initialize dwDataLength with block length in bytes before all decryption calls.</p>

<pre><code>dwDataLength = nBlockLength;

if (!CryptDecrypt(m_hKey, NULL, TRUE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
{
     DWORD dwError = GetLastError();

     throw (""Cannot decrypt data!!"");
}
</code></pre>

<p>Entire decryption method </p>

<pre><code>void CWinRSA::FinishDecrypt(const char* pcbRawData, const size_t nDataSize, char** ppcbDecData, size_t&amp; rnDecSize) const
{
    if (m_hProvider == NULL)
    {
        throw (""Cannot decrypt data with wrong provider!!"");
    }

    if (m_hKey == NULL)
    {
        throw (""Cannot decrypt data with a wrong key!!"");
    }

    size_t nBlockLength = GetBlockLength();

    if ((nDataSize % nBlockLength) != 0)
    {
        throw (""Cannot decrypt data!! Probably data is corrupted!!"");
    }

    size_t nPaddingSize = nBlockLength - 11;
    size_t nBlockProcess = nDataSize / nBlockLength;

    size_t nResultSize = nBlockProcess * nPaddingSize;

    (*ppcbDecData) = new char[nResultSize];

    DWORD dwDataLength;

    char* pcbComputeResult = new char[nBlockLength];

    for (int iBlock = 0; iBlock &lt; nBlockProcess - 1; iBlock++)
    {
        memcpy(pcbComputeResult, pcbRawData + (iBlock * nBlockLength), nBlockLength);

        dwDataLength = nBlockLength;

        if (!CryptDecrypt(m_hKey, NULL, FALSE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
        {
            throw (""Cannot decrypt data!!"");
        }

        memcpy((*ppcbDecData) + (iBlock * nPaddingSize), pcbComputeResult, nPaddingSize);
    }

    memcpy(pcbComputeResult, pcbRawData + ((nBlockProcess - 1) * nBlockLength), nBlockLength);

    dwDataLength = nBlockLength;

    if (!CryptDecrypt(m_hKey, NULL, TRUE, 0, (BYTE*)pcbComputeResult, &amp;dwDataLength))
    {
        throw (""Cannot decrypt data!!"");
    }

    memcpy((*ppcbDecData) + ((nBlockProcess - 1) * nPaddingSize), pcbComputeResult, nPaddingSize);

    rnDecSize = ((nBlockProcess - 1) * nPaddingSize) + dwDataLength;

    delete[] pcbComputeResult;
    pcbComputeResult = NULL;
}
</code></pre>
","719","<c++><encryption><cryptoapi>","1","0","2","2019-09-26 14:33:37","32937065","0","2","5348281","","2019-09-26 14:33:37","2015-10-04 12:22:44",""
"39079756","System.Security.Cryptography.Csp on Ubuntu 16.04","<p>I have ASP.Net Core 1.0.0 app using cryptography. I need to decrypt keys using <code>RSACryptoServiceProvider</code>. Visual Studio suggested adding <code>System.Security.Cryptography.Csp</code> version 4.0.0 to my dependencies. I accept, and on Windows it all works just fine. But when I deployed it on Ubuntu 16.04 <code>RSACryptoServiceProvider</code>'s methods started to throw <code>PlatformNotSupportedException</code> exception. Am I using the wrong assembly?
I found <a href=""https://github.com/dotnet/corefx/tree/v1.0.0/src/System.Security.Cryptography.Csp"" rel=""nofollow"">https://github.com/dotnet/corefx/tree/v1.0.0/src/System.Security.Cryptography.Csp</a> and there is 1.0.0 version. Is that what I need? How can I add it to my project?</p>
","<p><code>RSACryptoServiceProvider</code> is based on CryptoAPI, a Windows-specific unmanaged API. Since it's not available on Linux, a <code>PlatformNotSupportedException</code> exception is thrown at runtime.</p>

<p>Instead, consider referencing <code>System.Security.Cryptography.Algorithms</code> and using <code>RSA.Create()</code> to get an implementation compatible with your environment (on Linux, you'll get a <code>RSAOpenSsl</code> instance).</p>
","707","<c#><asp.net-core><cryptoapi><ubuntu-16.04>","3","5","1","2016-08-22 12:46:02","39079963","0","1","","","","2016-08-22 12:37:00",""
"37948766","Convert DER encoded X509 certificate buffer to windows CERT_CONTEXT structure","<p>I have a X509 certificate, which was created using OpenSSL and exported to DER blob using OpenSSL i2d_X509() function.</p>

<p>Is there any way to convert DER certificate blob into Windows <a href=""https://msdn.microsoft.com/en-us/library/aa377189(VS.85).aspx"" rel=""nofollow"">CERT_CONTEXT</a> structure?</p>

<p>I know, that it could be done using temporary file,  CertOpenStore(CERT_STORE_PROV_FILENAME) and CertEnumCertificatesInStore() functions. But could not find any way without using temporary file.</p>
","<p>Got it.
It can be done using <strong>::CertCreateCertificateContext</strong> function:</p>

<pre><code>std::vector&lt;BYTE&gt; certificate;
// ... acquire DER encoded certificate using i2d_X509()
// ...
PCCERT_CONTEXT context = ::CertCreateCertificateContext(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
    certificate.data(), 
    certificate.size());
// ...
// ...
::CertFreeCertificateContext(context);
</code></pre>
","702","<c++><windows><openssl><cryptoapi>","1","1","1","2016-06-23 07:57:48","37985470","0","","","","","2016-06-21 15:35:41",""
"41747380","Build a certificate context from a .pem file containing certificate and private key","<p>I'm developing a C++/Windows TLS client.</p>

<p>I can build a certificate context for the server certificate in this way:</p>

<pre><code>    ReadFile(hFile, cert, 8192, &amp;len, NULL);
    CryptStringToBinary(cert, readLen, CRYPT_STRING_BASE64_ANY, binCert, &amp;binLen, NULL, NULL);
    PCCERT_CONTEXT pContext = CertCreateCertificateContext(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, (BYTE*)binCert, binLen);
</code></pre>

<p>but if I try do to the same with a client certificate (.pem file containing certificate and private key) I got a fail.
I think this is due to the fact that server as only one base64 section</p>

<p>-----BEGIN CERTIFICATE-----
-----END CERTIFICATE-----</p>

<p>while the client has two:</p>

<p>-----BEGIN CERTIFICATE-----
-----END CERTIFICATE-----</p>

<p>-----BEGIN PRIVATE KEY----
-----END PRIVATE KEY----</p>

<p>But that's just my guess.</p>

<p>Can someone provide a code snip that builds a certificate context from this kind of .pem file?</p>

<p>Acceptable code must not parse directly the file, I mean I don't want to parse the file to separate certificate from key.</p>

<p>Thanks!</p>

<p>Let me include an example of pem I would like to use:</p>

<pre><code>Bag Attributes
friendlyName: client
localKeyID: 54 69 6D 65 20 31 34 38 34 38 33 33 35 35 39 31 30 39 
Key Attributes: &lt;No Attributes&gt;
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDMuupRTZX52zM2
1xt/3X3JhPtjtV5k4Ua+t/KFMOa0GERyJfzYFvgaKPUQWmNCkfK+oflG8IeNhoPl
+axvWckGb9Hy78M/BPyj19h96q09KpgRtPzl7QPhQUigFe7a+k6kb+unH+21bv1X
u3btN36Q/hTMHziq+EgYSuuWhDau2NQ2xgCSrJdMOox84BPaI8RqRQhL9Ob3Q5vC
ZS936NABYkBstSIMx+w9gsP6aLh+99okBa30EY9hriP8hPJ3UfIL/0ZcamCxhFOt
p3NZlI5WNz+7Gxt0Z1JtGF86fXIj65qntLDC+J2E8/6imUTA7G0KLDbgngGga2Vm
IYtckCnLAgMBAAECggEAcnJa4rBYkqAy9Qky2jvbQXgRgB+3cPVuMtdpv4MitLKM
MLODsNjGQPl8ZXPh4SjtZhvt2fZEEJ2NxlXYSzcJ5YtE9mWJ5ATJpl3XLCywQ204
LU3bwjzI2ndAPh2EtO0QYWQffAGhRLeS8CRfyyQmoK8ouSMK7qh0xP+8yxuF5h9X
1TW9wLeB3UEI0OtpaBGtOBHq06iX0BLdaszDB3cpaH3v8RCXtrtdaB2oPvMuooKf
gQFVNik7lgahMLBEXnc8BR5/LM/lxABODADU+PUvT0c8xrpi6BmOT8V5qWWsZnZC
LWTnOKSUbHz7HdTVHL1q0qMIELI7sVjL/CA4A7kRgQKBgQDxG6hfx/OYdXQaaFm5
uWexlrVNkOirwuO4Qq46rzzYnn0mSje5btBLo872sF2/5Hfkp+4PqcI+r1qM+hGe
xYl8OH1ZELXAhPVDoix9spunh7Kyaf4cxldHVh0S+aJkKuoIu8bx3UwnDjFu55zp
z8FfI7IvKziIv5cYXyG10zFtkQKBgQDZYA8Z219W9kiDc6rPuEocGATEOQ2pEu1H
1IBwjDolLAEiMQU+TfN2M/DJpsJYIIOws2aXY9bykGEC/NmlmUXp0aUrr7gvcyXQ
bVC/Tb0c//HWs5bZJx0bfM6tuaKU6t9anBSCShLk+Sr84tDX7SdP3Qtax6HQnkZ/
eMj3TSgjmwKBgQDEy4Jey2G0qwmdFFdIFGDivtQ0/3Yp2+Tq3OJA3A+Z76LOwf1B
yYUSeB3RlJqwqdaCN99DwZfeelo6f1IqeamCTslhDRaMkPlvvsr5vfL2hvgAUCst
aWaLv2nztvYpNC3Z+wqjF7G0nw0SLNIStZRsB0LE5U47r8WwCtYFBuBtQQKBgCUK
2YfuejC3h2PfMhxzqy1eanGFx24oa4byD3EedEohVZAeCmazoelisIWshTG/WLGj
4Lerq9VqBR4dOHmfxOozb5IiP6DWXntGJZx0AuYON4f+0pXutGcavZ2dJLd7ztQC
BPyu4sliLJErlas2HpzdbjHqEwkZ76mJS7XY0B5BAoGBAMiH9bMvVneJ9IOJyS0i
rosw53t9GW9m9jIKvkMyFxlyBTyrIyqOCFhnbku7wyAT8LIWqaLEWoUU1aA1Jdki
0xjnhK/3hkN1jVq66a0Oc6sOS9RY0Nobpc9sRJxbRIaunjUV/nmGqrtgQhIoOYhg
KW8xlDPBCuTaJ61PjgpFssKG
-----END PRIVATE KEY-----
Bag Attributes
friendlyName: client
localKeyID: 54 69 6D 65 20 31 34 38 34 38 33 33 35 35 39 31 30 39 
subject=/C=it/ST=mi/L=milan/O=hat/OU=red/CN=clientzilla
issuer=/C=it/ST=mi/L=milan/O=hat/OU=red/CN=clientzilla
-----BEGIN CERTIFICATE-----
MIIDVzCCAj+gAwIBAgIERNkHRjANBgkqhkiG9w0BAQsFADBcMQswCQYDVQQGEwJp
dDELMAkGA1UECBMCbWkxDjAMBgNVBAcTBW1pbGFuMQwwCgYDVQQKEwNoYXQxDDAK
BgNVBAsTA3JlZDEUMBIGA1UEAxMLY2xpZW50emlsbGEwHhcNMTcwMTE4MTczMjQz
WhcNMTcwNDE4MTczMjQzWjBcMQswCQYDVQQGEwJpdDELMAkGA1UECBMCbWkxDjAM
BgNVBAcTBW1pbGFuMQwwCgYDVQQKEwNoYXQxDDAKBgNVBAsTA3JlZDEUMBIGA1UE
AxMLY2xpZW50emlsbGEwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDM
uupRTZX52zM21xt/3X3JhPtjtV5k4Ua+t/KFMOa0GERyJfzYFvgaKPUQWmNCkfK+
oflG8IeNhoPl+axvWckGb9Hy78M/BPyj19h96q09KpgRtPzl7QPhQUigFe7a+k6k
b+unH+21bv1Xu3btN36Q/hTMHziq+EgYSuuWhDau2NQ2xgCSrJdMOox84BPaI8Rq
RQhL9Ob3Q5vCZS936NABYkBstSIMx+w9gsP6aLh+99okBa30EY9hriP8hPJ3UfIL
/0ZcamCxhFOtp3NZlI5WNz+7Gxt0Z1JtGF86fXIj65qntLDC+J2E8/6imUTA7G0K
LDbgngGga2VmIYtckCnLAgMBAAGjITAfMB0GA1UdDgQWBBTOFmnZVt304ZpmU2Ny
eTpalYJLZDANBgkqhkiG9w0BAQsFAAOCAQEAVquQQWQpjz4ISWdMkdHHi5zN0MzB
75PbxUKcGRx9f63sIGYlCEQ0n/GTW9ycgeF0FPxAmTxozU3G+f+cA36TRyXRzqpa
prSjWi2acfOydiI3msPohMbOkllqvmPez3sRbU8UTLL3jQX068qteLLwy0zs8plg
SRCdD87cukOjQ3PNox/88FUTAr+zVMSWfxsJ7miOxYbOFy1CVTWLpha57vP5FmA/
TkXMo3O+GLdWqWHiTDZjR84YWg9xco5NXQCETwz/LajSos2Sl2eqWAkOp7QljXs9
pu8UrmGJTO1S0Ipp5MzkmZpWx2T6E7c9zzdMzKjxjuM9f5ZEXR3tMzovvA==
-----END CERTIFICATE-----
</code></pre>
","","693","<c++><windows><x509><cryptoapi><schannel>","1","","0","2017-01-19 16:52:31","","4","","","","","2017-01-19 16:52:31",""
"17142565","How to generate java equivalent secret key in objective C?","<p>Here is java code</p>

<pre><code>public SecretKey getSymmetricKey(String keyString) {
    SecretKey secretKey = null;
    try {
        byte[] raw = Base64.decode(keyString);
        secretKey = new SecretKeySpec(raw, ""AES"");
        System.out.println(""key ""+secretKey);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return secretKey;
}
</code></pre>

<p>please help me on this how to implement above in objective c or which API i need to refer for this ??</p>
","","688","<iphone><security><cryptoapi><encryption-symmetric>","1","","0","2013-07-02 12:37:47","","0","3","","","","2013-06-17 07:40:50",""
"18093316","MS CryptoAPI giving wrong RC4 Results?","<p>I am working on a product that needs to be able to consume files created with an older product. Some of these files contain content encrypted with RC4 encryption using MS CryptoAPI.  I have thus far been unable to successfully decrypt the content using other crypto libraries.  After some experimentation, it appears that CryptoAPI's RC4 output is ""correct"" (i.e. agrees with other libraries) when the key is ASCII, but is ""wrong"" (differs from other libraries that all agree) when the key is not ASCII (e.g. a hash of a password).</p>

<p>Since all the content I'm interested in consuming was encrypted with a key that was derived from a password via hashing, I'm a bit stuck at the moment.  I've written up a small test to show the issue that includes 3 test cases as you can see below in the code.  Botan (C++) and CryptoJS (JS) always agree on output. MS CryptoAPI, however, only agrees for the ASCII keys.</p>

<p>Before I go to MS with this issue, is anyone aware of something I'm misunderstanding or doing wrong that could cause this issue?</p>

<p>Also, I apologize for my atrocious javascript.</p>

<pre><code>#pragma pack (push, 1)
struct PlainTextKeyBlob
{
    BLOBHEADER _hdr;
    DWORD      _cbKey;
    BYTE       _key[1];
};
#pragma pack (pop)

void TestBotanAndMSCryptoRC4()
{
    struct TestItem
    {
        std::string key;
        std::string plainText;
    };

    TestItem TestItems[] = {
    { ""Secret"",               ""Attack at dawn"" },  // Example taken from Wikipedia RC4 page to verify output.
    { ""!\\\""#$%&amp;'()*+"",       ""Encrypt me"" } ,     // Key with various ASCII symbols.
    { ""\xF4\xE7\xA8\x74\x0D"", ""Encrypt me"" }       // Key is first 5 bytes of SHA1 hash of ""Secret"".
    };
    DWORD NumTestItems = _countof(TestItems);

    for( DWORD i = 0; i &lt; NumTestItems; i++ )
    {
        // Botan Encryption
        Botan::SymmetricKey symmKey((BYTE*)TestItems[i].key.c_str(), TestItems[i].key.size());
        Botan::Pipe pipe(Botan::get_cipher(""ARC4"", symmKey, Botan::ENCRYPTION));
        pipe.process_msg(TestItems[i].plainText);
        SecureByteVector&amp; encryptedBuff = pipe.read_all();

        // MS Crypto API Encryption
        AutoCryptProv CryptProv;
        if( !CryptAcquireContext( CryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        {
            ASSERT(false);
            return;
        }

        DWORD blobKeySize = TestItems[i].key.size();
        DWORD blobSize    = sizeof(PlainTextKeyBlob) + blobKeySize - 1;
        CByteArray keyBlob;
        keyBlob.SetSize(blobSize);

        PlainTextKeyBlob *pKeyBlob = reinterpret_cast&lt;PlainTextKeyBlob*&gt;(keyBlob.GetData());
        pKeyBlob-&gt;_hdr.bType       = PLAINTEXTKEYBLOB;
        pKeyBlob-&gt;_hdr.bVersion    = CUR_BLOB_VERSION;
        pKeyBlob-&gt;_hdr.reserved    = 0;
        pKeyBlob-&gt;_hdr.aiKeyAlg    = CALG_RC4;
        pKeyBlob-&gt;_cbKey           = TestItems[i].key.size();
        memcpy_s(pKeyBlob-&gt;_key, blobKeySize, TestItems[i].key.c_str(), TestItems[i].key.size());

        AutoCryptKey CryptKey;
        if( !CryptImportKey(CryptProv, reinterpret_cast&lt;BYTE*&gt;(pKeyBlob), blobSize, NULL, 0, CryptKey) )
        {
            ASSERT(false);
            return;
        }

        CByteArray dataBytes;
        dataBytes.SetSize(TestItems[i].plainText.size());
        memcpy_s(dataBytes.GetData(), dataBytes.GetSize(), TestItems[i].plainText.c_str(), TestItems[i].plainText.size());

        DWORD buffSize = dataBytes.GetSize();
        if( !CryptEncrypt(CryptKey, 0, TRUE, 0, dataBytes.GetData(), &amp;buffSize, dataBytes.GetSize()) )
        {
            ASSERT(false);
            return;
        }

        ASSERT(encryptedBuff.size() == dataBytes.GetSize());
        ASSERT( 0 == memcmp(encryptedBuff.begin(), dataBytes.GetData(), dataBytes.GetSize()) );
    }
}

&lt;html&gt;
&lt;body&gt;
&lt;script src=""http://crypto-js.googlecode.com/svn/tags/3.1.2/build/rollups/rc4.js""&gt;&lt;/script&gt;
&lt;div id=""output"" /&gt;
&lt;script&gt;
    var key1 = CryptoJS.enc.Hex.parse('536563726574'); // Secret
    var message1 = ""Attack at dawn"";
    var encrypted1 = CryptoJS.RC4.encrypt(message1, key1);

    var key2 = CryptoJS.enc.Hex.parse('215c22232425262728292a2b'); // !\""#$%&amp;'()*+
    var message2 = ""Encrypt me"";
    var encrypted2 = CryptoJS.RC4.encrypt(message2, key2);

    var key3 = CryptoJS.enc.Hex.parse('f4e7a8740d'); // First 5 bytes of hash of ""Secret""
    var message3 = ""Encrypt me"";
    var encrypted3 = CryptoJS.RC4.encrypt(message3, key3);

    var elem = document.getElementById(""output"");
    elem.innerHTML = ""Key1: "" + encrypted1.key + ""&lt;br&gt; ciphertext1: "" + encrypted1.ciphertext + ""&lt;br&gt;&lt;br&gt;"" +
                     ""Key2: "" + encrypted2.key + ""&lt;br&gt; ciphertext2: "" + encrypted2.ciphertext + ""&lt;br&gt;&lt;br&gt;"" +
                     ""Key3: "" + encrypted3.key + ""&lt;br&gt; ciphertext3: "" + encrypted3.ciphertext;
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
","<p>I just wanted to follow up with the answer I found in case this is useful to someone else in the future.</p>

<p>First and foremost, the answer was to RTFM! As it turns out, by default, CryptDeriveKey adds a ""salt"" to 40-bit symmetric keys consisting of all 0's. When I looked at our old CryptoAPI code and saw that we weren't passing any flags into it, I assumed this meant nothing special was going on and I didn't read through the details of all possible flags on MSDN. Furthermore, since MS considers this portion of the key a salt <strong>it is not included when you export the key</strong> so that was also a dead end.</p>

<p>I eventually found my way to <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387695(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa387695(v=vs.85).aspx</a> which explains the salt mechanism for 40-bit keys and the line that caught my eye was that, for compatibility, you should create keys with the CRYPT_NO_SALT flag.  In our case, we already have encrypted content with such keys, so we simply modified our Botan/CryptoJS code to append 11 bytes of 0s to the end of the base 40-bit key.</p>

<p>The details for the various CryptDeriveKey flags can be found here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx</a></p>
","686","<cryptoapi><cryptojs><botan><rc4-cipher>","0","0","1","2013-09-27 16:30:10","19055779","0","","","","","2013-08-07 01:45:11",""
"17790442","How can I use Windows Crypto APIs to validate a certificate during a TLS handshake using OpenSSL?","<p>During a SSL/TLS handshake, I would like to have my C application search the Windows certificate store for a trusted certificate that will validate the server's certificate. Currently, the application requires a file containing the root certificate and I would like to allow it to simply use any certificate in the Windows certificate store without having to specify which one to use first, similar to the way browsers work.</p>

<p>I am using OpenSSL but I can't figure out how to co-ordinate the OpenSSL calls with the Windows Crypto API calls to validate the certificate.</p>
","","684","<c><windows><ssl><openssl><cryptoapi>","2","","0","2013-07-22 14:41:28","","1","1","","","","2013-07-22 14:41:28",""
"3394976","Getting exception when calling CryptGetKeyParam","<p>I'm trying to use the CryptoAPI (CAPI) to perform a Diffie Hellman Key Exchange. I'm using the MSDN documentation.</p>

<pre><code>        // Step 0) Acquire context
        if (!CAPI.CryptAcquireContext(ref this._cryptographicProvider, null, null, CAPI.PROV_DSS_DH, CAPI.CRYPT_VERIFYCONTEXT))
            HandleWin32Error(""Unable to acquire cryptographic context"");

        // Setp 1) Generate private key
        if (!CAPI.CryptGenKey(this._cryptographicProvider, CAPI.CALG_DH_EPHEM, DHKEYSIZE &lt;&lt; 16 | CAPI.CRYPT_EXPORTABLE | CAPI.CRYPT_PREGEN, ref this._privateKeyPointer))
            HandleWin32Error(""Unable to generate private cryptographic key"");

        uint gSize = 0;
        CAPI.CryptGetKeyParam(this._privateKeyPointer, CAPI.KP_G, null, ref gSize, (uint)0);

        byte[] g = new byte[gSize];
        var res = CAPI.CryptGetKeyParam(this._privateKeyPointer, CAPI.KP_G, g, ref gSize, (uint)0);
</code></pre>

<p>The first call CryptGetKeyParam works perfectly, i.e. it successfully returns the size of g, as 64.</p>

<p>Then the code fails on the last line, either by returning nothing to the g buffer (as is the case in that example) with res = true, or with an AccessViolationException when I use the following call:</p>

<pre><code>var res = CAPI.CryptGetKeyParam(this._privateKeyPointer, CAPI.KP_G, ref g, ref gSize, (uint)0);
</code></pre>

<p>Yes, I've overloaded the P\Invoke methods:</p>

<pre><code>    [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern bool CryptGetKeyParam(IntPtr hKey, uint dwParam, ref byte[] pbData, ref uint pdwDataLen, uint dwFlags);

    [DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern bool CryptGetKeyParam(IntPtr hKey, uint dwParam, byte[] pbData, ref uint pdwDataLen, uint dwFlags);
</code></pre>

<p>Any thoughts/ideas on this?</p>

<p>*Interestingly, I have managed to get a complete Diffie Hellman Key Exchange to work, i.e. successfully agreeing the same secret (s1) between two parties. But this is with pre-defined P and G parameters. I'm re-working the code because something didn't seem to be correct as the derived secret was the same for every key exchange, implying that X was consistent. (i.e. Bob and Alice agreed on s1 every single time!?) - Here I, again, had an issue with CryptGetKeyParam as I was unable to determine the size of the session key when using KP_KEYLEN?!
*</p>
","<p>Ah ha!</p>

<p>It was a combination of the context flags and the overloaded method... Works now!</p>

<p>When P &amp; G are NOT predefined, then don't set the CRYPT_PREGEN flag... And only one of the two overloaded methods was needed (this one):</p>

<pre><code>[DllImport(""advapi32.dll"", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern bool CryptGetKeyParam(IntPtr hKey, uint dwParam, byte[] pbData, ref uint pdwDataLen, uint dwFlags);
</code></pre>
","668","<c#><pinvoke><cryptoapi>","0","1","1","2010-08-03 09:36:56","","0","","","","","2010-08-03 08:53:32",""
"41726085","X509 Certificate verification with Windows Crypto API","<p>I need to write a C program for Windows that receives a certificate from network (in PEM format) and validates its signature with a certificate chain file (which is already presented in the application's folder).</p>

<p>Writing such an application is pretty easy and strait forward with openssl library but seems a little complicated with the Windows Crypto API.</p>

<p>Here is what I've tried so far:</p>

<p>First I thought I can create a HCERTSTORE using the certificate-chain file:</p>

<pre><code>HCERTSTORE hFileStoreHandle = CertOpenStore( 
CERT_STORE_PROV_FILENAME,
PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, NULL,
(CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG),
L""certificate-chain.pem.cert"");
</code></pre>

<p>Then I figured I can iterate through the store and get PCCERT_CONTEXT struct of certificates:</p>

<pre><code>PCCERT_CONTEXT CAfileContext = NULL;
while(CAfileContext = CertEnumCertificatesInStore(
 hCertStore,
 CAfileContext)) {

    //start verification here
}
</code></pre>

<p>I don't know if I am on the right track or not but I'm facing two major problems here.</p>

<p>First is I don't know how to get the received certificate from buffer and convert it to a proper struct in order to validate its signature with certificate-chain file.</p>

<p>Second is I don't know how to verify a certificate signature using the CA chain file.</p>

<p>I'll appreciate all the suggestions and helps. </p>
","<p>Here is the sample code for you, hopefully it can help you.</p>

<pre><code>HRESULT hr = E_FAIL;
DWORD dwError = 0;
PCCERT_CONTEXT  pCert = NULL;

HCERTSTORE hCertStore = CertOpenStore(
    CERT_STORE_PROV_FILENAME,                   
    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
    NULL,                                   
    (CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG),             
    L""certificate-chain.pem.cert"");

do
{
    if ((pCert = CertEnumCertificatesInStore(hCertStore, pCert)) == NULL)
        break;

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcSubject = CertDuplicateCertificateContext(pCert);
    for (; NULL != pcSubject;)
    {
        DWORD dwFlags = 0;
        BOOL bret = TRUE;
        hr = S_OK;

        pcIssuer = CertGetIssuerCertificateFromStore(
            hCertStore, pcSubject, NULL, &amp;dwFlags);

        if (pcIssuer == NULL)
        {
            dwError = GetLastError();
            if (CRYPT_E_SELF_SIGNED != dwError)
            {
                hr = E_FAIL;
                break;
            }
            else
            {
                if ((bret = CertCompareCertificateName(
                    X509_ASN_ENCODING, 
                    &amp;pcSubject-&gt;pCertInfo-&gt;Subject, 
                    &amp;pcSubject-&gt;pCertInfo-&gt;Issuer)) == FALSE)
                {
                    hr = E_FAIL;
                    break;
                }
            }
        }

        HCRYPTPROV hprov = NULL;
        bret = CryptAcquireContext(
                    &amp;hprov, nullptr, nullptr, PROV_RSA_FULL, 
                    CRYPT_SILENT | CRYPT_VERIFYCONTEXT | CRYPT_NEWKEYSET);

        if (FALSE == bret)
        {
            dwError = GetLastError();
            if (NTE_EXISTS == dwError)
                bret = CryptAcquireContext(
                        &amp;hprov, nullptr, nullptr, PROV_RSA_FULL,
                        CRYPT_SILENT | CRYPT_VERIFYCONTEXT);
            if (FALSE == bret)
            {
                hr = E_FAIL;
                break;
            }
        }

        if ((bret = CryptVerifyCertificateSignatureEx(
            hprov, X509_ASN_ENCODING,
            CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
            (void*)pcSubject,
            CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT, 
            (void*)(pcIssuer == nullptr ? pcSubject : pcIssuer),
            0, nullptr)) == FALSE)
        {
            hr = E_FAIL;
            break;
        }

        if (nullptr == pcIssuer)
        {
            CERT_PUBLIC_KEY_INFO msCert;
            msCert.Algorithm = 
                pcSubject-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.Algorithm;
            msCert.PublicKey.cbData = 
                sizeof(PETRUSTED_ROOTCERT_PUBKEY);
            msCert.PublicKey.pbData = 
                const_cast&lt;LPBYTE&gt;(PETRUSTED_ROOTCERT_PUBKEY);
            msCert.PublicKey.cUnusedBits = 
                pcSubject-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.cUnusedBits;

            if (FALSE == CertComparePublicKeyInfo(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                &amp;pcSubject-&gt;pCertInfo-&gt;SubjectPublicKeyInfo, &amp;msCert))
            {
                hr = E_FAIL;
                break;
            }
        }

        bret = CryptReleaseContext(hprov, 0);
        hprov = NULL;

        CertFreeCertificateContext(pcSubject);
        pcSubject = pcIssuer;
        pcIssuer = NULL;
    }

    if (pcIssuer != NULL)
        CertFreeCertificateContext(pcIssuer);

    if (pcSubject != NULL)
        CertFreeCertificateContext(pcSubject);

    if (FAILED(hr))
    {
        CertFreeCertificateContext(pCert);
        break;
    }

} while (pCert != NULL);

CertCloseStore(hCertStore, 0);

if (FAILED(hr))
    wprintf(L""Failed to verify X509 certification.\n"");
else
    wprintf(L""Successfully verify X509 certification.\n"");
</code></pre>
","664","<c><x509certificate><cryptoapi>","0","1","1","2018-11-23 15:21:59","","5","","","","","2017-01-18 17:46:09",""
"32992587","Digital signature using Microsoft CryptoAPI from windows service?","<p>Is it possible to sign digitally from windows service?
The same code, that works from console application, does not work from Windows service</p>

<p>I got folllowing error when I attempt to digitally sign:</p>

<blockquote>
  <p>System.InvalidOperationException: The current session is not
  interactive.    at
  System.Security.Cryptography.CAPI.CryptUIDlgSelectCertificateW(CRYPTUI_SELECTCERTIFICATE_STRUCTW
  csc)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromStore(SafeCertStoreHandle
  safeSourceStoreHandle, String title, String message, X509SelectionFlag
  selectionFlags, IntPtr hwndParent)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromCollectionHelper(X509Certificate2Collection
  certificates, String title, String message, X509SelectionFlag
  selectionFlag, IntPtr hwndParent)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromCollection(X509Certificate2Collection
  certificates, String title, String message, X509SelectionFlag
  selectionFlag)</p>
</blockquote>

<p>Seems like Windows Service cannot invoke GUI that offers list of certificates to choose or window for PIN?
Service runs as LocalSystem which is Admin. I also added app.manifest with following settings:</p>

<pre><code>&lt;requestedExecutionLevel level=""requireAdministrator"" uiAccess=""false"" /&gt;
</code></pre>

<p>Is it possible to use win service for this functionality?</p>
","<p>The method you are using pops up a dialog to allow you to view and select certificates to use. A service cannot usually have a user interface (since they run outside of an interactive user session). I believe you can have interactive services but I wouldn't recommend it in this case. Use another way of selecting the certificate, perhaps based on the thumbprint of the required certificate e.g. <a href=""https://stackoverflow.com/questions/6304773/how-to-get-x509certificate-from-certificate-store-and-generate-xml-signature-dat"">How to get X509Certificate from certificate store and generate xml signature data?</a></p>
","663","<.net><windows-services><digital-signature><smartcard><cryptoapi>","1","0","2","2015-10-09 11:35:08","","0","","75825","","2015-10-09 11:35:08","2015-10-07 12:45:20",""
"32992587","Digital signature using Microsoft CryptoAPI from windows service?","<p>Is it possible to sign digitally from windows service?
The same code, that works from console application, does not work from Windows service</p>

<p>I got folllowing error when I attempt to digitally sign:</p>

<blockquote>
  <p>System.InvalidOperationException: The current session is not
  interactive.    at
  System.Security.Cryptography.CAPI.CryptUIDlgSelectCertificateW(CRYPTUI_SELECTCERTIFICATE_STRUCTW
  csc)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromStore(SafeCertStoreHandle
  safeSourceStoreHandle, String title, String message, X509SelectionFlag
  selectionFlags, IntPtr hwndParent)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromCollectionHelper(X509Certificate2Collection
  certificates, String title, String message, X509SelectionFlag
  selectionFlag, IntPtr hwndParent)    at
  System.Security.Cryptography.X509Certificates.X509Certificate2UI.SelectFromCollection(X509Certificate2Collection
  certificates, String title, String message, X509SelectionFlag
  selectionFlag)</p>
</blockquote>

<p>Seems like Windows Service cannot invoke GUI that offers list of certificates to choose or window for PIN?
Service runs as LocalSystem which is Admin. I also added app.manifest with following settings:</p>

<pre><code>&lt;requestedExecutionLevel level=""requireAdministrator"" uiAccess=""false"" /&gt;
</code></pre>

<p>Is it possible to use win service for this functionality?</p>
","<p>You might want to enable Interactive Services Detection (service name is UI0Detect). </p>

<p><a href=""https://i.stack.imgur.com/iAuV8.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iAuV8.jpg"" alt=""Interactive Services Detection""></a></p>

<p>This service will enable you to open dialog windows in special session 0. It works since Vista. A window will pop up to inform you (currently logged on user) that a service needs desktop interaction (i.e. input PIN for access to private key).</p>

<p>You can read more information about session 0 and interactive services detection <a href=""http://blogs.msdn.com/b/patricka/archive/2010/04/27/what-is-interactive-services-detection-and-why-is-it-blinking-at-me.aspx"" rel=""nofollow noreferrer"">here</a></p>
","663","<.net><windows-services><digital-signature><smartcard><cryptoapi>","1","1","2","2015-10-09 11:35:08","","0","","75825","","2015-10-09 11:35:08","2015-10-07 12:45:20",""
"37945586","VB code using advapi32.dll cryptverifysignature works on Vista SP2 not on Windows 10 64-bit","<p>I have been trying to troubleshoot why an element of an application written and compiled in VB6 on a Vista SP2 machine works perfectly on that machine but not on a 64-bit Windows 10 machine. To improve debugging capabilities I replicated the problem coding in Excel VBA. Works on the Vista machine but not on the Windows 10 machine.</p>

<p>The CryptoAPI calls are all declared thusly:</p>

<pre><code>Private Declare Function CryptVerifySignature _
Lib ""advapi32.dll"" _
    Alias ""CryptVerifySignatureA"" ( _
        ByVal hHash As Long, _
        pbSignature As Byte, _
        ByVal dwSigLen As Long, _
        ByVal hPubKey As Long, _
        ByVal sDescription As String, _
        ByVal dwFlags As Long _
            ) As Long
</code></pre>

<p>The part that is failing on the Windows 10 machine is highlighted by train tracks above and below in the following:</p>

<pre><code>Private Function SignValidate(ByRef abData() As Byte, _
                        ByRef abSigned() As Byte, _
                        Optional bSigned As Boolean = True) As Long
Dim hHash As Long
Dim lngReturnValue As Long
Dim lngSigLen As Long
Dim abText() As Byte
Dim strTxt As String
Dim lngW As Long
Dim lngX As Long
Dim lngY As Long

Dim abHashVal() As Byte

SignValidate = -1
ReDim abText(UBound(abData))
abText = abData

'Create a hash object to sign/validate
lngReturnValue = CryptCreateHash(hCryptProv, CALG_SHA, 0, 0, hHash)
If lngReturnValue = 0 Then
    'Set_locale regionalSymbol
    Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not create a Hash Object (CryptCreateHash API)""
End If
'Hash the data
lngW = UBound(abText) + 1
lngReturnValue = CryptHashData(hHash, abText(0), lngW, 0)
If lngReturnValue = 0 Then
    'Set_locale regionalSymbol
    Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not calculate a Hash Value (CryptHashData API)""
End If

If bSigned Then
    'release old key pair handle
    If hKeyPair &lt;&gt; 0 Then CryptDestroyKey hKeyPair
    'get a handle to the signature key pair
    lngReturnValue = CryptGetUserKey(hCryptProv, AT_SIGNATURE, hKeyPair)
    If lngReturnValue = 0 Then
        'Set_locale regionalSymbol
        Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not obtain key pair""
    End If
    'Determine the size of the signature
    lngReturnValue = CryptSignHash(hHash, AT_SIGNATURE, 0, 0, vbNull, lngSigLength)
    If lngSigLength &gt; 0 Then ReDim abSig(lngSigLength - 1)
    'Sign the hash object
    lngReturnValue = CryptSignHash(hHash, AT_SIGNATURE, 0, 0, abSig(0), lngSigLength)
    If lngReturnValue = 0 Then
        'Set_locale regionalSymbol
        Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not sign the hash""
    End If
    ' the signature is now available
    ' size returned array to signature length
    ReDim abSigned(UBound(abSig))
    ' return the signature to the calling procedure
    abSigned = abSig
    SignValidate = 0
Else
    lngSigLength = UBound(abSigned) + 1
    ReDim abSig(UBound(abSigned))
    abSig = abSigned ' load the Signature array

'========================================================
    'this is the line where the actual validation is done
    lngReturnValue = CryptVerifySignature(hHash, abSig(0), lngSigLength, hKeyPair, 0, 0)
'========================================================
    If lngReturnValue = 0 Then 'some error occurred
        SignValidate = Err.LastDllError
    Else
        SignValidate = 0
    End If
End If
End Function
</code></pre>

<p>The Windows 10 machine fails on the highlighted call to CryptVerifySignature and returns an Err.LastDllError equal to NTE_BAD_SIGNATURE. The Vista machine validates the signature fine.</p>

<p>I have spent days researching what might be happening here. All to no avail. Any pointers gratefully received</p>
","<blockquote>
  <p>EDIT - I can't see anything wrong with your declare or call</p>
</blockquote>

<p>The only alternative I've seen is to change byte Pointer to be declared as <code>ByVal pSignature Long</code> and then calling it using <code>varPtr(abSig(0)</code></p>

<p>But your code looks fine - I'm puzzled</p>

<blockquote>
  <hr>
</blockquote>

<p>Your declare doesn't match Microsoft API declaration. Not sure if that's by design because Signature is a byte pointer </p>

<p>According to docs </p>

<pre><code>LPBYTE, BYTE  will be : *   ByRef Byte
</code></pre>

<p>Change this (by default arguments are passed ByVal)</p>

<pre><code>pbSignature As Byte
</code></pre>

<p>To this</p>

<pre><code>ByRef pbSignature As Byte
</code></pre>
","657","<vba><api><encryption><vb6><cryptoapi>","2","0","2","2017-05-07 20:29:44","43836363","14","1","","","","2016-06-21 13:17:43",""
"37945586","VB code using advapi32.dll cryptverifysignature works on Vista SP2 not on Windows 10 64-bit","<p>I have been trying to troubleshoot why an element of an application written and compiled in VB6 on a Vista SP2 machine works perfectly on that machine but not on a 64-bit Windows 10 machine. To improve debugging capabilities I replicated the problem coding in Excel VBA. Works on the Vista machine but not on the Windows 10 machine.</p>

<p>The CryptoAPI calls are all declared thusly:</p>

<pre><code>Private Declare Function CryptVerifySignature _
Lib ""advapi32.dll"" _
    Alias ""CryptVerifySignatureA"" ( _
        ByVal hHash As Long, _
        pbSignature As Byte, _
        ByVal dwSigLen As Long, _
        ByVal hPubKey As Long, _
        ByVal sDescription As String, _
        ByVal dwFlags As Long _
            ) As Long
</code></pre>

<p>The part that is failing on the Windows 10 machine is highlighted by train tracks above and below in the following:</p>

<pre><code>Private Function SignValidate(ByRef abData() As Byte, _
                        ByRef abSigned() As Byte, _
                        Optional bSigned As Boolean = True) As Long
Dim hHash As Long
Dim lngReturnValue As Long
Dim lngSigLen As Long
Dim abText() As Byte
Dim strTxt As String
Dim lngW As Long
Dim lngX As Long
Dim lngY As Long

Dim abHashVal() As Byte

SignValidate = -1
ReDim abText(UBound(abData))
abText = abData

'Create a hash object to sign/validate
lngReturnValue = CryptCreateHash(hCryptProv, CALG_SHA, 0, 0, hHash)
If lngReturnValue = 0 Then
    'Set_locale regionalSymbol
    Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not create a Hash Object (CryptCreateHash API)""
End If
'Hash the data
lngW = UBound(abText) + 1
lngReturnValue = CryptHashData(hHash, abText(0), lngW, 0)
If lngReturnValue = 0 Then
    'Set_locale regionalSymbol
    Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not calculate a Hash Value (CryptHashData API)""
End If

If bSigned Then
    'release old key pair handle
    If hKeyPair &lt;&gt; 0 Then CryptDestroyKey hKeyPair
    'get a handle to the signature key pair
    lngReturnValue = CryptGetUserKey(hCryptProv, AT_SIGNATURE, hKeyPair)
    If lngReturnValue = 0 Then
        'Set_locale regionalSymbol
        Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not obtain key pair""
    End If
    'Determine the size of the signature
    lngReturnValue = CryptSignHash(hHash, AT_SIGNATURE, 0, 0, vbNull, lngSigLength)
    If lngSigLength &gt; 0 Then ReDim abSig(lngSigLength - 1)
    'Sign the hash object
    lngReturnValue = CryptSignHash(hHash, AT_SIGNATURE, 0, 0, abSig(0), lngSigLength)
    If lngReturnValue = 0 Then
        'Set_locale regionalSymbol
        Err.Raise Err.LastDllError, , ""DLL error code shown above. Could not sign the hash""
    End If
    ' the signature is now available
    ' size returned array to signature length
    ReDim abSigned(UBound(abSig))
    ' return the signature to the calling procedure
    abSigned = abSig
    SignValidate = 0
Else
    lngSigLength = UBound(abSigned) + 1
    ReDim abSig(UBound(abSigned))
    abSig = abSigned ' load the Signature array

'========================================================
    'this is the line where the actual validation is done
    lngReturnValue = CryptVerifySignature(hHash, abSig(0), lngSigLength, hKeyPair, 0, 0)
'========================================================
    If lngReturnValue = 0 Then 'some error occurred
        SignValidate = Err.LastDllError
    Else
        SignValidate = 0
    End If
End If
End Function
</code></pre>

<p>The Windows 10 machine fails on the highlighted call to CryptVerifySignature and returns an Err.LastDllError equal to NTE_BAD_SIGNATURE. The Vista machine validates the signature fine.</p>

<p>I have spent days researching what might be happening here. All to no avail. Any pointers gratefully received</p>
","<p>After much frustration and fruitless research I've eventually discovered what the problem was. Along the way I discovered that the problem originated in another part of the code altogether. I also discovered that the problem manifested itself on Windows 10 32 bit as well - so not a 64 bit problem.</p>

<p>An incorrectly populated dwflags argument to an earlier call to CryptImportKey didn't seem to prevent the call to CryptVerifySignature succeeding under Vista 32 bit, even though the call to CryptImportKey, on investigation, had failed. Once the dwflags argument of CryptImportKey was corrected, to CRYPT_EXPORTABLE Or CRYPT_NO_SALT, it succeeded and the subsequent call to CryptVerifySignature succeeded under all alternative operating system / bit number combinations I was able to test.</p>

<p>Apologies and thanks in equal measure to all those who have sought to help in this matter. Until the next time.</p>
","657","<vba><api><encryption><vb6><cryptoapi>","2","1","2","2017-05-07 20:29:44","43836363","14","1","","","","2016-06-21 13:17:43",""
"11529744","printf: Displaying an SHA1 hash in hexadecimal","<p>I have been following the msdn example that shows how to hash data using the Windows CryptoAPI. The example can be found here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382380%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa382380%28v=vs.85%29.aspx</a></p>

<p>I have modified the code to use the SHA1 algorithm.</p>

<p>I don't understand how the code that displays the hash (shown below) in hexadecmial works, more specifically I don't understand what the >> 4 operator and the &amp; 0xf operator do.</p>

<pre><code>if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &amp;cbHash, 0)){
    printf(""MD5 hash of file %s is: "", filename);
    for (DWORD i = 0; i &lt; cbHash; i++)
    {
        printf(""%c%c"", rgbDigits[rgbHash[i] &gt;&gt; 4],
           rgbDigits[rgbHash[i] &amp; 0xf]);
    }
    printf(""\n"");
}
</code></pre>

<p>I would be grateful if someone could explain this for me, thanks in advance :)</p>
","<p><code>x &gt;&gt; 4</code> shifts <code>x</code> right four bits. <code>x &amp; 0xf</code> does a bitwise <code>and</code> between <code>x</code> and <code>0xf</code>. 0xf has its four least significant bits set, and all the other bits clear.</p>

<p>Assuming <code>rgbHash</code> is an array of unsigned char, this means the first expression retains only the four most significant bits and the second expression the four least significant bits of the (presumably) 8-bit input.</p>

<p>Four bits is exactly what will fit in one hexadecimal digit, so each of those is used to look up a hexadecimal digit in an array which presumably looks something like this:</p>

<pre><code>char rgbDigits[] = ""0123456789abcdef""; // or possibly upper-case letters
</code></pre>
","650","<c++><windows><sha1><cryptoapi>","1","2","2","2012-07-17 20:01:19","11529852","1","","","","","2012-07-17 19:42:50",""
"11529744","printf: Displaying an SHA1 hash in hexadecimal","<p>I have been following the msdn example that shows how to hash data using the Windows CryptoAPI. The example can be found here: <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382380%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa382380%28v=vs.85%29.aspx</a></p>

<p>I have modified the code to use the SHA1 algorithm.</p>

<p>I don't understand how the code that displays the hash (shown below) in hexadecmial works, more specifically I don't understand what the >> 4 operator and the &amp; 0xf operator do.</p>

<pre><code>if (CryptGetHashParam(hHash, HP_HASHVAL, rgbHash, &amp;cbHash, 0)){
    printf(""MD5 hash of file %s is: "", filename);
    for (DWORD i = 0; i &lt; cbHash; i++)
    {
        printf(""%c%c"", rgbDigits[rgbHash[i] &gt;&gt; 4],
           rgbDigits[rgbHash[i] &amp; 0xf]);
    }
    printf(""\n"");
}
</code></pre>

<p>I would be grateful if someone could explain this for me, thanks in advance :)</p>
","<p>this code uses simple bit 'filtering' techniques</p>

<ul>
<li>"">> 4"" means shift right by 4 places, which in turn means 'divide by 16' </li>
<li>""&amp; 0xf"" equals to bit AND operation which means 'take first 4 bits'  </li>
</ul>

<p>Both these values are passed to rgbDigits which proly produced output in valid range - human readable</p>
","650","<c++><windows><sha1><cryptoapi>","1","1","2","2012-07-17 20:01:19","11529852","1","","","","","2012-07-17 19:42:50",""
"37709434","Can I enable FIPS momentarily in a .net application?","<p>Openssl allows going in and out of FIPS mode.  Does the windows crypto api and .net wrapper classes alow a similar function?</p>

<p>I want to enable FIPS mode, sign a document, and then return to normal mode.</p>
","<p>Unfortunately not; at least, not without some architectural changes.</p>

<p>You can enable/disable FIPS mode by setting a registry value:</p>

<pre><code>HKLM\System\CurrentControlSet\Control\Lsa\FIPSAlgorithmPolicy\Enabled (DWORD)
</code></pre>

<p>0 is disabled, 1 is enabled</p>

<p>However, there are some limitations: once you load the cryptographic providers into your process, it ""remembers"" the state of that FIPS mode for the rest of the process' lifetime. So code like this would work:</p>

<p>(NOTE: both cases assume that FIPS mode is off at the beginning)</p>

<pre><code>static void Main(string[] args)
{
    using (RegistryKey fipsAlgorithmPolicy = Registry.LocalMachine.OpenSubKey(@""System\CurrentControlSet\Control\Lsa\FIPSAlgorithmPolicy"", true))
    {
        fipsAlgorithmPolicy.SetValue(""Enabled"", 1, RegistryValueKind.DWord);
    }
    SHA1 sha = new SHA1Managed(); // throws, which is what you want
}
</code></pre>

<p>But code like this would not:</p>

<pre><code>static void Main(string[] args)
{
    SHA1 sha = new SHA1Managed(); // Does not throw, which is expected
    using (RegistryKey fipsAlgorithmPolicy = Registry.LocalMachine.OpenSubKey(@""System\CurrentControlSet\Control\Lsa\FIPSAlgorithmPolicy"", true))
    {
        fipsAlgorithmPolicy.SetValue(""Enabled"", 1, RegistryValueKind.DWord);
    }
    sha = new SHA1Managed(); // Also does not throw, which is a shame
}
</code></pre>

<p>In order for your code to reflect the new state, you'd have to restart your process. With that being said, what you <em>could</em> do is sequester the code that performs the cryptographic routines into a ""helper"" process that your application spawns after setting FIPS mode. It'd be a bit of a pain to implement, but it would allow you to toggle FIPS mode and have your code behave as expected.</p>
","648","<c#><.net><cryptoapi><fips>","2","3","2","2018-10-17 04:52:39","37711887","1","","","","","2016-06-08 17:46:20",""
"37709434","Can I enable FIPS momentarily in a .net application?","<p>Openssl allows going in and out of FIPS mode.  Does the windows crypto api and .net wrapper classes alow a similar function?</p>

<p>I want to enable FIPS mode, sign a document, and then return to normal mode.</p>
","<p>You can on a per program basis - setting <a href=""https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/runtime/enforcefipspolicy-element"" rel=""nofollow noreferrer"">enforceFIPSPolicy</a> to <code>true</code> in a .NET Runtime Settings Schema will specify that you want to enforce a computer configuration requirement that cryptographic algorithms must comply with the Federal Information Processing Standards (FIPS).</p>
","648","<c#><.net><cryptoapi><fips>","2","0","2","2018-10-17 04:52:39","37711887","1","","","","","2016-06-08 17:46:20",""
"41364728","How to determine hash and encryption algorithm of S/MIME message with Win32 CryptoAPI?","<p>CryptVerifyMessageSignature and CryptDecryptMessage functions allow me to check if an S/MIME signature is valid (or decrypt encrypted data in CryptDecryptMessage case) and also return the certificate which was used for signing (or encryption). However, there is no information about which algorithms were actually used for signing and encryption. How can I get this info?</p>

<p>I'm using C# but any C/C++ sample or hint is also welcome.</p>

<p>Edit: signature verification code snippet (the entire code is very big to include it here) added upon request</p>

<pre><code>IntPtr pbDetachedSignBlob = IntPtr.Zero;
uint cbDetachedSignBlob = (uint)signatureBytes.Length;
IntPtr pbContent = IntPtr.Zero;
uint cbContent = (uint)data.Length;

pbDetachedSignBlob = Marshal.AllocHGlobal((int)cbDetachedSignBlob);
Marshal.Copy(signatureBytes, 0, pbDetachedSignBlob, (int)cbDetachedSignBlob);
pbContent = Marshal.AllocHGlobal((int)cbContent);
Marshal.Copy(data, 0, pbContent, (int)cbContent);
IntPtr[] messageArray = { pbContent };
uint[] messageSizeArray = { cbContent };

GCHandle messageArrayHandle = GCHandle.Alloc(messageArray, GCHandleType.Pinned);
IntPtr messageArrayPtr = (IntPtr)messageArrayHandle.AddrOfPinnedObject();

int ret = CryptoApiFuncs.MessageFuncs.CryptVerifyDetachedMessageSignature(pVerifyPara, 0, pbDetachedSignBlob, cbDetachedSignBlob, 1, messageArrayPtr, ref messageSizeArray[0], ref pSignerCert);
</code></pre>
","<p>The api you are using, carry out checks validity of digital signature which goes with documents and so on.. this check is done against a certificate, the info of whom are contained in the <code>CERT_CONTEXT</code> structure (<code>pSignerCert</code>) into which in turn it is contained a CERT_INFO structure (<code>pCertInfo CERT_CONTEXT</code> structure field).</p>

<p>Into <code>CERT_CONTEXT</code> you can find infos about standard certicate type of encoding used (<code>X509_ASN_ENCODING</code> or <code>PKCS_7_ASN_ENCODING</code>).</p>

<p>Into <code>CERT_INFO</code> you can find <code>CRYPT_ALGORITHM_IDENTIFIER</code> and other more detailed infos.</p>

<p>For a documentation about <code>CryptVerifyDetachedMessageSignature</code> apis and related structures:</p>

<ul>
<li><p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381076(v=vs.85).aspx"" rel=""nofollow noreferrer"">CryptVerifyDetachedMessageSignature</a></p></li>
<li><p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa377189(v=vs.85).aspx"" rel=""nofollow noreferrer"">CERT_CONTEXT</a></p></li>
<li><p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa377200(v=vs.85).aspx"" rel=""nofollow noreferrer"">CERT_INFO</a></p></li>
</ul>

<p><strong>EDIT:</strong></p>

<p>Digital signature system generally works creating an hash of the data to sign (SHA1 minimum level older certificates standard, now newer certicates start from a level of SHA256..), then this hash get encrypted with a private key using an algorithm of asymmetric cryptography (RSA). </p>

<p>When the message is received, it get decrypted with the public key contained in the certificate released publicly, and then the date get hashed with the right algorithm, declared in the certificate (<em>from programmatically point of view, see the struct fields upon</em>) and if the two hashes (one in the same certificate that goes with the data, and the other calculated on the client who verify the digital signature) correspond, then it is verified that the data are not corrupted or changed by someone other than the author, and if the certificate it is released by a valid certification authority, then the author is also identified in a sure manner.</p>
","644","<c#><winapi><encryption><cryptoapi><smime>","0","0","2","2016-12-29 16:45:18","","2","","695182","","2016-12-28 15:26:23","2016-12-28 15:09:46",""
"41364728","How to determine hash and encryption algorithm of S/MIME message with Win32 CryptoAPI?","<p>CryptVerifyMessageSignature and CryptDecryptMessage functions allow me to check if an S/MIME signature is valid (or decrypt encrypted data in CryptDecryptMessage case) and also return the certificate which was used for signing (or encryption). However, there is no information about which algorithms were actually used for signing and encryption. How can I get this info?</p>

<p>I'm using C# but any C/C++ sample or hint is also welcome.</p>

<p>Edit: signature verification code snippet (the entire code is very big to include it here) added upon request</p>

<pre><code>IntPtr pbDetachedSignBlob = IntPtr.Zero;
uint cbDetachedSignBlob = (uint)signatureBytes.Length;
IntPtr pbContent = IntPtr.Zero;
uint cbContent = (uint)data.Length;

pbDetachedSignBlob = Marshal.AllocHGlobal((int)cbDetachedSignBlob);
Marshal.Copy(signatureBytes, 0, pbDetachedSignBlob, (int)cbDetachedSignBlob);
pbContent = Marshal.AllocHGlobal((int)cbContent);
Marshal.Copy(data, 0, pbContent, (int)cbContent);
IntPtr[] messageArray = { pbContent };
uint[] messageSizeArray = { cbContent };

GCHandle messageArrayHandle = GCHandle.Alloc(messageArray, GCHandleType.Pinned);
IntPtr messageArrayPtr = (IntPtr)messageArrayHandle.AddrOfPinnedObject();

int ret = CryptoApiFuncs.MessageFuncs.CryptVerifyDetachedMessageSignature(pVerifyPara, 0, pbDetachedSignBlob, cbDetachedSignBlob, 1, messageArrayPtr, ref messageSizeArray[0], ref pSignerCert);
</code></pre>
","<p>Couldn't find the way to do this directly via CryptoAPI but managed to accomplish this with System.Security.Cryptography.Pkcs.SignedCms class:</p>

<pre><code>SignedCms cms = new SignedCms(new ContentInfo(data));
cms.Decode(signature);
string algName = cms.SignerInfos[0].DigestAlgorithm.FriendlyName;
</code></pre>

<p>where data is the message bytes being verified and signature is the detached signature bytes.</p>

<p>Production code must also be ready to expect non-single values in SignerInfos collection but the sample code shows the idea.</p>

<p>The same way, EnvelopedCms class provides the details on encryption algorithm of the message:</p>

<pre><code>EnvelopedCms cms = new EnvelopedCms();
cms.Decode(data);
string s = cms.ContentEncryptionAlgorithm.Oid.FriendlyName;
</code></pre>
","644","<c#><winapi><encryption><cryptoapi><smime>","0","1","2","2016-12-29 16:45:18","","2","","695182","","2016-12-28 15:26:23","2016-12-28 15:09:46",""
"38528194","OpenSSL and MS CryptoAPI compatibility issue","<p>I'm facing a incompatibility issue between Microsoft CrypoAPI and OpenSSL and I can't solve it.</p>

<p>I want to RSA encrypt a message using CAPI with public key and after that to decrypt it with OpenSSL (using the private key), but with no luck.</p>

<p>The steps I'm doing are as follow:</p>

<ul>
<li>Generating a public/private key pair with OpenSSL in pem format.</li>
</ul>

<p><code>openssl genrsa  -out private.pem 2048</code></p>

<p><code>openssl rsa -in private.pem -outform PEM -pubout -out public.pem</code></p>

<ul>
<li>Then In CAPI, I'm importing the generated keys like this:
dsadsa</li>
</ul>

<pre class=""lang-cpp prettyprint-override""><code>      const char* szPemPrivKey = 
""-----BEGIN RSA PRIVATE KEY-----""
""MIIEpAIBAAKCAQEAvUT7PaQzzhSmyQKrnroWCk2tdy9O1BR6bINObhGXoDfK4tnU""
""qgpr0MbM8VjCvpgNjJT8m5RZkvSxcmaWZZQnXxr/SESnrmwk6CcRAvEk45M3LTix""
""N0TTUZzQdBbG9z0bgx1a1P866S87MOf6wbb9yUfV79N7J+xZRQC8mnRtvmzjRZ3W""
""MOcBZ8n1C106gOq//SwvB28mGWTpJ+opASv3mkxTydiDd5v7/yq2Lx4NrvJN+1E4""
""nOX6PLiTECFcvNYzZe9KDuJ5CJv45ifRUo9m5ebo759lKpL1X69ptG7RpHEYULYY""
""urwEGExC1jp/Nbft0zOehsF4wwFqwQVQ34m5LQIDAQABAoIBAD6dQISu+th1aovb""
""T01ugHYeJoHka66rq6iUc/Dj7wZ5DqynpbwvQGXMLua1F5AYG3tjmoIZvNxqCP4w""
""xBaMwc2rz8JnvBVu/3Kx4eXYQvzqqflS5QXExigcubV+B4qpc52Xq4IFgca88lcG""
""l6VYVXMuSa9Shk652PqD+OEcHWY+aygXETLGEAlO88iWe2LbzrD9I1faW8Mrj+wi""
""b9mVhZbjbrI+w9O7cfde4d9Lo4wzGrrunRa0THKUyfwJGtTJ3eP2jCWlE1ij3Xmy""
""c/Mf8U8RlMU8N/Ys77WtCXUA3DK0ge8HSITqvD1NHSyuPM0XqinTkRSg0Ri/tWo+""
""1C6gKJ0CgYEA9K9snRlfuQshwfyR40npJ8r5X9YApjfK8PrxsmdpOi8tpDyi5I66""
""fmnUsbV0ikM+9U898myUAF3SxZIZfw+LYI3ofdstnv6wc9+c9jP9wbGxSryiBurW""
""d3uPuemee7+CxTVEwI0PEAVerRSP+m6MZ/F+SRkQjyLmBXu7soxaspMCgYEAxgWL""
""/wkz6WCf37+9TUHO0MG7vOQ2sI7Bc+82dAa9fsxLwpncmkNxEv+hK3k7Jlr2J4pZ""
""SveRhcq3Ohm2aDRi5CfgQaZO4bGDop7ZYWZuW/MakZdCf8olWCifXEPWcxBo8FGW""
""9/3XEbXkW481HDrX4wyn2b3ptdSqMcdDMKmifT8CgYEA6vtVWYG2teSE5OED0b13""
""VinNV0YTlY1bLhYw6134ZlJMiL9ayBhx7VkBVDCo3Oc7nSYenaO8dqWj9u0Z4zYw""
""aeeecM9+foSlPIJxINhJSCy30Mha6j24/UICg05iTwFaOr2vayOMZZxikeF/a8ei""
""u2fmGZkil/Ox524ukYfMylUCgYAiFTJTYzIcKRVbXZUnhvwh0jaN/HmtSeTiH3ov""
""3jkfaepgRDtEEfeUXYtQAD2+DEnx5E4aKSJS9OE0jthmdx3OR07B/e31yqfthYnE""
""yeyUxvL7vB0mAZUL53IGX2a5x0lIk8J4TKiH09bKK4von/gojDUXtShUs5XXm4Rl""
""C8174QKBgQDbRGyg3VCwo3p0sdqm5UlCL0pc36T5bBUfkVGpJdBZxbIx283CvY35""
""OGqcYdiANMn+alg9IDXfuaFYgg1QTQSkF74CMi+gY7Z8n2OKsjF0cR8VkIYoI9BL""
""iDXvlWs2QVsv+1CIYmZdI8nkExirzRvBD75ZqNdGSWkrfuYnr/bpHg==""
""-----END RSA PRIVATE KEY-----"";


const char* szPemPubKey = 
""-----BEGIN PUBLIC KEY-----""
""MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvUT7PaQzzhSmyQKrnroW""
""Ck2tdy9O1BR6bINObhGXoDfK4tnUqgpr0MbM8VjCvpgNjJT8m5RZkvSxcmaWZZQn""
""Xxr/SESnrmwk6CcRAvEk45M3LTixN0TTUZzQdBbG9z0bgx1a1P866S87MOf6wbb9""
""yUfV79N7J+xZRQC8mnRtvmzjRZ3WMOcBZ8n1C106gOq//SwvB28mGWTpJ+opASv3""
""mkxTydiDd5v7/yq2Lx4NrvJN+1E4nOX6PLiTECFcvNYzZe9KDuJ5CJv45ifRUo9m""
""5ebo759lKpL1X69ptG7RpHEYULYYurwEGExC1jp/Nbft0zOehsF4wwFqwQVQ34m5""
""LQIDAQAB""
""-----END PUBLIC KEY-----"";



/* 
..... some unrelated code here */
char           derPubKey[2048];
size_t         derPubKeyLen = 2048;
CERT_PUBLIC_KEY_INFO *publicKeyInfo;
int            publicKeyInfoLen;
HCRYPTPROV hProv = NULL;
HCRYPTKEY hKey = NULL;
/*
* Convert from PEM format to DER format - removes header and footer and decodes from base64
*/
if ( !CryptStringToBinaryA( szPemPubKey, 0, CRYPT_STRING_BASE64HEADER, (BYTE*)derPubKey, (DWORD*)&amp;derPubKeyLen, NULL, NULL ) )
{
    fprintf( stderr, ""CryptStringToBinary failed. Err: %d\n"", GetLastError() );
}

/*
 * Decode from DER format to CERT_PUBLIC_KEY_INFO
 */
if ( !CryptDecodeObjectEx( X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO, (BYTE*)derPubKey, derPubKeyLen, 
                           CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;publicKeyInfo, (DWORD*)&amp;publicKeyInfoLen ) )
{
    fprintf( stderr, ""CryptDecodeObjectEx 1 failed. Err: %p\n"", GetLastError() );
    return -1;
}

// Create a temporary and volatile CSP context in order to import
// the key and use for signing
if (!CryptAcquireContext(&amp;hProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
{
    printf(""CryptAcquireContext failed with error 0x%.8X\n"", GetLastError());
    goto main_exit;
}

/*
 * Import the public key using the context
 */
if ( !CryptImportPublicKeyInfo( hProv, X509_ASN_ENCODING, publicKeyInfo, &amp;hKey ) )
{
    fprintf( stderr, ""CryptImportPublicKeyInfo failed. error: %d\n"", GetLastError() );
    return -1;
}
</code></pre>

<p>It seems that the key is imported correctly and <code>hKey</code> is populated.</p>

<ul>
<li>So far, so good. Then I'm tring to encrypt a plaintext</li>
</ul>

<pre class=""lang-js prettyprint-override""><code>    char* plaintext = ""123456"";
LPBYTE pEncryptedData = NULL;
DWORD EncryptedDataLen = 0;

LPBYTE pEncryptedDataRev = NULL; /* I'll explain this later (: */
DWORD EncryptedDataRevLen = 0;

pEncryptedData = (LPBYTE) LocalAlloc(0, 500);
EncryptedDataLen = 6;


pEncryptedDataRev = (LPBYTE) LocalAlloc(0, 500);
EncryptedDataLen = 6;


CopyMemory(pEncryptedData, plaintext, 6);


if ( CryptEncrypt( hKey, NULL, TRUE, 0, pEncryptedData, &amp;EncryptedDataLen, 500) ) {
    DWORD dwBytesWritten = 0;

    hFile = CreateFile(L""poc_enc"",              // name of the write
                       GENERIC_WRITE,          // open for writing
                       0,                      // do not share
                       NULL,                   // default security
                       CREATE_NEW,             // create new file only
                       FILE_ATTRIBUTE_NORMAL,  // normal file
                       NULL);                  // no attr. template

    ReverseStream(pEncryptedData, pEncryptedDataRev, EncryptedDataLen);

    WriteFile( 
                    hFile,           // open file handle
                    pEncryptedData,      // start of data to write
                    EncryptedDataLen,  // number of bytes to write
                    &amp;dwBytesWritten, // number of bytes that were written
                    NULL);            // no overlapped structure

      CloseHandle(hFile); 
} 
</code></pre>

<p>You can see that, I'm reversing the encrypted data with <code>ReverseStrem()</code>, that is because, that I've read that the endiannes which CAPI and OpenSSL use differ. (little-endian CAPI, and big-endian OpenSSL)</p>

<pre class=""lang-cpp prettyprint-override""><code>void ReverseStream(LPBYTE Source, LPBYTE Destination, DWORD Size)
{
    DWORD cnt = Size;
    while(0&lt;cnt)
    {
        Destination[Size-cnt] = Source[cnt];
        cnt--;
    }
}
</code></pre>

<ul>
<li>OK, Now the troubles come. The encrypted plaintext (123456) is written to a file named <code>poc_enc</code>, and when I try to decrypt it with OpenSSL</li>
</ul>

<p><code>openssl rsautl -decrypt   -in poc_enc -out plaintext -inkey private.pem</code></p>

<p>and I'm getting the following error:
</p>

<pre><code>    RSA operation error
16968:error:0407109F:rsa routines:RSA_padding_check_PKCS1_type_2:pkcs decoding error:.\crypto\rsa\rsa_pk1.c:273:
16968:error:04065072:rsa routines:RSA_EAY_PRIVATE_DECRYPT:padding check failed:.\crypto\rsa\rsa_eay.c:602:
</code></pre>

<p>Any ideas how can I fix this issue? Thanks :)</p>
","<p>The reverse function is wrong, this way you miss the last byte, it should be something like this:</p>

<pre><code>void ReverseStream(LPBYTE Source, LPBYTE Destination, DWORD Size)
{
    int SourceCnt = Size;
    int DestCnt = 0;

    for (SourceCnt = Size - 1, DestCnt = 0; SourceCnt &gt;= 0; SourceCnt--, DestCnt++)
        Destination[DestCnt] = Source[SourceCnt];
}
</code></pre>
","639","<openssl><cryptoapi>","1","1","1","2016-07-22 16:40:24","38531522","0","","","","","2016-07-22 13:50:41",""
"32745524","Apparently (!) inconsistent signing between .NET and Mono; Mono signing is not idempotent","<p>Google Cloud Storage provides Java, C# code samples for generating signed URLs:</p>

<p><a href=""https://cloud.google.com/storage/docs/access-control?hl=en#signing-code-csharp"" rel=""nofollow"">https://cloud.google.com/storage/docs/access-control?hl=en#signing-code-csharp</a></p>

<p>I'm using the code sample. With the same service account|key, bucket and object, the Java code and the C# code (on Windows) work. When I try the C# code on Mono/Linux, it does not work. The error is:</p>

<pre><code>Code: SignatureDoesNotMatch
Message: The request signature we calculated does not match the signature you provided. Check your Google secret key and signing method.
</code></pre>

<p>Injecting some debugging code corroborates this error.</p>

<p>Here's the augmented method that does the signing:</p>

<pre><code>private String signString(String stringToSign)  {
    if (key == null) throw new Exception(""Certificate not initialized"");
    CspParameters cp = new CspParameters(
        24,
        ""Microsoft Enhanced RSA and AES Cryptographic Provider"",
        ((RSACryptoServiceProvider)key.PrivateKey).CspKeyContainerInfo.KeyContainerName
        );
    RSACryptoServiceProvider provider = new RSACryptoServiceProvider(cp);
    byte[] buffer = Encoding.UTF8.GetBytes(stringToSign);
    byte[] rawSignature = provider.SignData(buffer, CryptoConfig.MapNameToOID(""SHA256""));
    Console.WriteLine (""signature == "");
    Console.WriteLine (BitConverter.ToString(rawSignature).Replace(""-"", string.Empty));
    return Convert.ToBase64String(rawSignature);
}
</code></pre>

<p>I expect (perhaps incorrectly that) repeated calls to signString with the same string value, would return the same rawSignature and result. On Java and Windows, this is true. On Mono, the value changes</p>

<pre><code>String testString=""helloworld"";
Console.WriteLine(""Signing '"" + testString + ""' == "" + this.signString(testString));
Console.WriteLine(""Signing '"" + testString + ""' == "" + this.signString(testString));
Console.WriteLine(""Signing '"" + testString + ""' == "" + this.signString(testString));
</code></pre>

<p>returns, abbreviated results:</p>

<pre><code>signature == 
4415768E8E2FB862...
Signing 'helloworld' == RBV2jo4v...
signature == 
95E589C2F8DAD7ED...
Signing 'helloworld' == leWJwvja...
signature == 
0589E4454FE4FB3A...
Signing 'helloworld' == BYnkRU/k...
</code></pre>

<p>With Java, a similar test using the Google sample returns:</p>

<pre><code>rawSignature == 
3E56F09EE9CF7D98...
Signing 'helloworld' == PlbwnunP...
rawSignature == 
3E56F09EE9CF7D98...
Signing 'helloworld' == PlbwnunP...
rawSignature == 
3E56F09EE9CF7D98...
Signing 'helloworld' == PlbwnunP...
</code></pre>

<p>What am I doing wrong?</p>
","<p>I've managed to get consistent results by not using <code>CspParameters</code> at all, but using the <code>PrivateKey</code> property of <code>X509Certificate2</code>. My current ""portable"" implementation unfortunately requires a cast which makes me nervous, but it does appear to give the same results on Windows and Linux (under Mono 4.0.2), and those are the same results as the original sample code. Here's a short test app which works under Mono:</p>

<pre><code>using System;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

public class Test
{
    static void Main()
    {
        var key = new X509Certificate2(""key.p12"", ""notasecret"");
        byte[] buffer = Encoding.UTF8.GetBytes(""test string"");
        // This is the slightly dodgy bit...
        var rsa = (RSACryptoServiceProvider) key.PrivateKey;
        byte[] signature = rsa.SignData(buffer, ""SHA256"");
        Console.WriteLine(Convert.ToBase64String(signature));
    }
}
</code></pre>

<p>As noted in comments, this <em>doesn't</em> work under .NET, for unknown reasons :(</p>

<p>Now I <em>haven't</em> tried using this to make any Cloud Storage requests yet, but I expect it would work.</p>

<p>On more modern platforms, you can use the fact that <code>RSA</code> has a <a href=""https://msdn.microsoft.com/en-us/library/mt132675(v=vs.110).aspx"" rel=""nofollow""><code>SignData</code></a> method, and use the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.rsacertificateextensions.getrsaprivatekey(v=vs.110).aspx"" rel=""nofollow""><code>GetPrivateRSAKey()</code> extension method</a> to get an <code>RSA</code> instance:</p>

<pre><code>var rsa = key.GetRSAPrivateKey();
var signature = rsa.SignData(
   buffer, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
</code></pre>

<p>You may be able to use this on Mono too depending on which version you target.</p>
","629","<c#><mono><cryptoapi>","4","1","1","2015-09-24 14:39:26","32762120","3","","609290","","2015-09-23 22:20:40","2015-09-23 17:09:57",""
"27857616","CryptAcquireContext failing with ERROR_FILE_NOT_FOUND (2L) when user not logged on Windows 8.1","<p>I am having a hard time migrating a C++ CryptoAPI-based application that currently runs on Windows Server 2008 to Windows 8.1. The scenario is:</p>

<p>This application is eventually triggered by WatchDog.exe, which in its turn is triggered when the computer is started by Windows' Task Scheduler.</p>

<p>Task Scheduler uses the following rules to start the WatchDog.exe:</p>

<ul>
<li>A Administrator User Account;</li>
<li>Run Whether user is logged on or not;</li>
<li>UNCHECKED: Do not store password. The task will only have access to
local resources;</li>
<li>Run with Highest Privileges;</li>
<li>Configure for Win 8.1;</li>
<li>Triggered at system startup.</li>
</ul>

<p>The server sits there, nobody logged, until in a given scenario WatchDog.exe starts the application. Application log confirms that the owner of the process (<em>GetUserName</em>) is the very same user Task Scheduler used to trigger WatchDog.exe.</p>

<p>It turns out that this application works fine in Windows Server 2008, but in windows 8.1 a call to <em><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx"" rel=""nofollow"">CryptAcquireContext</a></em> fails with return code <strong>ERROR_FILE_NOT_FOUND (2L)</strong>. The odd thing is that the application will NOT fail if, when started, the user is physically logged onthe machine, although it was not the user who started the application manually.</p>

<p>I took a look at the <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379886(v=vs.85).aspx"" rel=""nofollow"">documentation</a> and found:</p>

<blockquote>
  <p>""The profile of the user is not loaded and cannot be found. This
  happens when the application impersonates a user, for example, the
  IUSR_ComputerName account.""</p>
</blockquote>

<p>I had never heard of impersonification, so I made a research and found the APIs <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa378184(v=vs.85).aspx"" rel=""nofollow"">LogonUser</a>, <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa378612(v=vs.85).aspx"" rel=""nofollow"">ImpersonateLoggedOnUser</a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379317(v=vs.85).aspx"" rel=""nofollow"">RevertToSelf</a>. I then updated the application in this way:</p>

<pre><code>...
HANDLE hToken;
if (! LogonUser(L""admin"", L""."", L""XXXXXXXX"", LOGON32_LOGON_BATCH, LOGON32_PROVIDER_DEFAULT, &amp;hToken))
{
    logger-&gt;log (_T(""Error logging on.""));
}
else
{
    logger-&gt;log (PMLOG_LEVEL_TRACE, _T(""Logged on.""));
    if (! ImpersonateLoggedOnUser(hToken))
    {
        logger-&gt;log (_T(""Error impersonating.""));
    }
    else
    {
        logger-&gt;log (_T(""Impersonated.""));
        err = XXXXXXXXX(); // calls function which will execute CryptAcquireContext 
        if (! RevertToSelf())
        {
            logger-&gt;log (_T(""Error reverting.""));
        }
        else
        {
            logger-&gt;log (_T(""Reverted.""));
        }
    }
}
...
</code></pre>

<p>Excerpt with the call to CryptAcquireContext:</p>

<pre><code>...
//---------------------------------------------------------------
// Get the handle to the default provider. 
if(! CryptAcquireContext(&amp;hCryptProv, cryptContainerName, MS_ENHANCED_PROV, PROV_RSA_FULL, 0))
{
    DWORD e = GetLastError();
    _stprintf_s (logMsg, 1000, _T(""Error %ld acquiring cryptographic provider.""), e);
    cRSALogger-&gt;log (logMsg);
    return ERR_CCRYPT_NO_KEY_CONTAINER;
}
cRSALogger-&gt;log (_T(""Cryptographic provider acquired.""));
...
</code></pre>

<p>As the result, I got the log:</p>

<pre><code>...
[2015/01/08 20:53:25-TRACE] Logged on.
[2015/01/08 20:53:25-TRACE] Impersonated.
...
[2015/01/08 20:53:26-ERROR] Error 2 acquiring cryptographic provider.
...
[2015/01/08 20:53:26-TRACE] Reverted.
...
</code></pre>

<p>That seems to show that impersonation is working properly, but still I get Error <strong>2 (ERROR_FILE_NOT_FOUND)</strong> on <em>CryptAcquireContext</em>.</p>

<p><strong>Summary:</strong></p>

<ul>
<li>On Windows Server 2008, the very same application runs properly even
without the calls to <em>LogonUser/Impersonate/Revert</em>.</li>
<li>On Windows 8.1, the application, with or without the calls to
<em>LogonUser/Impersonate/Revert</em>, will only work properly if the user is logged on (which is not acceptable).</li>
</ul>

<p>Any thoughts where I can run to in order to get this working on windows 8.1?</p>

<p>Thank in advance,</p>

<p>Dan</p>
","","620","<c++><authentication><windows-8.1><impersonation><cryptoapi>","2","","0","2015-01-09 09:47:11","","2","","1763462","","2015-01-09 09:47:11","2015-01-09 09:37:58",""
"9351426","CSP Provider Name","<p>how can I get CSP provider name of my connected smartcard?</p>

<p>I couldn't access to registry windows so I'm find some way to achieve that information through win API.</p>

<p>I've already seen something about SCardGetCardTypeProviderName but it seems impossibile to find a complete example in C#.</p>
","<p>You can use <code>certutil</code>.</p>

<p>Something like this:</p>

<blockquote>
  <p>c:> Certutil -csplist</p>
</blockquote>

<p>It lists all CSP providers that currently exist on your PC.</p>
","619","<c#><security><smartcard><cryptoapi>","2","0","1","2016-12-20 08:37:03","","0","","","","","2012-02-19 17:32:12",""
"21341837","Mutual SSL authentication with CAPI and OpenSSL","<p>I need to do mutual SSL authentication from my client app (C++) using OpenSSL (via libcurl). I am reading certs from a smart card via MS Crypto API (CAPI) and ActivClient driver, and doing cert-chain validation with CAPI (this seemed to be easier validating the cert chain with OpenSSL since the cert chain is in the MS cert store). I can convert the client cert from CAPI to OpenSSL, but I'm having problems with the private key.</p>

<p>It seems that, for the server to validate my client's cert, I need to expose the client cert private key to OpenSSL. It's not quite clear how I should do that, or even if I can do that (it may depend on whether the key is marked as ""exportable"" in the cert). I can try following the suggestions in <a href=""https://stackoverflow.com/questions/16775911/converting-private-key-in-windows-store-to-pem-for-openssl?rq=1"">Converting private key in windows store to PEM (for OpenSSL)</a>, and hope the key is exportable, but I wonder whether I am even going down the correct path.</p>

<p>I've searched quite a bit on this topic, but haven't found any conclusive info.</p>

<p>Any advice and/or suggestions are appreciated!!</p>
","","615","<openssl><smartcard><private-key><cryptoapi><mutual-authentication>","1","","0","2018-01-15 11:12:44","","2","","-1","","2017-05-23 12:23:56","2014-01-24 20:25:06",""
"39431479","JPK - CryptoAPI RSA 256/ECB/PKCS#1 one time secret password encryption with public key from certificate (solution)","<p>Polish government (MF - Ministry of Finance) recently implemented SAF-T (Standard Audit File-Tax / pl: JPK - Jednolity Plik Kontrolny). I had much trouble to implement one of the key parts of this solution in the right way. This part is to encrypt user generated password used to encrypt files, sended to Azure Cloud Storage, with RSA 256/ECB/PKCS#1 algorithm from MS CryptoAPI, using public key loaded from certificate file served by the MF.</p>
","<p>My working solution to this is (uses <a href=""https://sourceforge.net/projects/jedi-apilib/"" rel=""nofollow"">JEDI API Library &amp; Security Code Library</a>):</p>

<pre><code>unit CryptoAPI_RSA;
// The MIT License (MIT)
// 
// Copyright (c) 2016 Grzegorz Molenda
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the ""Software""), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
interface

uses
  SysUtils,
  Classes;

function CryptoAPI_Encrypt_RSA(const Input: TBytes; const cert: TMemoryStream): String;

implementation

uses
  Windows,
  StrUtils,
  JwaWinCrypt,
  JwaWinError,
  EncdDecd;

type
  ERSAEncryptionError = class(Exception);

function WinError(const RetVal: BOOL; const FuncName: String): BOOL;
var
  dwResult: Integer;
begin
  Result:=RetVal;
  if not RetVal then begin
    dwResult:=GetLastError();
    raise ERSAEncryptionError.CreateFmt('Error [x%x]: %s failed.'#13#10'%s', [dwResult, FuncName, SysErrorMessage(dwResult)]);
  end;
end;

procedure reverse(var p: TBytes; len: Integer);
var
  i, j: Integer;
  temp: Byte;
begin
  i:=0;
  j:=len - 1;
  while i &lt; j do begin
    temp:=p[i];
    p[i]:=p[j];
    p[j]:=temp;
    Inc(i);
    Dec(j);
  end;
end;

function CryptoAPI_Encrypt_RSA(const Input: TBytes; const cert: TMemoryStream): String;
var
  derCert: AnsiString;
  derCertLen: Cardinal;
  hProv: HCRYPTPROV;
  certContext: PCCERT_CONTEXT;
  certPubKey: HCRYPTKEY;
  len: LongWord;
  rsa: TBytes;
  ins: TMemoryStream;
  ous: TStringStream;
begin
  Result:='';
  if (cert &lt;&gt; Nil) and (cert.Size &gt; 0) then begin
    SetLength(derCert, 4096);
    FillChar(derCert[1], 4096, 0);
    // Convert from PEM format to DER format - removes header and footer and decodes from base64
    WinError(CryptStringToBinaryA(PAnsiChar(cert.Memory), cert.Size, CRYPT_STRING_BASE64HEADER, @derCert[1], derCertLen, Nil), 'CryptStringToBinaryA');
    SetLength(derCert, derCertLen);
    try
      // Get the certificate context structure from a certificate.
      certContext:=CertCreateCertificateContext(X509_ASN_ENCODING or PKCS_7_ASN_ENCODING, @derCert[1], derCertLen);
      WinError(certContext &lt;&gt; Nil, 'CertCreateCertificateContext');
      try
        hProv:=0;
        WinError(CryptAcquireContext(hProv, Nil, Nil, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT), 'CryptAcquireContext'); // flag CRYPT_VERIFYCONTEXT - for backward compatibility with win2003server (and probably with win10pro+)
        try
          // Get the public key information for the certificate.
          certPubKey:=0;
          WinError(CryptImportPublicKeyInfo(hProv, X509_ASN_ENCODING or PKCS_7_ASN_ENCODING,
                                            @certContext.pCertInfo.SubjectPublicKeyInfo, certPubKey), 'CryptImportPublicKeyInfo');
          len:=Length(Input);
          if len &gt; 0 then begin
            SetLength(rsa, len + 512);
            FillChar(rsa, len + 512, 0);
            try
              CopyMemory(@rsa[0], @Input[0], len);
              // encrypt our Input buffer
              WinError(CryptEncrypt(certPubKey, 0, True, 0, @rsa[0], len, len + 512), 'CryptEncrypt');
              SetLength(rsa, len);
              // IMPORTANT !!!
              // .Net RSA algorithm is BIG-ENDIAN,
              // CryptoAPI is LITTLE-ENDIAN, 
              // so reverse output before sending to Azure Cloud Storage
              reverse(rsa, len);
              ins:=TMemoryStream.Create;
              try
                ins.Write(rsa[0], len);
                ins.Position:=0;
                ous:=TStringStream.Create;
                try
                  EncodeStream(ins, ous);
                  ous.Position:=0;
                  Result:=ous.DataString;
                  Result:=ReplaceStr(Result, #13#10, '');
                finally
                  ous.Free;
                end;
              finally
                ins.Free;
              end;
            finally
              SetLength(rsa, 0);
            end;
          end;
        finally
          WinError(CryptReleaseContext(hProv, 0), 'CryptReleaseContext');
        end;
      finally
        CertFreeCertificateContext(certContext);
      end;
    finally
      SetLength(derCert, 0);
    end;
  end;
end;

end.
</code></pre>

<p>Usage is:</p>

<pre><code>var
  cf: TMemoryStream;
  input: TBytes;
  output: String;
begin
  if Edit1.Text = '' then
    Exit;
  Memo1.Clear;
  cf:=TMemoryStream.Create;
  try
    cf.LoadFromFile('cert.pem'); // certificate with public key
    input:=TEncoding.Default.GetBytes(Edit1.Text);
    try
      output:=CryptoAPI_Encrypt_RSA(input, cf);
    finally
      SetLength(input, 0);
    end;
    Memo1.Lines.Text:=output;
  finally
    cf.Free;
  end;
end;
</code></pre>

<p>Hope that this might help someone, see ya.</p>
","612","<delphi><delphi-2010><solution><cryptoapi>","0","2","1","2017-02-08 09:33:26","39431480","0","1","","","","2016-09-10 23:26:34",""
"46831837","OpenSSL speedup with cryptodev on i.MX6 CAAM","<p>I am trying to utilize the CAAM hardware on the i.MX6 through cryptodev. The speedup looks good in the openssl speed benchmark. For example when running:</p>

<pre><code>openssl speed -evp aes-256-cbc -engine cryptodev
</code></pre>

<p>I get good speedup and I can see the interrupts to the CAAM increasing rapidly in /proc/interrupts.
However I need to use the encryption in an application so I utilize the OpenSSL API functions for envelope encryption:</p>

<pre><code> int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char **ek, int *ekl, unsigned char *iv, EVP_PKEY **pubk, int npubk);

 int EVP_SealUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, unsigned char *in, int inl);

 int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
             int *outl);
</code></pre>

<p>passing EVP_aes_256_cbc() as the const EVP_CIPHER *type.
Here I do not get any speedup and I also do not see the interrupts to the CAAM increasing in /proc/interrupts. Could anyone please guide me about what is wrong in this scenario? Why is the API call not utilizing the CAAM engine while the ""openssl speed"" benchmark is working fine?</p>
","","610","<openssl><cryptoapi><hardware-acceleration><imx6>","1","","0","2017-10-19 14:06:15","","4","","","","","2017-10-19 14:06:15",""
"22063310","Adding authenticated attributes using MS CryptoApi","<p>I'm struggling adding authenticated attributes (OCSP data) to my message using CryptoApi. I first used CryptoApi's simplified message functions, but now switch to the low-level message functions, thinking that I would be able to control the message structure better. But I am once again stuck. My process is as follows:</p>

<ul>
<li>Initialize CMSG_SIGNER_ENCODE_INFO and CMSG_SIGNED_ENCODE_INFO structure</li>
<li>I create a CRYPT_ATTRIBUTE for the ocsp date and specifies it in the CMSG_SIGNER_ENCODE_INFO structure</li>
<li>I then call CryptMsgCalculateEncodedLength to get the size</li>
<li>CryptMsgOpenToEncode with CMSG_SIGNED as the message type</li>
<li>CryptMsgUpdate, to insert my content into the message</li>
<li>CryptMsgGetParam with CMSG_CONTENT_PARAM to get the encoded blob</li>
<li>CryptMsgClose, I'm done with the message for now.</li>
</ul>

<p>I open the message again to get the CMSG_ENCRYPTED_DIGEST, which is sent to a TSA and the result is added as an unaunthenticated attribute using CryptMsgControl.</p>

<p>I'm using this to sign signature tags in Adobe. So when there is no authenticated attributes, I receive three green check from Adobe:</p>

<ol>
<li>The document has not been modified...</li>
<li>The document is signed by the current user</li>
<li>The signature includes an embedded timestamp (and the timestamp is validate)</li>
</ol>

<p>But as soon as the authenticated attribute is added the signer's identity is invalidated and the timestamp data in incorrect. The CMSG_COMPUTED_HASH_PARAM when authenticated attributes are added and when not, differs. Should this not be the same? Since the document digest is of the content of the document and not of the authenticated attribute.</p>

<p>Is there another way to add authenticated attributes? I've tried to add it as a signer using CryptMsgControl, but that did not help either...</p>
","<p>how about this step on adding the authenticated attributes for signing, example time stamping,</p>

<pre><code>CryptEncodeObject(PKCS_7_ASN_ENCODING, szOID_RSA_signingTime, &amp;curtime, pTime, &amp;szTime);
pTime = (BYTE *)LocalAlloc(GPTR, szTime);
CryptEncodeObject(PKCS_7_ASN_ENCODING, szOID_RSA_signingTime, &amp;curtime, pTime, &amp;szTime);
time_blob.cbData = szTime;
time_blob.pbData = pTime;
attrib[0].pszObjId = szOID_RSA_signingTime;
attrib[0].cValue = 1;
attrib[0].rgValue = &amp;time_blob;
CosignerInfo.cAuthAttr = 1;
CosignerInfo.rgAuthAttr = attrib;
</code></pre>

<p>and that Cosigner params is from CMSG_SIGNER_ENCODE_INFO CosignerInfo;</p>
","608","<signing><cryptoapi><pkcs#7>","0","0","1","2014-12-11 19:14:22","","0","1","1699210","","2014-12-11 19:14:22","2014-02-27 08:47:48",""
"3525826","Why does my decryption function scramble the ciphertext even more, instead of decrypting it?","<p>I've created this program that can encrypt a found file and then it can be decrypted later via the CryptDecrypt function. The function succeeds but instead of decrypting the file back to plain text it makes the file look even more encrypted.</p>

<p>I've put both the CryptEncrypt function and CryptDecrypt function so you can have a more less view what I'm doing wrong. One more thing I'm using the Win32 API, no MFC or ATL.</p>

<pre><code>if (LOWORD(wParam) == WORD(decrypt_id))
  {
   wchar_t filepath[256];
   GetWindowTextW(hWnd, filepath, (int)256);
   _wstat(filepath, &amp;info4); 

   const long bytesize = info4.st_size;
   unsigned char *buffer = new unsigned char[bytesize];
   file = _wfopen(filepath, L""r"");
   size_t readsize = fread(buffer, sizeof(char), info4.st_size , file);
   BOOL returnn = CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENHANCED_PROV,  PROV_RSA_FULL, 0);
   BOOL rvalue1 = CryptGenKey(hCryptProv, CALG_RC4, KEYLENGTH | CRYPT_EXPORTABLE, &amp;hkey);
   DWORD val = GetLastError();
   DWORD datalength = info4.st_size;
   BOOL rvalue3 = CryptDecrypt(hkey, NULL, FALSE, NULL, buffer, &amp;datalength);
   file2 = _wfopen(filepath, L""w"");
   size_t writesize = fwrite(buffer, sizeof(char), sizeof(buffer), file2);
   free(buffer);
   CryptReleaseContext(hCryptProv, 0);
   CryptDestroyKey(hkey);
   if (rvalue3 == 0)
   {
    DWORD result = GetLastError();
    wchar_t dest[256] = L""Decryptor Failed To Decrypt File!"";
    wcscat_s(dest, L""\n"");
    wcscat_s(dest, L""Error Code: "");
    wchar_t code[256];
    swprintf_s(code, L""%d"", result);
    wcscat_s(dest, code);
    wcscat_s(dest, L""\n"");
    wcscat_s(dest, L""Error Code Information at: http://msdn.microsoft.com/en-us/library/ms681381(v=VS.85).aspx"");
    MessageBoxW(hWnd, dest, L""Error"", MB_ICONERROR | MB_OK);
    ShowWindow(encrypt_button, SW_HIDE);
   }
   else
   {
    MessageBox(hWnd, L""Successfully Decrypted The File!"", L"""", MB_OK | MB_ICONINFORMATION);
    ShowWindow(encrypt_button, SW_HIDE);
   }
  }
  if (LOWORD(wParam) == WORD(encrypt_id))
  {
   wchar_t filepath[256];
   GetWindowTextW(hWnd, filepath, (int)256);
   _wstat(filepath, &amp;info4); 
   const long bytesize = info4.st_size;
   unsigned char *buffer = new unsigned char[bytesize];
   file = _wfopen(filepath, L""r"");
   size_t readsize = fread(buffer, sizeof(char), info4.st_size , file);
   BOOL returnn = CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENHANCED_PROV,  PROV_RSA_FULL, 0);
   BOOL rvalue1 = CryptGenKey(hCryptProv, CALG_RC4, KEYLENGTH | CRYPT_EXPORTABLE, &amp;hkey);
   DWORD val = GetLastError();
   DWORD datalength = info4.st_size;
   BOOL rvalue3 = CryptEncrypt(hkey, NULL, FALSE, NULL, buffer, &amp;datalength, datalength);
   file2 = _wfopen(filepath, L""w"");
   size_t writesize = fwrite(buffer, sizeof(char), sizeof(buffer), file2);
   free(buffer);
      CryptDestroyKey(hkey);
   CryptReleaseContext(hCryptProv, 0);
   if (rvalue3 == 0)
   {
    DWORD result = GetLastError();
    wchar_t dest[256] = L""Encryptor Failed To Encrypt File!"";
    wcscat_s(dest, L""\n"");
    wcscat_s(dest, L""Error Code: "");
    wchar_t code[256];
    swprintf_s(code, L""%d"", result);
    wcscat_s(dest, code);
    wcscat_s(dest, L""\n"");
    wcscat_s(dest, L""Error Code Information at: http://msdn.microsoft.com/en-us/library/ms681381(v=VS.85).aspx"");
    MessageBoxW(hWnd, dest, L""Error"", MB_ICONERROR | MB_OK);
    ShowWindow(encrypt_button, SW_HIDE);
   }
   else
   {
    MessageBox(hWnd, L""Successfully Encrypted The File!"", L"""", MB_OK | MB_ICONINFORMATION);
    ShowWindow(encrypt_button, SW_HIDE);
   }
  }
</code></pre>
","<p>It looks like before encrypting or decrypting, you're generating a random key with <code>CryptGenKey</code>. This means that you will use a different key for encryption and decryption, so your file will not decrypt correctly.</p>

<p>You will need to use the same key for encryption or decryption. Either by exporting and importing the key, or possibly by using <code>CryptDeriveKey</code> to derive the key from a shared password.</p>
","606","<c++><winapi><encryption><cryptoapi>","1","1","1","2011-08-23 21:41:23","3525910","0","","600500","","2011-08-23 21:41:23","2010-08-19 20:14:33",""
"12789436","How to programmatically update subversion password on local machine?","<p>I am building a small internal tool for use with the developers in my company. One of the small goals is to update multiple locations when we change our passwords. One of these locations that needs to be updated is subversion. Most of the developers use TortoiseSvn but not all do (so I'd prefer a program neutral solution but it's not a requirement). </p>

<p>From my research around this topic, my first impression was that Tortoise or another application would have a change password function that I could use. This isn't so from what I can find. So my next thought was to change the encrypted password that is stored in %APPDATA%\Subversion\auth\svn.simple. This way, we could bypass any program and just fix the local machine credentials and be on our merry way.</p>

<p>For a Windows machine, subversion uses the wincrypt password-store for encryption. Working with that code was fairly straight forward. I found this <a href=""http://www.obviex.com/Samples/Dpapi.aspx"" rel=""nofollow noreferrer"">DPAPI (from Obviex)</a> code that would work to handle the encryption for me. It just takes care of the details for me (small note: I had some small issues with <code>System.Security.Cryptography.ProtectedData</code> so I decided to stick with this other way).</p>

<p>With this code, I was able to decrypt the password from the svn.simple folder and find that it worked (Previously saved authentication was decrypted and turned up the right password). However, when I would encrypt the password and store it in the proper place, I will always get a login screen from TortoiseSvn. It doesn't like my encrypted password. </p>

<p>So what's my question... has anyone accomplished something similar to what I am trying to do? Should I just forget trying to update the subversion password? Should I force a checkout of a repository and provide the credentials (I can do this using <a href=""http://sharpsvn.open.collab.net/"" rel=""nofollow noreferrer"">SharpSvn</a>) and then delete the repository once it finishes?</p>

<p>Guess I am just hoping to find that someone has solved this problem already and can point me in the right direction. Please let me know if you have questions. </p>

<p>Other noteworthy links:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3883129/extract-tortoisesvn-saved-password"">Stackoverflow question on extracting TortoiseSVN password</a></li>
<li><a href=""http://www.leapbeyond.com/ric/TSvnPD/"" rel=""nofollow noreferrer"">TortoiseSVN Password Decrypter</a> - Used this for parsing the files within svn.simple. Small changes were made for applying the new encrypted password to the existing svn authentication files.</li>
</ul>
","<p>I know this is a completely different direction than you were asking but in the right circumstance, it achieves your goal...</p>

<p>If you are using Active Directory to manage your users and you are willing to switch your SVN server applications, you should consider <a href=""http://www.visualsvn.com/server/"" rel=""nofollow"">VisualSVN server</a>.  It has support for authentication against LDAP and it uses the user's SID in the authz file so user name and password changes are transparent.  Plus it's <a href=""http://www.visualsvn.com/server/licensing/"" rel=""nofollow"">free for commercial use</a>.</p>
","606","<c#><svn><authentication><tortoisesvn><cryptoapi>","3","1","1","2012-10-14 08:48:55","12880648","0","","-1","","2017-05-23 12:15:16","2012-10-08 21:02:50",""
"7603542","How to import a certificate to a key container in usb token?","<p>I have a problem, I am currently working in a project PKI, I must to create a module to renewal certificate using exits public/private key pair . I can get information about key container from usb token but i don't know how to import new certificate created using same public/private keypair like old certificate? Can every tell me how can i achieve this using CryptoAPI? </p>
","","594","<c++><cryptoapi>","0","","0","2011-09-29 21:22:16","","3","","","","","2011-09-29 21:22:16",""
"21266761","Export to PEM format using CryptoAPI","<p>I have a certificate from the windows store and I would like to extract the public key in PEM format using the CryptoAPI.</p>

<pre><code>PCCERT_CONTEXT pCert  = CertFindCertificateInStore (...);
</code></pre>

<p>From the <code>pCert</code> there is no obvious way to get the public key certificate in PEM format using CryptoAPI.</p>
","<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376064%28v=vs.85%29.aspx"" rel=""nofollow""><code>CertFindCertificateInStore</code></a> returns <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa377189%28v=vs.85%29.aspx"" rel=""nofollow""><code>PCCERT_CONTEXT</code></a> which has a <code>pCertInfo</code> as a member, of type <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa377200%28v=vs.85%29.aspx"" rel=""nofollow""><code>PCERT_INFO</code></a> which on its turn has a <code>SubjectPublicKeyInfo</code> member of type <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa377463%28v=vs.85%29.aspx"" rel=""nofollow""><code>CERT_PUBLIC_KEY_INFO</code></a> which supposedly has what you need ) ... hope this helps :)</p>
","594","<c++><c><ssl><cryptoapi>","0","0","1","2015-05-19 20:48:14","","0","","3906760","","2015-05-19 20:48:14","2014-01-21 18:57:15",""
"9765145","Crypto API throws error while running in Japanese version OS (callng from .NET)","<p>I coded my application (Windows UI in .NET) on an English system locale. I have setup to encrypt/decrypt data which I did using the WinCrypto API in VC++, have referred this dll in my .NET application. This setup works well in English locale and fails in Japanese version.</p>

<p>I couldn't find issue in VC++ while I use unicode for this purpose. </p>

<p>I am getting exception in <code>CryptDecrypt()</code> method. It returns <code>0</code> when running in Japanese version. </p>

<pre><code>bRet = CryptDecrypt( hKey, 0, TRUE, 0, pbTargetBuffer, &amp;dwCryptDataLen ); 
</code></pre>

<p>This function works in En-US.</p>

<p>Is anything I missed at first look?</p>

<p><strong>Update</strong>: bRet is <code>0</code> and <code>GetLastError()</code> value is <code>2148073477</code>. Guess its bad data. But I am not sure about correcting my data. Its shows different characters (in C++ code) eventhough I passed correct ones from C#.</p>

<p>This is how I defined my function in C++:</p>

<pre><code>__declspec(dllexport) int DoDecryption( LPCTSTR chEncryptedData_i, 
                                        LPCTSTR chPassword_i, 
                                        unsigned char chDecryptedData_o[] )
{
    // ...
}
</code></pre>

<p>I have tried <code>char*</code> as well as <code>wchar_t*</code> instead of <code>LPCTSTR</code> . </p>
","","589","<c++><.net><cryptoapi>","0","","0","2012-03-20 19:57:28","","3","0","","user257111","2012-03-20 19:57:28","2012-03-19 04:46:45",""
"34366428","Diffie-Hellman (to RC4) with Wincrypt From Python","<p>I am currently working on a project written in C++ that leverages the CryptoAPI to perform a Diffie-Hellman key exchange. I'm having a bit of trouble getting this to work as the eventual RC4 session key I get cannot be used to encrypt the same text in Python (using pycrypto).</p>

<p>The C++ code to perform the Diffie-Hellman key exchange was taken from <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381969(v=vs.85).aspx"" rel=""nofollow noreferrer"">msdn</a>, but is included here for posterity:</p>

<pre><code>#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#pragma comment(lib, ""crypt32.lib"")

// The key size, in bits.
#define DHKEYSIZE 512

// Prime in little-endian format.
static const BYTE g_rgbPrime[] = 
{
    0x91, 0x02, 0xc8, 0x31, 0xee, 0x36, 0x07, 0xec, 
    0xc2, 0x24, 0x37, 0xf8, 0xfb, 0x3d, 0x69, 0x49, 
    0xac, 0x7a, 0xab, 0x32, 0xac, 0xad, 0xe9, 0xc2, 
    0xaf, 0x0e, 0x21, 0xb7, 0xc5, 0x2f, 0x76, 0xd0, 
    0xe5, 0x82, 0x78, 0x0d, 0x4f, 0x32, 0xb8, 0xcb,
    0xf7, 0x0c, 0x8d, 0xfb, 0x3a, 0xd8, 0xc0, 0xea, 
    0xcb, 0x69, 0x68, 0xb0, 0x9b, 0x75, 0x25, 0x3d,
    0xaa, 0x76, 0x22, 0x49, 0x94, 0xa4, 0xf2, 0x8d 
};

// Generator in little-endian format.
static BYTE g_rgbGenerator[] = 
{
    0x02, 0x88, 0xd7, 0xe6, 0x53, 0xaf, 0x72, 0xc5,
    0x8c, 0x08, 0x4b, 0x46, 0x6f, 0x9f, 0x2e, 0xc4,
    0x9c, 0x5c, 0x92, 0x21, 0x95, 0xb7, 0xe5, 0x58, 
    0xbf, 0xba, 0x24, 0xfa, 0xe5, 0x9d, 0xcb, 0x71, 
    0x2e, 0x2c, 0xce, 0x99, 0xf3, 0x10, 0xff, 0x3b,
    0xcb, 0xef, 0x6c, 0x95, 0x22, 0x55, 0x9d, 0x29,
    0x00, 0xb5, 0x4c, 0x5b, 0xa5, 0x63, 0x31, 0x41,
    0x13, 0x0a, 0xea, 0x39, 0x78, 0x02, 0x6d, 0x62
};

BYTE g_rgbData[] = {0x01, 0x02, 0x03, 0x04,    0x05, 0x06, 0x07, 0x08};

int _tmain(int argc, _TCHAR* argv[])
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    BOOL fReturn;
    HCRYPTPROV hProvParty1 = NULL; 
    HCRYPTPROV hProvParty2 = NULL; 
    DATA_BLOB P;
    DATA_BLOB G;
    HCRYPTKEY hPrivateKey1 = NULL;
    HCRYPTKEY hPrivateKey2 = NULL;
    PBYTE pbKeyBlob1 = NULL;
    PBYTE pbKeyBlob2 = NULL;
    HCRYPTKEY hSessionKey1 = NULL;
    HCRYPTKEY hSessionKey2 = NULL;
    PBYTE pbData = NULL;

    /************************
    Construct data BLOBs for the prime and generator. The P and G 
    values, represented by the g_rgbPrime and g_rgbGenerator arrays 
    respectively, are shared values that have been agreed to by both 
    parties.
    ************************/
    P.cbData = DHKEYSIZE/8;
    P.pbData = (BYTE*)(g_rgbPrime);

    G.cbData = DHKEYSIZE/8;
    G.pbData = (BYTE*)(g_rgbGenerator);

    /************************
    Create the private Diffie-Hellman key for party 1. 
    ************************/
    // Acquire a provider handle for party 1.
    fReturn = CryptAcquireContext(
        &amp;hProvParty1, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 1.
    fReturn = CryptGenKey(
        hProvParty1, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Create the private Diffie-Hellman key for party 2. 
    ************************/
    // Acquire a provider handle for party 2.
    fReturn = CryptAcquireContext(
        &amp;hProvParty2, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 2.
    fReturn = CryptGenKey(
        hProvParty2, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 1's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen1;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob1 = (PBYTE)malloc(dwDataLen1)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob1,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 2's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen2;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob2 = (PBYTE)malloc(dwDataLen2)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob2,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Party 1 imports party 2's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty1,
        pbKeyBlob2,
        dwDataLen2,
        hPrivateKey1,
        0,
        &amp;hSessionKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Party 2 imports party 1's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty2,
        pbKeyBlob1,
        dwDataLen1,
        hPrivateKey2,
        0,
        &amp;hSessionKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Convert the agreed keys to symmetric keys. They are currently of 
    the form CALG_AGREEDKEY_ANY. Convert them to CALG_RC4.
    ************************/
    ALG_ID Algid = CALG_RC4;

    // Enable the party 1 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey1,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Enable the party 2 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey2,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Encrypt some data with party 1's session key. 
    ************************/
    // Get the size.
    DWORD dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        NULL, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate a buffer to hold the encrypted data.
    pbData = (PBYTE)malloc(dwLength);
    if(!pbData)
    {
        goto ErrorExit;
    }

    // Copy the unencrypted data to the buffer. The data will be 
    // encrypted in place.
    memcpy(pbData, g_rgbData, sizeof(g_rgbData)); 

    // Encrypt the data.
    dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        pbData, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Decrypt the data with party 2's session key. 
    ************************/
    dwLength = sizeof(g_rgbData);
    fReturn = CryptDecrypt(
        hSessionKey2,
        0,
        TRUE,
        0,
        pbData,
        &amp;dwLength);
    if(!fReturn)
    {
        goto ErrorExit;
    }


ErrorExit:
    if(pbData)
    {
        free(pbData);
        pbData = NULL;
    }

    if(hSessionKey2)
    {
        CryptDestroyKey(hSessionKey2);
        hSessionKey2 = NULL;
    }

    if(hSessionKey1)
    {
        CryptDestroyKey(hSessionKey1);
        hSessionKey1 = NULL;
    }

    if(pbKeyBlob2)
    {
        free(pbKeyBlob2);
        pbKeyBlob2 = NULL;
    }

    if(pbKeyBlob1)
    {
        free(pbKeyBlob1);
        pbKeyBlob1 = NULL;
    }

    if(hPrivateKey2)
    {
        CryptDestroyKey(hPrivateKey2);
        hPrivateKey2 = NULL;
    }

    if(hPrivateKey1)
    {
        CryptDestroyKey(hPrivateKey1);
        hPrivateKey1 = NULL;
    }

    if(hProvParty2)
    {
        CryptReleaseContext(hProvParty2, 0);
        hProvParty2 = NULL;
    }

    if(hProvParty1)
    {
        CryptReleaseContext(hProvParty1, 0);
        hProvParty1 = NULL;
    }

    return 0;
}
</code></pre>

<p>I believe that I can complete the Diffie-Hellman key exchange in Python, as I can generate the same public and private keys without error. I've based my Diffie-Hellman key exchange on <a href=""https://github.com/lowazo/pyDHE/blob/master/DiffieHellman.py"" rel=""nofollow noreferrer"">this repository</a>.</p>

<p>I haven't been able to test this, however as I can't seem to get the shared secret exported from the C++ code (similar to <a href=""https://stackoverflow.com/questions/87694/im-using-wincrypt-for-diffie-hellman-can-i-export-the-shared-secret-in-plain"">this thread</a>, that was never satisfactorily answered). I can however get the RC4 session key with the following code:</p>

<pre><code>// Get the key length
DWORD keylen;
CryptExportKey(   
    hSessionKey1,
    NULL,    
    PLAINTEXTKEYBLOB,
    0,
    NULL,
    &amp;keylen);

// Get the session key
CryptExportKey(   
    hSessionKey1,
    NULL,     
    PLAINTEXTKEYBLOB,   
    0,  
    encKey,    
    &amp;keylen);
</code></pre>

<p>The output from this function gets me:</p>

<pre><code>08 02 00 00 01 68 00 00 10 00 00 00 75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b
</code></pre>

<p>I know there is a 12 byte header+length on this, so that leaves me with the following 16 byte RC4 session key:</p>

<pre><code>75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b
</code></pre>

<p>So I am currently trying to validate that I can encrypt the same plaintext using the RC4 that I have acquired from the <code>CryptExportKey</code>. I am currently trying to encrypt <code>g_rgbData</code> from the C++ code above, which is set to:</p>

<pre><code>BYTE g_rgbData[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
</code></pre>

<p>With the C++ code I get the following encrypted output:</p>

<pre><code>cc 94 aa ec 86 6e a8 26
</code></pre>

<p>Using pycrypto I have the following code:</p>

<pre><code>from Crypto.Cipher import ARC4
key = '75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b'
key = key.replace(' ', '').decode('hex')

plaintext = '0102030405060708'
plaintext = plaintext.replace(' ', '').decode('hex')

rc4 = ARC4.new(key)
encrypted = rc4.encrypt(plaintext)

print encrypted.encode('hex')
</code></pre>

<p>This results in the following output:</p>

<pre><code>00 5b 64 25 4e a5 62 e3
</code></pre>

<p>Which doesn't match the C++ output. I've played around with endianess, but I suspect something else might be going on. </p>

<p>Sorry if this is long winded, but it brings me to my two questions:</p>

<ol>
<li><p>Whenever you transition from the shared key to RC4 (using <code>CryptSetKeyParam</code> with <code>CALG_RC4</code>), what is actually going on under the hood here? I can't seem to find any information about this process anywhere so that I can implement it in Python.</p></li>
<li><p>Any idea why my RC4 will not work with the same key and the same plaintext in Python?</p></li>
</ol>

<p>Any help would be greatly appreciated!</p>
","<p>According to the PyCrypto <a href=""https://www.dlitz.net/software/pycrypto/api/current/Crypto.Cipher.ARC4-module.html"" rel=""nofollow"">docs</a> your key must be minimum 40 bytes:</p>

<blockquote>
  <p>key (byte string) - The secret key to use in the symmetric cipher. It can have any length, <strong>with a minimum of 40 bytes</strong>. Its cryptograpic strength is always capped to 2048 bits (256 bytes).</p>
</blockquote>

<p>but then there is a contradiction just above:</p>

<blockquote>
  <p>key_size = xrange(1, 257)</p>
  
  <p>Size of a key (in bytes)</p>
</blockquote>

<p>allowing key-lengths to be from 1-256, so I'm not sure if this even helps.</p>
","586","<python><c++><encryption><pycrypto><cryptoapi>","16","1","2","2015-12-22 01:30:50","34407142","5","3","-1","","2017-05-23 12:31:23","2015-12-19 01:50:53",""
"34366428","Diffie-Hellman (to RC4) with Wincrypt From Python","<p>I am currently working on a project written in C++ that leverages the CryptoAPI to perform a Diffie-Hellman key exchange. I'm having a bit of trouble getting this to work as the eventual RC4 session key I get cannot be used to encrypt the same text in Python (using pycrypto).</p>

<p>The C++ code to perform the Diffie-Hellman key exchange was taken from <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381969(v=vs.85).aspx"" rel=""nofollow noreferrer"">msdn</a>, but is included here for posterity:</p>

<pre><code>#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#pragma comment(lib, ""crypt32.lib"")

// The key size, in bits.
#define DHKEYSIZE 512

// Prime in little-endian format.
static const BYTE g_rgbPrime[] = 
{
    0x91, 0x02, 0xc8, 0x31, 0xee, 0x36, 0x07, 0xec, 
    0xc2, 0x24, 0x37, 0xf8, 0xfb, 0x3d, 0x69, 0x49, 
    0xac, 0x7a, 0xab, 0x32, 0xac, 0xad, 0xe9, 0xc2, 
    0xaf, 0x0e, 0x21, 0xb7, 0xc5, 0x2f, 0x76, 0xd0, 
    0xe5, 0x82, 0x78, 0x0d, 0x4f, 0x32, 0xb8, 0xcb,
    0xf7, 0x0c, 0x8d, 0xfb, 0x3a, 0xd8, 0xc0, 0xea, 
    0xcb, 0x69, 0x68, 0xb0, 0x9b, 0x75, 0x25, 0x3d,
    0xaa, 0x76, 0x22, 0x49, 0x94, 0xa4, 0xf2, 0x8d 
};

// Generator in little-endian format.
static BYTE g_rgbGenerator[] = 
{
    0x02, 0x88, 0xd7, 0xe6, 0x53, 0xaf, 0x72, 0xc5,
    0x8c, 0x08, 0x4b, 0x46, 0x6f, 0x9f, 0x2e, 0xc4,
    0x9c, 0x5c, 0x92, 0x21, 0x95, 0xb7, 0xe5, 0x58, 
    0xbf, 0xba, 0x24, 0xfa, 0xe5, 0x9d, 0xcb, 0x71, 
    0x2e, 0x2c, 0xce, 0x99, 0xf3, 0x10, 0xff, 0x3b,
    0xcb, 0xef, 0x6c, 0x95, 0x22, 0x55, 0x9d, 0x29,
    0x00, 0xb5, 0x4c, 0x5b, 0xa5, 0x63, 0x31, 0x41,
    0x13, 0x0a, 0xea, 0x39, 0x78, 0x02, 0x6d, 0x62
};

BYTE g_rgbData[] = {0x01, 0x02, 0x03, 0x04,    0x05, 0x06, 0x07, 0x08};

int _tmain(int argc, _TCHAR* argv[])
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    BOOL fReturn;
    HCRYPTPROV hProvParty1 = NULL; 
    HCRYPTPROV hProvParty2 = NULL; 
    DATA_BLOB P;
    DATA_BLOB G;
    HCRYPTKEY hPrivateKey1 = NULL;
    HCRYPTKEY hPrivateKey2 = NULL;
    PBYTE pbKeyBlob1 = NULL;
    PBYTE pbKeyBlob2 = NULL;
    HCRYPTKEY hSessionKey1 = NULL;
    HCRYPTKEY hSessionKey2 = NULL;
    PBYTE pbData = NULL;

    /************************
    Construct data BLOBs for the prime and generator. The P and G 
    values, represented by the g_rgbPrime and g_rgbGenerator arrays 
    respectively, are shared values that have been agreed to by both 
    parties.
    ************************/
    P.cbData = DHKEYSIZE/8;
    P.pbData = (BYTE*)(g_rgbPrime);

    G.cbData = DHKEYSIZE/8;
    G.pbData = (BYTE*)(g_rgbGenerator);

    /************************
    Create the private Diffie-Hellman key for party 1. 
    ************************/
    // Acquire a provider handle for party 1.
    fReturn = CryptAcquireContext(
        &amp;hProvParty1, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 1.
    fReturn = CryptGenKey(
        hProvParty1, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 1's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey1,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Create the private Diffie-Hellman key for party 2. 
    ************************/
    // Acquire a provider handle for party 2.
    fReturn = CryptAcquireContext(
        &amp;hProvParty2, 
        NULL,
        MS_ENH_DSS_DH_PROV,
        PROV_DSS_DH, 
        CRYPT_VERIFYCONTEXT);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Create an ephemeral private key for party 2.
    fReturn = CryptGenKey(
        hProvParty2, 
        CALG_DH_EPHEM, 
        DHKEYSIZE &lt;&lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN,
        &amp;hPrivateKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the prime for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_P,
        (PBYTE)&amp;P,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Set the generator for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_G,
        (PBYTE)&amp;G,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Generate the secret values for party 2's private key.
    fReturn = CryptSetKeyParam(
        hPrivateKey2,
        KP_X,
        NULL,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 1's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen1;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob1 = (PBYTE)malloc(dwDataLen1)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey1,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob1,
        &amp;dwDataLen1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Export Party 2's public key.
    ************************/
    // Public key value, (G^X) mod P is calculated.
    DWORD dwDataLen2;

    // Get the size for the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        NULL,
        PUBLICKEYBLOB,
        0,
        NULL,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate the memory for the key BLOB.
    if(!(pbKeyBlob2 = (PBYTE)malloc(dwDataLen2)))
    { 
        goto ErrorExit;
    }

    // Get the key BLOB.
    fReturn = CryptExportKey(
        hPrivateKey2,
        0,
        PUBLICKEYBLOB,
        0,
        pbKeyBlob2,
        &amp;dwDataLen2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Party 1 imports party 2's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty1,
        pbKeyBlob2,
        dwDataLen2,
        hPrivateKey1,
        0,
        &amp;hSessionKey2);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Party 2 imports party 1's public key.
    The imported key will contain the new shared secret 
    key (Y^X) mod P. 
    ************************/
    fReturn = CryptImportKey(
        hProvParty2,
        pbKeyBlob1,
        dwDataLen1,
        hPrivateKey2,
        0,
        &amp;hSessionKey1);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Convert the agreed keys to symmetric keys. They are currently of 
    the form CALG_AGREEDKEY_ANY. Convert them to CALG_RC4.
    ************************/
    ALG_ID Algid = CALG_RC4;

    // Enable the party 1 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey1,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Enable the party 2 public session key for use by setting the 
    // ALGID.
    fReturn = CryptSetKeyParam(
        hSessionKey2,
        KP_ALGID,
        (PBYTE)&amp;Algid,
        0);
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Encrypt some data with party 1's session key. 
    ************************/
    // Get the size.
    DWORD dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        NULL, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }

    // Allocate a buffer to hold the encrypted data.
    pbData = (PBYTE)malloc(dwLength);
    if(!pbData)
    {
        goto ErrorExit;
    }

    // Copy the unencrypted data to the buffer. The data will be 
    // encrypted in place.
    memcpy(pbData, g_rgbData, sizeof(g_rgbData)); 

    // Encrypt the data.
    dwLength = sizeof(g_rgbData);
    fReturn = CryptEncrypt(
        hSessionKey1, 
        0, 
        TRUE,
        0, 
        pbData, 
        &amp;dwLength,
        sizeof(g_rgbData));
    if(!fReturn)
    {
        goto ErrorExit;
    }

    /************************
    Decrypt the data with party 2's session key. 
    ************************/
    dwLength = sizeof(g_rgbData);
    fReturn = CryptDecrypt(
        hSessionKey2,
        0,
        TRUE,
        0,
        pbData,
        &amp;dwLength);
    if(!fReturn)
    {
        goto ErrorExit;
    }


ErrorExit:
    if(pbData)
    {
        free(pbData);
        pbData = NULL;
    }

    if(hSessionKey2)
    {
        CryptDestroyKey(hSessionKey2);
        hSessionKey2 = NULL;
    }

    if(hSessionKey1)
    {
        CryptDestroyKey(hSessionKey1);
        hSessionKey1 = NULL;
    }

    if(pbKeyBlob2)
    {
        free(pbKeyBlob2);
        pbKeyBlob2 = NULL;
    }

    if(pbKeyBlob1)
    {
        free(pbKeyBlob1);
        pbKeyBlob1 = NULL;
    }

    if(hPrivateKey2)
    {
        CryptDestroyKey(hPrivateKey2);
        hPrivateKey2 = NULL;
    }

    if(hPrivateKey1)
    {
        CryptDestroyKey(hPrivateKey1);
        hPrivateKey1 = NULL;
    }

    if(hProvParty2)
    {
        CryptReleaseContext(hProvParty2, 0);
        hProvParty2 = NULL;
    }

    if(hProvParty1)
    {
        CryptReleaseContext(hProvParty1, 0);
        hProvParty1 = NULL;
    }

    return 0;
}
</code></pre>

<p>I believe that I can complete the Diffie-Hellman key exchange in Python, as I can generate the same public and private keys without error. I've based my Diffie-Hellman key exchange on <a href=""https://github.com/lowazo/pyDHE/blob/master/DiffieHellman.py"" rel=""nofollow noreferrer"">this repository</a>.</p>

<p>I haven't been able to test this, however as I can't seem to get the shared secret exported from the C++ code (similar to <a href=""https://stackoverflow.com/questions/87694/im-using-wincrypt-for-diffie-hellman-can-i-export-the-shared-secret-in-plain"">this thread</a>, that was never satisfactorily answered). I can however get the RC4 session key with the following code:</p>

<pre><code>// Get the key length
DWORD keylen;
CryptExportKey(   
    hSessionKey1,
    NULL,    
    PLAINTEXTKEYBLOB,
    0,
    NULL,
    &amp;keylen);

// Get the session key
CryptExportKey(   
    hSessionKey1,
    NULL,     
    PLAINTEXTKEYBLOB,   
    0,  
    encKey,    
    &amp;keylen);
</code></pre>

<p>The output from this function gets me:</p>

<pre><code>08 02 00 00 01 68 00 00 10 00 00 00 75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b
</code></pre>

<p>I know there is a 12 byte header+length on this, so that leaves me with the following 16 byte RC4 session key:</p>

<pre><code>75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b
</code></pre>

<p>So I am currently trying to validate that I can encrypt the same plaintext using the RC4 that I have acquired from the <code>CryptExportKey</code>. I am currently trying to encrypt <code>g_rgbData</code> from the C++ code above, which is set to:</p>

<pre><code>BYTE g_rgbData[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
</code></pre>

<p>With the C++ code I get the following encrypted output:</p>

<pre><code>cc 94 aa ec 86 6e a8 26
</code></pre>

<p>Using pycrypto I have the following code:</p>

<pre><code>from Crypto.Cipher import ARC4
key = '75 2c 59 8c 6e e0 8c 9f ed 30 17 7e 9d a5 85 2b'
key = key.replace(' ', '').decode('hex')

plaintext = '0102030405060708'
plaintext = plaintext.replace(' ', '').decode('hex')

rc4 = ARC4.new(key)
encrypted = rc4.encrypt(plaintext)

print encrypted.encode('hex')
</code></pre>

<p>This results in the following output:</p>

<pre><code>00 5b 64 25 4e a5 62 e3
</code></pre>

<p>Which doesn't match the C++ output. I've played around with endianess, but I suspect something else might be going on. </p>

<p>Sorry if this is long winded, but it brings me to my two questions:</p>

<ol>
<li><p>Whenever you transition from the shared key to RC4 (using <code>CryptSetKeyParam</code> with <code>CALG_RC4</code>), what is actually going on under the hood here? I can't seem to find any information about this process anywhere so that I can implement it in Python.</p></li>
<li><p>Any idea why my RC4 will not work with the same key and the same plaintext in Python?</p></li>
</ol>

<p>Any help would be greatly appreciated!</p>
","<p>Finally had some time to look over your code. When I run your code locally, I am able to export the session key and can use it successfully in pycrypto. My guess is that you are either not exporting the session key correctly (e.g. is what you posted what you are running?) or the data you are encrypting in C++ is not the same data that you are encrypting in Python - double check that the data you are encrypting is also correct. I suspect that it's probably the latter, as there isn't really much you can screw up with the <code>CryptExportKey</code> you've posted.</p>
","586","<python><c++><encryption><pycrypto><cryptoapi>","16","6","2","2015-12-22 01:30:50","34407142","5","3","-1","","2017-05-23 12:31:23","2015-12-19 01:50:53",""
"14371263","Problems to import RSA key in other computer","<p>I am creating a little tool for encrypt and decrypt using a pair keys (public and private keys).
I export public and private key on my computer and I can encrypt and decrypt files without problems. I have problem when I try decrypt files in other machine with the same public key. </p>

<pre><code>// initializing CSP HCRYPTPROV hProv; HCRYPTKEY hKey;

if(!CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, 0)){  if(GetLastError() == NTE_BAD_KEYSET){       if (!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)){          return FALSE;       }   } }

// create a pair keys if (!CryptGenKey(hProv, AT_KEYEXCHANGE,  CRYPT_ARCHIVABLE, &amp;hKey))    return FALSE;

// public key if (!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, sizePublicKey))  return FALSE;

*publicKey = (BYTE *) LocalAlloc(LPTR, *sizePublicKey * sizeof(DWORD)); if(*publicKey == NULL)  return FALSE;

if (!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, *publicKey, sizePublicKey))  return FALSE; // save public key on file

// private key if (!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, sizePrivateKey))   return FALSE;

*privateKey = (BYTE *) LocalAlloc(LPTR, *sizePrivateKey * sizeof(DWORD)); if(*publicKey == NULL)    return FALSE;

if (!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, *privateKey, sizePrivateKey))   return FALSE;

PrivateKey.key = (BYTE *) LocalAlloc(LPTR, *sizePrivateKey * sizeof(DWORD)); if(*publicKey == NULL)     return FALSE; // save private key on file


//I encrypt file using  if(!CryptEncrypt(hKey, 0, TRUE, 0, cache, &amp;sizeCache, BLOCK_SIZE_ENCRYPT)){
                free(cache);
                return FALSE;           }

//To decrypt file //First import public key

CryptImportKey(hProv, publicKey, sizePublicKey, 0, 0, &amp;hKey)

//To decrypt:           if (!CryptDecrypt(hKey, 0, TRUE, 0, cache, &amp;sizeCache)){
                free(cache);
                return FALSE;           }
</code></pre>

<p>In the same computer that key ware created the application encrypt and decrypt correctly but if I try decrypt files in other computer the CryptDecrypt() failed with error 80090003 (error got by GetLastError())
Any idea? what am I doing wrong...?
How to I can export the public key to other computer?
Thanks!</p>
","<p>Probably you are not exporting the key, just using the CSP containing the key, while you are in the same computer, the key is stored in the container where you ""link"" by using the cryptoapi. Once you go to other computer the container is not present, so you can not use the key.</p>

<p>Make sure that the Private Key is exportable.</p>
","586","<c++><c><winapi><cryptoapi><rsacryptoserviceprovider>","0","0","1","2013-04-27 00:29:58","","2","","2125578","","2013-04-27 00:29:58","2013-01-17 02:28:39",""
"24513020","How to import a session key created using openssl command line into Windows CryptoAPI","<p>I want to import session key and decrypt data in Windows CryptoAPI. The session key and encrypted data created by openssl commands.</p>

<p>On linux:</p>

<pre><code>% openssl enc -e -aes-128-cbc -kfile randtxt -in text.txt -out text.enc -nosalt -p &gt; session.dat
</code></pre>

<p>The <code>session.dat</code> looks like this:</p>

<pre><code>key = 1234567890ABCDEF1234567890ABCDEF

iv = 0102030405060708090A0B0C0D0E0F00
</code></pre>

<p>I want to decrypt this data - in <code>text.enc</code> - in a Windows application.</p>

<p>How to import the session key using <code>CryptImportKey</code> (or otherwise) to decrypt the data?</p>
","<p>There is a <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382383%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">specific page on MSDN</a> that explains how to import plain text keys. It uses <code>CryptImportKey</code> directly, but you may have a different configuration or context, so try and match it against the example.</p>

<p>It also tells you that it uses <code>PLAINTEXTKEYBLOB</code> but as I did not see any code reference to it, I'm not sure that this is true. The example is for a DES key.</p>

<p>To show how this can be done for AES keys, try <a href=""https://stackoverflow.com/q/842357/589259"">this Q/A</a>. Probably best to try and convert this code to AES-128 bit keys first.</p>
","584","<encryption><openssl><cryptoapi>","2","2","2","2014-07-02 13:18:18","24516099","2","","589259","","2014-07-01 17:05:26","2014-07-01 14:39:16",""
"24513020","How to import a session key created using openssl command line into Windows CryptoAPI","<p>I want to import session key and decrypt data in Windows CryptoAPI. The session key and encrypted data created by openssl commands.</p>

<p>On linux:</p>

<pre><code>% openssl enc -e -aes-128-cbc -kfile randtxt -in text.txt -out text.enc -nosalt -p &gt; session.dat
</code></pre>

<p>The <code>session.dat</code> looks like this:</p>

<pre><code>key = 1234567890ABCDEF1234567890ABCDEF

iv = 0102030405060708090A0B0C0D0E0F00
</code></pre>

<p>I want to decrypt this data - in <code>text.enc</code> - in a Windows application.</p>

<p>How to import the session key using <code>CryptImportKey</code> (or otherwise) to decrypt the data?</p>
","<p>i could import session key like this.</p>

<pre><code>BYTE pbBuffer[] = { 0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF, 0x12, 0x34
    , 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF };
BYTE iv[] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x0A
    , 0x0B, 0x0C, 0x0D, 0x0E, 0x0F };
HCRYPTPROV hProvider;
HCRYPTKEY hKey;

struct KEYBLOB {
    BLOBHEADER bh;
    DWORD dwKeyLen;
    BYTE bytes[16];
}blob;

blob.bh.bType = PLAINTEXTKEYBLOB;
blob.bh.reserved = 0;
blob.bh.bVersion = CUR_BLOB_VERSION;
blob.bh.aiKeyAlg = CALG_AES_128;
blob.dwKeyLen = 16;
memcpy(blob.bytes, pbBuffer, 16);


if (!CryptAcquireContext(&amp;hProvider, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {
    printf(""CryptAcquireContext Error\n"");
    return FALSE;
}

if (!CryptImportKey(hProvider, (BYTE*)&amp;blob, sizeof(KEYBLOB), NULL, CRYPT_NO_SALT, &amp;hKey)){
    printf(""CryptImportKey Error\n"");
    CryptReleaseContext(hProvider, 0);
    return FALSE;
}

if (!CryptSetKeyParam(hKey, KP_IV, iv, 0)){
    printf(""CryptSetKeyParam2 Error\n"");
    CryptDestroyKey(hKey);
    CryptReleaseContext(hProvider, 0);
    return FALSE;
}

BYTE pbDataBuff[1024 * 2 + 1];
DWORD dwSize, dwWritten;
HANDLE hEncryptFile, hDecryptFile;
BOOL bEnd;

hEncryptFile = CreateFile(_T(""data.aes""), GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
hDecryptFile = CreateFile(_T(""outdata.txt""), GENERIC_WRITE, FILE_SHARE_READ, NULL,
    CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

while (1) {
    ReadFile(hEncryptFile, pbDataBuff, 1024 * 2, &amp;dwSize, NULL);
    if (dwSize &lt; 1024 * 2)
        bEnd = TRUE;
    else
        bEnd = FALSE;
    if (!CryptDecrypt(hKey, 0, bEnd, 0, pbDataBuff, &amp;dwSize)) {
        printf(""CryptDecrypt Error\n"");
        CryptDestroyKey(hKey);
        CryptReleaseContext(hProvider, 0);
        CloseHandle(hEncryptFile);
        CloseHandle(hDecryptFile);
        return FALSE;
    }
    WriteFile(hDecryptFile, pbDataBuff, dwSize, &amp;dwWritten, NULL);

    if (bEnd)
        break;
}
CryptDestroyKey(hKey);
CryptReleaseContext(hProvider, 0);
CloseHandle(hEncryptFile);
CloseHandle(hDecryptFile);
return TRUE;
</code></pre>
","584","<encryption><openssl><cryptoapi>","2","2","2","2014-07-02 13:18:18","24516099","2","","589259","","2014-07-01 17:05:26","2014-07-01 14:39:16",""
"18005884","Decrypt CryptoAPI SIMPLEBLOB in Java","<p>Here is my process:</p>

<p>CryptoAPI:</p>

<ol>
<li>Generate AES session key</li>
<li>Use recipient's public key to encrypt and export (1) in a SIMPLEBLOB
with RSA</li>
<li>Send SIMPLEBLOB to recipient</li>
</ol>

<p>Java:</p>

<ol>
<li>Recipient receives (3)</li>
<li>Recipient wants to decrypt SIMPLEBLOB using his private key</li>
</ol>

<p>This is pretty standard I believe. There is a need to byte reverse the received byte array (from step 4 above). However, for some reason, the number of bytes received is above the maximum allowable number of bytes that RSA algorithm can decrypt. The error is ""javax.crypto.IllegalBlockSizeException: Data must not be longer than 256 bytes"". So there is something else going on that I don't understand. Can someone explain how to properly decrypt the SIMPLEBLOB in Java? Resources would help.</p>
","<p>Have a look at this page: <a href=""http://msdn.microsoft.com/en-us/library/ee442763.aspx"" rel=""nofollow"">SIMPLEBLOB structure</a>
The first 12 Bytes of the blob belong to <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa387453%28v=vs.85%29.aspx"" rel=""nofollow"">BLOBHEADER</a>. To decrypt the key, start from the 12th position of the encrypted blob.</p>
","581","<java><c++><encryption><cryptoapi>","0","0","1","2013-09-25 10:32:28","19002327","4","","","","","2013-08-01 22:42:08",""
"15770240","Efficient RC6 and Mars encryption algorithm implementions","<p>I am running linux kernel 2.6.32 which does not provide rc6 and mars encryption algorithms in its crypto API and I need to embed these algorithms as kernel modules and register them in linux's crypto API. </p>

<p>One way is to write my own implementation of these algorithms but I dont want to re-invent the wheel so I need to know whether there is any widely used implemention of these algos in C? I know there cant be a definite answer to this one but still if any of you gurus can tell me about some of the best open source implementations. It would be very helpful for me. </p>

<p>Thanks in advance.</p>
","","580","<c><linux><encryption><linux-kernel><cryptoapi>","0","","0","2013-04-02 17:17:46","","7","","","","","2013-04-02 17:17:46",""
"12530612","OpenSSL decrypted text length","<p>I am using this simple function for decrypting a AES Encrypted string</p>

<pre><code>unsigned char *aes_decrypt(EVP_CIPHER_CTX *e, unsigned char *ciphertext, int *len)
{
  int p_len = *len, f_len = 0;
  unsigned char *plaintext = (unsigned char*)malloc(p_len + 128);
  memset(plaintext,0,p_len);
  EVP_DecryptInit_ex(e, NULL, NULL, NULL, NULL);
  EVP_DecryptUpdate(e, plaintext, &amp;p_len, ciphertext, *len);
  EVP_DecryptFinal_ex(e, plaintext+p_len, &amp;f_len);

  *len = p_len + f_len;
  return plaintext;
}
</code></pre>

<p>The problem is that len is returning a value that does not match the entire decoded string. What could be the problem ?</p>
","<p>When you say ""string"", I assume you mean a zero-terminated textual string.  The encryption process is dependent on a cipher block size, and oftentimes padding.  What's actually being encoded and decoded is up to the application... it's all binary data to the cipher.  If you're textual string is smaller than what's returned from the decrypt process, your application needs to determine the useful part.  So for example if you KNOW your string inside the results is zero-terminated, you can get the length doing a simple strlen.  That's risky of course if you can't guarantee the input... probably better off searching the results for a null up to the decoded length...</p>
","576","<c++><linux><openssl><aes><cryptoapi>","0","2","2","2012-10-16 05:48:42","12531199","0","","","","","2012-09-21 12:25:45",""
"12530612","OpenSSL decrypted text length","<p>I am using this simple function for decrypting a AES Encrypted string</p>

<pre><code>unsigned char *aes_decrypt(EVP_CIPHER_CTX *e, unsigned char *ciphertext, int *len)
{
  int p_len = *len, f_len = 0;
  unsigned char *plaintext = (unsigned char*)malloc(p_len + 128);
  memset(plaintext,0,p_len);
  EVP_DecryptInit_ex(e, NULL, NULL, NULL, NULL);
  EVP_DecryptUpdate(e, plaintext, &amp;p_len, ciphertext, *len);
  EVP_DecryptFinal_ex(e, plaintext+p_len, &amp;f_len);

  *len = p_len + f_len;
  return plaintext;
}
</code></pre>

<p>The problem is that len is returning a value that does not match the entire decoded string. What could be the problem ?</p>
","<p>If you are using cipher in ECB, CBC or some other chaining modes, you must pad plain text to the length, which is multiple of cipher block length. You can see a PKCS#5 standard for example. High-level functions like in OpenSSL can perform padding transparently for programmer. So, encrypted text can be larger than plain text up to additional cipher block size.</p>
","576","<c++><linux><openssl><aes><cryptoapi>","0","1","2","2012-10-16 05:48:42","12531199","0","","","","","2012-09-21 12:25:45",""
"21701571","ECDSA signing and verification in windows and linux","<p>This is continuation of my previous post (<a href=""https://stackoverflow.com/questions/20992760/understanding-bcryptsignhash-output-signature"">Understanding BCryptSignHash output signature</a>).</p>

<p>Let me clearly state my problem:</p>

<ol>
<li>I need to sign a data in windows application level.</li>
<li>I need to verify the same in linux application level and windows driver (that i have wrote).</li>
</ol>

<p>I tried following:</p>

<ol>
<li><p>Using CryptoAPI, i was able to sign in windows application level and verify in the windows driver. In linux, i tried to use simpleECDSA (<a href=""http://jonasfj.dk/blog/2007/12/simpleecdsa-a-simple-implementation-of-ecdsa-in-c/"" rel=""nofollow noreferrer"">http://jonasfj.dk/blog/2007/12/simpleecdsa-a-simple-implementation-of-ecdsa-in-c/</a>) to verify the signature (generated using cryptoAPI). I was able to convert the binary key blobs from cryptoAPI in simpleECDSA but could not interpret the signature.</p></li>
<li><p>Using Crypto++ library, i was able to sign in windows application level and verify in linux application level but could not use the same to verify in windows driver.</p></li>
</ol>

<p>Kindly let me know if there is a library available or a way that i could use the same public/private key and signature across windows application/driver and linux.</p>

<p>Am new to cryptography hence forgive my naiveness.</p>

<p>Thanks,</p>

<p>F</p>
","","568","<linux><windows><cryptoapi><crypto++>","2","","0","2014-02-11 12:14:04","","11","","-1","","2017-05-23 11:59:09","2014-02-11 12:14:04",""
"20648110","How to determine which personal certificate comes from hardware device in C#?","<p>Assuming I have multiple personal certificates for current user. But only one certificate belongs to Aladdin eToken.</p>

<p>I want to determine which certificate belongs to Aladdin eToken.</p>

<p>Should I use <code>X509Store</code> and <code>X509Crtificate</code> for this?</p>

<p>Should I try eToken SDK?</p>
","<p>This depends on how Aladdin eToken signs certificates. If it issues an X509 Certificate with the Issuer field set to something identifiable (e.g. Aladdin eToken) then you should be able to find the certificate that way.</p>

<pre><code>// Get the MY store for the current user
X509Store store = new X509Store(StoreName.My, StoreLocation.CurrentUser);

store.Open(OpenFlags.ReadOnly);

X509Certificate2Collection certs = 
    store.Certificates.Find(X509FindType.FindByIssuerName,
                            ""Aladdin eToken"");
</code></pre>

<p>That should get you all certificates which have the string ""Aladdin eToken"" in the issuer name. If you need to use different criteria to identify the certificate, there are heaps of other valid arguments you can pass the <code>Find</code> method of the <code>Certificates</code> collection to get matches.</p>

<p>For example, if you're looking for a specific certificate, you can <code>FindByThumbprint</code> or <code>FindBySerialNumber</code>.</p>
","558","<c#><x509certificate><cryptoapi><e-token>","3","-1","1","2018-02-21 16:04:50","","0","","382","","2018-02-21 16:04:50","2013-12-18 01:31:30",""
"28777582","Reading Certificate Data from Signed Executables with Multiple Signatures","<p>Microsoft is moving away from SHA1. As a result many executables now have two or more signatures; one using a SHA1 digest for backward compatibility and one using a SHA256.</p>

<p>For example if you look at the properties of <code>vstest.executionengine.exe</code> from Visual Studio 2013 (look at the properties on Windows 8 or Server 2012) you'll see it has 3 different signatures from 3 different certificates.</p>

<p>I already have code that uses a combination of <code>CryptQueryObject</code>, <code>CryptMsgGetParam</code>, and .NET <code>SignedCms</code>, but it only sees 1 of the 3 signatures. There appears to be only one message with one signer.</p>

<p>I need to get the certificate information for all signatures. How are multiple signatures modeled - is it multiple messages, or multiple signers in a single message? Did Microsoft add new APIs or new flags to access multiple signatures?</p>
","<p>It turns out that Microsoft (sort of) hides subsequent signatures.  When adding another signature, the entire CMS structure is added as an unsigned attribute.</p>

<p>So for example a dual-signed Authenticode signature decoded as a .NET SignedCms will have one signer, and that SignerInfo will have a value in UnsignedAttributes.  If you take the attribute ASN RawData value and pass it to SignedCms.Decode, you get the second signature.</p>

<pre><code>// decode inner signature    
signedCms2.Decode(signedCms1.SignerInfos[0].UnsignedAttributes[0].Values[0].RawData);
</code></pre>

<p>It also appears that instead of adding another attribute to the root signature signer, the attribute is added in the inner-most signers attributes.</p>

<p>Also note that not all attributes are inner signatures, I think you need to check for a proper Oid on the attribute.</p>

<p>Is suspect that this was the best way for Microsoft to keep backward compatibility.</p>
","551","<digital-signature><sha1><sha256><cryptoapi><authenticode>","4","6","1","2015-05-08 22:10:14","","0","2","13302","","2015-02-28 08:32:59","2015-02-28 02:53:24",""
"15877325","Import DER encoded public key using crypto API","<p>Is it possible to import DER encoded public key using MS crypto API? So i can verfiy signatures ?
I need a piece of code or help for MS Crypto API for importing DER encoded public-key/certificate.</p>
","<p>Following three steps will allow you to import your public key certificate</p>

<ol>
<li><p>Get the certificate context using <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/aa376033%28v=vs.85%29.aspx"" rel=""nofollow"">CertCreateCertificateContext</a></p></li>
<li><p>Open the other people certificate store with <a href=""http://msdn.microsoft.com/en-gb/library/windows/desktop/aa376559%28v=vs.85%29.aspx"" rel=""nofollow"">CertOpenStore</a> for ADDRESSBOOK</p></li>
<li><p>Add the certificate context to the other people certificate store using <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa376009%28v=vs.85%29.aspx"" rel=""nofollow"">CertAddCertificateContextToStore</a> </p></li>
</ol>
","546","<windows><rsa><public-key><cryptoapi><der>","2","2","1","2014-08-24 22:01:39","","0","","608639","","2014-08-24 22:01:39","2013-04-08 10:54:23",""
"9426418","How to read pkcs#7 file properly","<p>I have a file with detached pkcs#7 signature of size 267 bytes. I create it after executing </p>

<pre><code>CryptSignMessage(
    &amp;SigParams,
    TRUE,
    1,
    MessageArray,
    MessageSizeArray,
    pbSignedMessageBlob,
    &amp;cbSignedMessageBlob)
</code></pre>

<p>function and then I write content of pbSignedMessageBlob:</p>

<pre><code>pbSignedMessageBlob[cbSignedMessageBlob] = '\0';
 FILE *file;
 file = fopen(""c:\\path\\sign_pkcs7.pk7"", ""wb"");
 fwrite(pbSignedMessageBlob, sizeof(BYTE), cbSignedMessageBlob, file);
 fclose(file);
</code></pre>

<p>Then I try to verify this signature and read this file:</p>

<pre><code>BYTE *pkcsContent;
FILE *file3;
file3 = fopen(""c:\\users\\timur\\desktop\\sign_pkcs7.pk7"", ""rb"");
pkcsContent = MyReadFile(file3, cbArray);
BYTE* MyReadFile(FILE *f, DWORD &amp;len)
{
    size_t result;
    BYTE *buffer;
    if (f == NULL) 
    {
        fputs (""File error"", stderr); 
        exit (1);
    }

fseek (f, 0, SEEK_END);
len = ftell (f);
rewind (f);

//buffer = (BYTE*) malloc (sizeof(char)*lSize);
buffer = new BYTE[len + 1];
if (buffer == NULL) 
{
    fputs (""Memory error"", stderr); 
    exit (2);
}

result = fread (buffer, 1, len, f);
if (result != len) 
{
    fputs (""Reading error"",stderr); 
    exit (3);
}
buffer[len] = '\0';

fclose (f);

    return buffer;
}
</code></pre>

<p>But the file content I get into pkcsContent is only 37 bytes length.
I also tried to manage files using std::fstream, but result is the same. Maybe the way I'm writing file to disk is wrong?</p>
","<p>Are you trying to compute the length of <code>pkcsContent</code> with <code>strlen</code> (this is my guess since you're null-terminating the buffer in <code>MyReadFil</code>)? You can't do that because PKCS#7 is binary data and it can contain 0 anywhere.</p>
","542","<c++><io><cryptoapi><pkcs#7>","0","0","1","2012-02-24 07:20:01","","0","","983507","","2012-02-24 06:40:38","2012-02-24 06:32:45",""
"41136495","After adding js file with the custom module in magento,checkout page is not working","<p>I want to add the js file along with the custom module.After adding it in layout file of my module.Payment method stop to work.Can somebody tell me what is the problem.
here is the code-
custom_layout.xml</p>

<pre><code>     &lt;?xml version=""1.0""?&gt;
     &lt;layout version=""0.1.0""&gt;
     &lt;default&gt;
     &lt;reference name=""head""&gt;
     &lt;action method=""addJs""&gt;&lt;script&gt;custom_module/crypto.js&lt;/script&gt;
     &lt;/action&gt;   
     &lt;/reference&gt;
     &lt;/default&gt;
     &lt;/layout&gt;
</code></pre>

<p>config.xml</p>

<pre><code>    &lt;frontend&gt;
    &lt;layout&gt;
    &lt;updates&gt;
     &lt;ideal&gt;
     &lt;file&gt;custom_layout.xml&lt;/file&gt;
        &lt;/ideal&gt;
    &lt;/updates&gt;
     &lt;/layout&gt;
     &lt;/frontend&gt;
</code></pre>

<p>After adding crypto js,it is available in header but checkout page is not working.here is the screenshots-
<a href=""https://i.stack.imgur.com/eSTxb.png"" rel=""nofollow noreferrer"">screenshot of console</a></p>

<p><a href=""https://i.stack.imgur.com/MqZpk.png"" rel=""nofollow noreferrer"">screenshot of non clickable checkout page</a></p>
","<p>I think its conflict issue so you can add group of js like</p>

<pre><code>&lt;action  method=""addItem""&gt;
&lt;type&gt;js&lt;/type&gt;&lt;name&gt;custom_module/crypto.js&lt;/name&gt;
&lt;group&gt;cust_js&lt;/group&gt;
&lt;/action&gt;
</code></pre>

<p>try to add js mentioned as above. This will fix conflict issue hope its help :)</p>
","535","<javascript><magento-1.9><cryptoapi><cryptojs>","0","2","1","2017-01-17 07:18:15","","0","","","","","2016-12-14 06:54:25",""
"7480677","AES decryption not working please help","<p>I am doing AES Encryption and decryption in program. I am not able to get the plain text when i decrypt. My code ins as follows...</p>

<pre><code>- (NSData *)aesEncrypt:(NSString *)key data:(NSData *)data
{  
    // 'key' should be 32 bytes for AES256, will be null-padded otherwise  
    char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)  
    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)   // fetch key data  
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];   
    NSUInteger dataLength = [data length];   
    //See the doc: For block ciphers, the output size will always be less than or equal to the input size plus the size of one block.  //That's why we need to add the size of one block here  
    size_t bufferSize = dataLength + kCCBlockSizeAES128;  
    void *buffer = malloc(bufferSize);   
    size_t numBytesEncrypted = 0;     
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, 
                                          kCCAlgorithmAES128, 
                                          kCCOptionPKCS7Padding,
                                          keyPtr, kCCKeySizeAES256,
                                          NULL /* initialization vector (optional) */,             
                                          [data bytes], 
                                          dataLength, /* input */             
                                          buffer, bufferSize, /* output */             &amp;
                                          numBytesEncrypted);  
    if (cryptStatus == kCCSuccess) 
    {   
        //the returned NSData takes ownership of the buffer and will free it on deallocation   
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];  
    }   
    free(buffer); //free the buffer;  
    return nil; 
} 

- (NSData *)aesDecrypt:(NSString *)key data:(NSData *)data
{  
    // 'key' should be 32 bytes for AES256, will be null-padded otherwise  
    char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)  
    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)   // fetch key data  
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];   
    NSUInteger dataLength = [data length];   
    //See the doc: For block ciphers, the output size will always be less than or equal to the input size plus the size of one block.  //That's why we need to add the size of one block here  
    size_t bufferSize = dataLength + kCCBlockSizeAES128;  
    void *buffer = malloc(bufferSize);   
    size_t numBytesEncrypted = 0;     
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, 
                                          kCCAlgorithmAES128, 
                                          kCCOptionPKCS7Padding,
                                          keyPtr, 
                                          kCCKeySizeAES256,
                                          NULL /* initialization vector (optional) */,             
                                          [data bytes], 
                                          dataLength, /* input */             
                                          buffer, 
                                          bufferSize, /* output */             
                                          &amp;numBytesEncrypted);  
    if (cryptStatus == kCCSuccess) 
    {   
        //the returned NSData takes ownership of the buffer and will free it on deallocation   
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];  
    }   
    free(buffer); //free the buffer;  
    return nil; 
} 
</code></pre>
","<p>The key must be same when you encrypt or decrypt data. How are you calling the decrypt method, can you share the code??</p>
","535","<iphone><ios><encryption><aes><cryptoapi>","0","1","2","2011-09-20 10:55:36","7484020","1","","","","","2011-09-20 05:49:21",""
"7480677","AES decryption not working please help","<p>I am doing AES Encryption and decryption in program. I am not able to get the plain text when i decrypt. My code ins as follows...</p>

<pre><code>- (NSData *)aesEncrypt:(NSString *)key data:(NSData *)data
{  
    // 'key' should be 32 bytes for AES256, will be null-padded otherwise  
    char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)  
    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)   // fetch key data  
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];   
    NSUInteger dataLength = [data length];   
    //See the doc: For block ciphers, the output size will always be less than or equal to the input size plus the size of one block.  //That's why we need to add the size of one block here  
    size_t bufferSize = dataLength + kCCBlockSizeAES128;  
    void *buffer = malloc(bufferSize);   
    size_t numBytesEncrypted = 0;     
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, 
                                          kCCAlgorithmAES128, 
                                          kCCOptionPKCS7Padding,
                                          keyPtr, kCCKeySizeAES256,
                                          NULL /* initialization vector (optional) */,             
                                          [data bytes], 
                                          dataLength, /* input */             
                                          buffer, bufferSize, /* output */             &amp;
                                          numBytesEncrypted);  
    if (cryptStatus == kCCSuccess) 
    {   
        //the returned NSData takes ownership of the buffer and will free it on deallocation   
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];  
    }   
    free(buffer); //free the buffer;  
    return nil; 
} 

- (NSData *)aesDecrypt:(NSString *)key data:(NSData *)data
{  
    // 'key' should be 32 bytes for AES256, will be null-padded otherwise  
    char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)  
    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)   // fetch key data  
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];   
    NSUInteger dataLength = [data length];   
    //See the doc: For block ciphers, the output size will always be less than or equal to the input size plus the size of one block.  //That's why we need to add the size of one block here  
    size_t bufferSize = dataLength + kCCBlockSizeAES128;  
    void *buffer = malloc(bufferSize);   
    size_t numBytesEncrypted = 0;     
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, 
                                          kCCAlgorithmAES128, 
                                          kCCOptionPKCS7Padding,
                                          keyPtr, 
                                          kCCKeySizeAES256,
                                          NULL /* initialization vector (optional) */,             
                                          [data bytes], 
                                          dataLength, /* input */             
                                          buffer, 
                                          bufferSize, /* output */             
                                          &amp;numBytesEncrypted);  
    if (cryptStatus == kCCSuccess) 
    {   
        //the returned NSData takes ownership of the buffer and will free it on deallocation   
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];  
    }   
    free(buffer); //free the buffer;  
    return nil; 
} 
</code></pre>
","<p>You are not specifying the encryption mode.  Use CBC or CTR.  Do <strong>not</strong> use ECD as it is insecure.  You are specifying a null IV.  That may mean that the system is supplying a random (or zero) IV.  Much better to specify an IV explicitly, and to ensure that the same IV is use for both encryption and decryption.</p>

<p>Another common source of errors is trying to treat bytes as character data (and <em>vice versa</em>).  Be sure to treat bytes as bytes and characters as characters and know which one you are dealing with at all times.</p>
","535","<iphone><ios><encryption><aes><cryptoapi>","0","0","2","2011-09-20 10:55:36","7484020","1","","","","","2011-09-20 05:49:21",""
"38121372","Extract Certificate Chain from SChannel with C++ and CryptoApi/SChannel","<p>Is it possible to extract the certificate chain sent by the remote computer in TLS 1.0 Handshake?</p>

<p>The API QueryContextAttributes with SECPKG_ATTR_REMOTE_CERT_CONTEXT value, returns only the end certificate.</p>

<p>Is possible to extract all the chain certificates using some methods?
Environment Windows and C++ using CryptoApi and SChannel.</p>

<p>Thanks!</p>
","<p>Yes, it is.</p>

<p>Use <code>QueryContextAttributes()</code> with <code>SECPKG_ATTR_REMOTE_CERT_CONTEXT</code> and server certificate returned will have <code>hCertStore</code> member set to a certificate store containing all server's intermediate CA certificates. (See remarks at <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379340.aspx"" rel=""nofollow"">MSDN</a>.)</p>

<p>See the code snippet below (Source: WebClient.c, Microsoft Platform SDK) how you can parse the chain:</p>

<pre class=""lang-c prettyprint-override""><code>static 
void
DisplayCertChain(
    PCCERT_CONTEXT  pServerCert,
    BOOL            fLocal)
{
    CHAR szName[1000];
    PCCERT_CONTEXT pCurrentCert;
    PCCERT_CONTEXT pIssuerCert;
    DWORD dwVerificationFlags;

    printf(""\n"");

    // display leaf name
    if(!CertNameToStr(pServerCert-&gt;dwCertEncodingType,
                      &amp;pServerCert-&gt;pCertInfo-&gt;Subject,
                      CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                      szName, sizeof(szName)))
    {
        printf(""**** Error 0x%x building subject name\n"", GetLastError());
    }
    if(fLocal)
    {
        printf(""Client subject: %s\n"", szName);
    }
    else
    {
        printf(""Server subject: %s\n"", szName);
    }
    if(!CertNameToStr(pServerCert-&gt;dwCertEncodingType,
                      &amp;pServerCert-&gt;pCertInfo-&gt;Issuer,
                      CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                      szName, sizeof(szName)))
    {
        printf(""**** Error 0x%x building issuer name\n"", GetLastError());
    }
    if(fLocal)
    {
        printf(""Client issuer: %s\n"", szName);
    }
    else
    {
        printf(""Server issuer: %s\n\n"", szName);
    }


    // display certificate chain
    pCurrentCert = pServerCert;
    while(pCurrentCert != NULL)
    {
        dwVerificationFlags = 0;
        pIssuerCert = CertGetIssuerCertificateFromStore(pServerCert-&gt;hCertStore,
                                                        pCurrentCert,
                                                        NULL,
                                                        &amp;dwVerificationFlags);
        if(pIssuerCert == NULL)
        {
            if(pCurrentCert != pServerCert)
            {
                CertFreeCertificateContext(pCurrentCert);
            }
            break;
        }

        if(!CertNameToStr(pIssuerCert-&gt;dwCertEncodingType,
                          &amp;pIssuerCert-&gt;pCertInfo-&gt;Subject,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          szName, sizeof(szName)))
        {
            printf(""**** Error 0x%x building subject name\n"", GetLastError());
        }
        printf(""CA subject: %s\n"", szName);
        if(!CertNameToStr(pIssuerCert-&gt;dwCertEncodingType,
                          &amp;pIssuerCert-&gt;pCertInfo-&gt;Issuer,
                          CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                          szName, sizeof(szName)))
        {
            printf(""**** Error 0x%x building issuer name\n"", GetLastError());
        }
        printf(""CA issuer: %s\n\n"", szName);

        if(pCurrentCert != pServerCert)
        {
            CertFreeCertificateContext(pCurrentCert);
        }
        pCurrentCert = pIssuerCert;
        pIssuerCert = NULL;
    }
}
</code></pre>
","529","<c++><windows><ssl><cryptoapi><schannel>","1","1","1","2016-08-23 09:54:24","39097930","0","1","","","","2016-06-30 11:08:06",""
"28288397","Import CSP blob exported from .NET into python pyCrypto","<p>I have a CPS Blob exported from certificate using <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.exportcspblob(v=vs.110).aspx"" rel=""nofollow noreferrer""><code>RSACryptoServiceProvider.ExportCspBlob</code></a> in my .NET application.</p>

<p></p>

<pre><code>return Convert.ToBase64String(rsaAlg.ExportCspBlob(false /*includePrivateParameters*/));
</code></pre>

<p>Now, I need to import that blob in python application. I tried using pyCrypto, but with no luck.</p>

<p></p>

<pre><code># that's the value I'm getting from .NET code above
key = 'BgIAAAAkAABSU0ExAAgAAAEAAQARMnLlzOgHkmHssf6ZSFJn8TlTiOBSoRSEnkI4U0UI6n1jFY2bTWS9O5uApMNXz1vr5OyxoXsNVF2XrNM4DOC+lRn3R/H+mZZxZY1F8oXxhe4L5AFOMhyykPreQtu9z+oKOzVB80zR+EU+nc/290POVK9/LGzP94cTk0VHSZdXDgL1eOiXLSg8h1OnJmMGxY6HyNvbF90onoHMWNrIeRue1vP/S5QLwuzkHv6tgm54bSwXWXFdDRbjtrA9HJkbf74hflAIqivO34bx+53whl2fEsC51eXqFdCr7XJJw+bwlENwDF9bUtCXQ+jXbiYtzvMbntRCKZ8LPRqlN9OWrBC2';

from Crypto.PublicKey import RSA
from Crypto.Util import asn1
from base64 import b64decode

# let's decrypt base64 first
keyDER = b64decode(key)

seq = asn1.DerSequence()
seq.decode(keyDER)
keyPub = RSA.importKey(keyDER)
</code></pre>

<p>I'm getting</p>

<blockquote>
  <p>Traceback (most recent call last):   File ""C:\Program Files
  (x86)\Microsoft Visual Studio 12.0\Common7\IDE\Extensio
  ns\Microsoft\Python Tools for Visual
  Studio\2.1\visualstudio_py_util.py"", line 1 06, in exec_file
      exec_code(code, file, global_variables)   File ""C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\Extensio
  ns\Microsoft\Python Tools for Visual
  Studio\2.1\visualstudio_py_util.py"", line 8 2, in exec_code
      exec(code_obj, global_variables)   File ""c:\users\marcinj\documents\visual studio
  2013\Projects\PythonApplication
  1\PythonApplication1\PythonApplication1.py"", line 12, in 
      seq.decode(keyDER)   File ""C:\Python27\lib\site-packages\Crypto\Util\asn1.py"", line 237, in
  decode
      raise ValueError(""Not a DER SEQUENCE."") ValueError: Not a DER SEQUENCE.</p>
</blockquote>
","<p>The CSP blob format is proprietary to Microsoft and poorly documented. Rather than use that format I would instead use the <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rsacryptoserviceprovider.exportparameters(v=vs.110).aspx"" rel=""nofollow""><code>ExportParameters</code></a> method to get an <a href=""https://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters(v=vs.110).aspx"" rel=""nofollow""><code>RSAParameters</code></a> struct. From this struct I would directly access the <code>Exponent</code> and <code>Modulus</code> byte arrays and base64 encode them for transfer to the python program, as in the following snippet:</p>

<pre class=""lang-cs prettyprint-override""><code>var rsa = RSA.Create ();
var RsaParms = rsa.ExportParameters (false);
Console.WriteLine (Convert.ToBase64String( RsaParms.Modulus));
Console.WriteLine (Convert.ToBase64String (RsaParms.Exponent));
</code></pre>

<p>In the python program, the documentation for PyCrypto's RSA <code>importKey</code> mentions a few options for acceptable formats. The simplest of these is the PKCS#1 RSAPublicKey structure. This is quite easy to construct from the asn1 module, as in the following snippet:</p>

<pre class=""lang-py prettyprint-override""><code>mod_raw = b64decode('qLhDLGNh7+9xRahkaWILm5HcG3T0Q4SUoDA3bpQtqLxU3AQ/fmYQWLXh0Se1mhQ3AIMduVgKaJhK1sH+G/toXuQ0n5ENw6PtGMODwsDXF072kaBKD3JBZSESC9a9a8QDoGtv7WwvH1UcIE9di60C7YdBMlqqBgkjMQ6c3CTh9KU=')
exp_raw = b64decode('EQ==')
mod = int.from_bytes(mod_raw, 'big')
exp = int.from_bytes(exp_raw, 'big')
seq = asn1.DerSequence()
seq.append(mod)
seq.append(exp)
der = seq.encode()
keyPub = RSA.importKey(der)
</code></pre>
","525","<python><.net><rsa><pycrypto><cryptoapi>","2","3","1","2016-12-26 11:09:23","28290057","0","","4082217","","2016-12-26 11:09:23","2015-02-02 22:56:21",""
"20898093","How to get private key with asn format from pfx?","<p>How to get private key with asn format from pfx? I need to get the private key with asn format to put to Qt's variable QSslKey to connect https server.</p>

<p>I have to use Win32 Api to do it, and I can't use OpenSSL to transform it.</p>

<p>First I try to get the private key directly:</p>

<pre><code>1.CertOpenSystemStore(NULL, _T(""MY""))
2.CryptAcquireCertificatePrivateKey(...)
3.CryptGetUserKey(...)
4.CryptExportKey(...)
</code></pre>

<p>But the private key I have got, I don't know how to use it. </p>
","<p><strong>Warning</strong> : This is not the exact answer for your question, but i hope it will give you some help towards what you want to acheive</p>

<p>Based on my experience, Windows crypto APIs are designed to use the private key within the certificate store rather than export the key outside, unless you are using CryptoAPI standard functions like PFXExportCertStoreEx ().</p>

<p>CryptExportKey function gives the private/public key pair in a key blob structure which you have to convert to the format you want. The closest thing i have ever seen this being being done is in</p>

<p>Openssl engine for Windows, <strong>filename : e_capi.c</strong></p>

<p>refer to the function</p>

<pre><code> **capi_load_privkey() and subfunction capi_get_pkey()**
</code></pre>

<p>Here conversion of the Key blob to OpenSSL compatible structure is done.
Hope this helps</p>
","525","<visual-c++><private-key><cryptoapi><pfx>","0","1","1","2014-01-07 04:13:59","20953239","0","","608639","","2014-01-07 04:13:59","2014-01-03 06:41:42",""
"25313533","Get certificate selected by window.crypto ""ask""","<p>anyone knows how you can get on javascript which certificate do you select from the pop-up of window.crypto.signText(""xxxxx"",""ask"")?
On Firefox, just in case :)
I'm using <a href=""https://developer.mozilla.org/en-US/docs/JavaScript_crypto"" rel=""nofollow"">https://developer.mozilla.org/en-US/docs/JavaScript_crypto</a> but i can't believe you have a method to select a certificate of firefox store and you can't know from code which certificate was selected.
Regards.</p>
","","522","<javascript><firefox><certificate><mozilla><cryptoapi>","0","","0","2014-08-14 16:58:30","","2","","","","","2014-08-14 16:58:30",""
"20347134","Java standard crypto API vs. specific provider (Bouncy Castle)","<p>I'm developing a java application that uses some basic/common crypto (AES, 3DES, DH, ECDH) and is supposed to run on as many platforms (mainly Win/Linux/Android) as possible. Concerning the crypto part I thought it would be best to use the standard Java API so users can use whatever cryptographic provider they desire.</p>

<p>Luckily/Unfortunately I inherited some old code fixed to Bouncy Castle.
Now I have to decide between either giving up my idea of staying independent of any crypto provider or updating/rewriting the old code to work with the standard API. The amount of work for updating/rewriting would be feasible but is it worth the while?</p>
","","520","<java><android><bouncycastle><cryptoapi>","1","","0","2013-12-03 09:19:30","","5","","","","","2013-12-03 09:19:30",""
"42479318","Calling Third Party Cryptographic service provider from Microsoft Word for Digital Signature","<p>I'm developing a third party Cryptographic Service Provider (CSP) DLL and Want to integrate the same with Microsoft Windows. The main goal of this development is to call our cryptographic functions like Digital Signature and signature verification from Office tools like word,excel etc. Here i'm facing the following issues.</p>

<p>1) I have developed CSP DLL, Signed and registered it in registry entries. This is working fine as we tested with test application by loading our cpacquirecontext and other crypto APIs.Here we are providing CSP name ""XYZ"" in the test application so that Test application correctly identifying our dll and calling the functions accordingly.</p>

<p>2) After this now we want to call our CSP dll API from Microsoft word for digital signature operation. For this what settings/Configurations need to be done in order to bypass default Microsoft csp and call our csp dll for Digital Signature. kindly help me in solving this issue.</p>
","<p>In order to make the certificates stored in your CSP usable by Office and other application for digital signature operations, you will need to register these certificate in Windows <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa388136(v=vs.85).aspx"" rel=""nofollow noreferrer"">""MY"" certificate store</a> using <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376015(v=vs.85).aspx"" rel=""nofollow noreferrer"">CertAddEncodedCertificateToStore</a> and then update the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa381420(v=vs.85).aspx"" rel=""nofollow noreferrer"">CERT_KEY_PROV_INFO_PROP_ID</a> property of the resulting CERT_CONTEXT using <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376573(v=vs.85).aspx"" rel=""nofollow noreferrer"">CertSetCertificateContextProperty</a> in order to indicate your CSP name and the container where the certificate's key resides.</p>

<p>I have written a small command line program that uses this method to load all certificates stored in a given CSP to the ""MY"" certificate store. It also offers the possibility to remove certificates from the ""MY"" certificate store, which is useful when the certificates are no more needed/available.
You can get its source code from <a href=""https://www.idrix.fr/Root/Samples/LoadCertToStore.cpp"" rel=""nofollow noreferrer"">https://www.idrix.fr/Root/Samples/LoadCertToStore.cpp</a>.</p>

<p>I hope this will help.</p>
","520","<digital-signature><cryptoapi><service-provider>","0","1","2","2017-04-24 03:08:52","","0","1","","","","2017-02-27 06:40:49",""
"42479318","Calling Third Party Cryptographic service provider from Microsoft Word for Digital Signature","<p>I'm developing a third party Cryptographic Service Provider (CSP) DLL and Want to integrate the same with Microsoft Windows. The main goal of this development is to call our cryptographic functions like Digital Signature and signature verification from Office tools like word,excel etc. Here i'm facing the following issues.</p>

<p>1) I have developed CSP DLL, Signed and registered it in registry entries. This is working fine as we tested with test application by loading our cpacquirecontext and other crypto APIs.Here we are providing CSP name ""XYZ"" in the test application so that Test application correctly identifying our dll and calling the functions accordingly.</p>

<p>2) After this now we want to call our CSP dll API from Microsoft word for digital signature operation. For this what settings/Configurations need to be done in order to bypass default Microsoft csp and call our csp dll for Digital Signature. kindly help me in solving this issue.</p>
","<p>I have same situation as you. <br >
My CSP work fine with test applications and MS Office 2007 but it's not work with MS Office 2010 and 2013. <br >
This is the MS Office's issue: </p>

<blockquote>
  <p>Office 2010 does not support certain certificates in a Windows 7 or Windows Vista environment. Specifically, these unsupported certificates use private keys that are stored by a third-party cryptographic service provider (CSP). Therefore, an Office 2010 document cannot be signed by using a Cryptographic API (CAPI).</p>
</blockquote>

<p>You can download Office 2010 hotfix package (Mso-x-none) <a href=""https://support.microsoft.com/en-ph/help/2281460/description-of-the-office-2010-hotfix-package-mso-x-none-september-22-2010"" rel=""nofollow noreferrer"">here</a>.</p>

<p>For MS Office 2013, It seems you need Service Pack 1.</p>
","520","<digital-signature><cryptoapi><service-provider>","0","0","2","2017-04-24 03:08:52","","0","1","","","","2017-02-27 06:40:49",""
"33919247","alloc_ahash vs alloc_shash in Linux Crypto Libraries","<p>In the Linux CRYPTO libraries, what is the difference among:</p>

<ul>
<li>crypto_alloc_hash(...); </li>
<li>crypto_alloc_ahash(...);</li>
<li>crypto_alloc_shash(...);</li>
</ul>

<p>I would guess 'a' stands for asynchronous and 's' for synchronous.<br></p>

<p>If this is the case, what does it mean in terms of implementation choice?</p>

<p>(I am trying to find the correct way to calculate an HMAC(SHA1) value while processing a TCP packet using the CRYPTO libraries).</p>
","<p><a href=""https://stackoverflow.com/questions/748175/asynchronous-vs-synchronous-execution-what-does-it-really-mean"">SO Question1</a> &amp; <a href=""https://stackoverflow.com/questions/3389765/asynchronous-function-call-for-c"">SO Question2</a> are good starting points for you.<br></p>

<p>There are nothing called asynchronous and synchronous functions.All functions(callees) need to return to the callers.<br></p>

<p>But there are asynchronous and synchronous operations.</p>

<p><code>crypto_alloc_ahash()</code> &amp; <code>crypto_alloc_shash()</code> differ in that the
first consist of the asynchronous operations and the latter consist of
synchronous operations. <br></p>

<p>In case of the first the function when called returns immediately to the main programme leaving behind its operations to complete. When the operations complete they usually use SIGNALS/INTERRUPTS to let the main programme know that they have completed. You can see the implementation <a href=""http://lxr.free-electrons.com/source/crypto/ahash.c?v=2.6.37#L425"" rel=""nofollow noreferrer"">here</a> and an excerpt is given below.</p>

<pre><code>struct crypto_ahash *crypto_alloc_ahash(const char *alg_name, u32 type,
                                        u32 mask)
 {
         return crypto_alloc_tfm(alg_name, &amp;crypto_ahash_type, type, mask);
 }
</code></pre>

<p>In case of the latter the main programme(caller) has to wait for the operation in the function to complete to continue. I can't think of specific scenarios
where synchronization is mandatory in this context. You can see the implementation <a href=""http://lxr.free-electrons.com/source/crypto/shash.c?v=2.6.37#L544"" rel=""nofollow noreferrer"">here</a></p>

<p>Indeed both the functions look the same but for the type of the values they return.<br>
Async variants of functions is normally what you should look for the speed reasons of your programme. Also you cannot make async calls from sync variants for obvious reasons.</p>

<p><strong>Edit :</strong><br></p>

<p><a href=""http://lxr.free-electrons.com/source/include/linux/crypto.h#L1613"" rel=""nofollow noreferrer"">crypto_alloc_hash</a> is synchronous hash and I couldn't find out the difference between hash and shash.<br></p>

<p>Both returns allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code.<br></p>

<p>See <a href=""http://www.chronox.de/crypto-API/API-crypto-alloc-shash.html"" rel=""nofollow noreferrer"">shash</a> vs <a href=""http://www.chronox.de/crypto-API/API-crypto-alloc-hash.html"" rel=""nofollow noreferrer"">hash</a>.</p>
","518","<linux><tcp><cryptoapi><hmacsha1>","2","1","1","2015-11-26 09:25:16","33923262","3","1","1620779","","2015-11-26 09:25:16","2015-11-25 14:36:22",""
"11709500","CAPI does not support Password Based Encryption (PBE) encryption?","<p>I am trying to port a UNIX code using OpenSSL (PKCS#5 &amp; PKCS#7) to windows.</p>

<p>In the case of OpenSSL, all the encoding/decoding (certificates or
passwords) is done transparently to the caller in the function
<a href=""http://www.openssl.org/docs/crypto/CMS_encrypt.html"" rel=""noreferrer"">CMS_Encrypt</a>, as it should be.</p>

<p>CAPI does the same thing in the case of
certificate based encryption inside the function <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379925%28v=vs.85%29.aspx"" rel=""noreferrer"">CryptEncryptMessage</a>
(no ASN details are revealed to the caller). After some googling, I found out the following <a href=""http://www.idrix.fr/Root/content/view/37/54/"" rel=""noreferrer"">key generation implementation</a>. Now how am I supposed to use it in CAPI ?</p>

<p>Because CAPI does not
support PBE encryption at the high level (PBKDF2) my guess
is that the encoding has to be done (somehow?) manually. And by manually I mean writing
(and reading) the binary representations of various ASN tags. How am I supposed to do this ?</p>

<p>I cannot access the <a href=""http://www.koders.com/c/fid4F23D8E46AFA71338959D003DFF969831DE6120C.aspx"" rel=""noreferrer"">msasn1.h</a> API since msasn1.lib is never distributed. Has anyone been able to use CAPI interface for doing anything else other than certificates based encryption ?</p>
","","509","<c++><cryptoapi><pbkdf2>","8","","0","2015-10-10 20:23:41","","4","","136285","","2012-07-30 07:25:46","2012-07-29 13:10:12",""
"34728198","CertFindCertificateInStore fails with Oject or property not found","<p>Actually i am searching certificate on the basis of common name. For that we have done :-</p>

<pre><code>PSTR pszCommonName = ""cn.com""; 
CERT_RDN_ATTR certRDNAttr[1]; 
certRDNAttr[0].pszObjId = szOID_COMMON_NAME; 
certRDNAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING; 
certRDNAttr[0].Value.pbData = (PBYTE) pszCommonName; 
certRDNAttr[0].Value.cbData = lstrlen(pszCommonName); 
CERT_RDN certRDN = {1, certRDNAttr};  
</code></pre>

<p><code>// Find the certificate context 
    if (pCertContext =  CertFindCertificateInStore(hCertStore, X509_ASN_ENCODING                                      | PKCS_7_ASN_ENCODING, 0, CERT_FIND_SUBJECT_ATTR, &amp;certRDN, NULL))</code> </p>

<p>My Store contains the desired Cert with given common name but it is not located by the api, it returns null. </p>

<p>Not able to find the issue. </p>
","","475","<cryptoapi><certificate-store>","2","","0","2016-01-11 18:08:17","","0","","","","","2016-01-11 18:08:17",""
"2943854","Howto take a glimpse into mscorlib?","<p>I want to read data into RSAParameters structure (<a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters%28v=VS.100%29.aspx"" rel=""nofollow noreferrer""> RSAParameters </a>) and did check twice, that the data is correct. But still, I get an error ""invalid data"" exception for this:</p>

<pre><code>   bei System.Security.Cryptography.CryptographicException.ThrowCryptogaphicException(Int32 hr)
   bei System.Security.Cryptography.Utils._ImportKey(SafeProvHandle hCSP, Int32 keyNumber, CspProviderFlags flags, Object cspObject, SafeKeyHandle&amp; hKey)
   bei System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters(RSAParameters parameters)
</code></pre>

<p>How can I take a look into the source code to check why _ImportKeys is throwing an exception? I have no experience with .dll 'decryption'..are there any symbols to reference somewhere for visual studio 8.0? Thank you.</p>
","<p>Use <a href=""http://www.red-gate.com/products/reflector/"" rel=""nofollow noreferrer"">.NET Reflector</a> to disassemble the DLL you want to examine.</p>
","460","<c#><cryptoapi><mscorlib>","2","2","2","2015-03-24 11:03:00","2943868","0","","351998","","2010-05-31 13:41:01","2010-05-31 13:35:35",""
"2943854","Howto take a glimpse into mscorlib?","<p>I want to read data into RSAParameters structure (<a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters%28v=VS.100%29.aspx"" rel=""nofollow noreferrer""> RSAParameters </a>) and did check twice, that the data is correct. But still, I get an error ""invalid data"" exception for this:</p>

<pre><code>   bei System.Security.Cryptography.CryptographicException.ThrowCryptogaphicException(Int32 hr)
   bei System.Security.Cryptography.Utils._ImportKey(SafeProvHandle hCSP, Int32 keyNumber, CspProviderFlags flags, Object cspObject, SafeKeyHandle&amp; hKey)
   bei System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters(RSAParameters parameters)
</code></pre>

<p>How can I take a look into the source code to check why _ImportKeys is throwing an exception? I have no experience with .dll 'decryption'..are there any symbols to reference somewhere for visual studio 8.0? Thank you.</p>
","<p>You can also use  <a href=""https://www.jetbrains.com/decompiler/download/"" rel=""nofollow"">JetBrains dotPeek</a>. It is 100% free. </p>
","460","<c#><cryptoapi><mscorlib>","2","0","2","2015-03-24 11:03:00","2943868","0","","351998","","2010-05-31 13:41:01","2010-05-31 13:35:35",""
"38105117","Verify rsa signature with CryptoApi","<p>I'm trying to calculate message rsa signature in python 2 code using <code>rsa</code> or <code>pyopenssl</code> package and verify it with microsoft CryptoApi. Unfortunately, <code>CryptVerifySignature</code> is always reporting error <code>0x80090006: Invalid signature</code>.
My python code:</p>

<pre><code>import rsa
from OpenSSL import crypto

private_key = ""-----BEGIN RSA PRIVATE KEY-----\nMIICWwIBAAKBgQDFloLNqx8YZHc8D5Pk6TniJo5nwdvObNilEih2VZtTPCHooa/A\nUhz0mqh/lOKkskDNa5RCz4iTWy7wug2v+1GGlFp9jEtYq6foVu8N9DChvc8OIVV1\n4PgyFCCbCJOi5ccVUh5KBCyO8FtxHiS6a8wE3glSwsUGfzpMdrfKCYENRwIDAQAB\nAoGAJOcHZwIevJ+G5WDDbm1gsiwhTJ+YPeV2UN4jUHaMm+8PJjOMb47meYipD6ru\n6XOhRrxg5Fl+WIcfLTaSd9uoTfYIJArTPF6R2EAkcPGeil3mMSDMwqTz5eStOI/q\nRkMryHN5lCOWkm3dWXNmT/75rnqJ4dFGE1iw5dL4OJbovQECQQDyabjCqIjsTHZW\nIohqQaZAbO+wLvP4IgeUvJ31CR5Xms61FUUOe5WEs6GnSfZlsdzun+58DBEsjo7J\ncqbZxTD5AkEA0KmdPO9LMSweTSqIbH72NcIuW8cQGI2oJKNLG4Ncc7GN6ElyHJ7H\nIbRfrb2UupsLvLTDFLIrOdGWG74JGkoAPwJARGJ+tKtGtSJ835+uTAtpExOoKlOU\nj5NKADOVe+KupJgPaBYv/P3wGBd0qvS6hcW/RbHoXSYqUh+FOF8Xoqd2QQJAJeuN\nHbPHEGqaHx/ppv3ztJVTY25rqGql8fKTBa77sDLGPT6LtFPOkHt9H8/iJX9jxKl9\nAlfWry09gFEqylJEdQJAHEA0/fDR+yHxxx4w9QnfbPtn0RNHQbBzKx0K37hMu/tE\n0wxp8BFWEs5YAWWNw82ft5yOg81MH1n8iCIHzWTKrw==\n-----END RSA PRIVATE KEY-----\n""

message = ""testmessage""
key = rsa.PrivateKey.load_pkcs1(private_key)
signature = rsa.sign(message, key, 'MD5')
</code></pre>

<p>Signature becomes aa69b87840390e6032e57f4bb... bytes, and the same signature I have via <code>openssl dgst -md5 -sign private.pem -keyform PEM message.txt</code> command</p>

<p>My c++ code (short version):</p>

<pre><code>const char kPublicVerifyKey[] =
  ""-----BEGIN PUBLIC KEY-----\n""
  ""MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDFloLNqx8YZHc8D5Pk6TniJo5n\n""
  ""wdvObNilEih2VZtTPCHooa/AUhz0mqh/lOKkskDNa5RCz4iTWy7wug2v+1GGlFp9\n""
  ""jEtYq6foVu8N9DChvc8OIVV14PgyFCCbCJOi5ccVUh5KBCyO8FtxHiS6a8wE3glS\n""
  ""wsUGfzpMdrfKCYENRwIDAQAB\n""
  ""-----END PUBLIC KEY-----\n"";

...

  std::vector&lt;unsigned char&gt; key_buffer(public_key.size);
  DWORD key_buffer_size = key_buffer.size();
  if (!CryptStringToBinaryA(static_cast&lt;const char*&gt;(public_key.data),
    public_key.size, CRYPT_STRING_BASE64HEADER,
    key_buffer.data(), &amp;key_buffer_size, NULL, NULL))
  {
    return false;
  }

  CERT_PUBLIC_KEY_INFO* key_info = nullptr;
  DWORD key_info_size = 0;
  if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_PUBLIC_KEY_INFO,
    key_buffer.data(), key_buffer_size,
    CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;key_info, &amp;key_info_size))
  {
    return false;
  }

  HCRYPTPROV crypt_context;
  if (!CryptAcquireContext(&amp;crypt_context, NULL, NULL,
    PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
  {
    return false;
  }

  HCRYPTKEY crypt_key;
  if (!::CryptImportPublicKeyInfo(crypt_context,
    X509_ASN_ENCODING, key_info, &amp;crypt_key))
  {
    return false;
  }

  HCRYPTHASH hash;
  if (!::CryptCreateHash(crypt_context, CALG_MD5, 0, 0, &amp;hash)) {
    return false;
  }

  if (!::CryptHashData(hash,
    static_cast&lt;const BYTE*&gt;(message.data), message.size, 0))
  {
    return false;
  }

  BOOL result = ::CryptVerifySignature(hash,
    static_cast&lt;const BYTE*&gt;(signature.data), signature.size,
    crypt_key, NULL, 0);
</code></pre>

<p>Why <code>CryptVerifySignature</code> think that my signature is incorrect? A found related questions (<a href=""https://stackoverflow.com/questions/20775792/php-openssl-signed-string-not-getting-verified-by-win-cryptoapi"">php openssl signed string not getting verified by Win CryptoAPI</a>) with advice to reverse just signature or signature and public key data bytes, but doing this with signature changes nothing and reversing public key results in error <code>ASN1 bad tag value met. 0x8009310b</code> by <code>CryptDecodeObjectEx</code> function.</p>

<p>Private key was generated with <code>openssl genrsa -out private.pem 1024</code> command and public was generated with <code>openssl rsa -in private.pem -inform PEM -outform PEM -pubout</code></p>
","","455","<python><c++><cryptoapi><pyopenssl>","1","","0","2016-06-29 17:10:56","","6","","-1","","2017-05-23 11:44:15","2016-06-29 16:18:16",""
"40297283","How to get a HCRYPTKEY from X.509 certificate?","<p>The certificate is obtained from a smart card via the BSI API (<code>gscBsiPkiGetCertificate</code>) and I'm trying to get the key handle to its public/private key pair to perform asymmetric crypto operations using the CryptoAPI's <code>CryptEncrypt</code> and <code>CryptDecrypt</code> functions.</p>

<h2>What I've Tried</h2>

<p><code>gscBsiPkiGetCertificate</code> returns the raw certificate data in hex encoded form and I was able to decode it and successfully call <code>CertCreateCertificateContext</code> to get the <code>CERT_CONTEXT</code> structure. With this <code>CERT_CONTEXT</code>, I had tried <code>CertGetCertificateContextProperty</code> with parameters</p>

<ul>
<li><code>CERT_KEY_CONTEXT_PROP_ID</code></li>
<li><code>CERT_KEY_PROV_HANDLE_PROP_ID</code></li>
<li><code>CERT_KEY_PROV_INFO_PROP_ID</code></li>
<li><code>CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID</code></li>
<li><code>CERT_HCRYPTPROV_TRANSFER_PROP_ID</code></li>
</ul>

<p>However all of them returned <code>CRYPT_E_NOT_FOUND</code>. I had also tried <code>GetCryptProvFromCert</code> in hope of getting the certificate container handle, which would then allow me to get the key handle via <code>CryptGetUserKey</code>. However <code>GetCryptProvFromCert</code> failed with error <code>CRYPT_E_NO_KEY_PROPERTY</code>. </p>

<p>I am currently using pure CryptoAPI as a workaround: <code>CryptAcquireContext</code> to access card -> <code>CryptGetProvParam</code> to enumerate certificate containers -> <code>CryptAcquireContext</code> to access container -> <code>CryptGetUserKey</code> to get key handle. This is far from ideal since I've to interate through the containers to find the required certificate. <code>gscBsiPkiGetCertificate</code> allows me to specify an AID value to get the certificate directly.</p>

<p>I had also tried using <code>CryptEncryptMessage</code> which takes a <code>PCCERT_CONTEXT</code> directly and thus avoiding the need for the <code>HCRYPTKEY</code>. However, trying with algorithm identifiers <code>szOID_RSA</code>, <code>szOID_RSA_ENCRPT</code>, and <code>szOID_RSA_DH</code> all returned <code>CRYPT_E_UNKNOWN_ALGO</code>. I'm quite sure the certificate supports RSA encryption since calling <code>CryptGetKeyParam</code> with <code>KP_ALGID</code> on the key handle obtained through CryptoAPI returns me <code>CALG_RSA_KEYX</code></p>

<h2>Bonus Challenge</h2>

<p>I am using BSI API to access both data and certificate containers within the card. I would like to avoid the workaround as I want to standardise all smart card operations to use only BSI or CryptoAPI. If it's impossible for me to get the key handle using BSI API, I would then like know how to use CryptoAPI to access the data containers. <code>CryptGetProvParam</code> only enumerates the certificate containers.</p>
","<p>you could try something like that <br>
1) you get the certificate context e.g. <br>
pSignerCertContext = CertFindCertificateInStore(hCertStore, PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 0, CERT_FIND_HASH, &amp;hashBlob, NULL)
<br>
2) you get a handle to crypt provider e.g. :<br>
CryptAcquireContext(&amp;hProv, strContainer.c_str(), strProvider.c_str(), PROV_RSA_FULL, CRYPT_SILENT)
<br>
3) You associate the certificate context with the crypt provider e.g. <br>
CertSetCertificateContextProperty(pSignerCertContext, CERT_SET_KEY_PROV_HANDLE_PROP_ID, 0, &amp;hProv)
<br>
4) after this you can use either CryptAcquireCertificatePrivateKey or CryptGetUserKey </p>
","455","<winapi><certificate><smartcard><cryptoapi>","2","0","1","2018-07-26 12:52:36","","6","","","","","2016-10-28 02:47:11",""
"46517050","How many Bitcoin addresses can I generate through Coinbase API?","<p>I use Coinbase <a href=""https://developers.coinbase.com/api/v2#create-address"" rel=""nofollow noreferrer"">API</a> to generate Bitcoin addresses.</p>

<p>What are the limits of this API?</p>

<p>How many Bitcoin addresses can I generate?</p>
","<p>The API says that: </p>

<blockquote>
  <p>The Coinbase API is rate limited to prevent abuse that would degrade our ability to maintain consistent API performance for all users. By default, each API key or app is rate limited at 10,000 requests per hour. If your requests are being rate limited, HTTP response code 429 will be returned with an rate_limit_exceeded error.</p>
</blockquote>

<p>So I would reason to assume you can generate 10,000 BTC addresses per hour. Of course there might be somewhere else it has been mentioned.</p>
","449","<api><currency><bitcoin><cryptoapi><coinbase-api>","2","1","1","2018-10-05 14:32:32","","0","1","5754223","","2017-10-01 21:36:16","2017-10-01 21:24:32",""
"2720171","Do any replacements for CryptoAPI exist for Windows?","<p>I am having major problems with cryptoAPI, and was wondering do you get any 3rd party / better solutions for windows?</p>

<p>Main problem I have with CryptoAPI is that its not OS independent enough. I can't find the right balance in my code to get stuff to work on Windows 2003 and Windows 2008+. </p>

<p>What I essentially want to achieve can be read about <a href=""https://stackoverflow.com/questions/2720276/how-to-use-crypto-to-extract-the-textual-information-in-a-file"">here</a>. This is my only use for Cryptography at this stage.</p>
","<p>CryptoAPI is a pain to use properly, if you are having problems, can I suggest <a href=""http://www.cryptopp.com/"" rel=""nofollow noreferrer"">Crypto++</a> ? The documentation isn't the best, but I've found it to be very powerful.</p>

<p>Without knowing more about what you are trying to achieve I can't be more help I'm afraid.</p>
","447","<c++><c><api><cryptoapi>","3","1","5","2013-08-09 12:00:04","","0","","-1","","2017-05-23 12:26:46","2010-04-27 09:51:51",""
"2720171","Do any replacements for CryptoAPI exist for Windows?","<p>I am having major problems with cryptoAPI, and was wondering do you get any 3rd party / better solutions for windows?</p>

<p>Main problem I have with CryptoAPI is that its not OS independent enough. I can't find the right balance in my code to get stuff to work on Windows 2003 and Windows 2008+. </p>

<p>What I essentially want to achieve can be read about <a href=""https://stackoverflow.com/questions/2720276/how-to-use-crypto-to-extract-the-textual-information-in-a-file"">here</a>. This is my only use for Cryptography at this stage.</p>
","<ul>
<li>Botan library - very nice library</li>
<li>gnu-tls/libgcrypt</li>
</ul>
","447","<c++><c><api><cryptoapi>","3","1","5","2013-08-09 12:00:04","","0","","-1","","2017-05-23 12:26:46","2010-04-27 09:51:51",""
"2720171","Do any replacements for CryptoAPI exist for Windows?","<p>I am having major problems with cryptoAPI, and was wondering do you get any 3rd party / better solutions for windows?</p>

<p>Main problem I have with CryptoAPI is that its not OS independent enough. I can't find the right balance in my code to get stuff to work on Windows 2003 and Windows 2008+. </p>

<p>What I essentially want to achieve can be read about <a href=""https://stackoverflow.com/questions/2720276/how-to-use-crypto-to-extract-the-textual-information-in-a-file"">here</a>. This is my only use for Cryptography at this stage.</p>
","<p>Try Bouncy Castle, it's available in C# &amp; Java:
<a href=""http://www.bouncycastle.org/"" rel=""nofollow noreferrer"">http://www.bouncycastle.org/</a></p>

<p>Quite a few vendors in our space use it in production. </p>
","447","<c++><c><api><cryptoapi>","3","2","5","2013-08-09 12:00:04","","0","","-1","","2017-05-23 12:26:46","2010-04-27 09:51:51",""
"2720171","Do any replacements for CryptoAPI exist for Windows?","<p>I am having major problems with cryptoAPI, and was wondering do you get any 3rd party / better solutions for windows?</p>

<p>Main problem I have with CryptoAPI is that its not OS independent enough. I can't find the right balance in my code to get stuff to work on Windows 2003 and Windows 2008+. </p>

<p>What I essentially want to achieve can be read about <a href=""https://stackoverflow.com/questions/2720276/how-to-use-crypto-to-extract-the-textual-information-in-a-file"">here</a>. This is my only use for Cryptography at this stage.</p>
","<p>I could recommend OpenSSL <a href=""http://www.openssl.org/"" rel=""nofollow noreferrer"">http://www.openssl.org/</a>. It is not only for SSL the area, but for cryptography as a whole. It is <strong>open source code</strong>. This fact can be very useful in some situations. It also works very will in Windows. Recommended compiled binaries and libraries for Windows you can find here <a href=""http://www.slproweb.com/products/Win32OpenSSL.html"" rel=""nofollow noreferrer"">http://www.slproweb.com/products/Win32OpenSSL.html</a></p>
","447","<c++><c><api><cryptoapi>","3","2","5","2013-08-09 12:00:04","","0","","-1","","2017-05-23 12:26:46","2010-04-27 09:51:51",""
"2720171","Do any replacements for CryptoAPI exist for Windows?","<p>I am having major problems with cryptoAPI, and was wondering do you get any 3rd party / better solutions for windows?</p>

<p>Main problem I have with CryptoAPI is that its not OS independent enough. I can't find the right balance in my code to get stuff to work on Windows 2003 and Windows 2008+. </p>

<p>What I essentially want to achieve can be read about <a href=""https://stackoverflow.com/questions/2720276/how-to-use-crypto-to-extract-the-textual-information-in-a-file"">here</a>. This is my only use for Cryptography at this stage.</p>
","<p>Crypto++ is amazing in power, but suffers from its complexity and a lack of automation/documentation. It also suffers from a lack of debugging I think, when the check does not work, it just does not work, but you're given little hints as to what could cause the failure...</p>

<p>Anyway, since you are using C++, may I suggest <a href=""http://www.keyczar.org/"" rel=""nofollow noreferrer"">Google Keyczar</a> ?</p>

<ul>
<li>It's meant to be easy to use, with safe defaults, yet allows customization.</li>
<li>It comes up with a complete Key Management system, which Crypto++ does not feature and which is complicated enough to code by oneself.</li>
<li>It's open source too, so the code can be audited.</li>
<li>It's portable even outside of the Windows environment.</li>
</ul>

<p>I haven't, unfortunately, used it myself. I am currently stuck with Crypto++. But if I had the opportunity to choose right now, I think I'd invest time to experiment with Keyczar.</p>
","447","<c++><c><api><cryptoapi>","3","1","5","2013-08-09 12:00:04","","0","","-1","","2017-05-23 12:26:46","2010-04-27 09:51:51",""
"38466999","X509Certificate constructor takes >6 seconds to execute for a particular user","<p>I've developed a C#, .NET4.5.2 client/server system which uses TLS/SSL to communicate.  The certificates are loaded from a file.  I created the certificate files using 'MakeCert' utitilty to create a .pvk and .cer file then I combined them into a .pfx using 'pvk2pfx' utility.</p>

<p>To use the certificates I load them by using the X509Certificate2 constructor with the overload to pass in the file path and password as strings:</p>

<pre><code>X509Certificate2(string filePath, string password)
</code></pre>

<p>I've noticed over time that the loading of certificates has become very slow.  I'm not sure if there was an 'event' that made them slow or if it has been gradual but it's now up to about 6 seconds to load the PFX file.  Loading the CER file is no problem and takes ~0.1 seconds.</p>

<p>I'm running Windows 8.1 and the problem is only for my user login on the laptop.</p>

<p>I wrote the following test app to verify the problem:</p>

<pre><code>    private const string filePath = @""c:\testcert.pfx"";
    private const string password = ""testpassword"";
    static void Main(string[] args)
    {
        var stopwatch = new Stopwatch();
        try
        {
            Console.WriteLine(""About to create certificate. Press Enter."");
            Console.ReadLine();

            stopwatch.Start();
            var cert = new X509Certificate(filePath, password);
            stopwatch.Stop();

            Console.WriteLine(stopwatch.Elapsed);
            Console.WriteLine(""Certificate created. About to reset.  Press Enter."");
            Console.ReadLine();

            cert.Reset();

            Console.WriteLine(""Certificate reset.  Press Enter."");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
        Console.ReadLine();
    }
</code></pre>

<p>I asked some colleagues to run the program on their PCs.  I also tried running within a VM and then setting up a new user on my own laptop. In all cases it ran in ~0.1 seconds but for my normal user login it runs in >6 seconds.</p>

<p>At first I wasn't calling 'Reset()' on the certificate so thought perhaps there was a problem with some temporary files somewhere so I used procmon to find out what was happening.  I identified that some temporary files were being created in the following directory (although they got tidied up when the application exited even without the call to Reset()):</p>

<pre><code>C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Crypto\RSA\&lt;SID&gt;
</code></pre>

<p>Just to be sure I've tried deleting the files in this directory but it doesn't make any difference.</p>

<p>Using procmon I can see that there are 2 gaps in file/registry activity during the loading of the certificate which don't occur in a system where the load is fast.  First is just after it tries to use 'dpapi.dll'.  The second is after a read to the following 'C:\Extend\$UsnJrnl:$J:$DATA'.  DPAPI.dll is the interface for Windows Data Protection.  The latter file is the USN Journal for NTFS which records file changes.  I'm no expert on either and I'm not sure if either is relevant!</p>

<p>I've then tried using API Monitor  <a href=""http://www.rohitab.com/apimonitor"" rel=""nofollow"">http://www.rohitab.com/apimonitor</a> to observe system calls.  Again I'm no expert but I trawled through to see what was happening just before the pauses.  There's a lot in there I don't understand that may or may not be relevant and I welcome comment on any of it to help focus in on the problem.</p>

<p>The last call before a 2 second gap is a memcpy with the following call stack:</p>

<pre><code>#   Module  Address Offset  Location
1   RPCRT4.dll  0x74f6378b  0x2378b I_RpcSendReceive + 0x1bb
2   RPCRT4.dll  0x74f6367b  0x2367b I_RpcSendReceive + 0xab
3   RPCRT4.dll  0x74f594df  0x194df NdrServerInitializeNew + 0x83f
4   RPCRT4.dll  0x74f63619  0x23619 I_RpcSendReceive + 0x49
5   RPCRT4.dll  0x74f6398b  0x2398b NdrSendReceive + 0x2b
</code></pre>

<p>Higher up the potentially interesting lines seem to be:</p>

<pre><code>#   Time of Day Thread  Module  API Return Value    Error   Duration
64922   6:38:44.348 AM  1   DPAPI.dll   SystemFunction040 ( 0x00ac5a30, 8, RTL_ENCRYPT_OPTION_SAME_LOGON )  STATUS_SUCCESS      0.0000402
64923   6:38:44.349 AM  1   CRYPTBASE.dll   RtlInitUnicodeString ( 0x0090e5a8, ""\Device\KsecDD"" )           0.0000004

64949   6:38:44.349 AM  1   RPCRT4.dll  RtlInitUnicodeString ( 0x0090e0b0, ""\RPC Control\protected_storage"" )           0.0000000
</code></pre>

<p>I find it difficult to trace the callstack but I think these are ultimately coming from a function called CryptQueryObject.</p>

<p>I've found the following article which may be relevant but it's not Windows8.1.  I've deleted the %windir%\Temp folder just in case but also hasn't helped.</p>

<p><a href=""https://support.microsoft.com/en-gb/kb/931908"" rel=""nofollow"">https://support.microsoft.com/en-gb/kb/931908</a></p>

<p>I remember finding an article somewhere that suggested a delay might be something to do with ActiveDirectory calls from CryptQueryObject but I can't find the link.   </p>

<p>I'm really looking for:</p>

<ol>
<li>How to fix my user login so it doesn't take 6 seconds to load a certificate</li>
<li>How to ensure my code is OK so it doesn't happen again or to other people using the system</li>
</ol>

<p>Thanks for any help.</p>
","<p>This issue has now resolved and I <em>think</em> I understand why!</p>

<p>When you load an X509Certificate with a private key, Windows stores the key to a file and encrypts the file using 'Data Protection' (hence the calls to DPAPI I had monitored). </p>

<p><a href=""https://technet.microsoft.com/en-us/library/cc962112.aspx"" rel=""nofollow"">https://technet.microsoft.com/en-us/library/cc962112.aspx</a></p>

<p>The key used to encrypt the file is called a 'Master Key'.  It is based on your user login and gets renewed whenever you change your use password.  It also automatically expires after 90 days.</p>

<p><a href=""http://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28#33"" rel=""nofollow"">http://www.passcape.com/index.php?section=docsys&amp;cmd=details&amp;id=28#33</a></p>

<p>As described in the above link, the master key is stored in the following directory:</p>

<pre><code>%APPDATA%/Microsoft/Protect/%SID%
</code></pre>

<p>I could see that my MasterKey was in fact older than 90 days by looking at the 'last modified' date on the files in that directory.  So, whenever I was loading a certificate, it was trying to store the private key in an encrypted file and noticed that the Master Key was out of date so it would then try and update it.</p>

<p>I reran ProcMon but stopped filtering for activity just from my test app.  I could then see that a number of UDP calls to our Active Directory server were being made during the 'gaps' by a process called lsass.exe which is to do with security and password updates (can't post another link due to stack overflow restrictions but easy to search for).</p>

<p>I think that the process of trying to update the master key must involve some interaction to the ActiveDirectory service.</p>

<p>I work remotely and connect to my work network via VPN.  The VPN does not allow access to the ActiveDirectory server so  I think the delays were caused by trying and failing to access that server.</p>

<p>I waited till my next visit to the office and as soon as I was connected to the network and could access the ActiveDirectory server then the delay in loading certificates disappeared.  I confirmed that my MasterKey files have also been updated and are no longer out of date.</p>

<p>I retested loading certificates while connected via the VPN and the delay is still gone so this does seem to confirm that it is OK as long as the Master Key isn't out of date.</p>

<p>Unfortunately, I couldn't change my password over the VPN due to the same problems of not being able to access the Active Directory service.</p>

<p>My problem solved.  I appreciate it was probably fairly unique but I hope the details of my investigation help somebody else at some point!</p>
","445","<c#><ssl><cryptoapi><x509certificate2><dpapi>","0","0","1","2016-08-03 07:22:39","","0","1","6609382","","2016-07-19 19:41:03","2016-07-19 19:31:17",""
"48468599","CryptBinaryToStringA not encoding in B64","<p>My goal is to use CryptoAPI to take some bytes of a signed and encoded certificate made in CryptoAPI and convert them to B64. Problem is, the certificate header is being tacked on but the output is not B64!</p>

<p>My output:</p>

<blockquote>
  <p>-----BEGIN CERTIFICATE-----MIIDfjCCAmagAwIBAgIBAjANBgkqhkiG9w0BAQsFADBoMQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xEDAOBgNVBAoMB0FVVE9TT0wxDzANBgNVBAsMBkNNREVQVDEUMBIGA1UEAwwLbmFtZWRwaXBlQ0EwHhcNMTgwMTI2MTk0NDQ2WhcNMTkwMTI2MTk0NDQ2WjBlMQswCQYDVQQGEwJVUzEOMAwGA1UECAwFVGV4YXMxEDAOBgNVBAcMB0hvdXN0b24xDDAKBgNVBAoMA0RpczEmMCQGA1UEAwwdU1ZSLkNNMDA0MDlEOTg4RTk1LjE1MTY5OTQ5OTIwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD28NOZkuJbUsU0COQFrJgMgzGaj/afj6lYKZyTr5oXtenSmTAXN0WJE7Wd7DCfKqPpbnui4mb62Tgn3NCyMyEHY5jzFUWaUIchlmVzkamQzkmE3g99Fhj3EZP9zAEQE7qs7p5aKcgzIHuMRDB16Ap7/GcFLTUBXcval17yOyU+J9csiywTRA54IK8nvtXzYVvgDSKXOh02VEU9RIjE4C069PKGg04lwZNHm8KvuPJn70PXQQnDaoSkbyvh46lKGhJUsNzNsV0Dpk1owrV9jCCUhpOKdA61Ye8P1oFgLkyu8VV4FjJL7/t7AwaV7AgV7fVtOQ1fZ1HU4VheDD+Q23snAgMBAAGjNjA0MBMGA1UdJQQMMAoGCCsGAQUFBwMBMA4GA1UdDwEB/wQEAwIFoDANBgNVHQoEBjAEAwIGQDANBgkqhkiG9w0BAQsFAAOCAQEAShaqwVJvEjg9n4Tw24hBvl5pXpRGlUjgOQHDsk9sf8WWlDQWZzdRbaw9Y2QBEPuBbxbnF/voiUwYIhWrIYZziZDmx4mHuM1tt7Dyo79pAaJ6KrYkEzOoLP9VCuC1qHsux9cwYb1WiJmJtIZi22aFvAXDCQ3cDr6ej+PbgrXOL+oaS3b95F2ds6zWhDjyFwBLldkAXB4P/GiiOnS3X85DVxWLzY+y88hoKqBYJq5vaAIdLHlqA6jZJYuR2VUjVixggLclAeGUYO9ljLcyS9aer0DFJvdCMKJyUfcN6t6s/tDsKO7nrJrPNIVxbXfg8KzVnWG3Px9KTF9u9bt2G3kJNg==-----END
  CERTIFICATE-----</p>
</blockquote>

<p>If I paste the above text here and try to decode it, it fails...its not B64:
<a href=""https://www.base64decode.org/"" rel=""nofollow noreferrer"">https://www.base64decode.org/</a></p>

<p>If I go to <a href=""https://www.base64encode.org/"" rel=""nofollow noreferrer"">https://www.base64encode.org/</a> and paste in the above, the tool converts it to B64 which I can submit via the in-house API call I need to make and OpenSSL is happy with it. I need to use the last two function calls in the code sample to do this, but its not working. No errors are being thrown.</p>

<p>Code:</p>

<pre><code>std::string sCertificate;
HCRYPTPROV hCaProv = NULL;
PCRYPT_KEY_PROV_INFO pKeyInfo_CA = NULL;
CERT_INFO serverCertInfo;
CRYPT_ALGORITHM_IDENTIFIER signAlgo;
DWORD cbEncodedCert_SERVER = 0;
LPBYTE pbEncodedCert_SERVER = NULL;
DWORD dwB64CertificateLength;
LPSTR lpstrServerCertificate = NULL;

//...
//do a million things to process a CSR and make a certificate ready to be signed

//use CryptSignAndEncodeCertificate to figure out how much space to allocate for the certificate
if (!CryptSignAndEncodeCertificate(
    hCaProv,
    pKeyInfo_CA-&gt;dwKeySpec,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    X509_CERT_TO_BE_SIGNED,
    (void*)&amp;serverCertInfo,
    &amp;signAlgo,
    NULL,
    NULL,
    &amp;cbEncodedCert_SERVER
))
{
    LocalFree(pbEnhancedUsage);
    LocalFree(pbUsage);
    LocalFree(pbEncodedBasicConstraints);
    CertFreeCertificateContext(pCACertContext);
    CryptReleaseContext(hCaProv, 0);
    CertCloseStore(hStoreRoot, 0);
    throw std::runtime_error(""Unable to sign and encode certificate"");
}

//allocate space for the certificate
pbEncodedCert_SERVER = (LPBYTE)LocalAlloc(0, cbEncodedCert_SERVER);

//use CryptSignAndEncodeCertificate to sign and encode the new certificate
if (!CryptSignAndEncodeCertificate(
    hCaProv,
    pKeyInfo_CA-&gt;dwKeySpec,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    X509_CERT_TO_BE_SIGNED,
    (void*)&amp;serverCertInfo,
    &amp;signAlgo,
    NULL,
    pbEncodedCert_SERVER,
    &amp;cbEncodedCert_SERVER
))
{
    LocalFree(pbEnhancedUsage);
    LocalFree(pbUsage);
    LocalFree(pbEncodedBasicConstraints);
    CertFreeCertificateContext(pCACertContext);
    LocalFree(pbEncodedCert_SERVER);
    CryptReleaseContext(hCaProv, 0);
    CertCloseStore(hStoreRoot, 0);
    throw std::runtime_error(""Unable to sign and encode certificate"");
}

//free up a bunch of memory we don't need anymore
CertFreeCertificateContext(pCACertContext);
CryptReleaseContext(hCaProv, 0);
CertCloseStore(hStoreRoot, 0);
LocalFree(pbEnhancedUsage);
LocalFree(pbUsage);
LocalFree(pbEncodedBasicConstraints);

//convert to B64 (call #1 to get length)
if (!CryptBinaryToStringA(
    pbEncodedCert_SERVER,
    cbEncodedCert_SERVER,
    CRYPT_STRING_BASE64HEADER | CRYPT_STRING_NOCRLF,
    NULL,
    &amp;dwB64CertificateLength
))
{
    LocalFree(pbEncodedCert_SERVER);
    throw std::runtime_error(""Could not get size of B64 string for server certificate"");
}

//allocate space based on call #1
lpstrServerCertificate = (LPSTR)LocalAlloc(0, dwB64CertificateLength);

//convert to B64 (call #2 to encode)
if (!CryptBinaryToStringA(
    pbEncodedCert_SERVER,
    cbEncodedCert_SERVER,
    CRYPT_STRING_BASE64HEADER | CRYPT_STRING_NOCRLF,
    lpstrServerCertificate,
    &amp;dwB64CertificateLength
))
{
    LocalFree(pbEncodedCert_SERVER);
    LocalFree(lpstrServerCertificate);
    throw std::runtime_error(""Could not make B64 string of server certificate"");
}

//put the certificate text into a std::string to pass it out of the function and be done
sCertificate = lpstrServerCertificate;

//free resources
LocalFree(pbEncodedCert_SERVER);
LocalFree(lpstrServerCertificate);
</code></pre>

<p>Suggestions? I feel I might be doing a simple mistake here but I don't know what.</p>
","<p>I would think that CryptBinaryToString would actually convert the result to B64 on first pass...for some reason another pass was required. Seems silly to have to call the same function 4 times to do the job but apparently its necessary. I added this code and called it on sCertificate the code above and now I have something in B64 that works. Go figure. Hopefully another person gets something out of this.</p>

<pre><code>bool UTIL::EncodeB64(
    std::string sToEncode, //data to encode in B64 [IN]
    std::string &amp; sEncoded //encoded data [OUT]
    )
{
    sEncoded = """";
    LPSTR lpstrEncoded = NULL;
    DWORD dwB64Length;
    std::vector&lt;BYTE&gt; vcharBytes(sToEncode.begin(), sToEncode.end());

    //convert to B64 (call #1 to get length)
    if (!CryptBinaryToStringA(
        &amp;vcharBytes[0],
        vcharBytes.size(),
        CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
        NULL,
        &amp;dwB64Length
    ))
    {
        //crashed and burned
        return false;
    }

    //allocate space based on call #1
    lpstrEncoded = (LPSTR)LocalAlloc(0, dwB64Length);

    //convert to B64 (call #2 to encode)
    if (!CryptBinaryToStringA(
        &amp;vcharBytes[0],
        vcharBytes.size(),
        CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
        lpstrEncoded,
        &amp;dwB64Length
    ))
    {
        //crashed and burned
        LocalFree(lpstrEncoded);
        return false;
    }

    //set result that we are going to pass out
    sEncoded = lpstrEncoded;

    //free memory
    LocalFree(lpstrEncoded);

    //success
    return true;
}
</code></pre>

<p>Added to calling code:</p>

<pre><code>std::string sB64Pass1Certificate = lpstrServerCertificate;

LocalFree(pbEncodedCert_SERVER);
LocalFree(lpstrServerCertificate);

if (!EncodeB64(
    sB64Pass1Certificate,
    sCertificate
))
{
    throw std::runtime_error(""Could not make B64 string of server certificate (second pass)"");
}
</code></pre>
","436","<c++><windows><encoding><x509><cryptoapi>","0","0","1","2018-01-26 21:28:24","","4","","608639","","2018-01-26 20:26:01","2018-01-26 19:52:59",""
"40660426","How to stop Windows CryptoAPI to add private key to public-only cert upon decryption","<p>I'm trying to test S/MIME decryption but CryptDecryptMessage function in decryption mode keeps working even if the certificate in Personal store is public-only (while private key is needed for decryption). Magically, the certificate turns into private+public certificate after this function is called.</p>

<p>Initially, I had full certificate in my Personal store and everything was working fine. Then, I had to test what would happen if someone tried to decrypt having just a public-key cert. So I exported public key, removed cert from the store and imported the public key alone. But I can't do my testing that because Windows somehow adds the private key back to the cert. Perhaps, there is some internal cache of private keys or something like that which is activated when CryptoAPI needs the private key. I would like to disable this feature if possible or somehow tell the system that I don't want to use it with my CryptoAPI calls.</p>

<p>The same occurs with Outlook (as it internally uses the same CryptoAPI functions).</p>

<p>I now added the excerpt from sources (cannot create the fully self-contained sample as it turns out to be too complex) but the decryption part should be OK. I double checked that the private key appears in the certificate at the very moment when CryptDecryptMessage is executed, not before or after.</p>

<pre><code>// stores is 1 entry (MY), got with CertOpenStore
// contentBytes is our data to decrypt
IntPtr[] storeHandles = new IntPtr[stores.Length];
for (int i = 0; i &lt; stores.Length; i++)
{
    if (stores[i] != null)
    {
        storeHandles[i] = stores[i].Handle;
    }
}
byte[] contentBytes = data;
IntPtr pDecryptPara = IntPtr.Zero;
IntPtr pbEncryptedBlob = IntPtr.Zero;
uint cbEncryptedBlob = (uint)contentBytes.Length;
IntPtr pbDecrypted = IntPtr.Zero;
uint cbDecrypted = 0;
CRYPT_DECRYPT_MESSAGE_PARA decryptPara = new CRYPT_DECRYPT_MESSAGE_PARA();
decryptPara.cbSize = (uint)Marshal.SizeOf(decryptPara.GetType());
decryptPara.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
decryptPara.cCertStore = (uint)storeHandles.Length;

GCHandle storeHandlesHandle = GCHandle.Alloc(storeHandles, GCHandleType.Pinned);
decryptPara.rghCertStore = (IntPtr) storeHandlesHandle.AddrOfPinnedObject();

IntPtr pXchgCert = IntPtr.Zero;

pDecryptPara = Marshal.AllocHGlobal((int)decryptPara.cbSize);
Marshal.StructureToPtr(decryptPara, pDecryptPara, true);

pbEncryptedBlob = Marshal.AllocHGlobal((int)cbEncryptedBlob);
Marshal.Copy(contentBytes, 0, pbEncryptedBlob, (int)cbEncryptedBlob);
// At this point the cert in MY storage does not have private key
int ret = CryptoApiFuncs.CryptDecryptMessage(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, ref cbDecrypted, ref pXchgCert);
// Now the cert has the private key
</code></pre>
","","436","<c#><winapi><certificate><private-key><cryptoapi>","1","","0","2016-11-21 17:12:49","","2","1","695182","","2016-11-21 17:12:49","2016-11-17 16:41:45",""
"21868286","CCCrypto decrypt: exactly one block less","<p>I'm trying to decrypt string encrypted by golang script. The encryption is CBC, key size 256. 16 bytes long iv is include at the beginning of ciphered text, as golang doc suggested. Everything works fine except the objc codes always lost the last <em>block</em>. e.g. when I expect 80 bytes return but only get 64, expect 128 but get 112. any advice? thanks!</p>

<p><strong>golang code</strong></p>

<pre><code>func encrypt(text_s, key_s string) byte[] {

    text := []byte(text_s)

    // padding text
    n := aes.BlockSize - (len(text) % aes.BlockSize)
    log.Println(""Need to pad:"", n)

    if n != aes.BlockSize || n != 0 {
        text = append([]byte(strings.Repeat("" "", n)), text...)
    }

    log.Println(""to encrypt:'"", string(text), ""'"")
    log.Println(""padded length:"", len(text))

    key  := []byte(key_s)[:32]
    block, _ := aes.NewCipher(key)

    // if err != nil {
    //  panic(err)
    // }

    ret := make([]byte, aes.BlockSize + len(text))
    iv  := ret[:aes.BlockSize]

    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        panic(err)
    }

    cbc := cipher.NewCBCEncrypter(block, iv)
    cbc.CryptBlocks(ret[aes.BlockSize:], text)

    return ret
}
</code></pre>

<p><strong>objc codes</strong>:</p>

<pre><code>    - (NSData *)decrypt:(NSData*)data{
    if (!key) {
        key = [[_token substringToIndex:32] dataUsingEncoding:NSUTF8StringEncoding];
    }

//    NSLog(@""decodbase64 :%@"",[[NSString alloc] initWithData:data encoding:NSASCIIStringEncoding]);
//    NSString *key = _token;
//    
//    char keyPtr[kCCKeySizeAES256 + 1]; // room for terminator (unused)

    // 'key' should be 32 bytes for AES256, will be null-padded otherwise
//    bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)

//    BOOL patchNeeded = ([_token length] &gt; kCCKeySizeAES256);
//    NSLog(@""need patch? %@"", patchNeeded ? @""YES"": @""NO"");
//    
//    if (patchNeeded) {
//        key = [_token substringToIndex:kCCKeySizeAES256]; // Ensure that the key isn't longer than what's needed (kCCKeySizeAES256)
//    }

    // fetch key data
//    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSASCIIStringEncoding];

//    if (patchNeeded) {
//        // Previous iOS version than iOS7 set the first char to '\0' if the key was longer than kCCKeySizeAES256
//        keyPtr[0] = '\0';  
//    }

    size_t dataLength   = [data length] - kCCBlockSizeAES128;
    NSData *iv          = [data subdataWithRange:NSMakeRange(0, kCCBlockSizeAES128)];
    NSData *encrypted   = [data subdataWithRange:NSMakeRange(kCCBlockSizeAES128, dataLength)];

    //See the doc: For block ciphers, the output size will always be less than or
    //equal to the input size plus the size of one block.
    //That's why we need to add the size of one block here
//    size_t bufferSize = dataLength + kCCBlockSizeAES128;
//    void *buffer = malloc(dataLength);
    NSMutableData *ret = [NSMutableData dataWithLength:dataLength + kCCBlockSizeAES128];

    size_t numBytesDecrypted = 0;
    CCCryptorStatus status = CCCrypt(kCCDecrypt, kCCAlgorithmAES,
                                          kCCOptionPKCS7Padding,
                                          [key bytes],
                                          kCCKeySizeAES256,
                                          [iv bytes],
                                          [encrypted bytes], dataLength, /* input */
                                          [ret mutableBytes], [ret length], /* output */
                                          &amp;numBytesDecrypted
                                          );

    NSLog(@""err: %d"", status);
    NSLog(@""dataLength: %d, num: %d"", (int)dataLength, (int)numBytesDecrypted);
    if (status == kCCSuccess) {
        //the returned NSData takes ownership of the buffer and will free it on deallocation
        return ret;
    }

//    free(buffer); //free the buffer;
    return nil;
}
</code></pre>
","<p>it turns out the problem is with the decryption option:</p>

<pre><code>CCCryptorStatus status = CCCrypt(kCCDecrypt, kCCAlgorithmAES,
                                          0, // change to 0 solve the problem
                                          [key bytes],
                                          kCCKeySizeAES256,
                                          [iv bytes],
                                          [encrypted bytes], dataLength, /* input */
                                          [ret mutableBytes], [ret length], /* output */
                                          &amp;numBytesDecrypted
                                          );
</code></pre>
","424","<ios><objective-c><encryption><go><cryptoapi>","0","0","1","2014-02-19 10:15:43","21877382","0","","","","","2014-02-19 00:05:52",""
"10626617","Translate PEM to DER on Windows CE 3","<p>I have a RSA public key crypto wrapper which works quite well in desktop Windows and Windows Embedded/POSReady. I need to port this system to both Windows CE 5 and Windows CE 3. In part of this system, I allow developers to import various crypto objects, such as certificates and keys, in several encodings. The most commonly used encoding is Base64 encoded PEM. On most versions of Windows, it is easy to convert encodings to the binary (DER) format that Windows needs for <code>CryptDecodeObjectEx</code> calls:</p>

<pre><code>bool MyClass::externalToBinary( const DATA_BLOB &amp;in, DATA_BLOB &amp;outDER )
{
    DWORD flags;

    // This call determines the format and how much memory is needed in outDER
    if ( ::CryptStringToBinaryA( reinterpret_cast&lt;char *&gt;(in.pbData), in.cbData, CRYPT_STRING_ANY,     NULL, &amp;outDER.cbData, NULL, &amp;flags ) == false &amp;&amp;
         ::CryptStringToBinaryA( reinterpret_cast&lt;char *&gt;(in.pbData), in.cbData, CRYPT_STRING_HEX_ANY, NULL, &amp;outDER.cbData, NULL, &amp;flags ) == false )
    {
        // Log errors here using ::GetLastError();
        return false;
    }

    if ( ( outDER.pbData = new unsigned char[outDER.cbData] ) == NULL )
    {
        // Log errors here using ::GetLastError();
        return false;
    }
    return ( ::CryptStringToBinaryA( reinterpret_cast&lt;char *&gt;(in.pbData), in.cbData, flags, outDER.pbData, &amp;outDER.cbData, NULL, NULL ) != FALSE );
} // end externalToBinary
</code></pre>

<p>Unfortunately, <code>CryptStringToBinary</code> doesn't exist in Windows CE 3's version of CryptoAPI. While I can do away with support for less popular encodings (such as hex), I really don't want to remove support for PEM encoding in the CE 3 version of the API.</p>

<p>Does anyone have a <code>CryptStringToBinary</code> alternative that would work on Windows CE 3? The developers using this API don't currently have OpenSSL as a dependency, so I would prefer not to add it just for this.</p>
","<p>Well - PEM is simply base64 encoded DER. So if this is the only place you need to convert; I'd just forego the API niceties; strip off any empty line or line starting with a '-'; and base64 decode the anything in between. The result is the DER you're after. WindowsCE3 has a Encode/Decodeter type for Base64; If for some reason you do not/cannot want to use that - <a href=""https://stackoverflow.com/questions/342409/how-do-i-base64-encode-decode-in-c"">How do I base64 encode (decode) in C?</a> or <a href=""http://www.adp-gmbh.ch/cpp/common/base64.html"" rel=""nofollow noreferrer"">http://www.adp-gmbh.ch/cpp/common/base64.html</a> are fairly trivial 'raw' versions.</p>
","422","<c++><windows-ce><cryptoapi><pem><der>","3","0","1","2013-12-08 11:04:54","20452668","0","","","","","2012-05-16 20:59:10",""
"24440715","How to import private key with passprhase from PEM file","<p>I trying to load a private key from a PEM file using CryptStringToBinary and CryptDecodeObjectEx, that works fine when the private key is not password protected, but it doesn't work when the key is password protected.</p>

<pre><code>if(!CryptStringToBinary(buffer.get(), length, CRYPT_STRING_BASE64HEADER, reinterpret_cast&lt;BYTE*&gt;(outBuffer.get()),
                        &amp;outLength, 0, 0))
{
    cerr &lt;&lt; ""CryptStringToBinary Error: "" &lt;&lt; GetLastError();
    return -1;
}

DWORD keyBlobLength = 0;
CRYPT_PRIVATE_KEY_INFO* keyBlob = 0;

if(!CryptDecodeObjectEx(X509_ASN_ENCODING, PKCS_PRIVATE_KEY_INFO, 
                        reinterpret_cast&lt;const BYTE*&gt;(outBuffer.get()), 
                        outLength, CRYPT_DECODE_ALLOC_FLAG, 0, &amp;keyBlob, &amp;keyBlobLength))
{
    cerr &lt;&lt; ""CryptDecodeObjectEx Error:\n"" &lt;&lt; GetLastError();
    return -1;
}
</code></pre>

<p>Any ideas how to decrypt the PEM file using the password? I need to use WinCrypt not openssl.</p>
","","415","<c++><ssl><cryptoapi>","1","","0","2014-06-26 21:40:45","","0","","","","","2014-06-26 21:40:45",""
"36714111","What is an analog CryptSetProvParam(PP_SIGNATURE_PIN) analog in CryptoAPI NG?","<p>I'm writing an application for smartcards. I know how my application can obtain the PIN using a method CryptSetProvParam, but I don't know how to do the same thing when I'm using CryptoAPI NG. I want to prevent the PIN request UI window pop up.</p>
","<p>Setting CspParameters.KeyPassword is equivalent to calling CryptSetProvParam with PP_KEYEXCHANGE_PIN (or PP_SIGNATURE_PIN). This flag is not supported by the default Microsoft crypto-service-provider (it is intended for use with smartcard-based CSPs).</p>
","410","<smartcard><cryptoapi><cng>","1","1","1","2017-04-21 00:09:37","43531875","0","","","","","2016-04-19 09:22:58",""
"45531141","how to automaticaly export windows root certificates to a file?","<p>On a windows machine, I want to create a c++ code that exports windows root certificates to <code>.pem \ .crt</code> file (just like certmgr.msc tool allows me to do manually).
currently digging in windows' cryptoAPI docs but didn't find something.</p>

<p>Edit:
after using the soltuion below the PEM certificates are created in the following format (unnecary newline between lines and an extra character at the end) :                                  -----BEGIN CERTIFICATE-----</p>

<p>MIICvDCCAiUCEEoZ0jiMglkcpV1zXxVd3KMwDQYJKoZIhvcNAQEEBQAwgZ4xHzAd</p>

<p>BgNVBAoTFlZlcmlTaWduIFRydXN0IE5ldHdvcmsxFzAVBgNVBAsTDlZlcmlTaWdu</p>

<p>.... </p>

<p>Rj1QNAufcFb2jip/F87lY795aQdzLrCVKIr17aqp0l3NCsoQCY/Os68olsR5KYSS</p>

<p>3P+6Z0JIppAQ5L9h+JxT5ZPRcz/4/Z1PhKxV0f0RY2M=</p>

<p>-----END CERTIFICATE-----</p>

<p>i don't believe it will be accepted by openSSL, what is the cause for this?</p>
","<p>What you're looking for is <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376050(v=vs.85).aspx"" rel=""nofollow noreferrer"">CertEnumCertificatesInStore</a> function.
Also if you want to save certificate in PEM you will need <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379887(v=vs.85).aspx"" rel=""nofollow noreferrer"">CryptBinaryToString</a>.</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

#pragma comment(lib, ""crypt32.lib"")

int _tmain(int argc, _TCHAR* argv[])
{
    DWORD num = 1;
    /* open root certificate store */
    HCERTSTORE hCertStore = CertOpenSystemStore(NULL, L""ROOT"");

    PCCERT_CONTEXT pCert = nullptr;
    while (pCert = CertEnumCertificatesInStore(hCertStore, pCert))
    {
        /* if you need save certificate in PEM */
        DWORD size = 0;
        CryptBinaryToString(pCert-&gt;pbCertEncoded, pCert-&gt;cbCertEncoded, CRYPT_STRING_BASE64HEADER, nullptr, &amp;size);
        std::vector&lt;wchar_t&gt; pem(size);
        CryptBinaryToString(pCert-&gt;pbCertEncoded, pCert-&gt;cbCertEncoded, CRYPT_STRING_BASE64HEADER,
            pem.data(), &amp;size);

        std::wstring pem_cert = std::to_wstring(num) + L"".pem"";
        std::wofstream pem_cert_file(pem_cert, std::ios::binary | std::ios::out);
        pem_cert_file.write(pem.data(), pem.size() - 1);


        /* or if you need save certificate in binary form (DER encoding)*/
        std::string der_cert = std::to_string(num) + "".cer"";
        std::ofstream der_cert_file(der_cert, std::ios::binary | std::ios::out);
        der_cert_file.write(reinterpret_cast&lt;char*&gt;(pCert-&gt;pbCertEncoded), pCert-&gt;cbCertEncoded);
        ++num;
    }

    CertCloseStore(hCertStore, 0);
    return 0;
}
</code></pre>
","408","<certificate><ssl-certificate><x509certificate><pem><cryptoapi>","0","1","1","2017-08-10 09:13:02","","0","","4358948","","2017-08-10 08:43:26","2017-08-06 10:39:37",""
"35853008","Save and load Smart Card Certificate","<p>I need help on sending certificate information from one program to another, and logging into Windows with that information through the use of <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa374801(v=vs.85).aspx"" rel=""nofollow"" title=""CredMarshalCredential"">CredMarshalCredential</a> and <a href=""https://www.idrix.fr/Root/Samples/SmartCardLogon.cpp"" rel=""nofollow"">LogonUser</a>. My program currently passes credentials and logs in successfully with a regular username/password combination. I'm just adding the ability to do it with Smart Card credentials.</p>

<p>I've used this <a href=""https://www.idrix.fr/Root/Samples/SmartCardLogon.cpp"" rel=""nofollow"">example</a> successfully to login with a Smart Card Certificate.</p>

<p>This works when you run the program as the user, but not when trying to run the program as SYSTEM. This is because SYSTEM cannot access the user's ""MY"" store. I'm trying to work around this, either by passing the cert or the entire cert store to the program running as SYSTEM from an application running as the user.</p>

<p>I've tried numerous approaches to get something that would login successfully after serialization, but haven't gotten anything to successfully work. The approach that seems to work the best has been to call <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376567(v=vs.85).aspx"" rel=""nofollow"">CertSaveStore</a> and Open the BLOB. I've used the last example at the bottom of this <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382035(v=vs.85).aspx"" rel=""nofollow"">Microsoft Example Page</a>. This restores the cert store from the BLOB correctly, finds certs, and even generates a username. But the generated username is different than the original generated username and fails to login with an error of ERROR_LOGON_FAILURE (The user name or password is incorrect).</p>

<p>My current test applications saves the cert and loads it again in the same program. I've taken the SYSTEM aspect out of the equation for now. I'm guessing the restored cert store is missing some information, but I'm not sure what I'm missing. Any insight would be appreciated.</p>

<p>One last note, I originally tried to just pass the generated username and PIN to SYSTEM and have it step down, but it failed with the same ERROR_LOGON_FAILURE error. I'm assuming the username has to be regenerated since being called by a different user/program, but that assumption could be wrong.</p>
","<p>I have gotten my example program working with <code>CertSerializeCertificatesStoreElement</code> and <code>CertAddCertificateContextToStore</code>. I am able to serialize the certificate, and add it to a new store in memory at a later time. I had tried this earlier, but accidentally did not save the size of the serialized item, I just tried to use <code>sizeof()</code> the item which returned an incorrect size.</p>

<p>If anyone is looking to send certificate credentials between programs in the same userspace this approach will work well.</p>

<p>I took this ahead step further and implemented it in my userspace/SYSTEM paradigm. The logic worked correctly, and I was able to generate a username but still failed to <code>LogonUser</code>. After another week or trial and error, I found a solution that works between the userspace and SYSTEM. I ended up having to use <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa378292(v=vs.85).aspx"" rel=""nofollow"">LsaLogonUser</a> instead of <code>LogonUser</code>.</p>

<p>If anyone is looking to have a userspace program send credentials to a daemon running in SYSTEM and have that program step down to the user use this <a href=""https://www.idrix.fr/Root/Samples/LsaSmartCardLogon.cpp"" rel=""nofollow"">example</a>. I initially tried this <a href=""https://www.idrix.fr/Root/Samples/LsaSmartCardLogon2.cpp"" rel=""nofollow"">very similar example</a>, but it continues to fail. In the working example, you do not need to pass in a domain or username, just the PIN. The system will read the Smart Card from the reader and verify with the passed in PIN. This solution will work across computers, ONLY IF the smart card is located at the remote computer. I am looking into a way to accomplish having it work with the smart card in the host computer, but it is outside of this post.</p>

<p>I hope this saves someone the weeks of work I put into getting to this point.</p>
","408","<c><certificate><smartcard><cryptoapi>","1","0","1","2016-03-16 17:55:03","35903519","3","1","3067374","","2016-03-09 17:20:24","2016-03-07 20:07:08",""
"22081043","What is this undocumented flag in the Microsoft CryptoAPI File Encrypt Sample?","<p>In the Microsoft C <a href=""http://msdn.microsoft.com/en-us/library/aa382358%28v=vs.85%29.aspx"" rel=""nofollow"">sample code</a> for RC4-encrypting a file using the CryptoAPI, the functions <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379941%28v=vs.85%29.aspx"" rel=""nofollow"">CryptGenKey</a> and <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa379916%28v=vs.85%29.aspx"" rel=""nofollow"">CryptDeriveKey</a> are passed an undocumented flag</p>

<pre><code>#define KEYLENGTH     0x00800000
...
if (CryptGenKey(
        hCryptProv, 
        ENCRYPT_ALGORITHM, 
        KEYLENGTH | CRYPT_EXPORTABLE, 
        &amp;hKey))
...    
</code></pre>

<p>There is no flag with this value defined in the CryptoAPI header file <code>wincrypt.h</code>. Leaving it out doesn't seem to do any harm. In fact, when I change the algorithm from RC4 to AES, using this flag results in an <code>ERROR_INVALID_PARAMETER</code>.</p>

<p>What is it there for?</p>
","<p>It's not <em>undocumented</em>, and it's not a flag. From the page you linked for <code>CryptGenKey</code> (<strong>emphasis mine</strong>):</p>

<blockquote>
  <p>Specifies the type of key generated. The sizes of a session key, RSA signature key, and RSA key exchange keys can be set when the key is generated. <strong>The key size, representing the length of the key modulus in bits, is set with the upper 16 bits of this parameter. Thus, if a 2,048-bit RSA signature key is to be generated, the value 0x08000000 is combined with any other dwFlags predefined value with a bitwise-OR operation.</strong> The upper 16 bits of 0x08000000 is 0x0800, or decimal 2,048. The RSA1024BIT_KEY value can be used to specify a 1024-bit RSA key</p>
</blockquote>

<p>The <code>#define</code> provides the key size used to represent the length of the key modulus in bytes in the upper 16 bits, exactly like the above states. The code sample you've included uses <code>0x00800000</code> instead, to indicate a 128-bit key.</p>

<p>The quote goes on to explain:</p>

<p><strong>The upper 16 bits of 0x08000000 is 0x0800, or decimal 2,048.</strong></p>

<p>The key size (in the upper 16 bits) is combined with a bitwise OR of one of the <em>predefined flag values</em>.</p>
","405","<cryptoapi><mscapi>","0","1","1","2015-06-09 02:48:43","22081189","0","","608639","","2015-06-09 02:48:43","2014-02-27 21:38:57",""
"18654671",".NET RSAKeyValue base64 private key to a single base64 private key","<p>I am supplied the following RSA private key in the format</p>

<pre><code>&lt;RSAKeyValue&gt;
   &lt;Modulus&gt;XXXXXXXX&lt;/Modulus&gt;
   &lt;Exponent&gt;XXXXXXXX&lt;/Exponent&gt;
   &lt;P&gt;XXXXXXXX&lt;/P&gt;
   &lt;Q&gt;XXXXXXXX&lt;/Q&gt;
   &lt;DP&gt;XXXXXXXX&lt;/DP&gt;
   &lt;DQ&gt;XXXXXXXX&lt;/DQ&gt;
   &lt;InverseQ&gt;XXXXXXXXXX/InverseQ&gt;
   &lt;D&gt;XXXXXXXX&lt;/D&gt;
&lt;/RSAKeyValue&gt;
</code></pre>

<p>The XXXX are in Base64 format.</p>

<p>I want to know how to combine it all the XXXXXX bits to a single Base64 string.<br>
With this single Base64 string i do the following:<br>
1. Feed it to a TMemorStream <br>
2. use Indy's TIdDecoderMIME class to decode Base64 from the MemoryStream<br>
3. The decoded MemoryStream is then feed into CryptDecrypt function from wcrypt2.pas (a delphi wrapper of Microsoft's Cryptographic API) from Jedi</p>

<p>I know the solution for public key in the same format</p>

<pre><code>&lt;RSAKeyValue&gt;
&lt;Modulus&gt;xqiYKv0umaLdmrKPyBfYmAfzZYVsvsOJyS4c1lBPjqpn7zh+XyxPXK7MxJkAlenQJM33M+ZYfmlPLya7JWXXTPviylEEtlmul9GshpX2caxWu2YO9vNIHRZYYau4ccbkm95iMyJi8KN2ANtqDwiJv55vcXZDqjPSDE4ap49xmog==&lt;/Modulus&gt;
&lt;Exponent&gt;AAQC&lt;/Exponent&gt;
&lt;/RSAKeyValue&gt;
</code></pre>

<p>The solution is to add ""BgIAAACkAABSU0ExAAQAAAE"" + Exponent + Modulus</p>

<p>The result is:
    BgIAAACkAABSU0ExAAQAAAEAAQCxqiYKv0umaLdmrKPyBfYmAfzZYVsvsOJyS4c1lBPjqpn7zh+XyxPXK7MxJkAlenQJM33M+ZYfmlPLya7JWXXTPviylEEtlmul9GshpX2caxWu2YO9vNIHRZYYau4ccbkm95iMyJi8KN2ANtqDwiJv55vcXZDqjPSDE4ap49xmog==</p>

<p>With the private key how do we combine it? I know it starts off like this:</p>

<p>""BwIAAACkAABSU0ExAAQAAAE"" + Exponent + Modulus + ???????</p>
","<blockquote>
  <p>The XXXX in the RSAKeyValue XML are in base64, just that i do not want to expose the details there. I want to know how do i combine all the XXXX base64 codes into a single base64 private key.</p>
</blockquote>

<p>I suspect that this means that you are performing the base64 encoding line by line. It's much simpler to perform the encoding on the entire file.</p>

<p>For example you might do this as follows:</p>

<ol>
<li>Load the file into a <code>TStringList</code>.</li>
<li>Extract a single string representing the file using the <code>Text</code> property of the string list.</li>
<li>Base64 encode that string.</li>
<li>Send it over the wire.</li>
<li>At the receiving end, decode the string.</li>
<li>Assign the string to the <code>Text</code> property of a string list.</li>
</ol>
","396","<delphi><cryptoapi>","-1","0","1","2013-09-09 00:31:23","","6","","2732388","","2013-09-09 00:31:23","2013-09-06 09:40:44",""
"9115974","Passing a structure appears to corrupt data","<p>I have a program that needs to pass data from C++ to C# and back for processing.  In order to do this, I have retrieved a structure, converted it into a byte array and then converted it back on the other end.  However, when converting it back, the data is not correct, even though the memory dump shows that the values in memory for each variable are identical.</p>

<p>Here is the code to retrieve the value:</p>

<pre><code>array&lt;Byte&gt; ^ GetPublicKeyBlob(String ^ ContainerName) {
    const TCHAR * tContainer = context-&gt;marshal_as&lt;const TCHAR*&gt;(ContainerName);
    HCRYPTPROV hProv = NULL;
    CryptAcquireContext(&amp;hProv, tContainer, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET);
    DWORD dwKeySize = 0;
    CryptExportPublicKeyInfo(hProv, AT_SIGNATURE, X509_ASN_ENCODING, NULL, &amp;dwKeySize);
    PCERT_PUBLIC_KEY_INFO pbKey = (PCERT_PUBLIC_KEY_INFO)calloc(dwKeySize, sizeof(BYTE));
    CryptExportPublicKeyInfo(hProv, AT_SIGNATURE, X509_ASN_ENCODING, (PCERT_PUBLIC_KEY_INFO)pbKey, &amp;dwKeySize);
    array&lt;Byte&gt; ^ retVal = gcnew array&lt;Byte&gt;(dwKeySize);
        for(int i = 0; i &lt; dwKeySize; i++)
            retVal[i] = ((BYTE*)pbKey)[i];

    free(pbKey);
return retVal;
}
</code></pre>

<p>Then on the other end, I change it back to a PCERT_PUBLIC_KEY_INFO structure with the following code:</p>

<pre><code>BYTE * cpiBuffer = (BYTE*)calloc(_PublicKey-&gt;Length, sizeof(BYTE));
for(int i = 0; i &lt; _PublicKey-&gt;Length; i++)
    cpiBuffer[i] = _PublicKey[i];
PCERT_PUBLIC_KEY_INFO cpi = (PCERT_PUBLIC_KEY_INFO)cpiBuffer;
</code></pre>

<p>When looking at them in a memory dump, pbKey, retVal, _PublicKey, cpiBuffer and cpi all have the exact same values.  But when looking at cpi as a structure, the Algorithm.pszObjId points to some erroneous memory location and when I try to use it in a function, it fails.  What am I doing wrong here?</p>
","<pre><code>typedef struct _CRYPT_ALGORITHM_IDENTIFIER {
  LPSTR            pszObjId;
  CRYPT_OBJID_BLOB Parameters;
} CRYPT_ALGORITHM_IDENTIFIER, *PCRYPT_ALGORITHM_IDENTIFIER;
</code></pre>

<p>As you can see, pszObjId is a pointer, it's contents are somewhere in memory. By casting the PCERT_PUBLIC_KEY_INFO structure to byte array you are only getting the value of the pointer, not what it points to.</p>

<p>On a side note, I'm not sure why are you marshaling as TCHAR*, if you want bytes then you should use char* or unsigned char*. If UNICODE is defined TCHAR will be wchar_t and that might make some difficulties.</p>
","394","<c#><c++><interop><c++-cli><cryptoapi>","0","0","1","2012-02-02 16:54:22","","2","","","","","2012-02-02 16:28:39",""
"30570209","Getting error while using CryptAcquireCertificatePrivateKey API to extract private key from PFX file","<p>We are developing VC++ application using Crypto APIs for windows 7 OS.
We are using CryptAcquireCertificatePrivateKey API to extract private key from PFX file  .</p>

<p>On executind this API, we are getting below error:</p>

<p>0X8009200B(private key error)</p>

<p>PFX file used with this API has multi layer certificate(root and intermediate).
When we use such PFX file, error comes.
And if we use PFX having single layer certificate that time it works.</p>

<p>So please suggest the reason for its failing.</p>

<p>Note: PFX file is provided by third party vendor(like symantec).</p>

<p>Thanks in advance.</p>
","","393","<certificate><cryptoapi><pfx>","2","","0","2015-06-01 09:41:51","","1","","","","","2015-06-01 09:41:51",""
"33515969","Create HMAC SHA1 in C using pure linux crypto api","<p>I need to apply HMAC SHA1 on some scatterlists in a C program.
I have a sample code written for <strong>kernel 2.4</strong> hmac crypto api, that uses this function:</p>

<p><code>void crypto_hmac(struct crypto_tfm *tfm, u8 *key, unsigned int *keylen, struct scatterlist *sg, unsigned int nsg, u8 *out)</code></p>

<p>but the crypto API in <strong>kernel 3.13</strong> and after is SO MUCH DIFFERENT than 2.4!</p>

<p>I looked everywhere to find any example of using new strange minimalized function</p>

<pre><code>static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)
</code></pre>

<p>provided in <strong>hmac.c (source/crypto)</strong>, but I cannot find any topic or examples that uses kernel crypto api <strong>specificly</strong> <strong>hmac</strong> transform.</p>

<p>Any body has any experience using <strong>Linux Crypto API HMAC in C</strong>? Using this procedure will not be more than a few line of C codes.</p>
","","392","<c><linux><hmac><cryptoapi>","4","","0","2015-11-04 08:21:38","","1","","5523375","","2015-11-04 08:21:38","2015-11-04 07:24:26",""
"40238501","Windows CryptoAPI symmetric encoding/decoding block that already aligning","<p>I need migrating from OpenSSL to MS CryptoAPI.</p>

<p>When I use OpenSSL, I got N-bytes (already aligned - for example, let say the data length = 32bytes) of data and encode/decode it from one buffer to another. All works fine.</p>

<p>Now I must ""use CryptoAPI!"".
So I write something like:</p>

<pre><code>    // Import AES key
    if(!CryptImportKey(m_hProvider, (CONST BYTE*)&amp;aeskey, structsize, NULL, 0, &amp;m_hAesKey ) ) {
        throw WinAESException(""SetKey: Import key failed"");
    }

    // Set Mode
    DWORD dwMode = CRYPT_MODE_ECB; //I can also use CRYPT_MODE_CBC with set of IV but let simple the code;
    if(!CryptSetKeyParam(m_hAesKey, KP_MODE, (BYTE*)&amp;dwMode, 0)) {
        throw WinAESException(""SetKey: Set ECB mode failed"");
    }
</code></pre>

<p>It's works ok,
and now I try to encode the data</p>

<pre><code>    DWORD d = (DWORD)psize;
    result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, buffer, &amp;d, (DWORD)bsize );
</code></pre>

<p>And what I see? The encoded part of data is larger than source.
I understand that the CryptEncrypt function somehow padded already padding data?</p>

<p>Is it possible, anyhow, to get the codded result the same size as it was plain data?</p>

<p>I do not use not-aligned block, I want, when I encrypt 32bytes, to get exactly 32bytes, not 48...</p>

<p>When I test expected size </p>

<pre><code>    DWORD d = 16;
    result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, 0, &amp;d, (DWORD)bsize );  //need 32

    d = 32;
    result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, 0, &amp;d, (DWORD)bsize );  //need 48 

    d = 48;
    result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, 0, &amp;d, (DWORD)bsize );   //need 64

    d = 64;
    result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, 0, &amp;d, (DWORD)bsize );  //need 80
</code></pre>

<p>WTHF I do wrong? 
P.S. If I truncate the encrypted result to desired size and then try to decrypt it, decryption done with returned expected error code, but the data decrypted correctly.  but this hack is not for me...</p>
","<p>It seems that I find the temporary solution.
When I need to encrypt/decrypt the entire block - all I need is to lie the function - ""it is not the last/the only block"":
So type not:</p>

<pre><code>result = CryptEncrypt( m_hAesKey, NULL, TRUE, 0, buffer, &amp;d, (DWORD)bsize );
</code></pre>

<p>but:</p>

<pre><code>result = CryptEncrypt( m_hAesKey, NULL, FALSE, 0, buffer, &amp;d, (DWORD)bsize );
</code></pre>

<p>Now it works. And hope they do not change concept of padding data at the end of last piece to start add alignment at the begining of block...</p>
","392","<c++><aes><padding><cryptoapi><ecb>","0","-1","1","2016-10-25 12:46:10","","4","","","","","2016-10-25 11:16:14",""
"51941921","Where can I get a crypto api that converts fiat currency amount to crypto currency value","<p>I am asking if there is any crypto api which can accept a fiat currency of any amount(USD) and can convert the equivalent value to a crypto currency 
value(BTC,ETH,BCH,LTC).a typical example of what am talking about is google crypto converter. ""bitcoin to usd"" &lt;= making this GET request to google will tell better.</p>

<pre><code>https://exampledomain.com/search?=usd+to+eth&amp;amount=100
</code></pre>

<p>Just something similar to this, I looked for something similar to this in cryptocompare api, programmableweb and others, but they only offer the price.. Any one with better idea</p>
","<p>This is very simple with JQuery. I demonstrate using the API from BTC to USD and USD to BTC to convert a given amount of dollars to BTC. It is really as simple as that to interface with a REST API in JavaScript.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>var dollar_amount = 42.99;
$.get(""https://min-api.cryptocompare.com/data/price?fsym=BTC&amp;tsyms=USD"",function(data){
  BTC_amount = dollar_amount / data[""USD""];
  console.log(""Using USD to BTC $"" + dollar_amount + "" is "" + BTC_amount + "" BTC"");
});

$.get(""https://min-api.cryptocompare.com/data/price?fsym=USD&amp;tsyms=BTC"",function(data){
  BTC_amount = dollar_amount * data[""BTC""];
  console.log(""Using BTC to USD $"" + dollar_amount + "" is "" + BTC_amount + "" BTC"");
});</code></pre>
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;script src=""https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js""&gt;&lt;/script&gt;</code></pre>
</div>
</div>
</p>
","385","<javascript><rest><bitcoin><cryptoapi>","0","1","1","2018-08-21 06:52:00","51943119","2","","1270789","","2018-08-21 06:52:00","2018-08-21 05:09:42",""
"41384395","Wrong result for base64 string of HMAC_SHA1 using Crypto*** API","<p>I'm trying to use the winapi crypto api to get a base64 encoded hash. I copied and modified to get the function below. I got it from here mostly - <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382379(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa382379(v=vs.85).aspx</a></p>

<p>Running it with <code>calcHmacSha1(""message"", ""key"")</code> should give <code>IIjfdNXyFGtIFGyvSWU3fp0L46Q=</code>. However it gives me <code>SlLDwKvAoGBJ0atki7QFfj/181k=</code>, the non base64 version it gives is <code>4a 52 c3 c0 ab c0 a0 60 49 d1 ab 64 8b b4 05 7e 3f f5 f3 59</code>. This is a same situation encountered here - <a href=""https://stackoverflow.com/questions/25436416/cryptoapi-returns-incorrect-result-for-hmac-sha1/25448769?noredirect=1#comment69968471_25448769"">CryptoAPI returns incorrect result for HMAC_SHA1</a> - however his solution does not work for key's greater then 16 characters, and that is my need.</p>

<pre><code>#pragma comment (lib, ""Crypt32.lib"")
#include &lt;wincrypt.h&gt;

std::string calcHmacSha1(std::string msg, std::string key) {
    std::string hash;

    std::vector&lt;BYTE&gt; msgbytebuffer(msg.begin(), msg.end());
    std::vector&lt;BYTE&gt; keybytebuffer(key.begin(), key.end());

    // http://msdn.microsoft.com/en-us/library/Aa379863

    HCRYPTPROV  hProv       = NULL;
    HCRYPTHASH  hHash       = NULL;
    HCRYPTKEY   hKey        = NULL;
    HCRYPTHASH  hHmacHash   = NULL;
    PBYTE       pbHash      = NULL;
    DWORD       dwDataLen   = 0;
    BYTE*       Data1     = &amp;keybytebuffer[0]; // {0x6b,0x65,0x79};
    BYTE*       Data2     = &amp;msgbytebuffer[0]; // {0x6D,0x65,0x73,0x73,0x61,0x67,0x65};
    HMAC_INFO   HmacInfo;

    //--------------------------------------------------------------------
    // Zero the HMAC_INFO structure and use the SHA1 algorithm for
    // hashing.

    debug_log(""sizeof(Data2)"", sizeof(Data2));
    debug_log(""sizeof(BYTE)"", sizeof(BYTE));

    ZeroMemory(&amp;HmacInfo, sizeof(HmacInfo));
    HmacInfo.HashAlgid = CALG_SHA1;

    //--------------------------------------------------------------------
    // Acquire a handle to the default RSA cryptographic service provider.

    if (!CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
       debug_log("" Error in AcquireContext 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    //--------------------------------------------------------------------
    // Derive a symmetric key from a hash object by performing the
    // following steps:
    //    1. Call CryptCreateHash to retrieve a handle to a hash object.
    //    2. Call CryptHashData to add a text string (password) to the
    //       hash object.
    //    3. Call CryptDeriveKey to create the symmetric key from the
    //       hashed password derived in step 2.
    // You will use the key later to create an HMAC hash object.

    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &amp;hHash)) {
       debug_log(""Error in CryptCreateHash 0x%08x \n"", GetLastError());
       goto ErrorExit;
    }

    if (!CryptHashData(hHash, Data1, key.length() * sizeof(BYTE), 0)) {
       debug_log(""Error in CryptHashData 1 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    if (!CryptDeriveKey(hProv, CALG_RC4, hHash, 0, &amp;hKey)) {
       debug_log(""Error in CryptDeriveKey 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    //--------------------------------------------------------------------
    // Create an HMAC by performing the following steps:
    //    1. Call CryptCreateHash to create a hash object and retrieve
    //       a handle to it.
    //    2. Call CryptSetHashParam to set the instance of the HMAC_INFO
    //       structure into the hash object.
    //    3. Call CryptHashData to compute a hash of the message.
    //    4. Call CryptGetHashParam to retrieve the size, in bytes, of
    //       the hash.
    //    5. Call malloc to allocate memory for the hash.
    //    6. Call CryptGetHashParam again to retrieve the HMAC hash.

    if (!CryptCreateHash(hProv, CALG_HMAC, hKey, 0, &amp;hHmacHash)) {
       debug_log(""Error in CryptCreateHash key 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    if (!CryptSetHashParam(hHmacHash, HP_HMAC_INFO, (BYTE*)&amp;HmacInfo, 0)) {
       debug_log(""Error in CryptSetHashParam 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    if (!CryptHashData(hHmacHash, Data2, msg.length() * sizeof(BYTE), 0)) {
       debug_log(""Error in CryptHashData 2 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    //--------------------------------------------------------------------
    // Call CryptGetHashParam twice. Call it the first time to retrieve
    // the size, in bytes, of the hash. Allocate memory. Then call
    // CryptGetHashParam again to retrieve the hash value.

    if (!CryptGetHashParam(hHmacHash, HP_HASHVAL, NULL, &amp;dwDataLen, 0)) {
       debug_log(""Error in CryptGetHashParam 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    pbHash = (BYTE*)malloc(dwDataLen);
    if(NULL == pbHash) {
       debug_log(""unable to allocate memory\n"");
       goto ErrorExit;
    }

    if (!CryptGetHashParam(hHmacHash, HP_HASHVAL, pbHash, &amp;dwDataLen, 0)) {
       debug_log(""Error in CryptGetHashParam 0x%08x"", GetLastError());
       goto ErrorExit;
    }

    DWORD base64Size = 0;
    if (!CryptBinaryToString(pbHash, dwDataLen, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &amp;base64Size)) {
        debug_log(""Error in CryptBinaryToString 1 0x%08x"", GetLastError());
        goto ErrorExit;
    };

    WCHAR* base64 = new WCHAR[ base64Size + 1 ];
    if (!CryptBinaryToString(pbHash, dwDataLen, CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, base64, &amp;base64Size)) {
        debug_log(""Error in CryptBinaryToString 2 0x%08x"", GetLastError());
        goto ErrorExit;
    };
    hash = string_cast&lt;std::string&gt;(base64);
    delete[] base64;
    debug_log(""hash:"", hash);

    // printf(""The hash is:  "");
    // char chash[512];
    // for(DWORD i = 0 ; i &lt; dwDataLen ; i++) {
    //    printf(""%.2x "",pbHash[i]);
    // }
    MessageBox(NULL, L""hi"", L""cap"", 0);

    // Free resources.
    ErrorExit:
        if(hHmacHash) CryptDestroyHash(hHmacHash);
        if(hKey) CryptDestroyKey(hKey);
        if(hHash) CryptDestroyHash(hHash);
        if(hProv) CryptReleaseContext(hProv, 0);
        if(pbHash) free(pbHash);
        return hash;
}
</code></pre>
","<p>the function work correct, not need fix it. but you not take to account what is key here used for <code>HMAC</code> - not direct your string key, but first, based on your string key, <code>RC4</code> key created and <code>HMAC</code> calculated for this binary <code>RC4</code> key.</p>

<p>different keys -> different hash.</p>

<p>windows not let direct use string keys. it algorithm is better - first convert weak string key to more strong binary key. however if you want use string key and got result for it - can use code like this:</p>

<pre><code>#define BLOCK_SIZE 64

BOOL hmac(PCSTR key, PCSTR message, ALG_ID Algid)
{
    UCHAR i_key_pad[BLOCK_SIZE], o_key_pad[BLOCK_SIZE];

    HCRYPTPROV  hProv;
    HCRYPTHASH  hHash;
    ULONG len = (ULONG)strlen(key), cb;
    BOOL f;

    if (f = CryptAcquireContext(&amp;hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
    {
        if (len &gt; BLOCK_SIZE)
        {
            if (f = CryptCreateHash(hProv, Algid, 0, 0, &amp;hHash))
            {
                f = CryptHashData(hHash, (PBYTE)key, len, 0) &amp;&amp;
                    CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&amp;len, &amp;(cb = sizeof(len)), 0) &amp;&amp;
                    CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)(key = (PCSTR)alloca(len)), &amp;len, 0);

                CryptDestroyHash(hHash);
            }
        }

        if (f)
        {
            ULONG i = BLOCK_SIZE;

            do 
            {
                UCHAR c = --i &lt; len ? key[i] : 0;

                i_key_pad[i] = 0x36 ^ c;
                o_key_pad[i] = 0x5c ^ c;

            } while (i);

            if (f = CryptCreateHash(hProv, Algid, 0, 0, &amp;hHash))
            {
                f = CryptHashData(hHash, i_key_pad, sizeof(i_key_pad), 0) &amp;&amp;
                    CryptHashData(hHash, (PBYTE)message, (ULONG)strlen(message), 0) &amp;&amp;
                    CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&amp;len, &amp;(cb = sizeof(len)), 0) &amp;&amp;
                    CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)(key = (PCSTR)alloca(len)), &amp;len, 0);

                CryptDestroyHash(hHash);

                if (f &amp;&amp; (f = CryptCreateHash(hProv, Algid, 0, 0, &amp;hHash)))
                {
                    f = CryptHashData(hHash, o_key_pad, sizeof(o_key_pad), 0) &amp;&amp;
                        CryptHashData(hHash, (PBYTE)key, len, 0) &amp;&amp;
                        CryptGetHashParam(hHash, HP_HASHVAL, (BYTE*)key, &amp;len, 0);

                    CryptDestroyHash(hHash);

                    if (f &amp;&amp; len)
                    {
                        DbgPrint(""\nThe hash is:  "");
                        do 
                        {
                            DbgPrint(""%02x"", (UCHAR)*key++);
                        } while (--len);
                        DbgPrint(""\n"");
                    }
                }
            }
        }

        CryptReleaseContext(hProv, 0);
    }

    return f;
}


//The hash is:  2088df74d5f2146b48146caf4965377e9d0be3a4
hmac(""key"",""message"", CALG_SHA1);
</code></pre>
","382","<winapi><cryptoapi><hmacsha1>","1","3","1","2018-01-22 11:18:38","41387095","0","","472495","","2018-01-22 11:18:38","2016-12-29 17:22:37",""
"31945699","How to get a list of all certificates in a file?","<p>I would like to be able to open a file and grab a list of all the certificates for that file, and list off all key information for each certificate. </p>

<p><em>Currently, I have the listing of key information done correctly for the first certificate listed from <code>CryptQueryObject()</code>, but I cannot find any way of getting a list of all the certificates.</em></p>

<p><a href=""https://msdn.microsoft.com/en-us/library/ms148497%28v=vs.110%29.aspx"" rel=""nofollow noreferrer"">Here</a> is what I would like to use, but I cannot use .NET and I would not like to be restricted to Windows 8/Server 2012 which the solution from <a href=""https://stackoverflow.com/questions/24892531/reading-multiple-signatures-from-executable-file"">here</a> would do.</p>
","","374","<c++><windows><cryptoapi>","5","","0","2015-08-11 19:28:33","","1","","-1","","2017-05-23 12:16:41","2015-08-11 15:16:36",""
"52010412","Calling crypt32.dll CryptProtectData method from native code","<p>I'm trying to call into the <strong>crypt32.dll</strong> method <strong>CryptProtectData</strong> from managed code, but I do not seem to have the marshaling types quite right in my delegate's declaration:</p>

<pre><code>[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
private delegate bool CryptProtectDataDelegate(
    IntPtr pDataIn,             // DATA_BLOB*
    //StringBuilder szDataDescr,  // LPCWSTR
    [MarshalAs(UnmanagedType.LPWStr)] string szDataDescr,   // LPCWSTR
    IntPtr pOptionalEntropy,    // DATA_BLOB*
    int pvReserved,             // PVOID 
    IntPtr pPromptStruct,       // CRYPTPROTECT_PROMPTSTRUCT*
    int dwFlags,                // DWORD 
    IntPtr pDataOut             // DATA_BLOB*
);
</code></pre>

<p>which when invoked,</p>

<pre><code>bool theResult = cryptProtectData(
    pDataIn,
    null,
    IntPtr.Zero,    // null,
    0,              // null,
    IntPtr.Zero,    // null,
    flag,
    pDataOut);
</code></pre>

<p>causes the exception</p>

<blockquote>
  <p>+CryptProtectDataDelegate::Invoke' has unbalanced the stack. This is likely because the managed PInvoke signature does not match the
  unmanaged target signature. Check that the calling convention and
  parameters of the PInvoke signature match the target unmanaged
  signature.'</p>
</blockquote>

<p>The native definition for <code>CryptProtectData</code> is</p>

<pre><code>DPAPI_IMP BOOL CryptProtectData(
  DATA_BLOB                 *pDataIn,
  LPCWSTR                   szDataDescr,
  DATA_BLOB                 *pOptionalEntropy,
  PVOID                     pvReserved,
  CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct,
  DWORD                     dwFlags,
  DATA_BLOB                 *pDataOut
);
</code></pre>

<p>where DPAPI_IMP is defined as</p>

<pre><code>#define DPAPI_IMP DECLSPEC_IMPORT
</code></pre>

<p><strong>I'm note sure what the legal type representations are that I should be using for the parameters in the delegate definition?</strong></p>

<p>Assuming <code>PVOID</code> is a <strong><code>void *</code></strong>, I found some documentation which suggests that it could be represented as an <code>int</code>, and b/c it can be <em><code>null</code></em>, I set it to <em><code>0</code></em> (<a href=""https://docs.microsoft.com/en-us/dotnet/framework/interop/default-marshaling-behavior"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/dotnet/framework/interop/default-marshaling-behavior</a>).</p>

<hr>

<p>Below is what should be a complete and run-able example (that will crash)</p>

<pre><code>using System;
using System.Runtime.InteropServices;

namespace CallNativeDLLs
{
    static class NativeMethods
    {
        [DllImport(""kernel32.dll"")]
        public static extern IntPtr LoadLibrary(string dllToLoad);

        [DllImport(""kernel32.dll"")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);

        [DllImport(""kernel32.dll"")]
        public static extern bool FreeLibrary(IntPtr hModule);
    }

    class Program
    {
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private delegate bool CryptProtectDataDelegate(
            IntPtr pDataIn,             // DATA_BLOB*
            //StringBuilder szDataDescr,  // LPCWSTR
            [MarshalAs(UnmanagedType.LPWStr)] string szDataDescr,   // LPCWSTR
            IntPtr pOptionalEntropy,    // DATA_BLOB*
            int pvReserved,             // PVOID 
            IntPtr pPromptStruct,       // CRYPTPROTECT_PROMPTSTRUCT*
            int dwFlags,                // DWORD 
            IntPtr pDataOut             // DATA_BLOB*
        );

        static void Main(string[] args)
        {
            IntPtr pDll = NativeMethods.LoadLibrary(@""c:\windows\system32\crypt32.DLL"");

            IntPtr pAddressOfFunctionToCall = NativeMethods.GetProcAddress(pDll, ""CryptProtectData"");

            var cryptProtectData = (CryptProtectDataDelegate)Marshal.GetDelegateForFunctionPointer(
                pAddressOfFunctionToCall,
                typeof(CryptProtectDataDelegate));

            IntPtr pDataIn = Marshal.StringToHGlobalAnsi(""hi"");
            int flag = (int)0x4; //CRYPTPROTECT_LOCAL_MACHINE 
            var pDataOut = new IntPtr();

            // EXCEPTION thrown here
            bool theResult = cryptProtectData(
                pDataIn,
                null,
                IntPtr.Zero,    // null,
                0,              // null,
                IntPtr.Zero,    // null,
                flag,
                pDataOut);

            bool result = NativeMethods.FreeLibrary(pDll);

            Console.WriteLine(theResult);
        }
    }
}
</code></pre>

<hr>

<p><strong>Update:</strong> Using <strong>Amy's</strong> link, the following runs (though I haven't tried decrypting the string yet, and CRYPTPROTECT_LOCAL_MACHINE is weak)</p>

<pre><code>using System;
using System.Runtime.InteropServices;

namespace CallNativeDLLs
{
    static class NativeMethods
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct DATA_BLOB
        {
            public int cbData;
            public IntPtr pbData;
        }

        [Flags]
        public enum CryptProtectPromptFlags
        {
            CRYPTPROTECT_PROMPT_ON_UNPROTECT = 0x1,
            CRYPTPROTECT_PROMPT_ON_PROTECT = 0x2
        }

        [Flags]
        public enum CryptProtectFlags
        {
            CRYPTPROTECT_UI_FORBIDDEN = 0x1,
            CRYPTPROTECT_LOCAL_MACHINE = 0x4,
            CRYPTPROTECT_CRED_SYNC = 0x8,
            CRYPTPROTECT_AUDIT = 0x10,
            CRYPTPROTECT_NO_RECOVERY = 0x20,
            CRYPTPROTECT_VERIFY_PROTECTION = 0x40
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct CRYPTPROTECT_PROMPTSTRUCT
        {
            public int cbSize;
            public CryptProtectPromptFlags dwPromptFlags;
            public IntPtr hwndApp;
            public String szPrompt;
        }

        [DllImport(""Crypt32.dll"",
            SetLastError = true,
            CharSet = System.Runtime.InteropServices.CharSet.Auto)]     
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CryptProtectData(
            ref DATA_BLOB pDataIn,
            String szDataDescr,
            ref DATA_BLOB pOptionalEntropy,
            IntPtr pvReserved,
            ref CRYPTPROTECT_PROMPTSTRUCT pPromptStruct,
            CryptProtectFlags dwFlags,
            ref DATA_BLOB pDataOut
        );
    }

    class Program
    {
        static void Main(string[] args)
        {
            IntPtr pbData = Marshal.StringToHGlobalAnsi(""hi"");
            var pDataIn = new NativeMethods.DATA_BLOB{cbData=0,pbData=pbData};
            var pOptionalEntropy = new NativeMethods.DATA_BLOB();
            var pPromptStruct = new NativeMethods.CRYPTPROTECT_PROMPTSTRUCT();
            var pDataOut = new NativeMethods.DATA_BLOB();

            bool theResult = NativeMethods.CryptProtectData(
                ref pDataIn,
                null,
                ref pOptionalEntropy, // null,
                IntPtr.Zero,          // null,
                ref pPromptStruct,    // null,
                NativeMethods.CryptProtectFlags.CRYPTPROTECT_LOCAL_MACHINE,
                ref pDataOut);

            Console.WriteLine(theResult);
        }
    }
}
</code></pre>
","","374","<c#><pinvoke><marshalling><cryptoapi>","1","","0","2018-08-24 20:26:16","","6","","1105214","","2018-08-24 20:26:16","2018-08-24 19:06:53",""
"26282253","Content of a XML signed by OpenSSL","<p>Currently, I want sign and encrypt a XML file by using the library CryptoAPI in C#. In fact, I want do the same work that OpenSSL with the following command line:</p>

<pre><code>openssl smime -sign -in file.xml -out file.out -passin pass:test -binary -nodetach -inkey certificat.priv.pem -signer certificat.pub.pem
</code></pre>

<p>To realize this with C# on a desktop application, I have just used the functions of SignedXML. Unfortunately, these functionalities don’t exist in Compact Framework! So, I try to construct my XML by hand by using CryptoAPI. My code works fine but my XML is different from that obtained by OpenSSL.</p>

<p>Here an abstract of my XML (signed):</p>

<pre><code>UNKNOWN STRING (in base 64, it begins by “MII…”)
&lt;?xml version=""1.0""?&gt;
&lt;test&gt;
    CONTENT OF MY XML
    &lt;signature&gt;…&lt;/signature&gt;
&lt;/test&gt;
FIRST UNKNOWN string (perhaps the Public Key)
SECOND UNKNOWN string (in this string, there is the current date)
</code></pre>

<p>So, with CryptoAPI, I've calculated the digest value and the signature. With XMLDocument functions, I have inserted these informations into my XML. Now, I search to understand the composition of the unknown strings described above.</p>

<p>Can you explain me the content of these unknown strings? I have already done several searches but I’ve not found explanation.</p>

<p>Thank you by advance for your help!</p>

<p>Best regards</p>
","","366","<c#><xml><openssl><cryptoapi>","2","","0","2014-10-09 15:25:45","","0","","","","","2014-10-09 15:25:45",""
"46185428","BCryptImportKeyPair returns STATUS_INVALID_PARAMETER when i try to import public key","<p>I followed <a href=""https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/Security/DhOakleyGroup1/cpp/DhOakleyGroup1.cpp#L379"" rel=""nofollow noreferrer"">this example</a>. I am trying to add the public key which i got from the server into the key Pair and I am getting STATUS_INVALID_PARAMETER. </p>

<pre><code>    BCRYPT_DH_KEY_BLOB header;
    header.dwMagic = BCRYPT_DH_PUBLIC_MAGIC;
    header.cbKey = (ULONG)(pub_key.size());
    cout &lt;&lt; ""header contents "" &lt;&lt; header.dwMagic &lt;&lt; "" : "" &lt;&lt; header.cbKey &lt;&lt; endl;
    memcpy(&amp;pubKeyBlobFromServer[0], &amp;header, sizeof(BCRYPT_DH_KEY_BLOB));
    // copy Public key
    cout &lt;&lt; ""size of pub_key "" &lt;&lt; pub_key.size() &lt;&lt; endl;
    cout &lt;&lt; ""size of pubKeyBlobFromServer before :"" &lt;&lt; pubKeyBlobFromServer.size() &lt;&lt; endl;
    cout &lt;&lt; ""size of BCRYPT_DH_KEY_BLOB "" &lt;&lt; sizeof(BCRYPT_DH_KEY_BLOB) &lt;&lt; endl;
    pubKeyBlobFromServer.insert(pubKeyBlobFromServer.end(), pub_key.begin(), pub_key.end());
    cout &lt;&lt; ""size of pubKeyBlobFromServer after :"" &lt;&lt; pubKeyBlobFromServer.size() &lt;&lt; endl;
    Status = BCryptImportKeyPair(
                                        ExchAlgHandleB,             // Alg handle
                                        nullptr,                       // Parameter not used
                                        BCRYPT_DH_PUBLIC_BLOB,      // Blob type (Null terminated unicode string)
                                        &amp;PubKeyHandleB,             // Key handle that will be recieved
                                        const_cast&lt;PUCHAR&gt;(pubKeyBlobFromServer.data()),            // Buffer than points to the key blob
                                        (ULONG)pubKeyBlobFromServer.size(),     // Buffer length in bytes
                                        0);                         // Flags
</code></pre>

<p>I am getting the following output.</p>

<pre><code>header contents 1112557636 : 128
size of pub_key 128
size of pubKeyBlobFromServer before :8
size of BCRYPT_DH_KEY_BLOB 8
size of pubKeyBlobFromServer after :136
</code></pre>

<p>I tried printing the bytes of pubKeyBlobFromServer. the public key starts from 8th byte. first 8 is reserved for BCRYPT_DH_KEY_BLOB . I am not sure what is wrong. Please suggest the place where i am making mistake. If not please suggest a sample which imports public key from string. Thanks in Advance.</p>
","<p>Microsoft's sample code takes the easy way out; because the same API exported the key, it is already in the right format.</p>

<p>In order to construct a valid key blob yourself, you need to look up <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa833125(v=vs.85).aspx"" rel=""nofollow noreferrer"">the documentation for the <code>BCRYPT_DH_KEY_BLOB</code> structure</a>:</p>

<blockquote>
  <p>A Diffie-Hellman public key BLOB (BCRYPT_DH_PUBLIC_BLOB) has the following format in contiguous memory. The Modulus, Generator, and Public numbers are in big-endian format.</p>
</blockquote>

<pre><code>BCRYPT_DH_KEY_BLOB
Modulus[cbKey] // Big-endian.
Generator[cbKey] // Big-endian.
Public[cbKey] // Big-endian.
</code></pre>

<p>Looks like your code was only including one of the three components.</p>
","365","<c++11><winapi><cryptoapi><cng><wincrypt>","0","1","1","2017-09-13 21:33:46","46207161","2","1","1294545","","2017-09-12 22:50:06","2017-09-12 21:15:45",""
"35521900","Is there a cross-platform C/C++ equivalent to CertGetCertificateChain()?","<p>I'm attempting to programmatically build and validate a certificate chain based on an in-memory X509 certificate object (received over a network connection), and a filesystem directory containing trusted root certificates.</p>

<p>I'm familiar with how to accomplish this on Windows using <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376078%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">CertGetCertificateChain</a>, but in my research, I haven't found any API that is quite as simple to use.  Specifically, one that will go on the wire to fetch the signing (CA) certificate(s) using the Authority Information Access (AIA) field in the end-entity certificate.</p>

<p>I found this <a href=""http://gnutls.org/manual/html_node/Verifying-a-certificate.html#Verifying-a-certificate"" rel=""nofollow noreferrer"">example for gnuTLS</a>, and I found these similar answers <a href=""https://stackoverflow.com/questions/16291809/openssl-programatically-verify-certificate-chain-in-c-in-memory-certs"">here</a>, and <a href=""https://stackoverflow.com/questions/35072261/certificate-chain-validation-error-openssl"">here</a>, but I understand that complexity is the enemy of secure crypto and these seem quite complex by comparison.</p>

<p>Is there an API equivalent to CertGetCertificateChain that's cross-platform, as in POSIX-portable?</p>

<p>I'm library shopping, so I'm not tied to a specific library (OpenSSL, LibreSSL, gnuTLS, etc.), just looking for the right one for the job.</p>
","","356","<openssl><x509><pki><cryptoapi><gnutls>","2","","0","2016-02-21 23:29:19","","2","","-1","","2017-05-23 11:50:34","2016-02-20 10:25:27",""
"8667129","CryptAcquireContextA fails in C++ CLR for ""Aloaha Cryptographic Provider""","<p>I have C++ CLR project with both managed and unmanaged code. In this project I loop through list of cryptoproviders and search for suitable.</p>

<p>So I use functions <br>
CryptEnumProvidersA <br>
CryptAcquireContextA </p>

<p>I have C# project which uses C++ project.
When I call the method to loop through list of cryptoproviders twice, my application crashes. And it crashes on CryptAcquireContextA. And only on ""Aloaha Cryptographic Provider"".</p>

<p>When i use debug mode, it also crashes.
But when i use debug mode, set breakpoint and pass through code with F10, it works fine.</p>

<p>When i carry out C++ code to separate project, it works fine in all cases.</p>

<p>So, I have two questions here:<br>
1) How such a crash possible? And why it happens?<br>
2) How can I call CryptAcquireContextA to handle such a crash?<br></p>

<p>My considerations.<br>
1) Some troubles with memory. I was searching for memory leaks, but I didn't find any.<br>
2) I tried to use try-catch, but with no result, CryptAcquireContextA crashes anyway. I would like to use function like ""CryptIsValidProvider"" or ""CryptPingProvider"", but I didn't find it.</p>
","<p>If it works when single-stepping, it's probably a race condition (you're paused in the debugger long enough for some other process or driver to make progress).</p>

<p>Does it matter how much code you single-step through?  Does putting a <code>Sleep</code> instead of a breakpoint right before the <code>CryptAcquireContextA</code> call also work?</p>
","348","<c#><c++-cli><cryptoapi>","0","0","1","2012-01-27 14:51:23","8672093","0","","","","","2011-12-29 11:10:19",""
"14160486","Load a smart card minidriver without injecting a card","<p>I am currently evaluating if it is possible to use a smart card minidriver for my project. My Project is to use a smartphone as a card reader and use it for a smart card login. What I'd like to know is if it is possible to make the Microsoft Base CSP load the smart card minidriver without the card beeing inserted into any actual card reader connected via USB. The idea is to either write a new csp or write a smart card minidriver to talk to the smart card over the smartphone. To achieve this I implement the communication between CSP or smart card minidriver via a simple TCP network connection or a bluetooth connection. Anyhow, in both cases I would need to CSP to load the driver without the card beeing inserted. Does any one have an idea how this can be acchieved?</p>

<p>Just for the record, I am using Windows 7 as the targeted platform.</p>
","","346","<winapi><driver><smartphone><smartcard><cryptoapi>","1","","0","2013-01-04 16:01:04","","1","1","","","","2013-01-04 16:01:04",""
"17819033","How do I add a Client Certificate and Private Key to the Users Store in Windows with C++?","<p>Basically, the title: How do I add a Client Certificate and Private Key to the Users Store in Windows with C++?</p>

<p>I've found the function <code>PFXImportCertStore</code> which will let me load the cert and private key from a PKCS12 into a temporary cert store but I dont know how to save this store to the users store. The goal is to add a private key which other applications can access (for example, Outlook).</p>
","<p>I needed to call <code>CertAddCertificateContextToStore</code> to put it in the store that I wanted.</p>
","342","<c++><windows><cryptoapi>","0","0","1","2013-07-24 16:21:59","17839605","0","","","","","2013-07-23 19:11:48",""
"30090556","CertCreateCertificateChainEngine returning ""Invalid Parameter"" (0x80070057)","<p>I have been trying to create a non-default certificate chain using modified version of an example posted <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382042(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa382042(v=vs.85).aspx</a></p>

<pre><code>

    CERT_CHAIN_ENGINE_CONFIG chainConfig;
    HCERTCHAINENGINE hChainEngine;

    :: SecureZeroMemory (&chainConfig, sizeof (CERT_CHAIN_ENGINE_CONFIG));

    chainConfig.cbSize = sizeof(chainConfig);

    chainConfig.hRestrictedRoot = NULL;
    chainConfig.hRestrictedTrust = NULL;
    chainConfig.hRestrictedOther = NULL;

    // Following two parameters are optionally enabled.
    chainConfig.hExclusiveRoot = NULL;
    chainConfig.hExclusiveTrustedPeople = NULL;

    chainConfig.cAdditionalStore = 0;
    chainConfig.rghAdditionalStore = NULL;
    chainConfig.dwFlags = CERT_CHAIN_CACHE_END_CERT;
    chainConfig.dwUrlRetrievalTimeout = 0;
    chainConfig.MaximumCachedCertificates = 0;
    chainConfig.CycleDetectionModulus = 0;
    // optionally enabled following param.
    chainConfig.dwExclusiveFlags = CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG;

    if (!CertCreateCertificateChainEngine(&chainConfig, &hChainEngine))
    {
        // failure
    }

</code></pre>

<p>When I ran this program using Visual Studio 2010 - I could get a valid value of hChainEngine but while running the same program under VS 2013, I get an error E_INVALIDPARAM (0x80070057) (The parameter is incorrect.)</p>

<p>I tried every other combination possible to understand what went wrong but couldn't figure out which parameter here, the API doesn't like.</p>

<p>One thing I have observed is, while VS2010 points to a ""C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\Include"" and VS2013 points to ""C:\Program Files (x86)\Windows Kits\8.1\Include\um"" which have different structure of _CERT_CHAIN_ENGINE_CONFIG. I tried to manage my structure allocation accordingly but no luck!</p>

<p>Can someone here please help me understand what is wrong here? Thanks</p>

<p>I have both versions of Visual Studio installed on Windows 7.</p>
","","340","<c++><visual-studio-2010><visual-studio-2012><cryptoapi>","0","","0","2015-05-07 01:47:25","","2","","","","","2015-05-07 01:47:25",""
"33476529","MSDN C example program for signing a hash and verifying the hash signature doesn't work","<p>I've tried out the sample program at <a href=""https://msdn.microsoft.com/en-us/library/aa382371(v=vs.85).aspx"" rel=""nofollow"">MSDN</a> that demonstrates how a hash can be signed and a hash signature verified. But when I execute the program, I get the following output:</p>

<pre><code>CSP context acquired.
An error occurred in running the program.
Error during CryptGetUserKey for signkey.
Error number 8009000d.
Program terminating.
</code></pre>

<p>8009000d is the numeric error code for NTE_NO_KEY. Does anyone have an idea why the program fails in this way? I'm on Windows 7. </p>
","<p>Apparently there is no key in the context you've aquired.  </p>

<p>You can change slightly this example, by combining it with another microsoft example one about context acqusition and key generation. You have simply to add code for generateing keys if these are missing:  </p>

<pre><code>...
if (CryptGetUserKey(hProv,  AT_SIGNATURE, &amp;hKey)) {  // if block unchanged
    printf(""The signature key has been acquired. \n"");
}
else if (GetLastError() == NTE_NO_KEY) {             // insert processing of missing keys 
    if (CryptGenKey(                                
        hProv,
        AT_SIGNATURE,
        0,
        &amp;hKey)) {
        printf(""Created a signature key pair.\n"");
    }
    else {
        MyHandleError(""Error during creation of new signature key."");
    }
}
else {                      // The original else part will handle other errors
    MyHandleError(""Error during CryptGetUserKey for signkey."");
}
</code></pre>
","338","<c++><winapi><hash><sign><cryptoapi>","3","3","1","2015-11-02 14:06:08","33479451","2","1","3723423","","2015-11-02 14:06:08","2015-11-02 11:27:21",""
"33804023","'BUG: scheduling while atomic' with crypto_alloc_hash","<p>I am trying to use Linux kernel's crypto libraries to calculate an HMAC value, given key and message. The idea is to calculate the HMAC and insert it in a TCP option during an iperf session (this part is not relevant). 
This is the function I wrote to use the crypto libraries, and it takes two keys of 8 bytes (to be combined) and a variable number of bytes composing the message:</p>

<pre><code>void crypto_hmac_sha1(u8 *key_1, u8 *key_2, u32 *hash_out, int arg_num, ...)
{
    struct crypto_ashash *shash;
    struct shash_desc *desc = NULL;
    const char hmac_alg[] = ""hmac(sha1)"";
    u8 key[16];
    int i;
    int ret;
    int length;
    u8 *msg;
    va_list list;

    /* Initialize result placeholder */
    memset(hash_out, 0, sizeof(hash_out));

    for (i = 0; i &lt; 8; i++)
        key[i] ^= key_1[i];
    for (i = 0; i &lt; 8; i++)
        key[i + 8] ^= key_2[i];

    printk(""A1\n"");
    shash = crypto_alloc_ahash(hmac_alg, 0, 0);
    printk(""A2\n"");
    desc = kzalloc(sizeof(*desc) + crypto_shash_descsize(shash), GFP_KERNEL);
    if (!desc)
        goto out;

    desc-&gt;tfm = shash;
    desc-&gt;flags = CRYPTO_TFM_REQ_MAY_SLEEP;

    ret = crypto_shash_setkey(shash, key, 16);
    if (ret &lt; 0)
        goto out;

    crypto_shash_init(desc);

    for (i = 0; i &lt; arg_num; i++) {
        length = va_arg(list, int);
        msg = va_arg(list, u8 *);
        ret = crypto_shash_update(desc, msg, length);
        if (ret &lt; 0)
            goto out;
    }

    ret = crypto_shash_final(desc, hash_out);
out:
    kfree(desc);
}
</code></pre>

<p>The error is the following (due to the fact that crypto_alloc_ahash tries to acquire a semaphore and it is not allowed in the current context):</p>

<pre><code>BUG: scheduling while atomic: iperf/769/0x00000100
CPU: 0 PID: 769 Comm: iperf Not tainted 4.1.0-gdee0521-dirty #143
Received SIGSEGV in SIGSEGV handler, aborting stack trace!
</code></pre>

<p>Fix suggestions?</p>
","<p>Without being familiar with the crypto library: if you have a upper bound for the the number of concurrent executions of <code>crypto_hmac_sha1</code>, you might use a pool of preallocated hash algorithms structures. Given that scheduling/sleeping does not seem to be allowed, such a bound shouldn't be to hard to find: the number of hardware threads will do it.</p>

<p>Also, <code>CRYPTO_TFM_REQ_MAY_SLEEP</code> seems suspicious if no scheduling is allowed.</p>
","320","<c><linux-kernel><cryptoapi><crypt>","0","1","1","2015-11-19 14:05:37","33806127","1","","2982437","","2015-11-19 13:15:08","2015-11-19 12:30:19",""
"39221662","CryptoAPI and CRLs","<p>I'm facing problems with CryptoAPI's certificate chain validation, in particular with the revocation check. The problem is that I'm working under Windows CE (with no internet access), and CryptoAPI does not export CRL API's for it. </p>

<p><a href=""https://msdn.microsoft.com/en-us/library/ms936955.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/ms936955.aspx</a></p>

<p>I've done some research, and it seems that <code>CertGetCertificateChain()</code> does revocation check, but under the hood.</p>

<p>I have created with <code>OpenSSL</code> self signed <code>Root CA</code> and <code>Intermediate CA</code> (signed with Root CA) and finally I signed a end certificate with <code>Intermediate CA</code>, which contains the extension <code>crlDistributionPoints</code> in which is pointed the <code>Intermediate CA</code>'s CRL encoded in <code>PEM</code> format. For brevity, lets name it <code>intermediate.crl.pem</code>.</p>

<p>So, <code>intermediate.crl.pem</code> is persistent on my disk, and in my <code>openssl.cnf</code> I linked it like this:</p>

<pre><code>...
[ extensions_section ]

crlDistributionPoints=//windows//intermediate.crl.pem
 ...
</code></pre>

<p>I'm not sure, that this is correct however, also I'm not sure that CryptoAPI does not expect some different format (for example DER instead of PEM).</p>

<p>And finally the revocation check is not correct. I always get the error that the certificate is revoked no matter whether it is in CRL or not.</p>

<p>Can you give me some guidance here? It is important that <code>intermediate.crl.pem</code> must not be obtained thru the network (it must resist on the filesystem). </p>

<p>Also, I noticed that Windows CE, supports a certificate store called <code>Disallowed</code> which CryptoAPI's chain engine checks during the validation and returns an error (says that the cert is not valid) if the certificate being validated is in there.  </p>

<p>Does using this store instead CRL is better approach?</p>
","","320","<certificate><windows-ce><cryptoapi><certificate-revocation>","1","","0","2016-08-30 23:24:20","","0","","608639","","2016-08-30 23:24:20","2016-08-30 07:46:12",""
"27115828","Microsoft CryptoAPI not working in web service on Windows Server 2008 R2","<p>We have a web service that uses the Microsoft Crypto API for encryption. It works fine as a web service on Windows Server 2003. For some reason, it doesn't work as a web service on the Windows Server 2008 R2 that we're trying to move it to, although the same code does work on the server in a regular Windows application (ie: not a web service).</p>

<p>Is there some kind of security setting or something like that which needs to be changed to enable this to work? Something has obviously changed between Windows Server versions. It is a 32 bit web service running under IIS.</p>
","<p>We got it figured out. It turns out that the default Application Pool Identity basically has no rights. We set it to run under an identity that has the appropriate rights and now it's working.</p>
","313","<iis-7.5><windows-server-2008-r2><cryptoapi><mscapi>","0","0","1","2015-06-09 02:48:26","27132776","0","","608639","","2015-06-09 02:48:26","2014-11-24 23:02:17",""
"5372340","What method of encryption is suitable for encrypting individual words, and also an entire document?","<p>I need to save several documents to the cloud and need to save the documents, document metadata, and words/phrases for searching.</p>

<p>My plan is to use a symmetric cypher for encrypting the whole document, but I'm unsure of the right way to hash each word.  I would like something secure, but I don't want to increase the count of characters in each word unnecessarily.</p>

<p>What implementation is most suitable for doing a symmetric encryption against a document, and what is the best way to hash a word or phrase without making it many times larger than it needs to be? </p>
","<p>Your requirements are mutually exclusive.  That kind of metadata will leak a huge amount of information about the document content, to the point it can't be called secure.</p>

<p>Furthermore, encrypting individual words is futile.  The difficulty of breaking encryption is usually said to be as difficult as breaking the key, but this assumes the information content in the plaintext is greater than that in the key.  For single words, that certainly isn't true.</p>
","309","<c#><encryption><hash><cryptoapi><encryption-symmetric>","1","0","2","2011-03-21 06:07:10","5374360","5","","","","","2011-03-20 23:27:11",""
"5372340","What method of encryption is suitable for encrypting individual words, and also an entire document?","<p>I need to save several documents to the cloud and need to save the documents, document metadata, and words/phrases for searching.</p>

<p>My plan is to use a symmetric cypher for encrypting the whole document, but I'm unsure of the right way to hash each word.  I would like something secure, but I don't want to increase the count of characters in each word unnecessarily.</p>

<p>What implementation is most suitable for doing a symmetric encryption against a document, and what is the best way to hash a word or phrase without making it many times larger than it needs to be? </p>
","<p>First, I suggest different tags.  It sounds like you're really interested in offloading searching to a server in a cryptographically secure way (such that the server doesn't have access to the plaintext and such that the client need not transfer the entire index).</p>

<p>Issues:</p>

<ul>
<li>An attacker being able to figure out which words are in the index (and which are not) could be an issue for you.  You should state whether it is as a part of your requirements.</li>
<li>An attacker being able to figure out which items in the index occur more frequently could be an issue for you.  You should state whether it is as a part of your requirements.</li>
<li>An attacker being able to associate words with a document could be an issue for you.  You should state whether it is as a part of your requirements.</li>
<li>An attacker may be able to subvert the server entirely and observe queries / retrievals.  You should state security needs in this circumstance as well.</li>
<li>Probably others I haven't thought of.</li>
</ul>

<p>I'm assuming that you're designing your own, but there is probably some prior art, research, etc. that would be smarter than I am below:</p>

<p>For the first, I suggest that you should hash the words, combining the plaintext with a secret (not shared with the index server) before hashing, and truncating the hash to the point where it is likely to be non-unique in the index.  This costs you hash efficiency, but helps prevent an attacker from using the hash as a plaintext equivalent or experimentally determining the secret</p>

<p>For the second and third, you should encrypt any indexed data (such as counts or document+position) and decrypt it on the client.  This may cost you latency.</p>

<p>For the fourth, you'd want to consider concealing real requests inside groups of unrelated requests, things like that, but you'd want a lot of math to make sure you weren't still vulnerable to statistical analysis.</p>

<p>For the fifth, do some web research.  I'm confident there will be stuff out there, and this is a pretty specific (and less common) need, so you'll want someone who put more thought into it than I just have.</p>
","309","<c#><encryption><hash><cryptoapi><encryption-symmetric>","1","1","2","2011-03-21 06:07:10","5374360","5","","","","","2011-03-20 23:27:11",""
"30722114","Sign with private key and verify with public","<p>OpenSSL's rsautl allows signing with a private key. This is without a hash. Then recovering the signed file with a public key.</p>

<p>I've looked at <code>CryptCreateHash/CryptSignHash/CryptHashData</code> but I'm not sure how to do it. I believe those functions will only sign the hash of the data, not the data itself.</p>

<p>Is there any way I can sign with the private key and no hash involved?</p>

<p>Edit: Made necessary changes from jww's recommendations.</p>
","","305","<c><windows><openssl><cryptoapi><mscapi>","1","","0","2015-06-09 03:03:18","","6","","4987827","","2015-06-09 03:03:18","2015-06-09 02:35:09",""
"2696139","BAD_UID error while exporting key in CryptoAPI","<p>I am writing a test application for Microsoft CryptoAPI. I want to export the secret key of one party using the public key of the second party, and then import that secret key as the second party's secret key (this sets up a shared secret key for communication). Here is my code:</p>

<pre><code>if(!CryptExportKey(encryptT-&gt;hSymKey, decryptT-&gt;hPubKey, SIMPLEBLOB, 0, keyExBuf, &amp;bufLen)) {
    FormattedDebugPrint(NULL, GetLastError(), ""could not export secret key"", TRUE);
    return -1;
}
if(!CryptImportKey(decryptT-&gt;hCryptProv, keyExBuf, bufLen, decryptT-&gt;hPubKey, 0, &amp;(decryptT-&gt;hSymKey))) {
    FormattedDebugPrint(NULL, GetLastError(), ""could not import secret key"", TRUE);
    return -1;
}
</code></pre>

<p>And this gives the error:</p>

<pre><code>80090001: Bad UID.
</code></pre>

<p>The public keypair is being generated for both encryptT and decryptT (sender, receiver) by calling:</p>

<pre><code>CryptGenKey(encryptT-&gt;hCryptProv, CALG_RSA_KEYX, CRYPT_EXPORTABLE, &amp;(encryptT-&gt;hPubKey))
</code></pre>

<p>Any idea what could be causing the error?</p>

<p>Thanks,</p>
","<p>Never mind, I figured it out. Basically, you can't just use another public key directly even if it's initialized the same way -- I needed to first export that public key, and then import it using the handle to the cryptographic provider of the other party.</p>
","302","<encryption><cryptoapi><encryption-symmetric><public-key-encryption><secret-key>","0","0","1","2010-04-23 18:57:31","2701229","2","","","","","2010-04-23 04:06:57",""
"48673289","How to calculate Subject Key Identifier in CNG?","<p>My goal is to populate the Subject Key Identifier Extension (2.5.29.14) for a certificate using Microsoft CNG. I did it previously with Microsoft CAPI but the function I used:</p>

<p>CryptHashPublicKeyInfo</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380204(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380204(v=vs.85).aspx</a></p>

<p>Is now depreciated. CNG has no such method. However, the descripion for CryptHashPublicKeyInfo in the link above says that they do a SHA1 hash of the public key information. So I did a SHA1 hash of the public key bytes in CNG on the same data in CryptHashPublicKeyInfo (CAPI) and the two hashes are different. I need to resolve this difference. To be clear, my logic is running on the same public key from the same CSR.</p>

<p>Details in RFC 5280 seem to confirm what Microsoft says:
<a href=""https://tools.ietf.org/html/rfc5280#section-4.2.1.2"" rel=""nofollow noreferrer"">https://tools.ietf.org/html/rfc5280#section-4.2.1.2</a></p>

<blockquote>
  <p>(1) The keyIdentifier is composed of the 160-bit SHA-1 hash of the
             value of the BIT STRING subjectPublicKey (excluding the tag,
             length, and number of unused bits).</p>
  
  <p>Cooper, et al.              Standards Track                    [Page
  28]   RFC 5280            PKIX Certificate and CRL Profile<br>
  May 2008</p>

<pre><code>  (2) The keyIdentifier is composed of a four-bit type field with
       the value 0100 followed by the least significant 60 bits of
       the SHA-1 hash of the value of the BIT STRING
       subjectPublicKey (excluding the tag, length, and number of
       unused bits).
</code></pre>
</blockquote>

<p>^I'm guessing Microsoft is doing case #1.</p>

<p>Here is my CAPI code:</p>

<pre><code>//depreciated (CAPI)
//get data for subject key identifier
//get length
HCRYPTPROV hHashProv = NULL;
if (!CryptHashPublicKeyInfo(
    hHashProv,
    CALG_SHA1, //sha1
    0,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    &amp;serverCertInfo.SubjectPublicKeyInfo,
    NULL,
    &amp;dwSubjectKeyIdentifier
))
{
    throw std::runtime_error(""Unable to get length of public key info hash"");
}

//alocate data buffer
pbSubjectKeyIdentifier = (LPBYTE)LocalAlloc(0, dwSubjectKeyIdentifier);
//fill data buffer with subject key identifier
if (!CryptHashPublicKeyInfo(
    hHashProv,
    CALG_SHA1, //sha1
    0,
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    &amp;serverCertInfo.SubjectPublicKeyInfo,
    pbSubjectKeyIdentifier,
    &amp;dwSubjectKeyIdentifier
))
{
    throw std::runtime_error(""Unable to fill public key info hash"");
}

CRYPT_DATA_BLOB skiBlob;
skiBlob.cbData = dwSubjectKeyIdentifier;
skiBlob.pbData = pbSubjectKeyIdentifier;

//encode subject key identifier extension
LPBYTE pbEncodeSKI = NULL;
DWORD dwEncodedSKI;
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&amp;skiBlob,
    NULL,
    &amp;dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to get length to encode extension: subject key identifier"");
}

pbEncodeSKI = (LPBYTE)LocalAlloc(0, dwEncodedSKI);
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&amp;skiBlob,
    pbEncodeSKI,
    &amp;dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to encode extension: subject key identifier"");
}
</code></pre>

<p>This produces this value in the extension (same public key in certificate request): 9d77f29e4fa15e46237d59a7c00efde9d286b9dc</p>

<p>This is my CNG code:</p>

<pre><code>NTSTATUS statusBCryptOpenAlgorithmProvider;
NTSTATUS statusBCryptHash;
BCRYPT_ALG_HANDLE hHashAlg;
LPBYTE pbHash;
DWORD dwHash = 20;
LPSTR lpstrPublicKeyEncoded;
DWORD dwPublicKeyEncoded;
CRYPT_DATA_BLOB skiBlob;

if (!CryptBinaryToStringA(
    infoPublicKey.PublicKey.pbData,
    infoPublicKey.PublicKey.cbData,
    CRYPT_STRING_BINARY,
    NULL,
    &amp;dwPublicKeyEncoded
))
{
    throw std::runtime_error(""Error getting length of encoded binary string (CryptBinaryToString)"");
}

lpstrPublicKeyEncoded = (LPSTR)LocalAlloc(0, dwPublicKeyEncoded);
if (!CryptBinaryToStringA(
    infoPublicKey.PublicKey.pbData,
    infoPublicKey.PublicKey.cbData,
    CRYPT_STRING_BINARY,
    lpstrPublicKeyEncoded,
    &amp;dwPublicKeyEncoded
))
{
    LocalFree(lpstrPublicKeyEncoded);
    throw std::runtime_error(""Error encoding binary string (CryptBinaryToString)"");
}

statusBCryptOpenAlgorithmProvider = BCryptOpenAlgorithmProvider(
    &amp;hHashAlg,
    BCRYPT_SHA1_ALGORITHM,
    MS_PRIMITIVE_PROVIDER,
    0
);

if (0 != statusBCryptOpenAlgorithmProvider)
{
    LocalFree(lpstrPublicKeyEncoded);
    throw std::runtime_error(""Error opening SHA1 algorithm provider (BCryptOpenAlgorithmProvider)"");
}

pbHash = (LPBYTE)LocalAlloc(0, dwHash);
statusBCryptHash = BCryptHash(
    hHashAlg,
    NULL,
    0,
    (BYTE*)lpstrPublicKeyEncoded,
    dwPublicKeyEncoded,
    pbHash,
    dwHash
);

if (0 != statusBCryptHash)
{
    LocalFree(lpstrPublicKeyEncoded);
    BCryptCloseAlgorithmProvider(hHashAlg, 0);
    LocalFree(pbHash);
    throw std::runtime_error(""Error hashing public key (BCryptHash)"");
}

skiBlob.pbData = pbHash;
skiBlob.cbData = dwHash;

BCryptCloseAlgorithmProvider(hHashAlg, 0);
LocalFree(pbHash);
LocalFree(lpstrPublicKeyEncoded);

//encode subject key identifier extension
LPBYTE pbEncodeSKI = NULL;
DWORD dwEncodedSKI;
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&amp;skiBlob,
    NULL,
    &amp;dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to get length to encode extension: subject key identifier"");
}

pbEncodeSKI = (LPBYTE)LocalAlloc(0, dwEncodedSKI);
if (!CryptEncodeObject(
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
    szOID_SUBJECT_KEY_IDENTIFIER,
    (void*)&amp;skiBlob,
    pbEncodeSKI,
    &amp;dwEncodedSKI
))
{
    throw std::runtime_error(""Unable to encode extension: subject key identifier"");
}
</code></pre>

<p>This produces this SKI value (different): 210816297e8e76879f99ec4762452b5d38967b5b</p>

<p>Any clue what I am doing wrong in the CNG code sample? There is apparently a magic sequence of calls but I don't know what it is.</p>
","<p>Here you go: both CNG and CAPI variants.</p>

<pre><code>HRESULT capiCreateKeyIdentifierFromPublicKey(NCRYPT_KEY_HANDLE hCngKey, CRYPT_DATA_BLOB* outHash)
{
    HRESULT                 hr         = S_OK;
    BOOL                    bResult    = FALSE;

    PCERT_PUBLIC_KEY_INFO   pCertInfo  = NULL;
    DWORD                   cbCertInfo = 0;

    outHash-&gt;pbData = NULL;
    outHash-&gt;cbData = 0;


    /* STEP1: Extract public key. */
    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, &amp;cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pCertInfo = (PCERT_PUBLIC_KEY_INFO)HeapAlloc(GetProcessHeap(), 0, cbCertInfo);
    if (NULL == pCertInfo) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }


    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, &amp;cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP2: Make hash. */
    bResult = CryptHashPublicKeyInfo(NULL, CALG_SHA1, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, NULL, &amp;outHash-&gt;cbData);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    outHash-&gt;pbData = (BYTE*)HeapAlloc(GetProcessHeap(), 0, outHash-&gt;cbData);

    bResult = CryptHashPublicKeyInfo(NULL, CALG_SHA1, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, outHash-&gt;pbData, &amp;outHash-&gt;cbData);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }


Cleanup:
    if (!SUCCEEDED(hr) &amp;&amp; NULL != outHash-&gt;pbData) {
        HeapFree(GetProcessHeap(), 0, outHash-&gt;pbData);
        outHash-&gt;pbData = NULL;
        outHash-&gt;cbData = 0;
    }

    if (NULL != pCertInfo) {
        HeapFree(GetProcessHeap(), 0, pCertInfo);
        pCertInfo = 0;
    }

    return hr;
}


HRESULT cngCreateKeyIdentifierFromPublicKey(NCRYPT_KEY_HANDLE hCngKey, CRYPT_DATA_BLOB* outHash)
{
    // @see https://docs.microsoft.com/en-us/windows/desktop/seccng/creating-a-hash-with-cng
    HRESULT                 hr           = S_OK;
    BOOL                    bResult      = FALSE;

    BCRYPT_ALG_HANDLE       hAlg         = NULL;
    BCRYPT_HASH_HANDLE      hHash        = NULL;
    NTSTATUS                status       = 0;

    DWORD                   cbData       = 0;
    DWORD                   cbHashObject = 0;
    PBYTE                   pbHashObject = NULL;

    PCERT_PUBLIC_KEY_INFO   pCertInfo    = NULL;
    DWORD                   cbCertInfo   = 0;

    BYTE*                   pbEncodedCertInfo = NULL;
    ULONG                   cbEncodedCertInfo = 0;

    outHash-&gt;pbData = NULL;
    outHash-&gt;cbData = 0;

    /* STEP1: Extract public key. */
    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, &amp;cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pCertInfo = (PCERT_PUBLIC_KEY_INFO)HeapAlloc(GetProcessHeap(), 0, cbCertInfo);
    if (NULL == pCertInfo) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }


    bResult = CryptExportPublicKeyInfo(hCngKey, 0, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pCertInfo, &amp;cbCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP2: Encode the public key. */
    bResult = CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pCertInfo, pbEncodedCertInfo, &amp;cbEncodedCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pbEncodedCertInfo = (BYTE*)HeapAlloc(GetProcessHeap(), 0, cbEncodedCertInfo);

    bResult = CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pCertInfo, pbEncodedCertInfo, &amp;cbEncodedCertInfo);
    if (!bResult) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }



    /* STEP3: Open an algorithm handle. */
    status = BCryptOpenAlgorithmProvider(
        &amp;hAlg,
        BCRYPT_SHA1_ALGORITHM,
        NULL,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP4: Calculate the size of the buffer to hold the hash object. */
    status = BCryptGetProperty(
        hAlg,
        BCRYPT_OBJECT_LENGTH,
        (PBYTE)&amp;cbHashObject,
        sizeof(DWORD),
        &amp;cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP5: Allocate the buffer for hash object on the heap. */
    pbHashObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbHashObject);
    if (NULL == pbHashObject) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }



    /* STEP6: Create a hash object (get handle to CNG hash object). */
    status = BCryptCreateHash(
        hAlg,
        &amp;hHash,
        pbHashObject,
        cbHashObject,
        NULL,
        0,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP7: Calculate the length of buffer for result hash. */
    status = BCryptGetProperty(
        hAlg,
        BCRYPT_HASH_LENGTH,
        (PBYTE)&amp;outHash-&gt;cbData,
        sizeof(DWORD),
        &amp;cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }



    /* STEP8: Allocate buffer for result hash on the heap. */
    outHash-&gt;pbData = (PBYTE)HeapAlloc(GetProcessHeap(), 0, outHash-&gt;cbData);
    if (NULL == outHash-&gt;pbData) {
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Cleanup;
    }



    /* STEP9: Hash data. */
    status = BCryptHashData(
        hHash,
        (PBYTE)pbEncodedCertInfo,
        cbEncodedCertInfo,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }


    /* STEP10: Close hash object and get result value. */
    status = BCryptFinishHash(
        hHash,
        outHash-&gt;pbData,
        outHash-&gt;cbData,
        0
    );

    if (!NT_SUCCESS(status)) {
        hr = HRESULT_FROM_NT(status);
        goto Cleanup;
    }

Cleanup:
    if (!SUCCEEDED(hr) &amp;&amp; NULL != outHash-&gt;pbData) {
        HeapFree(GetProcessHeap(), 0, outHash-&gt;pbData);
        outHash-&gt;pbData = NULL;
        outHash-&gt;cbData = 0;
    }

    if (NULL != hHash) {
        BCryptDestroyHash(hHash);
        hHash = NULL;
    }

    if (NULL != pbHashObject) {
        HeapFree(GetProcessHeap(), 0, pbHashObject);
        pbHashObject = NULL;
    }

    if (NULL != hAlg) {
        BCryptCloseAlgorithmProvider(hAlg, 0);
        hAlg = NULL;
    }

    if (NULL != pbEncodedCertInfo) {
        HeapFree(GetProcessHeap(), 0, pbEncodedCertInfo);
        pCertInfo = 0;
    }

    if (NULL != pCertInfo) {
        HeapFree(GetProcessHeap(), 0, pCertInfo);
        pCertInfo = 0;
    }

    return hr;
}
</code></pre>

<p>Usage:</p>

<pre><code>CRYPT_DATA_BLOB subjectKeyIdentifier = { 0 };
NCRYPT_KEY_HANDLE hCngKey = NULL;

HRESULT hr = NCryptOpenStorageProvider(&amp;hProvider, MS_KEY_STORAGE_PROVIDER, 0);
if (hr) {
    hr = NCryptOpenKey(hProvider, &amp;hCngKey, wszKeyName, 0, 0);
    if (ERROR_SUCCESS == hr) {
        hr = cngCreateKeyIdentifierFromPublicKey(hCngKey, &amp;subjectKeyIdentifier);
        if (hr) {
            // do smth with data
            // clear the memory
            HeapFree(GetProcessHeap(), 0, subjectKeyIdentifier.pbData);
            subjectKeyIdentifier.pbData = NULL;
            subjectKeyIdentifier.cbData = 0;
        }

    }
}

......
</code></pre>
","301","<c++><hash><cryptoapi><cng>","0","2","1","2018-07-05 15:13:46","51194439","1","","","","","2018-02-07 21:09:30",""
"55151904","How to get the public key from a certificate in windows system certstore","<p>I have added a certificate to the system store with something like this:</p>

<pre><code>PCCERT_CONTEXT pCertContext;
HCERTSTORE hCertStore;
CRYPT_KEY_PROV_INFO provInfo;

if (pCertContext = CertCreateCertificateContext(MY_ENCODING_TYPE, certDER, certSize)) {
    provInfo.pwszContainerName = idCert;
    provInfo.pwszProvName = provName;
    provInfo.dwProvType = provType;
    provInfo.dwFlags = 0;
    provInfo.cProvParam = 0;
    provInfo.rgProvParam = NULL;
    provInfo.dwKeySpec = AT_SIGNATURE;

    if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;provInfo)) Error(TEXT(""CertSetCertificateContextProperty""));

    if (!(hCertStore = CertOpenSystemStore(NULL, L""MY""))) Error(TEXT(""CertOpenSystemStore""));
    if (!CertAddCertificateContextToStore(hCertStore, pCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL)) Error(TEXT(""CertAddCertificateContextToStore""));
    CertFreeCertificateContext(pCertContext);
} else Error(TEXT(""CertCreateCertificateContext""));
</code></pre>

<p>Now I'm making a Cryptographyc Service Provider and need to get the public key from this certificate to implement the CPExportKey() function.</p>

<p>Is this possible? If it is, how can I do it?</p>

<p>Also, if someone could point me at a kind of guide, or howto, of CSP drivers implementation it would be great! I'm having a bad time searching documentation for these things.</p>
","<p>So I found the solution below. With all non-essential for understanding code omitted.</p>

<p>Iterate through the certificates in the store and through its properties to find my certificate, then use the <code>CryptDecodeObjectEx()</code> function to convert the key to the <code>RSA_CSP_PUBLICKEYBLOB</code> format. </p>

<p>The key is kept at this location <code>pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.pbData</code> and its size at <code>pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.cbData</code>.</p>

<pre><code>HCERTSTORE hCertStore = NULL;
PCCERT_CONTEXT pCertContext = NULL;
PBYTE pbPKEY = NULL;
DWORD iPKEYSize;

hCertStore = CertOpenSystemStore(NULL, L""MY"");

while(pCertContext = CertEnumCertificatesInStore(
    hCertStore,
    pCertContext))
{
    DWORD dwPropId = 0;
    while(dwPropId = CertEnumCertificateContextProperties(
        pCertContext, // The context whose properties are to be listed.
        dwPropId))    // Number of the last property found.  
    {
        // ...
        // here I compare the properties to see if it is the certificate that I want.
        // ...
        CryptDecodeObjectEx((PKCS_7_ASN_ENCODING | X509_ASN_ENCODING), 
            RSA_CSP_PUBLICKEYBLOB, 
            pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.pbData, 
            pCertContext-&gt;pCertInfo-&gt;SubjectPublicKeyInfo.PublicKey.cbData, 
            CRYPT_ENCODE_ALLOC_FLAG, 
            NULL, 
            &amp;pbPKEY, 
            &amp;iPKEYSize);

            // pbData and pcbDataLen are output parameters of the function
            *pcbDataLen = iPKEYSize;
            memcpy(pbData, pbPKEY, *pcbDataLen);
            LocalFree((HANDLE)pbPKEY);
        }
    }
}
</code></pre>
","300","<c++><windows><cryptoapi><certificate-store>","2","2","1","2019-03-15 20:43:38","55190427","1","1","","","","2019-03-13 22:07:07",""
"43939884","Windows CryptoApi private key dialog box NOT at front","<p>I have a C# background desktop app (like a service) listening http requests. </p>

<p>When I request my service, the service try sign a pdf* using a certificate (local user) that was imported with enabled secure protection of the private key therefore windows prompt a windows Crypto Api dialog box to ask the private key. </p>

<p>*The dialogbox is opened at this like:
MakeSignature.SignDetached(signatureAppearance, pks, new[] { certificate }, null, null, null, 0, CryptoStandard.CADES);
where MakeSignature is part of iTextSharp.text.pdf.security Version=5.5.0.0</p>

<p><strong>The problem is that the first prompt of the CryptoApi private key it appears at the background of current window (browser).</strong></p>

<p>Does someone knows how could I force the cryptoApi to be at the front?</p>

<p><img src=""https://image.ibb.co/eV5NJ5/crypto_Api_Dialog_Box.png"" alt=""cryptoApi Dialog box""></p>

<p>Best Regards,
Francisco.</p>
","","284","<c#><certificate><itext><cryptoapi>","1","","0","2017-06-01 07:26:13","","1","","","","","2017-05-12 14:12:01",""
"23255701","CryptEncrypt gives different results for different languages","<p>When I run this code in C++ (shown), C#, or VB6, I get different results for pbBuffer in CryptEncrypt! The only thing I can think of is CryptEncrypt is language-based or the parameters are wrong for the other functions. What other reason would this happen? Am I passing the wrong parameters to CryptDeriveKey?</p>

<pre><code>if (CryptAcquireContext(&amp;hProv, NULL, NULL, PROV_RSA_FULL, 0))     
{   
    if (CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;hHash))        
    {   
        if (CryptHashData(hHash, (BYTE *)szLocalPassword, _tcslen(szLocalPassword), 0))            
        {
            if (CryptDeriveKey(hProv, CALG_RC4, hHash, CRYPT_EXPORTABLE, &amp;hKey))                   
            {   
                dwLength = sizeof(TCHAR)*_tcslen(sUnencryptedString);                      
                BYTE *pbBuffer = (BYTE *)malloc(dwLength);                     
                if (pbBuffer != NULL)                      
                {   
                // Convert TCHAR to BYTE
                char c_szText[128] = {0};       // Any char
                SIZE_T so = wcslen(sUnencryptedString) + 1;
                wcstombs(c_szText, sUnencryptedString, so);
                memcpy(pbBuffer, c_szText, dwLength);

                if (CryptEncrypt(hKey, 0, TRUE, 0, pbBuffer, &amp;dwLength, dwLength))                         
</code></pre>
","<p>This is the VB code that shows how to pass the correct info to the Crypto APIs to encrypt a string in VB6. Hopefully someone can use this info when searching!</p>

<pre><code>...
Dim bKeyRoot() As Byte
bKeyRoot = StrConv(sKeyRoot, vbFromUnicode)
lResult = CryptHashData(hHash, bKeyRoot(0), Len(sKeyRoot), 0)
...
Dim bText() As Byte
bText = StrConv(sText, vbFromUnicode)
lResult = CryptEncrypt(lKey, 0, 1, 0, bText(0), lClear, lData)
sText = StrConv(bText, vbUnicode)
</code></pre>
","281","<c#><c++><vb6><cryptoapi>","0","0","1","2014-04-29 01:17:49","","8","","662586","","2014-04-29 01:16:42","2014-04-23 21:38:30",""
"40844688","Add extension to certificate using CryptoApi","<p>I'm trying to add an extension to the certificate request using the CryptoApi. Here is the code that I use:</p>

<pre class=""lang-c prettyprint-override""><code>char extensionValue[] = ""testValue"";


_CRYPTOAPI_BLOB myBlob = {
    (DWORD)strlen(extensionValue),
    (BYTE*)extensionValue
};

wchar_t pszString[1000];
DWORD dwLength = 1000;
bool checkEncodingToBase64Test = CryptBinaryToStringW(myBlob.pbData, myBlob.cbData, CRYPT_STRING_BASE64, (LPWSTR)pszString, &amp;dwLength);


BSTR bstrValue = pszString;
BSTR bstrName = SysAllocString(L""1.2.643.100.111"");

HRESULT checkAddingExtention = pEnroll-&gt;addExtensionToRequest(0, bstrName, bstrValue);
</code></pre>

<p>To check the request I use <a href=""https://certlogik.com/decoder/"" rel=""nofollow noreferrer"">https://certlogik.com/decoder/</a>
When checking here get this result:</p>

<pre><code>Requested Extensions:
        X509v3 Extended Key Usage: 
            TLS Web Client Authentication, E-mail Protection, 1.2.643.2.2.34.6
        X509v3 Key Usage: 
            Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment
        1.2.643.100.111: 
            testValue

SEQUENCE {:
   OBJECT IDENTIFIER '1 2 643 100 111'
   OCTET STRING 74 65 73 74 56 61 6C 75 65
}
</code></pre>

<p>But I need to get this type of structure:</p>

<pre><code>SEQUENCE {
  OBJECT IDENTIFIER '1 2 643 100 111'
  OCTET STRING, encapsulates {
  UTF8String
  'testValue'
  }
}
</code></pre>

<p>How to achieve this? How to put a UTF8-string in extension?</p>
","<p>Try to do it this way</p>

<pre><code>WCHAR *id = L""testValue"";
CERT_NAME_VALUE otherNameValue = { CERT_RDN_UTF8_STRING, (DWORD)wcslen(id) * sizeof(wchar_t), (PBYTE)id };

BYTE *buf;
DWORD size = 0;
CryptEncodeObjectEx(PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, X509_ANY_STRING, &amp;otherNameValue, CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;buf, &amp;size);

CERT_EXTENSION CertExtension[] = { {""1.2.643.100.111"", FALSE, size, buf} };

...
LocalFree(buf);
</code></pre>
","279","<c++><c><winapi><x509certificate><cryptoapi>","1","0","1","2018-09-11 14:45:33","","1","","7088776","","2016-11-28 13:29:22","2016-11-28 12:44:31",""
"37523101","CryptProtectData fails with NTE_BAD_KEYSET (0x80090016) error on Windows XP when run from the local service","<p>I'm using the following code from within my local service to scramble some sensitive data before it's saved in the <code>HKLM</code> key:</p>

<pre><code>LPCTSTR pStr = L""This is a plaintext string!"";

DATA_BLOB blobIn;
blobIn.pbData = (BYTE*)pStr;
blobIn.cbData = lstrlen(pStr) * sizeof(TCHAR);

DATA_BLOB blobOut = {0};

if(::CryptProtectData(&amp;blobIn, NULL, NULL, NULL, NULL, CRYPTPROTECT_UI_FORBIDDEN, &amp;blobOut))
{
    //Success, use encrypted byte array from blobOut.pbData

    ::LocalFree(blobOut.pbData);
}
</code></pre>

<p>Well, this works fine, except when run on Windows XP (from within my local service.) The <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380261%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396"" rel=""nofollow"">CryptProtectData</a> API fails with error code NTE_BAD_KEYSET (0x80090016).</p>

<p>Any idea how to make it work there?</p>
","","277","<c++><windows><winapi><cryptoapi>","2","","0","2016-05-30 10:14:13","","4","","","","","2016-05-30 10:14:13",""
"50322187","What is the GUID suffix on key container storage files in Windows?","<p>I am wondering what are the GUID suffixes for the RSA key container files stored in the machine and user key container stores. I cannot identify some of these as key containers through CAPI/CNG, although I'll expose my case using command line tools instead. Commands below are for PowerShell in an elevated prompt. On most machines, the GUID suffix is the same for all these file names, but on this one there are <em>four</em> different GUIDs, while the API is returning only keys with only one. <strong>What is this GUID?</strong> I do not like random secrets stored by I do not know what on my machine; <strong>are they safe to delete?</strong></p>

<p>The content of the machine store directory is:</p>

<pre><code>&gt; ls -n $env:ProgramData\Microsoft\Crypto\Rsa\MachineKeys  | sort { ""$_""[-3..-1] }
d1f9044f5d7345da71c0d2efd2e4f59e_e9f96f2e-b8b7-49b2-85a5-840195eca603
d6d986f09a1ee04e24c949879fdb506c_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
6de9cb26d2b98c01ec4e9e8b34824aa2_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
76944fb33636aeddb9590521c2e8815a_a4dc5a56-574d-4e4b-ba8d-d88984f9a6c5
d6d986f09a1ee04e24c949879fdb506c_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
d1f9044f5d7345da71c0d2efd2e4f59e_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
ba8e1b9b5510957b3af7b811f05660de_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
d1f9044f5d7345da71c0d2efd2e4f59e_c6a7fc9d-32a6-41e4-afd5-7dc7b822029e
</code></pre>

<p>I sorted the list by the last three characters, so that it's easy to see in a glance that there are 4 distinct GUID suffixes to the key container files. Now let's enumerate the key reported by all installed CSPs. I'll get the list of providers, and later the list of each provider's keys using the <code>certutil</code> tool that comes with Windows. Its output requires some regex magic for parsing, which is not essential, just convenient:</p>

<pre><code>&gt; certutil -csplist | sls  '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value }
Microsoft Base Cryptographic Provider v1.0
Microsoft Base DSS and Diffie-Hellman Cryptographic Provider
Microsoft Base DSS Cryptographic Provider
[...snip...]
</code></pre>

<p>The output for a single key lists the name, flags and the key container ID, the latter matching respective file name in the above directory (of course, we can see more keys from additional KSPs, smart cards, TPM etc.). Example for one provider (the <code>-q</code> makes some providers fail silently instead of asking for user's action, such as inserting a SmartCard):</p>

<pre><code>&gt; certutil -key -q
Microsoft Strong Cryptographic Provider:
  iisConfigurationKey
  6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  RSA
    AT_KEYEXCHANGE

  iisWasKey
  76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  [...snip...]
</code></pre>

<p>Some key names are just GUIDs too, but if we grep out only the lines that start with at the least 20 hex digits, there will be only the IDs listed. So all key IDs from all providers can be concisely shown with:</p>

<pre><code>&gt; certutil -csplist | sls '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value } |
%{ certutil -key -q -csp ""$_"" } | sls '^\s+[0-9a-f]{20}.+' | sort -u

  597367cc37b886d7ee6c493e3befb421_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  6de9cb26d2b98c01ec4e9e8b34824aa2_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  76944fb33636aeddb9590521c2e8815a_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  ba8e1b9b5510957b3af7b811f05660de_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  d6d986f09a1ee04e24c949879fdb506c_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
  f0e91f6485ac2d09485e4ec18135601e_f7fe3b04-ef9b-4b27-827f-953c5743e2ec
</code></pre>

<p>Here are actually 2 more keys than there are in the MachineKeys directory (they come from the KSP, in fact, <code>certutil -key -csp KSP</code> shows them, if you are wondering). But the fact is they all have the same GUID suffix <code>_f7fe3b04-ef9b-4b27-827f-953c5743e2ec</code>.</p>

<p>The machine was installed by the vendor (an HP notebook, to be exact). This is unlike other machines, that we assemble or buy barebone and install and configure by ourselves. And I am working with some sensitive data sometimes, so I am indeed <s>paranoid</s> vetting the software thoroughly before allowing machines to access sensitive data.</p>

<p>The OS is Windows 10, if that matters, but the same type of storage has not changed from Windows 7, AFAIK, even with the introduction of the new CNG API in 8.0 (or 8.1?).</p>

<hr>

<p>Just in case anyone would find useful a PowerShell snippet to readably list keys by provider, I used this command:</p>

<pre><code>&gt; certutil -csplist | sls  '^Provider Name: (.*)' | %{ $_.Matches[0].Groups[1].Value } |
%{ Write-Host -for Yellow ""`n$_""; certutil -key -q -csp ""$_"" }
</code></pre>
","<p>Found the answer here: <a href=""https://serverfault.com/a/642279/451491"">https://serverfault.com/a/642279/451491</a></p>

<blockquote>
  <p>The file naming convention is x_y, where x is a random GUID to
  uniquely identify the key, and y is the machine GUID found at
  HKLM\SOFTWARE\Microsoft\Cryptography.</p>
</blockquote>
","275","<windows><security><cryptoapi><cng>","2","1","1","2019-04-25 13:29:59","","1","","15168","","2018-06-19 15:53:59","2018-05-14 01:48:42",""
"23010561","cloud9 crypto is not working at all been trying for days","<p>I am trying to get a setup work with utils, the problem is it can not find the crypto module.</p>

<p>I have install utils and crypto using npm install then when I run my script</p>

<pre><code>node server.js casper.js
</code></pre>

<p>I get this error </p>

<pre><code>Error: Cannot find module 'crypto'

phantomjs://bootstrap.js:289
phantomjs://bootstrap.js:254 in require
/var/lib/stickshift/53452520e0b8cd1d870002e1/app-root/data/828422/node_modules/utils/utils.js:7
/var/lib/stickshift/53452520e0b8cd1d870002e1/app-root/data/828422/node_modules/utils/utils.js:117
/var/lib/stickshift/53452520e0b8cd1d870002e1/app-root/data/828422/node_modules/utils/utils.js:118
TypeError: 'undefined' is not a function (evaluating 'utils.inherits(Nightmare, Casper)')

/var/lib/stickshift/53452520e0b8cd1d870002e1/app-root/data/828422/node_modules/nightmarejs/lib/nightmareClient.js:21
/var/lib/stickshift/53452520e0b8cd1d870002e1/app-root/data/828422/node_modules/nightmarejs/lib/nightmareTest.js:16
</code></pre>

<p>why can it not find crypto. I have tried all different ways to get this working, but no luck 
does any one have any ideas?</p>

<p>package.json file</p>

<pre><code>    {
  ""name"": ""chat-example"",
  ""version"": ""0.0.0"",
  ""description"": ""A chat example to showcase how to use `socket.io` with a static `express` server"",
  ""main"": ""server.js"",
  ""repository"": """",
  ""author"": ""Mostafa Eweda &lt;mostafa@c9.io&gt;"",
  ""dependencies"": {
    ""async"": ""~0.2.8"",
    ""express"": ""~3.2.4"",
    ""socket.io"": ""~0.9.14"",
    ""phantomjs"": ""*"",
    ""casperjs"": ""*"",
    ""nightmarejs"": ""*"",
    ""utils"": ""*"",
    ""casper"": ""*""
  }
}
</code></pre>

<p>server.js</p>

<pre><code>var nightmareJS = require('./node_modules/nightmarejs/lib/nightmare').nightmare('test');

nightmareJS.notifyCasperMessage = function(msg) {
    if(msg.type == 'statement') {
        console.log(msg.msg);
        console.log(""Nightmare Server says hello."");
    }
    else if(msg.type == 'dateQuestion') {
        console.log(msg.msg);
        var d = new Date();
        nightmareJS.sendCasperMessage({ time: d.toString(), timeNow: d.getTime()});
    }
}
</code></pre>

<p>casper.js</p>

<pre><code>casper.start('http://www.google.com', function() {
    this.test.assertTitle('Google', 'Google has the correct title');
    this.sendMessageToParent({ type: 'statement', msg: 'Hello Nightmare.'})
})

casper.then(function() {
    this.waitForMessageResponse({ type: 'dateQuestion', msg: 'What time is it?'}, 'time', function() {
        var d = new Date();
        this.echo('Nightmare thinks the time is: ' + this.lastDataReceived.time);
        this.log('Nightmare thinks the time is: ' + this.lastDataReceived.time, 'debug');
        this.test.assert(Math.abs(this.lastDataReceived.timeNow - d.getTime()) &lt; 1000, ""Nightmare and Casper's times are within 1000 seconds of each other"");
    })
});

casper.run(function() {
    this.test.done();
});
</code></pre>

<p>and then i run the files using </p>

<p>node server.js casper.js</p>

<p>i am trying to get nightmarejs to work but utils cannot find crypto </p>

<p>please someone help i so need this to work</p>
","","270","<node.js><undefined><cryptoapi><cloud9-ide>","1","","0","2014-04-13 15:35:27","","5","","3407899","","2014-04-13 15:35:27","2014-04-11 10:51:59",""
"33016599","Verify a signature in Java that is created by Windows Crypto API","<p>I have signature created by Crypto API</p>

<pre><code>if(!CryptCreateHash(hProv, CALG_MD5, 0, 0, &amp;Hash))
    return;         
if(!CryptHashData(Hash, Buff,count, 0))
    return;     
if(CryptSignHash(Hash,AT_SIGNATURE,NULL,0,Buff,&amp;count))
...
</code></pre>

<p>I want to verify the signature in Java.</p>

<p>C++ generates a key length of 148 bytes, I need a java 162. I generate it using <a href=""http://www.jensign.com/JavaScience/MSKeytoJKey/"" rel=""nofollow"">http://www.jensign.com/JavaScience/MSKeytoJKey/</a> .
To check out 162 generated 148 coincide.</p>

<p>Then I try to verify the signature</p>

<pre><code>Signature dsa   = Signature.getInstance(""MD5WithRSA"");
dsa.initVerify(rsapublickey);
dsa.update(Text);
Sign = dsa.verify(TextSign);
</code></pre>

<p>You guessed it, the value of Sign is false. What have I missed and is this really going anywhere?</p>
","<p>The native cryptography API uses little-endian byte order while the .NET Framework and JAVA uses big-endian byte order. If you are verifying a signature generated by using Crypto API, you must swap the order of signature bytes before calling function to verify the signature in Java.</p>
","267","<java><c++><rsa><digital-signature><cryptoapi>","2","1","1","2017-07-19 15:13:01","","0","0","1816580","","2015-10-08 19:46:47","2015-10-08 12:59:27",""
"1933858","How to submit for Microsoft Knowledge Base?","<p>I've recently found a very nonobvious solution for a Microsoft CryptoAPI issue. Because of a read-only flag on the (seemingly unrelated) CREDHIST file, the whole CryptoAPI stack was wildly misbehaving, from CryptAcquireContext() upwards. For the greater common good, I'd like to see this documented in MS KB, where it belongs.</p>

<p>From my past exploits around the MS KB I know that strangers aren't supposed to submit articles; only MS employees and contractors do. So I'm looking for a MS-affiliated sponsor who'd submit the article on my behalf. The credit does not matter; articles are anonymous anyway.</p>

<p>Full write-up here:
<a href=""http://social.msdn.microsoft.com/Forums/en/windowssecurity/thread/11b08625-b432-4667-ab82-a7e0ed008fc3"" rel=""nofollow noreferrer"">http://social.msdn.microsoft.com/Forums/en/windowssecurity/thread/11b08625-b432-4667-ab82-a7e0ed008fc3</a></p>
","<p>Try submitting the relevant comments, writeup, etc. via the ""Send comments about this topic to Microsoft"" link from a top-level <a href=""http://msdn.microsoft.com/en-us/library/aa380255%28VS.85%29.aspx"" rel=""noreferrer"">CryptoAPI MSDN page</a> (which just generates an email).</p>

<p>EDIT: If you're a TechNet subscriber, you have <a href=""http://technet.microsoft.com/en-us/subscriptions/bb521230.aspx"" rel=""noreferrer"">two free incidents</a> you can use to contact Microsoft about this.  You'll also get guaranteed forum replies from Microsoft with a subscription.  If you don't subscribe, you can <a href=""https://support.microsoft.com/oas/default.aspx?&amp;c1=509&amp;gprid=3223&amp;&amp;st=1"" rel=""noreferrer"">pay some money for a one-time incident</a>.  Or, if you can phrase it as a Vista SP1 issue, <a href=""https://support.microsoft.com/oas/default.aspx?prid=11274&amp;gprid=500921&amp;x=8&amp;y=9&amp;st=1"" rel=""noreferrer"">you might be able to get some attention for free</a>.</p>
","263","<cryptoapi>","7","11","1","2011-09-01 07:41:56","1933898","2","1","","","","2009-12-19 19:10:16","2011-09-01 13:25:55"
"35057272","How to get next certificate in chain","<p>I want to get parent certificate (or all certificates in chain for that matter) from Windows Certificate Store (assuming I know the location of the end certificate). I need to get each one in order to build my own custom <code>X509_STORE</code> (using <em>OpenSSL</em>). </p>

<p>I think the proper course of action would be:</p>

<ol>
<li>obtain first certificate using <code>CertFindCertificateInStore</code> (done)</li>
<li>get the certificate chain using <code>CertGetCertificateChain</code> (done)</li>
<li>extract the certificates from chain (?)</li>
<li>for each certificate in chain, convert it using <code>d2i_X509</code> (done)</li>
</ol>

<p>or</p>

<ol>
<li>obtain first certificate using <code>CertFindCertificateInStore</code> (done)</li>
<li>get the parent certificate (if exists) (?)</li>
<li>convert it using <code>d2i_X509</code>, go to 2. (done)</li>
</ol>

<p>Then create the store.</p>

<p>The question to answer is then - how to get the parent certificate or all certificates in chain using Windows Certificate Store? I'm probably missing some more or less occult function here.</p>
","<p>as the <code>CertFindCertificateInStore</code> outputs a chain context, one can access it's members using the beautiful construction:</p>

<p><code>chainContext-&gt;rgpChain[0]-&gt;rgpElement[iCertIndex]-&gt;pCertContext-&gt;pbCertEncoded</code></p>

<p>where <code>iCertIndex</code> is between <code>0</code> (end-certificate) and <code>chainSize -1</code> (self-signed root certificate).</p>
","259","<c><openssl><cryptoapi><wincrypt>","0","0","1","2016-01-28 10:47:44","35059262","0","","4658000","","2016-01-28 10:47:44","2016-01-28 09:15:23",""
"37340414","How to encrypt a file using Crypto API with multiple threads?","<p>I am trying to encrypt a file using multiple threads and Crypto API / AES256 / CBC mode / <strong>NO</strong> IV (initialization vector) is used.</p>

<p>I am dividing the file into as many number of threads. The thread which gets the last block of the file, does a CryptEncrypt passing Final as true.</p>

<p>Following the approach suggested <a href=""https://blogs.msdn.microsoft.com/alejacma/2008/06/30/threading-issues-with-cryptoapi/"" rel=""nofollow"">here</a>: Each thread uses a duplicated key.</p>

<p>Additionally, each thread opens the source file in shared read mode and starts reading from the offset allotted, keeping encrypting and writing to the destination file (again opened in shared write mode) as appropriate offsets.</p>

<p>The output file which i get in case of single and multi threaded is not the same and hash mismatches. What is that i am doing wrong?</p>
","<p>You cannot do that. IV or chaining mode is irrelevant here (though some chaining mode allows parallelism - but is would be its implementation). Consider performing encryption of following text:</p>

<pre><code>""Block cipher mode of operation""
</code></pre>

<p>Somehow you divide it this way (2 threads):</p>

<ul>
<li><code>""Block cipher mo""</code></li>
<li><code>"" de of operation""</code></li>
</ul>

<p>How can you be sure that it gets executed (by OS scheduler) in the same sequence? If you divide it into 3 threads, it may be:</p>

<ul>
<li><code>""Block ciphe""</code></li>
<li><code>""r mode o""</code></li>
<li><code>""f operation""</code></li>
</ul>

<p>but it may get executed as:</p>

<ul>
<li><code>""r mode o""</code></li>
<li><code>""f operation""</code></li>
<li><code>""Block ciphe""</code></li>
</ul>

<p>The end result, as you can guess, would be different!</p>

<p>Also, with CBC mode, the result depends on previous outcome, a <a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29"" rel=""nofollow"">mentioned here</a>. See, on the right side, CBC is not parallelizable.</p>
","252","<windows><visual-c++><aes><encryption-symmetric><cryptoapi>","1","1","1","2016-05-20 09:00:07","37340637","1","0","1987142","","2016-05-20 09:00:07","2016-05-20 07:22:06",""
"36569940","Writing my own CSP (cryptographic service provider)","<p>I have to implement my own csp for signing. I have access to remote certificate storage, which implements functions for signing. Server API has call for listing all certificates. I want to add those certificates to containers. I read csp cookbook, but there is no mention, when I should add those certificates to containers. I implemented pkcs11 module, which is functional on linux. Certificates are added to slots in C_Initialize function. 
I believe that the first function which is called is CryptAquiareContext so that´s probably the function I was looking for. Is that correct? And what is a difference between CryptAquireContext and CPAquireContext and which function should I use? I would take any advice to make it right. Thank you.</p>
","<p>CryptAquireContext is called by user code. CryptAquireContext  function-- enumerates the registred CSP in system registry, then loads appropriate image into memory and pass arguments to the CPAquireContext function. So of CP* function should be exported from your CSP-library. </p>
","248","<c><cryptoapi><pkcs#11>","3","1","1","2017-02-10 07:13:03","","0","2","761212","","2017-01-01 07:32:29","2016-04-12 10:02:06",""
"46363692","Always getting same encrypted string with CryptoAPI","<p>Is there a way to get a non-deterministic output from the CryptoAPI? In other words, a different string output when encrypting a string.</p>

<p>For example, using CALG_AES_256 when deriving a crypt key with password of 'password' and string to encrypt of 'a', it always returns ""SnÆwÞ¢L\x1e?6FÏLþw""</p>

<p>I'm somewhat of a n00b in using CryptoAPI, so any assistance is appreciated.</p>

<p>Edited:
Here is the cryptography code from Microsoft's example code <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382044(v=vs.85).aspx"" rel=""nofollow noreferrer"">decrypte</a> and <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382358(v=vs.85).aspx"" rel=""nofollow noreferrer"">encrypt</a> This is the same code, just shortened/compacted. This code was compiled in VS 2017 as a Win32 Console app. pszSource and pszDest are two files in the C:\temp folder. source.txt has the letter we're trying to encrypt in it.</p>

<p>The problem I'm having is that this crypt/decrypt code from the CryptoAPI <b>does not</b> allow certain strings to be encrypted and then decrypted (i.e. n, t, L, p, aa, ab, ac, ad, ae, etc). If someone can tell me why, that would be very helpful.</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;wincrypt.h&gt;

#define KEYLENGTH  0x00800000
#define ENCRYPT_BLOCK_SIZE 8 

bool MyDecryptFile(LPTSTR szSource,LPTSTR szDestination,LPTSTR szPassword);
bool MyEncryptFile(LPTSTR szSource,LPTSTR szDestination,LPTSTR szPassword);

int _tmain(int argc, _TCHAR* argv[])
{

    LPTSTR pszSource = L""c:\\temp\\source.txt"";
    LPTSTR pszDestination = L""c:\\temp\\dest.txt"";
    LPTSTR pszPassword = L""t"";

    if (MyEncryptFile(pszSource, pszDestination, pszPassword))
        {
        _tprintf(TEXT(""Encryption of the file %s was successful. \n""),pszSource);
        _tprintf(TEXT(""The encrypted data is in file %s.\n""),pszDestination);
        }

    if (MyDecryptFile(pszSource, pszDestination, pszPassword))
        {
        _tprintf(TEXT(""Encryption of the file %s was successful. \n""),pszSource);
        _tprintf(TEXT(""The encrypted data is in file %s.\n""),pszDestination);
        }

    return 0;
}

bool MyEncryptFile(LPTSTR pszSourceFile,LPTSTR pszDestinationFile,LPTSTR pszPassword)
{
    bool fReturn = false;
    HANDLE hSourceFile = INVALID_HANDLE_VALUE, hDestinationFile = INVALID_HANDLE_VALUE;
    HCRYPTPROV hCryptProv = NULL;
    HCRYPTKEY hKey = NULL, hXchgKey = NULL;
    HCRYPTHASH hHash = NULL;
    PBYTE pbBuffer = NULL;
    DWORD dwBlockLen, dwBufferLen, dwCount;

    hSourceFile = CreateFile(pszSourceFile,FILE_READ_DATA,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE == hSourceFile)
        goto Exit_MyEncryptFile;

    hDestinationFile = CreateFile(pszDestinationFile,FILE_WRITE_DATA,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE == hDestinationFile)
        goto Exit_MyEncryptFile;

    CryptAcquireContext(&amp;hCryptProv,NULL,MS_ENH_RSA_AES_PROV,PROV_RSA_AES,0);
    CryptCreateHash(hCryptProv,CALG_SHA_256,0,0,&amp;hHash);
    CryptHashData(hHash,(BYTE *)pszPassword,lstrlen(pszPassword),0);
    CryptDeriveKey(hCryptProv,CALG_AES_256,hHash,CRYPT_EXPORTABLE,&amp;hKey);

    dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
    if (ENCRYPT_BLOCK_SIZE &gt; 1)
        dwBufferLen = dwBlockLen + ENCRYPT_BLOCK_SIZE;
    else
        dwBufferLen = dwBlockLen;
    pbBuffer = (BYTE *)malloc(dwBufferLen);

    bool fEOF = FALSE;
    do
    {
        if (ReadFile(hSourceFile,pbBuffer,dwBlockLen,&amp;dwCount,NULL))
            {
            if (dwCount &lt; dwBlockLen)
                fEOF = TRUE;
            if (CryptEncrypt(hKey,NULL,fEOF,0,pbBuffer,&amp;dwCount,dwBufferLen))
                WriteFile(hDestinationFile,pbBuffer,dwCount,&amp;dwCount,NULL);
            }
    } 
    while (!fEOF);

    fReturn = true;

Exit_MyEncryptFile:
    if (hSourceFile) CloseHandle(hSourceFile);
    if (hDestinationFile) CloseHandle(hDestinationFile);
    if (pbBuffer) free(pbBuffer);
    if (hHash) {CryptDestroyHash(hHash);hHash = NULL;}
    if (hKey) CryptDestroyKey(hKey);
    if (hCryptProv) CryptReleaseContext(hCryptProv, 0);

    return fReturn;
}


bool MyDecryptFile(LPTSTR pszSourceFile,LPTSTR pszDestinationFile,LPTSTR pszPassword)
{
    bool fReturn = false;
    HANDLE hSourceFile = INVALID_HANDLE_VALUE, hDestinationFile = INVALID_HANDLE_VALUE;
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    HCRYPTPROV hCryptProv = NULL;
    PBYTE pbBuffer = NULL;
    DWORD dwCount, dwBlockLen, dwBufferLen;

    hSourceFile = CreateFile(pszDestinationFile,FILE_READ_DATA,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE == hSourceFile)
        goto Exit_MyDecryptFile;

    hDestinationFile = CreateFile(pszSourceFile,FILE_WRITE_DATA,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    if (INVALID_HANDLE_VALUE == hDestinationFile)
        goto Exit_MyDecryptFile;

    CryptAcquireContext(&amp;hCryptProv,NULL,MS_ENH_RSA_AES_PROV,PROV_RSA_AES,0);
    CryptCreateHash(hCryptProv,CALG_SHA_256,0,0,&amp;hHash);
    CryptHashData(hHash,(BYTE *)pszPassword,lstrlen(pszPassword),0);
    CryptDeriveKey(hCryptProv,CALG_AES_256,hHash,CRYPT_EXPORTABLE,&amp;hKey);

    dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
    dwBufferLen = dwBlockLen;

    pbBuffer = (PBYTE)malloc(dwBufferLen);
    bool fEOF = false;
    do
    {
        if (!ReadFile(hSourceFile,pbBuffer,dwBlockLen,&amp;dwCount,NULL))
            goto Exit_MyDecryptFile;

        if (dwCount &lt;= dwBlockLen)
            fEOF = TRUE;

        LONG rv = CryptDecrypt(hKey,0,fEOF,0,pbBuffer,&amp;dwCount);
        if (rv==0)
            {
            DWORD dwErr = GetLastError();       // &lt;--- fails if password and string are n, t, L, p, aa, ab, ac, ad , ae
            goto Exit_MyDecryptFile;
            }

        if (!WriteFile(hDestinationFile,pbBuffer,dwCount,&amp;dwCount,NULL))
            goto Exit_MyDecryptFile;
    } 
    while (!fEOF);

    fReturn = true;

Exit_MyDecryptFile:

    if (pbBuffer) free(pbBuffer);
    if (hSourceFile) CloseHandle(hSourceFile);
    if (hDestinationFile) CloseHandle(hDestinationFile);
    if (hHash) {CryptDestroyHash(hHash);hHash = NULL;}
    if (hKey) CryptDestroyKey(hKey);
    if (hCryptProv) CryptReleaseContext(hCryptProv, 0);

    return fReturn;
}
</code></pre>

<p>What about using this to get the KP_IV option?</p>

<pre><code>BOOL bRV;
bRV = CryptAcquireContextW(&amp;hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0);
bRV = CryptGenKey(hCryptProv, CALG_AES_256,0,&amp;hKey);
DWORD dwMode = CRYPT_MODE_CBC;
bRV = CryptSetKeyParam(hKey,KP_MODE,(BYTE*)&amp;dwMode,0);
BYTE pbData[16];
memcpy(pbData,""n"",sizeof(""n""));  // &lt;--- Hard coded password
bRV = CryptSetKeyParam(hKey,KP_IV,pbData,0);
enter code here
</code></pre>
","<p>If you want to obtain different cypertext when encrypting the same plaintext with the same key, you have to use the <strong>CBC mode of operation</strong>:
<a href=""https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>

<p>In order to correctly encrypt with CBC, you need to generate a different <strong>random Initialization Vector</strong> (IV) every time.
In order to decrypt, you need to know the IV used during encryption.
So, the IV must be associated (in clear) to the cyphertext.</p>

<p>In reference to your example, when calling the CryptDeriveKey function, the CBC is the default mode but it uses an IV set to zero and this invalidates the utility of the CBC operating mode:
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa379916(v=vs.85).aspx</a></p>

<p>In order to set the random IV you need to call the CryptSetKeyParam function, which accept the KP_IV param:
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380272(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380272(v=vs.85).aspx</a></p>

<p>Bye
  Giovanni</p>
","240","<encryption><cryptoapi>","-1","0","1","2017-09-23 13:52:37","","11","","662586","","2017-09-23 13:52:37","2017-09-22 11:27:30",""
"24631389","How to set CFB-128 using Microsoft CryptoAPI?","<p>I am using <code>MS_ENH_RSA_AES_PROV</code> provider with <code>PROV_RSA_AES</code> provider type. I have selected <code>CALG_AES_128</code> block cipher algorithm with <code>CRYPT_MODE_CFB</code> cipher mode.  I would like to set <code>KP_MODE_BITS</code> key parameter to 128, but calling <code>CryptSetKeyParam()</code> by passing value greater than 64 always returns with NTE_BAD_DATA (0x80090005L).</p>

<p>How can I set CFB-128 using CryptoAPI? Thanks.</p>
","","239","<c++><windows><aes><cryptoapi><mscapi>","2","","0","2015-06-09 02:52:30","","0","","608639","","2015-06-09 02:52:30","2014-07-08 12:03:45",""
"48080919","C++ access trusted root certificates","<p>I have created a public/private key pair with openSSL and converted it into a <code>*.pfx</code> file with openSSL. I then imported this file into the <code>Windows Trusted Certificate Store</code>.</p>

<p>I now would like to access the private key from this certificate via c++ code.
Is this possible? If yes, can you please point me into a direction? I haven't found anything suitable yet.</p>
","<p>Yes it is possible to access the private key.</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376050(v=vs.85).aspx"" rel=""nofollow noreferrer"">CertEnumCertificatesInStore</a> returns <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa377189(v=vs.85).aspx"" rel=""nofollow noreferrer"">PCCERT_CONTEXT </a> structure which contain the encoded and decoded representations of certificates. Passing this structure to the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379885(v=vs.85).aspx"" rel=""nofollow noreferrer"">CryptAcquireCertificatePrivateKey</a> obtains the private key from the certificate</p>
","237","<c++><windows><certificate><private-key><cryptoapi>","0","1","1","2018-01-04 09:03:38","","1","1","608639","","2018-01-04 03:57:11","2018-01-03 16:03:22",""
"13628697","Issue validating ASHWID (HardwareToken) in the cloud","<p>I'm trying to validate HardwareToken issued by HardwareIdentification.GetPackageSpecificToken with an azure (.net 4.5) service. I followed the official <a href=""http://msdn.microsoft.com/en-us/library/windows/apps/jj553431.aspx"" rel=""nofollow"">guidance</a>. But i'm stuck in the very last checking. I can't figure why the signature checking is always failing (every other checks such as cheking certificate chain, weighted hardware token comparison or root certiticate publicKey matching are working fine).</p>

<p>Here is the code i'm using to perform the signature validation : 
    var publicKeyProvider = leaf.PublicKey.Key as System.Security.Cryptography.RSACryptoServiceProvider;</p>

<pre><code>var signedData = nonce.Concat(token).ToArray();
SHA1Managed hash = new SHA1Managed();
byte[] hashedData;
hashedData = hash.ComputeHash(signedData);

if (!publicKeyProvider.VerifyHash(hashedData, CryptoConfig.MapNameToOID(""SHA1""), signature))
   throw new Exception(""Invalid or Corrupted HardwareToken"");
</code></pre>

<p>I also tried using VerifyData with the same result, it is always returning False (no matter I use a nonce or not).</p>

<p>I uploaded a very basic sample project right here : <a href=""https://github.com/sandorfr/sandor/tree/master/W8/HardwareTokenSample"" rel=""nofollow"">https://github.com/sandorfr/sandor/tree/master/W8/HardwareTokenSample</a></p>

<p>Did someone faced/solved this issue?</p>

<p>Best regards,</p>
","<p>Signature kind used by ASHWID is not supported by .net because it uses PSS, so I had to make a native call to NCryptVerifySignature.</p>
","234","<windows-8><windows-runtime><cryptoapi><rsacryptoserviceprovider>","0","0","1","2012-12-21 13:08:14","13990796","1","1","1036079","","2012-11-29 15:18:33","2012-11-29 15:07:48",""
"2918024","How Can I Generate Equivalent Output Using the CryptoAPI and the .NET Encryption (TripleDESCryptoServiceProvider)?","<p>I have some C#/.NET code that encrypts and decrypts data using TripleDES encryption.  It sticks to the sample code provided at MSDN pretty closely.  The encryption piece looks like the following:</p>

<pre><code>   TripleDESCryptoServiceProvider _desProvider = new TripleDESCryptoServiceProvider();

    //bytes for key and initialization vector
    //keyBytes is 24 bytes of stuff, vectorBytes is 8 bytes of stuff
    byte[] keyBytes;
    byte[] vectorBytes;

    FileStream fStream = File.Open(locationOfFile, FileMode.Create, FileAccess.Write);

    CryptoStream cStream = new CryptoStream(fStream,
      _desProvider.CreateEncryptor(keyBytes, vectorBytes),
      CryptoStreamMode.Write);

    BinaryWriter bWriter = new BinaryWriter(cStream);

    //write out encrypted data
    //raw data is a few bytes of binary information
    byte[] rawData;
    bWriter.Write(rawData);
</code></pre>

<p>With encrypting and decrypting in C#, this all works like a charm.  The problem is I need to write a small Win32 utility that will duplicate the encryption above.  I have tried several methods using the CryptoAPI, and I simply do not get output that the .NET piece can decrypt, no matter what I do.  Can someone please tell me what the equivalent C++ code is that will produce the same output?</p>

<p>I am not certain just what methods of the CryptoAPI the .NET functions use to encrypt the data.  What options are used, and what method of generating the key is used?</p>

<p>Before someone suggests that I just write it in C# anyway, or create some common library bridge for them, those options are unfortunately off the table.  It really has to work in Win32 with .NET and without using a DLL.  I have some leeway in changing the C# code.</p>

<p>I apologize in advance if this is bone-headed, as I am new to encryption.</p>
","","228","<c#><c++><cryptoapi>","1","","0","2010-05-27 01:59:56","","2","","","","","2010-05-27 01:59:56",""
"6320830","File System Filter and CryptoAPI issue in Win CE","<p>I have been working on a file system filter for the past two weeks and I have come across an interesting issue. I basically built the encoding/decoding implementation in an app that runs on the OS startup in Platform Builder first to verify that it works and for debugging purposes. This app works fine and is able to acquire a context ,generate keys , encrypt /decrypt without issue.</p>

<p>When I try to do the same thing on filesys dll load (this is the point at which file system filters are loaded in my understanding), no CSP services seem available to my file system filter. CryptAcquireContext fails with NTE_BAD_KEYSET or when I attempt to use the default provider, it fails with NTE_PROV_TYPE_NOT_DEF.</p>

<p>In frustration  I wrote some code to enumerate all the providers available at that time and it turns out there arent any when filesys is loaded, wondering if anyone has any experience or ideas that can help. I have officially run out of ideas.</p>

<p>Cheers
Bernard</p>
","","225","<windows-ce><cryptoapi><mscapi>","1","","0","2011-06-12 07:52:44","","0","","","","","2011-06-12 07:52:44",""
"15818891","Creating a .cer [DER encoding] in code","<p>I have a working solution that creates valid .pfx files (based on CryptoAPI being wrapped in C#). I can import this into my private tore, then export it to a .cer</p>

<p>HOWEVER (isnt there always a however?) what I can not do is generate the appropriate .cer file from code. OpenSSL (or any other third party elements) are not an option for this environment, neither is anything that requires a manual/GUI type operation....</p>

<p>I am sure the function exists in the API (CertMgr.msc must call ""Something"" when it does the magic...but two days of searching have yielded nothing.</p>
","<p>A poor mans answer (I would very much a lower level)</p>

<p>// create the pfx byte stream... byte[] selfSigned = CertificateCreator.CreateSelfSignCertificatePfx(distinguishedName, new DateTime(2013, 4, 1), new DateTime(2013, 12, 31), insecurePassword);</p>

<p>// crate a certificate instance X509Certificate2 cert = new X509Certificate2(selfSigned, insecurePassword);</p>

<p>// export as .cer [DER] selfSigned = cert.Export(X509ContentType.Cert);</p>

<p>// write to file.. System.IO.File.WriteAllBytes(certificateFilename+"".cer""), selfSigned);</p>
","223","<certificate><cryptoapi>","0","0","1","2014-05-02 12:01:47","","0","","321731","","2014-05-02 12:01:47","2013-04-04 18:28:13",""
"46187001","What is the certificate store where my USB Token is listed? (Crypto API)","<p>I'm trying to show the default dialog box to select certificate listing my USB token (G&amp;D Burti StarSign). I can show this dialog listing all installed certificates, but my token is not shown. How can I do it using CAPI? (An exemple would be great!)</p>

<p>PS.: The programming language is Delphi, but I understand another C like (C++/C#) languages</p>

<p>The software for token administration show my token:
<a href=""https://i.stack.imgur.com/tzljq.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/tzljq.png"" alt=""enter image description here""></a></p>
","<p>The CSP / drivers need to propagate the certificate to your local machine. Verify the certificate is visible using the certificate mmc snapin. Once you know the certificate store being used, used the above mentioned CryptUIDlgSelectCertificateFromStore to view them. </p>
","221","<delphi><cryptoapi>","1","0","1","2017-09-13 02:08:55","","2","","836749","","2017-09-13 02:08:55","2017-09-13 00:15:02",""
"32146921","Step from CertEnumSystemStoreLocation() to CertEnumSystemStore()","<p>My question is about cryptoAPI interface.</p>

<p>Look, CertEnumSystemStoreLocation() is a function to enumerate all certificate store locations available in system. It returns (using callback) enumerated location as wide string (LPCWSTR).</p>

<p>CertEnumSystemStore() enumerates stores by the given location. It takes integer  constant for location (DWORD) as argument.</p>

<p>I tried to enumerate locations and the result was a list of strings, that semantically is equal to the list of DWORD location constants from CryptoAPI import module.</p>

<p>And my question is: what should i do to translate wide string representation of store  location to DWORD constant? Is there a cryptoAPI function (or, at least, commonly used method) for it?</p>
","<p>It looks like the <code>dwFlags</code> passed to your <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376061(v=vs.85).aspx"" rel=""nofollow""><code>CertEnumSystemStoreLocationCallback</code></a> callback function actually gives you the store location constant, although this is incredibly badly documented.</p>

<p>The example shown here for <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa382362(v=vs.85).aspx"" rel=""nofollow"">Listing System and Physical Stores</a> handles the <code>dwFlags</code> value in its callback like this:</p>

<pre><code>dwFlags &amp;= CERT_SYSTEM_STORE_MASK;
dwFlags |= pEnumArg-&gt;dwFlags &amp; ~CERT_SYSTEM_STORE_LOCATION_MASK;
CertEnumSystemStore(dwFlags, ...);
</code></pre>

<p>So I think if you do that masking you'll be left with the location constant in <code>dwFlags</code> equivalent to the string passed in the <code>pvszStoreLocation</code> parameter.</p>
","221","<windows><winapi><cryptoapi>","0","2","2","2015-08-21 20:49:23","32149046","0","","","","","2015-08-21 18:17:53",""
"32146921","Step from CertEnumSystemStoreLocation() to CertEnumSystemStore()","<p>My question is about cryptoAPI interface.</p>

<p>Look, CertEnumSystemStoreLocation() is a function to enumerate all certificate store locations available in system. It returns (using callback) enumerated location as wide string (LPCWSTR).</p>

<p>CertEnumSystemStore() enumerates stores by the given location. It takes integer  constant for location (DWORD) as argument.</p>

<p>I tried to enumerate locations and the result was a list of strings, that semantically is equal to the list of DWORD location constants from CryptoAPI import module.</p>

<p>And my question is: what should i do to translate wide string representation of store  location to DWORD constant? Is there a cryptoAPI function (or, at least, commonly used method) for it?</p>
","<p>The <code>dwFlags</code> argument passed to the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376061.aspx"" rel=""nofollow"">CertEnumSystemStoreLocationCallback callback function</a> contains the store location encoded in the bits <code>CERT_SYSTEM_STORE_LOCATION_MASK</code>. Shifting those to the right by <code>CERT_SYSTEM_STORE_LOCATION_SHIFT</code> turns it into the numeric store ID.</p>

<p>The following code retrieves the list of store locations alongside the numeric store IDs:</p>

<p>Structure for communication:</p>

<pre><code>#include &lt;SDKDDKVer.h&gt;
#include &lt;windows.h&gt;
#include &lt;wincrypt.h&gt;
#pragma comment(lib, ""Crypt32.lib"")

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

struct Location {
    DWORD StoreId;
    std::wstring Name;
};
typedef std::vector&lt;Location&gt; StoreLocationsContainer;
</code></pre>

<p>Callback:</p>

<pre><code>BOOL WINAPI CertEnumSystemStoreLocationCallback( LPCWSTR pvszStoreLocations,
                                                 DWORD dwFlags,
                                                 void* pvReserved,
                                                 void* pvArg
                                                 ) {
    StoreLocationsContainer&amp; locations = *reinterpret_cast&lt;StoreLocationsContainer*&gt;( pvArg );
    DWORD StoreId = ( dwFlags &amp; CERT_SYSTEM_STORE_LOCATION_MASK )
                    &gt;&gt; CERT_SYSTEM_STORE_LOCATION_SHIFT;
    Location location = { StoreId, std::wstring( pvszStoreLocations ) };
    locations.push_back( location );
    return TRUE;
}
</code></pre>

<p>Implementation:</p>

<pre><code>StoreLocationsContainer GetStoreLocations() {
    StoreLocationsContainer locations;
    if ( !::CertEnumSystemStoreLocation( 0x0,
                                         &amp;locations,
                                         CertEnumSystemStoreLocationCallback ) ) {
        throw std::runtime_error( ""CertEnumSystemStoreLocation"" );
    }
    return locations;
}
</code></pre>

<p>For completeness, here is the remaining code to dump all stores across all locations:</p>

<pre><code>BOOL WINAPI CertEnumSystemStoreCallback( const void* pvSystemStore,
                                         DWORD dwFlags,
                                         PCERT_SYSTEM_STORE_INFO pStoreInfo,
                                         void* pvReserved,
                                         void* pvArg ) {
    std::wcout &lt;&lt; L""  "" &lt;&lt; static_cast&lt;const wchar_t*&gt;( pvSystemStore ) &lt;&lt; std::endl;
    return TRUE;
}

void PrintStores( const StoreLocationsContainer&amp; locations ) {
    for ( const Location&amp; loc : locations ) {
        std::wcout &lt;&lt; loc.Name &lt;&lt; std::endl;
        DWORD dwFlags = ( loc.StoreId &lt;&lt; CERT_SYSTEM_STORE_LOCATION_SHIFT )
                        &amp; CERT_SYSTEM_STORE_LOCATION_MASK;
        ::CertEnumSystemStore( dwFlags, nullptr, nullptr, CertEnumSystemStoreCallback );
    }
}

int main() {
    StoreLocationsContainer locations = GetStoreLocations();
    PrintStores( locations );

    return 0;
}
</code></pre>
","221","<windows><winapi><cryptoapi>","0","0","2","2015-08-21 20:49:23","32149046","0","","","","","2015-08-21 18:17:53",""
"4305952","Can't reproduce ATL-based data decryption in .NET: wrong first 4 bytes","<p>This is C++ code:</p>

<pre><code>CCryptMD5Hash md5;
CCryptProv cprov;
PCWSTR pszPassword = &lt;password&gt;;
BYTE* data = &lt;array of bytes&gt;;
ATL::CCryptDerivedKey m_CryptKey;

md5.Initialize( cprov );
md5.AddData(reinterpret_cast&lt;const BYTE*&gt;(pszPassword), wcslen(pszPassword) * sizeof(wchar_t));

m_CryptKey.Initialize( cprov, md5, CALG_DES);

std::vector&lt;BYTE&gt; buff(data, data + size);
DWORD cbBufSize = buff.size();
m_CryptKey.Decrypt(TRUE, &amp;buff.front(), &amp;cbBufSize));
</code></pre>

<p>It successfully decodes the array of bytes to a string like ""ABC-DEF-2\ZXCVBNMHOHUH,2020100"".</p>

<p>And this is the corresponding .NET code I'm trying to write:</p>

<pre><code>byte[] salt = new byte[0];
byte[] input = &lt;array of bytes&gt;;
byte[] pwd = Encoding.Unicode.GetBytes(&lt;password&gt;);

DESCryptoServiceProvider des = new DESCryptoServiceProvider();
PasswordDeriveBytes pdb = new PasswordDeriveBytes(pwd,  salt);
des.Key = pdb.CryptDeriveKey(""DES"", ""MD5"", 0, des.IV);

MemoryStream ms = new MemoryStream(input);
CryptoStream ds = new CryptoStream(ms, des.CreateDecryptor(), CryptoStreamMode.Read);

StreamReader sr = new StreamReader(ds, Encoding.Unicode);
string s = sr.ReadToEnd();
</code></pre>

<p>Its output string is ""몶뛛跬DEF-2\ZXCVBNMHOHUH,2020100"". So, the first four characters are decoded incorrectly. Changing salt makes these characters different.</p>

<p>Since there is <strong>no salt in C++ code</strong>, I can't even think about it's possible value to try. But all the simple ones don't work too.</p>

<p>Can someone please help?</p>
","<p>Does it work passing a zero value into the C# code for <code>des.IV</code>?</p>

<p>You can set the equivalent CBC IV in the C++ code using <a href=""http://msdn.microsoft.com/en-us/library/kh1xzw45%28v=VS.80%29.aspx"" rel=""nofollow"">SetIV</a></p>

<pre><code>m_CryptKey.SetIV(...);
</code></pre>
","219","<c#><.net><encryption><atl><cryptoapi>","2","1","1","2010-11-29 17:28:07","4306057","0","1","1271135","","2010-11-29 17:28:07","2010-11-29 16:49:40",""
"7527509","Is it possible to reuse a CryptVerifySignature() hash object?","<p>MSDN says that after <code>CryptVerifySignature()</code> you cannot reuse <code>HCRYPTHASH</code> object to try hashing more data, instead it says you need to recreate it with <code>CryptDestroyHash()</code> and <code>CryptCreateHash()</code>. <em>Reusing really fails.</em></p>

<p><strong>Anyone is familiar with a hack that can save these calls, or it is really impossible?</strong></p>
","<p>I imagine the <code>HCRYPTHASH</code> data structure is more flexible than just being used to call with <code>CryptVerifySignature()</code>.  It's designed to operate on a (possibly discontinuous) stream of data (via <code>CryptHashData()</code>), which means it stores some state within it on the hash's current values.  Therefore, once you've used it on a stream (even partial) the state is irrevocably altered, so you can't use it on another stream.</p>

<p>I guess they could've provided a <code>reset</code> function for the <code>HCRYPTHASH</code> structure... but they didn't!</p>
","218","<c><cryptoapi>","0","1","1","2014-04-07 23:54:21","7529630","1","","1451110","","2014-04-07 23:54:21","2011-09-23 10:18:46",""
"43608055","OSCP requests randomly appear in webpagetest.org results","<p>When testing website performance with webpagetest.org, eventually some tests contain requests that should not have been requested by the selected browser. </p>

<p>Example:
<a href=""https://www.webpagetest.org/result/170425_AH_NP7/1/details/#waterfall_view_step1"" rel=""nofollow noreferrer"">https://www.webpagetest.org/result/170425_AH_NP7/1/details/#waterfall_view_step1</a></p>

<p>Although I run a test with Google Chrome, the second request is done by User-Agent: Microsoft-CryptoAPI/6.1
to Host: gm.symcd.com</p>

<p>Re-running the same tests usually results in a run without any of those requests.</p>

<p>This happens on www.webpagetest.org as well as on our company's local WPT installation on a windows host.</p>

<p>The User-Agent first made me suspect Windows Update Agent as a source, but the host gm.symcd.com seems to belong to Symantec.</p>

<p>Has anyone experienced the same behaviour?
What is the best thing to do to prevent these undesired requests?</p>
","<p>Those, seemingly random, requests are OSCP lookups (<a href=""https://www.ietf.org/rfc/rfc2560.txt"" rel=""nofollow noreferrer"">RFC 2560: Online Certificate Status Protocol</a>) to ensure SSL certificates are still valid and have not been revoked.</p>

<p>OSCP lookups by the client are only necessary unless the server does OSCP Stapling (<a href=""https://www.ietf.org/rfc/rfc6961.txt"" rel=""nofollow noreferrer"">RFC 6961: Multiple Certificate Status Request Extension</a>), which means it provides a signed authoritative OSCP response alongside the SSL certificate chain.</p>

<p>So, as Patrick Meenan pointed out, ""the performance fix to make them not happen is to enable OCSP Stapling on the web server.""</p>

<p>If the server does not staple the OSCP data, the client should make an OSCP request, unless it already has a valid cached response from a recent OSCP request. On a Windows client, the OSCP request will submitted via the operating system's CryptoAPI unless there is already a valid cached response.</p>

<p>To ensure repeatable web page test results, tests should require the certificate cache to be empty at the start of a test, which on webpagetest.org is configured in Advanced Settings -> Advanced -> ""Clear SSL Certificate Caches"".</p>
","216","<ssl><tls1.2><cryptoapi><webpagetest><oscp5>","1","0","2","2017-05-04 09:45:54","43779259","0","","5069530","","2017-05-04 09:41:06","2017-04-25 10:24:27",""
"43608055","OSCP requests randomly appear in webpagetest.org results","<p>When testing website performance with webpagetest.org, eventually some tests contain requests that should not have been requested by the selected browser. </p>

<p>Example:
<a href=""https://www.webpagetest.org/result/170425_AH_NP7/1/details/#waterfall_view_step1"" rel=""nofollow noreferrer"">https://www.webpagetest.org/result/170425_AH_NP7/1/details/#waterfall_view_step1</a></p>

<p>Although I run a test with Google Chrome, the second request is done by User-Agent: Microsoft-CryptoAPI/6.1
to Host: gm.symcd.com</p>

<p>Re-running the same tests usually results in a run without any of those requests.</p>

<p>This happens on www.webpagetest.org as well as on our company's local WPT installation on a windows host.</p>

<p>The User-Agent first made me suspect Windows Update Agent as a source, but the host gm.symcd.com seems to belong to Symantec.</p>

<p>Has anyone experienced the same behaviour?
What is the best thing to do to prevent these undesired requests?</p>
","<p>OCSP is used to check the revocation of the certificate. The answer can be cached a few days.</p>

<p>If you want to avoid the OCSP request to the CA, <strong>your can active ""OCSP stapling"" on your server</strong>: your server will regularly do the request to the CA and serve the signed answer during the client handshake: is will save time for all your visitors.</p>
","216","<ssl><tls1.2><cryptoapi><webpagetest><oscp5>","1","1","2","2017-05-04 09:45:54","43779259","0","","5069530","","2017-05-04 09:41:06","2017-04-25 10:24:27",""
"3390499","SUBMIT certificate request - outside domain","<p>I need to submit a PKCS#10 certificate request to a certificate authority who is outside my domain. <a href=""http://msdn.microsoft.com/en-us/library/ms867026.aspx#certenroll_topic4"" rel=""nofollow noreferrer"">This article in MSDN</a> shows a way to submit certificate requests within a network using <code>ICertRequest2</code> COM object.</p>

<pre><code>hr = CertRequest-&gt;Submit( CR_IN_ENCODEANY | CR_IN_FORMATANY, RequestStr,
                          AttributesStr, CAName, &amp;Disp );
</code></pre>

<p>where</p>

<pre><code>BSTR CAName = SysAllocString( L""COMPUTERNAME\\CA Name"" );
</code></pre>

<p>My question is how do i submit my request progrmatically from the client who is outside the Domain.</p>

<p>I don't want to use the Microsoft web enrollment pages, as this needs to be a automated process.</p>

<p>My CA is 2003 Enterprise and client is XP SP3.</p>

<p>Any ideas please?</p>

<p>Thanks</p>
","<p>In general, this can be done in few ways</p>

<ol>
<li><p>Manually with some audit procedures between the CA and the participating entity/user</p></li>
<li><p>Semi automatically using the MS windows provided web URL/enrolment page, certsrv</p></li>
<li><p>Write your own solution, say, a web service to liaise between user and the CA</p></li>
</ol>
","215","<encryption><certificate><windows-server-2003><cryptoapi>","0","0","1","2010-10-27 10:53:59","4032417","2","","119535","","2010-08-02 21:16:30","2010-08-02 18:09:14",""
"27609128","Testing MS-CAPI CSP, signature fails even with WinDbg kernel debugging","<p>Trying to test a new CSP under Win 7.  Set the boot config to allow kernel debug, run <code>WndDbg</code> and select file:kernel debug and set to local.  Attempting to use signtool with my new CSP still results in signature failure check.  Environment is:</p>

<pre>
OS Name:                   Microsoft Windows 7 Home Premium
OS Version:                6.1.7601 Service Pack 1 Build 7601
OS Manufacturer:           Microsoft Corporation
OS Configuration:          Standalone Workstation
OS Build Type:             Multiprocessor Free

System Model:              Dell System Inspiron N7110
System Type:               x64-based PC
Processor(s):              1 Processor(s) Installed.
                           [01]: Intel64 Family 6 Model 42 Stepping 7 GenuineIntel ~2501 Mhz
BIOS Version:              Dell Inc.          A09, 11/18/2011
Windows Directory:         C:\Windows
System Directory:          C:\Windows\system32
</pre>

<hr>

<p>Any thoughts on why the presence of the kernel debugger is not preventing the signature check on the test CSP?  Does that setup only work in a remote-debug environment?</p>
","<p>You'll need a remote debugger to disable the signature check.</p>

<p>There are <a href=""https://msdn.microsoft.com/en-us/library/windows/hardware/hh439378%28v=vs.85%29.aspx"" rel=""nofollow"">various mechanisms such as 1394 (FireWire) or Serial Cable</a> by which you can can connect the second computer for remote debugging.</p>

<p>If your CSP can run in a VM, then that would be an option too if you just have the one machine.</p>
","211","<windows><windbg><cryptoapi><mscapi>","2","0","1","2016-02-19 10:24:35","","0","","5348281","","2016-02-19 10:24:35","2014-12-22 19:23:54",""
"45096601","Implementing CPAcquireContext in custom CSP","<p>We want to develop custom Cryptographic Service Provider (CSP). For this we are referring following link</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380245%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa380245%28v=vs.85%29.aspx</a></p>

<p>From the documents, we understood that following cryptographic functions need to be implemented for custom CSP.</p>

<ol>
<li>CPAcquireContext</li>
<li>CPCreateHAsh</li>
<li>CPDecrypt etc. as mentioned in the following  link</li>
</ol>

<p><a href=""https://msdn.microsoft.com/en-us/library/ms925441.aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/ms925441.aspx</a></p>

<p>According to this link, CPAcquireContext function takes following arguments</p>

<pre><code>BOOL CPAcquireContext(

  _Out_  HCRYPTPROV *phProv,

  _In_   CHAR *pszContainer,

  _In_   DWORD dwFlags,

  _In_   PVTableProvStruc pVTable

);
</code></pre>

<p>but we did not find any further information(like what need to do with these arguments and how to fill HCRYPTPROV structure) about the implementation of CPAcquireContext or any other entry points mentioned in the link.</p>

<p>Is there any other document which explain this portion in detail?  can anyone  give further assistance in developing these functions.</p>
","","210","<smartcard><cryptoapi><mscapi>","3","","0","2017-09-04 14:25:12","","1","0","5730444","","2017-09-04 14:25:12","2017-07-14 06:57:29",""
"18661966","CryptAcquireContext ERROR_INVALID_PARAMETER on NT Service","<p>I have a Windows service written in C++, which uses:</p>

<pre><code>CryptAcquireContext( &amp;hCryptProv, NULL, NULL, PROV_RSA_FULL,0);
</code></pre>

<p>I keep getting <strong>ERROR_INVALID_PARAMETER</strong> although the same line of code works perfectly if i use it in a user mode application.</p>

<p>Note: I've already tried with no luck:</p>

<pre><code>CRYPT_MACHINE_KEYSET | CRYPT_SILENT
</code></pre>
","","209","<c++><winapi><service><cryptoapi>","1","","0","2013-09-06 16:13:53","","2","","","","","2013-09-06 16:04:01",""
"8259645","How does this code C# translate in C++ using Windows Cryptorgraphic API?","<p>How would you translate this C# in C++ using the Windows Cryptographic API? I'm a newbie in this field and that API looks quite complex...</p>

<pre><code>Rijndael aes = Rijndael.Create();
aes.Padding = PaddingMode.None;
MemoryStream ms = new MemoryStream(cryptedText);
byte[] decryptedText = new byte[0x10];

using (CryptoStream decrypt = new CryptoStream(ms, aes.CreateDecryptor(decryptKey, new byte[0x10]), CryptoStreamMode.Read))
{
    decrypt.Read(decryptedText, 0, 0x10);
}
</code></pre>

<p>Thanks in advance...</p>
","<p>You can use the managed version in C++ as seen on this MSDN page, look for the Example section </p>

<p><a href=""http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx#Y2371"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx#Y2371</a></p>
","208","<c#><windows><winapi><cryptoapi>","0","0","1","2011-11-24 17:21:38","","0","0","","","","2011-11-24 15:53:55",""
"46081741","STATUS_INVALID_PARAMETER error import diffie hellman public key using BCryptImportKeyPair","<p>I am trying to add a public key into diffie Hellman implementation of Bcrypt. 
<a href=""https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/Security/DhOakleyGroup1/cpp/DhOakleyGroup1.cpp"" rel=""nofollow noreferrer"">example</a> suggested to create and export a public key. In my case I already got the public key from the client. I am trying to use that public key to generate shared session key. I get STATUS_INVALID_PARAMETER when i try to use BCryptImportKeyPair. 
I created PBCRYPT_DH_KEY_BLOB and added the values manually. 
Is there any other way to do this? an example of importing public key into BCrypt from string would be appreciated. </p>

<p>Thanks in Advance. Please check the code below.  </p>

<pre><code>KeyLength = 1024;//bits
const int sz = 1024;
char * shared_public_key = ""48DE15D8E46B857B387E315D518B7D9EDDA1FCA6661CFC9C066B3A352E8644A30BFBB7F84C93818F67B7037235D11A5B0F31E15BCB344C2A7C13E339ED98939CF3F092E64C0DEA28A150404432E3B7077DE3E4D40E421EA88FFAF4D7AD53851912389674B24C80E5FD05D1C60344535159E7A4CAF9F9DCAF712C2A41EF524632"";
char * prime      = ""CBBD1F895B751A803674B4CF6178DAFF87E3AADD017B96CA0D536215091AC55C0D777ADB6206581E7681C5059BEFF7990E4B3DD074266B608800CF7110BE99B861D189A82A26D569CAA2F314E8E79838AEE8DA96380BDFA55B34CA43866B24C0A822947E669C9AA037A8FA765F637663AB4103A9251C70000A689796CE42A2A3"";
BYTE OakleyGroup1P[sz /8];
int fld_sz = sz / 8;
string s_prime(prime, fld_sz*2);
transform(s_prime.begin(), s_prime.end(), s_prime.begin(), ::tolower);
string res = """";
for (int i = 0; i &lt; s_prime.size(); i += 2) {
  res += s_prime.substr(i, 2);
  res += "" "";
}
std::istringstream hex_chars_stream(res);

unsigned int c;
int i = 0;
while (hex_chars_stream &gt;&gt; std::hex &gt;&gt; c)
{
  OakleyGroup1P[i++] = c;
}
cout &lt;&lt; ""size of OakleyGroup1P :"" &lt;&lt; i &lt;&lt; endl;
/*for (unsigned char x : OakleyGroup1P) {
  cout &lt;&lt; ((x &gt;&gt; 4) &amp; 0x0F) &lt;&lt; "" "" &lt;&lt; (x &amp; 0x0F) &lt;&lt; endl;
}*/

PBYTE PubBlobA2 = new BYTE[sz/8];
string s_shared(shared_public_key, fld_sz * 2);
transform(s_shared.begin(), s_shared.end(), s_shared.begin(), ::tolower);
string temp = """";
for (int i = 0; i &lt; s_shared.size(); i += 2) {
  temp += s_shared.substr(i, 2);
  temp += "" "";
}
std::istringstream hex_chars_stream2(temp);

i = 0;
while (hex_chars_stream2 &gt;&gt; std::hex &gt;&gt; c)
{
  PubBlobA2[i++] = c;
}
cout &lt;&lt; ""size of PubBlobA2 :"" &lt;&lt; i &lt;&lt; endl;
for (int j = 0; j &lt; i; j++) {
  cout &lt;&lt; ((*(PubBlobA2 + j) &gt;&gt; 4) &amp; 0x0F) &lt;&lt; "" "" &lt;&lt; (*(PubBlobA2 + j) &amp; 0x0F) &lt;&lt; endl;
}

//
// Construct the DH parameter blob. this is the only supported
// method for DH in CNG.
//
// Calculate size of param blob and allocate memory

DhParamBlobLength = sizeof(BCRYPT_DH_PARAMETER_HEADER) + 
                sizeof(OakleyGroup1G) + 
                sizeof(OakleyGroup1P);

DhParamBlob = (PBYTE)HeapAlloc (
                                    GetProcessHeap (), 
                                    0, 
                                    DhParamBlobLength);
if( NULL == DhParamBlob )
{
    Status = STATUS_NO_MEMORY;
    ReportError(Status);
    goto cleanup;
}

DhParamHdrPointer  = (BCRYPT_DH_PARAMETER_HEADER *)DhParamBlob;

//
// Set header properties on param blob
//

DhParamHdrPointer-&gt;cbLength      = DhParamBlobLength;
DhParamHdrPointer-&gt;cbKeyLength   = KeyLength/8;//bytes
DhParamHdrPointer-&gt;dwMagic       = BCRYPT_DH_PARAMETERS_MAGIC;

//
// Set prime
//

memcpy(DhParamBlob + sizeof(BCRYPT_DH_PARAMETER_HEADER),
        OakleyGroup1P,
        sizeof(OakleyGroup1P));

//
// Set generator
//

memcpy(DhParamBlob + sizeof(BCRYPT_DH_PARAMETER_HEADER) + sizeof(OakleyGroup1P),
       OakleyGroup1G,
       sizeof(OakleyGroup1G));


//
// Open alg provider handle
//

Status = BCryptOpenAlgorithmProvider(
                                    &amp;ExchAlgHandleB, 
                                    BCRYPT_DH_ALGORITHM, 
                                    NULL, 
                                    0);
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}



//
// B generates a private key
// 

Status = BCryptGenerateKeyPair(
                                    ExchAlgHandleB,             // Algorithm handle
                                    &amp;PrivKeyHandleB,            // Key handle - will be created
                                    KeyLength,                  // Length of the key - in bits
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

Status = BCryptSetProperty(
                                    PrivKeyHandleB,
                                    BCRYPT_DH_PARAMETERS,
                                    DhParamBlob,
                                    DhParamBlobLength,
                                    0);
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

Status = BCryptFinalizeKeyPair(
                                    PrivKeyHandleB,             // Key handle
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

//
// B exports DH public key
//

Status = BCryptExportKey(
                                    PrivKeyHandleB,             // Handle of the key to export
                                    NULL,                       // Handle of the key used to wrap the exported key
                                    BCRYPT_DH_PUBLIC_BLOB,      // Blob type (null terminated unicode string)
                                    NULL,                       // Buffer that recieves the key blob
                                    0,                          // Buffer length (in bytes)
                                    &amp;PubBlobLengthB,            // Number of bytes copied to the buffer
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}

PubBlobB = (PBYTE)HeapAlloc (
                                    GetProcessHeap (), 
                                    0, 
                                    PubBlobLengthB);
if( NULL == PubBlobB )
{
    Status = STATUS_NO_MEMORY;
    ReportError(Status);
    goto cleanup;
}


Status = BCryptExportKey(
                                    PrivKeyHandleB,             // Handle of the key to export
                                    NULL,                       // Handle of the key used to wrap the exported key
                                    BCRYPT_DH_PUBLIC_BLOB,      // Blob type (null terminated unicode string)
                                    PubBlobB,                   // Buffer that recieves the key blob
                                    PubBlobLengthB,             // Buffer length (in bytes)
                                    &amp;PubBlobLengthB,            // Number of bytes copied to the buffer
                                    0);                         // Flags
if( !NT_SUCCESS(Status) )
{
    ReportError(Status);
    goto cleanup;
}


//
// Build KDF parameter list
//

//specify hash algorithm, SHA1 if null

//specify secret to append
BufferArray[0].BufferType = KDF_TLS_PRF_SEED;
BufferArray[0].cbBuffer = sizeof(rgbrgbTlsSeed);
BufferArray[0].pvBuffer = (PVOID)rgbrgbTlsSeed;

//specify secret to prepend
BufferArray[1].BufferType = KDF_TLS_PRF_LABEL;
BufferArray[1].cbBuffer = (DWORD)((wcslen(Label) + 1) * sizeof(WCHAR));
BufferArray[1].pvBuffer = (PVOID)Label;

ParameterList.cBuffers  = 2;
ParameterList.pBuffers  = BufferArray;
ParameterList.ulVersion = BCRYPTBUFFER_VERSION;

//
// B imports A's public key
//
// dh public key blob structure
PBCRYPT_DH_KEY_BLOB p_dh_pub_key_blob = (PBCRYPT_DH_KEY_BLOB)HeapAlloc(
  GetProcessHeap(),
  0,
  sizeof(BCRYPT_DH_KEY_BLOB));
p_dh_pub_key_blob-&gt;dwMagic = BCRYPT_DH_PUBLIC_MAGIC;
p_dh_pub_key_blob-&gt;cbKey = sz/8;
DWORD df_pub_key_data_length = sizeof(BCRYPT_DH_KEY_BLOB) + sz / 8;

PBYTE p_df_pub_key_data = (PBYTE)HeapAlloc(
  GetProcessHeap(),
  0,
  df_pub_key_data_length);
memcpy(p_df_pub_key_data,
  p_dh_pub_key_blob,
  sizeof(BCRYPT_DH_KEY_BLOB));
memcpy(p_df_pub_key_data + sizeof(BCRYPT_DH_KEY_BLOB),
  PubBlobA2,
  sz/8);
Status = BCryptImportKeyPair(
  ExchAlgHandleB,             // Alg handle
  NULL,                       // Parameter not used
  BCRYPT_DH_PUBLIC_BLOB,      // Blob type (Null terminated unicode string)
  &amp;PubKeyHandleB,             // Key handle that will be recieved
  p_df_pub_key_data,            // Buffer than points to the key blob
  df_pub_key_data_length,     // Buffer length in bytes
  0);    
</code></pre>
","","204","<c++><winapi><cryptoapi><cng><wincrypt>","1","","0","2017-09-07 15:01:09","","3","","1294545","","2017-09-07 15:01:09","2017-09-06 18:08:31",""
"53953631","Translate Windows RC4 CryptDeriveKey to PHP for openssl","<p>This is the second component of the legacy system translation we’ve been trying to do.  We have managed to match exactly the initial binary password/key that Windows ::CryptHashData generates.</p>

<p>That password/key is passed to ::CryptDeriveKey where it performs a number of steps to create the final key to be used by ::CryptEncrypt.  My research has led me to the CryptDeriveKey documentation where it clearly describes the steps required to derive the key for ::CryptEncrypt but so far I haven’t been able to get it to decrypt the file on the PHP side. 
<a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptderivekey</a></p>

<p>Based on the ::CryptDeriveKey documentation there may be some additional undocumented steps for our specific legacy key size that may not be well understood.  The current Windows ::CryptDeriveKey is set for ZERO SALT by default which is apparently different from NO_SALT somehow.  See salt value functionality here:
<a href=""https://docs.microsoft.com/en-us/windows/desktop/SecCrypto/salt-value-functionality"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/desktop/SecCrypto/salt-value-functionality</a></p>

<p>The parameters on the CryptAPI for our legacy system are as follows:</p>

<p>Provider type:      PROV_RSA_FULL</p>

<p>Provider name:  MS_DEF_PROV</p>

<p>Algo ID     CALG_RC4        </p>

<p>Description     RC4 stream encryption algorithm</p>

<p>Key length:         40 bits.</p>

<p>Salt length:        88 bits.   ZERO_SALT</p>

<p>Special Note:       A 40-bit symmetric key with zero-value salt, however, is not equivalent to a 40-bit symmetric key without salt. For interoperability, keys must be created without salt. This problem results from a default condition that occurs only with keys of exactly 40 bits.</p>

<p>I’m not looking to export the key, but reproduce the process that creates the final encryption key that is passed to ::CryptEncrypt for the RC4 encryption algorithm and have it work with openssl_decrypt.</p>

<p>Here is the current windows code that’s working fine for encrypt.</p>

<pre><code>try {
    BOOL bSuccess;
    bSuccess = ::CryptAcquireContextA(&amp;hCryptProv, 
                                      CE_CRYPTCONTEXT, 
                                      MS_DEF_PROV_A, 
                                      PROV_RSA_FULL, 
                                      CRYPT_MACHINE_KEYSET);

    ::CryptCreateHash(hCryptProv, 
                      CALG_MD5, 
                      0, 
                      0, 
                      &amp;hSaveHash);

    ::CryptHashData(hSaveHash, 
                    baKeyRandom, 
                    (DWORD)sizeof(baKeyRandom), 
                    0);

    ::CryptHashData(hSaveHash, 
                    (LPBYTE)T2CW(pszSecret), 
                    (DWORD)_tcslen(pszSecret) * sizeof(WCHAR), 
                     0);

    ::CryptDeriveKey(hCryptProv, 
                     CALG_RC4, 
                     hSaveHash, 
                     0, 
                     &amp;hCryptKey);

    // Now Encrypt the value
    BYTE * pData = NULL;
    DWORD dwSize = (DWORD)_tcslen(pszToEncrypt) * sizeof(WCHAR); 
    // will be a wide str
    DWORD dwReqdSize = dwSize;

    ::CryptEncrypt(hCryptKey, 
                   NULL, 
                   TRUE, 
                   0, 
                   (LPBYTE)NULL, 
                   &amp;dwReqdSize, 0);

    dwReqdSize = max(dwReqdSize, dwSize);

    pData = new BYTE[dwReqdSize];

    memcpy(pData, T2CW(pszToEncrypt), dwSize);

    if (!::CryptEncrypt(hCryptKey, 
                        NULL, 
                        TRUE, 
                        0, 
                        pData, 
                        &amp;dwSize, 
                        dwReqdSize)) {

            printf(""%l\n"", hCryptKey);
            printf(""error during CryptEncrypt\n"");
            }

    if (*pbstrEncrypted)
    ::SysFreeString(*pbstrEncrypted);
    *pbstrEncrypted = ::SysAllocStringByteLen((LPCSTR)pData, dwSize);
    delete[] pData;
    hr = S_OK;
}
</code></pre>

<p>Here is the PHP code that tries to replicate the ::CryptDeriveKey function as described in the documentation.</p>

<p>Let n be the required derived key length, in bytes. The derived key is the first n bytes of the hash value after the hash computation has been completed by CryptDeriveKey. If the hash is not a member of the SHA-2 family and the required key is for either 3DES or AES, the key is derived as follows:</p>

<ol>
<li><p>Form a 64-byte buffer by repeating the constant 0x36 64 times. Let k be the length of the hash value that is represented by the input parameter hBaseData. Set the first k bytes of the buffer to the result of an XOR operation of the first k bytes of the buffer with the hash value that is represented by the input parameter hBaseData.</p></li>
<li><p>Form a 64-byte buffer by repeating the constant 0x5C 64 times. Set the first k bytes of the buffer to the result of an XORoperation of the first k bytes of the buffer with the hash value that is represented by the input parameter hBaseData.</p></li>
<li><p>Hash the result of step 1 by using the same hash algorithm as that used to compute the hash value that is represented by the hBaseData parameter.</p></li>
<li><p>Hash the result of step 2 by using the same hash algorithm as that used to compute the hash value that is represented by the hBaseData parameter.</p></li>
<li><p>Concatenate the result of step 3 with the result of step 4.</p></li>
<li>Use the first n bytes of the result of step 5 as the derived key.</li>
</ol>

<p>PHP Version of ::CryptDeriveKey.</p>

<pre><code>function cryptoDeriveKey($key){

    //Put the hash key into an array
    $hashKey1 = str_split($key,2);
    $count = count($hashKey1);
    $hashKeyInt = array();

    for ($i=0; $i&lt;$count; $i++){
        $hashKeyInt[$i] = hexdec($hashKey1[$i]);
    }
    $hashKey = $hashKeyInt;

    //Let n be the required derived key length, in bytes.  CALG_RC4 = 40 bits key or 88 salt bytes
    $n = 40/8;

    //Let k be the length of the hash value that is represented by the input parameter hBaseData
    $k = 16;

    //Step 1 Form a 64-byte buffer by repeating the constant 0x36 64 times   
    $arraya = array_fill(0, 64, 0x36);

    //Set the first k bytes of the buffer to the result of an XOR operation of the first k bytes of the buffer with the hash value 
    for ($i=0; $i&lt;$k; $i++){
        $arraya[$i] = $arraya[$i] ^ $hashKey[$i];
    }

    //Hash the result of step 1 by using the same hash algorithm as hBaseData
    $arrayPacka = pack('c*', ...$arraya);
    $hashArraya = md5($arrayPacka);

    //Put the hash string back into the array
    $hashKeyArraya = str_split($hashArraya,2);
    $count = count($hashKeyArraya);
    $hashKeyInta = array();
    for ($i=0; $i&lt;$count; $i++){
        $hashKeyInta[$i] = hexdec($hashKeyArraya[$i]);
    }

    //Step 2 Form a 64-byte buffer by repeating the constant 0x5C 64 times. 
    $arrayb = array_fill(0, 64, 0x5C);

    //Set the first k bytes of the buffer to the result of an XOR operation of the first k bytes of the buffer with the hash value
    for ($i=0; $i&lt;$k; $i++){
        $arrayb[$i] =  $arrayb[$i] ^ $hashKey[$i];
    }

    //Hash the result of step 2 by using the same hash algorithm as hBaseData    
    $arrayPackb = pack('c*', ...$arrayb);
    $hashArrayb = md5($arrayPackb);

    //Put the hash string back into the array
    $hashKeyArrayb = str_split($hashArrayb,2);
    $count = count($hashKeyArrayb);
    $hashKeyIntb = array();
    for ($i=0; $i&lt;$count; $i++){
        $hashKeyIntb[$i] = hexdec($hashKeyArrayb[$i]);
    }

    //Concatenate the result of step 3 with the result of step 4.
    $combined = array_merge($hashKeyInta, $hashKeyIntb);

    //Use the first n bytes of the result of step 5 as the derived key.
    $finalKey = array();
    for ($i=0; $i &lt;$n; $i++){
        $finalKey[$i] =  $combined[$i];
    }
    $key = $finalKey;

    return $key;
}
</code></pre>

<p>PHP Decrypt Function</p>

<pre><code>function decryptRC4($encrypted, $key){
    $opts = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;
    $cypher = ‘rc4-40’;
    $decrypted = openssl_decrypt($encrypted, $cypher, $key, $opts);
    return $decrypted; 
}
</code></pre>

<p>So here are the big questions:</p>

<p>Has anyone been able to successfully replicate ::CryptDeriveKey with RC4 on another system?  </p>

<p>Does anyone know what is missing from the PHP script we created that prevents it from creating the same key and decrypt the Windows CryptoAPI encrypted file with openssl_decrypt?  </p>

<p>Where and how do we create the 88 bit zero-salt that is required for the 40bit key?</p>

<p>What are the correct openssl_decrypt parameters that would accept this key and decrypt what was generated by ::CryptDeriveKey? </p>

<p>Yes, we know this isn’t secure and its not being used for passwords or PII.   We would like to move away from this old and insecure method, but we need take this interim step of translating the original encryption to PHP first for interoperability with the existing deployed systems.  Any help or guidance would be appreciated.</p>
","<p>Just in case anyone else wanders down this path here are the answers to all the questions above.</p>

<p>You can replicate ::CryptDeriveKey on PHP using openssl but there are some prerequisites that have to be met on the windows side first.  </p>

<p>CryptDeriveKey MUST be set to CRYPT_NO_SALT as follows:</p>

<pre><code>::CrypeDeriveKey(hCryptProv, CALG_RC4, hSaveHash, CRYPT_NO_SALT, &amp;hCryptKey)
</code></pre>

<p>This will allow you to create a key from your hash and generate a matching key in PHP that will work on openssl.  If you don't set any salt parameters you will get a key that is created with an unknown proprietary salt algorithm that cant be matched on another system. </p>

<p>The reason that you have to set CRYPT_NO_SALT is because both the CryptAPI and openssl have proprietary salt algorithms and there is no way to get them to match.  So you should do your salting separately.  There are more details about this salt value functionality here: <a href=""https://docs.microsoft.com/en-us/windows/desktop/SecCrypto/salt-value-functionality"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/desktop/SecCrypto/salt-value-functionality</a></p>

<p>Here is what the PHP script needs to look like to create an equivalent passkey for for openssl to use.</p>

<pre><code>&lt;?php
$random = pack('c*', 87,194,...........);
$origSecret = 'ASCII STRING OF CHARACTERS AS PASSWORD'; 

//Need conversion to match format of Windows CString or wchar_t*
//Windows will probably be UTF-16LE and LAMP will be UTF-8
$secret = iconv('UTF-8','UTF-16LE', $origSecret);

//Create hash key from Random and Secret
//This is basically a hash and salt process.
$hash = hash_init(""md5"");
hash_update($hash, $random);
hash_update($hash, $secret);
$key = hash_final($hash);

$key = cryptoDeriveKey($key);
//Convert the key hex array to a hex string for openssl_decrypt
$count = count($key);
$maxchars = 2;
for ($i=0; $i&lt;$count; $i++){
    $key .= str_pad(dechex($key[$i]), $maxchars, ""0"", STR_PAD_LEFT);
}
</code></pre>

<p>IMPORTANT:  OpenSSL expects the key to be the raw hex values that are derived from the hash, unfortunately openssl_decrypt() wants the same value as a string or password.  Therefor you have to do a hex to string conversion at this point.  There is a great write up here on why you have to do this.
<a href=""http://php.net/manual/en/function.openssl-encrypt.php"" rel=""nofollow noreferrer"">http://php.net/manual/en/function.openssl-encrypt.php</a></p>

<pre><code>$opts = OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING;
//Convert key hex string to a string for openssl_decrypt
//Leave it as it is for openssl command line.
$key = hexToStr($key);
$cipher = 'rc4-40';
$encrypted = “the data you want to encrypt or decrypt”;
$decrypted = openssl_decrypt($encrypted, $cipher, $key, $opts);  

echo $decrypted;  //This is the final information you’re looking for


function cryptoDeriveKey($key){
//convert the key into hex byte array as int
    $hashKey1 = str_split($key,2);
    $count = count($hashKey1);
    $hashKeyInt = array();
    for ($i=0; $i&lt;$count; $i++){
        $hashKeyInt[$i] = hexdec($hashKey1[$i]);
    }
    $hashKey = $hashKeyInt;
    //Let n be the required derived key length, in bytes.  CALG_RC4 = 40 bits key with 88 salt bits
    $n = 40/8;
    //Chop the key down to the first 40 bits or 5 bytes.
    $finalKey = array();
    for ($i=0; $i &lt;$n; $i++){
        $finalKey[$i] =  $hashKey[$i];
    }
    return $finalKey;
}


function hexToStr($hex){
    $string='';
    for ($i=0; $i &lt; strlen($hex)-1; $i+=2){
        $string .= chr(hexdec($hex[$i].$hex[$i+1]));
    }
return $string;
}
?&gt;
</code></pre>

<p>If you’re having trouble getting the correct values after using the code above you can try exporting your key value from CryptoAPI and testing it with openssl command line.</p>

<p>First you have to set CryptDeriveKey to allow the key to be exported with CRYPT_EXPORTABLE and CRYPT_NO_SALT</p>

<pre><code>::CrypeDeriveKey(hCryptProv, CALG_RC4, hSaveHash, CRYPT_EXPORTABLE | CRYPT_NO_SALT, &amp;hCryptKey)
</code></pre>

<p>If you want to know how to display a PLAINTEXTKEYBLOB from the exported key follow this link.
<a href=""https://docs.microsoft.com/en-us/windows/desktop/seccrypto/example-c-program--importing-a-plaintext-key"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/desktop/seccrypto/example-c-program--importing-a-plaintext-key</a></p>

<p>Here is an example exported key blob
0x08 0x02 0x00 0x00 0x01 0x68 0x00 0x00 0x05 0x00 0x00 0x00 0xAA 0xBB 0xCC 0xDD 0xEE   </p>

<p>0x08 0x02 0x00 0x00 0x01 0x68 0x00 0x00  //BLOB header matches almost exactly
0x05 0x00 0x00 0x00                      //Key length in bytes is correct 5 bytes
0xAA 0xBB 0xCC 0xDD 0xEE                 //First 5 bytes of our created hash key!!</p>

<p>Use your exported key value from the BLOB as the Hex Key Value in the openssl enc command below.</p>

<pre><code>openssl enc -d -rc4-40 -in testFile-NO_SALT-enc.txt -out testFile-NO_SALT-dec.txt -K ""Hex Key Value"" -nosalt -nopad
</code></pre>

<p>This will decrypt the file that was encrypted on the Windows machine using CryptEncrypt.</p>

<p>As you can see, when you set the CryptDeriveKey to CRYPT_NO_SALT all you need for the openssl password or key is the first “keylength” bits of your CryptHashData password.  Simple enough to say but a real pain to get to.  Good luck and hope this helps someone else with legacy Windows translation issues.</p>
","198","<php><hash><salt><cryptoapi><php-openssl>","2","0","1","2018-12-30 04:04:08","53975190","0","1","","","","2018-12-28 04:17:57",""
"22052522","RSA Crypto Service Container Private Key goes out of sync","<p>In a client/server model
We have a RSACryptoServiceProvider key created using a well known ""container name"" at the startup code, and set a rule on it to Allow Generic Read, and persist the public key into a database. The clients connecting to the server, send sensitive information encrypted with the public key and the server decrypts it using the private key.</p>

<p>However, over time, we are observing that the public key in the crypto store (it's a machine level crypto store at %ProgramData%\Microsoft\Crypto\RSA\Machine Keys goes out of sync with the stored public key in the database) and our clients stop communicating with the server.</p>

<p>Are there any possible reasons as to how this happens ? Is there a way we can detect it when this happens ?</p>
","","198","<c#><.net><cryptoapi><rsacryptoserviceprovider>","0","","0","2014-02-26 20:26:53","","2","","","","","2014-02-26 20:26:53",""
"33320528","Using CryptoAPI do encrypt Winsock communication","<p>I came across the CryptoAPI from the Microsoft MSDN to encrypt communication between my Clients and my Server for a basic Networking Application. (Just to learn about securing network communications).</p>

<p>I decide to use AES 256bit cypher in CBC for packets encryption and RSA 2048bit for sending / receiving the AES symmetric key.</p>

<p>I have read many examples, even succeed writing few snippets using this lib such as:</p>

<ul>
<li>Encrypting / Decrypting Unicode String using AES</li>
<li>Encrypting / Decrypting Streams using AES</li>
</ul>

<p>those two snippets works fine and are quite easy to write.</p>

<p>Now I want to Encrypt / Decrypt on the fly any static bytes array (which comes from my server or client) but I can't get it work for some reason which are probably really stupid.</p>

<p>I'm not even sure if using CryptoAPI is the way to go for such needs.</p>

<p>This is my attempt which fails with the error : 234 (ERROR_MORE_DATA)</p>

<pre><code>function AES(const data : Pointer; var dest : TBytesArray; bufferSize : DWORD; Key : String; doCrypt : Boolean) : Boolean;
var AES  : HCRYPTPROV;
    hKEY : HCRYPTKEY;
begin
    CryptAcquireContext(@AES, nil, nil, PROV_RSA_AES, 0);
    try
        hKey := AES_DeriveKeyFromPassword(AES, key);
        try
            SetLength(dest, bufferSize);
            Move(data^, dest[0], bufferSize);

            if NOT CryptEncrypt(hKey, 0, true, 0, @dest[0], @bufferSize, bufferSize) then showmessage(inttostr(getlasterror()));
        finally
            CryptDestroyKey(hKey);
        end;
    finally
        CryptReleaseContext(AES, 0);
    end;
end;
</code></pre>

<p>I'm sure I'm doing something wrong somewhere, but I don't understand why.</p>

<p>When I change the Final to false the error doesn't came up but I don't know why I would need to use this flag (else than true) since I just want to encrypt packets by packets. </p>

<p>Notice:</p>

<p>The data parameter could contain static byte array (Network arrival / sent buffers)</p>

<p>Generally : buffer : array[0..1023] of byte </p>

<p>I copy this static bytes array to a dynamic one which is the destination one to be encrypted / decrypted.</p>

<p>So the exact question is:</p>

<p>How could I encrypt / decrypt on the fly data for Winsock communication without using third part components / packages just the CryptoAPI?</p>
","","194","<delphi><encryption><aes><cryptoapi>","0","","0","2015-10-24 16:32:00","","2","","1816580","","2015-10-24 16:32:00","2015-10-24 16:30:55",""
"15818420","Getting same ciphertext every time from the same plaintext","<p>I am using Microsoft CryptoAPI to encrypt the password. Using 3DES from Microsoft Enhanced Cryptographic Provider. What I noticed is that I seem to be getting exactly the same ciphertext from the same plaintext every time. As far as I know this should not be happening in CBC mode, which CALG_3DES is operating in according to MSDN. I know 3DES is old and I should be using AES instead but this is a legacy code and I would like to avoid changing the algorithm. Am I doing something wrong? I think I might need to provide IV but I do not see how it can be done for 3DES using CryptoAPI. None of MSDN samples show it. Below is the redacted code snippet that shows the sequence of CryptoAPI calls.</p>

<p>Here is my code so far:</p>

<pre><code>CryptAcquireContext(&amp;hProvider, NULL,  MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);

/// key acquired by some means and stored in pszTempData

CryptCreateHash( hProvider, CALG_SHA_256, 0, 0, &amp;hHash );

CryptHashData( hHash, (BYTE *)pszTempData, wcslen(pszTempData), 0 );

CryptDeriveKey( hProvider, CALG_3DES, hHash,  CRYPT_EXPORTABLE, &amp;hDecEncKey );


// some buffer manipulation to ensure buffer size is of correct size

CryptEncrypt( hDecEncKey, 0, TRUE, 0, pbBuffer, &amp;dwCount, dwBufferLen );

CryptBinaryToString(pbBuffer, dwCount, CRYPT_STRING_BINARY, wsTempOut, &amp;dwStrLen);
</code></pre>
","<p>instead of the following line :</p>

<pre><code>CryptAcquireContext(&amp;hProvider, NULL,  MS_ENH_RSA_AES_PROV, PROV_RSA_AES,     CRYPT_VERIFYCONTEXT);
</code></pre>

<p>use the following lines of code : (change your args accordingly)</p>

<pre><code>if(CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)==0){
    //Prateek 12-10-13
    printf(""\n crytpAcquireContext failed..%x.\n"",GetLastError());
    if(GetLastError()==NTE_BAD_KEYSET){
            if(CryptAcquireContext(&amp;hCryptProv, NULL, NULL, PROV_RSA_FULL,   CRYPT_NEWKEYSET)==0){

                    printf(""\n crytpAcquireContext again failed..%x.\n"",GetLastError());
            }
    }
</code></pre>

<p>}</p>
","193","<cryptoapi>","2","0","2","2014-04-09 02:35:17","22951764","0","","281306","","2013-04-04 18:25:25","2013-04-04 18:01:50",""
"15818420","Getting same ciphertext every time from the same plaintext","<p>I am using Microsoft CryptoAPI to encrypt the password. Using 3DES from Microsoft Enhanced Cryptographic Provider. What I noticed is that I seem to be getting exactly the same ciphertext from the same plaintext every time. As far as I know this should not be happening in CBC mode, which CALG_3DES is operating in according to MSDN. I know 3DES is old and I should be using AES instead but this is a legacy code and I would like to avoid changing the algorithm. Am I doing something wrong? I think I might need to provide IV but I do not see how it can be done for 3DES using CryptoAPI. None of MSDN samples show it. Below is the redacted code snippet that shows the sequence of CryptoAPI calls.</p>

<p>Here is my code so far:</p>

<pre><code>CryptAcquireContext(&amp;hProvider, NULL,  MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);

/// key acquired by some means and stored in pszTempData

CryptCreateHash( hProvider, CALG_SHA_256, 0, 0, &amp;hHash );

CryptHashData( hHash, (BYTE *)pszTempData, wcslen(pszTempData), 0 );

CryptDeriveKey( hProvider, CALG_3DES, hHash,  CRYPT_EXPORTABLE, &amp;hDecEncKey );


// some buffer manipulation to ensure buffer size is of correct size

CryptEncrypt( hDecEncKey, 0, TRUE, 0, pbBuffer, &amp;dwCount, dwBufferLen );

CryptBinaryToString(pbBuffer, dwCount, CRYPT_STRING_BINARY, wsTempOut, &amp;dwStrLen);
</code></pre>
","<p>This question was never answered adequately. You can set the IV the same way for any cryptographic algorithm that supports IVs. The Microsoft CryptoAPI deals with variables called <code>HCRYPTKEY</code> for interacting with keys. HCRYPTKEY is nothing special, just a variable that contains a numeric value that is a handle to a key. The Cryptographic Service Provider (CSP) can look up and interact with keys when you use this HCRYPTKEY handle. In your case, call <code>CryptSetKeyParam(hDecEncKey, KP_IV, the_IV_Bytes, 0);</code>. For documentation, see <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa380272%28v=vs.85%29.aspx"" rel=""nofollow"">here</a>.</p>
","193","<cryptoapi>","2","1","2","2014-04-09 02:35:17","22951764","0","","281306","","2013-04-04 18:25:25","2013-04-04 18:01:50",""
"11743690","how to crypto api for writing kernel module","<p>I want to write a small kernel module in which I have to take a static string, hex-encode it and then use arc4 algorithm to encrypt it and then reverse the process. The logic is pretty clear to me. What I am suffering is that of a guideline of using the crypto api. I cannot exactly find the way out. If some one can give me a rough introduction or a useful link, it will be of much help to me. I searched a lot about it, but could not figure it out exactly. Thanks in advance.</p>
","","185","<linux><module><kernel><cryptoapi>","0","","0","2012-07-31 15:31:14","","3","","","","","2012-07-31 15:31:14",""
"28859065","Check pointer handle is valid","<p>I want to implement a Microsoft CryptographicServiceProvider library and currently I thinking about the best way how to deal with context handle which I create. </p>

<p>My question is specific to this case but the design approach can be used in other situations.</p>

<p>I come from a managed code background and I am not 100% shure about multithread pointer handling in C/C++.</p>

<p>In general there are two functions which are responsible for handle creation and destruction (CryptAcquireContext, CryptReleaseContext), and all subsequent CSP functions uses the handle which is return by the creator function.</p>

<p>I didn't found any concrete information or specification from Microsoft which gives a design approach or rules how to do it. But I did research with other CSP providers created by Microsoft to find out the design rules, which are:</p>

<ul>
<li>The functions must be thread safe</li>
<li>The context handle will not be shared between threads</li>
<li>If a context handle is not valid return with an error</li>
</ul>

<p>Other MS CSP Provider will return a valid pointer as handle, or NULL if not.</p>

<p>I don't think that the calling application will pass complete garbage but it could happen that it passes a handle which has been already released and my library should return with an error.</p>

<p>This brought me to three ideas how to implement that:</p>

<ol>
<li><p>Just allocate memory of my context struct with malloc or new and return the raw pointer as handle. </p>

<p>I can expect that the applications which call my library will pass a valid handle. But if not my library will run into an undefined behaviour.    So I need a better solution.</p></li>
<li><p>Add the pointer which I create to a list (std::list, std::map). So I can iterate the list to check if the pointer exists. The access to the list is guarded with a mutex.</p>

<p>This should be safe and a regular API usage shouldn't be a performance issue. But in a Terminal Server scenario it could be. In this case the Windows process lsass.exe creates for every user who wants to login a CSP context in a separate thread and makes around 10 API calls per context.</p>

<p>The design goal is that my library should be able to handle 300 clients parallel. I don't know how many threads a created by Windows in this case.</p>

<p>So if possible I would prefer a lockless implementation.</p></li>
<li><p>I allocate a basic struct which holds a check value and the pointer of the actual data. Use the pointer of this struct as context handle.</p>

<pre><code>typedef struct CSPHandle  
{  
    int Type; // (eg. magic number CSPContext=0xA1B2C3D4)  
    CSPContextPtr pCSPContext;  
};
</code></pre>

<p>So I could read the first byte of the passed pointer and check if the data equals my defined type. And I have the full control about actual data pointer, which is set to NULL if the context is released. Is this a good or bad idea?</p></li>
</ol>

<p>What are your thoughts about this case? Should I go with one of these approaches or is there a other solution? </p>

<p>Thanks</p>
","<p>I found a solution and will answer my question.</p>

<p>I overlooked a little but important detail</p>

<p>In CSP there are not direct API calls to the dll (load library, get function pointer, call function) because the function calls are forwarded by the Microsoft CSP which loads the CSP library by name. </p>

<p>So the Microsoft CSP needs to know and to check the passed context to get a correct mapping to the specific library.</p>

<p>Example:<br>
1. client->cryptacquirecontext(<em>in</em> cspname, <em>out</em> ctx)<br>
2. MS CSP->loads libray from the cspname<br>
3. MS CSP->calls the function pointer of the loaded library<br>
4. CSP LIB->cryptacquirecontext creates new context<br>
5. MS CSP->receives the returned csp handle and saves it to the dll mapping<br>
6. MS CSP->returns the result to the calling application<br>
7. client->cryptsetprovparam(ctx) // which was created before<br>
8. MS CSP->checks if the context exists and which library is responsible<br>
9. MS CSP->if the given context can not be mapped to a csp dll an error will be   returned, because the MS CSP doesn’t know which function pointer should be called.</p>

<p>So in this case it should be sufficient just to allocate memory. If the client application passes invalid context handle it will never hit the csp library.</p>

<p>I think that the MS CSP uses a list with mutex guard to store the context mappings. Because the context can be anything from a random number to a valid pointer.</p>
","184","<c++><c><multithreading><thread-safety><cryptoapi>","0","0","1","2015-03-05 13:17:47","","1","","1806019","","2015-03-04 16:43:17","2015-03-04 16:01:46",""
"24141360","Endianness of BcryptSignHash output signature","<p>The private and public key blobs generated by <em>BcryptGenerateKeyPair</em> are big-endian encoded (<a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/aa375520%28v=vs.85%29.aspx</a>).</p>

<p>Using these keys, i sign a data using <em>BcryptSignHash</em> and generate a 64-byte signature which ideally should be (r,s). Is this signature also big-endian encoded?</p>

<p>I need this information to extract r and s from 64-byte signature. I am assuming 64-byte signature to be concatenation of r (first 32 bytes) and s (last 32 bytes).</p>

<p>Please correct me if am wrong</p>
","<p>For DSA signatures, yes the signature output from BCryptSignHash is as you describe, namely (r,s) in big-endian format.</p>

<p>(I've had to extract these values in the past when interoperating with OpenSSL).</p>
","180","<cryptoapi><cng><libgcrypt>","1","1","1","2015-01-24 14:09:57","","0","","","","","2014-06-10 12:46:07",""
"42388203","Install self-signed certificate to personal store from .cer file using c++","<p>I try to create a certificate for testing purposes in two steps. First, I create a self-signed certificate which establishes my own Certification Authority (CA). Second, I use that root certificate to sign a test server certificate which will be placed in personal certificate store. I open an administrative command prompt and enter the following:</p>

<p><strong>Step 1:</strong>
MakeCert -pe -n ""CN=TestCA"" -b 01/01/2015 -e 01/01/2020 -ss my -sr currentuser -a sha256 -sky signature -len 2048 -r ""TestCA.cer""</p>

<p><strong>Step 2:</strong>
MakeCert -pe -n ""CN=localhost"" -b 01/01/2015 -e 01/01/2020 -eku 1.3.6.1.5.5.7.3.1 -in ""TestCA"" -is my -ir currentuser -ss my -sr currentuser -a sha256 -sky exchange -sp ""Microsoft RSA SChannel Cryptographic Provider"" -sy 12 -len 2048 ""Localhost.cer""</p>

<p>Following those steps, everything works fine. After that, I try to install those certificates via c++ application. It seems to be fine when I check those certificates in certmgr.msc, however, client always fail to connect to server since then. After deleting certificate ""localhost"" from personal certificate store, then do step 2 using MakeCert.exe again. Client can success to connect to server. Maybe there is something important that I was missing. If anyone knows it, please give me some suggestions. By the way, my client and server are running in the same computer. My codes are shown below.</p>

<pre><code>HCERTSTORE hMyCertStore = NULL;
if(hMyCertStore = CertOpenStore(
   CERT_STORE_PROV_SYSTEM,          // The store provider type
   0,                               // The encoding type is
                                    // not needed
   NULL,                            // Use the default HCRYPTPROV
   CERT_SYSTEM_STORE_CURRENT_USER,  // Set the store location in a
                                    // registry location
   L""MY""                            // The store name as a Unicode 
                                    // string
   ))
{
    printf(""The system store was created successfully.\n"");
}
else
{
    printf(""An error occurred during creation ""
        ""of the system store!\n"");
    exit(1);
}

CRYPTUI_WIZ_IMPORT_SRC_INFO importSrc;

memset(&amp;importSrc, 0, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
importSrc.dwSize = sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO);
importSrc.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
importSrc.pwszFileName = L""C:\\Temp\\MakeCert\\localhost.cer"";
importSrc.pwszPassword = L"""";
importSrc.dwFlags = CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED;

if (CryptUIWizImport(CRYPTUI_WIZ_NO_UI,
                     NULL,
                     NULL,
                     &amp;importSrc,
                     hMyCertStore) == 0)
{
    printf(""CryptUIWizImport error %d\n"", GetLastError());
}
</code></pre>

<p>Any help would be greatly appreciated.</p>

<p>Clement</p>
","<p>I've found the difference between MakeCert and my application. After installing by MakeCert, I opened certificate dialog's General tab, then I found there is a string ""You have a private key that corresponds to this certificate, but using my application, there is no string in the dialog. I think that I've missed some steps during the install procedure. If anyone know, please give me some suggestion.</p>

<p>Thanks.</p>

<p>Clement</p>
","178","<certificate><cryptoapi>","1","0","1","2017-02-23 09:58:12","","0","1","","","","2017-02-22 09:56:26",""
"36311701","Cross platform (including Windows) way to use OS trusted certificates with nodejs","<p>Is there a node module available or code that can read trusted certificates from the OS in a cross platform way?  Others answers cover how to use <a href=""https://stackoverflow.com/questions/20658120/nodejs-unable-to-read-default-cas-in-ubuntu"">ubuntus</a> which I could adapt for MacOS X, but I have not been able to find any code that can easily read Windows trusted certificates.  Other questions have pointed to where they exist in the <a href=""https://superuser.com/questions/411909/where-is-the-certificate-folder-in-windows-7"">registry</a> and that I should be using the CryptoAPI to load them, but I have not been able to find a good example of doing this from node yet.</p>
","<p>It sounds like the problem you are describing is not really about reading the certificates, but simply knowing where they live. </p>

<p>Trying to build something that can automatically discover where trusted certificates live on any running machine is almost certainly impossible, and probably not a good idea anyway.</p>

<p>Instead, this sounds like it should be solved with a simple environment variable (the problem after all is about <em>variability</em> of certificate paths on different <em>environments</em>). </p>

<p>You might set 3 environment variable, let's call them <code>CERT_PATH</code>, <code>KEY_PATH</code> and <code>CA_PATH</code>. You can configure these on any OS to point to the correct location. You can then reference them in your application:</p>

<pre><code>var fs = require('fs');  
var https = require('https');

var options = {  
    key: fs.readFileSync(process.env.KEY_PATH),
    cert: fs.readFileSync(process.env.CERT_PATH),
    ca: fs.readFileSync(process.env.CA_PATH),
};

https.createServer(options, function (req, res) {  
    console.log(new Date()+' '+
        req.connection.remoteAddress+' '+
        req.method+' '+req.url);
    res.writeHead(200);
    res.end(""hello world\n"");
  }).listen(4433);
</code></pre>
","178","<node.js><ssl><cryptoapi>","4","2","1","2016-04-06 11:58:09","","1","","-1","","2017-05-23 12:00:27","2016-03-30 14:21:53",""
"22760269","AES decryption using user-defined key","<p>Is there way to use user-defined key for AES decrypting using WinCrypt API? From what i understand reading the docs and samples, standart way is to generate random key using Windows cryptographic API, the export this key to a file and use it for decryption. </p>

<p>But i need to allow user to define its own password for encryption/decryption.</p>
","<p>The .NET library provides PasswordDeriveBytes in the System.Security.Cryptography namespace for exactly this purpose.  It looks like CryptDeriveKey is the WinCrypt API equivalent.  Yes, you can let your users choose their own passwords, then let this function chew up many microseconds calculating the actual key bytes for the crypto function.  Your end users will never miss those few microseconds, but a brute force hacker being slowed to trying 1 million passwords per second instead of 1 billion will hate it, and this is as it should be.</p>
","173","<winapi><cryptoapi>","1","1","1","2015-08-03 10:27:22","","3","1","","","","2014-03-31 11:21:36",""
"24382887","What is difference between Crypt... and CP... functions?","<p>I try to learn WIN API. I found <a href=""http://msdn.microsoft.com/en-us/library/aa380252%28v=vs.85%29.aspx#base_cryptography_functions"" rel=""nofollow"">base cryptographic functions</a> such as <a href=""http://msdn.microsoft.com/en-us/library/aa379924%28v=vs.85%29.aspx"" rel=""nofollow"">CryptEcrypt</a> and <a href=""http://msdn.microsoft.com/en-us/library/aa380252%28v=vs.85%29.aspx#csp_functions"" rel=""nofollow"">CSP Functions</a> such as <code>CPEncrypt</code>. Also I read <a href=""http://www.progtown.com/topic175686-differences.html"" rel=""nofollow"">this</a>. I would like to clarify. If I use CPEncrypt then I call CSP functions directly, without CriptoAPI? And if I use CryptEcrypt, it calls CriptoAPI, and CriptoAPI calls CSP functions?
What is difference between Crypt... and CP... functions?</p>
","<blockquote>
  <p>What is difference between Crypt... and CP... functions?</p>
</blockquote>

<p>The <em>CP</em> functions are the underlying implementations of the <code>CryptoAPI</code> within a particular CSP.</p>

<blockquote>
  <p>If I use CPEncrypt then I call CSP functions directly, without
  CriptoAPI?</p>
</blockquote>

<p>Do not call them directly; abusing the intended use pattern of a security API is a very bad idea and in the case of the CryptoAPI the intended pattern is to go via the API's <code>CryptXXX</code> functions.</p>

<blockquote>
  <p>And if I use CryptEcrypt, it calls CriptoAPI, and CriptoAPI calls CSP functions?</p>
</blockquote>

<p><code>CryptEncrypt</code> is part of the CryptoAPI, calling it will eventually invoke <code>CPEncrypt</code> in whatever CSP you are using.</p>
","171","<winapi><cryptoapi>","1","2","1","2016-02-24 14:38:01","24384480","0","","15519","","2016-02-24 14:38:01","2014-06-24 09:21:12",""
"33173950","determine, is cert. store system or physical, having HCERTSTORE handle only","<p>let us assume, we have a valid HCERTSTORE handle of opened certificate store. How can we determine - is opened store physical or system?</p>

<p>Restriction 1 - we should use CryptoAPI (C++) only.</p>

<p>Restriction 2 - we've successfully forgotten, what kind of store was used in CertOpenStore() call.</p>
","<p>I don't see a way to solve this with CryptoAPI and, as the constraint 2 is artificial, don't think it was designed to address this problem. Closeable handles can't be passed around between processes, so one cannot ""forget"" what it was unless deliberately: the knowledge is right there, in the code that got the handle.</p>

<p>By looking through the function list in the left pane at <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa376559%28v=vs.85%29.aspx"" rel=""nofollow"">CertOpenStore - MSDN</a>, I see <a href=""http://CertGetStoreProperty"" rel=""nofollow""><code>CertGetStoreProperty()</code></a>, but there's only one predefined property, <code>CERT_STORE_LOCALIZED_NAME_PROP_ID</code>, which isn't reliable.</p>
","169","<windows><cryptoapi><certificate-store>","0","0","1","2015-10-16 16:37:02","33175285","2","","","","","2015-10-16 15:16:16",""
"54353039","How to create a public/private key pair to use with OpenSSL","<p>i am trying to create a windows application which creates a public and private key and export this so that i can use this with OpenSSL.
I took same examples provided by MSDN but there is something wrong... I think its a problem of the sizes for allocating memory.</p>

<p>The result i need is a base64 encoded public and private key like this:</p>

<p>const char* szPemPrivKey = 
    ""-----BEGIN RSA PRIVATE KEY-----""
    ""MIICXAIBAAKBgQCf6YAJOSBYPve1jpYDzq+w++8YVoATI/YCi/RKZaQk+l2ZfoUQ""
    ""g0qrYrfkzeoOa/qd5VLjTTvHEgwXnlDXMfo+vSgxosUxDOZXMTBqJGOViv5K2QBv""
    ""k8A1wi4k8tuo/7OWya29HvcfavUk3YXaV2YFe8V6ssaZjNcVWmDdjqNkXwIDAQAB""
    ""AoGALrd+ijNAOcebglT3ioE1XpUbUpbir7TPyAqvAZUUESF7er41jY9tnwgmBRgL""
    ""Cs+M1dgLERCdKBkjozrDDzswifFQmq6PrmYrBkFFqCoLJwepSYdWnK1gbZ/d43rR""
    ""2sXzSGZngscx0CxO7KZ7xUkwENGd3+lKXV7J6/vgzJ4XnkECQQDTP6zWKT7YDckk""
    ""We04hbhHyBuNOW068NgUUvoZdBewerR74MJx6nz28Tp+DeNvc0EveiQxsEnbV8u+""
    ""NRkX5y0xAkEAwcnEAGBn5kJd6SpU0ALA9XEpUv7tHTAGQYgCRbfTT59hhOq6I22A""
    ""ivjOCNG9c6E7EB2kcPVGuCpYUhy7XBIGjwJAK5lavKCqncDKoLwGn8HJdNcyCIWv""
    ""q5iFoDw37gTt1ricg2yx9PzmabkDz3xiUmBBNeFJkw/FToXiQRGIakyGIQJAJIem""
    ""PPPvYgZssYFbT4LVYO8d/Rk1FWVyKHQ9CWtnmADRXz7oK7l+m7PfEuaGsf9YpOcR""
    ""koGJ/TluQLxNzUNQnQJBAImwr/yYFenIx3HQ6UX/fCt6qpGDv0VfOLyR64MNeegx""
    ""o7DhNxHbFkIGzk4lKhMKcHKDrawZbdJtS9ie2geSwVQ=""
    ""-----END RSA PRIVATE KEY-----"";</p>

<p>const char* szPemPubKey = 
    ""-----BEGIN RSA PUBLIC KEY-----""
    ""MIGJAoGBAJ/pgAk5IFg+97WOlgPOr7D77xhWgBMj9gKL9EplpCT6XZl+hRCDSqti""
    ""t+TN6g5r+p3lUuNNO8cSDBeeUNcx+j69KDGixTEM5lcxMGokY5WK/krZAG+TwDXC""
    ""LiTy26j/s5bJrb0e9x9q9STdhdpXZgV7xXqyxpmM1xVaYN2Oo2RfAgMBAAE=""
    ""-----END RSA PUBLIC KEY-----"";</p>

<p><a href=""https://www.idrix.fr/Root/Samples/capi_pem.cpp"" rel=""nofollow noreferrer"">https://www.idrix.fr/Root/Samples/capi_pem.cpp</a></p>

<p>Can someone correct my code or give me a hint what i do wrong?</p>

<pre><code>int CreateKeys(DWORD keyLength)
{
/* variables */
HCRYPTPROV hCryptProv = NULL;
DWORD flags = keyLength /*key length*/ &lt;&lt; 16;
flags |= CRYPT_EXPORTABLE;
DWORD size = 0;
HCRYPTKEY hKey = NULL;

/* variables public key */
HCRYPTKEY hPublicKey = NULL;
DWORD dwPublicKeyLen = 0;
BYTE* pbPublicKey = NULL;
HANDLE hPublicKeyFile = NULL;
LPBYTE pPublicBLOB = (LPBYTE)LocalAlloc(0, size);

/* variables private key */
HCRYPTKEY hPrivateKey = NULL;
DWORD dwPrivateKeyLen = 0;
BYTE* pbPrivateKey = NULL;
HANDLE hPrivateKeyFile = NULL;
LPBYTE pPrivateKeyBLOB = (LPBYTE)LocalAlloc(0, size);

/* get provider */  
DWORD rc = CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT | CRYPT_SILENT);

// Generate new key pair
//_tprintf(_T(""CryptGenKey...\n""));
if (!CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_ARCHIVABLE, &amp;hKey))
{
    // Error
    //_tprintf(_T(""CryptGenKey error 0x%x\n""), GetLastError());
    return 1;
}
// Get public key size
//_tprintf(_T(""CryptExportKey...\n""));
if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwPublicKeyLen))
{
    // Error
    //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
    return 1;
}
// Create a buffer for the public key
//_tprintf(_T(""malloc...\n""));
if (!(pbPublicKey = (BYTE *)malloc(dwPublicKeyLen)))
{
    // Error
    //_tprintf(_T(""malloc error 0x%x\n""), GetLastError());
    return 1;
}
// Get public key
//_tprintf(_T(""CryptExportKey...\n""));
if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbPublicKey, &amp;dwPublicKeyLen))
{
    // Error
    //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
    return 1;
}





// Get private key size
//_tprintf(_T(""CryptExportKey...\n""));
if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwPrivateKeyLen))
{
    // Error
    //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
    return 1;
}
// Create a buffer for the private key
//_tprintf(_T(""malloc...\n""));
if (!(pbPrivateKey = (BYTE *)malloc(dwPrivateKeyLen)))
{
    // Error
    //_tprintf(_T(""malloc error 0x%x\n""), GetLastError());
    return 1;
}
// Get private key
//_tprintf(_T(""CryptExportKey...\n""));
if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, pbPrivateKey, &amp;dwPrivateKeyLen))
{
    // Error
    //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
    return 1;
}

/*
rc = CryptExportKey(hPrivateKey, 0, PRIVATEKEYBLOB, 0, 0, &amp;size);
LPBYTE pPrivKeyBLOB = (LPBYTE)LocalAlloc(0, size);
rc = CryptExportKey(hPrivateKey, 0, PRIVATEKEYBLOB, 0, pPrivKeyBLOB, &amp;size);
*/

/* DER */
rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, pbPrivateKey, 0, NULL, NULL, &amp;dwPrivateKeyLen);

LPBYTE pPrivateDER = (LPBYTE)LocalAlloc(0, dwPrivateKeyLen);
rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, pbPrivateKey, 0, NULL, pPrivateDER, &amp;dwPrivateKeyLen);

/* PEM */
DWORD pemPrivateSize = 0;
rc = CryptBinaryToStringA(pPrivateDER, dwPrivateKeyLen, CRYPT_STRING_BASE64HEADER, NULL, &amp;pemPrivateSize);

LPSTR pPrivatePEM = (LPSTR)LocalAlloc(0, pemPrivateSize);
rc = CryptBinaryToStringA(pPrivateDER, dwPrivateKeyLen, CRYPT_STRING_BASE64HEADER, pPrivatePEM, &amp;pemPrivateSize);



/* DER */
rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pbPublicKey, 0, NULL, NULL, &amp;dwPublicKeyLen);

LPBYTE pPublicDER = (LPBYTE)LocalAlloc(0, dwPublicKeyLen);
rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pbPublicKey, 0, NULL, pPublicDER, &amp;dwPublicKeyLen);

/* PEM */
DWORD pemPublicSize = 0;
rc = CryptBinaryToStringA(pPublicDER, dwPublicKeyLen, CRYPT_STRING_BASE64HEADER, NULL, &amp;pemPublicSize);

LPSTR pPublicPEM = (LPSTR)LocalAlloc(0, pemPublicSize);
rc = CryptBinaryToStringA(pPublicDER, dwPublicKeyLen, CRYPT_STRING_BASE64HEADER, pPrivatePEM, &amp;pemPublicSize);

printf(""%s"", pPrivatePEM);
printf(""%s"", pPublicPEM);

return 0;
}
</code></pre>
","<p>it seem like you provided wrong format to the <code>CryptEncodeObjectEx</code> Function to get public keys
I used <code>CryptExportPublicKeyInfo</code> to get the right key info.</p>

<p>Try this code:</p>

<pre><code>int CreateKeys(DWORD keyLength)
{
    /* variables */
    HCRYPTPROV hCryptProv = NULL;
    DWORD flags = keyLength /*key length*/ &lt;&lt; 16;
    flags |= CRYPT_EXPORTABLE;
    DWORD size = 0;
    HCRYPTKEY hKey = NULL;

    /* variables public key */
    HCRYPTKEY hPublicKey = NULL;
    DWORD dwPublicKeyLen = 0;
    BYTE* pbPublicKey = NULL;
    HANDLE hPublicKeyFile = NULL;
    LPBYTE pPublicBLOB = (LPBYTE)LocalAlloc(0, size);

    /* variables private key */
    HCRYPTKEY hPrivateKey = NULL;
    DWORD dwPrivateKeyLen = 0;
    BYTE* pbPrivateKey = NULL;
    HANDLE hPrivateKeyFile = NULL;
    LPBYTE pPrivateKeyBLOB = (LPBYTE)LocalAlloc(0, size);

    /* get provider */
    DWORD rc = CryptAcquireContext(&amp;hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT | CRYPT_SILENT);

    // Generate new key pair
    //_tprintf(_T(""CryptGenKey...\n""));
    if (!CryptGenKey(hCryptProv, AT_KEYEXCHANGE, CRYPT_ARCHIVABLE, &amp;hKey)) {
        // Error
        //_tprintf(_T(""CryptGenKey error 0x%x\n""), GetLastError());
        return 1;
    }
    // Get public key size
    //_tprintf(_T(""CryptExportKey...\n""));
    if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, NULL, &amp;dwPublicKeyLen)) {
        // Error
        //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
        return 1;
    }
    // Create a buffer for the public key
    //_tprintf(_T(""malloc...\n""));
    if (!(pbPublicKey = (BYTE *)malloc(dwPublicKeyLen))) {
        // Error
        //_tprintf(_T(""malloc error 0x%x\n""), GetLastError());
        return 1;
    }
    // Get public key
    //_tprintf(_T(""CryptExportKey...\n""));
    if (!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbPublicKey, &amp;dwPublicKeyLen)) {
        // Error
        //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
        return 1;
    }





    // Get private key size
    //_tprintf(_T(""CryptExportKey...\n""));
    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, &amp;dwPrivateKeyLen)) {
        // Error
        //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
        return 1;
    }
    // Create a buffer for the private key
    //_tprintf(_T(""malloc...\n""));
    if (!(pbPrivateKey = (BYTE *)malloc(dwPrivateKeyLen))) {
        // Error
        //_tprintf(_T(""malloc error 0x%x\n""), GetLastError());
        return 1;
    }
    // Get private key
    //_tprintf(_T(""CryptExportKey...\n""));
    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, pbPrivateKey, &amp;dwPrivateKeyLen)) {
        // Error
        //_tprintf(_T(""CryptExportKey error 0x%x\n""), GetLastError());
        return 1;
    }

    /*
    rc = CryptExportKey(hPrivateKey, 0, PRIVATEKEYBLOB, 0, 0, &amp;size);
    LPBYTE pPrivKeyBLOB = (LPBYTE)LocalAlloc(0, size);
    rc = CryptExportKey(hPrivateKey, 0, PRIVATEKEYBLOB, 0, pPrivKeyBLOB, &amp;size);
    */

    /* DER */
    rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, pbPrivateKey, 0, NULL, NULL, &amp;dwPrivateKeyLen);

    LPBYTE pPrivateDER = (LPBYTE)LocalAlloc(0, dwPrivateKeyLen);
    rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, PKCS_RSA_PRIVATE_KEY, pbPrivateKey, 0, NULL, pPrivateDER, &amp;dwPrivateKeyLen);

    /* PEM */
    DWORD pemPrivateSize = 0;
    rc = CryptBinaryToStringA(pPrivateDER, dwPrivateKeyLen, CRYPT_STRING_BASE64HEADER, NULL, &amp;pemPrivateSize);

    LPSTR pPrivatePEM = (LPSTR)LocalAlloc(0, pemPrivateSize);
    rc = CryptBinaryToStringA(pPrivateDER, dwPrivateKeyLen, CRYPT_STRING_BASE64HEADER, pPrivatePEM, &amp;pemPrivateSize);

    DWORD  pkiLen = 0;
    LPVOID pki = nullptr;
    rc = CryptExportPublicKeyInfo(hCryptProv, AT_KEYEXCHANGE, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, &amp;pkiLen);

    // allocate memory
    pki = (LPBYTE)LocalAlloc(0, pkiLen);

    rc = CryptExportPublicKeyInfo(hCryptProv, AT_KEYEXCHANGE, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, (PCERT_PUBLIC_KEY_INFO)pki, &amp;pkiLen);

    /* DER */   
    rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pki, 0, NULL, NULL, &amp;pkiLen);

    LPBYTE pPublicDER = (LPBYTE)LocalAlloc(0, dwPublicKeyLen);
    rc = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_PUBLIC_KEY_INFO, pki, 0, NULL, pPublicDER, &amp;dwPublicKeyLen);

    /* PEM */
    DWORD pemPublicSize = 0;
    rc = CryptBinaryToStringA(pPublicDER, dwPublicKeyLen, CRYPT_STRING_BASE64HEADER, NULL, &amp;pemPublicSize);

    LPSTR pPublicPEM = (LPSTR)LocalAlloc(0, pemPublicSize);
    rc = CryptBinaryToStringA(pPublicDER, dwPublicKeyLen, CRYPT_STRING_BASE64HEADER, pPublicPEM, &amp;pemPublicSize);

    printf(""%s"", pPrivatePEM);
    printf(""%s"", pPublicPEM);

    return 0;
}
</code></pre>
","169","<c++><key><private><public><cryptoapi>","0","0","1","2019-01-26 13:49:22","","0","","","","","2019-01-24 18:16:38",""
"41064225","Encode UTF8String to ASN1 with CryptoAPI","<p>I use this code to encode UTF8String in ASN1: </p>

<pre><code>const char *charExtensionValue = ""test value тест тест with some cyrillic symbols"";

CERT_NAME_VALUE myNameValue;
myNameValue.dwValueType = CERT_RDN_UTF8_STRING;
myNameValue.Value.cbData = (DWORD)(strlen(charExtensionValue)+1)*2;
myNameValue.Value.pbData = (LPBYTE)charExtensionValue;

CERT_BLOB encodedBlob;

bool checkASN1Encoding = CryptEncodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, X509_ANY_STRING, &amp;myNameValue, CRYPT_ENCODE_ALLOC_FLAG, NULL, &amp;encodedBlob.pbData, &amp;encodedBlob.cbData);
</code></pre>

<p>CryptEncodeObjectEx works well, without any errors, but the result is not expected: </p>

<pre><code>OCTET STRING, encapsulates {
   UTF8String ""ø§³û¦© Ґѐô´ 
</code></pre>

<p>What am I doing wrong?</p>
","<p>the docs say CERT_RDN_UTF8_STRING means the value member must be ""An array of 16 bit Unicode characters UTF8 encoded on the wire as a sequence of one, two, or three, eight-bit characters."" but charExtensionValue points to an array of 8 bit characters. Also you are calculating the string as if it is a UTF-16 string which it is not. – Stuart</p>
","163","<c><cryptoapi>","0","1","1","2018-07-13 06:44:54","51319131","2","","","","","2016-12-09 15:54:09",""
"48632517","How to load *.CER file using CertCreateCertificateContext","<p>I am having to use VBA and CryptoAPI in order to perform a secure information exchange.  As part of the process, there is a need to establish a Context/Context-Handle through CryptoAPI using a custom Public-Key certificate (*.cer).</p>

<p>The *.cer file I have is ""DER encoded binary X.509"" file.  Thus far I have been able to get the file loaded into a binary-array using Windows API calls (CreateFile and ReadFile).  However when CertCreateCertificateContext() method is invoked, the ""ASN.1 bag tag value met""/(CRYPT_E_ANS1_BADTAG) error is raised.</p>

<p>Below is an excerpt of the code that I have put together thus far.</p>

<pre><code>Option Compare Database

Public Declare Function CertCreateCertificateContext Lib ""Crypt32.dll"" ( _
    ByVal dwCertEncodingType As Long, _
    ByVal pbCertEncoded As String, _
    ByVal cbCertEncoded As Long _
    ) As Long

Public Declare Function CryptDecodeObjectEx Lib ""Crypt32.dll"" ( _
    ByVal dwCertEncodingType As Long, _
    ByVal lpszStructType As String, _
    ByVal pbEncoded As String, _
    ByVal cbEncoded As Long, _
    ByVal dwFlags As Long, _
    ByVal pDecodePara, _
    ByVal pvStructInfo As Long, _
    ByVal pcbStructInfo As Long _
) As Long

Public Declare Function CreateFile Lib ""kernel32"" Alias ""CreateFileA"" ( _
    ByVal lpFileName As String, _
    ByVal dwDesiredAccess As Long, _
    ByVal dwShareMode As Long, _
    lpSecurityAttributes As Long, _
    ByVal dwCreationDisposition As Long, _
    ByVal dwFlagsAndAttributes As Long, _
    hTemplateFile As Long) As Long

Public Declare Function ReadFile Lib ""kernel32.dll"" ( _
    ByVal hfile As Long, _
    lpBuffer As Any, _
    ByVal nNumberOfBytesToRead As Long, _
    lpNumberOfBytesRead As Long, _
    lpOverlapped As Any) As Long
Public Declare Function GetFileSize Lib ""kernel32.dll"" (ByVal hfile As Long, lpFileSizeHigh As Long) As Long
'close handle
Private Declare Function CloseHandle Lib ""kernel32"" (hObject As Long) As Long
'API error function
Private Declare Function GetLastError Lib ""kernel32"" () As Long


Const GENERIC_READ = &amp;H80000000
Const GENERIC_WRITE = &amp;H40000000
Const FILE_SHARE_READ = &amp;H1
Const FILE_SHARE_WRITE = &amp;H2
Const CREATE_ALWAYS = 2
Const CREATE_NEW = 1
Const OPEN_ALWAYS = 4
Const OPEN_EXISTING = 3
Const TRUNCATE_EXISTING = 5
Const FILE_ATTRIBUTE_ARCHIVE = &amp;H20
Const FILE_ATTRIBUTE_HIDDEN = &amp;H2
Const FILE_ATTRIBUTE_NORMAL = &amp;H80
Const FILE_ATTRIBUTE_READONLY = &amp;H1
Const FILE_ATTRIBUTE_SYSTEM = &amp;H4
Const FILE_FLAG_DELETE_ON_CLOSE = &amp;H4000000
Const FILE_FLAG_NO_BUFFERING = &amp;H20000000
Const FILE_FLAG_OVERLAPPED = &amp;H40000000
Const FILE_FLAG_POSIX_SEMANTICS = &amp;H1000000
Const FILE_FLAG_RANDOM_ACCESS = &amp;H10000000
Const FILE_FLAG_SEQUENTIAL_SCAN = &amp;H8000000
Const FILE_FLAG_WRITE_THROUGH = &amp;H80000000

Const CRYPT_ENCODE_ALLOC_FLAG = &amp;H8000

Const X509_ASN_ENCODING = &amp;H1
Const PKCS_7_ASN_ENCODING = &amp;H10000
Const CertEncodingCombined = &amp;H1 Or &amp;H10000

Const certBufferSize = 65536
Const X509_PUBLIC_KEY_INFO = ""X509_PUBLIC_KEY_INFO"" &amp; vbNullChar

Private Const INVALID_HANDLE_VALUE = -1

Public Sub foo()
    '-- create file: to open the Cert file (API Documentation: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx)
    Dim certFileHandle As Long
    Dim pathToCert As String

    '-- get file-handle to the CER
    pathToCert = ""C:\Projects\Cryptography\SampleCert\public_v2_DER.cer""
    certFileHandle = CreateFile( _
        pathToCert, _
        GENERIC_READ, _
        FILE_SHARE_READ, _
        ByVal CLng(0), _
        OPEN_EXISTING, _
        FILE_ATTRIBUTE_NORMAL, _
        0)
    MsgBox (""Handle to the Cert: "" + CStr(certFileHandle))  '-- display handle
    '-- check for error
    If (certFileHandle = INVALID_HANDLE_VALUE) Then
        '-- get last error
        MsgBox (""Error "" &amp; CStr(Err.LastDllError) &amp; "" during CreateFile!"")
        Exit Sub
    End If

    '-- get file size
    Dim highorder As Long, certFileSize As Long
    hiorder = 0  ' initialize the value for high-order half
    certFileSize = GetFileSize(certFileHandle, highorder)  ' read the file's size
    MsgBox (""Cert Size: "" &amp; CStr(certFileSize))

    '-- read the file into a byte-array
    Dim longbuffer As Long  ' receives long read from file
    Dim bytes() As Byte
    ReDim bytes(certBufferSize) '--certBufferSize
    Dim numread As Long  ' receives number of bytes read from file
    Dim error As Long

    '-- read the Cer-file as byte-array
    Dim bBytes() As Byte
    ReDim bBytes(certFileSize) As Byte
    error = ReadFile(certFileHandle, bBytes(1), UBound(bBytes), numread, ByVal CLng(0))
    '--     check for errors
    If (error = 0) Then
        MsgBox (""Error "" &amp; CStr(Err.LastDllError) &amp; "" during ReadFile!"")
    Else
        MsgBox (""Got Cert info"")
    End If

    '-- do load the context--------------------------
    On Error Resume Next
    Dim certificateAsString As String
    Dim nCertLen As Long
    Dim certContextHandle As Long
    '-- using byte-array, create a Certificate Context
    certContextHandle = CertCreateCertificateContext( _
        CertEncodingCombined, _
        bBytes, _
        certBufferSize _
    )
    MsgBox (""Cert Handle: "" &amp; CStr(certContextHandle))  '-- display Context-handle
    MsgBox (""Error "" &amp; CStr(Err.LastDllError) &amp; "" during CreateCertContext!"")   '-- display error
    '-- This is where the error is raised: (-2146881269), CRYPT_E_ASN1_BADTAG (ASN.1 bad tag value met)

    '-- release it
    ReleaseContextHandle (certContextHandle)

    '-- close the file
    CloseHandle (certFileHandle)
End Sub
</code></pre>
","","161","<access-vba><cryptoapi>","1","","0","2018-02-05 22:27:55","","0","","","","","2018-02-05 22:27:55",""
"36974545","Random numbers for Windows Phone 8 and Windows Store 8?","<p>I'm struggling with a port of a couple of security libraries to the Windows Phone 8 and Windows Store 8 platform. I need a function which provides random numbers.</p>

<p>Win32 has <code>CryptGenRandom</code> and even <code>RtlGenRandom</code>. Windows Store 10 and Universal Windows has <code>BCryptGenRandom</code>. However, there's a hole for Windows Phone 8 and Windows Store 8 because CryptoAPI is <em>not</em> available, and CNG is <em>only</em> available on Windows 10 and Universal Windows. The MSDN docs say <code>BCryptGenRandom</code> is available for ""Windows Store"", but they don't say its Windows Store 10 and UWP (<a href=""https://stackoverflow.com/a/36963659/608639"">thanks CW</a>).</p>

<p>The libraries are unmanaged C/C++. They are written in standard/portable C and C++. On occasion, they have to use a OS specific API like those for gathering random number. They don't compile against managed APIs, and they don't link to managed libraries.</p>

<p>What do we use for random numbers for Windows Phone 8 and Windows Store 8?</p>
","<p>In WP8.1 and Windows 8+ we are using <a href=""https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.cryptographicbuffer.generaterandomnumber"" rel=""nofollow"">CryptographicBuffer.GenerateRandomNumber</a></p>
","160","<windows-phone-8><random><windows-store-apps><cryptoapi><cng>","0","1","1","2016-05-05 09:00:59","","0","","-1","","2017-05-23 10:31:35","2016-05-02 03:24:40",""
"31307226","Windows Crypto API AES decryption leaves first block partially decrypted","<p>I'm coding c++ FYI</p>

<p>Ok so I have the windows Crypto API generating an RSA key pair so that I may properly export my generated AES key.</p>

<p>All works well, my code decrypts <strong>ALL</strong> of the data <strong>WITH THE EXCEPTION</strong> of 10 bytes starting at offset 0x2 in the outputted plaintext</p>

<p>It seems that offset 0x2 is random, while 0x3 is what it should be, while 0x4-0xC is 0xB8 consistently.</p>

<p>--Message Generation</p>

<pre><code>char message[700];
memset(message, 't', sizeof(message));
</code></pre>

<p>--Encryption</p>

<pre><code>CryptEncrypt(hKey, NULL, eof, 0, (LPBYTE)tmp_blk_buff, &amp;p_block_size, TMP_BLOCK_BUFFER_SIZE(context-&gt;in_size))
</code></pre>

<p>--Decryption</p>

<pre><code>CryptDecrypt(context-&gt;aes_hKey, NULL, eof, 0, (LPBYTE)tmp_blk_buff, &amp;p_block_size)
</code></pre>

<p>There is to much code to past in here.</p>

<p>Am I missing a dwFlag or something...I'm pretty stumped on this.
Thanks for any input.</p>

<p><img src=""https://i.stack.imgur.com/KvYDD.png"" alt=""The Plain Text""></p>
","","160","<c++><windows><encryption><aes><cryptoapi>","1","","0","2015-07-09 02:43:10","","2","","","","","2015-07-09 02:43:10",""
"33569311","System crash with Linux CryptoApi Module","<p>I tried to write Linux kernel module with cryptoapi. I found some examples like this: <a href=""https://codedream.me/2014/04/cryptoapi-linux-kernel/"" rel=""nofollow"">https://codedream.me/2014/04/cryptoapi-linux-kernel/</a></p>

<p>This example is working for me. Then I made some changes. Now my system crashes, when I try to load module. Can you help me with this?</p>

<pre class=""lang-c prettyprint-override""><code>/* Common headers */
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/err.h&gt;
/* crypto headers */
#include &lt;linux/crypto.h&gt;
#include &lt;linux/err.h&gt;
#include &lt;linux/scatterlist.h&gt;

#define AES_BLOCK_SIZE (16)
#define AES_IV_SIZE    (16)
#define AES_KEY_SIZE   (64) /* because we are using XTS mode */

typedef enum {
    ENCRYPT,
    DECRYPT
} cipher_mode;

static int crypt_data(u8 *key, u32 key_len, u8 *iv, u32 iv_len, u8 *dst, 
                      u32 dst_len, u8 *src, u8 src_len, cipher_mode mode)
{
    struct crypto_blkcipher *blk;
    struct blkcipher_desc desc;
    struct scatterlist sg[2];

    /* CRYPTO_ALG_TYPE_BLKCIPHER_MASK, CRYPTO_ALG_TYPE_BLKCIPHER */
    blk = crypto_alloc_blkcipher(""xts(aes)"", 0, 0);
    if (IS_ERR(blk)) {
        printk(KERN_ALERT ""Failed to initialize AES-XTS mode\n"");
        return -1;
    } else {
        printk(KERN_ALERT ""Initialized cipher: %s\n"", crypto_blkcipher_name(blk));
        printk(KERN_ALERT ""with IV size: %d\n"", crypto_blkcipher_ivsize(blk));
        printk(KERN_ALERT ""block size: %d\n"", crypto_blkcipher_blocksize(blk));
    }

    if (crypto_blkcipher_setkey(blk, key, key_len)) {
        printk(KERN_ALERT ""Failed to set key.\n"");
        goto err;
    }

    crypto_blkcipher_set_iv(blk, iv, iv_len);

    sg_init_one(&amp;sg[0],src,src_len);
    sg_init_one(&amp;sg[1],dst,dst_len);

    /* do encryption */
    desc.tfm = blk;
    desc.flags = 0;

    if (mode == ENCRYPT) {
        if (crypto_blkcipher_encrypt(&amp;desc, &amp;sg[1], &amp;sg[0], src_len))
            printk(KERN_ALERT ""Failed to encrypt.\n"");
    } else {
        if (crypto_blkcipher_decrypt(&amp;desc, &amp;sg[1], &amp;sg[0], src_len))
            printk(KERN_ALERT ""Failed to encrypt.\n"");
    }

    crypto_free_blkcipher(blk);
    return 0;

err:
    crypto_free_blkcipher(blk);
    return -1;
}

static int aes_crypt_init(void)
{
    int len = 5000;
    u8 key[AES_KEY_SIZE]; 
    u8 iv[AES_IV_SIZE];
    u8 src[len];
    u8 enc[len];
    u8 dec[len];
    int err = 0;

    printk(KERN_ALERT ""AES crypto module start initialyzing.\n"");
    err = crypt_data(key, AES_KEY_SIZE, iv, AES_IV_SIZE, enc, len, src, len, ENCRYPT);
    return err;
}

static void aes_crypt_exit(void)
{
    printk(KERN_ALERT ""AES crypto module exiting.\n"");
}

module_init(aes_crypt_init);
module_exit(aes_crypt_exit);

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Dmitry Falko"");
MODULE_DESCRIPTION(""Testing module crypto api for AES-XTS mode"");
</code></pre>

<p>When variable <code>len = 1000</code>, module is loaded normal. But if I change it on <code>len = 5000</code>, I get system crash when I load module.</p>

<p>My system is: <code>Linux ubuntu-virtual-machine 3.13.0-65-generic #105-Ubuntu SMP Mon Sep 21 18:50:58 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux</code></p>
","<p>You're probably running out of stack space. Stack in kernel threads is <em>extremely</em> limited; allocating 15 KB (5000 x 3) of data on the stack is not going to work.</p>

<p>Use <code>kmalloc()</code> and <code>kfree()</code> to allocate large buffers.</p>
","158","<linux><linux-kernel><cryptoapi>","1","2","1","2015-11-06 16:59:31","33571848","0","","3866447","","2015-11-06 16:21:42","2015-11-06 14:43:18",""
"48348550","CertGetCertificateChain - Invalid memory access","<p>Cross-posting for visibility: <a href=""https://groups.google.com/forum/#!topic/jna-users/qfkoxPwA-r8"" rel=""nofollow noreferrer"">https://groups.google.com/forum/#!topic/jna-users/qfkoxPwA-r8</a></p>

<p>I am working on creating a wrapper for the CertGetCertificateChain method in the Crypt32 lib and I would like to get help in resolving an 'Invalid Memory Access' issue that results in a crash.</p>

<p>The signature for the wrapper is:</p>

<pre><code>boolean CertGetCertificateChain(Pointer hChainEngine, PCERT_CONTEXT pCertContext, Pointer pTime,
            Pointer hAdditionalStore, CERT_CHAIN_PARA.ByReference pChainPara, int dwFlags, Pointer pvReserved,
            PointerByReference ppChainContext);
</code></pre>

<p>The structures i am using are:</p>

<pre><code>public static class CERT_CHAIN_PARA extends Structure {
    public int cbSize;
    public CERT_USAGE_MATCH RequestedUsage;

    @Override
    protected List&lt;String&gt; getFieldOrder() {
        return Arrays.asList(""cbSize"", ""RequestedUsage"");
    }


    public static class ByReference extends CERT_CHAIN_PARA implements Structure.ByReference {}
}


public static class CERT_USAGE_MATCH extends Structure {
    public int dwType;
    public CERT_ENHKEY_USAGE Usage;


    @Override
    protected List&lt;String&gt; getFieldOrder() {
        return Arrays.asList(""dwType"", ""Usage"");
    }


    public static class ByReference extends CERT_USAGE_MATCH implements Structure.ByReference {}
}


public static class CERT_ENHKEY_USAGE extends Structure {
    public int cUsageIdentifier;
    public LPSTR.ByReference rgpszUsageIdentifier;


    @Override
    protected List&lt;String&gt; getFieldOrder() {
        return Arrays.asList(""cUsageIdentifier"", ""rgpszUsageIdentifier"");
    }


    public static class ByReference extends CERT_ENHKEY_USAGE implements Structure.ByReference {}
}
</code></pre>

<p>There are copies of the ones in the Wincrypt.h header. CERT_CHAIN_PARA has additional members that become active only when a flag is enabled and I have not enabled it in the native code. So, i avoided adding them here.</p>

<p>The calling code is:</p>

<pre><code>CERT_CHAIN_PARA.ByReference pChainPara = new CERT_CHAIN_PARA.ByReference();
PointerByReference p = new PointerByReference();


pChainPara.cbSize = pChainPara.size();
pChainPara.RequestedUsage.dwType = WinCrypt.USAGE_MATCH_TYPE_AND;
pChainPara.RequestedUsage.Usage.cUsageIdentifier = 0;
pChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = null;


CertGetCertificateChain(null, pCertContext, null, null, pChainPara, 0, null, p);
</code></pre>

<p>The crash happens on the call to CertGetCertificateChain. One thing i've noticed it that setting pChainPara to null stops it from throwing the memory access exception and crashing. But i am not sure if this is because the pChainPara structure is corrupt or if setting null forces it to fail early and masks an issue somewhere else. I've checked the sizes of the structure passed in and they match with the sizes in the native code.</p>

<p>Please let me know if i need to provide more information. Once implemented and tested, i'll clean this up and contribute the certificate workflow's wrappers and structures to JNA.</p>

<p>Edit:
I tried adding the additional members in CERT_CHAIN_PARA as given below:</p>

<pre><code>    public static class CERT_CHAIN_PARA extends Structure {

        public int cbSize;
        public CERT_USAGE_MATCH RequestedUsage;

        public CERT_USAGE_MATCH RequestedIssuancePolicy;
        public int dwUrlRetrievalTimeout;
        public boolean fCheckRevocationFreshnessTime;
        public int dwRevocationFreshnessTime;
        public FILETIME pftCacheResync;
        public CERT_STRONG_SIGN_PARA.ByReference pStrongSignPara;
        public int dwStrongSignFlags;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            //          return Arrays.asList(""cbSize"", ""RequestedUsage"");
            return Arrays.asList(""cbSize"", ""RequestedUsage"",""RequestedIssuancePolicy"",""dwUrlRetrievalTimeout"",""fCheckRevocationFreshnessTime"",
                    ""dwRevocationFreshnessTime"",""pftCacheResync"",""pStrongSignPara"",""dwStrongSignFlags"");
        }

        public static class ByReference extends CERT_CHAIN_PARA implements Structure.ByReference {

        }
    }

    public static class CERT_STRONG_SIGN_SERIALIZED_INFO extends Structure {
        DWORD dwFlags;
        LPWSTR pwszCNGSignHashAlgids;
        LPWSTR pwszCNGPubKeyMinBitLengths;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            return Arrays.asList(""dwFlags"", ""pwszCNGSignHashAlgids"", ""pwszCNGPubKeyMinBitLengths"");
        }

        public static class ByReference extends CERT_STRONG_SIGN_SERIALIZED_INFO implements Structure.ByReference {
        }
    }

    public static class DUMMYUNIONNAME extends Union {
        Pointer pvInfo;
        CERT_STRONG_SIGN_SERIALIZED_INFO.ByReference pSerializedInfo;
        LPSTR pszOID;
    }

    public static class CERT_STRONG_SIGN_PARA extends Structure {
        public int cbSize;
        public int dwInfoChoice;

        public DUMMYUNIONNAME union;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            return Arrays.asList(""cbSize"", ""dwInfoChoice"", ""union"");
        }

        public static class ByReference extends CERT_STRONG_SIGN_PARA implements Structure.ByReference {
        }
    }

    public static class FILETIME extends Structure {

        public int dwLowDateTime;
        public int dwHighDateTime;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            return Arrays.asList(""dwLowDateTime"", ""dwHighDateTime"");
        }

        public static class ByReference extends FILETIME implements Structure.ByReference {
        }

        public static class ByValue extends FILETIME implements Structure.ByValue {
        }
    }
}
</code></pre>

<p>And the calling code was modified to set the rest of the members:</p>

<pre><code>pChainPara.RequestedIssuancePolicy.Usage.cUsageIdentifier = 0;
pChainPara.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier = null;

pChainPara.dwUrlRetrievalTimeout = 0;
pChainPara.fCheckRevocationFreshnessTime = false;
pChainPara.dwRevocationFreshnessTime = 0;
pChainPara.pftCacheResync.dwHighDateTime = 0;
pChainPara.pftCacheResync.dwLowDateTime = 0;

pChainPara.pStrongSignPara = null;
</code></pre>

<p>But I still get the failure as mentioned above.</p>

<p>Edit2:</p>

<pre><code>PCERT_CONTEXT context = CryptUIDlgSelectCertificateFromStore(store, hwnd,
                """", """", 2, 0, null);

    public static class CERT_CONTEXT extends Structure {

        public int dwCertEncodingType;
        public Pointer pbCertEncoded;
        public int cbCertEncoded;
        public Pointer pCertInfo;
        public Pointer hCertStore;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            return Arrays.asList(""dwCertEncodingType"", ""pbCertEncoded"", ""cbCertEncoded"", ""pCertInfo"", ""hCertStore"");
        }

        public static class ByReference extends CERT_CONTEXT implements Structure.ByReference {
        }
    }

    public static class PCERT_CONTEXT extends Structure {

        public CERT_CONTEXT.ByReference certContext;

        @Override
        protected List&lt;String&gt; getFieldOrder() {
            return Arrays.asList(""certContext"");
        }

        public static class ByReference extends PCERT_CONTEXT implements Structure.ByReference {
        }

        public static class ByValue extends PCERT_CONTEXT implements Structure.ByValue {
        }
    }
</code></pre>
","<p>It's quite possible that you need to define the remainder of the <code>CERT_CHAIN_PARA</code> structure, since its expected size depends on a compile-time variable (independent of what you might supply in <code>cbSize</code>).</p>

<blockquote>
  <p>Note  This member can be used only if CERT_CHAIN_PARA_HAS_EXTRA_FIELDS
  is defined by using the #define directive before including Wincrypt.h.
  If this value is defined, the application must zero all unused fields.</p>
</blockquote>

<p><strong>UPDATE</strong></p>

<p><code>PCERT_CONTEXT</code> is a typedef to <code>CERT_CONTEXT *</code>. Your Java definition will in effect make it <code>CERT_CONTEXT **</code>, at least w/r/t passing it as a parameter. If you need native <code>CERT_CONTEXT *</code>, use Java <code>CERT_CONTEXT</code> as the parameter type.  Embedding a pointer field within a struct effectively gives the callee the <em>address</em> of the value you wish to pass, rather than the pointer value you really want to pass.</p>

<p>In general you should omit the <code>&lt;Structure&gt;.ByReference</code> notation <em>unless</em> you are defining a structure field that needs to be of type <code>struct *</code>.</p>
","155","<java><jna><cryptoapi>","0","1","1","2018-01-23 16:52:31","48348729","7","","1533083","","2018-01-21 14:53:22","2018-01-19 19:51:09",""
"56464228","How to parse certificate Subject string?","<p>Using <code>CertNameToStr</code> function you can get a certificate's Subject string:</p>

<blockquote>
  <p>C=US, S=California, L=San Jose, O=""Adobe Systems, Incorporated"", OU=Digital ID Class 3 - Microsoft Software Validation v2, OU=Acrobat Engineering, CN=""Adobe Systems, Incorporated""</p>
</blockquote>

<p>My question is, how to parse it to get an array of name-value pairs?</p>

<p>I tried to use the <code>SplitString()</code> function with <code>,</code> character as a delimiter:</p>

<pre><code>  StrArr := SplitString(edtSubjectStr.Text, ',');
  for I := Low(StrArr) to High(StrArr) do
    Memo1.Lines.Append(Trim(StrArr[i]));
</code></pre>

<p>but the result is unsatisfactory:</p>

<blockquote>
  <p>C=US<br>
  S=California<br>
  L=San Jose<br>
  O=""Adobe Systems<br>
  Incorporated""<br>
  OU=Digital ID Class 3 - Microsoft Software Validation v2<br>
  OU=Acrobat Engineering<br>
  CN=""Adobe Systems<br>
  Incorporated""</p>
</blockquote>

<p>Is there any API function to parse this subject string?</p>

<p>Or maybe there is a way of parsing it with some other Delphi components|classes|functions?</p>
","<p>Here is the answer:</p>

<p>just use <code>CERT_X500_NAME_STR or CERT_NAME_STR_CRLF_FLAG</code> as the value of the <code>dwStrType</code> property of the <code>CertNameToStr()</code> function and you'll get a <code>CRLF</code> separated string!</p>
","152","<delphi><cryptoapi>","1","3","1","2019-06-06 10:16:33","56475502","6","","65863","","2019-06-05 16:09:22","2019-06-05 16:06:40",""
"18112937","Trigger an event when a new certificate is added to certificate store","<p>I am writing a windows service which can be triggered whenever a new certificate is added to the MY certificate store. It then opens the certificate store through this service and carries out some actions.</p>

<p>Is there a way to implement a callback function in the service/application which can be called by the crypto APIs when applications like mmc.exe or certreq.exe request and install a new certificate in the certificate store?</p>
","<p>Found an alternative. MY cert store certificates are written in </p>

<blockquote>
  <p>C:\Users\username\AppData\Roaming\Microsoft\SystemCertificates\My\Certificates</p>
</blockquote>

<p>Now using a directory event watcher to view newly installed certificates.</p>
","151","<windows><x509certificate><cryptoapi><certificate-store>","0","0","1","2013-08-08 22:34:43","18137355","0","","","","","2013-08-07 20:13:33",""
"16661551","Win32 CRYTO Who is responsible for certificate permissions in CERT_SYSTEM_STORE_SERVICES?","<p>My service use certificate in CERT_SYSTEM_STORE_SERVICES.
The problem is that system makes usage of CERT_SYSTEM_STORE_SERVICES very uncomfortable.
I use MMC (started as Admin) and open Local services storage for my service. Then I import certificate from file there.</p>

<p>I expect that newly created storage and certificate will have appropriate permissions for my service (runs under NETWORK_SERVICE). However neither storage itself, nor the private key have permissions for NETWORK_SERVICE initially.</p>

<p>So, my questions is: is it by design or I should avoid CERT_SYSTEM_STORE_SERVICES ?</p>
","","151","<winapi><service><permissions><cryptoapi>","1","","0","2013-05-21 03:14:10","","0","","","","","2013-05-21 03:14:10",""
"39403652","How to verify client cert installed in system","<p>I am trying to implement a multiplatform device/client certificate chck in my app.
I want to implement for Windows and Mac, so the common implementation in c++ with few platform specific code.
I have OpenSSL integrated too.</p>

<p>I have Client cert installed in Windows personal store and for Mac in login key chain.</p>

<p>I have a the CA chain as form of .pem file.</p>

<p>I wanted to get the leaf CA from Pem file using openssl, than use the issuer name and use platform specific code to get matching client cert from device.
Than I want to get the context of clinet cert and use openssl to verify againt the CA chain</p>

<p>The problem for me here is,
1. how to get the leaf from the PEM
2. How to retrive the public part of installed client cert in both Windos/mac?</p>

<p>Regards,
Birajendu</p>
","<p>here is the piece of code</p>

<pre><code>X509_STORE      *openssl_store = NULL;
X509_STORE_CTX  *vrfy_ctx = NULL;

OpenSSL_add_all_algorithms();

if (!(openssl_store=X509_STORE_new())) {
    printf(""Error creating X509_STORE_CTX object"");
    return false;
}
vrfy_ctx = X509_STORE_CTX_new();
if (NULL == vrfy_ctx) {
    printf(""X509_STORE_CTX_new failed"");
    return false;
}

if (1 != X509_STORE_load_locations(openssl_store, tmpCertFile.c_str(), NULL)) {
    printf(""Error loading CA cert or chain file"");
    return false;
}

HCERTSTORE hStore = NULL;
BYTE *pCert = NULL; 
DWORD dwCert = 0;
PCCERT_CONTEXT pCertContext = NULL;

//Open Personal Certificate Store
hStore = CertOpenSystemStore(0, TEXT(""MY""));
if (hStore == NULL) {
    printf(""CertOpenSystemStore failed, error : %d"", GetLastError());
    return false;
} 

//Enumerate Certificate Store
while (pCertContext = CertEnumCertificatesInStore(hStore, pCertContext)) {

    const unsigned char *cert_data = pCertContext-&gt;pbCertEncoded;

    X509 *cert = d2i_X509(NULL, &amp;cert_data, pCertContext-&gt;cbCertEncoded);

    X509_STORE_CTX_init(vrfy_ctx, openssl_store, cert, NULL);
    int ret = X509_verify_cert(vrfy_ctx);
    X509_STORE_CTX_cleanup(vrfy_ctx);

    if (1 == ret) {
        printf(""Matching client certificate found"");
        return true;
    }

    if (cert) {
        X509_free(cert);
    }
}
if (hStore) {
    CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
}
</code></pre>
","150","<macos><winapi><ssl><openssl><cryptoapi>","-1","0","1","2016-09-14 16:25:53","","1","","","","","2016-09-09 03:59:50",""
"44302687","CryptVerifyTimeStampSignature returning CRYPT_E_ASN1_BADTAG","<p>I am trying to verify the timestamp of a signature with the <code>CryptVerifyTimeStampSignature</code> Windows Crypto API function. I am stuggling to understand what exactly should be passed into the <code>pbTSContentInfo</code> parameter. </p>

<pre><code>BOOL CryptVerifyTimeStampSignature(
    _In_      const BYTE                     pbTSContentInfo,
                    DWORD                    cbTSContentInfo,
    _In_opt_  const DWORD                    pbData,
                    DWORD                    cbData,
    _In_opt_        HCERTSTORE               hAdditionalStore,
    _Out_           PCRYPT_TIMESTAMP_CONTEXT ppTsContext,
    _Out_opt_       PCCERT_CONTEXT           *ppTsSigner,
    _Out_opt_       HCERTSTORE               *phStore
);
</code></pre>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/dd433804(v=vs.85).aspx"" rel=""nofollow noreferrer"" title=""MSDN"">MSDN</a> documentation states that <code>pbTSContentInfo</code> should contain:</p>

<blockquote>
  <p>A pointer to a buffer that contains time stamp content.</p>
</blockquote>

<p>I am unsure what exactly this pointer should point to and where I can retrieve it from. The signature I am validating is an Authenticode signature on an executable. So far I have tried passing the encoded message returned by <code>CryptMsgGetParam</code> however this returns CRYPT_E_ASN1_BADTAG.</p>

<p>Thanks to anyone who can help! </p>
","","145","<c++><windows><winapi><cryptoapi><authenticode>","0","","0","2017-06-01 08:46:26","","5","","","","","2017-06-01 08:46:26",""
"32208100","Do Windows crypto APIs run slower on purpose with debugger attached to the process?","<p>In my Windows application I needed to implement the <a href=""https://en.wikipedia.org/wiki/PBKDF2"" rel=""nofollow"">PBKDF2</a> encryption for passwords. For that I needed to calculate <a href=""https://en.wikipedia.org/wiki/Hash-based_message_authentication_code"" rel=""nofollow"">HMAC</a> using SHA-256 many times over. So for a single round of that I was calling the following sequence of APIs:</p>

<pre><code>//For simplicity I'm not posting the full code
//One can look up implementation of HMAC/SHA-256 in C
CryptAcquireContext(, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_NEWKEYSET);
CryptImportKey(, , 0, CRYPT_IPSEC_HMAC_KEY, );
CryptCreateHash(, CALG_HMAC, , 0, );
CryptSetHashParam(, HP_HMAC_INFO, , 0);
CryptHashData(, , , 0);
CryptGetHashParam(, HP_HASHVAL, NULL, , 0);
CryptGetHashParam(, HP_HASHVAL, , , 0);
</code></pre>

<p>This sequence may be called on the order of 10,000+ times in a sort of a loop according to PBKDF2 specifications.</p>

<p>I started noticing though, that if I run this sequence via Ctrl+F5 (in Visual Studio), or without a debugger, it executes in about less than 1 sec on my laptop. But if I attach a debugger to the process, it runs painfully slow -- sometimes close to 10+ seconds or so. (The timing in this case is also inconsistent.)</p>

<p>So I thought that this happens because of a debugger build. So I tried building a release build and then attached a debugger. To my amazement it was also running slow.</p>

<p>So I'm curious, is there something in those crypto APIs that make them run slower with the debugger attached?</p>
","<blockquote>
  <p>I just tried it and if I attach Visual Studio debugger to my running process, it doesn't seem to happen.</p>
</blockquote>

<p>Then it depends from the Windows debug heap (not to be confused with the CRT debug heap, which is completely unrelated and is activated building in debug mode):</p>

<blockquote>
  <p>Instead of using the standard heap API, processes that the debugger creates use a special debug heap. You can force a spawned process to use the standard heap instead of the debug heap by using the <code>_NO_DEBUG_HEAP</code> environment variable or the <code>-hd</code> command-line option.</p>
</blockquote>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/hardware/hh406274%28v=vs.85%29.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/hardware/hh406274%28v=vs.85%29.aspx</a></p>

<p>For a more detailed explanation and some benchmarks, see <a href=""http://preshing.com/20110717/the-windows-heap-is-slow-when-launched-from-the-debugger/"" rel=""nofollow"">here</a>.</p>
","143","<c++><c><winapi><hmac><cryptoapi>","1","1","1","2015-08-26 07:09:07","","2","","","","","2015-08-25 15:29:09",""
"24367022","How to set to use DPAPI or not?","<p>I learn about WIN API methods responsible for secure storage. I read about CryptoAPI and DPAPI: </p>

<blockquote>
  <p>""The public DPAPI interfaces are part of Crypt32.dll and are available
  for any user process that has loaded it. This DLL is part of
  CryptoAPI.""</p>
</blockquote>

<p>So when I want to use <code>CryptProtectData</code> I call <code>CryptProtectData</code> from <code>Crypt32.dll</code>. But when I want to use DPAPI I must call <code>CryptProtectData</code> from <code>Crypt32.dll</code> too. How can I set to use DPAPI or not,  to use CryptoAPI or not?</p>

<p>EDIT: How can I know what I do not use DPAPI? And how can I ""say"" a program to use DPAPI?</p>
","","142","<winapi><cryptoapi><dpapi>","0","","0","2014-06-23 13:45:39","","5","","3186861","","2014-06-23 13:45:39","2014-06-23 13:19:27",""
"20377595","Avoid CryptoAPI HTTPS certificate chain check during WCF client request","<p>I do a WCF client call over a secured connection (HTTPS). This call takes very much time (about 30 to 40 seconds). Then I get a chain trust exception.</p>

<p>So i added the following code to ignore this error:</p>

<pre><code>System.Net.ServicePointManager.ServerCertificateValidationCallback = 
    (a, b, c, d) =&gt; true;
</code></pre>

<p>The call works now without an exception - but it's still very slow. During investigation using Fiddler I recognized that there where four additional HTTP requests which all times out. The last call is the call from my request which works.</p>

<p>So I know the reason for the delay.</p>

<p>Fiddler shows ""CryptoAPI"" as the user agent for the additional calls. I know that CryptoAPI tries to resolve the certificate chain by downloading the missing certificates - but the host isn't available.</p>

<p>I know, I can manually install all needed certificates to the certificate store. Then it works and the additional requests are gone.</p>

<p>But I wonder if is it also possible to disable the certificate chain check via CryptoAPI? It's an intranet service and therefore the check isn't really important.</p>
","","141","<wcf><https><request><certificate><cryptoapi>","1","","0","2013-12-04 14:33:40","","0","","2894974","","2013-12-04 14:33:40","2013-12-04 14:11:13",""
"48511954","Porting code from CryptoAPI to CNG","<p>I started writing code in CryptoAPI in unmananaged C++ to:</p>

<ol>
<li>Create private keys</li>
<li>Create self signed certificate (CA)</li>
<li>Create CSRs</li>
<li>Process CSRs and sign with private CA to make certificates
So most of the PKI...CryptoAPI is being depreciated so now I now port it all to CNG before the ship sinks. This provides mostly reference information:</li>
</ol>

<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/bb204779(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/bb204779(v=vs.85).aspx</a></p>

<p>But what are the major architectural differences and gotchas? From what I can tell they splitted out some of the provider/agorithm stuff and changed function names to make it work better with FIPS but that's all that stood out. What do I need to look out for? There are hardly any CNG code samples.</p>
","","141","<cryptoapi><cng>","1","","0","2018-01-30 00:01:29","","0","","","","","2018-01-30 00:01:29",""
"32906357","How to find the correct certificate when decdrypting with Crypt32 in c#?","<p>I try to decrypt an ecrypted file. Sender sent 2 files, one from pord one from test environment. I can decrypt the prod version, but i can't decrypt the test version.</p>

<p>When try to decrypt the good verison, my tool use my certificate to decrypt, but when i try to decrypt the wrong version, it try to use the sender's certificate to decrypt. (But i haven't the private key of the sender, ofcourse :) )</p>

<p>I said to sender, You do something wrong, but he said, the prod and test is same, he sees the both sign on the files, i try to use the wrong cert.</p>

<p>But i don't know how can i use the good cert?</p>

<p>I use Crypt32.dll from C#, here is the simplified code:</p>

<pre><code>// Prepare stream for encoded info
m_callbackFile = decodedFile;

// Set callback for streaming
StreamInfo = Win32.CreateStreamInfo( (int) encodedFile.Length, new Win32.StreamOutputCallbackDelegate( StreamOutputCallback ) );

// Open message to encode
m_hMsg = Win32.OpenMessageToDecode( StreamInfo );

     // Open message to decode: call API:
    hMsg = CryptMsgOpenToDecode(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        bDetached ? CMSG_DETACHED_FLAG : 0,
        0,
        IntPtr.Zero,
        IntPtr.Zero,
        ref StreamInfo
    );

// Process the whole message
Win32.ProcessMessage( m_hMsg, encodedFile );

    // ProcessMessage: read file from piece to piece, and call API:
    bResult = CryptMsgUpdate(
        hMsg.DangerousGetHandle(),
        new IntPtr( pAux ),
        pbData.Length,
        bFinal
    );


// With enveloped messages we have to verify that we got a valid encryption algorithm
Win32.CheckEnvelopeAlg( m_hMsg );

    // CheckEnvelopeAlg: read the crypth algorithm id from message
    bResult = CryptMsgGetParam(
        hMsg,
        dwParamType, // 15 - CMSG_ENVELOPE_ALGORITHM_PARAM
        dwIndex,
        pParam,
        ref cbParam
    );
    // result is:
    AlgId = (CRYPT_ALGORITHM_IDENTIFIER) Marshal.PtrToStructure( pEnvelopeAlg.DangerousGetHandle(), typeof( CRYPT_ALGORITHM_IDENTIFIER ) );
    // ""2.16.840.1.101.3.4.1.2""


// Decrypt the message
Win32.Decrypt( m_hMsg );
    // Get recipient cert
    bResult = CryptMsgGetParam(
        hMsg,
        dwParamType, // 19 - CMSG_RECIPIENT_INFO_PARAM
        dwIndex,
        pParam,
        ref cbParam
    );
    // return with SafeNTHeapHandle pCertInfo

    // Open personal cert store
  hStore = CertOpenSystemStore(
      IntPtr.Zero,
      ""MY""
    );

  CERT_INFO certInfo = (CERT_INFO) Marshal.PtrToStructure( pCertInfo.DangerousGetHandle(), typeof( CERT_INFO ) );
    // we can read the serial of the cert from this certInfo
    // this serial is our certificate in the prod case, but this serial is the sender's certificate in the uatcase!
</code></pre>

<p>What i did wrong? How can i decrypt the both file?
(I try to find a tool to watch/analyze the encrypted file under windows, but didn't find any useful tool :( Can You suggest one? :) )</p>
","<p>Problem is: more than 1 ""recipients"" are on the file.
i did a loop, where i try to read the current ""recipient's"" certificate (and its private key), but take the next ""recipient"" when it failed.</p>

<pre><code>// GetCountOfKeyTransferRecipients
            GetMessageParam( hMsg, Win32.CMSG_RECIPIENT_COUNT_PARAM, out pRecipientsCount );
            Int32 recipientsCount = (Int32) Marshal.ReadInt32( pRecipientsCount.DangerousGetHandle() );

            Logger.Log( ""Recipientek száma:"" + recipientsCount.ToString(), Logger.Level.ERROR );
            Boolean succes = false;
            Int32 recipientIndex = 0;
            for (recipientIndex = 0; recipientIndex &lt; recipientsCount; recipientIndex++)
            {
                succes = GetCertificateFromStore( hMsg, recipientIndex, out KeyProvInfo ); // try-catch is inside...
                if (succes)
                {
                    break;
                }
            }
            if (!succes)
            {
                throw new Exception( ""Get message certificate failed! See previous errors in the log file."" );
            }
</code></pre>
","141","<c#><encryption><cryptoapi>","0","0","1","2015-10-06 08:53:53","","0","","","","","2015-10-02 11:37:54",""
"41768523","Unhandled exception calling CertCreateCertificateChainEngine function","<p>I'm following this tutorial from Microsoft <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa382042(v=vs.85).aspx"" rel=""nofollow noreferrer"">Example C Program: Creating a Certificate Chain</a></p>

<p>But I get Unhandled exception calling CertCreateCertificateChainEngine function at the following block</p>

<pre><code>if(CertCreateCertificateChainEngine(
     &amp;ChainConfig,
     &amp;hChainEngine)) {

    printf(""A chain engine has been created.\n"");
}
else {

    MyHandleError(""The engine creation function failed."");
}
</code></pre>

<p>Exception message is:</p>

<pre><code>Unhandled exception at 0x7535F61A (crypt32.dll) in capi_verify.exe: 0xC0000005: Access violation writing location 0xCCCCCCD0.
</code></pre>

<p>Here is how the variables are defined:</p>

<pre><code>HCERTCHAINENGINE         hChainEngine = NULL;
CERT_CHAIN_ENGINE_CONFIG ChainConfig;
</code></pre>

<p>and the ChainConfig struct is initialized as:</p>

<pre><code>ChainConfig.cbSize = sizeof(CERT_CHAIN_ENGINE_CONFIG);
ChainConfig.hRestrictedRoot= NULL ;
ChainConfig.hRestrictedTrust= NULL ;
ChainConfig.hRestrictedOther= NULL ;
ChainConfig.cAdditionalStore=0 ;
ChainConfig.rghAdditionalStore = NULL ;
ChainConfig.dwFlags = CERT_CHAIN_CACHE_END_CERT;
ChainConfig.dwUrlRetrievalTimeout= 0 ;
ChainConfig.MaximumCachedCertificates=0 ;
ChainConfig.CycleDetectionModulus = 0;
</code></pre>

<p>CertCreateCertificateChainEngine function has the following signature:</p>

<pre><code>BOOL WINAPI CertCreateCertificateChainEngine(
  _In_  PCERT_CHAIN_ENGINE_CONFIG pConfig,
  _Out_ HCERTCHAINENGINE          *phChainEngine
);
</code></pre>

<p>And here is the debug screenshot of ChainConfig:</p>

<p><a href=""https://i.stack.imgur.com/fyI24.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/fyI24.png"" alt=""ChainConfig""></a></p>

<p>hChainEngine is shown as NULL e.g. 0x00000000</p>
","<p>I figured the cause of this exception. The problem was that due to changes have been made after windows 7 we should initialize hExclusivrTrustPeople and hExclusiveRoot members too. So the mentioned article is sort of outdated for newer windows systems</p>
","139","<c><visual-c++><cryptoapi>","0","0","1","2017-09-27 12:01:36","","0","","","","","2017-01-20 16:45:01",""
"10541262","CA Pinning with CryptoAPI","<p>I'm validating an SSL server certificate using CryptoAPI (CertGetCertificateChain and CertVerifyCertificateChainPolicy specifically).</p>

<p>I would like to limit which CAs I will accept signatures from, aka CA Pinning.</p>

<p>Is there a way to do this shy of having my own code compare the root cert against a list of acceptable certificates?</p>
","","138","<windows><pki><cryptoapi>","1","","0","2012-05-10 19:59:56","","1","","","","","2012-05-10 19:59:56",""
"34717845","Deprecated function from wincrypt","<p>What does it mean that a function, in particular <code>CryptExportPKCS8</code> is deprecated? 
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379932(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa379932(v=vs.85).aspx</a></p>

<p>I'm aware that one can't use it with newer version of <code>wincrypt</code> just because it is not present in header file, but can a program based on old <code>wincrypt.h</code> and <code>crypt32.lib</code> still retrieve private key from certificate store in Windows 10? Or is it impossible to access such data without using more up-to-date API?</p>
","<p>Deprecated means ""going away, change your code"".  In this case, it appears that MS wants you to use <code>PFXExportCertStoreEx()</code> instead.</p>
","130","<c><cryptoapi><certificate-store><wincrypt>","0","-1","1","2016-01-11 09:50:31","","0","","4658000","","2016-01-11 09:34:42","2016-01-11 09:20:49",""
"32516025","Slow key enumeration in a machine RSA key container","<p>I need to enumerate keys in the machine key container. Although this is generally an optional provider function, both <code>MS_STRONG_PROV</code> and <code>MS_ENH_RSA_AES_PROV</code> support it. I do not think I am doing anything wrong or unusual: first, acquiring a context handle with <code>CryptAcquireContext(...   CRYPT_MACHINE_KEYSET | CRYPT_VERIFYCONTEXT ...)</code>, then calling <code>CryptGetProvParam(... PP_ENUMCONTAINERS ...)</code> repeatedly until the enumeration is exhausted:</p>

<pre><code>void enum_keys(HCRYPTPROV hprov) {
  BYTE buf[1024];  // Max key name length we support.
  for (DWORD first_next = CRYPT_FIRST; 1; first_next = CRYPT_NEXT) {
    DWORD buf_len = sizeof buf;
    if (!CryptGetProvParam(hprov, PP_ENUMCONTAINERS, buf, &amp;buf_len, first_next)) {
      if (GetLastError() == ERROR_NO_MORE_ITEMS) break;
      else exit(1);
    }
  }
}

void do_benchmark(DWORD enum_flags) {
  enum_flags |= CRYPT_VERIFYCONTEXT;
  HCRYPTPROV hprov;
  if (!CryptAcquireContext(&amp;hprov, NULL, MS_ENH_RSA_AES_PROV_A,
                           PROV_RSA_AES, enum_flags))
    exit(1);

  int K = 100;
  ClockIn();  // Pseudocode
  for (int i = 0; i &lt; K; ++i)
    enum_keys (hprov);
  ClockOut();  // Pseudocode.
  printf("" %f ms per pass\n"", TimeElapsed() / K);

  CryptReleaseContext(hprov, 0);
}

void main() {
  printf(""--- User key store access performance test... "");
  do_benchmark(0);
  printf(""--- Machine key store access performance test... "");
  do_benchmark(CRYPT_MACHINE_KEYSET);
}
</code></pre>

<p>To benchmark the enumeration, I am leaving context acquisition and release out of the loop, and clocking only the enumeration, and repeat the enumeration 100 times. What I am noticing is that the enumeration is significantly slower for a normal user than an administrator. When I run the test as myself (member of Administrators with UAC enabled), I am getting </p>

<pre><code>--- User key store access performance test...  3.317211 ms per pass
--- Machine key store access performance test...  78.051593 ms per pass
</code></pre>

<p>However, when I run the same test from an elevated prompt, the result is dramatically different:</p>

<pre><code>--- User key store access performance test...  3.279580 ms per pass
--- Machine key store access performance test...  1.499939 ms per pass
</code></pre>

<p>Under the hood, more keys are reported to an admin than to non-admin user, but that's expected and normal. What I do not understand is why the enumeration is ~40 times slower for a non-admin user. Any pointers?</p>

<p>I am putting the full <a href=""https://gist.github.com/kkm000/8fc78dd6861354d96e8c"" rel=""nofollow"">source of my test into a Gist</a>. The test is run on a pretty generic Windows 7 machine without any crypto hardware.</p>

<p><strong>Added</strong>: on a Server 2012 virtual machine on a Server 2012 HyperV host, the slowdown factor was even greater, over 130: 440 vs 3.3 ms. 440ms is a performance issue for me, indeed.</p>
","<p>Could it be related to this issue from Microsoft:</p>

<p><a href=""https://support.microsoft.com/en-us/help/2302077/you-experience-poor-performance-when-you-call-the-cryptacquirecontext-function-in-windows-server-2008-r2-or-in-windows-7"" rel=""nofollow noreferrer"">You experience poor performance when you call the CryptAcquireContext function in Windows Server 2008 R2 or in Windows 7</a></p>

<p>From the issue:
""This issue occurs because of a change in the CryptAcquireContext function in Windows Server 2008 R2 and in Windows 7.</p>

<p>This change checks whether the function runs in a domain environment. However, the process is time-consuming and causes the increased running time of the CryptAcquireContext function.""</p>
","129","<winapi><cryptoapi><mscapi>","0","0","1","2017-05-29 12:03:15","","6","","1149924","","2015-09-11 20:27:43","2015-09-11 05:22:15",""
"31309853","Crypto librarys in Mono not found","<p>I have a problem compiling a C# program with mono in Ubuntu 14.04, mono version: 3.2.8. It tells me that the Crypto Library ECDiffieHellmanCng and the ECDsaCng references are missing. 
I found out that they are not implemented in mono yet. I tried this reference design from Microsoft:
<a href=""http://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/ECDsaCng.cs,27778745e2b25dfa"" rel=""nofollow"">http://referencesource.microsoft.com/#System.Core/System/Security/Cryptography/ECDsaCng.cs,27778745e2b25dfa</a>
But a lot of libraries are missing afterwards, and it gets a never ending story. (I added a lot bet then it says that some stuff is already implemented in the namespace)
Do you have any ideas what I could try else?
Should I just compile it with MS and then try it with Wine? </p>
","","126","<c#><mono><cryptoapi>","1","","0","2015-07-09 06:37:50","","5","","","","","2015-07-09 06:37:50",""
"57624159","Delphi & CryptoAPI - how to calculate HMAC-SHA512 hash?","<p>Does anybody know how to calculate a HMAC-SHA512 hash in Delphi 2010+ using MS CryptoAPI ?  </p>

<p>The example from MS website, <a href=""https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program--creating-an-hmac"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program--creating-an-hmac</a> generates incorrect results.</p>

<p>I have found this answer <a href=""https://stackoverflow.com/a/41387095/2111514"">https://stackoverflow.com/a/41387095/2111514</a> to be somehow usefull (because it is manual rewrite from <a href=""https://en.wikipedia.org/wiki/HMAC"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/HMAC</a>), but it is not in Pascal and my attempt to refactor it to Pascal was without luck. It works, but still calculates wrong results.  </p>

<p>Can anybody help me, please?</p>

<p><strong>Edit::</strong> This is my code that I have problem with:</p>

<pre><code>uses
  Windows,
  JwaWinCrypt,
  JwaWinError;

const
  BLOCK_SIZE = 64;

type
  EHMACError = class(Exception);

function WinError(const RetVal: BOOL; const FuncName: String): BOOL;
var
  dwResult: Integer;
begin
  Result:=RetVal;
  if not RetVal then begin
    dwResult:=GetLastError();
    raise EHMACError.CreateFmt('Error [x%x]: %s failed.'#13#10'%s', [dwResult, FuncName, SysErrorMessage(dwResult)]);
  end;
end;

function TBytesToHex(const Value: TBytes): String;
const
  dictionary: Array[0..15] of Char = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
var
  i: Integer;
begin
  Result:='';
  for i:=0 to High(Value) do
    Result:=Result + dictionary[Value[i] shr 4] + dictionary[Value[i] and $0F];
end;

function hmac(AKey, AMessage: TBytes; Algid: ALG_ID): TBytes;

  function hash(const hProv: HCRYPTPROV; hData: TBytes): TBytes;
  var
    len, cb: DWORD;
    hHash: HCRYPTHASH;
  begin
    SetLength(Result, 0);
    WinError(CryptCreateHash(hProv, Algid, 0, 0, hHash), 'CryptCreateHash');
    try
      len:=Length(hData);
      cb:=SizeOf(len);
      WinError(CryptHashData(hHash, @hData[0], len, 0), 'CryptHashData');
      WinError(CryptGetHashParam(hHash, HP_HASHSIZE, @len, cb, 0), 'CryptGetHashParam(HP_HASHSIZE)');
      SetLength(Result, len);
      WinError(CryptGetHashParam(hHash, HP_HASHVAL, @Result[0], len, 0), 'CryptGetHashParam(HP_HASHVAL)');
    finally
      WinError(CryptDestroyHash(hHash), 'CryptDestroyHash');
    end;
  end;

  function double_hash(const hProv: HCRYPTPROV; hData1, hData2: TBytes): TBytes;
  var
    len, len1, len2, cb: DWORD;
    hHash: HCRYPTHASH;
  begin
    SetLength(Result, 0);
    WinError(CryptCreateHash(hProv, Algid, 0, 0, hHash), 'DH_CryptCreateHash');
    try
      len1:=Length(hData1);
      len2:=Length(hData2);
      cb:=SizeOf(DWORD);
      WinError(CryptHashData(hHash, @hData1[0], len1, 0), 'DH_CryptHashData(hData1)');
      WinError(CryptHashData(hHash, @hData2[0], len2, 0), 'DH_CryptHashData(hData1)');
      WinError(CryptGetHashParam(hHash, HP_HASHSIZE, @len, cb, 0), 'DH_CryptGetHashParam(HP_HASHSIZE)');
      SetLength(Result, len);
      WinError(CryptGetHashParam(hHash, HP_HASHVAL, @Result[0], len, 0), 'DH_CryptGetHashParam(HP_HASHVAL)');
    finally
      WinError(CryptDestroyHash(hHash), 'DH_CryptDestroyHash');
    end;
  end;

var
  hProv: HCRYPTPROV;
  hHash: HCRYPTHASH;
  i_key_pad, o_key_pad: TBytes;
  data, ret: TBytes;
  len, i: Integer;
  c: Byte;
  ifree: Boolean;
begin
  ifree:=False;
  SetLength(Result, 0);
  SetLength(i_key_pad, BLOCK_SIZE);
  SetLength(o_key_pad, BLOCK_SIZE);
  WinError(CryptAcquireContext(hProv, Nil, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT), 'CryptAcquireContext');
  try
    data:=AKey;
    len:=Length(data);
    if len &gt; BLOCK_SIZE then begin
      data:=hash(hProv, data);
      ifree:=True;
    end;
    //
    i:=BLOCK_SIZE-1;
    while i &gt;= 0 do begin
      if i &lt; len then
        c:=data[i]
      else
        c:=0;
      i_key_pad[i]:=$36 xor c;
      o_key_pad[i]:=$5c xor c;
      Dec(i);
    end;
    data:=double_hash(hProv, i_key_pad, AMessage);
    Result:=double_hash(hProv, o_key_pad, data);
    SetLength(data, 0);
  finally
    if ifree then
      SetLength(data, 0);
    SetLength(i_key_pad, 0);
    SetLength(o_key_pad, 0);
    WinError(CryptReleaseContext(hProv, 0), 'CryptReleaseContext');
  end;
end;
</code></pre>

<p>...and it is called by:</p>

<pre><code>Result:=hmac(Password, InString, CALG_SHA_512);
</code></pre>

<p>Example:</p>

<p><code>TBytesToHex(hmac('pass', 'test', CALG_SHA_512));</code> produces (HEX encoded)</p>

<blockquote>
  <p>1319bb7baefc3fbaf07824261c240cecd04a54cd83cdf0deb68e56cadff20e7c644e2e956660ab9df47a19502173090df5ec3d0b9236d59917afc4f3607cf980</p>
</blockquote>

<p>whereas <a href=""https://www.freeformatter.com/hmac-generator.html"" rel=""nofollow noreferrer"">online HMAC calculator</a> produces</p>

<blockquote>
  <p>46beca277a5fec10beba65b0c2fb3917115f352eb8b2560e9ada0a3dbafb6c7a3fc456b1e13a07c4a9c856b633b70b2403907ca89894021772393e3f97e78684</p>
</blockquote>

<p>for the same input</p>
","<p>The whole working solution to my question, thanks to @whosrdaddy for helping.</p>

<pre><code>//
// HMAC-SHA512 - cryptoapi hash generation
//
// based on:
//   https://en.wikipedia.org/wiki/HMAC
//   https://github.com/ogay/hmac
//
// refactored from:
//   https://stackoverflow.com/questions/41384395/wrong-result-for-base64-string-of-hmac-sha1-using-crypto-api/41387095#41387095
//
unit CryptoAPI_HMAC_SHA512;

interface

uses
  SysUtils,
  Classes;

function CryptoAPI_Hash_HmacSHA512(const InString, Password: TBytes): TBytes; overload;
function CryptoAPI_Hash_HmacSHA512(const InString, Password: String): String; overload;

implementation

uses
  Windows,
  JwaWinCrypt,
  JwaWinError;

const
  BLOCK_SIZE  = 128; // bytes for SHA512

type
  EHMACError = class(Exception);

function WinError(const RetVal: BOOL; const FuncName: String): BOOL;
var
  dwResult: Integer;
begin
  Result:=RetVal;
  if not RetVal then begin
    dwResult:=GetLastError();
    raise EHMACError.CreateFmt('Error [x%x]: %s failed.'#13#10'%s', [dwResult, FuncName, SysErrorMessage(dwResult)]);
  end;
end;

function hmac(AKey, AMessage: TBytes; Algid: ALG_ID): TBytes;

  function hash(const hProv: HCRYPTPROV; hData1, hData2: TBytes): TBytes;
  var
    len, len1, len2, cb: DWORD;
    hHash: HCRYPTHASH;
  begin
    SetLength(Result, 0);
    WinError(CryptCreateHash(hProv, Algid, 0, 0, hHash), 'CryptCreateHash');
    try
      len:=0;
      len1:=Length(hData1);
      len2:=Length(hData2);
      cb:=SizeOf(DWORD);
      WinError(CryptHashData(hHash, @hData1[0], len1, 0), 'CryptHashData(hData1)');
      if len2 &gt; 0 then
        WinError(CryptHashData(hHash, @hData2[0], len2, 0), 'CryptHashData(hData1)');
      WinError(CryptGetHashParam(hHash, HP_HASHSIZE, @len, cb, 0), 'CryptGetHashParam(HP_HASHSIZE)');
      SetLength(Result, len);
      WinError(CryptGetHashParam(hHash, HP_HASHVAL, @Result[0], len, 0), 'CryptGetHashParam(HP_HASHVAL)');
    finally
      WinError(CryptDestroyHash(hHash), 'CryptDestroyHash');
    end;
  end;

var
  hProv: HCRYPTPROV;
  i_key_pad, o_key_pad: TBytes;
  data: TBytes;
  emptyArray: TBytes;
  len, i: Integer;
  c: Byte;
  ifree: Boolean;
begin
  ifree:=False;
  SetLength(Result, 0);
  SetLength(emptyArray, 0);
  SetLength(i_key_pad, BLOCK_SIZE);
  SetLength(o_key_pad, BLOCK_SIZE);
  WinError(CryptAcquireContext(hProv, Nil, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, CRYPT_VERIFYCONTEXT), 'CryptAcquireContext');
  try
    data:=AKey;
    len:=Length(data);
    if len &gt; BLOCK_SIZE then begin
      data:=hash(hProv, data, emptyArray);
      len:=Length(data);
      ifree:=True;
    end;
    //
    i:=BLOCK_SIZE-1;
    while i &gt;= 0 do begin
      c:=0;
      if i &lt; len then
        c:=data[i];
      i_key_pad[i]:=$36 xor c;
      o_key_pad[i]:=$5c xor c;
      Dec(i);
    end;
    if ifree then
      SetLength(data, 0);
    data:=hash(hProv, i_key_pad, AMessage);
    Result:=hash(hProv, o_key_pad, data);
    SetLength(data, 0);
  finally
    SetLength(i_key_pad, 0);
    SetLength(o_key_pad, 0);
    WinError(CryptReleaseContext(hProv, 0), 'CryptReleaseContext');
  end;
end;

function TBytesToHex(const Value: TBytes): String;
const
  dictionary: Array[0..15] of Char = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
var
  i: Integer;
begin
  Result:='';
  for i:=0 to High(Value) do
    Result:=Result + dictionary[Value[i] shr 4] + dictionary[Value[i] and $0F];
end;

// source: https://stackoverflow.com/a/26892830/2111514
function MBCSString(const s: UnicodeString; CodePage: Word): RawByteString;
var
  enc: TEncoding;
  bytes: TBytes;
begin
  enc:=TEncoding.GetEncoding(CodePage);
  try
    bytes:=enc.GetBytes(s);
    SetLength(Result, Length(bytes));
    Move(Pointer(bytes)^, Pointer(Result)^, Length(bytes));
    SetCodePage(Result, CodePage, False);
  finally
    enc.Free;
  end;
end;

function UnicodeStringToTBytes(const Value: String): TBytes;
var
  ansi: AnsiString;
begin
  ansi:=MBCSString(Value, 65001); // Unicode (UTF-8) codepage
  Result:=BytesOf(ansi);
  ansi:='';
end;

function CryptoAPI_Hash_HmacSHA512(const InString, Password: TBytes): TBytes;
begin
  SetLength(Result, 0);
  if Length(Password) = 0 then
    raise EHMACError.Create('Error: Password length must be greater then 0!');

  Result:=hmac(Password, InString, CALG_SHA_512);
end;

function CryptoAPI_Hash_HmacSHA512(const InString, Password: String): String;
var
  input_bytes, input_password: TBytes;
begin
  input_bytes:=UnicodeStringToTBytes(InString);
  input_password:=UnicodeStringToTBytes(Password);
  try
    Result:=TBytesToHex(CryptoAPI_Hash_HmacSHA512(input_bytes, input_password));
  finally
    SetLength(input_password, 0);
    SetLength(input_bytes, 0);
  end;
end;

end.
</code></pre>
","126","<delphi><hash><delphi-2010><hmac><cryptoapi>","0","0","1","2019-08-28 10:16:01","57627897","10","","2111514","","2019-08-23 13:41:31","2019-08-23 10:13:39",""
"45427873","Is there any vb6 library that uses hkdf and sha-512","<p>I am encrypting my data using AES-128 CBC. However it is decrypted by another software CodeIgnitor, which actually converts password into 2 elements. <strong>HMAC key</strong> and <strong>encryption_key</strong> using hkdf and SHA-512 digest.</p>

<p>How can i implement this thing in my code. (I am using VB 6)</p>

<p>Re-phrasing my question: How is password converted into 2 elements HMAC_key and encryption_key?</p>

<hr>

<p>Let's see if I can explain further..</p>

<p>Encryption software used is <a href=""https://www.di-mgt.com.au/properpassword.html#vbnet2vb6"" rel=""nofollow noreferrer"">CryptoSys</a> while decryptionis done by <a href=""https://www.codeigniter.com/user_guide/libraries/encryption.html"" rel=""nofollow noreferrer"">CodeIgnitor</a>..which is not working</p>

<p>So the difference I can see between the two is that codeignitor is expecting an HMAC authmessage when decrypting while the encryption does not prepend it the final message. So how can i do that? I am using VB6 for encryption.</p>

<hr>

<p>So far I have come to the conclusion that there could be 2 key-derivation function a pb-kdf or a h-kdf.</p>

<p>The h-kdf authentication in particular works as follows:</p>

<ol>
<li>A password is enterd by user</li>
<li>Based on this password and a random IV, an HMAC key is generated using HKDF and SHA-512 digest algo.</li>
<li>This HMAC key is saved and also expanded and then using IV/salt encrypts the plaintext message.</li>
<li>The IV is pre-pended to the plain-text message and base64 encoded.</li>
<li>The HMAC key is then pre-pended to the final message gereated in step 4.</li>
</ol>

<p>So basically hkdf does not convert a key into 2 elements but only uses the basic key generated to generate other keys (and HMAC key is the original key used to generate other keys) now my question becomes...</p>

<p>Is there any vb6 library that uses hkdf and sha-512? As far as i have researched, Chilkat and CryptoSys APIs are only pbkdf based..Am I correct?</p>
","","125","<codeigniter><encryption><aes><hmac><cryptoapi>","0","","0","2017-08-02 03:27:21","","2","","6412823","","2017-08-02 03:27:21","2017-08-01 02:08:30",""
"45211765","CryptoAPI RSA Schannel Provider error","<p>I am trying to generate digital signature using ""Microsoft RSA SChannel Cryptographic Provider"". After acquiring the handle to container, I am generating a signature using CryptGenKey(). But this function returns FALSE. </p>

<p>The dwError for CryptGenKey() returns 80090008.</p>

<p>The same works for any other provider type. Also, when I am trying to create key exchange pair for the same provider, it is working fine. What am I doing wrong?</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;

int main()
{
    HCRYPTPROV phProv = 0;
    LPTSTR pszContainer = NULL;
    DWORD dwFlags = 0;
    bool flag;
    DWORD_PTR dwError;
    HCRYPTKEY phKey;

    flag = CryptAcquireContext(&amp;phProv, pszContainer,
        MS_DEF_RSA_SCHANNEL_PROV, PROV_RSA_SCHANNEL, dwFlags);
    if (!flag)
    {
        flag = CryptAcquireContext(&amp;phProv, pszContainer,
            MS_DEF_RSA_SCHANNEL_PROV, PROV_RSA_SCHANNEL, CRYPT_NEWKEYSET);
    }
    dwError = GetLastError();

    flag = CryptGenKey(phProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &amp;phKey);
    dwError = GetLastError();

    flag = CryptGetUserKey(phProv, AT_SIGNATURE, &amp;phKey);
    dwError = GetLastError();

    return 0;
}
</code></pre>

<p>Thanks.</p>
","<p>The SChannel provider doesn't support <code>AT_SIGNATURE</code> RSA keys, only <code>AT_EXCHANGE</code>.  It's mainly a holdover from early TLS (back when it was still SSL) when keys were exchanged using RSA encryption instead of agreed upon using Diffie-Hellman Key Agreement signed with RSA signature... and then, presumably ""well, everybody knows how the SChannel provider behaves, why change it?"".  (The closest I see to that being written down is <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa387690(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/aa387690(v=vs.85).aspx</a>, which shows CALG_RSA_KEYX and doesn't talk about CALG_RSA_SIGN.)</p>

<p>In CAPI an <code>AT_EXCHANGE</code> key can do both encryption and signing, and an <code>AT_SIGNATURE</code> key can only do signing.</p>

<p>In general the Windows Cryptography team discourages new code written with CAPI (I don't have written evidence othen than what I just wrote; mainly this has come from being in meetings with them).  CNG has a much more developer-friendly API, and is more powerful.  CNG shipped back in in Windows Vista, and so it's available in every supported version of Windows.  CAPI doesn't serve the purpose of ""well, it has more coverage"" anymore, it's just ""the old, crufty, legacy API"" (unless you're writing code for out-of-support OSes, like XP).</p>

<p>If you are using CAPI, I don't know why you'd want to use the SChannel provider.  PROV_RSA_AES via MS_ENH_RSA_AES_PROV is the most functional RSA that CAPI has (SHA-2 based PKCS signatures).  But it's out of date compared to the software provider in CNG (PSS signature, OAEP with SHA-2, and supports public exponent values larger than 2^32 (okay, that's not a common need, but it's something CNG fixed)).</p>
","121","<c><rsa><provider><cryptoapi><schannel>","0","1","1","2017-07-21 15:35:48","45241569","0","","238704","","2017-07-20 11:36:28","2017-07-20 10:12:31",""
"27802413","How to query the root certificate?","<p>I have a file. This file is digitally signed with our companys certificate. This certificate, has a countersignature (for example by Microsoft ). However this certificate also has a Certification Path, where on the top there is a root certificate ( like Symantec ), under that is another certificate ( like Symantec code signing ), and under that is our companys certificate. </p>

<p>I found <a href=""http://support.microsoft.com/kb/323809"" rel=""nofollow"">This</a> link, and rewrote it, so i can query everything i need. Well almost everything.<br>
I couldn't figure out, how can i query the information about the root certificate? It's name, or something? Obviousley I am missing something, but i don't know what.</p>

<p>Could someone please help me?</p>

<p>Thanks in advance!</p>
","<p>There are cryptoAPI functions to establish certificate trust.</p>

<p>I recommend that you go through the following links to understand the basics.</p>

<p>Refer to</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/aa380252%28v=VS.85%29.aspx#certificate_chain_verification_functions"" rel=""nofollow"">Certificate Chain Verification Functions</a></p>

<p><a href=""http://etutorials.org/Programming/secure+programming/Chapter+10.+Public+Key+Infrastructure/10.6+Performing+X.509+Certificate+Verification+with+CryptoAPI/"" rel=""nofollow"">Performing X.509 Certificate Verification with CryptoAPI</a></p>
","120","<c><windows><cryptoapi>","0","0","1","2015-01-07 11:05:21","","0","","","","","2015-01-06 16:03:09",""
"56137510","CryptBinaryToString not outputting expected public key","<p>I'm trying to output the original base64 form of an imported RSA public key using Windows CryptoAPI functions.  Using CryptBinaryToString with the CRYPT_STRING_BASE64HEADER flag, the output header reads ""BEGIN CERTIFICATE"" instead of expected ""BEGIN PUBLIC KEY"".  </p>

<p>(EDIT: I didn't highlight this part of my problem)
Furthermore, the resulting public key appears to be different than the original.</p>

<p>Will this become problematic if I were to export the output and reimport it? If so, what am I doing wrong?</p>

<p>Here's how the public key was imported.  </p>

<p>Public key is stored in file pubkey.pem in the following PEM format:</p>

<pre><code>-----BEGIN PUBLIC KEY-----
[REDACTED]
-----END PUBLIC KEY-----
</code></pre>

<p>File is read into a buffer with CreateFile/ReadFile.
PEM converted to binary using CryptStringToBinaryA.
Binary is decoded to X509_PUBLIC_KEY_INFO using CryptDecodeObjectEx.
PubKeyInfo struct is decoded to RSA_CSP_PUBLICKEYBLOB (same function as above).</p>

<p>This part works just fine (can import the key and encrypt data with CryptImportKey, CryptEncrypt, etc).</p>

<p>Here's the code that I've put together to try and bring the raw blob back to base64 PEM format.  I've removed most error-checking to save headaches.</p>

<p>pbTmp and cbTmp are the temp buffer to hold output and size respectively.
pBinaryKey is the raw public key blob (imported from earlier)
pBuffer is the output buffer (assumed to be the correct size)
ulDataLen is the output buffer size</p>

<pre><code>CryptEncodeObjectEx(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB, pBinaryKey, 0, NULL, NULL, &amp;cbTmp)
pbTmp = malloc(cbTmp);
CryptEncodeObjectEx(X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB, pBinaryKey, 0, NULL, pbTmp, &amp;cbTmp)
CryptBinaryToStringA(pbTmp, cbTmp, CRYPT_STRING_BASE64HEADER, NULL, &amp;ulDataLen)
CryptBinaryToStringA(pbTmp, cbTmp, CRYPT_STRING_BASE64HEADER, pBuffer, &amp;ulDataLen)
</code></pre>

<p>The resulting buffer ends up with this:</p>

<pre><code>-----BEGIN CERTIFICATE-----
[REDACTED; DIFFERENT FROM ORIGINAL PUBLIC KEY]
-----END CERTIFICATE-----
</code></pre>
","<p>According to the <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptbinarytostringa#parameters"" rel=""nofollow noreferrer"">document</a>:</p>

<blockquote>
  <p>CRYPT_STRING_BASE64HEADER(0x00000000):Base64, with <strong>certificate</strong>
  beginning and ending headers.</p>
</blockquote>

<p>The expected header is ""BEGIN CERTIFICATE"". And there is no other flag parameter support for ""BEGIN PUBLIC KEY"". As @Jonathan Potter says, you can always use the <code>CRYPT_STRING_BASE64</code> flag to encode without headers and then add the correct header yourself.</p>

<p>And, here is another <a href=""https://stackoverflow.com/questions/17143606/how-to-save-public-key-from-a-certificate-in-pem-format"">answer</a> about getting PUBILC from CERTIFICATE with openssl.</p>
","118","<windows><winapi><base64><certificate><cryptoapi>","1","0","1","2019-05-15 22:26:33","","1","","11500337","","2019-05-15 22:26:33","2019-05-14 19:38:43",""
"37983297","When can CertGetCertificateChain return multiple simple certificate chains?","<p>Why does <code>CertGetCertificateChain</code> have a facility to return more than one""simple chain""? What are simple chains and what other type of chains should I expect?</p>

<p>On a test run passing a certificate such as the following...</p>

<pre><code>root
  |- parent
    |- my certificate 
</code></pre>

<p>...the result was one simple chain:</p>

<pre><code>0. my certificate
1. parent
2. root
</code></pre>

<p>In what case will we see more than one simple chain returned?</p>
","<p>Multiple chains may appear whan there are multiple paths from single leaf certificate through multiple CA certificates.</p>

<p>This occurs in two (major) cases:</p>

<ol>
<li><p>two or more CA certificates share the same Subject and public key. This happens when CA certificate is renewed with the same key pair. This will result in two very similar certificates which can be used as a node in the certification path building. They are different, but they both (since Subject and public key are shared) can be used to validate the signature of the issued certificate.</p></li>
<li><p>when cross-certification is used to provide additional paths to (possibly) a different root certificate. Litreally the same as above, with the exception that this option is used to provide routes to different CA roots.</p></li>
</ol>

<p>Single certificate chain is just single path from a collection of all possible paths.</p>
","117","<x509certificate><cryptoapi><code-signing-certificate>","1","2","1","2016-06-23 10:00:23","","0","","","","","2016-06-23 05:50:18",""
"24227169","How can I populate scatterlists from a buffer","<p>Trying to use the linux crypto api to encrypt data coming in from a byte array buffer. Looking through the crypto folder source I came across sg_copy_from_buffer in scatterlist.c. It needs to know the number of entries as one of its parameters but I'm not sure what the unit of granularity is for one of the entries. Based on the incoming byte array, how can I decide the number of entries? This is for the latest version of the kernel 3.15. </p>

<p>Also, what does sg stand for? Its used when instantiating pretty much every scatterlist but intuitively I would think of using sl.</p>
","<p>""SG"" stands for <a href=""http://en.wikipedia.org/wiki/Vectored_I/O"" rel=""nofollow"">scatter/gather</a>.</p>

<p>SG lists do not have a unit of granularity; entries can have any size.</p>

<p>The number of entries in an SG list can be determined with <code>sg_nents()</code>.</p>
","117","<linux><linux-kernel><cryptoapi>","0","0","1","2014-06-15 08:31:12","","0","","","","","2014-06-15 06:36:40",""
"32752220","Computing hash with crypto API","<p>I've been trying to compute md5 hash using crypto API but have faced a lot of issues. </p>

<pre><code>char * getHashedKey(char *keybuf) {
  char * output;
  struct scatterlist sg;
  struct crypto_hash *tfm;
  struct hash_desc desc;
  int i;

  printk(""%s received keybuf %s %d\n"", __func__, keybuf, strlen(keybuf));
  output = kmalloc(sizeof(*output) * 16, GFP_KERNEL);
  memset(output, 0x00, 16);

  // works if I overwrite value like this
  //keybuf = ""abcdef012345"";

  tfm = crypto_alloc_hash(""md5"", 0, CRYPTO_ALG_ASYNC);
  desc.tfm = tfm;
  desc.flags = 0;

  sg_init_one(&amp;sg, keybuf, strlen(keybuf));
  // tried type casting too
  //sg_init_one(&amp;sg, (u8 *) keybuf, strlen(keybuf));
  crypto_hash_init(&amp;desc);
  crypto_hash_update(&amp;desc, &amp;sg, strlen(keybuf));
  crypto_hash_final(&amp;desc, output);

  for(i = 0; i &lt; 16; i++)
  {
      printk(""%x"", output[i]);
  }
  printk(""\n"");

  return output;
}
</code></pre>

<p>Here's what I tried: 
1. If ""output"" is unsigned char, I get correct output but not when I'm using char.</p>

<ol start=""2"">
<li><p>If I over write the value of keybuf, only then it works.</p></li>
<li><p>I tried type casting keybuf as (u8*) as mentioned in some forums but that doesn't work too</p></li>
</ol>

<p>The distorted output by using char is:</p>

<pre><code>3ffffffe9ffffffb7ffffffb472ffffffe0ffffffed41225affffffebffffffdaffffffd3ffffffbaffffffabffffffde
</code></pre>

<p>Can someone help me with this?</p>
","<p>You have two display issues.</p>

<p>First: Passing a <code>char</code> value -- implicitly a <code>signed char</code> -- as an argument to <code>printf()</code> causes it to be extended to a <code>signed int</code>. As a result, passing a value with the high bit set (e.g, <code>0xe9</code>, the second byte in your sample output) will cause it to be sign-extended to <code>0xffffffe9</code> and printed as such.</p>

<p>To fix this, declare <code>output</code> as an array of <code>unsigned char</code>, or the equivalent type <code>u8</code>.</p>

<p>Second: You are printing each byte using the <code>%x</code> format string, with no padding specified. This will cause values between <code>0x0</code> and <code>0xf</code> to be printed as a single character instead of two, resulting in ambiguous output.</p>

<p>To fix this, use the <code>%02x</code> format string.</p>
","99","<c><md5><cryptoapi>","0","1","1","2015-09-24 02:22:02","","0","","188331","","2015-09-24 02:08:50","2015-09-24 02:06:41",""
"33635326","How does Crypto API Call works","<p>I'm working on securing the API {WSDL Endpoints} to HTTPS, trying to make use of CryptoAPI Calls in ASP.NET. Can any one tell me what a CryptoAPI call means, I have already gone through many websites, but I really don't understand why do we use that? By making use of CryptoAPI what is that I achieve? How does that work...?</p>
","<p>CryptoApi (aka CAPI) is Microsoft's crypto library. <a href=""https://en.wikipedia.org/wiki/Microsoft_CryptoAPI"" rel=""nofollow"">https://en.wikipedia.org/wiki/Microsoft_CryptoAPI</a></p>

<p>It is used for things like encrypting files, but HTTPS is an entire protocol layer, it's more than just encryption.</p>

<p>If you are trying to secure a web service, then you don't need to write your own server crypto code.</p>

<p>Just bind the ASP.NET website to the HTTPS protocol in IIS (in addition to or in place of HTTP). When the client calls the API over HTTPS, the encryption process is invisible to the client and server yet the communication is still secure.</p>

<p>Here is an overview of how to setup IIS for HTTPS: <a href=""https://www.digicert.com/ssl-certificate-installation-microsoft-iis-8.htm"" rel=""nofollow"">https://www.digicert.com/ssl-certificate-installation-microsoft-iis-8.htm</a></p>

<p>Encryption is incredibly difficult to do correctly, even for crypto experts. So us mere mortal general programmers are encouraged to avoid writing our own encryption code as much as possible. HTTPS/SSL/TLS has its issues, but the good thing about it is that its implemented in a way that is largely invisible to the applications which make use of it.</p>

<p>Here's a general overview of how HTTPS works (aimed at web devs): <a href=""https://blog.hartleybrody.com/https-certificates/"" rel=""nofollow"">https://blog.hartleybrody.com/https-certificates/</a></p>
","98","<asp.net><ssl><cryptoapi>","0","0","1","2015-11-23 09:04:50","","1","","5545933","","2015-11-23 08:43:08","2015-11-10 16:54:30",""
"18382872","padding issue while decryption using AES256 with ECB mode in java","<p>Hi I have issue while decrypting a String which is encrypted in IOS environment using AES256 with ECB mode. I have to decrypt this encrypted string in java.</p>

<p>Let me share my code for decryption in java</p>

<pre><code>public static String decrypt(String strToDecrypt) throws UnsupportedEncodingException
{
     byte[] key = ""12345678911234567891123456789112"".getBytes(""UTF-8"");

    try
    {   Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS7Padding"");
        final SecretKeySpec secretKey = new SecretKeySpec(key, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        final String decryptedString = new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt.getBytes(""UTF-8""))));
        return decryptedString;
    }
    catch (Exception e)
    {
        System.out.println(""Error while decrypting""+ e);

    }
    return null;
}
</code></pre>

<p>Encryption code at IOS platform</p>

<pre><code>- (NSData *)AES256EncryptWithKey:(NSString *)key:(NSString *)plaintext {

// 'key' should be 32 bytes for AES256, will be null-padded otherwise

char keyPtr[kCCKeySizeAES256+1]; // room for terminator (unused)

bzero(keyPtr, sizeof(keyPtr)); // fill with zeroes (for padding)

// fetch key data

[key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];



    NSLog(@"" key ptr string %s"",keyPtr);

NSData *dTextIn=[plaintext dataUsingEncoding:NSUTF8StringEncoding];

NSUInteger dataLength = [dTextIn length];

//See the doc: For block ciphers, the output size will always be less than or

//equal to the input size plus the size of one block.

//That's why we need to add the size of one block here

size_t bufferSize = dataLength + kCCBlockSizeAES128;

void *buffer = malloc(bufferSize);

size_t numBytesEncrypted = 0;

CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128,kCCOptionPKCS7Padding,

                                          keyPtr, kCCKeySizeAES256,

                                          NULL /* initialization vector (optional) */,

                                          [dTextIn bytes], dataLength, /* input */

                                          buffer, bufferSize, /* output */

                                          &amp;numBytesEncrypted);

if (cryptStatus == kCCSuccess) {

//the returned NSData takes ownership of the buffer and will free it on deallocation

return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];

}





free(buffer); //free the buffer;

return nil;

}

   original string is ""my name is nitish"" // which is encoded in IOS Platform, padding PKCS7Padding and ECB Mode
Encrypted String1 in IOS platform is ""p1sBWnbfE/5g3RdT7PHBFy6idtGJlpLBq5IqKV4wXKQ=""
Encrypted string in java platform is ""p1sBWnbfE/5g3RdT7PHBF8z1aSePf1f9hn6Z33GdrRI=""
</code></pre>

<p>I don't know what is the error and why I can't decrypt the ios String in java platform but i can Decrypt encrypted string in Java platform. Please give some solution.</p>

<p>error is decryptingjavax.crypto.BadPaddingException: pad block corrupted</p>

<p>thanks in advance</p>
","","97","<java><ios><aes><cryptoapi>","0","","0","2013-08-23 05:21:19","","2","2","2147227","","2013-08-23 05:21:19","2013-08-22 14:09:20","2013-09-05 14:57:18"
"53928214","Unable to create a valid CRYPT_HASH_BLOB in ruby","<p>I'm using Crypto API in Ruby to find a windows certificate using it's Thumbprint. For that I'm using <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-certfindcertificateinstore"" rel=""nofollow noreferrer"">CertFindCertificateInStore</a> function which requires a <a href=""https://msdn.microsoft.com/en-us/7a06eae5-96d8-4ece-98cb-cf0710d2ddbd"" rel=""nofollow noreferrer"">CRYPT_HASH_BLOB</a> structure.</p>

<p>I'm dealing with pointers by using <code>FFI::MemoryPointer</code>. Have tried various approaches to create this struct but none of them seems to be working.</p>

<p>Can someone please take a look and provide me suggestions.</p>

<p>Here is the complete code for the reference:</p>

<pre><code>    require ""ffi""

    module LibC
      extend FFI::Library
      ffi_lib FFI::Library::LIBC

      # memory allocators
      attach_function :malloc, [:size_t], :pointer
      attach_function :calloc, [:size_t], :pointer
      attach_function :free, [:pointer], :void
    end

    module Crypto
      extend LibC
      extend FFI::Library
      ffi_lib ""Crypt32""

      HCERTSTORE               = FFI::TypeDefs[:pointer]
      HCRYPTPROV_LEGACY        = FFI::TypeDefs[:pointer]
      PCCERT_CONTEXT           = FFI::TypeDefs[:pointer]
      DWORD                    = FFI::TypeDefs[:uint32]
      BLOB                     = FFI::TypeDefs[:ulong]
      LPCTSTR                  = FFI::TypeDefs[:pointer]
      BOOL                     = FFI::TypeDefs[:bool]
      LPVOID                   = FFI::TypeDefs[:pointer]

      class CRYPT_HASH_BLOB &lt; FFI::Struct
        layout :cbData, DWORD, # Count, in bytes, of data
               :pbData, :pointer # Pointer to data buffer

        def initialize(str)
          super(nil)
          if str
            # Method 1: Simply using thumbprint string
            buffer1 = LibC.malloc str.size
            buffer1.write_string str
            self[:pbData] = buffer1
            self[:cbData] = str.size

            # Converting thumbpring string into a byte array
            # arr = [str].pack('H*').unpack('C*')

            # Method 2: Using Byte Array  with LibC
            # buffer2 = LibC.malloc(arr.first.size * arr.size) # Create the pointer to the array
            # buffer2.write_array_of_uint32 arr                # Fill the memory location with data
            # self[:pbData] = buffer2
            # self[:cbData] = arr.size

            # # Method 3: Using Byte Array with FFI::MemoryPointer
            # buffer3 = FFI::MemoryPointer.new :uint32, arr.size # Create the pointer to the array
            # buffer3.put_array_of_uint32 0, arr                 # Fill the memory location with data
            # self[:pbData] = buffer3
            # self[:cbData] = arr.size
          end
        end
      end

      attach_function :CertOpenStore, [DWORD, DWORD, HCRYPTPROV_LEGACY, DWORD, LPCTSTR], HCERTSTORE
      attach_function :CertCloseStore, [HCERTSTORE, DWORD], BOOL
      attach_function :CertFindCertificateInStore, [HCERTSTORE, DWORD, DWORD, DWORD, LPVOID, PCCERT_CONTEXT], PCCERT_CONTEXT
      attach_function :CertFreeCertificateContext, [PCCERT_CONTEXT], BOOL
    =begin
      PCCERT_CONTEXT CertFindCertificateInStore(
        HCERTSTORE     hCertStore,
        DWORD          dwCertEncodingType,
        DWORD          dwFindFlags,
        DWORD          dwFindType,
        const void     *pvFindPara,
        PCCERT_CONTEXT pPrevCertContext
      );
    =end
    end

    class CertificateHandler
      include Crypto
      CERT_STORE_PROV_SYSTEM = 10
      CERT_SYSTEM_STORE_LOCAL_MACHINE = 0x00020000
      X509_ASN_ENCODING = 0x00000001
      PKCS_7_ASN_ENCODING = 0x00010000
      ENCODING_TYPE = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING
      CERT_CLOSE_STORE_FORCE_FLAG = 1

      CERT_COMPARE_SHA1_HASH = 1
      CERT_COMPARE_SHIFT = 16
      CERT_FIND_SHA1_HASH = CERT_COMPARE_SHA1_HASH &lt;&lt; CERT_COMPARE_SHIFT

      def self.finalize(certstore_handler)
        proc { certstore_handler.to_s }
      end

      def add_finalizer(certstore_handler)
        ObjectSpace.define_finalizer(self, self.class.finalize(certstore_handler))
      end

      def remove_finalizer
        ObjectSpace.undefine_finalizer(self)
      end

      def utf8_to_wide(ustring)
        # ensure it is actually UTF-8
        # Ruby likes to mark binary data as ASCII-8BIT
        ustring = (ustring + """").force_encoding(""UTF-8"") if ustring.respond_to?(:force_encoding) &amp;&amp; ustring.encoding.name != ""UTF-8""

        # ensure we have the double-null termination Windows Wide likes
        ustring += ""\000\000"" if ustring.length == 0 || ustring[-1].chr != ""\000""

        # encode it all as UTF-16LE AKA Windows Wide Character AKA Windows Unicode
        ustring = ustring.encode(""UTF-16LE"") if ustring.respond_to?(:encode)
        ustring
      end

      def cert_find_by_thumbprint(thumbprint = nil)
        store_name = ""Root""
        thumbprint ||= ""1D F4 AB B6 13 F2 12 27 1C 04 F8 52 9D DE 38 E4 B7 24 2E 6C"" # Assume this is a valid thumbprint in Root
        thumbprint.gsub!(/[^A-Za-z0-9]/, """") # Discard WhiteSpaces

        certstore_handler = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, nil,
          CERT_SYSTEM_STORE_LOCAL_MACHINE, utf8_to_wide(store_name))
        add_finalizer(certstore_handler)

        pcert_context = CertFindCertificateInStore(certstore_handler, ENCODING_TYPE, 0, CERT_FIND_SHA1_HASH, CRYPT_HASH_BLOB.new(thumbprint), nil)

        puts ""Certificate Found = #{!pcert_context.null?}"" # It should be true

        CertFreeCertificateContext(pcert_context)
        closed = CertCloseStore(@certstore_handler, CERT_CLOSE_STORE_FORCE_FLAG)
        remove_finalizer
      end
    end

    CertificateHandler.new.cert_find_by_thumbprint
</code></pre>
","<p>I'm not familiar with Ruby at all, but I can make some assumptions. Correct me if I'm wrong.</p>

<p>You are converting source thumbprint (SHA1 value) to a string without spaces between octets:</p>

<pre><code>thumbprint ||= ""1D F4 AB B6 13 F2 12 27 1C 04 F8 52 9D DE 38 E4 B7 24 2E 6C"" # Assume this is a valid thumbprint in Root
thumbprint.gsub!(/[^A-Za-z0-9]/, """") # Discard WhiteSpaces
</code></pre>

<p>This will result something like this: <code>1DF4ABB613F212271C04F8529DDE38E4B7242E6C</code> and then you pass this string into <code>CRYPT_HASH_BLOB</code> constructor in this line:</p>

<pre><code>pcert_context = CertFindCertificateInStore(certstore_handler, ENCODING_TYPE, 0, CERT_FIND_SHA1_HASH, CRYPT_HASH_BLOB.new(thumbprint), nil)
</code></pre>

<p>In the <code>CRYPT_HASH_BLOB.initialize(str)</code> you unpack the utf8 string to a byte array. First method is incorrect, because you treat input string as raw char array. Instead, it is a hex-encoded byte array, thus <code>arr = [str].pack('H*').unpack('C*')</code> line must be involved. At least, google suggests that this line will convert a series of octets to a corresponding byte array. So, method 3 is just fine with the exception that you must allocate <strong>*byte*</strong> array (not integer array) and write chars instead of ints. The correct constructor code should look like this:</p>

<pre><code>def initialize(str)
    super(nil)
    if str
        # Converting thumbpring string into a byte array
        arr = [str].pack('H*').unpack('C*')

        # Method 3: Using Byte Array with FFI::MemoryPointer
        buffer3 = FFI::MemoryPointer.new(:char, arr.size) # Create the pointer to the array
        buffer3.write_array_of_char(arr) # Fill the memory location with data
        self[:pbData] = buffer3
        self[:cbData] = arr.size
    end
end
</code></pre>

<p>I believe, this will do the work.</p>
","96","<ruby><pointers><winapi><x509certificate><cryptoapi>","1","0","1","2018-12-26 11:36:42","53931549","3","","10829266","","2018-12-26 07:03:50","2018-12-26 06:25:57",""
"33690579","SignerSignEx as the Azure WebJob","<p>I found a brilliant use of <code>SignerSignEx</code> on C# here: <a href=""https://stackoverflow.com/a/26372061"">https://stackoverflow.com/a/26372061</a></p>

<p>It works fine on the dev. machine, but on Azure WebJob you have to use something like this:</p>

<pre><code>X509Certificate2 cert = new X509Certificate2(certPath, 
                        certPassword, 
                        X509KeyStorageFlags.MachineKeySet |
                        X509KeyStorageFlags.PersistKeySet |
                        X509KeyStorageFlags.Exportable);
</code></pre>

<p>But with <code>X509KeyStorageFlags.MachineKeySet</code> flag <code>SignerSignEx</code> returns hResult=-2146885626 (Error code 0x80092006 - No provider was specified for the store or object.)</p>

<p>How I can fix it and why MachineKeySet has influence on provider ?
Thanks!</p>
","<p>After some research I almost sure (99% :) ) that <code>SignerSignEx</code> just doesn't work without user's profile. 
So I used mono + openssl.</p>

<p>Looks like a solution.</p>

<p>You can see an example of authenticode with Mono at:
<a href=""https://github.com/mono/mono/blob/master/mcs/tools/security/signcode.cs"" rel=""nofollow"">https://github.com/mono/mono/blob/master/mcs/tools/security/signcode.cs</a></p>

<p>Bye,
have a beautiful time!</p>
","93","<c#><azure><sign><cryptoapi><webjob>","0","0","1","2015-11-16 10:44:28","","0","","-1","","2017-05-23 12:30:14","2015-11-13 10:26:30",""
"48894179","Code signing no longer working","<p>We have a legacy Windows Workflow process that uses <code>SignerSign</code> to apply a digital signature to an EXE. We are migrating away from the Windows Workflow process, and so I have been preparing a tool within the context of our new process to perform the same signing operation. I copy/pasted the code signing code from the Workflow Activity to a class in the new project, but I am encountering an error when I try to run it.</p>

<p>The rough outline of what the code does is:</p>

<ul>
<li><code>CertOpenStore</code> is used to open the PFX file containing the private key and certificate.</li>
<li>A certificate context is obtained by calling <code>CertEnumCertificatesInStore</code> on the resulting certificate store handle.</li>
<li><code>SignerSign</code> is called with a <code>SIGNER_SUBJECT_INFO</code> pointing at the target EXE file, a <code>SIGNER_CERT</code> pointing at the certificate context from the previous step and a <code>SIGNATURE_SIGNER_INFO</code> specifying that the SHA-1 algorithm should be used. (I have tried changing the algorithm to SHA-2 512 with no change in the outcome.) The <code>pProviderInfo</code> parameter is <code>NULL</code>.</li>
<li>A separate call is made to <code>SignerTimeStamp</code> to apply a timestamp to the signature. A comment in the code indicates that if the <code>pwszHttpTimeStamp</code> parameter to <code>SignerSign</code> is used, it returns HRESULT 0x80070020 (""File in use""?)</li>
</ul>

<p>When I try to run this code on Windows 10 64-bit, whether from a 32-bit or 64-bit process, I get error HRESULT 0x80092006 ""No provider was specified for the store or object."". I tried supplying a <code>pProviderInfo</code> with the provider name set to ""Microsoft Strong Cryptographic Provider"" (seen in the API Monitor trace output for when SignTool.exe signs the executable -- this works) but it did not affect the outcome.</p>

<p>Does anyone know what exactly this error means and how to fix it?</p>
","<p>I have no idea at all why this worked, but by massaging my code so that does the same thing I see SignTool doing in Rohitab's API Monitor, and then paring bits away to what appears to be the minimal working set, this now signs files again:</p>

<ul>
<li>Instead of <code>CertOpenStore</code>,. <code>PFXImportCertStore</code> is used to open the PFX file and produce an <code>HCERTSTORE</code>. This requires loading the PFX into memory so that it can be passed in as a <code>CRYPT_DATA_BLOB</code> -- no big deal.</li>
<li>A certificate context is obtained using <code>CertEnumCertificatesInStore</code> as before.</li>
<li><code>CertGetCertificateChain</code> is used on the resulting certificate context with an unrestrictive <code>CERT_CHAIN_PARA</code> and flags <code>CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING |    CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS | CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT</code>. No additional store is specified. When I originally wrote this, based on the API Monitor results, I defined <code>CERT_CHAIN_PARA_HAS_EXTRA_FIELDS</code> and populated them the same way the API Monitor capture showed, but I continue to get <code>S_OK</code> from <code>SignerSign</code> with the short <code>CERT_CHAIN_PARA</code> structure as well.</li>
<li><code>SignerSign</code> is called as before, except that a dummy collection-type store is passed in as the <code>hCertStore</code> of the <code>SIGNER_CERT_STORE_INFO</code> struct nested within the <code>SIGNER_CERT</code>. This dummy collection type store is created by calling <code>CertOpenStore</code> twice, once with <code>CERT_STORE_PROV_COLLECTION</code> and flag <code>CERT_STORE_CREATE_NEW_FLAG</code> and once with <code>CERT_STORE_PROV_MEMORY</code> specifying encodings <code>PKCS_7_ASN_ENCODING | X509_ASN_ENCODING</code>, and then adding the memory store to the collection store using <code>CertAddStoreToCollection</code>.</li>
</ul>

<p>If the dummy collection type store is not specified, then <code>SignerSign</code> complains that it cannot find a path to a trusted root. Note that the certificate I am using in my testing is self-signed, and thus doesn't <em>have</em> a path to a trusted root. Perhaps the dummy collection type store would not be necessary with a code signing certificate that does have a path to a trusted root, I do not presently have the means to test.</p>

<p>In any case, I hope this helps resolve this issue for anybody else who might have bumped into problems with <code>SignerSign</code>. :-)</p>
","93","<c#><windows><digital-signature><signature><cryptoapi>","2","0","1","2018-02-20 23:29:54","","0","","","","","2018-02-20 21:04:19",""
"57115991","C++ CryptoAPI: How to encrypt file for distribution to multiple receivers","<p>I've updated this to more thoroughly describe what's going on. Hope I haven't broken any rules in doing so.</p>

<p>Second update: changed decryption on the application side (After ""The following adapted from..."").</p>

<p>I have a text file which I encrypt on a source machine. The resulting file needs to be distributed to a number of destination machines and decrypted on the fly for presentation there. Transmission security is not an issue; our primary concern is with data integrity for reporting purposes; the end user should not be able to edit a free text file - hence, the encryption. On the source machine, my encryption and decryption work fine. This is the source encryption:</p>

<pre><code>HCRYPTPROV m_hCryptProv;
HCRYPTKEY m_hSigKey;
HCRYPTKEY m_hExchKey;
HCRYPTHASH m_hHash;
CMemFile m_file;
CString m_strPassword;
CString m_strData;
CByteArray arData;
CFile file;
DWORD dwBlobLen = 0;
BYTE* pbKeyBlob;

CryptAcquireContext(&amp;m_hCryptProv, NULL, NULL, PROV_RSA_FULL, 0);
CryptCreateHash(m_hCryptProv, CALG_MD5, 0, 0, &amp;m_hHash);
CryptHashData(m_hHash, (const BYTE*)strPassword.GetString(), strPassword.GetLength() * sizeof(TCHAR), 0);
CryptDeriveKey(m_hCryptProv, CALG_RC2, m_hHash, CRYPT_EXPORTABLE, &amp;m_hSigKey);

// m_strData is input to be encrypted
m_crypto.Encrypt(m_strData, arData);
file.Write(arData.GetData(), static_cast&lt;UINT&gt;(arData.GetCount()));
file.Flush();
file.Close();

// encrypted file ""file"" copied to target machine as ""GlobalOperator.dat"".

// Generate exchange key and write to file.
CryptGetUserKey(m_hCryptProv, AT_KEYEXCHANGE, &amp;m_hExchKey);
CryptExportKey(m_hExchKey, 0, PUBLICKEYBLOB, 0, NULL, &amp;dwBlobLen);
pbKeyBlob = (BYTE*)malloc(dwBlobLen);
//CryptExportKey(m_hExchKey, 0, PUBLICKEYBLOB, 0, NULL, &amp;dwBlobLen);
CryptExportKey(m_hExchKey, 0, PUBLICKEYBLOB, 0, pbKeyBlob, &amp;dwBlobLen);
file.Write(pbKeyBlob, dwBlobLen);
file.Flush();
file.Close();

// key file ""file"" copied to target machine as ""key.dat"".
</code></pre>

<p>The target machine(s) run an application an attempts to read the encrypted file:</p>

<pre><code>CString m_strData;
CByteArray arData;
CFile GlobalOperatorFile;

GlobalOperatorFile.Open(""GlobalOperator.dat"")
arData.SetSize(static_cast&lt;INT_PTR&gt;(GlobalOperatorFile.GetLength()));
GlobalOperatorFile.Read(arData.GetData(), static_cast&lt;UINT&gt;(GlobalOperatorFile.GetLength()));
GlobalOperatorFile.Close();

// Try to deserialize the data.
DWORD dwBlobLen = 0;
CMemFile m_file;
m_file.SetLength(0);

//  Write the contents of the byte array to the memory file.
m_file.Write(arData.GetData(), static_cast&lt;UINT&gt;(arData.GetCount()));
m_file.Flush();

//  Acquire direct access to the memory file buffer.
BYTE* pData = m_file.Detach();

DWORD dwDataLength = static_cast&lt;DWORD&gt;(arData.GetCount());

// The following adapted from https://docs.microsoft.com/en-us/windows/win32/seccrypto/example-c-program-decrypting-a-file
CryptCreateHash(m_hCryptProv, CALG_MD5, 0, 0, &amp;m_hHash);
CString pwd = ""EncryptionKey"";
CryptHashData(m_hHash, (const BYTE*)pwd.GetString(), pwd.GetLength() * sizeof(TCHAR), 0);
CryptDeriveKey(m_hCryptProv, CALG_RC2, m_hHash, CRYPT_EXPORTABLE, &amp;m_hKey);
CryptDecrypt(m_hKey, NULL, TRUE, 0, pData, &amp;dwDataLength);

// The above call to CryptDecrypt fails with error code 0x80090005: NTE_BAD_DATA

</code></pre>

<p>So I clearly have no idea what I'm doing with encryption/decryption.</p>

<p>Can anyone help?</p>

<pre><code>
</code></pre>
","","91","<c++><encryption><cryptoapi>","0","","0","2019-07-23 20:29:03","","0","","8382366","","2019-07-23 20:29:03","2019-07-19 15:57:12",""
"49942253","Create similar signature with openssl and Windows CryptoAPI","<p>I create detached signature with openssl as</p>

<p>openssl smime -sign -md sha256 -in {f_in} -signer {cert} -inkey {key} -out {f_out} -outform DER</p>

<p>Next I try to replay it with CryptoAPI using same input file and loading same certificate with private key from windows certificate storage. How should I call the API to receive the same ASN.1 <strong>format</strong> in the output?</p>

<p><strong>EDIT (ADDITION):</strong>
I feel that there's something wrong with CMSG_SIGNER_ENCODE_INFO.
How to fill rgAuthAttr to add contentType, signingTimeto and messageDigest to it before passing to CryptMsgOpenToEncode. See the ASN.1 below to understand what openssl command done in this part. Mind it alse add 1.2.840.113549.1.9.15 sMIMECapabilities section, but I'm not sure that it's the root of the problem.</p>

<p>I trying it using (""Microsoft Enhanced RSA and AES Cryptographic Provider"", """", 24). And as I see the main diff in how messageDigest is written. Here's how it written with openssl (it should be ethalon for me)</p>

<pre><code>[0] {
    SEQUENCE {
      OBJECTIDENTIFIER 1.2.840.113549.1.9.3 (contentType)
      SET {
          OBJECTIDENTIFIER 1.2.840.113549.1.7.1 (data)
      }
    }
    SEQUENCE {
      OBJECTIDENTIFIER 1.2.840.113549.1.9.5 (signingTime)
      SET {
          UTCTime '180406133432Z'
      }
    }
    SEQUENCE {
      OBJECTIDENTIFIER 1.2.840.113549.1.9.4 (messageDigest)
      SET {
          OCTETSTRING c75f664aef53e428e65c58cb926e3c175b81070417628105941d387c1d4fa8b0
      }
    }
    SEQUENCE {
      OBJECTIDENTIFIER 1.2.840.113549.1.9.15
      SET {
          SEQUENCE {
            SEQUENCE {
                OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.42
            }
            SEQUENCE {
                OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.22
            }
            SEQUENCE {
                OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.2
            }
            SEQUENCE {
                OBJECTIDENTIFIER 1.2.840.113549.3.7 (id_des_EDE3_CBC)
            }
            SEQUENCE {
                OBJECTIDENTIFIER 1.2.840.113549.3.2
                INTEGER 0x0080 (128 decimal)
            }
            SEQUENCE {
                OBJECTIDENTIFIER 1.2.840.113549.3.2
                INTEGER 0x40 (64 decimal)
            }
            SEQUENCE {
                OBJECTIDENTIFIER 1.3.14.3.2.7 (desCBC)
            }
            SEQUENCE {
                OBJECTIDENTIFIER 1.2.840.113549.3.2
                INTEGER 0x28 (40 decimal)
            }
          }
      }
    }
}
</code></pre>
","","82","<openssl><signature><asn.1><cryptoapi>","0","","0","2018-04-24 13:53:24","","2","","2156010","","2018-04-24 13:53:24","2018-04-20 12:59:29",""
"54503343","Bulk ETH address checker","<p>I used <a href=""https://github.com/corpetty/py-etherscan-api"" rel=""nofollow noreferrer"">https://github.com/corpetty/py-etherscan-api</a>,
This is my simple script, for checking eth addresses for balance, but it very slow, how I can make this script much more faster?</p>

<pre><code>from etherscan.accounts import Account
import sys 
import os
list = ""adr.txt""
with open(list, 'r') as f:
    for line in f:
        address = line.rstrip()
        api = Account(address=address, api_key='YourApiKey')
        balance = api.get_balance()
        print(address, (int(balance) / 1000000000000000000), file=open(""result.txt"", ""a""))
</code></pre>
","","82","<python><python-3.x><ethereum><pycrypto><cryptoapi>","1","","0","2019-02-04 00:30:40","","0","","11008556","","2019-02-04 00:30:40","2019-02-03 13:26:25",""
"56995561","How to use CryptoAPI to encrypt an AES key with an RSA public key","<p>I am using the Windows CryptoAPI's <code>CryptGenKey</code> function to generate an RSA key pair. Then, I have an AES key generated and exported as hex so that I can encrypt it with the RSA public key. Here's the code:</p>

<pre><code>// &lt;includes&gt;
// handle to CSP

// declaring keys
HCRYPTKEY testKey = NULL;
HCRYPTKEY hRSAKey = NULL;

// generating RSA key pair
CryptGenKey(hCryptProv, CALG_RSA_KEYX, CRYPT_EXPORTABLE, &amp;hRSAKey); 

// generating AES key
testKey = CryptGenKey(hCryptProv,CALG_AES_256,1,&amp;hKey);

// exporting AES key to hex string
std::string hexAES = exportKeyAsHex(testKey);

// attempting encryption of AES key with RSA
// ...this is where I need help...

DWORD pbDataLen;
const size_t chunk_size = 256;
BOOL isFinal = FALSE;
CryptEncrypt(hRSAKey, NULL, isFinal, 0, hexAES, pbDataLen, chunk_size);
</code></pre>

<p>I get the following error: <code>no suitable conversion from string to BYTE</code> for the variable <code>hexAES</code> in the last line. So I know it's not the right data type. How do I fix this code to successfully encrypt the AES-256 key using the generated RSA public key?</p>
","","78","<c++><winapi><rsa><cryptoapi>","0","","0","2019-07-11 19:27:08","","1","","451321","","2019-07-11 18:52:30","2019-07-11 18:45:58",""
"47964660","JSON returning multidimensional arrays from cryptcompare api","<p>I have been trying to figure out how to get data from JSON from cryptocompare api to google spreadsheet.Here it's my code:</p>

<pre><code>function gather(symbol, array) {
for (i in array.AggregatedData) {
return array[i];
  }
return 0;
}

function chc(symbol, key, rand) {
var url = ""https://www.cryptocompare.com/api/data/coinsnapshot/?fsym=""+ symbol +""&amp;tsym=USD"";

var response = UrlFetchApp.fetch(url);
var text = response.getContentText();

var obj_array = JSON.parse(text);
var obj = gather(obj_array);
var value = obj[key];

return parseFloat(value);
}
</code></pre>

<p>I get an error that cannot read the property of AggregatedData undefined.</p>

<p>Here it's the way the data shows on the api 
<a href=""https://www.cryptocompare.com/api/data/coinsnapshot/?fsym=BTC&amp;tsym=USD"" rel=""nofollow noreferrer"">JSON output</a></p>
","<p>You might have a wrong variable type. </p>

<p>If AggregatedData is method or function you should use () at the end.</p>

<p>PS: There is a script from Trevor Lohrbeer that can be used to import JSON more intuitively.</p>
","76","<json><google-sheets-api><cryptoapi>","0","0","1","2017-12-24 23:36:39","","0","1","","","","2017-12-24 23:19:57",""
"43911379","Data integrity in asyncronous CryptoApi in Linux","<p>I work on implementation of driver for Linuc CryptoApi. Encryption/decryption will be performed in hardware and I want to use asynchronous operation of CryptoApi, which perfectly suitable for this purpose. Main purpose of driver is using with ipsec.</p>

<p><a href=""https://01.org/linuxgraphics/gfx-docs/drm/crypto/architecture.html"" rel=""nofollow noreferrer"">Citation</a> from documentation: </p>

<blockquote>
  <p>Asynchronous operation is provided by the kernel crypto API which implies that the invocation of a cipher operation will complete almost instantly. That invocation triggers the cipher operation but it does not signal its completion. Before invoking a cipher operation, the caller must provide a callback function the kernel crypto API can invoke to signal the completion of the cipher operation. Furthermore, the caller must ensure it can handle such asynchronous events by applying appropriate locking around its data. The kernel crypto API does not perform any special serialization operation to protect the caller’s data integrity.</p>
</blockquote>

<p>Common mechanism of work: driver get query for processing data, make child process which will communicate with hardware, then driver(not child process) return special code(""in progress"") to caller. Caller now can create one else query or do another useful work. When data processing complete child process call callback function, which registered by caller, and die. </p>

<p>But caller of the driver can be killed, for example, before data will be handled by hardware. If caller process not exist anymore in system, execution callback function can corrupt system. Besides that, before execution of callback function child process get encrypted/decrypted data from hardware and write it to some buffer, which was provided by caller. And this is one more scenario of system corruption. If caller not exist anymore driver should not use buffer.</p>

<p>How did kernel developers planned me to resolve this issue? What mechanism of synchronization between my driver and customer application should I use?</p>

<p>And I want to go back to upper <a href=""https://01.org/linuxgraphics/gfx-docs/drm/crypto/architecture.html"" rel=""nofollow noreferrer"">citation</a>:
Furthermore, the caller must ensure it can handle such asynchronous events by applying appropriate locking around its data. The kernel crypto API does not perform any special serialization operation to protect the caller’s data integrity.</p>

<p>I don't know, but it can concern to issue I research. In that case it's not problem of my driver to control data integrity. Then maybe it's a problem of ipsec level? For example, xfrm subsystem? </p>

<p>Any comments or ideas, please?</p>
","","75","<c><linux-kernel><linux-device-driver><cryptoapi><ipsec>","2","","0","2017-05-11 09:21:31","","0","1","","","","2017-05-11 09:21:31",""
"58040517","Linux Kernel Crypto API","<p>I''m try to make simple kernel module with using Linux Kernel Crypto API.
<br>I've got the example from <a href=""https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html"" rel=""nofollow noreferrer"">https://www.kernel.org/doc/html/v4.17/crypto/api-samples.html</a> (Code Example For Symmetric Key Cipher Operation
)</p>

<p>My problem is variable ""<em>scratchpad</em>"" (Input date) is the same value before and after launching it. 
<br>Also bracnh is never used:</p>

<pre><code>if (rc)
        pr_info(""skcipher encrypt returned with result %d\n"", rc);
</code></pre>

<p>I'm sure doing something wrong?</p>
","<p>Regarding the first part of the question:</p>

<blockquote>
  <p>My problem is variable ""scratchpad"" (Input date) is the same value before and after launching it.</p>
</blockquote>

<p>Since you are attempting to cipher in-place by passing the same scatter/gather list as a destination, this is a problem. They should not be the same.</p>

<p>To debug, you can:</p>

<ol>
<li>Try other algorithms. I see from your <code>/proc/crypto</code> file that you have <code>__cbc-aes-aesni</code>. You may want to try that and others, to test the logic of your module.</li>
<li>Try cryptodev from userspace (<code>/dev/crypto</code>). It makes debugging much easier, by using cryptodev <a href=""https://github.com/cryptodev-linux/cryptodev-linux/tree/master/tests"" rel=""nofollow noreferrer"">tests</a> and examining <code>dmesg</code>. Adding <code>enable_stats=1</code> to module options also helps. When your application is stable on userspace, it's up to you to go back to the kernel.</li>
</ol>

<p>For the second part:</p>

<blockquote>
  <p>Also bracnh is never used:</p>

<pre><code>if (rc)
       pr_info(""skcipher encrypt returned with result %d\n"", rc);
</code></pre>
</blockquote>

<p>I would say this is not a problem.</p>

<p>Following the code sequence (referencing same kernel version v4.17 as your documentation link): </p>

<ol>
<li><a href=""https://elixir.bootlin.com/linux/v4.17/source/include/linux/crypto.h#L507"" rel=""nofollow noreferrer""><code>crypto_wait_req</code></a> takes an error code, in our case passed by <code>crypto_skcipher_encrypt()</code>. Unless the error is <code>-EBUSY</code> or <code>-EINPROGRESS</code>, this error code  is returned to <code>rc</code>, and zero is perfectly normal.</li>
<li>In turn, <a href=""https://elixir.bootlin.com/linux/v4.17/source/include/crypto/skcipher.h#L436"" rel=""nofollow noreferrer""><code>crypto_skcipher_encrypt</code></a> returns 0 if the cipher operation was successful; &lt; 0 if an error occurred. Since you've set a key, 0 should be returned.</li>
<li>I'll reference Intel's <code>__cbc-aes-aesni</code> as the driver. Checking <a href=""https://elixir.bootlin.com/linux/v4.17/source/arch/x86/crypto/aesni-intel_glue.c#L471"" rel=""nofollow noreferrer""><code>cbc_encrypt()</code></a>, you can see zero is the return value on success, as evidenced in the return value of <a href=""https://elixir.bootlin.com/linux/v4.17/source/crypto/skcipher.c#L109"" rel=""nofollow noreferrer""><code>skcipher_walk_done()</code></a> in successful state.</li>
</ol>

<p>Thus it is expected behaviour on successful operation that the branch is not called.</p>
","73","<c><kernel><kernel-module><cryptoapi>","1","0","1","2019-09-21 19:46:20","58043582","2","","","","","2019-09-21 12:58:04",""
"51293419","AES128 with CryptoAPI","<p>I'm trying to encrypt strings in AES128 using CryptoAPI, but I'm not getting it for some reason. When I compile, it simply crashes the application. I believe the problem is in the calls of the <code>CryptDecrypt</code> and <code>CryptEncrypt</code> functions, as I wrote this function based on another that I found on the internet. I know nothing concrete about it, nor the way to use it.</p>

<p>Here is my code:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;

#pragma comment(lib, ""crypt32.lib"")

#define BLOCK_LEN 16

std::string AES128(std::string key, std::string data, bool enc)
{
    bool Result = false;
    size_t blocks = ceil((float)data.length() / BLOCK_LEN) + 1;
    BYTE* chunk = new BYTE[blocks * BLOCK_LEN];
    memset(chunk, 0, blocks * BLOCK_LEN);
    memcpy(chunk, data.c_str(), data.length());

    HCRYPTPROV hProv;
    if (!CryptAcquireContextA(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
        goto finally;

    HCRYPTHASH hHash;
    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash))
        goto finally;

    if (!CryptHashData(hHash, (BYTE*)key.c_str(), key.length(), 0))
        goto finally;

    HCRYPTKEY hKey;
    if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &amp;hKey))
        goto finally;

    for (int i = 0; i &lt; blocks; i++)
        switch (enc)
        {
        case true:
        {
            DWORD out_len = BLOCK_LEN;
            if (!CryptEncrypt(hKey, NULL, i + 1 == blocks, NULL, &amp;chunk[i * BLOCK_LEN], &amp;out_len, blocks * BLOCK_LEN))
                goto finally;
            break;
        }

        case false:
        {
            DWORD out_len = BLOCK_LEN;
            if (!CryptDecrypt(hKey, NULL, i + 1 == blocks, NULL, &amp;chunk[i * BLOCK_LEN], &amp;out_len))
                goto finally;
            break;
        }
        }

    Result = true;
    goto finally;

    finally:
    {
        if (hProv)
            CryptReleaseContext(hProv, 0);
        if (hHash)
            CryptDestroyHash(hHash);
        if (hKey)
            CryptDestroyKey(hKey);

        if (Result)
            return std::string(reinterpret_cast&lt;char*&gt;(chunk));
        else
            return """";
    }
}

int main()
{
    std::string key = ""12345"";
    std::string data = ""aaaaaabbbbbb"";
    std::string encdata = AES128(key, data, true);
    std::string decdata = AES128(key, encdata, false);

    printf(""%s =&gt; %s =&gt; %s"", data.c_str(), encdata.c_str(), decdata.c_str());
    system(""pause"");
}
</code></pre>

<p>Sorry bad English, I'm Brazilian.</p>
","<p>I suspect your crash is coming here:</p>

<pre><code>return std::string(reinterpret_cast&lt;char*&gt;(chunk));
</code></pre>

<p><code>chunk</code> is a completely random sequence of bytes. It may have embedded nulls. It almost certainly does not end in null. This constructor requires a null-terminated sequence of characters. I suspect it's continuing to read bytes looking for a null until it hits an invalid address and crashes.</p>

<p>AES-encrypted data is not a string of characters. It is a just bytes. You need to treat it as such. You can return it as a <code>vector&lt;BYTE&gt;</code> or you could use a Base64- or hex-encoding function to convert it into a human-readable string if that's what you need. Be sure to decode this string before trying to decrypt it.</p>
","71","<c><openssl><aes><cryptoapi>","2","1","2","2018-07-11 21:05:20","51294043","4","1","3292279","","2018-07-11 21:05:20","2018-07-11 20:03:15",""
"51293419","AES128 with CryptoAPI","<p>I'm trying to encrypt strings in AES128 using CryptoAPI, but I'm not getting it for some reason. When I compile, it simply crashes the application. I believe the problem is in the calls of the <code>CryptDecrypt</code> and <code>CryptEncrypt</code> functions, as I wrote this function based on another that I found on the internet. I know nothing concrete about it, nor the way to use it.</p>

<p>Here is my code:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;

#pragma comment(lib, ""crypt32.lib"")

#define BLOCK_LEN 16

std::string AES128(std::string key, std::string data, bool enc)
{
    bool Result = false;
    size_t blocks = ceil((float)data.length() / BLOCK_LEN) + 1;
    BYTE* chunk = new BYTE[blocks * BLOCK_LEN];
    memset(chunk, 0, blocks * BLOCK_LEN);
    memcpy(chunk, data.c_str(), data.length());

    HCRYPTPROV hProv;
    if (!CryptAcquireContextA(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
        goto finally;

    HCRYPTHASH hHash;
    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash))
        goto finally;

    if (!CryptHashData(hHash, (BYTE*)key.c_str(), key.length(), 0))
        goto finally;

    HCRYPTKEY hKey;
    if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &amp;hKey))
        goto finally;

    for (int i = 0; i &lt; blocks; i++)
        switch (enc)
        {
        case true:
        {
            DWORD out_len = BLOCK_LEN;
            if (!CryptEncrypt(hKey, NULL, i + 1 == blocks, NULL, &amp;chunk[i * BLOCK_LEN], &amp;out_len, blocks * BLOCK_LEN))
                goto finally;
            break;
        }

        case false:
        {
            DWORD out_len = BLOCK_LEN;
            if (!CryptDecrypt(hKey, NULL, i + 1 == blocks, NULL, &amp;chunk[i * BLOCK_LEN], &amp;out_len))
                goto finally;
            break;
        }
        }

    Result = true;
    goto finally;

    finally:
    {
        if (hProv)
            CryptReleaseContext(hProv, 0);
        if (hHash)
            CryptDestroyHash(hHash);
        if (hKey)
            CryptDestroyKey(hKey);

        if (Result)
            return std::string(reinterpret_cast&lt;char*&gt;(chunk));
        else
            return """";
    }
}

int main()
{
    std::string key = ""12345"";
    std::string data = ""aaaaaabbbbbb"";
    std::string encdata = AES128(key, data, true);
    std::string decdata = AES128(key, encdata, false);

    printf(""%s =&gt; %s =&gt; %s"", data.c_str(), encdata.c_str(), decdata.c_str());
    system(""pause"");
}
</code></pre>

<p>Sorry bad English, I'm Brazilian.</p>
","<p>Your calculations are off: <code>ceil((float)data.length() / BLOCK_LEN) + 1</code> is <code>2</code> for a <code>12</code>-byte input.</p>

<p>But you don't need to encrypt in chunks, the crypt API can handle chunking for you. Just call it once for the entire input.</p>

<p>Here's a modified version that works:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;wincrypt.h&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;

#pragma comment(lib, ""crypt32.lib"")

#define BLOCK_LEN 16

std::string AES128(const std::string&amp; key, const std::string&amp; data, bool enc)
{
    std::string result = data;
    bool Result = false;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    HCRYPTKEY hKey = NULL;
    result.resize((data.length() + BLOCK_LEN - 1) &amp; ~(BLOCK_LEN - 1));
    DWORD out_len = data.length();

    do {
        if (!CryptAcquireContextA(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
            break;

        if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash))
            break;

        if (!CryptHashData(hHash, (const BYTE*)key.c_str(), key.length(), 0))
            break;

        if (!CryptDeriveKey(hProv, CALG_AES_128, hHash, 0, &amp;hKey))
            break;

        if (enc)
        {
            if (!CryptEncrypt(hKey, NULL, TRUE, 0, (BYTE*)result.data(), &amp;out_len, result.length()))
                break;
        }
        else
        {
            if (!CryptDecrypt(hKey, NULL, TRUE, 0, (BYTE*)result.data(), &amp;out_len))
                break;
        }

        result.resize(out_len);
        Result = true;
    } while (false);

    if (hKey)
        CryptDestroyKey(hKey);
    if (hHash)
        CryptDestroyHash(hHash);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    if (!Result)
        result = """";
    return result;
}

int main()
{
    std::string key = ""12345"";
    std::string data = ""aaaaaabbbbbb"";
    std::string encdata = AES128(key, data, true);
    std::string decdata = AES128(key, encdata, false);

    printf(""%s =&gt; %s =&gt; %s\n"", data.c_str(), encdata.c_str(), decdata.c_str());
}
</code></pre>
","71","<c><openssl><aes><cryptoapi>","2","2","2","2018-07-11 21:05:20","51294043","4","1","3292279","","2018-07-11 21:05:20","2018-07-11 20:03:15",""
"55249755","CryptDecryptMessage returns CRYPT_E_NO_DECRYPT_CERT when executed inside service running under LSA","<p>I created an RSA Certificate with a Private Key in LocalMachine/My store.</p>

<p>I then created a simple Windows console app in C to:</p>

<ul>
<li>locate the cert by thumbprint</li>
<li>encrypt a buffer with <code>CryptEncryptMessage</code></li>
<li>write the buffer out to a file</li>
</ul>

<p>I then wrote a small service app, also in C to:</p>

<ul>
<li>read the buffer</li>
<li>decrypt with <code>CryptDecryptMessage</code></li>
</ul>

<p>It all works fine as long as the service app is not running under the Local System Account (LSA). In that case, <code>CryptDecryptMessage</code> generates <code>CRYPT_E_NO_DECRYPT_CERT (0x8009200C)</code>. This is despite that the Cert is in LocalMachine/My</p>

<p>I tried to strip down the code as much as possible but it is still rather long. I'm hoping there is some flag setting I am getting wrong. Or is this expected behavior? Thanks for taking a look.</p>

<h1>Windows console app</h1>

<pre><code>int __cdecl main(int argc, CHAR* argv[])
{
    HCERTSTORE hSysStore = NULL;
    DWORD err;
    PCHAR    certThumbprint   = ""14FE20556FC106DA4C561707ABDFEACEB8CAAC98"";
    PCERT_CONTEXT pContext = NULL;
    BYTE*    pbEncryptedBlob = NULL;
    DWORD    cbEncryptedBlob;
    BYTE bPlain[255] = {0};
    DWORD cbContent;
    strcpy_s(bPlain, sizeof(bPlain)-1, argv[1]);
    cbContent = strlen(bPlain)+1;
    err = myGetCertFromThumb(CERT_SYSTEM_STORE_LOCAL_MACHINE, L""MY"", certThumbprint, &amp;hSysStore, &amp;pContext);
    if (err != 0)
        goto cleanup;
    pbEncryptedBlob = malloc(BUF_SZ);
    cbEncryptedBlob = BUF_SZ;
    /**** code below ****/
    err = myEncryptMsg(pContext, bPlain, cbContent, pbEncryptedBlob, &amp;cbEncryptedBlob);
    if (err != 0)
        goto cleanup;
    printf(""Encrypted msg size=%d\n"", cbEncryptedBlob);

    /****  write cbEncryptedBlob to file  ****/

cleanup:
    if (pbEncryptedBlob)
        free(pbEncryptedBlob);
    if (pContext)
        CertFreeCertificateContext(pContext);
    if (hSysStore != NULL)
        CertCloseStore(hSysStore, CERT_CLOSE_STORE_CHECK_FLAG);
    return(err);
}

DWORD myEncryptMsg(PCERT_CONTEXT pContext, BYTE* pbPlain, DWORD cbPlainszsz, BYTE* pbCipher, DWORD *pcbCiphersz)
{
    BOOL rc;
    DWORD err;
    PCCERT_CONTEXT RecipientCertArray[1];
    DWORD EncryptAlgSize;
    HCRYPTPROV hCryptProv;
    CRYPT_ALGORITHM_IDENTIFIER EncryptAlgorithm;
    CRYPT_ENCRYPT_MESSAGE_PARA EncryptParams;
    DWORD EncryptParamsSize;
    rc = CryptAcquireContext(
        &amp;hCryptProv,        // Address for handle to be returned.
        NULL,               // Use the current user's logon name.
        NULL,               // Use the default provider.
        PROV_RSA_FULL,      // Need to both encrypt and sign.
        0);              // No flags needed.
    if (rc) 
        goto keyset_exists;
    err = GetLastError();
    if (err != NTE_BAD_KEYSET)
        goto cleanup;
    rc = CryptAcquireContext(
        &amp;hCryptProv,        // Address for handle to be returned.
        NULL,               // Use the current user's logon name.
        NULL,               // Use the default provider.
        PROV_RSA_AES,      // Need to both encrypt and sign.
        CRYPT_NEWKEYSET);              // No flags needed.
    if (!rc) 
    {
        err = GetLastError();
        goto cleanup;
    }
keyset_exists:
    RecipientCertArray[0] = pContext;
    EncryptAlgSize = sizeof(EncryptAlgorithm);
    memset(&amp;EncryptAlgorithm, 0, EncryptAlgSize);
    EncryptAlgorithm.pszObjId = szOID_NIST_AES256_CBC;
    EncryptParamsSize = sizeof(EncryptParams);
    memset(&amp;EncryptParams, 0, EncryptParamsSize);
    EncryptParams.cbSize =  EncryptParamsSize;
    EncryptParams.dwMsgEncodingType = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
    EncryptParams.hCryptProv = hCryptProv;
    EncryptParams.ContentEncryptionAlgorithm = EncryptAlgorithm;
    rc = CryptEncryptMessage(
        &amp;EncryptParams,
        1,
        RecipientCertArray,
        pbPlain,
        cbPlainszsz,
        pbCipher,
        pcbCiphersz);
    if (!rc)
    {
        err = GetLastError();
        goto cleanup;
    }
    err = 0;
cleanup:
    if(hCryptProv)
        CryptReleaseContext(hCryptProv,0);
    return(err);
}
</code></pre>

<h1>Windows Service App</h1>

<pre><code>BYTE * someRoutineInsideService()
{
    DWORD err;
    BYTE*    pbEncryptedBlob = NULL;
    DWORD    cbEncryptedBlob;
    BYTE* pbDecryptedMessage = NULL;
    DWORD cbDecryptedMessage;
    pbEncryptedBlob = malloc(BUF_SZ);
    cbEncryptedBlob = BUF_SZ;

    /**** read pbEncryptedBlob from file ****/

    pbDecryptedMessage = malloc(BUF_SZ);
    cbDecryptedMessage = BUF_SZ;
    /**** code below ****/
    err = myDecryptMessage(""MY"", pbEncryptedBlob, cbEncryptedBlob, pbDecryptedMessage, &amp;cbDecryptedMessage);
    if (err != 0)
        goto cleanup;
cleanup:
    if (pbEncryptedBlob)
        free(pbEncryptedBlob);
    return(pbDecryptedMessage);
}

DWORD myDecryptMessage(LPSTR cStore, BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecryptedMessage, DWORD *cbDecryptedMessage)
{
    HCERTSTORE CertStoreArray[1];
    CRYPT_DECRYPT_MESSAGE_PARA  DecryptParams;
    DWORD  DecryptParamsSize = sizeof(DecryptParams);
    HCRYPTPROV hCryptProv = 0;                      // CSP handle
    HCERTSTORE hStoreHandle = 0;
    DWORD err = 0;
    BOOL rc;
    rc = CryptAcquireContext(
        &amp;hCryptProv,        // Address for handle to be returned.
        NULL,               // Use the current user's logon name.
        NULL,               // Use the default provider.
        PROV_RSA_FULL,      // Need to both encrypt and sign.
        0);              // No flags needed.
    if (!rc)
    {
        err = GetLastError();
        goto cleanup;
    }
    hStoreHandle = CertOpenSystemStore(hCryptProv, cStore);
    if (hStoreHandle == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }
    CertStoreArray[0] = hStoreHandle;
    memset(&amp;DecryptParams, 0, DecryptParamsSize);
    DecryptParams.cbSize = DecryptParamsSize;
    DecryptParams.dwMsgAndCertEncodingType = (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING);
    DecryptParams.cCertStore = 1;
    DecryptParams.rghCertStore = CertStoreArray;
    rc = CryptDecryptMessage(
              &amp;DecryptParams,
              pbEncryptedBlob,
              cbEncryptedBlob,
              pbDecryptedMessage,
              cbDecryptedMessage,
              NULL);
    if (!rc)
    {
        err = GetLastError();    
        /**** returns 0x8009200C (CRYPT_E_NO_DECRYPT_CERT) if service run under LSA ****/
        goto cleanup;
    }
cleanup:
    if(hCryptProv)
        rc = CryptReleaseContext(hCryptProv,0);
    return(err);
}
</code></pre>
","","67","<c><windows><service><certificate><cryptoapi>","0","","0","2019-03-19 20:49:49","","7","","","","","2019-03-19 20:49:49",""
"53741229","How to save encryption key in registry in CryptoAPI?","<p>I am new to MFC and CryptoAPI. I want to encrypt trace files in my application.
The key derived successfully using a password and I am able to encrypt the data. The encrypted data written in a file. While opening the file again the key becomes 0 since I haven't stored it anywhere.</p>

<p>I am planning to store the key generated to the registry.</p>

<pre><code>bool CCrypto::DeriveKey(CString strPassword)
{
    //  Return failure if we don't have a context or hash.
    if(m_hCryptProv == NULL || m_hHash == NULL)
        return false;

    //  If we already have a hash, trash it.
    if(m_hHash)
    {
        CryptDestroyHash(m_hHash);
        m_hHash = NULL;
        if(!CryptCreateHash(m_hCryptProv, CALG_MD5, 0, 0, &amp;m_hHash)) 
            return false;
    }

    //  If we already have a key, destroy it.
    if(m_hKey)
    {
        ::CryptDestroyKey(m_hKey);
        m_hKey = NULL;
    }

    //  Hash the password. This will have a different result in UNICODE mode, as it
    //  will hash the UNICODE string (this is by design, allowing for UNICODE passwords, but
    //  it's important to be aware of this behaviour.
    if(!CryptHashData(m_hHash, (const BYTE*)(LPCSTR)strPassword, strPassword.GetLength() * sizeof(TCHAR), 0)) 
        return false;

    //  Create a session key based on the hash of the password.
    if(!CryptDeriveKey(m_hCryptProv, CALG_RC2, m_hHash, CRYPT_EXPORTABLE, &amp;m_hKey))
        return false;

    HKEY subKey;
    char data[256] = """";
    unsigned long length = 255;
    DWORD disposition;
    char main_key[256] = ""Software\\HFS Internal Interface"";
    if (RegCreateKeyEx(HKEY_CURRENT_USER, main_key, 0, """", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;subKey, &amp;disposition) == ERROR_SUCCESS) {
        RegSetValueEx(subKey, ""Encryption"", 0, REG_SZ, (unsigned char *)m_hKey, length);
    }
    //  And we're done.
    return true;
}
</code></pre>

<p>But when <code>m_hKey</code> of type <code>HCRYPTKEY</code> gets converted to Unicode characters. I need to store the correct key in registry. Any help appreciated.</p>
","<p>you serialize handle to the key, not the key data
probably you should export key after encryption via CryptExportKey
and import it in decryption via CryptImportKey</p>

<p>Moreover, if you derive your key from the hash, why not to store the hash in a registry, and then derive it from this hash again</p>
","67","<visual-c++><mfc><aes><cryptoapi>","0","0","1","2019-01-15 15:41:56","","5","1","","","","2018-12-12 10:42:38",""
"42890377","Cryptographic API vs manually implemented algorithm","<p>I tried to search across the internet, but was unable to find something.
So question is: What is better to use? OS provided cryptographic API or manually implemented/library provided algorithms?</p>

<p>I know that, when CPU enters in kernel mode after OS system call, it consumes large amount of CPU cycles, but on the other hand I know that OS can use hardware accerelated cryptography. So what is situation in real world? Is it worth to use OS Cryptographic API?</p>

<p>For example project that I work on, uses CRC32 and MD5 algorithms.</p>

<p>EDIT: My primary goal is to select fastest approach and secondary is to know all cons and pros.</p>
","<p>MD5 is probably available everywhere. CRC32 is so simple (and not really cryptography) that you can just include or implement it directly in your application.</p>

<p>The Windows crypto API supports <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380243(v=vs.85).aspx"" rel=""nofollow noreferrer"">multiple providers</a> and the default provider is probably fully implemented in user mode without switching to kernel mode for most things. The PRng and AES encryption might be implemented in hardware.</p>

<p>What is your goal? Speed? No backdoors? Obscure algorithms?</p>
","64","<c><linux><windows><optimization><cryptoapi>","-1","1","2","2017-03-19 18:57:43","42890627","6","","6099096","","2017-03-19 18:57:43","2017-03-19 18:22:40","2017-03-19 21:19:55"
"42890377","Cryptographic API vs manually implemented algorithm","<p>I tried to search across the internet, but was unable to find something.
So question is: What is better to use? OS provided cryptographic API or manually implemented/library provided algorithms?</p>

<p>I know that, when CPU enters in kernel mode after OS system call, it consumes large amount of CPU cycles, but on the other hand I know that OS can use hardware accerelated cryptography. So what is situation in real world? Is it worth to use OS Cryptographic API?</p>

<p>For example project that I work on, uses CRC32 and MD5 algorithms.</p>

<p>EDIT: My primary goal is to select fastest approach and secondary is to know all cons and pros.</p>
","<p>There are hardware accelerators for TLS but are are used primarily for public key encryption. Unless you have specialized Bitcoin mining hardware, hashing will be done userside and in software. Use what is most convenient.</p>
","64","<c><linux><windows><optimization><cryptoapi>","-1","0","2","2017-03-19 18:57:43","42890627","6","","6099096","","2017-03-19 18:57:43","2017-03-19 18:22:40","2017-03-19 21:19:55"
"40718952","NTLM Authentications fired from X509Chain Build function","<p>We have recently been challenged by the network team on the failed NTLM authentications captured by AD domain controller. The requests were fired from one of Services hosted on a Windows 2008 Server which have joined the domain. 
The service is using a local system account to logon. It is reason why failed NTLM login has been captured as there was no failed login captured by using a domain user login. But the domain user login is not allowed by the company policy.</p>

<p>With the Wireshark tool, we have found the requests come from the X509Chain object's Build function. This is the default function provided by .NET framework and we cannot find any useful supporting document to: </p>

<ol>
<li>Explain why the NTLM requests are fired</li>
<li>Prove there was no security threat from the requests</li>
<li>How to configure in the application level to avoid the failed log in requests (changing the policy rule or AD audit is not allowed)</li>
</ol>

<p>Part of the code  (VB.NET):</p>

<pre><code>        Dim chnCerts As X509Chain = New X509Chain()
        chnCerts.ChainPolicy.RevocationFlag = X509RevocationFlag.EndCertificateOnly
        chnCerts.ChainPolicy.RevocationMode = X509RevocationMode.Online

        chnCerts.ChainPolicy.UrlRetrievalTimeout = New TimeSpan(0, 0, 120)
        chnCerts.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag

        If certType = Crypto.CertType.PrivateKeyCert Then
            certPrivateValidationStatus = Nothing
            chnCerts.Build(certPrivate)
</code></pre>
","<p>As an AD and PKI guy, I find the conclusion suspect.  Chain verification has nothing to do with NTLM.  Certs and CRLs (AIAs and CDP) should be over HTTP and use anonymous auth.  It could be that you have a home grown PKI that is misconfigured and the AIA or CDP is requesting auth. I'd love to see the wireshark capture...  </p>
","61","<.net><security><x509certificate><ntlm><cryptoapi>","0","0","2","2016-11-21 18:21:11","","0","","","","","2016-11-21 11:23:07",""
"40718952","NTLM Authentications fired from X509Chain Build function","<p>We have recently been challenged by the network team on the failed NTLM authentications captured by AD domain controller. The requests were fired from one of Services hosted on a Windows 2008 Server which have joined the domain. 
The service is using a local system account to logon. It is reason why failed NTLM login has been captured as there was no failed login captured by using a domain user login. But the domain user login is not allowed by the company policy.</p>

<p>With the Wireshark tool, we have found the requests come from the X509Chain object's Build function. This is the default function provided by .NET framework and we cannot find any useful supporting document to: </p>

<ol>
<li>Explain why the NTLM requests are fired</li>
<li>Prove there was no security threat from the requests</li>
<li>How to configure in the application level to avoid the failed log in requests (changing the policy rule or AD audit is not allowed)</li>
</ol>

<p>Part of the code  (VB.NET):</p>

<pre><code>        Dim chnCerts As X509Chain = New X509Chain()
        chnCerts.ChainPolicy.RevocationFlag = X509RevocationFlag.EndCertificateOnly
        chnCerts.ChainPolicy.RevocationMode = X509RevocationMode.Online

        chnCerts.ChainPolicy.UrlRetrievalTimeout = New TimeSpan(0, 0, 120)
        chnCerts.ChainPolicy.VerificationFlags = X509VerificationFlags.NoFlag

        If certType = Crypto.CertType.PrivateKeyCert Then
            certPrivateValidationStatus = Nothing
            chnCerts.Build(certPrivate)
</code></pre>
","<p>Check your certificate properties.  It probably has an <code>ldap://</code> based Authority Information Access or CRL Distribution Point endpoint registered, which are registered in the cert properties by Windows Certificate Services (by default... when it's the CA and it's domain-attached).</p>

<p>The LDAP endpoint means (for Windows) ""in Active Directory"", so it's trying to access AD to download the data.  When that fails it moves on to the second entry, which is probably <code>http://</code>.  (And even if it isn't listed first, it's possible that Windows prefers LDAP to HTTP)</p>

<pre><code>[1]CRL Distribution Point
 Distribution Point Name:
      Full Name:
           URL=ldap:///CN=Our%20Corp%20CA,CN=CRL,CN=CDP,CN=Public%20Key%20Services,CN=Services,CN=Configuration,DC=corp,DC=ourcorp,DC=com?certificateRevocationList?base?objectClass=cRLDistributionPoint
           URL=http://corppki/crl/Our%20Corp%20CA.crl
           URL=http://crl.ourcorp.com/crl/Our%20Corp%20CA.crl
</code></pre>
","61","<.net><security><x509certificate><ntlm><cryptoapi>","0","0","2","2016-11-21 18:21:11","","0","","","","","2016-11-21 11:23:07",""
"56754400","Accessing memory pointed to by PAnsiChar in Inno Setup Pascal Script","<p>Need to Use the Win32 encryption API to convert password to encrypted blob before passing to child process.</p>

<p>Trying to use <code>CryptProtectData@crypt32.dll</code> API to perform the encryption.
The function is returning success. But I'm facing issue while accessing the returned encrypted blob.</p>

<p>Tried to use the <code>StrPas()</code> to convert the <code>PAnsiChar</code> to <code>AnsiString</code>, but I get <em>""Invalid identifier""</em> error.</p>

<pre class=""lang-pascal prettyprint-override""><code>const
  CRYPTPROTECT_LOCAL_MACHINE = $4;

type
  DataBlob = record
    cbData: Longword;
    pbData: PAnsiChar;
  end;

function CryptProtectData(var pDataIn: DataBlob;
  szDataDescr, pOptionalEntropy, pvReserved, pPromptStruct : DWORD;
  dwFlags: DWORD; var pDataOut: DataBlob): Boolean;
  external 'CryptProtectData@crypt32.dll stdcall delayload';

var
  Password: AnsiString;

function Encrypt(): Boolean;
var
  DataBlobIn, DataBlobOut: DataBlob
  EncryptStr: AnsiString;
begin
  DataBlobIn.cbData := Length(Password);
  DataBlobIn.pbData := Password;
  if CryptProtectData(DataBlobIn, 0, 0, 0, 0, CRYPTPROTECT_LOCAL_MACHINE, DataBlobOut) then
  begin
    Log('Success');

    { Using StrPas gives an 'unknown identifier error' }
    EncryptStr := StrPas(DataBlobOut.pbData);
  end;
end;
</code></pre>

<p>The size of the return memory blob is <code>DataBlobOut.cbData</code>, 
but how to access the memory blob returned in <code>DataBlobOut.pbData</code>?</p>

<p>Can you please point to some sample code where we can access the memory of length X?</p>
","<p>To copy data from a memory pointer to an Inno Setup buffer-like variable (such as <code>AnsiString</code>), you can use <a href=""https://docs.microsoft.com/en-us/windows/win32/devnotes/rtlmovememory"" rel=""nofollow noreferrer""><code>RtlMoveMemory</code> WinAPI function</a>:</p>

<pre class=""lang-pascal prettyprint-override""><code>procedure RtlMoveMemory(Dest: AnsiString; Source: PAnsiChar; Len: Integer);
  external 'RtlMoveMemory@kernel32.dll stdcall';
</code></pre>

<p>You can use it like:</p>

<pre class=""lang-pascal prettyprint-override""><code>{ Allocate memory }
SetLength(EncryptStr, DataBlobOut.cbData);
{ Copy data }
RtlMoveMemory(EncryptStr, DataBlobOut.pbData, DataBlobOut.cbData);
</code></pre>
","60","<winapi><inno-setup><pascalscript><cryptoapi>","1","1","1","2019-07-15 07:07:37","56755768","2","1","850848","","2019-06-27 08:29:43","2019-06-25 12:45:06",""
"56572249","How to access Kucoin OHLC data from API?","<p>I need to access kucoin Open-high-low-close data from Kucoin API.</p>

<p>Looking in <a href=""https://docs.kucoin.com/#get-trade-histories"" rel=""nofollow noreferrer"">https://docs.kucoin.com/#get-trade-histories</a>, I deduced that to access OHLC data (for instance BTC versus USDT, with hourly timestamp), the address should be something like this : </p>

<pre><code>https://api.kucoin.com/api/v1/market/candles?symbol=BTC-USDT&amp;type=1hour
</code></pre>

<p>Doing that, I get empty list for the data <code>{'code': '200000', 'data': []}</code>
(according to kucoin API doc, code <code>200000</code> correspond to a good request)</p>

<p>What I am doing wrong ?</p>

<p>ps : same method worked very well on kraken api (e.g. <a href=""https://api.kraken.com/0/public/OHLC?pair=xbtusd"" rel=""nofollow noreferrer"">https://api.kraken.com/0/public/OHLC?pair=xbtusd</a> )</p>

<p>Thank you very much in advance for your help !</p>
","<p>Kukoin docs also mention two more arguments: startAt and endAt that are start and end of time interval in unix time format.</p>

<p>I tried </p>

<pre><code>curl ""https://api.kucoin.com/api/v1/market/candles?symbol=BTC-USDT&amp;type=1hour&amp;startAt=1562460061&amp;endAt=1562467061""
</code></pre>

<p>(7000 seconds interval).</p>

<p>and got the result</p>

<pre><code>{""code"":""200000"",""data"":[[""1562464800"",""11233.3"",""11186.4"",""11236.1"",""11185.2"",""145.83911572"",""1635403.570428367""],[""1562461200"",""11196.7"",""11227.2"",""11236.5"",""11163.9"",""179.29402628"",""2009821.31982076""]]}
</code></pre>
","59","<json><api><bitcoin><cryptoapi><cryptocurrency>","3","2","1","2019-07-07 02:46:59","56919000","0","1","11639720","","2019-06-13 12:05:30","2019-06-13 01:32:15",""
"43711617","CryptGetProvParam and multithreaded programs","<p>The MSDN documentation for <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa380196(v=vs.85).aspx"" rel=""nofollow noreferrer"">CryptGetProvParam</a> says </p>

<p><em>This function must not be used on a thread of a multithreaded program.</em></p>

<p>I'm hoping there is some set of conditions under which it can be used that way. Does anyone have any experience in this area and can tell me a work-around?</p>

<p>Thanks.</p>
","<p>Some of the MSDN documentation is written by interns and the quality is not always great. They are clearly talking about issues related to calling this function from multiple threads at the same time, not just having multiple threads in the process.</p>

<p>If you look at some of the query values and how the API is designed it should be easy to spot the queries that <strong>cannot</strong> work with multiple threads. Anything that uses <code>CRYPT_FIRST</code>/<code>NEXT</code> (<code>PP_*ENUM*</code>) will have to rely on some internal state to remember ""where it is"". These queries have the thread warning in their description as well.</p>

<p>This does not mean that the other queries are thread safe but I would imagine that they are. You could debug the functions but things might change over time/versions and parts of the crypto system is extensible as well so you can never truly know without official information from Microsoft. You can add feedback to the MSDN page and hope that they update it.</p>
","55","<windows><security><cryptoapi>","1","2","1","2017-04-30 23:25:43","43712407","2","1","","","","2017-04-30 21:40:48",""
"57106715","Incorrect output when decoding rsa string","<p>I have made this code, it's encrypting string and converting it to base64 string (so I can copy it).</p>

<pre><code>void EncryptString(std::string data)
{
DWORD strlen = data.size() * sizeof(char);

unsigned char* buffer = new unsigned char[0];

buffer = (LPBYTE)malloc(strlen);

std::copy(data.begin(), data.end(), buffer);

DWORD lenght = 0;

if (!CryptEncrypt(hKey, 0, TRUE, 0, NULL, &amp;lenght, NULL))
{
    ExitThread(0);
}

buffer = (LPBYTE)malloc(lenght);

if (!CryptEncrypt(hKey, 0, TRUE, 0, buffer, &amp;strlen, lenght))
{
    ExitThread(0);
}

DWORD dlen2 = 0;
if (!CryptBinaryToString(buffer, lenght, CRYPT_STRING_BASE64, NULL, &amp;dlen2))
{
    ExitThread(0);
}

TCHAR* tempo = new TCHAR[dlen2];

if (!CryptBinaryToString(buffer, lenght, CRYPT_STRING_BASE64, tempo, &amp;dlen2))
{
    ExitThread(0);
}

for (int i = 0; i &lt; dlen2; i++) 
{
    printf(""%c"", tempo[i]);
}
}
</code></pre>

<p>I got string like this:</p>

<blockquote>
  <p>li2b5qyVGbwJw6qAIitPRFI5BbRua2W0hJ1y6YLCKOOOkvQg3i4gZbUd3vaRzKRP
  F5rHd9HvGTxHX6hOsJah8LfBeftf3ZBrE+F/zcGKQqcENesrxNpm1yLZDtaJdMbZ
  JcdNcP/JoyVuvS2Gbc0I35chzBCRafwtRLD41aIdNfxnLw9+R4CQQ8BmKUUD8U7d
  2wLIZzW+kPSWBLYw2JU69x0H8e2rA1AhJEqnGtypfeOKxTmOzvCzQQFaykp4vLyp
  t7MoIjArwhNqdpajKfVtu74hUmn2OgLX6FfO8x1bRs61NUnF9f2PniTzI4pyVAjx
  +MQioBwlro/xLjnOn4vppne6w4cbLzH8JIZC9Zqhn1LFGBE5fAlstlrv3onHfRdm yTvgLxGqFC8RdJ6uEuS10u7EBC/Whq4Ti4XpyET/ILmIHlZmK9mVICE7c95DirTS
  ejqNQNODmZtqgs4+sJLyFSZV3bkzKyIjrl9K1riAozLFdS8OeeAdbilEFpBXWLy9
  5Q1xPkhRasauHMYRkv13pH58zaqcoHF/ThKHg+uPbY8dByfM/9v+igSK/fr88S49
  iHam92vIpia+6SbJxilg+00jpMn+ZinLweHPG/kngbENbxFE4m9HbbZC9Vk8NAbG
  uMiVP8kL0UL5cuKxR771sav1tXQInNuJOKZ+g9qixlg=</p>
</blockquote>

<p>When I try to decrypt it, I'm getting string like this:
<a href=""https://i.stack.imgur.com/9756t.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9756t.png"" alt=""pic""></a>
What I'm doing wrong?</p>

<p>Decrypting:</p>

<pre><code>void Decrypt()
{
DWORD dlen = 0;
if (!CryptStringToBinary(dataKey, strlen(dataKey), CRYPT_STRING_BASE64, NULL, &amp;dlen, NULL, NULL))
{
    printf(""Error while getting size... %d\n"", GetLastError());
    exit(0);
}

BYTE* temp;
if (!(temp = (LPBYTE)malloc(dlen)))
{
    printf(""Out of memory %d\n"", GetLastError());
    exit(0);
}

if (!CryptStringToBinary(dataKey, strlen(dataKey), CRYPT_STRING_BASE64, temp, &amp;dlen, NULL, NULL))
{
    printf(""Error while converting to base64 string... %d\n"", GetLastError());
    exit(0);
}

if (!CryptDecrypt(hKey, NULL, true, 0, temp, &amp;dlen))
{
    printf(""Can't get lenght! %d"", GetLastError());
    exit(0);
}

for (DWORD i = 0; i &lt; dlen; i++)
{
    printf(""%c"", temp[i]);
}
printf(""\n"");
}
</code></pre>
","<p><code>unsigned char buffer[512];</code> instead of <code>unsigned char* buffer = new unsigned char[0];</code></p>
","55","<c++><rsa><cryptoapi>","0","0","1","2019-07-19 06:47:11","","9","","11725000","","2019-07-19 06:40:14","2019-07-19 06:27:29",""
"56322382","Why does DirectoryEntry.Invoke(""SetPassword"", value) trigger Credential Required CryptoAPI Private Key","<p>I've recently been working on some old code and, when testing, I've started seeing the ""Credential Required"" window: ""Do you want to allow the app to access your private key?  Key description: CryptoAPI Private Key.""</p>

<p><a href=""https://i.stack.imgur.com/MSIYT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/MSIYT.png"" alt=""Credential Required: CyrptoAPI Private Key""></a></p>

<p>It happens at this line of code:</p>

<pre><code>object result = this.m_DirectoryEntry.Invoke(MethodName, Argument);
</code></pre>

<p>where <code>MethodName</code> is <code>SetPassword</code>.</p>

<p>Clicking 'Don't Allow' still allows the method to proceed.</p>

<p>It also happens when I run the application outside of Visual Studio.  This will not be an acceptable user experience.</p>

<p>Why is it happening?
How can I stop it?</p>

<p>I'm using Visual Studio Community 2015 Update 3 on a Server 2016 machine.  The project uses .NET 4.5.2.</p>

<h2>Code to recreate</h2>

<p>New solution.
In the project Properties, set Target framework to .NET Framework 4.5.2.
Add a reference to System.DirectoryServices.</p>

<pre><code>namespace SetPasswordCryptoApiTester1
{
    using System;
    using System.DirectoryServices;

    class Program
    {
        static void Main(string[] args)
        {
            var adsPath = ""LDAP://CN=path_to_user"";

            using (var de = new DirectoryEntry(adsPath))
            {
                Console.WriteLine(""Press a key to set the password..."");
                Console.ReadKey(true);

                object result = de.Invoke(""SetPassword"", ""Sausag32"");

                Console.WriteLine(""Press a key to continue..."");
                Console.ReadKey(true);
            }
        }
    }
}
</code></pre>
","<p>Maybe you've already worked around this, but I thought I'd answer anyway. Although I can't say for certainty what's happening.</p>

<p>That calls the <code>SetPassword</code> method on the native Windows <code>IADsUser</code> object. In the <a href=""https://docs.microsoft.com/en-us/windows/win32/api/iads/nf-iads-iadsuser-setpassword#remarks"" rel=""nofollow noreferrer"">Remarks section of the documenation</a> it describes 3 methods it tries to reset the password. It's possible that one of those methods is causing the pop-up, and when you click ""Don't allow"", it just moves on to the next.</p>

<p>The first one it uses is LDAP over SSL (LDAPS). I've never seen this, but there might be something weird with the way LDAPS is setup on your domain where it's asking for a client certificate maybe?</p>

<p>You can test this theory... In PowerShell, try this:</p>

<pre><code>Invoke-WebRequest https://example.com:636
</code></pre>

<p>(Replace ""example.com"" with your domain name) You will either get a certificate error (maybe that same pop up?), but if the SSL handshake works then you should get a ""The underlying connection was closed"".</p>

<p>If you do get that pop up when trying through PowerShell, then I don't think there's anything you can do unless you're a domain admin. Something would have to change on the Domain Controller.</p>
","52","<.net><cryptoapi><adsi><directoryentry>","0","1","1","2019-07-03 12:33:03","56870265","0","","2871239","","2019-05-27 14:08:48","2019-05-27 08:31:37",""
"54402654","How to store and retrieve encryption key using blob with cryptoApi","<p>I am using blob in my encryption application to store the encryption key. </p>

<p>I am a beginner in MFC. I am using <code>CryptExportKey()</code> to export key to the blob. I have put the below code in my <code>Encrypt()</code> function. See the code in the <code>Encrypt()</code> function below,</p>

<pre><code>if (CryptGetUserKey(
    m_hCryptProv,
    AT_KEYEXCHANGE,
    &amp;hXchgKey))
{
    printf(""The key exchange key has been acquired. \n"");
}
else
{
    printf(""Error during CryptGetUserKey exchange key."");
}

if (CryptExportKey(
    m_hKey,
    hXchgKey,
    SIMPLEBLOB,
    0,
    NULL,
    &amp;dwBlobLen))
{
    _tprintf(
        TEXT(""The key BLOB is %d bytes long. \n""),
        dwBlobLen);

}

if (pbKeyBlob = (BYTE*)malloc(dwBlobLen))
{
    printf(""Memory has been allocated for the BLOB. \n"");
}

if (CryptExportKey(
    m_hKey,
    hXchgKey,
    SIMPLEBLOB,
    0,
    pbKeyBlob,
    &amp;dwBlobLen))
{
    printf(""Contents have been written to the BLOB. \n"");
}
</code></pre>

<p>Also I have put the below code in <code>Decrypt()</code> function to import the key.</p>

<pre><code>    if (!CryptImportKey(
    m_hCryptProv,
    pbKeyBlob,
    dwBlobLen,
    0,
    0,
    &amp;m_hKey))
{
    //success
}
</code></pre>

<p>The exporting succeeded but importing failed. </p>

<p>My file will be closed after encryption. When loading the application, the  decryption also fails since key is not successfully imported. During encryption and decryption the <code>m_hCryptProv</code> have different values. Is it significant in this case? I am working so longer on this encryption work. Any help appreciated.</p>
","<p>You are using exchange key when export key, so you get a blob encrypted with a <em>hXchgKey</em>. During import you also need specify <em>exchange key</em> to decrypt blob:  </p>

<pre><code>if (!CryptImportKey(
    m_hCryptProv,
    pbKeyBlob,
    dwBlobLen,
    hXchgKey,
    0,
    &amp;m_hKey))
{
    //success
}
</code></pre>

<p>From <a href=""https://docs.microsoft.com/en-us/windows/desktop/api/wincrypt/nf-wincrypt-cryptimportkey"" rel=""nofollow noreferrer"">MSDN</a>:  </p>

<blockquote>
<pre><code>BOOL CryptImportKey(
  HCRYPTPROV hProv,
  const BYTE *pbData,
  DWORD      dwDataLen,
  HCRYPTKEY  hPubKey,
  DWORD      dwFlags,
  HCRYPTKEY  *phKey
);
</code></pre>
  
  <p>hPubKey:<br>
  If the key BLOB is encrypted with the key exchange key
  pair, for example, a SIMPLEBLOB, this parameter can be the handle to
  the key exchange key.</p>
</blockquote>
","50","<encryption><visual-c++><blob><cryptoapi><visual-c++-6>","0","0","1","2019-01-30 19:45:29","","0","","","","","2019-01-28 13:04:14",""
"45759258","how to use Cryptocapital API v4, can't find sdk download link","<p>Cryptocapital.co provides API to exchange crypto currency, I want to access their API to integrate with a website, they do have a documentation here - <a href=""https://api.cryptocapital.co/v4"" rel=""nofollow noreferrer"">https://api.cryptocapital.co/v4</a> </p>

<p>and they have a sample code as below </p>

<pre><code>var key = '1234567890abcdef';
var secret = '1234567890abcdef';
var command = 'PING';
var nonce = Date.now();
var message = command + nonce;
var signature = CryptoJS.SHA1(message + key + secret);

var options = {
  url: 'https://api.cryptocapital.co/v4/ping',
  headers: {
    'key': key,
    'message': message,
    'signature': signature,
    'nonce': nonce
  }
};

request(options, function(err, res, body) {
  // do something
  // ...
});
</code></pre>

<p>There is no download link or reference to any SDK, when i run this code it says </p>

<blockquote>
  <p>request is not defined</p>
</blockquote>

<p>I don't know where to start in this specific API.</p>

<p>please see the documentation and help me on identifying what I am doing wrong.</p>
","<p>It's making the assumption that your using the popular <a href=""https://www.npmjs.com/package/request"" rel=""nofollow noreferrer"">request</a> lib to make the HTTP request.</p>

<p>You can, however, use whatever library you like. Or don't use a library at all, use <a href=""https://nodejs.org/api/https.html#https_https_get_options_callback"" rel=""nofollow noreferrer"">https.get</a>.</p>
","48","<javascript><node.js><bitcoin><cryptoapi>","0","1","1","2017-08-18 14:41:54","45759357","0","","","","","2017-08-18 14:36:39",""
"57688134","How to SSL/TLS Client Authentication on Chrome using Custom Cryptographic Service Provider (CSPs)","<p>I had already written a CSP module and it worked well. Here is a problems, I use my CSP module to browser to a web page that required ssl client authentication, and it worked on IE, but not for Chrome.
Chrome screen show error
<strong>This site can't provide a secure connection</strong>
<strong>ERR_BAD_SSL_CLIENT_AUTH_CERT</strong></p>

<p>I use chrome with enable-logging, and an WARNING occur like <code>WARNING:ssl_platform_key_win.cc(386)] Could not acquire private key: Error (0x13D) while retrieving error. (0xC0000225)</code></p>

<pre><code>HCERTSTORE hStore = NULL;
CRYPT_KEY_PROV_INFO key_prov_info = { 0 };
PCCERT_CONTEXT pCertContext = nullptr;
std::vector&lt;BYTE&gt; der_encoded_cert;

hStore = CertOpenSystemStore(NULL, L""MY"");
if (!hStore)
{
    goto Exit;
}

der_encoded_cert = LoadFromFile();

pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING, der_encoded_cert.data(), der_encoded_cert.size());
if (!pCertContext)
{
    goto Exit;
}

key_prov_info.dwProvType = MY_PROVIDER_TYPE; // Or YOUR_PROVIDER_TYPE
key_prov_info.dwKeySpec = AT_SIGNATURE; // Or AT_KEYEXCHANGE
key_prov_info.pwszContainerName = L""My key name"";
key_prov_info.dwFlags = CERT_SET_KEY_PROV_HANDLE_PROP_ID;
key_prov_info.cProvParam = L""My provider Name"";
key_prov_info.pwszProvName = nullptr;
key_prov_info.rgProvParam = 0;


if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, &amp;key_prov_info))
{
    goto Exit;
}

if (!CertAddCertificateContextToStore(hStore, pCertContext, CERT_STORE_ADD_ALWAYS, NULL))
{
    goto Exit;
}
</code></pre>

<p>How to detect this problem come from? I can only export chrome logging.</p>
","<p>Chrome browser does not use Microsoft CAPI (CryptoAPI) for cryptographic services, but it includes the BoringSSL library instead. Hence, Chrome will not have access to your custom CSP module.</p>

<p>You should be able to import the client certificate and private key (Settings -> Advanced -> Privacy and security -> Manage Certificates -> Personal -> Import).</p>

<p>You don't explain why you need a custom CSP to do this with IE as importing the cert and private key into Window's certificate store should also make ssl client certificates work without it. HTH.</p>
","46","<c><google-chrome><cryptoapi>","0","0","1","2019-08-30 13:51:50","","0","","9786210","","2019-08-28 09:44:34","2019-08-28 08:33:27",""
"56950124","How to translate CryptoApi to Cryptography API: Next Generation","<p>I am tasked with replacing some old legacy code using CryptoApi, which is deprecated, with the newer Cryptography API: Next Generation from windows. The new encryption method must produce the same result as the old one.</p>

<p>I have simplified the old methods to make it more compact (you could view it as pseudocode):</p>

<pre><code>private UIntPtr mProviderHandle = UIntPtr.Zero;
private UIntPtr mHashHandle = UIntPtr.Zero;
private UIntPtr mKeyHandle = UIntPtr.Zero;
private uint mBlockSize = 0;
private bool m_disposed;

private void Init(string pContextName, string pSharedSecret)
{
    string providerName = = ""Microsoft Base Cryptographic Provider v1.0"";
    var providerType = ProviderType.PROV_RSA_FULL; // 1
    var providerFlags = ContextOperations.CRYPT_DEFAULT; // 0
    var hashAlg = ProviderAlgorithm.CALG_MD5; // 0x8003
    var keyAlg = ProviderAlgorithm.CALG_RC2; // 0x6602
    CryptAcquireContext(ref mProviderHandle, pContextName, providerName, providerType, providerFlags);

    CryptCreateHash(mProviderHandle, hashAlg, UIntPtr.Zero, 0, ref mHashHandle);

    CryptHashData(mHashHandle, Encoding.Default.GetBytes(pSharedSecret), (uint)pSharedSecret.Length, 0))

    CryptDeriveKey(mProviderHandle, keyAlg, mHashHandle, 0, ref mKeyHandle)); 
}

public byte[] Encrypt(byte[] pData, bool pFinal = true)
{
    uint length = (uint)bytes.Length;
    uint m = 0;

    if (0 &lt; BlockSize)
    {
        // one more blocks than the number of blocks touched
        m = (uint)(((((length - 1) / BlockSize) + 1) + 1) * BlockSize);
        Array.Resize(ref bytes, (int)m);
    }
    else
    {
        m = length;
    }
    APIBOOL apiFinal = pFinal ? APIBOOL.TRUE : APIBOOL.FALSE;
    if (APIBOOL.FALSE != NativeMethods.CryptEncrypt(mKeyHandle, UIntPtr.Zero, apiFinal, 0,
            bytes, ref length, m))
    {
        Array.Resize(ref bytes, (int)length);
        encrypted = true;
    }

    return bytes;
}
</code></pre>

<p>And here is the new method:</p>

<pre><code>private byte[] EncryptCNG(byte[] data, string pSharedSecret)
{
    using (RC2CryptoServiceProvider rc2 = new RC2CryptoServiceProvider())
    {
        using (MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider())
        {
            rc2.Key = md5.ComputeHash(Encoding.Unicode.GetBytes(pSharedSecret));
            rc2.IV = new byte[rc2.BlockSize/8];
        }
        var encryptor = rc2.CreateEncryptor();
        var result = encryptor.TransformFinalBlock(data, 0, data.Length);
        return result;
    }
}
</code></pre>

<p>Both methods Encrypt() and EncryptCNG() produce a byte array with the same length and constant value (depending on the input). But the values/bytes differ. The Desired result is that the same input generates identical output. So that Encrypt can be replaced by EncryptCNG.
My Questions are whether EncryptCNG is the correct way to use the new API and if it is a correct translation of the functionality of Init + Encrypt? And if it is, Why does it generates different results?</p>

<p>Any Help is much appreciated.</p>
","","41","<c#><cryptoapi><cng>","0","","0","2019-07-09 10:24:31","","0","","3006215","","2019-07-09 10:24:31","2019-07-09 10:03:24",""
"26442712","Centralize digital certificates into a webservice inside an organization","<p>I have a specific need inside my organization and want to know if it would be possible. Any suggestion would be appreciated;</p>

<p>Inside my organization, for several reasons, there are distributed a lot of certificates installed inside each worker computers.  Each worker may have maybe 5 or 6 certificates to access several webs, sign documents, etc.  Each time a computer is broken and reinstalled, or a new worker is hired or someone is fired, the management of that certificates, become a real headache; removal, re-installation, etc.</p>

<p>I am proposing to my organization to develop some kind of certificate repository to centralize the several certificates of my organization.</p>

<p>My questions are about to the possibility to develop and change or implement the keystore o a new CSP or KSP so this new crypto provider could access a central service/server/repository to present (authenticate), and sign documents every time a specific user needs it.</p>

<p>In the case of computer reinstallation, just installing the developed driver/csp, would give access to the central certificate repository.</p>

<p>The concrete questions are if you think it would be possible to develop that driver/CSP/KSP piece of software and what is your opinion about the possibilities to implement it successfully in a maintainable way into MS-Windows environments.  How would you focus this development?, just some tips about what it would be possible or not.</p>

<p>Regards,</p>
","<p>Definitely it can be done because there are solutions like RedTrust from Evolium that do exactly this.</p>

<p>A centralized certificate store that also allows to manage the usage of the certificates.</p>
","39","<certificate><cryptoapi>","0","0","1","2015-06-18 15:46:25","","0","1","","","","2014-10-18 17:42:59",""
"54917196","CryptoAPI use CryptSignMessage sign but openssl cant verify ,how to do?","<p>cryptoapi sign code:</p>

<p>void __stdcall pkcs7_crypto_smime_signed(char * strcontext , int contentsize , char * cerbuffer ,char * cerpassword , int cersize, char ** outdata , int * outdatasize , int * outerrresult /<em>PCRYPT_DATA_BLOB pEncodedBlob, LPWSTR pwszSignerName</em>/)
{
    /<em>---------------------------------------------------------------
        Declare and initialize variables. This includes getting a 
        pointer to the message content. This sample creates 
        the message content and gets a pointer to it. In most 
        situations, the content will exist somewhere, and a 
        pointer to it will get passed to the application. 
    ---------------------------------------------------------------</em>/
    CRYPT_DATA_BLOB pEncodedBlob ;//= new CRYPT_DATA_BLOB;
    //pEncodedBlob->cbData = contentsize;
    //pEncodedBlob->pbData = (BYTE *)strcontext;</p>

<pre><code>HCERTSTORE hSystemStoreHandle;
CRYPT_SIGN_MESSAGE_PARA SignMessagePara;

//---------------------------------------------------------------
//   The message to be signed and encoded.

//BYTE* pbContent = (BYTE*) ""The quick brown fox jumped over "" \
//    ""the lazy dog."";

/*---------------------------------------------------------------
    The length of the message. This must be one more than the 
    value returned by strlen() to include the terminal NULL 
    character.
---------------------------------------------------------------*/
//DWORD cbContent = lstrlenA((char *) pbContent) + 1;

//---------------------------------------------------------------
//    Arrays to hold the message to be signed and its length.

//const BYTE *rgpbToBeSigned[1] ;
//DWORD rgcbToBeSigned[1];

//---------------------------------------------------------------
//    The signer's certificate.

PCCERT_CONTEXT pSignerCert = NULL ;//(PCCERT_CONTEXT *)malloc(sizeof(CERT_CONTEXT)) ; 
//memset((char *)pSignerCert, 0, sizeof(CERT_CONTEXT));
char * strmsg = (char *)malloc(contentsize + 1);
memset(strmsg, 0, contentsize + 1);
//---------------------------------------------------------------
//    Buffer to hold the name of the subject of a certificate.

char pszNameString[MAX_NAME];

//---------------------------------------------------------------
//  The following variables are used only in the decoding phase.

DWORD cbData = sizeof(DWORD);

//---------------------------------------------------------------
//  Begin processing. Display the original message.

//rgpbToBeSigned[0] = pbContent;
//rgcbToBeSigned[0] = cbContent;

//printf(""The original message = \n%s\n\n"",
//    rgpbToBeSigned[0]);

//---------------------------------------------------------------
// Open a certificate store.

if(hSystemStoreHandle = CertOpenStore(
    CERT_STORE_PROV_SYSTEM,
    0,
    NULL,
    CERT_SYSTEM_STORE_CURRENT_USER,
    CERTIFICATE_STORE_NAME))
{
    printf(""The certificate store is open. \n"");
}
else
{
    MyHandleError( ""Error Getting Store Handle"");
}

//_DecodePfxbCert( (LPBYTE)cerbuffer , cersize , cerpassword , pSignerCert);
{
    HCERTSTORE hCertStore = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;  


    CRYPT_DATA_BLOB dataBlob = {cersize, (BYTE *)cerbuffer};
    WCHAR * PWDS = (WCHAR *)malloc(strlen(cerpassword) + 1);
    memset(PWDS , 0 , sizeof(WCHAR) * (strlen(cerpassword) + 1) );
    swprintf(PWDS , L""%hs"" , cerpassword);
    hCertStore = PFXImportCertStore(&amp;dataBlob, PWDS /*? TEXT(pwd) : NULL*/, CRYPT_EXPORTABLE);
    if (NULL == hCertStore)
    {
        hCertStore = PFXImportCertStore(&amp;dataBlob, L"""", CRYPT_EXPORTABLE);
    }
    if (NULL == hCertStore)
    {
        return;
    }


    while(pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext))
    {       
        if (pCertContext-&gt;pbCertEncoded &amp;&amp; pCertContext-&gt;cbCertEncoded &gt; 0)
        {
            pSignerCert = CertDuplicateCertificateContext(pCertContext);
            break;
        }
    }


    CertCloseStore(hCertStore, 0);
    hCertStore = NULL;

}



if(pSignerCert == NULL)
{
    MyHandleError(""Signer certificate not found."");
}

/*---------------------------------------------------------------
Initialize the CRYPT_SIGN_MESSAGE_PARA structure. First, use 
memset to set all members to zero or NULL. Then set the values of
all members that must be nonzero.
---------------------------------------------------------------*/

memset(&amp;SignMessagePara, 0, sizeof(CRYPT_SIGN_MESSAGE_PARA));
SignMessagePara.cbSize = sizeof(CRYPT_SIGN_MESSAGE_PARA);
SignMessagePara.HashAlgorithm.pszObjId = szOID_RSA_MD2;
SignMessagePara.pSigningCert = pSignerCert;
SignMessagePara.dwMsgEncodingType = MY_ENCODING_TYPE;
SignMessagePara.cMsgCert = 1;
SignMessagePara.rgpMsgCert = &amp;pSignerCert;

/*---------------------------------------------------------------
    In two steps, sign and encode the message. First, get the 
    number of bytes required for the buffer to hold the signed 
    and encoded message.
---------------------------------------------------------------*/
const BYTE *rgpbToBeSigned[1] ;
DWORD rgcbToBeSigned[1];

memcpy_s(strmsg , contentsize + 1 , strcontext , contentsize);
rgpbToBeSigned[0] = (const BYTE *)strmsg;
rgcbToBeSigned[0] = strlen(strmsg) + 1;

DWORD dwSize = 0;
if( CryptSignMessage(
        &amp;SignMessagePara,
        FALSE,
        1,
        rgpbToBeSigned,
        rgcbToBeSigned,
        NULL,
        &amp;dwSize))
{
    printf(""The needed length is %d \n"", dwSize);
}
else
{
    MyHandleError(""Getting the length failed.\n"");
}

//---------------------------------------------------------------
//   Allocate memory for the required buffer.
memset(&amp;pEncodedBlob , 0 , sizeof(pEncodedBlob));
BYTE * p = (BYTE *)malloc(dwSize);
memset(p , 0 , dwSize);
pEncodedBlob.pbData = p;
pEncodedBlob.cbData = dwSize;
if(!pEncodedBlob.pbData)
{
    MyHandleError(""Memory allocation failed."");
}

//---------------------------------------------------------------
//   Call CryptSignMessage a second time to
//   copy the signed and encoded message to the buffer.
if( CryptSignMessage(
    &amp;SignMessagePara,
    FALSE,
    1,
    rgpbToBeSigned,
    rgcbToBeSigned,
    pEncodedBlob.pbData,
    &amp;pEncodedBlob.cbData))
{
    *outdata = (char *)malloc(pEncodedBlob.cbData);
    if(!outdata)
    {
        return;
    }

    memcpy_s(*outdata ,pEncodedBlob.cbData , pEncodedBlob.pbData , pEncodedBlob.cbData);
    *outdatasize = pEncodedBlob.cbData;
    printf(""Signing worked \n"");
}
else
{
    MyHandleError(""Signing failed.\n"");
}

//---------------------------------------------------------------
//  Clean up after signing and encoding.

if(pSignerCert)
{
    CertFreeCertificateContext(pSignerCert);
}

if(hSystemStoreHandle)
{
    CertCloseStore(hSystemStoreHandle,
        CERT_CLOSE_STORE_FORCE_FLAG);
}

return ;
</code></pre>

<p>}</p>

<p>i'm use openssl cms or smime verify failed. how to do ?
thanks! </p>
","","35","<openssl><exchange-server><sign><cryptoapi><smime>","0","","0","2019-02-28 02:23:51","","2","","11128165","","2019-02-28 02:23:51","2019-02-28 01:50:40",""
"58207191","Using AES encryption to encrypt text with N threads","<p>I have home task. I need to make implementation of AES encryption using WinCrypt.</p>

<p>I have N thread (for example 3). I have to encrypt text with this threads.</p>

<p>So, I have such code for creating contex (there is problem):</p>

<pre><code>    HCRYPTPROV hProvs;
    void hInit()
    {
        if (!CryptAcquireContext(&amp;hProvs, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT))
        {
            if (!CryptAcquireContext(&amp;hProvs, NULL, MS_ENHANCED_PROV, PROV_RSA_AES, CRYPT_NEWKEYSET | CRYPT_VERIFYCONTEXT))
            {
                printf(""%d\n"", GetLastError());
                getchar();
                ExitProcess(0);
            }
        }
        getchar();
    }
</code></pre>

<p>To encrypt a string, I must create contex for each thread or create global contex that will be used for all threads.</p>

<p>I'm using global contex.</p>

<p>When I try to create it, there is nothing. cmd is immedeatly closing. getchar() not working.</p>

<p>I tried this code on Windows 7 x32</p>

<p>Main question - what I should do to create contex for global encryption (with threads)?</p>
","","33","<c++><visual-studio><cryptoapi>","0","","0","2019-10-02 18:19:42","","0","1","","","","2019-10-02 18:19:42",""
"28538576","Best practice way to access Windows Local Machine Certificate Store from Java?","<p>Trying to access keys stuck in the Windows Certificate Store which are in the Local Machine store. MSCAPI is no help since that only provides access to the Current User and Root stores. Is there a known best-practice way of getting to the Local Machine store?</p>

<p>Everything I can find on this issue - like <a href=""https://stackoverflow.com/questions/3612962/access-local-machine-certificate-store-in-java"">this StackOverflow question</a> - is at least a few years out of date. Is JNI inevitable here?</p>
","","32","<java><encryption><java-native-interface><cryptoapi>","0","","0","2015-02-16 09:59:48","","3","","","","","2015-02-16 09:48:59","2015-02-16 22:26:47"
"57591760","Why is this decoding/encoding process giving a different buffer array?","<p>I have the following represented as an ArrayBuffer:</p>

<p><code>const encryptedMsg = await crypto.subtle.encrypt(algorithm, key, messageUTF8)</code></p>

<p>The byte length of this value is 28:</p>

<pre><code>encryptedMsg
// ArrayBuffer { byteLength: 28 }
</code></pre>

<p>When I convert this into a Uint8Array then I get the following values:</p>

<pre><code>const encryptedMsgArr = new Uint8Array(encryptedMsg)
// Uint8Array(28) [ 237, 243, 213, 127, 248, 55, 37, 237, 209, 21, … ]
</code></pre>

<p>I want to convert this into a UTF-8 cyphertext with a standard decoder and later revert that with a standard encoder:</p>

<pre><code>const encoder = new TextEncoder(""utf-8"");
const decoder = new TextDecoder(""utf-8"");
</code></pre>

<p>When decoding it:</p>

<pre><code>const cypherText = decoder.decode(encryptedMsgArr)
""���\u007f�7%��\u0015\u00113\u0012\u0016�۹o׀.:+=��\u0015\u0015""
</code></pre>

<p>But when I try to encode it back into a Uint8Array then it doesn't match up even though utf-8 encoding was specified for both.</p>

<p>In fact the above doesn't even look like it's utf-8, and the byte length does not match up either (now 46 instead of 28):</p>

<pre><code>encoder.encode(cypherText)
// Uint8Array(46) [ 239, 191, 189, 239, 191, 189, 239, 191, 189, 127, … ]
</code></pre>

<p>What am I doing wrong here?</p>

<p><strong>Goal</strong></p>

<p>To be able to export the cyphertext so it can be decrypted elsewhere at a later stage. If UTF-8 decoding of the ArrayBuffer doesn't work, the only other thing I can think of is to convert the AB into a stringified version of the array of integers and export that string, but I don't think that is a very sane methodology.</p>

<p><strong>Edit</strong></p>

<p>Actually, just declaring the encoder and decoder without utf-8 encoding fixes the issue, but @ornic has provided a nice base64 encoding/decoding function to use instead.</p>

<pre><code>const encoder = new TextEncoder();
const decoder = new TextDecoder();
</code></pre>
","<p>AFAIK the most common way is to decode your bytes to ASCII text, not UTF-8.</p>

<p>Something like that (all that code is from my current project, I found almost all of it there, on SoF):</p>

<pre><code>var bufferToBase64 = function (buffer) {
            var s = '';
            var uintArray = new Uint8Array(buffer);
            uintArray.filter(function (v) { s += String.fromCharCode(v); return false; });
            return window.btoa(s);
        };

var bytes = function (text) {
            return new Uint8Array(
               atob(text)
                  .split('')
                  .map(function (c) {
                       return c.charCodeAt(0);
                   })
            );
}
</code></pre>

<p>And the example of usage:</p>

<pre><code>test = new Uint8Array([1, 5, 167, 12])
&gt; Uint8Array(4) [1, 5, 167, 12]
test2 = bufferToBase64(test)
&gt; ""AQWnDA==""
test3 = bytes(test2)
&gt; Uint8Array(4) [1, 5, 167, 12]
</code></pre>
","32","<javascript><encoding><utf-8><cryptoapi><arraybuffer>","0","1","1","2019-08-21 13:47:55","57592917","5","","521411","","2019-08-21 13:47:55","2019-08-21 12:35:09",""
"54245908","What permissions are required to access Crypto API?","<p>An Oracle JRE 1.7 running on Win2008R2 is using the internal random seed generator (slow) instead of using the faster native generator.</p>

<p>After enabling a level of debugging, we can see the following error on stderr:</p>

<pre><code>provider: Failed to use operating system seed generator: java.io.IOException: Required native CryptoAPI features not available on this machine
</code></pre>

<p>My suspicion is that the windows account executing the JVM is missing some sort of privilege. The account is not part of the guests or domain guests group, which would cause the above error to occur.</p>

<p>Does anybody know which permissions are required in order for a windows account being able to use the Crypto API?</p>

<p>I can't see any errors in the security event log (… default logging settings).</p>
","","32","<java><windows><cryptoapi>","1","","0","2019-01-17 23:49:12","","0","","","","","2019-01-17 23:49:12",""
"54531106","Changing the endianess of a PEM-encoded private/public key pair for the purpose of CryptoAPI-compatible signatures in libcrypto","<p>I am writing a program which is able to sign and verify signatures originally made for CryptoAPI(The old Windows crypto library). The goal is to be able to sign/verify from linux.</p>

<p>However, i seem to be hitting a wall due to CryptoAPI and libcrypto having different endianess. </p>

<p>I have alread tried to reverse the order of the signature to be verified(entire 128 byte RSA-encrypted chunk with padding and all). This does not seem to be enough, and i am struggling to find a proper straight forward recipe to do this easily.</p>

<p>I found from another stackoverflow post that you need to reverse the endianess of the actual key. Therefore, i am wondering if there is any easy way of doing this, where i preferably don't have to mess around with the data myself. </p>

<p>I will stick to verification, as i assume the same workflow can be applied to a private key PEM. The situation is like this:</p>

<p>I have the public key as PEM, converted using the command</p>

<pre><code>openssl rsa -pubin -inform MS\ PUBLICKEYBLOB -in pkey_mspublic.bin -outform PEM -out pubkey.pem
</code></pre>

<p>The following is how i load the PEM into libcrypto, and verify the signature:</p>

<pre><code>BIO* certBio = BIO_new_mem_buf((void*)pubkey, -1);

RSA* rsa = NULL;
rsa = PEM_read_bio_RSA_PUBKEY(certBio, &amp;rsa,NULL, NULL);

for (int i=0; i &lt;signatureLength; i++)
{
   char tmp = expectedHashPtr[i];
   expectedHashPtr[i] = expectedHashPtr[signatureLength - 1 - i];
   expectedHashPtr[signatureLength - 1 - i] = tmp;
}

EVP_PKEY* pubKey  = EVP_PKEY_new();
EVP_PKEY_assign_RSA(pubKey, rsa);
std::cout &lt;&lt; ""pubkey size: "" &lt;&lt; EVP_PKEY_size(pubKey) &lt;&lt; std::endl;
EVP_MD_CTX* mdctx = EVP_MD_CTX_create();

if(!(mdctx = EVP_MD_CTX_create())) std::cout &lt;&lt; ""ctx create fail"" &lt;&lt; std::endl;

if(1 != EVP_VerifyInit(mdctx, EVP_md5())) std::cout &lt;&lt; ""digest init fail"" &lt;&lt; std::endl;

if(1 != EVP_VerifyUpdate(mdctx, data, 512)) std::cout &lt;&lt; ""digest fail"" &lt;&lt; std::endl;

std::cout &lt;&lt; ""finishing verify"" &lt;&lt; std::endl;
if(1 == EVP_VerifyFinal(mdctx, (unsigned char*)expectedHashPtr, signatureLength, pubKey))
{
    /* Success */
    std::cout &lt;&lt; ""Success"" &lt;&lt; std::endl;
    return true;
}
else
{
    ERR_print_errors_fp(stderr);
    std::cout &lt;&lt; ""Fail"" &lt;&lt; std::endl;
    return false;
}
</code></pre>

<p>When i run the above code, i get padding errors, which i think is happening because my key is wrong endianess, and therefore wrong:</p>

<pre><code>140278264301376:error:0407008A:rsa routines:RSA_padding_check_PKCS1_type_1:invalid padding:crypto/rsa/rsa_pk1.c:67:
140278264301376:error:04067072:rsa routines:rsa_ossl_public_decrypt:padding check failed:crypto/rsa/rsa_ossl.c:582:
</code></pre>

<p>So, my question is, is there a quick and easy way of handling endianess conversion of public and private key in PEM format? I do not want to do this by hand, as it has to scale. </p>
","","31","<endianness><cryptoapi><libcrypto>","0","","0","2019-02-05 09:23:20","","1","","","","","2019-02-05 09:23:20",""
"53965436","ccxt crypto API - Does it support OAuth access tokens?","<p>The API for ccxt.coinbase accepts API keys and secrets. How do I pass it an accessToken? That attribute does not seem to be valid.</p>

<p>All examples I see in the documentation (<a href=""https://github.com/ccxt/ccxt/wiki/Manual"" rel=""nofollow noreferrer"">https://github.com/ccxt/ccxt/wiki/Manual</a>) use API keys and I have not found an OAuth2 example.</p>

<p>I have a mobile wallet app where I want to give my users the ability to keep track of their Coinbase wallets all in one place.</p>
","<p>Judging from the <a href=""https://github.com/ccxt/ccxt/blob/master/python/ccxt/async_support/coinbase.py"" rel=""nofollow noreferrer"">source code for ccxt.coinbase</a>, there doesn't seem to be any support for passing along tokens. Although there is support for token error handling.</p>

<p>Do you have non-ccxt code that makes this possible? Maybe you could adopt it so that it can be added to the ccxt repo.</p>
","31","<node.js><cryptoapi><ccxt>","1","0","1","2018-12-29 11:24:20","","0","","","","","2018-12-28 23:35:42",""
"55533343","Visual Studio doen't show all constructors for Rfc2898DeriveBytes","<p>I am using Rfc2898DeriveBytes class for hashing passwords. And I want to use constructor which changes hashing function (<a href=""https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.rfc2898derivebytes.-ctor?view=netframework-4.7.2"" rel=""nofollow noreferrer"">MSDN</a>), but Visual studio is saying that constructor doesn't exist and only shows constructors with three parameters.</p>

<p>Previously I was using the version with three parameters which worked.</p>

<pre><code>new Rfc2898DeriveBytes(pass, salt, m_iterations);
</code></pre>

<p>This works fine.</p>

<pre><code>new Rfc2898DeriveBytes(pass, salt, m_iterations, HashAlgorithmName.SHA256);
</code></pre>

<p>This should work, but doesn't</p>
","<p>These overloads were added in .NET 4.7.2, .NET Core 2.0, and .NET Standard 2.1 (preview) - you can check this by using the .NET version selector in the top left. </p>

<p>Make sure your project is targeting one of these versions, or higher.</p>
","28","<c#><.net><visual-studio><cryptoapi>","1","1","1","2019-04-05 10:28:55","55533370","1","","1086121","","2019-04-05 10:28:55","2019-04-05 10:24:14",""
"42472935","Amazon S3 iOS Crypto class Android equivalent","<p>I am implementing an app using Amazon S3 File transfer on Android. The iOS app is already done. The iOS app calls </p>

<pre><code>NSData   *body = [Crypto decrypt:tokenString key: keyFromServer];
</code></pre>

<p>To decrypt. The Crypto class is part of the AWS iOS SDK by Amazon. I am having a hard time to find the Android counterpart for Crypto class.
Please help.</p>

<p>Thanks
Ray </p>
","","28","<android><ios><amazon-s3><cryptoapi>","1","","0","2017-02-26 19:22:08","","0","","485918","","2017-02-26 19:22:08","2017-02-26 19:11:54",""
"53886053","RC4 CryptoAPI to PHP port","<p>I am trying to emulate a working CryptoAPI RC4 encrypt/decrypt routine in PHP.  When doing so, I've run into a problem trying to recreate the CryptCreateHash +CryptHashData process.  I'm trying to figure out how CryptoAPI orders/combines the raw data when calling CryptHashData multiple times.  </p>

<p>I have tried to concatenate the two input values to the key in different ways as well as reverse the byte order, but I'm not sure how to emulate the exact steps that CryptHashData performs.</p>

<p>For example:</p>

<pre><code>// I create the hash variable, then hash a binary string using CryptHashData and then hash a secret using CryptHashData again.

BYTE baKeyRandom[10] = {87,253, ...};
::CryptCreateHash(hCryptProv, CALG_MD5, 0, 0, &amp;hSaveHash);
::CryptHashData(hSaveHash, baKeyRandom, (DWORD)sizeof(baKeyRandom), 0);
::CryptHashData(hSaveHash, (LPBYTE)T2CW(pszSecret), (DWORD)_tcslen(pszSecret) * sizeof(WCHAR), 0); 

Then in PHP I'm trying to do something similar

// server key secret
$secret = 'ABCDEF-G...';

// random byte string
$random = pack('c*', 87,253, ...);

// simple concat does not work to generate an MD5 key
$key = md5($random.$secret);
</code></pre>

<p>So the question is how to emulate this step and match the C++ CryptoApi MD5 hash key in php, I have been unable to decrypt using this key or match the php key against the C++ exported key</p>
","","28","<php><c++><openssl><cryptoapi>","1","","0","2018-12-21 14:00:51","","0","","","","","2018-12-21 14:00:51",""
"58353823","Using CryptoAPI encrypt file with CryptGenKey() function","<p>I'm doing encryption of file using CryptoAPI.
I'm using AES-128 ECB for this.
When I encrypt it, I'm printing key, that was generated by <code>CryptGenKey()</code>
Then hashing and deriving key. Everything is OK!
BUT when I try to decrypt it, I use the same key that I generated with <code>CryptGenKey()</code>, no way, I have corrupted file...</p>

<p>ENCRYPT:</p>

<pre><code>void Encrypt(std::wstring path) 
{
    HCRYPTKEY hKey_fornemty;
    HCRYPTKEY hSessionKey;
    HCRYPTHASH hHash_fornemty;

    if (!CryptGenKey(hProv_fornemty, CALG_AES_128, CRYPT_EXPORTABLE, &amp;hKey_fornemty))
    {
        ExitProcess(0);
    }

    if (!CryptGenKey(hProv_fornemty, AT_KEYEXCHANGE, 512 &lt;&lt; 16, &amp;hSessionKey))
    {
        ExitProcess(0);
    }

    DWORD dlen = 0;

    if (!CryptExportKey(hKey_fornemty, hSessionKey, SIMPLEBLOB, 0, NULL, &amp;dlen))
    {
        ExitProcess(0);
    }

    unsigned char* key = new unsigned char[dlen];

    if (!CryptExportKey(hKey_fornemty, hSessionKey, SIMPLEBLOB, 0, key, &amp;dlen))
    {
        ExitProcess(0);
    }

    if (!CryptCreateHash(hProv_fornemty, CALG_SHA_256, 0, 0, &amp;hHash_fornemty))
    {
        CryptReleaseContext(hProv_fornemty, 0);
        ExitProcess(0);
    }
    if (!CryptHashData(hHash_fornemty, (BYTE*)key, 32, 0))
    {
        CryptReleaseContext(hProv_fornemty, 0);
        ExitProcess(0);
    }
    if (!CryptDeriveKey(hProv_fornemty, CALG_AES_128, hHash_fornemty, 0, &amp;hKey_fornemty))
    {
        CryptReleaseContext(hProv_fornemty, 0);
        ExitProcess(0);
    }
        HANDLE hFile;
        DWORD dwBytesRead, dwBytesWritten, dwPos;
        CreateFileW(filePath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        LARGE_INTEGER size;
        GetFileSizeEx(hFile, &amp;size);

        unsigned char* buff = new unsigned char[size.QuadPart];
        DWORD lenght = size.QuadPart;

        dwPos = SetFilePointer(hFile, 0, NULL, 0);
        ReadFile(hFile, buff, size.QuadPart, &amp;dwBytesRead, NULL);

        CryptEncrypt(hKey_fornemty, NULL, NULL, 0, buff, &amp;lenght, lenght);

        dwPos = SetFilePointer(hFile, 0, NULL, 0);
        WriteFile(hFile, buff, lenght, &amp;dwBytesWritten, NULL);

        delete[] buff;
}
</code></pre>

<p>file size - 1024 bytes</p>

<p>DECRYPT:</p>

<pre><code>void Decrypt(std::wstring filePath) 
{
    HANDLE hFile;
    DWORD dwBytesRead, dwBytesWritten, dwPos;
    CreateFileW(filePath.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    LARGE_INTEGER size;
    GetFileSizeEx(hFile, &amp;size);
    unsigned char* key= new unsigned char[344];
    dwPos = SetFilePointer(hFile, size.QuadPart - 344, NULL, 0); //key reading (base64)
    ReadFile(hFile, key, 344, &amp;dwBytesRead, NULL);
    HCRYPTHASH hHash;
    HCRYPTKEY hKey;

    if (!CryptCreateHash(hProvs, CALG_SHA_256, 0, 0, &amp;hHash))
    {
        CryptReleaseContext(hProvs, 0);
        ExitProcess(0);
    }
    if (!CryptHashData(hHash, (BYTE*)temp_key, 32, 0))
    {
        CryptReleaseContext(hProvs, 0);
        ExitProcess(0);
    }
    if (!CryptDeriveKey(hProvs, CALG_AES_128, hHash, 0, &amp;hKey))
    {
        CryptReleaseContext(hProvs, 0);
        ExitProcess(0);
    }
        unsigned char* buff = new unsigned char[size.QuadPart];
        DWORD lenght = size.QuadPart;

        dwPos = SetFilePointer(hFile, 0, NULL, 0);
        ReadFile(hFile, buff, size.QuadPart, &amp;dwBytesRead, NULL);

        CryptDecrypt(hKey_fornemty, NULL, NULL, 0, buff, &amp;lenght);

        dwPos = SetFilePointer(hFile, 0, NULL, 0);
        WriteFile(hFile, buff, lenght, &amp;dwBytesWritten, NULL);

        delete[] buff;
}
</code></pre>

<p><code>unsigned char* key</code> from encrypt
same
<code>unsigned char* key</code> from decrypt</p>

<p>What's wrong?</p>
","","24","<c++><visual-studio><aes><cryptoapi>","0","","0","2019-10-12 11:47:09","","0","","","","","2019-10-12 11:47:09",""
"55215065","How to import cobinhood dependencies?","<p>I'm trying to use the CobinHood Java API, I downloaded the folder from GitHub. After copying the sample code to my NetBeans, it can't find the dependencies, even after adding the downloaded folder in the library. </p>

<p><a href=""https://github.com/eveasoft/cobinhood-client"" rel=""nofollow noreferrer"">https://github.com/eveasoft/cobinhood-client</a></p>

<p>How can I get these dependencies to work?</p>

<pre><code>import src.main.java.com.eveasoft.cobinhood.api.CobinhoodChartAPI;
import com.eveasoft.cobinhood.api.CobinhoodMarketAPI;
import com.eveasoft.cobinhood.api.CobinhoodTradingAPI;
import com.eveasoft.cobinhood.api.CobinhoodWalletAPI;
import com.eveasoft.cobinhood.exception.CobinException;
import com.eveasoft.cobinhood.model.*;
import com.eveasoft.cobinhood.model.chart.Candle;
import com.eveasoft.cobinhood.model.market.*;
import com.eveasoft.cobinhood.model.trading.Order;
import com.eveasoft.cobinhood.model.trading.Trade;
import com.eveasoft.cobinhood.model.wallet.*;
import retrofit2.Call;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;
</code></pre>
","","22","<java><api><netbeans><cryptoapi><cryptocurrency>","0","","0","2019-03-18 05:34:24","","0","","","","","2019-03-18 05:34:24",""
"50470141","Developing a third-party exchange on coinbase API","<p>The buy/sell feature on coinbase isn't supported in my region and i was intending to develop a third-party exchange utilizing their api. Could that restrictions (failure to support) affect my project?</p>
","","22","<cryptoapi><coinbase-api>","1","","0","2018-05-22 14:24:44","","0","","","","","2018-05-22 14:24:44",""
"58621823","data leak when generate key with winapi function","<p>I have question: when I'm trying to generate AES key 128 lenght with <code>CryptGenKey</code> I have data leak?</p>

<p>Code below:</p>

<pre><code>void GeKey(HCRYPTKEY hKey, HCRYPTPROV hProvs)
{
    DWORD len_iv = 0;

    if (!CryptGenKey(hProvs, CALG_AES_128, CRYPT_EXPORTABLE, &amp;hKey))
    {
        ExitProcess(0);
    }

    if (!CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, NULL, NULL, &amp;len_iv))
    {
        ExitProcess(0);
    }

    unsigned char* aes_key_dec = new unsigned char[len_iv];

    if (!CryptExportKey(hKey, NULL, PLAINTEXTKEYBLOB, NULL, aes_key_dec, &amp;len_iv))
    {
        ExitProcess(0);
    }

    for (int i = 0; i &lt; len_iv; i++)
    {
        printf(""%c"", aes_key_dec[i]);
    }
    printf(""\n\n"");

    delete[] aes_key_dec;
}
</code></pre>

<p><code>delete[] aes_key_dec;</code> can't help me with this issue. What's wrong :/</p>
","","15","<c++><visual-studio><cryptoapi><wincrypt>","1","","0","2019-10-30 09:07:03","","4","","","","","2019-10-30 09:07:03",""
"56614769","Is there a sanbox API for poloniex?","<p>I want to do some testing with the Poloniex private endpoints but I can't find a sanbox or test environment for said API</p>
","","9","<php><laravel><api><cryptoapi><poloniex>","0","","0","2019-06-15 22:53:46","","0","","","","","2019-06-15 22:53:46",""